    #include <bits/stdc++.h>
     
    #define icin(x) (x=scan())
    #define LL long long
    #define VVI vector< vector<int> >
    #define mod 1000000007LL
    #define maxn 100000
    #define inf 1324215
    #define pb push_back
    #define mp make_pair
    #define MAXL 22
    #define F first
    #define S second
     
    using namespace std;
     
     
     
    inline int scan(){
        char c = getchar_unlocked();
        int x = 0;
        while(c < '0' || c > '9'){
            c = getchar_unlocked();
        }
        while(c >= '0' && c <= '9'){
            x = (x << 1) + (x << 3) + c - '0';
            c = getchar_unlocked();
        }
        return x;
    }
     
     
    VVI gr;
     
    int level[maxn + 9];
    int visited[maxn + 9];
    int L[maxn + 9],P[MAXL][maxn + 9],strt[maxn+9],trnd[maxn+9];
    int N;
     
    int sec=0;
     
    struct  mycomp
    {
    	bool operator()( pair<int,int> p1 , pair<int,int> p2)
    	{
    		return p1.S < p2.S;
    	}
    };
     
    void BFS(int num)
    {
    	for(int i=1;i<=N;i++)
    		visited[i]=0;
    	queue<int> Q;
    	level[num]=1;
    	visited[num]=1;
    	Q.push(num);
    	while(!Q.empty())
    	{
    		
    		int x = Q.front();
    		Q.pop();
    		for(int i=0;i<gr[x].size();i++)
    		{
    			int y = gr[x][i];
    			if(visited[y])
    				continue;
    			else
    			{
    				visited[y] = 1;
    				level[y] = level[x]+1;
    				Q.push(y);
    			}
    		}
     
    	}
    }
     
    void DFS3(int num,int par=-1)
    {
     
    	
    	visited[num]=1;
    	L[num] = ((par==-1)? 1 : (L[par] +1));
     
    	sec++;
    	strt[num]  = sec;
     
    	if(par!=-1)
    	P[0][num] = par;
    	else P[0][num]=num;
     
    	for(int i=1;i<MAXL;i++)
    	{
    		int x = P[i-1][num];
    		if(x<=0)break;
     
    		P[i][num] = P[i-1][x];
     
    	}
     
    	for(int i=0;i<gr[num].size();i++)
    	{
    		int x = gr[num][i];
    		//cout << "X" << x <<trndl;
    		if(visited[x])continue;
    		else DFS3(x,num);
    	}
     
    	trnd[num] = ++sec;
     
    }
     
    bool is_ancestor(int u,int a)
    {
    	if(u==a)
    		return true;
    	if(strt[u] > strt[a] && trnd[u] < trnd[a] )
    		return true;
    	
    	return false;
    }
     
    int lca(int p,int q)
    {
     
    		int loga, i;
        if (L[p] < L[q]) swap(p,q);
        for (loga = 1; (1 << loga) <= L[p]; loga++);loga--;
        for (i = loga; i >= 0; i--)
            if (L[p] - (1 << i) >= L[q]) p = P[i][p];
        if (p == q) return p;
        for (i = loga; i >= 0; i--)
            if (P[i][p] != -1 && P[i][p] != P[i][q]) p = P[i][p], q = P[i][q];
        return P[0][p];
    }
     
    int main()
    {
    	int T;
    	icin(T);
    	while(T--)
    	{
    		
    		icin(N);
    		assert(N>2);
    		gr.resize(N+1);
    		
    		for(int i=1;i<=N;i++)
    			gr[i].clear();
    		for(int i=1;i<N;i++)
    		{
    			int x,y;
    			icin(x);
    			icin(y);
    			gr[x].pb(y);
    			gr[y].pb(x);
     
    		}
    		BFS(1);
    		for(int i=1;i<=N;i++)
    		visited[i]=0;
    		DFS3(1);
     
    		//cout << lca(4,5);
    		int Q;
    		icin(Q);
    		while(Q--)
    		{
    			int M;
    			icin(M);
    			vector< pair<int,int> > vec;
    			
    			
    			vector<int> l , r;
    			int root=inf;
    			for(int i=1;i<=M;i++)
    			{
    				int x;
    				icin(x);
    				vec.pb(mp(x,level[x]));
    						
    			}
    			sort(vec.begin(),vec.end(),mycomp());
    			int pos;
    			//cout << root << endl;
    			//for(int i=0;i<M-1;i++)
    			//root = min(max(lca(vec[i].F, vec[i+1].F),root);	
    			bool ans=true;
    			root = vec[0].F;
    			int lft=inf,rgt=inf;
    			lft=vec[0].F;
     
    			for(int i=1;i<M;i++)
    			{
    				int node = vec[i].F;
    				if(lca(node,lft)==lft)
    				{
    					lft=node;
    					continue;
    				}
    				else if(rgt==inf)
    				{
    					rgt=node;
    					continue;
    				}
    				else if(lca(node,rgt)==rgt)
    				{
    					rgt=node;
    					continue;
    				}
    				else
    				{
    					ans=false;
    					break;
    				}
    			}
     
    			if(ans)
    			{
    				if(lft!=inf && rgt!=inf)
    				{
    					if(level[lca(lft,rgt)]>level[root])
    					{
    						ans=false;
    					
    					}
    				}
    			}
    			
    			//cout << root << endl;
    			/*if(root==vec[0].F)
    			pos=1;
    			else
    			pos=0;
    			
    			while(pos<M)
    			{
    				if(l.size()==0)
    				{
    					l.pb(vec[pos].F);
    					pos++;
    					continue;
    				}
    				int y = lca(l[0],vec[pos].F);
    				
    				if(y==root)
    				{
    					if(r.size()==0)
    					{
    						r.pb(vec[pos].F);
    						pos++;
    						continue;
    					}
    					else
    					{
    						if(lca(vec[pos].F,r[0])==r[0])
    						{
    							for(int i=0;i<r.size();i++)
    							{
    								if(lca(vec[pos].F,r[i])!=r[i])
    								{
    						//			cout << vec[pos].F << " " << r[i];
    									ans=false;
    									break;
    								}
    							}
    							if(!ans)
    								break;
    							else
    							{
    								
    								r.pb(vec[pos].F);
    								pos++;
    								continue;
    							}
     
    						}
    						else
    						{
    						//	cout << y << " " << r[0] << " " << vec[pos].F << endl;
    							ans=false;
    							break;
    						}
    					}	
    				
    				}
    				else
    				{
     
    					if(lca(vec[pos].F,l[0])==l[0])
    						{
    							for(int i=0;i<l.size();i++)
    							{
    								if(lca(vec[pos].F,l[i])!=l[i])
    								{
    									//cout << vec[pos].F << " " << l[i];
    									ans=false;
    									break;
    								}
    							}
    						if(!ans)
    							break;
    						else
    						{
    							
    							l.pb(vec[pos].F);
     
    							pos++;
    							continue;
    						}
    						}
    						else
    						{
    							ans=false;
    							break;
    						}
    				}	
    			}
    			*/
     
    					if(ans)
    				printf("Yes\n");
    				else
    				printf("No\n");
     
    			}
    		
    			
     
     
    		}		
     
     
    	
     
    } 