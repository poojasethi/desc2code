#include<stdio.h>
#include<iostream>
#include<vector>
#include<string.h>
#include<string>
#include<stdlib.h>
#include<algorithm>
#include<set>
#include<stack>
#include<queue>
#include<assert.h>
#include<utility>
using namespace std;
long long depth[100000+2],parent[100000+2],start[100000+2],end[100000+2];
vector<long long>graph[100000+2];
 int counter;      
 long long visited[100000+2];      
       
       void init()
       {
          
       
            int i;
            for(i=0;i<100002;i++)
            {
                graph[i].clear();
                visited[i]=0;
            
            }
       
       }
       
       void dfs(int v)
       {
       
          visited[v]=1;
          counter++;
          int i;
          for(i=0;i<graph[v].size();i++)
          {
              int vv=graph[v][i];
              if(visited[vv])
              continue;
              else
              {
                  start[vv]=counter;
                  parent[vv]=v;
                  depth[vv]=1+depth[v];
                  dfs(vv);  
              
              }
          
          }
        end[v]=counter;
       
       }
       
       int lca(int x,int y)
       {
          int arr[100003];
          int brr[100003];
          int i=0,j=0;
          arr[i++]=x;
          brr[j++]=y;
          while(parent[x]!=-1)
          {
                arr[i++]=parent[x];
                x=parent[x];
          
          }
         
         while(parent[y]!=-1)
          {
                brr[j++]=parent[y];
                y=parent[y];
          
          }
       
       int z=arr[i-1];
       while(arr[i-1]==brr[j-1] && i>=0 && j>=0)
                {
                   z=arr[i-1];
                    i--;
                    j--;
                
                }
                return z;
       }
       
       
int main()
{

    long long t;
    cin>>t;
    while(t--)
    {
       long long n;
       cin>>n;
       long long x,y;
       init();
       for(int i=0;i<n-1;i++)
       {
           cin>>x>>y;
           graph[x].push_back(y);
           graph[y].push_back(x);       
       
       }
       counter=0;
       visited[1]=1;
       parent[1]=-1;
       depth[1]=1;
       dfs(1);
       
       
       
       
       int Q,k,max_depth_node,max_d,smallest_depth_node,small_d;
	scanf("%d",&Q);
	//printf("%d is Q\n",Q);
	for(int i=1;i<=Q;i++){
		max_d = 0;
		small_d = 1e9;
		vector<int> nodes;
		scanf("%d",&k);
		for(int j=0;j<k;j++){
			int x;
			scanf("%d",&x);
			if( depth[x] > max_d ){
				max_d = depth[x];
				max_depth_node = x;
			}
			if( depth[x] < small_d ){
				small_d = depth[x];
				smallest_depth_node = x;
			}
			nodes.push_back(x);
		}
		//printf("%d %d %d %d\n",max_depth_node,max_d,smallest_depth_node,small_d);
		int diff = -1,flag=1,remaining_maximum_depth_node,rem_max_d=0;
		for(int j=0;j<k;j++){
			int u = nodes[j];
			if( start[u]<=start[max_depth_node] && end[u]>=end[max_depth_node] ){
				continue;
			}
			else{
				flag = 0;
				if( depth[u] > rem_max_d){
					rem_max_d = depth[u];
					remaining_maximum_depth_node = u;
				}
			}
		}

		if( flag ){
			printf("Yes\n");
			continue;
		}

		int print = 0;
		for(int j=0;j<k;j++){
			int u = nodes[j];
			if( start[u]<=start[max_depth_node] && end[u]>=end[max_depth_node] ){
				continue;
			}
			else if( !(start[u]<=start[remaining_maximum_depth_node] && end[u]>=end[remaining_maximum_depth_node]) ){
				printf("No\n");
				print = 1;
				break;
			}
		}
		if( print == 0 ){
			int x = lca(max_depth_node,remaining_maximum_depth_node);
			if( start[smallest_depth_node] >= start[x] && end[smallest_depth_node] <= end[x] ){
				printf("Yes\n");
			}
			else{
				printf("No\n");
			}
		}
       
       
    }      
       
    }

   return 0;
}
