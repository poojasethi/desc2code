/*	Author: Ankit Sultana
 * * * * * * * * * * * * * * * * */
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#define LL long long
#define INF 1000000000
#define PB push_back
#define SWAP(a,b) a^=b,b^=a,a^=b
#define MP make_pair
#define vi vector<int>
#define vll vector<LL>
#define matint vector<vi>
#define matll vector<vll>
#define REP(i,n)	for(int i = 0; i < n; i++)
#define REP1(i,n)	for(int i = 1; i <= n; i++)
#define REPc(i,j,n)	for(int i = j; i <= n; i++)
#define MAXN 100003
#define LN 20

using namespace std;
vi adj[MAXN];
int pa[MAXN][LN] = {0}, st_time[MAXN] = {0}, end_time[MAXN] = {0}, depth[MAXN] = {0};
int V, K, univ_time = 1;

void precomp(int node = 1, int prev = -1, int d = 0)
{
	depth[node] = d;
	pa[node][0] = prev;
	st_time[node] = univ_time++;
	int sz = (int)adj[node].size();
	REP(i,sz){
		if(adj[node][i] == prev)	continue;
		precomp(adj[node][i], node, d+1);
	}
	end_time[node] = univ_time++;
}

int LCA(int u, int v)
{
	if(u == v)	return u;
	if(depth[u] < depth[v])	
		SWAP(u,v);
	int diff = depth[u]-depth[v];
	REP(i,LN){
		if((diff>>i)&1){
			u = pa[u][i];
		}
	}
	if(u == v)
		return u;
	for(int i = LN-1; i > -1; i--){
		if(pa[u][i] != pa[v][i]){
			u = pa[u][i], v = pa[v][i];
		}
	}
	return pa[u][0];
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie();
	cout<<unitbuf;
	int t, q, a, b;
	cin>>t;
	while(t--){
		cin>>V;
		REP1(i,V){
			adj[i].clear();
			REP(j,LN)
				pa[i][j] = -1;
		}
		REP(i,V-1){
			cin>>a>>b;
			adj[a].PB(b), adj[b].PB(a);
		}
		univ_time = 1;
		precomp();
		for(int i = 1; i < LN; i++){
			for(int j = 1; j <= V; j++){
				if(pa[j][i-1] != -1)
					pa[j][i] = pa[pa[j][i-1]][i-1];
			}
		}
		int D, RD, S, L;
		cin>>q;
		while(q--){
			vi _real, _a, _b;
			int maxim = 0, minim = INF;
			cin>>K;
			REP(i,K){
				cin>>a;
				_real.PB(a);
				if(depth[a] > maxim)
					maxim = depth[a], D = a;
				if(depth[a] <= minim)
					minim = depth[a], S = a;
			}
			REP(i,K){
				if(end_time[D] <= end_time[_real[i]] && st_time[D] >= st_time[_real[i]]){
					_a.PB(_real[i]);
				}
				else{
					_b.PB(_real[i]);
				}
			}
			if(_b.empty()){
				cout<<"Yes\n";
				continue;
			}
			int sz = (int)_b.size();
			maxim = 0, RD = 1;
			REP(i,sz){
				if(depth[_b[i]] > maxim)
					RD = _b[i], maxim = depth[_b[i]];
			}
			//cout<<RD<<' ';
			bool shit = false;
			REP(i,sz){
				if(_b[i] == RD)	continue;
				if(end_time[RD] <= end_time[_b[i]] && st_time[RD] >= st_time[_b[i]]){
				}
				else{
					shit = true;
					break;
				}
			}
			if(shit){
				cout<<"No\n";
				continue;
			}
			L = LCA(D, RD);
			//cout<<"D= "<<D<<" RD= "<<RD<<" L= "<<L<<" S= "<<S<<' ';
			if(end_time[S] <= end_time[L] && st_time[S] >= st_time[L]){
				cout<<"Yes\n";
			}
			else{
				cout<<"No\n";
			}
		}
	}
	return 0;
}
