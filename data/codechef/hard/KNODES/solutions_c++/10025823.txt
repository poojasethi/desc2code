//coded using editorial
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <map>
#define INF_MAX 2147483647
#define INF_MIN -2147483647
#define INF_LL 9223372036854775807LL
#define INF 2000000000
#define PI acos(-1.0)
#define inf INT_MAX
#define llu unsigned long long int
#define all(v) v.begin(),v.end()
#define pb push_back
#define mp make_pair
#define F first
#define S second
#define si(n) scanf("%d",&n)
#define slli(n) scanf("%lld",&n);
#define ss(n) scanf("%s",n);
using namespace std;
typedef long long int LL;


std::vector<int > adjList[100010];

int a[100010] , b[100010] , max_depth , D , RD , LCA_D_RD , S , min_depth;
int N , u , v , Q , M , flag = 0 , test;
int nr , T[100010] , P[100010] , L[100010] ,  st[100010] , en[100010];
int offset = 0;
int counter = 1;

//T is the direct ancestor
//P is the ancestor of that block of size square root N
//L is the level
int dp[100010][32];


void init()
{
	for(int i=0;i<N+4;i++)
		adjList[i].clear();
	L[1] = 1;
	nr = sqrt(N);
	counter = 1;
	offset = 0;
	min_depth = 1000000;
	max_depth = 0;
}


void dfs(int curr_node, int parent)  
{
      int k;
      
      st[curr_node] = counter++;


      if(L[curr_node] < nr)
          P[curr_node] = 1;
      else{
          if(!(L[curr_node] % nr))
              P[curr_node] = T[curr_node];
          else
              P[curr_node] = P[T[curr_node]];
      }   
      std::vector< int >::iterator it = adjList[curr_node].begin();
      while(it!=adjList[curr_node].end())
      {
      		if((*it)!=parent)
      		{
      			L[(*it)] = L[curr_node] + 1;
      			T[(*it)] = curr_node;
      			dfs((*it) , curr_node);
      		}
      		it++;
      }

      en[curr_node] = counter++;


}


void process3()
{
      int i, j;   
  //we initialize every element in P with -1
      for(i=0; i<=N + 4 ; i++)
          for (j=0;(1<<j)<=N + 4; j++)
              dp[i][j] = -1;   
  //the first ancestor of every node i is T[i]
      for (i = 1; i <= N; i++)
          dp[i][0] = T[i];   
  //bottom up dynamic programing
      for (j = 1; (1 << j) <= N; j++)
         for (i = 1; i <= N; i++)
             if (dp[i][j - 1] != -1)
                 dp[i][j] = dp[dp[i][j - 1]][j - 1];
}
  
int query(int p, int q)
{
      int tmp, lg , i;   
  //if p is situated on a higher level than q then we swap them
      if (L[p] < L[q])
      {
          tmp = p;
          p = q;
          q = tmp;  
      }
  //we compute the value of [log(L[p)]
      for (lg = 1; (1<<lg) <= L[p];)
      	 lg++;
      lg--;   
  //we find the ancestor of node p situated on the same level
  //with q using the values in P
      for (i = lg; i >= 0; i--){
          if(L[p] - (1 << i) >= L[q])
              p = dp[p][i];   
      }

      if (p == q)
          return p;   
  //we compute LCA(p, q) using the values in P
      for (i = lg; i >= 0; i--)
      {
          if (dp[p][i] != -1 && dp[p][i] != dp[q][i])
          {
              	p = dp[p][i];
          		q = dp[q][i];
          }
      }
   
      return T[p];
}

  int LCA(int x, int y)
  {
  //as long as the node in the next section of 
  //x and y is not one common ancestor
  //we get the node situated on the smaller 
  //lever closer
      while (P[x] != P[y])
          if (L[x] > L[y])
             x = P[x];
          else
              y = P[y];
           
  //now they are in the same section, so we trivially compute the LCA
      while (x != y)
          if (L[x] > L[y])
             x = T[x];
          else
             y = T[y];
      return x;
  }




int main()
{
si(test);
while(test--)
{
si(N);
init();
for(int i=1;i<=N-1;i++)
{
	si(u);si(v);
	adjList[u].pb(v);
	adjList[v].pb(u);
}
nr = sqrt(N);
L[1] = 1;
dfs(1 , -1);
si(Q);
while(Q--)
{
	si(M);
	max_depth = 0;
	min_depth = 1000000;
	flag = 0;
	for(int i=1;i<=M;i++)
	{
		si(a[i]);
		if(L[a[i]] < min_depth){
			min_depth = L[a[i]];
					S = a[i];
		}
		if(L[a[i]] > max_depth){
			max_depth = L[a[i]];
					D = a[i];
		}
	}
	//remove all the nodes which are in the path from the root to D
	offset = 0;
	for(int i=1;i<=M;i++){
		if((st[a[i]] <= st[D]) && (en[a[i]] >= en[D]))
			continue;
		else
			b[offset++] = a[i];
	}
	max_depth = 0;
	for(int i=0;i<offset;i++)
	{
		if(L[b[i]] > max_depth)
		{
			max_depth = L[b[i]];
				RD = b[i];
		}
	}

	if(offset ==  0)
	{
		printf("Yes\n");
		continue;
	}

	flag = 0;
	for(int i=0;(i<offset) && (flag==0);i++)
	{
 		if(st[b[i]] <= st[RD] && en[b[i]] >= en[RD])
 			continue;
 		else
 			flag = 1;
	}


	if(flag==1)
	{
		printf("No\n");
		continue;
	}
	else
	{
		LCA_D_RD = LCA(D , RD);
		if(st[LCA_D_RD]<=st[S] && en[LCA_D_RD]>=en[S])
			printf("Yes\n");
		else
			printf("No\n");
	}
}
}
return 0;
}
