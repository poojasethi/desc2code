#include<stdio.h>
#include<string.h>
#include<stdlib.h>


#define MAXN 200000
#define BLOCKSIZE 50
#define BLOCKNUM (MAXN/BLOCKSIZE)


struct TNum {
	int pos;
	int val;
} A[MAXN], OrdA[MAXN], Temp1[MAXN], Temp2[MAXN];


int Blocks[BLOCKNUM][BLOCKNUM], CummBlocks[BLOCKNUM][BLOCKNUM], Trans[MAXN], Up[MAXN], Down[MAXN];


long long Merge(int l, int r) {

	if(l==r) return 0;

	long long inv;
	int i, mid = (l+r)>>1, a, b, l1, l2;

	inv = Merge(l, mid), inv += Merge(mid+1, r);
	l1 = mid-l+1, l2 = r-mid;

	memcpy(Temp1, OrdA+l, l1*sizeof(TNum));
	memcpy(Temp2, OrdA+mid+1, l2*sizeof(TNum));

	a = b = 0;
	for(i = l; a<l1 && b<l2; i++) {
		if(Temp1[a].val<=Temp2[b].val) OrdA[i] = Temp1[a++];
		else OrdA[i] = Temp2[b++], inv += l1-a;
	}

	if(a==l1) memcpy(OrdA+i, Temp2+b, (l2-b)*sizeof(TNum));
	else memcpy(OrdA+i, Temp1+a, (l1-a)*sizeof(TNum));
	
	return inv;
}


int CalcUp(int N, int j1, int j2, int i1) {

	int jj1 = j1/BLOCKSIZE, jj2 = j2/BLOCKSIZE, ii1 = i1/BLOCKSIZE;
	int res, maxblock = (N-1)/BLOCKSIZE, blockj1, blockj2, blocki1, i, j,index;

	if(jj1+1<jj2 && ii1<maxblock) {
		res = CummBlocks[maxblock][jj2-1]-CummBlocks[ii1][jj2-1]-CummBlocks[maxblock][jj1]+CummBlocks[ii1][jj1];

		blockj1 = (jj1+1)*BLOCKSIZE, blockj2 = jj2*BLOCKSIZE;
		blocki1 = (ii1+1)*BLOCKSIZE;
		for(j = j1; j<blockj1; j++) if(Trans[j]>=i1) res++;
		for(j = blockj2; j<=j2; j++) if(Trans[j]>=i1) res++;
		for(i = i1; i<blocki1; i++) if((index = OrdA[i].pos)>=blockj1 && index<blockj2) res++;
	}

	else if(jj1+1<jj2) {
			for(res = 0, i = i1; i<N; i++) if((index = OrdA[i].pos)>=j1 && index<=j2) res++;
	     }
	else for(res = 0, j = j1; j<=j2; j++) if(Trans[j]>=i1) res++;

	return res;
}


int CalcDown(int j1, int j2, int i1) {

	int jj1 = j1/BLOCKSIZE, jj2 = j2/BLOCKSIZE, ii1 = i1/BLOCKSIZE;
	int res, blockj1, blockj2, blocki1, i, j,index;

	if(jj1+1<jj2 && 0<ii1) {
		res = CummBlocks[ii1-1][jj2-1]-CummBlocks[ii1-1][jj1];

		blockj1 = (jj1+1)*BLOCKSIZE, blockj2 = jj2*BLOCKSIZE;
		blocki1 = ii1*BLOCKSIZE;
		for(j = j1; j<blockj1; j++) if(Trans[j]<=i1) res++;
		for(j = blockj2; j<=j2; j++) if(Trans[j]<=i1) res++;
		for(i = blocki1; i<=i1; i++) if((index = OrdA[i].pos)>=blockj1 && index<blockj2) res++; 
	}

	else if(jj1+1<jj2) {
			for(res = i = 0; i<=i1; i++) if((index = OrdA[i].pos)>=j1 && index<=j2) res++;
	     }
	else for(res = 0, j = j1; j<=j2; j++) if(Trans[j]<=i1) res++;

	return res;
}


int main(void) {

	int N, M, m, i, j, newmaxval, prevoldval, maxblock, j1, j2, temp, diff;
	long long inv;

	for(scanf("%d%d", &N, &M), i = 0; i<N; i++) scanf("%d", &A[i].val), A[i].pos = i;
	memcpy(OrdA, A, N*sizeof(TNum));
	inv = Merge(0, N-1);

	for(newmaxval = -1, prevoldval = i = 0; i<N; i++) {
		if(OrdA[i].val!=prevoldval) {
			if(newmaxval>=0) Up[newmaxval] = i;
			prevoldval = OrdA[i].val, Down[++newmaxval] = i-1;
		}
		OrdA[i].val = A[OrdA[i].pos].val = newmaxval;
	}
	Up[newmaxval] = N;

	for(i = 0; i<N; i++) Trans[OrdA[i].pos] = i;

	for(i = 0; i<N; i++) Blocks[Trans[i]/BLOCKSIZE][i/BLOCKSIZE]++;

	maxblock = (N-1)/BLOCKSIZE;
	for(i = 0; i<=maxblock; i++) {
		CummBlocks[i][0] = Blocks[i][0];
		for(j = 1; j<=maxblock; j++) CummBlocks[i][j] = CummBlocks[i][j-1]+Blocks[i][j];
	}
	for(i = 1; i<=maxblock; i++) for(j = 0; j<=maxblock; j++) CummBlocks[i][j] += CummBlocks[i-1][j]; 

	for(m = 0; m<M; m++) {
		scanf("%d%d", &j1, &j2), j1--, j2--;
		if(j2<j1) temp = j1, j1 = j2, j2 = temp;

		diff = CalcUp(N, j1+1, j2-1, Up[A[j1].val]);
		diff -= CalcDown(j1+1, j2-1, Down[A[j1].val]);
		diff -= CalcUp(N, j1+1, j2-1, Up[A[j2].val]);
		diff += CalcDown(j1+1, j2-1, Down[A[j2].val]);
		if(A[j1].val<A[j2].val) diff++;
		else if(A[j1].val>A[j2].val) diff--;

		printf("%lld\n", inv+diff);
	}

	return 0;
}