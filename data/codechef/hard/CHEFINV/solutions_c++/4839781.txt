#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<map>
#include<vector>
#include<math.h>

using namespace std;


typedef struct node_{
	int left_lvalue;
	int left_svalue;
	int right_lvalue;
	int right_svalue;
}node;

typedef struct input_{
	int query;
	int pos;
	int idx;
}input;

int in()
{
    char c;
    while(c=getchar(),(c<'0'||c>'9')&&(c!='b')&&(c!='-'));
    bool flag=(c=='-');
    if(flag) c=getchar();
    int x=0;
    while(c>='0'&&c<='9') {
        x=x*10+c-48;
        c=getchar();
    }
    return flag?-x:x;
}


void insert_element(int t[],int ele,int l,int r,int idx)
{
	t[idx]++;
	if(l==r)
	return;
	else
	{
		int mid=(l+r)/2;
		if(ele<=mid)
		insert_element(t,ele,l,mid,2*idx+1);
		else
		insert_element(t,ele,mid+1,r,2*idx+2);
	}
}

int getS( int *t, int ele,int l, int r,int idx)
{
	if(l==r )
	return 0;
	int mid=(l+r)/2;
	if(ele<=mid)
	return getS(t,ele,l,mid,2*idx+1);
	else
	return t[2*idx+1]+getS(t,ele,mid+1,r,2*idx+2);
}

int getL(int *t, int ele,int l, int r,int idx)
{
	if(l==r)
	return 0;
	int mid=(l+r)/2;
	if(ele<=mid)
	return t[2*idx+2]+getL(t,ele,l,mid,2*idx+1);
	else
	return getL(t,ele,mid+1,r,2*idx+2);
}
int getcount(int c)
{
	float temp=log(c);
	float t=log(2);
	temp=temp/t;
	int ans=(int)temp;
	if(ans==temp)
	return pow(2,ans);
	else
	return pow(2,ans+1);
}

int ar[200001];
int arr[200001];
node query_answer [200001][2];
node self_answer [200001];
int leftTree[801000]={0};
int rightTree[801001]={0};

int main()
{

	int n,m,i,j,a,b;
	cin >> n >> m;
	long long int total_inversion_count=0;
	map<int ,int > hash_map;
	
	for(i=0;i<n;i++)
	{
	arr[i]=in();
	ar[i]=arr[i];
	}
	
	sort(arr,arr+n);
	hash_map.insert(pair<int,int>(arr[0],1));
	int last_val=arr[0];
	int count=1;
	for(i=1;i<n;i++)
	{
		if(arr[i]!=last_val)
		{
		hash_map.insert(pair<int,int>(arr[i],++count));
		last_val=arr[i];
		}
	}
	int new_size=count;
	
	for(i=0;i<n;i++)
	{
	ar[i]=hash_map.find(ar[i])->second;

	}
	
	
	
	
	vector <input> connection[n+1];
	int query [m][2];
	for(i=0;i<m;i++)
	{
		a=in();
		b=in();
		query[i][0]=a;
		query[i][1]=b;
		input A,B;
		A.idx=a;
		A.query=i;
		A.pos=0;
		B.idx=b;
		B.pos=1;
		B.query=i;
		connection[a].push_back(B);
		connection[b].push_back(A);
		
	}
	
	 
	int new_count=getcount(count);
	//cout << "count" << count << endl;
	//cout << "new_count=" << new_count << endl;
	
	for(i=1;i<=n;i++)
	{
		int size=connection[i].size();
		for(j=0;j<size;j++)
		{
			int q=connection[i][j].query;
			int p=connection[i][j].pos;
			int pos=connection[i][j].idx-1;
			query_answer[q][p].left_svalue=getS(leftTree,ar[pos],1,new_count,0);
			query_answer[q][p].left_lvalue=getL(leftTree,ar[pos],1,new_count,0);
			

		}
		self_answer[i].left_lvalue=getL(leftTree,ar[i-1],1,new_count,0);
		self_answer[i].left_svalue=getS(leftTree,ar[i-1],1,new_count,0);
		//cout << self_answer[i].left_lvalue << endl; 
		//cout << "t[0]=" << leftTree[0] << endl;
		total_inversion_count+=self_answer[i].left_lvalue;
		
		insert_element(leftTree,ar[i-1],1,new_count,0);
	}
	
	//cout << "total " << total_inversion_count;
	
	
	
	for(i=n;i>0;--i)
	{
		int size=connection[i].size();
		for(j=0;j<size;j++)
		{
			int q=connection[i][j].query;
			int p=connection[i][j].pos;
			int pos=connection[i][j].idx-1;
			query_answer[q][p].right_svalue=getS(rightTree,ar[pos],1,new_count,0);
			query_answer[q][p].right_lvalue=getL(rightTree,ar[pos],1,new_count,0);	
			
		}
		self_answer[i].right_lvalue=getL(rightTree,ar[i-1],1,new_count,0);
		self_answer[i].right_svalue=getS(rightTree,ar[i-1],1,new_count,0);
		insert_element(rightTree,ar[i-1],1,new_count,0);
	}
	
	
	for(i=0;i<m;i++)
	{
		int index_a=query[i][0];
		int index_b=query[i][1];
		int value_a=ar[index_a-1];
		int value_b=ar[index_b-1];
		long long int answer=total_inversion_count;
		int a_indexa_r_big=self_answer[index_a].right_lvalue;
		int a_indexb_r_big=query_answer[i][0].right_lvalue;
		int a_indexa_r_small=self_answer[index_a].right_svalue;
		int a_indexb_r_small=query_answer[i][0].right_svalue;
		int b_indexb_l_small=self_answer[index_b].left_svalue;
		int b_indexa_l_small=query_answer[i][1].left_svalue;
		int b_indexb_l_big=self_answer[index_b].left_lvalue;
		int b_indexa_l_big=query_answer[i][1].left_lvalue;
		
		
		
		answer=answer+(a_indexa_r_big-a_indexb_r_big);
		answer=answer+(b_indexb_l_small-b_indexa_l_small);
		answer-=(a_indexa_r_small-a_indexb_r_small);
		answer-=(b_indexb_l_big-b_indexa_l_big);
		

		
		if(value_a>value_b)
		answer++;
		else if(value_b>value_a)
		answer--;
		printf("%lld\n",answer);

	}
	
	return 0;
}