/*Programmed by Ayush Jaggi*/

#include<bits/stdc++.h>

using namespace std;

#define pb push_back
#define mp make_pair
#define F first
#define S second
#define L(i,x,y) for(i=x;i<y;i++)
#define l0(i,x) for(i=0;i<x;i++)
#define l1(i,x) for(i=1;i<x;i++)
#define pd(n) printf("%d",n)
#define pdn(n) printf("%d\n",n)
#define pds(n) printf("%d ",n)
#define plld(n) printf("%lld",n)
#define plldn(n) printf("%lld\n",n)
#define pllds(n) printf("%lld ",n)
#define pc(n) printf("%c",n)
#define pn printf("\n")
#define ps printf(" ")
#define plf(n) printf("%.6lf",n)
#define plfn(n) printf("%.6lf\n",n)
#define plfs(n) printf("%.6lf ",n)
#define pllf(n) printf("%.6llf",n)
#define pllfn(n) printf("%.6llf\n",n)
#define pllfs(n) printf("%.6llf ",n)
#define psn(n) printf("%s\n",n)
#define pss(n) printf("%s ",n)
#define sd(n) scanf("%d",&n)
#define sld(n) scanf("%ld",&n)
#define slld(n) scanf("%lld",&n)
#define slf(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define sc(n) scanf("%c",&n)
#define mem(n,m) memset(n,m,sizeof(n))
#define W(t) while(t--)

typedef long long LL;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef vector<string> VS;

template<class T> inline T gcd(T a, T b)
{
    return b ? gcd(b, a % b) : a;
}

/*inline void prime()
{
    int s, d, count=0;
    lb=sqrt(n);
    for(s=2; s<=lb; s++)
        if(!pr[s])
        {
            sieve[count++]=s;
            for(d=s*s; d<=n; d+=s)
                pr[d]=1;
        }
}

inline LL expo(LL base, int nent)
{
    if(nent==1)
        return base;
    else if(nent&1)
    {
        LL temp=expo(base,nent/2);
        temp=temp*temp*base;
        if(temp>=MOD)
            temp%=MOD;
        return temp;
    }
    else
    {
        LL temp=expo(base,nent/2);
        temp*=temp;
        if(temp>=MOD)
            temp%=MOD;
        return temp;
    }
}*/

struct tree
{
    int *s;
    int *l, *r;
    int sz;
} mst[1000025];

LL MOD=1000000007, totinv, ans;
int arr[200020], qs, qf, qu_res[100][3], lim;

inline void mstc(int first, int last, int idx)
{
    if(first!=last)
    {
        int i=0, j=0, k=0, m=(first+last)>>1;
        mstc(first,m,2*idx+1);
        mstc(m+1,last,2*idx+2);
        mst[idx].s=new int[last-first+5];
        mst[idx].sz=last-first+1;

        while(i<mst[2*idx+1].sz && j<mst[2*idx+2].sz)
            if(mst[2*idx+1].s[i]<=mst[2*idx+2].s[j])
                mst[idx].s[k++]=mst[2*idx+1].s[i++];
            else
            {
                totinv+=mst[2*idx+1].sz-i;
                mst[idx].s[k++]=mst[2*idx+2].s[j++];
            }
        while(i<mst[2*idx+1].sz)
            mst[idx].s[k++]=mst[2*idx+1].s[i++];
        while(j<mst[2*idx+2].sz)
            mst[idx].s[k++]=mst[2*idx+2].s[j++];

        mst[idx].l=new int[last-first+5];
        mst[idx].r=new int[last-first+5];
        i=0, k=0;
        while(k<mst[idx].sz)
        {
            while(i<mst[2*idx+1].sz && mst[2*idx+1].s[i]<mst[idx].s[k])i++;
            mst[idx].l[k]=i;
            k++;
        }
        mst[idx].l[k]=mst[2*idx+1].sz;
        j=0, k=0;
        while(k<mst[idx].sz)
        {
            while(j<mst[2*idx+2].sz && mst[2*idx+2].s[j]<mst[idx].s[k])j++;
            mst[idx].r[k]=j;
            k++;
        }
        mst[idx].r[k]=mst[2*idx+2].sz;
    }
    else
    {
        mst[idx].sz=1;
        //mst[idx].s=new int(arr[first]);
        mst[idx].s=new int[5];
        mst[idx].s[0]=arr[first];
        //mst[idx].l=new int(1);
        //mst[idx].r=new int(1);
    }
}

inline int lbsearch(int val)
{
    int i=0, j=mst[0].sz-1, m;
    //cout<<j<<" "<<mst[0].s[j]<<endl;
    while(i<=j)
    {
        m=(i+j)>>1;
        if(mst[0].s[m]==val)break;
        mst[0].s[m]<val ? i=m+1 : j=m-1;
        //mst[0].s[m]>=val ? j=m-1 : i=m+1;
    }
    //cout<<"hello";
    //if(mst[0].s[m]==val)
    //return -1;
    //else return m;
    return m;
    //return i;
}

inline int ubsearch(int val)
{
    int i=0, j=mst[0].sz-1, m;
    while(i<=j)
    {
        m=(i+j)>>1;
        mst[0].s[m]<=val ? i=m+1 : j=m-1;
    }
    //if(mst[0].s[m]==val)
    //return -1;
    //else return m;
    return i;
}

inline void query(int lb, int ub)
{
    //if(lb==ub && lb==-1)
    //return;
    int i=0, j=0, cur[100][3], temp_res[100][3];
    cur[j][2]=0;
    cur[j][0]=0, cur[j][1]=mst[0].sz-1;
    temp_res[j][0]=lb, temp_res[j][1]=ub, temp_res[j][2]=mst[cur[j][2]].sz;
    while(i<=j)
    {
        if(cur[i][1]<qs || cur[i][0]>qf)
        {
            i++;
            continue;
        }
        else if(cur[i][0]>=qs && cur[i][1]<=qf)
        {
            qu_res[++lim][0]=temp_res[i][0], qu_res[lim][1]=temp_res[i][1], qu_res[lim][2]=temp_res[i][2];
            i++;
            continue;
        }
        else
        {
            int m=(cur[i][0]+cur[i][1])>>1;
            if(m<qs || cur[i][0]>qf);
            else
            {
                cur[++j][0]=cur[i][0], cur[j][1]=m, cur[j][2]=cur[i][2]*2+1;
                //if(temp_res[i][0]==-1)
                //temp_res[j][0]=-1;
                //else
                temp_res[j][0]=mst[cur[i][2]].l[temp_res[i][0]];
                temp_res[j][1]=mst[cur[i][2]].l[temp_res[i][1]], temp_res[j][2]=mst[cur[j][2]].sz;
            }
            if(m+1>qf || cur[i][1]<qs);
            else
            {
                cur[++j][0]=m+1, cur[j][1]=cur[i][1], cur[j][2]=cur[i][2]*2+2;
                //if(temp_res[i][0]==-1)
                //temp_res[j][0]=-1;
                //else
                temp_res[j][0]=mst[cur[i][2]].r[temp_res[i][0]];
                temp_res[j][1]=mst[cur[i][2]].r[temp_res[i][1]], temp_res[j][2]=mst[cur[j][2]].sz;
            }
            i++;
        }
    }
}

int main()
{
    int n, m, x, y, i, lb[200020], ub[200020];
    sd(n);
    sd(m);
    l0(i,n)
    sd(arr[i]);
    mstc(0,n-1,0);
    l0(i,n)
    {
        lb[i]=lbsearch(arr[i]);
        ub[i]=ubsearch(arr[i]);
    }
    //cout<<ub[i]<<endl;}
    W(m)
    {
        ans=totinv;
        sd(x);
        sd(y);
        x--;
        y--;
        if(x==y || arr[x]==arr[y])
        {
            plldn(ans);
            continue;
        }
        else if(x>y)
        {
            int temp=x;
            x=y;
            y=temp;
        }
        qs=x+1;
        qf=y-1;
        if(arr[x]<arr[y])
            ans++;
        else ans--;
        lim=-1;
        query(lb[x],ub[x]);
        //if(lb[x]!=-1)
        l0(i,lim+1)
        {
            ans+=(qu_res[i][2]-qu_res[i][1])-qu_res[i][0];
            //cout<<qu_res[i][0]<<" "<<qu_res[i][1]<<" "<<qu_res[i][2]<<endl;
        }
        //cout<<"hello"<<endl;
        //else l0(i,lim+1)
        //ans+=qu_res[i][2]-qu_res[i][1];
        lim=-1;
        query(lb[y],ub[y]);
        //if(lb[y]!=-1)
        l0(i,lim+1)
        {
            ans+=qu_res[i][0]-(qu_res[i][2]-qu_res[i][1]);
            //cout<<qu_res[i][0]<<" "<<qu_res[i][1]<<" "<<qu_res[i][2]<<endl;
        }
        //else l0(i,lim+1)
        //ans+=qu_res[i][1]-qu_res[i][2];
        plldn(ans);
    }
    return 0;
}
