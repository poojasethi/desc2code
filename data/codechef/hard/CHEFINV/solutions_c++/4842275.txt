// adapted from tester's solution
#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

#define fore(i, l, r) for(int i = l; i< r; i++)
#define forn(i, n) fore(i, 0, n)
#define pb push_back
#define x first
#define y second
#define mp make_pair

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vpii;
typedef long long ll;

vpii suffix[200005], prefix[200005];
int ans[200005], a[200005], n, maxIdx;

void prefixCalc(){
  vi fwt(maxIdx + 1, 0);
  fore(i, 1, n + 1){
    for(int j = a[i]; j > 0; j -= (j & -j)) fwt[j]++;
    int l = prefix[i].size();
    forn(k, l){
      int idx = prefix[i][k].y;
      if(idx > 0) for(int j = prefix[i][k].x; j <= maxIdx; j += (j & -j)) ans[idx] += fwt[j];
      else{
	idx = -idx;
	for(int j = prefix[i][k].x; j <= maxIdx; j += (j & -j)) ans[idx] -= fwt[j];
      }
    }
  }
}

void suffixCalc(){
  vi fwt(maxIdx + 1, 0);
  for(int i = n; i >= 1; i--){
    for(int j = a[i]; j <= maxIdx; j += (j & -j)) fwt[j]++;
    int l = suffix[i].size();
    forn(k, l){
      int idx = suffix[i][k].y;
      if(idx > 0) for(int j = suffix[i][k].x; j > 0; j -= (j & -j)) ans[idx] += fwt[j];
      else{
	idx = -idx;
	for(int j = suffix[i][k].x; j > 0; j -= (j & -j)) ans[idx] -= fwt[j];
      }
    }
  }
}

int main(){
  int m;
  scanf("%d %d", &n, &m);
  int b[n + 5];
  fore(i, 1, n + 1){
    scanf("%d", &a[i]);
    b[i] = a[i];
  }
  
  // converting the numbers to 1 - n
  sort(b + 1, b + n + 1);
  maxIdx = unique(b + 1, b + 1 + n) - (b + 1);  // unique removes the consecutive duplicates and returns iterator just after the position
  fore(i, 1, n + 1) a[i] = lower_bound(b + 1, b + maxIdx + 1, a[i]) - b;  // lower bound return the first position where < op is not followed
  
  // forming the suffix and prefix calucation arrays
  fore(i, 1, m + 1){
    int l, r;
    scanf("%d %d", &l, &r);
    if(l > r) swap(l, r); // using the swap function
    if(a[l] != a[r]) ans[i] = 1;
    prefix[l - 1].pb(mp(a[l] + 1, -i));
    suffix[l + 1].pb(mp(a[l] - 1, -i));
    prefix[r - 1].pb(mp(a[r] + 1, -i));
    suffix[r + 1].pb(mp(a[r] - 1, -i));
    
    prefix[l - 1].pb(mp(a[r] + 1, i));
    suffix[l + 1].pb(mp(a[r] - 1, i));
    prefix[r - 1].pb(mp(a[l] + 1, i));
    suffix[r + 1].pb(mp(a[l] - 1, i));
  }
  
  ll invPair = 0;
  vi fwt(maxIdx + 1, 0);
  for(int i = n; i >= 1; i--){
    for(int j = a[i]; j <= maxIdx; j += (j & -j)) fwt[j]++;
    for(int j = a[i] - 1; j > 0; j -= (j & -j)) invPair += fwt[j];
  }
  
  prefixCalc();
  suffixCalc();
  fore(i, 1, m + 1) printf("%lld\n", invPair + ans[i]);
}
