#include<bits/stdc++.h>

using namespace std;
 
int a[200010],MaxVal;
vector<int> temp;
map<int,int> cood;
long long ans[200010],tree[200010];
pair<int, pair<int,int> > inter[800010];
 
int readSingle(int idx){
	int sum = tree[idx]; // sum will be decreased
	if (idx > 0){ // special case
		int z = idx - (idx & -idx); // make z first
	idx--; // idx is no important any more, so instead y, you can use idx
	while (idx != z){ // at some iteration idx (y) will become z
		sum -= tree[idx]; 
// substruct tree frequency which is between y and "the same path"
		idx -= (idx & -idx);
	}
}
	return sum;
}
 
int read1(int idx){
	int sum = 0;
	while (idx > 0){
		sum += tree[idx];
		idx -= (idx & -idx);
	}
	return sum;
}
 
int read(int idx){
	
	return read1(MaxVal)-read1(idx);
}
 
int read2(int idx){
	
	return read1(MaxVal)-2*read1(idx-1)-readSingle(idx);
}
 
void update(int idx ,int val){
	while (idx <= MaxVal){
		tree[idx] += val;
		idx += (idx & -idx);
	}
}
 
int main(){
	
	memset(ans,0,sizeof(ans));	
	memset(tree,0,sizeof(tree));
	
	int i,x,y,n,m;
	long long orig=0;
	
	scanf("%d%d",&n,&m);;
	
	for(i=0;i<n;i++){
		scanf("%d",&a[i]);
		temp.push_back(a[i]);
	}
	
	sort(temp.begin(),temp.end());
	vector<int>::iterator it=unique(temp.begin(),temp.end());
	
	temp.resize(distance(temp.begin(),it));
	
	int count=0;
	
	for(it=temp.begin();it!=temp.end();it++)
		cood[*it]=++count;
	
	for(i=0;i<n;i++)
		a[i]=cood[a[i]];
	MaxVal=count+5;
	
	count=-1;	
	for(i=0;i<m;i++){
		cin>>x>>y;
		x--;y--;
		inter[++count]=make_pair(x, make_pair(i,y ));
		inter[++count]=make_pair(y, make_pair(i,x ));
		ans[i]=ans[i]+( a[y]>a[x] ? 1 : 0)+( a[x]<a[y] ? -1 : 0); 		
	}
	
	count++;
	
	sort(inter,inter+count);
	int ind=0;
	
	for(i=0;i<n;i++){
		while(ind<count && inter[ind].first<=i){
			
			ans[inter[ind].second.first]+=( read2(a[inter[ind].second.second])-read2(a[inter[ind].first]));
			
			ind++;		
		}
		
		orig=orig+read(a[i]);
		update(a[i],1);						
	}
	
	for(i=0;i<m;i++)
		printf("%lld\n",orig+ans[i]);		
	
	return 0;
} 