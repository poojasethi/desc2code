#include <algorithm>
#include <stdio.h>
#include <vector>
#define  maxn      200003
#define  pb        push_back
using    namespace std;
typedef  long long LL;

struct data
{
  int val,id,pos;
}ar[maxn];

bool comp1(data a , data b) { return a.val<b.val; }
bool comp2(data a , data b) { return a.id<b.id;   }

LL ans;
int n,m,k;
int qc[maxn];
int tree[2][maxn];
int query[maxn][2];
vector<int>q[maxn];
vector<LL>ql[maxn];
vector<LL>qr[maxn];

void Update(int kd , int x)
{
  while(x<=k)
  {
    tree[kd][x]++;
    x+=(x&(-x));
  }
}

LL Query(int kd , int x)
{
  LL res=0;
  while(x)
  {
    res+=(LL)tree[kd][x];
    x-=(x&(-x));
  }
  return res;
}

int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1 ; i<=n ; i++)
  {
    scanf("%d",&ar[i].val);
    ar[i].id=i;
  }
  sort(ar+1,ar+n+1,comp1);
  for(int i=1 ; i<=n ; )
  {
    int j=i;
    k++;
    while(j<=n && ar[i].val==ar[j].val) ar[j++].pos=k;
    i=j;
  }
  sort(ar+1,ar+n+1,comp2);
  for(int i=1 ; i<=n ; i++)
  {
    qc[i]=1;
    q[i].pb(ar[i].pos);
  }
  for(int i=1 ; i<=m ; i++)
  {
    scanf("%d%d",&query[i][0],&query[i][1]);
    if(ar[query[i][0]].pos!=ar[query[i][1]].pos)
    {
      q[query[i][0]].pb(ar[query[i][1]].pos);
      q[query[i][1]].pb(ar[query[i][0]].pos);
    }
  }
  for(int i=1 ; i<=n ; i++)
  {
    int sz=q[i].size();
    for(int j=0 ; j<sz ; j++)
      ql[i].pb(Query(0,k)-Query(0,q[i][j]));
    Update(0,ar[i].pos);
    ans+=ql[i][0];
  }
  for(int i=n ; i>=1 ; i--)
  {
    int sz=q[i].size();
    for(int j=0 ; j<sz ; j++)
      qr[i].pb(Query(1,q[i][j]-1));
    Update(1,ar[i].pos);
    ans+=qr[i][0];
  }
  ans/=2LL;
  for(int i=1 ; i<=m ; i++)
  {
    LL res=ans;
    int x=query[i][0];
    int y=query[i][1];
    if(ar[x].val==ar[y].val)
    {
      printf("%lld\n",res);
      continue;
    }
    res-=ql[x][0]+qr[x][0]+ql[y][0]+qr[y][0];
    res+=ql[x][qc[x]]+qr[x][qc[x]]+ql[y][qc[y]]+qr[y][qc[y]];
    res+=1LL;
    qc[x]++;
    qc[y]++;
    printf("%lld\n",res);
  }
  return 0;
}
