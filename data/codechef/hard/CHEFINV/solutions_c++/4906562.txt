#include <bits/stdc++.h>

#define ALL(c)        c.begin(), c.end()
#define TR(c, it)     for(typeof(c.begin()) it = c.begin(); it != c.end(); it++)
#define FOR(i, j, n)  for(int (i) = (j); i < n; i++)
#define REP(i, j, lo) for(int (i) = (j); i >= (lo); i--)
#define MAX(a, b)     ((a) > (b) ? (a) : (b))
#define MIN(a, b)     ((a) < (b) ? (a) : (b))
#define gc            getchar_unlocked
#define pu            putchar_unlocked

#ifndef ONLINE_JUDGE
    #define gc getchar
    #define pu putchar
#endif

#define ll            long long int
#define ull           unsigned long long int
#define inf           INT_MAX
#define mininf        INT_MIN
#define pb            push_back
#define pob           pop_back
#define pf            push_front
#define pof           pop_front
#define mp            make_pair
#define PI            3.14159265358979323846264338327950288
#define endl          '\n'
#define SET(arr, val) memset(arr, val, sizeof arr)
#define SI            ( { int x; scanf("%d", &x); x; } )
#define IOSFAST       ( ios::sync_with_stdio(false); )
#define sysp          ( system("pause") )
#define isNum(a)      (a>=48 && a<=57)
#define isSchar(a)    (a>='a' && a<='z')
#define isCchar(a)    (a>='A' && a<='Z')
#define fi             first
#define se             second
#define clz(x)         __builtin_clz(x)
#define ctz(x)         __builtin_ctz(x)
#define popcount(x)    __builtin_popcount(x)
#define clzll(x)       __builtin_clzll(x)
#define ctzll(x)       __builtin_ctzll(x)
#define popcountll(x)  __builtin_popcountll(x)

using namespace std;

typedef pair<int, int> pii;
typedef pair<pii, int> ppi;
typedef pair<int, pii> pip;

/** FUNCTIONS **/
template <typename T> inline void ifast(T &x)
{ register int c = gc();x = 0;int neg = 0;for(;((c < 48 || c > 57)&&c != '-');c = gc());if(c == '-') neg = 1, c = gc();
  for( ; c > 47 && c < 58 ; c = gc()) x = (x << 1) + (x << 3) + c - 48; if(neg) x = -x; }

template <typename T> inline void dfast(T &x)
{ T s=1,i=10;x=0;char c=gc();if(c=='-')s=-1,c=gc();while(isNum(c))x=x*10+(c-'0'),c=gc();if(c!='.')return;c=gc();
  while(isNum(c)) x = x + (c - '0') / i, i *= 10, c = gc(); }

int sfast(char*str){register char c=0;register int i=0;while(c<33)c=gc();while(c!='\n'){str[i]=c;c=gc(),i++;}str[i]='\0'; return i;}

int sfast(string &str){register char c=0;register int i=0;while(c<33)c=gc();str="";while(c!='\n'){str += c;c = gc();i++;} return i;}

template<typename T>T s2num(string &Text){ stringstream ss(Text);T result;return ss >> result ? result : 0;}

template<typename T>string num2s(T Number){ stringstream ss; ss << Number; return ss.str();}

template<typename T> T gcd(T a, T b){if(b == 0) return a; else return gcd(b, a % b);}

template<typename T> T ncr(T n,T r){T c=1,d;for(T j=1;j<r+1;j++){d=gcd(c, j);c /= d;c *= (n - j + 1) / (j / d);}return c;}

template<typename T> T uplim(){ return numeric_limits<T>::max(); }

template<typename T> T lolim(){ return numeric_limits<T>::min(); }

/** END **/
ll BIT[200010] = {0};
ll ans1[200010] = {0}, ans2[200010] = {0}, ans3[200010] = {0}, ans4[200010] = {0}, ans5[200010] = {0};
ll n, m;
vector<pii> start[200010], end[200010];

void update(ll idx, int k)
{
    while(idx <= n)
    {
        BIT[idx] += k;
        idx = idx + (idx & -idx);
    }
}

ll query(ll idx)
{
    ll sum = 0;
    while(idx > 0)
    {
        sum += BIT[idx];
        idx = idx - (idx & -idx);
    }
    return sum;
}

int main()
{
    ifast(n);
    ifast(m);
    ll *inp = new ll[n+1], *aux = new ll[n+1];
    FOR(i, 1, n+1)
    {
        ifast(inp[i]);
        aux[i] = inp[i];
    }
    FOR(i, 1, m+1)
    {
        int x, y;
        ifast(x);
        ifast(y);
        start[ MIN(x, y) ].pb( mp( MAX(x, y), i) );
        end[ MAX(x, y) ].pb( mp( MIN(x, y), i) );
        if(inp[ MIN(x, y) ] > inp[ MAX(x, y) ])
            ans5[i] = -1;
        else if(inp[ MIN(x, y) ] < inp[ MAX(x, y) ])
            ans5[i] = 1;
    }
    sort(aux+1, aux+n+1);
    FOR(i, 1, n+1)
    {
        int idx = lower_bound(aux+1, aux+n+1, inp[i]) - (aux + 1);
        inp[i] = idx + 1;
    }
    ll inv = 0;
    REP(i, n, 1)
    {
        ll x = query(inp[i]-1);
        inv += x;
        update(inp[i], 1);
    }
    SET(BIT, 0);
    FOR(i, 1, n+1)
    {
        ll z = query(n+1) - query( inp[i] );
        ll y = query( inp[i] - 1 );
        if(start[i].size())
        {
            FOR(j, 0, start[i].size())
            {
                ll h = query(n+1) - query( inp[ start[i][j].fi ] );
                ll d = query( inp[ start[i][j].fi ] - 1 );
                ans1[  start[i][j].se ] -= z;
                ans2[  start[i][j].se ] -= y;
                ans3[  start[i][j].se ] -= h;
                ans4[  start[i][j].se ] -= d;
            }
        }
        if(end[i].size())
        {
            FOR(j, 0, end[i].size())
            {
                ll h = query(n+1) - query( inp[ end[i][j].fi ] );
                ll d = query( inp[ end[i][j].fi ] - 1 );
                ans1[ end[i][j].se ] += h;
                ans2[ end[i][j].se ] += d;
                ans3[ end[i][j].se ] += z;
                ans4[ end[i][j].se ] += y;
                if(inp[i] > inp[ end[i][j].fi ])
                    ans4[ end[i][j].se ]--;
                if(inp[i] < inp[ end[i][j].fi ])
                    ans3[ end[i][j].se ]--;
            }
        }
        update(inp[i], 1);
    }
    FOR(i, 1, m+1)
        printf("%lld\n", inv + ans1[i] + ans4[i] - ans2[i] - ans3[i] + ans5[i]);
    return 0;
}
