//---------------------------JUGNU: LET YOUR LIGHT SHINE---------------------------//
#include <bits/stdc++.h>
#define ll long long int
#define pb push_back
#define pf push_front
#define sz size
#define mk make_pair
#define ln length
#define vt(a) vector <ll> a
#define st(a) set <ll> a
#define sti(a) set <ll>::iterator a
#define fr(i,a,b) for(i=a;i<b;i++)
#define fre(i,a,b) for(i=a;i<=b;i++)
#define frr(i,a,b) for(i=a;i>=b;i--)
#define sc(a) scanf("%d",&a)
#define sm(a,b) scanf("%d%d", &a, &b)
#define pr(a) printf("%d\n", a)
#define pm(a,b) printf("%d %d\n", a, b)
#define cn(a) cin >> a
#define ct(a) cout << a << endl
#define isset(x,i) ((x>>i)&1)
#define fastScan ios_base::sync_with_stdio(0); cin.tie(NULL);
using namespace std;
vector<int> valid_moves;
int Grundy[100005];
int Recursive_Compute_Grundy(int x)
{
	if(Grundy[x] != -1)
		return Grundy[x];
	set<int> mex;
	mex.clear();
	int i;
	fr(i, 0, valid_moves.sz())
	{
		if((x - valid_moves[i])>=0)
			mex.insert(Recursive_Compute_Grundy(x - valid_moves[i]));
	}
	int val = 0;
	while(1)
	{
		if(mex.find(val) == mex.end())
			return (Grundy[x] = val);
		val++;
	}
}
int main()
{
	int i, j, t, n, m, k, l, r, mini,cnt, maxi, temp, flag, result, decider;
	valid_moves.pb(1);
	valid_moves.pb(4);
	valid_moves.pb(27);
	valid_moves.pb(256);
	valid_moves.pb(3125);
	valid_moves.pb(46656);
	fr(i, 0, 100005)
		Grundy[i] = -1;
	Grundy[0] = 0;
	sc(t);
	while(t--)
	{
		decider = 0;
		sc(n);
		fr(i, 0, n)
		{
			sc(k);
			decider = decider ^ Recursive_Compute_Grundy(k);
		}
		if(decider)
			printf("Little Chef\n");
		else
			printf("Head Chef\n");
	}
return 0;
}
