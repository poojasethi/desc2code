/*
 The original version of this problem is couting number of different sub-string of a given string.
 We can apply the idea of building the suffix array algorithm to sort all the path from the each city to the capital and also, determine the longest common prefix of two path in the sorted array.
 */

#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <map>
#define MAXN 111111
#define MAXQ 111111
#define ll long long

using namespace std;


map<pair<int,int>,int> hashed;
vector<int> cumul_arr[MAXQ+2];
int sz;


int N;
int A[MAXN+2];
int num_digs[MAXN+2];

int find(int L,int v) {
    
    if(hashed.find(make_pair(L,v))!=hashed.end()) {
        return hashed[make_pair(L,v)];
    }
    
    //L+v*t<=n
    //t<=(n-L)/v;
    cumul_arr[sz].resize((N-L)/v+1);
    cumul_arr[sz][0]=num_digs[L];
    for(int j=1;j<=(N-L)/v;j++)
        cumul_arr[sz][j]=cumul_arr[sz][j-1]+num_digs[L+v*j];
    hashed[make_pair(L,v)]=sz;
    sz++;
    return sz-1;
}

int printdig(int i,int j) {
    int x=A[i];
    for(int k=0;k<j;k++) {
        x/=10;
    }
    return x%10;
}

int ND(int x) {
    if(x==0)
        return 1;
    int ct=0;
    while(x) {
        ct++;
        x/=10;
    }
    return ct;
}

int main() {
    cin>>N;
    num_digs[0]=0;
    for(int i=1;i<=N;i++) {
        cin>>A[i];
        num_digs[i]=ND(A[i]);
    }
    sz=0;
    int M;
    cin>>M;
    for(int i=1;i<=M;i++) {
        int l,v,k;
        cin>>l>>v>>k;
        if(l>N) {
            printf("So sad\n");
            continue;
        }
        // l+v*t <= n
        // t <= (n-l)/v
        if(true) {//(n-l)/v>20 && k>20) {
            int L=l%v;
            // L+v*t
            int id = find(L,v);
            // V[i] = L + i*v = l + q*v
            // i=(l-L)/v+q
            
            int qlow=0;
            int qhigh=(N-l)/v;
            
            int prev=((l-L)/v>0?cumul_arr[id][(l-L)/v-1]:0);
            while(qlow<qhigh) {
                int q=(qlow+qhigh)/2;
                int j=(l-L)/v+q;
                if(cumul_arr[id][j]-prev>=k) {
                    qhigh=q;
                } else {
                    qlow=q+1;
                }
            }
            int j=(l-L)/v+qlow;
            if(cumul_arr[id][j]-prev<k) {
                printf("So sad\n");
            } else {
                //l+qlow*v
                cout << printdig(l+qlow*v, cumul_arr[id][j]-prev-k) << endl;
            }
        } 
        
    }
}