#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <sstream>
#include <set>
#include <map>
#include <queue>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <ctime>
using namespace std;
/*
f(1) = 0
f(2) = 5
f(n) = f(n-1) + f(n-2)+
*/
#define MOD 1000000007
#define MAXN 4
int size;
struct Matrix
{
int X[MAXN][MAXN];
Matrix () {}
Matrix (int k)
{
memset(X, 0, sizeof(X));
for(int i=0; i<size; i++)
X[i][i] = k;
}
};
Matrix operator *(Matrix &A, Matrix &B)
{
Matrix M;
for(int i=0; i<size; i++)
{
for(int j=0; j<size; j++)
{
long long tmp = 0;
for(int k=0; k<size; k++)
tmp += (long long)A.X[i][k] * B.X[k][j];
M.X[i][j] = tmp % MOD;
}
}
return M;
}
Matrix pow(Matrix x, long long n)
{
Matrix P(0);
P.X[0][0]=5;P.X[0][1]=0;P.X[0][2]=8;P.X[0][3]=5;
while(n)
{
if(n & 1) P = P * x;
n >>= 1;
x = x * x;
}
return P;
}
int main()
{
/*
N, 0 -> 2^(N-1) * 1
N-2, 1 -> 2^(N-2) * C(N-1, 1)
N-4, 2 -> 2^(N-3) * C(N-2, 2)
0, N/2 -> 2^(N/2) * C(N/2, N/2)
*/
int T;
scanf("%d", &T);
size = 4;
Matrix M(0);
M.X[0][0] = 1; M.X[0][1] = 1;
M.X[1][0] = 1;
M.X[2][0] = 1; M.X[2][2] = 1; M.X[2][3] = 1;
M.X[3][0] = 1; M.X[3][2] = 1;
for(int caso=1; caso<=T; caso++)
{
long long n;
scanf("%lld", &n);
if(n == 1) printf("0\n");
else if(n == 2) printf("5\n");
else
{
Matrix P = pow(M, n-2);
printf("%d\n", (int)(P.X[0][0]) % MOD);
}
}
return 0;
}
