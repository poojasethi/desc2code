#include<stdio.h>
#define int64 long long
#define mod 1000000007

int64*** Pow;
int64** Result;
int64** temp;

void PrecomputeSquares()
{
    Pow = new int64**[50];
    
    for(int i=0; i<50; ++i)
    {
        Pow[i] = new int64*[4];
        for(int j=0; j<4; ++j)
        {
            Pow[i][j] = new int64[4];
        }
    }

    Pow[0][0][0] = 2;
    Pow[0][0][1] = 1;
    Pow[0][0][2] = -2;
    Pow[0][0][3] = -1;

    Pow[0][1][0] = 1;
    Pow[0][1][1] = 0;
    Pow[0][1][2] = 0;
    Pow[0][1][3] = 0;

    Pow[0][2][0] = 0;
    Pow[0][2][1] = 1;
    Pow[0][2][2] = 0;
    Pow[0][2][3] = 0;

    Pow[0][3][0] = 0;
    Pow[0][3][1] = 0;
    Pow[0][3][2] = 1;
    Pow[0][3][3] = 0;

    for(int id=1; id<50; ++id)
    {
        for(int i=0; i<4; ++i)
        {
            for(int j=0; j<4; ++j)
            {
                Pow[id][i][j] = 0;
                for(int k=0; k<4; ++k)
                {
                    Pow[id][i][j] = (Pow[id][i][j]+Pow[id-1][i][k]*Pow[id-1][k][j])%mod;
                }
            }
        }
    }
}

void MatrixMultiply(int64** &A, int64** &B, int64** &C)
{
    for(int i=0; i<4; ++i)
    {
        for(int j=0; j<4; ++j)
        {
            C[i][j] = 0;
            for(int k=0; k<4; ++k)
            {
                C[i][j] = (C[i][j]+A[i][k]*B[k][j])%mod;
            }
        }
    }
    int64** temp = A;
    A = C;
    C = temp;
}

int64 Recurrence(int64 N)
{
    N -= 4;

    Result[0][0] = 1;
    Result[0][1] = 0;
    Result[0][2] = 0;
    Result[0][3] = 0;
    
    Result[1][0] = 0;
    Result[1][1] = 1;
    Result[1][2] = 0;
    Result[1][3] = 0;
    
    Result[2][0] = 0;
    Result[2][1] = 0;
    Result[2][2] = 1;
    Result[2][3] = 0;
    
    Result[3][0] = 0;
    Result[3][1] = 0;
    Result[3][2] = 0;
    Result[3][3] = 1;
    
    int id=0;
    int64** swap;
    int64 check = 1;

    while(N)
    {
        if(N&check)
        {
            temp[0][0] = (Result[0][0]*Pow[id][0][0]+Result[0][1]*Pow[id][1][0]+Result[0][2]*Pow[id][2][0]+Result[0][3]*Pow[id][3][0])%mod;
            temp[0][1] = (Result[0][0]*Pow[id][0][1]+Result[0][1]*Pow[id][1][1]+Result[0][2]*Pow[id][2][1]+Result[0][3]*Pow[id][3][1])%mod;
            temp[0][2] = (Result[0][0]*Pow[id][0][2]+Result[0][1]*Pow[id][1][2]+Result[0][2]*Pow[id][2][2]+Result[0][3]*Pow[id][3][2])%mod;
            temp[0][3] = (Result[0][0]*Pow[id][0][3]+Result[0][1]*Pow[id][1][3]+Result[0][2]*Pow[id][2][3]+Result[0][3]*Pow[id][3][3])%mod;

            temp[1][0] = (Result[1][0]*Pow[id][0][0]+Result[1][1]*Pow[id][1][0]+Result[1][2]*Pow[id][2][0]+Result[1][3]*Pow[id][3][0])%mod;
            temp[1][1] = (Result[1][0]*Pow[id][0][1]+Result[1][1]*Pow[id][1][1]+Result[1][2]*Pow[id][2][1]+Result[1][3]*Pow[id][3][1])%mod;
            temp[1][2] = (Result[1][0]*Pow[id][0][2]+Result[1][1]*Pow[id][1][2]+Result[1][2]*Pow[id][2][2]+Result[1][3]*Pow[id][3][2])%mod;
            temp[1][3] = (Result[1][0]*Pow[id][0][3]+Result[1][1]*Pow[id][1][3]+Result[1][2]*Pow[id][2][3]+Result[1][3]*Pow[id][3][3])%mod;
            
            temp[2][0] = (Result[2][0]*Pow[id][0][0]+Result[2][1]*Pow[id][1][0]+Result[2][2]*Pow[id][2][0]+Result[2][3]*Pow[id][3][0])%mod;
            temp[2][1] = (Result[2][0]*Pow[id][0][1]+Result[2][1]*Pow[id][1][1]+Result[2][2]*Pow[id][2][1]+Result[2][3]*Pow[id][3][1])%mod;
            temp[2][2] = (Result[2][0]*Pow[id][0][2]+Result[2][1]*Pow[id][1][2]+Result[2][2]*Pow[id][2][2]+Result[2][3]*Pow[id][3][2])%mod;
            temp[2][3] = (Result[2][0]*Pow[id][0][3]+Result[2][1]*Pow[id][1][3]+Result[2][2]*Pow[id][2][3]+Result[2][3]*Pow[id][3][3])%mod;

            temp[3][0] = (Result[3][0]*Pow[id][0][0]+Result[3][1]*Pow[id][1][0]+Result[3][2]*Pow[id][2][0]+Result[3][3]*Pow[id][3][0])%mod;
            temp[3][1] = (Result[3][0]*Pow[id][0][1]+Result[3][1]*Pow[id][1][1]+Result[3][2]*Pow[id][2][1]+Result[3][3]*Pow[id][3][1])%mod;
            temp[3][2] = (Result[3][0]*Pow[id][0][2]+Result[3][1]*Pow[id][1][2]+Result[3][2]*Pow[id][2][2]+Result[3][3]*Pow[id][3][2])%mod;
            temp[3][3] = (Result[3][0]*Pow[id][0][3]+Result[3][1]*Pow[id][1][3]+Result[3][2]*Pow[id][2][3]+Result[3][3]*Pow[id][3][3])%mod;

            int64** swap = Result;
            Result = temp;
            temp = swap;
        }
        id++;
        N >>= 1;
    }    

    int64 ans = (44*Result[0][0]+18*Result[0][1]+5*Result[0][2])%mod;

    return (ans>=0)?ans:(ans+=mod);
}

//FastIO begin

#define BUFFERSIZE 20000000

char *ipos, *opos, InpFile[BUFFERSIZE], OutFile[BUFFERSIZE], DIP[20];

inline int64 ni(int flag=0)
{
    while(*ipos <= 32) ++ipos;
    if(flag) return (*ipos++ - '0'); /* For getting Boolean Characters */
    int64 x=0, neg=0;
    char c;
    while(true)
    {
        c=*ipos++;
        if(c == '-') neg = 1;
        else
        {
            if(c<=32) return neg?-x:x;
            x=(x<<1)+(x<<3)+c-'0';
        }
    }
}

inline void pi(int64 x,int flag = 1)
{
    int64 y,dig=0;
    while (x||!dig)
    {
        y=x/10;
        DIP[dig++]=x-((y << 3) + (y << 1))+'0';
        x=y;
    }
    while (dig--) *opos++=DIP[dig];
    *opos++= flag ? '\n' : ' ';
}

inline void InitFASTIO()
{
    ipos = InpFile; opos = OutFile;
    fread(InpFile,20000000,1,stdin);
}

inline void FlushFASTIO()
{
    fwrite(OutFile,opos-OutFile,1,stdout);
}

//FastIO end

int main()
{   
    Result = new int64*[4];
    for(int i=0; i<4; ++i) Result[i] = new int64[4];
    temp = new int64*[4];
    for(int i=0; i<4; ++i) temp[i] = new int64[4];

    PrecomputeSquares();
     
    //InitFASTIO();
    int64 T;
    int64 N;
    scanf("%lld",&T);
    //T = ni();

    while(T--)
    {
        scanf("%lld",&N);
        //N = ni();
        if(N == 1)
        {
            //pi(0);
            printf("0\n");
        }
        else if(N == 2)
        {
            //pi(5);
            printf("5\n");
        }
        else if(N == 3)
        {
            //pi(18);
            printf("18\n");
        }
        else if(N == 4)
        {
            //pi(44);
            printf("44\n");
        }
        else
        {
            //pi(Recurrence(N));
            printf("%lld\n",Recurrence(N));
        }
    }
    //FlushFASTIO();

    delete[] Pow,Result,temp;

    return 0;
}
