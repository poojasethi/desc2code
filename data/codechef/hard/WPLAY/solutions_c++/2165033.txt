#include <iostream>
#include <cstring>
#include <stdio.h>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#include <map>
#include <vector>
#include <list>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <string>
#include <cmath>
#define ff first
#define ss second
#define get getchar
using namespace std;
set<long long>st;
string tmp;
char s[20],a[20][20];
int dp[70000],present[70000],n;
unsigned long long hash(string str)
{
    unsigned long long h=0;
    for(int i=0;i<str.size();i++)
    h=(h*2397+str[i]);
    return h;
}
int solve(int state)
{
    if(dp[state]!=-1)
    return dp[state];
    int substate=state,res=1;
    for(;substate>0;substate=(substate-1)&state)
    {
         if(present[substate])
         res=solve(state&(~substate));
         if(res==0)
         break;
    }
    if(res==0)
    dp[state]=1;
    else dp[state]=0;
    return dp[state];
}
int got (int mask) {
 	int &res = dp[mask];

 	if (res != -1) return res;
 	res = 0;

 	for (int i = mask;i > 0;i = (i - 1) & mask) {
 	 	if (present[i] && !got(mask ^ i)) {
 	 	 	return res = 1;
 	 	}
 	}
 	return res;
}
inline int go(int ac) {
	//ac signifies the current active state.
	if(dp[ac]!=-1) //memoization.
		return dp[ac];
	//op will contain number of set bits in ac
	//ones will contain the indices of set bits in ac.
	int op = 0, ones[22];
	for(int i=0; i<n;i++) {
		if((ac&(1<<i))>0) {
			ones[op++] = i;
		}
	}
	//iteraring through all possible words than can be made from current active board.
	for(int i=1; i<(1<<op);i++) {
		int mask = 0;
		for(int j=0; j<op;j++) {
			if(i&(1<<j)) {
				mask |= (1<<ones[j]);
			}
		}
		//mask is the current choice of word to be made from active set.
		if(present[mask]) {
			//next is the next possible board configuration, if mask is the chosen word.
			int next = go(ac ^ mask);
			//as mask will be inactive in the future, ac^mask, will set the bits set in mask to 0 in ac.
			if(next == 0) { //found a losing pos
				return dp[ac] = 1;//hence ac is a winning position.
			}
		}
	}
	//as we found no losing position from ac, hence ac is a losing position in itself, hence dp[ac] = 0
	return dp[ac] = 0;
}

int main()
{
    int i,j,k,d,t;
    scanf("%d",&d);
    for(i=0;i<d;i++)
    {
      scanf("%s",s);
      tmp=s;
      sort(tmp.begin(),tmp.end());
      st.insert(hash(tmp));
    }
    int r,c;
    scanf("%d%d%d",&r,&c,&t);
    n=r*c;
    while(t--)
    {
        fill(dp,dp+70000,-1);
        memset(present,0,sizeof(present));
        for(i=0;i<r;i++)
        scanf("%s",a[i]);
        for(i=0;i<(1<<n);i++)
        {
            tmp="";
            for(j=0;j<n;j++)
            {
                if(i&(1<<j))
                tmp+=a[j/c][j%c];
            }
            sort(tmp.begin(),tmp.end());
            present[i]=(st.find(hash(tmp))!=st.end());
        }
        int res=solve((1<<n)-1);
        if(res)puts("Alice");
        else puts("Bob");
    }
    return 0;
}
