#pragma comment(linker,"/STACK:64000000")
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <sstream>
#include <cmath>
#include <ctime>
#include <memory.h>

#define WR printf
#define RE scanf
#define PB push_back
#define SE second
#define FI first
#define MP make_pair

#define FOR(i,Be,En) for(int (i)=(Be);(i)<=(En);++(i))
#define DFOR(i,Be,En) for(int (i)=(Be);(i)>=(En);--(i))
#define SZ(a) (int)((a).size())
#define FA(i,v) FOR(i,0,SZ(v)-1)
#define RFA(i,v) DFOR(i,SZ(v)-1,0)
#define CLR(a) memset(a,0,sizeof(a))

#define LL  long long
#define VI  vector<int>
#define PAR pair<int ,int> 

using namespace std;
void __never(int a){printf("\nOPS %d", a);}
void __die(int a){printf("%d",(a*a)/(a+a));}
#define ass(s) {if (!(s)) {__never(__LINE__);cout.flush();cerr.flush();__die(0);}}

#define MN 100500

PAR m[MN];
PAR po[200000];
int r[MN];
int pc;
int n;
void init()
{
	freopen("input.txt","r",stdin);
	freopen("output.txt","w",stdout);
}
int gcd(int a, int b){
	while (a && b){
		if (a >= b) a %= b;
		else b %= a;
	}
	return a + b;
}
bool cmp(const PAR & a, const PAR & b) {
	return a.FI*b.SE < b.FI*a.SE;
}
bool was[300][300];
void Pre(){
	pc = 0;
	FOR(i,100,200) FOR(j,100,220) {
		int gc = gcd(i,j);
		int ii = i / gc;
		int jj = j / gc;
		if (was[ii][jj]) continue;
		was[ii][jj] = true;
		po[pc++] = MP(i,j);
	}
	sort(po,po + pc, cmp);
}
bool ok(int g){
	ass(0<=g && g < pc);
	int a = po[g].FI, b = po[g].SE;
	FOR(i,0,n-1) r[i] = m[i].SE*b - m[i].FI*a;
	sort(r,r+n);
	for (int le = 0, ri = n-1;le<ri;le++,ri--) {
		if (r[le] + r[ri] < 20*a) return false;
	}
	return true;
}
void sol(){	
	cin >> n;
	FOR(i,0,n-1)  {
		RE("%d %d",&m[i].FI,&m[i].SE);
		//m[i].FI += 10;
	}
	int low = 0, hi = pc - 1;
	ass(ok(low));
	while (low < hi) {
		int ce = (low + hi + 1) / 2;
		if (ok(ce)) low = ce;
		else hi = ce-1;
	}
	WR("%.6lf",1.*po[low].FI/po[low].SE);
	
}
int main()
{
	//init();
	Pre();
	sol();
	return 0;
}