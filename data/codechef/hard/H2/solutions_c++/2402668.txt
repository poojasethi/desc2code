#include <algorithm>
#include <assert.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

typedef struct {
	double x, y;
} point_t;

int pt_cnt[112][112];

int N;
point_t points[3100];
pair<double,int> dists[3100];
int order[3100];
int cnt[3100];
point_t midline;

double sqr(double x)
{
	return x*x;
}

double dist2(const point_t *p)
{
	double dot = p->x*midline.x + p->y*midline.y;
	point_t proj = { dot*midline.x, dot*midline.y };
	return sqr(proj.x-p->x) + sqr(proj.y-p->y);
}

bool is_left(const point_t *p)
{
	double cross = p->x*midline.y - p->y*midline.x;
	return cross < 0.0;
}

int main(void)
{
	double lo = 0.0, hi = 0.0, mid;

	int T;
	scanf("%d", &T);
	for (int i = 0; i < T; ++i) {
		int x, y;
		scanf("%d %d", &x, &y);
		pt_cnt[x+10][y] += 1;
	}

	for (int w = 60; w <= 110; ++w) {
		for (int p = 50; p <= 100; ++p) {
			if (pt_cnt[w][p] == 0)
				continue;
			points[N].x = w;
			points[N].y = p;
			order[N] = N;
			cnt[N] = pt_cnt[w][p];
			N += 1;
			double speed = p * 1.0 / w;
			if (speed > hi)
				hi = speed;
		}
	}

	for (int i = 0; i < 30; ++i) {
		mid = (lo+hi) / 2.0;
		double len = hypot(mid, 1.0);
		midline.x = 1.0 / len;
		midline.y = mid / len;
		for (int j = 0; j < N; ++j) {
			dists[j] = make_pair(dist2(&points[j]), cnt[j]);
			if (is_left(&points[j]))
				dists[j].first *= -1.0;
		}
		std::sort(dists, dists+N);

		bool possible = true;
		for (int a = 0, b = N-1; possible && a < b; a += 1, b -= 1) {
			bool left_a = dists[a].first <= 0.0;
			bool left_b = dists[b].first <= 0.0;
			if (left_a && left_b)
				continue;
			if (!left_a && !left_b) {
				possible = false;
				break;
			}
			assert(left_a && !left_b);
			possible = fabs(dists[a].first) > fabs(dists[b].first);
			if (possible) {
				int mn = min(dists[a].second, dists[b].second);
				dists[a].second -= mn;
				dists[b].second -= mn;
				if (dists[a].second > 0)
					a -= 1;
				if (dists[b].second > 0)
					b += 1;
			}
		}

		if (possible)
			lo = mid;
		else
			hi = mid;
	}

	printf("%0.7lf\n", mid);

	return 0;
}
