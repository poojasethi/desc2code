#include <algorithm>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;

#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n) FOR(i,0,n)

#define SZ(xs) int((xs).size())
#define ELEM(x,xs) ((xs).find(x)!=(xs).end())
#define SORT(xs) sort((xs).begin(),(xs).end())
#define FOREACH(it,xs) for(typeof((xs).begin()) it=(xs).begin();it!=(xs).end();++it)

#define MP make_pair
#define PB push_back

#define fst first
#define snd second

#define PMOD(a,b) (((a)%(b)+(b))%(b))

#define DUMP(x) cerr << #x << " = " << (x) << endl;

const double EPS = 1e-9;
const double PI = acos(-1.0);

template <class T> inline T sq(T x) {return x*x;}

template <class T> inline void upd_min(T &lhs, T rhs) {if(lhs>rhs)lhs=rhs;}
template <class T> inline void upd_max(T &lhs, T rhs) {if(lhs<rhs)lhs=rhs;}

const int MOD = (int)1e9+7;

ll fact(int n) {

  return n ? n*fact(n-1) % MOD : 1;

}

void solve() {

  int T;
  cin >> T;
  while (T--) {
    int N, M;
    cin >> N >> M;
    vector<ll> v(N);
    ll f = fact(M);
    ll sum = M*f % MOD;
    REP(i,M) {
      v[i] = f;
    }
    FOR(i,M,N) {
      v[i] = sum;
      sum += sum - v[i-M];
      sum %= MOD;
    }
    cout << endl;
    ll ans = 0;
    REP(i,M) {
      ans += (M - i)*v[N-i-2];
      ans %= MOD;
    }
    cout << (ans + MOD)%MOD << endl;
  }

}

int main() {

  solve();

  return 0;

}
