#include<vector>
#include<cstring>
#include<algorithm>
#include<stdio.h>
#include<climits>
#include<set>
#include<fstream>
#include<cmath>
#include<bitset>
#include<map>
#include<stack>
#include<fstream>
#include<iostream>
#include<queue>
#include<assert.h>
#define test(t) while(t--)
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)

#define p(n) printf("%lld\n",n)
#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>

#define pb push_back
#define inf 1000000000LL
#define mp make_pair

#define N 100004
#define LN 20
#define ll long long
#define mod 1000000007LL
//#define inf 100000000

using namespace std;

string ss[1000002];
vector<ll>value[1000002];
vector<ll>rvalue[1000002];
ll power[1000002];
ll inv[1000002];

ll modPow(ll a,ll b,ll md){
    ll ans = 1;
    while(b){
       if(b&1)
            ans = (ans*a)%md;
        a = (a*a)%md;
        b/=2;
    }
    return ans;
}

ll modExp(ll a,ll b,ll md){
    return power[b];
}

ll inverse(ll num){
   return inv[num];
}

struct trie{
  struct trie * child[26];
  ll cnt;
};

struct trie * head ;

struct trie * newNode(){

  struct trie * newN = new trie();
  newN->cnt = 0;
  for(int i=0;i<26;++i)
    newN->child[i]=NULL;
    return newN;
}

int palin(int id,int i,int j){


    if(i>j)
        return 1;
    int sz = (j-i+1);
    if(sz==1)
        return 1;
    int div = sz/2;
    ll left = value[id][i+div-1];
    if(i>0)
        left-=value[id][i-1];
    left=(left%mod+2*mod)%mod;
    left = (left*inverse(i))%mod;
    int ri = ss[id].size()-1-j;
    ll right = rvalue[id][ri+div-1];
    if(ri>0)
        right-=rvalue[id][ri-1];
    right=(right%mod+2*mod)%mod;
    right = (right*inverse(ri))%mod;

    if(left==right)
        return 1;
    else
        return 0;
}

void inser(int id){

   struct trie * oldHead = head ;

   for(int i=0;i<ss[id].size();++i){
         int idd = ss[id][i]-'a';
         if(head->child[idd]==NULL)
                head->child[idd] = newNode();
         head = head->child[idd];
          if(palin(id,i+1,ss[id].size()-1))
            head->cnt++;
   }
   head = oldHead ;
}

ll query(string que){
   struct trie * oldHead = head ;
   for(int i=0;i<que.size();++i){
         int idd = que[i]-'a';
         if(head->child[idd]==NULL){
             head = oldHead;
             return 0LL;
         }else
            head = head->child[idd];
   }
   ll an = head->cnt;
   head = oldHead;
   return an;
}
map<pair<int,ll>,ll>m1;
int main(){
  int t,n,i,j;
  power[0] = 1;
  inv[0] = 1;
  for(i=1;i<=1000000;++i){
     power[i] = (power[i-1]*26)%mod;
     inv[i] = modPow(power[i],mod-2,mod);
  }
  cin>>t;


  while(t--){
   m1.clear();
     s(n);
     head = newNode();
     for(i=0;i<n;++i){
        cin>>ss[i];
        value[i].clear();
        rvalue[i].clear();
     }
     for(i=0;i<n;++i){
        ll hasv = 0;
        for(j=ss[i].size()-1;j>=0;--j){
           hasv = (hasv+modExp(26LL,ss[i].size()-1-j,mod)*(ss[i][j]-'a'));
           hasv%=mod;
           rvalue[i].pb(hasv);
        }
        hasv = 0;
        for(j=0;j<=ss[i].size()-1;++j){
           hasv = (hasv+modExp(26LL,j,mod)*(ss[i][j]-'a'));
           hasv%=mod;
           value[i].pb(hasv);
        }
        pair<int,ll>pp = make_pair(ss[i].size(),hasv);
        if(m1.count(pp))
            m1[pp]++;
        else
            m1[pp] = 1;
     }
     for(i=0;i<n;++i){
        inser(i);
     }
      ll ans = 0;
      for(i=0;i<n;++i){
        reverse(ss[i].begin(),ss[i].end());
        ans+=query(ss[i]);
        // cout<<ss[i]<<endl;
        int sz = ss[i].size()-1;
       // cout<<ans<<endl;
        ll hss = 0;
        for(j=0;j<ss[i].size()-1;++j){
            hss = hss + modExp(26LL,j*1LL,mod)*(ss[i][j]-'a');
            hss%=mod;
            pair<int,ll>pp = make_pair(j+1,hss);
            if(palin(i,0,ss[i].size()-2-j)){

                if(m1.count(pp))
                    ans+=m1[pp];
            }
        }
        if(value[i][sz]==rvalue[i][sz])
            ans-=1;
       // cout<<ans<<endl;
      }
      printf("%lld\n",ans);
  }
}
