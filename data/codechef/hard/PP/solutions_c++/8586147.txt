#pragma comment(linker, "/STACK:102400000,102400000")
#include <bits/stdc++.h>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 1000005

template <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}
template <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}

char s[N];
struct trie{
    int ch[26],v;
    void init(){
        memset(ch,0,sizeof(ch));
        v=0;
    }
}t[N];
int sz;
const int mo1=1000000007;
const int mo2=42424243;
struct hash{
    int x,y;
    hash(){}
    hash(int _x):x(_x),y(_x){}
    hash(int _x,int _y):x(_x),y(_y){}
    hash operator +(const hash&a)const{
        int xx=x+a.x,yy=y+a.y;
        if(xx>=mo1)xx-=mo1;
        if(yy>=mo2)yy-=mo2;
        return hash(xx,yy);
    }
    hash operator -(const hash&a)const{
        int xx=x-a.x,yy=y-a.y;
        if(xx<0)xx+=mo1;
        if(yy<0)yy+=mo2;
        return hash(xx,yy);
    }
    hash operator *(const hash&a)const{
        int xx=1LL*x*a.x%mo1,yy=1LL*y*a.y%mo2;
        return hash(xx,yy);
    }
    bool operator ==(const hash&a)const{
        return x==a.x&&y==a.y;
    }
};
const hash X(4243,10007);
hash h[N],g[N],q[N];
bool check(int i,int j){
    if(i>=j)return 1;
    return h[j+1]-h[i]*q[j-i+1]==g[i]-g[j+1]*q[j-i+1];
}
string ss[N];
int main(){
    //ios::sync_with_stdio(0);
    int T,i,j,k,m,ca=0,n;
    q[0]=1;
    for(i=1;i<N;i++)q[i]=q[i-1]*X;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        vector<pii>v;
        for(i=0;i<n;i++){
            scanf("%s",s);
            m=strlen(s);
            string st(s,s+m);
            ss[i]=st;
            v.pb(mp((int)st.size(),i));
        }
        sort(all(v));
        sz=0;t[0].init();
        ll ans=0;
        for(int it=0;it<n;it++){
            i=v[it].y;
            string &st=ss[i];m=st.size();
            //cout<<st<<"\n";
            h[0]=0;
            for(j=0;j<m;j++){
                h[j+1]=h[j]*X+st[j];
            }
            g[m]=0;
            for(j=m-1;j>=0;j--){
                g[j]=g[j+1]*X+st[j];
            }
            int p=0;
            for(j=m-1;j>=0;j--){
                k=st[j]-'a';
                if(!t[p].ch[k])break;
                p=t[p].ch[k];
                if(t[p].v&&check(0,j-1)){
                    ans+=t[p].v;
                }
            }
            p=0;
            for(j=0;j<m;j++){
                k=st[j]-'a';
                if(!t[p].ch[k])++sz,t[sz].init(),t[p].ch[k]=sz;
                p=t[p].ch[k];
            }
            t[p].v++;
        }
        //DBG(ans)
        sz=0;t[0].init();
        for(int it=0;it<n;it++){
            i=v[it].y;
            string &st=ss[i];m=st.size();
            //cout<<st<<"\n";
            h[0]=0;
            for(j=0;j<m;j++){
                h[j+1]=h[j]*X+st[j];
            }
            g[m]=0;
            for(j=m-1;j>=0;j--){
                g[j]=g[j+1]*X+st[j];
            }
            int p=0;
            for(j=0;j<m;j++){
                k=st[j]-'a';
                if(!t[p].ch[k])break;
                p=t[p].ch[k];
                if(t[p].v&&check(j+1,m-1)){
                    ans+=t[p].v;
                }
            }
            p=0;
            for(j=m-1;j>=0;j--){
                k=st[j]-'a';
                if(!t[p].ch[k])++sz,t[sz].init(),t[p].ch[k]=sz;
                p=t[p].ch[k];
            }
            t[p].v++;
        }
        printf("%lld\n",ans);
        /*
        ans=0;ll ans1=0;
        for(i=0;i<n;i++)
            for(k=0;k<n;k++)if(i!=k){
                string st=v[i]+v[k];m=st.size();
                h[0]=0;
                for(j=0;j<m;j++){
                    h[j+1]=h[j]*X+st[j];
                }
                g[m]=0;
                for(j=m-1;j>=0;j--){
                    g[j]=g[j+1]*X+st[j];
                }
                int l=0,r=st.size()-1;
                while(l<r&&st[l]==st[r])l++,r--;
                assert((l>=r)==(h[m]==g[0]));
                if(l>=r)ans++;
                if(h[m]==g[0])ans1++;
                if(ans){
                    cerr<<v[i]<<" "<<v[k]<<"\n";ans=0;break;
                }
            }
        DBG(ans)DBG(ans1)
        //*/
    }
    return 0;
}