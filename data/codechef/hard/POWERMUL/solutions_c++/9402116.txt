#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inp_s ios_base::sync_with_stdio(false)
#define DRT() int test_case;cin>>test_case;while(test_case--)
#define VI vector<int>
#define VS vector<string>
#define VLL vector<ll>
#define PII pair<int,int>
#define all(c) c.begin(),c.end()
#define sz(c) (int)c.size()
#define clr(c) c.clear()
#define pb push_back
#define mp make_pair
#define GI(x) scanf("%d",&x)
#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define RFOR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)
#define MOD 1000000007
#define EPS 1E-10
#define INF 1000000000
#define MAXN 100005
#define PI acos(-1)
#define CASE(x) cout << "Case #" << x << ": ";
bool flag[MAXN];
vector <ll> primes;
map <ll, ll> :: iterator it;
map <ll, ll> track[MAXN];
ll co[MAXN];
ll m;
 
ll extEuclid(ll a, ll b)
{
ll q, ps=1, s=0, pt=0, t=1, r;
 
while(a%b != 0)
{
q = a/b; r = a-q*b;
 
ll tmps=s, tmpt=t;
s = ps-q*s, t = pt-q*t;
ps = tmps, pt = tmpt;
 
a=b; b=r;
}
return (t+m)%m;
}
 
void precalcPrimes()
{
for (ll i = 2; i < MAXN; i++)
flag[i] = 1;
for (ll i = 2; i * i < MAXN; i++)
{
if (flag[i])
{
for (ll j = i * i; j < MAXN; j += i)
{
flag[j] = 0;
}
}
}
for (ll i = 2; i < MAXN; i++)
{
if (flag[i])
primes.pb(i);
}
}
ll power(ll b, ll e)
{
ll x = 1;
while (e)
{
if (e & 1)
x = (x*b)%m;
b = (b * b) % m;
e /= 2;
}
return x;
}
int main()
{
precalcPrimes();
ll t, n, q, r;
scanf("%lld", &t);
while (t--)
{
scanf("%lld %lld %lld", &n, &m, &q);
 
ll k = 0;
for (ll i = 1; i <= n; i++)
co[i] = i, clr(track[i]);
while (k < sz(primes) && primes[k] <= n)
{
if (m % primes[k] == 0)
{
for (ll i = primes[k]; i <= n; i += primes[k])
{
ll tmp = co[i], cnt = 0;
while (tmp % primes[k] == 0)
{
tmp /= primes[k];
cnt++;
}
co[i] = tmp;
cnt *= i;
track[i][primes[k]] += cnt;
}
}
k++;
}
 
for (ll i = 2; i <= n; i++)
{
co[i] = power(co[i], i);
co[i] = (co[i - 1] * co[i]) % m;
 
for (it = track[i - 1].begin(); it != track[i - 1].end(); ++it)
track[i][it -> first] += it -> second;
}
while (q--)
{
scanf("%lld", &r);
 
ll ans = (co[r] * co[n - r]) % m;
ans = extEuclid(m, ans);
ans = (ans * co[n]) % m;
for (it = track[n].begin(); it != track[n].end(); ++it)
{
ll tmp = track[n][it -> first] - track[r][it -> first] - track[n - r][it -> first];
ans = (ans * power(it -> first, tmp)) % m;
}
printf("%lld\n", ans);
}
}
return 0;
}