#include <stdio.h>

#define DEBUG 0
#define NMAX 111111
#define VMAX 33333
#define PMAX 4000
#define SMAX 30

char is_not_prime[VMAX];
int p[PMAX], np;

void Sieve() {
	int i, j;
	for (np = 0, i = 2; i < VMAX; i++) {
		if (is_not_prime[i]) continue;
		p[np++] = i;
		for (j = 2 * i; j < VMAX; j += i)
			is_not_prime[j] = 1;
	}
}

int pm[SMAX][3], npm;

void Decompose(int M) {
	int i;
	for (npm = i = 0; i < np; i++)
		if ((M % p[i]) == 0) {
			pm[npm][0] = p[i];
			pm[npm][1] = 1;
			pm[npm][2] = 0;
			while ((M % p[i]) == 0) {
				pm[npm][1] *= p[i];
				pm[npm][2]++;
				M /= p[i];
			}
			npm++;
		}
	if (M > 1) {
		pm[npm][0] = pm[npm][1] = M;
		pm[npm][2] = 1;
		npm++;
	}
}

int mod;

inline int RaiseToPowLL(int x, int y) {
	if (y == 0) return 1;
	int r = RaiseToPowLL(x, y >> 1);
	r = ((long long) r * (long long) r) % mod;
	if (y & 1) r = ((long long) r * (long long) x) % mod;
	return r;
}

inline int RaiseToPowInt(int x, int y) {
	if (y == 0) return 1;
	int r = RaiseToPowInt(x, y >> 1);
	r = (r * r) % mod;
	if (y & 1) r = (r * x) % mod;
	return r;
}

int RaiseToPow(int x, int y) {
	if (mod <= 40000) return RaiseToPowInt(x, y);
	return RaiseToPowLL(x, y);
}

int ExtendedGCD(int A, int B, int &X, int &Y) {
	if (B == 0) {
		X = 1;
		Y = 0;
		return A;
	}
	int X0, Y0, D;
	D = ExtendedGCD(B, A % B, X0, Y0);
	X = Y0;
	Y = X0 - (A / B) * Y0;
	return D;
}

int f[SMAX][NMAX], fm[NMAX];
long long pcnt[SMAX][NMAX], ppow[NMAX];

void Precompute(int N) {
	int i, j, k, x, y, garbage, lcm, limit = N / 2;
	for (i = 0; i < npm; i++) {
		ppow[0] = 1;
		for (j = 1; j < pm[i][2]; j++)
			ppow[j] = ppow[j - 1] * pm[i][0];
		mod = pm[i][1];
		f[i][0] = 1;
		pcnt[i][0] = 0;
		for (j = 1; j <= limit; j++) {
			f[i][j] = f[i][j - 1];
			pcnt[i][j] = pcnt[i][j - 1];
			x = N - j + 1;
			while ((x % pm[i][0]) == 0) {
				pcnt[i][j] += (N - j + 1);
				x /= pm[i][0];
			}
			x %= pm[i][1];
			if (x > 1) f[i][j] = ((long long) f[i][j] * (long long) RaiseToPow(x, N - j + 1)) % pm[i][1];
			if (DEBUG) fprintf(stderr, " A: x=%d exp=%d => %d\n", x, N - j + 1, f[i][j]);
			x = j;
			while ((x % pm[i][0]) == 0) {
				pcnt[i][j] -= j;
				x /= pm[i][0];
			}
			// Modular inverse of x.
			x %= pm[i][1];
			if (x > 1) {
				ExtendedGCD(x, pm[i][1], y, garbage);
				y %= pm[i][1];
				while (y < 0) y += pm[i][1];
				f[i][j] = ((long long) f[i][j] * (long long) RaiseToPow(y, j)) % pm[i][1];
			}
			if (DEBUG) fprintf(stderr, " B: inverse(x=%d,ppow=%d)=%d => \n", x, pm[i][1], y, f[i][j]);
			if (DEBUG) fprintf(stderr, "i=%d (prime=%d ppow=%d) j=%d: %d %lld\n", i, pm[i][0], pm[i][1], j, f[i][j], pcnt[i][j]);
		}
		for (j = 1; j <= limit; j++) {
			if (pcnt[i][j] >= pm[i][2])
				f[i][j] = 0;
			else
				f[i][j] = ((long long) f[i][j] * ppow[pcnt[i][j]]) % pm[i][1];
			if (DEBUG) fprintf(stderr, "i=%d pm=%d j=%d: %d\n",i, pm[i][1], j, f[i][j]);
		}
	}
	for (j = 0; j <= limit; j++) {
		// Chinese Remainder Theorem.
		fm[j] = f[0][j]; lcm = pm[0][1];
		for (i = 1; i < npm; i++) {
			x = (f[i][j] - (fm[j] % pm[i][1]));
			if (x < 0) x += pm[i][1];
			ExtendedGCD(lcm % pm[i][1], pm[i][1], y, garbage);
			y %= pm[i][1];
			while (y < 0) y += pm[i][1];
			k = ((long long) y * (long long) x) % pm[i][1];
			fm[j] += k * lcm;
			lcm *= pm[i][1];
		}
	}
	for (j = N; j > limit; j--)
		fm[j] = fm[N - j];
}

int main() {
	//freopen("y.txt", "r", stdin);
	Sieve();
	int T, N, M, Q, r;
	scanf("%d", &T);
	while (T--) {
		scanf("%d %d", &N, &M);
		Decompose(M);
		Precompute(N);
		scanf("%d", &Q);
		while (Q--) {
			scanf("%d", &r);
			printf("%d\n", fm[r]);
		}
	}
	return 0;
}
