#include<bits/stdc++.h>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
using namespace std;
typedef long long ll;
typedef pair < int , int > pii;
const int MAX = 1e5+5;
const ll INF = 1e9+9;
const ll MOD = 1000000007;

int all[MAX];

struct info{ 
	int _2, _3, _5; 
	info(){}
	info( int a, int b, int c ){
		_2 = a;
		_3 = b;
		_5 = c;
	}
};

struct segtree{
	int start, end;
	segtree *left, *right;
	info value;
	
	segtree( int start, int end ){
		this -> start = start;
		this -> end = end;
		value = info(0,0,0);
		if( start == end ){
			left = right = NULL;
			return ;
		}
		int mid = ( start+end )/2;
		left = new segtree( start, mid );
		right = new segtree( mid+1, end );
	}
	
	void update( int from, int to, int t, int v ){
		if( start == from && end == to ){
			if( t == 2 )
				value._2+= v;
			if( t == 3 )
				value._3+= v;
			if( t == 5 )
				value._5+= v;
			return ;
		}
		int mid = ( start+end )/2;
		
		if( value._2 > 0  ){
			left -> update(start,mid,2,value._2);
			right -> update(mid+1,end,2,value._2);
			value._2 = 0;
		}
		if( value._3 > 0  ){
			left -> update(start,mid,3,value._3);
			right -> update(mid+1,end,3,value._3);
			value._3 = 0;
		}
		if( value._5 > 0  ){
			left -> update(start,mid,5,value._5);
			right -> update(mid+1,end,5,value._5);
			value._5 = 0;
		}
		
		if( to <= mid ) left -> update(from,to,t,v);
		else if( from > mid ) right -> update(from,to,t,v);
		else{
			left -> update(from,mid,t,v);
			right -> update(mid+1,to,t,v);
		}
	}
	
	void clear( int node ){
		if( start == end && end == node ){
			value = info(0,0,0);
			return ;
		}
		int mid = ( start+end )/2;
		
		if( value._2 > 0  ){
			left -> update(start,mid,2,value._2);
			right -> update(mid+1,end,2,value._2);
			value._2 = 0;
		}
		if( value._3 > 0  ){
			left -> update(start,mid,3,value._3);
			right -> update(mid+1,end,3,value._3);
			value._3 = 0;
		}
		if( value._5 > 0  ){
			left -> update(start,mid,5,value._5);
			right -> update(mid+1,end,5,value._5);
			value._5 = 0;
		}
		
		if( node <= mid ) left -> clear(node);
		else right -> clear(node);
	}
	
	info query( int node ){
		if( start == end && end == node ) return value;
		int mid = ( start+end )/2;
		
		if( value._2 > 0  ){
			left -> update(start,mid,2,value._2);
			right -> update(mid+1,end,2,value._2);
			value._2 = 0;
		}
		if( value._3 > 0  ){
			left -> update(start,mid,3,value._3);
			right -> update(mid+1,end,3,value._3);
			value._3 = 0;
		}
		if( value._5 > 0  ){
			left -> update(start,mid,5,value._5);
			right -> update(mid+1,end,5,value._5);
			value._5 = 0;
		}
		
		if( node <= mid ) return left -> query(node);
		return right -> query(node);
	}
};

int main(){
	int n;
	cin >> n;
	for( int i = 0 ; i < n ;i++ )
		cin >> all[i];
	int q, a ,c, d, e;
	cin >> q;
	segtree st(1,n);
	int r;
	info aux;
	while( q-- ){
		cin >> a;
		if( a == 1 ){
			cin >> c >> d >> e;
			st.update(c,d,e,1);
		}
		else{
			cin >> c >> d;
			st.clear(c);
			all[c-1] = d;
		}
	}
	for( int i = 0 ; i < n ;i++ ){
		aux = st.query(i+1);
		while( aux._2-- && all[i]%2 == 0 ) all[i] /= 2;
		while( aux._3-- && all[i]%3 == 0 ) all[i] /= 3;
		while( aux._5-- && all[i]%5 == 0 ) all[i] /= 5;
		
		//r = all[i]/aux;
		if( i ) cout << " ";
		cout << all[i];
	}
	cout << endl;
	
    return 0;
}