#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
#define N 100010
#define gc getchar_unlocked
#define ll long long

int a[4*N];
int b[4*N];
int c[4*N];
int twos[N];
int threes[N];
int fives[N];
int encode[N];
ll base[N];

inline ll in()
{
char temp;
	ll x=0;
	temp=gc();
	while(temp<48)temp=gc();
	x+=(temp-'0');
	temp=gc();
	while(temp>=48){
		x=x*10;
		x+=(temp-'0');
		temp=gc();
	}
	return x;
}

void build_tree(int idx,int lo,int hi)
{
	if(lo==hi)
	{
		a[idx]=0;
		b[idx]=0;
		c[idx]=0;
		encode[lo]=idx;
		return ;
	}
	int mid=(lo+hi)/2;
	build_tree(2*idx,lo,mid);
	build_tree(2*idx+1,mid+1,hi);
	a[idx]=b[idx]=c[idx]=0;
	return ;
}

void query12(int idx,int lo,int hi,int l,int r)
{
	if(lo>=l && hi<=r)
	{
		a[idx]++;
		return ;
	}
	else if(lo>r || hi<l)
		return ;
	else 
	{
		int mid=(lo+hi)/2;
		query12(2*idx,lo,mid,l,r);
		query12(2*idx+1,mid+1,hi,l,r);
		return ;
	}
}

void query13(int idx,int lo,int hi,int l,int r)
{
	if(lo>=l && hi<=r)
	{
		b[idx]++;
		return ;
	}
	else if(lo>r || hi<l)
		return ;
	else 
	{
		int mid=(lo+hi)/2;
		query13(2*idx,lo,mid,l,r);
		query13(2*idx+1,mid+1,hi,l,r);
		return ;
	}
}

void query15(int idx,int lo,int hi,int l,int r)
{
	if(lo>=l && hi<=r)
	{
		c[idx]++;
		return ;
	}
	else if(lo>r || hi<l)
		return ;
	else 
	{
		int mid=(lo+hi)/2;
		query15(2*idx,lo,mid,l,r);
		query15(2*idx+1,mid+1,hi,l,r);
		return ;
	}
}

void query2(int idx,int lo,int hi,int l,int d)
{
	if(lo==hi)
	{
		a[idx]=0;
		b[idx]=0;
		c[idx]=0;
		base[l]=d;
		twos[l]=threes[l]=fives[l]=0;
		while(!(base[l]%2))
		{
			base[l]/=2;
			twos[l]++;
		}
		while(!(base[l]%3))
		{
			base[l]/=3;
			threes[l]++;
		}
		while(!(base[l]%5))
		{
			base[l]/=5;
			fives[l]++;
		}
		return ;
	}
	int le=2*idx;
	int ri=2*idx+1;
	int mid=(lo+hi)/2;
	a[le]+=a[idx];
	a[ri]+=a[idx];
	b[le]+=b[idx];
	b[ri]+=b[idx];
	c[le]+=c[idx];
	c[ri]+=c[idx];
	a[idx]=b[idx]=c[idx]=0;
	if(l<=mid)
		query2(le,lo,mid,l,d);
	else
		query2(ri,mid+1,hi,l,d);
	return ;
}

void lazy_prop(int idx,int lo,int hi)
{
	if(lo==hi)
		return ;
	int le=2*idx;
	int ri=2*idx+1;
	int mid=(lo+hi)/2;
	a[le]+=a[idx];
	a[ri]+=a[idx];
	b[le]+=b[idx];
	b[ri]+=b[idx];
	c[le]+=c[idx];
	c[ri]+=c[idx];
	lazy_prop(le,lo,mid);
	lazy_prop(ri,mid+1,hi);
	return ;
}

int main()
{
	int n;
	int m;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		base[i]=in();
	for(int i=0;i<n;i++)
	{
		while(!(base[i]%2))
		{
			base[i]/=2;
			twos[i]++;
		}
		while(!(base[i]%3))
		{
			base[i]/=3;
			threes[i]++;
		}
		while(!(base[i]%5))
		{
			base[i]/=5;
			fives[i]++;
		}
	}	
	build_tree(1,0,n-1);
	scanf("%d",&m);
	for(int i=0;i<m;i++)
	{
		int q;
		scanf("%d",&q);
		if(q==1)
		{
			int l,r,p;
			scanf("%d%d%d",&l,&r,&p);
			if(p==2)
				query12(1,0,n-1,l-1,r-1);
			else if(p==3)
				query13(1,0,n-1,l-1,r-1);
			else
				query15(1,0,n-1,l-1,r-1);
		}
		else
		{
			int l,d;
			scanf("%d%d",&l,&d);
			query2(1,0,n-1,l-1,d);
		}
	}
	lazy_prop(1,0,n-1);
	for(int i=0;i<n;i++)
	{
//		printf("%lld ",encode[i]);
		ll sum=base[i];
		for(int j=0;j<(twos[i]-a[encode[i]]);j++)
			sum*=2;
		for(int j=0;j<(threes[i]-b[encode[i]]);j++)
			sum*=3;
		for(int j=0;j<(fives[i]-c[encode[i]]);j++)
			sum*=5;
		printf("%lld ",sum);
	}
	return 0;
}