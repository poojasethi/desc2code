#include <bits/stdc++.h>
#include <tr1/unordered_map>

using namespace std;
using namespace tr1;
 
#ifdef _WIN32  
    #define getchar_unlocked getchar 
    #define putchar_unlocked putchar 
#endif 
   
inline void read( int &n ) { 
    n = 0; 
    register bool neg = false; 
    register char c = getchar_unlocked(); 
    if( c == EOF) { n = -1; return; } 
    while (!('0' <= c && c <= '9')) { 
        if( c == '-' ) neg = true; 
        c = getchar_unlocked(); 
    } 
    while ('0' <= c && c <= '9') { 
        n = n * 10 + c - '0'; 
        c = getchar_unlocked(); 
    } 
    n = (neg ? (-n) : (n)); 
} 
   
inline void writeInt(long long n){ 
    register int idx = 20; 
    if( n < 0 ) putchar_unlocked('-'); 
    n = abs(n); 
    char out[21]; 
    out[20] = ' '; 
    do{ 
        idx--; 
        out[idx] = n % 10 + '0'; 
        n/= 10; 
    }while(n); 
    do{ putchar_unlocked(out[idx++]); } while (out[idx] != ' '); 
}

int vet[100001];
bitset < 1000012 > bs;
vector < int >  primes;
struct tri{
	int a, b, c, lazy_a, lazy_b, lazy_c, flag;
	tri( int a = 0, int b = 0, int c = 0, int lazy_a = 0, int lazy_b = 0, int lazy_c = 0, int flag = 0 ) :
	a(a), b(b), c(c), lazy_a(lazy_a), lazy_b(lazy_b), lazy_c(lazy_c) { }
};

tri tree[1<<20];

void push( int at, int lo, int hi ){
	int i = (at << 1) + 1;
	int j = i + 1;
	if( lo != hi ){
		if( tree[at].lazy_a ){
			tree[i].lazy_a += tree[at].lazy_a;
			tree[j].lazy_a += tree[at].lazy_a;
		}
		if( tree[at].lazy_b ){
			tree[i].lazy_b += tree[at].lazy_b;
			tree[j].lazy_b += tree[at].lazy_b;
		}
		if( tree[at].lazy_c ){
			tree[i].lazy_c += tree[at].lazy_c;
			tree[j].lazy_c += tree[at].lazy_c;
		}
	}
	else{
		tree[at].a += tree[at].lazy_a;
		tree[at].b += tree[at].lazy_b;
		tree[at].c += tree[at].lazy_c;
	}
	tree[at].lazy_a = tree[at].lazy_b = tree[at].lazy_c = 0;
}

void build( int at, int lo, int hi ){
	tree[at] = tri();
	tree[at].flag = 1;
	if( lo == hi ) return ;
	int i = (at << 1) + 1;
	int j = i + 1;
	int mid =  (lo+hi) >> 1;
	build(i, lo, mid);
	build(j, mid+1, hi);
}

void update( int at, int lo, int hi, int x, int y, int add[] ){
	int i = (at << 1) + 1;
	int j = i + 1;
	int mid = (lo + hi) >> 1;
	if( x <= lo && hi <= y ){
		tree[at].lazy_a += add[0];
		tree[at].lazy_b += add[1];
		tree[at].lazy_c += add[2];
		push(at, lo, hi);
		return ;
	}
	push(at, lo, hi);
	if( mid >= x ) update(i, lo, mid, x, y, add);
	if( (mid+1) <= y ) update(j, mid+1, hi, x, y, add);
}

void update( int at, int lo, int hi, int x ){
	int i = (at << 1) + 1;
	int j = i + 1;
	int mid = ( lo + hi ) >> 1;
	if( lo == hi ){
		tree[at] = tri();
		tree[at].flag = 1;
		return;
	}
	push(at, lo, hi);
	if( mid >= x ) update(i, lo, mid, x);
	else update(j, mid+1, hi, x);
}

tri query( int at, int lo, int hi, int x ){
	int i = (at << 1) + 1;
	int j = i + 1;
	int mid = ( lo + hi ) >> 1;
	push(at, lo, hi);
	if( lo == hi ) return tree[at];
	if( mid >= x ) return query(i, lo, mid, x);
	else return query(j, mid+1, hi, x);
}

void sieve( long long upperbound ){
    long long _sieve_size = upperbound + 1;
    bs[0] = bs[1] = 1;
    for( long long i = 2; i <= _sieve_size; i++ ){
        if( !bs[i] ){
            for( long long j = i * i; j <= _sieve_size; j += i ) bs[j] = 1;
            primes.push_back((int)i);
        }
    }
}

unordered_map < int, int > fator;
unordered_map < int, int > :: iterator it;

void primeFactors( long long N ){
  fator.clear();
  long long PF_idx = 0, PF = primes[PF_idx];
  while( N != 1 && (PF * PF <= N)){
    while( N % PF == 0){ N /= PF; fator[PF]++;}
    PF = primes[++PF_idx];
  }
  if( N != 1 ) fator[N]++;
}

int fastPow(int base, int p){
    if(p == 0) return 1;
    else if(p == 1) return base;
    int res = fastPow(base, p >> 1);
    res *= res;
    if(p % 2 == 1) res *= base;
    return res;
}

int getAns( int idx, int n ){
	tri ans = query(0, 1, n, idx+1);
	primeFactors(vet[idx]);
	fator[2] -= ans.a;
	fator[3] -= ans.b;
	fator[5] -= ans.c;
	
	it = fator.begin();
	int resp = 1;
	while( it != fator.end() ){
		if( it->second >= 0 ) resp *= fastPow(it->first,it->second);
		it++;
	}

	return resp;
}

int main(){
	ios::sync_with_stdio(false);
	int n, q, op, lo, hi, fat;
	int idx[7];
	idx[2] = 0; idx[3] = 1; idx[5] = 2;
	read(n);
	for( int i = 0; i < n; i++ ) read(vet[i]);
	build(0, 1, n);
	sieve(1000001);
	read(q);
	while( q-- ){
		read(op);
		if( op == 1 ){
			read(lo);
			read(hi);
			read(fat);
			int val[] = {0,0,0};
			val[idx[fat]]++;
			update(0, 1, n, lo, hi, val);
		}
		else{
			read(lo);
			read(vet[lo-1]);
			update(0, 1, n, lo);
		}
	}
	for( int i = 0; i < n; i++ ){
		if( i ) putchar_unlocked(' ');
		writeInt(getAns(i,n));
	}
	putchar_unlocked('\n');
	return 0;
}