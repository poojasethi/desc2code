#include<bits/stdc++.h>
using namespace std;
#define ll long long int
#define lf long double
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define inf INT_MAX
#define linf LONG_LONG_MAX
#define ppi pair<int,int>
#define ppl pair<int,int>
#define F   first
#define S   second
#define s(n)                        scanf("%d",&n)
#define sc(n)                       scanf("%c",&n)
#define sl(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)
#define ss(n)                       scanf("%s",n)
ll A[100010];
ll tree[400100],lazy[400100][3];
void build_tree(int index, int a, int b)
{
  	if(a > b)
        return;
  	if(a == b)
  	{
        tree[index]=A[a]; //initial value here
        lazy[index][0]=0;
        lazy[index][1]=0;
        lazy[index][2]=0;
		return;
	}
	build_tree(index*2, a, (a+b)/2);
	build_tree(index*2+1,1+(a+b)/2, b);
	tree[index]=0; //insert property here;
	lazy[index][0]=0;
    lazy[index][1]=0;
    lazy[index][2]=0;
		
}
ll divide(ll a,ll b,ll c)
{
	while(a>1&&a%c==0&&b>0)
	{
		a=a/c;
		b--;
	}
	return a;
}
void update_tree(int index, int a, int b, int i, int j, int val,int act)
{
  	if(lazy[index][0]!=0) {
  		tree[index]=(tree[index]%2==0)?divide(tree[index],lazy[index][0],2):tree[index];
    if(a!=b)
    {
        lazy[2*index][0]+=lazy[index][0] ;          //notify its left child
        lazy[2*index+1][0]+=lazy[index][0];         //notify its right child
    }
    lazy[index][0]=0;
		}
		if(lazy[index][1]!=0) {
			tree[index]=(tree[index]%3==0)?divide(tree[index],lazy[index][1],3):tree[index];
    if(a!=b)
    {
        lazy[2*index][1]+=lazy[index][1] ;          //notify its left child
        lazy[2*index+1][1]+=lazy[index][1];         //notify its right child
    }
    lazy[index][1]=0;
		}
		if(lazy[index][2]!=0) {
			tree[index]=(tree[index]%5==0)?divide(tree[index],lazy[index][2],5):tree[index];
    if(a!=b)
    {
        lazy[2*index][2]+=lazy[index][2] ;          //notify its left child
        lazy[2*index+1][2]+=lazy[index][2];         //notify its right child
    }
    lazy[index][2]=0;
		}
	if(a > b || a > j || b < i)      // Current segment is not within range [i, j]
		return;
  	if(a >= i && b <= j) { 
  		tree[index]=(tree[index]%act==0)?tree[index]/act:tree[index];
     	if(a != b) {  //not a leaf notify its child
                
        lazy[2*index][val]+=1;   //left child
        lazy[2*index+1][val]+=1;  //right child
    }
    	return;
	}
	update_tree(index*2, a, (a+b)/2, i, j, val,act);
	update_tree(1+index*2, 1+(a+b)/2, b, i, j,val,act);
}
void update_tree2(int index, int a, int b, int i, int j, int val)
{
  	if(lazy[index][0]!=0) {
  		tree[index]=(tree[index]%2==0)?divide(tree[index],lazy[index][0],2):tree[index];
    if(a!=b)
    {
        lazy[2*index][0]+=lazy[index][0] ;          //notify its left child
        lazy[2*index+1][0]+=lazy[index][0];         //notify its right child
    }
    lazy[index][0]=0;
		}
		if(lazy[index][1]!=0) {
			tree[index]=(tree[index]%3==0)?divide(tree[index],lazy[index][1],3):tree[index];
    if(a!=b)
    {
        lazy[2*index][1]+=lazy[index][1] ;          //notify its left child
        lazy[2*index+1][1]+=lazy[index][1];         //notify its right child
    }
    lazy[index][1]=0;
		}
		if(lazy[index][2]!=0) {
			tree[index]=(tree[index]%5==0)?divide(tree[index],lazy[index][2],5):tree[index];
    if(a!=b)
    {
        lazy[2*index][2]+=lazy[index][2] ;          //notify its left child
        lazy[2*index+1][2]+=lazy[index][2];         //notify its right child
    }
    lazy[index][2]=0;
		}
	if(a > b || a > j || b < i)      // Current segment is not within range [i, j]
		return;
  	if(a >= i && b <= j) { 
  		tree[index]=val;
     		lazy[index][0]=lazy[index][1]=lazy[index][2]=0;
    	return;
	}
	update_tree2(index*2, a, (a+b)/2, i, j, val);
	update_tree2(1+index*2, 1+(a+b)/2, b, i, j,val);
}
ll query_tree(int index, int a, int b, int i, int j)
{
	if(a > b || a > j || b < i)
        return  0;//value according to property
  	if(lazy[index][0]!=0) {
  		tree[index]=(tree[index]%2==0)?divide(tree[index],lazy[index][0],2):tree[index];
    if(a!=b)
    {
        lazy[2*index][0]+=lazy[index][0] ;          //notify its left child
        lazy[2*index+1][0]+=lazy[index][0];         //notify its right child
    }
    lazy[index][0]=0;
		}
		if(lazy[index][1]!=0) {
			tree[index]=(tree[index]%3==0)?divide(tree[index],lazy[index][1],3):tree[index];
    if(a!=b)
    {
        lazy[2*index][1]+=lazy[index][1] ;          //notify its left child
        lazy[2*index+1][1]+=lazy[index][1];         //notify its right child
    }
    lazy[index][1]=0;
		}
		if(lazy[index][2]!=0) {
			tree[index]=(tree[index]%5==0)?divide(tree[index],lazy[index][2],5):tree[index];
    if(a!=b)
    {
        lazy[2*index][2]+=lazy[index][2] ;          //notify its left child
        lazy[2*index+1][2]+=lazy[index][2];         //notify its right child
    }
    lazy[index][2]=0;
		}
		if(a >= i && b <= j)
			return tree[index];
	ll q1=query_tree(index*2, a, (a+b)/2, i, j);
	ll q2=query_tree(1+index*2, 1+(a+b)/2, b, i, j);
	q1=q1+q2;  //return according to property
	return q1;
}
int main()
{
	int n,s,m,ans,a,b,i;
	ll val,c;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	{
		scanf("%lld",&A[i]);
	}
	build_tree(1,0,n-1);
	scanf("%d",&m);
	for(i=0;i<m;i++)
	{
		scanf("%d %d %lld",&a,&b,&c);
		if(a==1)
		{
			scanf("%lld",&val);
			if(val==2)
				s=0;
			else if(val==3)
				s=1;
			else
				s=2;
			update_tree(1,0,n-1,b-1,c-1,s,val);
		}
		else
		{
			update_tree2(1,0,n-1,b-1,b-1,c);
		}
	}
	for(i=0;i<n;i++)
	{
		ans=query_tree(1,0,n-1,i,i);
		printf("%d ",ans);
	}
}