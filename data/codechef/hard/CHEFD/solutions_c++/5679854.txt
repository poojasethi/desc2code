#include <iostream>
#include <cassert>
#include <algorithm>
#include <cstdio>
using namespace std;
 
int MAX=100001;
int MIN=-1;
class node
{
	public:
	int two,three,five,lazy;
	int l2,l3,l5;
}tree[300001];

node newnode(int p)
{
	node aa;
	aa.two=0;
	aa.three=0;
	aa.five=0;
	aa.lazy=0;
	aa.l2=0;
	aa.l3=0;
	aa.l5=0;
	if (p==2) 
	{
		aa.l2=1;
		aa.lazy=1;
	}
	else if (p==3) 
	{
		aa.l3=1;
		aa.lazy=1;
	}
	else if (p==5) 
	{
		aa.l5=1;
		aa.lazy=1;
	}
	return aa;
} 
node f(node left,node right)
{
/*
Function specific to the problem .
*/
	node aa;
	aa.five=left.five+right.five;
	aa.two=left.two+right.two;
	aa.three=left.three+right.three;
	aa.lazy=0;
	aa.l2=0;
	aa.l3=0;
	aa.l5=0;
	return aa;
}
 
node maketree(int a[],int index,int low,int high)
{
/*
Initialziation of a tree
index=Current x
[low high]=current range
*/
	assert(high>=low);
	if (low==high)
	{
		tree[index].five=0;
		tree[index].two=0;
		tree[index].three=0;
		tree[index].lazy=0;
		tree[index].l2=0;
		tree[index].l3=0;
		tree[index].l5=0;
		return tree[index];
	}
	else
	{
		int mid=(low+high)/2;
		node left=maketree(a,2*index+1,low,mid);
		node right=maketree(a,2*index+2,mid+1,high);
		tree[index]=f(left,right);
		return tree[index];
	}
}
 
int divide(int a,int p,int c)
{
//	cout<<a<<" "<<p<<" "<<c<<endl;
	while (p && a%c==0)
	{
		a/=c;
		p--;
	}
	return a;
}
node updatenode(node n,node temp)
{
	node aa;
	aa.two=n.two+temp.l2;
	aa.three=n.three+temp.l3;
	aa.five=n.five+temp.l5;
	aa.l2=0;
	aa.l3=0;
	aa.l5=0;
	aa.lazy=0;
	return aa;
}
void updatefinal(int a[],int index,int low,int high)
{
/*
Initialziation of a tree
index=Current x
[low high]=current range
*/
	assert(high>=low);
	if (low==high)
	{
	//	cout<<" "<<low<<" "<<a[low]<<" "<<tree[index].two<<" "<<tree[index].three<<" "<<tree[index].five<<" ";
	//	cout<<tree[index].l2<<" "<<tree[index].l3<<" "<<tree[index].l5<<" ";
		a[low]=divide(a[low],tree[index].two+tree[index].l2,2);
		a[low]=divide(a[low],tree[index].three+tree[index].l3,3);
		a[low]=divide(a[low],tree[index].five+tree[index].l5,5);
	//	cout<<a[low]<<endl;	
	}
	else
	{
		if (tree[index].lazy!=0)
		{
			node temp=tree[index];
			tree[index]=updatenode(tree[index],temp);	
			
			tree[2*index+1].lazy+=temp.lazy;
			tree[2*index+1].l2+=temp.l2;
			tree[2*index+1].l3+=temp.l3;
			tree[2*index+1].l5+=temp.l5;
			
			tree[2*index+2].lazy+=temp.lazy;
			tree[2*index+2].l2+=temp.l2;
			tree[2*index+2].l3+=temp.l3;
			tree[2*index+2].l5+=temp.l5;
					
		}
		int mid=(low+high)/2;
		updatefinal(a,2*index+1,low,mid);
		updatefinal(a,2*index+2,mid+1,high);
		return ;
	}
}


void updatetree(int index,int low,int high,int x,int y,int p)
{
/*
To update the node in a tree. Node at index x in updated to newvalue from oldvalue.
index=Current x
[low high]=current range
*/
	assert(high>=low);
 
	if (tree[index].lazy!=0)
	{
		node temp=tree[index];
		tree[index]=updatenode(tree[index],temp);
		if (low!=high)
		{
			tree[2*index+1].lazy+=temp.lazy;
			tree[2*index+1].l2+=temp.l2;
			tree[2*index+1].l3+=temp.l3;
			tree[2*index+1].l5+=temp.l5;
			
			tree[2*index+2].lazy+=temp.lazy;
			tree[2*index+2].l2+=temp.l2;
			tree[2*index+2].l3+=temp.l3;
			tree[2*index+2].l5+=temp.l5;
			
		}
	}
 
	if (y < low || high < x)
	{
		return;
	}
 
	if (low>=x&&high<=y)  //completely in range
	{
		node temp=newnode(p);
		tree[index]=updatenode(tree[index],temp);
		if (low!=high)
		{
			tree[2*index+1].lazy+=temp.lazy;
			tree[2*index+1].l2+=temp.l2;
			tree[2*index+1].l3+=temp.l3;
			tree[2*index+1].l5+=temp.l5;
			
			tree[2*index+2].lazy+=temp.lazy;
			tree[2*index+2].l2+=temp.l2;
			tree[2*index+2].l3+=temp.l3;
			tree[2*index+2].l5+=temp.l5;	
		}
		return ;
	}
	else
	{
		int mid=(low+high)/2;
 
		updatetree(2*index+1,low,mid,x,y,p);
		updatetree(2*index+2,mid+1,high,x,y,p);
		tree[index]=f(tree[2*index+1],tree[2*index+2]);
 
		return;
	}
}
 
void searchtree(int a[],int low,int high,int x,int y,int index)
{
/*
To search in a segment tree in the range [x-y], while the current range is [low-high] and the current index index.
*/
 
	if (tree[index].lazy!=0)
	{
		node temp=tree[index];
		tree[index]=updatenode(tree[index],temp);
		if (low!=high)
		{
			tree[2*index+1].lazy+=temp.lazy;
			tree[2*index+1].l2+=temp.l2;
			tree[2*index+1].l3+=temp.l3;
			tree[2*index+1].l5+=temp.l5;
			
			tree[2*index+2].lazy+=temp.lazy;
			tree[2*index+2].l2+=temp.l2;
			tree[2*index+2].l3+=temp.l3;
			tree[2*index+2].l5+=temp.l5;
			
		}
	}
 
	if (low==x && high==x)
	{
		tree[index]=newnode(0);
		a[low]=y;
	}
	else
	{
		int mid=(low+high)/2;
		if (mid>=x)
		{
			searchtree(a,low,mid,x,y,2*index+1);
		}
		else if (mid<x)
		{
			searchtree(a,mid+1,high,x,y,2*index+2);
		}
		else
		{
			searchtree(a,low,mid,x,y,2*index+1);
			searchtree(a,mid+1,high,x,y,2*index+2);
			//return f(left,right);;
		}
	}
}
inline void readint(int &a)
{
    register int c;
    a = 0;
    do c = getchar_unlocked(); while(c < '0');
    do{
    a = (a << 1) + (a << 3) + c - '0';
    c = getchar_unlocked();
    }while(c >= '0');
}
     
inline void printint(int a)
{
    char s[11];
    int t = -1;
    do{
    s[++t] = a % 10 + '0';
    a /= 10;
    }while(a > 0);
    while(t >= 0)putchar_unlocked(s[t--]);
    putchar_unlocked(' ');
}
 
int main()
{
	int a[MAX];
	node temp;
	int i,n,m,x,y,p;
	int t,tt;
	readint(n);
	for (i=0;i<n;i++) readint(a[i]);
//		for (i=0;i<n;i++) printint(a[i]);	
    readint(m);
	maketree(a,0,0,n-1);
	while (m--)
	{
		readint(t);
	    readint(x);
	    readint(y);
		if (t==2)
		{
			x--;
			searchtree(a,0,n-1,x,y,0);
		}
		else
		{
			x--;
			y--;
			readint(p);
	//		cout<<"LOL"<<endl;
			updatetree(0,0,n-1,x,y,p);
	//		a[x]=y;
		}
	}
	updatefinal(a,0,0,n-1);
	for (i=0;i<n;i++) printint(a[i]);		
	return 0;
} 
