#include <iostream>
#include <stdio.h>
#include <fstream>
#include <string.h>

#include <string>
#include <vector>
#include <map>
#include <set>
#include <list>
#include <set>
#include <deque>
#include <utility>
#include <sstream>
#include <queue>
#include <stack>
#include <bitset>

#include <math.h>
#include <iomanip>
#include <algorithm>
#include <limits.h>

#define MP make_pair
#define MT make_tuple
#define PB push_back
#define FI first
#define SE second
#define INPUT "/Users/manuelalejandrovergaradiaz/Documents/Manu/Programation/Programation/Programation/autocomplete.txt"
#define OUTPUT "/Users/manuelalejandrovergaradiaz/Documents/Manu/Programation/Programation/Programation/output"
#define FILE 0

#define MAX (1<<20)
#define MAXN 1000
#define INF -1
#define EPS 0.0000001
#define MOD 1000000007
#define PI acos(-1)
#define sbit(a) a&(-a)
#define gauss(a) a*(a+1)/2
#define Node pair<int, int>

typedef long long ll;

using namespace std;

struct SegTree {
    int start, end, value;
    int cnt[6];
    SegTree *left, *right;
    
    SegTree() {}
    SegTree(int start, int end) {
        this -> start = start;
        this -> end = end;
        cnt[2] = cnt[3] = cnt[5] = 0;
        if(start == end) left = right = NULL;
        else {
            int mid = (start + end) / 2;
            left = new SegTree(start, mid);
            right = new SegTree(mid+1, end);
        }
    }
    
    void update() {
        if(cnt[2]) {
            if(left != NULL && right != NULL) left -> cnt[2] += cnt[2], right -> cnt[2] += cnt[2], cnt[2] = 0;
        }
        if(cnt[3]) {
            if(left != NULL && right != NULL) left -> cnt[3] += cnt[3], right -> cnt[3] += cnt[3], cnt[3] = 0;
        }
        if(cnt[5]) {
            if(left != NULL && right != NULL) left -> cnt[5] += cnt[5], right -> cnt[5] += cnt[5], cnt[5] = 0;
        }
    }
    
    void set(int pos, int value) {
        update();
        if(start == end) {
            cnt[2] = cnt[3] = cnt[5] = 0;
            this -> value = value;
            return ;
        }
        int mid = (start + end) / 2;
        if(pos <= mid) left -> set(pos, value);
        else right -> set(pos, value);
    }
    
    void set2(int from, int to, int p) {
        update();
        if(start == from && end == to) {
            if(left != NULL && right != NULL) left -> cnt[p]++, right -> cnt[p]++;
            else cnt[p]++;
            return ;
        }
        int mid = (start + end) / 2;
        if(to <= mid) left -> set2(from, to, p);
        else if(from > mid) right -> set2(from, to, p);
        else left -> set2(from, mid, p), right -> set2(mid+1, to, p);
    }
    
    int get(int pos) {
        update();
        if(start == end) {
            while(cnt[2] && value%2 == 0) {
                value /= 2;
                cnt[2]--;
            }
            while(cnt[3] && value%3 == 0) {
                value /= 3;
                cnt[3]--;
            }
            while(cnt[5] && value%5 == 0) {
                value /= 5;
                cnt[5]--;
            }
            return value;
        }
        int mid = (start + end) / 2;
        if(pos <= mid) return left -> get(pos);
        else return right -> get(pos);
    }
    
};

int N, M, A, T, L, R, P, D;

int main() {
    
    if(FILE) {
        freopen(INPUT, "r", stdin);
        freopen(OUTPUT, "w", stdout);
    }
    
    scanf("%d", &N);
    SegTree st(1, N);
    for(int i = 1; i <= N; i++) scanf("%d", &A), st.set(i, A);
    scanf("%d", &M);
    for(int i = 1; i <= M; i++) {
        scanf("%d", &T);
        if(T == 1) scanf("%d %d %d", &L, &R, &P), st.set2(L, R, P);
        else scanf("%d %d", &L, &D), st.set(L, D);
    }
    
    for(int i = 1; i <= N; i++) {
        if(i > 1) printf(" ");
        printf("%d", st.get(i));
    }
    printf("\n");
    
    return 0;
}
