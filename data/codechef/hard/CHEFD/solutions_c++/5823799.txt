#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <algorithm>
using namespace std;

#define nln        puts("")                         ///prLLInewline
#define getLLI(a)  scanf("%d",&a);
#define max3(a,b,c) max(a,max(b,c))                  ///3 ta theke max
#define min3(a,b,c) min(a,min(b,c))                  ///3 ta theke min

#define FOR1(i,n)  for(LLI i=1;i<=n;i++)
#define FOR0(i,n)  for(LLI i=0;i<n;i++)                 ///looping
#define FORR(i,n)  for(LLI i=n-1;i>=0;i--)
#define ALL(p)     p.begin(),p.end()

#define SET(p)     memset(p,-1,sizeof(p))
#define CLR(p)     memset(p,0,sizeof(p))            ///memset
#define MEM(p,v)   memset(p,v,sizeof(p))

#define READ(f)    freopen(f, "r", stdin)           /// file
#define WRITE(f)   freopen(f, "w", stdout)

#define SZ(c)      (LLI)c.size()
#define PB(x)      push_back(x)                     ///STL defines
#define MP(x,y)    make_pair(x,y)
#define ff         first
#define ss         second

#define LI         long LLI
#define LLI        long long //LLI
#define f64        long double
#define PI         acos(-1.0)                        ///PI er value

LLI Set(LLI N,LLI pos)
{
    return N=N | (1<<pos);
}
LLI reset(LLI N,LLI pos)
{
    return N= N & ~(1<<pos);
}
bool check(LLI N,LLI pos)
{
    return (bool)(N & (1<<pos));
}
void CI(LLI &_x)
{
    scanf("%d",&_x);
}

void CO(LLI &_x)
{
    cout<<_x;
}

template<typename T> void getarray(T a[],LLI n)
{
    for(LLI i=0; i<n; i++) cin>>a[i];
}
template<typename T> void prLLIarray(T a[],LLI n)
{
    for(LLI i=0; i<n-1; i++) cout<<a[i]<<" ";
    cout<<a[n-1]<<endl;
}

const double EPS=1e-9;                              ///constatnts
const LLI INF=0x7f7f7f7f;

LLI dr8[8]= {1,-1,0,0,1,-1,-1,1};            ///8 direction move
LLI dc8[8]= {0,0,-1,1,1,1,-1,-1};
LLI dr4[4]= {0,0,1,-1};                      ///4 direction move
LLI dc4[4]= {-1,1,0,0};                      ///or adjacent dir.
LLI kn8r[8]= {1,2,2,1,-1,-2,-2,-1};          ///knight moves
LLI kn8c[8]= {2,1,-1,-2,-2,-1,1,2};
#define mx 1000005
struct sumit
{
    int two,three,five;

};
LLI arr[mx];
LLI tree[5*mx];
sumit prop[5*mx];
void init(LLI node,LLI b,LLI e)
{
    if(b==e)
    {
        tree[node]=arr[b];
        return;
    }

    LLI left=node*2;
    LLI right=left+1;
    LLI mid=(b+e)/2;
    init(left,b,mid);
    init(right,mid+1,e);
//	tree[node]=tree[left]+tree[right];

}
void update(LLI node,LLI b,LLI e,LLI i,LLI j,LLI x)
{
    if(j<b||i>e)
        return;
    if(b>=i&&e<=j)
    {

//        tree_value[node]=(e-b+1)*x;
//       cout<<"SSSSSSS "<<node<<"\n";
        if(x==2)

            prop[node].two+=1;
        else if(x==3)
            prop[node].three+=1;
        else
            prop[node].five+=1;

        return;
    }
    LLI left,right,mid;
    left=node<<1;
    right=(node<<1)+1;
    mid=(b+e)/2;

    if(prop[node].two!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].two+=prop[node].two;
        prop[right].two+=prop[node].two;
        prop[node].two=0;
    }

    if(prop[node].five!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].five+=prop[node].five;
        prop[right].five+=prop[node].five;
        prop[node].five=0;
    }
    if(prop[node].three!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].three+=prop[node].three;
        prop[right].three+=prop[node].three;
        prop[node].three=0;
    }
    update(left,b,mid,i,j,x);
    update(right,mid+1,e,i,j,x);
//    tree_value[node]=tree_value[left]+tree_value[right];

}
void update_query(LLI node,LLI b,LLI e,LLI inx,LLI val)
{
    if(inx>e||b>inx)
        return ;
    if(b>=inx&&e<=inx)
    {
//        cout<<"SSSSSS "<<node<<'\n';
        prop[node].two=0;
        prop[node].three=0;
        prop[node].five=0;
        tree[node]=val;
        return;
    }

    LLI left,right,mid;
    left=(node<<1);
    right=(node<<1)+1;
    mid=(b+e)/2;

    if(prop[node].two!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].two+=prop[node].two;
        prop[right].two+=prop[node].two;
        prop[node].two=0;
    }

    if(prop[node].five!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].five+=prop[node].five;
        prop[right].five+=prop[node].five;
        prop[node].five=0;
    }
    if(prop[node].three!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].three+=prop[node].three;
        prop[right].three+=prop[node].three;
        prop[node].three=0;
    }
    update_query(left,b,mid,inx,val);
    update_query(right,mid+1,e,inx,val);
//    return  p1+p2;

}
LLI gcd(LLI a,LLI b)
{
    if(b==0)
        return  a;
    return gcd(b,a%b);

}
LLI poww(int a,int b)
{

    LLI ans=1;
    for(int i=1; i<=b; i++)
        ans=ans*a;
    return ans;
}
LLI query(LLI node,LLI b,LLI e,LLI i,LLI j)
{
    if(i>e||b>j)
        return 0;
    if(b>=i&&e<=j)
    {
//        cout<<"PORN "<<node<<" "<<tree[node]<<" "<<prop[node].two<<" "<<prop[node].three<<" "<<prop[node].five<<"\n";
        int tt=0,th=0,fi=0;
        LLI temp=tree[node];
        while(temp%2==0)
            temp=temp/2,tt++;

        temp=tree[node];
        while(temp%3==0)
            temp=temp/3,th++;
        temp=tree[node];
        while(temp%5==0)
            temp=temp/5,fi++;

//            cout<<"PPP "<<tt<<" "<<th<<" "<<fi<<"\n";

        temp=tree[node];
        temp=temp/poww(2,min(tt,prop[node].two));
        temp=temp/poww(3,min(th,prop[node].three));
        temp=temp/poww(5,min(fi,prop[node].five));
        return temp;
    }

    LLI left,right,mid;
    left=(node<<1);
    right=(node<<1)+1;
    mid=(b+e)/2;

    if(prop[node].two!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].two+=prop[node].two;
        prop[right].two+=prop[node].two;
        prop[node].two=0;
    }

    if(prop[node].five!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].five+=prop[node].five;
        prop[right].five+=prop[node].five;
        prop[node].five=0;
    }
    if(prop[node].three!=0)
    {
//        tree_value[left]=(mid-b+1)*tree_prop[node];
//        tree_value[right]=(e-mid)*tree_prop[node];
        prop[left].three+=prop[node].three;
        prop[right].three+=prop[node].three;
        prop[node].three=0;
    }
    LLI p1=query(left,b,mid,i,j);
    LLI p2=query(right,mid+1,e,i,j);
    return  p1+p2;


}

int main()
{
//    READ("input.txt");
    // WRITE("output.txt");
    LLI n;
    cin>>n;
    for(LLI i=1; i<=n; i++)
        cin>>arr[i];
    LLI q;
    cin>>q;
    init(1,1,n);
    for(LLI i=1; i<5*mx; i++)
        prop[i].two=0,prop[i].three=0,prop[i].five=0;
//    memset(prop,1,sizeof prop);
//for(LLI i=1;i<=7;i++)
//    cout<<i<<" : "<<tree[i]<<"\n";
    while(q--)
    {

        LLI order;
        cin>>order;
        if(order==1)
        {
// cout<<"111111111111111111\n";
            LLI l,r,div;
            cin>>l>>r>>div;
            update(1,1,n,l,r,div);
//            puts("FFFFFFFFFFF : tree ");
//            for(LLI i=1; i<=7; i++)
//                cout<<i<<" : "<<tree[i]<<"\n";
//
//                puts("FFFFFFFFFFF : prop ");
//                            for(LLI i=1; i<=7; i++)
//                cout<<i<<" : "<<prop[i].two<<" "<<prop[i].three<<" "<<prop[i].five<<"\n";

        }
        else
        {
// cout<<"2222222222222222222222\n";
            LLI inx,val;
            cin>>inx>>val;
            update_query(1,1,n,inx,val);

//            puts("FFFFFFFFFFF : tree ");
//            for(LLI i=1; i<=7; i++)
//                cout<<i<<" : "<<tree[i]<<"\n";

//                puts("FFFFFFFFFFF : prop ");
//                            for(LLI i=1; i<=7; i++)
//                cout<<i<<" : "<<prop[i].two<<" "<<prop[i].three<<" "<<prop[i].five<<"\n";

        }
    }
    for(LLI i=1; i<=n; i++)
        if(i==1)
            cout<<query(1,1,n,i,i);

        else
            cout<<" "<<query(1,1,n,i,i);
    puts("");

}
