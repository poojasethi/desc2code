#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <stack>
#include <algorithm>
#include <cstring>
#include <map>
#include <bitset>
#include <string>
#include <cmath>
#include <set>
#include <climits>
#include <iomanip>
#include <cassert>
 
using namespace std;
 
const int INF = 1000000009;
const int MOD = 1000000007;
 
typedef long long LL;
typedef unsigned long long ULL;
typedef priority_queue <int> PQ;
typedef pair <int, int> II;
typedef priority_queue <II> PQII;
typedef map <int, int> MI;
typedef map <string, int> MSI;
typedef vector <int> VI;
typedef vector <double> VD;
typedef vector <VI> VVI;
typedef vector <LL> VL;
typedef vector <VL> VVL;
typedef vector <string> VS;
typedef vector < II > VII;
 
#define IOS ios_base::sync_with_stdio(false)
 
VII V;
int n, m;
int memo[(1<<20)+10];
set< II > S;
int tot[30];
int edges[30];
 
int dp(int bitmask){
	int id = __builtin_popcount(bitmask);
	// base
	if(id >= n){
		return 0;
	}
	
	// memo
	if(memo[bitmask]!=-1){
		return memo[bitmask];
	}
	
	int res = INF;
	
	for(int i=0; i<n; i++){
		if(!(bitmask & (1<<i))){
			//this is a free Node
			int mask = bitmask & edges[i];
			int cnt1 = __builtin_popcount(mask); // cantidad de pares que cierro
			int cnt2 = tot[i] - cnt1; // cantidad de pares que abro
			int val = cnt2*(n-1-id) - cnt1*(n-1-id);
			res= min(res, val + dp(bitmask | (1<<i)));
		}
	}
	return memo[bitmask] = res;
}
 
int main(){
	IOS;
	memset(memo, -1, sizeof memo);
	cin >> n >> m;
	for(int i=0; i<m; i++){
		int x, y;
		cin >> x >> y;
		x--; y--;
		V.push_back(II(x, y));
		V.push_back(II(y, x));
		tot[x]++;
		tot[y]++;
		S.insert(II(x, y));
		S.insert(II(y, x));
	}
	for(int i=0; i<n; i++){
		int bitmask = 0;
		for(int j=0; j<n; j++){
			if(i == j) continue;
			if(S.count( II(i, j) )){
				bitmask = bitmask | (1<<j);
			}
		}
		edges[i] = bitmask;
	}
	
	cout << dp(0) << endl;
} 
