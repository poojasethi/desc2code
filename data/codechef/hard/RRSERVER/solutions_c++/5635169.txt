/*----------------Subham Mishra---------------------------------------*/
#include<bits/stdc++.h>
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define pl(n) printf("%lld\n",n)
#define p(n) printf("%d\n",n)
#define pb push_back
#define mp make_pair
#define mod 10000007LL
#define N 100014
#define ll  long long
using namespace std;
ll powmod(ll a,ll b,ll c)
{
 ll res=1;
 while(b)
 {
  if(b&1)
  res=res*a;
  res%=c;
  a=(a*a)%c;
  b/=2;
 }
 return res;
}
ll mInverse(ll a,ll mod1)
{
    if(a==0LL)
        return 1LL;
    return powmod(a,(1LL*(mod1-2LL)),mod1)*1LL;
}

/// SIEVE

int mark[N+126];
vector<int>v1[N+123];
void sieve()
{
    int i,j;
    memset(mark,0,sizeof(mark));
    for(i=2;i<=N;i+=2)
    {
    v1[i].pb(2);mark[i]=1;
    }
    for(i=3;i<=N;i+=3)
    if(mark[i]==0)v1[i].pb(3);
    for(i=5;i*i<=N;i+=2)
    {
        if(mark[i]==0)
        {
          mark[i]=1;
          v1[i].pb(i);
          for(j=i;j*i<=N;j+=2)
          {
            if(mark[i*j]==0)
            {
                mark[i*j]==1;
                v1[i*j].pb(i);
            }
          }
        }
    }
    for(i=sqrt(N);i<=N;++i)
    if(mark[i]==0)v1[i].pb(i);
}
int bit[2*N+5],maxval;
void update(ll idx,ll val)
{
 while(idx<=maxval)
 {
  bit[idx]+=val;
  idx+=(idx & -idx);
 }
}
ll query(ll idx)
{
 ll sum=0;
 while(idx>0)
 {
   sum+=bit[idx];
   idx-=(idx & -idx);
 }
 return sum;
 }
 int setb(int num)
 {
  int an=0;
  while(num)
  {
   if(num&1)
   an++;
   num>>=1;
  }
  return an;
 }
//double dp[6004][3002];
  //vector<int>v[21];
  int val[21];
  int dp[1200000],dp1[1200000];
 int main()
 {
 int t,n,i,n1,n2,m,j;
 s(n);s(m);
 memset(val,0,sizeof(val));
 for(i=1;i<=m;++i)
 {
 s(n1);s(n2);
 val[n1]+=1<<(n2-1);
 val[n2]+=1<<(n1-1);
 }
 int sz=1<<n;
 dp[0]=0;
 dp1[0]=0;
 for(i=1;i<=sz;++i)
 dp[i]=INT_MAX;
 for(i=1;i<sz;++i)
 {
 vector<int>v;
 for(j=1;j<=n;++j)
 {
  if(i&(1<<(j-1)))
  v.pb(j);
 }
 if(v.size()==1)
 {
  dp[i]=0;
  dp1[i]=setb(val[v[0]]);
  //continue;
 }
 else
 {
 for(j=0;j<v.size();++j)
 {
  int va=1<<(v[j]-1);
  dp[i]=min(dp[i],dp[i-va]+dp1[i-va]);
  }
  int an=0;
  for(j=0;j<v.size();++j)
  {
   int va=i&val[v[j]];
   va=val[v[j]]-va;
   an+=setb(va);
  }
  dp1[i]=an;
  }
  //cout<<i<<" "<<dp[i]<<" "<<dp1[i]<<endl;
 }
 p(dp[sz-1]);
 return 0;
 }
