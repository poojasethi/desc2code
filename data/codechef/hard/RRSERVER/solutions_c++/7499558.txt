/* Author: Ankit Sultana
 * Comment: 
 * * * * * * * * * * * * * */
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <iterator>
#include <cmath>
#include <cassert>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <list>
#include <queue>
#define F first
#define S second
#define LL long long
#define PB push_back
#define gc getchar_unlocked
#define SWAP(a,b) a^=b,b^=a,a^=b
#define MP make_pair
#define pint pair<int, int>
#define pll pair<LL, LL>
#define vi vector<int>
#define vll vector<LL>
#define REP(i,n)	for(__typeof(n) i = 0; i < n; i++)
#define REP1(i,n)	for(__typeof(n) i = 1; i <= n; i++)
#define REP2(i,n)	for(__typeof(n) i = 1; i < n; i++)
#define REPc(i,j,n)	for(__typeof(n) i = j; i <= n; i++)
#define REPc2(i,j,n)	for(__typeof(n) i = j; i < n; i++)
#define matint vector<vi >
#define matll vector<vll >
#define last_bit(n) (n&(-n))
#define ll_two(n) (1ll<<n)
#define int_two(n) (1<<n)
#define absol(n) (n < 0?-n: n)

#define ALL(container) (container).begin(), (container).end()
#define RALL(container) (container).rbegin(), (container).rend()
#define SZ(container) (container).size()
#define FOR(i,c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)
#define PRINT(i,j,k,arr) for(__typeof(k) i = j; i <= k; i++) std::cout<<arr[i]<<' ';
#define MAX 1100000

const int INF = 1<<28;
const LL mod = 1000000007;

template<class T> std::ostream& operator<<(std::ostream &os, const std::vector<T> &t) {
	os<<"["; FOR(it,t) { if(it != t.begin()) os<<", "; os<<*it; } os<<"]\n";
	return os;
}

template <typename T> T gcd(T a, T b) { return b==0?a: gcd(a%b, b); }

template <typename T>
T expo(T b, T e) {
	if(e <= 1)	return e==0?1: b;
	return (e&1)==1? (b*expo((b*b)%mod, e>>1))%mod: expo((b*b)%mod, e>>1);
}

using namespace std;

template <typename T>
void InPos(T &x)
{
	register T c = gc();
	while(((c < 48) || (c > 57)) && (c!='-')) c = gc();
	bool neg = false; if(c == '-') neg = true; x = 0;
	for(;c < 48 || c > 57;c=gc());
	for(;c > 47 && c < 58;c=gc())	x = (x*10) + (c - 48); if(neg)	x = -x;
}

int n, m, mask = 0, dp[MAX] = {0}, mdp[MAX] = {0};
bool adj_m[21][21] = {false};
vi adj[21];

int main()
{
	InPos(n), InPos(m);
	int a, b, sizes[21] = {0};
	REP(i,m){
		InPos(a), InPos(b);
		a--, b--;
		//adj_m[a][b] = true, adj_m[b][a] = true;
		adj[a].PB(b), adj[b].PB(a);
		sizes[a]++, sizes[b]++;
	}
	//mdp is:
	//	for a given bitmask mask... it is the number of connections (a, b) such that exactly one of them is in the bitmask
	//	==> mdp[mask|(1<<x)] = mdp[mask]-(number of on bits y such that (x, y) is an edge)+(number of off bits y such that (x,y) is an edge);
	mdp[0] = 0;
	int LIMIT = (1<<n)-1;
	int temp_mask;
	for(int mask = 1; mask <= LIMIT; mask++){
		//unset last bit.. blah blah blah
		temp_mask = mask-last_bit(mask);
		mdp[mask] = mdp[temp_mask];
		int x = 0, temp = mask;
		while(temp){
			if(temp&1)
				break;
			x++;
			temp >>= 1;
		}
		REP(i,sizes[x]){
			if(((1<<adj[x][i])&temp_mask)){
				mdp[mask]--;
			}
			else{
				mdp[mask]++;
			}
		}
	}
	REP(i,LIMIT+1)
		dp[i] = INF;
	dp[0] = 0;
	for(int mask = 1; mask <= LIMIT; mask++){
		REP(i,n){
			if(((1<<i)&mask)){
				dp[mask] = min(dp[mask], mdp[mask]+dp[mask^(1<<i)]);
			}
		}
	}
	/*REP(i,LIMIT+1)
		cout<<dp[i]<<' ';
	cout<<endl;*/
	printf("%d\n", dp[LIMIT]);
	return 0;
}
