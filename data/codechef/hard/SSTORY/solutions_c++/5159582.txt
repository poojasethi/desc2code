/*   if we have a common substring with length L, we can always find common substring with length less than L */

#include<bits/stdc++.h>
using namespace std;
#define MOD 34369934LL
#define MAGIC 9584612342LL
#define lld long long
#define MAX 500005

#define DisplayDebuggingInfo 0
#define debug(args...) {dbg,args; if(DisplayDebuggingInfo) cerr<<endl;}
struct debugger{template<typename T> debugger& operator,(const T& v){if(DisplayDebuggingInfo){cerr<< v <<" ";return *this;}}}dbg;

int mark;

string s1,s2;
struct node
{
    vector<int> Llist;
    int turn;
}table[MOD];

bool check(int key,int start,int len)
{

    if(table[key].Llist.size()==0 || table[key].turn!=mark)return false;
    bool f=1;
    for(int i=0;i<table[key].Llist.size();++i)
    {
        int k = start;
        int idx=table[key].Llist[i];
        for(int j=idx;j<idx+len;++j)
        {
            if(s1[j]!=s2[k++])
            {
                f=0;
                break;
            }
        }
        if(f) return true;
    }
    return false;
}

void insert(int hash,int idx)
{
    if(table[hash].turn!=mark)
    {
        table[hash].turn=mark;
        table[hash].Llist.clear();
    }
    table[hash].Llist.push_back(idx);
}

int isPossible(int len)
{
    mark++;
    if(len==0) return -1;
    lld hash = 0,mul=1;
    for(int i=0;i<len;++i)
    {
        hash = (hash*MAGIC + s1[i])%MOD;
        mul = (mul*MAGIC)%MOD;
    }
    insert(hash,0);
    mul = (MOD-mul)%MOD;
    for(int i=len;i<s1.length();++i)
    {
        hash = (hash*MAGIC + s1[i] + mul*s1[i-len])%MOD;
        insert(hash,i-len+1);
    }
    hash = 0;
    for(int i=0;i<len;++i)
    {
        hash = (hash*MAGIC + s2[i])%MOD;
    }
    if(check(hash,0,len))return 0;
    for(int i=len;i<s2.length();++i)
    {
        hash = (hash*MAGIC + s2[i] + mul*s2[i-len])%MOD;
        if(check(hash,i-len+1,len))return i-len+1;
    }
    return -1;
}

int main()
{
    cin>>s1>>s2;
    int lo = 0,hi=s2.length(),idx;
    while(lo<hi)
    {
        int mid = (lo+hi+1)>>1;
        //debug("mid ",mid);
        idx = isPossible(mid);
        if(idx!=-1)lo = mid;
        else hi = mid-1;
    }
    idx = isPossible(lo);
    if(idx!=-1)
    {
        for(int i=idx;i<lo+idx;++i)
            cout<<s2[i];
    }
    cout<<endl<<lo<<endl;
}
