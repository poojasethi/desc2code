#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <algorithm>
#include <vector>
#include <cstring>
#include <stack>
#include <utility>
#include <map>
#include <set>
#include <string>
using namespace std;
#define INF (int(1e9))
#define INFL (LL(1e18))
#define in2(n,m) scanf("%d %d",&n,&m);
#define in3(x,y,z) scanf("%d %d %d",&x,&y,&z);
#define in4(p,q,r,s) scanf("%d %d %d %d",&p,&q,&r,&s);
#define getcx getchar
inline void in(int &n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
int PA = 30;
int modA = 1000000007;

int PB = 29;
int modB = 1000000009;

long long int YHashFwdA[1000006],YHashBwdA[1000006];
long long int YHashFwdB[1000006],YHashBwdB[1000006];

long long int ZHashFwdA[1000006],ZHashBwdA[1000006];
long long int ZHashFwdB[1000006],ZHashBwdB[1000006];

long long int PPA[300005];
long long int PPB[300005];

void pre()
{
    int n=250000;
    PPA[0]=1;
    for(int i=1; i<=n+5; i++)
    {
        PPA[i]=PPA[i-1]*PA;
        if(PPA[i]>=modA)
        {
            PPA[i]%=modA;
        }
    }
    PPB[0]=1;
    for(int i=1; i<=n+5; i++)
    {
        PPB[i]=PPB[i-1]*PB;
        if(PPB[i]>=modB)
        {
            PPB[i]%=modB;
        }
    }
}
void YCreateHash(string &str)
{
    int n=str.size();

    //Fwd
    YHashFwdA[n]=0;
    YHashFwdB[n]=0;
    for(int i=n-1; i>=0; i--)
    {
        YHashFwdA[i]=(str[i]-96)+PA*YHashFwdA[i+1];
        YHashFwdB[i]=(str[i]-96)+PB*YHashFwdB[i+1];
        if(YHashFwdA[i]>=modA)
        {
            YHashFwdA[i]%=modA;
        }
        if(YHashFwdB[i]>=modB)
        {
            YHashFwdB[i]%=modB;
        }
    }
    //Done

    return;
}
void ZCreateHash(string &str)
{
    int n=str.size();

    //Fwd
    ZHashFwdA[n]=0;
    ZHashFwdB[n]=0;
    for(int i=n-1; i>=0; i--)
    {
        ZHashFwdA[i]=(str[i]-96)+PA*ZHashFwdA[i+1];
        ZHashFwdB[i]=(str[i]-96)+PB*ZHashFwdB[i+1];
        if(ZHashFwdA[i]>=modA)
        {
            ZHashFwdA[i]%=modA;
        }
        if(ZHashFwdB[i]>=modB)
        {
            ZHashFwdB[i]%=modB;
        }
    }
    //Done

    return;
}
pair< int , int > YfwdHash(int i,int j)
{
    long long int ansA=YHashFwdA[i]-(YHashFwdA[j+1]*PPA[j-i+1]);
    long long int ansB=YHashFwdB[i]-(YHashFwdB[j+1]*PPB[j-i+1]);

    if(ansA>=modA)
    {
        ansA%=modA;
    }
    if(ansA<0)
    {
        ansA%=modA;
        ansA+=modA;
        ansA%=modA;
    }

    if(ansB>=modB)
    {
        ansB%=modB;
    }
    if(ansB<0)
    {
        ansB%=modB;
        ansB+=modB;
        ansB%=modB;
    }

    return pair< int , int >(ansA,ansB);
}
pair< int , int > ZfwdHash(int i,int j)
{
    long long int ansA=ZHashFwdA[i]-(ZHashFwdA[j+1]*PPA[j-i+1]);
    long long int ansB=ZHashFwdB[i]-(ZHashFwdB[j+1]*PPB[j-i+1]);

    if(ansA>=modA)
    {
        ansA%=modA;
    }
    if(ansA<0)
    {
        ansA%=modA;
        ansA+=modA;
        ansA%=modA;
    }

    if(ansB>=modB)
    {
        ansB%=modB;
    }
    if(ansB<0)
    {
        ansB%=modB;
        ansB+=modB;
        ansB%=modB;
    }

    return pair< int , int >(ansA,ansB);
}
int main()
{
    pre();

    string Y;
    string Z;
    cin>>Y>>Z;

    YCreateHash(Y);
    ZCreateHash(Z);

    int low,up,mid;
    low=0;
    up=Z.size();
    while(low<up)
    {
        mid=low+(up-low+1)/2;
        bool fnd=false;
        if(mid==0)
        {
            fnd=true;
        }
        vector< pair< int , int > > v;
        for(int i=0; i+mid-1<Y.size(); i++)
        {
            v.push_back(YfwdHash(i,i+mid-1));
        }
        sort(v.begin(),v.end());
        for(int i=0; i+mid-1<Z.size(); i++)
        {
            if( binary_search(v.begin(),v.end(),ZfwdHash(i,i+mid-1))==true )
            {
                fnd=true;
                break;
            }
        }
        if(fnd==true)
        {
            low=mid;
        }
        else
        {
            up=mid-1;
        }
    }
    if(low==0)
    {
        printf("0\n");
    }
    else
    {
        vector< pair< int , int > > v;
        string ans;
        for(int i=0; i+low-1<Y.size(); i++)
        {
            v.push_back(YfwdHash(i,i+low-1));
        }
        sort(v.begin(),v.end());
        for(int i=0; i+low-1<Z.size(); i++)
        {
            if( binary_search(v.begin(),v.end(),ZfwdHash(i,i+low-1))==true )
            {
                ans=Z.substr(i,low);
                break;
            }
        }
        printf("%s\n",ans.c_str());
        printf("%d\n",low);
    }
    return 0;
}
