
//~        Author : Sarvesh Mahajan                             
//               IIIT,Hyderabad                                   
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#ifndef ONLINE_JUDGE
#define DEBUG
#endif

#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define For(i,a,b) for(i=a;i<b;i++)
#define loop(i,b) for(i=0;i<b;i++)
#define Loop(i,b) for(i=1;i<=b;i++)
#define pi(n) printf("%d ",n)
#define si(n) scanf("%d",&n)
const int MOD=1e9+7;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef long long LL;
#define F first
#define S second
#define sz size
#define pLL(x) cout<<x<<' '
#define fill(x,c) memset(x,c,sizeof(x))
#ifdef DEBUG
#define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;
#else
#define DB(x)
#define DB2(x,y)
#define DB3(x,y,z)
#endif
// Input: text, N
// Output: sa[] is a sorted list of offsets to all non-empty suffixes,
// lcp[i] = length of longest common prefix of text+sa[i] and text+sa[i+1]
const int MAX=1e6;
char text[MAX]; long long key[MAX]; int N, sa[MAX], rank[MAX], *lcp=(int*)key;
struct Cmp { bool operator()(int i, int j) const { return key[i]<key[j]; } };
void build() 
{
	for (int i = 0; i < N; i++)
	{
		sa[i] = i; key[i] = text[i];
	}
	sort(sa, sa+N, Cmp());
	for (int K = 1; ; K *= 2) 
	{
		for (int i = 0; i < N; i++)
			rank[sa[i]] = i>0 && key[sa[i-1]]==key[sa[i]] ? rank[sa[i-1]] : i;
		if (K >= N) break;
		for (int i = 0; i < N; i++)
			key[i] = rank[i] * (N+1LL) + (i+K < N ? rank[i+K]+1 : 0);
		sort(sa, sa+N, Cmp());
	}
	for (int i = 0, k = 0; i < N; i++)
	{
		if (k > 0) k--;
		if (rank[i] == N-1)
		{
			lcp[N-1] = -1; k = 0; continue;
		}
		int j = sa[rank[i]+1];
		while (text[i+k] == text[j+k]) k++;
		lcp[rank[i]] = k;
	}
}

/*unsigned int LCP(const unsigned int u, const unsigned int v, unsigned int pow) const 
{ // LCP of u and v, known to be less than 2^(pow+1)
        if (rank[0][u] != rank[0][v]) // first char different
            return 0;
        while(rank[pow][u]!=rank[pow][v])
            pow--;
        return (1<<pow) + LCP(u+(1<<pow), v+(1<<pow), pow-1);
}*/

bool different(int x,int y,int l)
{
	//DB2(sa[x],sa[y]);
	int mini=min(sa[x],sa[y]);
	int maxi=max(sa[x],sa[y]);
	if(mini<l and maxi>l)
		return 1;
	return 0;
}
int main()
{
//	ios_base::sync_with_stdio(false);
	int n,t,m,l,k,i,j,res=0,fl,x,y,z;
	char s1[MAX],s2[MAX];
	scanf("%s%s",s1,s2);
	l=strlen(s1);
	int l2=strlen(s2);
	N=l+l2+1;
	loop(i,l)
		text[i]=s1[i];
	text[l]='#';
	loop(i,l2)
		text[l+1+i]=s2[i];
	//DB(text)
	string s22="";
	loop(i,l2)
		s22+=s2[i];
	build();
	int ans=0;
	for(i=0;i+1<N;++i)
	{
//		DB3(i,sa[i],sa[i+1])
//		DB3(i,lcp[i],lcp[i+1])
			if(!different(i,i+1,l))
				continue;
			if(lcp[i]>0)
				ans=max(lcp[i],ans);
			//DB2(i,lcp[i])
	}

	if(!ans)
	{
		puts("0");
		return 0;
	}


	

	set<string> se;
	loop(i,N-1)
	{
		int idx;
		if(lcp[i] == ans)
		{
			if(sa[i]>l and sa[i+1]<l)
			{
				 idx=sa[i]-l-1;
			//	 DB(idx)
			//	 if(idx+ans-1<l2)
				se.insert(s22.substr(idx,ans));
				
			}
			else if(sa[i+1]>l and sa[i]<l)
			{
				idx=sa[i+1]-l-1;
				//DB(idx)
			//	if(idx+ans-1<l2)
			 
				se.insert(s22.substr(idx,ans));
			}

		}
	}

	

	int ll=s22.sz();
	string ss,pp;
	loop(i,ll)
	{
		//if(i+ans-1<l2)
		 pp=s22.substr(i,ans);
		//DB(pp)
		if(se.find(pp)!=se.end())
		{
			ss=pp;
			break;
		}
	}



	cout<<ss<<endl;
	pi(ans);
	puts("");

	
}
