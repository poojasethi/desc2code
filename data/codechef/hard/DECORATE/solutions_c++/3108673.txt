#include<bits/stdc++.h>
using namespace std;

#define REP( i , n ) for( int i = 0 ; i < n ; ++i )
#define f(i,x,y) for (int i = x; i < y; i++)
#define fd(i,x,y) for(int i = x; i>= y; i--)

#define N 100005
/*class StringHash {
	static long MULTIPLIER = 27;
	static long REVERSE_MULTIPLIER ;
        static long MOD;
	static long[] hash;
	static long[] reversePower;
	public StringHash(CharSequence string , long mod ) {
        MOD = mod;
        REVERSE_MULTIPLIER = BigInteger.valueOf(MULTIPLIER).modInverse(BigInteger.valueOf( MOD )).longValue();
        int n = string.length();
		hash = new long[ n + 1 ];
		long power = 1;
		reversePower = new long[ n + 1 ];
		reversePower[0] = 1;
                hash[ 0 ] = 0;
		for (int i = 0; i < n ; i++) {
			hash[i + 1] = ( hash[i] + ( (string.charAt(i) - 'a' + 1) * power )%mod )%mod;
			power = ( power*MULTIPLIER )%mod;
			reversePower[i + 1] = ( reversePower[i] * REVERSE_MULTIPLIER )%mod;
		}
	}
	public long hash(int from, int to) {
		return ( ( (hash[to] - hash[from] + MOD )%MOD )* reversePower[from] )%MOD;
	}
}*/

typedef vector< int > vi;
typedef long long ll;
typedef vector< ll > vll;
typedef pair< ll , ll > pll;
ll pow( ll a , ll b , ll c ){
	ll ans = 1;
	while( b ){
		if( b&1 ) ans = ( ans * a )%c;
		a = ( a * a )%c;
		b >>= 1;
	}
	return ans;
}
ll modInverse( ll a , ll mod ){ return pow( a , mod - 2 , mod );}
struct StringHash{
	ll MULTIPLIER ;
	ll REVERSE_MULTIPLIER;
	ll MODULE;
	vll hash , reversePower;
	StringHash(){}
	StringHash( string s , long mod )
	{
		MULTIPLIER = 27;
		MODULE = mod;
		REVERSE_MULTIPLIER = modInverse( MULTIPLIER , MODULE );
		int n = s.size();
		hash.resize( n + 1 ) , reversePower.resize( n + 1 );
		reversePower[ 0 ] = 1;
        hash[ 0 ] = 0;
		ll power = 1;
		REP( i , n ){
			hash[ i + 1 ] = ( hash[ i ] + ( ( s[ i ] - 'a' + 1 ) * power )%MODULE ) %MODULE;
			power = ( power * MULTIPLIER )%MODULE;
			reversePower[ i + 1 ] = ( reversePower[ i ] * REVERSE_MULTIPLIER )%MODULE;
		}
	}
	ll Hash( int from , int to ){
		return ( ( ( hash[ to ] - hash[ from ] + MODULE )% MODULE ) * reversePower[ from ] ) %MODULE;
	}
};
int cnt_unique_palin( string &s )
{
	int n = s.length();
	StringHash H1 = StringHash( s , 1000000009LL );
	StringHash H2 = StringHash( s , 1000000007LL );
	set< pll >S;
	vi d1( n );
	int l = 0 , r = -1;
	for( int i = 0 ; i < n ; ++i ) {
	    int k = ( i > r ? 1 : min ( d1[ l + r - i ] , r - i + 1 ) );
	    if( i > r )
	        S.insert( pll( H1.Hash( i , i + 1 )  , H2.Hash( i , i + 1 ) ) );
	    while( i + k < n && i - k >= 0 && s[ i - k ] == s[ i + k ] )  {
	        S.insert( pll( H1.Hash( i - k , i + k + 1 )  , H2.Hash( i - k , i + k + 1 ) ) );
	        k++;
	    }
	    d1[ i ] = k--;
	    if( i + k > r )
	            l = i - k , r = i + k ;
	}
	vi d2( n );
	l = 0 ; r = -1;
	for( int i = 0 ; i < n ; ++i ) {
	    int k = ( i > r ? 0 : min ( d2[ l + r - i + 1 ] , r - i + 1 ) );
	    while ( i + k < n && i - k - 1 >= 0 && s[ i - k - 1 ] == s[ i + k ] )  {
	        S.insert( pll( H1.Hash( i - k - 1 , i + k + 1 )  , H2.Hash( i - k - 1 , i + k + 1 ) ) );
	        k++;
	    }
	    d2[ i ] = k--;
	    if( i + k > r )
	            l = i - k - 1 ,  r = i + k;
	}
	return S.size();
}
// bignum
#define mod 1000000
void impr(vll C){
	printf("%lld",C.back());
	for(int i=C.size()-2;i>=0;i--) printf("%06lld",C[i]);
	printf("\n");
}
 
vll operator*(vll a,vll b){
	int m=a.size(),n=b.size();
	vll c(m+n); 
	ll s=0;
	f(i,0,m+n){
		int ini=max(0,i-n+1);
		int fin=min(i+1,m);
		f(j,ini,fin)s+=a[j]*b[i-j];
		int k=i;
		while(s){
			c[k]+=s%mod; s=s/mod;
			if(c[k]>=mod){ c[k]-=mod; c[k+1]++;}
			k++;
		}
	}
	if(c.back()==0)c.pop_back();
	return c;
}
vll operator+ (vll a,vll b){
	int m=a.size(),n=b.size();
	if(m<n) swap(a,b), swap(m,n);
	vll c(m+1); 
	f(i,0,m){
		ll s=a[i];
		if(i<n)s+=b[i];
		c[i] += s;
		if(c[i] >= mod) c[i]-=mod, c[i+1]++;
	}
	if(c.back()==0)c.pop_back();
	return c;
}
vll operator/ (vll a, int k) {
	int n = a.size();
	vll c(n);
	fd(i,n-1,0) {
		c[i] = a[i]/k;
		if(i) a[i-1] += a[i]%k * mod;
	}
	if(c.back()==0) c.pop_back();
	return c;
}
bool operator<(vll A,vll B){
	int m=A.size(), n=B.size();
	if(m<n) return 1;
	if(m>n) return 0;
	fd(i,m-1,0){
		if(A[i]<B[i])return 1;
		if(A[i]>B[i])return 0;
	}
	return 0;
}

vll K[ 605 ];
int phi[ N + 1 ];
vll neck( int n , int k ){
    vll kk( 1 , k );
    K[ 0 ] = vll( 1 , 1 );
    for( int i = 1 ; i <= 600 ; ++i ) K[ i ] = K[ i - 1 ] * kk;
    for( int i = 1 ; i <= N ; ++i ) phi[ i ] = i;
    for( int i = 1 ; i <= N ; ++i )for( int j = i * 2 ; j <= N ; j += i ) phi[ j ] -= phi[ i ];
    //for( int i = 1 ; i <= 15 ; ++i ) impr( K[ i ] );
	//cout << endl;  
	vll S( 1 , 0 );
	for( int d = 1 ; d <= n ; ++d )
		if( n%d == 0 )
			S = S + ( vll( 1 , phi[ d ] )* K[ n/ d ] );
	S = S / n;
	//cout << " neck : " ;impr( S );
	return S;
}
vll brac( int n , int k )
{
	vll S = neck( n , k );
	vll TWO( 1 , 2 ) , FOUR( 1 , 4 ) , K1( 1 , k + 1 );
	if( n % 2 == 0 ) return ( ( TWO * S ) + ( K1 * K[ n /2 ] ) )/4;
	return ( S + K[ ( n + 1 )/2 ] ) / 2;
}
int main()
{
	string s;
	int n;
	while( cin >> s >> n )
	{
		int k = cnt_unique_palin( s );
		//cout << " k : " << k << endl;
		impr( brac( n , k ) );
	}
}