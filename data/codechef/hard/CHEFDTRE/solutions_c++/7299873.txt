#include <bits/stdc++.h>
using namespace std;

const int N = 4e5 + 5;

struct node{
	int key, prior, sz;
	node *l, *r;
	node(){
		key = prior = 0;
		sz = 1;
		l = r = NULL;
	}
} *A[N];

typedef node* pnode;

int cnt(pnode t){
	return (t ? t->sz : 0);
}

void update(pnode &t){
	if(t)	t->sz = cnt(t->l) + cnt(t->r) + 1;
	else t->sz = 0;
}

void merge(pnode &t, pnode l, pnode r){
	if(!t)	t = (l ? l : r);
	else{
		if(l->prior >= r->prior)	merge(l->r, l->r, r), t = l;
		else merge(r->l, l, r->l), t = r;
	}
	update(t);
}

void split(pnode t, pnode &l, pnode &r, int key){
	if(!t){
		l = r = NULL;
		return ;
	}
	else if(t->key > key)	split(t->l, l, t->l, key), r = t;
	else split(t->r, t->r, r, key), l = t; 
	update(t);
}

void insert(pnode &t, pnode &b){
	if(!t)	t = b;
	else{
		if(b->prior > t->prior){
			split(t, b->l, b->r, b->key);
			t = b;
		}
		else insert((t->key > b->key ? t->l : t->r), b);
	}
	update(t);
}

void union_join(pnode &a, pnode &b){	//we unite each element of b into a.
	if(!b)	return ;
	union_join(a, b->l), union_join(a, b->r);
	b->l = b->r = NULL;
	b->sz = 1;
	insert(a, b);
}

void inOrder(pnode t){
	if(!t)	return ;
	else{
		cout<<t->key<<endl<<"My left -->"<<endl;
		inOrder(t->l);
		cout<<"My left closed, my right -->"<<endl;
		inOrder(t->r);
		cout<<"My right closed"<<endl;
	}
}

int KthElement(pnode t, int k){
	if(k == cnt(t->l) + 1)	return t->key;
	else if(cnt(t->l) >= k)	return KthElement(t->l, k);
	else return KthElement(t->r, k - (cnt(t->l) + 1));
}

int main(){
	int n, q, cntr, a, b;
	string type;
	cin>>n>>q;
	for(int i = 1; i <= n; i++){
		A[i] = new node();
		A[i]->key = i;
		A[i]->prior = (rand()<<10) + rand();
	}
	cntr = n;
	
	while(q--){
		cin>>type>>a>>b;
		
		if(type[0] == 'U'){
			if(cnt(A[a]) < cnt(A[b]))	swap(A[a], A[b]);
			union_join(A[a], A[b]);
			A[++cntr] = new node();
			A[cntr] = A[a];
		}
		else	cout<<KthElement(A[a], b)<<endl;
	}
	return 0;
}