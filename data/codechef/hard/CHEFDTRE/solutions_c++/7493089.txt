#pragma comment(linker, "/STACK:102400000,102400000")
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <queue>
#include <set>
#include <cmath>
#include <fstream>
#include <assert.h>
#include <complex>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 100005

vi s[N],v[N];char t[10];
int id[N<<2];
void merge(int x,int y){
    static int q[N];
    int top=0,l=0,r=0;
    while(l<s[x].size()&&r<s[y].size()){
        if(s[x][l]<s[y][r])q[top++]=s[x][l++];
        else q[top++]=s[y][r++];
    }
    while(l<s[x].size())q[top++]=s[x][l++];
    while(r<s[y].size())q[top++]=s[y][r++];
    s[x].resize(top);
    for(int i=0;i<top;i++)s[x][i]=q[i];
    s[y].clear();
}
void go(int x){
    int y=v[x][0];
    for(int i=1;i<v[x].size();i++){
        int j=v[x][i];
        merge(y,j);
    }
    v[x].clear();
    if(s[y].size()>2000)merge(x,y);
    else v[x].pb(y);
}
int main()
{
    //freopen("1.txt","w",stdout);
    int T,i,j,k,ca=0,n=1,m;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)s[i].pb(i),id[i]=i;
    int sz=n;
    for(i=0;i<m;i++){
        int a,b;
        scanf("%s%d%d",t,&a,&b);
        if(t[0]=='U'){
            int x=id[a],y=id[b];
            //cerr<<x<<" "<<y<<"\n";
            if(max(s[x].size(),s[y].size())<=2000){
                merge(x,y);id[++sz]=x;
                continue;
            }
            if(s[x].size()<=2000)swap(x,y);
            if(s[y].size()<=2000)v[x].pb(y);
            else{
                merge(x,y);
                for(j=0;j<v[y].size();j++)v[x].pb(v[y][j]);
                v[y].clear();
            }
            if(v[x].size()>20)go(x);
            id[++sz]=x;
        }
        else{
            int l=1,r=n;a=id[a];
            //DBG(a)
            while(l<=r){
                int x=(l+r)>>1;
                int res=upper_bound(all(s[a]),x)-s[a].begin();
                for(j=0;j<v[a].size();j++){
                    k=v[a][j];
                    int y=upper_bound(all(s[k]),x)-s[k].begin();
                    res+=y;
                    if(res>=b)break;
                }
                if(res>=b)r=x-1;
                else l=x+1;
            }
            printf("%d\n",r+1);
        }
    }
    return 0;
}