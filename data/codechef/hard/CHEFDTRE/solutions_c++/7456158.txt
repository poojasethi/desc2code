#include <set>
#include <map>
#include <list>
#include <stack>
#include <cmath>
#include <queue>
#include <ctime>
#include <cfloat>
#include <vector>
#include <string>
#include <cstdio>
#include <bitset>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <iomanip>
#include <sstream>
#include <utility>
#include <iostream>
#include <algorithm>
  
using namespace std;
  
#define FOR(i, a, b) for(int i = a; i <= b; ++i)
#define RFOR(i, b, a) for(int i = b; i >= a; --i)
#define REP(i, N) for(int i = 0; i < N; ++i)
#define RREP(i, N) for(int i = N-1; i >= 0; --i)
#define FORIT(i, a) for( TI(a) i = a.begin(); i != a.end(); i++ )
#define MAXN 5000603
#define INF 0x3F3F3F3F
#define LINF 0x3F3F3F3FFFFFFFFFLL
#define FILL(X, V) memset( X, V, sizeof(X) )
#define TI(X) __typeof((X).begin())
#define ALL(V) V.begin(), V.end()
#define SIZE(V) int((V).size())
#define pb push_back
#define mp make_pair
  
  
struct tri{
    int atual, custo;
    tri ( int atual = 0, int custo = 0) : atual(atual), custo(custo) { }
};
  
typedef vector < int > vi;
typedef vector < vi > vii;
typedef vector < tri > vtri;
typedef vector < vtri > vvtri;
typedef long long uint64;
 
struct node_t{
  int sz, pr;
  uint64 key;
  node_t *l, *r;
  node_t( uint64 val = 0 ) : key(val), sz(0), pr(rand()), l(NULL), r(NULL) {}
  ~node_t(){ if(l) delete l; if(r) delete r; }
};
 
typedef node_t *tree;
 
void rotate_right(node_t* &t ){
  node_t* n = t->l;
  t->l = n->r;
  n->r = t;
  t = n;
}
 
void rotate_left(node_t* &t ){
  node_t* n = t->r;
  t->r = n->l;
  n->l = t;
  t = n;
}
 
void update(node_t* &t){
  if(!t) return;
  t->sz = ((t->l)?(t->l->sz):(0)) + 1 + ((t->r)?(t->r->sz):(0));
}
 
void fix( node_t* &t ){
  if(!t) return;
  update(t->l); update(t->r); update(t);
}
 
void insert(node_t* &t, uint64 val){
  if( !t ) t = new node_t(val);
  else{
    if( val < t->key ) insert( t->l, val);
    else insert( t->r, val);
  }
  
  if( t->l && (t->l->pr > t->pr) ) rotate_right(t);
  else if( t->r && (t->r->pr > t->pr) ) rotate_left(t);
  
  fix(t);
}
 
inline int p( node_t* t ){ return (t ? (t->pr) : (-1)); }
 
void erase( node_t* &t, uint64 val ){
  if( !t ) return;
  if( t->key != val ) erase( ((val < t->key)?(t->l):(t->r)), val );
  else {
    if( !(t->l) && !(t->r) ){ delete t, t = NULL; }
    else{
      (p(t->l) < p(t->r)) ? rotate_left(t) : rotate_right(t);
      erase( t, val );
    }
  }
  fix(t);
}

int cnt (node_t * it) {
  return it ? it->sz : 0;
}

void split (node_t * t, int key, node_t * & l, node_t * & r) {
  if (!t)
    l = r = NULL;
  else if (key < t->key)
    split (t->l, key, l, t->l),  r = t;
  else
    split (t->r, key, t->r, r),  l = t;
  fix(l);  fix(r); fix(t);
}

node_t * unite (node_t * l, node_t * r) {
  if (!l || !r)  return l ? l : r;
  if (l->pr < r->pr)  swap (l, r);
  node_t * lt, *rt;
  split (r, l->key, lt, rt);
  l->l = unite (l->l, lt);
  l->r = unite (l->r, rt);
  fix(l);
  return l;
}
 
int ith(node_t *t, int i) {
    int lsz = (t->l)?(t->l->sz):(0);
    if (lsz+1 == i) return t->key;
    if (lsz >= i) return ith(t->l, i);
    return ith(t->r, i-lsz-1 );
}
 
int main(){
    ios::sync_with_stdio(false);
    int n, q, a, b;
    srand(time(NULL));
    string op;
    cin >> n >> q;
    vector <  tree  > treap;
    treap.resize(n);
    for( int i = 0; i < n; i++ ){
      treap[i] = NULL;
      insert(treap[i],uint64(i));
    }
    while( q-- ){
      cin >> op;
      if( op == "UNION" ){
        cin >> a >> b;
        a--;
        b--;
        tree nova = unite(treap[a],treap[b]);
        treap[a] = NULL;
        treap[b] = NULL;
        treap.push_back(nova);
      }
      else{
        cin >> a >> b;
        a--; b--;
        cout << ith(treap[a],b+1)+1 << '\n';
      }
    }
    return 0;
}   