#include <bits/stdc++.h>
using namespace std;

#define PB push_back
#define MP make_pair
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
#define si(a) scanf("%d", &a)
#define sl(a) scanf("%lld", &a)
#define sd(a) scanf("%lf", &a)
#define sii(a, b) scanf("%d%d", &a, &b)
#define sll(a, b) scanf("%lld%lld", &a, &b)
#define sdd(a, b) scanf("%lf%lf", &a, &b)
#define Fast_IO ios_base::sync_with_stdio(0);cin.tie(0)

#define MAX 100001
#define MAX_PRIORITY 1000000000
struct Treap {
   int key, priority, cnt;
   Treap *left, *right;
   Treap(int ky = 0, int pr = 0, Treap *l = NULL, Treap *r = NULL, int c = 1) :
      key(ky), priority(pr), left(l), right(r), cnt(c)  {}
   void merge() {
      cnt = 1;
      if(left) cnt += left->cnt;
      if(right) cnt += right->cnt;
   }
};
typedef Treap* pTreap;
pTreap tree[MAX+MAX];
int biggest[MAX+MAX];

void rotleft(pTreap &par) {
   pTreap nw = par->left;
   if(!nw) return;
   par->left = nw->right, nw->right = par;
   par->merge();
   par = nw;
   par->merge();
}
void rotright(pTreap &par) {
   pTreap nw = par->right;
   if(!nw) return;
   par->right = nw->left, nw->left = par;
   par->merge();
   par = nw;
   par->merge();
}
inline void balance(pTreap &par) {
   if(par->left != NULL && par->left->priority > par->priority) rotleft(par);
   else if(par->right != NULL && par->right->priority > par->priority) rotright(par);
}
bool search(const pTreap par, int key) {
   if(!par) return false;
   if(par->key == key) return true;
   return (key < par->key) ? search(par->left, key) : search(par->right, key);
}
void insert(pTreap &par, int key, int pr) {
   if(par == NULL) {
      par = new Treap(key, pr);
      return;
   }
   if(key > par->key) insert(par->right, key, pr);
   else insert(par->left, key, pr);
   par->merge();
   balance(par);
}
void erase(pTreap &par, int key) {
   if(!par) return;
   if(key < par->key) erase(par->left, key);
   else if(key > par->key) erase(par->right, key);
   else {
      if(par->left == NULL && par->right == NULL) delete par, par = NULL;
      else if(par->left != NULL && par->left->key == key) erase(par->left, key);
      else {
         (par->right == NULL || (par->left != NULL && par->left->priority > par->right->priority)) ? rotleft(par) : rotright(par);
         erase(par, key);
      }
   }
   if(par) par->merge();
}
void split(pTreap &par, pTreap &big, int key) {
   insert(par, key, MAX_PRIORITY+10);
   pTreap tmp = par;
   big = par->right, par = par->left;
   delete tmp, tmp = NULL;
}
// joins two treaps while all the elements of the small treap is strictly less than the big treap
void join(pTreap &small, pTreap &big, int key) {
   small = new Treap(key, 0, small, big);
   erase(small, key);
}
// unites two treaps
pTreap unite(pTreap &t1, pTreap &t2) {
   if(t1 == NULL) return t2;
   if(t2 == NULL) return t1;
   if(t1->priority < t2->priority) swap(t1, t2);
   pTreap big, ret;
   split(t2, big, t1->key);
   ret = new Treap(t1->key, t1->priority, unite(t1->left, t2), unite(t1->right, big));
   ret->merge();
   return ret;
}

int find(const pTreap par, int k)
{
   //if(par != NULL) cout << par->key << ' ' << par->cnt << endl;
   int lefsum = (par->left) ? par->left->cnt : 0;
   lefsum++;
   if(lefsum == k) return par->key;
   else if(lefsum > k) return find(par->left, k);
   else return find(par->right, k - lefsum);
}

int main()
{
   //WRITE("abc.in");
   srand(unsigned(time(NULL)));
   int N, Q, a, b, cur;
   char command[15];
   sii(N, Q);
   ITR(i, 1, N+1) insert(tree[i], i, (rand() % MAX_PRIORITY) + 1), biggest[i] = i;
   cur = N+1;
   while(Q--) {
      scanf("%s", command);
      sii(a, b);
      if(!strcmp(command, "GET")) printf("%d\n", find(tree[a], b));
      else {
         /*
         join(tree[a], tree[b], biggest[a]);
         tree[cur] = tree[a];
         biggest[cur++] = max(biggest[a], biggest[b]);
         */
         tree[cur++] = unite(tree[a], tree[b]);
      }
   }
   return 0;
}
