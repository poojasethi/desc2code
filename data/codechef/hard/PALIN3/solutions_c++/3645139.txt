#define _CRT_SECURE_NO_WARNINGS
#pragma comment(linker, "/stack:16777216")
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility> 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i < (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
#define FILL(A,value) memset(A,value,sizeof(A))
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UINT;
typedef vector <int> VI;
typedef pair <int, int> PII;

const int INF = 1000000000;
const int MAX = 2000000;
const int MAX2 = 128;
const int BASE = 1000000000;

#define MOD 1000000007

int n;
char S[MAX];
int LOdd[MAX];
int LEven[MAX];
int C[MAX];
int D[MAX][3];

int main()
{
	#ifndef ONLINE_JUDGE
		freopen("in.txt", "r", stdin);
	#endif

	scanf("%s", S);
	n = strlen(S);
	FOR (i,0,n)
	{
		C[i] = (i == 0 ? 0 : C[i-1]);
		C[i] += (S[i] - '0');
		C[i] %= 3;
	}
	int l, r, k;
	l = 0, r = -1;
	FOR (i,0,n)
	{
		if (i > r)
			k = 1;
		else
			k = min(r-i, LOdd[l+r-i]);
		while (i-k >= 0 && i+k < n && S[i-k] == S[i+k])
			++ k;
		LOdd[i] = k;
		if (i+k-1 > r)
		{
			l = i-k+1;
			r = i+k-1;
		}
	}
	l = 0, r = -1;
	FOR (i,0,n)
	{
		if (i > r)
			k = 0;
		else
			k = min(r-i, LEven[l+r-i-1]);
		while (i-k >= 0 && i+k+1 < n && S[i-k] == S[i+k+1])
			++ k;
		LEven[i] = k;
		if (k > 0 && i+k > r)
		{
			l = i-k+1;
			r = i+k;
		}
	}

	int last;
	Int res = 0;

	FILL(D, 0);
	if (S[0] != '0')
		D[0][0] ++;
	FOR (i,1,n+1)
	{
		int cur = (S[i-1] - '0') % 3;
		int left = i-LOdd[i-1]+1;
		int prev = (i == 1 ? 0 : C[i-2]);
		int val = 0;
		FOR (j,0,3)
			if (((prev-j+3)*2 + cur) % 3 == 0)
				val = j;
		res += D[i-1][val] - (left-1 == 0 ? 0 : D[left-2][val]);
		FOR (j,0,3)
			D[i][j] = D[i-1][j];
		if (S[i] != '0')
			D[i][C[i-1]] ++;
		if (S[i-1] == '0')
			++ res;
	}
	
	FILL(D, 0);
	if (S[0] != '0')
		D[0][0] ++;
	FOR (i,1,n+1)
	{
		if (LEven[i-1] > 0)
		{
			int cur = 0;
			int left = i-LEven[i-1]+1;
			int prev = C[i-1];
			int val = 0;
			FOR (j,0,3)
				if (((prev-j+3)*2 + cur) % 3 == 0)
					val = j;
			res += D[i-1][val] - (left-1 == 0 ? 0 : D[left-2][val]);
		}
		FOR (j,0,3)
			D[i][j] = D[i-1][j];
		if (S[i] != '0')
			D[i][C[i-1]] ++;
	}

	printf("%lld\n", res);

	return 0;
}