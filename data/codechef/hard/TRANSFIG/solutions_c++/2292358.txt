#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <list>
#include <complex>
#include <queue>
#pragma comment(linker, "/STACK:266777216")
using namespace std;

#define assert(f) { if(!(f)) { fprintf(stderr,"Assertion failed: "); fprintf(stderr,#f); fprintf(stderr,"\n"); exit(1); } }

typedef long long LL;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<double> VD;
typedef pair<double,double> PDD;

const int inf=1000000000;
const LL INF=LL(inf)*inf;
const double eps=1e-9;
const double PI=2*acos(0.0);
#define bit(n) (1<<(n))
#define bit64(n) ((LL(1))<<(n))
#define pb push_back
#define sz size()
#define mp make_pair
#define cl clear()
#define all(a) (a).begin(),(a).end()
#define fill(ar,val) memset((ar),(val),sizeof (ar))
#define MIN(a,b) {if((a)>(b)) (a)=(b);}
#define MAX(a,b) {if((a)<(b)) (a)=(b);}
#define sqr(x) ((x)*(x))
#define X first
#define Y second

//clock_t start=clock();
//fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));

#define N 101010

#define MOD 1000000007
int fac[N];
int inv[N];
int invfac[N];

int SZ;
int p1[N],q1[N];
int p2[N],q2[N];

int bin(int n,int k)
{
  if(k<0 || k>n) return 0;
  return LL(fac[n]) * invfac[k] % MOD * invfac[n-k] % MOD;
}

int ans;

void rec(int L1,int R1,int L2,int R2)
{
  assert(R1-L1==R2-L2);
  int root = p1[L1];
  if(p2[R2]!=root) {ans=0;return;}
  if(L1==R1) return;
  int cnt=0;
  for(int k1=L1+1,k2=L2;k1<=R1;)
  {
    int j2 = q2[p1[k1]];
    if(j2<k2 || j2>=R2){ans=0;return;}
    int j1 = k1 + j2-k2;
    rec(k1,j1,k2,j2);
    k1=j1+1;
    k2=j2+1;
    cnt++;
  }
  ans = LL(ans) * bin(SZ,cnt) % MOD;
}

int main()
{
#ifndef ONLINE_JUDGE
  freopen("tra.in","r",stdin);
#endif
  for(int n=0;n<2;n++)
    fac[n]=inv[n]=invfac[n]=1;
  for(int n=2;n<N;n++)
  {
    fac[n] = LL(n) * fac[n-1] % MOD;
    inv[n] = LL(MOD - MOD/n) * inv[MOD%n] % MOD;
    invfac[n] = LL(inv[n]) * invfac[n-1] % MOD;
  }
  int T;
  for(scanf("%d",&T);T--;)
  {
    int n;
    scanf("%d%d",&n,&SZ);
    for(int i=1;i<=n;i++)
    {
      scanf("%d",p1+i);
      q1[p1[i]]=i;
    }
    for(int i=1;i<=n;i++)
    {
      scanf("%d",p2+i);
      q2[p2[i]]=i;
    }
    ans=1;
    rec(1,n,1,n);
    printf("%d\n",ans);
  }
  return 0;
}