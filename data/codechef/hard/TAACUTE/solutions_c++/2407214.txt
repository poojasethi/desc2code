#include <iostream>
#include <ctime>
#include <fstream>
#include <cmath>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <complex>
#include <utility>
#include <cctype>

using namespace std;

#define FORALL(i,a,b) for(int i=(a);i<=(b);++i)
#define FOR(i,n) for(int i=0;i<(n);++i)
#define FORB(i,a,b) for(int i=(a);i>=(b);--i)

typedef long long ll;
typedef long double ld;
//#define vec complex

typedef pair<int,int> pii;
typedef map<int,int> mii;

#define pb push_back
#define mp make_pair

const ld PI = atan2(0,-1);

#define MAXN 2004
#define EPS 1e-10
#define eq(a,b) (abs((a)-(b)) <= EPS)
template<class T> struct vec {
	T x,y;
	vec(T a, T b) : x(a), y(b) {}
	vec() : x(0), y(0) {}
	vec operator-(const vec& b) { return vec(x-b.x, y-b.y); }
};

/*	
template<class T> T dot(const vec<T>& a, const vec<T>& b) { return real(a*conj(b)); }
template<class T> T cross(const vec<T>& a, const vec<T>& b) { return imag(a*conj(b)); }
template<class T> ld angle(const vec<T>& a, const vec<T>& b){ return atan2(cross(a,b), dot(a,b)); }
template<class T> ld angle(const vec<T>& a) { return angle(a,vec<T>(1,0)); }
*/

template<class T> T dot(const vec<T>& a, const vec<T>& b) { return a.x*b.x + a.y*b.y; }
template<class T> T cross(const vec<T>& a, const vec<T>& b) { return a.y*b.x - a.x*b.y; }
template<class T> ld angle(const vec<T>& a, const vec<T>& b){ return atan2(cross(a,b), dot(a,b)); }
template<class T> ld angle(const vec<T>& a) { return angle(a,vec<T>(1,0)); }

vec<int> P[MAXN];
int f[MAXN][MAXN][2];
int g[MAXN][MAXN];

int main(){
	int N,x,y;
	cin >> N;
	FOR(i,N) scanf("%d%d",&x,&y), P[i] = vec<int>(x,y);
	//FOR(i,N) x=y=i*5, P[i] = vec<ld>(x,y);
	assert(PI == M_PI);
	unsigned int colin = 0;
	unsigned int ans = 0;
	FOR(i,N) {
		vector<pair<ld,int> > angles; angles.reserve(2*(N-1));
		FOR(j,N){
			if (i==j) continue;
			ld t = angle(P[j]-P[i]);
			angles.pb(mp(t,j));
			angles.pb(mp(t+2*M_PI,j));
		}
		
		sort(angles.begin(), angles.end());
		
		int M = angles.size();
		assert(M==2*(N-1));
		
		const int jstart = (M>>1)-1;
		ld t,s; int idx,pdx;
		int me = jstart;
		for(int j=jstart,k=M-1, h=M-1;j>=0;--j) {
			t = angles[j].first;
			idx = angles[j].second;
			if (!eq(t,angles[me].first)) me = j;
			if (j<jstart && (s=angles[j+1].first, pdx=angles[j+1].second, eq(t,s))) {
				f[i][idx][0] = f[i][pdx][0];  g[i][idx] = g[i][pdx]; colin+=(me-j); continue;
			}
			
			while(angles[k].first >= angles[j].first + PI/2. - EPS) k--;
			while(angles[h].first >= angles[j].first + PI - EPS) h--;
			
			assert(k>=j && h>=j);
			
			f[i][idx][0] = k-j;
			g[i][idx] = h-j;
		}
	}
	
	assert(!(colin&1));
	//
	//cout << colin/2 << endl;
	FOR(i,N) FOR(j,N) ans += g[i][j] - f[i][j][0];
	ans = 1ll*N*(N-1)*(N-2)/6 - ans - colin/2;
	cout << ans << endl;
}














