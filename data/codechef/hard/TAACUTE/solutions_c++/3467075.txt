// I use Dragans code (c0d3junki3) to learn sorting of points by using
// integer types instead of doubles and precisions

#include <vector>
#include <algorithm>
#include <cstdio>
#include <iostream>

using namespace std;

long long n;

vector<pair<int, int> > pts, ori;

bool cmp(pair<int, int> a, pair<int, int> b) {
  if (a.second <= 0 && b.second > 0) return 1;
  if (a.second > 0 && b.second <= 0) return 0;
  if (a.second == 0 && b.second == 0) return (a.first < b.first);
  if (a.first * b.second - b.first * a.second > 0) return 1;
  return 0;
}

bool isacute(pair<int, int> a, pair<int, int> b) {
    if (a.first * b.second - a.second * b.first >= 0 && a.first * b.first + a.second * b.second > 0) {
        return 1;
    }
    return 0;
}

bool isacute2(pair<int, int> a, pair<int, int> b) {
    if(a.first * b.second - a.second * b.first > 0 && a.first * b.first + a.second * b.second > 0) {
        return 1;
    }
    return 0;
}

int obtuse() {
    int ans = 0;
    int j = 0, a = 1, b = 1, m = n - 1;
    sort(pts.begin(), pts.end(), cmp);
    while (j < m) {
        while(isacute(pts[j], pts[a]) && a < m) {
            a++;
        }
        while(!isacute2(pts[b], pts[j]) && b < m) {
           b++;
        }
        ans += b - a;
        j++;
    }
    return ans;
}

long long nC3(long long a) {
    long long ans = (a * (a - 1) * (a - 2)) / 6;
    return ans;
}

int main()
{
    int x, y;
    long long res = 0, ans;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &x);
        scanf("%d", &y);
        ori.push_back(make_pair(x, y));
    }
    for (int i = 0; i < n; i++) {
        pts.clear();
        for (int j = 0; j < n; j++) {
            if (j != i) {
                pts.push_back(make_pair(ori[j].first - ori[i].first, ori[j].second - ori[i].second));
            }
        }
        res += 1LL*obtuse();
    }
    ans = nC3(n);
    cout << ans - res << "\n";
}
