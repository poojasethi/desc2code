#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<ctime>
#include<assert.h>

#include<cmath>
#include<iostream>
#include<fstream>

#include<string>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
#include<set>
#include<sstream>
#include<stack>
#include<limits.h>

using namespace std;

#define MAX(a,b) ((a)>(b) ? (a) : (b))
#define MIN(a,b) ((a)<(b) ? (a) : (b))
//#define EPS 1e-7
#define asdf exit(0);
#define PI 2*acos(0.0)



#define _abs(x)	 (((x)>0)?(x):-(x))
#define _max(x,y)	(((x)>(y))?(x):(y))
#define _min(x,y)	(((x)<(y))?(x):(y))
#define S(x)	((x)*(x))
#define D2(a,b)	(S(a.first-b.first) + S(a.second-b.second))
//typedef __int64	LL;
typedef long long LL;
typedef pair<int,int> Point;
Point RotateCCW90(Point p)
{
    return Point(-p.second,p.first);
}




int quad(const Point &a)
{
    if(!a.first && !a.second)	return 0;
    if(a.first >  0 && a.second >= 0)	return 1;
    if(a.first <= 0 && a.second >  0)	return 2;
    if(a.first <  0 && a.second <= 0)	return 3;
    return 4;
}
int sortPointByAngles(const Point &a,const Point &b)
{

//sort by quadrant [inc]
    int aa = quad(a);
    int bb = quad(b);
    if(aa!=bb)	return aa < bb;

//sort by angles [inc]
    LL area = ((LL)(a.first))*((LL)(b.second)) - ((LL)(a.second))*((LL)(b.first));
    if(area)	return area > 0;

//sort by distance from origin [inc]
    aa = _abs(a.first);
    bb = _abs(b.first);
    if(aa != bb)return aa < bb;

    aa = _abs(a.second);
    bb = _abs(b.second);
    return aa < bb;
}



int n;
Point p1[8100];
Point p2[8100];




// returns +ve if a to b is a clock wise direction w.r.to bas else -ve
int tri(Point bas,Point a,Point b)
{
    return (a.first-bas.first)*(b.second-bas.second)-(b.first-bas.first)*(a.second-bas.second);
}


/*
int le2(Point a,Point b,Point c)
{
    if(quad(a)==quad(c)){ return 1;}
    else if( ((quad(a)+1) ==quad(c)) ||  (quad(a)==4 && quad(c)==1) ) {return 1;}
	else if(((quad(a)+2) ==quad(c)) ||  (quad(a)==4 && quad(c)==2) || (quad(a)==3 && quad(c)==1) ){;}
    else return 0;


    if(tri(Point(0,0),b,c)<0) return 1;
    return 0;

}*/

int le(Point a,Point b,Point c)
{
    if(tri(Point(0,0),b,c)<0) return 1;
    return 0;

}


int eq(Point a,Point b)
{
    if(quad(a)!=quad(b))
    {
        return 0;
    }
    if(tri(Point(0,0),a,b)==0) return 1;
    return 0;

}

int vis[4][4];
int sum[8010];


int Sn(int i)
{
    if(i<0) return 0;
    return sum[i];
}




LL cal()
{
    int i,j,j1,j2,j3;
    LL ret=0,ret1=0;


    for(i=0,j1=0,j2=0,j3=0; i<n; i++)
    {
        while(j1<(i+n) && le(p2[i],RotateCCW90(p2[i]),p2[j1] ) ) j1++;

        j2=MAX(j1,j2);
        while(j2<(i+n) && eq(p2[i],p2[j2]))j2++;
        while(j2<(i+n) && le(p2[i],RotateCCW90(RotateCCW90(p2[i])),p2[j2] ) ) j2++;


        j3=MAX(j2,j3);
        while(j3<(i+n) && eq(p2[j3], RotateCCW90(RotateCCW90(p2[i])) ) ) j3++;


        if(sum[i]-Sn(i-1))
        {
            if(j2>j1)ret+=(Sn(j2-1)-Sn(j1-1));
            if(j3>j2)ret1+=(Sn(j3-1)-Sn(j2-1));
        }
    }

    ret1/=2;

    return (ret+ret1);
}




void make()
{
    int i,j;


    for(i=-1; i<=1; i++)
        for(j=-1; j<=1; j++)
        {
            p2[n++]=Point(i,j);
            vis[i+1][j+1]=1;
        }
    sort(p2,p2+n,sortPointByAngles);

    for(i=0; i<(n-2); i++) p2[i]=p2[i+2];
    n-=2;

    for(i=0; i<n; i++)
    {
        p2[i+n]=p2[i];
    }


    for(i=0; i<n; i++)
    {
        if( -1<=p2[i].first && p2[i].first<=1 && -1<=p2[i].second && p2[i].second<=1 && vis[p2[i].first+1][p2[i].second+1])
        {
            vis[p2[i].first+1][p2[i].second+1]--;
            sum[i]=0;
        }
        else sum[i]=1;
    }
    for(i=0; i<n; i++) sum[i+n]=sum[i];
    for(i=1; i<2*n; i++) sum[i]+=sum[i-1];

}




int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("in1.txt","w",stdout);
    int x,y,i,j;




    while(scanf("%d",&n)==1)
    {

        for(i=0; i<n; i++)
        {
            scanf("%d %d",&x,&y);
            p1[i]=Point(x,y);
        }




        LL N=n;
        LL ans=(N*(N-1)*(N-2))/6;



        for(i=0; i<n; i++)
        {
            for(j=0; j<n; j++)
            {
                p2[j].first=p1[j].first-p1[i].first;
                p2[j].second=p1[j].second-p1[i].second;
            }



            make();
            ans-=cal();


            n=(int)N;
        }


        printf("%lld\n",ans);

    }

    return 0;
}
