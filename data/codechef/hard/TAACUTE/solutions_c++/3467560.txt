// I use Dragans code (c0d3junki3) to learn sorting of points by using
// integer types instead of doubles and precisions

#include <vector>
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

long long n; int i;

struct slog  {
    int first, second;
    bool operator < (const slog &b) const {
      if (second <= 0 && b.second > 0) return 1;
      if (second > 0 && b.second <= 0) return 0;
      if (second == 0 && b.second == 0) return (first < b.first);
      if (first * b.second - b.first * second > 0) return 1;
      return 0;
    }
} pts[2005], ori[2005];

bool isacute(slog a, slog b) {
    if (a.first * b.second - a.second * b.first >= 0 && a.first * b.first + a.second * b.second > 0) {
        return 1;
    }
    return 0;
}

bool isacute2(slog a, slog b) {
    if(a.first * b.second - a.second * b.first > 0 && a.first * b.first + a.second * b.second > 0) {
        return 1;
    }
    return 0;
}

int obtuse() {
    int ans = 0;
    int j = 1, a = 1, b = 1, m = n - 1;
    sort(pts+1, pts+n);
    while (j <= m) {
        while( isacute (pts[j], pts[a]) && a <= m) a++;
        while(!isacute2(pts[b], pts[j]) && b <= m) b++;
        ans+=b-a;
        j++;
    }
    return ans;
}

int main()
{
    int x, y;
    long long res = 0, ans;
    cin >> n;
    for (int i=1; i<=n; i++) scanf("%d %d", &ori[i].first, &ori[i].second);
    for (i=1; i<=n; i++) {
        int k=0;
        for (int j=1; j<=n; j++) {
            if (j!=i) {
                pts[++k].first =ori[j].first -ori[i].first;
                pts[  k].second=ori[j].second-ori[i].second;
            }
        }
        res += 1LL*obtuse();
    }
    ans=(n*(n-1)*(n-2))/6;
    cout << ans - res << "\n";
}
