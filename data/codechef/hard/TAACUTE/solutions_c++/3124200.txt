#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<memory.h>
#include<cstdlib>
#include<cmath>
#include<cassert>
#include<memory.h>
#include<algorithm>
#include<queue>
#include<utility>
#include<map>
#include<bitset>
using namespace std;

typedef vector<int> VI;
typedef long long LL;
typedef unsigned long long uLL;
typedef pair<int, int> PII;
typedef vector<PII> VPII;
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#pragma comment(linker, "/STACK:266777216")

const int inf=1000000000;
const LL INF=LL(inf)*inf;
const double eps=1e-9;
const double PI=2*acos(0.0);

int N;
VPII pts, ori;

bool cmp(PII a, PII b) //sorts pts in anticlockwise order starting from negative x axis
{
  if(a.se<=0 && b.se>0)return 1;
  if(a.se>0 && b.se<=0)return 0;
  if(a.se == 0 && b.se==0)return (a.fi<b.fi);
  if(a.fi*b.se - b.fi*a.se>0)return 1;
  return 0;
}
bool isacute(PII a, PII b)  //to check if less than 90 degree
{
    if(a.fi*b.se - a.se*b.fi >= 0 && a.fi*b.fi + a.se*b.se>0)
    {
        return 1;
    }
    return 0;
}
bool isacute2(PII a, PII b) //stronger version to check if >270 degree
{
    if(a.fi*b.se - a.se*b.fi > 0 && a.fi*b.fi + a.se*b.se>0)
    {
        return 1;
    }
    return 0;
}

LL obtuse()
{
    //To find number of obtuse angles
    LL ans = 0;
    int j=0, a=1,b=1, M=N-1;

    sort(pts.begin(), pts.end(), cmp);

    while(j<M)
    {
        //To find least index where angle is >= 90 degree
        while(isacute(pts[j], pts[a]) && a<M)
        {
            a++;
        }
        //To find least index where angle is >270 degree
        while(!isacute2(pts[b], pts[j]) && b<M)
        {
           b++;
        }
        ans += (LL)(b-a);
        j++;
    }
    return ans;
}

LL nC3(int a)
{
    LL ans = ((LL)a*(a-1)*(a-2))/6;
    return ans;
}

void solve()
{
    ori.clear();
    int x, y;
    LL res = 0, ans;

    scanf("%d", &N);
    for(int i=0; i<N; i++)
    {
        scanf("%d%d", &x, &y);
        ori.pb(mp(x,y));
    }

    for(int i=0; i<N; i++) //Do it taking each point as O
    {
        pts.clear();
        for(int j=0; j<N; j++)
        {
            if(j!=i)
            {
                pts.pb(mp(ori[j].fi - ori[i].fi, ori[j].se - ori[i].se));
            }
        }
        res+= obtuse();
    }
    ans = nC3(N);
    printf("%lld\n", ans - res );
}

int main()
{
    #ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);
    #endif
    solve();
}
