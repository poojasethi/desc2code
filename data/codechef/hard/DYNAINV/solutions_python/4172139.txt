import sys,copy
mynumber=0
def merge(a,b,n,m):
    global mynumber
    i=0
    j=0
    c=[]
    if(n==0):
        return b
    if(m==0):
      return a
    while((i<n) and (j<m)):
        if(a[i]<=b[j]):
            c+=[a[i]]
            i+=1
        else:
            c+=[b[j]]
            mynumber+=len(a[i:])
            j+=1
    if(i<n):
        c+=a[i:]
    if(j<m):    
        c+=b[j:]
    return c
def mergesort(a,n):
    if(n==1):
        return a
    else:
        b=mergesort(a[:n/2],n/2)
        c=mergesort(a[n/2:],n-n/2)
        return merge(b,c,n/2,n-n/2)
def count_inversions(arr,n):
    global mynumber
    mynumber=0
    arr2=copy.deepcopy(arr)
    #arr2[x],arr2[y]=arr2[y],arr2[x]
    mergesort(arr2,n)
    return mynumber
def another_count_inversions(arr,n):
    i=0
    count=0
    while i<n:
        j=i+1
        while j<n:
            if(arr[j]<arr[i]):
                count+=1
            j+=1
        i+=1
    return count
def count_inversions2(a,n):
  res = 0
  counts = [0]*(n+1)
  rank = { v : i+1 for i, v in enumerate(sorted(a)) }
  for x in reversed(a):
    i = rank[x] - 1
    while i:
      res += counts[i]
      i -= i & -i
    i = rank[x]
    while i <= len(a):
      counts[i] += 1
      i += i & -i
  return res
n,q=[int(x) for x in raw_input().split()]
arr=[int(x) for x in raw_input().split()]
value=count_inversions2(arr,n)
while q:
    x,y=[int(x) for x in raw_input().split()]
    if(x>y):
            if(arr[x-1]>arr[y-1]):
                value+=1
            else:
              value-=1
    else:
            if(arr[y-1]>arr[x-1]):
                value+=1
            else:
              value-=1
    k=x-1
    z=y-1
    arr[k],arr[z]=arr[z],arr[k]
    print value%2
    q-=1
    
