//counts number of inversions
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

#define F(x) (x&(x+1))
#define H(x) (x|(x+1))

int tree[100001];
//return sum upto index r in O(log(Maxval))
int sum(int r){
	int result=0;
	for(;r>=0;r=F(r)-1)
		result+=tree[r];
	return result;
}

//update the value of tree[j] for which F(j)<=i<=j -O(log(Maxval))
int inc(int i,int delta,int n){
	for(;i<n;i=H(i))
		tree[i]+=delta;
}

//convert original array to array of unique integers from 0 to n-1
void convert(int a[],int b[],int n){
	sort(b,b+n);
	for(int i=0;i<n;i++)
		a[i]=lower_bound(b,b+n,a[i])-b;

}


int main(){
	int n,q,x,y;
    cin>>n>>q;
	int a[n],b[n];
	memset(tree,0,sizeof(tree));

    for(int i=0;i<n;i++){
        cin>>a[i];
		b[i]=a[i];
	}
	convert(a,b,n);

	long long count=0;
	for(int i=n-1;i>=0;i--){
		count+=sum(a[i]);
		inc(a[i],1,n);
	}
	bool ans=count%2;
	while(q--){
		cin>>x>>y;
		ans^=1;
		cout<<ans<<endl;
	}
		
	return 0;
}

