/* Writen by Filip Hlasek 2012 */
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <cmath>
#include <cstring>
 
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define REP(i,b) for(int i=0;i<b;i++)
 
using namespace std;
 
int N,M,I;
 
#define MAXN 2222
 
int A[MAXN][MAXN];
int left[MAXN],right[MAXN],leftdown[MAXN],rightdown[MAXN],dp[2][MAXN];
 
int main(int argc, char *argv[]){
  int T; 
  scanf("%d",&T);
  while(T--){
    scanf("%d%d%d",&N,&M,&I);
    if(I==1){
      REP(i,N) REP(j,M) scanf("%d",&(A[i][j]));
    }
    else{
      int X,P,Q,MM;
      scanf("%d%d%d%d",&X,&P,&Q,&MM);
      int cur = X;
      REP(i,N) REP(j,M){
         cur = ( cur * P + Q ) % MM;
         A[i][j] = X - cur;
      }
    }
    int act = 1;
    REP(j,M){
      left[j] = A[N-1][j];
      if(j && left[j-1]>0) left[j]+=left[j-1];
    }
    FORD(j,M-1,0){
      right[j] = A[N-1][j];
      if(j<M-1 && right[j+1]>0) right[j]+=right[j+1];
    }
    REP(i,M) dp[act][i] = left[i] + right[i] - A[N-1][i];
 
    FORD(i,N-2,0){
      act = 1-act;
      REP(j,M){
        left[j] = A[i][j];
        if(j && left[j-1]>0) left[j]+=left[j-1];
        leftdown[j] = left[j] + dp[1-act][j];
        if(j) leftdown[j] = max(leftdown[j],A[i][j]+leftdown[j-1]);
      }
      FORD(j,M-1,0){
        right[j] = A[i][j];
        if(j<M-1 && right[j+1]>0) right[j]+=right[j+1];
        rightdown[j] = right[j] + dp[1-act][j];
        if(j<M-1) rightdown[j] = max(rightdown[j],A[i][j]+rightdown[j+1]);
      }
      REP(j,M){
        dp[act][j] = dp[1-act][j]+left[j]+right[j]-A[i][j];
        dp[act][j] = max(dp[act][j],right[j]+leftdown[j]-A[i][j]);
        dp[act][j] = max(dp[act][j],rightdown[j]+left[j]-A[i][j]);
      }
    }
    int best = -1000000000;
    REP(i,M) best = max(best, dp[act][i]);
    printf("%d\n",best);
  }
  return 0;
}