#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <map>

#define REP(a,b) for (int a = 0; a < b; a++)
#define FOR(a,b,c) for (int a = b; a <= c; a++)
#define RESET(a,b) memset(a,b,sizeof a)

#define PII pair<int,int>
#define MP make_pair
#define LL long long

#define INF 2123123123
#define F first
#define S second

using namespace std;

int nkasus;
int r,c,jm;
int m[2013][2013];
int maxl[2013],maxr[2013];
int dp[2][2013][3];
int ans;
LL X,P,M,Q;

int main(){
	scanf("%d", &nkasus);
	REP(jt,nkasus){
		scanf("%d%d%d", &r, &c, &jm);
		
		if (jm == 1){
			REP(i,r){
				REP(j,c){
					scanf("%d", &m[i][j]);
				}
			}
		}else{
			scanf("%lld%lld%lld%lld", &X, &P, &Q, &M);
			
			LL cur = X;
			REP(i,r){
				REP(j,c){
					cur = (cur * P + Q) % M;
					m[i][j] = (int)(X - cur);
				}
			}
			/*
			REP(i,r){
				REP(j,c){
					printf("%d ", m[i][j]);
				}
				printf("\n");
			}
			*/
		}
		
		if (c == 1){
			ans = 0;
			REP(i,r){
				ans += m[i][0];
			}
		}else{
			int g = 0;
			RESET(dp,0);
			REP(i,r){
				//isi <-|
				int cur = 0;
				REP(j,c){
					cur += m[i][j];
					if (cur < 0) cur = 0;
					maxl[j] = cur;
				}
				//isi |->
				cur = 0;
				for (int j = c-1; j >= 0; j--){
					cur += m[i][j];
					if (cur < 0) cur = 0;
					maxr[j] = cur;
				}
			
				//isi DP <-|
				dp[g][0][1] = m[i][0] + dp[1-g][0][0];
				FOR(j,1,c-1){
					dp[g][j][1] = m[i][j] + max(dp[g][j-1][1], maxl[j-1] + dp[1-g][j][0]);
				}	
		
				//isi DP |->
				dp[g][c-1][2] = m[i][c-1] + dp[1-g][c-1][0];
				for (int j = c-2; j >= 0; j--){
					dp[g][j][2] = m[i][j] + max(dp[g][j+1][2], maxr[j+1] + dp[1-g][j][0]);
				} 
			
				//isi DP v
				//printf("*%d %d %d %d\n", m[i][0], dp[1-g][0][0], maxr[1], dp[g][1][2]);
				dp[g][0][0] = m[i][0] + max(dp[1-g][0][0] + maxr[1], dp[g][1][2]);
				dp[g][c-1][0] = m[i][c-1] + max(dp[1-g][c-1][0] + maxl[c-2], dp[g][c-2][1]);
				FOR(j,1,c-2){
					//turun
					dp[g][j][0] = m[i][j] + maxl[j-1] + maxr[j+1] + dp[1-g][j][0];
					//kiri
					dp[g][j][0] = max(dp[g][j][0], m[i][j] + maxr[j+1] + dp[g][j-1][1]);
					//kanan
					dp[g][j][0] = max(dp[g][j][0], m[i][j] + maxl[j-1] + dp[g][j+1][2]);
				}
			/*
				REP(j,c){
					printf("%d ", maxl[j]);
				}
				printf("\n");
				
				REP(j,c){
					printf("%d ", maxr[j]);
				}
				printf("\n");
				
				REP(k,3)
					REP(j,c){
						printf("%d %d %d = %d\n", i, j, k,  dp[g][j][k]);
					}
			*/
				g = 1-g;
			}
			
			ans = -INF;
			REP(j,c){
				ans = max(ans, dp[1-g][j][0]);
			}
		}
		
		printf("%d\n", ans);
	}

	return 0;
}
