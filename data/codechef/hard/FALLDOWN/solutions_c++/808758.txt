#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <set>
#include <map>
#include <vector>
#include <string>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <algorithm>
#include <sstream>
#include <cassert>
using namespace std; 

#define f first
#define s second
#define mp make_pair
#define sz(a) int((a).size()) 
#define pb push_back 
#define all(c) (c).begin(),(c).end() 
#define forit(it,S) for(typeof(S.begin()) it = S.begin(); it != S.end(); ++it)

const long long inf = 2100000000;
int a[2015][2015], rg[2015], lg[2015];
int n, m;
int prev[2015], cur1[2015], s[2015], res[2015], sum[2015], cur2[2015];

int main() {
	int tests;
	for (scanf("%d", &tests); tests > 0; --tests) {
		int type;
		scanf("%d%d%d", &n, &m, &type);	
		if (type == 1) {
			for (int i = 1; i <= n; ++i)
				for (int j = 1; j <= m; ++j)
					scanf("%d", &a[i][j]);
		}
		else {
			int x, p, q, mod;
			scanf("%d%d%d%d", &x, &p, &q, &mod);
			int cur = x;
			for (int i = 1; i <= n; ++i) {
				for (int j = 1; j <= m; ++j) {
					cur = (cur * p + q) % mod;
					a[i][j] = x - cur;
				}
			}
		}
		for (int j = 0; j <= m + 1; ++j) {
			prev[j] = 0;
			s[j] = 0;
		}			
		for (int i = 1; i <= n; ++i) {		
			int mn = 0;
			int mnp = 0;
			for (int j = 1; j <= m; ++j) {
				s[j] = s[j - 1] + a[i][j];
				cur1[j] = s[j] - mn;
				lg[j] = mnp;
				if (s[j] < mn) {
					mn = s[j];
					mnp = j;
				}
			}				
			mn = 0;
			mnp = m + 1;
			for (int j = m; j >= 1; --j) {
				s[j] = s[j + 1] + a[i][j];
				cur2[j] = s[j] - mn;
				rg[j] = mnp;
				if (s[j] < mn) {
					mn = s[j];
					mnp = j;
				}
			}	
				
			int mx = -inf;
			for (int j = 1; j <= m; ++j) {
				mx = max(mx, prev[j] + cur1[j] - a[i][j]);
				res[j] = mx + cur2[j];
				mx += a[i][j];
			}
			mx = -inf;
			for (int j = m; j >= 1; --j) {
				mx = max(mx, prev[j] + cur2[j] - a[i][j]);
				res[j] = max(res[j], mx + cur1[j]);
				mx += a[i][j];
			}	
			
			for (int j = 1; j <= m; ++j)
				prev[j] = res[j];				
		}		
		cout << *max_element(res + 1, res + m + 1) << endl;
	}
	return 0;		
}
