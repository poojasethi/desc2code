#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <functional>
#include <math.h>

inline bool fastreadIsEndOfLine(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
    if(c == '\r' || c == '\n')
      return true;
  }

  return false;
}

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadNeg(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  bool neg = false;
  if(c == '-')
  {
	  c = getchar();
	  neg = true;
  }
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }

  if(neg)
	  *a = -*a;
}

int primes[80000 + 1]; // Enough to contain primes up to 1000001 (10^6 is maximum for A[i])
int primesOccur[80000 + 1]; // Max occurance for primes
int primeCount = 0;
int lowestPrime[1000000 + 1];
void CollectPrimes(int upperBound)
{
  memset(lowestPrime, 0, sizeof(lowestPrime));
  lowestPrime[0] = lowestPrime[1] = 1;
  primes[primeCount++] = 1;

  for(int i = 2; i < upperBound; i += 1)
  {
    if(lowestPrime[i] > 0)
      continue;

    primes[primeCount] = i;
    lowestPrime[i] = primeCount;

    int k = i + i;
    while(k < upperBound)
    {
      lowestPrime[k] = primeCount;
      k += i;
    }
    ++primeCount;
  }
}

int N, K, M;
int T = 1;
int A[1000000 + 1];

int CachePrimIndex[1000000 + 1][21];
char CacheOccur[1000000 + 1][21];
char CachePrimCount[1000000 + 1];

void factorizeRec(int a)
{
  if(a != 1)
  {
	  char &primCount = CachePrimCount[a];
    if(primCount == 0)
    {
      int *primIndex = CachePrimIndex[a];
      char *occur = CacheOccur[a];

      int i = lowestPrime[a];
      //int *pr = primes;
      //label1:
      //if(a % *pr != 0) // try next prime
      //{
      //  ++pr;
      //  goto label1;
      //}

      a = a / primes[i];
      factorizeRec(a); // Call recursively

      // Copy the previous number's data and add our new prime on top of it
      primCount = CachePrimCount[a];
      const int *primIndexA = CachePrimIndex[a];
      const char *occurA = CacheOccur[a];

      bool found = false;
      for(int j = 0; j < primCount; ++j)
      {
        primIndex[j] = primIndexA[j];
        occur[j] = occurA[j];

        if(primIndex[j] == i)
        {
          occur[j]++;
          found = true;
        }
      }

      if(!found)
      {
        primIndex[primCount] = i;
        occur[primCount] = 1;
        ++primCount;
      }

    }
  }
}

void factorizeRecTop(int a)
{
  const int *primIndex = CachePrimIndex[a];
  const char *occur = CacheOccur[a];
	const char &primCount = CachePrimCount[a];
  if(primCount == 0)
    factorizeRec(a);

	for(int i = 0; i < primCount; ++i)
	{
    int &po = primesOccur[primIndex[i]];
    const int &o = occur[i];
		if(po < o)
		{
			po = o;
		}
	}
}






int main()
{
  CollectPrimes(1000000 + 1);
  memset(CachePrimCount, 0, sizeof(CachePrimCount));

#ifdef USE_DATA_TXT
  freopen_s(&stream, "C:\\Projects\\TaskTemplate\\data.txt", "r", stdin);
#endif
#ifdef PRINT_PERF
  auto start = std::chrono::high_resolution_clock::now();
#endif

  //FILE *fff = fopen("c:\\data.txt", "wt");
  //for(int k = 0; k < 100000; ++k)
  //{
  //  fprintf(fff, "%d ", 1000000);
  //}
  //fprintf(fff, "\n");
  //fclose(fff);



  fastread(&T);

  while(T--)
  {
    fastread(&N);

    memset(primesOccur, 0, sizeof(primesOccur));

    for(int i = 0; i < N; ++i)
    {
      fastread(A + i);
    }

    for(int i = 0; i < N; ++i)
    {
      factorizeRecTop(A[i]);
    }

    int answer = 0;
    for(int i = 0; i < primeCount; ++i)
    {
      answer += primesOccur[i];
    }

    printf("%d\n", answer);
  }

#ifdef PRINT_PERF
  PrintResultPerf(start);
#endif
#ifdef USE_DATA_TXT
  if(stream)
  {
    fclose(stream);
    stream = NULL;
  }
#endif

  return 0;
}
