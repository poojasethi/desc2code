#include <cstdio>
#include <cstring>
#include <vector>
#include <map>
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;

int order[1<<15]; // maps the majority voting

void prepareOrdering (vector <int> &ans , int i , int m)
{
	if (m == 1)
	{
		ans.push_back(order[i]+1);
		return;
	}
	int k = order[i];
	i = i ^ (1 << order[i]); // remove the ith candidate
	prepareOrdering(ans,i,m-1);
	ans.push_back(k+1);
}

void print (vector <int> a)
{
	for (int i = 0; i < a.size()-1; i++) printf("%d ",a[i]);
	printf("%d\n",a[a.size()-1]);
}

string getBits (int n, int m)
{
	string s;
	for (int i = 0; i < m; i++) s += "0";
	if (n == 0) return s;
	int i = 0;
	while (n)
	{
		s[i++] = (n%2)+'0';
		n /= 2;
	}
	return s;
}	

main ()
{
	int t;	
	scanf ("%d",&t);

	while (t--)
	{
		int n,m,i,j,k;
		scanf ("%d%d",&n,&m);

		int arr[n][m];

		// input the preference orders
		for (i = 0; i < n; i++)
		{
			for (j = 0; j < m; j++) 
			{
				scanf ("%d",&arr[i][j]);
				arr[i][j]--;
			}
		}
		
		// find dist for each edge i -> j
		int dist[20][20];
		memset(dist,0,sizeof(dist));
		for (i = 0; i < n; i++)
		{
			for (j = 0; j < m; j++)
			{
				for (k = j+1; k < m; k++)
				{
					dist[arr[i][k]][arr[i][j]]++;
				}
			}
		}

		/*for (int i = 0; i < m; i++)
		{
			for (int j = 0; j < m; j++) cout << dist[i][j] << " ";
			cout << "\n";
		}*/

		int memo[1<<15];
		memset(order,-1,sizeof(order));
		memset(memo,-1,sizeof(memo));
		memo[0] = 0; // no candidate in subset initially, hence dp value 0 too
	
		for (int i = 0; i < (1 << m); i++)
		{
			string s = getBits(i,m);
			
			for (int j = 0; j < m; j++)
			{
				if (s[j] == '1')
				{
					int distance = 0;
					for (int k = 0; k < m; k++)
					{
						if (s[k] == '0')
						{
							distance += dist[j][k];
						}
					}
					// remove the candidate j by toggling the jth bit of i
					//cout << i << " " << (i^(1<<j)) << "\n";
					distance += memo[ i ^ (1 << j) ]; // add the already best value without this candidate
					if (memo[i] == -1)
					{
						memo[i] = distance;
						order[i] = j;
					}
					else if (memo[i] > distance) // find new best value
					{
						memo[i] = distance;
						order[i] = j;
					}
				}
			}
		}
	
		printf ("%d: ",memo[(1<<m)-1]);
		
		// prepare the best ordering
		vector <int> ans;
		prepareOrdering(ans,(1<<m)-1,m);
		
		print(ans);
	}
}
			
