/*-------Heavy Light Decomposition--------*/
#include<bits/stdc++.h>
//#define DEBUG
//#ifdef DEBUG
//code to debug
//#endif
//#undef DEBUG
using namespace std;
const int maxn=100005,ln=17;
const int mod=1e9+7;
#define F(i,p,n) for(int i=p;i<n;i++)
#define I(i,p,q) for(int i=p;i>=q;i--)
#define Ss(x) scanf("%s",x)
#define S(x) scanf("%d",&x)
#define Ps(x) printf("%d  ",x)
#define P(x) printf("%d\n",x)
typedef long long int LL;
#define Bug(x) cout << #x << "=" << x << endl
#define pii pair<int,int>
#define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int
#define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit


int par[ln][maxn],depth[maxn];
int tree[6*maxn],subsize[maxn];
vector<int> adj[maxn],weight[maxn],edge[maxn];
int arr[maxn],arrpos[maxn],chainhead[maxn],chainlen[maxn],chainno,sz,chainind[maxn],chainpos[maxn],edgeinfo[maxn];

void build_tree(int node,int a,int b)
{
    if(a>b)
        return;
    if(a==b)
    {
        tree[node]=arr[a];
        return;
    }
    build_tree(2*node,a,(a+b)>>1);
    build_tree(2*node+1,(a+b)/2+1,b);
    tree[node]=tree[2*node]+tree[2*node+1];
}

void update_tree(int node,int a,int b,int x,int val)
{

    if(a>b||x>b||x<a)
        return;
    if(x==a&&b==x)
    {
        tree[node]=val;
        return;
    }
    update_tree(2*node,a,(a+b)/2,x,val);
    update_tree(1+2*node,((a+b)/2)+1,b,x,val);
    tree[node]=tree[2*node]+tree[2*node+1];
}

int query_tree(int node,int a,int b,int i,int j)
{
    if(a>b||i>b||j<a)
        return 0;
    int ret;
    if(a >= i && b <= j)
		return tree[node];
    int q1=query_tree(2*node,a,(a+b)/2,i,j);
    int q2=query_tree(1+2*node,((a+b)/2)+1,b,i,j);
    return ret=(q1+q2);
}

int lca(int u,int v)
{
    if(depth[u] < depth[v])
        swap(u,v);
	int diff = depth[u] - depth[v];
	for(int i=0; i<ln; i++)
        if( (diff>>i)&1 )
            u = par[i][u];
	if(u == v)
        return u;
	for(int i=ln-1; i>=0; i--)
        if(par[i][u] != par[i][v])
        {
            u = par[i][u];
            v = par[i][v];
        }
	return par[0][u];
}

void hld(int cur, int w, int prev) {
	if(chainhead[chainno] == 0)
    {
		chainhead[chainno] = cur;
	}
	chainind[cur] = chainno;
	arrpos[cur] = ++sz;
	arr[sz] = w;
	chainpos[cur]=++chainlen[chainno];

	int sc = -1, cost;

	for(int i=0; i<adj[cur].size(); i++)
        if(adj[cur][i] != prev)
        {
            if(sc == -1 || subsize[sc] < subsize[adj[cur][i]])
            {
                sc = adj[cur][i];
                cost = weight[cur][i];
            }
        }

	if(sc != -1)
    {
		hld(sc, cost, cur);
	}

	for(int i=0; i<adj[cur].size(); i++)
        if(adj[cur][i] != prev)
        {
            if(sc != adj[cur][i])
            {
                chainno++;
                hld(adj[cur][i], weight[cur][i], cur);
            }
        }
}

void dfs(int cur,int p ,int d)
{
    par[0][cur]=p;
    subsize[cur]=1;
    depth[cur]=d;
    F(i,0,adj[cur].size())
    {
        if(!subsize[adj[cur][i]])
        {
            edgeinfo[edge[cur][i]]=adj[cur][i];
            dfs(adj[cur][i],cur,d+1);
            subsize[cur]+=subsize[adj[cur][i]];
        }
    }
}

int chain_query(int u,int v)
{
    int uchain,vchain=chainind[v],ans=0,res;
    while(1)
    {
        uchain=chainind[u];
        if(uchain==vchain)
        {
            if(u==v)
                break;
            res=query_tree(1,1,sz,arrpos[v]+1,arrpos[u]);
            ans+=res;
            break;
        }
        res=query_tree(1,1,sz,arrpos[chainhead[uchain]],arrpos[u]);
        ans+=res;

		u = chainhead[uchain];
		u = par[0][u];
    }
    return ans;
}

void query(int x,int y)
{
    int com=lca(x,y);
    P(chain_query(x,com)+chain_query(y,com));
}

void change(int x,int y)
{
    update_tree(1,1,sz,arrpos[edgeinfo[x]],y);
}

int main()
{

        int n;
        S(n);

        sz=0;
        chainno=1;
        F(i,1,n)
        {
            int p,q,w;
            S(p);
            S(q);
            S(w);
            adj[p].push_back(q);
            adj[q].push_back(p);
            weight[p].push_back(w);
            weight[q].push_back(w);
            edge[p].push_back(i);
            edge[q].push_back(i);
        }

        dfs(1,0,0);
        hld(1,0,0);
        build_tree(1,1,sz);

        F(i,1,ln)
        {
            F(j,1,n+1)
            {
                if(par[i-1][j])
                    par[i][j]=par[i-1][par[i-1][j]];
            }
        }
        int q;
        S(q);

        while(q--)
        {
            int tp;
            S(tp);

            int x,y;
            S(x);
            S(y);
            if(tp==1)
                change(x,y);
            else
                query(x,y);
        }
    return 0;
}
