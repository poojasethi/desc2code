//LCA Segment tree
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<queue>
#include<utility>
#include<cstring>
#include<cmath>
#define LL long long int
#define mod 1000000007
#define vi vector<int>
#define vvi vector < vi >
#define pii pair<int,int>
#define all(c) c.begin(),c.end()
#define sf(n) scanf("%d",&n);
#define sl(n) scanf("%lld",&n);
#define mem(a,val) memset(a,val,sizeof(a))
#define nl printf("\n");
#define pb push_back
#define mp make_pair
#define f first
#define s second
#define MAXN 100005
using namespace std;
bool vis[MAXN];
int N,par[MAXN],tree[MAXN],edge[MAXN],seg[5*MAXN]={0},start[MAXN],end[MAXN],level[MAXN],P[MAXN],depth,nr;
vi v[MAXN],cost[MAXN];
pair<int,int> iedge[MAXN];
void build_tree(int node,int a,int b)
{	if(a>b) return ;
	if(a==b) 
	{	seg[node]=0;
		return ;
	}
	build_tree(2*node,a,(a+b)/2);
	build_tree(2*node+1,(a+b)/2+1,b);
	seg[node]=seg[2*node]+seg[2*node+1];
	return ;
}
void update_tree(int node,int a,int b,int st,int en,int val)
{	if(a>b||en<a||st>b) return;
	if(st<=a&&b<=en) 
	{	seg[node]+=val;
		return ;
	}
	update_tree(2*node,a,(a+b)/2,st,en,val);
	update_tree(2*node+1,(a+b)/2+1,b,st,en,val);	
}
int query_tree(int node,int a,int b,int u)
{	int ans=0;
	if(a>b||u<a||u>b) return 0;
	if(a==b) return seg[node];
	ans+= query_tree(2*node,a,(a+b)/2,u);
	ans+= query_tree(2*node+1,(a+b)/2+1,b,u);
	return ans+seg[node];
}
void max_depth(int src)
{	int i;
	vis[src]=true;
	for(i=0;i<v[src].size();i++)
	{	if(!vis[v[src][i]])
		{	level[v[src][i]]=level[src]+1;
			if(depth<level[v[src][i]]) depth=level[v[src][i]];
			max_depth(v[src][i]);
		}
	}
}
int dfs(int src)
{	int i,last;
	static int k=1;
	vis[src]=true;
	tree[k]=src;
	start[src]=k;
	last=k;
	//LCA precompute
	if(level[src]<nr)
        P[src]=1;
    else
    {	if(!(level[src]%nr))
            P[src]=par[src];
        else
            P[src]=P[par[src]];
    }
	for(i=0;i<v[src].size();i++)
	{	if(!vis[v[src][i]])
		{	k++;
			par[v[src][i]]=src;
			edge[v[src][i]]=edge[src]+cost[src][i];
			last=dfs(v[src][i]);
		}
	}
	return end[src]=last;
}
int LCA(int x,int y)
{	while(P[x]!=P[y])
    {	if(level[x]>level[y])
        	x=P[x];
        else
     		y=P[y];
    }
         
    while(x!= y)
    {	if(level[x]>level[y])
        	x=par[x];
        else
             y=par[y];
    }
  	return x;
}
void clear()
{	int i;
	for(i=1;i<=N;i++)
	{	v[i].clear();
		vis[i]=false;
	}
	par[1]=-1;
	edge[1]=0;
	level[1]=1;
	depth=1;
	
}
void input()
{	int i,x,y,c;
	sf(N);
	for(i=1;i<N;i++)
	{	sf(x);sf(y);sf(c);
		v[x].pb(y);
		v[y].pb(x);
		iedge[i]=mp(x,y);
		cost[x].pb(c);
		cost[y].pb(c);
	}
}
void output()
{	int q,u,v,w,a,b,i,c,d,e,f;
	sf(q);
	while(q--)
	{	sf(u);sf(v);sf(w);
		if(u==1)
		{	if(par[iedge[v].f]==iedge[v].s)
			{	e=query_tree(1,1,N,start[iedge[v].f])+edge[iedge[v].f];
				f=query_tree(1,1,N,start[iedge[v].s])+edge[iedge[v].s];
				update_tree(1,1,N,start[iedge[v].f],end[iedge[v].f],w-(e-f));
			}
			else	
			{	e=query_tree(1,1,N,start[iedge[v].f])+edge[iedge[v].f];
				f=query_tree(1,1,N,start[iedge[v].s])+edge[iedge[v].s];
				update_tree(1,1,N,start[iedge[v].s],end[iedge[v].s],w-(f-e));
			}
		}
		else
		{	a=query_tree(1,1,N,start[v])+edge[v];
			b=query_tree(1,1,N,start[w])+edge[w];
			c=LCA(v,w);
			d=query_tree(1,1,N,start[c])+edge[c];
			printf("%d\n",a+b-2*d);
		}
	}
}
int main()
{	clear();
	input();
	max_depth(1);
	nr=sqrt(depth);
	mem(vis,false);
	dfs(1);
	build_tree(1,1,N);
	//debug();
	output();
	return 0;
}
