#include <bits/stdc++.h>
using namespace std;
 
#define N 100005
#define LN 17
#define root 1
 
vector<pair<int, int> > adjList[N];	//stores destination and weight.
pair<int, pair<int, int> > edges[N];	//stored the edges.
int subsize[N], depth[N], p[N][LN+5];
int chainNo[N], chainHead[N], position[N], baseArray[N];
int seg[4*N];
int n, chainNumb, ptr;
 
int dfs1(int u, int h, int prev){
    depth[u] = h;	//give depth
    p[u][0] = prev;	//give parent
    subsize[u] = 1; //base case.
    for(int i=0;i<adjList[u].size();i++)
        if(adjList[u][i].first!=prev)
            subsize[u] += dfs1(adjList[u][i].first, h+1, u);	//add to subsize
    return subsize[u];
}
 
void hld(int u, int prev, int cost){
	if(chainHead[chainNumb]==0)	chainHead[chainNumb] = u;	//this is the head, if chainHead is undeclared.
    int special_child = -1, special_cost;
    ptr++;
    position[u] = ptr;  //position of u in baseArray
    baseArray[ptr] = cost;   //cost of edge in baseArray
    chainNo[u] = chainNumb; //chain of uth node
    for(int i=0;i<adjList[u].size();i++)
        if((special_child==-1 || subsize[adjList[u][i].first] > subsize[special_child]) && adjList[u][i].first!=prev)
            special_child = adjList[u][i].first, special_cost = adjList[u][i].second;
 
    if(subsize[u]==1)   return ;
 
    if(special_child!=-1)    hld(special_child, u, special_cost);   //extend chain to its special child.
    for(int i=0;i<adjList[u].size();i++){
        if(special_child!=adjList[u][i].first && adjList[u][i].first!=prev){
                chainNumb++;    //new chain
                hld(adjList[u][i].first, u, adjList[u][i].second);  //if not special child, then start a new chain.
        }
    }
}
 
void build_tree(int nd, int l, int r){
    if(l==r)    seg[nd] = baseArray[l];
    else{
        int mid = (l+r)/2;
        build_tree(nd*2, l, mid);
        build_tree(nd*2+1, mid+1, r);
        seg[nd] = seg[nd*2] + seg[nd*2+1];
    }
}
 
int query_segment_tree(int nd, int l, int r, int a, int b){
    if(a > r || b < l || a > b)  return 0;
    else if(l>=a && r<=b)   return seg[nd];
    else{
        int mid = (l+r)/2;
        return query_segment_tree(nd*2, l, mid, a, b) + query_segment_tree(nd*2+1, mid+1, r, a, b);
    }
}
 
int query_up(int a, int b){
    int ans = 0, chainA = chainNo[a], chainB = chainNo[b];
    if(a==b)    return 0;
    while(1){
        if(chainA == chainB){   //same chain
            ans += query_segment_tree(1, 0, ptr, position[b]+1, position[a]);
            break;
        }
        else{   //if different chain, then we make a jump to the parent chain.
            ans += query_segment_tree(1, 0, ptr, position[chainHead[chainA]], position[a]);
            a = p[chainHead[chainA]][0];	//swap to parent
            chainA = chainNo[a];	//update chainA
        }
    }
    return ans;
}
 
int lca_query(int a, int b){
    if(depth[a] < depth[b]) swap(a, b);
 
    for(int i=LN;i>=0;i--)
        if(depth[p[a][i]] >= depth[b] && p[a][i]!=-1)
            a = p[a][i];
 
    if(a==b)    return a;
    
    for(int i=LN;i>=0;i--)
        if(p[a][i]!=-1 && p[a][i]!=p[b][i])
            a = p[a][i], b = p[b][i];
 
    return p[a][0];
}
 
int query(int a, int b){
    int lca = lca_query(a, b);
    return query_up(a, lca) + query_up(b, lca);
}
 
void update_segment_tree(int nd, int l, int r, int a, int val){
    if(a > r || a < l)  return ;
    else if(l==r && a==l)   seg[nd] = val;
    else{
        int mid = (l+r)/2;
        update_segment_tree(nd*2, l, mid, a, val);
        update_segment_tree(nd*2+1, mid+1, r, a, val);
        seg[nd] = seg[nd*2] + seg[nd*2+1];
    }
}
 
void change(int e, int val){
    int u = edges[e].second.first, v = edges[e].second.second;
    if(p[u][0] == v)	update_segment_tree(1, 0, ptr, position[u], val);	//if u is the child.
    else update_segment_tree(1, 0, ptr, position[v], val);	//if v is the child.
}
 
int main(){
 
    int t;
    //scanf("%d", &t);
 
    //while(t--){
    	memset(p, -1, sizeof(p));
    	memset(chainHead, 0, sizeof(chainHead));
        for(int i = 0; i < N ; i++)	adjList[i].clear();
        chainNumb = 0;
        ptr = -1;
 
        int u, v, w, type;
        scanf("%d", &n);
        for(int i = 1;i < n;i++){
            scanf("%d %d %d", &u, &v, &w);
            edges[i].first = w;
            edges[i].second.first = u;
            edges[i].second.second = v;
            adjList[u].push_back(make_pair(v, w));
            adjList[v].push_back(make_pair(u, w));
        }
 
        dfs1(root, 0, -1);  //to calculate subsize array.
        hld(root, -1, 0);   //to form chainNo, ...
        build_tree(1, 0, ptr);  //build segment tree.
 
        for(int i = 1;i <= LN;i++)	//LCA dp.
            for(int j = 1;j <= n;j++)
                if(p[j][i-1]!=-1)
                    p[j][i] = p[p[j][i-1]][i-1];
                    
		int q;
		cin>>q;
        while(q--){
            scanf("%d", &type);
            scanf("%d %d", &u, &v);
            if(type==2)   printf("%d\n", query(u, v));
            else change(u, v);
        }
    //}
    return 0;
}
 