/* Pranet Verma */
#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
#define s(n) scanf("%d",&n)
#define s2(n,m) scanf("%d%d",&n,&m)
#define s3(n,m,l) scanf("%d%d%d",&n,&m,&l)
#define rep(i,n) for(int i=0;i<n;++i)
ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); }
const int mod=1000000007;
int n,N,base;

int chain[100001];
int depth[100001];
int pa[100001][20];
int heavy[100001];
int sz[100001];
int leadsTo[100001];
int leadingTo[100001];
int tree[500000];
int posInBase[100001];
int baseArr[100001];


void makeTree(int i,int l,int r)
{
  if(l==r)
  {
    if(l<n)
    {
      tree[i]=baseArr[l];
    }
    else
    {
      tree[i]=0;
    }
    return;
  }

  int m=(l+r)/2;
  makeTree(2*i+1,l,m);
  makeTree(2*i+2,m+1,r);
  tree[i]=tree[2*i+1]+tree[2*i+2];
}

void mergeUp(int i)
{
  while(i)
  {
    int p=(i-1)/2;
    if(i&1)
      tree[p]=tree[i]+tree[i+1];
    else
      tree[p]=tree[i]+tree[i-1];
    i=p;
  }
}



struct Edge
{
  int u,v,w;
  Edge(){}
  Edge(int u,int v,int w)
  {
    this->u=u;
    this->v=v;
    this->w=w;
  }
};
vector<Edge> e;
vector<vector<int> > g;
void dfs(int u,int p)
{
  sz[u]=1;
  depth[u]=depth[p]+1;
  pa[u][0]=p;
  for(int i=0;i<g[u].size();++i)
  {
    int id=g[u][i];
    int v=e[id].u+e[id].v-u;

    if(v==p)
      continue;
    leadsTo[id]=v;
    leadingTo[v]=id;
    dfs(v,u);
    sz[u]+=sz[v];

    if(sz[heavy[u]]<sz[v])
      heavy[u]=v;
  }
}
void hld()
{

  N=ceil(log2(n));
  base=(1<<N)-1;

  dfs(1,0);


  int ptr=0;

  for(int i=1;i<=n;++i)
  {
    if(heavy[pa[i][0]]!=i)
      {
        for(int j=i;j;j=heavy[j])
        {
          chain[j]=i;
          int id=leadingTo[j];
          baseArr[ptr]=e[id].w;
          posInBase[j]=ptr;
          ++ptr;  
        }
      }
  }


  makeTree(0,0,base);

  for(int j=1;j<=n;++j)
  {
    for(int i=1;i<N;++i)
    {
      pa[j][i]=pa[pa[j][i-1]][i-1];
    }
  }
}

int lca(int u,int v )
{
  if(depth[u]<depth[v])
    swap(u,v);

  int d=depth[u]-depth[v];


  for(int i=N-1;i>=0;--i)
    if(d&(1<<i))
      u=pa[u][i];

  if(u==v)
    return u;

  for(int i=N-1;i>=0;--i)
  {
    if(pa[u][i]!=pa[v][i])
    {
      u=pa[u][i];
      v=pa[v][i];
    }
  }

  return pa[u][0];

}
void addEdge(int u,int v,int w)
{
  g[u].pb(e.size());
  g[v].pb(e.size());
  e.pb(Edge(u,v,w));
}


int query(int i,int l,int r,int x,int y)
{
  if(x>r || y<l)
    return 0;
  if(x<=l && r<=y)
    return tree[i];
  int m=(l+r)/2;
  int lt=query(2*i+1,l,m,x,y);
  int rt=query(2*i+2,m+1,r,x,y);

  return lt+rt;
}
int queryUp(int u,int v)
{
    int ans=0;
    while(true)
    {
      if(chain[u]==chain[v])
      {
          ans+=query(0,0,base,posInBase[v]+1,posInBase[u]);
          break;
      }
        
      int U=chain[u];

      ans+=query(0,0,base,posInBase[U],posInBase[u]);
      
      u=pa[U][0];
    }

    return ans;
}
int main()
{
  
  s(n);
  g.resize(n+1);
  for(int i=0;i<n-1;++i)
  { 
    int u,v,w;
    s3(u,v,w);
    addEdge(u,v,w);
  }


  hld();
  int q;
  s(q);
  while(q--)
  {
    int t,u,v,e,w;
    s(t);
    if(t==1)
    {
      s2(e,w);  
      --e;
      int u=leadsTo[e];
      tree[base+posInBase[u]]=w;
      mergeUp(base+posInBase[u]);
    }
    else
    {
      s2(u,v);
      int l=lca(u,v);
      int a=queryUp(u,l);
      int b=queryUp(v,l);
      printf("%d\n",a+b);
    }
  }

}

