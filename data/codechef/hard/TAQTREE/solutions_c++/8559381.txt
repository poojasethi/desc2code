#include <bits/stdc++.h>
#define filein(t) freopen(t, "r", stdin)
#define fileout(t) freopen(t, "w", stdout)
#define mp make_pair
#define f first
#define s second
#define N 100005
#define NN 10000000
#define ln 1e10+1
#define BIT(i, j) ((j >> i) & 1)
#define ll long long
#define oo 1000000007
#define ln 1e9
#define pii pair < pair <int, int>, int >
#define pi pair < int, pair <int, int> >
#define Pa pair < int ,int >


using namespace std;

vector <Pa> a[N];
int cnt[N], T[N], P[20][N], pos[N], num, B[N], n, V[N], C[4*N], d[N];
Pa L[N];

void DFS1(int u, int par)
{
    cnt[u] = 1;
    for(int i=0; i<a[u].size(); i++)
    {
        int v = a[u][i].f;
        int w = a[u][i].s;
        if(v == par)    continue;
        T[v] = T[u] + 1;
        V[v] = w;
        P[0][v] = u;
        DFS1(v, u);
        cnt[u] += cnt[v];
    }
}

void DFS2(int u, int par)
{
    int Ma = -1;
    pos[u] = ++num;
    d[num] = u;
    if(B[u] == 0)
        B[u] = pos[u];
    for(int i=0; i<a[u].size(); i++)
    {
        int v = a[u][i].f;
        if(v == par)    continue;
        if(cnt[Ma] < cnt[v] || Ma == -1)    Ma = v;
    }
    if(Ma == -1)
        return;
    B[Ma] = B[u];
    DFS2(Ma, u);
    for(int i=0; i<a[u].size(); i++)
    {
        int v = a[u][i].f;
        if(v == par || v == Ma)    continue;
        DFS2(v, u);
    }
}

int LCA(int u, int v)
{
    if(T[u] < T[v]) swap(u, v);
    int hi = T[u] - T[v];
    for(int i=0; i<20; i++)
        if(BIT(i, hi))
            u = P[i][u];
    if(u == v)  return u;
    for(int i=19; i>=0; i--)
        if(P[i][u] != P[i][v])
        {
            u = P[i][u];
            v = P[i][v];
        }
    return P[0][u];
}

void Update(int node, int l, int r, int pos, int Val)
{
    if(l == r && l == pos)
    {
        C[node] = Val;
        return;
    }
    if(l > pos || r < pos)  return;
    int g = (l + r) / 2;
    Update(node*2, l, g, pos, Val);
    Update(node*2+1, g+1, r, pos, Val);
    C[node] = C[2*node] + C[2*node+1];
}

int Get_Val(int node, int l, int r, int d, int c)
{
    if(d <= l && r <= c)
        return C[node];
    if(d > r || l > c)  return 0;
    int g = (l + r) / 2;
    int u = Get_Val(node*2, l, g, d, c);
    int v = Get_Val(node*2+1, g+1, r, d, c);
    return u + v;
}

int Get(int u, int par)
{
    int r = 0;
    while(T[d[B[u]]] > T[par])
    {
        r += Get_Val(1, 1, n, B[u], pos[u]);
        u = P[0][d[B[u]]];
    }
    r += Get_Val(1, 1, n, pos[par]+1, pos[u]);
    return r;
}

int main()
{
   // filein("inp.txt");  fileout("out.txt");
    cin >> n;
    int u, v, w, q, type, tt;
    for(int i=1; i<n; i++)
    {
        cin >> u >> v >> w;
        a[u].push_back(mp(v, w));
        a[v].push_back(mp(u, w));
        L[i] = mp(u, v);
    }
    DFS1(1, 0);
    for(int j=1; j<20; j++)
        for(int i=1; i<=n; i++)
            P[j][i] = P[j-1][P[j-1][i]];
    DFS2(1, 0);
    for(int i=1; i<=n; i++)
        Update(1, 1, n, pos[i], V[i]);
    cin >> q;
    while(q--)
    {
        cin >> type;
        if(type == 1)
        {
            cin >> tt >> w;
            int u = L[tt].f;
            int v = L[tt].s;
            if(T[u] > T[v]) swap(u, v);
            Update(1, 1, n, pos[v], w);
        }
        else
        {
            cin >> u >> v;
            int par = LCA(u, v);
            int P = Get(u, par);
            int Q = Get(v, par);
            cout << P + Q << endl;
        }
    }
}
