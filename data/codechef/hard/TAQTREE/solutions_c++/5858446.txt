//g++ -std=c++0x your_file.cpp -o your_program
#include<iostream>
#include<fstream>
#include<string>
#include<algorithm>
#include<math.h>
#include<vector>
#include<cstring>
#include<queue>
#include<cstdio>
#include<cstdlib>
#include<map>
#include<set>
#define fname ""
#define mp make_pair
#define F first
#define pb push_back
#define S second
#define ub upper_bound
#define lb lower_bound
#define inf 2000000000
#define INF 2000000000000000000ll
using namespace std;

const int maxn = 101010;

const int N = (1 << 17);

vector <pair <pair <int, int>, int> > g[maxn];

int sz[maxn], lvl[maxn], Val[maxn];

int up[18][maxn];

int Vertex[maxn];

void dfs(int v, int pr = -1, int Level = 1)
{
	lvl[v] = Level;
	sz[v] = 1;
	for (int i = 0; i < (int)g[v].size(); i++)
	{
		int to = g[v][i].F.F, len = g[v][i].F.S, id = g[v][i].S;
		if (to != pr)
		{
			up[0][to] = v;
			for (int j = 1; j <= 16; j++)
				up[j][to] = up[j - 1][up[j - 1][to]];
			Vertex[id] = to;
			Val[to] = len;
			dfs(to, v, Level + 1);
			sz[v] += sz[to];
		}
	}
}

int lca(int x, int y)
{
	if (x == y)
		return x;
	if (lvl[x] > lvl[y])
		swap (x, y);
	for (int j = 16; j >= 0; j--)
		if (lvl[up[j][y]] >= lvl[x])
			y = up[j][y];
	if (x == y)
		return x;
	for (int j = 16; j >= 0; j--)
		if (up[j][x] != up[j][y])
			x = up[j][x], y = up[j][y];
	return up[0][x];
}

int p[maxn];

vector <int> P[maxn];

int P_sz;

void hld(int v, int pr = -1)
{
	bool found = 0;
	for (int i = 0; i < g[v].size(); i++)
	{
		int to = g[v][i].F.F;
		if (to != pr)
		{
			hld(to, v);
			if (sz[to] + sz[to] >= sz[v])
			{
				p[v] = p[to];
				P[p[to]].pb(v);
				found = 1;
			}
		}
	}
	if (!found)
	{
		P_sz++;
		p[v] = P_sz;
		P[P_sz].pb(v);
	}
}

int id[maxn];

int Last[maxn];

int t[N * 2 + 5];

void build()
{
	int ln = 0;
	for (int i = 1; i <= P_sz; i++)
	{
		for (int j = 0; j < (int)P[i].size(); j++)
		{
			int v = P[i][j];
			t[N + ln] = Val[v];
			id[v] = ln++;
			Last[i] = v;
		}
	}
	for (int i = N - 1; i >= 1; i--)
		t[i] = t[i + i] + t[i + i + 1];
}

void upd(int x, int val, int v = 1, int tl = 0, int tr = N - 1)
{
	if (tl == tr)
	{
		t[v] = val;
		return ;
	}
	int tm = (tl + tr) >> 1;
	if (x <= tm)
		upd(x, val, v + v, tl, tm);
	else
		upd(x, val, v + v + 1, tm + 1, tr);
	t[v] = t[v + v] + t[v + v + 1];
}

int get(int l, int r, int v = 1, int tl = 0, int tr = N - 1)
{
	if (l > tr || tl > r || l > r)
		return 0;
	if (l <= tl && tr <= r)
		return t[v];
	int tm = (tl + tr) >> 1;
	return get(l, r, v + v, tl, tm) + get(l, r, v + v + 1, tm + 1, tr);
}

int GetOnPath(int x, int y)
{
	int v = lca(x, y);
	int res = 0;
	while (p[x] != p[v])
	{
		res += get(id[x], id[Last[p[x]]]);
		x = up[0][Last[p[x]]];
	}
	res += get(id[x], id[v] - 1);
	while (p[y] != p[v])
	{
		res += get(id[y], id[Last[p[y]]]);
		y = up[0][Last[p[y]]];
	}
	res += get(id[y], id[v] - 1);
	return res;
}

int main()
{
//	freopen (fname".in", "r", stdin);
//	freopen (fname".out", "w", stdout);
	int n;
	cin >> n;
	int x, y, z;
	for (int i = 1; i < n; i++)
	{
		scanf("%d%d%d", &x, &y, &z);
		g[x].pb(mp(mp(y, z), i));
		g[y].pb(mp(mp(x, z), i));
	}
	dfs(1);
	hld(1);
	build();
	int Q, tp;
	cin >> Q;
	while (Q--)
	{
		scanf("%d%d%d", &tp, &x, &y);
		if (tp == 1)
			upd(id[Vertex[x]], y);
		else
			printf("%d\n", GetOnPath(x, y));
	}
	return 0;
}
