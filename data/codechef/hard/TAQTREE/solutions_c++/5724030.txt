#include <bits/stdc++.h>
using namespace std;

#define PB push_back
#define MP make_pair
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
#define si(a) scanf("%d", &a)
#define sl(a) scanf("%lld", &a)
#define sd(a) scanf("%lf", &a)
#define sii(a, b) scanf("%d%d", &a, &b)
#define sll(a, b) scanf("%lld%lld", &a, &b)
#define sdd(a, b) scanf("%lf%lf", &a, &b)
#define siii(a, b, c) scanf("%d%d%d", &a, &b, &c)
#define slll(a, b, c) scanf("%lld%lld%lld", &a, &b, &c)
#define sddd(a, b, c) scanf("%lf%lf%lf", &a, &b, &c)

#define MAX 100005
#define Lgn 18
int N, Q;
int in[MAX], out[MAX], Tm;
int par[MAX][Lgn], W[MAX], idw[MAX];
vector <int> adj[MAX], cost[MAX];

void dfs(int nd)
{
   in[nd] = ++Tm;
   REP(i, adj[nd].SZ) {
      int ch = adj[nd][i];
      if(ch == par[nd][0]) continue;
      par[ch][0] = nd;
      W[ch] = idw[cost[nd][i]];
      idw[cost[nd][i]] = ch;
      dfs(ch);
   }
   out[nd] = ++Tm;
}

void precal_lca()
{
   ITR(i, 1, Lgn) ITR(j, 1, N+1)
      par[j][i] = par[par[j][i-1]][i-1];
}

inline bool IsAncestor(int u, int v)
{
   return (in[u] <= in[v]) && (out[u] >= out[v]);
}

int LCA(int u, int v)
{
   if(IsAncestor(u, v)) return u;
   for(int log = Lgn-1; log >= 0; log--) if(!IsAncestor(par[u][log], v))
      u = par[u][log];
   return par[u][0];
}

Long Tree[MAX+MAX];

Long read(int id)
{
   Long sum = 0;
   while(id > 0) {
      sum += Tree[id];
      id -= (id & -id);
   }
   return sum;
}

void update(int id, Long val)
{
   while(id < MAX+MAX) {
      Tree[id] += val;
      id += (id & -id);
   }
}

void main_()
{
   cin >> N;
   REP(i, N-1) {
      int u, v;
      cin >> u >> v >> idw[i+1];
      adj[u].PB(v);
      adj[v].PB(u);
      cost[u].PB(i+1);
      cost[v].PB(i+1);
   }
   par[1][0] = 1;
   dfs(1);
   precal_lca();

   ITR(i, 1, N+1) {
      update(in[i], W[i]);
      update(out[i], -W[i]);
   }

   //ITR(i, 1, N+1) printf("W[%d]: %d idw[%d]: %d\n", i, W[i], i, idw[i]);

   cin >> Q;
   while(Q--) {
      int tp, u, v;
      cin >> tp >> u >> v;
      if(tp == 1) {
         int ch = idw[u];
         update(in[ch], v-W[ch]);
         update(out[ch], W[ch]-v);
         W[ch] = v;
      }
      else {
         int lca = LCA(u, v);
         Long ret = read(in[u]) + read(in[v]);
         ret -= 2*read(in[lca]);
         cout << ret << endl;
         //printf("read[%d]: %d read[%d]: %d read[%d]: %d W[%d]: %d\n", in[u], read(in[u]), in[v], read(in[v]), in[lca], read(in[lca]), lca, W[lca]);
      }
   }
}

int main()
{
   ios_base::sync_with_stdio(0); cin.tie(0);
   int t = 1;
   //cin >> t;

   while(t--) main_();

   return 0;
}
