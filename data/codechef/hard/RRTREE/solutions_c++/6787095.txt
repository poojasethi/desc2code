/*God is greater than any problem that
u have and u have to not worry because
when u pray and then worry,
the worry nullify your prayer
He is right here, right now !!
*/

#include <bits/stdc++.h>
using namespace std;
#define bitcnt __builtin_popcount
#define ln length()
#define rep(i, n) for(int i = 0; i < n; i++)
#define rrep(i, n) for(int i = n - 1; i >= 0; i--)
#define all(a)  a.begin(),a.end()
#define LL long long
#define limit 1000006
#define sl(n) scanf("%lld", &n)
#define s(n)  scanf("%d", &n)
#define pl(n) printf("%lld", n)
#define pi(n)  printf("%d", n)
#define pb push_back
#define pn printf("\n")
#define ff first
#define ss second
#define mkp make_pair
#define mod 1000000007
typedef vector<LL> row;
typedef vector<row> matrix;

#define get getchar_unlocked
inline int scan()
{
    int n=0,s=1;
    char p=get();
    if(p=='-')  s=-1;
    while((p<'0'||p>'9')&&p!=EOF&&p!='-') p=get();
    if(p=='-') s=-1,p=get();
    while(p>='0'&&p<='9') { n = (n<< 3) + (n<< 1) + (p - '0'); p=get(); }
    return n*s;
}

void print(int X)
{
  if(X<0) { putchar_unlocked('-');  X=-X;  }
  int Len=0,Data[10];
  while(X) { Data[Len++]=X%10; X/=10; }
  if(!Len) Data[Len++]=0;
  while(Len--) putchar_unlocked(Data[Len]+48);
}
int f[100010][20], l[100010];
bool vis[100001];
vector<int>adj[100001];
 
int dfs(int v,int le)
{
    vis[v]=1;
    l[v]=le;
    for(int i=0;i<adj[v].size();i++)
    {
        if(!vis[adj[v][i]])dfs(adj[v][i],le+1);
    }
} 

int lca(int p, int q)
  {
      int tmp, log, i;
   
  //if p is situated on a higher level than q then we swap them
      if (l[p] < l[q])swap(p,q);
  
  //we compute the value of [log(L[p)]
      for (log = 1; 1 << log <= l[p]; log++);
      log--;
   
  //we find the ancestor of node p situated on the same level
  //with q using the values in P
      for (i = log; i >= 0; i--)
          if (l[p] - (1 << i) >= l[q])
              p = f[p][i];
   
      if (p == q)
          return p;
  //we compute LCA(p, q) using the values in P
      for (i = log; i >= 0; i--)
         { if (f[p][i] != -1 && f[p][i]!=f[q][i])
              p = f[p][i], q = f[q][i];
         }
      return f[p][0];
}                
int dis(int a,int b)
{
    return l[a]+l[b]-2*l[lca(a,b)];
}  
       
int main()
{
    int t, n, i, j, p;
    t = scan();
    while(t--)
    {
        n = scan();
        if(n==1)continue;
        memset(f, -1, sizeof(f));
        memset(vis, 0, sizeof(vis));
        for(i = 0; i <= n; i++) adj[i].clear();
        for(i = 2; i <= n; i++)
        {
            p = scan();
            f[i][0]=p;
            adj[p].push_back(i);
        }
        dfs(1,0);
        for(j = 1; 1 << j <= n; j++)
        {
            for(i = 0; i <= n; i++)
            {
                if(f[i][j-1] > 0)
                {
                    f[i][j]=f[f[i][j-1]][j-1];
                }
            }
        }
        int p1=1;
    	int p2=2;
        int l=1;
        print(l); pn;
        for(i=3;i<=n;i++)
        {
            int l1=dis(i,p1);
            int l2=dis(i,p2);
            if(l1>=l2 && l1>l)p2=i,l=l1;
            if(l2>=l1 && l2>l)p1=i,l=l2;
            print(l); pn;
        } 
    }
    return 0;
}                                          
