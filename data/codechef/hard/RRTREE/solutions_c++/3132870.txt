#include <cstdio>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

#define all(a) (a).begin(),(a).end()
#define pb push_back
#define sz(a) ((int)(a).size())
#define mp make_pair

typedef pair<int,int> pint;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;


#define MAX_N 100005

int n,depth[MAX_N],path[MAX_N],parent[MAX_N],size[MAX_N],head[MAX_N];
list<int> adjl[MAX_N];
vi ps;

int f(int i, int p)
{
	parent[i]=p;
	depth[i]=(p==-1?0:depth[p]+1);
	size[i]=1;
	for (list<int>::iterator it=adjl[i].begin(); it!=adjl[i].end(); it++)
		if ((*it)!=p)
			size[i]+=f(*it,i);
	return size[i];
}

void h(int i)
{
	int mx=0;
	for (list<int>::iterator it=adjl[i].begin(); it!=adjl[i].end(); it++)
		if ((*it)!=parent[i])
			mx=max(mx,size[*it]),h(*it);
	if (parent[i]!=-1&&size[parent[i]]<2*size[i]&&size[i]>=2*mx)
		ps.pb(i);
}

int pid;
int g(int i)
{
	path[i]=pid;
	if (parent[i]==-1||size[parent[i]]>=2*size[i])
		return head[i]=i;
	else
		return head[i]=g(parent[i]);
}

int lca(int a, int b)
{
	while (path[a]!=path[b])
	{
		if (depth[head[a]]<depth[head[b]])
			b=parent[head[b]];
		else
			a=parent[head[a]];
		if (a==-1||b==-1) return 0;
	}
	return (depth[a]<depth[b]?a:b);
}
#define dist(a,b) (depth[a]+depth[b]-2*depth[lca(a,b)])

int main()
{
	int a,b,c,e,tc;
	scanf("%d",&tc);
	while (tc--)
	{
		scanf("%d",&n);
		for (int i=0; i<n; i++)
		{
			adjl[i].clear();
			path[i]=-10*i;
			head[i]=i;
		}
		for (int i=1; i<n; i++)
			scanf("%d",&a),a--,
			adjl[a].pb(i),adjl[i].pb(a);
		f(0,-1);
		ps.clear();
		h(0);
		pid=1;
		for (int i=0; i<sz(ps); i++,pid++)
			g(ps[i]);
		a=b=0;
		for (int i=1; i<n; i++)
		{
			c=dist(a,i),e=dist(b,i);
			if (dist(a,b)<max(c,e))
			{
				if (c>e)
					b=i;
				else
					a=i;
			}
			printf("%d\n",dist(a,b));
		}
	}
	return 0;
}
