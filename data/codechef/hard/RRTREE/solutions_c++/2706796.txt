// -*- C++ -*-
// File: a.cpp
// Copyright (C) 2013
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int,int> pii;

/*** TEMPLATE CODE ENDS HERE */

const int maxn = 1<<18;
const int logn = 18;

int timer;;
VI g[maxn];
int P[maxn][logn];
int t_in[maxn], t_out[maxn];
int depth[maxn];
int diametr[maxn];
int query[maxn];

void dfs(int at, int from) {
	P[at][0] = from;	
	FOR(i,1,logn) P[at][i] = P[ P[at][i-1] ][i-1];
	t_in[at] = timer++;
	rep(i,g[at].size()) dfs(g[at][i], at);
	t_out[at] = timer++;
}

bool is_ancestor(int a, int b) {  // if i is ancestor of j
	return t_in[a] <= t_in[b] && t_out[a] >= t_out[b];
}

int lca(int a, int b) {
	if(is_ancestor(a,b)) return a;
	if(is_ancestor(b,a)) return b;
	for(int i = logn-1; i>=0; --i) if(!is_ancestor(P[a][i],b)) a = P[a][i];
	return P[a][0];
}

int main() {
#ifdef LOCAL_HOST
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
#endif

    ios_base::sync_with_stdio(false);
	
	int T;
	cin >> T;
	
	while(T--) {
		
		int n;
		cin >> n;
		
		rep(i,n) g[i].clear();
		
		FOR(i,1,n) {
			int t;
			cin >> t;
			t--;
			g[t].pb(i);
			query[i] = t;
		}
		
		timer = 0;
		dfs(0,0);
		
		depth[0] = 0;
		diametr[0] = 0;
		
		int cur = 0, ans = 0;
		
		FOR(it,1,n) {
			
			const int v = query[it];			
			depth[it] = depth[v] + 1;
			
			if(depth[cur]==depth[v]) {
				diametr[it] = diametr[cur] + 1;
				cur = it;
				ans = max(ans, max(diametr[it], depth[it]));
			}
			else {
				int u = lca(it, cur);
				diametr[cur] = max(diametr[cur], depth[cur] + depth[it] - 2*depth[u]);
				ans = max(ans, diametr[cur]);
				ans = max(ans, depth[it]);
				ans = max(ans, depth[cur]);
			}
			cout << ans << endl;
		}
		
	}

#ifdef LOCAL_HOST
    printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC);
#endif

    return 0;
}
