#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cstring>

using namespace std;

#define pb push_back
#define MaxN 100007
#define LogN 20 

int L[MaxN], P[2*MaxN][LogN], T[MaxN]; 
int N, M, diam, d1, d2;

void init()
{
    for (int i=0 ; i<=N ; i++)
    {
        L[i] = 0;
        for (int j=0 ; j<LogN ; j++)
        {
           P[i][j] = -1;    
        }    
    }     
    P[1][0] = 1;
}

void preProcess()
{
    // Initialization
    for (int i=0 ; i<=N ; i++)
        for (int j=0 ; (1<<j) <= N ; j++)
            P[i][j] = -1;
    
    for (int i=1 ; i<=N ; i++)
        P[i][0] = T[i];
         
    // bottom up dynamic programming
    for (int j=1 ; (1<<j) <= N ; j++)
        for (int i=1 ; i<=N ; i++)   
            if (P[i][j-1] != -1)
               P[i][j] = P[P[i][j-1]][j-1]; 
}

int lca(int p, int q)
{
    int tmp, log, i;
   
   //if p is situated on a higher level than q then we swap them
   if (L[p] < L[q])
       tmp = p, p = q, q = tmp;
  
   //we compute the value of [log(L[p)]
   for (log = 1; 1 << log <= L[p]; log++);
       log--;
   
   //we find the ancestor of node p situated on the same level
   //with q using the values in P
   for (i = log; i >= 0; i--)
       if (L[p] - (1 << i) >= L[q])     
           p = P[p][i];
   
   if (p == q)
       return p;
   
   //we compute LCA(p, q) using the values in P
   for (i = log; i >= 0; i--)
       if (P[p][i] != -1 && P[p][i] != P[q][i])     
           p = P[p][i], q = P[q][i];
               
   return T[p];   
}

bool update(int i, int u, int & v)
{
    int temp = lca(i, u); 
    int dia = L[i] + L[u] - 2*L[temp];
    if (dia > diam)
    {
        diam = dia;
        v = i;
        return true;        
    }    
    
    return false;
} 
int main()
{
    int t;
    scanf("%d", &t);
    T[1] = -1;
    
    while (t--)
    {
        scanf("%d", &N);
        init();
        diam = 1;
        d1 = 1;
        d2 = 2;
        L[1] = 0;
        for (int i=2 ; i<=N ; i++)
        {
            scanf("%d", &T[i]);
            L[i] = L[T[i]] + 1;
            P[i][0] = T[i];
            
            for (int j=1 ; (1<<j)<=L[i] ; j++)
               P[i][j] = P[P[i][j-1]][j-1];
        
            if (!update(i, d1, d2))
                  update(i, d2, d1);
                  
            printf("%d\n", diam);   
        }      
    }
    return 0;   
}
