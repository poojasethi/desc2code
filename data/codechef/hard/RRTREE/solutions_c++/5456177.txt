#include<bits/stdc++.h>
using namespace std;
 
#define LET(x, a)  __typeof(a) x(a)
#define tr(v, it) for(LET(it, v.begin()); it != v.end(); it++)
#define PB push_back
#define MP make_pair
#define INF 1000000000
#define MOD 1000000007
#define LL long long int
#define ULL unsigned LL
#define PII pair<int, int>
#define MAX 1003000 
vector<set<int> > v;
int subcnt[MAX];
void add_edge(int x, int y) {
    v[x].insert(y);
    v[y].insert(x);
}

PII find_center(int cnode, int par, int tnodes) {
    int cmax = tnodes - subcnt[cnode];
    set<int> ::iterator it;
    PII ret = MP(INF, INF);
    for (it = v[cnode].begin(); it != v[cnode].end(); it++) {
        if (*it == par)
            continue;
        cmax = max(cmax, subcnt[*it]);
        ret = min(ret, find_center(*it, cnode, tnodes));
    }
    return min(ret, MP(cmax, cnode));
}
int get_tnodes(int cnode, int par = -1) {
    int &ret = subcnt[cnode];
    ret = 1;
    set<int> ::iterator it;
    for (it = v[cnode].begin(); it != v[cnode].end(); it++) {
        if (*it == par)
            continue;
        ret += get_tnodes(*it, cnode);
    }
    return ret;
}
int F[MAX];
int BIT[MAX];
int visBIT[MAX];
int BITiter = 1;
void U(int loc, int val) {
    loc += 5;
    for (int i = loc; i < MAX; i += (i & -i)) {
        if (visBIT[i] != BITiter) {
            visBIT[i] = BITiter;
            BIT[i] = -INF;
        }
        BIT[i] = max(BIT[i], val);
    }
}
int Q(int loc) {
    loc += 5;
    int ret = 0;
    for (int i = loc; i > 0; i -= (i & -i)) {
        if (visBIT[i] != BITiter) 
            continue;
        ret = max(ret, BIT[i]);
    }
    return ret;
}
vector<PII> upds;
void dfs(int cnode, int par, int cmax, int dep = 1) {
    if (cnode > cmax) {
        F[cnode] = max(F[cnode], dep + Q(cnode));
    }
    upds.PB(MP(cnode, dep));
    set<int> ::iterator it;
    for (it = v[cnode].begin(); it != v[cnode].end(); it++) {
        if (*it == par)
            continue;
        dfs(*it, cnode, max(cmax, cnode), dep + 1);
    }
}
void pushupds() {
    for (int i = 0; i < (int)upds.size(); i++) {
        U(upds[i].first, upds[i].second);
    }
    upds.clear();
}

void make_ans(int cnode) {
    PII cret = find_center(cnode, -1, get_tnodes(cnode));
    // cout << cnode << " " << subcnt[cnode] << endl;
    int u = cret.second;
    set<int> ::iterator it;
    BITiter ++;
    for (it = v[u].begin(); it != v[u].end(); it++) {
        v[*it].erase(u);
        dfs(*it, -1, u);
        pushupds();
    }
    F[u] = max(F[u], Q(u));
    BITiter++;
    set<int> ::reverse_iterator rit;
    for (rit = v[u].rbegin(); rit != v[u].rend(); rit++) {
        v[*rit].erase(u);
        dfs(*rit, -1, u);
        pushupds();
    }
    for (it = v[u].begin(); it != v[u].end(); it++) {
        make_ans(*it);
    }
}
vector<int> ord;
int main() {
    int q, x, t;
    cin >> t;
    while (t--) {
        memset(F, 0, sizeof(F));
        cin >> q;
        q--;
        int n = 1;
        v.clear();
        v.resize(MAX);
        while (q--) {
            scanf("%d", &x);
            add_edge(x, n + 1);
            ord.PB(n + 1);
            n += 1;
        }
        make_ans(1);
        for (int i = 1; i <= n; i++) {
            F[i] = max(F[i], F[i - 1]);
        }
        for (int i = 2; i <= n; i++) 
            printf("%d\n", F[i]);
    }
    // cout << BITiter << endl;
    return 0;
}

