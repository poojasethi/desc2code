#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <map>
#include <cstdio>
#include <set>
#include <queue>
#include <cassert>

using namespace std;

#define FOR(i, a, b) for(int i = a; i < b; i++)
#define REP(i, n) FOR(i, 0, n)
#define ll long long
#define mp make_pair
#define pb push_back

#define N 100005

int n, par[N];
int d[N];
int p[N][17];

int LCA(int u, int v)
{
    if(u == v) return u;
    if(d[v] > d[u]) swap(u, v);
    int k = d[u] - d[v];
    REP(i, 17) if(k & (1<<i))
    {
        u = p[u][i];
    }
    for(int i = 16; i >= 0; i--)
    {
        if(p[u][i] != p[v][i])
        {
            u = p[u][i];
            v = p[v][i];
        }
    }
    return p[u][0];
}

int dis(int u, int v)
{
    return d[u] + d[v] - 2*d[LCA(u, v)];
}

int main()
{
    int t; cin >> t;
    while(t--)
    {
        d[0] = 0;
        par[0] = -1;
        scanf("%d", &n);
        REP(i, n-1)
        {
            scanf("%d", par + i + 1);
            par[i+1]--;
            d[i+1] = d[par[i+1]] + 1;
        }
        REP(i, n) REP(j, 17) p[i][j] = -1;
        REP(i, n) p[i][0] = par[i];
        FOR(j, 1, 17) REP(i, n)
        {
            if(p[i][j-1] != -1) p[i][j] = p[p[i][j-1]][j-1];
        }
        int p1 = 0, p2 = 0;
        int dia = 0;
        FOR(i, 1, n)
        {
            if(dia >= dis(p1, i))
            {
                // p2 is good
                if(dis(i, p2) > dia)
                {
                    p1 = i;
                    dia++;
                }
            }
            else
            {
                p2 = i;
                dia++;
            }
            printf("%d\n", dia);
        }
    }
    return 0;
}
