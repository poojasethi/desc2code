#include <iostream>
#include <string>
#include <sstream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <list>
#include <map>
#include <set>
#include <fstream>
#include <cstring>
#include <iomanip>
#include <math.h>
#include <cmath>
#include <queue>
#include <stack>

#define PB push_back
#define MP make_pair
#define rep(i,a,b) for (int i = a; i <= b; i++)

#pragma comment(linker, "/STACK:16777216")

typedef long long int64;
typedef unsigned long long uint64;

using namespace std;

/*
inline int read_int()
{
    register char c;
    while ((c=getchar_unlocked()) < 48 || c > 57);
    int p = c-48;
    while ((c=getchar_unlocked()) >= 48 && c <= 57) p=p*10+c-48;
    return p;
}
*/

/*
struct matrix
{
    int64 a[2][2];
};

matrix mul(matrix A,matrix B)
{
    matrix C;
    memset(C.a,0,sizeof(C.a));
    for (int i = 0; i <= 1;i ++)
        for (int j = 0; j <= 1; j++)
            for (int k = 0; k <= 1; k++)
                C.a[i][j] = (C.a[i][j] + A.a[i][k] * B.a[k][j]) % md;
    return C;
}

matrix pow(matrix A, int64 p)
{
    if (p == 1) return A;
    if (p & 1) return mul(A,pow(A,p-1));
    matrix X = pow(A,p >> 1);
    return mul(X,X);
}



int64 pow(int64 x, int64 y, int64 z)
{
    if (y == 0) return 1%z;
    if (y == 1) return x%z;
    if (y & 1) return (x*pow(x,y-1,z))%z;
    int64 temp = pow(x,y>>1,z);
    return (temp*temp)%z;
}
*/

int pos[400][400];
int a[400][400];
int final_pos[400];

int main()
{
   	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);

    int t;
    cin>>t;

    while (t--)
    {
        int n;
        cin>>n;

        memset(pos,0,sizeof(pos));

        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n - 1; j++)
            {
                cin>>a[i][j];
                pos[a[i][j]][j]++;
            }
        }
        memset(final_pos,0,sizeof(final_pos));


        for (int j = 1; j <= n; j++) // try number
        {
            bool found_pos = false;

            for (int q = 1; q <= n; q++) // try position
            {
                // count smaller to left, smaller to right
                // count larger to left, larger to right

                int small_left = 0, small_right = 0;
                int large_left = 0, large_right = 0;

                bool skip = false;

                for (int k = 1; k <= n; k++)
                {
                    if (final_pos[k] == q)
                    {
                        skip = true;
                        break;
                    }

                    if (final_pos[k] != 0)
                        if (final_pos[k] < q) small_left++;
                        else small_right++;
                }

                if (skip) continue;

                int total_left = q - 1;
                int total_right = n - q;

                large_left = total_left - small_left;
                large_right = total_right - small_right;

                //cout<<"Trying for "<<j<<" at position "<<q<<endl;
                //cout<<small_left<<" "<<small_right<<" "<<large_left<<" "<<large_right<<endl;

                if (pos[j-1][q-1] >= small_left )
                    if (pos[j-1][q] >= small_right )
                        if (pos[j][q] >= large_right)
                            if (pos[j][q-1] >= large_left )
                            {
                                final_pos[j] = q;
                                found_pos = true;

                                pos[j-1][q-1] -= small_left;
                                pos[j-1][q] -= small_right;
                                pos[j][q] -= large_right;
                                pos[j][q-1] -= large_left;

                                //cout<<j<<" "<<q<<endl;
                                break;
                            }
            }

        }

        int out[301];

        for (int p = 1; p <= n; p++) out[final_pos[p]] = p;
        for (int p = 1; p <= n; p++) cout<<out[p]<<" ";
        cout<<endl;

    }
	return 0;
}
