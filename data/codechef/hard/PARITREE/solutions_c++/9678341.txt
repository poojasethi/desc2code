                #include <bits/stdc++.h>
                using namespace std;
     
                typedef long long ll;
     
                const int N = 1e5 + 5;
                const int mod = 1e9 + 7;
                int type,q,u,v,x;
                int uf[N];
                int val[N];
                vector < int > graph[N];
                #define gc() getchar_unlocked()
                inline int scan(){
                int x = 0;
                char c = gc();
                while(c < '0' || c > '9') c = gc();
                while(c >= '0' && c <= '9'){
                    x = x * 10 + (c - '0');
                    c = gc();
                }
                return x;
                }
     
                void pre(int n){
                for(int i = 1; i<=n; ++i){
                    uf[i] = i;
                }
               }
     
     
                int FIND(int u){
                    if(uf[u]!=uf[uf[u]]){
                        uf[u] = FIND(uf[u]);
                    }
                    return uf[u];
                }
     
     
     
     
     
                void UNION(int u, int v){
                    int xx = FIND(u);
                    int yy = FIND(v);
                    if(xx==yy) return;
                    uf[xx] = yy;
                    return;
                }
                inline long long mul(long long u , long long v){
                    return (u % mod * v %mod) % mod;
                }
                inline long long power(long long u , long long v){
                    long long ret = 1LL;
                    while(v > 0){
                        if(v & 1)
                            ret = mul(ret , u);
                        u = mul(u , u);
                        v /= 2;
                    }
                    return ret;
                }
                inline int QUERY(int n){
                    set < int > forest;
                    for(int i = 1; i <= n; ++i){
                        forest.insert(FIND(i));
                    }
                    return (int)forest.size();
                }
                inline long long int get(int x){
                    x -= 1;
                    return power(2LL , x * 1LL);
                }
                bool isBipartite(int n){
                    memset(val , -1 , sizeof val);
                    //val[1] = 1;
                    for(int node = 1; node <= n; ++node){
                    if(val[node] == -1){
                    stack < int > st;
                    val[node] = 1;
                    st.push(node);
                    while(!st.empty()){
                        int t = st.top();
                        st.pop();
                        for(int i = 0; i < graph[t].size(); ++i){
                            if(val[graph[t][i]] == -1){
                                val[graph[t][i]] = val[t] == 1 ? 2 : 1;
                                st.push(graph[t][i]);
                                continue;
                            }
                            if((val[t] == val[graph[t][i]])) return false;
                        }
                    }
                    }
                    }
                    return true;
                }
     
                int main()
                {
                    ios_base::sync_with_stdio(false);
                    cin.tie(NULL);
                    int tt , n , q , u , v , x;
                    set < pair < int , int > > zero;
                    set < pair < int , int > > one;
                    tt = scan();
                    while(tt--){
                        n = scan() , q = scan();
                        pre(n);
                        zero.clear();
                        one.clear();
                        for(int i = 0; i <= n; ++i) graph[i].clear();
                        for(int i = 0; i < n - 1; ++i){
                            u = scan() , v = scan();
                        }
                        bool hasDescrepancy = false;
                        vector < pair < int , int > > sss;
                        for(int i = 1; i <= q; ++i){
                            u = scan() , v = scan() , x = scan();
                            x %= 2;
                            if(x)
                            sss.push_back(make_pair(u , v));
                            int c = min(u , v) , d = max(u , v);
                            if(!hasDescrepancy){
                                if(x)
                                    hasDescrepancy = zero.find(make_pair(c , d)) != zero.end();
                                else
                                    hasDescrepancy = one.find(make_pair(c , d)) != one.end();
                            }
                            !x ? zero.insert(make_pair(c , d)) : one.insert(make_pair(c , d));
                            if(!x)
                            UNION(c , d);
                        }
                        if(hasDescrepancy){
                            printf("0\n");
                            continue;
                        }
                        for(int i = 0; i < sss.size(); ++i){
                            graph[FIND(sss[i].first)].push_back(FIND(sss[i].second));
                            graph[FIND(sss[i].second)].push_back(FIND(sss[i].first));
                        }
                        for(int i = 0; i < sss.size(); ++i){
                            UNION(sss[i].first , sss[i].second);
                        }
                        if(!isBipartite(n)){
                            printf("0\n");
                            continue;
                        }
                        printf("%lld\n", get(QUERY(n)));
                    }
                    return 0;
                }
     