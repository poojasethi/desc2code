#include <iostream>
#include <stdio.h>
#include <vector>
#include <string.h>
#include <queue>
#include <utility>
using namespace std;

#define MAX 100001
#define MOD 1000000007
typedef long long ll;


ll n,q;
ll rank[MAX];
ll parent[MAX];
ll odd_even[MAX];
bool visited[MAX];
bool exists = true;
ll arr[MAX][3];

ll counter = 0;

vector < pair<ll ,ll > > edges[MAX];

ll modular_pow(ll base, ll exponent)
{
    ll result = 1;
    while (exponent > 0)
    {
        if (exponent % 2 == 1)
            result = (result * base) % MOD;
        exponent = exponent >> 1;
        base = (base * base) % MOD;
    }
    return result;
}

void create_set(ll x)
{
	parent[x]=x;
	rank[x]=0;
	odd_even[x] = 0;
	visited[x]=false;
	edges[x].clear();
}

ll find_set(ll x)
{
	if(x!=parent[x])
	{
		ll temp = parent[x];
		parent[x] = find_set(parent[x]);
		odd_even[x] = odd_even[x] ^ odd_even[temp];
	}
	return parent[x];
}

void merge_set(ll x,ll y,ll z)
{
	ll px = find_set(x);
	ll py = find_set(y);
	if(rank[px] > rank[py])
	{
		//change(y,z);
		parent[py] = px;
		odd_even[y] = odd_even[x] ^ z;
	}
	else
	{
		//change(x,z);
		parent[px] = py;
		odd_even[x] = odd_even[y] ^ z;
	}
	if(rank[px] == rank[py])
		rank[py] = rank[py]+1;
}

void bfs(ll index)
{
	//visited[index] = true;
	queue< ll >mq;
	mq.push(index);
	while(!mq.empty())
	{
		ll temp_ind = mq.front();
		mq.pop();
		if(visited[temp_ind])
			continue;
		//ll temp_val = odd_even[temp_ind];
		int temp_len = edges[temp_ind].size();
		visited[temp_ind]  =true;
		for(int i=0;i<temp_len;i++)
		{
			int ed1 = edges[temp_ind][i].first;
			int ed2 = edges[temp_ind][i].second;
			//cout<<" ed1 "<<ed1<<" ed2 "<<ed2<<endl; 
			
				if(find_set(temp_ind) == find_set(ed1))
				{
					if((odd_even[temp_ind]^odd_even[ed1])!=ed2)
					{
						exists = false;
						break;
					}
				}
				else
				{
					merge_set(temp_ind,ed1,ed2);
					counter++;
				}
			if(!visited[ed1])
				mq.push(ed1);
		}
	}
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld",&n);
		scanf("%lld",&q);
		ll temp1,temp2,temp3;
		//memset(odd_even,0,sizeof(odd_even[0])*MAX);
		for(ll i=1;i<=(n-1);i++)
		{
			create_set(i);
			scanf("%lld",&temp1);
			scanf("%lld",&temp2);
		}
		create_set(n);
		counter = 0;
		exists = true;
		//bool check = false;
		/*for(int i=1;i<=q;i++)
		{
			scanf("%lld",&temp1);
			scanf("%lld",&temp2);
			scanf("%lld",&temp3);
			//cout<<" parent check "<<parent[2]<<endl;
			if(find_set(temp1) == find_set(temp2))
			{
				//cout<<" temp1 "<<temp1<<" temp2 "<<temp2<<" odd_even "<<odd_even[temp1]<<" and "<<odd_even[temp2]<<endl;
				ll temp4 = odd_even[temp1] ^ odd_even[temp2];
				if(temp4 != temp3)
				{
					check=true;
					break;
				}
			}
			else
			{
				counter++;
				merge_set(temp1,temp2,temp3);
			}
		}
		*/
		for(int i=1;i<=q;i++)
		{
			scanf("%lld",&temp1);
			scanf("%lld",&temp2);
			scanf("%lld",&temp3);
			edges[temp1].push_back(make_pair(temp2,temp3));
			edges[temp2].push_back(make_pair(temp1,temp3));
			arr[i][0] = temp1;
			arr[i][1] = temp2;
			arr[i][2] = temp3;
		}
		for(ll i =1;i<=n;i++)
		{
			if(!visited[i])
			{
				bfs(i);
				if(!exists)
					break;
			}
		}
		for(int i=1;i<=q;i++)
		{
			ll t1 = arr[i][0];
			ll t2 = arr[i][1];
			ll t3 = arr[i][2];
			if((odd_even[t1]^odd_even[t2])!=t3)
			{
				exists = false;
				break;
			}
		}
		if(!exists)
			printf("%d\n",0);
		else
		{
			ll ans = modular_pow(2,n-1-counter);
			printf("%lld\n",ans);
		}
	}
}