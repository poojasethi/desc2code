#include<bits/stdtr1c++.h>
using namespace std;
typedef long long LL;

int N,K,B;
const LL mod=(1e9 +7);
const int KX=(1<<7);
int up[KX+2][KX +2],TB[KX+2][KX +2];

bool cmp(const int &a,const int &b)
{
		return a>b;
}
int update(int omask,int nmask)
{
	int arr[10];
	int st=K*5*35;
	for(int i=0;i<K;i++)
	{
		arr[i]=st;
		if(nmask&(1<<i))
			arr[i]++;
		if(omask&(1<<i))
			st-=5*31;
	}
	for(int i=0;i<K-1;i++)
	{
		if(arr[i]<arr[i+1])
			return -1;
	}

	int ret=0;
	TB[omask][nmask]=0;
	if(arr[0]%5!=0)
		TB[omask][nmask]=1;
	for(int i=0;i<K-1;i++){
		if(arr[i]>arr[i+1])
			ret|=(1<<i);
	}
	return ret;
}

#define E 0
#define G 2
#define L 1
LL dp[32][32][3][KX];
int vis[32][32][3][KX],ID;
int zabbat(int o,int bit,int TB)
{
	if(o!=E)
		return o;
	if(TB)
	{
		if(bit) return E;
		return G;
	}
	if(bit)
		return L;
	return E;
}

LL solve(int ind,int b,int omask,int o)
{
	if(o==G || b<0)
		return 0;

	if(ind==-1){
		//cout<<omask<<" --- "<<b<<endl;
		bool valid=(omask==((1<<(K-1))-1)) || (omask==((1<<(K))-1));
		//if(valid)
			//cout<<ind<<" "<<o<<" "<<omask<<endl;
		return (valid&&(b==0));
	}
	LL &ret=dp[ind][b][o][omask];
	int &tv=vis[ind][b][o][omask];
	if(tv==ID)
		return ret;
	tv=ID;
	ret=0;
	for(int i=0;i<(1<<K);i++)
	{
		int n=__builtin_popcount(i);
		int nb=b-(n%2);
		int nmask=up[omask][i];
		int no=zabbat(o,((N>>ind) &1),TB[omask][i]);
		if(nmask==-1)
			continue;
		//cout<<ind<<" "<<i<<" "<<omask<<" ->"<<nmask<<" "<<nb<<" "<<no<<endl;
		//if(mp.count(nmask))
			//continue;
		//cout<<ind<<" "<<i<<" "<<omask<<" ->"<<nmask<<" "<<nb<<" "<<no<<endl<<endl;;
		ret+=solve(ind-1,nb,nmask,no);
		ret%=mod;
	}
	return ret;
}

LL fact(int n)
{
	LL ret=1;
	for(int i=1;i<=n;i++)
		ret*=i;
	return ret;
}
int main()
{
    #ifndef ONLINE_JUDGE
        freopen("2.in","r",stdin);
		//freopen("2.out","w",stdout);
    #endif // ONLINE_JUDGE
    
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);




    int tc;
    cin>>tc;
    while(tc--)
    {
    	cin>>N>>K>>B;
    	for(int i=0;i<(1<<(K-1));i++)
			for(int j=0;j<(1<<(K));j++)
				up[i][j]=update(i,j);
    	ID++;
    	LL ret=solve(30,B,0,E);
    	cout<<ret<<endl;

    }
    return 0;
    
}
