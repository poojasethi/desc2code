#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

#define pb push_back
#define mp make_pair

#define ALL(x) (x).begin(),(x).end()
#define CLR(a,b) memset(a,b,sizeof(a))
#define REPN(x,a,b) for (int x=a; x<b;++x)
#define REP(x,b) REPN(x, 0, b)
#define forit(i,c) for (typeof((c).end()) i=(c).begin();i!=(c).end(); ++i)

#define dbg(x) cout << #x << " = " << x << endl;
#define dbg2(x, y) cout << #x << " = " << x << "  " << #y << " = " << y << endl;
#define dbg3(x, y, z) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << endl;
#define dbg4(x, y, z, w) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << "  " << #w << " = " << w <<  endl;

typedef long long ll;

ll MOD = 1000000007;

ll dp[35][33][(1<<7)];
int BN[35];

int main() {

    int T, N, K, B;
    cin >> T;
    while (T--) {
        cin >> N >> K >> B;
        CLR(BN, 0);
        int MB = 0;
        REP(i, 32) {
            if (N&(1<<i)) BN[i] = 1, MB = i;
        }

        CLR(dp, 0);
        dp[MB+1][0][0] = 1;
//        dbg(MB);

        for (int i = MB+1; i >= 1; i--) {
//            dbg(i);
            for (int b = 0; b <= B; b++) {
                for (int mask = 0; mask < (1<<K); mask++) if (dp[i][b][mask]) {
                    for (int pred = 0; pred < (1<<K); pred++) {
                        int newmask = mask;
                        for (int j = 0; j < K; j++) if (newmask != -1) {
                            //rules
                            int bitPred = (pred & (1<<j)) ? 1 : 0;
                            if (j == 0) { //compare first number with N
                                if (!(mask & (1<<j))) { // its only important if is equal to the N-number
                                    if (BN[i-1] == 0) { //i-1 bit of N is 0
                                        if (bitPred) newmask = -1;
                                    }
                                    else { //B[i-1] = 1
                                        if (!bitPred) newmask |= (1<<j);
                                    }
                                }
                            }
                            else { //compare to the previous number
                                if (!(mask & (1<<j))) { // its only important when is equal to the previous number until the i-th bit
                                    int prevPred = (pred & (1<<(j-1))) ? 1 : 0;
                                    if (prevPred == 0) {
                                        if (bitPred) newmask = -1;
                                    }
                                    else {
                                        if (!bitPred) newmask |= (1<<j);
                                    }
                                }
                            }
                        }
                        if (newmask != -1) {
                            int nbits = __builtin_popcount(pred);
                            ll &res = dp[i-1][b+(nbits&1)][newmask];
                            res += dp[i][b][mask];
                            if (res >= MOD) res -= MOD;
                        }
                    }
                }
            }
        }
        int maskminor = (1<<K) - 1;
        cout << (dp[0][B][maskminor] + dp[0][B][maskminor-1])%MOD << "\n";
    }

    return 0;
}
