
// topcoder.cpp : ?R???\?[?? ?A?v???P?[?V?????̃G???g?? ?|?C???g???`???܂??B
//

#include <stdio.h>
#include <string.h>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <climits>
#include <cfloat>
#include <map>
#include <utility>
#include <set>
#include <list>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <complex>
#include <stack>
#include <queue>
#include <numeric>
#include <assert.h>
#include "math.h"

using namespace std;
typedef long long ll;

static const double EPS = 1e-6;
int ROUND(double x) { return (int)(x+0.5); }
bool ISINT(double x) { return fabs(ROUND(x)-x)<=EPS; }
bool ISEQUAL(double x,double y) { return fabs(x-y)<=EPS*max(1.0,max(fabs(x),fabs(y))); }
double SQSUM(double x,double y) { return x*x+y*y; }	
#define PI	(3.14159265358979323846)
template<class T> bool INRANGE(T x,T a,T b) { return a<=x&&x<=b; }
#define NG (-1)
#define SZ(a) ((int)a.size()) 

#define BIG (1000000000000000LL)

#if 1


#define REP(i,n) for(int i=0;i<(int)n;++i)
#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)
#define ALL(c) (c).begin(), (c).end()

typedef int Weight;
struct Edge {
	int src, dst;
	Weight weight;
	Edge(int src, int dst, Weight weight) :
	src(src), dst(dst), weight(weight) { }
};
bool operator < (const Edge &e, const Edge &f) {
	return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!
		e.src != f.src ? e.src < f.src : e.dst < f.dst;
}
typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

typedef vector<Weight> Array;
typedef vector<Array> Matrix;

bool augment(Graph& g, int u,
	vector<int>& matchTo, vector<bool>& visited) {
		if (u < 0) return true;
		for(Edges::iterator e=g[u].begin();e!=g[u].end();++e)
		{
			if (!visited[e->dst]) {
				visited[e->dst] = true;
				if (augment(g, matchTo[e->dst], matchTo, visited)) {
					matchTo[e->src] = e->dst;
					matchTo[e->dst] = e->src;
					return true;
				}
			}
		}
		return false;
}

int bipartiteMatching(Graph& g, int L, Edges& matching) {
	const int n = g.size();
	vector<int> matchTo(n, -1);
	int match = 0;
	REP(u, L) {
		vector<bool> visited(n);
		if (augment(g, u, matchTo, visited)) ++match;
	}
	REP(u, L) if (matchTo[u] >= 0) // make explicit matching
		matching.push_back( Edge(u, matchTo[u], 1) );
	return match;
}


#define NUM (1000)
#define inf 0x3f3f3f3f
int Edmonds_Karp(int n,int cap[][NUM],int source,int sink){
	int pre[NUM],d[NUM],p,q,t,i,j; // que?͑傫?????Ȃ??ƃ_???H
	if (source==sink) return inf;
	static int flow[NUM][NUM];
	static int que[1000000];
//	memset(flow,0,sizeof(flow));
//	memset(que,0,sizeof(que));
	while (true){
		memset(pre,-1,sizeof(pre));
		d[source]=inf;p=q=0,que[q++]=source;
		while(p<q&&pre[sink]<0){
			t=que[p++];
			for (i=0;i<n;i++)
				if (pre[i]<0&&(j=cap[t][i]-flow[t][i]))
					pre[que[q++]=i]=t,d[i]=min(d[t],j);
		}
		if (pre[sink]<0) break;
		for (i=sink;i!=source;i=pre[i])
			flow[pre[i]][i]+=d[sink],flow[i][pre[i]]-=d[sink];
	}
	for (j=i=0;i<n;j+=flow[source][i++]);
	return j;
}

class BipartiteMatching
{
public:
	BipartiteMatching(int v) : V(v) 
	{
		init();
	};

	void init()
	{
		G.clear();
		G.resize(V);
		match.clear();
		match.resize(V);
		used.clear();
		used.resize(V);
	}

	void add_edge(int u, int v)
	{
		G[u].push_back(v);
		G[v].push_back(u);
	}

	int run()
	{
		int res=0;
		fill(match.begin(),match.end(),-1);
		for(int v=0;v<V;v++)
		{
			if(match[v]<0)
			{
				fill(used.begin(),used.end(),false);
				if(dfs(v))
				{
					res++;
				}
			}
		}

		return res;
	}

private:
	const int V;
	vector < vector <int> > G;
	vector <int> match;
	vector <bool> used;


	bool dfs(int v)
	{
		used[v]=true;
		for(int i=0;i<SZ(G[v]);i++)
		{
			int u=G[v][i];
			int w=match[u];
			if(w<0||!used[w]&&dfs(w))
			{
				match[v]=u;
				match[u]=v;
				return true;
			}
		}
		return false;
	}
};











int main(){

	// ???I ??o?O?ɏ????I
//	freopen("input.txt","r",stdin);

	int T;
	scanf("%d ",&T);

	for(int i=0;i<T;i++)
	{
		int H,W;
		scanf("%d %d ",&H,&W);

		

		vector <string> vs;
		vector < vector <int> > vvi(H, vector <int> (W,-1) );
		int L = 0;
		int R = 0;
		for(int k=0;k<H;k++)
		{
			char str[256];
			scanf("%s ",str);
			vs.push_back(str);
		}

		int id=0;
		for(int y=0;y<SZ(vs);y++)
		{
			for(int x=0;x<SZ(vs[y]);x++)
			{
				if( !((x+y)&1) )
				{
					vvi[y][x]=id;
					id++;
					L++;
				}
			}
		}

		for(int y=0;y<SZ(vs);y++)
		{
			for(int x=0;x<SZ(vs[y]);x++)
			{
				if( ((x+y)&1)==1 )
				{
					vvi[y][x]=id;
					id++;
					R++;
				}
			}
		}

		const int N=1+W*H+1;
		int empty = 0;
		vector < vector <int> > capacity(N, vector <int> (N,0));
		Graph g;
		g.resize(W*H);
		
		BipartiteMatching *bi = new BipartiteMatching(W*H);
		for(int y=0;y<SZ(vs);y++)
		{
			for(int x=0;x<SZ(vs[y]);x++)
			{
				if(vs[y][x]=='.')
				{
					empty++;
				}

				if( ((y+x)&1)==0 && vs[y][x]=='.')
				{
					const static int DX[] = {-1,1,-2,2,-2,2,-1,1}; // ?`?F?Xy??????x???????D??
					const static int DY[] = {-2,-2,-1,-1,1,1,2,2};
					for(int d=0;d<8;d++)                   
					{
						const int nx = x+DX[d];
						const int ny = y+DY[d]; 
						if(INRANGE(nx,0,SZ(vs[y])-1)&&INRANGE(ny,0,SZ(vs)-1)&&vs[ny][nx]=='.')
						{
							const int ORI    = vvi[y][x];
							const int DEST   = vvi[ny][nx];

							g[ORI].push_back(Edge(ORI,DEST,1));

							bi->add_edge(y*W+x,ny*W+nx);
						}
					}
				}
			}
		}


#if 0
		static int cap[NUM][NUM];
		memset(cap,0,sizeof(cap));
		for(int y=0;y<N;y++)
		{
			for(int x=0;x<N;x++)
			{
				cap[y][x]=capacity[y][x];
			}
		}
		int result = empty-Edmonds_Karp(N, cap,0,N-1);
#elif 0
		Edges matching;
		int result = empty-bipartiteMatching(g, L, matching);
#else


		int result = empty-bi->run();
		delete(bi);
#endif

		printf("%d\n",result);
	}


/*
	64bit integer VC
		printf("%I64d\n",ret);
*/

}


#else

int main(){

	// ???I ??o?O?ɏ????I
//	freopen("input.txt","r",stdin);

	int T;
	scanf("%d ",&T);

	for(int i=0;i<T;i++)
	{
		int N,M,C1,C2;
		scanf("%d %d %d %d ",&N,&M,&C1,&C2);

		if(C1>C2)
		{
			swap(C1,C2);
		}
		vector <int> vi;
		vector <int> vlo;
		vector <int> vhi;
		for(int k=0;k<N;k++)
		{
			int tmp;
			scanf("%d ",&tmp);

			if(INRANGE(tmp,C1,C2))
			{
				vi.push_back(tmp);
			}
			else if(tmp<C1)
			{
				vlo.push_back(tmp);
			}
			else
			{
				vhi.push_back(tmp);
			}
		}
		vi.push_back(C2);
		sort(vi.begin(),vi.end());
		sort(vlo.rbegin(),vlo.rend());
		sort(vhi.begin(),vhi.end());
		

		int lo = 0;
		int hi = 1000000;

		while(lo<hi)
		{
			int mid = lo+(hi-lo)/2LL;

			bool ok = true;
			int used_number = 0;
			int now = C1;
			int last_in = false;
			for(int k=0;k<SZ(vi);k++)
			{
				if(now+mid>=vi[k])
				{
					last_in = true;
				}
				else
				{
					if(last_in)
					{
						now = vi[k-1];
						used_number++;
						if(used_number>M)
						{
							ok = false;
							break;
						}
						last_in = false;
						k--;
					}
					else
					{
						ok = false;
						break;
					}
				}
			}

			if(ok)
			{
				int must_use_out = M-SZ(vi)+1;
				int lid = 0;
				int hid = 0;
				int nowlow = C1;
				int nowhi = C2;
				
				while(must_use_out>0)
				{
					if(lid<SZ(vlo) && abs(nowlow-vlo[lid])<=mid)
					{
						nowlow = vlo[lid];
						lid++;
						must_use_out--;
					}
					else if (hid<SZ(vhi) && abs(nowhi-vhi[hid])<=mid)
					{
						nowhi = vhi[hid];
						hid++;
						must_use_out--;
					}
					else
					{
						ok = false;
						break;
					}


				}

			}




			if(ok)
			{
				hi=mid;
			}
			else
			{
				lo=mid+1;
			}
		}

		printf("%d\n",lo);
	}


/*
	64bit integer VC
		printf("%I64d\n",ret);
*/

}

#endif