#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define f(i, a, b) for(int i = a; i < b; i++)
#define rep(i, n) f(i, 0, n)

const int N = 30 * 30 + 2;
int R, C;
char s[64][64];
int rd[] = {-2, -2, -1, -1, 1, 1, 2, 2};
int cd[] = {-1, 1, -2, 2, -2, 2, -1, 1};
int ok(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C && s[r][c] != '#';
}

const int inf = 1 << 30;
int n, source, sink;
vector<int> adj[N];
int cap[N][N];
bool viz[N];
int from[N];

// bfs
int findpath() {

    for(int i = 0; i < n; i++) {
        viz[i] = 0;
        from[i] = -1;
    }

    queue<int> q;
    q.push(source);
    viz[source] = 1;

    while(!q.empty()) {

        int done = 0;
        int cur = q.front(); q.pop();

        for(int i = 0; i < adj[cur].size(); i++) {
            int next = adj[cur][i];
            if(!viz[next] && cap[cur][next] > 0) {
                q.push(next);
                viz[next] = 1;
                from[next] = cur;
                if(next == sink) {
                    done = 1;
                    break;
                }
            }
        }

        if(done) break;

    }

    int cur = sink;
    int pathcap = inf;

    while(from[cur] != -1) {
        int prev = from[cur];
        pathcap = min(pathcap, cap[prev][cur]);
        cur = prev;
    }

    cur = sink;
    while(from[cur] != -1) {
        int prev = from[cur];
        cap[prev][cur] -= pathcap;
        cap[cur][prev] += pathcap;
        cur = prev;
    }

    return pathcap == inf ? 0 : pathcap;

}

int maxflow() {

    int res = 0;
    while(1) {

        int x = findpath();
        if(x == 0) break;
        else res += x;

    }

    return res;

}

int main(){

    int T; cin >> T; while(T--) {

        scanf("%d %d", &R, &C);
        rep(i, R) scanf("%s", s[i]);

        n = R * C + 2;
        source = n - 2;
        sink = n - 1;

        rep(i, n) {
            adj[i].clear();
            rep(j, n) cap[i][j] = 0;
        }

        int ct = 0;
        rep(i, R) rep(j, C) {
            int v = C * i + j;
            if(ok(i, j)) {
                ct++;
                if((i + j) % 2 == 0) {
                    adj[source].push_back(v);
                    adj[v].push_back(source);
                    cap[source][v] = 1;
                }
                else {
                    adj[v].push_back(sink);
                    adj[sink].push_back(v);
                    cap[v][sink] = 1;
                }

                rep(k, 8) {
                    int nr = i + rd[k];                
                    int nc = j + cd[k];
                    int nv = C * nr + nc;
                    if(ok(nr, nc)) {
                        if((i + j) % 2 == 0) {
                            adj[v].push_back(nv);
                            cap[v][nv] = 1;
                            adj[nv].push_back(v);
                        }
                    }
                }
            }
        }

        cout << ct - maxflow() << endl;

    }
}
