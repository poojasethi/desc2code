#include<iostream>
#include<cmath>
#include<algorithm>
#include<climits>
#include<vector>
#include<queue>
#include<stack>
#include<bitset>
#include<set>
#include<deque>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
using namespace std;

//#undef mydebug
#ifdef mydebug
#define db(args...) {putchar('[');printf(#args);printf(":");dbg,args;printf("]\n");}
#define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}}
#define DBG_ARR(a,b,c) printf(#a);DBG(a,b,c)
#define DBG_MAT(a,s,b,c) printf(#a);printf("\n");DBGM(a,s,b,c)
#define DBG_VECT(a) printf(#a);DBG(a,0,(a).size())
#else
#define assert(f) {}
#define db(args...) {}
#define DBG_ARR(a,b,c) {}
#define DBG_MAT(a,s,b,c) {}
#define DBG_VECT(a) {}
#endif

#define MOD 	 1000000007LL
#define LL 		 long long
#define ULL      unsigned long long
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define si(n)    scanf("%d",&n)
#define si2(n,m) scanf("%d %d",&n,&m)
#define sll(n)   scanf("%lld",&n)
#define slu(n)   scanf("%llu",&n)
#define ss(n)    scanf("%s",n)
#define pnl      printf("\n")
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define FILL(a,b)       memset(a,b,sizeof(a))
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define pb push_back
#define mp make_pair
#define XX first
#define YY second
#define UNIQUE(v) sort(all(v)),v.erase(unique(all(v)),v.end())
template<typename T>void DBG(const T A,int S,int N){cout<<"[";FOR(i,S,N){cout<<"#"<<i<<":"<<A[i]<<" ";}cout<<"]\n";}
template<typename T>void DBGM(const T A,int S,int M,int N){FOR(i,S,M){FOR(j,S,N){cout<<A[i][j]<<" ";}printf("\n");}}
struct debugger{template<typename T>debugger&operator,(const T&v){cout<<" "<<v;return *this;}}dbg;

#define SIZE 10001
#define MAXX 10001
typedef pair<int,int> PII;
typedef vector<int> VI;
int R,C,total;
string arr[SIZE];
void precompute(){}
#define MAX_V1 900
#define MAX_V2 900
#define MAX_E 150000

int V1,V2,leftL[MAX_V2],rightR[MAX_V1];
int E,to[MAX_E],next[MAX_E],last[MAX_V1];
bool visited[MAX_V1];

int dx[]={2,1,-1,-2,-2,-1,1,2};
int dy[]={1,2,2,1,-1,-2,-2,-1};
void hopcroft_karp_init(int v1, int v2){
    V1=v1;
    V2=v2;
    E = 0;
    FILL(last,-1);
}
void hopcroft_karp_add_edge(int u, int v){
    to[E]=v;
    next[E]=last[u];
    last[u]=E;
    E++;
}

bool hopcroft_karp_dfs(int u){

    if(visited[u]){
        return false;
    }
    visited[u] = true;

    for(int e=last[u],v; e!=-1; e=next[e]){
        v = to[e];
        if(leftL[v]==-1 || hopcroft_karp_dfs(leftL[v])){
            rightR[u] = v;
            leftL[v] = u;
            return true;
        }
    }//end for

    return false;
}

int hopcroft_karp_match(){

    FILL(leftL,-1);
    FILL(rightR,-1);

    bool change = true;

    while(change){
        change = false;

        FILL(visited,false);

        FOR(i,0,V1){
            if(rightR[i]==-1){
                change |= hopcroft_karp_dfs(i);
            }//end if
        }//end for
    }//end while

    int ret = 0;

    FOR(i,0,V1){
        if(rightR[i]!=-1){
            ++ret;
        }
    }
    return ret;
}

void doThis(){
    si2(R,C);
    total=0;
    REP(i,R){
        cin>>arr[i];
        REP(j,C){
            if(arr[i][j]=='.'){
                ++total;
            }//end if
        }//end j rep
    }//end i rep

    hopcroft_karp_init(R*C,R*C);

    FOR(i,0,R){
        FORD(j,i%2,C,2){
            if(arr[i][j]=='.'){
                FOR(k,0,8){
                    int Xx = i+dx[k];
                    int Yy = j+dy[k];

                    if(Xx>=0&&Xx<R&&Yy>=0&&Yy<C&&arr[Xx][Yy]=='.'){
                        db(i,j,Xx,Yy);
                        int f = i*C+j;
                        int g = Xx*C+Yy;
                        db("adding edge between",f,g);
                        hopcroft_karp_add_edge(f,g);
                    }
                }

            }//end if
        }//end for j
    }//end for i

    //db(total,hopcroft_karp_match());
    //DBG_MAT(arr,0,R,C);
    printf("%d\n",total-hopcroft_karp_match());
}
int main(){
#ifdef amy
freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);
#endif
precompute();
int t=1;
scanf("%d",&t);
while(t--){doThis();}
#ifdef amy
fprintf(stdout,"\nTIME: %.3lf sec\n",(double)clock()/(CLOCKS_PER_SEC));
#endif
return 0;
}
