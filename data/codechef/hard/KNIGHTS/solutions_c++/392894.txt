#include <iostream>
#include <iosfwd>
#include <iomanip>

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cctype>

#include <vector>
#include <bitset>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <deque>
#include <string>
#include <list>
#include <iterator>
#include <sstream>
#include <complex>

#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>

using namespace std;

#define BUG(x) if (DEBUG) cout << __LINE__ << ": " << #x << " = " << x << endl
#define LET(x, a) __typeof(a) x = a
#define FOR(i, a, b) for (LET(i, (a)); i < (b); ++i)
#define RFOR(i, a, b) for (LET(i, (a)); i >= (b); --i)
#define REP(i, N) FOR (i, 0, N)
#define RREP(i, N) RFOR (i, N, 0)
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define CLEAR(x) memset( (x), 0, sizeof((x)))
#define FILL(x, v) memset((x), (v), sizeof((x)))
#define SORT(x) sort((x).begin(), (x).end())
#define UNIQUE(x) SORT(x), (x).resize(unique((x).begin(), (x).end()) - (x).begin())
#define REVERSE(x) reverse((x).begin(), (x).end())
#define FOREACH(it, v) for(LET(it, (v).begin()); it != (v).end(); ++it)
#define PRESENT(x, v) (find(ALL((x)), (v)) != (x).end())
#define CPRESENT(x, v) ((x).find((v)) != (x).end())
#define PB(x) push_back((x))
#define SIZE(x) ((int) (x).size())
#define MP(x, y) make_pair((x), (y))

typedef vector <int> VI; typedef vector <string> VS; typedef vector <double> VD;
typedef vector <VI> VVI; typedef vector <VS> VVS; typedef stringstream SS;
typedef pair <int, int> PII; typedef long long LL; typedef unsigned long long ULL;
typedef vector <PII> VPII; typedef vector <LL> VLL; typedef vector <bool> VB;
typedef vector <VLL> VVLL; typedef vector <VD> VVD; typedef vector <VB> VVB;

template <class T> inline int size(const T& c) { return (int) c.size(); }
VI tokenInt(string& s) {stringstream sin(s); VI v; int x; while (sin >> x) v.PB(x); return v;}
VS tokenStr(string& s) {stringstream sin(s); VS v; string x; while (sin >> x) v.PB(x); return v;}
int rInt() {int nT = -1; scanf("%d", &nT); return nT;}
string rStr() {char nStr[1 << 10] = ""; scanf("%s", nStr); return nStr;}
LL rLL() {LL nT = -1; scanf("%lld", &nT); return nT;}
char rChar() {char c = -1; scanf("%c", &c); return c;}
VI stov(string& s) {VI v; REP(i, size(s)) v.PB(s[i] - '0'); REVERSE(v); return v;}
LL stol(string& s) {LL r = 0; REP(i, size(s)) r = r * 10LL + (s[i] - '0'); return r;}
int stoi(string& s) {int r = 0; REP(i, size(s)) r = r * 10 + (s[i] - '0'); return r;}
string ltos(LL x) {string s; do {s.PB(x % 10 + '0'); x /= 10;} while (x); REVERSE(s); return s;}
VI ltov(LL x) {VI v; do {v.PB(x % 10); x /= 10;} while (x); return v;}
string itos(int x) {string s; do {s.PB(x % 10 + '0');x /= 10;} while (x); REVERSE(s); return s;}
VI itov(int x) {VI v; do {v.PB(x % 10);x /= 10;} while (x); return v;}
string vtos(VI& v) {string s; int l = size(v); REP(i, l) s.PB(v[l-i-1] + '0'); return s;}
LL vtol(VI& v) {LL r = 0; int l = size(v); REP(i, l) r = r * 10LL + v[l-i-1]; return r;}
int vtoi(VI& v) {int r = 0, l = size(v); REP(i, l) r = r * 10 + v[l-i-1]; return r;}
inline LL two(int x) {return (1LL << (x));}
template <class T> ostream& operator <<(ostream &O, vector <T> &v) {O << '{';
int x = size(v)-1; REP(i,x) O << v[i] << ", "; if (x >= 0) O << v[x]; return O << '}';}
VS split(string s,string del) {s += del[0]; string temp; VS ret; REP(i,size(s))
if(del.find(s[i]) == string::npos) temp.PB(s[i]); else{ret.PB(temp);temp = "";} return ret;}

const bool DEBUG = true;
const double EPS = 1e-8;
const int INF  = 1000000000;
const LL INFLL = 1000000000000000000LL;

struct HopcroftKarp
{
    int nodes;
    vector < vector <int> > adj;
	vector <int> dx, dy, mx, my;
    void initialize(int nodes) {
		this -> nodes = nodes;
		adj.resize(nodes);
		mx.resize(nodes, -1); my.resize(nodes, -1);
		dx.resize(nodes, 0); dy.resize(nodes, 0);
    }
    inline void addEdge(int u, int v) {adj[u].push_back(v);}
    bool bfs() {
        bool found = false;
        queue <int> q;
		for (int i = 0; i < nodes; ++i)
			if (mx[i] == -1)
				q.push(i);
		for (int i = 0; i < nodes; ++i)
			dx[i] = dy[i] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = 0; i < size(adj[u]); ++i){
				int v = adj[u][i];
                if (dy[v] == 0) {
                    dy[v] = dx[u] + 1;
                    if (my[v] == -1)
                        found = true;
                    else
                        dx[my[v]] = dy[v] + 1, q.push(my[v]);
                }
            }
        }
        return found;
    }

    bool dfs(int u) {
        for (int i = 0; i < size(adj[u]); ++i){
			int v = adj[u][i];
            if (dy[v] == dx[u] + 1) {
                dy[v] = 0;
                if (my[v] == -1 || dfs(my[v])) {
                    mx[u] = v; my[v] = u;
					return true;
				}
			}
		}
        return false;
    }

    int matching() {
        int res = 0;
        while (bfs() == true) 
			for (int i = 0; i < nodes; ++i) 
				if (mx[i] == -1 && dfs(i))
					res++;
        return res;
    }
};

struct Solver
{
	vector <string> vs; int rows, cols;
	inline int toEdge(int u, int v) {
		return (cols * u + v);
	}
	inline bool valid(int u, int v) {
		return u >= 0 && v >= 0 && u < rows && v < cols && vs[u][v] != '#';
	}
	int solve(int rows, int cols, vector <string>& v_s) {
		vs = v_s; this -> rows = rows; this -> cols = cols;
		int black = (rows * cols) >> 1, white = (rows * cols + 1) >> 1;
		HopcroftKarp graph; graph.initialize(rows * cols);
		int dx[] = {2, -2, 2, -2, 1, -1, 1, -1};
		int dy[] = {1, 1, -1, -1, 2, 2, -2, -2};
		for (int i = 0; i < rows; ++i)
			for (int j = 0; j < cols; ++j)
				if (((i + j + 1) & 1) && vs[i][j] != '#')
					for (int k = 0; k < 8; ++k)
						if (valid(i + dx[k], j + dy[k]))
							graph.addEdge(toEdge(i, j), toEdge(i + dx[k], j + dy[k]));
		int nodes = 0;
		for (int i = 0; i < rows; ++i)
			for (int j = 0; j < cols; ++j)
				if (vs[i][j] != '#')
					++nodes;
		int result = nodes - graph.matching();
		return result;
	}
};

const int maxBufSize = (1 << 24);
const int maxStrSize = (1 << 20);

struct Input
{
	int bufSize, bufEnd, bufPos;
	char buffer[maxBufSize];
	Input() {grabBuffer();}
	void grabBuffer() {
		bufSize = (maxBufSize); bufPos = 0;
		bufEnd = fread(buffer, sizeof (char), bufSize, stdin);
		buffer[bufEnd] = '\0';
	}
	bool bufEof() {return bufPos == bufEnd;}
	int getChar() {return buffer[bufPos++];}
	void skipWS() {
		while ((buffer[bufPos] == '\n' ||
			buffer[bufPos] == ' ' || buffer[bufPos] == '\t')) 
			bufPos++;
	}
	int rUint() {
		int n = 0, x; skipWS();
		for (int x = getChar(); x <= '9' && x >= '0'; x = getChar())
			n = (n << 3) + (n << 1) + (x - '0');
		return n;
	}
	int rInt() {
		int sign = 0, n = 0, x; skipWS();
		if (buffer[bufPos] == '-')
			sign = 1, getChar();
		for (x = getChar(); x <= '9' && x >= '0'; x = getChar())
			n = (n << 3) + (n << 1) + (x - '0');
		return sign == 0? n: -n;
	}
	LL rLL() {
		int sign = 0, x; LL n = 0; skipWS();
		if (buffer[bufPos] == '-')
			sign = 1, getChar();
		for (x = getchar(); x <= '9' && x >= '0'; x = getChar())
			n = (n << 3) + (n << 1) + (x - '0');
		return n;
	}
	inline bool isWhiteSpace(char x) {
		return x == ' ' || x == '\n' || x == '\t';
	}
	string rStr() {
		char result[maxStrSize]; skipWS();
		int idx = 0, x;
		for (x = getChar(); !isWhiteSpace(x); x = getChar())
			result[idx++] = x;
		result[idx] = '\0';
		return result;
	}
	char rChar() {skipWS(); return getChar();}
};

struct Output
{
	int bufSize, bufEnd, bufPos;
	char buffer[maxBufSize];
	Output() {bufPos = bufEnd = 0; bufSize = maxBufSize;}
	~Output() {flushBuffer();}
	void print(int x) {
		char temp[1 << 4]; int idx = 0;
		do {
			temp[idx++] = '0' + (x % 10);
			x /= 10;
		} while (x != 0);
		temp[idx] = '\0';
		reverse(temp, temp + idx);
		print(temp);
	}
	void print(char ch) {buffer[bufEnd++] = ch;}
	void print(char* s) {while (*s) buffer[bufEnd++] = *s++;}
	void flushBuffer() {buffer[bufEnd] = '\0'; puts(buffer); bufEnd = 0;}
	template <class A, class B> void print(const A& a, const B& b) {
		print(a); print(b);
	}
};

Input input; Output output;


int main()
{
	const bool contest = false;
	if (contest == true) {
		freopen("input.txt", "r", stdin);
		freopen("output.txt", "w", stdout);
	}
	int nTest = input.rUint();
	for (int test = 1; test <= nTest; ++test) {
		int rows = input.rUint(), cols = input.rUint();
		vector <string> vs(rows);
		for (int i = 0; i < rows; ++i)
			vs[i] = input.rStr();
		Solver solver;
		int result = solver.solve(rows, cols, vs);
		output.print(result, '\n');
	}
	return 0;
}

// Powered by PhoenixAI
