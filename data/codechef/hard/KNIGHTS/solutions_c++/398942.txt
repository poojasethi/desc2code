// author: amit.codename13@gmail.com - Amit Karmakar
// I hope this would pass.


// Template Begins
#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <climits>
#include <ext/hash_map>
using namespace std;
using namespace __gnu_cxx;

// To be expanded in future.
#define RESET(c) memset((c), 0, sizeof(c))
typedef vector<int> VI; 
typedef vector<VI> VVI; 
typedef pair<int,int> II; 
typedef vector<II> VII;
#define sz(a) int((a).size()) 
#define pb push_back 
#define all(c) (c).begin(),(c).end() 
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) 
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end())
typedef long long LL;
typedef unsigned long long ULL;
const int INF = INT_MAX;
const int NINF = INT_MIN;
vector<string> split( const string& s, const string& delim=" ") {vector<string> res;string t;for ( int i = 0 ; i != s.size() ; i++ ) {if ( delim.find( s[i] ) != string::npos ) {if ( !t.empty() ) {res.push_back( t );t = "";}} else {t += s[i];}}if ( !t.empty() ) {res.push_back(t);}return res;}
struct eqstr{bool operator()(const char* s1, const char* s2) const{return strcmp(s1, s2) == 0;}};
template <typename T> string toString ( T Number ) {ostringstream ss; ss << Number; return ss.str();}
template <typename T> T toNum ( const string &Text ) {istringstream ss(Text); T result; return ss >> result ? result : 0; }
#define tests(t)  int runs; scanf("%d", &runs); for(int t = 1; t <= runs; t++)
typedef hash_map<char *, int, hash<const char *>, eqstr> HMS;
#define REP(i, n) for(int i = 0, limiti = n; i < limiti; i++)
// Template ends here.
  
int n, m;

bool valid(int i, int j) {
     if(i >= 0 && i < m && j >= 0 && j < n) return true;
     return false;
}

const int MAXN = 30*30+10;
int cap[MAXN][MAXN];

int r[] = {1, 2, 2, 1, -1, -2, -2, -1};
int c[] = {-2, -1, 1, 2, 2, 1, -1, -2};

VI graph[MAXN];

bool finished;
void dfs(int u, int d, VI &from, VI &seen) {
  if(!finished)
  tr(graph[u], it)
        if(!seen[*it] && cap[u][*it] > 0) {
          from[*it] = u;
          seen[*it] = 1;
          if(*it == d) {
            finished = true;
            return;
          }
          dfs(*it, d, from, seen);
        }
}
int bfs(int s, int d) {
    VI from(MAXN, -1);
    VI seen(MAXN, 0);
    queue<int> q;
    seen[s] = 1;
    
    q.push(s);
    
    while(!q.empty())
    {
      int u = q.front();
      q.pop();
      
      tr(graph[u], it)
        if(!seen[*it] && cap[u][*it] > 0) {
          q.push(*it);
          from[*it] = u;
          seen[*it] = 1;
          if(*it == d)
            goto out;
        }
    }
    
    //finished = false;
    //dfs(s, d, from, seen);
    out:
        
    int path_cap = INF;      
    int where = d, prev;
    while(from[where] > -1) {
      prev = from[where];
      path_cap = min(path_cap, cap[prev][where]);
      where = prev;
    }
    
    where = d;
    while(from[where] > -1) {
      prev = from[where];
      cap[prev][where] -= path_cap;
      cap[where][prev] += path_cap;
      where = prev;
    }
    
    if(path_cap == INF)
      return 0;
    else
      return path_cap;
}

int ford(int source, int sink)
{
  int flow = 0, newcap;
  while(newcap = bfs(source, sink))
    flow += newcap;
  return flow;
}

#define idx(i, j) (i*n+j)

int main() {
  //clock_t start = clock();
  //freopen("output.txt", "r", stdin);
  //freopen("fastsol2pppppppp.txt", "w", stdout);
  tests(t) {
      scanf("%d %d", &m, &n);
      char board[31][31];
      REP(i, m)
        scanf("%s", board[i]);
      
      REP(i, MAXN)
        graph[i].clear();
        
      int V = 0;
      REP(i, m)
        REP(j, n) {
          board[i][j] = (board[i][j]=='.');
          if(board[i][j])
            V++;
        }
        
      REP(i, m)
        for(int j = (i%2); j < n; j += 2)
          if(board[i][j])
            REP(k, 8) {
                   int x = i+r[k], y = j+c[k];
                   if(valid(x, y) && board[x][y])
                   {
                                    cap[idx(i,j)][idx(x,y)] = 1;
                                    cap[idx(x,y)][idx(i,j)] = 0;
                                    graph[idx(i,j)].push_back(idx(x,y));
                                    graph[idx(x,y)].push_back(idx(i,j));
                   }
            }
      
      for(int i = 0; i < m; i++)
        for(int j = (i%2); j < n; j += 2)
          if(board[i][j]) {
            cap[m*n+1][idx(i,j)] = 1;
            cap[idx(i,j)][m*n+1] = 0;
            graph[m*n+1].push_back(idx(i,j));
            graph[idx(i,j)].push_back(m*n+1);
          }
          
      for(int i = 0; i < m; i++)
        for(int j = !(i%2); j < n; j += 2)
          if(board[i][j]) {
            cap[idx(i,j)][m*n+2] = 1;
            cap[m*n+2][idx(i,j)] = 0;
            graph[idx(i,j)].push_back(m*n+2);
            graph[m*n+2].push_back(idx(i,j));
          }
      printf("%d\n", V-ford(m*n+1, m*n+2));    
  }  
  //while(1);
  //clock_t end = clock();
  //printf("Time taken = %lf\n", (double)(end-start)/CLOCKS_PER_SEC);
}
     
