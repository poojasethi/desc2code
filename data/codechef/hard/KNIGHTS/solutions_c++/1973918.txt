#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

const int INF =  1 << 30;
const int NIL = 0;
const int LIMIT = 1000;
const int MAX_N = 35;
int H[] = {-1,  1,  2, 2, 1, -1, -2, -2};
int V[] = {-2, -2, -1, 1, 2,  2,  1, -1};
vector<int> G[LIMIT];
int dist[LIMIT];
int match[LIMIT];
int Q[LIMIT];
char B[MAX_N][MAX_N];
char C[MAX_N][MAX_N];
int  id[MAX_N][MAX_N];
int m, n, M, N;

bool bfs()
{
  int i, u, v, front = 0, back = 0;
  
  for (i = 1; i <= M; i++) {
    if (match[i] == NIL) {
      dist[i] = 0;
      Q[back++] = i;
    } else {
      dist[i] = INF;
    }
  }

  dist[NIL] = INF;

  while (front != back) {
    u = Q[front++];

    if (u == NIL)
      continue;

    for (i = 0; i < int(G[u].size()); i++) {
      v = G[u][i];
      if (dist[match[v]] == INF) {
        dist[match[v]]= dist[u] + 1;
        Q[back++] = match[v];
      }
    }
  }

  return dist[NIL] != INF;
}

bool dfs(int u)
{
  int i, v;
  if (u == NIL)
    return true;

  for (i = 0; i < int(G[u].size()); i++) {
    v = G[u][i];
    if (dist[u] + 1 == dist[match[v]]) {
      if (dfs(match[v])) {
        match[v] = u;
        match[u] = v;
        dist[u] = INF;
        return true;
      }
    }
  }

  dist[u] = INF;
  return false;
}


int main(int argc, char **argv)
{
  int t, i, j, r, c, u, node, ans;

  scanf("%d", &t);

  for (i = 0; i < MAX_N; i++)
    C[0][i] = (i%2 == 0) ? 'W' : 'B';

  for (i = 1; i < MAX_N; i++)
    for (j = 0; j < MAX_N; j++)
      C[i][j] = (C[i-1][j] == 'W') ? 'B' : 'W';

  while (t--) {
    scanf("%d %d\n", &m, &n);

    for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++)
        B[i][j] = getchar();
      getchar(); // \n
    }

    memset(id, 0, sizeof id);
    node = 1;
    for (i = 0; i < m; i++)
      for (j = 0; j < n; j++)
        if (B[i][j] == '.' && C[i][j] == 'W')
          id[i][j] = node++;

    M = node - 1;

    for (i = 0; i < m; i++)
      for (j = 0; j < n; j++)
        if (B[i][j] == '.' && C[i][j] == 'B')
          id[i][j] = node++;

    N = node - M - 1;

    for (i = 0; i < LIMIT; i++)
      G[i].clear();

    for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
        for (int k = 0; k < 8; k++) {
          r = i + V[k];
          c = j + H[k];
          u = id[i][j];

          if (c >= 0 && c < n && r >= 0 && r < m)
            if (B[r][c] == '.')
              G[u].push_back(id[r][c]);
        }

      }
    }

    //for (i = 0; i < m; i++) {
    //  for (j = 0; j < n; j++)
    //    cout << C[i][j] << " ";
    //  cout << endl;
    //}

    //cout << endl;

    //for (i = 0; i < m; i++) {
    //  for (j = 0; j < n; j++)
    //    cout << id[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;

    //for (i = 1; i <= M + N; i++) {
    //  cout << i << " : ";
    //  for (j = 0; j < int(G[i].size()); j++)
    //    cout << G[i][j] << " ";
    //  cout << endl;
    //}

    ans = node - 1;
    memset(match, NIL, sizeof match);

    while (bfs()) {
      for (i = 1; i <= M; i++)
        if (match[i] == NIL && dfs(i))
          ans--;
    }

    printf("%d\n", ans);
  }

  return EXIT_SUCCESS;
}

