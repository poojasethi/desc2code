#include <bits/stdc++.h>
using namespace std;
 
#define PB push_back
#define MP make_pair
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
#define si(a) scanf("%d", &a)
#define sl(a) scanf("%lld", &a)
#define sd(a) scanf("%lf", &a)
#define sii(a, b) scanf("%d%d", &a, &b)
#define sll(a, b) scanf("%lld%lld", &a, &b)
#define sdd(a, b) scanf("%lf%lf", &a, &b)
#define siii(a, b, c) scanf("%d%d%d", &a, &b, &c)
#define slll(a, b, c) scanf("%lld%lld%lld", &a, &b, &c)
#define sddd(a, b, c) scanf("%lf%lf%lf", &a, &b, &c)
 
#define DIM 30
#define MAX 100005
 
const int dim = 26;
struct matrix {
   double val[DIM][DIM];
 
   matrix operator * (const matrix &B)
   {
      matrix ret;
      REP(i, dim) REP(j, dim) {
         double sum = 0.0;
         REP(k, dim) sum += val[i][k]*B.val[k][j];
         ret.val[i][j] = sum;
      }
      return ret;
   }
};
 
matrix identity()
{
   matrix ret;
   REP(i, dim) REP(j, dim) {
      ret.val[i][j] = 0.0;
      if(i == j) ret.val[i][i] = 1.0;
   }
   return ret;
}
 
void print(matrix &X)
{
   REP(i, dim) {
      REP(j, dim) printf("%lf ", X.val[i][j]);
      puts("");
   }
}
 
matrix bigmod(matrix &X, int pw)
{
   matrix ret = identity();
   while(pw > 0) {
      if(pw & 1)
         ret = ret*X;
      X = X*X;
      pw /= 2;
   }
   return ret;
}
 
void main_()
{
   matrix X;
   int N, K;
   string s, wrd;
   cin >> N >> K;
   cin >> s;
   REP(i, dim) REP(j, dim) cin >> X.val[i][j];
   X = bigmod(X, K);
 
   map <string, bool> mp;
   double ret = 0.0;
   REP(i, N) {
      cin >> wrd;
      if(wrd.SZ != s.SZ) continue;
      if(mp.find(wrd) != mp.end()) continue;
      mp[wrd] = true;
      double add = 1.0;
      REP(j, wrd.SZ)
         add *= X.val[s[j]-'a'][wrd[j]-'a'];
      ret += add;
   }
   printf("%.8lf\n", ret);
}
 
int main()
{
   ios_base::sync_with_stdio(0); cin.tie(0);
   //WRITE("test.out");
   int t;
   cin >> t;
 
   while(t--) main_();
 
   return 0;
}