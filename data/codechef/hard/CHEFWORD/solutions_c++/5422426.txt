
//#define DEBUG       //comment when you have to disable all debug macros.
//#define LOCAL     //uncomment for testing from local file
#define NDEBUG    //comment when all assert statements have to be disabled.
//#include GRAPH
#include <iostream>
#include <cstring>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <bitset>
#include <climits>
#include <ctime>
#include <algorithm>
#include <functional>
#include <stack>
#include <queue>
#include <list>
#include <deque>
#include <sys/time.h>
#include <iomanip>
#include <cstdarg>
#include <utility> //std::pair
#include <cassert>
#define fd(i,a) for(i=1;i<=a;i++)
#define fa(i,a,b) for(i=a;i<=b;i++)
#define fs(i,a,b,c) for(i=a;i<=b;i+=c)
#define tr(c,i) for(typeof(c.begin()) i = (c).begin(); i != (c).end(); i++) 
#define present(c,x) ((c).find(x) != (c).end()) 
#define all(x) x.begin(), x.end()
#define pb push_back
#define mp make_pair
#define clr(x,y) memset(x,y,sizeof x)
#define log2(x) (log(x)/log(2))
#define ARRAY_SIZE(arr) (1[&arr]-arr)      
#define INDEX(arr,elem)        (lower_bound(all(arr),elem)-arr.begin())
#define lld long long int
#define MOD 1000000007
#define gcd __gcd
#define equals(a,b) (a.compareTo(b)==0)    //for strings only
using namespace std;

#ifdef DEBUG
#define debug(args...)            {dbg,args; cerr<<endl;}
#else
#define debug(args...)              // Just strip off all debug tokens
#endif

#ifdef GRAPH
#include "drawGraph.cpp"
#endif

struct debugger
{
	template<typename T> debugger& operator , (const T& v)
		{    
			cerr<<v<<" ";    
			return *this;    
		}

}dbg;

typedef vector<vector<long double> > TARR;
set<string> target;


TARR mul(TARR A, TARR B) {
    TARR C(26, vector<long double>(26, 0.0));
	 lld i,j,k;
    for(i = 0; i < 26; i++) {
        for( j = 0; j < 26; j++) {
            for( k = 0; k < 26; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return C;
}
TARR expo(TARR a, int k) {
    if(k==1) {
        return a;
    }
    if(k%2!=0) {
        return mul(a, expo(a, k - 1));
    }
    TARR sub = expo(a, k / 2);
    return mul(sub, sub);
}


TARR multiply(TARR &pp,lld n){
	//n--;
	return expo(pp,n);
}

void solve(TARR &pp, string start, lld k){
	lld len=start.length(),i;
	string t;
	long double p=0,c;
	pp = multiply(pp,k);
	tr(target,it){
		t = *it;
		if(start.length()!=t.length())continue;
		c=1;
//p+=init[v][maps(*it)];
		for(i=0;i<len;i++){
			c*=pp[start[i]-'a'][t[i]-'a'];
//			debug(start[i],t[i],mat[start[i]-'a'][t[i]-'a']);
		}

		p+=c;
		//	debug(t,c,p);
	}
	cout<<fixed<<setprecision(15)<<p<< "\n";
}

int main()
{
#ifdef LOCAL
	freopen("input.in","r",stdin);
#endif
	lld t,n,k,i,j,slen;
	string start,s;
	TARR pp(26, vector<long double>(26, 0.0));
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		scanf("%lld",&k);
		cin>>start;
		slen = start.length();
		for(i=0;i<26;i++)for(j=0;j<26;j++)scanf(" %Lf",&pp[i][j]);
		
		// printf("{");
		// for(i=0;i<26;i++){
		// 	printf("{");
		// 	for(j=0;j<25;j++)printf("%.2lf,",alpha_p[i][j]);
		// 	printf("%.2lf},",alpha_p[i][25]);
		// }		printf("}");


		target.clear();
		for(i=0;i<n;i++){
			cin>>s;
			target.insert(s);
		}
		solve(pp,start,k);
	}
}