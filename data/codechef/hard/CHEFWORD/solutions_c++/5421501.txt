#include <bits/stdc++.h>

using namespace std;

template< class T >
class Matrix
{
    public:
		int m,n;
		T *data;

        Matrix( int m, int n );
		Matrix( const Matrix< T > &matrix );

		const Matrix< T > &operator=( const Matrix< T > &A );
        const Matrix< T > operator*( const Matrix< T > &A );
        const Matrix< T > operator^( int P );

		~Matrix();
};

template< class T >
Matrix< T >::Matrix( int m, int n )
{
    this->m = m;
    this->n = n;
    data = new T[m*n];
}

template< class T >
Matrix< T >::Matrix( const Matrix< T > &A )
{
    this->m = A.m;
    this->n = A.n;
    data = new T[m*n];
    for( int i = 0; i < m * n; i++ )
		data[i] = A.data[i];
}

template< class T >
Matrix< T >::~Matrix()
{
    delete [] data;
}

template< class T >
const Matrix< T > &Matrix< T >::operator=( const Matrix< T > &A )
{
    if( &A != this )
    {
        delete [] data;
        m = A.m;
        n = A.n;
        data = new T[m*n];
        for( int i = 0; i < m * n; i++ )
			data[i] = A.data[i];
    }
    return *this;
}

template< class T >
const Matrix< T > Matrix< T >::operator*( const Matrix< T > &A )
{
	Matrix C( m, A.n );
	for( int i = 0; i < m; ++i )
		for( int j = 0; j < A.n; ++j )
        {
			C.data[i*C.n+j]=0;
			for( int k = 0; k < n; ++k )
				C.data[i*C.n+j] = C.data[i*C.n+j] + data[i*n+k]*A.data[k*A.n+j];
		}
	return C;
}

template< class T >
const Matrix< T > Matrix< T >::operator^( int P )
{
	if( P == 1 ) return (*this);
	if( P & 1 ) return (*this) * ((*this) ^ (P-1));
	Matrix B = (*this) ^ (P/2);
	return B*B;
}

int main()
{
    int i, j, t, n, k;
    double x;
    scanf("%d", &t);
    while(t--){
        scanf("%d%d\n", &n, &k);
        Matrix<double> M(26,26);
        Matrix<double> P(26,26);
        string s;
        getline(cin, s);
        for(i=0; i<26; i++){
            for(j=0; j<26; j++){
                scanf("%lf\n", &x);
                M.data[i*26+j] = x;
            }
        }
        /*for(i=0; i<3; i++){
            for(j=0; j<3; j++){
                cout << M.data[i*3+j] << " ";
            }
            cout << "\n";
        }*/
       /* for(i=0; i<4; i++)
            M.data[i] = .25;
        M.data[26] = .5;
        M.data[27] = .5;
        M.data[52] = .1;
        M.data[53] = .9;
        for(i=3; i<26; i++)
            M.data[26*i] = 1;*/
        P = M^k;
        /*for(i=0; i<26; i++){
            for(j=0; j<26; j++){
                cout << P.data[i*26+j] << " ";
            }
            cout << "\n";
        }*/
        double ans=0;
        set<string> myset;
        while(n--){
            string s1;
            getline(cin, s1);
            if(myset.find(s1)!=myset.end())
                continue;
            myset.insert(s1);
            if(s.size()!=s1.size())
                continue;
            x=1.0;
            for(i=0; i<s.size(); i++){
                if(!(s1[i]>='a'&&s1[i]<='z')){
                    x=0;
                    break;
                }
                /*else if(!(s1[i]>='a'&&s1[i]<='z')){
                    if(s[i]!=s1[i]){
                        x=0;
                        break;
                    }
                }*/
                else{
                    //cout << (s[i]-'a')*26+s1[i]-'a' << " ";
                    //cout << M.data[(s[i]-'a')*26+s1[i]-'a'] << "\n";
                    x=double(x*P.data[(s[i]-'a')*26+s1[i]-'a']);
                }
            }
            ans=double(ans+x);
        }
        //cout << ans << "\n";
        //char buf[4*(DBL_MANT_DIG + DBL_MAX_EXP)];
        //snprintf(buf, sizeof buf, "%.*f", (int)sizeof buf, ans);
       // char *p = strchr(buf, '.'); // beware locale-specific radix char, though!
        //p[8+1] = 0;
        //puts(buf);
        printf("%.15lf\n", ans);
        //cout << setprecision(14) << ans << "\n";
        //cout << setprecision(15) << ans << "\n";
    }

    return 0;
}
