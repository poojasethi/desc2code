#include <iostream>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <string>
#include <set>
#include <vector>

using std::set;
using std::string;
using std::vector;

class CMathUtil
{
	CMathUtil(const CMathUtil&);
	CMathUtil& operator=(const CMathUtil&);
public:
	CMathUtil() { ; }
	~CMathUtil() { ; }
public:
	// 快速幂运算
	template<class data_t> static void quick_exp(const data_t& a,data_t& e,unsigned long long x)
	{
		data_t product = a;
		for(;0 != x;x >>= 1)
		{
			if(x&1) e = product*e;
			product = product*product;
		}
	}
};

template<class data_t,class value_t>
class CMatrixImpl:public value_t
{
protected:
	size_t				_size;
	size_t				_row;
	size_t				_col;
private:
	static unsigned int module;
protected:
	typedef unsigned long long uint64_t;
public:
	static void init(unsigned int m) { module = m; }
	data_t& operator()(size_t i,size_t j) { assert(0 <= i && i < _row && 0 <= j && j < _col);return value_t::_p[i*_col+j]; }
	const data_t& operator()(size_t i,size_t j)const  { assert(0 <= i && i < _row && 0 <= j && j < _col);return value_t::_p[i*_col+j]; }
public:	// 这个接口只对方阵有效
	void unit() { assert(_row == _col);memset(value_t::_p,0,sizeof(unsigned int)*_size);for(size_t i = 0;i < _size;i += _row + 1) value_t::_p[i] = 1; }
protected:	// 这两个只对方阵有效
	data_t trD()const { assert(_row == _col);data_t ret = data_t();for(size_t i = 0;i < _size;i += _row+1) ret = ret+value_t::_p[i];return ret; }
	unsigned int trI()const { assert(_row == _col);uint64_t ret = 0;for(size_t i = 0;i < _size;i += _row+1) ret = (ret+value_t::_p[i])%module;return (unsigned int)(ret); }
protected:
	bool equal(const data_t* data,size_t size)const { return (size == _size && (0 == memcmp(value_t::_p,data,_size*sizeof(data_t)))); }
protected:
	void add(const data_t* data,data_t* result)const { for(size_t i = 0;i < _size;++i) result[i] = value_t::_p[i]+data[i]; }
	void addI(const unsigned int* data,unsigned int* result)const { for(size_t i = 0;i < _size;++i) result[i] = ((uint64_t)value_t::_p[i]+data[i])%module; }
	void sub(const data_t* data,data_t* result)const { for(size_t i = 0;i < _size;++i) result[i] = value_t::_p[i]-data[i]; }
	void subI(const unsigned int* data,unsigned int* result)const { for(size_t i = 0;i < _size;++i) result[i] = ((uint64_t)value_t::_p[i]+module-data[i])%module; }
protected:
	void mulI(const unsigned int* data,unsigned int* result,size_t dim)const
	{
		for(size_t k = 0;k < dim;++k)
		{
			for(size_t i = 0,u = k;i < _row;++i,u += dim)
			{
				if(0 == value_t::_p[u]) continue;
				for(size_t j = 0,v = k*_col,w = i*_col;j < _col;++j,++v,++w)
				{
					result[w] = ((uint64_t)result[w]+((uint64_t)value_t::_p[u]*data[v])%module)%module;
					// 如果module*module+module不超过uint64_t,则可以采用下面的语句稍微快一些
					//result[w] = ((uint64_t)result[w]+(uint64_t)_p[u]*data[v])%module;
				}
			}
		}
	}
protected:
	void mul(const data_t* data,data_t* result,size_t dim)const
	{
		for(size_t i = 0,p = 0;i < _row;++i)
		{
			for(size_t j = 0;j < dim;++j,++p)
			{
				for(size_t k = 0;k < _col;++k)
				{
					result[p] += value_t::_p[i*_col+k]*data[k*dim+j];
				}
			}
		}
	}
};

template<class data_t,class value_t> unsigned int CMatrixImpl<data_t,value_t>::module = 0;


template<class data_t,size_t Row,size_t Col>
class matrix_stack_value_t
{
protected:
	data_t	_p[Row*Col];
};

template<class data_t,size_t Row,size_t Col>
class stack_matrix_t:public CMatrixImpl< data_t,matrix_stack_value_t<data_t,Row,Col> >
{
private:
	typedef CMatrixImpl< data_t,matrix_stack_value_t<data_t,Row,Col> > base_t;
public:
	stack_matrix_t() { base_t::_row = Row,base_t::_col= Col,base_t::_size = Row*Col;memset(base_t::_p,0,base_t::_size*sizeof(data_t)); }
	~stack_matrix_t() { ; }
public:
	bool operator==(const stack_matrix_t& rhs)const { return base_t::equal(rhs._p,rhs._size); }
	bool operator!=(const stack_matrix_t& rhs)const { return !((*this) == rhs); }
public:
	stack_matrix_t operator+(const stack_matrix_t& rhs)const { stack_matrix_t result;add(rhs._p,result._p);return result; }
	stack_matrix_t operator-(const stack_matrix_t& rhs)const { stack_matrix_t result;sub(rhs._p,result._p);return result; }
	stack_matrix_t operator*(const stack_matrix_t& rhs)const { if(Col != Row) throw "";stack_matrix_t ret;base_t::mul(rhs._p,ret._p,Row);return ret; }
public:	// 只对方阵有效
	unsigned int tr()const { return tr(); }
	stack_matrix_t operator^(unsigned long long x)const
	{
		assert(base_t::_row == base_t::_col);
		stack_matrix_t result;result.unit();
		CMathUtil::quick_exp(*this,result,x);
		return result;
	}
};

void CodeChef201411CHEFWORD()
{
	static const size_t charset_size = 26;
	typedef stack_matrix_t<double,charset_size,charset_size> CMatrix;

	static const size_t buff_size = 100;

	CMatrix convert;
	unsigned int nCases = 0;scanf("%d",&nCases);								// 1 <= nCases <= 50
	for(unsigned int iCases = 1;iCases <= nCases;++iCases)
	{
		char buff[buff_size] = { 0 },word[buff_size] = { 0 };
		unsigned int n = 0,k = 0;												// 1 <= n <= 100000,1 <= k <= 1000000000
		scanf("%d%d%s",&n,&k,buff);
		for(unsigned int i = 0;i < charset_size;++i)
		{
			for(unsigned int j = 0;j < charset_size;++j)
			{
				double v = 0;
				scanf("%lf",&v);
				convert(i,j) = v;
			}
		}

		CMatrix result = convert^k;

		double ans = 0;
		size_t len = strlen(buff);
		set<string> table;
		for(unsigned int i = 0;i < n;++i)
		{
			scanf("%s",word);
			if(strlen(word) != len) continue;
			if(table.find(word) != table.end()) continue;
			table.insert(word);
			double v = 1.0;
			for(size_t j = 0;j < len;++j)
			{
				v *= result(buff[j]-'a',word[j]-'a');
			}
			ans += v;
		}
		printf("%.9f\n",ans);
	}
}

int main()
{
	CodeChef201411CHEFWORD();
	return 0;
}
