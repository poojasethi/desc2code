#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>
#include <queue>
#include <deque>
#include <cstring>
#include <string>
using namespace std;
#define fi "input.txt"
#define fo "output.txt"
#define fileopen freopen(fi,"r",stdin);freopen(fo,"w",stdout);
#define FOR(i,l,r) for(int i=(int)l;i<=(int)r;i++)
#define FORD(i,l,r) for(int i=(int)l;i>=(int)r;i--)
#define xy pair<int,int>
#define pb push_back
#define int64 long long
#define X first
#define Y second
#define init(a,v) memset(a,v,sizeof(a))
#define Sz(s) ((int)s.size())

const int OO = 2e9;
const int64 MOD = 1e9+7;
const double Pi = 3.141592653589793;
const int N = 1e3+5;
const int M=31  ;

struct Matrix{
    int n,m;
    int64 v[M][M];
    void clr() {init(v,0);}
} odd,even;

Matrix operator*(Matrix A,Matrix B) {
    Matrix res;res.n=A.n;res.m=B.m;res.clr();
    FOR(i,1,A.n) FOR(j,1,B.m) FOR(k,1,A.m) {
        res.v[i][j]=res.v[i][j]+A.v[i][k]*B.v[k][j];
        if (res.v[i][j]>MOD) res.v[i][j]%=MOD;
    }
    return res;
}

Matrix Power(Matrix A,int k) {
    if (k==1) return A;
    Matrix half=Power(A,k/2);
    if (k%2) return half*half*A; else return half*half;
}

int64 MM(int n,int m) {
    int64 res=0;
    Matrix Src;
    odd.n=odd.m=even.n=even.m=m;
    Src.n=m;Src.m=1;
    FOR(i,1,m) Src.v[i][1]=1;
    if (n>1) Src=Power(odd,n/2)*Src;
    if (n>2) Src=Power(even,(n-1)/2)*Src;
    FOR(i,1,m) res=(res+Src.v[i][1])%MOD;
    return res;
}

void solve() {
    FOR(i,1,30) FOR(j,1,30) {
        even.v[i][j]=(abs(i-j)<=1);
        odd.v[i][j]=(abs(i-j)==1);
    }
    int t,n,m;scanf("%i",&t);
    while (t--) {
        scanf("%i%i",&n,&m);
        cout<<MM(n,m)<<endl;
    }
}

int main() {
    solve();
}