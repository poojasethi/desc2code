# include <iostream>
# include <algorithm>
# include <cstdio>
# include <cmath>
# include <numeric>
# include <cstdlib>
# include <cstring>
# include <vector>
# include <list>
# include <set>
# include <map>
# include <stack>
# include <string>
# include <queue>
# include <cctype>
# include <climits>
# include <complex>
using namespace std;
#define all(a) a.begin(),a.end()
#define si(n) scanf("%d",&n)
#define pi(n) printf("%d" , n)
#define sl(n) scanf("%lld" , &n)
#define pl(n) printf("%lld" , n)
#define pnl() printf("\n")
#define pb push_back
#define ss second
#define ff first
#define mp make_pair
#define sz(a) a.size()
#define fill(a,v)  memset(a,v,sizeof(a))
#define index(arr,ind) (lower_bound(all(arr),ind)-arr.begin())
typedef long long ll ;
typedef unsigned long long ull;
long long INF = 1e9 ;
typedef pair < int , int > pii ;
typedef  vector < int > vi ;
typedef vector < pii > vpi ;
typedef vector < ll > vl ;
typedef pair < int , pii > tri ;
typedef vector < string > vs ;
typedef vector < vi > mat ;
long long  mod  = 1e9 + 7 ;
int m  , t ;
mat mul ( mat a , mat b )
{
    int r1 , c1 , r2 , c2 ;
    r1 = a.size() ;
    c1 = a[0].size() ;
    r2 = b.size() ;
    c2 = b[0].size() ;
    mat c ( r1 , vi ( c2 , 0 )) ;
    for ( int i = 0 ; i < r1 ; i++)
    {
        for ( int j= 0 ; j < c2 ; j++)
        {
            c[i][j] = 0 ;
            for ( int k = 0 ; k < r2 ; k++)
            {
                c[i][j] = ( ( c[i][j] % mod )+ (  (( a[i][k] % mod ) * ( b[k][j] % mod ) ) % mod  ) % mod ) % mod ;
            }
        }

    }
    return c ;
}

mat pow ( mat a , int ex )
{
    mat ans ( m , vi ( m , 0)) ;
    if ( ex == 1 )
        return a ;
    mat y = pow ( a , ex / 2 );
    ans = mul ( y , y ) ;
    if (( ex % 2 ) != 0  )
    ans = mul ( a , ans ) ;
    return ans ;
}


int main()
{
    long long n , ways ;
    si(t) ;
    while ( t-- )
    {
        ways = 0 ;
        sl(n) ;
        si(m) ;
        if ( n == 1)
        {
            pi(m) ;
            pnl() ;
            continue ;
        }
        if ( m == 1 )
        {
            pi(0) ;
            pnl() ;
            continue ;

        }
        mat even ( m , vi ( m , 0 )) ,  odd ( m , vi ( m , 0 )) ,  odev( m , vi ( m , 0 )) , base ( m ,  vi ( 1 , 1)) , fr( m , vi ( 1 , 0 )) ;
        for ( int i = 0 ; i < m ; i++)
        {
            if ( i == 0 )
                even[i][i+1] = odd[i][i+1] = 1  ;
            else if ( i == ( m -1 ))
                even[i][m-2] = odd[i][m-2] = 1 ;
            else
            {
                even[i][i+1] =  even[i][i-1] = odd[i][i+1] = odd[i][i-1] = 1 ;

            }
            odd[i][i] = 1 ;
        }
        if ( n == 2 )
        {

            fr = mul ( even ,  base ) ;
            for ( int i = 0 ; i < m ; i++)
            {
                ways = ( ways + fr[i][0] ) % mod ;
                ways = ways % mod ;
            }
            pl(ways) ;
            pnl() ;
            continue ;
        }
        long long exp = ( n - 1 ) / 2 ;
        odev = mul( odd , even ) ;
       /* cout << endl ;
        cout << " odev array " << endl ;
        for ( int i = 0 ; i < m ; i++)
        {
            for ( int j = 0 ; j < m ; j++)
            {
                cout << odev[i][j] << " " ;
            }
            cout << endl ;
        }
        */
        odev = pow ( odev , exp ) ;
        if ( ( n % 2 ) == 0 )
        {
            odev = mul (  even , odev ) ;
        }
        fr = mul ( odev , base ) ;
        for ( int i = 0 ; i < m ; i++)
            {
                ways = ( ways + fr[i][0] ) % mod ;
                ways = ways % mod ;
            }
            pl(ways) ;
            pnl() ;
    }
    return 0 ;
}
