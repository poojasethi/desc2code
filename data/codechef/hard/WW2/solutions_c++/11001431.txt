#include <iostream>
#include <cstring>
using namespace std;
#define MX 32
#define CLR(a) memset(a,0,sizeof a)
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define MOD 1000000007
typedef long long ll;

struct Matrix
{
    int m[MX][MX];
 
    int row,col;
 
    Matrix(){
    	CLR(m);
    }
 
    Matrix(int m2[MX][MX],int row2,int col2){
        row=row2;
        col=col2;
        rep(i,0,row-1)
            rep(j,0,col-1)
                m[i][j] = m2[i][j];
    }
 
    Matrix operator * (const Matrix& obj) // multiplication
    {
        Matrix ret;
 
        ret.row=row;
        ret.col=obj.col;
 
        rep(k,0,col-1)
            rep(i,0,row-1)
                rep(j,0,obj.col-1)
                    ret.m[i][j] = (ret.m[i][j] + (ll)m[i][k]*obj.m[k][j])%MOD;
 
        return ret;
    }
 
    Matrix operator ^ (int p) // exponentiation
    {
        Matrix ret, temp(this->m,this->row,this->col);  // init temp with 'this' matrix
 
        ret.row=row;
        ret.col=col;
 
        rep(i,0,temp.row-1) // initialize ret with identity matrix
            ret.m[i][i] = 1;
 
        while(p)
        {
            if(p&1)
            {
                ret = ret*temp;
            }
 
            temp = temp*temp;
            p >>= 1;
        }
 
        return ret;
    }
};

int main() {
int t;scanf("%d",&t);
int row,col,a[MX][MX],b[MX][MX];

Matrix c[2];

while(t--){
scanf("%d%d",&row,&col);
CLR(b);
for(int l=0;l<=1;l++){
	CLR(a);
	for(int j=0;j<col;j++){
		 b[j][0]=1;
		for(int k=-1;k<=1;k++){
			if((l!=0||k!=0) &&(j+k>=0)&&(j+k<=col-1)){
				a[j][j+k]++;
			}
		}
	}
	c[l] = Matrix(a,col,col); 
}

	Matrix m=((c[1]*c[0])^((row-1)>>1))*Matrix(b,col,1);
    if(row%2==0) m=c[0]*m;

	 int ans=0;
        rep(j,0,col-1) {
            ans=(ans+m.m[j][0])%MOD;
        }
 
        printf("%d\n",ans);
}
	return 0;
}