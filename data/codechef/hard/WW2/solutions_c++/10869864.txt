#include <bits/stdc++.h>
 
using namespace std;
 
#define ll long long int
#define pb push_back
#define mp make_pair
#define INF (ll)(1e18)
#define inf 0x7fffffff
#define inff 100000
#define ff first
#define ss second
#define sz(x) ((int) (x).size())
#define fast cin.sync_with_stdio(0);cin.tie(0)
#define rep(i,N) for(int i = 0;i < N;i++)
#define frep(i,a,b) for(int i = a;i <= b;i++)
#define pii pair<int , int>
#define pll pair<ll , ll>
#define vii vector<int>
#define vpii vector< pii >
#define fill(A,v) memset(A,v,sizeof(A))
#define setbits(x) __builtin_popcountll(x)
#define print(A,j,k) for(int ii=j;ii<k;ii++)cout<<A[ii]<<" ";cout<<"\n"
#define all(x) (x).begin(), (x).end()
#define gcd __gcd
#define SQRT 350
#define CASES int t;cin>>t;while(t--)
#define FILE freopen("inp.txt" , "r" , stdin);
#define ld long double

const int MOD = 1e9 + 7;
const int N = 1e6 + 5;

class matrix {
public:
    int rows;
    int columns;
    ll values[105][105];
    matrix(int r , int c) {
        rows = r;
        columns = c;
    }
    matrix(int r , int c , int v) {
        rows = r;
        columns = c;
        rep(i , r)
            rep(j , c)
                values[i][j] = v;
    }
    matrix() {
        assert(false);
    }
    void display() {
        rep(i , rows) {
            rep(j , columns)
                cout << values[i][j] << ' ';
            cout << '\n';
        }
        cout << '\n';
    }
};

matrix product(matrix &a , matrix &b) {
    matrix c(a.rows , b.columns);
    for(int i = 0;i < a.rows;i++) {
        for(int j = 0;j < b.columns;j++) {
            ll sum = 0;
            for(int k = 0;k < a.columns;k++) {
                sum += a.values[i][k] * b.values[k][j]; 
                if (sum >= MOD)
                    sum %= MOD;
            }
            c.values[i][j] = sum;
        }
    }
    return c;
}

matrix fpow(matrix &base, int power) {
    if (power == 1) {
        return base;
    }
    matrix sq = product(base , base);
    matrix res = fpow(sq , power/2);
    if (power % 2)
        res = product(res , base);
    return res;
}


int main(int argc, char const *argv[])
{
    fast;

    CASES {
        int n , m;
        cin >> n >> m;

        if (n == 1) {
            cout << m << '\n';
            continue;
        }

        matrix odd(m , m) , even(m , m);

        //XOXOXOXO
        //OXOXOXOX
        //XOXOXOXO
        rep(i , even.rows) {
            even.values[i][i] = 1;
            if (i >= 1) 
                even.values[i][i - 1] = odd.values[i][i - 1] = 1;
            if (i < odd.rows - 1)
                even.values[i][i + 1] = odd.values[i][i + 1] = 1;
        }

        matrix transition = product(odd , even);
        n--;

        matrix one(1 , m , 1);      //1Xm initial matrix


        if (n == 1) {
            matrix res = product(one , odd);
            ll ans = 0;
            for(int i = 0; i < res.columns;i++) {
                ans = ans + res.values[0][i];
                if (ans >= MOD)
                    ans %= MOD;
            }
            cout << ans << '\n';
            continue;
        }

        if (n >= 2) {
            transition = fpow(transition , n/2);
        }

        // odd.display();
        // even.display();
        // transition.display();

        if (n % 2)
            transition = product(transition , odd);

        matrix res = product(one , transition);
        ll ans = 0;
        for(int i = 0; i < res.columns;i++) {
            ans = ans + res.values[0][i];
            if (ans >= MOD)
                ans %= MOD;
        }
        cout << ans << '\n';
    }

    return 0;
}