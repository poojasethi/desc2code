/* Matrix Exponentiation
Ref: Editorial
*/
#include <bits/stdc++.h>

typedef long long lld;
typedef unsigned long long llu;
#define rep(i,x,y)  for(i=x;i<y;i++)
#define rrep(i,x,y) for(i=x;i>=y;i--)
#define trv(y,x)    for(typeof(x.begin())y=x.begin();y!=x.end();y++)
#define MOD 1000000007
#define INF 1000000001

using namespace std;

class Matrix
{
    public:
    int row,col;
    vector< vector<lld> > A;
    Matrix(int n,int m)
    {
        row=n;
        col=m;
        A=vector< vector<lld> >(n,vector<lld>(m,0));
    }
    Matrix operator *(Matrix B)
    {
        if(col==B.row)
        {
            Matrix Pr(row,B.col);
            int i,j,k;
            rep(i,0,Pr.row)
                rep(j,0,Pr.col)
                    rep(k,0,col)
                        Pr.A[i][j]=(Pr.A[i][j]+(A[i][k]*B.A[k][j])%MOD)%MOD;
            return Pr;
        }
    }
    ~Matrix()
    {
        row=col=0;
        A.clear();
    }
};

Matrix ModPow(Matrix A,int p)
{
    if(p==1)
        return A;
    else if(p%2==1)
    {
        return A*ModPow(A,p-1);
    }
    else
    {
        Matrix B(A.row,A.col);
        B=ModPow(A,p/2);
        return B*B;
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t,m,n,i,j;
    lld Ans;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        Matrix ToEven(m,m),ToOdd(m,m),I(m,m);
        rep(i,0,m) I.A[i][i]=1; // Identity Matrix
        rep(i,0,m) // Transition Matrices
        {
            ToOdd.A[i][i]=1;
            if(i-1>=0){
                ToOdd.A[i][i-1]=1;
                ToEven.A[i][i-1]=1;
            }
            if(i+1<m){
                ToOdd.A[i][i+1]=1;
                ToEven.A[i][i+1]=1;
            }
        }
        --n; // No of rows b/w 1st and n-th
        Matrix Soln=(n/2)>0?ModPow(ToEven*ToOdd,n/2):I;
        if(n%2==1) Soln=Soln*ToEven;
        Ans=0;
        rep(i,0,m)rep(j,0,m)Ans=(Ans+Soln.A[i][j])%MOD;
        cout<<Ans<<'\n';
    }
    return 0;
}
