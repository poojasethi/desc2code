#include <cstdio>
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
 
using namespace std;
 
void solve();
int main() {
  int t;
  scanf("%d\n", &t);
  while (t--) {
    solve();
  }
  return 0;
}
int N;
//vector<vector<int> > G;
int G[30][30];
 
int lleft[30];
int graf[33];
void dfs(int nod) {
  ++N; graf[N-1] = nod; lleft[nod] = 0;
  for (int i = 1; i <= G[nod][0]; ++i) if (lleft[G[nod][i]]) {
    dfs(G[nod][i]);
  }
}
int compute();
 
void solve() {
  int m;
  scanf("%d\n", &m);
  //G.clear(); G.resize(30);
  //memset(lleft, 0, sizeof(lleft)); 
  for (int i = 0; i < 27; ++i) G[i][0] = 0; 
  while (m--) {
    char a, b;
    cin >> a >> b;
    
    lleft[a-'A'] = lleft[b-'A'] = 1;
    a-='A'; b-='A';
    G[a][++G[a][0]] = b;
    G[b][++G[b][0]] = a;
    //G[a-'A'].push_back(b-'A');
    //G[b-'A'].push_back(a-'A');
  }
  //solve for subcomponents
  int total = 0;
  for (int i = 0; i < 30; ++i) if (lleft[i]) {
    N = 0;
    dfs(i);
    //am un graf
    total += compute();
  }
 
  printf("%d\n", total * 100);
 
}
int masks[30];
int invers[30];
int best;
int finish;
void back(int mask,int steps, int k) {
  if (steps >= best) return;
  if (mask == finish) {best=steps; return;}
  if (steps + 1 >= best) return;
  if (k >= N) return;
  //use k or not
  back(mask | masks[k], steps+1, k+1);
  back(mask, steps, k+1);
}
int compute() {
  if (N == 2) return 1;
  if (N == 3) return 1;
  //build the masks
  for (int i = 0; i < N; ++i) invers[graf[i]] = i;
  for (int i = 0; i < N; ++i) {
    masks[i] = (1 << i);
    for (int j = 1; j <= G[graf[i]][0]; ++j) {
      masks[i] |= (1 << invers[G[graf[i]][j]]);
    }
  }
  //done the masks?
  best = (N+1)/2;
  finish = (1 << N) - 1;
  back(0, 0, 0);
  return best;
} 