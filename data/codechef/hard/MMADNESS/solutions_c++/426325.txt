/* Author : Akshay */
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
using namespace std;
#define sqr(x) x*x
typedef pair<int,int> ii;
int tc,n,G[30],i,j,Visited,ret;
char ch1,ch2;
void f(int idx,int mask,int count)
{
	if( idx >=26 || (count>=ret ))
		return ;
	if( mask == Visited)
	{
		ret=count;
		return ;
	}
	if((Visited & (1<<idx))==0)//Node is not present
	{
		f(idx+1,mask,count);
		return ;
	}
	else
	{
		//Either I can make this node as administrator or not
		f(idx+1,mask,count);
		if((mask|(G[idx])) != mask ) f(idx+1,mask|G[idx],count+1);
	}
}
int main()
{
	scanf("%d",&tc);
	while(tc--)
	{
		scanf("%d",&n);
		Visited=0;//It is bitmask which denotes set of vertices which should have been visited at the end.
		for(i=0;i<26;i++) G[i]=(1<<i);
		//G[i] stores which all are vertices are directly acccessible from node i.
		for(i=0;i<n;i++)
		{
			scanf(" %c %c",&ch1,&ch2);
			G[(ch1-'A')] = G[(ch1-'A')] | ( 1 << (ch2-'A'));
			G[(ch2-'A')] = G[(ch2-'A')] | ( 1 << (ch1-'A'));
			Visited = Visited | ( 1 << (ch1-'A'));
			Visited = Visited | ( 1 << (ch2-'A'));
		}
		ret=100;
		f(0,0,0);
		/*f(idx,mask,cost) - idx is the last visited node , mask is set of vertices which have been visited till now and cost is the number of nodes that should be made administrator */
		printf("%d\n",100*ret);		
	}
	return 0;
}



