#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <queue>
#include <cstring>
using namespace std ;
 
#define FOREACH(it,c) for( __typeof((c).begin()) it=(c).begin();it!=(c).end();it++)
#define FOR(i,a,b) for( int i=(a),_b=(b);i<=_b;i++) 
#define DOW(i,b,a) for( int i=(b),_a=(a);i>=_a;i--)
#define REP(i,n) FOR(i,0,(n)-1)
#define DEP(i,n) DOW(i,(n)-1,0)
#define all(a) (a).begin() , (a).end()
#define push(a,b) (a).push_back((b))
#define For(i,a,b) for(int i = a; i < b; i++)
 
typedef vector<int> VI ;
typedef vector<string> VS ;
typedef long long ll;
typedef pair <int, int> pii;
template<class T> inline int size(const T&c) { return c.size(); }  

const int maxN = 302, inf = 1000000000;
int N, F, M, Q, n, qb, qf, lo, up, lid, uid;
map <pii,int> id;
int c[maxN][maxN];
set <int> events[102];
ll res;

int ID(int b, int f){
	pii t = make_pair(b, f);
	if (id.count(t) != 0) return id[t];
	id[t] = ++n;
	return id[t];
}

void AddE(int b1, int f1, int b2, int f2, int cost){
	int u = ID(b1, f1), v = ID(b2, f2);
	c[u][v] = c[v][u] = min(c[u][v], cost);
	events[b1].insert(f1);
	events[b2].insert(f2);
}

void BuildGraph(){
	for(int i = 1; i < maxN; i++)
		for(int j = i+1; j < maxN; j++)
			c[i][j] = c[j][i] = inf;

	for(int i = 1; i < N; i++) AddE(i, 1, i+1, 1, 1);
	int b1, b2, f1, f2, cost;
	for(int i = 1; i <= M; i++){
		scanf("%d %d %d %d %d", &b1, &f1, &cost, &b2, &f2);
		AddE(b1, f1, b2, f2, cost);
	}
	for(int i = 1; i <= N; i++){//Add cac canh noi cac dinh cua cung 1 hang
		set <int>::iterator curr = events[i].begin();
		int prev = 1;
		curr++;
		for(; curr!= events[i].end(); curr++){
			AddE(i, prev, i, *curr, *curr-prev);
			prev = *curr;
		}
	}
}

int GetLower(int b, int f){
	set <int>::iterator curr = events[b].lower_bound(f);
	if (curr == events[b].end() || *curr > f) curr--;
	return *curr;
}

int GetUpper(int b, int f){
	set <int>::iterator curr = events[b].upper_bound(f);
	if (curr == events[b].end()) return -1;
	return *curr;
}

int Dist(int b, int f){//duong di ngan nhat tu tang f cua toa nha b toi qb, bf
	int u = ID(b, f);
	int ret = qf-1 + f-1 + abs(b-qb);
	ret = min(ret, c[u][lid] + qf-lo);
	if (up != -1) ret = min(ret, c[u][uid] + up-qf);
	return ret;
}

long long SumChain(int first, int spt){//tong lien tiep i, i+1,...,i+spt-1
	return (2*first + spt - 1) * (ll)spt / 2;
}

void Floyd(){
	for(int k = 1; k <= n; k++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				c[i][j] = min(c[i][j], c[i][k] + c[k][j]);
}

int main(){
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);

	scanf("%d %d %d", &N, &F, &M);
	
	BuildGraph();
	Floyd();

	scanf("%d", &Q);
	while (Q--){
		scanf("%d %d", &qb, &qf);
		lo = GetLower(qb, qf);
		lid = ID(qb, lo);
		up = GetUpper(qb, qf);
		if (up != -1) 
			uid = ID(qb, up);
		res = 0;
		for(int i = 1; i <= N; i++){
			if (i == qb) continue;
			set <int>::iterator curr = events[i].begin();
			int a = *curr; curr++;
			int dA = Dist(i, a);
			for(; curr != events[i].end(); curr++){
				int b = *curr;
				int dB = Dist(i, b);
				int pA = (abs(dB - dA) + b - a) / 2;
				if (a + pA == b) pA--;
				int pB = b-a-1 - pA;
				if (dA > dB) swap(pA, pB);
				res += SumChain(dA, pA+1) + SumChain(dB+1, pB);
				a = b; dA = dB;
			}
			res += SumChain(dA, F-a+1);
		}
		printf("%lld\n", res);
	}

	return 0;
}
