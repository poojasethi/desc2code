#include<map>
#include<cstdio>
#include<vector>
#include<algorithm>
 
#define rep(i,n) for(int i=0;i<(n);i++)
 
using namespace std;
 
typedef long long ll;
 
const int INF=1<<29;
 
struct vertex{
	int id,h; // Ã¥Â¡ï¿½Ã£ï¿½Â®Ã§ï¿½ÂªÃ¥ï¿½Â·, Ã©ï¿½ï¿½Ã¦ï¿½Â°
	bool operator<(const vertex &v)const{ return id!=v.id ? id<v.id : h<v.h; }
};
 
struct edge{
	vertex u,v;
	int cost;
};
 
// a + (a+1) + (a+2) + (a+n-1)
ll sum(ll a,ll n){ return a*n+n*(n-1)/2; }
 
// h1 Ã©ï¿½ï¿½Ã£ï¿½Â¾Ã£ï¿½Â§Ã£ï¿½Â®Ã¦ï¿½ï¿½Ã§ï¿½Â­Ã¨Â·ï¿½Ã©ï¿½Â¢Ã£ï¿½ï¿½ d1, h2 Ã©ï¿½ï¿½Ã£ï¿½Â¾Ã£ï¿½Â§Ã£ï¿½Â®Ã¦ï¿½ï¿½Ã§ï¿½Â­Ã¨Â·ï¿½Ã©ï¿½Â¢Ã£ï¿½ï¿½ d2 Ã£ï¿½Â®Ã£ï¿½Â¨Ã£ï¿½ï¿½Ã£ï¿½Â®
// h1, h1+1, ..., h2 Ã©ï¿½ï¿½Ã£ï¿½Â¾Ã£ï¿½Â§Ã£ï¿½Â®Ã¦ï¿½ï¿½Ã§ï¿½Â­Ã¨Â·ï¿½Ã©ï¿½Â¢Ã£ï¿½Â®Ã¥ï¿½ï¿½
ll calc(int h1,ll d1,int h2,ll d2){
	if(d1>d2) swap(d1,d2);
	ll a=sum(d1,d2-d1);
	h1+=d2-d1;
	d1=d2;
	return a+sum(d1,(h2-h1+1)/2)+sum(d2,(h2-h1+2)/2);
}
 
int main(){
	int nb,nf,m; scanf("%d%d%d",&nb,&nf,&m);
	vector<edge> E;
	rep(i,m){
		int id1,h1,id2,h2,cost;
		scanf("%d%d%d%d%d",&id1,&h1,&cost,&id2,&h2); id1--; h1--; id2--; h2--;
		E.push_back((edge){(vertex){id1,h1},(vertex){id2,h2},cost});
	}
	rep(i,nb-1){
		// Ã©ï¿½Â£Ã£ï¿½ï¿½Ã¥ï¿½ï¿½Ã£ï¿½ï¿½Ã¥Â¡ï¿½Ã£ï¿½Â®Ã¤Â¸ï¿½Ã©ï¿½ï¿½Ã£ï¿½Â©Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½Â¤Ã£ï¿½ÂªÃ£ï¿½ï¿½
		E.push_back((edge){(vertex){i,0},(vertex){i+1,0},1});
	}
	m=E.size();
 
	// Ã©ï¿½ï¿½Ã¨Â¦ï¿½Ã£ï¿½ÂªÃ© ï¿½Ã§ï¿½Â¹Ã£ï¿½Â®Ã£ï¿½Â¿Ã£ï¿½ï¿½Ã£ï¿½Â¿Ã£ï¿½ï¿½
	vector<int> V[100];
	rep(i,m){
		vertex u=E[i].u,v=E[i].v;
		V[u.id].push_back(u.h);
		V[v.id].push_back(v.h);
	}
	// Ã© ï¿½Ã§ï¿½Â¹Ã©ï¿½ï¿½Ã¥ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã©ï¿½ï¿½Ã¨Â¤ï¿½Ã£ï¿½ï¿½Ã©ï¿½Â¤Ã£ï¿½ï¿½Ã£ï¿½Â¦Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½Â¨Ã£ï¿½Â®Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½Â«Ã£ï¿½Â½Ã£ï¿½Â¼Ã£ï¿½ï¿½
	int n=0;
	rep(i,nb){
		sort(V[i].begin(),V[i].end());
		V[i].erase(unique(V[i].begin(),V[i].end()),V[i].end());
		n+=V[i].size();
	}
 
	map<vertex,int> f; // Ã© ï¿½Ã§ï¿½Â¹ -> Ã© ï¿½Ã§ï¿½Â¹Ã§ï¿½ÂªÃ¥ï¿½Â·
	rep(i,nb) rep(j,V[i].size()) {
		vertex v={i,V[i][j]};
		if(f.count(v)==0) f.insert(make_pair(v,f.size()));
	}
 
	// Warshall-Floyd
	static int wf[300][300];
	rep(u,n) rep(v,n) wf[u][v]=(u==v?0:INF);
	rep(i,m){
		vertex u=E[i].u,v=E[i].v;
		wf[f[u]][f[v]]=wf[f[v]][f[u]]=E[i].cost;
	}
	rep(i,nb) rep(j,(int)V[i].size()-1) {
		vertex u={i,V[i][j]},v={i,V[i][j+1]}; // Ã¥ï¿½ï¿½Ã£ï¿½ï¿½Ã¥Â¡ï¿½Ã£ï¿½Â®Ã©ï¿½Â£Ã£ï¿½ï¿½Ã¥ï¿½ï¿½Ã£ï¿½ï¿½Ã©ï¿½ï¿½Ã£ï¿½Â©Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã£ï¿½Â¤Ã£ï¿½ÂªÃ£ï¿½ï¿½
		wf[f[u]][f[v]]=wf[f[v]][f[u]]=V[i][j+1]-V[i][j];
	}
	rep(w,n) rep(u,n) rep(v,n) wf[u][v]=min(wf[u][v],wf[u][w]+wf[w][v]);
 
	// query
	int nq; scanf("%d",&nq);
	while(nq--){
		int id,h; scanf("%d%d",&id,&h); id--; h--;
 
		// u Ã£ï¿½Â«Ã¨Â¿ï¿½Ã£ï¿½ï¿½Ã©ï¿½ï¿½Ã¨Â¦ï¿½Ã£ï¿½Âª 2 Ã© ï¿½Ã§ï¿½Â¹
		int u1,u2,h1,h2;
		rep(j,V[id].size()){
			if(V[id][j]>h) break;
			h1=V[id][j];
			u1=f[(vertex){id,h1}];
		}
		rep(j,V[id].size()){
			h2=V[id][j];
			u2=f[(vertex){id,h2}];
			if(V[id][j]>=h) break;
		}
 
		int d[300]; // d[v] := Ã£ï¿½Â¯Ã£ï¿½Â¨Ã£ï¿½ÂªÃ© ï¿½Ã§ï¿½Â¹ u Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã©ï¿½ï¿½Ã¨Â¦ï¿½Ã£ï¿½ÂªÃ© ï¿½Ã§ï¿½Â¹ v Ã£ï¿½Â¸Ã£ï¿½Â®Ã¦ï¿½ï¿½Ã§ï¿½Â­Ã¨Â·ï¿½Ã©ï¿½Â¢
		rep(v,n) d[v]=min(abs(h1-h)+wf[u1][v],abs(h2-h)+wf[u2][v]);
 
		ll ans=0;
		rep(i,nb) if(i!=id) { // Ã¥Â¡ï¿½ i Ã£ï¿½Â®Ã¨Â·ï¿½Ã©ï¿½Â¢Ã£ï¿½Â®Ã¥ï¿½ï¿½
			rep(j,(int)V[i].size()-1){
				int v1=f[(vertex){i,V[i][j]}];
				int v2=f[(vertex){i,V[i][j+1]}];
				ans+=calc(V[i][j],d[v1],V[i][j+1],d[v2])-d[v2]; // Ã©ï¿½ï¿½Ã¨Â¦ï¿½Ã£ï¿½Âª 2 Ã© ï¿½Ã§ï¿½Â¹Ã©ï¿½ï¿½
			}
 
			int v=f[(vertex){i,V[i].back()}];
			ans+=sum(d[v],nf-V[i].back()); // Ã¤Â¸ï¿½Ã§ï¿½ÂªÃ©Â«ï¿½Ã£ï¿½ï¿½Ã©ï¿½ï¿½Ã¨Â¦ï¿½Ã£ï¿½ÂªÃ© ï¿½Ã§ï¿½Â¹Ã£ï¿½ï¿½Ã£ï¿½ï¿½Ã¥Â¡ï¿½Ã£ï¿½Â®Ã£ï¿½Â¦Ã£ï¿½Â£Ã£ï¿½ÂºÃ£ï¿½ï¿½Ã£ï¿½Â¾Ã£ï¿½Â§
		}
		printf("%lld\n",ans);
	}
 
	return 0;
} 