#include<map>
#include<cstdio>
#include<vector>
#include<algorithm>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef long long ll;

const int INF=1<<29;

struct vertex{
	int id,h; // 塔の番号, 階数
	bool operator<(const vertex &v)const{ return id!=v.id ? id<v.id : h<v.h; }
};

struct edge{
	vertex u,v;
	int cost;
};

// a + (a+1) + (a+2) + (a+n-1)
ll sum(ll a,ll n){ return a*n+n*(n-1)/2; }

// h1 階までの最短距離が d1, h2 階までの最短距離が d2 のときの
// h1, h1+1, ..., h2 階までの最短距離の和
ll calc(int h1,ll d1,int h2,ll d2){
	if(d1>d2) swap(d1,d2);
	ll a=sum(d1,d2-d1);
	h1+=d2-d1;
	d1=d2;
	return a+sum(d1,(h2-h1+1)/2)+sum(d2,(h2-h1+2)/2);
}

int main(){
	int nb,nf,m; scanf("%d%d%d",&nb,&nf,&m);
	vector<edge> E;
	rep(i,m){
		int id1,h1,id2,h2,cost;
		scanf("%d%d%d%d%d",&id1,&h1,&cost,&id2,&h2); id1--; h1--; id2--; h2--;
		E.push_back((edge){(vertex){id1,h1},(vertex){id2,h2},cost});
	}
	rep(i,nb-1){
		// 隣り合う塔の一階どうしをつなぐ
		E.push_back((edge){(vertex){i,0},(vertex){i+1,0},1});
	}
	m=E.size();

	// 重要な頂点のみをみる
	vector<int> V[100];
	rep(i,m){
		vertex u=E[i].u,v=E[i].v;
		V[u.id].push_back(u.h);
		V[v.id].push_back(v.h);
	}
	// 頂点集合から重複を除いて、あとのためにソート
	int n=0;
	rep(i,nb){
		sort(V[i].begin(),V[i].end());
		V[i].erase(unique(V[i].begin(),V[i].end()),V[i].end());
		n+=V[i].size();
	}

	map<vertex,int> f; // 頂点 -> 頂点番号
	rep(i,nb) rep(j,V[i].size()) {
		vertex v={i,V[i][j]};
		if(f.count(v)==0) f.insert(make_pair(v,f.size()));
	}

	// Warshall-Floyd
	static int wf[300][300];
	rep(u,n) rep(v,n) wf[u][v]=(u==v?0:INF);
	rep(i,m){
		vertex u=E[i].u,v=E[i].v;
		wf[f[u]][f[v]]=wf[f[v]][f[u]]=E[i].cost;
	}
	rep(i,nb) rep(j,(int)V[i].size()-1) {
		vertex u={i,V[i][j]},v={i,V[i][j+1]}; // 同じ塔の隣り合う階どうしをつなぐ
		wf[f[u]][f[v]]=wf[f[v]][f[u]]=V[i][j+1]-V[i][j];
	}
	rep(w,n) rep(u,n) rep(v,n) wf[u][v]=min(wf[u][v],wf[u][w]+wf[w][v]);

	// query
	int nq; scanf("%d",&nq);
	while(nq--){
		int id,h; scanf("%d%d",&id,&h); id--; h--;

		// u に近い重要な 2 頂点
		int u1,u2,h1,h2;
		rep(j,V[id].size()){
			if(V[id][j]>h) break;
			h1=V[id][j];
			u1=f[(vertex){id,h1}];
		}
		rep(j,V[id].size()){
			h2=V[id][j];
			u2=f[(vertex){id,h2}];
			if(V[id][j]>=h) break;
		}

		int d[300]; // d[v] := クエリ頂点 u から重要な頂点 v への最短距離
		rep(v,n) d[v]=min(abs(h1-h)+wf[u1][v],abs(h2-h)+wf[u2][v]);

		ll ans=0;
		rep(i,nb) if(i!=id) { // 塔 i の距離の和
			rep(j,(int)V[i].size()-1){
				int v1=f[(vertex){i,V[i][j]}];
				int v2=f[(vertex){i,V[i][j+1]}];
				ans+=calc(V[i][j],d[v1],V[i][j+1],d[v2])-d[v2]; // 重要な 2 頂点間
			}

			int v=f[(vertex){i,V[i].back()}];
			ans+=sum(d[v],nf-V[i].back()); // 一番高い重要な頂点から塔のてっぺんまで
		}
		printf("%lld\n",ans);
	}

	return 0;
}
