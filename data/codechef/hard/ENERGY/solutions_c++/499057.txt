#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>

#define	pb			push_back
#define	rep(i,n)	for(int i=0;i<(n);i++)

using namespace std;

typedef	vector<bool>	vb;
typedef	vector<int>		vi;
typedef	vector<vi>		vvi;

int hall[2][200];	// whether person is in hall

enum {IN=0,OUT=1,MALE=0,FEMALE=1};
struct Event{
	int t,id,io,sex;
	Event(){}
	Event(int T,int ID,int IO,int S):t(T),id(ID),io(IO),sex(S){}
	bool operator<(const Event &e)const{
		if(t!=e.t)	return t<e.t;
		return io<e.io;
	}
};

template<class T> struct Edge{
	int u,v;
	T w;
	Edge(){}
	Edge(int U,int V,T W):u(U),v(V),w(W){}
	bool operator<(const Edge &e)const{ return w<e.w; }
};

template<class T>
struct AdjList:public vector< vector< Edge<T> > >{
	AdjList(){}
	AdjList(int n,const vector< Edge<T> > &v=vector< Edge<T> >()):vector< vector< Edge<T> > >(n,v){}
	template<class U> AdjList(U b,U e):vector< vector< Edge<T> > >(b,e){}
};

bool dfs(int u,vb &visited,const AdjList<int> &adj,vvi &match){
	if(u==-1)	return true;
	if(!hall[0][u])	return false;

	rep(i,adj[u].size()){
		int v=adj[u][i].v;
		if(hall[1][v] && !visited[v]){
			visited[v]=true;
			if(dfs(match[1][v],visited,adj,match)){
				match[0][u]=v;
				match[1][v]=u;
				return true;
			}
		}
	}

	return false;
}

bool augment(int n,const AdjList<int> &adj,vvi &match){
	int L=adj.size();
	vb visited(n-L);
	rep(u,L)if(match[0][u]==-1){
		if(dfs(u,visited,adj,match))	return true;
	}
	return false;
}

int main(){
	int T;	scanf("%d",&T);
	while(T--){
		memset(hall,0,sizeof(hall));

		int ngirl,nboy,tend;	scanf("%d%d%d",&nboy,&ngirl,&tend);
		int n=nboy+ngirl;

		vector<Event> events;
		static bool love[2][200][200];
		memset(love,0,sizeof(love));
		rep(i,2)rep(j,i?ngirl:nboy){
			int tin,tout,m;	scanf("%d%d%d",&tin,&tout,&m);
			events.pb(Event(tin ,j,IN ,i));
			events.pb(Event(tout,j,OUT,i));
			rep(k,m){
				int partner;	scanf("%d",&partner);
				love[i][j][partner]=true;
			}
		}
		sort(events.begin(),events.end());

		AdjList<int> adj(nboy);
		rep(u,nboy)rep(v,ngirl){
			if(love[0][u][v] && love[1][v][u])	adj[u].pb(Edge<int>(u,v,1));
		}

		int ans[201]={},nmatch=0,tpre=0;
		vvi match(2,vi(max(nboy,ngirl),-1));
		rep(k,events.size()){
			Event e=events[k];
			int u=e.id,t=e.t,sex=e.sex,io=e.io;
			hall[sex][u]=(io==IN);
// printf("t=%2d: %d pair matched, id=%d (%c), %s\n",e.t,nmatch,e.id,e.sex==0?'M':'F',e.io==0?"IN":"OUT");
// rep(u,nboy) printf("match: %d x %d\n",u,match[0][u]);
// rep(u,ngirl)printf("match: %d x %d\n",match[1][u],u);
// rep(u,nboy) printf("hall: %d\n",hall[0][u]);
// rep(u,ngirl)printf("hall: %d\n",hall[1][u]);
			ans[nmatch]+=t-tpre;
			tpre=t;

			// remove a matching
			if(io==OUT && ~match[sex][u]){
				int partner=match[sex][u];
				match[sex][u]=match[!sex][partner]=-1;
				nmatch--;
			}

			if(augment(n,adj,match))	nmatch++;
		}
		ans[nmatch]+=tend-tpre;

		rep(i,min(nboy,ngirl)+1)	printf("%d%c",ans[i],i<min(nboy,ngirl)?' ':'\n');
	}

	return 0;
}
