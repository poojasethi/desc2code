#include<cstdio>
typedef long long el;
int arr[100000], valI[100001]={0}, L;
int k;
int max(int a, int b) {
	return a>b?a:b;
}
int main(void) {
	int n, Amax = -1;
	scanf("%d%d", &n, &k);
	int prevI, prevJ;
	for(int i=1;i<=n;i++) {
		scanf("%d", arr+i);
		Amax = max(arr[i], Amax);
	}
	prevI = 0;
	el total = n*(n+1ll)>>1;
	el badP = 0;
	L = 0;
	for(int j=1;j<=n;j++) {
		/*for this j get badP if exists a rightmost bad pair*/
		int Aj = arr[j];
		// printf("%d\n", Aj);
		if(valI[Aj]>prevI || (L>prevI && Aj>k)) {
			/*add the prev pair*/
			if(prevI!=0) {
				// printf("%d:%d \n", prevI, prevJ);
				badP += prevI * 1ll * (j-prevJ);
			}
			prevI = max(valI[Aj], L);
			prevJ = j;
		}
		/*for this Aj update values*/
		if(Aj==k) {
			L = j;
			continue;
		}
		else if(Aj<k)// no updates required
			continue;
		// printf("%d%d\n", Aj, k);
		Aj -= k;
		/*update all divisors of Aj*/
		/*such divisors should be >k and less than =  Amax*/

		int d1, d2;
		for(int i=1;i*i<=Aj;i++) {
			if(Aj%i==0) {
				d1 = i;
				d2 = Aj/i;
				if(d1>k && d1<=Amax)
					valI[d1] = j;
				if(d2>k && d2<=Amax)
					valI[d2] = j;
				// printf("%dff%d at %d  %d\n", valI[d1], valI[d2], j, Aj);
			}
		}
	}
	// printf("%d:%d\n", prevI, prevJ);
	if(prevI!=0) {
		// printf("%d:%d \n", prevI, prevJ);
		badP += prevI*(n+1ll-prevJ);
	}
	printf("%lld\n", total-badP);
	return 0;
}