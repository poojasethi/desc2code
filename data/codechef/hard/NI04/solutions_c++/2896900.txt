/*
  with the help of god
*/
#include <algorithm>
#include <numeric>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <iostream>
#include <iterator>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <sstream>
#include <stack>

using namespace std;

//typedef 

typedef long long ll;
typedef long double ld;
typedef unsigned int ui;
typedef unsigned long long ull;
typedef pair<int,int> pii;

//define

#define gi ({int t; scanf("%d",&t); t;})
#define gl ({ll t; scanf("%lld",&t); t;})
#define gd ({double t;scanf("%lf",&t); t;})
#define rep(i,n) for(int i=0,_n=n;i<_n;i++)
#define fr(i,a,b) for(int i=a;i<b;i++)
#define frd(i,a,b)  for(int i=b;i>=a;i--)
#define repd(i,n) for(int _n=ni=_n-1;i>=0;--i)
#define fit(i,v) for(__typeof((v).begin()) i =(v).begin(); i != (v).end(); ++i)
#define fitd(i,v) for(__typeof((v).rbegin()) i=(v).rbegin(); i!=(v).rend();++i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define ms(a,x) memset(a, x, sizeof(a))
#define sz(c) (int)(c).size()
#define dbg(x) cerr<<#x<<" = "<<(x)<<endl 
#define sqr(x) ((x)*(x))
#define mod (ll) (1e4 + 7 + eps)

//template
template <class T> T gcd(T a,T b){
  T r;
  while(b!=0){
    r=a%b;
    a=b;
    b=r;
  }
  return a;
}

int max(int a,int b){ return a>b?a:b;}
int min(int a,int b){ return a<b?a:b;}
ll modulo(ll a,ll b){ return a<b?a:a%b;}

//constants
const int inf = (int) 1e9 + 5;
const ll linf = (ll) 1e16 + 5;
const double eps = 1e-6;

//geomentry
typedef struct{
  //vector is ax,by
  double x,y;
}point,geovector;
typedef struct{
  //ax+by+c=0
  double a,b,c;
}line;
typedef struct{
  double r;
  point c;
}circle;
bool issame(double x,double y){
  return fabs(x-y) < eps-eps/100.0;
}
double dist(point p,point q){
  return sqrt(sqr(p.x-q.x) + sqr(p.y-q.y));
}

//exponentiation
ll power(ll a,ll b){
  if(b==0) return 1;
  if(b==1) return a;
  ll ret = power(a,b>>1);
  (ret *= ret)%=mod;
  if(b&1) (ret*=a)%=mod;
  return ret;
}

//inversemodulo

ll im(ll a,ll n){
  ll i=n,v=0,d=1;
  ll x;
  while(a>0){
    ll t=i/a;
    x=a;
    a=i%x;
    i=x;	
    x=d;
    d=v-t%x;
    v=x;
  }
  v%=n;
  if(v<0) v=(v+n)%n;
  return v;
}
int main(){
  int t;
  t=gi;
  while(t--){
    int p,q,m,n,k;
    p=gi;q=gi;m=gi;n=gi;k=gi;
    /*
      p-aeroplanes waiting to land
      q-aeroplanes waiting to take off
      m-rate of arraival of aeroplane 
      n-time to take off from arraival
    */
    vector <int> arr;
    int tym=0;
    int tkn=0;
    if(p!=0){ p--; arr.pb(0); }
    else if(q!=0){ tkn++; q--; }
    tym=1;
    while(tym<=k){
      int land=0;
      if(tym%m==0){
	p++;
      }
      if(p!=0){
	land=1;
	p--;
	arr.pb(tym);
      }
      int j=lower_bound(arr.begin(),arr.end(),tym-n)-arr.begin();
      fr(i,j,sz(arr)){
	if(arr[i]+n==tym){ 
	  q++;
	}
	else{
	  break;
	}
      }
      if(!land && q!=0){ q--; tkn++; }
      tym++;
    }
    rep(i,sz(arr)){
      if(arr[i]+n>k) q++;
    }
    if((k+1)%m==0) p++;
    printf("%d %d %d %d",arr.size(),tkn,p,q);
    printf("\n");
  }
  return 0;
}

