/**
* He who forgives and acknowledges himself... that is what it truly means to be strong!
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
#include <climits>
#include <iomanip>
#include <cassert>
#include <cmath>
#include <stack>
using namespace std;

#define trace(x) {cerr << #x << "=" << x <<endl;}
#define trace2(x, y) {cerr << #x << "=" << x << " " << #y << "=" << y <<endl;}
#define track(x) {cerr << #x << ":" << endl; for (int q = 0; q < x.size(); q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackarr(x, n) {cerr << #x << ":" << endl; for (int q = 0; q < n; q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;}
#define trackcr(x) {cerr << #x << ":" << endl; for (auto i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;}
template <typename Tk, typename Tv> ostream& operator<<(ostream& os, const pair<Tk, Tv> &p){os << "{" << p.first << ',' << p.second << "}";return os;}

typedef long long ll;
typedef vector<int> vi;
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef pair<int,int> ii;
typedef vector<pair<int,int> > vii;

const int MAX = 100005;
const int MOD = 1000000000+7;
const int INF = 1000000000;

struct node {
    int val, cnt[15];
    int size, pr;
    bool rev;
    node *l, *r;
    node(int val, int pr) {
        this->val = val;
        this->pr = pr;
        this->l = this->r = NULL;
        this->rev = false;
        this->size = 1;
        memset(cnt, 0, sizeof(cnt));
    }

    friend ostream& operator <<(ostream &o, node &x) {
        o << "{ x= " << &x << ", val=" << x.val << ", size=" << x.size << ", rev=" << x.rev << ", pr=" << x.pr;
        o << "l = " << x.l << " " << ", r = " << x.r << " ";
        o << " [";
        for (int i = 0; i < 15; i++) {
            o << x.cnt[i] << " ";
        }
        o << "] }";
    }
};


class Treap {
    node *root;

    int getSize(node *p) {
        if (p == NULL) return 0;
        else return p->size;
    }

    int getCnt(node *p, int i) {
        if (p == NULL) return 0;
        else return p->cnt[i];
    }

    void augment(node *p) {
        if (p==NULL) return;
        else {
            if (p->rev) {
                if (p->l) p->l->rev ^= 1;
                if (p->r) p->r->rev ^= 1;
                swap(p->l, p->r);
                p->rev=false;
            }
            p->size = getSize(p->l)+getSize(p->r)+1;
            for (int i = 0; i < 15; i++) p->cnt[i] = getCnt(p->l, i)+getCnt(p->r, i);
            p->cnt[p->val]++;
        }
    }

    node* rightRotate(node* x){
        node *y = x->l;
        node *B = y->r;

        x->l = B;
        y->r = x;

        augment(x); augment(y);
        return y;
    }

    node* leftRotate(node* x){
        node *y = x->r;
        node *B = y->l;

        x->r = B;
        y->l = x;

        augment(x); augment(y);
        return y;
    }

    node* insert(node *p, int pos, int x, int pr) {
        if (p==NULL) {
            return new node(x, pr);
        } else {
            augment(p);
            int sz = getSize(p->l);
            if (pos <= sz) {
                p->l = insert(p->l, pos, x, pr);
                augment(p);
                node* l = p->l;
                if (l->pr < p->pr) {
                    return rightRotate(p);
                }
            } else {
                p->r = insert(p->r, pos-sz-1, x, pr);
                augment(p);
                node* r = p->r;
                if (r->pr < p->pr) {
                    return leftRotate(p);
                }
            }
            return p;
        }
    }

    node* merge(node *lt, node *rt) {
        if (lt==NULL) return rt;
        else if (rt==NULL) return lt;
        else {
            if (lt->pr < rt->pr) {
                augment(lt);
                lt->r = merge(lt->r, rt);
                augment(lt);
                return lt;
            } else {
                augment(rt);
                rt->l = merge(lt, rt->l);
                augment(rt);
                return rt;
            }
        }
    }

    pair<node*, node*> split(node* p, int pos) {
        node* tmpRt = insert(p, pos, 0, -1);
        return make_pair(tmpRt->l, tmpRt->r);
    }

    void inorder(node *p, ostream &o) {
        if (p==NULL) return;
        else {
            inorder(p->l, o);
            o << *p << endl;
            inorder(p->r, o);
        }
    }

public:
    Treap(){
        srand(time(NULL));
        root=NULL;
    }

    void insert(int pos, int x) {
        root = insert(root, pos, x, rand());
    }

    void reverse(int l, int r) {
        pair<node*, node*> p = split(root, l);
        pair<node*, node*> q = split(p.second, r-l+1);
        (q.first)->rev ^= 1;
        root = merge(merge(p.first, q.first), q.second);
    }

    void get(int l, int r, int cnt[]) {
        pair<node*, node*> p = split(root, l);
        pair<node*, node*> q = split(p.second, r-l+1);
        for (int i = 0; i < 15; i++) {
            cnt[i] = (q.first)->cnt[i];
        }
        root = merge(merge(p.first, q.first), q.second);
    }

    void inorder(ostream &o) {
        inorder(root, o);
    }

    friend std::ostream& operator<<(ostream &o, Treap D) {
        D.inorder(o);
        return o;
    }

};

long long power(long long n,int m)
{
    if(m==0) return 1;
    long long x=power(n,m/2);
    if(m%2==0) return (x*x)%MOD;
    else return (((x*x)%MOD)*n)%MOD;
}

long long fact[MAX];
long long ifact[MAX];
void initfact(int n,long long fact[],long long ifact[])
{
     int i;
     fact[0]=1;
     for(i=1;i<=n;i++) {
        fact[i] = i*fact[i-1]%MOD;
     }
     ifact[n] = power(fact[n],MOD-2);
     for(i=n;i>0;i--) {
        ifact[i-1] = ifact[i]*i%MOD;
     }
}

int main() {
    initfact(100003, fact, ifact);

    int n, q;
    scanf("%d%d", &n, &q);
    char s[100005];
    scanf("%s", s);

    Treap T;
    for (int i = 0; s[i]; i++) {
        T.insert(i, s[i]-'a');
    }

    while (q--) {
        int choice;
        scanf("%d", &choice);

        int l, r;
        scanf("%d%d", &l, &r);
        l--, r--;

        if (choice==2) {
            int cnt[15];
            T.get(l, r, cnt);

            int oddCnt = 0;
            for (int i = 0; i < 15; i++) if (cnt[i] % 2 == 1) oddCnt++;
            //trackarr(cnt, 15);
            //trace(oddCnt);
            if (oddCnt > 1) {
                printf("%d\n", 0);
            } else {
                int len = r-l+1;
                ll answer = fact[len/2];
                for (int i = 0; i < 15; i++) {
                    if (cnt[i]>1) {
                        answer *= ifact[cnt[i]/2];
                        answer %= MOD;
                    }
                }
                printf("%lld\n", answer);
            }

        } else {
            T.reverse(l, r);
        }
    }
}
