#include<iostream>
#include<cstring>
#include<numeric>
#include<cassert>
using namespace std;
 
struct Node {
	Node * child[2], * parent;
	int value, size, c[10];
	bool reverse;
 
	Node() {
		size = 0;
		reverse = false;
		memset(c, 0, sizeof c);
	}
};
 
Node * root, * nil;
 
void initTree() {
	root = nil = new Node();
	nil->child[0] = nil->child[1] = nil->parent = nil;
}
 
void update(Node * x) {
	if(x == nil) return;
	x->size = x->child[0]->size + x->child[1]->size + 1;
	for(int i = 0; i < 10; ++i)
		x->c[i] = x->child[0]->c[i] + x->child[1]->c[i];
	++x->c[x->value];
}
 
void pushDown(Node * x) {
	if(x == nil) return;
	if(x->reverse) {
		swap(x->child[0], x->child[1]);
		x->reverse ^= true;
		x->child[0]->reverse ^= true;
		x->child[1]->reverse ^= true;
	}
}
 
void setLink(Node * x, Node * y, int d) {
	x->child[d] = y;
	y->parent = x;
}
 
int getDir(Node * x, Node * y) {
	return x->child[0] == y ? 0 : 1;
}
 
void rotate(Node * x, int d) {
	Node * y = x->child[d], * z = x->parent;
	setLink(x, y->child[d ^ 1], d);
	setLink(y, x, d ^ 1);
	setLink(z, y, getDir(z, x));
	update(x); update(y);
}
 
void splay(Node * x) {
	while(x->parent != nil) {
		Node * y = x->parent;
		Node * z = y->parent;
		int dy = getDir(y, x), dz = getDir(z, y);
		if(z == nil) rotate(y, dy);
		else if(dy == dz) rotate(z, dz), rotate(y, dy);
		else rotate(y, dy), rotate(z, dz);
	}
}
 
Node * nodeAt(Node * x, int pos) {
	while(pushDown(x), x->child[0]->size != pos) {
		if(pos < x->child[0]->size) x = x->child[0];
		else pos -= x->child[0]->size + 1, x = x->child[1];
	}
	return splay(x), x;
}
 
Node * join(Node * x, Node * y) {
	if(x == nil) return y;
	x = nodeAt(x, x->size - 1);
	setLink(x, y, 1);
	return update(x), x;
}
 
void split(Node * x, int left, Node * &t1, Node * &t2) {
	if(left == 0) t1 = nil, t2 = x;
	else {
		t1 = nodeAt(x, left - 1);
		t2 = t1->child[1];
		t1->child[1] = t2->parent = nil;
		update(t1);
	}
}
 
const int N = 1e5, MOD = 1e9 + 7;
int n, q, factorial[N + 1], invertFactorial[N + 1];
string s;
 
void enter() {
	cin >> n >> q >> s;
}
 
Node * buildTree(int l, int r) {
	if(l == r) return nil;
	int mid = (l + r) >> 1;
	Node * res = new Node();
	res->value = s[mid] - 'a';
	res->parent = nil;
	setLink(res, buildTree(l, mid), 0);
	setLink(res, buildTree(mid + 1, r), 1);
	return update(res), res;
}
 
int calcResult(const int c[10]) {
	int countOdd = 0;
	for(int i = 0; i < 10; ++i) countOdd += c[i] & 1;
	if(countOdd > 1) return 0;
	int res = factorial[accumulate(c, c + 10, 0) >> 1];
	for(int i = 0; i < 10; ++i)
		res = 1LL * res * invertFactorial[c[i] >> 1] % MOD;
	return res;
}
 
void solve() {
	for(int i = 0; i < q; ++i) {
		int type, l, r; cin >> type >> l >> r; --l;
		Node * t1, * t2, * t3;
		split(root, r, t1, t3);
		split(t1, l, t1, t2);
		if(type == 1) t2->reverse ^= true;
		else cout << calcResult(t2->c) << '\n';
		root = join(join(t1, t2), t3);
		assert(root->size == n);
	}
}
 
int power(int a, int n) {
	int res = 1;
	for(; n > 0; n >>= 1) {
		if((n & 1) != 0) res = 1LL * res * a % MOD;
		a = 1LL * a * a % MOD;
	}
	return res;
}
 
void init() {
	factorial[0] = 1;
	for(int i = 1; i <= n; ++i)
		factorial[i] = 1LL * factorial[i - 1] * i % MOD;
	for(int i = 0; i < n; ++i)
		invertFactorial[i] = power(factorial[i], MOD - 2);
}
 
int main() {
	ios::sync_with_stdio(false);
	enter();
	init();
	initTree();
	root = buildTree(0, n);
	solve();
	return 0;
}
