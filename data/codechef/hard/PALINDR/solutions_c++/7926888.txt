#include <bits/stdc++.h>
using namespace std;
 
const int MAXN = 112345;
const int MOD = (int)1E9+7;
long long fact[MAXN], inverse[MAXN];
 
long long fast_exp(long long base, int exp) {
    long long prod = 1LL;
    for (int i=30; i>=0; i--) {
        prod *= prod;
        prod %= MOD;
        if (exp & (1<<i)) {
            prod *= base;
            prod %= MOD;
        }
    }
    return prod;
}
 
void build_fact() {
    fact[0] = 1;
    inverse[0] = 1;
    for (int i=1; i<MAXN; i++) {
        fact[i] = (fact[i-1]*i)%MOD;
        inverse[i] = fast_exp(fact[i],MOD-2);
    }
}
 
class Treap{
 
    struct _node{
        int qtd[10], cnt, val, pri, lazy;
        _node *l, *r;
 
        _node() {}
        _node(int _val) {
            val = _val;
            lazy = 0;
            for (int i=0; i<10; i++) qtd[i] = 0;
            qtd[val] = 1;
            cnt = 1;
            pri = (rand()<<16)^rand();
            l = r = NULL;
        }
 
        void refresh() {
            cnt = 1;
            for (int i=0; i<10; i++) qtd[i] = 0;
            qtd[val] = 1;
            if (l) {
                cnt += l->cnt;
                for (int i=0; i<10; i++) qtd[i] += l->qtd[i];
            }
            if (r) {
                cnt += r->cnt;
                for (int i=0; i<10; i++) qtd[i] += r->qtd[i];
            }
        }
 
        void refresh_lazy() {
            if (!lazy) return;
            if (!r) {
                r = l;
                l = NULL;
            }
            else if (!l) {
                l = r;
                r = NULL;
            }
            else {
                _node* aux = l;
                l = r;
                r = aux;
            }
            if (l) l->lazy ^= 1;
            if (r) r->lazy ^= 1;
            lazy = 0;
        }
 
    };
 
    typedef _node* node;
 
    node root;
 
    void split(node v, int sobra, node &l, node &r) {
        l = r = NULL;
        if (!v) return;
        v->refresh_lazy();
        node esq = v->l;
        node dir = v->r;
        if ((!esq && sobra > 0) || (esq && esq->cnt < sobra)) {
            if (esq) sobra -= esq->cnt;
            sobra--;
            split(v->r,sobra,v->r,r);
            l = v;
        }
        else {
            split(v->l,sobra,l,v->l);
            r = v;
        }
        v->refresh();
    }
 
    node merge(node l, node r) {
        if (l) l->refresh_lazy();
        if (r) r->refresh_lazy();
        if (!l) return r;
        if (!r) return l;
        if (l->pri < r->pri) {
            l->r = merge(l->r,r);
            l->refresh();
            return l;
        }
        else {
            r->l = merge(l,r->l);
            r->refresh();
            return r;
        }
    }
 
    int answer[10];
 
    void do_query(node v, int ini, int fim, int x, int y) {
        if (!v || ini > y || fim < x) return;
        v->refresh_lazy();
        if (x <= ini && fim <= y) {
            for (int i=0; i<10; i++) answer[i] += v->qtd[i];
            return;
        }
        node esq = v->l;
        node dir = v->r;
        if (!dir) {
            do_query(esq,ini,fim-1,x,y);
            if (x <= fim && fim <= y) answer[v->val]++;
            return;
        }
        if (!esq) {
            do_query(dir,ini+1,fim,x,y);
            if (x <= ini && ini <= y) answer[v->val]++;
            return;
        }
        int mid = ini+(esq->cnt);
        do_query(esq,ini,mid-1,x,y);
        do_query(dir,mid+1,fim,x,y);
        if (x <= mid && mid <= y) answer[v->val]++;
    }
 
    long long eval(int l, int r) {
        int aux = 0;
        for (int i=0; i<10; i++) {
            if (answer[i]%2 == 1) aux++;
        }
        if (aux > 1) return 0;
        if (aux == 1 && (r-l+1)%2 == 0) return 0;
        int sum = 0;
        for (int i=0; i<10; i++) sum += (answer[i]/2);
        long long ans = fact[sum];
        for (int i=0; i<10; i++) ans = (ans*inverse[answer[i]/2])%MOD;
        return ans;
    }
 
public:
    Treap() { root = NULL; }
 
    int size() {
        if (!root) return 0;
        return root->cnt;
    }
 
    void insert(int x, int y) {
        node l, r;
        split(root,x-1,l,r);
        root = merge( merge(l, new _node(y)), r );
    }
 
    void reverse(int x, int y) {
        if (x > y) swap(x,y);
        node l, r, m;
        split(root,y,m,r);
        split(m,x-1,l,m);
        m->lazy = 1;
        m->refresh_lazy();
        root = merge(merge(l,m),r);
    }
 
    long long query(int x, int y) {
        if (x > y) swap(x,y);
        for (int i=0; i<10; i++) answer[i] = 0;
        do_query(root,1,size(),x,y);
        return eval(x,y);
    }
 
} treap;
 
int main() {
    build_fact();
    int N, M, x, y, op;
    char c;
    scanf("%d %d",&N,&M);
    for (int i=1; i<=N; i++) {
        scanf(" %c",&c);
        treap.insert(i,c-'a');
    }
    while (M--) {
        scanf("%d %d %d",&op,&x,&y);
        if (op == 1) treap.reverse(x,y);
        else printf("%lld\n",treap.query(x,y));
    }
    return 0;
}