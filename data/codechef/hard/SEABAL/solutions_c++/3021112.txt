#include <vector>
#include <queue>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

#define fi first
#define se second
#define mp make_pair
#define sz(x) ((int)(x).size())
#define re return
#define pb(x) push_back(x)
#define pf(x) push_front(x)
#define abs(x) ((x) < 0 ? -(x) : (x))
#define INF 2000000000
#define sqr(x) ((x) * (x))
#define all(x) x.begin(), x.end()
#define fname "a"
#define MOD 1000000007

int n, m, cur, k;
int a[111111], x, y, ll[111111], rr[111111], L, R, p[111111];
vector < pair < int, int  > > g;
int t[5111111];

int Left(int x) {
	if(ll[x] == x) re x;
	re ll[x] = Left(ll[x]);
}

int Right(int x) {
	if(rr[x] == x) re x;
	re rr[x] = Right(rr[x]);
}

void build(int v, int l, int r) {
	if(l == r) t[v] = g[l - 1].se;
	else {
		int mid = (l + r) / 2;
		build(v * 2, l, mid);
		build(v * 2 + 1, mid + 1, r);
		t[v] = min(t[v * 2], t[v * 2 + 1]);
	}
}

bool get(int v, int l, int r, int A, int B, int x)  {
	
	if(l > B || r < A) re 0;
	if(A <= l && r <= B && t[v] > x)  {
		re 0;
	}
	if(l == r) {
		
		t[v] = INF;
		re 1;	
	}
	int mid = (l + r) / 2;
	if(get(v * 2, l, mid, A, B, x)) {
		t[v] = min(t[v * 2], t[v * 2 + 1]);
		re 1;
		
	} 
	if(get(v * 2 + 1, mid + 1, r, A, B, x)) {
	 t[v] = min(t[v * 2], t[v * 2 + 1]);
	 re 1;
	}
	 re 0;
}

int main() {

	//freopen(fname".in", "r", stdin);
	//freopen(fname".out", "w", stdout);

	cin >> n >> m;

	for(int i = 1; i <= n; i++)
		cin >> a[i];
	
	for(int i = 1; i <= m; i++) {
		cin >> x >> y;
		p[x]++;
		g.pb(mp(x, y));
	}
	sort(all(g));
	build(1, 1, m);
	
	for(int i = 1; i <= n; i++)
		p[i] += p[i - 1];
	
	for(int i = 1; i <= n; i++)
		ll[i] = rr[i] = i;
	cin >> k;
	int res = 0;
	for(int i = 1; i <= k; i++) {
		cin >> x;
		a[x + res]--;
		if(!a[x + res]) {
		             
			cur = x + res;
			if(!a[cur - 1] && cur - 1 >= 1) ll[cur] = cur - 1;
			if(!a[cur + 1] && cur + 1 <= n) ll[cur + 1] = cur;
			if(!a[cur - 1] && cur - 1 >= 1) rr[cur - 1] = cur;
			if(!a[cur + 1] && cur + 1 <= n) rr[cur] = cur + 1;
			
			L = Left(cur);
			R = Right(cur);
	       
	        int lll = (L == 1 ? 1 : p[L - 1] + 1);
			while(get(1, 1, m, lll, m, R)) res++;
			
		}
	
		cout << res << endl;
		
	}
	re 0;
}








