#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <algorithm>
#include <iostream>
#include <complex>

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define all(c) (c).begin(), (c).end()
#define sz(a) int((a).size())
#define pb push_back
#define mp make_pair
#define traverse(c,it, cond) for(it = c.begin(); it != c.end() && cond; it++)
#define ll long long
#define INF 0x7FFFFFFF

int balloon[100001],res[100001],ans;
ll rangecnt[100001];

struct nod
{
	ll sum;
	int chupd;
	vi range;
}segtree[262144];

void build(int node,int beg,int end)
{
	if(beg==end)
	{
		segtree[node].sum = balloon[beg];
		return;
	}
	
	int mid = (beg+end)/2;
	build(2*node+1,beg,mid);
	build(2*node+2,mid+1,end);
	
	segtree[node].sum = segtree[2*node+1].sum + segtree[2*node+2].sum;
}

ll rangequery(int node,int beg,int end,int i,int j)
{
	if(j<beg || i>end)
		return 0;
	else if(beg>=i && end<=j)
		return segtree[node].sum;
	else
	{
		int mid = (beg+end)/2;
		ll x1 = rangequery(2*node+1,beg,mid,i,j);
		ll x2 = rangequery(2*node+2,mid+1,end,i,j);
		return x1+x2;
	}
}

void rangeupdate(int node,int beg,int end,int i,int j,int x)
{
	if(j<beg || i>end)
		return;
	else if(beg>=i && end<=j)
		segtree[node].range.pb(x);
	else
	{
		int mid = (beg+end)/2;
		rangeupdate(2*node+1,beg,mid,i,j,x);
		rangeupdate(2*node+2,mid+1,end,i,j,x);
	}
}

void pointupdate(int node,int beg,int end,int i)
{
	if(i<beg || i>end)
		return;
	else if(beg==end && beg==i)
	{
		segtree[node].sum--;
		if(segtree[node].sum == 0)
		{
			vi::iterator it;
			traverse(segtree[node].range,it,true)
			{
				rangecnt[*it]--;
				if(rangecnt[*it] == 0)
					ans++;
			}
		}
	}
	else
	{
		int mid = (beg+end)/2;
		pointupdate(2*node+1,beg,mid,i);
		pointupdate(2*node+2,mid+1,end,i);
		segtree[node].sum = segtree[2*node+1].sum + segtree[2*node+2].sum;
		segtree[node].chupd++;
		if(segtree[node].sum == 0)
		{
			vi::iterator it;
			traverse(segtree[node].range,it,true)
			{
				rangecnt[*it]-=segtree[node].chupd;
				if(rangecnt[*it] == 0)
					ans++;
			}
		}
	}
}

int main()
{
	int n,m,i,l,r,k,x,y;
	scanf("%d%d",&n,&m);
	for(i=0;i<n;i++)
		scanf("%d",&balloon[i]);
	build(0,0,n-1);
	for(i=0;i<m;i++)
	{
		scanf("%d%d",&l,&r);
		rangecnt[i] = rangequery(0,0,n-1,l-1,r-1);
		rangeupdate(0,0,n-1,l-1,r-1,i);
//		printf("%d\n",rangecnt[i]);
	}
	scanf("%d",&k);
	for(i=0;i<k;i++)
	{
		scanf("%d",&x);
		if(i>0)
			y = x + res[i-1];
		else
			y = x;
		ans = 0;
		pointupdate(0,0,n-1,y-1);
		if(i>0)
			res[i] = res[i-1]+ans;
		else
			res[i] = ans;
		printf("%d\n",res[i]);
	}
	return 0;
}
