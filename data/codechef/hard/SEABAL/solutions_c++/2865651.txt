#include <iostream>
#include <algorithm>
#include <vector>
#include <stdio.h>
using namespace std;
const int maxn = 5e5;
#define oo 10000000
typedef long long ll;

int n,m,k;
int bal[maxn];
int xi[maxn];
int ans[maxn];

ll abi[maxn];

struct inter
{
	int ini,fin,pos;

	inter(int i, int f)
	{
		ini = i;
		fin = f;
	}
	inter()
	{

	}

	bool operator < (const inter& a)const
	{
		if(ini != a.ini)return ini < a.ini;
		return fin < a.fin;
	}

};

vector<inter>lista;

struct node
{
	int pos;

	void merge(node a, node b)
	{
		if(lista[a.pos].fin <= lista[b.pos].fin)
			pos = a.pos;
		else
			pos = b.pos;
	}

}tree[maxn];

void init(int root, int l, int r)
{
	if(l == r)
	{
		tree[root].pos = l;
		return;
	}
	int m = (l + r) >> 1;
	int lc = root << 1;
	int rc = lc|1;

	init(lc,l,m);
	init(rc, m + 1,r);
	tree[root].merge(tree[lc],tree[rc]);
}

void elimina(int root, int l, int r, int pos)
{
	if(l == r && pos == l)
	{
		lista[pos].fin = oo;
		return;
	}
	int m = (l + r) >> 1;
	int lc = root << 1;
	int rc = lc|1;

	if(pos <= m)
		elimina(lc,l,m,pos);
	else
		elimina(rc, m + 1,r,pos);

	tree[root].merge(tree[lc],tree[rc]);
}

node stquery(int root, int l, int r, int i, int j)
{
	if(l == i && r == j)
		return tree[root];

	int m = (l + r) >> 1;
	int lc = root << 1;
	int rc = lc|1;

	if(j <= m)
		return stquery(lc,l,m,i,j);
	else if(i > m)
		return stquery(rc, m + 1,r,i,j);
	else
	{
		node a = stquery(lc,l,m,i,m);
		node b = stquery(rc,m + 1,r, m + 1,j);
		node res = node();
		res.merge(a,b);
		return res;
	}
}

void update(int pos, ll v)
{
	while(pos <= n)
	{
		abi[pos] += v;
		pos += (pos&(-pos));
	}
}

ll query(int pos)
{
	if(pos <= 0)return 0;
	ll res = 0;
	while(pos)
	{
		res += abi[pos];
		pos -= (pos&-pos);
	}
	return res;
}

int lower ( int pos)
{
	int low = 0;
	int high = pos;
	int val = query(pos);
	while ( low <= high )
	{
		int mid = ( low + high ) / 2;
		if (query( mid ) >= val ) {
			high = mid - 1;
		}
		else low = mid + 1;
	}
	//low points to the index with value equal to val. So return low + 1
	return low + 1;
}

int upper (int pos)
{
	int val = query(pos);
	int low = pos;
	int high = n;

	while ( low <= high ) 
	{
		int mid = ( low + high ) / 2;
		if ( query( mid ) <= val ) {
			low = mid + 1;
		}
		else high = mid - 1;
	}
	//low points to the index with value greater than val. So return low - 1
	return low - 1;
}

int solve(int p)
{
	int cur = xi[p] + ans[p - 1];
	//int cur = xi[p];
	if(bal[cur] == 0)return ans[p - 1];

	bal[cur]--;
	update(cur,-1);

	//update(cur,1);

	if(bal[cur] > 0)return ans[p - 1];

	int l = lower(cur);
	int r = upper(cur);
	int pos = lower_bound(lista.begin(),lista.end(),inter(l,-1)) - lista.begin();

	int total = ans[p - 1];
	if(pos == lista.size())return total;

	node res = stquery(1,0,m - 1,pos, m - 1);

	while(lista[res.pos].fin <= r)
	{
		total++;
		elimina(1,0, m - 1,res.pos);
		res = stquery(1,0,m - 1,pos, m - 1);
	}
	//cout << total << endl;
	return total;
}

int main()
{
	scanf("%d %d",&n,&m);
	//fill(bal + 1,bal + maxn,1 << 28);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d",&bal[i]);
		update(i,bal[i]);
	}

	int a,b;
	for(int i = 0; i < m; i++)
	{
		scanf("%d %d",&a,&b);
		lista.push_back(inter(a,b));
	}

	sort(lista.begin(),lista.end());

	for(int i = 0; i < m; i++)
		lista[i].pos = i;

	init(1,0, m - 1);
	scanf("%d",&k);

	for(int i = 1; i <= k; i++)
	{
		scanf("%d",&xi[i]);
		ans[i] = solve(i);
	}
	//cout << "-------" << endl;
	for(int i = 1; i <= k; i++)
		printf("%d\n", ans[i]);
	return 0;
}
