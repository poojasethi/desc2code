#include <iostream>
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
#define INF 100001
#define LEFT(n) 2*(n)
#define RIGH(n) 2*(n)+1

#ifdef EBUG
    #define PRINT(x) cout << #x": " << (x) << endl;
#else
    #define PRINT(x) 
#endif
using namespace std;
typedef pair<int, int> pii;
struct box{
    int balloons, index;
    box *prev, *next;
};

void init_rmq(vector<pii> &rmq, vector<pii> &contents, int pos, int from, int to){
    if (from == to-2){
        if (contents[from].second < contents[from+1].second){
            rmq[pos] = make_pair(contents[from].second, from);        
        }
        else{
            rmq[pos] = make_pair(contents[from+1].second, from+1);
        }
        return;
    }else{
        init_rmq(rmq, contents, LEFT(pos), from, (from+to)/2);
        init_rmq(rmq, contents, RIGH(pos), (from+to)/2, to);
        rmq[pos] = min(rmq[LEFT(pos)], rmq[RIGH(pos)]);
    }
}

pii query_rmq (vector<pii> &rmq, vector<pii> &contents, int pos, int from, int to, int s, int e){
    /*PRINT(from);
    PRINT(to);
    PRINT(s);
    PRINT(e);*/
    if (e <= from || to <= s){
        return make_pair(INF,INF);
    }
    if (from >= s && to <= e){
        if (from == to-1){
            return make_pair(contents[from].second, from);
        }
        return rmq[pos];
    }
    return min(query_rmq(rmq, contents, LEFT(pos), from, (from+to)/2, s,e),
               query_rmq(rmq, contents, RIGH(pos), (from+to)/2, to, s,e));
}

void update_rmq(vector<pii> &rmq, vector<pii> &contents, int pos, int from, int to, int key, int val){
    if (from == to-1){
        contents[from].second = val;
        return;
    }
    if (from == to-2){
        if (key == from){
            update_rmq(rmq,contents,0, from, from+1, key, val);
        }else{
            update_rmq(rmq,contents,0, from+1, to, key, val);
        }
        if (contents[from].second < contents[from+1].second){
            rmq[pos] = make_pair(contents[from].second, from);        
        }
        else{
            rmq[pos] = make_pair(contents[from+1].second, from+1);
        }
        return;
    }
    if (key < (from+to)/2){
        update_rmq(rmq, contents, LEFT(pos), from, (from+to)/2, key, val);
    }else{
        update_rmq(rmq, contents, RIGH(pos), (from+to)/2, to, key, val);
    }
    rmq[pos] = min(rmq[LEFT(pos)], rmq[RIGH(pos)]);
}

int main(){
    int n, m;
    cin >> n >> m;
    box boxes[n+2];
    boxes[0].index = 0;
    boxes[0].next = &boxes[1];
    boxes[n+1].prev = &boxes[n];
    boxes[n+1].index = n+1;
    for (int i = 1; i <= n; i++){
        boxes[i].index = i;
        boxes[i].prev = &boxes[i-1];
        boxes[i].next = &boxes[i+1];
        scanf("%d", &boxes[i].balloons);
    }
    int rmq_size = 1;
    while(1<<rmq_size++ < m);
    rmq_size = 1 << rmq_size;
    vector<pii> intervals(rmq_size, make_pair(INF,INF));
    for (int i = 0; i < m; i++){
        scanf("%d%d", &intervals[i].first, &intervals[i].second);
    }
    sort(intervals.begin(), intervals.end());
    vector<pii> rmq(rmq_size);
    init_rmq(rmq, intervals, 1, 0, rmq_size);
    int ans = 0;
    int k;
    cin >> k;
    while (k--){
        int burst;
        scanf("%d", &burst);
        burst+=ans;
        if (!--boxes[burst].balloons){
            boxes[burst].prev->next = boxes[burst].next;
            boxes[burst].next->prev = boxes[burst].prev;
            int up_to = boxes[burst].prev->next->index;
            pii result;
            int from = upper_bound(intervals.begin(), intervals.end(), make_pair(boxes[burst].prev->index+1, 0))- intervals.begin();
            PRINT(from);
            PRINT(up_to);
            PRINT(boxes[burst].prev->index+1);
            int to = intervals.size();
            while ((result = query_rmq(rmq,intervals,1,0,rmq_size, from, to)).first < up_to){
                ans++;
                PRINT(result.first);
                PRINT(result.second);
                update_rmq(rmq,intervals, 1, 0,rmq_size, result.second, INF);
                PRINT("DESPUES DEL UPD");
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}