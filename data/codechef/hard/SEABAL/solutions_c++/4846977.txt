#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++)
#define rep(i, n) FOR(i, 0, n)
#define CL(a, v) memset((a), (v), sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int, int> pii;

/*** TEMPLATE CODE ENDS HERE */

#define MAXN 100000

typedef long long ptype;

ptype seed = 47;

ptype my_rand() {
  seed = (seed * 279470273) % 4294967291LL;
  return seed;
}

struct item {
  int key;
  ptype prior;
  item* l, *r;
  int cont;

  item() {}

  item(int key) : key(key), l(NULL), r(NULL), cont(1) { prior = my_rand(); }
};

#include <iostream>

void update_cont(item*& t) {
  if (t) t->cont = 1 + (t->l ? t->l->cont : 0) + (t->r ? t->r->cont : 0);
}

void split(item* t, int key, item*& l, item*& r) {
  if (!t)
    l = r = NULL;
  else {
    if (key < t->key)
      split(t->l, key, l, t->l), r = t;
    else
      split(t->r, key, t->r, r), l = t;
    update_cont(t);
  }
}

void insert(item*& t, item* it) {
  if (!t)
    t = it;
  else {
    if (it->prior > t->prior)
      split(t, it->key, it->l, it->r), t = it;
    else
      insert(it->key < t->key ? t->l : t->r, it);
    update_cont(t);
  }
}

void merge(item*& t, item* l, item* r) {
  if (!l || !r)
    t = l ? l : r;
  else if (l->prior > r->prior)
    merge(l->r, l->r, r), t = l;
  else
    merge(r->l, l, r->l), t = r;
  update_cont(t);
}

int n, m, a[MAXN];
item* t[MAXN], *aux;
int p[MAXN], s[MAXN], e[MAXN], sz[MAXN];

int Find(int x) {
  if (x != p[x]) return p[x] = Find(p[x]);
  return x;
}

int solve(int x) {
  int ret = 0;
  aux = t[x];

  while (aux) {
    if (aux->key <= e[x]) {
      ret += 1 + (aux->l ? aux->l->cont : 0);
      aux = aux->r;
    } else
      aux = aux->l;
  }

  return ret;
}

int b[MAXN], nb;

void write_to_b(item*& t) {
  if (t) {
    b[nb++] = t->key;
    write_to_b(t->l);
    write_to_b(t->r);
  }
}

int Union(int x, int y) {
  x = Find(x);
  y = Find(y);
  int ret = -solve(x) - solve(y);
  nb = 0;

  if (sz[y] > sz[x]) {
    write_to_b(t[x]);

    for (int i = 0; i < nb; ++i) {
      if (b[i] != -1) {
        insert(t[y], new item(b[i]));
        ++sz[y];
      }
    }

    p[x] = y;
    s[y] = min(s[x], s[y]);
    e[y] = max(e[x], e[y]);
    ret += solve(y);
  } else {
    write_to_b(t[y]);

    for (int i = 0; i < nb; ++i) {
      if (b[i] != -1) {
        insert(t[x], new item(b[i]));
        ++sz[x];
      }
    }

    p[y] = x;
    s[x] = min(s[x], s[y]);
    e[x] = max(e[x], e[y]);
    ret += solve(x);
  }

  return ret;
}

int main() {
  scanf("%d %d", &n, &m);

  for (int i = 0; i < n; ++i) {
    scanf("%d", &a[i]);
    p[i] = i;
    s[i] = i;
    e[i] = i;
  }

  for (int i = 0, l, r; i < m; ++i) {
    scanf("%d %d", &l, &r);
    --l;
    --r;
    insert(t[l], new item(r));
    ++sz[l];
  }

  int Q, x, ans = 0;

  scanf("%d", &Q);

  while (Q--) {
    scanf("%d", &x);
    x += ans - 1;
    --a[x];

    if (a[x] == 0) {
      ans += solve(x);
      if (x > 0 && a[x - 1] == 0) ans += Union(x - 1, x);
      if (x + 1 < n && a[x + 1] == 0) ans += Union(x, x + 1);
    }

    printf("%d\n", ans);
  }

  return 0;
}