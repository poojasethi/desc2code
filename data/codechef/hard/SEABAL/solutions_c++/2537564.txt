#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>

using namespace std;

#define pb push_back
#define mp make_pair

#define ALL(x) (x).begin(),(x).end()
#define CLR(a,b) memset(a,b,sizeof(a))
#define REPN(x,a,b) for (int x=a; x<b;++x)
#define REP(x,b) REPN(x, 0, b)

#define dbg(x) cout << #x << " = " << x << endl;
#define dbg2(x, y) cout << #x << " = " << x << "  " << #y << " = " << y << endl;
#define dbg3(x, y, z) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << endl;
#define dbg4(x, y, z, w) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << "  " << #w << " = " << w <<  endl;

#define F first
#define S second

#define Left(x) (2*x)
#define Right(x) (Left(x) + 1)

const int MAX = 100010;
typedef pair <int, int> pii;

int T[MAX*4]; //0 valor, 1 id
int A[MAX], C[MAX], L[MAX], R[MAX];

int n, m, ans;
pii  V[MAX];

void build_tree(int node, int le, int ri) {
    if (le == ri) {
        T[node] = V[le].second;
        return ;
    }
    int mid = (le + ri) >> 1;
    build_tree(Left(node), le, mid);
    build_tree(Right(node), mid+1, ri);
    
    T[node] = min(T[Left(node)], T[Right(node)]);
}

int query(int ql, int qr, int maxi, int node = 1, int le = 0, int ri = m-1) {
    if (qr < le || ql > ri) return 0;
    if (le >= ql && ri <= qr && maxi < T[node]) return 0;

    if (le == ri) {
        T[node] = 1000000000;
        return 1;
    }

    int mid = (le + ri) >> 1;

    if (query(ql, qr, maxi, Left(node), le, mid)) {
        T[node] = min(T[Left(node)], T[Right(node)]);
        return 1;
    }

    if (query(ql, qr, maxi, Right(node), mid+1, ri)) {
        T[node] = min(T[Left(node)], T[Right(node)]);
        return 1;
    }
    return 0;
}

void update(int u) {
    if (L[u] >= 0) R[L[u]] = R[u];
    if (R[u] < n) L[R[u]] = L[u];

    
    int le = L[u]+1, ri = R[u]-1;
    
    int ql = le == 0 ? 0 : C[le-1];
    int qr = C[ri]-1;
    
    if (ql <= qr)
        while (query(ql, qr, ri)) ans++;
}

int main() {
    int u, v, nro;
    scanf("%d %d", &n, &m);
    REP(i, n) {
        scanf("%d", &A[i]);
    }

    CLR(C, 0);

    REP(i, m) {
        scanf("%d %d", &u, &v);
        u--;
        v--;
        V[i] = mp(u, v);
        C[u]++;
    }

    sort(V, V+m);

    REP(i, n) {
        L[i] = i-1; R[i] = i+1;
        C[i] += C[i-1];
    }


    ans = 0;

    REP(i, n) if (!A[i]) update(i);

    build_tree(1, 0, m-1);


    scanf("%d", &nro);

    REP(i, nro) {
        scanf("%d", &u);
        u--;
        u += ans;
        A[u]--;
        if (A[u]) {
            printf("%d\n", ans);
            continue;
        }
        update(u);
        printf("%d\n", ans);
    }

    return 0;
}
