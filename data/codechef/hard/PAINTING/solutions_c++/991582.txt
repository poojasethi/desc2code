#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <cmath>

using namespace std;

typedef long long ll;

#define MAXN 2002
#define x1 yasdasdasdasd
#define y1 xasdasdasdasd
#define yn ynsdasdasdasd
#define MP make_pair
#define F first
#define S second

char dc[4] = {'U', 'R', 'D', 'L'};
int dx[4] = { 0, 1, 0,-1};
int dy[4] = { 1, 0,-1, 0};

struct Move
{
	int dist, dir;
};

int n;
Move a[MAXN];

int xn, yn;
ll x[MAXN];
ll y[MAXN];
bool mark[MAXN][MAXN][5];

inline int getIndex(int *a, int n, int b)
{
	return lower_bound(a, a + n, b) - a;
}

int main()
{
	scanf("%d\n", &n);

	x[xn++] = 0;
	y[yn++] = 0;

	for (ll i = 0, cx = 0, cy = 0; i < n; ++i)
	{
		char c;
		int dist;
		scanf("%c %d\n", &c, &dist);

		a[i].dir = strchr(dc, c) - dc;
		a[i].dist = dist;
		ll nx = cx + dx[a[i].dir] * a[i].dist;
		ll ny = cy + dy[a[i].dir] * a[i].dist;

		x[xn++] = nx;
		y[yn++] = ny;

		cx = nx;
		cy = ny;
	}

	sort(x, x + xn);
	sort(y, y + yn);

	xn = unique(x, x + xn) - x;
	yn = unique(y, y + yn) - y;

	int cx = lower_bound(x, x + xn, 0) - x;
	int cy = lower_bound(y, y + yn, 0) - y;

	mark[cx][cy][4] = 1;
	      
	for (int i = 0; i < n; ++i)
	{
		ll ans = 0;
		for (int cdist = 0; cdist < a[i].dist; )
		{
			int nx = cx + dx[a[i].dir];
			int ny = cy + dy[a[i].dir];
			cdist += (abs(x[nx] - x[cx]) + abs(y[ny] - y[cy]));
			if (!mark[cx][cy][a[i].dir]) ans += (1LL * abs(x[nx] - x[cx]) + 1LL * abs(y[ny] - y[cy]) - 1);
			if (!mark[nx][ny][4]) ++ans;
			mark[cx][cy][a[i].dir] = mark[nx][ny][a[i].dir ^ 2] = mark[nx][ny][4] = 1;
			cx = nx;
			cy = ny;
		}
		cout << ans << endl;
	}

	return 0;
}
