
#include<iostream>
#include<sstream>
#include<cstdio>
#include<memory.h>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<string>
#include<map>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<assert.h>
#include<set>
#include<deque>
#include<climits>
#include<utility>

using namespace std;

#define SI ({int _x; scanf("%d",&_x); _x;})
#define SLL ({long long _x; scanf("%lld",&_x); _x;})
#define SLF ({double _x; scanf("%lld",&_x); _x;})
#define SC ({char _x; scanf("%c",&_x); _x;})
#define sscan(n) scanf("%s",n)
#define lc(i) (i<<1)
#define rc(i) ((i<<1)+1)
#define MP make_pair
#define PB push_back
#define LL long long
#define FILL(a,x) memset(a,x,sizeof a)
#define REP(i,n) for(int i=0;i<(n);++i)
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define FORD(i,a,b) for(int i=(b)-1;i>=(a);--i)
#define REPD(i,b) for(int i=(b)-1;i>=0;--i)
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)>(b)?(b):(a))
#define ABS(a) ((a)<0?-(a):(a))

typedef vector<int> VI; 
typedef pair<int,int> PI; 
#define SZ(a) int((a).size()) 
#define ALL(c) (c).begin(),(c).end() 
#define SORT(a) sort(ALL(a))
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) 
#define present(c,x) ((c).find(x) != (c).end()) 
#define dbg(x) cout<<#x<<" = "<<x<<endl
#define RAND(x) ((int)(((rand()*1.0)/RAND_MAX)*(x)))

struct hseg { LL x1, x2,y; };
struct vseg { LL y1, y2,x; };

vector <vseg> v;
vector <hseg> h;

//map <int,vector <vseg> > v;
//map <int,vector <hseg> > h;

LL hinter(vseg s)
{
	int sz = SZ(h);
	LL ret = 0;
	REP(i,sz)
	{
		if(h[i].y <= s.y2 && h[i].y >= s.y1 && s.x >= h[i].x1 && s.x <= h[i].x2) ++ret;
	}
	return ret;
}

LL vinter(hseg s)
{
	int sz = SZ(v);
	LL ret = 0;
	REP(i,sz)
	{
		if(v[i].x <= s.x2 && v[i].x >= s.x1 && s.y >= v[i].y1 && s.y <= v[i].y2) ++ret;
	}
	return ret;
}

LL updateh(hseg s)
{
//	printf("updateh for (%lld,%lld) to (%lld,%lld)\n",s.x1,s.y,s.x2,s.y);
	LL ret = llabs(s.x2 - s.x1) + 1;

//	REP(i,SZ(h))  printf("(%lld,%lld) to (%lld,%lld)\n",h[i].x1,h[i].y,h[i].x2,h[i].y);

	for(int i = 0; i<SZ(h);)
	{
		if(h[i].y != s.y) { ++i; continue; }
		if(s.x1 >= h[i].x1 && s.x2 <= h[i].x2) return 0;
		if(h[i].x1 >= s.x1 && h[i].x2 <= s.x2)
		{
			ret -= (h[i].x2 - h[i].x1 + 1);
			ret += vinter(h[i]);
			h.erase(h.begin() + i);
		}
		else if(h[i].x1 >= s.x1 && h[i].x1 <= s.x2)
		{
			ret -= (s.x2 - h[i].x1 + 1);
			/*
			hseg vs;
			vs.y = s.y;
			vs.x1 = h[i].x1;
			vs.x2 = s.x2;
			*/
			ret += vinter(h[i]);
			s.x2 = h[i].x2;
			h.erase(h.begin() + i);
		}
		else if(h[i].x2 >= s.x1 && h[i].x2 <= s.x2)
		{
			ret -= (h[i].x2 - s.x1 + 1);
			/*
			hseg vs;
			vs.y = s.y;
			vs.x1 = s.x1;
			vs.x2 = h[i].x2;
			*/
			ret += vinter(h[i]);
			s.x1 = h[i].x1;
			h.erase(h.begin() + i);
		}
		else ++i;
	}
	ret -= vinter(s);
	h.PB(s);
	return ret;
}

LL updatev(vseg s)
{
//	printf("updatev for (%lld,%lld) to (%lld,%lld)\n",s.x,s.y1,s.x,s.y2);

	LL ret = llabs(s.y2 - s.y1) + 1;
//	dbg(ret);

	for(int i = 0; i<SZ(v);)
	{
	//	printf("v[i] = (%lld,%lld) to (%lld,%lld)\n",v[i].x,v[i].y1,v[i].x,v[i].y2);
		if(v[i].x != s.x) { ++i; continue; }
		if(s.y1 >= v[i].y1 && s.y2 <= v[i].y2) return 0;
		if(v[i].y1 >= s.y1 && v[i].y2 <= s.y2)
		{
			ret -= (v[i].y2 - v[i].y1 + 1);
			ret += hinter(v[i]);
			v.erase(v.begin() + i);
		}
		else if(v[i].y1 >= s.y1 && v[i].y1 <= s.y2)
		{
			ret -= (s.y2 - v[i].y1 + 1);
			/*
			vseg vs;
			vs.x = s.x;
			vs.y1 = v[i].y1;
			vs.y2 = s.y2;
			*/
			ret += hinter(v[i]);
			s.y2 = v[i].y2;
			v.erase(v.begin() + i);
		}
		else if(v[i].y2 >= s.y1 && v[i].y2 <= s.y2)
		{
			ret -= (v[i].y2 - s.y1 + 1);
			/*
			vseg vs;
			vs.x = s.x;
			vs.y1 = s.y1;
			vs.y2 = v[i].y2;
			*/
			ret += hinter(v[i]);
			s.y1 = v[i].y1;
			v.erase(v.begin() + i);
		}
		else ++i;
	//	dbg(ret);
	}
	ret -= hinter(s);
//	dbg(ret);
	v.PB(s);
	return ret;
}

int main()
{
	int n;
	scanf("%d\n",&n);
	LL x = 0, y = 0;
	hseg h0;
	h0.y = 0; h0.x1 = h0.x2 = 0;
	vseg v0;
	v0.x = v0.y1 = v0.y2 = 0;
	h.PB(h0); v.PB(v0);
	while(n--)
	{
		char dir;
		LL dis;
		scanf("%c %lld\n",&dir,&dis);
	//	dbg(dir); dbg(dis);
		if(dir == 'U')
		{
			vseg s;
			s.x = x;
			s.y1 = y+1;
			s.y2 = y+dis;
			printf("%lld\n",updatev(s));
			y += dis;
		}
		else if(dir == 'D')
		{
			vseg s;
			s.x = x;
			s.y1 = y-dis;
			s.y2 = y-1;
			printf("%lld\n",updatev(s));
			y -= dis;
		}
		else if(dir == 'L')
		{
			hseg s;
			s.y = y;
			s.x1 = x-dis;
			s.x2 = x-1;
			printf("%lld\n",updateh(s));
			x -= dis;
		}
		else if(dir == 'R')
		{
			hseg s;
			s.y = y;
			s.x1 = x+1;
			s.x2 = x+dis;
			printf("%lld\n",updateh(s));
			x += dis;
		}
	}
	return 0;
}
