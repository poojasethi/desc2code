//Author: Aman Choudhary
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <cmath>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <map>
#include <cassert>
#define mod  1000000007
#define PHI 1000000006
#define ull unsigned long long
#define ll long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define S1(x) scanf("%llu",&x)
#define MAX 50009
#define NIL 0
#define INF (1<<28)

#define MAXNODES 50009
using namespace std;

int dx[]={1,-1,0,0};
int dy[]={0,0,1,-1};
ll startx[1002];
ll endx[1002];
ll starty[1002];
ll endy[1002];
void intersect(ll sx1,ll sy1,ll ex1,ll ey1,ll sx2,ll sy2,ll ex2,ll ey2, vector<pair<ll,ll> >* segments)
{
    if(sx2==ex2)
    {
        if(sx1!=sx2)
            return;
        ll sy3=max(min(sy1,ey1),min(sy2,ey2));
        ll ey3=min(max(sy1,ey1),max(sy2,ey2));
        if(sy3>ey3)
            return;
        segments->push_back(make_pair(sy3,ey3));
        return;
    }
    if(sy2==ey2)
    {
        if(sy2>=min(sy1,ey1) && sy2<=max(sy1,ey1) && min(sx2,ex2)<=sx1 && max(sx2,ex2)>=sx1)
            segments->push_back(make_pair(sy2,sy2));
        return;
    }
}
map<pair<int,int>,bool> hashed;
int main()
{
    int N;
    scanf("%d",&N);
    ll cx=0;
    ll cy=0;
    ll answer=0;
    startx[0]=endx[0]=starty[0]=endy[0]=0;
    for(int i=1;i<=N;i++)
    {
        char dir[3];
        ll steps;
        int id;
       scanf("%s",&dir);
       scanf("%lld",&steps);
        if(dir[0]=='R')
            id=0;
        if(dir[0]=='L')
            id=1;
        if(dir[0]=='U')
            id=2;
        if(dir[0]=='D')
            id=3;
        startx[i]=cx+dx[id];
        starty[i]=cy+dy[id];
        endx[i]=cx+dx[id]*steps;
        endy[i]=cy+dy[id]*steps;

        cx=endx[i];
        cy=endy[i];
        vector<pair<ll,ll> > segments;
        for(int j=0;j<i;j++)
        {
            if(startx[i]==endx[i])
                intersect(startx[i],starty[i],endx[i],endy[i],startx[j],starty[j],endx[j],endy[j],&segments);
            else
                intersect(starty[i],startx[i],endy[i],endx[i],starty[j],startx[j],endy[j],endx[j],&segments);
        }
        sort(segments.begin(),segments.end());
        ll st=(startx[i]==endx[i]?min(starty[i],endy[i]):min(startx[i],endx[i]));
        ll en=(startx[i]==endx[i]?max(starty[i],endy[i]):max(startx[i],endx[i]));
        ll currocc=en-st+1;
        for(int j=0;j<segments.size();j++)
        {
            currocc-=max(0ll,(segments[j].second-max(st,segments[j].first))+1);
            st=max(st,segments[j].second+1);
        }
        answer+=currocc;
        printf("%lld\n",currocc);
    }
}
