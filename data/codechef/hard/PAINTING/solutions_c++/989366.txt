#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<set>
#include<map>
using namespace std;

#define LIM (1<<10)
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define LL long long
#define PLL pair<LL,LL>
#define TLL pair<LL,PLL>
#define INF ((1LL)<<50)

LL dx[4]={0,0,1,-1};
LL dy[4]={1,-1,0,0};
int N,dir;
LL counter;
char ip[5];
LL dist;
LL cx,cy;

set<TLL> X,Y;
set<TLL>::iterator it,jt,itx,ity;

LL countX(LL y,LL s,LL e)
{
    //printf("countX : y=%lld s=%lld e=%lld\n",y,s,e);
    itx=X.lower_bound(MP(y,MP(-INF,-INF)));
    if(itx==X.end() || (*itx).F>y){
        //printf("special %lld\n",e-s+1);
        return e-s+1;
    }
    LL ret=0;
    while((*itx).F==y){
       LL cl=(*itx).S.F;
       LL cr=(*itx).S.S;
       //printf("cl=%lld cr=%lld s=%lld e=%lld\n",cl,cr,s,e);
       if(cl<s) cl=s;
       if(cr>e) cr=e;
       if(cl<=cr){
           ret+=cl-s;
           s=cr+1;
           if(s>e) break;
       }
       itx++;
    }
    if(s<=e){
        ret += e-s+1;
    }
    //printf("returning %lld\n",ret);
    return ret;
}

LL countY(LL x,LL s,LL e)
{
    //printf("countY : x=%lld s=%lld e=%lld\n",x,s,e);
    ity=Y.lower_bound(MP(x,MP(-INF,-INF)));
    if(ity==Y.end() || (*ity).F>x){
        //printf("special %lld\n",e-s+1);
        return e-s+1;
    }
    LL ret=0;
    while((*ity).F==x){
       LL cl=(*ity).S.F;
       LL cr=(*ity).S.S;
       //printf("cl=%lld cr=%lld s=%lld e=%lld\n",cl,cr,s,e);
       if(cl<s) cl=s;
       if(cr>e) cr=e;
       if(cl<=cr){
           ret+=cl-s;
           s=cr+1;
           if(s>e) break;
       }
       ity++;
    }
    if(s<=e){
        ret += e-s+1;
    }
    //printf("returning %lld\n",ret);
    return ret;
}

int main()
{
    scanf("%d",&N);
    cx=cy=0;
    X.insert(MP(0,MP(0,0)));
    Y.insert(MP(0,MP(0,0)));
    while(N--){
        scanf("%s%lld",ip,&dist);
        if(ip[0]=='U') dir=0;
        else if(ip[0]=='D') dir=1;
        else if(ip[0]=='R') dir=2;
        else if(ip[0]=='L') dir=3;
        LL nx=cx+dist*dx[dir];
        LL ny=cy+dist*dy[dir];
        //printf("dir = %d dist = %lld\n",dir,dist);
        counter=0;
        if(nx==cx){
            LL mx=cx;
            LL sy,ey;
            if(dir==0){
                sy=cy+1;
                ey=ny;
            }
            else{
                sy=ny;
                ey=cy-1;
            }
            //printf("mx=%lld sy=%lld ey=%lld\n",mx,sy,ey);
            itx=X.lower_bound(MP(sy,MP(-INF,-INF)));
            //printf("itx : %lld %lld %lld \n",(*itx).F,(*itx).S.F,(*itx).S.S);

            //printf("size : %d\n",itx-X.begin());
            for(;itx!=X.end();itx++){
                if((*itx).F<sy) continue;
                if((*itx).F>ey){
                    counter += countY(mx,sy,ey);
                    Y.insert(MP(mx,MP(sy,ey)));
                    if(sy==ey){
                        X.insert(MP(sy,MP(mx,mx)));
                    }
                    break;
                }
                else{
                    if((*itx).S.F<=mx && mx<=(*itx).S.S){
                        if(sy==(*itx).F){
                            sy++;
                            if(sy>ey) break;
                        }
                        else{
                            counter += countY(mx,sy,(*itx).F-1);
                            Y.insert(MP(mx,MP(sy,(*itx).F-1)));
                            if(sy==(*itx).F-1){
                                X.insert(MP(sy,MP(mx,mx)));
                            }
                            sy=(*itx).F+1;
                            if(sy>ey) break;
                        }
                    }
                }
            }
            if(itx==X.end() || (*itx).F>ey){
                counter += countY(mx,sy,ey);
                Y.insert(MP(mx,MP(sy,ey)));
                if(sy==ey){
                    X.insert(MP(sy,MP(mx,mx)));
                }
                //continue;
                //printf("special\n");
            }
        }
        else if(ny==cy){
            LL my=cy;
            LL sx,ex;
            if(dir==2){
                sx=cx+1;
                ex=nx;
            }
            else{
                sx=nx;
                ex=cx-1;
            }
            //printf("my=%lld sx=%lld ex=%lld\n",my,sx,ex);
            ity=Y.lower_bound(MP(sx,MP(-INF,-INF)));
            //printf("ity : %lld %lld %lld \n",(*ity).F,(*ity).S.F,(*ity).S.S);
            for(;ity!=Y.end();ity++){
                //printf("ity : (%lld,%lld,%lld)\n",(*ity).F,(*ity).S.F,(*ity).S.S);
                if((*ity).F<sx) continue;
                if((*ity).F>ex){
                    counter += countX(my,sx,ex);
                    X.insert(MP(my,MP(sx,ex)));
                    if(sx==ex){
                        Y.insert(MP(sx,MP(my,my)));
                    }
                    break;
                }
                else{
                    if((*ity).S.F<=my && my<=(*ity).S.S){
                        if(sx==(*ity).F){
                            sx++;
                            if(sx>ex) break;
                        }
                        else{
                            counter += countX(my,sx,(*ity).F-1);
                            X.insert(MP(my,MP(sx,(*ity).F-1)));
                            if(sx==(*ity).F-1){
                                Y.insert(MP(sx,MP(my,my)));
                            }
                            sx=(*ity).F+1;
                            if(sx>ex) break;
                        }
                    }
                }
            }
            if(ity==Y.end() || (*ity).F>ex){
                //printf("special\n");
                counter += countX(my,sx,ex);
                X.insert(MP(my,MP(sx,ex)));
                if(sx==ex){
                    Y.insert(MP(sx,MP(my,my)));
                }
                //continue;
            }
        }
        printf("%lld\n",counter);
        cx=nx;
        cy=ny;
    }
    return 0;
}
