#include <iostream>
#include <algorithm>
#include <cmath>
#include <memory.h>

#define EPS 1e-8

using namespace std;

struct Point {
	double x, y;
}p[60], q[60];

bool operator<(const Point &p1, const Point &p2) {
	return p1.x < p2.x - EPS || fabs(p1.x - p2.x) <= EPS && p1.y < p2.y - EPS;
}

int main() {

	int T, n, i, j, k, s, t, m;
	double s1[60], s2[60], alpha, d, a, x, y, temp, ms;
	for (scanf("%d", &T); T; T--) {
		scanf("%d", &n);
		ms = 0;
		q[0].x = q[0].y = 0;
		for (i = 0; i < n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
		for (i = 0; i < n; i++)
			for (j = 0; j < n; j++) {
				if (j == i) continue;
				alpha = atan2(p[j].y - p[i].y, p[j].x - p[i].x);
				d = hypot(p[i].x - p[j].x, p[i].y - p[j].y);
				m = 1;
				for (k = 0; k < n; k++) {
					if (k == i || k == j) continue;
					x = (p[k].x - p[i].x) * cos(alpha) + (p[k].y - p[i].y) * sin(alpha);
					y = (p[i].x - p[k].x) * sin(alpha) + (p[k].y - p[i].y) * cos(alpha);
					if (x > EPS && x < d - EPS && y > EPS)
						q[m].x = x, q[m++].y = y;
				}
				sort(q + 1, q + m);
				if (m == 1) continue;
				q[0].x = q[0].y = 0;
				q[m].x = d, q[m++].y = 0;
				memset(s1, 0, sizeof(s1));
				memset(s2, 0, sizeof(s2));
				for (k = 1; k < m; k++)
					for (s = 0; s < k; s++) {
						if (q[s].x > q[k].x - EPS) break;
						a = (q[k].y - q[s].y) / (q[k].x - q[s].x);
						for (t = s + 1; t < k; t++)
							if (q[t].y - q[s].y < (q[t].x - q[s].x) * a - EPS)
								break;
						if (t < k) continue;
						temp = (q[s].y + q[k].y) * (q[k].x - q[s].x) / 2;
						if (q[s].y > q[k].y + EPS && s2[s] > EPS)
							s1[k] = max(s1[k], temp + s2[s]);
						else if (q[s].y < q[k].y - EPS && (s == 0 || s1[s] > EPS))
							s2[k] = max(s2[k], temp + s1[s]);
					}
				ms = max(ms, s1[m - 1]);
			}
		printf("%.1lf\n", ms);
	}				
	return 0;
}
