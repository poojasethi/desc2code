#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cmath>
using namespace std;
const int MAXN = 50;
const double EPS = 1e-8;
const double INF = 1.0/0.0;
struct Point {
double x, y;
Point(double xx = 0, double yy = 0) : x(xx), y(yy) {}
bool operator<(const Point& rhs) const { return x < rhs.x; }
};
Point p[MAXN], q[MAXN];
double best[2][MAXN];
int n;
double cross(const Point& a, const Point& b, const Point& c) {
return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
}
double solve(int a, int b) {
double dx = p[b].x-p[a].x, dy = p[b].y-p[a].y;
double len = sqrt(dx*dx + dy*dy);
double t = atan2(dy,dx);
int m = 0;
for (int i = 0; i < n; ++i) {
Point tmp(p[i].x-p[a].x, p[i].y-p[a].y);
Point nxt(tmp.x*cos(t)+tmp.y*sin(t), tmp.y*cos(t)-tmp.x*sin(t));
if (nxt.y+EPS < 0 || nxt.x+EPS < 0 || nxt.x > len+EPS) continue;
bool match = false;
for (int j = 0; j < m && !match; ++j)
if (fabs(q[j].x - nxt.x) < EPS) {
q[j].y = min(q[j].y, nxt.y);
match = true;
}
if (!match) q[m++] = nxt;
}
sort(q, q+m);
best[0][m-1] = -INF;
best[1][m-1] = 0;
for (int i = m-2; i >= 0; --i) {
best[0][i] = best[1][i] = -INF;
int lo = i;
for (int j = i+1; j < m; ++j) {
if (cross(q[i], q[j], q[lo]) < -EPS) continue;
lo = j;
double area = (q[j].x-q[i].x)*(q[j].y+q[i].y)*0.5;
if (q[j].y > q[i].y+EPS)
best[1][i] = max(best[1][i], best[0][j]+area);
else if (q[j].y+EPS < q[i].y)
best[0][i] = max(best[0][i], best[1][j]+area);
}
}
return best[1][0];
}
int main() {
cout.setf(ios::fixed);
cout.precision(1);
int t;
cin >> t;
while (t--) {
cin >> n;
for (int i = 0; i < n; ++i) cin >> p[i].x >> p[i].y;
double mx = 0;
for (int i = 0; i < n; ++i)
for (int j = 0; j < n; ++j)
if (i != j)
mx = max(mx, solve(i, j));
cout << mx << endl;
}
}