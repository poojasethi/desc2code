// Alfonso2 Peterssen (mukel)
#include <iostream>
#include <cstdio>
#include <sstream>

#include <algorithm>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>

#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cassert>

using namespace std;

typedef long long int64;

#define endl '\n'
#define SZ(c) ((int)((c).size()))
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
#define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i)
#define ALL(c) (c).begin(), (c).end()

struct fastCin {
	char cur;
	inline char nextChar() {
		return cur = getc_unlocked(stdin);
	}
	inline char peekChar() {
		return cur;
	}
	inline operator bool() {
		return (peekChar() != 0);
	}
	inline static bool isBlank(char c) {
		return (c < '0' && c);
	}
	inline bool skipBlanks() {
		while (isBlank(nextChar()))
			;
		return peekChar() != 0;
	}
	fastCin() {
		cur = 0;
	}
	char tmp[1 << 8];
	inline fastCin& operator >>(int & n) {
		if (skipBlanks()) {
			int sign = +1;
			if (peekChar() == '-') {
				sign = -1;
				n = nextChar() - '0';
			} else
				n = peekChar() - '0';
			while (!isBlank(nextChar())) {
				n *= 10;
				n += peekChar() - '0';
			}
			n *= sign;
		}
		return *this;
	}
	inline fastCin& operator >>(int64 & n) {
		if (skipBlanks()) {
			int sign = +1;
			if (peekChar() == '-') {
				sign = -1;
				n = nextChar() - '0';
			} else
				n = peekChar() - '0';
			while (!isBlank(nextChar())) {
				n *= 10;
				n += peekChar() - '0';
			}
			n *= sign;
		}
		return *this;
	}
#define cin cin2
} cin2;

struct fastCout {
	char buf[1 << 22], * ptr;
	char tmp[1 << 8];
	fastCout() { ptr = buf; }
	void flush() { fwrite(buf, 1, ptr - buf, stdout); ptr = buf; }
	~fastCout() { flush(); }
	inline void putChar(char c) {
		if (ptr < buf + sizeof(buf))
			*ptr++ = c;
		else
			flush();
	}
	inline fastCout& operator << (char c) {
		putChar(c);
		return *this;
	}
	inline fastCout& operator << (char * s) {
		while (*s) putChar(*s++);
		return *this;
	}
	inline char * toString(int n) {
		char * p = (tmp + 20); // print in reverse order
		*p-- = 0; // ending
		if (n == 0) *p-- = '0';
		else {
			bool isNeg = 0;
			if (n < 0) isNeg = 1, n = -n;
			while (n > 0) *p-- = (n % 10) + '0', n /= 10;
			if (isNeg) *p-- = '-';
		}
		return p + 1;
	}
	inline char * toString(int64 n) {
			char * p = (tmp + 50); // print in reverse order
			*p-- = 0; // ending
			if (n == 0) *p-- = '0';
			else {
				bool isNeg = 0;
				if (n < 0) isNeg = 1, n = -n;
				while (n > 0) *p-- = (n % 10) + '0', n /= 10;
				if (isNeg) *p-- = '-';
			}
			return p + 1;
		}
	inline fastCout& operator << (int n) {
		return (*this) << toString(n);
	}
	inline fastCout& operator << (int64 n) {
		return (*this) << toString(n);
	}
	#define cout cout2
} cout2;

const int64
	MAXN = 3141LL * 3141 * 3141 * 3141 * 3141;

vector< int64 > powerNums;

int64 squareRoot(int64 n) {
	return sqrt(n);
}

bool isPowerNum(int64 n) {
	if (n < 4)
		return false;
	int64 sq = squareRoot(n);
	return sq * sq == n || binary_search(ALL(powerNums), n);
}

int64 getPowerNumsLessThan(int64 n) {
	if (n < 4)
		return 0;

	int64 sq = squareRoot(n);

	int lo = 0, hi = SZ(powerNums) - 1;

	while (lo <= hi)
	{
		int mid = (lo + hi) >> 1;

		if (n <= powerNums[mid])
			hi = mid - 1;
		else
			lo = mid + 1;
	}

	int64 r = hi + 1;

	r += sq - 1;
	if (sq * sq == n)
		--r;

	return r;
}

int64 getNonPowerIndex(int64 n) {
	//assert( !isPowerNum(n));
	return n - getPowerNumsLessThan(n) + 1;
}

int simulate(int64 n) {
	int64 nIndex = getNonPowerIndex(n);

	int steps = 0;
	int64 pos = 2, lo, hi;

	while (1) {
		steps++;
		if (pos == nIndex)
			return steps;
		if (pos < nIndex)
			pos <<= 1;
		else {
			lo = pos >> 1;
			hi = pos;
			break;
		}
	}

	while (lo < hi) {
		int64 mid = (lo + hi) >> 1;

		steps++;

		if (mid == nIndex)
			return steps;

		if (mid < nIndex)
			lo = mid;
		else
			hi = mid;
	}

	return steps;
}

void calcNonSquarePowerNums() {

	powerNums.reserve(1 << 20);

	for (int64 a = 2, f; (f = a * a * a) <= MAXN; ++a) {
		int64 limit = MAXN / a + 1;
		for (;;) {
			int64 sq = squareRoot(f);

			if (sq * sq != f)
				powerNums.push_back(f);

			if (f >= limit)
				break;
			f *= a;
		}
	}

	sort(ALL(powerNums));
	powerNums.erase(unique(ALL(powerNums)), powerNums.end());
}

int main() {

	ios::sync_with_stdio(0);

	calcNonSquarePowerNums();

	int T;
	for (cin >> T; T--;) {
		int64 P;
		cin >> P;
		if (isPowerNum(P))
			cout << getPowerNumsLessThan(P) + 1 << endl;
		else
			cout << simulate(P) << endl;
	}

	return 0;
}
