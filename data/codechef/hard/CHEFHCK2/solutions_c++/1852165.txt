#include <cstdio>

#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

#define EPS 1e-9
//#define INF 305731144433251701LL
//#define INF (305731144433251701LL * 2 + 100)
#define INF 1000000000000000000LL

typedef long long llong;

llong int_sqrt(llong x) {
/*
   double y = trunc(sqrt(x) + EPS);
   return fabs(y*y - x) < EPS;
*/
   llong L = 0, R = 1000000001;
   while (L < R) {
      llong M = L + (R-L)/2; // (L + R) / 2;
      llong M2 = M * M;
      if (M2 == x) return M;
      if (M2 < x)
         L = M+1;
      else
         R = M;
   }
   return L-1;  // truncate
}

bool is_square(llong x) {
   llong y = int_sqrt(x);
   return y*y == x;
}

vector<llong> PP;
void fill_PP() {
   PP.clear();
   for (llong n = 2; n <= 1000000; ++n) {
      llong np = n;
      for (int p = 3; ; p += 2) {
      // if (1.0*np*n > INF) break;
         if (np > INF / n / n) break;
         np *= n * n;
         if (!is_square(np))
            PP.push_back(np);
      }
   }
   sort(PP.begin(), PP.end());
   PP.erase(unique(PP.begin(), PP.end()), PP.end());
// fprintf(stderr, "size = %d\n", (int) PP.size());
}

/*
int primes[] = {
      2,      3,      5,      7,     11,     13,     17,     19,     23,     29, 
     31,     37,     41,     43,     47,     53,     59,     61,     67
};

int nprimes = sizeof(primes) / sizeof(primes[0]);

bool is_power_pw(double x) {
   if (x <= 3 + EPS) return false;
   for (int j = 0; j < nprimes; ++j) {
      double y = trunc(pow(x, 1.0 / primes[j]) + EPS);
      if (fabs(pow(y, primes[j]) - x) < EPS)
         return true;
   }
   return false;
}
*/

bool is_power_pw(llong x) {
   if (x <= 3) return false;
   vector<llong>::const_iterator it = lower_bound(PP.begin(), PP.end(), x);
   if (it != PP.end() && *it == x) return true;
   if (is_square(x)) return true;
   return false;
}

llong count_powers(llong x) {
   if (x <= 3) return 0;
// llong sq = trunc(sqrt(x + 0.1) + EPS) - 1;
   llong sq = int_sqrt(x) - 1;
   llong nonsq = upper_bound(PP.begin(), PP.end(), x) - PP.begin();
/*
   fprintf(stderr, "1 squares = %lld\n", sq);
   fprintf(stderr, "1 non-squares = %lld\n", nonsq);
*/
   return sq + nonsq;
}

llong count_nonpowers(llong x) {
// if (x <= 3) return x + 1;
   llong res = x + 1 - count_powers(x);
   return res;
}

llong solve(llong pw) {
   llong res;
   if ( is_power_pw(pw) ) {
      res = count_powers(pw);
   }
   else {
      llong idx = count_nonpowers(pw);
//    fprintf(stderr, "1 idx = %lld\n", idx);
      res = 1;
      llong t = 2;
      for (; t < idx; t *= 2) ++res;
      if (t != idx) {
         llong L = t/2, R = t;
      // fprintf(stderr, "L = %lld  R = %lld\n", L, R);
         while (true) {
            llong M = (L+R) / 2;
            ++res;
            if (M == idx) break;
            if (M < idx)
               L = M;
            else
               R = M;
         }
      }
   }
   return res;
}


int main(int argc, char* argv[]) {
   fill_PP();

   int N;
   scanf("%d", &N);
   for (int i = 0; i < N; ++i) {
      llong pw;
      scanf("%lld", &pw);
      llong res = solve(pw);
      if (i > 0) putchar(' ');
      printf("%lld", res);
   }
   printf("\n");

   return 0;
}
