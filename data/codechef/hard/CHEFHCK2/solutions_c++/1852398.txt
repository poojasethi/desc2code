/*
    Author: Nikolay Kuznetsov
    Dedicated to my Love, Kristina Dmitrashko
*/
#ifdef NALP_PROJECT
#pragma hdrstop
#else
#define _SECURE_SCL 0
#endif

#define _CRT_SECURE_NO_DEPRECATE
#pragma comment(linker, "/STACK:200000000")

#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <cmath>
#include <algorithm>
#include <utility>

#include <set>
#include <map>
#include <vector>
#include <string>
#include <queue>
#include <memory.h>

#include <iostream>
#include <sstream>

using namespace std;

typedef long long int64;

#define forn(i, n) for(int i = 0; i < (int)(n); i++)
#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)
#define pb push_back
#define mp make_pair
#define y1 YYYYYYYYYYYY1
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()

template<typename T> inline T Abs(T x) { return (x >= 0) ? x : -x; }
template<typename T> inline T sqr(T x) { return x * x; }
template<typename T> string toStr(T x) { stringstream st; st << x; string s; st >> s; return s; }

inline int nextInt() { int x; if (scanf("%d", &x) != 1) throw; return x; }
inline int64 nextInt64() { int64 x; if (scanf("%I64d", &x) != 1) throw; return x; }
inline double nextDouble() { double x; if (scanf("%lf", &x) != 1) throw; return x; }

const int INF = (int)1E9;
const int64 INF64 = (int64)1E18;
const long double EPS = 1E-9;
const long double PI = 3.1415926535897932384626433832795;

const int MAXN = 100100;

vector<int64> a;

int64 getSquare(int64 x) {
	int64 s = (int64)sqrt(x + 0.0) - 2, ans = 0;
	for(int64 i = s; i <= s + 5; i++)
		if (i*i <= x)
			ans = i;

	return ans;
}

int64 getLess(int64 x) {
	if (x <= 1) return 0;
	int64 sq = getSquare(x);
	int pos = (int)(upper_bound(all(a), x) - a.begin());
	return sq - 1 + pos;
}

bool check(int64 x) {
	if (x < 4) return false;
	int64 s = getSquare(x);
	if (s*s == x) return true;
	int pos = (int)(lower_bound(all(a), x) - a.begin());
	return pos < (int)a.size() && a[pos] == x;
}

int64 solve(int64 x) {
	int64 p = getLess(x);
	if (check(x))
		return p;
	else {
		x = x - p + 1;
		int64 ans = 0, l = -1, r = -1;
		for(int64 i = 2; ; i *= 2) {
			ans++;
			if (x == i) return ans;
			if (x < i) {
				l = i / 2;
				r = i;
				break;
			}
		}

		while (true) {
			ans++;
			int64 mid = (l + r) >> 1;
			if (mid == x) return ans;

			if (x > mid)
				l = mid;
			else
				r = mid;
		}

		throw;
	}
}

int64 mul(int64 a, int64 b) {
	return a * min(INF64 / a, b);
}

int main() {
#ifdef NALP_PROJECT
	freopen("input.txt", "rt", stdin);
//	freopen("output.txt", "wt", stdout);
#else
#endif

	int64 M = 1LL*3141*3141*3141*3141*3141 + 10;
	for(int64 i = 2; i * i * i <= M; i++) {
		int64 p = i * i * i;
		while (p <= M) {
			int64 s = getSquare(p);
			if (s*s != p) a.pb(p);
			p = mul(p, i);
		}
	}
	sort(all(a));
	a.erase(unique(all(a)), a.end());

	int n = nextInt();
	forn(i, n) {
		if (i > 0) cout << " ";
		int64 x;
		cin >> x;
		cout << solve(x);
	}
	cout << endl;

	return 0;
}
