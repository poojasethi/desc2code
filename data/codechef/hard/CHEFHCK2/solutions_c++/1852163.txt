#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <cmath>
#include <algorithm>
#include <sstream>
#include <stack>
#include <cstring>
#include <iomanip>
#include <ctime>
using namespace std;
#define pb push_back
#define INF 1001001001
#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))
#define FORI(i,n) for(int (i)=1;(i)<=(n);++(i))
#define mp make_pair
#define pii pair<int,int>
#define ll long long
#define vi vector<int>
#define SZ(x) ((int)((x).size()))
#define fi first
#define se second
#define wez(n) int (n); scanf("%d",&(n));
#define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m));
#define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k));
inline void pisz(int n) { printf("%d\n",n); }
template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";}
template<typename T> ostream& operator<<(ostream &s,vector<T> t){FOR(i,SZ(t))s<<t[i]<<" ";return s; }
#define IN(x,y) ((y).find((x))!=(y).end())
#define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl;
#define ALL(t) t.begin(),t.end()
#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)
#define TESTS wez(testow)while(testow--)
#define REP(i,a,b) for(int (i)=(a);(i)<=(b);++i)
#define REPD(i,a,b) for(int (i)=(a); (i)>=(b);--i)
#define REMAX(a,b) (a)=max((a),(b));
#define REMIN(a,b) (a)=min((a),(b));
#define IOS ios_base::sync_with_stdio(0);

const ll B = 3141LL * 3141LL * 3141LL * 3141LL * 3141LL;

ll sq (ll x) { // max j st j*j <= x
   ll from = 1, to = INF, best = 0;
   while (from <= to) {
      ll mid = (from + to) / 2;
      if (mid * mid <= x) {
         best = mid;
         from = mid+1;
      } else {
         to = mid - 1;
      }
   }
   return best;
}
vector<ll> nsp; // powers that arent squares
bool ispower (ll x) { // log
   if (x == 0 || x == 1) return 0;
   ll s = sq(x);
   if (s*s == x) return 1;
   return binary_search(ALL(nsp), x);
}
ll powersleq (ll x) { // log
   const ll squareslessorequal = sq(x) - 1;
   const int nsplessorequal = upper_bound(ALL(nsp), x) - nsp.begin();
   return squareslessorequal + nsplessorequal;
}
ll whichnonpower (ll x) { // log
   if (x == 0) return 1;
   return x + 1 - powersleq(x);
}
/*ll getnonpower_bf (ll p) { // log^2
   ll from = 0, to = B+1; // [from, to)
   while (1) {
      ll m = (from + to) / 2;
      ll h = whichnonpower(m); // log
      if (h == p) {
         while (ispower(m)) --m;
         return m;
      } else if (h < p) {
         from = m;
      } else {
         to = m;
      }
   }
}
ll nonpowerslessthannsp[1000007];
//const int M = 1000000;
ll Apot[70];//, A[M+6];
ll getnonpower (ll p) {
   if (p < 8) return getnonpower_bf(p);
   //DBG(p)
   //ll from = 1, to = SZ(nsp) - 1, be//
   int ind = lower_bound(nonpowerslessthannsp, nonpowerslessthannsp+SZ(nsp), p) - nonpowerslessthannsp;
   ll le = nsp[ind-1]+1, from = le, to = ind==SZ(nsp) ? B : nsp[ind]-1, N = nonpowerslessthannsp[ind-1];
   //DBG(le)DBG(ri)
   //exit(0);
   while (from <= to) {
      ll q = (from + to) / 2;
      //DBG(q)
      //ll non = N + q-le+1 - sq(q) + sq(le-1);
      ll non = whichnonpower(q);
      if (non < p) {
         from = q+1;
      } else if (non > p) {
         to = q-1;
      } else {
         return q;
      }
   }
}*/

int main () {
   REP(w,3,60) {
      for (ll x = 2; ; ++x) {
         //ll pw = pwr(x,w);
         ll pw = 1;
         FOR(u,w) {
            pw *= x;
            if (pw > B) break;
         }
         if (pw > B) break;
         nsp.pb(pw);
      }
   }
   //DBG(SZ(nsp))
   vector<ll> nu;
   FOREACH(x,nsp) {
      ll s = sq(*x);
      if (*x == s*s) {
      } else {
         nu.pb(*x);
      }
   }
   sort(ALL(nu));
   nu.erase(unique(ALL(nu)), nu.end());
   nsp = nu;
   /*FOR(i,SZ(nsp)) {
      nonpowerslessthannsp[i] = nsp[i] - (sq(nsp[i]) - 1 + i);
      //if (i < 20) { DBG(i) DBG(nsp[i]) DBG(nonpowerslessthannsp[i] ) }
   }
   //getnonpower(24);
   //DBG(SZ(nsp))
   //DBG(vector<ll>(nsp.begin(), nsp.begin() + 30))
   
   //REP(i,0,12) { DBG(i) DBG(whichnonpower(i)) }
   //REP(i,1,8) { DBG(i) DBG(getnonpower(i)) }
   
   REP(i,1,58) {
      //DBG(i)
      Apot[i] = getnonpower(1LL << i);
      //DBG(Apot[i])
   }
   Apot[59] = INF * 1LL * INF;
   //REP(i,1,M) A[i] = getnonpower(i);*/
     
   TESTS {
      ll x;
      scanf("%lld", &x);
      if (x == 0) {
         printf("2 ");
      } else if (ispower(x)) {
         printf("%lld ", powersleq(x));
      } else {
         x = whichnonpower(x);
         int k = 1;
         while ((1LL<<k) < x) ++k;
         if ((1LL<<k) == x) {
            printf("%d ", k);
         } else {
            ll L = 1LL << (k-1), R = 1LL << k;
            int steps = k;
            while(1) {
               ++steps;
               ll M = (L + R) / 2;
               if (M == x) {
                  printf("%d ", steps);
                  break;
               } else if (M < x) {
                  L = M;
               } else {
                  R = M;
               }
            }
         }
      }
   }
}
