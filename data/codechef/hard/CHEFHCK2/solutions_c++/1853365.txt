#include <cmath>
#include <ctime>
#include <iostream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <map>
#include <set>
#include <algorithm>
#include <cctype>
#include <stack>
using namespace std;

typedef long long int int64;

#define EPS 10e-9
#define INF 0x3f3f3f3f
#define REP(i,n) for(int i=0; i<(n); i++)
#define MAX 305731144433251701LL

int n;
int64 v[314259];
vector<int64> pw;

int64 mypow(int64 a, int64 b) {
	int64 res = 1;
	REP(i, b) {
		res = res * a;
	}
	return res;
}

bool square(int64 x) {
	int64 a = sqrt(x);
	if (a * a == x) return true;
	return false;
}

bool power(int64 x) {
	if (x < 4) return false;
	if (square(x)) return true;
	if (binary_search(pw.begin(), pw.end(), x)) return true;
	return false;
}


int64 getIndex(int64 x) {
	int64 res = (int64) sqrt(x + 0.5) -1;
	//printf("%lld\n", res);
	res = res + (int64) (upper_bound(pw.begin(), pw.end(), x) - pw.begin());
	//printf("%lld %lld %lld\n", pw[0], pw[1], pw[2]);
	return res;
}

int64 get(int64 x) {
	if (x == 1) return 0;
	if (x == 2) return 1;
	if (x == 3) return 2;
	int64 res = x-1;
	int64 ant = getIndex(res);
	//printf("%lld %lld\n", res, ant);
	res = res + ant;
	while (1) {
		int64 y = getIndex(res);
		//printf("%lld %lld\n", res, y);
		if (y == ant) return res;
		res += y - ant;
		ant = y;
	}
}

int64 getIndex2(int64 x) {
	if (x == 0) return 1;
	if (x == 1) return 2;
	int64 res = x+1;
	res -= (int64) sqrt(x + 0.5) - 1;
	res -= (int64) (upper_bound(pw.begin(), pw.end(), x) - pw.begin());
	return res;
}	

int64 busca(int64 x) {
	int64 res = 1;
	int64 k = 2;
	int64 p = getIndex2(x);
	//printf("\n%lld %lld\n", x, p);
	while (1) {
		//printf("%lld %lld\n", k, y);
		if (k == p) return res;
		if (k > p) break;
		k = k * 2;
		res++;
	}
	int64 a = k / 2;
	int64 b = k;
	while (1) {
		int64 meio = (a+b) / 2;
		res++;
		//printf("%lld %lld\n", meio, y);
		if (meio == p) return res;
		if (meio > p) {
			b = meio;
		}
		else {
			a = meio;
		}
	}
} 


/*void generate() {
	pw.clear();
	for (int64 p = 3; p <= 61; p = p+2) {
		int64 b = floor(pow(MAX, 1.0/p));
		for (int64 i = 2; i <= b; i++) {
			int64 x = mypow(i, p);
			//printf("%lld %lld %lld: %lld\n", i, p, b, x);
			if (!square(x)) {
				pw.push_back(x);
			}
		} 
	}
	sort(pw.begin(), pw.end());
	//printf("%d\n", (int) pw.size());
}*/

vector<int64> p3;
vector<int64> pr;

void generate() {
	pw.clear();
	p3.clear();
	pr.clear();
	for (int64 i = 2; i <= 673669LL; i++) {
		int64 x = i * i * i;
		if (!square(x)) p3.push_back(x);
	}
	for (int64 i = 2; i <= 3142LL; i++) {
		int64 x = i * i * i * i * i;
		while (1) {
			if (!square(x)) pr.push_back(x);
			if (x  > (ceil(ceil(MAX / i) / i)) ) break;
			x = x * i * i;
		}
	}
	sort(pr.begin(), pr.end());
	//printf("%d %d\n", p3.size(), pr.size());
	pw.resize((int) p3.size() + (int) pr.size());
	merge(p3.begin(), p3.end(), pr.begin(), pr.end(), pw.begin());
	pw.erase(unique(pw.begin(), pw.end()), pw.end());	
}

int main()
{	
	
	scanf("%d", &n);
	REP(i, n) scanf("%lld", &v[i]);
	generate();
	int64 res;
	REP(i, n) {
		if (power(v[i])) {
			res = getIndex(v[i]);
		}
		else {
			res = busca(v[i]);
		}
		if (i == n-1) printf("%lld", res);
		else printf("%lld ", res);
	}
	printf("\n");
	return 0;
}