



#include <iostream>
#include <fstream>
#include <string>
#include <cmath>
#include <map>
#include <set>
#include <sstream>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <cstring>
using namespace std;

#define INF 10000000LL

class UnionFind
{
private:
	vector<int> p, rank;

public:
	UnionFind(int N)
	{
		rank.assign(N, 0);
		p.assign(N, 0);
		for(int i = 0; i < N; i++) p[i] = i;
	}
	int findSet(int i)
	{
		return (p[i] == i) ? i : (p[i] = findSet(p[i]));
	}

	bool isSameSet(int i, int j)
	{
		return (findSet(i) == findSet(j));
	}

	void unionSet(int i, int j)
	{
		if(!isSameSet(i,j))
		{
			int x = findSet(i), y = findSet(j);
			if ( rank[x] > rank[y] ) p[y] = x;
			else
			{
				p[x] = y;
				if( rank[x] == rank[y] ) rank[y]++;
			}
		}
	}
};

int main()
{
	//ifstream fin("UNPAIR.txt");

	int t; cin >> t;
	for(int tt = 0; tt < t; tt++)
	{
		int n; cin >> n;

		vector< pair<long long, pair<int,int> > > Edges;
		for(int r = 0; r < n; r++)
		{
			for(int c = 0; c < n; c++)
			{
				long long w; cin >> w;
				if(c >= r && w > 0)
					Edges.push_back(make_pair(w,make_pair(r,c)));
			}
		}

		sort(Edges.begin(), Edges.end());
		long long mst_cost = 0;
		UnionFind UF(n);
		for(int i = 0; i < Edges.size(); i++)
		{
			pair<long long, pair<int,int> > front = Edges[i];
			if(!UF.isSameSet(front.second.first, front.second.second))
			{
				mst_cost += front.first;
				UF.unionSet(front.second.first, front.second.second);
			}

		}

		int bad = 0;

		if(mst_cost == 0)
			bad = 1;

		for(int i = 0; i < n; i++)
		{
			if(!UF.isSameSet(0,i))
			{
				bad = 1;
				break;
			}
		}

		if(n == 1 && Edges.size() != 0)
			cout << Edges[0].first << endl;

		else if(bad)
			cout << "-1" << endl;
		else
			cout << 2LL*mst_cost << endl;
	}

	int g;
	
}