#include"limits"
#include"cstdio"
#include"vector"
#include"list"
#include"cmath"
#include"set"
#include"map"
#include"queue"
#include"stack"
#include"bitset"
#include"cstring"
#include"cstdlib"
#include"string"
#include"cassert"
#include"iostream"
#include"algorithm"
#include"functional"
#include"numeric"
#include"sstream"
#include"iomanip"
#include"cctype"
#include"ctime"
 
#define MAX_INPUT 1<<20
#define MAX_OUTPUT 1<<20
 
typedef long double F128;       //            1.18973... E 4932
typedef double F64;             //            1.79769... E 308
typedef float F32;              //            3.40282... E 38
#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
typedef unsigned __int128 I128; // 3.4028236692093846... E 38
typedef signed __int128 I127;   // 1.7014118346046923... E 38
#endif
typedef unsigned long long I64; // 1.8446744073709551615 E 19
typedef signed long long I63;   //  9.223372036854775807 E 18
typedef unsigned int I32;       //           4.294967295 E 9
typedef signed int I31;         //           2.147483647 E 9
typedef unsigned short I16;     //                6.5535 E 4
typedef signed short I15;       //                3.2767 E 4
typedef unsigned char I8;       //                  2.55 E 2
typedef signed char I7;         //                  1.27 E 2
const I64 ULMAX = std::numeric_limits<I64>::max();
const I63 SLMAX = std::numeric_limits<I63>::max();
const I63 SLMIN = std::numeric_limits<I63>::min();
const I32 UIMAX = std::numeric_limits<I32>::max();
const I31 SIMAX = std::numeric_limits<I31>::max();
const I31 SIMIN = std::numeric_limits<I31>::min();
const I16 USMAX = std::numeric_limits<I16>::max();
const I15 SSMAX = std::numeric_limits<I15>::max();
const I15 SSMIN = std::numeric_limits<I15>::min();
const I8 UCMAX = std::numeric_limits<I8>::max();
const I7 SCMAX = std::numeric_limits<I7>::max();
const I7 SCMIN = std::numeric_limits<I7>::min();
 
const F64 PI = acos(-1);
const I63 INF2 = SLMAX>>1;
const I63 INF  = SIMAX>>1;
const F64 EPS = 1e-9;
 
template<typename T> struct unsign {
	typedef T type;
};
 
template<> struct unsign<I7> {
	typedef I8 type;
};
template<> struct unsign<I15> {
	typedef I16 type;
};
template<> struct unsign<I31> {
	typedef I32 type;
};
template<> struct unsign<I63> {
	typedef I64 type;
};
#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
template<> struct unsign<I127> {
	typedef I128 type;
};
#endif
template<bool b> class param{};
class IO {
	char INPUT[MAX_INPUT], OUTPUT[MAX_OUTPUT];
	char* inp, *otp;
	I32 inpsz;
	public:
	IO() {
		assert((inpsz=fread(INPUT, 1, sizeof(INPUT), stdin))<MAX_INPUT);
		inp = INPUT;
		otp = OUTPUT;
	}
	bool eof() {
		while(*inp>='\t' and *inp<=' ') inp++;
		return inp >= INPUT + inpsz;
	}
	template<typename T> inline void parse(T& n, param<true>) {
		n=(*inp)-'0';
		while(*++inp>='0')
			n = (n<<3)+(n<<1)+(*inp)-'0';
	}
	template<typename T> inline void parse(T& n, param<false>) { // decimal num
		n = 0;
		T pow = 1;
		bool seen_decimal = false;
		while((*inp>='.' and *inp<='9'))
			if(*inp=='.')
				seen_decimal = true, inp++;
			else if(not seen_decimal)
				n = n*10+(*inp++)-'0';
			else
				n = n + ((*inp++)-'0')*(pow*=0.1);
		while(*inp>' ') inp++; // parse that token
		// not handling 1e8
	}
	template<bool nonempty> inline void readline(char* c) {
		if(nonempty)
			while(*inp=='\n') inp++;
		while(*inp>'\n')*c++ = *inp++;
		*c = 0;
		inp++;
	}
	template<typename T> inline void read_vector(std::vector<T>& v, I32 sz=-1) {
		if(not (sz+1))
			(*this)>>sz;
		while(sz--) {
			T temp;
			(*this)>>temp;
			v.push_back(temp);
		}
	}
	template<typename T> inline void write(param<true>, T n) {
		I8 len = n>9?(n>99?(n>999?(n>9999?(n>99999?(n>999999?(n>9999999?(n>99999999?(n>999999999?10:9):8):7):6):5):4):3):2):1, j;
		if(len>9 and n>9999999999ll) {
			while(len<19 and lengs[len]<n)
				len++;
			if(n>9999999999999999999ull) len++;
		}
		j = len;
		while(--j)
			otp[j] = '0'+n%10, n/=10;
		*otp = n+'0';
		//assert(len==1 or (*otp>'0' and *otp<='9'));
		otp += len;
	}
	template<typename T> inline void write(param<false>, T& n) {
		const I8 len = sizeof(T);
		otp += sprintf(otp, len<=4?"%f":(len<=8?"%lf":"%Lf"), n);
	}
	template<typename T> inline IO& operator>>(T& n) {
		bool sgn=0;
		if(std::numeric_limits<T>::is_signed)
			while(*inp<'.') sgn = sgn or *inp=='-', inp++;
		else 
			while(*inp<'.') inp++;
		parse<T>(n, param<std::numeric_limits<T>::is_integer>());
		if(sgn) n = -n;
		return *this;
	}
	inline IO& operator>>(char* c) {
		while(*inp<=' ') inp++;
		*c++ = *inp++;
		while(*inp>' ') *c++ = *inp++;
		*c = 0;
		return *this;
	}
	inline IO& operator>>(char& c) {
		c = *inp++;
		return *this;
	}
	const static I64 lengs[19];
	template<typename T> inline IO& operator<<(T n) {
		if(n<0) *otp++ = '-', n = -n;
		write<T>(param<std::numeric_limits<T>::is_integer>(), n);
		return *this;
	}
	inline IO& operator<<(const char c) {
		*otp++ = c;
		return *this;
	}
	inline IO& operator<<(char* c) {
		while(*c)
			*otp ++ = *c++;
		return *this;
	}
	inline IO& operator<<(const char* c) {
		while(*c)
			*otp ++ = *c++;
		return *this;
	}
	void flush() {
		fwrite(OUTPUT, 1, otp-OUTPUT, stdout);
		otp = OUTPUT;
	}
	~IO() {
		flush();
	}
};
const I64 IO::lengs[19] = {0, 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999ll, 99999999999ll, 999999999999ll, 9999999999999ll, 99999999999999ll, 999999999999999ll, 9999999999999999ll, 99999999999999999ll, 999999999999999999ll};
#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
template<> inline void IO::write(param<true>, I128 n) {
	I8 len = n>9?(n>99?(n>999?(n>9999?(n>99999?(n>999999?(n>9999999?(n>99999999?(n>999999999?10:9):8):7):6):5):4):3):2):1, j;
	if(len>9 and n>9999999999ll) {
		while(len<19 and lengs[len]<n)
			len++;
		if(n>9999999999999999999ull) {
			I128 m = n/10000000000000000000ull;
			write(param<true>(), m);
			n %= 10000000000000000000ull;
		}
	}
	j = len;
	while(--j)
		otp[j] = '0'+n%10, n/=10;
	*otp = n+'0';
	otp += len;
}
#endif
using namespace std;
IO io;
template<class T1, class T2> inline T1 min(T1 a, T2 b){return a<b?a:b;}
template<class T1, class T2> inline T1 max(T1 a, T2 b){return b<a?a:b;}
template<class T1, class T2> inline void putmin(T1 a, T2 b){if(b<a)a=b;}
template<class T1, class T2> inline void putmax(T1 a, T2 b){if(a<b)a=b;}
 
#define SIZE(A) ((int)A.size())
#define LENGTH(A) ((int)A.length())
#define MP(A,B) make_pair(A,B)
#define PB(X) push_back(X)
#define REP(i,n) for(I32 i=0; i<(n); i++)
#define LOOP(i, a, b) for(I32 i=(a); i<(b); i++)
#define ALL(x) (x).begin(), (X).end()
#define FOREACH(it, x) for(typeof((x).begin()) it=(x).begin(); it!=(x).end(); it++)
 
I32 A[2000], N;
I32 trie[200000][3];
I32 root = 1, available = 1;
I32 best;
template<int pos> void put(I32 num, I32 node) {
	trie[node][2]++;//num children
	I32& next = trie[node][(num&(1<<pos))?1:0];
	if(not next)
		next = available++;
	put<pos-1>(num, next);
}
template<> void put<-1>(I32, I32) {}
template<int pos> void check(I32 third, I32 node, I32 cost, I32 image) {
	//cerr << "@ "<< node<< " image "<< image << " third "<<third << " pos "<<pos << "\n";
	if(cost+(1u<<(pos+1))-1<=best) return;
	assert(node and image);
	bool bit = not (third&(1u<<pos));
	if(trie[node][0]) {
		if(trie[image][bit] and (trie[image][bit]!= trie[node][0] or trie[trie[image][bit]][2]>1)) {
			//cerr << "got one "<< node<< " image "<< image << " third "<< third << " pos "<<pos << "\n";
			check<pos-1>(third, trie[node][0], cost+(1<<pos), trie[image][bit]);
		}
		else
			check<pos-1>(third, trie[node][0], cost, trie[image][bit^1]);
	}
	if(trie[node][1]) {
		if(trie[image][bit^1] and (trie[image][bit^1]!= trie[node][1] or trie[trie[image][bit^1]][2]>1)) {
			//cerr << "got zero "<< node<< " image "<< image << " third "<< third << " pos "<<pos << "\n";
			check<pos-1>(third, trie[node][1], cost+(1<<pos), trie[image][bit^1]);
		}
		else
			check<pos-1>(third, trie[node][1], cost, trie[image][bit]);
	}
}
template<> void check<-1>(I32, I32, I32 cost, I32) {
	best = max(cost, best);
}
void solve(){
	best = 0;
	root = available++;
	io >> N;
	REP(i, N) io >> A[i];
	sort(A, A+N);
	assert(N>=3);
	I32 minxor = 1u<<31;
	REP(i, N) {
		assert(i==0 or A[i]>=A[i-1]);
		if(i>1) {
			if(A[i]&(A[i]+1))
				check<29>(A[i], root, 0, root);
			else
				best = max(best, A[i]^minxor);
		}
		for(I32 j=0; j<i; j++)
			minxor = min(minxor, A[i]^A[j]);
		put<29>(A[i], root);
		//cerr << " best so far "<< best <<"\n";
	}
	io << best << "\n";
	io.flush();
}
int main() {
	I32 T;
	io>>T;
	for(I32 i=0; i<T; i++) {
		solve();
	}
	io.flush();
} 