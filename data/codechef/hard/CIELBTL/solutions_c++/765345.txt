#include<iostream>
#include<queue>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<string>
#include<cstring>
#include<map>
#include<numeric>
#include<sstream>
#include<cmath>
using namespace std;
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define pb push_back
#define f(i,x,y) for(int i = x; i<y; i++ )
#define FOR(it,A) for(typeof A.begin() it = A.begin(); it!= A.end(); it++)
#define quad(x) (x) * (x)
#define mp make_pair
#define clr(x, y) memset(x, y, sizeof x)
#define fst first
#define snd second
typedef pair<int, int> pii;
typedef long long ll;
typedef long double ld;
#define inf (1 << 30)
int va, vb, sa, sb, ma;

double F[6][300][300];
double G[6][300][300];
#define cte 110

double factor;

double solve(double P){
   f(mma, 0, ma + 1)
      f(vva, -101, va + 1)
       f(vvb, -101, vb + 1){
         int a = vva + cte, b = vvb + cte;
         double &res = F[mma][a][b] = 0;
         G[mma][a][b] = G[mma][a - 1][b] + G[mma][a][b - 1] - G[mma][a - 1][b - 1];

         if(vva <= 0 && vvb <= 0) res = P;
         else if(vvb <= 0) res = 1;
         else if(vva <= 0) res = 0;
         else{
            if(mma) 
               res = max(res, F[mma - 1][((vva + 1) >> 1) + cte][((vvb + 1) >> 1) + cte]);
            double aux = G[mma][a][b] - G[mma][a - sb - 1][b] - G[mma][a][b - sa - 1]
                         + G[mma][a - sb - 1][b - sa - 1];
            res = max(res, aux / factor);
         }
         G[mma][a][b] += res;
       }
   return F[ma][va + cte][vb + cte];

}

int main(){
   clr(F, 0); clr(G, 0);

   cin >> va >> vb >> sa >> sb >> ma;
   factor = (sa + 1) * (sb + 1) - 1;
   double le = 0, ri = 1;

   while(le + 1e-7 < ri){
      double mid = (le + ri) / 2;
      if(solve(mid) > mid) le = mid;
      else ri = mid;
   }
   printf("%.09f\n", (le + ri) / 2);
}

