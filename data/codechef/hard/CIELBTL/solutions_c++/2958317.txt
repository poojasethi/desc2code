#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <complex>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cmath>
#include <cassert>
#include <queue>
#include <set>
#include <map>
#include <valarray>
#include <bitset>
#include <stack>
#include <iomanip>
#include <fstream>
using namespace std;

#define REP(i,n) for(int i=0;i<(int)(n);++i)
#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)
#define ALL(c) (c).begin(), (c).end()
#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)
const int INF = 1<<29;
const double EPS = 1e-8;
const double PI = acos(-1);
typedef long long ll;
typedef pair<int,int> pii;

inline void chmax(double &a, double b) {
  if (a < b) a = b;
}

struct CumSum {
  double sum[102][202];
  void init() {
    memset(sum,0,sizeof(sum));
  }
  void assign(int i, int j, double x) {
    sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + x;
  }
  double get(int i1, int j1, int i2, int j2) { // [i1,i2)*[j1,j2)
    return sum[i2][j2] - sum[i1][j2] - sum[i2][j1] + sum[i1][j1];
  }
  double get2(int i1, int j1, int i2, int j2) { // [i1,i2)*[j1,j2)
    // (i,j)が未定義
    return sum[i2][j2-1] + sum[i2-1][j2] - sum[i2-1][j2-1]
      - sum[i1][j2] - sum[i2][j1] + sum[i1][j1];
  }
} cumsum[6];

double dp[101][101][6];

int va,vb,sa,sb,ma;

inline double sub2(double x, int i, int j, int k, bool f) {
  double A = 0;
  int ni = max(0,sb-i+1);
  int nj = max(0,sa-j+1);
  A += x * ni * nj;
  A += (sb-ni+1) * nj;
  if (f) A += cumsum[k].get(max(0,i-sb), max(0,j-sa), i+1, j+1);
  else A += cumsum[k].get2(max(0,i-sb), max(0,j-sa), i+1, j+1);
  
  double K = (sa+1)*(sb+1);
  if (f) {
    A /= K;
  } else {
    A /= K-1;
  }

  return A;
}


bool solve(double x) {
  REP(i,6) cumsum[i].init();
  memset(dp,0,sizeof(dp));
  REP(i,va+1) {
    REP(j,vb+1) {
      if (i==0||j==0) continue;
      REP(k,ma+1) {
        chmax(dp[i][j][k], sub2(x,i,j,k,0));
        if (k) {
          chmax(dp[i][j][k], sub2(x,(i+1)/2,(j+1)/2,k-1,1));
          chmax(dp[i][j][k], dp[(i+1)/2][(j+1)/2][k-1]);
        }
        cumsum[k].assign(i,j,dp[i][j][k]);
      }
    }
  }
  return x < dp[va][vb][ma];
}


int main() {
  while(cin>>va>>vb>>sa>>sb>>ma) {
    // solve(0.5); break;
    double low = 0, high = 1;

    while(high-low>=1e-7) {
      double mid = (low+high)/2;
      if (solve(mid)) {
        low = mid;
      } else {
        high = mid;
      }
    }

    printf("%.10f\n", low);
  }
}
