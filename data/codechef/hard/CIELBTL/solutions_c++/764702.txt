#include <iomanip>
#include <ctime>
#include <numeric>
#include <functional>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstring>
#include <climits>
#include <cmath>
#include <cctype>
#include <sstream>
#include <map>
#include <set>
#include <cstdio>
#include <queue>
#define f(i,x,y) for(int i=x;i<y;i++)
#define fd(i,y,x) for(int i=y;i>=x;i--)
#define FOR(it,A) for( typeof A.begin() it = A.begin(); it!=A.end(); it++)
#define impr(A) for( typeof A.begin() chen = A.begin(); chen !=A.end(); chen++ ) cout<<*chen<<" "; cout<<endl
#define ll long long
#define vint vector<int>
#define clr(A,x) memset(A,x,sizeof(A))
#define CLR(v) f(i,0,n) v[i].clear()
#define oo (1<<30)
#define ones(x) __builtin_popcount(x)
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define pb push_back
#define eps (1e-9)
#define cua(x) (x)*(x)
#define real double
#define fst first
#define snd second
using namespace std;

/*real operator+(real a, real b){ return real(a.fst+b.fst, a.snd+b.snd); }
real operator-(real a, real b){ return real(a.fst-b.fst, a.snd-b.snd); }
real operator/(real a,int t){ return real(a.fst/t, a.snd/t); }
double eval (real a, double x){ return a.fst*x + a.snd; }
*/
int v1,v2, s1,s2, mag;

real dp (int x,int y, int mag);
real sum (int x,int y, int mag);
real memo[105][105][6];
real memosum[105][105][6];
double prob;
real dp(int x, int y, int mag){
   real &res = memo[x][y][mag];
	if (res!=-1) return res;

	int dividir = s1 * s2 - 1;
//	if (x<s1 && y<s2) dividir -= (s1-x) * (s2-y);
	res = mag? dp ((x+1)/2, (y+1)/2, mag-1) : 0;
	
	real r2 = sum (x-1, y, mag) + sum (x, y-1, mag) - sum (x-1,y-1, mag);
	if (x>s1) r2 = r2 - sum (x-s1, y, mag);
	if (y>s2) r2 = r2 - sum (x, y-s2, mag);
	if (x>s1 && y>s2) r2 = r2 + sum (x-s1, y-s2, mag);
	
	if (y<s2) r2 = r2 + (min (x,s1) * (s2 - y));
	if (x<s1 && y<s2) r2 = r2 + (prob * (s1-x)*(s2-y));
	
	r2 = r2 / dividir;
	
	res = max (res, r2);
//	cout << x << " " << y << " " << dividir << endl;
	return res;
}
real sum (int x, int y, int mag){
	if (x==0 || y==0) return 0;
	real &res = memosum[x][y][mag];
	if (res!=-1) return res;
	res = sum (x-1, y, mag) + sum (x, y-1, mag) - sum (x-1, y-1, mag);
	res = res + dp (x,y, mag);
	return res;
}

int main()
{
	cin >> v1 >> v2 >> s1 >> s2 >> mag;
	swap(s1,s2);
	s1++; s2++;
	f(i,0,105)f(j,0,105)f(k,0,6) memo[i][j][k] = memosum[i][j][k] = -1;
/*	real r = dp (v1,v2,mag);
	double res = r.snd/(1-r.fst);
	*/
	double lo = 0, hi = 1;
	while (hi-lo > 1e-7){
		prob = (lo + hi)/2;
		f(i,0,105)f(j,0,105)f(k,0,6) memo[i][j][k] = memosum[i][j][k] = -1;
		if (dp(v1,v2,mag) < prob) hi = prob;
		else lo = prob;
	}
	cout << fixed << setprecision(8) << hi << endl;
}
