#ifdef _WIN32
#  define LL "%I64d"
#else
#  define LL "%Ld"
#endif

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <ctime>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <bitset>
#include <string>
#include <algorithm>
#include <complex>
#include <utility>
using namespace std;
#define null NULL
#define mp make_pair
#define pb(a) push_back(a)
#define sz(a) ((int)(a).size())
#define all(a) a.begin() , a.end()
#define fi first
#define se second
#define relaxMin(a , b) (a) = min((a),(b))
#define relaxMax(a , b) (a) = max((a),(b))
#define SQR(a) ((a)*(a))
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef long long ll;
#define SZ 300
#define MAXN 60
namespace A{
vi fo[SZ];
int mark , N;
int match[SZ] , used[SZ] , par[SZ] , blossom[SZ] , base[SZ];
int lca(int a,int b){
  ++mark;
  for(;;){
   a = base[a];
   used[a] = mark;
   if(match[a] == -1)break;
   a = par[match[a]];
         }
  for(;;){
   b = base[b];
   if(used[b] == mark)return b;
   b = par[match[b]];
         }
}
void mark_path(int vr , int root , int child){
  while(base[vr] != root){
   blossom[ base[vr] ] = blossom[ base[ match[vr] ] ] = mark;
   par[vr] = child;
   child = match[vr];
   vr = par[child];
                         }
}
int Q[SZ] , QL , QR;
bool in_Q[SZ];
int find_path(int vr){
  memset(in_Q , 0 , (N+1)*sizeof(bool));
  memset(par , -1 , (N+1)*sizeof(int));
  for(int i=0;i<N;++i)base[i] = i;
  QL = QR = 0; Q[QR++] = vr;
  while(QL < QR){
   int V = Q[QL++];
   for(int i=0;i<sz(fo[V]);++i){
    int T = fo[V][i];
    if(base[V] == base[T] || match[V] == T)continue;
    if(T == vr || match[T]!=-1 && par[match[T]]!=-1){ // blossom
     int root = lca(V , T);
     ++mark;
     mark_path(V , root , T);
     mark_path(T , root , V);
     for(int j=0;j<N;++j)
      if(blossom[ base[j] ] == mark){
       base[j] = root;
       if(!in_Q[j]){
        in_Q[j] = true;
        Q[QR++] = j;
                   }
                                    }
                                                      }
    else{
     if(par[T] == -1){
      par[T] = V;
      if(match[T] == -1)return T;
      T = match[T];
      if(!in_Q[T]){
       in_Q[T] = true;
       Q[QR++] = T;
                  }
                     }
        }
                               }
                }
  return -1;
}
int max_matching(){
  int how=0;
  memset(match , -1 , (N+1)*sizeof(int));
  for(int i=0;i<N;++i){
   if(match[i] != -1)continue;
   int last = find_path(i);
   if(last!=-1)++how;
   while(last!=-1){
    int pv = par[last] , ppv = match[pv];
    match[last] = pv; match[pv] = last;
    last = ppv;
                  }
                      }
  return how;
}
};
// Sol data
int ID(char w){
  if(w>='a' && w<='z')return w-'a';
  return w-'A'+26;
}
vi fo[MAXN];
bool USE[MAXN];
int step[MAXN];
void dfs(int vr){
  USE[vr] = true;
  for(int i=0;i<sz(fo[vr]);++i)
   if(!USE[fo[vr][i]])dfs(fo[vr][i]);
}
bool nech[MAXN];
char buf[10];
void doit(){
  for(int i=0;i<MAXN;++i)fo[i].clear() , A::fo[i].clear();
  memset(nech , 0 , sizeof nech);
  memset(step , 0 , sizeof step);
  int cnt; scanf("%d",&cnt);
  for(int i=0;i<cnt;++i){
   scanf("%s",&buf);
   ++step[ ID(buf[0]) ];
   ++step[ ID(buf[1]) ];
                        }
  for(int i=0;i<MAXN;++i)
   if(step[i] & 1)nech[i] = true;

  scanf("%d",&cnt);
  for(int i=0;i<cnt;++i){
   scanf("%s",&buf);
   fo[ ID(buf[0]) ].pb( ID(buf[1]) );
   fo[ ID(buf[1]) ].pb( ID(buf[0]) );
                        }
  A::N = 55;
  int brn = 0;
  for(int i=0;i<MAXN;++i){
   if(!nech[i])continue;
   ++brn;
   //cout<<i<<endl;
   memset(USE , 0 , sizeof USE);
   dfs(i);
   for(int j=i+1;j<MAXN;++j)
    if(USE[j] && nech[j]){
     //cout<<i<<' '<<j<<endl;
     //g[i].pb(j) , g[j].pb(i);
     A::fo[i].pb(j); A::fo[j].pb(i);
                         }
                         }
  int MSZ = A::max_matching();
  if(2*MSZ == brn)printf("YES\n");
  else printf("NO\n");
}
int main(){
  int Q; scanf("%d",&Q);
  while(Q--)doit();
  return 0;
}

