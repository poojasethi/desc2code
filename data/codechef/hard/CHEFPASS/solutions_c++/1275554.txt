#include <iostream>
#include <fstream>
#include <sstream>
#include <stack>
#include <queue>
#include <map>
#include <vector>
#include <string.h>
#include <list>
#include <algorithm>
#include <cmath>
#include <set>

#define for0(i,n) for (int i=0; i<n; i++)
#define forr(i,n) for (int i=n-1; i>=0; i--)
#define fori(i,a,b) for (int i=a; i<=b; i++)
#define iter(v,x) for(vector<x>::iterator it=v.begin(); it!=v.end(); it++)
#define vec(x) vector<x>
#define pb push_back
#define ms(a,z) memset(a,z,sizeof(a))
#define mp make_pair
#define gl(x) getline(cin,x,'\n')
#define nl cout<<"\n";
#define pr(x) cout<<(x)<<" ";
#define printv(v) for(int _=0; _<v.size(); _++) cout<<v[_]<<" "; cout<<"\n";
#define printa(a,s) for (int _=0; _<s; _++) cout<<a[_]<<" "; cout<<"\n";
#define print2D(a,m,n) for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<" "; cout<<"\n";} cout<<"\n";
#define sum(a,l,s) int s=0; for (int _=0; _<l; _++) s+=a[_];
#define fill2D(a,x,m,n) for (int _=0; _<m; _++) {for (int __=0; __<n; __++) a[_][__]=x;}
#define X first
#define Y second
#define sqr(x) 1LL*(x)*(x)
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define all(a) a.begin(),a.end()

using namespace std;
typedef long long ll;

int INF = 999999999;
double EPSILON = 0.00000001;
int node[256];
int degree[55];
bool bad[55];
vec(int) adj[55];
bool visited[55];

int bfs(int start)
{
    int res = 0;
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (not q.empty()){
        int top = q.front(); q.pop();
        if (bad[top]) res++;
        iter(adj[top],int){
            if (not visited[*it]){
                visited[*it] = true;
                q.push(*it);
            }
        }
    }
    return res;
}

int main()
{
    //freopen("password_recovery.txt","r",stdin);
    int cases;
    cin >> cases;
    for0(casen,cases){
        int n;
        cin >> n;
        ms(node,-1);
        int num=0;
        ms(degree,0);

        for0(i,n){
            string z;
            cin >> z;
            int a,b;
            if (node[z[0]] == -1){
                node[z[0]] = num;
                num++;
            }
            a = node[z[0]];
            if (node[z[1]] == -1){
                node[z[1]] = num;
                num++;
            }
            b = node[z[1]];
            degree[a]++;
            degree[b]++;
        }
        for0(i,52){
            bad[i] = degree[i]%2;
            adj[i].clear();
        }

        cin >> n;
        for0(i,n){
            string z;
            cin >> z;
            int a,b;
            if (node[z[0]] == -1){
                node[z[0]] = num;
                num++;
            }
            a = node[z[0]];
            if (node[z[1]] == -1){
                node[z[1]] = num;
                num++;
            }
            b = node[z[1]];
            adj[a].pb(b);
            adj[b].pb(a);
        }

        ms(visited,false);
        bool ans = true;
        for0(i,num){
            if (bad[i] and not visited[i]){
                int size = bfs(i);
                //pr(i) pr(size) nl
                if (size%2==1){
                    ans = false;
                    break;
                }
            }
        }

        if (ans) cout<<"YES\n";
        else cout<<"NO\n";
    }
    return 0;
}
