#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long ll;

// TO test primality I am using the Miller-Rabin test
// Author: thecodekaiser

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <map>
#include <string>
#include <queue>
#include <stack>

using namespace std;

typedef long long ll;

#define MOD 1000000007
#define INF 2000000000

// Method to return (a*b) % c
ll modMul(ll a, ll b, ll c)
{
	ll res = 0, y = a % c;
	while(b)
	{
		if(b & 1)
		{
			res = (res + y);
			while(res >= c)
				res -= c;
		}

		y = (y*2);					// Doubling the base
		while(y >= c)
			y -= c;

		// Could use y = (2*y) % c

		b >>= 1;
	}
	while(res >= c)
				res -= c;

	return res;
}

// Method to return (a^b) % c
ll modPow(ll a, ll b, ll c)
{
	ll res = 1, y = a%c;
	while(b)
	{
		if(b & 1)
		{
			res = (res * y) % c;
		}

		y = (y*y) % c;					// Squaring the base

		b >>= 1;
	}

	return res;
}

/* Now we have the Miller-Rabin Test
   Rabin-Miller test
   Miller-Rabin primality test, iteration signifies the accuracy of the test 
   1.] Fermat's Little Theorem
		According to Fermat's Little Theorem if p is a prime number and a is a positive integer less than p, then

		a^p = a ( mod p )
	or alternatively:
		a^(p-1) = 1 ( mod p ) 
  2.] If p is prime and x^2 = 1 ( mod p ), then x = +1 or -1 ( mod p ). We could prove this as follows:

		x^2			= 1 ( mod p )
		x^2 - 1		= 0	( mod p )
	   (x-1)(x+1)	= 0	( mod p )
    
  Algorithm
  Let p be the given number which we have to test for primality.
  First we rewrite p-1 as (2^d)*s.
  Now we pick some a in range [1,p-1] and then check whether a^s = 1 ( mod p ) or a(s*(2^r)) = -1 ( mod p ). 
  If both of them fail, then p is definitely composite. Otherwise p is probably prime.
  We can stop after a fixed no of iterations and claim that either p is definitely composite or definitely prime.
*/
int miller(ll p , int iter)
{
	if(p < 2)
		return 0;

	if(p == 2)
		return 1;

	if(!(p&1))
		return 0;

	int i;
	ll s = p-1, a, temp, mod;

	while(!(s&1))
		s >>= 1;

	for(i = 0; i < iter; i++)
	{
		a = rand()%(p-1) + 1;
		temp = s;
		mod = modPow(a,temp,p);
		while(temp != p-1 && mod != 1 && mod != p-1)
		{
			mod = (mod*mod) % p;
			temp <<= 1;
		}
		if(mod != p-1 && temp % 2 == 0)
		{
			return 0;
		}
	}
	return 1;
}

int main()
{
	int t;
	ll p;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld",&p);
		int flag = 1;

		if(miller(p,10) && p != 2 && p != 17)
			flag = 0;

		if(p == 16 || p == 17*2 || p == 17*17)
			flag = 0;

		if(flag)
			printf("Mike\n");
		else
			printf("Tom\n");
	}
	return 0;
}

