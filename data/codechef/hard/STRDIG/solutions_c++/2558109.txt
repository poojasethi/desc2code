//#undef _GLIBCXX_DEBUG

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <valarray>
#include <vector>

using namespace std;

#define foreach(iter,cont) for(typeof((cont).begin()) iter = (cont).begin(); iter != (cont).end(); ++iter)
#define min3(a, b, c) min(a, min(b, c))
#define max3(a, b, c) max(a, max(b, c))
#define inf 1000000008
#define eps 1.0e-10L
#define divisible(a, b) (((a) / (b)) * (b) == (a))
static const long long p = 1000000007;
__attribute__((unused)) static bool eq(long double a, long double b)  { return (a == b ? true : (a * b == 0 ? abs(a - b) < eps : abs(a - b) / (abs(a) + abs(b)) < eps));  }
__attribute__((unused)) static long long modp(long long n, long long m) { long long r = n % m; return r >= 0 ? r : r + m; }
__attribute__((unused)) static long long gcd(long long a, long long b) { return (a < 0 ? gcd(-a, b) : (b < 0 ? gcd(a, -b) : (!a && !b ? 1 : (b ? gcd(b, a % b) : a)))); }
template<class T> static int len(const T& cont) { return (int) cont.size(); }

// BEGIN CUT HERE
template<class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << "(" << p.first << ", " << p.second << ")"; }
template<class T> ostream &operator<<(ostream& os, const vector<T> &vec) { os << "[ "; for(size_t i = 0; i < vec.size(); i++) { os << vec[i]; if(i != vec.size() - 1) { os << ", "; } } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const list<T> &l) { os << "[ "; bool first = true; for(typename list<T>::const_iterator lstIt = l.begin(); lstIt != l.end(); ++lstIt) { if(!first) { os << ", "; } first = false; os << *lstIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const deque<T> &d) { os << "[ "; bool first = true; for(typename deque<T>::const_iterator dIt = d.begin(); dIt != d.end(); ++dIt) { if(!first) { os << ", "; } first = false; os << *dIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const vector<vector<T> > &mat) { for(size_t i = 0; i < mat.size(); i++) { if(i) os << endl; os << mat[i]; } return os; }
template<class T> ostream &operator<<(ostream &os, const set<T> &s) { os << "{ "; bool first = true; for(typename set<T>::const_iterator setIt = s.begin(); setIt != s.end(); ++setIt) { if(!first) { os << ", "; } first = false; os << *setIt; } return os << " }"; }
template<class T, class U> ostream &operator<<(ostream &os, const map<T, U> &m) { os << "{ "; bool first = true; for(typename map<T, U>::const_iterator mapIt = m.begin(); mapIt != m.end(); ++mapIt) { if(!first) { os << ", "; } first = false; os << mapIt->first << " = " << mapIt->second; } return os << " }"; }
enum CONSOLE_FG { FG_BLACK, FG_RED, FG_GREEN, FG_YELLOW, FG_BLUE, FG_MAGENTA, FG_CYAN, FG_WHITE };
enum CONSOLE_STYLE { STYLE_NONE, STYLE_BOLD };
ostream& operator<<(ostream &os, CONSOLE_FG color) { return os << "\x1b[" << ((int) color + 30) << "m"; }
ostream& operator<<(ostream &os, CONSOLE_STYLE style) { return os << "\x1b[" << (style == STYLE_NONE ? 0 : 1) << "m"; }
// END CUT HERE

int t, n;
string q, curStr;

void inc(string &str) {
	int overflow = 0;
	for(int pos = len(str) - 1; pos >= 0; pos--) {
		if(str[pos] == '?') {
			/*
			if(overflow) {
				str[pos] = '*';
			}
			*/
			overflow = 0;
			break;
		}

		if(pos == len(str) - 1 || overflow) {
			str[pos]++;
		}

		overflow = str[pos] > '9' ? 1 : 0;
		if(str[pos] > '9') {
			str[pos] = '0';
		}
	}

	if(overflow) {
		str.insert(0, 1, '1');
	}
}

bool valid(const string &str) {
	if(str[0] == '0') {
		return false;
	}

	string num = str;
	for(int i = 0; i < len(num); i++) {
		if(i == 0 || num[i] == '*') {
			num[i] = '1';
		} else if(num[i] == '?') {
			num[i] = 0;
		}
	}

	stringstream numParser;
	long long numVal;
	numParser << num;
	numParser >> numVal;

	return numVal > 0 && numVal <= 1000000000;	
}

bool match(string &str, int offset) {
	for(int i = 0; i < min(len(str), len(q) - offset); i++) {
		if(str[i] == '?') {
			str[i] = q[offset + i];
		} else if(str[i] == '*' && q[offset + i] == '0') {
			return false;
		} else if(str[i] == '*') {
			str[i] = q[offset + i];
		} else if(str[i] != q[offset + i]) {
			return false;
		}
	}

	return true;
}

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) {
	cin >> t;

	while(t--) {
		cin >> q;
		n = len(q);


		bool found = false;

		bool allZ = true;
		for(int i = 0; i < n; i++) {
			if(q[i] != '0') {
				allZ = false;
				break;
			}
		}

		if(allZ) {
			found = n <= 9;
		} else {

#ifdef DEBUG
			cout << q << endl;
			cout << string(len(q), '-') << endl;
			cout << endl;
#endif
			for(int numDigits = 1; !found && numDigits <= min(10, n); numDigits++) {
				for(int numInFirst = 1; !found && numInFirst <= numDigits; numInFirst++) {

#ifdef DEBUG
					cout << numDigits << " digits with " << numInFirst << " in first" << endl;
#endif

					string cur = q.substr(0, numInFirst);
					while(len(cur) < numDigits) {
						cur = "?" + cur;
					}

					if(!valid(cur)) {
						continue;
					}

					bool matches = true;
					int curOffset = numInFirst;
					while(curOffset < n) {
						inc(cur);
#ifdef DEBUG
						cout << "  At offset " << curOffset << " with cur value of " << cur << endl;
#endif
						if(!match(cur, curOffset) || !valid(cur)) {
							matches = false;
							break;
						}
						curOffset += len(cur);
					}

					if(matches) {
						found = true;
					}
				}
			}
		}

		printf("%s\n", found ? "YES" : "NO");

	}

	return 0;
}
