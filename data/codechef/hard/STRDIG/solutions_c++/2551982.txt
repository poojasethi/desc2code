#include"iostream"
#include"stdio.h"
#include"cstring"
using namespace std;
char Q[100001];
char NM[15];
int n;
char* prev(int &dig) {
    int i=14;
    while(NM[i]--=='0')NM[i--]='9';
    return NM+15-dig;
}
char* next(int& dig) {
    int i=14;
    while(NM[i]++=='9')NM[i--]='0';
    dig = max(dig, 15-i);
    return NM+15-dig;
}
bool solve2(int offset, int len) { // is concatenation of two consecutive integers
    if(len>9)
       return strncmp(Q+offset, "1000000000", n-offset)==0 and strncmp(Q, "999999999", offset)==0;
    if(Q[offset]=='0') return false; // leading zeros
    memset(NM, '0', 15);
    memcpy(NM+15-offset, Q, offset);
    int overlap = n-len, dig = offset;
    return (strncmp(Q+n-overlap, next(dig)+dig-offset, overlap)==0);
}
bool solve(int offset, const int len) {
    if(offset+len>n)
        return solve2(offset, len);
    long long num=0;
    int digits=len;
    if(Q[offset]=='0') return false; // leading '0'
    memset(NM, '0', 15);
    memcpy(NM+15-digits, Q+offset, digits);
    for(int i=offset; i<offset+digits; i++)
        num = num * 10 + Q[i] - '0';
    //check the part before offset
    if(strncmp(Q, prev(digits)+digits-offset, offset)!=0) return false;
    for(;offset<n;offset+=digits, num++) {
        char* strnum = next(digits);
        if(num>1000000000 or strncmp(Q+offset, strnum, min(digits, n-offset))!=0) return false;
    }
    cerr << " offset "<<offset<< " len = "<<len;
    return true;
}
bool trivial() { // consists of only one number
    if(n<=9) return true;
    if(strcmp(Q, "1000000000")==0) return true;
    return false;
}
int main() {
    int T;
    scanf("%d", &T);
    while(T--) {
        scanf("%s", Q);
        n = strlen(Q);
        int len_upper = 9 + (n<100?1:0);
        bool solved = trivial();
        for(int offset=0; solved==0 and offset<len_upper; offset++)
            for(int len = offset+1; solved==0 and len<=len_upper; len++)
                solved = solve(offset, len);
        printf("%s\n", solved?"YES":"NO");
    }
}