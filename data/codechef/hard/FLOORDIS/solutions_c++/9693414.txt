//#include<bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <queue>
#include <stack>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <set>
using namespace std;
#define w(t) while(t--)
#define S(x) scanf("%d",&x)
#define SLL(x) scanf("%lld",&x)
#define P(x) printf("%d\n",x)
#define fl(i , a, b) for(i = (int)a; i<(int)b; i++)
#define mem(a , value) memset(a , value , sizeof(a))
#define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++)
#define MOD 1000000007
#define MAX 1000000010
#define ll long long
#define all(v) v.begin(),v.end()
#define mp make_pair
#define pb push_back
#define f first
#define s second
typedef pair<int,int> pp;
#define N 1002
int n , m , W , KK, R , x,  y ,c1,c2, walls[N][N][4] , src , dst , g[N][N]; 
std::vector<pair <pp , pp > > cost ,ac; 
std::map<pair <pp , pp >, int> m1;
int par[N*N] , vis[N*N] , pa;
std::vector<int> v[N];
int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1}; 
queue <int> q;

int bfs()
{
    for(int i = 0; i<=502; i++)
    {
        par[i] = -1; vis[i] =0; 
    }
    q.push(src);
    vis[src] =1; 
    par[src] = -1; 
    while(!q.empty())
    {
        int el = q.front();
        q.pop();
        for (int i = 0; i < (int)v[el].size(); ++i)
        {
            int nx = v[el][i];
            if(!vis[nx] && g[el][nx]>0)
            {
                q.push(nx);
                vis[nx] = 1;
                par[nx] = el; 
            }
        }
    }
    return (vis[dst] == 1); 
}
int update()
{
    int ans = MAX; 
    int u = dst; 
    while(par[u]!=-1)
    {
        ans = min(ans, g[par[u]][u]); 
        u = par[u];  
    }
    u = dst;
    while(par[u]!=-1)
    {
        g[par[u]][u]-= ans;
        g[u][par[u]]+=ans; 
        u = par[u];
    }
    return ans; 
}
ll flow()
{
    ll ans=0 ; 
    while(bfs())
    {
        ans+=update();
    }
    return ans; 
}

int find(int x)
{
    if(x==par[x]) return x;
    return (par[x] = find(par[x])); 
}
void join(int x , int y , int x1 , int y1)
{
    int p1 = find( (x-1)*m + y ); int p2 = find( (x1-1)*m + y1 ); 
    if(p1!=p2)
        par[p2] = p1;
}
int valid(int i , int j )
{
    if(i>=1 && i<=n && j>=1 && j<=m) return 1;
    return 0; 
}
void solve()
{
    int i , j , k ;
    int cnt = 1;
    for(int i =1 ;i<=1000002; i++)
    {
        par[i] = cnt; 
        cnt++; vis[i] = 0 ; 
    }
    // made union of all the coordinates 
    fl(i,1,n+1)
    {
        fl(j,1,m+1)
        {
            fl(k,0,4)
            {
                int nx = dx[k] +i ;int ny = dy[k] + j;
                if(valid(nx, ny))
                {
                    if(walls[i][j][k] == 0 )
                        join(i , j , nx , ny); 
                }
            }
        }
    }
    // cout << endl << endl; 
    /*fl(i,1,n+1)
    {
        fl(j,1,m+1){
            cout <<find( (i-1)*m + j ) << " "; 
        }
        cout << endl;
    }*/
    // give  parents an id with id starting equal to 1; 
    mem(vis,0);
    cnt =1;
    fl(i,1,n+1)
    {
        fl(j,1,m+1)
        {
            pa = find( (i-1)*m + j );
            if(vis[pa] == 0){
                vis[pa] = cnt; 
                cnt++;
            }
        }
    }
    /*cout << endl << endl ;
    fl(i,1,n+1)
    {
        fl(j,1,m+1)
        {
            cout << vis[find( (i-1)*m + j )] << " " ;
        }
        cout << endl;
    }*/
    // make flow graph 
    fl(i,0,ac.size())
    {
        x = ac[i].f.f; y = ac[i].f.s; int p1 = find( (x-1)*m + y ); 

        x = ac[i].s.f; y = ac[i].s.s; int p2 = find( (x-1)*m + y );

        p1 = vis[p1]; p2 = vis[p2]; 
        if(p1 > p2 ) swap(p1,p2);
        // yahan galat aa raha hai. 
       /* if(p1 == p2)
        {
            while(1){

            }
        }*/
        if(p1!=p2)
        g[p1][p2] += (KK);
        g[p2][p1] += (KK);
    }   
    // cout << " yes 1 " << endl; 
    fl(i,1,501)
    {
        fl(j,i+1,501)
        {
            // if(g[i][i] >0 )cout << "DEBUG " << endl; 
            if(g[i][j] > 0 ){
                // cout << i << " " <<j <<" " << g[i][j] <<" "<< g[j][i]<<  endl ;
                v[i].pb(j);
                v[j].pb(i);
            }
        }
    }
    fl(i,0,R)
    {
        x = cost[i].f.f ; y = cost[i].f.s; 
        int p1 = find( (x-1)*m + y );
        p1 = vis[p1]; 
        v[src].pb(p1); 
        v[p1].pb(dst) ;
        g[src][p1]+= cost[i].s.f; 
        g[p1][dst] += cost[i].s.s; 
    }
}
int main()
{
    //std::ios_base::sync_with_stdio(false);
    int i, x1 , y1 , x2 , y2;
    cin >> n >> m >> W >> KK >> R;
    fl(i,0,W)
    {
        cin >> x1 >> y1 >> x2 >> y2 ;
        pp t1 = mp(x1 , y1) ; pp t2 = mp(x2,y2);
        if(t1 > t2) swap(t1,t2);
        if(m1.find(mp(t1, t2)) == m1.end())
        {
            m1[mp(t1,t2)] = 1;
            ac.pb(mp( mp(x1,y1) , mp(x2,y2) )); // walls between these coordinates .
        }
        if(x1==x2)
        {
            if(y1 > y2) swap(y2,y1);
            walls[x1][y1][2] = 1; // to the right 
            walls[x2][y2][3] = 1; // left 
        }
        else if(y1 == y2)
        {   
            if(x1 < x2) swap(x1,x2);
            walls[x1][y1][1] = 1; // top
            walls[x2][y2][0] = 1; // bottom 
        }
    } 
    // cout << "edges end " << endl; 
    src = 0; dst = 502; 
    fl(i,0,R)
    {
        cin >> x >> y >> c1 >> c2; 
        cost.pb(mp( mp(x,y) , mp(c1,c2) )); 
    }
    solve();
    printf("%lld\n", flow());
    return 0;
}
/*
// wa on this test CASE: Correct:248 Received:221
3 3 9 10 6 
1 1 1 2 
1 2 1 3 
1 2 2 2 
1 3 2 3 
2 2 2 3 
2 3 3 3 
3 1 3 2
3 2 2 2 
3 2 3 3

1 1 4 6 
1 2 6 5 
1 3 4 4
2 3 7 5 
3 2 1 1 
3 3 2 1


1 1 45 65 
1 2 61 50 
1 3 45 47
2 3 72 51 
3 2 12 19 
3 3 21 16 

1 1 4 6 
1 2 6 5 
1 3 4 4
2 3 7 5 
3 2 1 1 
3 3 2 1 

*/