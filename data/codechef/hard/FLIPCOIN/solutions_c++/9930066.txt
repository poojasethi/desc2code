
#include <bits/stdc++.h>
using namespace std;
 
int n, q, d, A, B;
int tree[400007], lazy[400007];
 
void update(int node, int a, int b, int i, int j)
{
	if(lazy[node] != 0)
	{
		tree[node] = (b - a + 1) - tree[node];
 
		if(a != b)
		{
			lazy[2*node] = 1 - lazy[2*node];
			lazy[2*node + 1] = 1 - lazy[2*node + 1];
		}
 
		lazy[node] = 0;
	}
 
	if(a > b || a > j || b < i)
		return ;
 
	if(a >= i && b <= j)
	{
		tree[node] = (b - a + 1) - tree[node];
 
		if(a != b)
		{
			lazy[2*node] = 1 - lazy[2*node];
			lazy[2*node + 1] = 1 - lazy[2*node + 1];
		}
 
		return ;
	}
 
	int mid = (a + b)/2;
 
	update(2*node, a, mid, i, j);
	update(2*node + 1, mid + 1, b, i, j);
 
	tree[node] = tree[2*node] + tree[2*node + 1];
}
 
int query(int node, int a, int b, int i, int j)
{
	if(a > b || a > j || b < i)
		return 0;
 
	if(lazy[node] != 0)
	{
		tree[node] = (b - a + 1) - tree[node];
 
		if(a != b)
		{
			lazy[2*node] = 1 - lazy[2*node];
			lazy[2*node + 1] = 1 - lazy[2*node + 1];
		}
 
		lazy[node] = 0;
	}
 
	if(a >= i && b <= j)
		return tree[node];
 
	int mid = (a + b)/2;
	
	int q1 = query(2*node, a, mid, i, j);
	int q2 = query(2*node + 1, mid + 1, b, i, j);
 
	return (q1 + q2);
}
 
int main()
{
	scanf("%d%d",&n,&q);
 
	memset(tree, 0, sizeof(tree));
	memset(lazy, 0, sizeof(lazy));
 
	while(q--)
	{
		scanf("%d%d%d",&d,&A,&B);
 
		if(d == 0)
			update(1, 0, n-1, A, B);
		else if(d == 1)
			printf("%d\n",query(1, 0, n-1, A, B));
	}
	return 0;
} 
