/*Useful info
__builtin_popcount(n) counts number of active bits.
__builtin_popcountl(n) for long and ll for long long

to_string(n): Converts a number from int to string*/

//My shortcuts
#include<bits/stdc++.h>
#define ll long long int
#define ull unsigned long long int
#define sf(n) scanf("%d",&n);
#define sf2(a,b) scanf("%d %d",&a,&b);
#define sf3(a,b,c) scanf("%d %d %d",&a,&b,&c);
#define sf4(a,b,c,d) scanf("%d %d %d %d",&a,&b,&c,&d);
#define sfl(n) scanf("%lld",&n);
#define sful(n) scanf("%llu",&n);
#define pf(n) printf("%d",n);
#define pfl(n) printf("%lld",n);
#define pful(n) printf("%llu",n);
#define ps printf(" ");
#define pn printf("\n");
#define put(a) printf("%s",a);
#define cut(n,val) memset(n,val,sizeof(n));
#define pub push_back()
#define ln size()
#define ff first
#define ss second
#define mpr make_pair()
#define bpop(n) __builtin_popcount(n)
#define fo(in,out) for(int i=in;i<out;i++)
#define st(n) to_string(n) //Works only in c++11
const long long int mod=1e9+7;
using namespace std;
//FAST IO->
//Advisable to use scanf and printf since it passes most time limits.
/*inline void read(int &a)
{
  register int c;
  a = 0;
  do c = getchar_unlocked(); while (c < '0');
  do{
    a = (a << 1) + (a << 3) + c - '0';
    c = getchar_unlocked();
  } while (c >= '0');
}
inline void print(int a)
{
  int s[25], t = -1;
  do
  {
    s[++t] = a % 10 + '0';
    a /= 10;
  } while (a > 0);
  while (t >= 0)putchar_unlocked(s[t--]);
  putchar_unlocked('\n');
}
/*inline ll readstr(char s[])
{
  register ll i = 0, c;
  do c = getchar_unlocked(); while (c < '0' || c > '9');
  do{
    s[i++] = c;
    c = getchar_unlocked();
  } while (c >= '0' && c <= '9');
  s[i] = '\0';
  return i;
}*/
//Functions->
#define N 100001
int seg[4*N+3];
bool lazy[4*N+3];
void update(int pos, int a, int b, int i, int j) 
{
	if(lazy[pos])
	{
		//This node needs to be updated i.e flagged down as child so as to support the upper parent nodes
		seg[pos] = (b - a + 1) -seg[pos];
		lazy[pos]=false;    // Update it
        	if(a < b)
        	{
            		lazy[(pos<<1)+1] =!lazy[(pos<<1)+1];                  // Mark child as lazy
            		lazy[(pos<<1)+2] =!lazy[(pos<<1)+2];                // Mark child as lazy
        	}
                                        // Reset it
	}	
    
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;
    
  	if(a>=i && b<=j) 
	{ 	// Leaf node
    		seg[pos] =(b-a+1)-seg[pos];	  //Adding cumulative value
    		
		if(a<b)
		{
			lazy[(pos<<1)+1] =!lazy[(pos<<1)+1];                  // Mark child as lazy
            lazy[(pos<<1)+2] =!lazy[(pos<<1)+2];      
		}
		return ;
	}
	int mid=(a+b)/2;
	update((pos<<1)+1, a, mid, i, j); // Updating left child
	update(2+(pos<<1), 1+mid, b, i, j); // Updating right child

	if(a<b)
		seg[pos] = seg[(pos<<1)+1]+seg[(pos<<1)+2]; // Updating root with max value

	//updating interval segment tree.
}
int range(int qlow,int qhigh,int low,int high,int pos)
{
	if(low>high || qlow>high || qhigh<low)
		return 0;

	if(lazy[pos])
    	{
        	// This node needs to be updated
			lazy[pos]=false;
        	seg[pos] = (high - low + 1) - seg[pos];            // Update it
        	if(low < high)
        	{
            		lazy[(pos<<1)+1] =!lazy[(pos<<1)+1];
            		lazy[(pos<<1)+2] =!lazy[(pos<<1)+2];          	
        	}
	      	                   
    	}
	
	if(qlow<=low && qhigh>=high)
		return seg[pos];
	
	int mid=(low+high)/2;
	int a=range(qlow,qhigh,low,mid,2*pos+1);
	int b=range(qlow,qhigh,mid+1,high,2*pos+2);
	
	return a+b;	   
}
//Driver Program->
int main()
{
	int n,m;
	sf(n);sf(m);
	
	cut(seg,0);
	cut(lazy,false);
	while(m--)
	{
		int idx,l,r;
		sf(idx);sf(l);sf(r);
		
		if(idx==0){
			update(0,0,n-1,l,r);
		}
		else
		{
			pf(range(l,r,0,n-1,0));pn;
		}
		
//	  	  for(int i=0;i<7;i++)
//	  	  	  cout<<seg[i]<<" ";
//	  	  cout<<endl;
	}
	return 0;
}	 	 

