#include<bits/stdc++.h>
using namespace std;
int lazy[300111]={};
class segtree{
	public:
	int heads;
	void merge(segtree a, segtree b){
		this->heads=a.heads+b.heads;
	}
	void leaf(){
		this->heads=0;
	}
}node[300111];
int rev(int a){
	if(lazy[a])return 0;
	else return 1;	
}
void buildtree (int cur, int left, int right){
	if(left==right){
		node[cur].leaf();
		return;
	}
	int mid=(left+right)/2;
	buildtree(2*cur, left, mid);
	buildtree(2*cur+1, mid+1, right);
	node[cur].merge(node[2*cur], node[2*cur+1]);
}

void update(int cur, int l, int r, int left, int right){
	if(lazy[cur]){
		node[cur].heads=right-left+1-node[cur].heads;
		if(left!=right){
			lazy[2*cur]=rev(2*cur);
			lazy[2*cur+1]=rev(2*cur+1);
		}
		lazy[cur]=0;
	}
	if(left>r||right<l||left>right)return;
	if(left>=l&&right<=r){
		node[cur].heads=right-left+1-node[cur].heads;
		if(left!=right){
			lazy[2*cur]=rev(2*cur);
			lazy[2*cur+1]=rev(2*cur+1);
		}
		return;
	}
	int mid=(left+right)/2;
	update(2*cur, l, r, left, mid);
	update(2*cur+1, l, r, mid+1, right);
	node[cur].merge(node[2*cur], node[2*cur+1]);
}

int query(int cur, int l, int r, int left, int right){
	int mid=(left+right)/2;
	if(lazy[cur]){
		node[cur].heads=right-left+1-node[cur].heads;
		if(left!=right){
			lazy[2*cur]=rev(2*cur);
			lazy[2*cur+1]=rev(2*cur+1);
		}
		lazy[cur]=0;
	}
	if(left>right||right<l||left>r){
		return 0;
	}
	if(left>=l&&right<=r){
		return node[cur].heads;
	}
	return query(2*cur, l, r, left, mid)+query(2*cur+1, l, r, mid+1, right);
}
int main(){
	int type, l, r, n, q;
	cin>>n>>q;
	buildtree(1, 0, n-1);
	while(q--){
		cin>>type>>l>>r;
		if(type){
			cout<<query(1, l, r, 0, n-1)<<endl;
		}
		else{
			update(1, l, r, 0, n-1);
		}
	}
}