 
#include<bits/stdc++.h>
using namespace std;
int segment[400000];
int lazy[400000];
void constructtree(int low,int high,int pos)
{
    if(low==high)
    {
        segment[pos]=1;
        return ;
    }
    int mid=(low+high)/2;
    constructtree(low,mid,2*pos+1);
    constructtree(mid+1,high,2*pos+2);
    segment[pos]=(segment[2*pos+1]+segment[2*pos+2]);
}
void update(int low ,int high,int qlow,int qhigh,int pos)
{
    if(lazy[pos]==1)
    {
        segment[pos]=high-low+1-segment[pos];
        if(low!=high)
        {
        lazy[2*pos+1]=!lazy[2*pos+1];
        lazy[2*pos+2]=!lazy[2*pos+2];
        }
 
        lazy[pos]=0;
    }
    if(qhigh<low||qlow>high||low>high)
        return ;
    if(low>=qlow && high<=qhigh)
	{
		segment[pos]=high-low+1-segment[pos];
		if(low!=high)
        {
        lazy[2*pos+1]=!lazy[2*pos+1];
        lazy[2*pos+2]=!lazy[2*pos+2];
        }
		return;
	}
	int mid=(low+high)/2;
	update(low,mid,qlow,qhigh,2*pos+1);
    update(mid+1,high,qlow,qhigh,2*pos+2);
     segment[pos]=segment[2*pos+1]+segment[2*pos+2];
}
int sum(int qlow,int qhigh,int low,int high,int pos)
{
     if(lazy[pos]==1)
    {
        segment[pos]=high-low+1-segment[pos];
        if(low!=high)
        {
        lazy[2*pos+1]=!lazy[2*pos+1];
        lazy[2*pos+2]=!lazy[2*pos+2];
        }
 
        lazy[pos]=0;
    }
    if(qhigh<low||qlow>high||low>high)
        return 0;
        if(qlow<=low&&qhigh>=high)
            return segment[pos];
        int mid=(low+high)/2;
        int a=sum(qlow,qhigh,low,mid,2*pos+1);
        int b=sum(qlow,qhigh,mid+1,high,2*pos+2);
        return (a+b);
}
int main()
{
    int n,q,i,opt,a,b,j;
    scanf("%d%d",&n,&q);
    constructtree(0,n-1,0);
    for(i=0;i<q;i++)
    {
        scanf("%d%d%d",&opt,&a,&b);
        if(opt==0)
            update(0,n-1,a,b,0);
 
        if(opt==1)
            {
 
                printf("%d\n",b-a+1-sum(a,b,0,n-1,0));
            }
    }
    return 0;
}