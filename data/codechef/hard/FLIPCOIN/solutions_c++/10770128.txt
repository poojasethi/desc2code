#include<bits/stdc++.h>
//using segment tree
using namespace std;
int *tree,*lazy;
//update tree - interval based
void updateRange(int node,int start,int end,int l,int r){
    //cout<<"start:"<<start<<" end:"<<end<<" node:"<<node;
    if(lazy[node]){
        tree[node] = (end-start+1) - tree[node];
        if(start!=end){
            lazy[node*2] = 1 -lazy[node*2];
            lazy[node*2+1] = 1 -lazy[node*2+1];
        }
        lazy[node] = 0;
    }
    if(start>end || start>r || end<l){
        //cout<<"\n";
        return;
    }
    if(start>=l && end<=r){
        tree[node] = (end-start+1) - tree[node];
        if(start!=end){
            lazy[node*2] = 1 -lazy[node*2];
            lazy[node*2+1] = 1 -lazy[node*2+1];
        }
        return;
    }
    //cout<<"\n";
    int mid = (start+end)/2;
    updateRange(2*node,start,mid,l,r);
    updateRange(2*node+1,mid+1,end,l,r);
    tree[node] = tree[node*2]+tree[node*2+1];
}

int queryRange(int node,int start,int end,int l,int r){
    if(start>r || end<l){
        return 0;
    }
    if(lazy[node]){
		tree[node] = (end-start+1) - tree[node];
		if(start != end){
			lazy[node<<1] = 1-lazy[node<<1];
			lazy[(node<<1)+1] = 1-lazy[(node<<1)+1];
		}
		lazy[node] = 0;
	}
    if(start>=l && end<=r){
        return tree[node];
    }
    int mid = (start+end)/2;
    return queryRange(node*2,start,mid,l,r)+queryRange(node*2+1,mid+1,end,l,r);
}
void displayTree(int n){
    for(int i=1;i<n;i++){
        cout<<tree[i]<<" ";
    }
    cout<<endl;
}

int main(){
    int n,q,i,l,r,x;
    scanf("%d%d",&n,&q);
    tree = new int[300000];
    lazy = new int[300000];
    while(q--){
        scanf("%d%d%d",&x,&l,&r);
        if(x)
            printf("%d\n",queryRange(1,0,n-1,l,r));
        else
            updateRange(1,0,n-1,l,r);
        //displayTree(2*n);
    }
    return 0;
}
