#include <bits/stdc++.h>

using namespace std;

struct node {
	int heads;
	int flips;
};

struct node *tree = new struct node[500005];

void build_tree(int node, int a, int b, int start, int end) {
	if(a > b) {
		return;
	}
	if(a > end || b < start) {
		return;
	}
	if(a == start && b == end) {
		tree[node].heads = (end - start + 1) - tree[node].heads;
		tree[node].flips ++;
		return;
	}

	int mid = (start + end) / 2;

	if(b <= mid) {
		build_tree(node * 2, a, b, start, mid);
	} else if(a > mid) {
		build_tree(node * 2 + 1, a, b, mid + 1, end);
 	} else {
		build_tree(node * 2, a, mid, start, mid);
		build_tree(node * 2 + 1, mid + 1, b, mid + 1, end);
	}

	tree[node].heads = tree[node * 2].heads + tree[node * 2 + 1].heads;
	if(tree[node].flips & 1) {
		tree[node].heads = (end - start + 1) - tree[node].heads;
	}
}

int query_tree(int node, int a, int b, int start, int end, int flips) {
	if(start > end) {
		return 0;
	}
	if(a > end || b < start) {
		return 0;
	}
	if(a == start && b == end) {
		if(flips & 1) {
			return (end - start + 1) - tree[node].heads;
		} else {
			return tree[node].heads;
		}
	}

	flips += tree[node].flips;

	int mid = (start + end) / 2;

	if(b <= mid) {
		return query_tree(node * 2, a, b, start, mid, flips);
	} else if(a > mid) {
		return query_tree(node * 2 + 1, a, b, mid + 1, end, flips);
 	} else {
		return query_tree(node * 2, a, mid, start, mid, flips) + query_tree(node * 2 + 1, mid + 1, b, mid + 1, end, flips);
	}
}

int main(int argc, char const *argv[]) {
	cin.sync_with_stdio(false);
	int n, k;
	int type, x, y;
	cin >> n >> k;
	while(k --) {
		cin >> type >> x >> y;
		if(type == 0) {
			build_tree(1, x, y, 0, n - 1);			
		} else {
			cout << query_tree(1, x, y, 0, n - 1, 0) << endl;
		}
	}
	return 0;
}