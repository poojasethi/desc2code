#include <bits/stdc++.h>
#define ll long long
#define maxn 100005
#define slld(t) scanf("%lld",&t)
#define sd(t) scanf("%d",&t)
#define pd(t) printf("%d\n",t)
#define plld(t) printf("%lld\n",t)
#define fo(i,n) for(long long i=0;i<n;i++)

struct node{
	ll f;
};


using namespace std;
ll xyz=10000001;
ll n;
ll p[1000009];
node tree[1000005];
ll lazy[1000005];
ll maxi(ll a,ll b){
    return(a>b)?a:b;
}
ll hcf(ll a,ll b){
	if(b==0)return a;
	return hcf(b,a%b);
}
node mergi(node a,node b){
    node c;
    c.f=a.f + b.f ;
    return c;
}
void build(ll i,ll s,ll e){

    if(s==e){
        tree[i].f=p[s];


        return;
    }
    ll mid=(s+e)/2;
    build(2*i,s,mid);
    build(2*i+1,mid+1 , e);
    tree[i]=mergi(tree[2*i],tree[2*i+1]);



}
void init(){
    build(1,1,n);

}

node identity;
node query(int t,int i,int j,int l,int r)
{   if(i> r || j<l || j<i){
        return identity;
	}

   // cout<<t<<" "<<i<<" "<<j<<" "<<l<<" "<<r<<endl;
     if(lazy[t]==1){
        tree[t].f=(j-i+1)- tree[t].f;
        if(i!=j){
            lazy[2*t]^=1;
            lazy[2*t + 1]^=1;
        }
        lazy[t]=0;
    }

	if(i>=l && j<=r)
		return tree[t];

	node t1,t2;

	int left = t<<1,right=left|1,mid=(i+j)>>1;

	 t1=query(left,i,mid,l,r);
	 t2=query(right,mid+1,j,l,r);

	return mergi(t1,t2);
}
void update(ll t, ll i,ll j,ll l, ll r){
    if(lazy[t]==1){
        tree[t].f=(j-i+1)- tree[t].f ;
        if(i!=j){
            lazy[2*t]^=1;
            lazy[2*t + 1]^=1;
        }
        lazy[t]=0;
    }


    if(j<i || i>r || j<l)return ;
    if(i>=l && j<=r){
        tree[t].f=(j-i+1)-tree[t].f;

        if(j!=i){
            lazy[2*t]^=1;
            lazy[2*t + 1]^=1;

            }
        return ;
    }
    ll mid=(i+j)/2;

    update(2*t,i,mid,l,r);
    update(2*t + 1,mid+1, j,l,r);
    tree[t]=mergi(tree[2*t],tree[2*t + 1]);

}

void solve(ll t){

    ll a,b,c,d;
    slld(a);
    if(a==0){
        slld(b);
        slld(c);

        update(1,1,n,b+1,c+1);

    }
    else {
        slld(b);
        slld(c);

        ll an=query(1,1,n,b+1,c+1).f;
        plld(an);
    }




}
int main(){
    ll t;
    t=1;
    while(t--){
    identity.f=0;
    slld(n);
    ll q;
    slld(q);
    for(ll i=1;i<=n;i++)p[i]=0;
    for(ll i=1;i<=4*n;i++){lazy[i]=0; tree[i].f=0;}
    init();




    while(q--)solve(t);
}}
