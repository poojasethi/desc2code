#include <iostream>
#include <vector>

using namespace std;

int *arr, *tree, *lazy;

void build(int i, int a, int b) {
    int mid = (a+b)/2;

    if(a==b) {
        tree[i] = arr[a];
        return;
    }
    build(i+i,a,mid);
    build(i+i+1,mid+1,b);
    tree[i] =  tree[i+i] + tree[i+i+1];

}

void update(int i, int a, int b, int x, int y) {
    int mid = (a+b)/2;

    if(lazy[i]) {
        tree[i] = b-a+1-tree[i];
        if(a!=b) {
            lazy[i+i] = (lazy[i+i]+1) % 2;
            lazy[i+i+1] = (lazy[i+i+1]+1) % 2;
        }
        lazy[i] = 0;
    }

    if(y<a || x>b) return;

    if(a>=x && b<=y) {
        tree[i] = b-a+1-tree[i];
        if(a!=b) {
            lazy[i+i] = (lazy[i+i]+1) % 2;
            lazy[i+i+1] = (lazy[i+i+1]+1) % 2;
        }
        return;
    }
    update(i+i,a,mid,x,y);
    update(i+i+1,mid+1,b,x,y);

    tree[i] = tree[i+i] + tree[i+i+1];
}

int query(int i, int a, int b, int x, int y) {
    int mid = (a+b)/2;
    if(y<a || x>b) return 0;
    if(lazy[i]) {
        tree[i] = b-a+1-tree[i];
        if(a!=b) {
            lazy[i+i] = (lazy[i+i]+1) % 2;
            lazy[i+i+1] = (lazy[i+i+1]+1) % 2;
        }
        lazy[i]=0;
    }
    if(a>=x && b<=y) return tree[i];
    return query(i+i,a,mid,x,y) + query(i+i+1,mid+1,b,x,y) ;
}

int main()
{
    int n,q,type,a,b;
    cin>>n>>q;
    tree = new int[3*n];
    lazy = new int[3*n];

    fill_n(tree,3*n,0);
    fill_n(lazy,3*n,0);

    while(q--) {
        cin>>type>>a>>b;
        if(type==0) {
            update(1,1,n,a+1,b+1);
        } else {
            cout<<query(1,1,n,a+1,b+1)<<'\n';
        }
//        for(int i=1;i<=7;i++) cout<<i<<" "<<tree[i]<<endl;
//            for(int i=1;i<=7;i++) cout<<i<<" "<<lazy[i]<<endl;
    }

    return 0;
}
