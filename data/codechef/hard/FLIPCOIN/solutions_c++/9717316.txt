#include <iostream>
#include<stdio.h>
#include<algorithm>
#include<cmath>
using namespace std;
/*void construct(int *tree,int *lazy,int sizew){
  for(int i=0;i<=sizew;i++){
    tree[i]=lazy[i]=0;
  }

}*/
int tree[1000000]={0};
int lazy[1000000]={0};
void update(int node,int start,int endi,int l,int r){
//cout<<"hey";
  if(lazy[node]!=0){
    tree[node]=(endi-start+1)-tree[node];
    if(start!=endi) //not leaf
    {
        lazy[2*node+1]=1-lazy[2*node+1];
        lazy[2*node+2]=1-lazy[2*node+2];
    }
    lazy[node]=0;
  }
  if(start>endi||start>r||endi<l)
     return;
  if(start>=l&&endi<=r){   //completely inside
     tree[node]=(endi-start+1)-tree[node];
     if(start!=endi){
        lazy[2*node+1]=1-lazy[2*node+1];
        lazy[2*node+2]=1-lazy[2*node+2];
     }
     return;
  }
  int mid=(start+endi)/2;
  //cout<<" mid  "<<mid;
  update(2*node+1,start,mid,l,r);
  update(2*node+2,mid+1,endi,l,r);
  tree[node]=tree[2*node+1]+tree[2*node+2];
}

  int query(int node,int start,int endi,int l,int r){
  //  cout<<" hey  ";
   if(lazy[node]!=0){
      tree[node]=(endi-start+1)-tree[node];
     if(start!=endi){
        lazy[2*node+1]=1-lazy[2*node+1];
        lazy[2*node+2]=1-lazy[2*node+2];
    }
    lazy[node]=0;

  }
  if(start>endi||start>r||endi<l)
    return 0;
  if(start>=l&&endi<=r){
    return tree[node];

  }
   int mid=(start+endi)/2;
   int p1=query(2*node+1,start,mid,l,r);
   int p2=query(2*node+2,mid+1,endi,l,r);
   return p1+p2;
}
int main()
{
    //cout << "Hello world!" << endl;
    int n,q,i,a,l,r;
    scanf("%d %d",&n,&q);
    /*int x=(int)ceil(log2(n));
    int sizew=2*(int)pow(x,2)-1;
    int *tree=new int[sizew+1];
    int *lazy=new int[sizew+1];
    construct(tree,lazy,sizew);

   /*   for(i=0;i<sizew;i++)
        cout<<tree[i]<<" ";*/
      for(i=0;i<q;i++){
        cin>>a>>l>>r;
        if(a==0)
            {
                update(0,0,n-1,l,r);
                //cout<<"yes ";
            }
        else
            cout<<query(0,0,n-1,l,r)<<endl;
      }
    return 0;
}
