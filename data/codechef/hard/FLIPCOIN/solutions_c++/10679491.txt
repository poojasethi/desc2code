#include <iostream>
#include <bits/stdc++.h>
#define ll long int
using namespace std;
 
struct node{
    int heads;
    int tails;
};
struct node tree[300000];
 
void construct(struct node tree[],ll arr[],ll low,ll high,ll root){
     if(low==high){
        if(arr[low]==0)tree[root].tails=1;
        else tree[root].heads=1;
        return ;
     }
     ll mid=(low+high)/2;
     construct(tree,arr,low,mid,2*root+1);
     construct(tree,arr,mid+1,high,2*root+2);
     tree[root].tails=tree[2*root+1].tails+tree[2*root+2].tails;
     tree[root].heads=tree[2*root+1].heads+tree[2*root+2].heads;
     return;
 }
 
 ll range(struct node tree[],ll lazy[],ll low,ll high,ll root,ll ql,ll qh){
 
     if(lazy[root]!=0){
            ll temp=tree[root].heads;
            tree[root].heads=tree[root].tails;
            tree[root].tails=temp;
            if(low!=high){
            lazy[2*root+1]=(lazy[2*root+1]+1)%2;
            lazy[2*root+2]=(lazy[2*root+2]+1)%2;
            }
            lazy[root]=0;
     }
     if(ql>high||qh<low)return 0;
     if(ql<=low&&qh>=high)return tree[root].heads;
     ll mid=(low+high)/2;
     return range(tree,lazy,low,mid,2*root+1,ql,qh)+range(tree,lazy,mid+1,high,2*root+2,ql,qh);
 }
 
void update(struct node tree[],ll lazy[],ll low,ll high,ll root,ll ql,ll qh){
     if(lazy[root]!=0){
            ll temp=tree[root].heads;
            tree[root].heads=tree[root].tails;
            tree[root].tails=temp;
            if(low!=high){
            lazy[2*root+1]=(lazy[2*root+1]+1)%2;
            lazy[2*root+2]=(lazy[2*root+2]+1)%2;
            }
            lazy[root]=0;
     }
      if(ql>high||qh<low)return ;
     if(ql<=low&&qh>=high){
        ll temp=tree[root].heads;
            tree[root].heads=tree[root].tails;
            tree[root].tails=temp;
            if(low!=high){
            lazy[2*root+1]=(lazy[2*root+1]+1)%2;
            lazy[2*root+2]=(lazy[2*root+2]+1)%2;
            }
            return ;
     }
     ll mid=(low+high)/2;
     update(tree,lazy,low,mid,2*root+1,ql,qh);
     update(tree,lazy,mid+1,high,2*root+2,ql,qh);
     tree[root].tails=tree[2*root+1].tails+tree[2*root+2].tails;
     tree[root].heads=tree[2*root+1].heads+tree[2*root+2].heads;
     return;
 }
 
int main()
{   ll n,q;
    scanf("%ld%ld",&n,&q);
    ll x,a,b,MAX;
    MAX=2*(pow(2,ceil(log2(n))))-1;
    ll arr[n];
    for(ll i=0;i<n;i++)arr[i]=0;
    ll lazy[MAX];
    for(ll i=0;i<MAX;i++){
        tree[i].heads=0;
        tree[i].tails=0;
        lazy[i]=0;
    }
    construct(tree,arr,0,n-1,0);
    while(q--){
        scanf("%ld%ld%ld",&x,&a,&b);
        if(x==0){
            update(tree,lazy,0,n-1,0,a,b);
        }
        else{
            printf("%ld\n",range(tree,lazy,0,n-1,0,a,b));
        }
    }
    return 0;
} 