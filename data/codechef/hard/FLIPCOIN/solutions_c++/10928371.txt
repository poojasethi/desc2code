//#define _CRT_SECURE_NO_WARNINGS
#include <cstring>
#include <bits/stdc++.h>
#include <list>
#include <stdio.h>
#include <iostream>
#include <list>
using namespace std;
 
int tree[400002];
bool lazy[400002];
 
int midValue(int l, int r)
{
	return l + (r - l) / 2;
}
 
void updateLazy(int node, int l, int r, int start, int end)
{
	if (lazy[node])
	{
		tree[node] = r - l + 1 - tree[node];
		if (l != r)
		{
			lazy[2 * node + 1] = !lazy[2 * node + 1];
			lazy[2 * node + 2] = !lazy[2 * node + 2];
		}
		lazy[node] = !lazy[node];
	}
 
	if (l > end || r < start)
		return;
 
	if (start <= l && r <= end)
	{
		lazy[node] = !lazy[node];
 
		if (lazy[node])
		{
			tree[node] = r - l + 1 - tree[node];
			if (l != r)
			{
				lazy[2 * node + 1] = !lazy[2 * node + 1];
				lazy[2 * node + 2] = !lazy[2 * node + 2];
			}
			lazy[node] = !lazy[node];
		}
		return;
	}
 
	int mid = midValue(l, r);
	int lChild = 2 * node + 1;
	int rChild = lChild + 1;
 
	updateLazy(lChild, l, mid, start, end);
	updateLazy(rChild, mid + 1, r, start, end);
 
	tree[node] = tree[lChild] + tree[rChild];
}
 
int queryLazy(int node, int l, int r, int start, int end)
{
	if (lazy[node])
	{
		tree[node] = r - l + 1 - tree[node];
		if (l != r)
		{
			lazy[2 * node + 1] = !lazy[2 * node + 1];
			lazy[2 * node + 2] = !lazy[2 * node + 2];
		}
		lazy[node] = !lazy[node];
	}
 
	if (l > end || r < start)
		return 0;
 
	if (start <= l && r <= end)
	{
		return tree[node];
	}
 
	int mid = midValue(l, r);
	int lChild = 2 * node + 1;
	int rChild = lChild + 1;
 
	return queryLazy(lChild, l, mid, start, end) + queryLazy(rChild, mid + 1, r, start, end);
}
 
int main()
{
	int n,q;
	cin >> n >> q; //cin>>n resolves to cin//(cin>>n)>>q  -> cin>>q
	
	bool type;
	int start, end;
	
	while (q--)
	{
		cin >> type >> start >> end;
		
		if (type)
		{
			cout<< queryLazy(0, 0, n - 1, start, end) << endl;
		}
		else
		{
			updateLazy(0, 0, n - 1, start, end);
		}
	}
 
	//getchar();
	return 0;
}