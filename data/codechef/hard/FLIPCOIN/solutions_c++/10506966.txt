#include<iostream>
#include<vector>
#include<string.h>
#include<stdio.h>
#include<climits>
#include<map>
#include<math.h>
#include<algorithm>
#define LL long long int
#define P(N) printf("%d\n",N);
#define S(N) scanf("%d",&N);
#define SL(N) scanf("%lld",&N);
#define pb push_back
#define mp make_pair
#define pnl printf("\n");
#define FOR(i,a,b) for (i=a;i<=b;i++)
#define mem(a,val) memset(a,val,sizeof(a))
using namespace std;
int gcd(int a, int b){ int temp; while(b>0)	{ temp= b; b=a%b; a=temp;}	return a;}
int tree[262144];
bool lazy[262144];
void update(int node,int ss,int se,int qs,int qe)
{
	if(lazy[node])
	{
		tree[node]=(se-ss+1)-tree[node];
		if(ss!=se)
		{
			lazy[node*2]=!lazy[2*node];
			lazy[node*2+1]=!lazy[2*node+1];
		}
		lazy[node]=false;
	}
	if(qe<ss || se<qs || ss>se)return;
	if(qs<=ss && se<=qe)
	{
		tree[node]=(se-ss+1)-tree[node];
		if(ss!=se)
		{
			lazy[2*node]=!lazy[2*node];
			lazy[2*node+1]=!lazy[2*node+1];
		}
		return;
	}
	int mid= ss+(se-ss)/2;

	update(2*node,ss,mid,qs,qe);
	update(2*node+1,mid+1,se,qs,qe);
	tree[node]=tree[2*node]+tree[2*node+1];
	return;
}
int query(int node,int ss,int se, int qs, int qe)
{
	if(qe<ss || se<qs || ss>se)return 0;
	if(lazy[node])
	{
		tree[node]=(se-ss+1)-tree[node];
		if(ss!=se)
		{
			lazy[2*node]=!lazy[2*node];
			lazy[2*node+1]=!lazy[2*node+1];
		}
		lazy[node]=false;
	}
	if(qs<=ss && se<=qe)return tree[node];

	int mid= ss+(se-ss)/2;
	//printf("%d %d %d\n", ss,se,mid);
	int q1= query(2*node,ss,mid,qs,qe);
	int q2= query(2*node+1,mid+1,se,qs,qe);
	int ret=q1+q2;
	return ret;
}
int main()
{
         // freopen("input.txt", "r", stdin);
      // freopen("C:\\Users\\sanjeev1779\\Desktop\\codechef\\output.txt", "w", stdout);
      int i,j,t,n,q,l,r,type;
      S(n) S(q)
      while(q--)
      {
      	 S(type) S(l) S(r)
      	// l--;r--;
      	 if(type==0)
      	 {
      	 	update(1,0,n-1,l,r);
      	 }
      	 else
      	 {
      	 	int ans=query(1,0,n-1,l,r);
      	 	P(ans)
      	 }

      }
return 0;
}
