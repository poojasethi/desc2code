#include <bits/stdc++.h>
#define rep(i,s,n) for(int i=s;i<=n;i++)

const int mx = 1e5 + 10;

using namespace std;

int A[mx], B[mx], T[mx * 4],N, M, V, D,qs,qe;

int max(int a,int b)
{
    if(a>b)
        return a;
    return b;
}

void build(int x, int y, int r)
{
    if (x==y)
        return void(T[r] = B[x]);
    int m = (x+y) >> 1;
    build(x, m,2*r); build(m+1, y, 2*r+1);
    T[r] = max(T[2*r], T[2*r+1]);
}

int qu(int x, int y, int r)
{
    if(qs > y || qe < x || x > y)
        return 0;
    if (qs <= x && qe >=y )
        return T[r];
    int m = (x+y)>>1;
    return max(qu(x,m,2*r),qu(m+1,y,2*r+1));
}

int binary_search(int v)
{
    int x = 1, y = N,cnt = 1;
    while(x<=y)
    {
        int m = (x+y) >> 1;
        if (A[m]>v) y = m-1;
        else if(A[m] < v) x = m+1;
        else
        {
            while(A[m+cnt]==v)
                ++cnt;
            return m + cnt - 1;
        }
    }
    return x - 1;
}

int main()
{
    scanf("%d",&N);
    rep(i,1,N)
        scanf("%d",&A[i]);
    rep(i,1,N-1)
        B[i] = A[i+1] - A[i];
    build(1, N, 1);
    scanf("%d",&M);
    while(M--)
    {
        scanf("%d %d",&V,&D);
        qe = binary_search(V) - 1;
        qs = 1;
        int L,R,s; 
        L = 1, R = qe;
        while(L<=R)
        {
            int m = (L+R) >> 1;
            qs = m;
            s = qu(1,N,1);
            if(s > D) 
                L = m + 1;
            else
                R = m - 1;
        }
        printf("%d\n",L);
    }
    return 0;
}