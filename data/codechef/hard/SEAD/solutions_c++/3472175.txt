#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<algorithm>
#include<cstring>
#include<iterator>
#define maxn 111111
#define mem(a,b) memset(a,b,sizeof a)
#define pb push_back
#define mp make_pair
#define F first
#define S second
#define sz(a) (int(a.size()))
#define step(i) (i&-i)

using namespace std;
const int mod=1e9+7;

struct tree{
    vector<pair<int,int> > a;
    vector<int> f;
    tree *l,*r;
    tree(int x,int g){
        a.pb(mp(x,g));
        f.resize(a.size()+1);
        f[1]=g;
        l=r=0;
    }
    tree(tree * ll,tree * rr){
        l=ll;r=rr;
        merge(l->a.begin(),l->a.end(),r->a.begin(),r->a.end(),back_inserter(a));
        f.resize(a.size()+1);

        for(int i=0;i<sz(a);++i){
            for(int j=i+1;j<sz(f);j+=step(j))
                f[j]=max(f[j],a[i].S);
        }
    }
};
int a[maxn],n;
tree * build(int l,int r){
    if(l==r)return new tree(-a[l]+a[l-1],l);
    int m=(l+r)>>1;
    return new tree(build(l,m),build(m+1,r));
}

int get(tree * t,int tl,int tr,int l,int r,int d){
    if(l>r)return 1;
    if(tl==l && tr==r){
        //if(d==6)cerr<<l<<' '<<r<<endl;
        int p=upper_bound(t->a.begin(),t->a.end(),mp(-d,0))-t->a.begin();
        //if(d==6)cerr<<p<<endl;
        if(p==0)return 1;
        else{
            int r=0;
            for(int i=p;i>0;i-=step(i)){
                //if(d==6)cerr<<i<<endl;
                r=max(r,t->f[i]);
            }
            return r;
        }
    }
    int tm=(tl+tr)>>1;
    return max(get(t->l,tl,tm,l,min(r,tm),d),
               get(t->r,tm+1,tr,max(l,tm+1),r,d)
    );
}

int main(){
    //freopen("in","r",stdin);
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>a[i];
    tree * T;
    if(n>1)T=build(2,n);
    int m;
    cin>>m;
    for(int i=1;i<=m;++i){
        int t,d;
        cin>>t>>d;
        if(n>1)cout<<get(T,2,n,2,upper_bound(a+1,a+n+1,t)-a-1,d)<<endl;
        else cout<<1<<endl;
    }
    return 0;
}
