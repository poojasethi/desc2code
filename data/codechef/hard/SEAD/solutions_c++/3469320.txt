/* 
 * File:   SEAD.cpp
 * Author: anuraganand
 * Created on 23 February, 2014, 1:24 PM
 */

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <iostream>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <list>
#include <utility>
#include <algorithm>
#include <cassert>

using namespace std;
#define ff first
#define ss second
#define pb push_back
#define mp make_pair
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef long long ll;
typedef vector<int> vi;
typedef long double ld;
#define var(a,b)  __typeof(b) a = b
#define rep(i,n)  for(int i = 0;(i) < (n);  ++i)
#define rept(i,a,b) for(var(i,a); i < (b); ++i)
#define tr(v,it)  for(var(it,v.begin());it!=v.end();++it)
#define fill(a,val) memset(a,val,sizeof(a))
#define gi(n) scanf("%d",&n);
#define all(v) v.begin(),v.end()

const int N = 100100;
const int inf = (int)1e9;
int diffMax[N << 2];
int a[N];

#define l(x) 2 * x + 1
#define r(x) 2 * x + 2

void buildDiff(int x, int l, int r) {
    if(l == r) {
        diffMax[x] = a[l] - a[l - 1];
    } else {
        int mid = (l + r) >> 1;
        buildDiff(l(x), l, mid);
        buildDiff(r(x), mid + 1, r);
        diffMax[x] = max(diffMax[l(x)], diffMax[r(x)]);
    }
}

int queryMax(int x, int l, int r, int ql, int qr) {
    if(l >= ql && r <= qr)
        return diffMax[x];
    int mid = (l + r) >> 1;
    int ret = -inf;
    if(ql <= mid) {
        ret = max(ret, queryMax(l(x), l, mid, ql, qr));
    }
    if(qr > mid) {
        ret = max(ret, queryMax(r(x), mid + 1, r, ql, qr));
    }
    return ret;
}

int main(int argc, char** argv) {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
    int n;
    cin >> n;
    rept(i, 1, n + 1) cin >> a[i];
    a[0] = a[1];
    buildDiff(0, 1, n);
    int q; 
    cin >> q;
    while (q--) {
        int tt, dd;
        cin >> tt >> dd;
        int maxpos = upper_bound(a + 1, a + n + 1, tt) - a; 
        int li = 1, ri = maxpos - 1;
        while (li < ri) {
            int mi = (li + ri) >> 1;
            int curMin = queryMax(0, 1, n, mi + 1, maxpos - 1);
            if(curMin > dd) li = mi + 1;
            else ri = mi;          
        }
        cout << li << endl;
    }
    
    return 0;
}

