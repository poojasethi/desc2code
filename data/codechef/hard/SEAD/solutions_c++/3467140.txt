#include <cstring>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;
typedef long long int64;
typedef pair<int, int> PII;
const int MOD = 1000000007;
const double EPSILON = 1e-10;

#define FORU(i, a, b) for (int i = a; i <= b; ++i)
#define FORD(i, a, b) for (int i = a; i >= b; --i)
#define SIZE(A) ((int) A.size())
#define PB(X) push_back(X)
#define MP(A, B) make_pair(A, B)

template<class T> inline T tmin(T a, T b) {return (a < b) ? a : b;}
template<class T> inline T tmax(T a, T b) {return (a > b) ? a : b;}
template<class T> inline T tabs(T a) {return (a > 0) ? a : -a;}
template<class T> T gcd(T a, T b) {if (b == 0) return a; return gcd(b, a % b);}

int a[100005], b[100005], val1[1<<20], val2[1<<20];

void init_segtree(int node, int l, int r)
{
	if (l == r) {
		val1[node] = val2[node] = b[l]; return;
	}
	int m = (l + r)/2;
	init_segtree(2*node, l, m);
	init_segtree(2*node+1, m+1, r);
	val1[node] = tmax(val1[2*node], val1[2*node+1]);
	val2[node] = tmin(val2[2*node], val2[2*node+1]);
}

int query(int node, int l, int r, int key, int ind)
{
	if (l == r) {
		if (val1[node] <= key) return l;
		else return -1;
	}
	if (val1[node] <= key) {
		return l;
	}
	if (val2[node] > key) {
		return -1;
	}
	int m = (l + r)/2;
	if (m+1 >= ind) {
		return query(2*node, l, m, key, ind);
	}
	else {
		int ans1 = query(2*node, l, m, key, ind);
		int ans2 = query(2*node+1, m+1, r, key, ind);
		if (ans2 == m + 1) return (ans1 == -1 ? ans2 : ans1);
		else return ans2;
	}
}

int main(int argc, char const *argv[])
{
	int n, m, t, d;
	scanf("%d", &n);
	FORU(i, 1, n) {
		scanf("%d", &a[i]);
		if (i > 1) b[i-1] = a[i] - a[i-1];
	}
	if (n > 1) init_segtree(1, 1, n-1);
	scanf("%d", &m);
	while (m--) {
		scanf("%d %d", &t, &d);
		if (n == 1) {
			printf("1\n"); continue;
		}
		int ind = upper_bound(a + 1, a + n + 1, t) - a;
		ind -= 1;
		int ans = query(1, 1, n-1, d, ind);
		if (ans == -1) ans = ind;
		printf("%d\n", ans);
	}
	return 0;
}