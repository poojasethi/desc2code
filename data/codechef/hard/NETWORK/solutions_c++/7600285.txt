#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <set>
#include <map>
#include <vector>
#include <string>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <algorithm>
using namespace std;
#define f first
#define s second
 
struct edge {
	int v, next;
} e[100000];
 
int S, T, n, m;
int dist[31][1000];
int xc[1000], yc[1000], xa[1000], ya[1000], ca[1000], d[30000], dn;
int ff, first[1000];
int used[30000], cc;
vector <pair <int, int> > de[1000];
int ptr[1000];
int para[1000], ckol[1000];
 
void addEdge(int u, int v) {
	++ff;
	e[ff].v = v;
	e[ff].next = first[u];
	first[u] = ff;
}
 
bool dfs(int u) {
	used[u] = cc;
	if (u >= m) {
		if (ckol[u - m] < ca[u - m]) {
			++ckol[u - m];
			return 1;
		}
		for (int i = first[u]; i; i = e[i].next) if (used[e[i].v] != cc && para[e[i].v] == u) {
			if (dfs(e[i].v)) return 1;
		}
		return 0;
	}
	else {
		for (int i = first[u]; i; i = e[i].next) if (used[e[i].v] != cc && dfs(e[i].v)) {
			para[u] = e[i].v;
			return 1;		
		}							
		return 0;
	}
}
 
int main() {
	int tests, i, j, k;
	scanf("%d", &tests);
	while (tests--) {
		scanf("%d%d", &n, &m);
		ff = 0;
		for (i = 0; i < n; ++i) {
			scanf("%d%d%d", &xa[i], &ya[i], &ca[i]);
			ckol[i] = 0;
		}			
		for (i = 0; i < m; ++i) {
			scanf("%d%d", &xc[i], &yc[i]);			
			de[i].clear();	
			para[i] = -1;
		}			
		dn = 0;			
		for (i = 0; i < n; ++i) {
			for (j = 0; j < m; ++j) {
				dist[i][j] = (xa[i] - xc[j]) * (xa[i] - xc[j]) + (ya[i] - yc[j]) * (ya[i] - yc[j]);
				d[dn++] = dist[i][j];
				de[j].push_back(make_pair(dist[i][j], i));
			}
		}	
		
		sort(d, d + dn);
		dn = unique(d, d + dn) - d;
		
		for (i = 0; i < n + m; ++i)
			first[i] = 0;
			
		for (i = 0; i < m; ++i) {
			sort(de[i].begin(), de[i].end());			
			ptr[i] = 0;
		}	
		
		int r = 0;
		for (i = 0; i < m; ++i) {
			if (r > 0) {
				while (ptr[i] < de[i].size() && de[i][ptr[i]].f <= d[r - 1]) {
					addEdge(i, m + de[i][ptr[i]].s);
					addEdge(m + de[i][ptr[i]].s, i);
					++ptr[i];
				}
			}
			bool found = true;
			while (r <= dn) {			
				if (found) {
					++cc;
					if (dfs(i)) break;
				}
				++r;
				found = false;
				for (j = 0; j <= i; ++j) {
					while (ptr[j] < de[j].size() && de[j][ptr[j]].f <= d[r - 1]) {
						addEdge(j, m + de[j][ptr[j]].s);
						addEdge(m + de[j][ptr[j]].s, j);
						if (used[j] == cc && used[m + de[j][ptr[j]].s] != cc)						
							found = true;
						++ptr[j];
					} 				
				} 			
 
			}
			printf("%.3lf\n", sqrt(0.0 + d[r - 1]));	
		}
		puts("");
 
	}
	return 0;		
}