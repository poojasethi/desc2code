#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <set>
#include <stack>
#include <deque>
#include <queue>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <cstring>
#include <iomanip>
#include <climits>
#include <cfloat>
#include <cstdio>
#define x first
#define y second
#define IN(x, n) (0 <= (x) && (x) < n)
#define YES 1
#define NO 0
#define MAX 100
#define MOD 1000000007
#define INF 288230376151711744LL
using namespace std;

int vec8[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};// signo x+
int vec4[4][2] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};//signo +

void int_to_char(int n, char s[], int base = 10){
	int i = 0;
	do{
		s[i++] = (n%base)+'0';
		n /= base;
	}while(n > 0);
	reverse(s, s+i);
	return;
}

string int_to_string(int n, int base = 10){
	string s = "";
	int i = 0;
	do{
		s += char((n%base)+'0');
		n /= base;
	}while(n > 0);
	reverse(s.begin(), s.end());
	return s;
}

int gcd(int uno, int dos)/*calculo el maximo comun divisor*/
{
	if(dos == 0)
		return uno;
	return gcd(dos, uno%dos);/*si este es uno los numeros solo tienen a 1 como maximo comun divisor*/
}

int mcm(int x, int y)/*minimo comun multiplo*/
{
   return (x/gcd(x,y))*y;/*es mejor primero dividir para no desbordar*/
}

typedef long long int entero;
typedef pair<int, int> Point;

int n, m, c[MAX], rango[MAX], s[MAX], dic[MAX], list[MAX];
entero cont, cont2;
/*set<Point> edges;
set<Point>::iterator ij;//*/

entero pot(entero a, entero b){
	if(b <= 0)
		return 1;
	entero resp = pot(a, b>>1);
	resp = (resp * resp)%MOD;
	if(b&1)
		return (a*resp)%MOD;
	return resp;
}

bool Labeled_Tree_from_Prufer_Sequence(){
	int i, j;
	for(i = 0; i < m; i++)
		list[i] = i;
//	edges.clear();
	for(i = 0; i < n; i++){
		for(j = 0; j < m; j++){
			if(list[j] >= 0 && dic[j]==0){
				if(rango[j] == rango[s[i]]){
					for(i--; i >= 0; i--)
						dic[s[i]]++;
					return false;
				}
//				edges.insert(Point(min(*it, sequence[i]), max(*it, sequence[i])));
				dic[s[i]]--;
				list[j] = -1;
				break;
			}
		}
	}
	for(j = 0; j < n; j++)
		dic[s[j]]++;
	for(i = 0; i < m; i++)
		if(list[i]>=0){
			for(j = i+1; j < m; j++)
				if(list[j]>=0){
					if(rango[i] == rango[j])
						return false;
					else return true;
				}
		}
//	edges.insert(Point(i, j));
//	cout << "El arbol:" << endl;
/*	for(ij = edges.begin(); ij != edges.end(); ij++)
		cout << "("<<(*ij).x << "," << (*ij).y<<") ";
	cout << endl;//*/
	return true;
}

void genera(int i){
	if(i == n){
		if(Labeled_Tree_from_Prufer_Sequence()){
//			cout << s << endl;
			c[s[0]]++;
			cont2++;
			
		}
		cont++;
		return;
	}
	for(int j = 0; j < m; j++){
		s[i] = j;
		dic[j]++;
		genera(i+1);
		dic[j]--;
	}
	return;
}

entero formula_k_1(int n){
	return pot(n, n-2);
}

entero formula_k_2(int n){
	entero resp = (pot(n, n-2) * pot(n-1, n))%MOD;
	return (resp * pot(4, n-1))%MOD;
}

entero formula_general(int n, int k){
	entero resp = (pot(n, n-2) * pot(n-1, n*k-n))%MOD;
	return (resp * pot(k, n*k-2))%MOD;
}

int main(){
	int i, j, k = 1;
	int v[MAX], dic[MAX];
/*	n = 6;
	for(i = 0; i < (n+2); i++)
		rango[i] = i/k;
	Labeled_Tree_from_Prufer_Sequence("064660");//*/
	while(scanf("%d%d", &n, &k)==2){
		cont = cont2 = 0;
/*		memset(c, 0, sizeof(c));
		memset(dic, 0, sizeof(dic));
		for(i = 0; i < (n+2); i++)
			rango[i] = i/k;
		m = n+2;//*/
//		genera(0);
//		imprime();
//		cout << "cont = " << cont <<" " << cont2 << " "<<formula_k_1(n+2)<< endl;
/*		for(i = 0; i < m; i++)
			cout << c[i] << " ";
		cout << endl;//*/
		cout << formula_general(n, k) << endl;
	}
	return 0;
}
