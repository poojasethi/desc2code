#include<bits/stdc++.h>
using namespace std;
//log(100000000)is 30 ie 30 bits to store no 10^9 in binary
#define M 29
#define MAXN 400001
int l[MAXN];
int r[MAXN];
int a[MAXN];
struct node{
	int link[2];
	node()
	{
		link[0]=-1;
		link[1]=-1;
	}
};
//id is stroed at link if 0 oor 1 oxurs acoudinly 
node trie[30*MAXN];

int id=0;
int newnode()
{return id++;}
inline void insert(int cur,int v)
{
	//29 bits shift to get the most significcant bit ie the 30th one
	int x=1<<M,i;
	for(i=0;i<=M;i++)
	{
		int nxt=(v&x)!=0;
		//if 30th bit is 1 then 1 nd 1 is 1 and not equal to zero is true sp gives 1 nd next sets to 1
		// if 0 then 0 nd 1 is 0 and ans is 0 and it is not equal to 0 is wrong so nxt =0;
		if(trie[cur].link[nxt]==-1)
		trie[cur].link[nxt]=newnode();
		cur=trie[cur].link[nxt];
		x>>=1;	
		//now 29th bit is 1 nd so on this procedure follows	
	}
}
int find_max(int cur,int v)
{
	int x=1<<M,i;
	int ans=0;
	for(i=0;i<=M;i++)
	{
		int nxt=(v&x)!=0;
		//finding the opposite
		if(trie[cur].link[1-nxt]!=-1)
		{
			//opposite fonund so that bit is 1
			ans=ans^x;
			cur = trie[cur].link[1 - nxt];
			
		}
		else
		cur = trie[cur].link[nxt];
		x>>=1;
	}
	return ans;
	
}
	void clear_trie() {
	for (int i = 0; i <= id; i++) {
		trie[i].link[0] = -1;
		trie[i].link[1] = -1;
	}
	id = 0;
}
int main()
{
	long long int n,i,j;
    long long int ans=0;
	int lbest=0,rbest=0;
	scanf("%lld",&n);
	int s=newnode();
	insert(s,0);
	for(i=0;i<n;i++)
	{
		scanf("%lld",&a[i]);
		lbest=lbest^a[i];
		insert(s,lbest);
		l[i]=max((i==0)?0:l[i-1],find_max(s,lbest));
		
	}
    clear_trie();
    s=newnode();
    insert(s,0);
    for(i=n-1;i>0;i--)
    {
    	rbest^=a[i];
    	insert(s,rbest);
    	r[i]=max((i==n-1)?0:r[i+1],find_max(s,rbest));
    	int cum=r[i]+l[i-1];
    	if(cum>ans)
    	ans=cum;
    	
	}
	printf("%lld\n",ans);

	
}
