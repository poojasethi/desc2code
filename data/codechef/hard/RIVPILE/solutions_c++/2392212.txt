// CodeChef - RIVPILE
// Greedy Technique
// Dijkstra's Algorithm

#include <cstdio>
#include <iostream>
#include <set>
#include <vector>
#include <algorithm>
#define INF 1e18
#define MAX 255

using namespace std;
typedef long long LL;
typedef pair<LL, LL> PLL;

struct Disk
{
  LL radius, cost;
}disk[MAX];

LL square(LL x) 
{
  return x * x;
}

int compare(Disk a, Disk b)
{
  return a.radius < b.radius;
}

LL n, m, w;
LL typeCount[MAX]; // Count of # of disk types allowed, used as visited[] array.
LL points[MAX][2];
LL distance0[MAX][MAX], pointCost[MAX][MAX]; // Cost of the disk at point i

int main() 
{
  int t;

  scanf("%d", &t);
  while(t--) 
  {
    set<PLL> q;

    scanf("%lld%lld%lld", &n, &m, &w);
    for(int i = 0; i < n; i++)
     scanf("%lld%lld", &points[i][0], &points[i][1]);

    for(int i = 0; i < n; i++) 
     for(int j = 0; j < n; j++)
      distance0[i][j] = square(points[i][0] - points[j][0]) + square(points[i][1] - points[j][1]);

    for(int i = 0; i < m; i++)
     scanf("%lld%lld", &disk[i].radius, &disk[i].cost);

    // Initialize
    sort(disk, disk + m, compare);
    for(int i = 0; i < n; i++)
     for(int j = 0; j < m; j++)
      pointCost[i][j] = INF;

    for(int i = 0; i < n; i++)
     typeCount[i] = m; // Initialize with last type
    //

    for(int i = 0; i < n; i++) 
     for(int j = m - 1; j >= 0; --j) 
      if(points[i][1] <= disk[j].radius) 
      {
        pointCost[i][j] = disk[j].cost;
        typeCount[i] = j;
        q.insert(PLL(pointCost[i][j], i * m + j)); // Encode (i, j) into a number
        // Insert all points that can reach y = 0 with possible disk types.
      }

    LL ans = -1;
    while(!q.empty())
    {
      int i = q.begin()->second / m; // Decode (i, j)
      int j = q.begin()->second % m;
      q.erase(q.begin());
      LL currentCost = pointCost[i][j];

      // Check if the disk touches y = w.
      if(w <= points[i][1] + disk[j].radius)
      {
        ans = currentCost;
        break;
      }

      for(int k = 0; k < n; k++) 
      {
        while(typeCount[k] && square(disk[j].radius + disk[typeCount[k] - 1].radius) >= distance0[k][i]) 
        {
          typeCount[k]--;
          pointCost[k][typeCount[k]] = currentCost + disk[typeCount[k]].cost;
          q.insert(PLL(pointCost[k][typeCount[k]], k * m + typeCount[k]));
        }
      }
    }

    if(ans == -1) printf("impossible\n");
    else printf("%lld\n", ans);
  }

  return 0;
}