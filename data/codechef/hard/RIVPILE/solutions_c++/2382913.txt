/*Author : Vineet Kumar */
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<climits>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<bitset>
#include<stack>
#include<queue>
using namespace std;

#define FOR(i,a,b)      for(int i= (int )a ; i < (int )b ; ++i)
#define rep(i,n)        FOR(i,0,n)
#define INF             INT_MAX
#define ALL(x)          x.begin(),x.end()
#define LET(x,a)        __typeof(a) x(a)
#define IFOR(i,a,b)     for(LET(i,a);i!=(b);++i)
#define EACH(it,v)      IFOR(it,v.begin(),v.end())
#define pb              push_back
#define sz(x)           int(x.size())
#define mp              make_pair
#define fill(x,v)       memset(x,v,sizeof(x))
#define max(a,b)        ((a)>(b)?(a):(b))
#define min(a,b)        ((a)<(b)?(a):(b))
#define si(n)           scanf("%d",&n)
#define pi(n)           printf("%d ",n)
#define pil(n)          printf("%d\n",n)
#define sl(n)           scanf("%lld",&n)
#define sd(n)           scanf("%lf",&n)
#define ss(n)           scanf("%s",n)
#define scan(v,n)       vector<int> v;rep(i,n){ int j;si(j);v.pb(j);}
#define mod (int)(1e9 + 7)
typedef pair<int,int> PI;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long LL;
#define MAXN 260
LL dist[MAXN][MAXN];
LL X[MAXN],Y[MAXN];
LL reach[MAXN][MAXN];
int disc_alloted[MAXN];
vector<pair<LL,LL> > disc;
int main()
{
    int i,j,n,w,m,t;
    for(si(t);t--;)
    {
        si(n);
        si(m);
        si(w);
        LL x,y;
        rep(i,n)
        {
            sl(X[i]);
            sl(Y[i]);
        }
        rep(i,n)
        {
            rep(j,n)
                dist[i][j] = (X[i]-X[j])*(X[i]-X[j]) + (Y[i]-Y[j])*(Y[i]-Y[j]);
            rep(j,m)
                reach[i][j] = (LL)1e18;
            disc_alloted[i] = m;
        }
        disc.clear();
        rep(i,m)
        {
            sl(x);
            sl(y);
            disc.pb(mp(x,y));
        }
        sort(ALL(disc));
        priority_queue<pair<LL,PI>, vector<pair<LL,PI> > , greater<pair<LL,PI> >  > Q,e;
        Q = e;
        rep(i,n)
        {
            for(j=m-1;j>=0;j--)
            {
                if(Y[i] <= disc[j].first)
                {
                    reach[i][j] = disc[j].second;
                    disc_alloted[i] = j;
                    Q.push(mp(reach[i][j],mp(i,j)));
                    //printf("insert v:%lld n:%d t:%d\n",reach[i][j],i,j);
                }
            }  
        }
        int node,disc_type;
        LL value,ans = -1,radius,temp;
        while(!Q.empty())
        {
            value = Q.top().first;
            node = Q.top().second.first;
            disc_type = Q.top().second.second;
            radius = disc[disc_type].first;
            Q.pop();
            //printf("v:%lld n:%d t:%d\n",value,node,disc_type);
            if(Y[node] + radius >= w)
            {
                ans = value;
                break;
            }
            rep(i,n)
            {
                if(node == i)
                    continue;
                while(disc_alloted[i] && ((radius+disc[disc_alloted[i]-1].first)*(radius+disc[disc_alloted[i]-1].first)) >= dist[node][i])
                {
                    temp = value + disc[disc_alloted[i]-1].second;
                    //if(temp < reach[i][disc_alloted[i]-1])
                    //{
                        disc_alloted[i]--;
                        //printf("insert: v:%lld n:%d t:%d\n",temp,i,disc_alloted[i]);
                        reach[i][disc_alloted[i]] = temp;
                        Q.push(mp(reach[i][disc_alloted[i]],mp(i,disc_alloted[i])));
                    /*}
                    else
                        break;*/
                }
            }
        }
        if(ans == -1)
            printf("impossible\n");
        else
            printf("%lld\n",ans);
    }
    return 0;
}