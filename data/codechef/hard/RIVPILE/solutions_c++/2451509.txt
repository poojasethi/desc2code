#include <map>
#include <set>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <vector>
#include <ctime>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <cassert>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;
#define LL long long
#define MM(a,x) memset(a,x,sizeof(a));
#define ALL(x)  (x).begin(), (x).end()
#define P(x)    cerr<<"["#x" = "<<x<<"]"<<endl;
#define P2(x,y) cerr<<"["#x" = "<<x<<", "#y" = "<<y<<"]\n";
#define TM(a,b) cerr<<"["#a" -> "#b": "<<1e3*(b-a)/CLOCKS_PER_SEC<<"ms]\n";
#define mp make_pair
#define pb push_back
template<class T> void PV(T a, T b) {while(a != b) cerr << *a++ << " "; cerr << endl;}
template<class T> inline bool chmin(T &a, T b) {return a > b ? a = b, 1 : 0;}
template<class T> inline bool chmax(T &a, T b) {return a < b ? a = b, 1 : 0;}
const int inf = 0x3f3f3f3f;
const int mod = int(1e9) + 7;

#define sq(x) ((x)*(x))

const int MAXN = 100000;
struct Edge {
	int v, d;
	Edge(int _v, int _d) : v(_v), d(_d) {}
	bool operator<(const Edge& other) const {
		return d > other.d;
	}
};

vector<Edge> edge[MAXN];
int dist[MAXN];
int dijkstra(int S, int T) {
	memset(dist, 0x3f, sizeof(dist));
	dist[S] = 0;
	priority_queue<Edge> que;
	que.push(Edge(S, 0));
	while(!que.empty()) {
		int u = que.top().v;
		int td = que.top().d;
		que.pop();
		if(td > dist[u]) continue;
		for(int i = 0; i < edge[u].size(); i++) {
			int v = edge[u][i].v;
			int d = edge[u][i].d;
			if(d + dist[u] < dist[v]) {
				dist[v] = d + dist[u];
				que.push(Edge(v, dist[v]));
			}
		}
	}
	return dist[T];
}

int TT, N, M, W;
LL X[255], Y[255];
LL R[255], C[255];

void addedge(int u, int v, int c) {edge[u].pb(Edge(v, c));}


int main() {
	ios_base::sync_with_stdio(0);
	cin >> TT;
	for(int ts = 1; ts <= TT; ts++) {
		vector<pair<LL, LL> >vp, vv;

		cin >> N >> M >> W;
		for(int i = 0; i < N; i++) cin >> X[i] >> Y[i];

		for(int i = 0; i < M; i++) {
			LL r, c;
			cin >> r >> c;
			vp.pb(mp(r, c));
		}

		sort(ALL(vp));
		for(int i = 0; i < vp.size(); i++) {
			while(vv.size() > 0 && vp[i].second <= vv.back().second) {
				vv.pop_back();
			}
			vv.pb(vp[i]);
		}

		for(int i = 1; i < vv.size(); i++) if(vv[i - 1].second >= vv[i].second) assert(0);

		M = vv.size();
		for(int i = 0; i < M; i++) {
			R[i] = vv[i].first;
			C[i] = vv[i].second;
		}

		int S = N * M, T = S + 1;

		for(int i = 0; i <= T; i++) edge[i].clear();

		for(int i = 0; i < N; i++)
			for(int j = 0; j + 1 < M; j++)
				addedge(i * M + j, i * M + j + 1, C[j + 1] - C[j]);

		for(int i = 0; i < N; i++) {
			for(int j = 0; j < M; j++) {
				if(R[j] >= Y[i]) {
					addedge(S, i * M + j, C[j]);
				}
			}
			for(int j = 0; j < M; j++) {
				if(Y[i] + R[j] >= W) {
					addedge(i * M + j, T, 0);
				}
			}
		}

		for(int i = 0; i < N; i++)
			for(int j = 0; j < N; j++) {
				LL DD = sq(X[i] - X[j]) + sq(Y[i] - Y[j]);
				/*
				vector<pair<int, int> > v1, v2;
				for(int k = 0; k < M; k++) {
					int t = -1;
					for(int l = M - 1; l >= 0; l--) {
						if(sq(R[k] + R[l]) >= DD) t = l;
					}
					if(t != -1) {
						v1.pb(mp(k, t));
						//cout << k << " " << t << endl;
						//addedge(i * M + k, j * M + t, C[t]);
					}
				}
				*/
				int l = M - 1;
				for(int k = 0; k < M; k++) {
					int t = -1;
					while(l >= 0 && sq(R[k] + R[l]) >= DD) t = l, l--;
					if(t != -1) {
						//			v2.pb(mp(k, t));
						addedge(i * M + k, j * M + t, C[t]);
						l = t;
						//	cout << k << " " << t << endl;
					}
				}
				//	assert(v2.size() == v1.size());
				//	for(int i = 0; i < v2.size(); i++) if(v1[i] != v2[i]) assert(0);
				/*
					for(int k = 0; k < M; k++) {
						int left = 0, right = M - 1;
						while(left < right) {
							int mid = left + right >> 1;
							if(sq(R[mid] + R[k]) >= DD) {
								right = mid;
							} else {
								left = mid + 1;
							}
						}
						if(sq(R[left] + R[k]) >= DD) {
							addedge(i * M + k, j * M + left, C[left]);
							cout<<k<<" "<<left<<endl;
						}
					}
					*/
			}
		int res = dijkstra(S, T);
		if(res >= inf) cout << "impossible" << endl;
		else cout << res << endl;
	}
	return 0;
}
