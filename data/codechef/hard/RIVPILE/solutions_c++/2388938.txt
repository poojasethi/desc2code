// CodeChef - RIVPILE
// Graphs & Trees
// Dijkstra's Algorithm

#include <cstdio>
#include <iostream>
#include <set>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef vector<LL> VL;
typedef vector<VL> VVL;
typedef vector<VI> VVI;
typedef pair<LL, LL> PLL;

VL x, y;

LL square(LL x) 
{
  return x * x;
}

int main() 
{
  int t;

  scanf("%d", &t);
  while(t--) 
  {
    int n, m;
    LL w;
    scanf("%d%d%lld", &n, &m, &w);
    x.resize(n);
    y.resize(n);
    for(int i = 0; i < n; ++i)
     scanf("%lld%lld", &x[i], &y[i]);

    VVL dist(n, VL(n));
    for(int i = 0; i < n; ++i) 
     for(int j = 0; j < n; ++j)
      dist[i][j] = square(x[i] - x[j]) + square(y[i] - y[j]);

    vector<PLL> r(m);
    for(int i = 0; i < m; ++i)
     scanf("%lld%lld", &r[i].first, &r[i].second);

    sort(r.begin(), r.end());
    VI v(n, m);
    VVL d(n, VL(m, (LL)1e18));

    set<PLL> q;
    for(int i = 0; i < n; ++i) 
     for(int j = m - 1; j >= 0; --j) 
      if(y[i] <= r[j].first) 
      {
        d[i][j] = r[j].second;
        v[i] = j;
        q.insert(PLL(d[i][j], i * m + j));
      }

    LL ans = -1;
    while(!q.empty())
    {
      int currentI = q.begin()->second / m;
      int currentJ = q.begin()->second % m;
      q.erase(q.begin());
      LL currentD = d[currentI][currentJ];
      if(w <= y[currentI] + r[currentJ].first) 
      {
        ans = currentD;
        break;
      }

      for(int i = 0; i < n; ++i) 
      {
        while(v[i] && square(r[currentJ].first + r[v[i] - 1].first) >= dist[i][currentI]) 
        {
          --v[i];
          d[i][v[i]] = currentD + r[v[i]].second;
          q.insert(PLL(d[i][v[i]], i * m + v[i]));
        }
      }
    }

    if(ans == -1) printf("impossible\n");
    else printf("%lld\n", ans);
  }

  return 0;
}