
/************** Elvis Rusnel Capia Quispe ***************/
#include <bits/stdc++.h>
#define f(i,x,y) for (int i = (x); i < (y); i++)
#define fd(i,x,y) for(int i = x; i>= y; i--)
#define FOR(it,A) for(typeof A.begin() it = A.begin(); it!=A.end(); it++)
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define vint vector<int>
#define pii pair<int,int>
#define vpii vector<pii>
#define ll long long
#define clr(A,x) memset(A, x, sizeof A)
#define pb push_back
#define fst first
#define snd second
#define ones(x) __builtin_popcount(x)
#define MOD 1000000007
#define INF 1000000000
#define HASH unsigned long long
#define bug1(x) cout<<#x<<" = "<<x<<endl
#define bug2(x,y) cout<<#x<<" = "<<x<<" "<<#y<<" = "<<y<<endl
#define bug3(x,y,z) cout<<#x<<" = "<<x<<" "<<#y<<" = "<<y<<" "<<#z<<" = "<<z<<endl
#define bug4(x,y,z,m) cout<<#x<<" = "<<x<<" "<<#y<<" = "<<y<<" "<<#z<<" = "<<z<<" "<<#m<<" = "<<m<<endl
#define sc(x) scanf("%d",&x)
#define MAXN 100005

using namespace std;
int toi(string a){	int ans;  sscanf(a.c_str(),"%d",&ans);  return ans;  }
string tos(int a){	ostringstream st; st<<a; string ans = st.str(); return ans;   }


struct nodo{
    int p  , q , c;

    nodo(int x,int y,int z){
    p = x;
    q = y;
    c = z;
    }
};

bool operator<(nodo a,nodo b){
return a.c > b.c;
}

int n , m , w , x[255] , y[255] , d[255][255];
vector<pii> who; // (costo,radio)

bool ispossible(int a,int tipoa,int b,int tipob){
    ll  p = x[a] - x[b];
    ll  q = y[a] - y[b];
    ll  r = who[tipoa].snd  + who[tipob].snd;

    return p*p + q*q <= r*r;
}

int D(){

    priority_queue<nodo> Q;

    f(i,0,n) f(j,0,m) d[i][j] = INF;

    f(i,0,n)
        f(j,0,m){
        int r = who[j].snd , c = who[j].fst;

                if(y[i] <= r)
                {   Q.push(nodo(i,j,c));
                    d[i][j] = c;
                    break;
                }
        }

    while(!Q.empty()){

        nodo where = Q.top(); Q.pop();
        int p = where.p , q = where.q , dist = where.c , r = who[q].snd;

        if( y[p] + r >= w ) return dist;

        if(dist == d[p][q] ){

            if(q + 1 < m){
            int nc = dist + who[q+1].fst - who[q].fst;

                if( nc < d[p][q+1]){
                Q.push(nodo(p,q+1,nc));
                d[p][q+1] = nc;
                }
            }

            f(i,0,n){

            if(p==i || d[i][0] < dist) continue;

            //buscar el de minimo costo
            int L = -1 , R = m;

            while(L + 1 < R){

            int mid = (L + R)>>1;

                if(ispossible(p,q,i,mid)) R = mid;
                else L = mid;
            }

            if(R==m) continue;

            int nc = dist + who[R].fst;

            if( nc < d[i][R]){
            Q.push(nodo(i,R,nc));
            d[i][R] = nc;
            }

            }
        }
    }

return -1;
}


int main(){
   // freopen("in.c","r",stdin);
    int tc, r , c;

    sc(tc);

    while(tc--){

        scanf("%d %d %d",&n,&m,&w);

        f(i,0,n) scanf("%d %d",&x[i],&y[i]);

        who.clear();

        f(i,0,m){
        scanf("%d %d",&r,&c);
        who.pb(pii(c,-r));
        }

        sort(all(who));

        f(i,0,m) who[i].snd = -who[i].snd;
        f(i,1,m) who[i].snd = max(who[i].snd , who[i-1].snd);

        int ans = D();

        if(ans!=-1) printf("%d\n",ans);
        else puts("impossible");
    }


    return 0;
}

