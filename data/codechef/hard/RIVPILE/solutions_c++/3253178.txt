#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <queue>
#include <utility>
#define Max 255
#define ll long long
#define inf 2000000000

using namespace std;


int n,m,x[Max],y[Max],r[Max],c[Max],R[Max],C[Max],w,nxt[Max][Max][Max];
priority_queue<pair <int , pair<int,int> > > pq;
int dist[Max][Max];

bool reach(int i,int p,int j,int q)
{
    ll x1,y1,x2,y2,rr;

    x1=x[i];
    x2=x[j];
    y1=y[i];
    y2=y[j];

    rr=r[p]+r[q];

    return ( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)  <= rr*rr );

}

int cost(int i,int p,int j,int q)
{
    if(i==j) return c[q]-c[p];

    if(j==n+1)return 0;

    return c[q];

}

int main()
{
    int i,j,k,T,p,q,cc;
    int vl[Max];

    //freopen("in.txt","r",stdin);

    scanf("%d",&T);

    while(T--)
    {
        scanf("%d %d %d",&n,&m,&w);

        for(i=1;i<=n;i++) scanf("%d %d",&x[i],&y[i]);

        for(i=1;i<=m;i++)
        {
            vl[i]=1;
            scanf("%d %d",&R[i],&C[i]);
        }

        for(i=1;i<=m;i++)
        {
            for(j=i+1;j<=m;j++)
            {
                if(R[i]==R[j] && C[i]==C[j])
                {
                    vl[j]=0;
                    continue;
                }

                if(R[i]<=R[j] && C[i]>=C[j])
                {
                    vl[i]=0;
                }

                else if(R[j]<=R[i] && C[j]>=C[i])
                {
                    vl[j]=0;
                }
            }
        }

        k=0;
        for(i=1;i<=m;i++)
        {
            if(vl[i])
            {
                k++;
                r[k]=R[i];
                c[k]=C[i];
            }
        }

        m=k;

        for(i=1;i<=m;i++)
        {
            k=i;

            for(j=i+1;j<=m;j++)
            {
                if(r[j]<r[k]) k=j;
            }

            swap(r[i],r[k]);
            swap(c[i],c[k]);
        }

        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                if(i==j) continue;

                q=m;

                for(p=1;p<=m;p++)
                {
                    while(q)
                    {
                        if(reach(i,p,j,q)==0) break;
                        q--;
                    }

                    nxt[i][p][j]=q+1;
                }

            }
        }

        for(i=1;i<=n;i++)
        {
            k=y[i];
            nxt[0][0][i]=m+1;
            for(j=1;j<=m;j++)
            {
                if(r[j]>=k)
                {
                    nxt[0][0][i]=j;
                    break;
                }

            }
        }

        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)
            {
                dist[i][j]=inf;
                if(y[i]+r[j]>=w) nxt[i][j][n+1]=0;
                else nxt[i][j][n+1]=m+1;
            }

        }

        dist[n+1][0]=inf;

        while(!pq.empty()) pq.pop();

        dist[0][0]=0;
        pq.push(make_pair(0,make_pair(0,0)));

        while(!pq.empty())
        {
            cc=pq.top().first;
            i=pq.top().second.first;
            p=pq.top().second.second;

            pq.pop();

            cc*=-1;

            //cout<<i<<endl;

            //cout<<i<<" "<<cc<<endl;


            if(i==n+1) break;

            if(dist[i][p]<cc) continue;

            if(i && p<m)
            {
                k=cost(i,p,i,p+1);

                if(k+cc<dist[i][p+1])
                {
                    dist[i][p+1]=k+cc;
                    pq.push(make_pair( -1*(k+cc)  ,make_pair(i,p+1)));
                }
            }

            if(i && nxt[i][p][n+1]==0)
            {
                if(cc<dist[n+1][0])
                {
                    dist[n+1][0]=cc;
                    pq.push(make_pair( -cc ,make_pair(n+1,0)));
                }
            }

            for(j=1;j<=n;j++)
            {
                if(i==j) continue;

                q=nxt[i][p][j];

                if(q==m+1) continue;

                k=cost(i,p,j,q)+cc;

                //cout<<k<<endl;

                if(k<dist[j][q])
                {
                    dist[j][q]=k;
                    pq.push(make_pair(-k, make_pair(j,q)));
                }


            }


        }

        if(dist[n+1][0]==inf) printf("impossible\n");
        else printf("%d\n",dist[n+1][0]);
    }

    return 0;
}
