//http://www.codechef.com/problems/RIVPILE
#include <string>
#include<stdio.h>
#include<vector>
#include<stack>
#include<queue>
#include<set>
#include<list>
#include<iostream>
#include<algorithm>
#include<math.h>
#include<string.h>
#include<limits.h>
#include<stdlib.h>
#include<time.h>
#define snd(a) scanf("%d",&(a))
#define snlld(a) scanf("%lld",&(a))
#define frr(i,n) for((i)=0;(i)<(n);(i)+=1)
#define pb push_back
#define pf push_front
#define all(a) (a).begin(),(a).end()
#define sz size()
#define mp make_pair
#define N 100010
#define mod  1000000007
#define modd  20071027
#define maxx 1000000000
#define vi vector<int>
#define vl vector<long long>
#define fr first
#define sd second
using namespace std;
typedef long long ll;
ll poww(ll b,ll p){
    ll a=1;
    while(p){
        if(p&1){a=(a*b);}
        p>>=1;
        b=(b*b);
    }
    return a;
}
int n,m;
int x[255],y[255];
int r[255],c[255];
int a[260];
ll vdist[252][252];
int diskct[260];
vector<pair<int,int> >disk2(255);
int dist[260][260];

int main(){
    int i,j,k,t,b[260],ct,w,p,cp;
    ll jj,kk,ans;
    snd(t);

    while(t--){
        for(i=0;i<260;i++){
            for(j=0;j<260;j++)dist[i][j]=mod;
        }
        ct=0;
        snd(n);snd(m);snd(w);
        for(i=0;i<n;i++){
            scanf("%d%d",&x[i],&y[i]);

        }
        for(i=0;i<m;i++){
            scanf("%d%d",&j,&k);
            disk2[i]=mp(j,k);
        }
        //remove unnecessary disks
        sort(disk2.begin(),disk2.begin()+m);

        ct=1;
        a[0]=0;
        for(i=1;i<m;i++){
            while(disk2[a[ct-1]].sd>=disk2[i].sd){ct--;if(!ct)break;}
            a[ct++]=i;
        }
        for(i=0;i<ct;i++)r[i]=disk2[a[i]].fr,c[i]=disk2[a[i]].sd;


        priority_queue<pair<int,int > >q;//(dist, (pile no,disk no) )
        //cout<<"m="<<m<<" ct="<<ct<<"\n";
        m=ct;

        for(i=0;i<n;i++){
            diskct[i]=m;
            for(j=m-1;j>=0;j--){
                if(y[i]<=r[j]){
                    dist[i][j]=c[j];
                    diskct[i]=j;
                    q.push(mp(-c[j],i*m+j));//min heap
                }
            }
            for(j=i;j<n;j++){
                kk=(x[i]-x[j]);
                jj=(y[i]-y[j]);
                vdist[i][j]=vdist[j][i]=kk*kk+jj*jj;
            }
        }
        ans=-1;
        ll val;
        //memset(done,0,sizeof done);
        //every vertex comes only once in the priority queue
        while(q.sz){
            i=q.top().sd/m;//pile no
            j=q.top().sd%m;//disk no
            val=dist[i][j];
            q.pop();
            if(y[i]+r[j]>=w){
                ans=dist[i][j];
                break;
            }
            for(k=0;k<n;k++){
                if(k==i)continue;
                if(diskct[k])kk=r[j]+r[diskct[k]-1];
                while(diskct[k]&&vdist[i][k]<=kk*kk){
                    dist[k][diskct[k]-1]=dist[i][j]+c[diskct[k]-1];
                    q.push(mp(-dist[k][diskct[k]-1],k*m+diskct[k]-1));
                    diskct[k]--;
                    if(diskct[k])kk=r[j]+r[diskct[k]-1];
                }

            }

        }
        if(ans!=-1){
            cout<<ans<<"\n";
        }
        else cout<<"impossible\n";
    }

}
