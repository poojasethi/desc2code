/*First  make a convex hull of the given points using Andrew's monotone chain algorithm O(nlogn)
Then use rotating calipers method to find  set of antipodal pairs and then compute maximum diameter from that set O(n)*/


#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;

typedef long long LL;

const int maxN = 100005;
int N;

struct point
{
  LL x;
  LL y;
  point(){}
  point(LL a , LL b)
  {
     x = a;
     y = b;
  }
  bool operator <(const point &p)const
  {
  return x < p.x || (x == p.x && y < p.y);
  }
   bool operator ==(const point &p)const
  {
  return (x == p.x &&  y == p.y);
  }
};

/*pair of antipodal points*/
struct antipair
{
    point p1;
    point p2;
    antipair(){}
    antipair(point a, point b)
    {
        p1 = a;
        p2 = b;
    }
};

vector<point>P;//stores input
vector<point>H;//will store the convex hull (last entry is same as first entry)
vector<antipair>A;//will store antipodal pairs

/*returns cross product of vectors OA and OB (can be used for distance of point O from line AB)*/
LL cross(const point &O, const point &A, const point &B)
{
    return (A.x - O.x)*(B.y - O.y) - (A.y - O.y)*(B.x - O.x);
}

/*build convex hull of the set of given points*/
void buildconvexhull()
{
        int k = 0;
        H.resize(2*N);
        // Sort points lexicographically
        sort(P.begin(), P.end());

       // Build lower hull
        for (int i = 0; i < N; i++)
        {
                while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0)
                {
                  k--;
                }
                H[k++] = P[i];
        }

        // Build upper hull
        for (int i = N-2, t = k+1; i >= 0; i--) {
                while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--;
                H[k++] = P[i];
        }

        H.resize(k);
}

/*Build set of antipodal pairs*(call this only if hull size >2)*/
void buildantipodalpairs()
{
    int n = H.size() - 1;//as last element of H is same as first element
    int k = 0;
    int j = 2;

    do
    {
      /*find point farthest away from line H(k) to H(k+1)*/
      while(cross( H[(j+1)%n], H[k], H[(k+1)%n])> cross(H[j], H[k], H[(k+1)%n]))
      {
        j = (j+1)%n;
      }

      /*Add antipodal pairs to set*/
      A.push_back(antipair(H[k], H[j]));
      A.push_back(antipair(H[(k+1)%n], H[j]));

      /*If next point also has same distance add those pairs too*/
      if(cross( H[(j+1)%n], H[k], H[(k+1)%n])== cross(H[j], H[k], H[(k+1)%n]))
      {
          A.push_back(antipair(H[k], H[(j+1)%n]));
          A.push_back(antipair(H[(k+1)%n], H[(j+1)%n]));
      }

      /*Increment k and repeat*/
      k = (k+1)%n;
    }
    while(k!=0);//when k is 0 we have completed one revolution using the k pointer and in worst case we would have traversed polygon twice
}

/*Returns square of Euclidean distance between points p1 and p2*/
LL dist(const point &p1, const point & p2)
{
    return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);
}

/*Scan antipodal set to find maximum diameter*/
void findmaxdiameter()
{
    LL ans;
    if(H.size()==1) ans = 0;
    if(H.size()==2) ans = dist(H[0], H[1]);
    if(H.size()>2)
    {
        LL m = -1;
        for(int i=0; i<A.size(); i++)
        {
            LL x = dist(A[i].p1, A[i].p2);
            if(x>m)
            {
            m = x;
            }
        }
        ans = m;
    }
    printf("%lld\n", ans);
}



void solve()
{

LL xcor, ycor;

/*Clear vectors*/
P.clear();
H.clear();
A.clear();

/*Take in input*/
scanf("%d", &N);
for(int i =0; i<N; i++)
{
    scanf("%lld%lld", &xcor, &ycor);
    P.push_back(point(xcor, ycor));
}

/*Solve*/
buildconvexhull();
if(H.size()>2)buildantipodalpairs();
findmaxdiameter();
}

int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
           solve();
    }
}
