#include <bits/stdc++.h>

using namespace std;

vector < pair < long long, long long > > Hull, pts;

long long CrossProduct (pair < long long, long long > p, pair < long long, long long > q)
{
	long long res = p.first * q.second - p.second * q.first;
	if (res > 0)
		return 1;
	else
		return 0;
}

bool Check (pair < long long, long long > p, pair < long long, long long > q, pair < long long, long long > r)
{
	pair < long long, long long > a = make_pair (q.first - p.first, q.second - p.second);
	pair < long long, long long > b = make_pair (r.first - p.first, r.second - p.second);
	return CrossProduct (b, a) > 0;
}

void ConvexHull ()
{
	sort (pts.begin (), pts.end ());
	long long n = pts.size ();
	Hull.resize (2 * n);
	long long sz = 0;
	for (long long i = 0; i < n; i++)
	{
		while (sz >= 2 && !Check (Hull[sz - 1], Hull[sz - 2], pts[i]))
			sz--;
		Hull[sz++] = pts[i];
	}

	for (long long i = n - 2, temp = sz + 1; i >= 0; i--)
	{
		while (sz >= temp && !Check (Hull[sz - 1], Hull[sz - 2], pts[i]))
			sz--;
		Hull[sz++] = pts[i];
	}
	if (sz >= 1)
		Hull.resize (sz - 1);
}

long long Distance (int x, int y)
{
	long long d1 = Hull[x].first - Hull[y].first;
	long long d2 = Hull[x].second - Hull[y].second;
	return d1 * d1 + d2 * d2;
}

long long FindMaxDistance ()
{
	int ptr1 = 0, ptr2 = 1;
	int n = Hull.size ();
	if (n == 1)
		return 0;
	long long res = 0;
	while (ptr1 < n)
	{
		long long temp = 0, next;
		while (ptr2 < 2 * n)
		{
			if (Distance (ptr1, ptr2 % n) >= temp)
			{
				temp = Distance (ptr1, ptr2 % n);
				next = ptr2;
				ptr2++;
			}
			else
				break;
		}
		res = max (res, Distance (ptr1, next));
		ptr2 = next;
		ptr1++;
	}
	return res;
}

int main ()
{
	int T;
	long long n, x, y;
	cin >> T;
	while (T--)
	{
		cin >> n;
		pts.clear ();
		Hull.clear ();
		for (long long i = 0; i < n; i++)
		{
			cin >> x >> y;
			pts.push_back (make_pair (x, y));
		}
		ConvexHull ();
		cout << FindMaxDistance () << endl;
	}
	return 0;
}
