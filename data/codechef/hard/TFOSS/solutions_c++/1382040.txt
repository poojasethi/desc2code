//Working code of convexhull,  tested on spoj GARDENHU
//prints hull in clockwise direction, doesn't have the points on an edge of hull (if not is not one of the edge-vertex)
#include <stdio.h>
#include <algorithm>
#include <math.h>
#include "vector"
#include "assert.h"

using namespace std;

#define INF 10000000000000LL

struct pt {
	long long x, y;
};

bool cmp (pt a, pt b) {
	return a.y <b.y || a.y == b.y && a.x <b.x;
}

bool cw (pt a, pt b, pt c) {
	return a.x * (b.y-c.y) + b.x * (c.y-a.y) + c.x * (a.y-b.y) <0;
}

bool ccw (pt a, pt b, pt c) {
	return a.x * (b.y-c.y) + b.x * (c.y-a.y) + c.x * (a.y-b.y)> 0;
}

long long dist2(pt a, pt b)
{
	return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);
}

long long convex_hull (vector <pt> & a) 
{
	if (a.size () == 1) 
		return 0LL;
	sort (a.begin (), a.end (), & cmp);

	pt p1 = a [0], p2 = a.back ();
	vector <pt> up, down;
	up.push_back (p1);
	down.push_back (p1);

	for (size_t i = 1; i <a.size (); ++i) 
	{
		if (i == a.size () -1 || cw (p1, a [i], p2)) 
		{
			while (up.size ()>= 2 && !cw (up [up.size () -2], up [up.size () -1], a[i]))
				up.pop_back ();
			up.push_back (a [i]);
		}
		if (i == a.size () -1 || ccw (p1, a [i], p2)) 
		{
			while (down.size ()>= 2 && !ccw (down [down.size () -2], down [down.size () -1], a [i]))
				down.pop_back ();
			down.push_back (a [i]);
		}
	}

	a.clear ();
	//Rotating calliper
	/*Given a list of 2d points, finds all ways of sandwiching the points
	between two parallel lines that touch one point each, and yields the sequence
	of pairs of points touched by each pair of lines.*/

	long long dist = -1;
	int i=0,j,m;
	j=down.size()-1;
	m=up.size()-1;
	while(i<m || j>0)
	{
		dist=max(dist,dist2(up[i], down[j]));
		//if all the way through one side of hull, advance the other side
		if(i==m)
			j--;
		else if(j==0)
			i++;
		else // still points left on both lists, compare slopes of next hull edges
        // being careful to avoid divide-by-zero in slope calculation
		{
			if ( (up[i+1].y-up[i].y) * (down[j].x-down[j-1].x) > (down[j].y-down[j-1].y) * (up[i+1].x-up[i].x) )
				i++;
			else
				j--;
			}
		}
	return dist;
}

int main()
{
	int t=1;
	scanf("%d", &t);
	vector<pt> pts;
	//vector<pt> hull;
	//int inx[];
	int i, n;
	while(t--)
	{
		pts.clear();
		//hull.clear();
		scanf("%d", &n);
		for(i=0;i<n;i++)
		{
			pt a, b;
			scanf("%lld %lld", &a.x, &a.y);
			//b.x = a.x, b.y = a.y;
			pts.push_back(a);
			//hull.push_back(b);
		}
		long long ans = convex_hull(pts);
		printf("%lld\n", ans);
	}
	return 0;
}