#include <bits/stdc++.h>
using namespace std;
#define gc getchar_unlocked
#define rep(i,n) for(i=0;i<n;i++)
#define ll long long
#define FOR(i,k,n) for(i=k;i<n;i++)

const int mod = 1000000007;

void read(int &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}

void read(long long &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}

int powMod(int base, int extra_primesp) {
  base %= mod;
  int result = 1;
  while (extra_primesp > 0) {
    if (extra_primesp & 1) result = ((ll)result * base) % mod;
    base = ((ll)base * base) % mod;
    extra_primesp >>= 1;
  }
  return result;
}
int posi[114], decompose[114];
int primes[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};
int factor( int n){
	int i;
	int total = 0;
	while(n%2 == 0){
		n = n>>1;
		total |= 1<<posi[2];
	}
	i = 3;
	while(i*i<=n){
		while (n%i==0){
			n /= i;
			total |= 1<<posi[i];
		}
		i += 2;
		
	}
	if (n > 2){
		total |= 1<<posi[n];
	}	
	return total;
	
}
long long factorial[100003];
long long comb(int n, int k){
	if (k>n)
		return 0;
	long long total = factorial[n];
	
	total *= powMod(factorial[n-k], mod-2);
	total %= mod;
	total *= powMod(factorial[k], mod-2);
	total %= mod;
	return total;
}

void pre(){
    
    int i, j;
    factorial[0]=factorial[1]=1;
    int n = 1e5+3;
    FOR(i,2,n)
    	factorial[i] = (factorial[i-1]*i)%mod;
 	
}
long long dp[26][3*(1<<15)+3], total[26];

int main(){
	int t;
	pre();
	read(t);
	int i,n, m,j,k,allones;
	rep(i, 113)
		posi[i]=-1;
	rep(i, 25){
		posi[primes[i]] = i;
	}
	FOR(i, 1, 100+1)
			decompose[i] = factor(i);
	while(t--)
	{
		read(n); read(m);
		int lower_limit = 0, extra_primes = 0;
		while(primes[lower_limit]<=m)lower_limit++;
		int pri_avail = lower_limit;
		if (lower_limit>15){
			extra_primes = lower_limit-15;
			lower_limit = 15;
		}
		int N = min(n, lower_limit);
		for(i=0;i<26;i++)
			total[i]=0;
		rep(i,26)
			rep(j,(1<<15)+1)
				dp[i][j]=0;
		allones = (1<<lower_limit)-1;
		
		FOR(j,0,1<<lower_limit)
			dp[0][j] = 1;
		FOR(i, 1, N+1){
		FOR(j, 2, m+1){
			int can = j;
			if(posi[can] != -1 && j>=50)
				continue;
			FOR(k, 0, allones+1){
				if ( (k&decompose[can]) ==0){
					dp[i][k|decompose[can]] += dp[i-1][k];	
					if (dp[i][k|decompose[can]] >= mod)
						dp[i][k|decompose[can]] -= mod;
				}
			}
		}
		}
		
		
		int xx;
		xx = 1;
		
		while(xx<=pri_avail){
			
			j = 0;
		
			while(j<=xx)
			{
				long long x = comb(extra_primes, j);
				x *= dp[xx-j][allones];
				x %= mod;
				x *= comb(xx, j);
				x %= mod;
				x *= factorial[j];
				x %= mod;
				total[xx] += x;
				if (total[xx] >= mod)
					total[xx] -= mod;
				j++;
			}
			xx++;
		}
		long long result = 1;	
		FOR(i, max(0,n-pri_avail), n){
			result += (total[min(pri_avail,n-i)]*comb(n,i))%mod;
			if (result >= mod)
				result -= mod;
		}
		cout<<result<<endl;
	}
	
	return 0;
} 


