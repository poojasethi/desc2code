// http://www.codechef.com/problems/J3/
#include <cstdio>
#include <cstdlib>
#include <cstring>

#define CODE_TO_CHECK_SQUARE { int cachedOffset = i * N; if (chessBoard[cachedOffset + j].isBlocked_) { break; } if (chessBoard[cachedOffset + j].isOccupied_) { return false; } }

struct ChessBoardSquare
{
    bool isOccupied_;
    bool isBlocked_;
};

ChessBoardSquare* chessBoard;
int rowNumOccupiedByQueenForColumn[500];

int N, K;

bool isChessBoardSquareAvailableAndSafe(int row, int column)
{
    // Check for blocked status.
    if (chessBoard[(row * N) + column].isBlocked_)
        return false;

    // Check for row safety on the left side.
    for (int i = row, j = column - 1 ; j >= 0; --j)
    {
        CODE_TO_CHECK_SQUARE
    }

    // Check for row safety on the right side.
    for (int i = row, j = column + 1; j < N; ++j)
    {
        CODE_TO_CHECK_SQUARE
    }

    // Check for row safety in the bottom left quadrant.
    for (int i = row - 1, j = column - 1; i >= 0 && j >= 0 ; --i, --j)
    {
        CODE_TO_CHECK_SQUARE
    }

    // Check for row safety in the top left quadrant.
    for (int i = row + 1, j = column - 1; i < N && j >= 0 ; ++i, --j)
    {
        CODE_TO_CHECK_SQUARE
    }

    // Check for row safety in the bottom right quadrant.
    for (int i = row - 1, j = column + 1; i >= 0 && j < N ; --i, ++j)
    {
        CODE_TO_CHECK_SQUARE
    }

    // Check for row safety in the top right quadrant.
    for (int i = row + 1, j = column + 1; i < N && j < N ; ++i, ++j)
    {
        CODE_TO_CHECK_SQUARE
    }

    return true;
}

bool placeQueens(int columnNum)
{
    // The best candidate to begin with is either 1 more than the current row occupied in this column, or 0 if we've never placed anything here before.
    int rowCandidateForThisColumn = 0;

    do
    {
        // If we were previously occupying a square in this column, we must give it up now.
        if (rowNumOccupiedByQueenForColumn[columnNum] != -1)
            chessBoard[(rowNumOccupiedByQueenForColumn[columnNum] * N) + columnNum].isOccupied_ = false;

        // Look for the next possible position in this column.
        if (isChessBoardSquareAvailableAndSafe(rowCandidateForThisColumn, columnNum))
        {
            // Mark the occupation of the new square in this column.
            rowNumOccupiedByQueenForColumn[columnNum] = rowCandidateForThisColumn;
            chessBoard[(rowCandidateForThisColumn * N) + columnNum].isOccupied_ = true;

            // If this was the last column under consideration, we're done.
            if (!columnNum)
                break;

            // Try to place queens in all other columns.
            if (placeQueens(columnNum - 1))
                break; // This means that all other underlying queens were placed successfully.
        }

        // Reaching here means that we must attempt a new placement.

    }
    while (++rowCandidateForThisColumn < N);

    // If we've already tried all the rows for this column, then the previous configuration is not conducive to a solution!
    if (rowCandidateForThisColumn == N)
    {
        // If we were previously occupying a square in this column, we must give it up now.
        if (rowNumOccupiedByQueenForColumn[columnNum] != -1)
            chessBoard[(rowNumOccupiedByQueenForColumn[columnNum] * N) + columnNum].isOccupied_ = false;

        return false;
    }

    return true;
}

void printSquare()
{
    printf("\n    ");
    for (int i = 0; i < N;)
    {
        printf("%3d ", ++i);
    }
    printf("\n");

    for (int i = 0; i < N; ++i)
    {
        printf("%3d ", i + 1);
        for (int j = 0; j < N; ++j)
        {
            char c = chessBoard[(i * N) + j].isBlocked_ ? '#' : chessBoard[(i * N) + j].isOccupied_ ? 'Q' : '-';
            printf("%3c ", c);
        }
        printf("\n\n");
    }
}

int main(void)
{
    int iNumOfTestCases;
    scanf("%d", &iNumOfTestCases);

    chessBoard = (ChessBoardSquare*) malloc(sizeof(ChessBoardSquare) * 500 * 500);

    while (iNumOfTestCases--)
    {
        scanf("\n%d %d", &N, &K);

        memset(chessBoard, 0, sizeof(ChessBoardSquare) * N * N);
        memset(rowNumOccupiedByQueenForColumn, 255, sizeof(int) * N);

        int i;
        for (i = 0; i < K; ++i)
        {
            int row, column;
            scanf("%d %d", &row, &column);
            --row; --column;

            chessBoard[(row * N) + column].isBlocked_ = true;
        }

        placeQueens(N-1);

        for (i = 0; i < N; ++i)
        {
            printf("%d ", ++rowNumOccupiedByQueenForColumn[i]);
        }
        printf("\n");

//        printSquare();
    }

    return 0;
}
