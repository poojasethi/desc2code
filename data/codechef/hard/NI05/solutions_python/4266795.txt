// Author: Bin Xiao
// July 8, 2014
#include <iostream>
#include <algorithm>
#include <vector>

#define DEBUG 0
using namespace std;

const int TYPENUM = 10;
const int CONSIDER = 2;
const int MAX_MARKED=7;
int rewards[TYPENUM][TYPENUM]={
    55, 60, 4, 25, 18, 10, 12, 8, 11, 50,
    60, 45, 75, 23, 27, 20, 24, 7, 33, 12,
    4, 75, 78, 32, 36, 30, 36, 6, 12, 65,
    25, 23, 32, 15, 45, 40, 48, 5, 14, 23,
    18, 27, 36, 45, 54, 50, 60, 4, 15, 12,
    10, 20, 30, 40, 50, 60, 72, 3, 32, 34,
    12, 24, 36, 48, 60, 72, 84, 2, 23, 34,
    8, 7, 6, 5, 4, 3, 2, 1, 34, 123,
    11, 33, 12, 14, 15, 32, 23, 34, 65,48,
    50, 12, 65, 23, 12, 34, 34, 123, 48, 71
};


class Retail {
private:
    int caseNum_;
    int maxReward_;
    int markedNum_;
    int items_[TYPENUM];
    int marked_[TYPENUM];
    vector<int> original_;
    vector<int> solution_;
    vector<int> maxPair_;            //keep local optimal solution for debug
    bool solve(); 
    inline void initialSolution();
    inline void optimize();
    inline int  calcReward();
public:
    bool readInput();
};


int  Retail::calcReward() {
    int points= 0;
    for(int i=0; i<markedNum_ ; ++i){
       points += rewards[original_[i]][solution_[i]];
    }
    return points;
}

void Retail::initialSolution() {
    // greedy strategy, always select largest rewards pair among remind options
    maxReward_=0;
    solution_.clear();
    original_.clear();
    for(int i=0; i<TYPENUM; ++i) {
        if(marked_[i]) {
            original_.push_back(i);         //do not change original_
            solution_.push_back(i);         //each type can have only to reward, final soultion is <original_,soultion_>
        }
    }
    maxReward_ = calcReward();              //initial reward
}

void Retail::optimize(){
    //enumerate all possible permunation
    while( next_permutation(solution_.begin(),solution_.end()) ){
        int newReward = calcReward();
        if ( newReward > maxReward_ ){
            maxReward_ = newReward;
            // copy current optimal solution to maxPair_   
            if(DEBUG) maxPair_.assign(solution_.begin(),solution_.end());
        }
    }
    cout<<maxReward_<<endl;
    if (DEBUG)  cout<<endl;
}

bool Retail::solve() {
    initialSolution();
    // the initial resutlt sometimes is not optimal,use mutation to improve
    optimize();
    return true;
}

bool Retail::readInput() {
    cin>>caseNum_;
    if (caseNum_<=0){
        cout<<"Wrong test case number:"<<caseNum_<<endl;
        return false;
    }

    while(caseNum_--){
        for(int i=0;i<TYPENUM; ++i){    //input items the customer bought
            cin>>items_[i];
            if(items_[i]&1) {
                cout<<"Number of items "<<i<<" = "<<items_[i]<<" is NOT even"<<endl;
                return false;
            }
        }
        markedNum_=0;
        for(int i=0;i<TYPENUM; ++i){    //input the marked flag
            cin>>marked_[i];
            if(marked_[i]&&(marked_[i]!=1)){
                cout<<"Read marked flag "<< i<<" error, "<<marked_[i]<<" is not a bitmap"<<endl;
            } else {
                markedNum_ += marked_[i];
                if( markedNum_ > MAX_MARKED ){
                    cout<<"Marked "<<markedNum_<<" items,too many!"<<endl;
                    return false;
                }
            }
        }
        solve();
    }    
    return true;
}

int main() {
    Retail my;
    my.readInput();
    return 0;
}

