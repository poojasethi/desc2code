/* Author : Mayank Natani
   Email-id : mayanknatani6@gmail.com, mayank.natani@students.iiit.ac.in 
   Blog : mayanknatani.wordpress.com */
 
/* Data Structure Includes */
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <bitset>
#include <stack>
 
/*other Includes */
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
 
/* C Includes */
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
 
using namespace std;
typedef vector<int > vi;
typedef vector<long long int > vl;
typedef vector<bool > vb;
typedef vector<char > vc;
typedef vector<float > vf;
typedef vector<double > vd;
typedef vector<vi > vvi;
 
#define pb push_back
#define si(n) scanf("%d",&n)
#define sc(n) scanf("%c",&n)
#define sf(n) scanf("%f",&n)
#define sd(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define all(a) a.begin(),a.end()
#define tr(container,it) for(typeof(container.begin()) it = container.begin() ; it != container.end() ; it++) //to traverse any container
#define present(container,element) (container.find(element)!=container.end()) //should be used for set,map etc.
#define vpresent(container,element) (find(all(container),element)!=container.end()) //should be used for vectors.
#define PI 3.14159265359
#define DegToRad(a) PI/180*all
#define RadToDeg(a) 180/PI*a
#define LL long long int 
#define MOD 1000000007
#define INF (1<<30)
int gcd(int a, int b) { while(b) b^=a^=b^=a%=b; return a; }

int reward[]={
	55	,60	,4	,25	,18	,10	,12	,8	,11	,50
	,60	,45	,75	,23	,27	,20	,24	,7	,33	,12
	,4	,75	,78	,32	,36	,30	,36	,6	,12	,65
	,25	,23	,32	,15	,45	,40	,48	,5	,14	,23
	,18	,27	,36	,45	,54	,50	,60	,4	,15	,12
	,10	,20	,30	,40	,50	,60	,72	,3	,32	,34
	,12	,24	,36	,48	,60	,72	,84	,2	,23	,34
	,8	,7	,6	,5	,4	,3	,2	,1	,34	,123
	,11	,33	,12	,14	,15	,32	,23	,34	,65	,48
	,50	,12	,65	,23	,12	,34	,34	,123,48	,71
};

vi a;
int dp[15][(1<<15) +100];

int solve(int idx,int mask){
	if(idx==a.size())
		return 0;
	if(dp[idx][mask]!=-1)
		return dp[idx][mask];

	if(mask & (1<<idx)){
		dp[idx][mask] = solve(idx+1,mask);
		return solve(idx+1,mask);
	}

	int ans=solve(idx+1,mask);
	int temp_mask;
	for(int i=0;i<a.size();i++){
		temp_mask = mask;
		if(i!=idx && !(mask & (1<<i))) {
			temp_mask = temp_mask | (1<<i);
			temp_mask = temp_mask | (1<<idx);
			ans = max(ans,reward [a[idx]*10 + a[i]] + solve(idx+1,temp_mask));
		}
	}
	dp[idx][mask]=ans;
	return ans;
}

int main(){
	int test;
	si(test);
	while(test--){
		a.clear();
		memset(dp,-1,sizeof(dp));
		int num;
		for(int i=0;i<10;i++)
			si(num);
		for(int i=0;i<10;i++){
			si(num);
			if(num==1){
				a.pb(i);
				a.pb(i);
			}
		}
		printf("%d\n",solve(0,0));
	}
	return 0;
}
