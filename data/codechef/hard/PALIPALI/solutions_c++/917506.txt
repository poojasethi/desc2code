#pragma comment(linker,"/STACK:64000000")
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <sstream>
#include <cmath>
#include <ctime>
#include <memory.h>

#define WR printf
#define RE scanf
#define PB push_back
#define SE second
#define FI first
#define MP make_pair

#define FOR(i,Be,En) for(int (i)=(Be);(i)<=(En);++(i))
#define DFOR(i,Be,En) for(int (i)=(Be);(i)>=(En);--(i))
#define SZ(a) (int)((a).size())
#define FA(i,v) FOR(i,0,SZ(v)-1)
#define RFA(i,v) DFOR(i,SZ(v)-1,0)
#define CLR(a) memset(a,0,sizeof(a))

#define LL  long long
#define VI  vector<int>
#define PAR pair<int ,int> 

using namespace std;
void __never(int a){printf("\nOPS %d", a);}
void __die(int a){printf("%d",(a*a)/(a+a));}
#define ass(s) {if (!(s)) {__never(__LINE__);cout.flush();cerr.flush();__die(0);}}


#define MN 100500
#define PP 100007


struct Tree{
	int m[MN+MN];
	int n;
	void Init(int N){
		n = N;
		FOR(i,1,n+n-1) m[i] = 0;
	}
	void Add(int pos, int val) {
		ass(1<=pos && pos<=n);
		pos+=n-1;
		m[pos] += val;
		while (pos > 1){
			pos >>= 1;
			m[pos] = m[pos+pos] + m[pos+pos+1];
		}
	}
	int Sum(int i, int j){
		//WR("sum(%d,%d)\n",i,j);
		if (i > j) return 0;
		ass(1<=i && i<=j && j<=n);
		i += n-1;
		j += n-1;
		int res = 0;
		while (i <= j){
			if ((i&1) == 1) res += m[i];
			if ((j&1) == 0) res += m[j];
			i = (i + 1) >> 1;
			j = (j - 1) >> 1;
		}
		return res;
	}
};




Tree tr;
LL ha[MN], rha[MN], ps[MN];
int pa[MN], se[MN];
char s[MN];
int n;
PAR q[MN+MN];
bool pali(int p, int len) {
	ass(p+len-1 <= n);
	LL h1 = ha[p+len-1] - ha[p-1]*ps[len];
	p = n - p + 2;
	ass(p+len-1 <= n);
	LL h2 = rha[p+len-1] - rha[p-1]*ps[len];
	return h1 == h2;
}
void init()
{
	freopen("input.txt","r",stdin);
	freopen("output.txt","w",stdout);
}
void sol(){	
	//cin >> s;
	gets(s);
	n = strlen(s);
	ha[0] = 0;
	FOR(i,1,n) ha[i] = ha[i-1]*PP + s[i-1];
	reverse(s, s + n);
	rha[0] = 0;
	FOR(i,1,n) rha[i] = rha[i-1]*PP + s[i-1];
	pa[0] =  0;
	FOR(i,2,n) {
		int low = 1, hi = min(i-1, n-i+1);
		if (!pali(i,low)) {
			pa[i] = 0;
		} else {
			while (low < hi) {
				int ce = (low + hi + 1) / 2;
				if (pali(i,ce)) {
					low = ce;
				} else {
					hi = ce-1;
				}
			}
			pa[i] = low;
		}
	}
	
	
	FOR(i,1,n) se[i] = i - pa[i];
	
	
	int ans = 0;
	
	
	int cc = 0;
	FOR(i,1,n) q[cc++] = MP(se[i],i);
	sort(q, q + cc);
	tr.Init(n);
	int cp = 0;
	FOR(i, 1, n) {
		while (cp < cc && q[cp].FI <= i) {
			tr.Add(q[cp].SE, 1);
			cp++;
		}
		ans += tr.Sum(i+1,i+pa[i]/2);
	}
	
	/*
	FOR(i,1,n) {
		int la = 0;
		FOR(j,i+1,i+pa[i]/2) if (se[j] <= i) la++;
		WR("la(%d) = %d\n",i,la);
		ans += la;
	}
	*/
	cout << ans << endl;
	
}
int main()
{
	//init();
	ps[0] = 1;
	FOR(i,1,MN-1) ps[i] = ps[i-1]*PP;
	int T;
	RE("%d",&T);
	gets(s);
	FOR(t,1,T)
		sol();	
	return 0;
}