#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <set>
#include <cstring>
using namespace std;
#define pb push_back
#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))
#define FORI(i,n) for(int (i)=1;(i)<=(n);++(i))
#define ll long long
#define vi vector<int>
#define sz size()
#define wez(n) int (n); scanf("%d",&(n));
template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";}
template<typename T> ostream& operator<<(ostream &s,vector<T> t){int k=0;FOR(i,t.size()){s<<k++<<": "<<t[i]<<endl;}return s; }
#define DBG(vari) cout<<#vari<<" = "<<vari<<endl;
#define TESTS wez(tes)while(tes--)

// np. parzysty dla aaaa zwraca: 0 1 2 1
vector<int> manacher(string s, bool parzysty) {
   int n = s.length();
   vector<int> res(n);
   int l = 0, r = -1;
   FOR(i,n) {
   	int k;
   	if (i>r) k = 1;
   	else k = min(res[l+r-i+parzysty], r-i+parzysty) + 1;
   	while (i+k-parzysty < n && i-k >= 0 && s[i+k-parzysty] == s[i-k]) ++k;
   	res[i] = --k;
   	if (i+k-parzysty > r){
         l = i-k;
         r = i+k-parzysty;
      }
   }
   return res;
}

int FFF[200006];
struct mycomp {
   bool operator() (const int & p, const int & q) const {
      return FFF[p] < FFF[q];
   }
};

char s[100006];

vi mm;
int len;

void addd (int val, int v, int x, int from, int to) {
   mm[v]+=val;
   if (from>=to) return;
   int mid = (from+to)/2;
   if (x <= mid) addd(val,2*v,x,from,mid);
   else addd(val,2*v+1,x,mid+1,to);
}

int how (int v, int x, int from, int to) {
   if (from>=to) return mm[v];
   int mid = (from+to)/2;
   if (x <= mid) return mm[2*v+1] + how(2*v,x,from,mid);
   return how(2*v+1,x,mid+1,to);
}

int howmanybigeq (int x) {
   return how(1,x,0,len);
}

void add (int val, int x) {
   addd(val,1,x,0,len);
}



int main () {
   TESTS {
      scanf("%s",s);
      len = strlen(s);
      vi m = manacher(s,1);
      m.erase(m.begin());
      FOR(i,len-1) {
         FFF[i]=i+m[i];
      }
      mm.clear();
      FOR(i,10*len+10) mm.pb(0);
      ll wyn=0;
      
      multiset<int,mycomp> fowy;
      FORI(i,len-3) {
         fowy.insert(i-1);
         add(1,i-1);
         while(1) {
            if (fowy.empty()) break;
            int j = *(fowy.begin());
            if (FFF[j] >= i) break;
            fowy.erase(fowy.begin());
            add(-1,j);
         }

         wyn += howmanybigeq(i - m[i]/2);
      }
      
      printf("%lld\n",wyn);
   }
}

