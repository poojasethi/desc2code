#include<bits/stdc++.h>

using namespace std;

//Truly one of the best DP problems I have ever come across. 

long double dp[55][105][55];

int main() {

cin.sync_with_stdio(0);
cin.tie(0);

int T;
cin>>T;

while(T--) {

//dp[i][j][k] denotes probability of ith object to have jth color in kth turn
int N,C,K;
cin>>N>>C>>K;



for(int i=0;i<=N;i++)
 for(int j=1;j<=C;j++)
  for(int k=0;k<=K;k++)
   dp[i][j][k]=(double)0;

for(int i=1;i<=N;i++)
 dp[i][1][0]=1;	//all objects are colored with 1 initially

for(int k=1;k<=K;k++) {
int l,r;
cin>>l>>r;

for(int i=1;i<=N;i++)
 for(int j=1;j<=C;j++) {
  if(i>=l&&i<=r) {		//LE chooses color j to paint the fence
    for(int jj=1;jj<=C;jj++) { 	//If initial color of fence was jj
     dp[i][(j*jj)%C][k]+=0.5*dp[i][jj][k-1]*1/C;	//LE chooses to paint the fence
     dp[i][jj][k]+=0.5*dp[i][jj][k-1]*1/C;		//LE does not choose the fence
     }
   }
  else
   dp[i][j][k]=dp[i][j][k-1];
}

}

long double fans=0;
for(int i=1;i<=N;i++)  
 for(int j=1;j<=C;j++)
  fans+=j*dp[i][j][K];


cout<<setprecision(10)<<fans<<"\n";
}

	return 0;
}
