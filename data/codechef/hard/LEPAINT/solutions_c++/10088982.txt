//Author : pakhandi
//
using namespace std;

#include<bits/stdc++.h>

#define wl(n) while(n--)
#define fl(i,a,b) for(i=a; i<b; i++)
#define rev(i,a,b) for(i=a; i>=b; i--)

#define si(n) scanf("%d", &n)
#define sll(l) scanf("%lld",&l)
#define ss(s) scanf("%s", s)
#define sc(c) scanf("%c", &c)
#define sd(f) scanf("%lf", &f)

#define pi(n) printf("%d\n", n)
#define pll(l) printf("%lld\n", l)
#define ps(s) printf("%s\n", s)
#define pc(c) printf("%c\n", c)
#define pd(f) printf("%lf\n", f)

#define debug(x) cout<<"\n#("<<x<<")#\n"
#define nline printf("\n")

#define mem(a,i) memset(a,i,sizeof(a))

#define MOD 1000000007
#define ll long long int
#define u64 unsigned long long int

#define mclr(strn) strn.clear()
#define ignr cin.ignore()
#define PB push_back
#define SZ size
#define MP make_pair
#define fi first
#define sec second

int objects, turns, colors;
std::vector<pair<int,int> > range;

double dp[51][102];
int ind;

double rec(int turn, int color)
{
    //base case
    if(turn == turns)
    {
        return color;
    }

    //memoisation part
    double &ret = dp[turn][color];
    if(ret >= 0)
        return ret;

    ret = 0.0;
    int i, j;

    int l = range[turn].first, r = range[turn].second;

    //index ind is within the range for this turn
    if(ind >= l && ind <= r)
    {
        // either we can change the color of this index to any other color
        // so probability of this action is.. (0.5) * (1 / colors)
        // 0.5 because we can change the color, or not change the color
        // and (1 / colors) is because we can choose any color from colors

        //                                       ____ (1 / colors) color 1
        //     change color of this index____0.5/____ (1 / colors) color 2
        //                              /       \____ (1 / colors) color n
        //                              \
        //                               \
        //                                \
        // don't change color of this index\____0.5

        fl(i,0,colors)
        {
            ret += rec(turn + 1, (color * i) % colors) * 0.5 * ( 1 / (colors * 1.0) );
        }

        ret += rec(turn + 1, color) * 0.5;
    }
    else
    {
        // if we can't change the color of this index in this turn,
        // the next state is same with no color change
        ret += rec(turn + 1, color);
    }

    return ret;
}

int main()
{
    int i, j, k;

    int cases;

    si(cases);

    wl(cases)
    {

        

        range.clear();

        si(objects);    si(colors); si(turns);

        fl(i,0,turns)
        {
            int l, r;
            si(l);  si(r);
            l--;    r--;
            range.PB(MP(l,r));
        }

        double ans = 0.0;

        //calculate the expected value of index i and add it to our final answer
        fl(i,0,objects)
        {
            fl(k,0,51)
                fl(j,0,102)
                        dp[k][j] = -1.0;
            //0-th turn, i-th index, initial color is 1
            ind = i;
            ans += rec(0,1);
        }

        printf("%.10lf\n", ans);

    }


    return 0;
}
/*
    Powered by Buggy Plugin
*/
