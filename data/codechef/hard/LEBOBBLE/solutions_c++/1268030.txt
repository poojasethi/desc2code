#include <cassert>
#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <cstring>

using namespace std;

struct FenwickTree {
    FenwickTree(int N): n(N), T(N+1, 0ll) {}
    void change(int x, long long by) {
        while (x <= n) {
            T[x] += by;
            x += x&-x;
        }
    }
    long long sum(int a, int b) const {
        long long sol = 0;
        for (--b; b>0; b-=b&-b) sol += T[b];
        for (--a; a>0; a-=a&-a) sol -= T[a];
        return sol;
    }

    int n;
    vector<long long> T;
};

const int MAXN = 50000;
int vals[2*MAXN];
int X[MAXN];
int P[MAXN];
int n;

int idx(int x) {
    return lower_bound(vals, vals+2*n, x) - vals;
}
inline long long calc(int pos, long long prob, const FenwickTree &T) {
    return prob * T.sum(pos+1, 2*n+1);
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int d;
        scanf("%d %d", &n, &d);
        for (int i=0; i<n; ++i) {
            scanf("%d", &X[i]);
            vals[2*i] = X[i];
            vals[2*i+1] = X[i] + d;
        }
        sort(vals, vals+2*n);
        for (int i=0; i<n; ++i) {
            scanf("%d", &P[i]);
        }
        
        FenwickTree T(2*n);
        long long sol = 0;
        for (int i=0; i<n; ++i) {
            int a = idx(X[i]) + 1; // + 1 because FenwickTree doesn't handle 0
            int b = idx(X[i] + d) + 1;
            sol += calc(a, 100-P[i], T);
            sol += calc(b,     P[i], T);
            T.change(a, 100-P[i]);
            T.change(b,     P[i]);
        }
        printf("%.4f\n", double(sol)/10000.0);
    }
    
	return 0;
}
