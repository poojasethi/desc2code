#include <cassert>
#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <cstring>

using namespace std;

class TournamentTree {
public:
    TournamentTree(int N) {
        for (n=1; n<N; n<<=1);
        T.assign(2*n, 0ll);
    }
    
    void change(int x, long long by) {
        x += n;
        T[x] += by;
        for (x/=2; x>0; x/=2) {
            T[x] = T[2*x] + T[2*x+1];
        }
    }

    long long sum(int l, int r) const {
        this->l = l;
        this->r = r;
        return sum(1, 0, n);
    }
private:
    int n;
    mutable int l, r;
    vector<long long> T;

    long long sum(int node, int a, int b) const {
        if (r<=a || l>=b) {
            return 0;
        }
        if (l<=a && b<=r) {
            return T[node];
        }
        const int mid = (a+b)/2;
        return sum(2*node, a, mid) + sum(2*node+1, mid, b);
    }
};

const int MAXN = 50000;
int vals[2*MAXN];
int X[MAXN];
int P[MAXN];
int n;

int idx(int x) {
    return lower_bound(vals, vals+2*n, x) - vals;
}
inline long long calc(int pos, long long prob, const TournamentTree &T) {
    return prob * T.sum(pos+1, 2*n);
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int d;
        scanf("%d %d", &n, &d);
        for (int i=0; i<n; ++i) {
            scanf("%d", &X[i]);
            vals[2*i] = X[i];
            vals[2*i+1] = X[i] + d;
        }
        sort(vals, vals+2*n);
        for (int i=0; i<n; ++i) {
            scanf("%d", &P[i]);
        }
        
        TournamentTree T(2*n);
        long long sol = 0;
        for (int i=0; i<n; ++i) {
            int a = idx(X[i]);
            int b = idx(X[i] + d);
            sol += calc(a, 100-P[i], T);
            sol += calc(b,     P[i], T);
            T.change(a, 100-P[i]);
            T.change(b,     P[i]);
        }
        printf("%.4f\n", double(sol)/10000.0);
    }
    
	return 0;
}
