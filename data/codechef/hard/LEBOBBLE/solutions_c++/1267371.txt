#include <cassert>
#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <cstring>

using namespace std;

class TournamentTree {
public:
    TournamentTree(int N) {
        for (n=1; n<N; n<<=1)
            ;
        T.assign(2*n - 1, 0ll);
    }
    
    void change(int x, long long by) {
        x += n - 1;
        assert(x < (int)T.size());
        T[x] += by;
        for (x=(x-1)/2; ; x=(x-1)/2) {
            assert(x*2 + 2 < (int)T.size());
            T[x] = T[x*2+1] + T[x*2+2];
            if (x == 0) {
                break;
            }
        }
    }

    long long sum(int l, int r) const {
        this->l = l;
        this->r = r;
        return sum(0, 0, n);
    }
private:
    int n;
    mutable int l, r;
    vector<long long> T;

    long long sum(int node, int a, int b) const {
        if (r<=a || l>=b) {
            return 0;
        }
        if (l<=a && b<=r) {
            assert(node < (int)T.size());
            return T[node];
        }
        const int mid = (a+b)/2;
        return sum(2*node+1, a, mid) + sum(2*node+2, mid, b);
    }
};

const int MAXN = 50000;
int vals[2*MAXN];
int X[MAXN];
int P[MAXN];
int n;

int idx(int x) {
    return lower_bound(vals, vals+2*n, x) - vals;
}
inline long long calc(int pos, long long prob, const TournamentTree &T) {
    return prob * T.sum(pos+1, 2*n);
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int d;
        scanf("%d %d", &n, &d);
        for (int i=0; i<n; ++i) {
            scanf("%d", &X[i]);
            vals[2*i] = X[i];
            vals[2*i+1] = X[i] + d;
        }
        sort(vals, vals+2*n);
        for (int i=0; i<n; ++i) {
            scanf("%d", &P[i]);
        }
        
        TournamentTree T(2*n);
        long long sol = 0;
        for (int i=0; i<n; ++i) {
            int a = idx(X[i]);
            int b = idx(X[i] + d);
            sol += calc(a, 100-P[i], T);
            sol += calc(b,     P[i], T);
            T.change(a, 100-P[i]);
            T.change(b,     P[i]);
        }
        printf("%.4f\n", double(sol)/10000.0);
    }
    
	return 0;
}
