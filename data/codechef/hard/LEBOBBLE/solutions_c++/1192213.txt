#include <stdio.h>
#include <algorithm>
using namespace std;
#define mp make_pair

template<class T>
class BIT {
  T *tree;
  int maxVal;
  public:
  T Mod;
  BIT(int N) {
    tree = new T[N+1];
    for(int i=0;i<N+1;++i) tree[i]=0;
    maxVal = N;
  }
  // Update frequency at index idx
  void update(int idx, T val) {
    //int idx2=idx+1;
    while(idx<=maxVal){
      tree[idx]+=val;
      idx += (idx & -idx);
    }
  }
  // Return cumulative frequency at index idx
  T read(int idx) {
    T sum=0;
    while(idx>0){
      sum+=tree[idx];
      idx -= (idx & -idx);
    }
    return sum;
  }
};

int B[50000], P[50000];
pair<int,int> Data[100000];  

int main(void){
  int i,j,T,n,d;
  long long ans;
  for(scanf("%d",&T);T>0;--T){
    scanf("%d %d",&n,&d);

    for(i=0;i<n;++i)scanf("%d",B+i);
    for(i=0;i<n;++i){
      scanf("%d",P+i);
      Data[2*i]=mp(B[i],2*i);
      Data[2*i+1]=mp(B[i]+d,2*i+1);
    }
    sort(Data,Data+2*n);
    BIT<long long> Bit(n);
    for(ans=0,j=2*n-1;j>=0;--j){
      i = Data[j].second; 
      if(i&1){
        i>>=1;
        ans+=Bit.read(i)*P[i];
        Bit.update(i+1,P[i]);
      } else {
        i>>=1;
        ans+=Bit.read(i)*(100-P[i]);
        Bit.update(i+1,100-P[i]);
      }      
    }
    printf("%.4f\n",(double)ans/10000.);
  }
  return 0;
}
