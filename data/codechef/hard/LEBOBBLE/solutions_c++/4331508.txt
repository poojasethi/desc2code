#include<iostream>
#include<map>
#include<vector>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<fstream>
using namespace std;
#define abs(x) ((x)>0?(x):-(x))
#define MaxVal n
#define lld signed long long int
#define pp pop_back()
#define ps(x) push_back(x)
#define tkint(n) scanf("%d",&n)
#define tkchar(ch) scanf("%c",&ch)
#define tklong(n) scanf("%I64d",&n)
map<lld,int> mp;
int n,p[50000+5];
lld b[50000+5],tree1[50000+5],tree2[50000+5];
vector<lld>tmp;
int where(lld x)
{
	if(x<=0)return 0;
	int xx=upper_bound(tmp.begin(),tmp.end(),x)-tmp.begin();
	return xx-1;
}
int fre_query(int idx){
	int sum = 0;
	while (idx > 0){
		sum += tree1[idx];
		idx -= (idx & -idx);
	}
	return sum;
}
int sum_query(int idx){
	int sum = 0;
	while (idx > 0){
		sum += tree2[idx];
		idx -= (idx & -idx);
	}
	return sum;
}
void sum_update(int idx ,int val){
	while (idx <= MaxVal){
		tree2[idx] += val;
		idx += (idx & -idx);
	}
}
void fre_update(int idx ,int val){
	while (idx <= MaxVal){
		tree1[idx] += val;
		idx += (idx & -idx);
	}
}
int main()
{
	int t,tt,temp,x;
	lld k,sum;
	cin>>t;
	while(t--)
	{
		mp.clear();
		cin>>n>>k;
		tmp.clear();
		tmp.ps(0);
		for(int i=1;i<=n;++i)scanf("%llu",&b[i]),tmp.ps(b[i]);
		for(int i=1;i<=n;++i)tkint(p[i]);
		sort(tmp.begin()+1,tmp.end());
		for(int i=1;i<=n;++i)
		{
			tree1[i]=tree2[i]=0;
			mp[tmp[i]]=i;
		}
		double ans=0;
		for(int i=1;i<=n;++i)
		{
			temp=fre_query(n)-fre_query(mp[b[i]]);
			x=where(b[i]-k);
			sum=sum_query(mp[b[i]])-sum_query(x);
			ans+=(1-p[i]/100.0)*(temp+sum/100.0);
			//cout<<i<<'\t'<<temp<<' '<<sum<<'\t'<<(p[i]/100.0)*(temp+sum/100.0)<<endl;

			temp=fre_query(n)-fre_query(where(b[i]+k));
			x=mp[b[i]];
			sum=sum_query(where(b[i]+k))-sum_query(mp[b[i]]);
			ans+=(p[i]/100.0)*(temp+sum/100.0);
			//cout<<i<<'\t'<<temp<<' '<<sum<<'\t'<<(1-p[i]/100.0)*(temp+sum/100.0)<<endl<<endl;
			fre_update(mp[b[i]],1);
			sum_update(mp[b[i]],p[i]);
		}
		printf("%0.4f\n",ans);
	}
}
/*6 3
4 1 2 3 6 5
20 30 40 50 60 70
*/
