#include <bits/stdc++.h>
#define mxlg 20
#define MAXN 100111
using namespace std;

const int INF = (1<<30);
typedef pair<int, int > res;

struct edge {
   int a, b, weight;
   edge() {}
   edge(int a,int b, int weight) : a(a), b(b), weight(weight) {
   }
   
};

struct decxx {
    int d, i, j;
    decxx() {}
    decxx(int d, int i, int j): d(d), i(i), j(j) {}
};




struct node {
   int anc[mxlg];
   
   int weight;
   int parent;
   int l, r;
   int leftmost, rightmost;
   int position;
   
   
   node() {}
   
   node( int weight , int l = -1, int r=-1) : l(l), r(r), weight(weight) {
      leftmost = -1;
      rightmost = -1;
      position = -1;
   }
};


res add(res a, res b) {
   if (a.first < b.first ) {
      return a;
   } else if (a.first > b.first) {
      return b;
   }
   
   
   return make_pair(a.first, a.second+b.second);
}

struct segtree {
   int i, j;
   res val;
   segtree *l, *r;
   
   int del;
   
   segtree(int i, int j ) : i(i), j(j) {
      del = 0;
      
      if ( i + 1 == j ) {
         l = NULL;
         r = NULL;
         
         val = make_pair(0, 1);
      } else {
         int k = (i+j)>>1;
         l = new segtree(i, k);
         r = new segtree(k, j);
         
         val = add(l->val, r->val);
      }
       
   }
   
    res query(int I, int J) {
       visit();
        if (I <= i && j <= J) {
            return val;
        } else if (j <= I || J <= i) {
            return make_pair(INF, 0);
        } else {
            return add(l->query(I, J), r->query(I, J));
        }
    }
    
   void visit() {
        if (del) {
            val = make_pair(val.first + del, val.second);
            if (l) {
                l->del += del;
                r->del += del;
            }
            del = 0;
        }
    }

   
    void inc(int I, int J, int d) {
        if (I <= i && j <= J) {
            del += d;
            visit();
        } else {
            visit();
            if (!(j <= I || J <= i)) {
                l->inc(I, J, d);
                r->inc(I, J, d);
                val = add(l->val, r->val);
            }
        }
    }
};

/*
1
9
1 2 16
3 2 19
2 4 10
4 5 20
5 6 8
5 7 15
5 8 12
7 9 7
3 1
3 5 17
8 3 12
10 6 8
*/


struct edge edges[MAXN];
struct node nodes[2*MAXN];
int parent[MAXN];
int root[MAXN];
bool vis[2*MAXN];
int R;

int cmp(edge x, edge y) {
   return x.weight < y.weight;
}

int find(int u) {
   if (parent[u] < 0 ) {
      return u;
   }
   
   return find(parent[u]);
}

int uni(int a, int b) {
   
   if (parent[a] == parent[b]) {
      parent[b]--;
   }
   
   if (parent[a] < parent[b]) {
      return (parent[b] = a);
      
   } else if (parent[a] > parent[b]) {
      return (parent[a] = b);
   }
}

void init(int i , int pos) {
   
   int j = nodes[i].anc[0] = nodes[i].parent;
   
   for (int k = 1; k < mxlg ; k++) {
      j = nodes[i].anc[k] = nodes[j].anc[k-1];
   }
   
   nodes[i].position = pos;
   
}

int find_root(int u, int w) {
   
   if (nodes[R].weight <= w) {
      return R;
   }
   
   int k = 0; 
   
   while ( nodes[nodes[u].anc[k]].weight <= w  ) {
      u = nodes[u].anc[k];
      k++;
   }
   
   while ( k-- ) {
      
      if (nodes[nodes[u].anc[k]].weight <= w) {
         u = nodes[u].anc[k];
      }
      
   }
   
   return u;
}


segtree *seg;
void rq_init(int n) {
   seg = new segtree(0, n);
}

void rq_inc(int i, int j, int d) {
   seg->inc(i , j+1, d);
}

int rq_query(int i, int j) {
   res p = seg->query(i, j+1);
   return (p.first ) ? 0:p.second;
   
}
int main() {
   int t;
   scanf("%d", &t);
   
   while (t--) {
      int n;
      scanf("%d", &n);
      for (int i = 0; i < n-1; i++) {
         int a, b, w;
         scanf("%d %d %d ", &a, &b, &w);
         a--;
         b--;
         
         edges[i] = edge(a, b, w);
      }
      
      for (int i = 0; i < n; i++) {
         nodes[i] = node(0);
         parent[i] = -1;
         root[i] = i;
      }
      
      sort(edges, edges+n-1, cmp);
      int N = n;
      
      for (int i = 0; i < n-1; i++) {
         
         int u = find(edges[i].a);
         int v = find(edges[i].b);
         int w = edges[i].weight;
         
         int k = uni(u, v);
         
         nodes[N] = node(w, root[u], root[v]);
         nodes[root[u]].parent = nodes[root[v]].parent = N;
         root[k] = N++;
      }
      
      R = N-1;
      for (int i = 0; i < N; i++) {
        vis[i] = false;
      }
    
    
      nodes[R].parent = R;
      
      vector<int> stack;
      vector<int> pre;
      
      stack.push_back(R);
      int pos =  0 ;
      
      while (!stack.empty()) {
         int i = stack.back();
         stack.pop_back();
         pre.push_back(i);
         
         init(i, pos);
         
         if ( i < n ) {
            pos++;
         }
         
         int j ; 
         
         if ( ~ ( j = nodes[i].r) && !vis[j] ) {
            stack.push_back(j);
            vis[j] = true;
         }
         
         if ( ~( j = nodes[i].l)&& !vis[j] ) {
            stack.push_back(j);
            vis[j] = true;
         }
      }
      
      for (int i = N-1; i >= 0; i--) {
         
         int k = pre[i];
         nodes[k].leftmost  = (~nodes[k].l && ~nodes[nodes[k].l].leftmost ) ? nodes[nodes[k].l].leftmost  : nodes[k].position;
         nodes[k].rightmost = (~nodes[k].r && ~nodes[nodes[k].l].rightmost) ? nodes[nodes[k].r].rightmost : nodes[k].position;
      }
      
      int Q, X;
      scanf("%d %d ", &Q, &X);
      
      rq_init(n);
      
      vector<decxx> decs;
      int f = 0;
      
      
      
      while (Q--) {
         int d, u, weight;
         scanf("%d %d %d", &d, &u, &weight);
         
         u--;
         
         int root = find_root(u, weight);
         
         
         int i = nodes[root].leftmost ;
         int j = nodes[root].rightmost ;
         
         for (; f < decs.size() && decs[f].d <= d; f++) {
            rq_inc(decs[f].i, decs[f].j, -1);
        }
         
         int ans = rq_query(i, j);
         
         
         cout<<ans<<endl;
         
         decs.push_back( decxx(d+X, i, j) );
         
         rq_inc(i , j , +1);
      }
      
   }
	return 0;
}

