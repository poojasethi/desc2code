#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}

int q;
struct node{
	int opt;
	int x[2][2];
}que[111111];
int ans[111111];
int addid[111111]={0},adtot=0;
map<int,int>mx,my;
int xtot=0,ytot=0;

int gai[111111],wen[111111];
int gtot,wtot;

int bit[211111]={0};
void bitupd(int x,int del){for (;x<=xtot;x+=x&-x)bit[x]+=del;}
int bitque(int x){int ans=0;for(;x;x-=x&-x)ans+=bit[x];return ans;}
int cmpg(int i,int j){
	return que[i].x[1][1]<que[j].x[1][1];
}
int cmpw(int i,int j){
	return que[i].x[1][0]<que[j].x[1][0];
}
void work(int l,int r){
	if(l==r)return;
	gtot=wtot=0;
	int mid=l+r>>1;
	for (int i=l;i<=mid;i++)if(que[i].opt)gai[++gtot]=i;
	for (int i=mid+1;i<=r;i++)if(!que[i].opt)wen[++wtot]=i;
	sort(gai+1,gai+1+gtot,cmpg);
	sort(wen+1,wen+1+wtot,cmpw);
	int cur=0;
	for (int i=1;i<=wtot;i++){
		while(cur<gtot && que[gai[cur+1]].x[1][1]<que[wen[i]].x[1][0]){
			cur++;
			bitupd(que[gai[cur]].x[0][0],que[gai[cur]].opt);
		}
		ans[wen[i]]-=bitque(que[wen[i]].x[0][1]);
	}
	for (int i=1;i<=cur;i++)bitupd(que[gai[i]].x[0][0],que[gai[i]].opt*-1);
	work(l,mid);
	work(mid+1,r);
}
int main()
{
	gn(q);
	int tmp=0;
	for (int i=1;i<=q;i++){
		char c;while((c=getchar())<'A'||c>'Z');
		if(c=='I' || c=='Q'){
			gn(que[i].x[0][0]),gn(que[i].x[1][0]),gn(que[i].x[0][1]),gn(que[i].x[1][1]);
			mx[que[i].x[0][0]];
			mx[que[i].x[0][1]];
			my[que[i].x[1][0]];
			my[que[i].x[1][1]];
		}
		if(c=='I'){
			tmp++;
			que[i].opt=1;
			addid[++adtot]=i;
		}else if(c=='Q'){
			que[i].opt=0;
			ans[i]=tmp;
		}else{
			int x;gn(x);
			if(addid[x]==-1){
				q--;
				i--;
				continue;
			}
			tmp--;
			que[i]=que[addid[x]];
			que[i].opt=-1;
			addid[x]=-1;
		}
	}
	for (map<int,int>::iterator it=mx.begin();it!=mx.end();it++)it->second=++xtot;
	for (map<int,int>::iterator it=my.begin();it!=my.end();it++)it->second=++ytot;
	for (int i=1;i<=q;i++){
		que[i].x[0][0]=mx[que[i].x[0][0]];
		que[i].x[0][1]=mx[que[i].x[0][1]];
		que[i].x[1][0]=my[que[i].x[1][0]];
		que[i].x[1][1]=my[que[i].x[1][1]];
	}
	for (int j=0;j<4;j++){
		work(1,q);
		for (int i=1;i<=q;i++){
			int X1=ytot-que[i].x[1][1]+1;
			int X2=ytot-que[i].x[1][0]+1;
			int Y1=que[i].x[0][0];
			int Y2=que[i].x[0][1];
			que[i].x[0][0]=X1;
			que[i].x[0][1]=X2;
			que[i].x[1][0]=Y1;
			que[i].x[1][1]=Y2;
		}
		swap(xtot,ytot);
	}
	for (int i=1;i<=q;i++)if(que[i].opt==0){
		printf("%d\n",ans[i]);
	}
	return 0;
}



			

