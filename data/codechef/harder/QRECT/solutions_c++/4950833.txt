#include <cassert>
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

#define part 610
#define maxn (100000 + 5)

struct node {
	int l, r, tot;
} tree[4][maxn * 8];

int lnk, prx[maxn * 2], pry[2 * maxn], nex[maxn * 2], ney[maxn * 2];
int n, x1[maxn], y1[maxn], x2[maxn], y2[maxn], i, idx, sig, ans, act, added, ps[maxn], del[maxn];
pair <int, int> wx[2 * maxn], wy[2 * maxn];
char c, tag[maxn];
int F[4][330 + 5][2 * maxn], a[4][2 * maxn];

int give_coordinate (pair<int, int> * a, int k) {
	int l = 1, r = n + n, mid;
	while (l < r) {
		mid = (l + r + 1) / 2;
		if (a[mid] > make_pair(k, 0)) r = mid - 1; else l = mid;
	}
//	assert(a[l] == make_pair(k, 0));
	a[l].second = 1;
	return l;
}

void change (int idx, int x, int y, int t) {
	if (idx == 1) y = n + n - y + 1;	
	if (idx == 2) x = n + n - x + 1;	
	
	if (idx == 0) x = n + n - x + 1, y = n + n - y + 1;
	
	if (t == 1 && a[idx][x]) {
		
		n ^= 1;
		n ^= 1;
		
	}
		
	if (t == 1) a[idx][x] = y; else a[idx][x] = 0;
    int	i = x / part + 1;
	while (i < 333) {
		int j = y;
		while (j <= n + n) {
			F[idx][i][j] += t;
			j = (j | (j - 1)) + 1;
		}
		i = (i | (i - 1)) + 1;
	}
}

int getsum2 (int idx, int x, int y) {
//	idx = 3 - idx;
	if (idx == 0) x = n + n - x + 1, y = n + n - y + 1;
	
	if (idx == 1) y = n + n - y + 1;
	if (idx == 2) x = n + n - x + 1;
	
	int ret = 0;
	int i = x / part, j;
	while (i > 0) {
		j = y;
		while (j > 0) {
			ret += F[idx][i][j];
			j = j & (j - 1);
		}
		i = i & (i - 1);
	}
	for(i = (x / part) * part; i <= x; i++) if (a[idx][i] && a[idx][i] <= y) ++ret;
	assert(ret <= act);
	return ret;
}

void init (int idx, int pos, int l, int r) {
	tree[idx][pos].l = l;
	tree[idx][pos].r = r;
	if (l < r) {
		init(idx, pos + pos, l, (l + r) / 2);
		init(idx, pos + pos + 1, (l + r) / 2 + 1, r);
	}
}

void modify (int idx, int pos, int j, int x) {
	tree[idx][pos].tot += x;
	if (tree[idx][pos].l == tree[idx][pos].r) return;
	if (tree[idx][pos + pos].r >= j) modify(idx, pos + pos, j, x); else modify(idx, pos + pos + 1, j, x);
}

int getsum (int idx, int pos, int l, int r) {
	if (tree[idx][pos].l == l && tree[idx][pos].r == r) return tree[idx][pos].tot;
	int ret = 0;
	if (l <= min(r, tree[idx][pos + pos].r)) ret += getsum(idx, pos + pos, l, min(r, tree[idx][pos + pos].r));
	if (max(l, tree[idx][pos + pos + 1].l) <= r) ret += getsum(idx, pos + pos + 1, max(l, tree[idx][pos + pos + 1].l), r);
	return ret;
}

int main (int argc, char * const argv[]) {
//	freopen("input.txt", "r", stdin);
	scanf("%d", &n);
	for(i = 1; i <= n; i++) {
		c = '/';
		while (c != 'I' && c != 'D' && c != 'Q') c = getchar();
		if (c == 'D') 
			scanf("%d", &x1[i]);
		else
			scanf("%d %d %d %d", &x1[i], &y1[i], &x2[i], &y2[i]);
		tag[i] = c;
	}
	for(i = 1; i <= n; i++) if (tag[i] != 'D') {
		wx[i] = make_pair(x1[i], 0);
		wy[i] = make_pair(y1[i], 0);
		wx[i + n] = make_pair(x2[i], 0);
		wy[i + n] = make_pair(y2[i], 0);
	}
	sort(wx + 1, wx + n + n + 1);
	sort(wy + 1, wy + n + n + 1);
	for(i = n; i >= 1; i--) if (tag[i] != 'D') {
		x1[i] = give_coordinate(wx, x1[i]);		
//		assert(x1[i] != 0);		
		y1[i] = give_coordinate(wy, y1[i]);
//		assert(y1[i] != 0);		
		x2[i] = give_coordinate(wx, x2[i]);
//		assert(x2[i] != 0);		
		y2[i] = give_coordinate(wy, y2[i]);
//		assert(y2[i] != 0);		
	}
	
	wx[0] = wy[0] = make_pair(-1, -1);
	
	lnk = -1;
	for(i = 1; i <= n + n; i++) {
		prx[i] = lnk;
		if (wx[i] != wx[i + 1]) lnk = i;
	}
	lnk = -1;
	for(i = 1; i <= n + n; i++) {
		pry[i] = lnk;
		if (wy[i] != wy[i + 1]) lnk = i;
	}
	lnk = 2 * n + 1;
	for(i = 2 * n; i >= 1; i--) {
		nex[i] = lnk;
		if (!(wx[i] == wx[i - 1])) lnk = i;
	}
	lnk = 2 * n + 1;
	for(i = 2 * n; i >= 1; i--) {
		ney[i] = lnk;
		if (!(wy[i] == wy[i - 1])) lnk = i;
	}
	
	for(i = 0; i < 4; i++) init(i, 1, 1, n + n);
	for(i = 1; i <= n; i++) if (tag[i] != 'Q') {
//		printf("+++%d\n", i);
		if (tag[i] == 'D') {
			idx = ps[x1[i]]; 
			assert(!del[idx] && idx != 0);
			del[idx] = 1;
		}else {
			++added;
			ps[added] = i;
			idx = i;
		}
		if (tag[i] == 'I') sig = 1; else sig = -1;
		
		modify(0, 1, x1[idx], sig);
		modify(1, 1, x2[idx], sig);
		modify(2, 1, y1[idx], sig);
		modify(3, 1, y2[idx], sig);
		
		change(0, x1[idx], y1[idx], sig); //lower lower
		change(1, x2[idx], y1[idx], sig); //upper lower
		change(2, x1[idx], y2[idx], sig); //lower upper
		change(3, x2[idx], y2[idx], sig); //upper upper
		act += sig;
//		printf("---%d\n", i);
	} else {
//		printf("+++%d\n", i);		
		ans = act;
		if (nex[x2[i]] <= n + n) ans -= getsum(0, 1, nex[x2[i]], n + n);
		if (prx[x1[i]] > 0) ans -= getsum(1, 1, 1, prx[x1[i]]);
		if (ney[y2[i]] <= n + n) ans -= getsum(2, 1, ney[y2[i]], n + n);
		if (pry[y1[i]] > 0) ans -= getsum(3, 1, 1, pry[y1[i]]);
		
		if (prx[x1[i]] > 0 && pry[y1[i]] > 0) ans += getsum2(3, prx[x1[i]], pry[y1[i]]);
		if (nex[x2[i]] <= n + n && ney[y2[i]] <= n + n) ans += getsum2(0, nex[x2[i]], ney[y2[i]]);
		
		if (prx[x1[i]] > 0 && ney[y2[i]] <= n + n) ans += getsum2(1, prx[x1[i]], ney[y2[i]]);
		if (nex[x2[i]] <= n + n && pry[y1[i]] > 0) ans += getsum2(2, nex[x2[i]], pry[y1[i]]);
		
		printf("%d\n", ans);
//		printf("---%d\n", i);		
	}
    return 0;
}