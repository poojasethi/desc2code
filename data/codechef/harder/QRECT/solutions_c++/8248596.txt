#include <cstdlib>
#include <climits>
#include <cassert>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <functional>
#include <algorithm>
#include <memory.h>
#include <numeric>
#include <utility>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <fstream>
 
#include <cstring>
#include <vector>
#include <bitset>
#include <deque>
#include <queue>
#include <stack>
#include <list>
#include <set>
#include <map>
 
#define forit(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)
#define clr(q) while (!q.empty()) q.pop()
#define alc(a, v) memset(a, v, sizeof(a))
 
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define MX 200010
using namespace std;
 
typedef long long int64;
typedef pair<int, int> pii;
typedef vector<int> vi;
int N, Q, ans[MX], s1[2 * MX], s2[2 * MX], D[MX], dn, X[MX], Y[MX], l1, l2;
struct Rect {
	int x1, x2, y1, y2, q;
}rect[MX];
void update1(int pos, int val) {
	for (; pos <= l1; pos += (pos & -pos)) {
		s1[pos] += val;
	}
}
void update2(int pos, int val) {
	for (; pos <= l1; pos += (pos & -pos)) {
		s2[pos] += val;
	}
}
int calc1(int pos) {
	int ret = 0;
	for (; pos; pos -= (pos & -pos)) {
		ret += s1[pos];
	}
	return ret;
}
int calc2(int pos) {
	int ret = 0;
	for (; pos; pos -= (pos & -pos)) {
		ret += s2[pos];
	}
	return ret;
}
 
struct Line {
	int x, y1, y2, q, id;
	Line(int x = 0, int y1 = 0, int y2 = 0, int q = 0) :x(x), y1(y1), y2(y2), q(q) {}
	bool operator < (const Line& A) const {
		if (x != A.x) return x < A.x;
		return q < A.q;
	}
}line[MX];
 
void solve(int l, int r) {
	if (l >= r) return;
	int mid = l + r >> 1, tot = 0, i, Ans = 0;
	for (i = l; i <= mid; i ++) {
		if (rect[i].q == 1) {
			Ans ++;
			line[tot ++] = Line(rect[i].x2, rect[i].y1, rect[i].y2, 2);
		} else if (rect[i].q == 2) {
			Ans --;
			line[tot ++] = Line(rect[i].x2, rect[i].y1, rect[i].y2, 1);
		}
	}
	for (i = mid + 1; i <= r; i ++) {
		if (rect[i].q == 0) {
			ans[i] += Ans;
			line[tot] = Line(rect[i].x1, rect[i].y1, rect[i].y2, 0);
			line[tot ++].id = i;
		}
	}
	sort(line, line + tot);
	for (i = 0; i < tot; i ++) {
		if (line[i].q == 0) {
			ans[line[i].id] -= calc2(line[i].y1 - 1) - calc1(line[i].y2);
		} else if (line[i].q == 1) {
			update1(line[i].y1, 1);
			update2(line[i].y2, 1);
		} else {
			update1(line[i].y1, -1);
			update2(line[i].y2, -1);
		}
	}
	for (i = 0; i < tot; i ++) {
		if (line[i].q == 1) {
			update1(line[i].y1, -1);
			update2(line[i].y2, -1);
		} else if (line[i].q == 2) {
			update1(line[i].y1, 1);
			update2(line[i].y2, 1);
		}
	}
	tot = 0;
	for (i = l; i <= mid; i ++) {
		if (rect[i].q == 1) {
			line[tot ++] = Line(-rect[i].x1, rect[i].y1, rect[i].y2, 2);
		} else if (rect[i].q == 2) {
			line[tot ++] = Line(-rect[i].x1, rect[i].y1, rect[i].y2, 1);
		}
	}
	for (i = mid + 1; i <= r; i ++) {
		if (rect[i].q == 0) {
			line[tot] = Line(-rect[i].x2, rect[i].y1, rect[i].y2, 0);
			line[tot ++].id = i;
		}
	}
	sort(line, line + tot);
	for (i = 0; i < tot; i ++) {
		if (line[i].q == 0) {
			ans[line[i].id] -= calc2(line[i].y1 - 1) - calc1(line[i].y2);
		} else if (line[i].q == 1) {
			update1(line[i].y1, 1);
			update2(line[i].y2, 1);
		} else {
			update1(line[i].y1, -1);
			update2(line[i].y2, -1);
		}
	}
	for (i = 0; i < tot; i ++) {
		if (line[i].q == 1) {
			update1(line[i].y1, -1);
			update2(line[i].y2, -1);
		} else if (line[i].q == 2) {
			update1(line[i].y1, 1);
			update2(line[i].y2, 1);
		}
	}
	Ans = 0;
	tot = 0;
	for (i = l; i <= mid; i ++) {
		if (rect[i].q == 1) {
			line[tot ++] = Line(rect[i].y2, 0, 0, 2);
		} else if (rect[i].q == 2) {
			line[tot ++] = Line(rect[i].y2, 0, 0, 1);
		}
	}
	for (i = mid + 1; i <= r; i ++) {
		if (rect[i].q == 0) {
			line[tot] = Line(rect[i].y1, 0, 0, 0);
			line[tot ++].id = i;
		}
	}
	sort(line, line + tot);
	Ans = 0;
	for (i = 0; i < tot; i ++) {
		if (line[i].q == 0) {
			
			ans[line[i].id] -= Ans;
		} else if (line[i].q == 1) {
			Ans --;
		} else Ans ++;
	}
	Ans = 0;
	tot = 0;
	for (i = l; i <= mid; i ++) {
		if (rect[i].q == 1) {
			line[tot ++] = Line(-rect[i].y1, 0, 0, 2);
		} else if (rect[i].q == 2) {
			line[tot ++] = Line(-rect[i].y1, 0, 0, 1);
		}
	}
	for (i = mid + 1; i <= r; i ++) {
		if (rect[i].q == 0) {
			line[tot] = Line(-rect[i].y2, 0, 0, 0);
			line[tot ++].id = i;
		}
	}
	sort(line, line + tot);
	Ans = 0;
	for (i = 0; i < tot; i ++) {
		if (line[i].q == 0) {
			ans[line[i].id] -= Ans;
		} else if (line[i].q == 1) {
			Ans --;
		} else Ans ++;
	}
	solve(l, mid);
	solve(mid + 1, r);
}
main() {
	scanf("%d", &Q);
	int i, d;
	char str[5];
	for (i = 0; i < Q; i ++) {
		scanf("%s", str);
		if (*str == 'I') {
			rect[i].q = 1;
			scanf("%d%d%d%d", &rect[i].x1, &rect[i].y1, &rect[i].x2, &rect[i].y2);
			X[l1 ++] = rect[i].y1;
			X[l1 ++] = rect[i].y2;
			D[dn ++] = i;
		} else if (*str == 'Q') {
			rect[i].q = 0;
			scanf("%d%d%d%d", &rect[i].x1, &rect[i].y1, &rect[i].x2, &rect[i].y2);
			X[l1 ++] = rect[i].y1;
			X[l1 ++] = rect[i].y2;
		} else {
			scanf("%d", &d);
			rect[i] = rect[D[d - 1]];
			rect[i].q = 2;
		}
	}
	sort(X, X + l1);
	l1 = unique(X, X + l1) - X;
	for (i = 0; i < Q; i ++) {
		rect[i].y1 = lower_bound(X, X + l1, rect[i].y1) - X + 1;
		rect[i].y2 = lower_bound(X, X + l1, rect[i].y2) - X + 1;
	}
	solve(0, Q - 1);
	
	for (i = 0; i < Q; i ++) {
		if (rect[i].q == 0) printf("%d\n", ans[i]);
	}
} 