/* Divanshu Garg */

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cctype>
#include <cassert>
#include <complex>

using namespace std;

#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(int i=(a);i<(n);++i)
#define FF(i,a,n) for(i=(a);i<(n);++i)
#define REP(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(int i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define Sl(x) scanf("%llu",&x)
#define M(x,i) memset(x,i,sizeof(x))
#define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl
#define MAX(a,b) ((a)>(b)?(a):(b))
ill ABS(ill a) { if ( a < 0 ) return (-a); return a; }
#define fr first
#define se second

/* Relevant code begins here */

/* Input from file or online */

void input() {
#ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
#endif
}

/* Input opener ends */

#define N 212345

set<int> allx, ally;
map<int,int> hashx, hashy;

int q;
char t[N][4];
int p[N][4];
int del[N];

vector<int> bit[N][4];
vector<int> val[N][4];
// 0 : top-left
// 1 : top-right
// 2 : bottom-right
// 3 : bottom-left

void add_into_bit(int x,int y,int idx) {
    for ( int i = x; i < N; i += (i&(-i)) )
        val[i][idx].pb(y);
}

void add(int x,int y,int change,int idx) {
    // if ( idx == 3 ) cout << x << " " << y << endl;
    for ( int i = x; i < N; i += (i&(-i)) ) {
        int pos = lower_bound(val[i][idx].begin(),val[i][idx].end(),y) - val[i][idx].begin();
        for ( int j = pos; j < bit[i][idx].size(); j += (j&(-j)) ) {
            bit[i][idx][j] += change;
        }
    }
}

int query(int x,int y,int idx) {
    int res = 0;
    for ( int i = x; i > 0; i -= (i&(-i)) ) {
        int pos = upper_bound(val[i][idx].begin(),val[i][idx].end(),y) - val[i][idx].begin();
        pos--;
        for ( int j = pos; j > 0; j -= (j&(-j)) ) {
            res += bit[i][idx][j];
        }
    }
    return res;
}

int main() {
    input();

    S(q);
    F(i,0,q) {
        scanf("%s",t[i]);
        S(p[i][0]);
        if ( t[i][0] != 'D' ) {
            F(j,1,4) S(p[i][j]);
            allx.insert(p[i][0]); allx.insert(p[i][2]);
            ally.insert(p[i][1]); ally.insert(p[i][3]);
        }
    }
    set<int>::iterator it;
    int K = 1;
    FE(it,allx) hashx[*it] = K++;
    K = 1;
    FE(it,ally) hashy[*it] = K++;
    F(i,0,q) {
        if ( t[i][0] == 'D' )
            continue;
        p[i][0] = hashx[p[i][0]];
        p[i][1] = hashy[p[i][1]];
        p[i][2] = hashx[p[i][2]];
        p[i][3] = hashy[p[i][3]];
        // cout << t[i][0] << " " ; F(j,0,4) cout << p[i][j] << " "; cout << endl;
    }

    F(i,0,q) {
        if ( t[i][0] != 'I' )
            continue;
        add_into_bit(p[i][0],p[i][3],0);
        add_into_bit(p[i][2],p[i][3],1);
        add_into_bit(p[i][2],p[i][1],2);
        add_into_bit(p[i][0],p[i][1],3);
    }

    F(idx,0,4) {
        F(i,0,N) {
            val[i][idx].pb(-1);
            sort(val[i][idx].begin(),val[i][idx].end());
            int sz = unique(val[i][idx].begin(),val[i][idx].end()) - val[i][idx].begin();
            val[i][idx].resize(sz);
            bit[i][idx].resize(sz+10,0);
        }
    }

    K = 1;
    F(i,0,q) {

        if ( t[i][0] == 'I' ) {
        
            del[K++] = i;
        
            add(p[i][0],p[i][3],1,0);
            add(p[i][2],p[i][3],1,1);
            add(p[i][2],p[i][1],1,2);
            add(p[i][0],p[i][1],1,3);
        
        } else if ( t[i][0] == 'D' ) {
        
            int whr = del[p[i][0]];
        
            add(p[whr][0],p[whr][3],-1,0);
            add(p[whr][2],p[whr][3],-1,1);
            add(p[whr][2],p[whr][1],-1,2);
            add(p[whr][0],p[whr][1],-1,3);
        
        } else {

            int ans = 0;
            
            ans -= query(p[i][0]-1,p[i][3],2);
            ans += query(p[i][2],p[i][3],3);
            ans -= query(p[i][2],p[i][1]-1,0);
            ans += query(p[i][0]-1,p[i][1]-1,1);

            printf("%d\n", ans);

        }

    }

    return 0;
}