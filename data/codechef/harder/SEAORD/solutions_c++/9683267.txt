
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define drep(i, a, b) for (int i = (a); i >= (b); --i)
#define REP(i, a, b) for (int i = (a); i < (b); ++i)
#define pb(x) push_back(x)
#define mp(x, y) (make_pair(x, y))
#define clr(x) memset(x, 0, sizeof(x))
#define xx first
#define yy second

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int inf = ~0U >> 1;
const ll INF = ~0ULL >> 1;
template <class T> inline void read(T &n)
{
    char c; int flag = 1;
    for (c = getchar(); !(c >= '0' && c <= '9' || c == '-'); c = getchar()); if (c == '-') flag = -1, n = 0; else n = c - '0';
    for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0'; n *= flag;
}
//***************************

const int maxn = 20000;

struct program
{
	int A, B, id, ta, tb;
} pro[maxn];

bool cmp(const program &a, const program &b)
{
	return a.B < b.B;
}

int N, total, sumx, sumy;
pii ans[maxn];

void print()
{
	rep(i, 1, N) ans[pro[i].id] = mp(pro[i].ta, pro[i].tb);
	rep(i, 1, N) printf("%d %d\n", ans[i].xx, ans[i].yy);
}

int checkIntersect()
{
	int x = -1;
	rep(i, 1, N) 
		if (!(pro[i].ta + pro[i].A <= pro[i].tb || pro[i].tb + pro[i].B <= pro[i].ta))
			x = i;
	return x;
}

void work()
{
	sumx = 0, sumy = 0;
	read(N);
	rep(i, 1, N) read(pro[i].A), read(pro[i].B), pro[i].id = i;
	rep(i, 1, N) sumx += pro[i].A;
	rep(i, 1, N) sumy += pro[i].B;
	int t = max(sumx, sumy);
	int tt = 0;
	rep(i, 1, N) tt = max(tt, pro[i].A + pro[i].B);
	printf("%d\n", total = max(t, tt));	
	if (tt >= t)
	{
		int x;
		rep(i, 1, N) if (pro[i].A + pro[i].B == tt) x = i;
		ans[x].xx = 0;
		int cur = pro[x].A;
		rep(i, 1, N) if (i != x) ans[i].xx = cur, cur += pro[i].A;
		cur = 0;
		rep(i, 1, N) if (i != x) ans[i].yy = cur, cur += pro[i].B;
		ans[x].yy = pro[x].A;
		rep(i, 1, N) printf("%d %d\n", ans[i].xx, ans[i].yy);
		return;
	}
	int flag = 0;
	if (sumx < sumy) 
	{
		swap(sumx, sumy);
		rep(i, 1, N) swap(pro[i].A, pro[i].B);
		flag = 1;
	}
	sort(pro + 1, pro + N + 1, cmp);
	int p = 1, cy = 0, cx = 0;
	while (p <= N && max(cx + pro[p].A, cy) + pro[p].B <= sumx)
		cx += pro[p].A, cy = max(cx, cy) + pro[p].B, p++;
	cy = sumx;
	drep(i, p - 1, 1) cy -= pro[i].B, pro[i].tb = cy;
	cy = 0;
	rep(i, p, N) pro[i].tb = cy, cy += pro[i].B;
	cx = 0;
	rep(i, 1, N) pro[i].ta = cx, cx += pro[i].A;
	if (flag) rep(i, 1, N) swap(pro[i].ta, pro[i].tb), swap(pro[i].A, pro[i].B);
	assert(checkIntersect() == -1);
	print();
}

int main()
{
	int cases;
	read(cases);
	rep(_, 1, cases) 
	{
	/*	if (_==37)
		{
			read(N);printf("%d\n",N);
			rep(i,1,N)read(pro[i].A),read(pro[i].B), printf("%d %d\n", pro[i].A, pro[i].B);
			return 0;
		}*/
		work();
		//printf("#%d\n", _);
	}

	return 0;
}