#include <cstdio>
#include <iostream>
#include <cmath>
#include <vector>
#include <list>
#include <cstring>
#include <map>
#include <algorithm>
 
#define LLABS(x) (((x) < 0LL) ? -(x) : (x))
 
using namespace std;
 
/* THANKS to Ajay Somani for this code! :) */
 
#define BUFSIZE (40000)
char outputbuffer[BUFSIZE<<1],inputbuffer[BUFSIZE];
char *outptr=outputbuffer,*ioptr=inputbuffer+BUFSIZE,*ioend=inputbuffer+BUFSIZE;
int input_eof=0;
bool sign = false;
 
#define putchar(c) (*outptr++ = (c))
#define getchar() ({if (ioptr >= ioend) init_input(); *ioptr++;})
#define eof() (ioptr>=ioend && input_eof)
#define eoln() ({if(ioptr >= ioend) init_input(); *ioptr == '\n';})
 
void init_input(){
        if (input_eof)
                return;
        int existing = BUFSIZE - (ioend - inputbuffer);
        memcpy(inputbuffer, ioend, existing);
        int wanted = ioend - inputbuffer;
        int count=fread(inputbuffer + existing, 1, wanted, stdin);
        if (count < wanted)
                input_eof = 1;
        ioend = inputbuffer + BUFSIZE - (wanted - count);
	--ioend;
        while (*ioend > ' ') --ioend ;
        ioend++;
        ioptr=inputbuffer;
}
 
inline void non_whitespace() {
        for(;;) {
                if(ioptr>=ioend)
                        init_input();
                if(*ioptr > ' ')
                        return;
                ioptr++;
        }
}
 
inline int getint() {
        non_whitespace();
        sign = false;
        if (*ioptr == '-') {
                sign = true;
                ioptr++;
        }
        int n=0;
        while(*ioptr>' ')
                n=(n<<3)+(n<<1)+*ioptr++-'0';
        ioptr++;
	if (sign) n = -n;
        return n;
}
 
struct Point {
	int x;
	int y;
 
	Point(int X, int Y): x(X), y(Y) {}
	Point(): x(0), y(0) {}
	Point(const Point &other) : x(other.x), y(other.y) {}
	bool operator<(const Point &two) const {
		return ((x < two.x) || ((x == two.x) && (y < two.y)));
	}
	bool operator==(const Point &two) const {
		return ((x == two.x) && (y == two.y));
	}
};
 
Point P[1000004];
int H[1000004];
int buckets[20002][2];
 
inline long long isLeft(int i, int j, int k) { 
	long long p0x = P[i].x, p0y = P[i].y;
	long long p1x = P[j].x, p1y = P[j].y;
	long long p2x = P[k].x, p2y = P[k].y;
	return((p1x - p0x)*(p2y - p0y) - (p2x - p0x)*(p1y - p0y));
}
 
inline long long findArea(int a, int b, int c) {
	Point &P0 = P[H[a]], &P1 = P[H[b]], &P2 = P[H[c]];
	long long p0x = P0.x, p0y = P0.y;
	long long p1x = P1.x, p1y = P1.y;
	long long p2x = P2.x, p2y = P2.y;
	return LLABS(p0x*(p1y-p2y) + p1x*(p2y-p0y) + p2x*(p0y-p1y));
}
 
inline void clearBuckets() {
	for(int i=0; i<20001; ++i) {
		buckets[i][0] = 10001; // ymin
		buckets[i][1] = -10001; // ymax
	}
}
 
inline void addPointToBuckets(int x, int y) {
	unsigned int xind = x+10000;
	
	if (buckets[xind][0] > y) {
		buckets[xind][0] = y; // ymin
	}
	if (buckets[xind][1] < y) {
		buckets[xind][1] = y; // ymax
	}
}
 
inline int sortBuckets() {
	Point curr;
	int i, temp;
	int index = 0;
	for (i=0; i<20001; ++i) {
		temp = buckets[i][0];
		if (temp != 10001) {
			curr.x = i-10000;
			curr.y = temp;
			P[index] = curr;
			index++;
		}
		if ((buckets[i][1] != -10001) && (buckets[i][1] != temp)) {
			curr.x = i-10000;
			curr.y = buckets[i][1];
			P[index] = curr;
			index++;
		}
	}
	return index;
}
 
int chainHull_2D(int n) {
	// the output array H[] will be used as the stack
	int    bot=0, top=(-1);  // indices for bottom and top of the stack
	int    i;                // array scan index
 
	// Get the indices of points with min x-coord and min|max y-coord
	int minmin = 0, minmax;
	int xmin = P[0].x;
 
	//if (P[1].x == xmin) minmax = 1; // new
	for (i=1; i<n; ++i) {
		if (P[i].x != xmin) break; // new
	}
	minmax = i-1;
 
	if (minmax == n-1) {       // degenerate case: all x-coords == xmin
		H[++top] = minmin;
		if (P[minmax].y != P[minmin].y) // a nontrivial segment
			H[++top] = minmax;
		H[++top] = minmin;           // add polygon endpoint
		return top+1;
	}
 
 
	// Get the indices of points with max x-coord and min|max y-coord
	int maxmin, maxmax = n-1;
	int xmax = P[n-1].x;
 
	//if (P[n-2].x == xmax) maxmin = n-2; // new
	for (i=n-2; i>=0; --i) {
		if (P[i].x != xmax) break; // new
	}
	maxmin = i+1;
 
	// Compute the lower hull on the stack H
	H[++top] = minmin;      // push minmin point onto stack
	i = minmax;
	while (++i <= maxmin) {
		// the lower line joins P[minmin] with P[maxmin]
		if (isLeft( minmin, maxmin, i) >= 0LL && i < maxmin)
			continue;          // ignore P[i] above or on the lower line
 
		while (top > 0) {        // there are at least 2 points on the stack
			// test if P[i] is left of the line at the stack top
			if (isLeft( H[top-1], H[top], i) > 0LL)
				break;         // P[i] is a new hull vertex
			else
				top--;         // pop top point off stack
		}
		H[++top] = i;       // push P[i] onto stack
	}
 
	// Next, compute the upper hull on the stack H above the bottom hull
	if (maxmax != maxmin)      // if distinct xmax points
		H[++top] = maxmax;  // push maxmax point onto stack
	bot = top;                 // the bottom point of the upper hull stack
	i = maxmin;
	while (--i >= minmax) {
		// the upper line joins P[maxmax] with P[minmax]
		if (isLeft( maxmax, minmax, i) >= 0LL && i > minmax)
			continue;          // ignore P[i] below or on the upper line
 
		while (top > bot) {    // at least 2 points on the upper stack
			// test if P[i] is left of the line at the stack top
			if (isLeft( H[top-1], H[top], i) > 0LL)
				break;         // P[i] is a new hull vertex
			else
				top--;         // pop top point off stack
		}
		H[++top] = i;       // push P[i] onto stack
	}
	if (minmax != minmin)
		H[++top] = minmin;  // push joining endpoint onto stack
 
	return top+1;
}
 
int main() {
	int T;
	T = getint();
 
	int N;
 
	int i, j, k;
	int xx, yy;
	int size, tt;
	long long maxarea, key;
 
	for (int t=0; t<T; t++) {
		N = getint();
		if (N < 3) {
			for (i=0; i<N; i++) {
				xx = getint();
				yy = getint();
			}
			printf("0\n");
			continue;
		}
		if (N > 1500) {
			clearBuckets();
			for (i=0; i<N; i++) {
				xx = getint();
				yy = getint();
				addPointToBuckets(xx, yy);
			}
			N = sortBuckets();
		} else {
			Point curr;
			int count = 0;
			map<long long, bool> pointMap;
			for (i=0; i<N; i++) {
				xx = getint();
				yy = getint();
				key = xx * 10001 + yy;
				if (pointMap.find(key) == pointMap.end()) {			
					pointMap[key] = true;
					curr.x = xx; curr.y = yy;
					P[count] = curr;
					count++;
				}
			}
			sort(P, P+count);
			N = count;
		}
 
		size = chainHull_2D(N);
		--size;
 
		if (size < 3) {
			printf("0\n");
			continue;
		}
		if (size == 3) {
			printf("%lld\n", findArea(0, 1, 2));
			continue;
		}
 
		i=0; j=1; k=2;
		maxarea = findArea(i, j, k);
		while (true) {
			while (true) {
				tt = (k+1) % size;
				while(findArea(i, j, k) <= findArea(i, j, tt)) {
					k = tt;
					tt = (k+1) % size;
				}
				tt = (j+1) % size;
				if (findArea(i, j, k) > findArea(i, tt, k)) break;
				j= tt;
			}
			maxarea = max(maxarea, findArea(i, j, k));
			++i; i %= size;
			if (i==j) {
				++j; j%=size;
			}
			if (j==k) {
				++k; k%=size;
			}
			if (i==0) break;
		}
 
		printf("%lld\n", maxarea);
	}
 
	return 0;
}