//{{{
#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
//#undef thecodegame
#ifdef thecodegame
    #include<debug.h>
#else
    #define DBG_ARR(a,b,c) {}
    #define DBG_MAT(a,s,b,c) {}
    #define DBG_VECT(a) {}
    #define db(...) {}
    #define dbt(x, ...) {}
	#define pprintf(...) {}
#endif

using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s\n",__LINE__,#f);exit(1);}}
#define MOD 	 1000000007LL
#define LL 		 long long
#define ULL      unsigned long long
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define pnl      printf("\n")
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second

const double PI=acos(-1.0);
template<typename T>inline T mod(T N,T M){return (N%M+M)%M;}
double start;//time
#ifdef amy
    #define inp(x) scanf("%d",&x);
#else
	#define SD(x) inp(x)
    #define getcx getchar_unlocked
        template<typename T>inline void inp(T &n){
        n=0;int ch=getcx();int sign=1;
        while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}
        while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}
        n=n*sign;
    }
#endif


//}}}
#define SIZE 100000009
#define MAXX 100000009

typedef int cord;
void pre(){}//end precompute
class Point{
    public:
        cord x,y;
        Point(){}
        Point(cord x,cord y):x(x),y(y){}
        Point(const Point &p):x(p.x),y(p.y){}
        Point operator+(const Point &p)const{return Point(x+p.x,y+p.y);}
        Point operator-(const Point &p)const{return Point(x-p.x,y-p.y);}
        Point operator*(cord c)const{return Point(x*c,y*c);}
        Point operator/(cord c)const{return Point(x/c,y/c);}
        bool operator<(const Point &rhs)const{return make_pair(y,x)<make_pair(rhs.y,rhs.x); }
        bool operator==(const Point &rhs)const{return make_pair(y,x)==make_pair(rhs.y,rhs.x); }
};
ostream &operator<<(ostream &out, const Point &p) {
  out<<"("<<p.x<<","<<p.y<< ")";
}
ostream &operator<<(ostream &out, const vector<Point>&p) {
  REP(i,p.size()){out<<i+1<<" "<<p[i]<<endl;}
}

/********************************** CONVEX HULL **************************/
inline cord dist2(const Point &a,const Point &b) {
    cord dx = a.x - b.x;
    cord dy = a.y - b.y;
    return dx*dx + dy*dy;
}
static const cord EPS = 1e-9;
inline int diff(cord lhs, cord rhs){//to compare two cord values 0 means same, 1 means rhs > lhs, 2 means lhs < rhs
    if(lhs==rhs){
        return 0;
    }

    //if(lhs-EPS<rhs&&rhs<lhs+EPS){return 0;}
    return (lhs<rhs)?-1:1;
}
inline int ccw(const Point& a,const Point& b,const Point& c){//if angle abc is acute, that means its not convex, shd be obtuse
    return diff(a.x*b.y + b.x*c.y + c.x*a.y - a.y*b.x - b.y*c.x - c.y*a.x, 0);
}
struct PointSorter {//sorter structure of points for convex Hull
    Point origin;
    PointSorter(const vector<Point>& points) {
        origin = points[0];
        for (int i = 1 ; i < points.size() ; i++) {
            int det = diff(origin.x, points[i].x);
            if (det > 0)
                origin = points[i];
            else if (det == 0 && diff(origin.y, points[i].y) > 0)
                origin = points[i];
        }
    }
    bool operator()(const Point &a, const Point &b){
        if (diff(b.x, origin.x) == 0 && diff(b.y, origin.y) == 0) return false;
        if (diff(a.x, origin.x) == 0 && diff(a.y, origin.y) == 0) return true;
        int det = ccw(origin, a, b);
        if (det == 0) return dist2(a, origin) < dist2(b, origin);
        return det < 0;
    }
};
vector<Point>ConvexHull(vector<Point>points){
    if(points.size()<=3){return points;}
    // sort the points
    PointSorter cmp(points);
    sort(points.begin(), points.end(), cmp);
    vector<Point>Hull;
    Hull.push_back(points[0]);
    Hull.push_back(points[1]);
    for(int i=2;i<points.size();i++){
        while(Hull.size()>=2&&ccw(Hull[Hull.size()-2],Hull[Hull.size()-1],points[i])>=0){
            Hull.pop_back();//remove the last inserted Point
        }
        Hull.push_back(points[i]);
    }
    return Hull;
}
/********************************** CONVEX HULL **************************/

#define signed_twice_area(a, b, c) (a.x*b.y - a.y*b.x + a.y*c.x - a.x*c.y + b.x*c.y - c.x*b.y)


int N;

void doThis(int ccc){
    //scanf("%d\n",&N);
    vector<Point>points;
    inp(N);
    REP(i,N){
        int x,y;
        inp(x);inp(y);
        points.PB(Point(x,y));
    }



    vector<Point>hull = ConvexHull(points);


    int maxt = 0;
    for(unsigned i1 = 0; i1 < hull.size(); ++i1) {
		for(unsigned i2 = i1 + 1, i3 = i1 + 2; i2 < hull.size(); ++i2){
			int last_t = 0, t = 0;
			for( ; i3 < hull.size() && t >= last_t; ++i3) {
				last_t = t;
				t = abs(signed_twice_area(hull[i1], hull[i2], hull[i3]));
				if(t > maxt) maxt = t;
			}
			i3 -= 2; // Rewind to the best last_t.
		}
	}
	printf("%d\n",maxt);
    //db(dis);

}//end doThis
int main(){
start = clock();
ios_base::sync_with_stdio(false);
#ifdef amy
	freopen("C:\\A\\in.txt","r+",stdin);
	freopen("C:\\A\\out.txt","w+",stdout);
#endif
pre();
int cases;
inp(cases);
FORE(i,1,cases){doThis(i);}
#ifdef amy
	fprintf(stdout,"\nTIME: %.3lf sec\n",(cord)(clock()-start)/(CLOCKS_PER_SEC));
#endif
//while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D
return 0;
}//end main
