//{{{
#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
//#undef thecodegame
#ifdef thecodegame
    #include<debug.h>
#else
    #define DBG_ARR(a,b,c) {}
    #define DBG_MAT(a,s,b,c) {}
    #define DBG_VECT(a) {}
    #define db(...) {}
    #define dbt(x, ...) {}
	#define pprintf(...) {}
#endif

using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s\n",__LINE__,#f);exit(1);}}
#define MOD 	 1000000007LL
#define LL 		 long long
#define ULL      unsigned long long
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define pnl      printf("\n")
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second

const double PI=acos(-1.0);
template<typename T>inline T mod(T N,T M){return (N%M+M)%M;}
double start;//time
#ifdef amy
    #define inp(x) scanf("%d",&x);
#else
	#define SD(x) inp(x)
    #define getcx getchar_unlocked
        template<typename T>inline void inp(T &n){
        n=0;int ch=getcx();int sign=1;
        while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}
        while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}
        n=n*sign;
    }
#endif


//}}}
#define SIZE 100000009
#define MAXX 100000009

typedef int cord_t;
class Point{
    public:
    cord_t x,y;
    Point(){}
    Point(cord_t x,cord_t y):x(x),y(y){}
    Point(const Point &p):x(p.x),y(p.y){}
    Point operator+(const Point &p)const{return Point(x+p.x,y+p.y);}
    Point operator-(const Point &p)const{return Point(x-p.x,y-p.y);}
    Point operator*(cord_t c)const{return Point(x*c,y*c);}
    Point operator/(cord_t c)const{return Point(x/c,y/c);}
    bool operator<(const Point &p)const{if(x==p.x){return y<p.y;}return x<p.x;}
    bool operator==(const Point &p)const{return (x==p.x)&&(y==p.y);}
};
bool points_sort_x(const Point &p1,const Point &p2){if(p1.x==p2.x){return p1.y<p2.y;}return p1.x<p2.x;}
bool points_sort_y(const Point &p1,const Point &p2){if(p1.y==p2.y){return p1.x<p2.x;}return p1.y<p2.y;}
ostream &operator<<(ostream &out,const Point &p){out<<"("<<p.x<<","<<p.y<< ")";return out;}
ostream &operator<<(ostream &out, const vector<Point>&p){for(int i=0;i<p.size();i++){out<<i+1<<" "<<p[i]<<endl;}return out;}

namespace Geometry{
    static const double EPS =1e-9;
    //comparison between two cord_t
    int compare(const int &l,const int &r){//for integer co-ordinates
        if(l==r){return 0;}
        return (l<r)?-1:1;
    }
    int compare(const double &l,const double &r){//for double co-ordinates
        if(l-EPS<r && r<l+EPS){return 0;}
        return (l<r)?-1:1;
    }
    //function for square distance between two points
    cord_t sqr_dis(const Point &p1,const Point &p2){
        cord_t dx = p1.x - p2.x;
        cord_t dy = p1.y - p2.y;
        return dx*dx+dy*dy;
    }
    // check for counter clock wise
    int ccw(const Point &a,const Point &b,const Point &c){
        return compare(a.x*b.y + b.x*c.y + c.x*a.y - a.y*b.x - b.y*c.x - c.y*a.x, 0);
    }
    double dis(const Point &p1,const Point &p2){
        return sqrt(sqr_dis(p1,p2));
    }
    double perimeter_of_poly(const vector<Point> &p){//last point is not same as starting
        //assert(p.size()>=3);
        double len = 0.0;int i;
        for(i=0;i<p.size()-1;i++){
           len+= (dis(p[i],p[i+1]));
        }
        len+= (dis(p[i],p[0]));
        return len;
    }
}
using namespace Geometry;
Point H[2000001];
vector<Point>ConvexHull(vector<Point> &P){
    if(P.size()<=3){return P;}
    sort(P.begin(),P.end());
    //P.erase(unique(P.begin(),P.end()),P.end());
    int n=P.size(),k=0;

    for(int i=0;i<n;i++){// for lower hull
        while(k>=2 && ccw(H[k-2],H[k-1],P[i])<=0){k--;}
        H[k++]=P[i];
    }
    for(int i=n-2,t=k;i>=0;i--){//for upper hull
        while(k>t && ccw(H[k-2],H[k-1],P[i])<=0){k--;}
        H[k++]=P[i];
    }
    return vector<Point>(H,H+k-1);
}
#define signed_twice_area(a, b, c) (a.x*b.y - a.y*b.x + a.y*c.x - a.x*c.y + b.x*c.y - c.x*b.y)


int N;

void doThis(int ccc){
    //scanf("%d\n",&N);
    vector<Point>points;
    inp(N);
    REP(i,N){
        int x,y;
        inp(x);inp(y);
        points.PB(Point(x,y));
    }



    vector<Point>hull = ConvexHull(points);


    int maxt = 0;
    for(unsigned i1 = 0; i1 < hull.size(); ++i1) {
		for(unsigned i2 = i1 + 1, i3 = i1 + 2; i2 < hull.size(); ++i2){
			int last_t = 0, t = 0;
			for( ; i3 < hull.size() && t >= last_t; ++i3) {
				last_t = t;
				t = abs(signed_twice_area(hull[i1], hull[i2], hull[i3]));
				if(t > maxt) maxt = t;
			}
			i3 -= 2; // Rewind to the best last_t.
		}
	}
	printf("%d\n",maxt);
    //db(dis);

}//end doThis
int main(){
start = clock();
ios_base::sync_with_stdio(false);
#ifdef amy
	freopen("C:\\A\\in.txt","r+",stdin);
	freopen("C:\\A\\out.txt","w+",stdout);
#endif
int cases;
inp(cases);
FORE(i,1,cases){doThis(i);}
#ifdef amy
	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)(clock()-start)/(CLOCKS_PER_SEC));
#endif
//while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D
return 0;
}//end main
