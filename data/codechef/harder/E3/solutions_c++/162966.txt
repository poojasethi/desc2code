#include <iostream>
#include <cstdio>
#include <cctype>
#include <string>
#include <cmath>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue>
#include <map>
#include <set>
#include <sstream>
#include <ctime>
#include <cassert>
#include <string.h>

using namespace std;

#define GI ({int t;scanf("%d",&t);t;})
#define GL ({LL t;scanf("%lld",&t);t;})
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
#define ROF(i,a,b) for(int i=a;i>b;i--)
#define SET(x,a) memset(x,a,sizeof(x));
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define tr(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)
#define pb push_back
#define sz(a) (int)(a.size())
#define INF (int)1e9
#define EPS (double)1e-3
#define is istringstream
#define os ostringstream
#define lb lower_bound
#define ub upper_bound
#define bs binary_search

typedef long long LL;
typedef pair< int, int > ii;
typedef vector< ii > vii;
typedef vector < vii > vvii;
typedef vector< int > vi;
typedef vector< vi > vvi;

char ch;
#define MAXN 1000000+5 
struct POINT{int x, y;};

POINT ZERO;
POINT peak[MAXN];
POINT hull[MAXN];
int n, m;

inline LL cross(POINT A, POINT ORG, POINT B){
    return LL(A.x - ORG.x) * (B.y - ORG.y) - LL(A.y - ORG.y) * (B.x - ORG.x);
}

inline LL area(int A, int B, int C){
	LL ret = cross(hull[A], hull[B], hull[C]);
    if(ret < 0)    ret = 0 - ret;
	return ret;
}

inline bool cmp(const POINT &A, const POINT &B){
    LL d = cross(A, ZERO, B);
    if(d == 0)    return (LL(A.x) * A.x + A.y * A.y) < (LL(B.x) * B.x + B.y * B.y);
    return d > 0;
}

int main(void){
	ZERO.x = 0, ZERO.y = 0; 
	int t = GI;
	while(t--){
		n = GI;
		REP(i, n)    peak[i].x = GI, peak[i].y = GI;
		int dx = INF, dy = INF;
		REP(i, n){
		    if(peak[i].y < dy)    dx = peak[i].x, dy = peak[i].y;
			else if(peak[i].y == dy && peak[i].x < dx)    dx = peak[i].x;    	
		}
		REP(i, n)    peak[i].x -= dx, peak[i].y -= dy;
		sort(peak, peak + n, cmp);
		hull[0].x = 0, hull[0].y = 0;
		m = 1;
		FOR(i, 1, n){
			if(peak[i].x == 0 && peak[i].y == 0)    continue;
		    hull[m].x = peak[i].x, hull[m].y = peak[i].y;
			m++;
			for(;;){
				if(m <= 2)    break;
			    LL d = cross(hull[m - 1], hull[m - 2], hull[m - 3]);
				if(d > 0)    break;
				hull[m - 2].x = hull[m - 1].x, hull[m - 2].y = hull[m - 1].y;
				m--;  	
			}
		}
		int A = 0, B = 1, C = 2;
		int a = A, b = B, c = C;
		if(m < 3){
		    printf("0\n");
			continue;	
		}
		if(m == 3) {
		    printf("%lld\n", area(A, B, C));
		    continue;
		}
		int CC;
		for(;;){
			for(;;){
			    CC = (C + 1) % m;
				while(area(A, B, CC) >= area(A, B, C)){
					C = CC;
					CC = (C + 1) % m;
				}
				CC = (B + 1) % m;
				if(area(A, CC , C) < area(A, B, C))    break;
				B = CC;
			}
			if(area(A, B, C) > area(a, b, c))    a = A, b = B, c = C;
			(A += 1) %= m;
			if(A == B)    (B += 1) %= m;
			if(B == C)    (C += 1) %= m;
			if(A == 0)    break;
		}
		LL ans = area(a, b, c);
		printf("%lld\n", ans);
	}
	// cin >> ch;
	return 0;
}
