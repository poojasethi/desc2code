#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

struct Dominator_tree
{
	#define Graph_n 400005
	#define Graph_m 400005
	
	int n,m,i,j,tot,u,v,tmp;
	int tfa[Graph_n],fa[Graph_n],semi[Graph_n],Min[Graph_n];
	int son[Graph_n],next[Graph_m],ed[Graph_m];
	int edge_x[Graph_m],edge_y[Graph_m];
	
	void clear(int N){n=N;m=0;}
	void add(int u,int v)
	{
		edge_x[++m]=u;edge_y[m]=v;
		next[i]=son[u];son[u]=i;ed[i]=v;
	}
	void dfs(int x)
	{
		for(int i=son[x];i;i=next[i])
		if(ed[i]==tot)
		{
			++tot;
			tfa[ed[i]]=x;
			dfs(ed[i]);
		}
	}
	int get(int x)
	{
		if(fa[x]==x)return x;
		int y=fa[x];get(y);
		if(semi[Min[y]]<semi[Min[x]])Min[x]=Min[y];
		return fa[x]=get(y);
	}
	
	void work()
	{
		tot=0;
		for(i=1;i<=n;++i)son[i]=0,fa[i]=Min[i]=semi[i]=i;
		for(i=1;i<=m;++i)
		{
			u=edge_x[i];v=edge_y[i];
			next[i]=son[u];son[u]=i;ed[i]=v;
		}
		tot=2;dfs(1);
		for(i=1;i<=n;++i)son[i]=0;
		for(i=1;i<=m;++i)
		{
			u=edge_y[i];v=edge_x[i];
			next[i]=son[u];son[u]=i;ed[i]=v;
		}
		for(i=n;i>=2;--i)
		{
			tmp=1000000000;
			for(j=son[i];j;j=next[j])
			{
				get(v=ed[j]);
				tmp=min(tmp,semi[Min[v]]);
			}
			semi[i]=tmp;fa[i]=tfa[i];
		}
	}
	
	#undef Graph_n
	#undef Graph_m
}G;

int T,n,m,q,i,j,k;
int sum[100005];

struct node
{
	int u,v;
}t[200005];
inline bool cmp(const node &a,const node &b){return a.v>b.v;}

int main()
{
	scanf("%d",&T);
	for(;T;--T)
	{
		scanf("%d%d%d",&n,&m,&q);
		for(i=1;i<=m;++i)scanf("%d%d",&t[i].u,&t[i].v);
		G.clear(n);
		sort(t+1,t+m+1,cmp);
		for(i=1;i<=m;++i)G.add(t[i].u,t[i].v);
		G.work();
		for(i=1;i<=n;++i)sum[i]=0;
		for(i=2;i<=n;++i)++sum[G.semi[i]];
		for(;q;--q)
		{
			scanf("%d",&k);
			printf("%d ",sum[k]);
		}
		printf("\n");
	}
}