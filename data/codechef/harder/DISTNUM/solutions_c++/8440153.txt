#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<set>
#include<map>
#include<assert.h>
#include<vector>
#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)
#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)
using namespace std;
typedef long long LL;
typedef double db;
const int P=1000000007;
const int N=410000;
int UP=3;
inline void read(int &x){
	x=0;char p=getchar();
	while(!(p<='9'&&p>='0'))p=getchar();
	while(p<='9'&&p>='0')x*=10,x+=p-48,p=getchar();
}
inline int Pow(int a,int b){
	int c=1;
	for(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;
	return c;
}
struct cao{
	int ty,x,y;
	inline cao(int _ty=0,int _x=0,int _y=0){
		ty=_ty;x=_x;y=_y;
	}
	inline void rd(){
		read(ty);
		if(ty==3)read(x);
		else read(x),read(y);
	}
}bb[N];
int ini[N],val[N],n,Q,M;
int A[4];
namespace sp{
	int id[N];
	int fa[N],l[N],r[N],sz1[N],sz2[N],root,tot,is[N];
	int gd=0;
	inline void updata(int x){
		sz1[x]=sz1[l[x]]+sz1[r[x]]+is[x];
		sz2[x]=sz2[l[x]]+sz2[r[x]]+1;
	}
	inline void left(int x){
		int y=fa[x];int z=fa[y];
		r[y]=l[x];if(l[x])fa[l[x]]=y;
		fa[x]=z;if(l[z]==y)l[z]=x;else r[z]=x;
		l[x]=y;fa[y]=x;updata(y);updata(x);
	}
	inline void right(int x){
		int y=fa[x];int z=fa[y];
		l[y]=r[x];if(r[x])fa[r[x]]=y;
		fa[x]=z;if(l[z]==y)l[z]=x;else r[z]=x;
		r[x]=y;fa[y]=x;updata(y);updata(x);
	}
	inline void splay(int x){
		while(fa[x]){
			int y=fa[x];int z=fa[y];
			if(!z){
				if(l[y]==x)right(x);else left(x);
			}
			else{
				if(l[z]==y){
					if(l[y]==x)right(y),right(x);
					else left(x),right(x);
				}
				else{
					if(r[y]==x)left(y),left(x);
					else right(x),left(x);
				}
			}
		}
		root=x;
	}
	int build(int cl,int cr){
		if(cl>cr)return 0;
		if(cl==cr){
			sz2[cl]=sz1[cl]=is[cl]=1;
		}
		int mid=(cl+cr)>>1;
		l[mid]=build(cl,mid-1);
		r[mid]=build(mid+1,cr);
		fa[l[mid]]=fa[r[mid]]=mid;
		is[mid]=1;
		updata(mid);
		return mid;
	}
	void init(){
		tot=n;
		root=build(1,n);
	}
	void dfs(int x){
		if(!x)return;
		dfs(l[x]);
		is[x]=(x<=n);
		id[x]=++gd;
		dfs(r[x]);
		updata(x);
	}
	inline int gtit(int x){
		int y=root;
		if(!x)return 0;
		while(1){
			//printf("%d %d\n",y,x);
			//system("pause");
			if(sz1[l[y]]>=x)y=l[y];
			else{
				if(sz1[l[y]]==x-1&&is[y]==1)return y;
				else {x-=is[y]+sz1[l[y]];y=r[y];}
			}
		}
	}
};
struct mes{
	int ans[4];
	inline void unit(){
		ans[0]=ans[1]=ans[2]=ans[3]=0;
	}
};
mes c;
inline mes operator +(const mes &a,const mes &b){
	rep(i,0,UP){
		c.ans[i]=a.ans[i]+b.ans[i];
		if(c.ans[i]>=P)c.ans[i]-=P;
	}
	return c;
}
int root[N];
int cl[N*100],cr[N*100];mes node[N*100];int segtot;
set<int>tmp[N];
int org[N];
//---------------------------------------------------------
void Tadd(int &me,int l,int r,int x,int y){
	if(!me)me=++segtot;
	if(l==r){
		rep(i,0,UP){
			node[me].ans[i]=node[me].ans[i]+A[i];
			if(node[me].ans[i]>=P)node[me].ans[i]-=P;
		}
		return;
	}
	int mid=(l+r)>>1;
	
	if(x<=mid)Tadd(cl[me],l,mid,x,y);
	else Tadd(cr[me],mid+1,r,x,y);
	
	node[me]=node[cl[me]]+node[cr[me]];
}
void Tdel(int &me,int l,int r,int x,int y){
	if(!me){assert(0);return;}
	if(l==r){
		rep(i,0,UP){
			node[me].ans[i]=node[me].ans[i]+P-A[i];
			if(node[me].ans[i]>=P)node[me].ans[i]-=P;
		}
		return;
	}
	int mid=(l+r)>>1;
	
	if(x<=mid)Tdel(cl[me],l,mid,x,y);
	else Tdel(cr[me],mid+1,r,x,y);
	
	node[me]=node[cl[me]]+node[cr[me]];
}
bool vis[N];
inline void bj(int x){
	for(;x;x-=(x&(-x)))vis[x]|=1;
}
//----------------------------------------------
inline void segmentadd(int x,int y,int vv){
	//printf("add %d %d %d\n",x-1,y,vv);
	A[0]=1;rep(i,1,UP)A[i]=A[i-1]*1ll*vv%P;
	for(;x<=sp::gd;x+=(x&(-x)))if(vis[x]){
		Tadd(root[x],1,sp::gd,y,vv);
	}
}
inline void segmentdel(int x,int y,int vv){
	//printf("del %d %d %d\n",x-1,y,vv);
	A[0]=1;rep(i,1,UP)A[i]=A[i-1]*1ll*vv%P;
	for(;x<=sp::gd;x+=(x&(-x)))if(vis[x]){
		Tdel(root[x],1,sp::gd,y,vv);
	}
}
//-----------------------------------------------------------
inline void insert(int gt,int pos,int vv){
	tmp[gt].insert(pos);
	set<int>::iterator it=tmp[gt].find(pos);
	
	if(tmp[gt].size()==1){
		segmentadd(1,pos,vv);
		return;
	}
	if(it==tmp[gt].begin()){
		++it;
		segmentdel(1,*it,vv);
		segmentadd(pos+1,*it,vv);
		segmentadd(1,pos,vv);
		return;
	}
	if(it==(--tmp[gt].end())){
		--it;
		segmentadd((*it)+1,pos,vv);
		return;
	}
	set<int>::iterator itt=it;
	++it;--itt;
	segmentdel((*itt)+1,(*it),vv);
	segmentadd(pos+1,(*it),vv);
	segmentadd((*itt)+1,pos,vv);
}
inline void dele(int gt,int pos){
	int vv=val[gt];
	if(tmp[gt].size()==1){
		segmentdel(1,pos,vv);
		tmp[gt].erase(pos);
		return;
	}
	set<int>::iterator it=tmp[gt].find(pos);
	if(it==tmp[gt].begin()){
		++it;
		segmentdel(1,pos,vv);
		segmentadd(1,*it,vv);
		segmentdel(pos+1,*it,vv);
		tmp[gt].erase(pos);
		return;
	}
	if(it==(--tmp[gt].end())){
		--it;
		segmentdel((*it)+1,pos,vv);
		tmp[gt].erase(pos);
		return;
	}
	set<int>::iterator bef=it;bef--;
	set<int>::iterator aft=it;aft++;
	segmentadd((*bef)+1,(*aft),vv);
	segmentdel(pos+1,(*aft),vv);
	segmentdel((*bef)+1,pos,vv);
	tmp[gt].erase(pos);
	return;
}
mes ask(int me,int l,int r,int x,int y){
	if(!me){
		mes uu;uu.unit();return uu;
	}
	if(x<=l&&r<=y)return node[me];
	int mid=(l+r)>>1;
	mes uu;uu.unit();
	if(x<=mid)uu=uu+ask(cl[me],l,mid,x,y);
	if(y>mid)uu=uu+ask(cr[me],mid+1,r,x,y);
	return uu;
}
mes getans(int l1,int r1,int l2,int r2){
	mes uu;uu.unit();
	for(;r1;r1-=(r1&(-r1)))uu=uu+ask(root[r1],1,sp::gd,l2,r2);
	return uu;
}
int main(){
	scanf("%d%d",&n,&Q);
	rep(i,1,n)read(ini[i]);
	rep(i,1,n)val[i]=ini[i];M=n;
	rep(i,1,Q){
		bb[i].rd();
		if(bb[i].ty%2==0)val[++M]=bb[i].y;
	}
	sort(val+1,val+1+M);
	M=unique(val+1,val+1+M)-val-1;
	rep(i,1,n)ini[i]=lower_bound(val+1,val+1+M,ini[i])-val;
	rep(i,1,Q)if(bb[i].ty%2==0)bb[i].y=lower_bound(val+1,val+1+M,bb[i].y)-val;
	
	sp::init();
	rep(i,1,Q){
		if(bb[i].ty==4){
			int yy=sp::gtit(bb[i].x);
			if(!yy){
				yy=sp::root;
				while(sp::l[yy])yy=sp::l[yy];
				sp::splay(yy);
				++sp::tot;
				sp::is[sp::tot]=1;
				sp::updata(sp::tot);
				sp::fa[sp::tot]=yy;
				sp::l[yy]=sp::tot;
				sp::updata(yy);
				bb[i].x=sp::tot;
				//sp::dd(sp::root);
			}
			else{
				sp::splay(yy);
				++sp::tot;
				sp::is[sp::tot]=1;
				sp::updata(sp::tot);
				if(!sp::r[yy]){
					sp::r[yy]=sp::tot;
					sp::fa[sp::tot]=yy;
					sp::updata(yy);
				}
				else{
					sp::sz1[yy]++;
					sp::sz2[yy]++;
					yy=sp::r[yy];
					while(sp::l[yy]){
						sp::sz1[yy]++;
						sp::sz2[yy]++;
						yy=sp::l[yy];
					}
					sp::sz1[yy]++;
					sp::sz2[yy]++;
					sp::fa[sp::tot]=yy;
					sp::l[yy]=sp::tot;
				}
				bb[i].x=sp::tot;
			}
		}
		if(bb[i].ty==3){
			int yy=sp::gtit(bb[i].x);
			sp::splay(yy);
			sp::is[yy]=0;
			sp::updata(yy);
		}
		//sp::dd(sp::root);
		//printf("re1 %d %d %d\n",bb[i].ty,bb[i].x,bb[i].y);
	}
	sp::dfs(sp::root);
	//rep(i,1,sp::gd)printf("%d ",sp::id[i]);printf("\n");
	//sp::dd(sp::root);
	rep(i,1,Q){
		if(bb[i].ty==1){
			bb[i].x=sp::id[sp::gtit(bb[i].x)];
			bb[i].y=sp::id[sp::gtit(bb[i].y)];
		}
		if(bb[i].ty==2){
			bb[i].x=sp::id[sp::gtit(bb[i].x)];
		}
		if(bb[i].ty==3){
			int gg=sp::gtit(bb[i].x);
			sp::splay(gg);
			sp::is[gg]=0;
			sp::updata(gg);
			//printf("__%d %d\n",gg,sp::id[gg]);
			bb[i].x=sp::id[gg];
		}
		if(bb[i].ty==4){
			sp::splay(bb[i].x);
			sp::is[bb[i].x]=1;
			sp::updata(bb[i].x);
			bb[i].x=sp::id[bb[i].x];
		}
		if(bb[i].ty==5){
			bb[i].x=sp::id[sp::gtit(bb[i].x)];
			bb[i].y=sp::id[sp::gtit(bb[i].y)];
		}
	}
	//rep(i,1,Q)printf("re %d %d %d\n",bb[i].ty,bb[i].x,bb[i].y);
	bool gg=0;
	rep(i,1,Q)gg|=(bb[i].ty==1);
	if(!gg)UP=0;
	rep(i,1,Q)if(bb[i].ty==1||bb[i].ty==5)bj(bb[i].x);
	rep(i,1,n){
		insert(ini[i],sp::id[i],val[ini[i]]);
	}
	
	memset(org,-1,sizeof org);
	rep(i,1,n)org[sp::id[i]]=ini[i];
	
	rep(i,1,Q){
		if(bb[i].ty==1){
			mes yy=getans(1,bb[i].x,bb[i].x,bb[i].y);
			int ans=(yy.ans[1]*1ll*yy.ans[1]%P)*1ll*yy.ans[1]%P;
			ans=(ans+(yy.ans[2]*1ll*yy.ans[1]%P)*1ll*(P-3))%P;
			ans=(ans+yy.ans[3]*2ll)%P;
			ans=ans*1ll*Pow(6,P-2)%P;
			printf("%d\n",ans);
		}
		if(bb[i].ty==2){
			dele(org[bb[i].x],bb[i].x);
			org[bb[i].x]=bb[i].y;
			insert(bb[i].y,bb[i].x,val[bb[i].y]);
		}
		if(bb[i].ty==3){
			dele(org[bb[i].x],bb[i].x);
			org[bb[i].x]=-1;
		}
		if(bb[i].ty==4){
			insert(bb[i].y,bb[i].x,val[bb[i].y]);
			org[bb[i].x]=bb[i].y;
		}
		if(bb[i].ty==5){
			mes yy=getans(1,bb[i].x,bb[i].x,bb[i].y);
			printf("%d\n",yy.ans[0]);
		}
	}
	return 0;
}




