#include<cstdio>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<algorithm>
#include<string>
#include<utility>
#include<cassert>
#include<cmath>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long

int isSquare(int x){
  int k = sqrt(x);
  if(k*k==x || (k-1)*(k-1)==x || (k+1)*(k+1)==x) return 1;
  return 0;
}

int isBeautiful(int x){
  if(isSquare(x)) return 1;
  if(x%2) return 0;
  return isSquare(x/2);
}

int N, V[310000];
vector<int> edge[310000];

int usable[310000], visited[310000], visnum;
int dist[310000], val[310000], size[310000], mxsize[310000], up[310000];
int q[310000], q_st, q_size;

int getNextRoot(int root, int usenum, int fg){
  int i, j, k, t, nodenum;
  int res;

  visnum++;

  q_st = q_size = 0;
  q[q_st+q_size++] = root;
  up[root] = -1;
  visited[root] = visnum;
  
  while(q_size){
    i = q[q_st++]; q_size--;
    rep(j,(int)edge[i].size()){
      k = edge[i][j];
      if(visited[k]==visnum || usable[k]!=usenum) continue;
      up[k] = i;
      visited[k] = visnum;
      q[q_st+q_size++] = k;
    }
  }
  for(t=q_st-1;t>=0;t--){
    i = q[t];
    size[i] = 1;
    rep(j,(int)edge[i].size()){
      k = edge[i][j];
      if(k==up[i] || usable[k]!=usenum) continue;
      size[i] += size[k];
    }
  }
  if(!fg) return -1;

  res = root;
  nodenum = size[root];
  rep(t,q_st){
    i = q[t];
    mxsize[i] = nodenum - size[i];
    rep(j,(int)edge[i].size()){
      k = edge[i][j];
      if(k==up[i] || usable[k]!=usenum) continue;
      if(mxsize[i] < size[k]) mxsize[i] = size[k];
    }
    if(mxsize[res] > mxsize[i]) res = i;
  }

  return res;
}

void getDist(int root, int usenum, ll distsum[], ll sum[]){
  int i, j, k;

  q_st = q_size = 0;
  q[q_st+q_size++] = root;
  dist[root] = 1; val[root] = V[root]*2-1;
  while(q_size){
    i = q[q_st++]; q_size--;
    rep(j,(int)edge[i].size()){
      k = edge[i][j];
      if(usable[k]!=usenum || k==up[i]) continue;
      dist[k] = dist[i] + 1;
      val[k] = val[i] + V[k]*2-1;
      q[q_st+q_size++] = k;
    }
    distsum[val[i]] += dist[i];
    sum[val[i]] += 1;
  }
}

void setUsenum(int root, int old, int next){
  int i, j, k;

  if(usable[root]==next) return;
  
  q_st = q_size = 0;
  q[q_st+q_size++] = root;
  usable[root] = next;
  while(q_size){
    i = q[q_st++]; q_size--;
    rep(j,(int)edge[i].size()){
      k = edge[i][j];
      if(usable[k]!=old) continue;
      usable[k] = next;
      q[q_st+q_size++] = k;
    }
  }
}


ll memory[6000000];
ll *distsum[310000], *sum[310000]; int mxd[310000];
ll distsumsum_mem[666666], sumsum_mem[666666];

ll calcu(ll distsum[], ll sum[], int mxd, int rootV){
  int i, k;
  ll *distsumsum, *sumsum;
  ll res = 0;

  distsumsum = distsumsum_mem + 333333;
  sumsum = sumsum_mem + 333333;

  distsumsum[mxd] = distsum[mxd];
  sumsum[mxd] = sum[mxd];
  for(i=mxd-1;i>=-mxd;i--){
    distsumsum[i] = distsumsum[i+1] + distsum[i];
    sumsum[i] = sumsum[i+1] + sum[i];
  }

  REP(i,-mxd,mxd+1) if(sum[i]){
    if(rootV) k = -i-1;
    else      k = -i+1;
    

    res += distsum[i] * sumsum[k];
    res += sum[i] * distsumsum[k];
    res += sum[i] * sumsum[k];
  }

  return res;
}

/* Devide and Conquer */
ll solve(int root){
  int i, j, k, usenum = root;
  ll res = 0;
  ll *mem = memory;
  int dsize = 0, mxdsize;

  root = getNextRoot(root, usenum, 1); /* searching the root node, which minimizes the max size of subtrees */
  if(size[usenum]==1) return 2*V[usenum];
  getNextRoot(root, usenum, 0); /* getting "depth" of each node */

  res += 2*V[root];

  /* checking the paths from root node to each node in each subtree, and counting them */
  rep(j,(int)edge[root].size()){
    k = edge[root][j];
    if(usable[k] != usenum) continue;

    mxd[dsize] = size[k]+5;
    distsum[dsize] = mem + mxd[dsize] + 5;
    mem = distsum[dsize] + 2*(mxd[dsize] + 5);
    sum[dsize] = mem + mxd[dsize] + 5;
    mem = sum[dsize] + 2*(mxd[dsize] + 5);

    REP(i,-mxd[dsize],mxd[dsize]+1){
      distsum[dsize][i] = 0;
      sum[dsize][i] = 0;
    }
    getDist(k, usenum, distsum[dsize], sum[dsize]);

    dsize++;
  }

  rep(i,dsize) res -= calcu(distsum[i], sum[i], mxd[i], V[root]); /* the paths whose both endpoints are in the same subtree */

  mxdsize = 0;
  rep(i,dsize) if(mxdsize < mxd[i]) mxdsize = mxd[i];

  mxd[dsize] = mxdsize;
  distsum[dsize] = mem + mxd[dsize] + 5;
  mem = distsum[dsize] + 2*(mxd[dsize] + 5);
  sum[dsize] = mem + mxd[dsize] + 5;
  mem = sum[dsize] + 2*(mxd[dsize] + 5);
  REP(i,-mxd[dsize],mxd[dsize]+1){
    distsum[dsize][i] = 0;
    sum[dsize][i] = 0;
  }
  rep(i,dsize) REP(j,-mxd[i],mxd[i]+1){
    distsum[dsize][j] += distsum[i][j];
    sum[dsize][j] += sum[i][j];
  }
  res += calcu(distsum[dsize], sum[dsize], mxd[dsize], V[root]); /* DP */

  REP(i,-2*V[root]+1,mxd[dsize]+1){
    res += 2 * (distsum[dsize][i] + sum[dsize][i]); /* the paths one endpoint is the current root */
  }

  /* devide to subtrees */
  usable[root] = -1;
  rep(j,(int)edge[root].size()){
    k = edge[root][j];
    if(usable[k] != usenum) continue;
    setUsenum(k, usenum, k);
    res += solve(k);
  }

  return res;
}

int main(){
  int i, j, k;
  ll res;

  scanf("%d",&N);
  rep(i,N) edge[i].clear();

  REP(k,1,N){
    scanf("%d%d",&i,&j);
    
    i--; j--;
    edge[i].push_back(j);
    edge[j].push_back(i);
  }
  rep(i,N) scanf("%d",V+i);
  

  rep(i,N) V[i] = isBeautiful(V[i]);
  rep(i,N) usable[i] = 0;

  res = solve(0);
  
  res /= 2;
  printf("%lld\n",res);

  return 0;
}