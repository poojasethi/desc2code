/**
 * cf. circulant matrix (http://en.wikipedia.org/wiki/Circulant_matrix)
 */

#include <cstdio>
#include <cctype>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;

#define MAX 1000005

typedef long long ll;

ll powmod(ll a, ll e, ll n) {
    ll ret = 1;
    while (e > 0) {
        if (e & 1)
            ret = (ret * a) % n;
        a = (a * a) % n;
        e >>= 1;
    }
    return ret;
}

ll invmod(ll a, ll p) {
    return powmod(a, p-2, p);
}

int isp[4000000];
int lsp[4000000], np;

void sieve(int n) {
    memset(isp, 0, sizeof(isp));
    for (int i = 3; i < n; i += 2)
        isp[i] = 1;
    for (ll i = 3; i < n; i += 2) if (isp[i])
        for (ll j = i * i; j < n; j += i)
            isp[j] = 0;
    np = 0;
    lsp[np++] = 2;
    for (int i = 3; i < n; i += 2)
        if (isp[i])
            lsp[np++] = i;
}

int isprime(int p) {
    if (p < 4000000)
        return isp[p];
    for (int i = 0, lim = sqrt(p); lsp[i] <= lim; i++)
        if (p % lsp[i] == 0)
            return 0;
    return 1;
}

int prim_root(int p) {
    if (p == 2)
        return 1;
    vector<int> f;
    for (int i = 0, m = p-1; i < np && m > 1; i++) {
        if (m % lsp[i] == 0) {
            f.push_back(lsp[i]);
            while (m % lsp[i] == 0)
                m /= lsp[i];
        }
    }
    for (int i = 0; i < np; i++) {
        int a = lsp[i], flag = 1;
        for (int j = 0; flag && j < f.size(); j++)
            if (powmod(a, (p-1)/f[j], p) == 1)
                flag = 0;
        if (flag)
            return a;
    }
    return 0;
}

void bit_reverse_copy(vector<ll> &a, int n) {
    int bits = 32 - __builtin_clz(n >> 1);
    for (int i = 0; i < n; i++) {
        int j = 0;
        for (int k = 0; k < bits; k++) {
            if (i & (1 << k))
                j |= 1 << (bits-k-1);
        }
        if (i < j)
            swap(a[i], a[j]);
    }
}

void ntt_radix2(vector<ll> &in, bool inv, ll root, ll p) {
    int n = in.size();
    bit_reverse_copy(in, n);

    for (int len = 2, half = 1; len <= n; len <<= 1, half <<= 1) {
        ll wlen = powmod(inv ? invmod(root, p) : root, (p-1)/len, p);
        for (int i = 0; i < n; i += len) {
            ll w = 1;
            for (int j = 0; j < half; j++) {
                ll u = in[i+j], v = (w * in[i+j+half]) % p;
                in[i+j] = u+v < p ? u+v : u+v-p;
                in[i+j+half] = u-v >= 0 ? u-v : u-v+p;
                w = (w * wlen) % p;
            }
        }
    }

    if (inv) {
        ll inv_n = invmod(n, p);
        for (int i = 0; i < n; i++)
            in[i] = (inv_n * in[i]) % p;
    }
}

void convolve(vector<ll> &a1, vector<ll> &b1, ll p) {
    ll prime1 = 134348801, root1 = 3;
    ll prime2 = 537133057, root2 = 5;

    int n = a1.size();
    vector<ll> a2 = a1, b2 = b1;

    ntt_radix2(a1, 0, root1, prime1);
    ntt_radix2(b1, 0, root1, prime1);
    ntt_radix2(a2, 0, root2, prime2);
    ntt_radix2(b2, 0, root2, prime2);

    for (int i = 0; i < n; i++) {
        a1[i] = (a1[i] * b1[i]) % prime1;
        a2[i] = (a2[i] * b2[i]) % prime2;
    }

    ntt_radix2(a1, 1, root1, prime1);
    ntt_radix2(a2, 1, root2, prime2);

    // chinese remainder algorithm
    ll inv_prime1 = invmod(prime1, prime2);
    for (int i = 0; i < n; i++) {
        ll aux = ((a2[i] - a1[i]) * inv_prime1) % prime2;
        if (aux < 0) aux += prime2;
        a1[i] = (a1[i] + aux * prime1) % p;
    }
}

void ntt_bluestein(vector<ll> &in, ll w_h, ll w, ll p) {
    int n = in.size(), m = 1;
    while (m < (n<<1))
        m <<= 1;

    vector<ll> a(m), b(m);

    ll inv_w_h = invmod(w_h, p);
    for (int i = 0; i < n; i++) {
        a[i] = (in[i] * powmod(w_h, i*i, p)) % p;
        b[i] = powmod(inv_w_h, i*i, p);
        if (i) b[m-i] = b[i];
    }

    convolve(a, b, p);

    for (int i = 0; i < n; i++)
        in[i] = (powmod(w_h, i*i, p) * a[i]) % p;
}

int solve(vector<ll> &in) {
    int n = in.size(), n2 = 2 * n;

    int p = 1000000 / n2 * n2 + 1;
    while (!isprime(p))
        p += n2;

    int g = prim_root(p);
    ll w_h = powmod(g, (p-1)/n2, p);
    ll w = (w_h * w_h) % p;

    for (int i = 0; i < n; i++)
        if (in[i] < 0)
            in[i] += p;

    ntt_bluestein(in, w_h, w, p);

    for (int i = 0; i < n; i++)
        if (in[i] == 0)
            return 1;
    return 0;
}

int main() {
    sieve(4000000);

    int T, n, x;
    vector<ll> a;

    scanf("%d", &T);
    while (T--) {
        a.clear();
        scanf("%d", &n);
        for (int i = 0; i < n; i++) {
            scanf("%d", &x);
            a.push_back(x);
        }

        puts(solve(a) ? "YES" : "NO");
    }
}
