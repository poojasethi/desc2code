/**
 * cf. circulant matrix (http://en.wikipedia.org/wiki/Circulant_matrix)
 */

#include <cstdio>
#include <cctype>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <complex>
#include <vector>
using namespace std;

#define MAX 1<<20
#define PRIME1 134348801
#define ROOT1  3
#define PRIME2 537133057
#define ROOT2  5

typedef long long ll;
typedef complex<long double> cdouble;

const long double eps = 1e-8;

#define gc getchar_unlocked
inline void readint(int &x) {
    int c = gc(), neg = 0;
    while (!isdigit(c) && c != '-') c = gc();
    if (c == '-') neg = 1, c = gc();
    for (x = 0; isdigit(c); c = gc())
        x = (x << 1) + (x << 3) + c - '0';
    if (neg) x = -x;
}

ll powmod(ll a, ll e, ll n) {
    ll ret = 1;
    while (e > 0) {
        if (e & 1)
            ret = (ret * a) % n;
        a = (a * a) % n;
        e >>= 1;
    }
    return ret;
}

ll invmod(ll a, ll p) {
    return powmod(a, p-2, p);
}

ll cra(pair<ll, ll> *a, int n) {
    ll m = 1, sum = 0;
    for (int i = 0; i < n; i++)
        m *= a[i].second;
    for (int i = 0; i < n; i++) {
        ll tmp = m / a[i].second;
        ll aux = (tmp * invmod(tmp, a[i].second)) % m;
        sum = (sum + a[i].first * aux) % m;
    }
    return sum;
}

int isp[MAX];
int lsp[MAX], np;

void sieve(int n) {
    memset(isp, 0, sizeof(isp));
    for (int i = 3; i < n; i += 2)
        isp[i] = 1;
    for (ll i = 3; i < n; i += 2) if (isp[i])
        for (ll j = i * i; j < n; j += i)
            isp[j] = 0;
    np = 0;
    lsp[np++] = 2;
    for (int i = 3; i < n; i += 2)
        if (isp[i])
            lsp[np++] = i;
}

int isprime(int p) {
    if (p < MAX)
        return isp[p];
    for (int i = 0; lsp[i] * lsp[i] <= p; i++)
        if (p % lsp[i] == 0)
            return 0;
    return 1;
}

int prim_root(int p) {
    if (p == 2)
        return 1;
    vector<int> f;
    for (int i = 0, m = p-1; i < np && m > 1; i++) {
        if (m % lsp[i] == 0) {
            f.push_back(lsp[i]);
            while (m % lsp[i] == 0)
                m /= lsp[i];
        }
    }
    for (int i = 0; i < np; i++) {
        int a = lsp[i], flag = 1;
        for (int j = 0; flag && j < f.size(); j++)
            if (powmod(a, (p-1)/f[j], p) == 1)
                flag = 0;
        if (flag)
            return a;
    }
    return 0;
}

ll _tmp[MAX];
void ntt_radix2(ll *in, int n, bool inv, ll root, ll p) {
    if (n == 1) return;

    ll h = n >> 1;
    for (int i = 0, j = 0; i < n; i += 2, j++) {
        in[j] = in[i];
        _tmp[h+j] = in[i+1];
    }
    for (int i = h; i < n; i++)
        in[i] = _tmp[i];

    ll *even = in, *odd = in+h;
    ntt_radix2(even, h, inv, root, p);
    ntt_radix2(odd, h, inv, root, p);

    ll a = inv ? powmod(root, p-2, p) : root;
    ll w = powmod(a, (p-1)/n, p), w_i = 1;
    for (int i = 0; i < h; i++) {
        ll conv = (w_i * odd[i]) % p;
        odd[i] = (even[i] - conv) % p;
        if (odd[i] < 0) odd[i] += p;
        even[i] = (even[i] + conv) % p;
        w_i = (w_i * w) % p;
    }
}

void ntt(ll *in, int n, bool inv, ll root, ll p) {
    ntt_radix2(in, n, inv, root, p);
    if (inv) {
        ll inv_n = powmod(n, p-2, p);
        for (int i = 0; i < n; i++)
            in[i] = (inv_n * in[i]) % p;
    }
}

ll _c[MAX], _d[MAX];
void convolve(ll *a, ll *b, int n, ll p) {
    ll prime1 = PRIME1, root1 = ROOT1;
    ll prime2 = PRIME2, root2 = ROOT2;

    // ll prime1 = 767164417, root1 = 132088491;
    // ll prime2 = 1031667713, root2 = 3198193;

    for (int i = 0; i < n; i++) {
        _c[i] = a[i];
        _d[i] = b[i];
    }

    ntt(a, n, 0, root1, prime1);
    ntt(b, n, 0, root1, prime1);
    ntt(_c, n, 0, root2, prime2);
    ntt(_d, n, 0, root2, prime2);

    for (int i = 0; i < n; i++) {
        a[i] = (a[i] * b[i]) % prime1;
        _c[i] = (_c[i] * _d[i]) % prime2;
    }

    ntt(a, n, 1, root1, prime1);
    ntt(_c, n, 1, root2, prime2);

    // chinese remainder algorithm
    ll inv_prime1 = powmod(prime1, prime2-2, prime2);
    for (int i = 0; i < n; i++) {
        ll aux = ((_c[i] - a[i]) * inv_prime1) % prime2;
        if (aux < 0) aux += prime2;
        a[i] = (a[i] + aux * prime1) % p;
    }
}

ll _a[MAX], _b[MAX];
void ntt_bluestein(ll *in, int n, ll w_h, ll w, ll p) {
    int m = 1;
    while (m < (n<<1))
        m <<= 1;

    memset(_a, 0, sizeof(_a));
    memset(_b, 0, sizeof(_b));

    ll inv_w_h = powmod(w_h, p-2, p);
    for (int i = 0; i < n; i++) {
        _a[i] = (in[i] * powmod(w_h, i*i, p)) % p;
        _b[i] = powmod(inv_w_h, i*i, p);
        if (i) _b[m-i] = _b[i];
    }

    convolve(_a, _b, m, p);

    for (int i = 0; i < n; i++)
        in[i] = (powmod(w_h, i*i, p) * _a[i]) % p;
}

int solve(ll *in, int n) {
    int n2 = 2 * n;

    ll p = 1000000 / n2 * n2 + 1;
    while (!isprime(p))
        p += n2;
    // p = 2200153; // XXX

    ll g = prim_root(p);
    ll w_h = powmod(g, (p-1)/n2, p);
    // w_h = 93; // XXX
    ll w = (w_h * w_h) % p;

    for (int i = 0; i < n; i++) {
        in[i] %= p;
        if (in[i] < 0)
            in[i] += p;
    }

    ntt_bluestein(in, n, w_h, w, p);

    for (int i = 0; i < n; i++)
        if (in[i] == 0)
            return 1;
    return 0;
}

inline bool isZero(double a) {
    return a + eps > 0.0 && eps > a ? 1 : 0;
}

inline bool isZero(const cdouble &a) {
    return isZero(a.real()) && isZero(a.imag());
}

cdouble operator*(int a, const cdouble &b) {
    return cdouble(a * b.real(), a * b.imag());
}

int n, a[MAX];
ll in[MAX];

int main() {
    sieve(MAX);

    int T;
    readint(T);
    while (T--) {
        readint(n);
        for (int i = 0; i < n; i++) {
            readint(a[i]);
            in[i] = a[i];
        }

        if (solve(in, n))
            puts("YES");
        else
            puts("NO");

        /*
        {
            int ans = 0;
            puts("");
            int lim = n;//(n >> 1) + 1;
            cdouble base = exp(cdouble(0, -2 * M_PI / n)), wj = 1;
            for (int j = 0; j < lim; j++, wj *= base) {
                cdouble wjk = 1, sum = 0;
                for (int k = 0; k < n; k++) {
                    sum += a[k] * wjk;
                    wjk *= wj;
                }
                cout << sum << endl;
                if (isZero(sum)) {
                    ans = 1;
                    break;
                }
            }
            puts("");
        }
        puts(ans ? "YES" : "NO");
        */
    }
}
