/**
 * cf. circulant matrix (http://en.wikipedia.org/wiki/Circulant_matrix)
 */

#include <cstdio>
#include <cctype>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <complex>
#include <vector>
using namespace std;

#define MAX 1<<22

typedef long long ll;

ll powmod(ll a, ll e, ll n) {
    ll ret = 1;
    while (e > 0) {
        if (e & 1)
            ret = (ret * a) % n;
        a = (a * a) % n;
        e >>= 1;
    }
    return ret;
}

ll invmod(ll a, ll p) {
    return powmod(a, p-2, p);
}

int isp[MAX];
int lsp[MAX], np;

void sieve(int n) {
    memset(isp, 0, sizeof(isp));
    for (int i = 3; i < n; i += 2)
        isp[i] = 1;
    for (ll i = 3; i < n; i += 2) if (isp[i])
        for (ll j = i * i; j < n; j += i)
            isp[j] = 0;
    np = 0;
    lsp[np++] = 2;
    for (int i = 3; i < n; i += 2)
        if (isp[i])
            lsp[np++] = i;
}

int isprime(int p) {
    if (p < MAX)
        return isp[p];
    for (int i = 0; lsp[i] * lsp[i] <= p; i++)
        if (p % lsp[i] == 0)
            return 0;
    return 1;
}

int prim_root(int p) {
    if (p == 2)
        return 1;
    vector<int> f;
    for (int i = 0, m = p-1; i < np && m > 1; i++) {
        if (m % lsp[i] == 0) {
            f.push_back(lsp[i]);
            while (m % lsp[i] == 0)
                m /= lsp[i];
        }
    }
    for (int i = 0; i < np; i++) {
        int a = lsp[i], flag = 1;
        for (int j = 0; flag && j < f.size(); j++)
            if (powmod(a, (p-1)/f[j], p) == 1)
                flag = 0;
        if (flag)
            return a;
    }
    return 0;
}

ll _tmp[MAX];
void ntt_radix2(ll *in, int n, bool inv, ll root, ll p) {
    if (n == 1) return;

    ll h = n >> 1;
    for (int i = 0, j = 0; i < n; i += 2, j++) {
        in[j] = in[i];
        _tmp[h+j] = in[i+1];
    }
    for (int i = h; i < n; i++)
        in[i] = _tmp[i];

    ll *even = in, *odd = in+h;
    ntt_radix2(even, h, inv, root, p);
    ntt_radix2(odd, h, inv, root, p);

    ll a = inv ? invmod(root, p) : root;
    ll w = powmod(a, (p-1)/n, p), w_i = 1;
    for (int i = 0; i < h; i++) {
        ll conv = (w_i * odd[i]) % p;
        odd[i] = (even[i] - conv) % p;
        if (odd[i] < 0) odd[i] += p;
        even[i] = (even[i] + conv) % p;
        w_i = (w_i * w) % p;
    }
}

void ntt(ll *in, int n, bool inv, ll root, ll p) {
    ntt_radix2(in, n, inv, root, p);
    if (inv) {
        ll inv_n = invmod(n, p);
        for (int i = 0; i < n; i++)
            in[i] = (inv_n * in[i]) % p;
    }
}

ll _c[MAX], _d[MAX];
void convolve(ll *a, ll *b, int n, ll p) {
    ll prime1 = 134348801, root1 = 3;
    ll prime2 = 537133057, root2 = 5;

    for (int i = 0; i < n; i++) {
        _c[i] = a[i];
        _d[i] = b[i];
    }

    ntt(a, n, 0, root1, prime1);
    ntt(b, n, 0, root1, prime1);
    ntt(_c, n, 0, root2, prime2);
    ntt(_d, n, 0, root2, prime2);

    for (int i = 0; i < n; i++) {
        a[i] = (a[i] * b[i]) % prime1;
        _c[i] = (_c[i] * _d[i]) % prime2;
    }

    ntt(a, n, 1, root1, prime1);
    ntt(_c, n, 1, root2, prime2);

    // chinese remainder algorithm
    ll inv_prime1 = invmod(prime1, prime2);
    for (int i = 0; i < n; i++) {
        ll aux = ((_c[i] - a[i]) * inv_prime1) % prime2;
        if (aux < 0) aux += prime2;
        a[i] = (a[i] + aux * prime1) % p;
    }
}

ll _a[MAX], _b[MAX];
void ntt_bluestein(ll *in, int n, ll w_h, ll w, ll p) {
    int m = 1;
    while (m < (n<<1))
        m <<= 1;

    memset(_a, 0, sizeof(_a));
    memset(_b, 0, sizeof(_b));

    ll inv_w_h = invmod(w_h, p);
    for (int i = 0; i < n; i++) {
        _a[i] = (in[i] * powmod(w_h, i*i, p)) % p;
        _b[i] = powmod(inv_w_h, i*i, p);
        if (i) _b[m-i] = _b[i];
    }

    convolve(_a, _b, m, p);

    for (int i = 0; i < n; i++)
        in[i] = (powmod(w_h, i*i, p) * _a[i]) % p;
}

int solve(ll *in, int n) {
    int n2 = 2 * n;

    ll p = 1000000 / n2 * n2 + 1;
    while (!isprime(p))
        p += n2;

    ll g = prim_root(p);
    ll w_h = powmod(g, (p-1)/n2, p);
    ll w = (w_h * w_h) % p;

    for (int i = 0; i < n; i++) {
        in[i] %= p;
        if (in[i] < 0)
            in[i] += p;
    }

    ntt_bluestein(in, n, w_h, w, p);

    for (int i = 0; i < n; i++)
        if (in[i] == 0)
            return 1;
    return 0;
}

int n;
ll a[MAX];

int main() {
    sieve(MAX);

    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 0; i < n; i++)
            scanf("%lld", &a[i]);

        puts(solve(a, n) ? "YES" : "NO");
    }
}
