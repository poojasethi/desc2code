#include <iostream>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <ctime>
#include <math.h>
#include <algorithm>
#include <iomanip>
#include <assert.h>
#include <map>
#include <queue>
#include <cstring>
#include <set>
#include <stack>
#include <numeric>
using namespace std;

typedef unsigned long long int ull;
typedef long long int ll;
#define vi vector<int>
#define vvi vector< vector<int> >
#define vd vector<double>
#define vb vector<bool>
#define vs vector<string>
#define pi pair<int,int>
#define pb push_back
#define out(a) cout<<(a)<<endl
#define pout(a) cout<<(a).first<<' '<<(a).second<<endl
#define sz(c) (int)(c).size()
#define fr(n,i) for(int (i)=0;(i)<(n);(i)++)
#define rng(s,e,i) for(int (i)=(s);(i)<=(e);(i)++)
#define all(c) (c).begin(),(c).end()
#define ifBit(n,i) ( ((n) >> (i)) & 1 )
#define mp make_pair
template<typename typ> void vout(vector<typ>& v){for(int vint=0;vint<sz(v);vint++){cout<<(v)[vint];if(vint==sz(v)-1) cout<<endl;else cout<<' ';}}
template<typename typ> void arrout(typ* arr,int l){for(int i=0;i<l;i++){cout<<arr[i];if(i<l-1) cout <<' ';else cout<<endl;}}

#ifdef DEBUG
	#define debug(args...)            {dbg,args; cerr<<endl;}
#else
	#define debug(args...)              // Just strip off all debug tokens
#endif

const long long inf = (1LL << 62);
struct debugger
{
	template<typename T> debugger& operator , (const T& v)
	{
		cerr<<v<<" ";
		return *this;
	}
}dbg;

class item {
public:
	long long a, b;
	item(long long na, long long nb) : a(na), b(nb) {}
	item() : a(0), b(0) {}
	long long val(int c) {
		return c * a + b;
	}
	friend item operator +=(item& it1, const item& it2);
};

item operator +=(item& it1, const item& it2) {
	it1.a += it2.a;
	it1.b += it2.b;
	return it1;
}

class node {
public:
	item fee, price;
	int l, r;
	node *left, *right;
	bool seen;
	node(int nl, int nr):l(nl), r(nr) {
		left = right = NULL;
		seen = false;
	}
};

void updatePrice(node* cur, int start, int end, item it) {
	if( cur -> r < start || cur -> l > end ) {
		return;
	}

	int mid = (cur -> l + cur -> r) / 2;
	if( !cur -> left ) {
		cur -> left = new node(cur -> l, mid);
		cur -> right = new node(mid + 1, cur -> r);
	}
	if( cur -> l >= start && cur -> r <= end ) {
		if( !cur -> seen ) {
			cur -> seen = true;
			cur -> price = it;
			return;
		}

		item it1 = cur -> price, it2 = it;
		long long leftPrice1 = it1.val(cur -> l), leftPrice2 = it2.val(cur -> l);
		if( leftPrice1 < leftPrice2 ) {
			swap(it1, it2);
		}

		long long rightPrice1 = it1.val(cur -> r), rightPrice2 = it2.val(cur -> r);
		if( rightPrice1 >= rightPrice2 ) {
			cur -> price = it1;
		} else {
			long long midPrice1 = it1.val(mid), midPrice2 = it2.val(mid);
			if( midPrice1 >= midPrice2 ) {
				cur -> price = it1;
				updatePrice(cur -> right, start, end, it2);
			} else {
				cur -> price = it2;
				updatePrice(cur -> left, start, end, it1);
			}
		}
	} else {
		updatePrice(cur -> left, start, end, it);
		updatePrice(cur -> right, start, end, it);
	}
}

void updateFee(node* cur, int start, int end, item it) {
	if( cur -> l > end || cur -> r < start ) {
		return;
	}
	if( cur -> l >= start && cur -> r <= end ) {
		cur -> fee += it;
	} else {
		int mid = (cur -> l + cur -> r) / 2;
		if( !cur -> left ) {
			cur -> left = new node(cur -> l, mid);
			cur -> right = new node(mid + 1, cur -> r);
		}
		updateFee(cur -> left, start, end, it);
		updateFee(cur -> right, start, end, it);
	}
}

long long getFee(node* cur, int u) {
	if( !cur || cur -> l > u || cur -> r < u ) {
		return 0;
	}
	long long ans = 0;
	if( cur -> l <= u && cur -> r >= u ) {
		ans += cur -> fee.val(u);
	}
	return ans + getFee(cur -> left, u) + getFee(cur -> right, u);
}

long long getPrice(node* cur, int u) {
	if( !cur || cur -> l > u || cur -> r < u ) {
		return -inf;
	}

	long long ans = max(getPrice(cur -> left, u), getPrice(cur -> right, u));
	if( u >= cur -> l && u <= cur -> r && cur -> seen ) {
		ans = max(ans, cur -> price.val(u));
	}
	return ans;
}

int main() {
	int n, m;
	cin >> n >> m;
	node *root = new node(1, n);
	int t, u, v;
	long long a, b;
	for(int i = 0 ; i < m ; i++) {
		cin >> t;
		if( t == 1 ) {
			cin >> u >> v >> a >> b;
			updatePrice(root, u, v, item(a, b - u * a));
		}
		else if( t == 2 ) {
			cin >> u >> v >> a >> b;
			updateFee(root, u, v, item(a, b - u * a));
		}
		else {
			cin >> u;
			long long price = getPrice(root, u);
			if( price == -inf ) {
				out("NA");
			} else {
				out(getFee(root, u) + price);
			}
		}
	}
}