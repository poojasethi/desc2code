#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<stack>

using namespace std;

#define sd(x) scanf("%d",&x);
#define slld(x) scanf("%lld",&x);
#define LL long long
#define LD long double
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define Fill(a, b) memset(a, b, sizeof(a))
long long INF = -2000000009;
long long NINF = 2000000009*INF;

typedef pair<int,int> PII;
typedef vector<int> VI;

#define MAXM 1000010

long long q[MAXM][5],ar[2*MAXM],x=0,br[2*MAXM],len=2,tree1[MAXM+1],tree2[MAXM+1];
bool gvis=false;

void update(int idx ,long long val,long long tree[])
{
	while (idx <= MAXM)
    {
		tree[idx] += val;
		idx += (idx & -idx);
	}
}
long long read(int idx,long long tree[])
{
	long long sum = 0;
	while (idx > 0)
    {
		sum += tree[idx];
		idx -= (idx & -idx);
	}
	return sum;
}

struct node
{
	int l,r;
	long long a,b,vl,vr;
	bool vis;
}st[8*MAXM];

int bin(int a,int b,long long val)
{//cout<<a<<endl;
	if(a==b)return a;
	else
	{
		int mid=(a+b+1)/2;
		if(br[mid]>val)return bin(0,mid-1,val);
		else return bin(mid,b,val);
	}
}

void initialise(int left,int right,int i)
{
	st[i].l=left;
	st[i].r=right;
	st[i].a=0;
	st[i].b=0;
	st[i].vl=0;
	st[i].vr=0;
	st[i].vis=false;
	//printf("%d %d %d\n",i,left,right);
	if(left<right)
	{
		int mid=(left+right)/2;
		initialise(left,mid,2*i);
		initialise(mid+1,right,2*i+1);
	}
}

void update(int left,int right,int i,long long x,long long y)
{
	//printf("am %d %lld %lld\n",i,x,y);
	if(br[st[i].l]<=right&&left<=br[st[i].r])
	{
		if(br[st[i].l]>=left&&br[st[i].r]<=right)
        {
			long long nowl=x*br[st[i].l]+y,nowr=x*br[st[i].r]+y;
			if((st[i].vl<nowl&&st[i].vr<nowr)||st[i].vis==false)
			{
				st[i].a=x;
				st[i].b=y;
				st[i].vl=nowl;
				st[i].vr=nowr;
				st[i].vis=true;
				//printf("%d %lld %lld %lld %lld\n",i,st[i].a,st[i].b,x,y);

			}
			else if(st[i].vl<nowl||st[i].vr<nowr)
			{
				update(left,right,2*i,x,y);
				update(left,right,2*i+1,x,y);
			}
        }
        else
        {
			update(left,right,2*i,x,y);
			update(left,right,2*i+1,x,y);
        }
	}
}
long long query(int idx,int i)
{//printf("%d\n",i);
	if(st[i].l==st[i].r)
	{
		if(st[i].vis==true)
		{
			gvis=true;
			return st[i].a*idx+st[i].b;
		}
		else return NINF;
	}
	else if(br[st[i].l]<=idx&&idx<=br[st[i].r])
	{
		int mid=(st[i].l+st[i].r)/2;
		if(idx<=br[mid])
		{
			if(st[i].vis==true)
			{
				gvis=true;
				return max(st[i].a*idx+st[i].b,query(idx,2*i));
			}
			else return query(idx,2*i);
		}
		else
		{
			if(st[i].vis==true)
			{
				gvis=true;
				return max(st[i].a*idx+st[i].b,query(idx,2*i+1));
			}
			else return query(idx,2*i+1);
		}
	}
}

void solve()
{
	int n,m;
	long long ans,a,b;
	sd(n);sd(m);
	for(int i=0;i<m;i++)
	{
		slld(q[i][0]);slld(q[i][1]);
		if(q[i][0]<3)
		{
			slld(q[i][2]);slld(q[i][3]);slld(q[i][4]);
			ar[x]=q[i][2];
			x++;
			ar[x]=q[i][1];
			x++;
		}
		else
		{
			ar[x]=q[i][1];
			x++;
		}
	}
	sort(ar,ar+x);
	br[1]=ar[0];
	for(int i=1;i<x;i++)
	{
		if(ar[i]!=ar[i-1])
		{
			br[len]=ar[i];
			len++;
		}
	}
	sort(br+1,br+len);
	//for(int i=0;i<len;i++)printf("%d ",br[i]);
	initialise(1,len-1,1);
	for(int i=0;i<m;i++)
	{
		if(q[i][0]==1)
		{
			//printf("%lld %lld %lld %lld\n",q[i][1],q[i][2],q[i][3],q[i][4]);
			update(q[i][1],q[i][2],1,q[i][3],q[i][4]-q[i][1]*q[i][3]);
		}
		else if(q[i][0]==2)
		{
			int x=bin(1,len-1,q[i][1]),y=bin(1,len-1,q[i][2]);
			update(x,q[i][3],tree1);
			update(y+1,-q[i][3],tree1);
			update(x,q[i][4]-q[i][1]*q[i][3],tree2);
			update(y+1,-q[i][4]+q[i][1]*q[i][3],tree2);
		}
		else if(q[i][0]==3)
		{
			gvis=false;
			ans=query(q[i][1],1);
			int x=bin(1,len-1,q[i][1]);
			a=read(x,tree1);
			b=read(x,tree2);
			if(gvis==true) printf("%lld\n",ans+a*q[i][1]+b);
			else printf("NA\n");
			gvis=false;
		}
	}

}

int main()
{
	int t=1;
	//scanf("%d",&t);
	while(t--)
	{
		solve();
	}
}
