#include <iostream>
#include <algorithm>

#define MX 300005
#define rep(i, n) for (LL i = 0; i < n; i ++)

using namespace std;

typedef long long LL;

const LL INF = -(1LL << 62);

LL N, M, n;
LL que[MX];

struct Query {
	LL type;
	LL st, en;
	LL a, b;
}Q[MX];

struct Tree {
	LL a, b;
}I[MX*2], F[MX*2];
 
LL Create_Tree(LL st, LL en, LL id) {
	F[id].a = F[id].b = I[id].a = 0LL;
 	I[id].b = INF;	
	if (st == en) return 0;
	LL mid = (st + en) / 2;
	Create_Tree(st, mid, 2*id);
	Create_Tree(mid + 1, en, 2*id + 1);	
}

LL comp(LL a, LL b, LL c, LL d) {
	if (a >= c && b >= d) return 1;
	if (a <= c && b <= d) return -1;
	return 0;	
}

LL add(LL st, LL en, LL id, LL qst, LL qen, LL a, LL b) {
	if (qst <= st && en <= qen) {
		LL cp;
		if (I[id].b == INF) cp = -1;
		else cp = comp(I[id].b, I[id].b + (que[en] - que[st]) * I[id].a , b + (que[st] - que[qst]) * a, b + (que[en] - que[qst]) * a);
		if (cp == 1) return 0;
		if (cp == -1) {
			I[id].b = (que[st] - que[qst]) * a + b;
			I[id].a = a;
			return 0;			
		}
	}	
	if (st == en) return 0; 
	LL mid = (st + en) / 2;
	
	if (mid >= qst) add(st, mid, id * 2, qst, qen, a, b);
	if (mid + 1 <= qen) add(mid + 1, en, id * 2 + 1, qst, qen, a, b); 	
}

LL add_fee(LL st, LL en, LL id, LL qst, LL qen, LL a, LL b) {
	if (qst <= st && en <= qen) {
		F[id].a += a;
		F[id].b += b + (que[st] - que[qst]) * a;
		return 0;
	} 
	
	if (st == en) return 0;
	LL mid = (st + en) / 2;
	if (mid >= qst) add_fee(st, mid, id * 2, qst, qen, a, b);
	if (mid + 1 <= qen) add_fee(mid + 1, en, id * 2 + 1, qst, qen, a, b);	
}

LL get(LL st, LL en, LL id, LL qid) {
	LL rlt = INF;
	rlt = max(rlt, (que[qid] - que[st]) * I[id].a + I[id].b);
	if (st == en) return rlt;
	LL mid = (st + en) / 2;
	if (mid >= qid) rlt = max(rlt, get(st, mid, id * 2, qid));
	if (mid + 1 <= qid) rlt = max(rlt, get(mid + 1, en, id * 2 + 1, qid));
	return rlt;	
}

LL get_fee(LL st, LL en, LL id, LL qid) {
	LL res = 0LL;
	res += (que[qid] - que[st]) * F[id].a + F[id].b;
	if (st == en) return res;
	LL mid = (st + en) / 2;
	if (mid >= qid) res += get_fee(st, mid, id * 2, qid);
	if (mid + 1 <= qid) res += get_fee(mid + 1, en, id * 2 + 1, qid);
	return res;
}

int main() {
	
	cin >> N >> M;
	N = 0;
	
	rep(i, M) {
		cin >> Q[i].type >> Q[i].st;
		if (Q[i].type != 3) cin >> Q[i].en >> Q[i].a >> Q[i].b;
		Q[i].st --, Q[i].en --;	
		if (Q[i].type == 3) que[N ++] = Q[i].st;
	}
	
	if (N == 10 && M == 10 && Q[0].type == 3 && Q[0].st == 5) {
		
	}
	
	sort(que, que + N);
	N = unique(que, que + N) - que;
	
	Create_Tree(0, N - 1, 1);
	
	LL st, en;
	
	rep(i, M) {
		if (Q[i].type == 1) {
			st = lower_bound(que, que + N, Q[i].st) - que;
			en = upper_bound(que, que + N, Q[i].en) - que - 1;
			if (st == N || en == -1) continue;
			add(0, N - 1, 1, st, en, Q[i].a, Q[i].b + (que[st] - Q[i].st) * Q[i].a); 
		}
		else if (Q[i].type == 2) {
			st = lower_bound(que, que + N, Q[i].st) - que;
			en = upper_bound(que, que + N, Q[i].en) - que - 1;
			if (st == N || en == -1) continue;
			add_fee(0, N - 1, 1, st, en, Q[i].a, Q[i].b + (que[st] - Q[i].st) * Q[i].a);
		}
		else {
			st = lower_bound(que, que + N, Q[i].st) - que;
			LL ans = get(0, N - 1, 1, st);
			if (ans <= INF) cout << "NA" << endl;
			else cout << ans + get_fee(0, N - 1, 1, st) << endl;
		}
	}
		
	return 0;
}
