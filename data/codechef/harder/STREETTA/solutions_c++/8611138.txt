#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}

struct query{
	int opt;
	int u,v,a,b;
}Q[333333];
map<int,int>ma;
int id[666666];int idtot=0;


ll ki[2222222],bi[2222222];
int l1,r1;int I;
ll kk,bb;int cur;
void add(int l,int r,int x){
	if(l1<=l && r<=r1){
		ki[x]+=kk;
		bi[x]+=bb;
	}else{
		int mid=l+r>>1;
		if(l1<=mid)add(l,mid,x<<1);
		if(r1>mid)add(mid+1,r,x<<1|1);
	}
}
ll s1;
void quesum(int l,int r,int x){
	s1+=1ll*id[I]*ki[x]+bi[x];
	if(l!=r){
		int mid=l+r>>1;
		if(I<=mid)quesum(l,mid,x<<1);
		else quesum(mid+1,r,x<<1|1);
	}
}
int sid[2222222]={0};
void cov(int l,int r,int x){
	if(l1<=l && r<=r1){
		if(sid[x]==0){
			sid[x]=cur;
		}else{
			ll la,lb,ra,rb;
			la=Q[sid[x]].b+1ll*Q[sid[x]].a*(id[l]-id[Q[sid[x]].u]);
			ra=Q[sid[x]].b+1ll*Q[sid[x]].a*(id[r]-id[Q[sid[x]].u]);
			lb=Q[cur].b+1ll*Q[cur].a*(id[l]-id[Q[cur].u]);
			rb=Q[cur].b+1ll*Q[cur].a*(id[r]-id[Q[cur].u]);
			if(lb>=la && rb>=ra){
				sid[x]=cur;
			}else if(lb<=la && rb<=ra);
			else{
				int mid=l+r>>1;
				cov(l,mid,x<<1);
				cov(mid+1,r,x<<1|1);
			}
		}
	}else{
		int mid=l+r>>1;
		if(l1<=mid)cov(l,mid,x<<1);
		if(r1>mid)cov(mid+1,r,x<<1|1);
	}
}
int an;ll s2;
void queseg(int l,int r,int x){
	if(sid[x]){
		ll tmp=Q[sid[x]].b+1ll*Q[sid[x]].a*(id[I]-id[Q[sid[x]].u]);
		if(tmp>s2){
			s2=tmp;
			an=1;
		}
	}
	if(l!=r){
		int mid=l+r>>1;
		if(I<=mid)queseg(l,mid,x<<1);
		else queseg(mid+1,r,x<<1|1);
	}
}

int main()
{
	int n,m;
	gn(n);gn(m);
	for (int i=1;i<=m;i++){
		gn(Q[i].opt);
		gn(Q[i].u);
		ma[Q[i].u];
		if(Q[i].opt<3){
			gn(Q[i].v);
			ma[Q[i].v];
			gn(Q[i].a);
			gn(Q[i].b);
		}
	}
	for (map<int,int>::iterator it=ma.begin();it!=ma.end();it++){
		it->second=++idtot;
		id[idtot]=it->first;
	}
	for (int i=1;i<=m;i++){
		Q[i].u=ma[Q[i].u];
		if(Q[i].opt<3)Q[i].v=ma[Q[i].v];
	}
	for (int i=1;i<=m;i++){
		if(Q[i].opt==2){
			l1=Q[i].u,r1=Q[i].v;
			kk=Q[i].a,bb=Q[i].b-1ll*id[l1]*Q[i].a;
			add(1,idtot,1);
		}else if(Q[i].opt==1){
			l1=Q[i].u,r1=Q[i].v;
			cur=i;
			cov(1,idtot,1);
		}else{
			I=Q[i].u;
			an=0;
			s2=ll(-6e18);
			queseg(1,idtot,1);

			if(an==0){
				printf("NA\n");
				continue;
			}

			s1=0;
			quesum(1,idtot,1);
			printf("%lld\n",s2+s1);
		}
	}
	return 0;
}
