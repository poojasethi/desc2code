#pragma warning(disable:4786)
#pragma warning(disable:4996)
#include<list>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<functional>
#include<string>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<utility>
#include<fstream>
#include<sstream>
#include<cmath>
#include<stack>
#include<assert.h>
using namespace std;
 
#define MEM(a, b) memset(a, (b), sizeof(a))
#define CLR(a) memset(a, 0, sizeof(a))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) )
#define S(X) ( (X) * (X) )
#define SZ(V) (int )V.size()
#define FORN(i, n) for(i = 0; i < n; i++)
#define FORAB(i, a, b) for(i = a; i <= b; i++)
#define ALL(V) V.Begin(), V.end()
#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))
 
typedef pair<int,int> PII;
typedef pair<double, double> PDD;
typedef vector<int> VI;
typedef vector<PII > VP;
 
#define AIN(A, B, C) assert(IN(A, B, C))
 
//typedef int LL;
typedef long long int LL;
//typedef __int64 LL;
typedef pair<LL,int> PLI;
 
struct Node
{
	int left, right;
	LL A, B;
	int doll;
} nodeSum[9000006], nodeMax[9000006];
 
int nnodeSum, nnodeMax;
 
LL QuerySum(int at, int left, int right, int u)
{
	if(at == 0) return 0;
 
	LL ret = 0;
	int mid = (left + right) / 2;
	if(u <= mid) ret += QuerySum(nodeSum[at].left, left, mid, u);
	else		 ret += QuerySum(nodeSum[at].right, mid + 1, right, u);
	
	ret += nodeSum[at].B + nodeSum[at].A * (u - left);
 
	return ret;
}
 
void UpdateSum(int at, int left, int right, int L, int R, LL a, LL b)
{
	if(L <= left && right <= R)
	{
		nodeSum[at].A += a;
		nodeSum[at].B += b + (left - L) * a;
		return;
	}
 
	int mid = (left + right) / 2;
	
	if(L <= mid)
	{
		if(nodeSum[at].left == 0) nodeSum[at].left = ++nnodeSum;
		UpdateSum(nodeSum[at].left, left, mid, L, R, a, b);
	}
 
	if(R > mid)
	{
		if(nodeSum[at].right == 0) nodeSum[at].right = ++nnodeSum;
		UpdateSum(nodeSum[at].right, mid + 1, right, L, R, a, b);
	}
}
 
LL INF = 1000000000LL;
PLI QueryMax(int at, int left, int right, int u)
{
	if(at == 0) return PLI(-INF, 0);
 
	PLI ret = PLI(-INF, 0), now;
	if(nodeMax[at].doll) 
		ret = PLI(nodeMax[at].B + (u - left) * nodeMax[at].A, 1);
	
	int mid = (left + right) / 2;
	if(u <= mid) 
		now = QueryMax(nodeMax[at].left, left, mid, u);
	else 
		now = QueryMax(nodeMax[at].right, mid + 1, right, u);
	
	if(now.second) ret.second = 1, ret.first = MAX(ret.first, now.first);
 
	return ret;
}
 
void UpdateMax(int at, int left, int right, int L, int R, LL a, LL b)
{
	if(R < left || right < L) return;
 
	if(L <= left && right <= R)
	{
		if(nodeMax[at].doll == 0)
		{
			nodeMax[at].doll = 1;
			nodeMax[at].A = a;
			nodeMax[at].B = b + (left - L) * a;
			return;
		}
 
		if(b + (left - L) * a <= nodeMax[at].B && b + (right - L) * a <= nodeMax[at].B + (right - left) * nodeMax[at].A)
			return;
 
		if(b + (left - L) * a >= nodeMax[at].B && b + (right - L) * a >= nodeMax[at].B + (right - left) * nodeMax[at].A)
		{
			nodeMax[at].A = a;
			nodeMax[at].B = b + (left - L) * a;
			return;
		}
 
		LL a1 = a, b1 = b + (left - L) * a;
		LL a2 = nodeMax[at].A, b2 = nodeMax[at].B;
 
		if(b1 < b2) {swap(a1, a2); swap(b1, b2);}
 
		if(nodeMax[at].left == 0) nodeMax[at].left = ++nnodeMax;
		if(nodeMax[at].right == 0) nodeMax[at].right = ++nnodeMax;
 
		int mid = (left + right) / 2;
		nodeMax[at].doll = 0;
 
		// b1 + (x - left) * a1 >= b2 + (x - left) * a2
		// x * (a2 - a1) <= b1 + left(a2 - a1) - b2
 
		LL x = (b1 - b2 + left * (a2 - a1)) / (a2 - a1);
		UpdateMax(nodeMax[at].left, left, mid, left, x, a1, b1);
		UpdateMax(nodeMax[at].right, mid + 1, right, left, x, a1, b1);
		UpdateMax(nodeMax[at].left, left, mid, x + 1, right, a2, b2 + (x + 1 - left) * a2);
		UpdateMax(nodeMax[at].right, mid + 1, right, x + 1, right, a2, b2 + (x + 1 - left) * a2);
		return;
	}
 
	int mid = (left + right) / 2;
	if(L <= mid)
	{
		if(nodeMax[at].left == 0) nodeMax[at].left = ++nnodeMax;
		UpdateMax(nodeMax[at].left, left, mid, L, R, a, b);
	}
 
	if(R > mid)
	{
		if(nodeMax[at].right == 0) nodeMax[at].right = ++nnodeMax;
		UpdateMax(nodeMax[at].right, mid + 1, right, L, R, a, b);
	}
}
 
int main()
{
	INF *= INF;
 
	int N, M;
	int cmd, u, v, a, b;
	PLI ans1;
	LL ans2;
 
	scanf("%d %d", &N, &M);
	AIN(N, 1, 1000000000);
	AIN(M, 1, 300000);
 
	nnodeMax = nnodeSum = 1;
 
	while(M--)
	{
		scanf("%d", &cmd);
		AIN(cmd, 1, 3);
 
		if(cmd == 1)
		{
			scanf("%d %d %d %d", &u, &v, &a, &b);
			AIN(u, 1, v); AIN(v, u, N);
			AIN(a, -1000000000, 1000000000); AIN(b, -1000000000, 1000000000);
			UpdateMax(1, 1, N, u, v, a, b);
		}
		else if(cmd == 2)
		{
			scanf("%d %d %d %d", &u, &v, &a, &b);
			AIN(u, 1, v); AIN(v, u, N);
			AIN(a, -10000, 10000); AIN(b, -10000, 10000);
			UpdateSum(1, 1, N, u, v, a, b);
		}
		else if(cmd == 3)
		{
			scanf("%d", &u);
			AIN(u, 1, N);
			PLI ans1 = QueryMax(1, 1, N, u);
			LL ans2 = QuerySum(1, 1, N, u);
			if(ans1.second == 0) printf("NA\n");
			else printf("%lld\n", ans1.first + ans2);
		}
	}
 
	return 0;
}