#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>
using namespace std;
typedef long long LL;
const double eps = 1e-8;
const double pi = acos(-1.0);
const LL inf = 2000000001LL;
int T;
LL ans,C,P,X,Y,UY,Z,Q,Yn,t,sd,UnTwo,tp,td,gh;
map<LL,LL> Tree[2];
 
 
LL MOD;
 
int real_rand() {
    return ((rand()%32768 << 15) ^ rand());
}
LL mod_exp(LL a, LL b) {
    LL res = 1;
    while(b > 0) {
        if(b&1)    res = (res*a)%MOD;
        a = (a*a)%MOD;
        b >>= 1;
    }
    return res;
}
 
LL solve(LL n, LL p) {
    LL Q = p - 1, S = 0;
    while(Q%2 == 0) {
        Q >>= 1;
        S++;
    }
    if(S == 1) {return mod_exp(n, (p + 1)/4);}
    LL z = 0;
    while(1) {
        z = 1 + real_rand()%(p-1);
        if(mod_exp(z, (p - 1)/2) != 1)   break;
    }
    LL c = mod_exp(z, Q);
    LL R = mod_exp(n, (Q + 1)/2);
    LL t = mod_exp(n, Q);
    LL M = S, b, i;
    while(1) {
        if(t%p == 1)  break;
        for(i = 1; i < M; ++i) {
            if(mod_exp(t, 1<<i) == 1)    break;
        }
        if (M == i) break;
        b = mod_exp(c, 1<<(M-i-1));
        R = (R*b)%p;
        t = (t*b%p*b)%p;
        c = (b*b)%p;
        M = i;
    }
    return (R%p + p)%p;
}
 
LL BabyGaint(LL Y,LL UY,LL Yn,LL P,int d) {
  if (Tree[d].count(Yn) > 0) return Tree[d][Yn];
  int w;
  for (int i = 1;i <= P/Q+1; i++) {
       Yn = Yn * tp % P;
       w = (i*Q%2) ^ d;
       if (Tree[w].count(Yn) > 0) {
          return i*Q + Tree[w][Yn];
       } 
   }
   return inf;
}
int main() {
    scanf("%d",&T);
    for (int tst = 1;tst <= T; tst++) {
        ans = inf; 
        cin>>C>>P; MOD = P; Q = int(sqrt(P)); Tree[0].clear(); Tree[1].clear();
        UnTwo = ((P + 1) / 2) % P;
        X = solve(5,P);
        if ((X & 1)  == 0) X = P - X;
        Y = ((1 + X) * UnTwo)% P;
        UY = ((X - 1) * UnTwo + P) % P;
        Z = (C * X) % P;
        
        td = 1; tp = 1;
        for (int i = 0;i < Q; i++) {
            if (Tree[i%2].count(td) == 0) Tree[i%2][td] = i;
            td = td * Y % P;
            tp = tp * UY % P;
        } 
        gh = (Z*Z+4)%P;
        if(mod_exp(gh,(P-1)/2) != P-1) {
           t = solve(gh,P);
           Yn = ((Z + t) * UnTwo + P) % P;
           sd =  BabyGaint(Y,UY,Yn,P,0);
           ans = min(ans,sd);
           Yn = ((Z - t) * UnTwo % P + P) % P;
           sd =  BabyGaint(Y,UY,Yn,P,0);
           ans = min(ans,sd);
        }
        
        gh =(Z*Z%P-4%P+P)%P;
        if(mod_exp(gh,(P-1)/2) != P-1) {
           t = solve(gh,P);
           Yn = ((Z + t) * UnTwo + P) % P;
           sd =  BabyGaint(Y,UY,Yn,P,1);
           ans = min(ans,sd);
           Yn = ((Z - t) * UnTwo % P + P) % P;
           sd =  BabyGaint(Y,UY,Yn,P,1);
           ans = min(ans,sd);
        }
        if (ans == inf) printf("-1\n"); else cout<<ans<<endl;
    }
    return 0;
}
