#include<stdio.h>
#include<iostream>
#include<vector>
#include<string.h>
#include<algorithm>
#include<deque>
#include<map>
#include<set>
#include<stdlib.h>
#include<math.h>
#include<queue>
#include<stack>
#include<functional>
using namespace std;
#define LL long long
#define si(x) scanf("%d",&x)
#define sc(x) scanf("%c",&x)
#define sl(x) scanf("%lld",&x)
#define all(x) x.begin(),x.end()
#define compress(x) {sort(all(x));(x).resize(unique(all(x))-(x).begin());}
template<class T> inline void umax(T &a,T b){if(a<b) a = b ;}
typedef pair<int, int> ii;
typedef pair<LL, LL> PII;
typedef pair<ii, int> iii;
typedef pair<ii, ii> iiii;
#define vl vector<>
#define vi vector<int>
#define vii vector<ii>
#define vvl vector< vl >
#define vvi vector< vi >
#define vvii vector< vii >
#define sz size()
#define pb push_back
#define F first
#define S second
#define mem(x,y) memset(x,y,sizeof(x))
#define rep(i,a,b) for(int i=(a);i<(b);i++)
#define repv(i,b,a) for(int i=(b);i>=(a);i--)
#define mod2 1000000007
#define pb push_back
#define mp make_pair
#define PDD pair<LL, LL>
#define LLD long double
#define trace(x)  cout << x <<endl;
#define trace1(x , y) cout << x <<" "<< y << endl;
 
const int maxn = 5000 + 2;
const int INF  = 2000000001 ;
//const LL INF = 0x0123456789ABCDEFLL;
LL pow_mod(LL x, LL n, LL p) {
  if (n == 0) return 1;
  if (n & 1)
    return (pow_mod(x, n-1, p) * x) % p;
  x = pow_mod(x, n/2, p);
  return (x * x) % p;
}
 
/* Takes as input an odd prime p and n < p and returns r
 * such that r * r = n [mod p]. */
LL tonelli_shanks(LL n, LL p) {
  LL s = 0;
  LL q = p - 1;
  while ((q & 1) == 0) { q /= 2; ++s; }
  if (s == 1) {
    LL r = pow_mod(n, (p+1)/4, p);
    if ((r * r) % p == n) return r;
    return 0;
  }
  // Find the first quadratic non-residue z by brute-force search
  LL z = 1;
  while (pow_mod(++z, (p-1)/2, p) != p - 1);
  LL c = pow_mod(z, q, p);
  LL r = pow_mod(n, (q+1)/2, p);
  LL t = pow_mod(n, q, p);
  LL m = s;
  while (t != 1) {
    LL tt = t;
    LL i = 0;
    while (tt != 1) {
      tt = (tt * tt) % p;
      ++i;
      if (i == m) return 0;
    }
    LL b = pow_mod(c, pow_mod(2, m-i-1, p-1), p);
    LL b2 = (b * b) % p;
    r = (r * b) % p;
    t = (t * b2) % p;
    c = b2;
    m = i;
  }
  if ((r * r) % p == n) return r;
  return 0;
}
LL modpow(LL base, LL exponent,LL modulus){
    if(base==0&&exponent==0)return 0;
    LL result = 1;
    while (exponent > 0){
        if (exponent % 2 == 1)
            result = (result * base) % modulus;
        exponent = exponent >> 1;
        base = (base * base) % modulus;
    }
    return result;
}
LL mod1(LL a, LL b) {
  return ((a%b)+b)%b;
}
LL extended_euclid(LL a, LL b, LL &x, LL &y) {   
  LL xx = y = 0;
  LL yy = x = 1;
  while (b) {
    LL q = a/b;
    LL t = b; b = a%b; a = t;
    t = xx; xx = x-q*xx; x = t;
    t = yy; yy = y-q*yy; y = t;
  }
  return a;
}
LL mod_inverse(LL a, LL n) {
  LL x, y;
  LL d = extended_euclid(a, n, x, y);
  if (d > 1) return -1;
  return mod1(x,n);
}
 
LL solve(LL a, LL b , LL m){  // returns x such that a^x is congruent to b mod m 
     LL X = sqrt(m+1) , val , tmp;
     map<LL , LL> p1 , idx;
     val  = 1;
     for(int i=0;i<=X+1;i++){
         p1[val] = 1;
         idx[val] = i;
         val  = (val * a)%m;
     }
     LL inv  = mod_inverse(modpow(a , X , m) , m);
     LL mul =  b;
     for(int i=0;i<=X+1;i++){
        if(p1[mul] > 0){
      //  if(i >0 || idx[mul] > 0)
        return  X * i + idx[mul];
        }
        mul = (mul * inv)%m;
     }
     return INF;
}
LL power(LL p,LL n,LL mod)
{
  LL ans=1;
  for(;n;n>>=1,p=p*p%mod)
    if(n&1)
      ans=ans*p%mod;
  return ans;
}
struct Digit
{
  LL a,b,w;
};
Digit mul(const Digit &a,const Digit &b,LL mod)
{
  Digit c;
  c.a=(a.a*b.a+a.b*b.b%mod*b.w)%mod;
  c.b=(a.b*b.a+a.a*b.b)%mod;
  c.w=a.w;
  return c;
}
LL power(LL a,LL w,LL n,LL mod)
{
  Digit ans,p;
  ans.a=1,ans.b=0,ans.w=w;
  p.a=a,p.b=1,p.w=w;
  for(;n;n>>=1,p=mul(p,p,mod))
    if(n&1)
      ans=mul(ans,p,mod);
  return ans.a;
}
LL Anti(LL p,LL mod)
{
  return power(p,mod-2,mod);
}
LL sqrt(LL n,LL p)
{
  if(n==0)
    return 0;
  LL a,w;
  for(a=1;;++a)
  {
    w=(a*a-n+p)%p;
    if(power(w,(p-1)/2,p)==p-1)
      break;
  }
  return power(a,w,(p+1)/2,p);
}
LL Log(LL x,LL a,LL p)
{
  static pair<int,int> sol[maxn];
  int limit=sqrt(p);
  LL now=1;
  for(int i=0;i<=limit;++i)
  {
    sol[i]=make_pair(now,i);
    now=now*x%p;
  }
  LL anti=Anti(sol[limit].first,p);
  sort(sol,sol+limit+1);
  for(int i=0;i<=limit+5;++i)
  {
    pair<int,int> q=make_pair(a,-1);
    int id=lower_bound(sol,sol+limit+1,q)-sol;
    if(sol[id].first==a)
      return i*limit+sol[id].second;
    a=a*anti%p;
  }
  return 2000000000;  
}
inline void solve(void){
            int t;
            si(t);
            while(t--){
                LL c , p , a1 , res1 = INF,res2 = INF,res3 = INF,res4 = INF , ret;
                sl(c);sl(p);
                if(c==0){
                  printf("%lld\n" ,c);
                  continue;
                }
                LL x = tonelli_shanks(5, p);
                LL y = (x + 1)%p;
                y = (y * modpow(2 , p-2, p))%p;
                LL z = (c * x)%p;
                LL ans = INF , delta;
                delta = ((z*z - 4)%p + p)%p;  // n is odd
                if(power(delta,(p-1)/2,p)==p-1)
                   res1=INF , res2 = INF;
                 else{ 
                  ret = tonelli_shanks(delta,p);
                 a1 = (z + ret)%p;
                 a1 = (a1 * modpow(2 , p-2 , p))%p;
                 a1 = (a1 * modpow(y , p-2 , p))%p;
                 res1 = solve((y*y)%p , a1 , p)*2+1;
                 a1 = ((z - ret)%p + p)%p;
                 a1 = (a1 * modpow(2 , p-2 , p))%p;
                 a1 = (a1 * modpow(y, p-2 , p))%p;
                 res2 = solve((y*y)%p  , a1 , p)*2+1;
                  }
                 delta = ((z*z + 4)%p + p)%p; 
                 if(power(delta,(p-1)/2,p)==p-1)
                   res3=INF , res4 = INF;
                 else{ 
                  ret = tonelli_shanks(delta , p);
                 a1 = ((z - ret)%p + p)%p;
                 a1 = (a1 * modpow(2 , p-2 , p))%p;
                 res3 = 2*solve((y*y)%p  , a1 , p);
                 a1 = ((z + ret)%p + p)%p;
                 a1 = (a1 * modpow(2 , p-2 , p))%p;
                 res4 = 2*solve((y*y)%p  , a1 , p);
                }
                 ans = min(min(res1 , res2) , min(res3 , res4));
                 if(ans >= 2000000000) ans = -1;
                 printf("%lld\n", ans);
            }
 
}
/*void init() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
}*/
int main(int argc, const char * argv[]){
    //freopen("positive.in","r",stdin);
    //freopen("positive.out","w",stdout);
   // init();
    solve();
    return 0;
} 