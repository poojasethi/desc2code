#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

#define REP0(i, n) for (int i = 0; i < n; i++)
#define REP1(i, n) for (int i = 1; i <= n; i++)
#define REP(i, l, r) for (int i = l; i <= r; i++)
#define RP(i, r, l) for (int i = r; i >= l; i--)
#define FORE(i, x) for (int i = fi[x]; i != -1; i = e[i].n)

#define MAX_N 51000
#define MAX_M 210000
#define A first
#define B second
#define MP make_pair

typedef long long m64;
typedef long double ld;
typedef pair < int, int > PT;
const ld PI = acos(-1);
struct nodeE { int t, n; } e[MAX_N << 1];
struct node
{
       ld x, y;
       inline node operator + (const node& b) { return (node) { x + b.x, y + b.y }; }
       inline node operator - (const node& b) { return (node) { x - b.x, y - b.y }; }
       inline node operator * (const node& b)
       { return (node) { x * b.x - y * b.y, x * b.y + y * b.x }; }
       inline node operator * (const ld& b) { return (node) { x * b, y * b }; }
       inline node operator / (const ld& b) { return (node) { x / b, y / b }; }
       inline void operator *= (const node& b)
       { ld _x = x * b.x - y * b.y, _y = x * b.y + y * b.x; x = _x, y = _y; }
       inline void operator = (const int& b) { x = b, y = 0; } 
} a[MAX_M], b[MAX_M], c[MAX_M], gi[50], zero;
int fi[MAX_N], sz[MAX_N], pi[MAX_N], trans[MAX_M], d1[MAX_N], d2[MAX_N];
bool used[MAX_N], np[MAX_N];
int n, tot, pn; m64 ans, all;

inline void insert(int x, int y) { e[++tot] = (nodeE) { y, fi[x] }, fi[x] = tot; }
inline int getn(int x) { int t = 1; while (t <= x) t <<= 1; return t; }
void init(void)
{
     REP(i, 2, n)
     {
        if (!np[i]) pi[++pn] = i;
        for (int j = 1; j <= pn && pi[j] * i <= n; j++)
        {
            np[i * pi[j]] = true;
            if (i % pi[j] == 0) break;
        }
     }
}
inline int rev(int x, int n)
{
       static int c[30], len; len = 0;
       while ((1 << len) < n) c[len++] = x & 1, x >>= 1;
       REP0(i, len) x |= c[i] << (len - i - 1);
       return x;
}

int num, trt, tss;
void DFS_rt(int x, int fa = -1)
{
     sz[x] = 1; int t = 0;
     FORE(i, x) if (e[i].t != fa && !used[e[i].t])
     { DFS_rt(e[i].t, x), sz[x] += sz[e[i].t]; if (t < sz[e[i].t]) t = sz[e[i].t]; }
     if (num - sz[x] > t) t = num - sz[x];
     if (t < tss) tss = t, trt = x;
}

int DFS_dep(int x, int fa = -1)
{
    int t = 0;
    FORE(i, x) if (e[i].t != fa && !used[e[i].t]) t = max(t, DFS_dep(e[i].t, x));
    return t + 1;
}

void Getd(int x, int d = 1, int fa = -1)
{ d2[d]++; FORE(i, x) if (e[i].t != fa && !used[e[i].t]) Getd(e[i].t, d + 1, x); }

void DFT(node *a, node *out, int N, int op = 1)
{
     REP0(i, N) out[i] = a[trans[i]];
     for (int i = 2, t = 1; i <= N; i <<= 1, t++)
     { 
         node wn = (node) { gi[t].x, op * gi[t].y };
         for (int j = 0; j < N; j += i)
         {
             node w, even, odd; w = 1;
             REP(k, j, j + (i >> 1) - 1)
             {
                even = out[k], odd = out[k + (i >> 1)] * w, w *= wn;
                out[k] = even + odd, out[k + (i >> 1)] = even - odd;
             }
         }
     }
}

void FFT(int n1, int n2)
{
     int N = getn(n1 + n2); REP0(i, N) trans[i] = rev(i, N);
     
    /* printf ("FFT Of a * b:\n");
     REP(i, 0, n1) printf ("%d ", d1[i]); puts("");
     REP(i, 0, n2) printf ("%d ", d2[i]); puts("");
     printf ("%d\n", N);
     REP0(i, N) printf ("%d ", trans[i]); puts("");
     puts("-----------------");
     */
     REP(i, 0, n1) a[i] = d1[i]; fill(a + n1 + 1, a + N, zero);
     REP(i, 0, n2) b[i] = d2[i]; fill(b + n2 + 1, b + N, zero);
     DFT(a, c, N), DFT(b, a, N); REP0(i, N) a[i] = (a[i] * c[i]) / N; DFT(a, c, N, -1);
     REP1(i, pn) if (pi[i] <= n1 + n2) ans += (m64)(c[pi[i]].x + 0.5); else break;
}

PT id[MAX_N];
void DFS(int x)
{
     tss = num = sz[x], trt = -1, DFS_rt(x), used[x = trt] = true; int len = 0, l1 = 0;
     FORE(i, x) if (!used[e[i].t]) id[++len] = MP(DFS_dep(e[i].t), e[i].t);
     sort(id + 1, id + len + 1), d1[0] = 1, d2[0] = 0;
     /*printf ("Solve At %d\n", x);
     REP1(i, len) printf ("[%d %d]\n", id[i].A, id[i].B);
     puts("");*/
     REP1(i, len)
     {
         int l2 = id[i].A; fill(d2, d2 + l2 + 1, 0), Getd(id[i].B), FFT(l1, l2);
         REP1(i, l1) d1[i] += d2[i]; copy(d2 + l1 + 1, d2 + l2 + 1, d1 + l1 + 1), l1 = l2;
     }
     //printf ("In the End %lld\n--------------------------------\n", ans);
     
     FORE(i, x) if (!used[e[i].t]) DFS(e[i].t);
}

int main(void)
{
    REP0(i, 30) gi[i] = (node) { cos(-2 * PI / (1 << i)), sin(-2 * PI / (1 << i)) };
    scanf ("%d", &n), fill(fi, fi + n + 1, -1), tot = 1, init(), zero = (node) { 0, 0 };
    
    //REP1(i, pn) printf ("%d ", pi[i]); puts("");
    
    REP1(i, n - 1) { int x, y; scanf ("%d%d", &x, &y), insert(x, y), insert(y, x); }
    sz[1] = n, DFS(1), all = n * (n - 1LL) >> 1, printf ("%.10lf", ((double) ans) / all);
    return 0;
}
