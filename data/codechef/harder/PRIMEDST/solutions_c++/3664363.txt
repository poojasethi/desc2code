#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<complex>
using namespace std;

#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define per(i, s, t) for (int i = (s); i >= (t); --i)
#define REP(i, n) rep(i, 1, n)
#define PER(i, n) per(i, n, 1)
#define Rep(i, n) rep(i, 0, n - 1)
#define mk make_pair
#define X first
#define Y second
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;
struct CLX{
    LD x, y;
    CLX(LD _x, LD _y) {x = _x; y = _y;}
    CLX() {}
    CLX operator + (const CLX &b) const{
        return CLX(x + b.x, y + b.y);
    }
    CLX operator - (const CLX &b) const{
        return CLX(x - b.x, y - b.y);
    }
    CLX operator * (const CLX &b) const{
        return CLX(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
const int MAX_N = 111111;
int g[MAX_N], nxt[MAX_N], c[MAX_N], ok[MAX_N], nm;
int s[MAX_N], sc[MAX_N], ntot, root;
int cnta[MAX_N], cntb[MAX_N], na, nb;
CLX A[MAX_N << 2], B[MAX_N << 2]; int N;
int n;
LD pi = M_PI;
int ans[MAX_N];

void addedge(int x, int y){
     g[nm] = y; nxt[nm] = c[x]; c[x] = nm; ok[nm] = 1; nm++;
}

void dfs(int i, int p){
     s[i] = sc[i] = 0; s[i]++;
     for (int k = c[i]; ~k; k = nxt[k]){
         int j = g[k];
         if (j != p && ok[k]){
            dfs(j, i);
            s[i] += s[j];
            sc[i] = max(sc[i], s[j]);
         }
     }
     sc[i] = max(sc[i], ntot - s[i]);
     if (sc[i] < sc[root]) root = i;
}

void dfs2(int i, int p, int d){
     cntb[d]++;
     nb = max(nb, d);
     for (int k = c[i]; ~k; k = nxt[k]){
         int j = g[k];
         if (j == p || !ok[k]) continue;
         dfs2(j, i, d + 1);
     }
}

int rev(int x, int N){
    int tot = 0, res = 0;
    for (int i = N >> 1; i; i >>= 1)
        res |= ((x & i) > 0) << (tot++);
    return res;
}

void DFT(CLX A[], int N, int fh){
     REP(i, N - 2){
        int j = rev(i, N);
        if (i < j) swap(A[i], A[j]);
     }
     CLX unit;
     for (int m = 1; m < N; m <<= 1){
         int m2 = m << 1;
         LD ang = 2 * pi * fh / m2;
         unit = CLX(cos(ang), sin(ang));
         for (int S = 0; S < N; S += m2){
             CLX r = CLX(1, 0);
             Rep(i, m){
                CLX y0 = A[S + i], y1 = A[S + i + m];
                A[S + i] = y0 + r * y1;
                A[S + i + m] = y0 - r * y1;
                r = r * unit;
             }
         }
     }
}

int TIME, TIM;

void RIN(){
     int n = max(na, nb);
     ++n;
     N = 1;
     while (N < n) N <<= 1;
     N <<= 1;
     //cout << N << endl;
     TIME += N * (log(N + 1e-9) / log(2.0));
     Rep(i, N) A[i] = B[i] = CLX(0, 0);
     Rep(i, na + 1) A[i] = CLX(cnta[i], 0);//, printf("A %d\n", cnta[i]);
     Rep(i, nb + 1) B[i] = CLX(cntb[i], 0);//, printf("B %d\n", cntb[i]);
     DFT(A, N, 1);
     DFT(B, N, 1);
     Rep(i, N) A[i] = A[i] * B[i];
     DFT(A, N, -1);
     Rep(i, na + nb + 3) ans[i] += int(A[i].x / N + 1e-2);
}

PII p[111111]; int pn;

int dfs3(int i, int p){
    int res = 1;
    for (int k = c[i]; ~k; k = nxt[k]){
        int j = g[k];
        if (ok[k] && j != p)
           res = max(res, dfs3(j, i) + 1);
    }
    return res;
}



void Divide(int x){
     pn = 0;
     for (int k = c[x]; ~k; k = nxt[k]){
         int j = g[k];
         if (!ok[k]) continue;
         p[++pn] = mk(dfs3(j, x), j);
     }
     //sort(p + 1, p + 1 + pn);
     na = 0;
     dfs(x, -1);
     TIM += s[x];
     cnta[0] = 1;
     REP(i, pn){
         int y = p[i].Y;
         nb = 0;
         dfs2(y, x, 1);
         RIN();
         na = max(na, nb);
         REP(i, nb) cnta[i] += cntb[i], cntb[i] = 0;
     }
     REP(i, na) cnta[i] = 0;
     for (int k = c[x]; ~k; k = nxt[k]){
         if (!ok[k]) continue;
         int y = g[k];
         ok[k ^ 1] = 0;
         dfs(y, -1);
         ntot = s[y];
         //cout << x << " " << y << " " << s[y] << endl;
         root = 0;
         dfs(y, -1);
         //printf("- %d %d %d\n", x, root, sc[root]);
         Divide(root);
     }
}

int usd[MAX_N];

int main(){
    //freopen("PRIMEDST.in", "r", stdin);
    //freopen("PRIMEDST.out", "w", stdout);
    scanf("%d", &n);
    memset(c, -1, sizeof c);
    REP(i, n - 1){
       int x, y;
       scanf("%d%d", &x, &y);
       addedge(x, y);
       addedge(y, x);
    }
    sc[0] = n;
    ntot = n;
    root = 0;
    dfs(1, -1);
    Divide(root);
    int anstot = 0;
    rep(i, 2, n){
       if (!usd[i]){
          anstot += ans[i];
          for (int j = i; j <= n; j += i)
              usd[j] = 1;
       }
    }
    //REP(i, n) printf("%d\n", ans[i]);
    printf("%.10f\n", anstot * 2.0 / n / (n - 1));
    //cout << TIM << endl;
    //system("pause");
}
