#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <complex>
using namespace std;
typedef long long ll;
int n, m, i, j, k, x, z;

int getint() {
	int ret = 0;
	char ch = getchar();
	while ( ch < '0' || ch > '9' ) ch = getchar();
	while ( ch >= '0' && ch <= '9' ) {
		ret = ret * 10 + ch - '0';
		ch = getchar();
	}
	return ret;
}

int prime[ 50010 ], ok[ 50010 ], tot;
void calprime() {
	ok[ 1 ] = 1;
	for ( int i = 2; i <= 50000; i++ ) {
		if ( !ok[ i ] ) prime[ ++tot ] = i;
		for ( int j = 1; i * prime[ j ] <= 50000; j++ ) {
			ok[ i * prime[ j ] ] = 1;
			if ( i % prime[ j ] == 0 ) break;
		}
	}
}

const double pi = acos( -1.0 );
struct Complex {
	double real, imag;
	Complex (){}
	Complex( double real, double imag ) : real( real ), imag( imag ) {}
} A[ 150010 ], y[ 150010 ];

Complex operator + ( const Complex &A, const Complex &B ) { return Complex( A.real + B.real, A.imag + B.imag ); }
Complex operator - ( const Complex &A, const Complex &B ) { return Complex( A.real - B.real, A.imag - B.imag ); }
Complex operator * ( const Complex &A, const Complex &B ) { return Complex( A.real * B.real - A.imag * B.imag, A.real * B.imag + A.imag * B.real ); }
Complex operator / ( const Complex &A, double d ) { return Complex( A.real / d, A.imag / d ); }
int N, _N, p;

void FFT( Complex *x, int L, int k, int flag ) {
	if ( k == 0 ) return;
	int n = 1 << k;
	int l = L, r = L + n / 2;

	for ( int i = 0; i < n; i += 2 ) {
		y[ l++ ] = x[ L + i     ];
		y[ r++ ] = x[ L + i + 1 ];
	}
	for ( int i = 0; i < n; i++ ) x[ L + i ] = y[ L + i ];

	FFT( x, L, k - 1, flag ), FFT( x, L + n / 2, k - 1, flag );
	Complex omega = Complex( 1, 0 );
	Complex _omega = flag ? Complex( cos( -2 * pi / n ), sin( -2 * pi / n ) ) : Complex( cos( 2 * pi / n ), sin( 2 * pi / n ) );

	for ( int i = 0; i < n / 2; i++ ) {
		Complex q_i = x[ L + i ], p_i = x[ L + n / 2 + i ];
		x[ L + i         ] = q_i + omega * p_i;
		x[ L + i + n / 2 ] = q_i - omega * p_i;
		omega = omega * _omega;
	}
}

struct Edge {
	int to;
	Edge *next;
} *G[ 50010 ], edges[ 2 * 50010 ];
int etop;

void AddEdge( int from, int to ) {
	edges[ etop ] = ( Edge ){ to, G[ from ] };
	G[ from ] = &edges[ etop++ ];
	edges[ etop ] = ( Edge ){ from, G[ to ] };
	G[ to ] = &edges[ etop++ ];
}

typedef int arr32[ 50010 ];
arr32 f, size, dis, Q, done, sum;
int l, r, g, S, mx;

void find_g( int x, int fa ) {
	size[ x ] = 1, f[ x ] = 0;

	for ( Edge *e = G[ x ]; e; e = e->next ) {
		if ( e->to == fa || done[ e->to ] ) continue;
		find_g( e->to, x );
		size[ x ] += size[ e->to ];
		f[ x ] = max( f[ x ], size[ e->to ] );
	}

	f[ x ] = max( f[ x ], S - f[ x ] );
	if ( f[ x ] < f[ g ] ) g = x;
}

void Get_msg( int x, int fa ) {
	Q[ ++r ] = x;
	sum[ dis[ x ] ]++;
	mx = max( mx, dis[ x ] );

	for ( Edge *e = G[ x ]; e; e = e->next ) {
		if ( e->to == fa || done[ e->to ] ) continue;
		dis[ e->to ] = dis[ x ] + 1;
		Get_msg( e->to, x );
	}
}

ll ret[ 50010 ];

ll Count( int x, int w ) {
	dis[ x ] = w, mx = r = 0;
	memset( sum, 0, sizeof sum );
	Get_msg( x, 0 );
	N = 1, p = 0;
	while ( N < 2 * mx + 2 ) N <<= 1, p++;
	for ( int i = 0; i <= mx; i++ ) A[ i ] = Complex( sum[ i ], 0 );
	for ( int i = mx + 1; i < N; i++ ) A[ i ] = Complex( 0, 0 );
	FFT( A, 0, p, 0 );
	for ( int i = 0; i < N; i++ ) A[ i ] = A[ i ] * A[ i ];
	FFT( A, 0, p, 1 );

	ll cnt = 0;
	for ( int i = 0; i <= min( mx * 2, n ); i++ ) ret[ i ] = ll( A[ i ].real / N + 0.5 );
	ret[ 2 ] -= sum[ 1 ];
	for ( int i = 1; i <= min( mx * 2, n ); i++ ) cnt += ( !ok[ i ] ) * ret[ i ];
	return cnt;
}

ll ans;

void solve( int x ) {
	ans += Count( x, 0 );
	done[ x ] = 1;

	for ( Edge *e = G[ x ]; e; e = e->next ) {
		if ( done[ e->to ] ) continue;
		ans -= Count( e->to, 1 );
		f[ g = 0 ] = S = size[ e->to ];
		find_g( e->to, x );
		solve( g );
	}
}

int main()
{
	calprime();
	n = getint();
	for ( i = 1; i < n; i++ ) AddEdge( getint(), getint() );

	f[ g = 0 ] = S = n;
	find_g( 1, 0 );
	solve( g );
	printf( "%.8lf", ( 1.0 * ans ) / ( 1ll * n * ( n - 1 ) ) );
	return 0;
}
