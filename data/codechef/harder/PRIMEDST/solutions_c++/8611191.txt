#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define clr(X,a) memset((X), (a), sizeof((X)))
#define s(a) scanf("%d", &a)
#define ps(a) printf("%d ", a)
#define pn(a) printf("%d\n", a)
#define rep(i,n) for(i = 0; i < (n); i++)
#define repr(i,a,b) for(i = (a); i <= (b); i++)
#define M_PI 3.14159265358979323846

int N,i,j,T,subtree[51000],nc,lp[51000],pr[20000],primes,mx,tot[102000],cdepth[51000];
int q[51000],cur,top;
vector<vector<int> > G;
bool vis[51000];
typedef complex<double> base;
base a[102000], b[102000];
void dfs(int v, int p);
void dfs2(int v, int p, int d, vector<int> &tds);
int find_centroid(int v, int sz);
inline void fft (vector<base> &a, int n, int invert);
void multiply(const vector<int> &a, const vector<int> &b, vector<int> &c);

int main()
{
    lp[0] = lp[1] = -1;
    for(i = 2; i <= 51000; i++)
    {
        if(lp[i] == 0)
        {
            lp[i] = i;
            pr[primes++] = i;
        }
        for(j = 0; j < primes && pr[j] <= lp[i] && i * pr[j] <= 51000; j++)
            lp[i * pr[j]] = pr[j];
    }
    s(N);
    G.resize(N + 1);
    rep(i, N-1)
    {
        int a, b; s(a); s(b);
        G[a].pb(b); G[b].pb(a);
    }
    q[0] = 1;
    cur = 0; top = 1;
    long long ans = 0;
    while(cur < top)
    {
        int v = q[cur++];
        dfs(v, -1);
        nc = find_centroid(v, subtree[v]);
        
        vector<int> ds;
        ds.push_back(0);
        for (int j = 0; j < G[nc].size(); j++) 
        {
            if (vis[G[nc][j]]) continue;
            vector<int> tds;
            dfs2(G[nc][j], nc, 1, tds);
            int m1 = *max_element(ds.begin(), ds.end());
            int m2 = *max_element(tds.begin(), tds.end());
            vector<int> a(m1+m2+1,0);
            vector<int> b(m1+m2+1,0);
            vector<int> c(m1+m2+1,0);
            for(int i=0;i<ds.size();i++)  a[ds[i]]++;
            for(int i=0;i<tds.size();i++) b[tds[i]]++;
            multiply(a, b, c);
            for(int i = 2; i < c.size(); i++)
                if(lp[i] == i) ans += c[i];
            ds.insert(ds.end(), tds.begin(), tds.end());
        }   
            
        vis[nc] = true;
        vector<int>::iterator it = G[nc].begin();
        for(int n2 = *it; it != G[nc].end(); it++, n2 = *it) 
            if(!vis[n2])
                q[top++] = n2;
    }   
    long double fans = ans;
    fans /= N; fans /= N-1; fans *= 2;
    printf("%.9Lf\n", fans);
    
    return 0;
}

void dfs(int v, int p)
{
    subtree[v] = 1;
    vector<int>::iterator it = G[v].begin();
    for(int n = *it; it != G[v].end(); it++, n = *it) if(n != p && !vis[n])
    {
        dfs(n, v);
        subtree[v] += subtree[n];
    }
}

int find_centroid(int v, int sz)
{
    int branch = v;
    vector<int>::iterator it = G[v].begin();
    for(int n = *it; it != G[v].end(); it++, n = *it) if(!vis[n] && subtree[n] > sz/2)
    {
        branch = n;
        break;
    }
    if(branch == v) return v;
    subtree[v] -= subtree[branch];
    subtree[branch] += subtree[v];
    return find_centroid(branch, sz);
}

void dfs2(int v, int p, int d, vector<int> &tds)
{
    tds.pb(d);
    vector<int>::iterator it = G[v].begin();
    for(int n = *it; it != G[v].end(); it++, n = *it) 
        if(n != p && !vis[n]) 
            dfs2(n, v, d + 1, tds);
}

void multiply (const vector<int> & a, const vector<int> & b, vector<int> & res) 
{
    vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end());
	size_t n = 1;
	while (n < max (a.size(), b.size()))  n <<= 1;
	n <<= 1;
	fa.resize (n),  fb.resize (n);
    
	fft (fa, n, 0),  fft (fb, n, 0);
	for (size_t i=0; i<n; ++i)
		fa[i] *= fb[i];
	fft (fa, n, 1);
 
	res.resize (n);
	for (size_t i=0; i<n; ++i)
		res[i] = int (fa[i].real() + 0.5);
}

inline void fft (vector<base> &a, int n, int invert)
{
	for (int i=1, j=0; i<n; ++i)
	{
		int bit = (n >> 1);
		for (; j>=bit; bit>>=1)
			j -= bit;
		j += bit;
		if (i < j)
			swap (a[i], a[j]);
	}

	for (int len=2; len<=n; len<<=1)
	{
		double ang = 2*M_PI/len * (invert == 1 ? -1 : 1);
		base wlen (cos(ang), sin(ang));
		for (int i=0; i<n; i+=len) {
			base w (1);
			for (int j=0; j<len/2; ++j) {
				base u = a[i+j],  v = a[i+j+len/2] * w;
				a[i+j] = u + v;
				a[i+j+len/2] = u - v;
				w *= wlen;
			}
		}
	}
	if (invert)
		for (int i=0; i<n; ++i)
			a[i] /= n;
}
