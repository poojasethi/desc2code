#include <iostream>
#include <cstdio>
#include <string.h>
#include <algorithm>
#include <cmath>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <map>


#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define abs(x) ((x)>=0?(x):-(x))
#define i64 long long
#define u32 unsigned int
#define u64 unsigned long long
#define clr(x,y) memset(x,y,sizeof(x))
#define CLR(x) x.clear()
#define ph(x) push(x)
#define pb(x) push_back(x)
#define Len(x) x.length()
#define SZ(x) x.size()
#define PI acos(-1.0)
#define sqr(x) ((x)*(x))
#define MP(x,y) make_pair(x,y)

#define FOR0(i,x) for(i=0;i<x;i++)
#define FOR1(i,x) for(i=1;i<=x;i++)
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define FORL0(i,a) for(i=a;i>=0;i--)
#define FORL1(i,a) for(i=a;i>=1;i--)
#define FORL(i,a,b)for(i=a;i>=b;i--)


#define rush() int CC;for(scanf("%d",&CC);CC--;)
#define Rush(n)  while(scanf("%d",&n)!=-1)
using namespace std;


void RD(int &x){scanf("%d",&x);}
void RD(i64 &x){scanf("%lld",&x);}
void RD(u64 &x){scanf("%I64u",&x);}
void RD(u32 &x){scanf("%u",&x);}
void RD(double &x){scanf("%lf",&x);}
void RD(int &x,int &y){scanf("%d%d",&x,&y);}
void RD(i64 &x,i64 &y){scanf("%I64d%I64d",&x,&y);}
void RD(u32 &x,u32 &y){scanf("%u%u",&x,&y);}
void RD(double &x,double &y){scanf("%lf%lf",&x,&y);}
void RD(int &x,int &y,int &z){scanf("%d%d%d",&x,&y,&z);}
void RD(i64 &x,i64 &y,i64 &z){scanf("%I64d%I64d%I64d",&x,&y,&z);}
void RD(u32 &x,u32 &y,u32 &z){scanf("%u%u%u",&x,&y,&z);}
void RD(double &x,double &y,double &z){scanf("%lf%lf%lf",&x,&y,&z);}
void RD(char &x){x=getchar();}
void RD(char *s){scanf("%s",s);}
void RD(string &s){cin>>s;}


void PR(int x) {printf("%d\n",x);}
void PR(int x,int y) {printf("%d %d\n",x,y);}
void PR(i64 x) {printf("%lld\n",x);}
void PR(u32 x) {printf("%u\n",x);}
void PR(u64 x) {printf("%I64u\n",x);}
void PR(double x) {printf("%.2lf\n",x);}
void PR(char x) {printf("%c\n",x);}
void PR(char *x) {printf("%s\n",x);}
void PR(string x) {cout<<x<<endl;}

void upMin(int &x,int y) {if(x>y) x=y;}
void upMin(i64 &x,i64 y) {if(x>y) x=y;}
void upMin(double &x,double y) {if(x>y) x=y;}
void upMax(int &x,int y) {if(x<y) x=y;}
void upMax(i64 &x,i64 y) {if(x<y) x=y;}
void upMax(double &x,double y) {if(x<y) x=y;}


int sgn(double x)
{
    if(x>1e-10) return 1;
    if(x<-1e-10) return -1;
    return 0;
}

const int mod=12345678;
const i64 inf=((i64)1)<<60;
const double dinf=1e50;
const int INF=2000000005;
const int N=100005;

struct node
{
    double x,y;

    node(double _x=0.0,double _y=0.0)
    {
        x=_x;
        y=_y;
    }

    node operator+(node a)
    {
        return node(x+a.x,y+a.y);
    }

    node operator-(node a)
    {
        return node(x-a.x,y-a.y);
    }

    node operator*(node a)
    {
        return node(x*a.x-y*a.y,x*a.y+y*a.x);
    }
};

node A[N];
int L;


int reverse(int x)
{
    int ans=0,i;
    FOR0(i,L) if(x&(1<<i)) ans|=1<<(L-1-i);
    return ans;
}


void bitReverseCopy(node a[],int n)
{
    int i;
    FOR0(i,n) A[i]=a[i];
    FOR0(i,n)
    {
        a[reverse(i)]=A[i];
    }
}


void fft(node a[],int n,int on)
{
    bitReverseCopy(a,n);
    int len,i,j,k;
    node x,y,u,t;
    for(len=2;len<=n;len<<=1)
    {
        x=node(cos(-on*2*PI/len),sin(-on*2*PI/len));
        for(j=0;j<n;j+=len)
        {
            y=node(1,0);
            for(k=j;k<j+len/2;k++)
            {
                u=a[k];
                t=y*a[k+len/2];
                a[k]=u+t;
                a[k+len/2]=u-t;
                y=y*x;
            }
        }
    }
    if(on==-1)
    {
        FOR0(i,n) a[i].x/=n;
    }
}



int prime[N],tag[N],cnt;

void init()
{
    tag[0]=1;
    tag[1]=1;
    int i,j;
    for(i=2;i<N;i++) if(!tag[i])
    {
        prime[cnt++]=i;
        for(j=i+i;j<N;j+=i) tag[j]=1;
    }
}


vector<int> g[N];
int n,visit[N];
i64 ans;

int f[N],f1[N];
vector<int> V;

void dfs(int u,int pre)
{
    f[u]=0;
    f1[u]=1;
    int i,v;
    FOR0(i,SZ(g[u]))
    {
        v=g[u][i];
        if(v==pre||visit[v]) continue;
        dfs(v,u);
        f1[u]+=f1[v];
        upMax(f[u],f1[v]);
    }
    V.pb(u);
}

int getRoot(int u)
{
    V.clear(); dfs(u,0);
    int ans=u,p=SZ(V),i,temp,v;
    FOR0(i,SZ(V))
    {
        v=V[i];
        temp=max(SZ(V)-f[v],f[v]);
        if(temp<p) p=temp,ans=v;
    }
    return ans;
}

int d[N];
int MaxDis;
node a[N],b[N];

void DFS1(int u,int pre,vector<int> &V)
{
    d[u]=d[pre]+1; upMax(MaxDis,d[u]);
    V.pb(u);
    int i,v;
    FOR0(i,SZ(g[u]))
    {
        v=g[u][i];
        if(v==pre||visit[v]) continue;

        DFS1(v,u,V);
    }
}


vector<int> V1[N];

int P[N],Q[N];

int M;

void deal()
{
    int i;
    for(i=0;i<=MaxDis;i++) a[i]=node(P[i],0),b[i]=node(Q[i],0);
    while(i<M) a[i]=node(0,0),b[i]=node(0,0),i++;
    fft(a,M,1);
    fft(b,M,1);
    for(i=0;i<M;i++) a[i]=a[i]*b[i];
    fft(a,M,-1);
    i64 temp;
    for(i=0;i<cnt&&prime[i]<M;i++)
    {
        temp=(i64)(a[prime[i]].x+0.5);
        ans+=temp;
    }
}

void DFS(int u)
{
    u=getRoot(u);
    MaxDis=0; d[u]=0;
    int i,j,v,sonNum=0;
    FOR0(i,SZ(g[u]))
    {
        v=g[u][i];
        if(visit[v]) continue;
        V1[sonNum].clear();
        DFS1(v,u,V1[sonNum]);
        sonNum++;
    }
    M=1; L=0;
    while(M<=MaxDis+MaxDis) M<<=1,L++;
    for(i=0;i<=MaxDis;i++) P[i]=Q[i]=0;
    FOR0(i,sonNum)
    {
        FOR0(j,SZ(V1[i]))
        {
            v=V1[i][j];
            Q[d[v]]++;
            if(!tag[d[v]]) ans++;
        }
        deal();
        for(j=0;j<=MaxDis;j++) P[j]+=Q[j],Q[j]=0;
    }
    visit[u]=1;
    FOR0(i,SZ(g[u]))
    {
        v=g[u][i];
        if(!visit[v]) DFS(v);
    }
}

int main()
{
    init();
    Rush(n)
    {
        int i;
        FOR1(i,n) g[i].clear();
        FOR1(i,n-1)
        {
            int u,v;
            RD(u,v);
            g[u].pb(v); g[v].pb(u);
        }
        ans=0; DFS(1);
        printf("%.8lf\n",ans/(1.0*n*(n-1)/2));
    }
}


