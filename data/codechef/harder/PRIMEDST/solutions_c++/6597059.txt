//Khagan

#include <algorithm>
#include <stdio.h>
#include <vector>
#define  maxn      50002
#define  fi        first
#define  se        second
#define  pb        push_back
using    namespace std;
typedef  pair<int,int> pi;

int n,p,t,ans;
bool mark[maxn];
pi cnt[maxn];
pi sum[maxn];
vector<int>pr;
vector<int>dist;
vector<int>adj[maxn];

int query(int x)
{
  if(x<=0 || sum[x].se!=t)
    return 0;
  return sum[x].fi;
}

void update(int x)
{
  if(sum[x].se==t) sum[x].fi++;
  else             sum[x]=pi(1,t);
}

void dfs3(int node , int dad , int lvl)
{
  dist.pb(lvl);
  int sz=adj[node].size();
  for(int i=0 ; i<sz ; i++)
    if(adj[node][i]!=dad && !mark[adj[node][i]])
      dfs3(adj[node][i],node,lvl+1);
}

int dfs2(int node , int dad , int tree)
{
  int sz=adj[node].size();
  for(int i=0 ; i<sz ; i++)
    if(adj[node][i]!=dad && !mark[adj[node][i]] && cnt[adj[node][i]].fi>tree/2)
      return dfs2(adj[node][i],node,tree);
  return node;
}

int dfs1(int node , int dad)
{
  cnt[node]=pi(1,t);
  int sz=adj[node].size();
  for(int i=0 ; i<sz ; i++)
    if(adj[node][i]!=dad && !mark[adj[node][i]])
      cnt[node].fi+=dfs1(adj[node][i],node);
  return cnt[node].fi;
}

void dfs(int root)
{
  t++;
  int tree=dfs1(root,0);
  root=dfs2(root,0,tree);
  mark[root]=true;
  int sz=adj[root].size();
  for(int i=0 ; i<sz ; i++)
    if(!mark[adj[root][i]])
    {
      dist.clear();
      dfs3(adj[root][i],root,1);
      int dsz=dist.size();
      for(int j=0 ; j<p && pr[j]<tree ; j++)
        for(int k=0 ; k<dsz ; k++)
          ans+=query(pr[j]-dist[k]);
      for(int j=0 ; j<dsz ; j++)
        update(dist[j]);
    }
  for(int i=0 ; i<p ; i++)
    ans+=query(pr[i]);
  for(int i=0 ; i<sz ; i++)
    if(!mark[adj[root][i]])
      dfs(adj[root][i]);
}

void CalcPrime()
{
  for(int i=2 ; i<n ; i++)
  {
    bool ok=true;
    for(int j=2 ; j*j<=i && ok ; j++)
      if(i%j==0)
        ok=false;
    if(ok)
      pr.pb(i);
  }
  p=pr.size();
}

void Read()
{
  scanf("%d",&n);
  for(int i=1,x,y ; i<n ; i++)
  {
    scanf("%d%d",&x,&y);
    adj[x].pb(y);
    adj[y].pb(x);
  }
}

int main()
{
  Read();
  CalcPrime();
  dfs(1);
  printf("%.7lf\n",(double)ans/((double)n*(double)(n-1)/(double)2));
  return 0;
}
