#include<cstdio>
#include<cassert>
#include<vector>
#include<set>
#include<complex>
#include<cmath>
#include<ctime>
#include<climits>
#include<algorithm>
#define TIME_LIMIT 2.00
inline double gettime() { return (double)clock() / CLOCKS_PER_SEC ; }
double timelimit;
const double PI = 3.1415926535897932384626433832795; // 4*atan(1.0);
const int MAXN = 50010;

using namespace std;

/* FFT Code from e-maxx.ru */
typedef complex<double> base;
 
void fft (vector<base> & a, bool invert) {
	int n = (int) a.size();
 
	for (int i=1, j=0; i<n; ++i) {
		int bit = n >> 1;
		for (; j>=bit; bit>>=1)
			j -= bit;
		j += bit;
		if (i < j)
			swap (a[i], a[j]);
	}
 
	for (int len=2; len<=n; len<<=1) {
		double ang = 2*PI/len * (invert ? -1 : 1);
		base wlen (cos(ang), sin(ang));
		for (int i=0; i<n; i+=len) {
			base w (1);
			for (int j=0; j<len/2; ++j) {
				base u = a[i+j],  v = a[i+j+len/2] * w;
				a[i+j] = u + v;
				a[i+j+len/2] = u - v;
				w *= wlen;
			}
		}
	}
	if (invert)
		for (int i=0; i<n; ++i)
			a[i] /= n;
}

void multiply (const vector<int> & a, const vector<int> & b, vector<int> & res) {
    vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end());
	size_t n = 1;
	while (n < max (a.size(), b.size()))  n <<= 1;
	n <<= 1;
	fa.resize (n),  fb.resize (n);
    
	fft (fa, false),  fft (fb, false);
	for (size_t i=0; i<n; ++i)
		fa[i] *= fb[i];
	fft (fa, true);
 
	res.resize (n);
	for (size_t i=0; i<n; ++i)
		res[i] = int (fa[i].real() + 0.5);
}


bool is_prime[MAXN];
void find_primes(int upto){
    for(int i=0;i<upto;i++)is_prime[i]=true;
    is_prime[0]=is_prime[1] = false;
    for(int i=2;i<=upto;i++)
        if(is_prime[i])
            for(long long j=i*1ll*i;j<=upto;j+=i)
                is_prime[j] = false;
}
// Original Tree
unsigned int N; // Vertex count
vector<int>G[MAXN]; // Adjacency matrix
bool centroid[MAXN];
int subtree_size[MAXN];

long long good;

void read_input(){
    scanf("%u",&N);
    for(int i=1;i<N;i++){
        int u,v;
        scanf("%d %d",&u,&v);
        --u;--v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
}


long long merge(vector<int>&a,vector<int>&b,vector<int>&c){
    long long res=0;
    multiply(a,b,c);
    //for(int i=0;i<N;i++)printf("%d %d %d\n",a[i],b[i],c[i]);
    for(int i=2;i<c.size();i++)if(is_prime[i])res+=c[i];
    return res;
}

int compute_subtree_size(int v, int p) {
  int c = 1;
  for (int i = 0; i < G[v].size(); i++) {
    int w = G[v][i];
    if (w == p || centroid[w]) continue;
    c += compute_subtree_size(G[v][i], v);
  }
  subtree_size[v] = c;
  return c;
}

pair<int, int> search_centroid(int v, int p, int t) {
  pair<int, int> res = make_pair(INT_MAX, -1);
  int s = 1, m = 0;
  for (int i = 0; i < G[v].size(); i++) {
    int w = G[v][i];
    if (w == p || centroid[w]) continue;

    res = min(res, search_centroid(w, v, t));

    m = max(m, subtree_size[w]);
    s += subtree_size[w];
  }
  m = max(m, t - s);
  res = min(res, make_pair(m, v));
  return res;
}

void enumerate_paths(int v, int p, int d, vector<int> &ds) {
  ds.push_back(d);
  for (int i = 0; i < G[v].size(); i++) {
    int w = G[v][i];
    if (w == p || centroid[w]) continue;
    enumerate_paths(w, v, d + 1, ds);
  }
}
int call_count;
long long count_pairs(vector<int> &d1, vector<int>&d2) {
  long long res = 0;
  //if(gettime()>timelimit)return 0;
  int m1 = *max_element(d1.begin(), d1.end());
  int m2 = *max_element(d2.begin(), d2.end());
  vector<int>a(m1+m2+1,0);
  vector<int>b(m1+m2+1,0);
  vector<int>c(m1+m2+1,0);
  for(int i=0;i<d1.size();i++)a[d1[i]]++;
  for(int i=0;i<d2.size();i++)b[d2[i]]++;
  res = merge(a,b,c);
  call_count++;
  return res;
}




void solve_subproblem(int v){
    //printf("Solving %d\n",v);
    compute_subtree_size(v,-1);
    int s = search_centroid(v,-1,subtree_size[v]).second;
    centroid[s] = true;
    
    for(int i = 0; i < G[s].size(); i++){
        if(centroid[G[s][i]])continue;
        solve_subproblem(G[s][i]);
    }
    vector<int>ds;
    ds.push_back(0);
    for (int i = 0; i < G[s].size(); i++) {
        if (centroid[G[s][i]]) continue;
        vector<int> tds;
        enumerate_paths(G[s][i], s, 1, tds);
        good += count_pairs(ds, tds);
        ds.insert(ds.end(), tds.begin(), tds.end());
    }
    //good += count_pairs(ds,ds);
    centroid[s] = false;
}

int main(){
    int i;
    long long total;
    long double ans;
    timelimit = gettime() + TIME_LIMIT;
    find_primes(MAXN);
    read_input();
    good = 0;
    solve_subproblem(0);
    total = N * 1ll * (N-1) / 2;
    assert(total > 0);
    ans = good*1.0L/total;
    printf("%.9Lf\n",ans);
    //while(gettime()<timelimit);
    return 0;
}

