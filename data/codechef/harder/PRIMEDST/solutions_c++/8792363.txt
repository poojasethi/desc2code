#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define MAXN 101000
#define MAXL 550000
#define MAXE MAXN*2
#define MAXV MAXN
#define PI 3.1415926535897
#define INF 0x3f3f3f3f
#define HAHA __attribute((optimize("O2")))
typedef double real;
typedef long long qword;
int cnt=0;

struct Complex
{
		real x,y;
		Complex(){}
		Complex(real x,real y=0):x(x),y(y){}
		Complex operator +(Complex a)
		{
				return Complex(x+a.x,y+a.y);
		}
		Complex operator -(Complex a)
		{
				return Complex(x-a.x,y-a.y);
		}
		Complex operator *(Complex a)
		{
				return Complex(x*a.x-y*a.y,x*a.y+y*a.x);
		}
};
int pp[MAXL];
Complex g1[MAXL],g2[MAXL],g3[MAXL];
HAHA void dft(Complex g[],int len,bool f)
{
		register int i,j,k;
		Complex t;
		for (i=1;i<len;i<<=1)
		{
				Complex wc=Complex(cos(2*PI/i/2),sin(2*PI/i/2) * (f ? -1 : 1));
				for (j=0;j<len;j+=(i<<1))
				{
						Complex ww=Complex(1,0);
						for (k=0;k<i;k++)
						{
								t=g[j+k];
								g[j+k]=g[j+k]+g[i+j+k]*ww;
								g[j+k+i]=t-g[i+j+k]*ww;
								ww=ww*wc;
						}
				}
		}
}
HAHA void fft(const int *t1,const int *t2,int *r,int n)//len != n
{
		cnt++;
		int len=n;
		register int i,j,k;
		register int x;
		while (len!=(len&(-len)))len-=len&(-len);
		len<<=2;
		for (i=0;i<len;i++)
		{
				pp[i]=0;
				for (x=1,j=len>>1;j;j>>=1,x<<=1)
				{
						if (i&j)pp[i]+=x;
				}
		}
		for (i=0;i<len;i++)
		{
				g1[pp[i]]=t1[i];
				g2[pp[i]]=t2[i];
		}
		dft(g1,len,0);
		dft(g2,len,0);
		for (i=0;i<len;i++)
				g2[i]=g1[i]*g2[i];
		for (i=0;i<len;i++)
				g1[pp[i]]=g2[i];
		dft(g1,len,1);
		for (i=0;i<len;i++)
				r[i]=(int)(g1[i].x/len+0.5);
}


struct Edge
{
		int np;
		int id;
		Edge *next;
}E[MAXE],*V[MAXV];
int tope=-1;
void addedge(int x,int y)
{
		E[++tope].np=y;
		E[tope].next=V[x];
		V[x]=&E[tope];
}
int lock[MAXN];
int siz[MAXN];
int pnt[MAXN];
int core,bstcs;
int n;
int dfs(int now,int pnt,int tree_size)
{
		Edge *ne;
		siz[now]=1;
		int t,r=tree_size-1;
		int mxcs=0;
		::pnt[now]=pnt;
		for (ne=V[now];ne;ne=ne->next)
		{
				if (lock[ne->id] || ne->np==pnt)continue;
				t=dfs(ne->np,now,tree_size);
				siz[now]+=t;
				r-=t;
				mxcs=max(mxcs,t);
		}
		mxcs=max(mxcs,r);
		if (mxcs<bstcs)
		{
				bstcs=mxcs;
				core=now;
		}
		return siz[now];
}
int dfs2(int now,int pnt,int depth,int *g)
{
		Edge *ne;
		g[depth]++;
		int ret=depth;
		for (ne=V[now];ne;ne=ne->next)
		{
				if (lock[ne->id] || ne->np==pnt)continue;
				ret=max(ret,dfs2(ne->np,now,depth+1,g));
		}
		return ret;
}
qword res[MAXL];
void pm(int *x)
{
		for (int i=0;i<n;i++)
				printf("%d ",x[i]);
		printf("\n");
}
int w[MAXL],r[MAXL],g[MAXL];
void solve(int now,int tree_size)
{
		if (tree_size==1)
		{
				res[0]++;return;
		}
		core=-1;
		bstcs=INF;
		dfs(now,now,tree_size);
		int core=::core;
		Edge *ne;
		int arr_len=dfs2(core,core,0,w)*2;
		for (ne=V[core];ne;ne=ne->next)
				if (!lock[ne->id])
						lock[ne->id]=core;
		for (ne=V[core];ne;ne=ne->next)
		{
				if (lock[ne->id]!=core)continue;
				solve(ne->np,ne->np==pnt[core] ? tree_size - siz[core] : siz[ne->np]);
		}
		memset(w,0,sizeof(int)*arr_len*4);
		w[0]=1;
		for (ne=V[core];ne;ne=ne->next)
		{
				if (lock[ne->id]==core)
				{
						int t=dfs2(ne->np,ne->np,1,g);
						if (t<=15000)
						{
								for (register int i=0;i<=t;i++)
										for (register int j=0;w[j];j++)
												res[i+j]+=g[i]*w[j]*2;
								for (register int i=0;i<=t;i++)
										w[i]+=g[i],g[i]=0;
						}else
						{
								fft(g,w,r,arr_len+1);
								for (register int i=0;i<arr_len+1;i++)
										res[i]+=r[i]*2,w[i]+=g[i],g[i]=0;
						}
				}
		}
		for (ne=V[core];ne;ne=ne->next)
		{
				if (lock[ne->id]==core)
						lock[ne->id]=0;
		}
		res[0]++;
}
int prime[MAXN],topp=-1;
bool pflag[MAXN];
void Init()
{
		for (int i=2;i<MAXN;i++)
		{
				if (!pflag[i])
						prime[++topp]=i;
				for (int j=0;j<=topp && i*prime[j]<MAXN;j++)
				{
						pflag[i*prime[j]]=true;
						if (i%prime[j]==0)break;
				}
		}
}
int main()
{
		int i;
		scanf("%d",&n);
		/*
		   int *a=new int[20];
		   int *b=new int[20];
		   int *c=new int[20];
		   for (i=0;i<n;i++)scanf("%d",a+i);
		   for (i=0;i<n;i++)scanf("%d",b+i);
		   fft(a,b,c,n);
		   for (i=0;i<10;i++)printf("%d ",c[i]);
		   return 0;*/
		int x,y;
		for (i=1;i<n;i++)
		{
				scanf("%d%d",&x,&y);
				//           x++;y++;
				addedge(x,y);
				addedge(y,x);
				V[x]->id=V[y]->id=i;
		}
		solve(1,n);
		Init();
		double ans=0;
		for (int i=2;i<MAXN;i++)
				if (!pflag[i])
						ans+=res[i];
		ans/=(qword)n*(n-1);
		printf("%.9lf\n",ans);
}