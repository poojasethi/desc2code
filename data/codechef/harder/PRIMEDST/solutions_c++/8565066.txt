#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <algorithm>
using namespace std;

struct complex
{
	double num,inum;
	complex(double A=0.0,double B=0.0){num=A,inum=B;}
};
complex operator +(const complex &A,const complex &B){return complex(A.num+B.num,A.inum+B.inum);}
complex operator -(const complex &A,const complex &B){return complex(A.num-B.num,A.inum-B.inum);}
complex operator *(const complex &A,const complex &B){return complex(A.num*B.num-A.inum*B.inum,A.num*B.inum+A.inum*B.num);}
struct Fast_Fourier_Transform
{
	#define size 140005
	#define pi 3.141592653589793238462643383
	
	int N,rev[size];
	complex *W,w[2][size];
	
	void prepare(int n)
	{
		if(N==n)return;
		int i,k,x,y;N=n;
		for(i=0;i<n;++i)
		{
			for(x=i,y=0,k=1;k<n;x>>=1,k<<=1)(y<<=1)|=x&1;
			rev[i]=y;
		}
		for(i=0;i<n;++i)
		{
			w[0][i]=complex(cos(2*pi*i/n),sin(2*pi*i/n));
			w[1][i]=complex(cos(2*pi*i/n),-sin(2*pi*i/n));
		}
	}
	void work(complex *A,int n)
	{
		if(n==1)return;
		int i,j,k,l,t;
		complex x,y;
		for(i=0;i<n;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
		for(i=1;i<n;i<<=1)
		for(j=0,t=n/(i<<1);j<n;j+=i<<1)
		for(k=l=0;k<i;++k,l+=t)
		{
			x=W[l]*A[j+k+i];
			y=A[j+k];
			A[j+k]=y+x;
			A[j+k+i]=y-x;
		}
	}
	
	void DFT(complex *A,int n){prepare(n);W=w[0];work(A,n);}
	void IDFT(complex *A,int n)
	{
		prepare(n);W=w[1];work(A,n);
		for(int i=0;i<n;++i)A[i].num/=n;
	}
	
	#undef size
	#undef pi
}FFT;

int N,n,m,i,j,k,u,v;
int son[50005],next[100005],ed[100005],tot;
int size[50005],heavy[50005];
bool vis[50005];

void dfs1(int x)
{
	vis[x]=true;
	size[x]=1;
	for(int i=son[x];i;i=next[i])
	if(!vis[ed[i]])
	{
		dfs1(ed[i]);
		size[x]+=size[ed[i]];
	}
	vis[x]=false;
}

void dfs2(int x)
{
	vis[x]=true;
	heavy[x]=v-size[x];
	for(int i=son[x];i;i=next[i])
	if(!vis[ed[i]])
	{
		if(size[ed[i]]>heavy[x])heavy[x]=size[ed[i]];
		dfs2(ed[i]);
	}
	if(heavy[x]<heavy[u]||u==-1)u=x;
	vis[x]=false;
}

complex A[140005];
int a[140005],d;
int tmp[50005],top;
bool f[200005];
long long ans;

void dfs3(int x,int y)
{
	vis[x]=true;
	++a[y];if(y>d)d=y;
	for(int i=son[x];i;i=next[i])if(!vis[ed[i]])dfs3(ed[i],y+1);
	vis[x]=false;
}

void dfs(int x)
{
	int i,j;
	dfs1(x);v=size[x];
	u=-1;dfs2(x);x=u;
	vis[x]=true;
	for(top=0,i=son[x];i;i=next[i])if(!vis[ed[i]])tmp[++top]=ed[i];
	
	d=0;a[0]=1;
	for(i=1;i<=top;++i)dfs3(tmp[i],1);
	for(N=1;N<=2*d;N<<=1);
	for(i=0;i<N;++i)A[i]=complex(a[i],0);
	FFT.DFT(A,N);
	for(i=0;i<N;++i)A[i]=A[i]*A[i];
	FFT.IDFT(A,N);
	for(i=1;i<N;++i)if(f[i])ans+=(long long)(A[i].num+0.1);
	for(i=0;i<=d;++i)a[i]=0;
	
	for(j=1;j<=top;++j)
	{
		d=0;
		dfs3(tmp[j],1);
		for(N=1;N<=2*d;N<<=1);
		for(i=0;i<N;++i)A[i]=complex(a[i],0);
		FFT.DFT(A,N);
		for(i=0;i<N;++i)A[i]=A[i]*A[i];
		FFT.IDFT(A,N);
		for(i=1;i<N;++i)if(f[i])ans-=(long long)(A[i].num+0.1);
		for(i=0;i<=d;++i)a[i]=0;
	}
	
	for(i=son[x];i;i=next[i])if(!vis[ed[i]])dfs(ed[i]);
}

int main()
{
	n=200000;
	for(i=2;i<=n;++i)f[i]=true;
	for(i=2;i<=n;++i)if(f[i])
	for(j=i+i;j<=n;j+=i)f[j]=false;
	scanf("%d",&n);
	for(i=1;i<n;++i)
	{
		scanf("%d%d",&u,&v);
		++tot;next[tot]=son[u];son[u]=tot;ed[tot]=v;
		++tot;next[tot]=son[v];son[v]=tot;ed[tot]=u;
	}
	dfs(1);
	printf("%.10lf\n",(double)ans/n/(n-1));
}