#include <bits/stdc++.h>
using namespace std;

// uzumaki naruto :)
#define TRACE

#ifdef TRACE
#define dbgarr(a,n)   cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n";
#define dbg(args...)  {debug,args; cerr<<endl;}
#define pause()       cin.get();cin.get();

#else
#define dbgarr(a,n)
#define dbg(args...)
#define pause()
#endif

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

template <typename T>
inline void fi(T *a)
{
    register char c=0;
    while (c<33) c=getchar_unlocked();
    *a=0;
    int tmp = 0;
    while (c>33)
    {
        if ( c == 45 ) tmp = 1;
        else *a=*a*10+c-'0';
        c=getchar_unlocked();
    }
    if ( tmp == 1 ) *a = 0-(*a);
}

#define fr first
#define se second
#define pb push_back
typedef long long LL;
typedef pair<int,int> pii;

const int NN = 112345;
vector<int> g[NN];

int p[20][NN],add[NN];
int st[NN],en[NN];
int in[NN],out[NN];
int tym = 0;

LL dp[NN];

void dfs(int x,int f){
    p[0][x] = f;
    in[x] = tym++;
    for(int i = 1; i < 20; ++i)
        p[i][x] = p[i-1][p[i-1][x]];

    int n = (int)g[x].size();
    for(int i = 0; i < n; ++i){
        int y = g[x][i];
        if (y != f) dfs(y,x);
    }
    out[x] = tym++;
}

bool child(int x,int y){
    return (in[x] <= in[y] and out[x] >= out[y]);
}

int LCA(int x,int y){
    if (child(x,y)) return x;
    if (child(y,x)) return y;
    for(int i = 19; i >= 0; --i){
        if (!child(p[i][x],y))
            x = p[i][x];
    }
    return p[0][x];
}

int dfs1(int x,int f){
    int cnt = 0;
    int n = (int)g[x].size();
    for(int i = 0; i < n; ++i){
        int y = g[x][i];
        if (y != f) cnt += dfs1(y,x);
    }

    cnt += en[x]-st[x];
    add[x] = cnt;
    return cnt;
}

void dec(int a,int b,int c,int d){
    if (child(c,a)) c = a;
    for(int i = 18; i >= 0; --i){
        if (!child(p[i][d],b) and child(c,p[i][d]))
            d = p[i][d];
    }

    if (!child(d,b) and child(c,p[0][d]))
        d = p[0][d];
    if (child(a,c) and child(c,d) and child(d,b) and c != d)
        st[d]++, en[c]++;
}

void dfs2(int x,int f,LL sum){
    sum += add[x];
    dp[x] = sum;
    int n = (int)g[x].size();
    for(int i = 0; i < n; ++i){
        int y = g[x][i];
        if (y != f) dfs2(y,x,sum);
    }
}

void solve(){
    int n,a,b,c,d;
    int m1,m2;

    fi(&n); fi(&m1); fi(&m2);
    for(int i = 1; i < n; ++i){
        fi(&a); fi(&b);
        g[a].pb(b),g[b].pb(a);
    }

    dfs(1,1);
    for(int i = 0; i < m1; ++i){
        fi(&a); fi(&b); fi(&c); fi(&d);
        int p1 = LCA(a,b), p2 = LCA(c,d);
        if (p1 != a) {
            en[a]++, st[p1]++;
            dec(p1,a,p2,c), dec(p1,a,p2,d);
        }

        if (p1 != b) {
            en[b]++, st[p1]++;
            dec(p1,b,p2,c), dec(p1,b,p2,d);
        }
    }

    dfs1(1,1);
    dfs2(1,1,0LL);

    for(int i = 0; i < m2; ++i){
        fi(&a); fi(&b);
        int com = LCA(a,b);
        LL ans = dp[a] + dp[b] - 2LL*dp[com];
        printf("%lld\n",ans);
    }
}

int main()
{
    solve();
    return 0;
}
