#include <bits/stdc++.h>
#define snd(a) scanf("%d",&(a))
#define snlld(a) scanf("%lld",&(a))
#define rep(i,n) for((i)=0;(i)<(n);(i)+=1)
#define reps(i,s,n) for((i)=(s);(i)<(n);(i)+=1)
#define tr(container,it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define pb push_back
#define pf push_front
#define all(a) (a).begin(),(a).end()
#define rall(a) (a).rbegin(),(a).rend()
#define fill(a,v) memset((a),(v),sizeof(a))
#define sz size()
#define mp make_pair
#define mod  1000000007
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template<class T> inline T poww(T b,T p){ll a=1;while(p){if(p&1){a=(a*b);}p>>=1;b=(b*b);}return a;}
template<class T> inline T poww2(T b,ll p){T a=1;while(p){if(p&1){a=(a*b);}p>>=1;b=(b*b);}return a;}
template<class T> inline T modpoww(T b,T p,T mmod){ll a=1;while(p){if(p&1){a=(a*b)%mmod;}p>>=1;b=(b*b)%mmod;}return a%mmod;}
template<class T>  inline T gcd(T a,T b){ if(b>a)return gcd(b,a);return ((b==0)?a:gcd(b,a%b));}
template<class T> inline void scan(vector<T>& a,int n){T b;int i; rep(i,n){cin>>b;a.pb(b);}}
inline void scand(vector<int>& a,int n){int b;int i; rep(i,n){snd(b);a.pb(b);}}
#define pii pair<int,int>
#define vpii vector<pii >
#define vi vector<int>
#define vvi vector<vi >
#define vl vector<long long>
#define vs vector<string>
#define fr first
#define sd second


int m1,m2,n;
vvi e;
ll cummu[100010];
ll sum[100010];
int level[100010];
int finish[100010];


//LCA
#define N 100010

int tree[(2*N)*6];
int vis[2*N],lev[2*N],istvis[N],ct;
void dfs(int v,int dep,int p){//eulerian tour
    istvis[v]=ct;
    vis[ct]=v;
    lev[ct++]=dep;
    level[v]=dep;
    int i,j;
    rep(i,e[v].sz){
        if(e[v][i]==p)continue;
        dfs(e[v][i],dep+1,v);
        vis[ct]=v;
        lev[ct++]=dep;
    }
    finish[v]=ct;
}
void init_seg_tree(int node,int s,int e){// segment tree over  array lev
    if(s==e){
        tree[node]=s;
        return;
    }
    init_seg_tree(node<<1,s,(s+e)/2);
    init_seg_tree((node<<1)+1,(s+e)/2+1,e);
    if(lev[tree[node*2]]<lev[tree[2*node+1]])tree[node]=tree[2*node];
    else tree[node]=tree[node*2+1];
}
int min_idx_query(int node,int s,int e,int qi,int qj){
    if(s>=qi&&e<=qj)return tree[node];
    if(qi>e||qj<s)return -1;
    int lans=min_idx_query(2*node,s,(e+s)/2,qi,qj);
    int rans=min_idx_query(2*node+1,(e+s)/2+1,e,qi,qj);
    if(lans==-1)return rans;
    if(rans==-1)return lans;
    if(lev[lans]<lev[rans])return lans;
    return rans;

}

int get_lca(int u,int v){
    return vis[min_idx_query(1,0,ct-1,min(istvis[u],istvis[v]),max(istvis[u],istvis[v]))];//query returns index of least depth node visited b/w ist visit of u and v
}
//LCA end

int ancesstor(int anc,int node){
    if(istvis[anc]<=istvis[node]&&finish[anc]>=finish[node])return 1;
    return 0;
}
pii common_path(int a,int u,int c,int v){
    pii ans=mp(0,0);
    if(!ancesstor(v,a))return ans;
    if(level[v]<level[u]){//v is closer to rot than u is ( v is higher)
        int x=get_lca(c,a);
        if(ancesstor(u,x))
            ans.fr=x,ans.sd=u;
    }
    else{
         int x=get_lca(c,a);
         ans.fr=x,ans.sd=v;
    }
    return ans;
}

void dfs_cummu(int k,int p){
    int i,j;
    rep(i,e[k].sz){
        if(e[k][i]==p)continue;
        dfs_cummu(e[k][i],k);
        cummu[k]+=cummu[e[k][i]];
    }
}
void dfs_sum(int k,int p){
    int i,j;

    rep(i,e[k].sz){
        if(e[k][i]==p)continue;
        sum[e[k][i]]=cummu[e[k][i]]+sum[k];
        dfs_sum(e[k][i],k);
    }
}

int main(){
    int i,j,k,a,b,c,d,u,v;
    pii p;
    cin>>n>>m1>>m2;
    e.resize(n+1);
    rep(i,n-1){
        snd(u);
        snd(v);
        e[u].pb(v);
        e[v].pb(u);
    }
    dfs(1,0,-1);
    init_seg_tree(1,0,ct-1);
    rep(i,m1){
        scanf("%d%d%d%d",&a,&b,&c,&d);
        cummu[a]++;
        cummu[b]++;
        cummu[get_lca(a,b)]-=2;
        u=get_lca(a,b);
        v=get_lca(c,d);
        //cout<<"u="<<u<<" v="<<v<<":\n";
        p=common_path(a,u,c,v);
        //cout<<"p.fr="<<p.fr<<" p.sd="<<p.sd<<"\n";
        cummu[p.fr]--,cummu[p.sd]++;
        p=common_path(a,u,d,v);
         //cout<<"p.fr="<<p.fr<<" p.sd="<<p.sd<<"\n";
        cummu[p.fr]--,cummu[p.sd]++;
        p=common_path(b,u,c,v);
        // cout<<"p.fr="<<p.fr<<" p.sd="<<p.sd<<"\n";
        cummu[p.fr]--,cummu[p.sd]++;
        p=common_path(b,u,d,v);
        // cout<<"p.fr="<<p.fr<<" p.sd="<<p.sd<<"\n";
        cummu[p.fr]--,cummu[p.sd]++;
     /*   rep(j,6){
            cout<<"j="<<j<<" cummu="<<cummu[j]<<"\n";
        }*/
    }
    dfs_cummu(1,-1);
    dfs_sum(1,-1);
   /* cout<<"\n";
    rep(j,6){
            cout<<"j="<<j<<" cummu="<<cummu[j]<<"\n";
        }
    rep(j,6){
            cout<<"j="<<j<<" sum="<<sum[j]<<"\n";
        }*/
    rep(i,m2){
        snd(u);
        snd(v);
        printf("%lld\n",sum[u]+sum[v]-2LL*sum[get_lca(u,v)]);
    }

}



















































