// 
// Least Common Ancestor Implementation
// http://www.codechef.com/problems/TALCA/
//

#include <bits/stdc++.h>
#define s(a) scanf("%d",&a)
#define ss(a) scanf("%s",a)

using namespace std;
typedef long long int ll;

vector<int> graph[500005];	    // Adjacency graph
int parent[20][500005];		    // parent[i][j] :: '2^i'th parent of node 'j', to be used for calculating LCA
int level[500005];	            // level[i] :: Level of node i, here level of the node node is 0 so on
int log2_[500005];
int label[500005];
ll dist[500005];
void DFS(int node, bool visited[])
{
	visited[node] = true;
	for(int i=0; i<graph[node].size(); ++i)
	{
		int v = graph[node][i];
		if(!visited[v])
		{
			parent[0][v] = node;
			for(int j=1;j<20;++j)
				parent[j][v] = parent[j-1][parent[j-1][v]];
			level[v] = level[node] + 1;
			DFS(v, visited);
		}
	}
	return ;
}

int LCA(int x, int y)
{
	if(level[x] > level[y]) swap(x,y);
	int diff = level[y] - level[x];
	while(diff)
	{
		int p = (diff&-diff);
		y = parent[(int)log2_[p]][y];
		diff -= p;
	}
	if(x==y) return x;
	for(int i=19;i>=0;--i)
	{
		if(parent[i][x] != parent[i][y]){
			x = parent[i][x], 
			y = parent[i][y];
		}
	}
	return parent[0][x];
}

void initialize_LCA()
{
	bool vis[500005];
        for(int i=1;i<500005;i++)
              if(__builtin_popcount(i)==1)
                    log2_[i] = __builtin_popcount(i-1);
	memset(vis,0,sizeof(vis));
	for(int i=0;i<20;++i) parent[i][0] = 0;
	level[0] = 0;
	DFS(0,vis);
}
inline void intersect(int u1,int v1,int u2,int v2)
{
     int l = LCA(v1,v2);
     if(level[l] > level[u1] && level[l] > level[u2])
     {
           if(level[u1]<level[u2])
                 label[u2] ++;
           else
                 label[u1] ++;
           label[l] --;;
     }
     //printf("After intersect %d %d %d %d, labels : \n",u1,v1,u2,v2);
     //for(int i=0;i<5;i++)printf("%d ",label[i]);printf("\n");
}
int dfs1(int node, bool vis[])
{
      vis[node] = true;
      ll accum = 0;
      for(int i=0;i<graph[node].size();i++)
      {
            if(vis[graph[node][i]])
                  continue;
            //dist[graph[node][i]] = cum + label[node];
            accum += dfs1(graph[node][i],vis);
      }
      return label[node] =  label[node] + accum;
}
void dfs2(int node,bool vis[],ll cum)
{
      vis[node] = true;
      dist[node] = label[node] + cum;
      for(int i=0;i<graph[node].size();i++)
      {
            if(vis[graph[node][i]])
                  continue;
            dfs2(graph[node][i],vis,cum + label[node]);
      }
}
int main()
{
	int N, M1, M2;
        int A,B,C,D,l1,l2;
	s(N);s(M1);s(M2);
        memset(label,0,sizeof(label));
        for(int i=0;i<N-1;++i)
	{
		int u, v;
		scanf("%d %d", &u, &v);
		--u, --v;
		graph[u].push_back(v),
		graph[v].push_back(u);
	}
	initialize_LCA();
        for(int i=0;i<M1;i++)
        {
            s(A);s(B);s(C);s(D);
            A--;B--;C--;D--;
            l1 = LCA(A,B);
            l2 = LCA(C,D);
            //printf("LCA's = %d %d\n",l1,l2);
            label[l1] --;
            label[A] ++;
            label[l1] --;
            label[B] ++;
            intersect(l1,A,l2,C);
            intersect(l1,A,l2,D);
            intersect(l1,B,l2,C);
            intersect(l1,B,l2,D);
        }
	bool vis[500005];
        memset(vis,0,sizeof(vis));
        dist[0] = 0;
        dfs1(0,vis);
        memset(vis,0,sizeof(vis));
        dfs2(0,vis,0);
        //for(int i=0;i<N;i++)
        //      printf("Dist %d = %lld, label = %d\n",i+1,dist[i],label[i]);
        for(int i=0;i<M2;i++)
        {
            s(A);s(B);
            A--; B--;
            l1 = LCA(A,B);
            printf("%lld\n",dist[A]+dist[B]-2*dist[l1]);
        }
	return 0;
}
