#include <iostream>
#include <cstdio>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <cassert>

using namespace std;

template <class T> inline int size(const T& c) {return (int) c.size();}

int rInt() {int N; scanf("%d", &N); return N;}

const int kSegmentSize = 524288;

struct SegmentTree
{
	vector <int> tree;
	vector <int> treeIndex;
	vector <int> v;
	int left(int x) {return (x << 1);}
	int right(int x) {return (x << 1) | 1;}
	void recurse(int node, int b, int e) {
		if (b == e) {
			tree[node] = 1;
			treeIndex[node] = b + 1;
		}
		else {
			int mid = (b + e) >> 1;
			recurse(left(node), b, mid);
			recurse(right(node), mid + 1, e);
			tree[node] = tree[left(node)] + tree[right(node)];
		}
	}
	void init(vector <int>& v) {
		this -> v = v;
		treeIndex.resize(kSegmentSize, 0);
		tree.resize(kSegmentSize, 0);
		recurse(1, 0, size(v) - 1);
	}
	int deleteKth(int node, int b, int e, int k) {
		if (b == e) {
			assert(tree[node] == 1);
			tree[node] = 0;
			return treeIndex[node];
		}
		else {
			int mid = (b + e) >> 1;
			int answer;
			if (tree[left(node)] >= k)
				answer = deleteKth(left(node), b, mid, k);
			else
				answer = deleteKth(right(node), mid + 1, e, k - tree[left(node)]);
			tree[node] = tree[left(node)] + tree[right(node)];
			return answer;
		}
	}
	int deleteKth(int k) {
		return deleteKth(1, 0, size(v) - 1, k);
	}
};

struct Solver
{
	void solve(vector <int>& shift) {
		int N = size(shift);
		vector <int> v;
		for (int i = 0; i < N; ++i) {
			v.push_back(i + 1);
		}
		
		// After all the soldiers have been ordered, we know that the
		// final ordering, starting from the left, is 1, 2,..., N.
		// We start with the last soldier that came, compute his rank,
		// given the number of other soldiers he had to pass, remove him
		// from the set {1, 2,..., N}, and continue with the other soldiers
		// in the reverse order of which they came.

		// The segment tree removes the rank of the soldier that has been
		// computed from the set {1, 2,..., N} for every soldier.
		SegmentTree segmentTree;
		segmentTree.init(v);
		
		// 'order' computes the ordering of soldiers in the reverse order
		// of which they came.
		vector <int> order(N);
		for (int i = size(shift) - 1; i >= 0; --i) {
			int k = shift[i];
			// If the soldier at position i had to move 'k' positions to
			// the left, then it must have been (k + 1)th rank from the
			// end in the current set of soldiers, or ((i + 1) - (k + 1) + 1)th
			// rank from the beginning.
			int result = segmentTree.deleteKth((i + 1) - (k + 1) + 1);
			// The deleteKth(k) function deletes the k'th indexed key in
			// the sequence of pending keys and returns the value associated
			// with it. The value here is the rank that we have initially set
			// using the variable 'v'.
			order[i] = result;
		}
		
		// Output the result.
		stringstream output;
		for (int i = 0; i < size(order); ++i) {
			if (i != 0) {
				output << ' ';
			}
			output << order[i];
		}
		printf("%s\n", output.str().c_str());
	}
};

int main()
{
	int testCases = rInt();
	for (int test = 0; test < testCases; ++test) {
		int N = rInt();
		vector <int> shift(N);
		for (int i = 0; i < N; ++i)
			shift[i] = rInt();
		Solver solver;
		solver.solve(shift);
	}
	return 0;
}
