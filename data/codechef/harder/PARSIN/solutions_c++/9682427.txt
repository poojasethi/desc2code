#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const int maxn = 75;

int size;

struct _mat {
	double num[maxn][maxn];
} E;

inline _mat mul(_mat &A, _mat &B) {
	_mat C;
	for(int i = 1; i <= size; i++) for(int j = 1; j <= size; j++) {
		C.num[i][j] = 0.0;
		for(int k = 1; k <= size; k++) C.num[i][j] += A.num[i][k] * B.num[k][j];
	}
	return C;
}

inline _mat qpow(_mat &A, int n) {
	_mat ans = E;
	for(_mat t = A; n; n >>= 1, t = mul(t, t)) if(n & 1) ans = mul(ans, t);
	return ans;
}

int main() {
	for(int i = 0; i < maxn; i++) E.num[i][i] = 1.0;

	int T; scanf("%d", &T);
	while(T--) {
		int n, m; double x; scanf("%d%d%lf", &m, &n, &x);
		const double sinx = sin(x), twocosx = 2.0 * cos(x);

		if(n == 1) {
			if(m == 1) printf("%.10lf\n", sinx);
			else printf("0\n");
			continue;
		}

		_mat trans; size = m << 1;
		for(int i = 1; i <= size; i++) for(int j = 1; j <= size; j++) trans.num[i][j] = 0;
		for(int i = 1; i <= m; i++) trans.num[i][i + m] = -1, trans.num[i + m][i] = 1;
		for(int i = 1; i <= m; i++) trans.num[i + m][i + m] = twocosx;
		for(int i = 1; i < m; i++) trans.num[i + m][i + m + 1] = sinx;

		_mat ans = qpow(trans, n - 2);
		printf("%.10lf\n", sinx * ans.num[1][size] + sin(2 * x) * ans.num[1 + m][size] + sinx * sinx * ans.num[2 + m][size]);
	}
	return 0;
}
