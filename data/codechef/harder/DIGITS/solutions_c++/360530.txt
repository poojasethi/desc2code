
/* Author :: Yash */
#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) 
#define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)
#define REP(i,n) FOR(i,0,n)
#define DEP(i,n) REV(i,n,0)
#define PB push_back
#define PP pop()
#define EM empty()
#define INF 1000000000
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a) 	    __typeof(a) x(a)
#define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i)
#define EACH(it,v)  	IFOR(it,v.begin(),v.end())
#define PRESENT(c,x) 	((c).find(x) != (c).end())
#define SZ(x) 		x.size()
#define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end())
#define D(N) 		int N
#define S(N)		scanf("%d",&N)
#define FASTIO          1

typedef pair<int,int>   PI;
typedef pair<int,PI>    TRI;
typedef V( int )        VI;
typedef V( PI  )        VII;
typedef V( string )     VS;
typedef long long       LL;
typedef long double     LD;

/* FastIO, generally required these days ;) */

#ifndef FASTIO
char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20];
inline int input(int flag=0) {

	while(*ipos <= 32) ++ipos;
	if ( flag  ) return (*ipos++ - '0'); /* For getting Boolean Characters */
	int x=0, neg = 0;char c;
	while( true ) {
		c=*ipos++; if(c == '-') neg = 1;
		else {
			if (c<=32) return neg?-x:x;
			x=(x<<1)+(x<<3)+c-'0';
		}
	}
}
inline void output(int x,int flag) {
	int y,dig=0;
	while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}
	while (dig--) *opos++=DIP[dig];
	*opos++= flag ? '\n' : ' ';
}
inline void InitFASTIO() {
	ipos = InpFile; opos = OutFile;
	fread_unlocked(InpFile,20000000,1,stdin);
}
inline void FlushFASTIO() {
	fwrite_unlocked(OutFile,opos-OutFile,1,stdout);	
}
#endif

/* Main Code Starts from here */

#define Max 4000000
#define MOD 1000000007

int t1[Max], inverse[Max], size1, size2;
LL powers[10][2500];

inline LL moduloSpecial(LL b, LL p, LL n) {
   LL x = 1, y = b;
   while (p) {
      if (p&1) {
	 x = (x*y); if(x >= n) x %= n;  
      }
      y = (y*y); if(y >= n) y %= n;
      p >>= 1;
   }
   return x % n;
}


LL getInverse(int a) {
   return moduloSpecial(a,MOD-2,MOD);
}



struct Pair{
   int first, second;
   Pair(int _first,int _second) {
      first = _first;
      second = _second;
   }
   Pair():first(-1),second(-1){}
};

Pair index1[Max], index2[Max], t2[Max];

bool cmp(const Pair& a, const Pair& b) {
   return a.first < b.first;
}

struct Tetra {

   int two, three, five, seven, digits[10], sum;
   Tetra(){}
   Tetra(int _two, int _three, int _five, int _seven) {
      two = _two;
      three = _three;
      five = _five;
      seven = _seven;
      memset(digits,0,sizeof digits); getDigits(); 
   }
   void getDigits() {
      digits[5] = five;
      digits[7] = seven;
      digits[9] = three/2; 
      digits[8] = two/3;
      
      digits[3] = three & 1; digits[2] = two % 3;
      if(digits[3] && digits[2]) {
	 --digits[3]; --digits[2]; digits[6]++;
      }
      digits[4] = digits[2]/2; digits[2] &= 1;
      sum = 0; FOR(i,2,10) sum += digits[i];
   }
};

bool operator<(const Tetra& p1, const Tetra& p2) {

   int sum1, sum2; sum1 = p1.sum; sum2 = p2.sum;

   if(sum1 < sum2) return true;
   if(sum1 > sum2) return false;

   REP(i,10) {
      if(p1.digits[i] < p2.digits[i]) return false;
      if(p1.digits[i] > p2.digits[i]) return true;
   }
   return true;
}
   
int main() {

   int kases; scanf("%d",&kases);

   REP(i,10) powers[i][0] = 1;
   FOR(i,1,701) {
      powers[5][i] = (powers[5][i-1]*5)%MOD; 
      powers[7][i] = (powers[7][i-1]*7)%MOD;
   }
   FOR(i,1,2101) powers[2][i] = (powers[2][i-1]*2)%MOD; 
   FOR(i,1,1401) powers[3][i] = (powers[3][i-1]*3)%MOD; 


   LL r1;
   REP(i,701) REP(j,701-i) {
      r1 = powers[5][i] * powers[7][j]; 
      if(r1 >= MOD) r1 %= MOD;
      t1[size1] = r1;inverse[size1] = getInverse(t1[size1]);
      index1[size1++] = Pair(i,j);
   }

   REP(j,1401) {
      int t = 3 * (700 - j/2);
      REP(i,t) {
	 r1 = powers[2][i] * powers[3][j]; //moduloSpecial(2,i,MOD) * moduloSpecial(3,j,MOD);
	 if(r1 >= MOD) r1 %= MOD;
	 t2[size2] = Pair(r1,size2); //.PB(r1);
	 index2[size2++] = Pair(i,j); //.PB(PI(i,j));
      }
   }

   sort(t2,t2+size2,cmp); VII search;
   REP(i,size2) {
      search.PB(PI(t2[i].first,t2[i].second));
   }

   VII::iterator it1, it2;
   int ssize = 0;


   while(kases--) {
      
      Tetra answer(3000,4000,1000,1000), tmpAns;

      int n; scanf("%d",&n);
      if(n <= 9) {
	 if(!n) {
	    puts("10");
	 }
	 else printf("%d\n",n); continue;
      }
      
      ssize = 0;
      REP(i,size1) {
	 
	 int tmp = ( (LL)n * inverse[i] ) % MOD;
	 it1 = lower_bound(ALL(search),PI(tmp,-1)); it2 = upper_bound(ALL(search),PI(tmp,INF)); 
	
	 bool done = false; 
	 while(it1 != search.end() && (*it1).first == tmp && it1 != it2) {
	    int j = (*it1).second;
	    int c = index1[i].first, d = index1[i].second, a = index2[j].first, b = index2[j].second;
	    ++it1;tmpAns = Tetra(a,b,c,d);
	    if(tmpAns < answer) {
	       answer = Tetra(a,b,c,d);
	    }
	 }
      }
      FOR(i,2,10) if(answer.digits[i]) {
	 int times = answer.digits[i];
	 REP(j,times) printf("%d",i);
      }
      puts("");
   }
   return 0;
}
