
/* Author :: Yash */

#include <vector>

#include <list>

#include <cassert>

#include <sstream>

#include <map>

#include <set>

#include <climits>

#include <deque>

#include <fstream>

#include <stack>

#include <bitset>

#include <stack>

#include <queue>

#include <algorithm>

#include <functional>

#include <numeric>

#include <cstring>

#include <utility>

#include <sstream>

#include <iostream>

#include <iomanip>

#include <cstdio>

#include <cmath>

#include <cstdlib>

#include <ctime>

using namespace std;

 

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

 

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i)

#define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)

#define REP(i,n) FOR(i,0,n)

#define DEP(i,n) REV(i,n,0)

#define PB push_back

#define PP pop()

#define EM empty()

#define INF 1000000000

#define PF push_front

#define ALL(x) x.begin(),x.end()

#define SORT(x) sort(ALL(x))

#define V(x) vector< x >

#define Debug false

#define PRINT(x) cout << x << " " << x << endl

#define LET(x,a) __typeof(a) x(a)

#define IFOR(i,a,b) for(LET(i,a);i!=(b);++i)

#define EACH(it,v) IFOR(it,v.begin(),v.end())

#define PRESENT(c,x) ((c).find(x) != (c).end())

#define SZ(x) x.size()

#define CPRESENT(c,x) (find(c.begin(),c.end(),x) != (c).end())

#define D(N) int N

#define S(N) scanf("%d",&N)

//#define FASTIO 1

 

typedef pair<int,int> PI;

typedef pair<int,PI> TRI;

typedef V( int ) VI;

typedef V( PI ) VII;

typedef V( string ) VS;

typedef long long LL;

typedef long double LD;

 

/* FastIO, generally required these days ;) */

 

/*ifndef FASTIO

char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20];

inline int input(int flag=0) {

 

while(*ipos <= 32) ++ipos;

if ( flag ) return (*ipos++ - '0'); /* For getting Boolean Characters 

int x=0, neg = 0;char c;

while( true ) {

c=*ipos++; if(c == '-') neg = 1;

else {

if (c<=32) return neg?-x:x;

x=(x<<1)+(x<<3)+c-'0';

}

}

}

inline void output(int x,int flag) {

int y,dig=0;

while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}

while (dig--) *opos++=DIP[dig];

*opos++= flag ? '\n' : ' ';

}

inline void InitFASTIO() {

ipos = InpFile; opos = OutFile;

fread_unlocked(InpFile,20000000,1,stdin);

}

inline void FlushFASTIO() {

fwrite_unlocked(OutFile,opos-OutFile,1,stdout);

}

endif 
*/
 

/* Main Code Starts from here */

 

const int MAXN = 235;

 

int T, N, K, low [MAXN], top [MAXN];

bitset<MAXN> value [MAXN][MAXN], flip [MAXN][MAXN];

bool last [2*MAXN], Faulty[MAXN][MAXN];

char str [MAXN];

 

bitset<MAXN> board[MAXN];

 

inline bool light (int r, int c) {

return board[r].test(c);

}

 

int main () {

 

int kases; scanf("%d",&kases);

while (kases--) {

 

scanf ("%d%d", &N,&K);

REP(i,N+5) board[i].reset();

 

for (int i = 0; i < N; i++) {

scanf ("%s", str);

for (int j = 0; j < N; j++) {

if(str[j] - '0') board[i].set(j);

Faulty[i][j] = 0;

}

}

REP(i,K) {

int x,y; scanf("%d%d",&x,&y);

--x; --y;

Faulty[x][y] = 1;

}

 

REP(i,N+5) REP(j,N+5) {

value[i][j].reset();

flip[i][j].reset();

}

 

for (int i = 0; i < N; i++)

flip [0][i].set(i);

 

for (int i = 0; i < N; i++)

{

for (int j = 0; j < N; j++)

{

if (light (i, j))

value [i][j].set(N);

 

value [i][j] ^= flip [i][j];

 

if (i > 0)

value [i][j] ^= flip [i - 1][j];

 

if (j > 0)

value [i][j] ^= flip [i][j - 1];

 

if (j + 1 < N)

value [i][j] ^= flip [i][j + 1];

}

 

for (int j = 0; j < N; j++)

flip [i + 1][j] = value [i][j];

}

 

bitset<MAXN> constant; constant.reset();

REP(i,N) constant.set(i);

 

vector < bitset<MAXN> > New;

REP(i,N) {

New.PB(flip[N][i] & constant);

last[i] = flip[N][i].test(N);

}

 

int cnt = 0;

 

REP(i,N) REP(j,N) if(Faulty[i][j]) {

New.PB(flip[i][j] & constant);

last[N+cnt++] = flip[i][j].test(N);

}

 

int start = 0; // Gauss Elimination.

for (int i = 0 ; i < N ; ++i ) {

 

// Check for each bit.

int k = -1;

for (int j = start ; j < New.size(); ++j) {

 

if(New[j].test(i)) {

k = j;

break;

}

}

if(k == -1) {

// Every one is already ZERO.

continue;

}

 

swap(New[k], New[start]);

swap(last[k], last[start]);

 

FOR(j,start+1,New.size()) {

// For each succeeding Equation.

if ( New[j].test(i) ) {

// If the ith bit is not zero. Make it Zero.

New[j] = New[j] ^ New[start];

last[j] = last[j] ^ last[start];

}

}

start += 1;

}

 

bool solved = true;

REP(i,New.size()) {

if(last[i] && !New[i].count()) solved = false;

}

 

puts(solved ? "YES" : "NO");

}

return 0;

}

