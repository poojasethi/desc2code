#include <iostream>
#include <cmath>
#include <deque>

using namespace std;
typedef unsigned long long ll;
const ll P = 1000004;
deque <ll> psieve;
bool sieve[P] = {0};

unsigned int witness[] = {2, 3, 5, 7, 11, 13, 17, 19, 21};
ll fact[21] = {1};

ll mulmod(ll a, ll b, ll c)
{
    ll x = 0;
    while (b > 0)
    {
        if (b&1)
            x = (x+a)%c;
        a = (a << 1)%c;
        b >>= 1;
    }
    return x;
}

ll expmod(ll base, ll exp, ll n)
{
    ll x = 1;
    while (exp)
    {
        if (exp&1)
            x = mulmod(x, base, n);
        base = mulmod(base, base, n);
        exp >>= 1;
    }
    return x;
}

bool Witness(ll a, ll s, ll d, ll n)
{
    ll w = expmod(a%n,d,n); ll w_ = w;
    if (w == 1 || w == n-1)
        return 0;
    while(s)
    {
        w = mulmod(w_,w_,n);
        if (w == 1 && w_ != n-1) return 1;
        if (w == 1 && w_ == n-1) return 0;
        w_ = w; s--;
    }
    return 1;
}

bool isPrime(ll p)
{
    if (!(p&1)) return p==2;
    if (!(p%3)) return p==3;
    if (!(p%5)) return p==5;

    ll s = 0, d = p-1, j;
    while (!(d&1))
    {
        s++;
        d >>= 1;
    }

    for (j = 0; j <= 8; j++)
    {
        if (p == witness[j]) return 1;
        if (!(p%witness[j]) || Witness(witness[j], s, d, p))
            return 0;
    }
    return 1;
}

void factAr()
{
    ll i; fact[1] = 1;
    for (i = 2; i < 21; i++)
        fact[i] = i*fact[i-1];
}

ll solve(ll n)
{
    if (n == 4 || n == 1)
        return 1;

    int cnt = 0; ll i;

    for (i = 0; (ll)psieve[i]*psieve[i]*psieve[i] <= n; i++)
    {
        if (n%psieve[i] == 0)
            {
                n /= psieve[i];
                cnt++;
                if (n%psieve[i] == 0)
                    return 0;
            }
    }

    if (n == 1) return fact[cnt];
    if (isPrime(n)) return fact[cnt+1];

    ll s = (ll)sqrt(double(n));
    while (s*s <= n) s++;
    while (s*s > n) s--;
    if (s*s == n) return 0;

    return fact[cnt+2];
}

void makesieve()
{
    sieve[0] = sieve[1] = 1;
    ll i, j;
    for (i = 2; i*i < P; i++)
        if (!sieve[i])
            {
                psieve.push_back(i);
                for (j = i*i; j < P; j+=i)
                    sieve[j] = 1;
            }
    while (i < P)
    {
        if(!sieve[i])
            psieve.push_back(i);
        i++;
    }
}

int main()
{
    makesieve(); factAr(); int t;
    cin >> t; ll sol, n;
    while (t)
    {
        cin >> n;
        sol = solve(n);
        if (sol == 0) cout << -1 << endl;
        else cout << sol << endl;
        t--;
    }
    return 0;
}
