#include <iostream>
#include <cstdio>
#include <cctype>
#include <string>
#include <cmath>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue>
#include <map>
#include <set>
#include <sstream>
#include <ctime>
#include <cassert>

using namespace std;

#define GI ({int t;scanf("%d",&t);t;})
#define GL ({LL t;scanf("%lld",&t);t;})
#define GD ({double t;scanf("%lf",&t);t;})
#define GS ({string s;cin>>s;s;})
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
#define ROF(i,a,b) for(int i=a;i>b;i--)
#define SET(x,a) memset(x,a,sizeof(x));
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define tr(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)
#define pb push_back
#define sz(a) (int)(a.size())
#define INF (int)1e9
#define EPS (double)1e-9
#define is istringstream
#define os ostringstream
#define lb lower_bound
#define ub upper_bound
#define bs binary_search

typedef long long LL;
typedef pair< int,int > ii;
typedef vector< ii > vii;
typedef vector < vii > vvii;
typedef vector< int > vi;
typedef vector< vi > vvi;
typedef vector< string > vs;

char ch;
#define MAXN 2005
int todel[MAXN][MAXN][2];
int len[MAXN][MAXN][2];
int sick[MAXN][MAXN][2];
int n;

int main(){
    int t = GI;
    while(t--){
		string half = "", mhalf = "", shalf = "", s = "", a = "";
		cin >> a;
        n = sz(a);
        REP(i, n + 1)    todel[i][i][0] = 0, todel[i][i][1] = 0, len[i][i][0] = 1, len[i][i][1] = 1;
        REP(i, n)    todel[i + 1][i][0] = 0, todel[i + 1][i][1] = 0;
        ROF(i, n - 1, -1)    FOR(j, i + 1, n)    REP(k, 2){
            todel[i][j][k] = INF;   
            if(k & 1){
                if(a[i] > a[j])    todel[i][j][k] = todel[i + 1][j - 1][1 - k];
                todel[i][j][k] = min(todel[i][j][k], 1 + min(todel[i + 1][j][k], todel[i][j - 1][k]));
                len[i][j][k] = j - i + 1 - todel[i][j][k];
            }
            else{
                if(a[i] < a[j])    todel[i][j][k] = todel[i + 1][j - 1][1 - k];
                todel[i][j][k] = min(todel[i][j][k], 1 + min(todel[i + 1][j][k], todel[i][j - 1][k]));
                len[i][j][k] = j - i + 1 - todel[i][j][k];
            }
        }
        if(len[0][n - 1][0] == 1){
            char cur = '{';
            REP(i, n)    if(a[i] < cur)    cur = a[i];
            printf("%c\n", cur);
        }
        else{
            int ans = len[0][n - 1][0], m = 0, lo = 0, hi = n - 1 , rem = ans, nc = 0, x, y;
            char isok = 'a';
            while(lo <= hi){
                if(len[lo][hi][m] <= 1)    break;
                x = -1;
                FOR(k, lo, hi + 1){
                    if(a[k] == isok){
                        x = k;
                        break;
                    }
                }
                if(x == -1){
                    isok++;
                    continue;
                }
                y = -1;
                if(m & 1){
                    ROF(k, hi, x){
                        if(a[k] < isok){
                            y = k;
                            break;        
                        }
                    }
                }
                else{
                    ROF(k, hi, x){
                        if(a[k] > isok){
                            y = k;
                            break;        
                        }       
                    }     
                }
                if(y == -1){
                    isok++;
                    continue;
                }
                if(len[x + 1][y - 1][1 - m] + 2 == rem){
                    rem -= 2;            
                    half += isok;
                    isok = 'a';
                    lo = x + 1, hi = y - 1;
                    m = 1 - m;
                }
                else{
                    isok++;
                    continue;
                }
            }
            s += half;
            int N = sz(s);
            FOR(i, lo, n + 1)    sick[0][i][0] = 0, sick[0][i][1] = 0;
            FOR(j, 0, N + 1)    sick[j][n][0] = 0, sick[j][n][1] = 0;
            FOR(i, 1, N + 1)    ROF(j, n - 1, lo - 1)    REP(k, 2){
                if(k & 1){
                    if(s[i - 1] > a[j])    sick[i][j][k] = 1 + sick[i - 1][j + 1][1 - k];
                    else sick[i][j][k] = sick[i][j + 1][k];     
                }          
                else{
                    if(s[i - 1] < a[j])    sick[i][j][k] = 1 + sick[i - 1][j + 1][1 - k];
                    else sick[i][j][k] = sick[i][j + 1][k];     
                } 
            }
            int i = sz(s) - 1, j = lo, em = 1 - m, togo = ans - i - 1;
            int how = 0, fpos = lo, apos = lo;
            if(ans % 2)    togo--, j++, fpos++; 
            while(i >= 0 && j < n){
                if(sick[i + 1][j][em] == togo){
                    char cur = '{';
                    int pos = 0;
                    while(sick[i + 1][j][em] == togo && j < n){
                        if(em == 0){
                            if(s[i] < a[j]){
                                if(a[j] < cur){
                                    cur = a[j];
                                    pos = j;        
                                }        
                            }
                        }     
                        else{
                            if(s[i] > a[j]){
                                if(a[j] < cur){
                                    cur = a[j];
                                    pos = j;        
                                }        
                            }
                        }     
                        j++;
                    }
                    shalf += cur;
                    j = pos + 1;
                    how++;
                    if(how == 1)    fpos = j - 1;
                    togo--;          
                    em = 1 - em;
                    i--;
                }         
                else j++; 
            }
            if(ans % 2){
                char cur = '{';
                FOR(q, apos, fpos){
                    if(a[q] < cur)    cur = a[q];
                }
                mhalf += cur;
            }
            printf("%s%s%s\n", half.c_str(), mhalf.c_str(), shalf.c_str());
        }
    }
    //cin >> ch;
    return 0;
}
