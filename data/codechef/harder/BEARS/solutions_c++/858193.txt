
/* C++ template */

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <cstring>
#include <string>
#include <algorithm>
#include <iomanip>
#include <climits>
#include <cassert>

using namespace std;

#define ll long long
#define pii pair<int,int>

/* Main code starts here */

class graph
{
public:
	ll n;
	ll m;
	vector<pii > edge;
	vector<int> degree;
	
	// full transformation
	int trans1(graph &op)
	{
		op.n = m;
		for( int i=0; i<m; i++ ) for( int j=i+1; j<m; j++)
		{
			if(edge[i].first==edge[j].first || edge[i].first==edge[j].second) op.edge.push_back(pii(i,j));
			else if(edge[i].second==edge[j].first || edge[i].second==edge[j].second) op.edge.push_back(pii(i,j));
		}
		op.m = op.edge.size();
		return 0;
	}

	int calc_degree(graph &op)
	{
		degree = vector<int>(n,0);
		for(int i=0;i<m;i++) {
		degree[edge[i].first]++;
		degree[edge[i].second]++;
		}

		op.degree = vector<int>(m,0);
		for(int i=0;i<m;i++) op.degree[i]=degree[edge[i].first]+degree[edge[i].second]-2;
	}

	// only degree of nodes
	int trans2(graph &op)
	{
		calc_degree(op);
		op.n=op.degree.size();
		op.m=0;
		for(int i=0;i<op.n;i++) op.m += op.degree[i]; 
		op.m /= 2;
		return 0;
	}
	
	// only count of n and m
	int trans3(graph &op)
	{
		op.n=m;
		ll ans=0;
		for(int i=0;i<n;i++) ans += degree[i]*(degree[i]-1)/2; 
		op.m=ans;
		return 0;
	}
	
	void clear()
	{
		n=0;
		m=0;
		edge.clear();
		degree.clear();
	}
};

graph g0,g1,g2,g3;

int input()
{
	int a,b;
	
	g0.clear();
	g1.clear();
	g2.clear();
	g3.clear();
	
	scanf("%lld%lld",&g0.n,&g0.m);
	
	for(int i=0; i<g0.m; i++ ) 
	{
		scanf("%d%d",&a,&b);
		g0.edge.push_back(pii(a,b));
	}
	
	return 0;
}

int solve()
{
	g0.trans1(g1);
	g1.trans2(g2);
	g2.trans3(g3);
	printf("%lld %lld\n",g3.n,g3.m);
	return 0;
}

int main()
{
	int test;
	scanf("%d",&test);
	while(test--)
	{
		input();
		solve();
	}
	return 0;
}

