#include <bits/stdc++.h>
using namespace std;
#define add(x) push_back(x)
#define repeat(x) for(int fl = 0;fl <x; fl ++)
#define del() pop_back()
#define left "("
#define right ")"
#define an "and"
#define o "or"
#define no "not"

class node {
	public :
    int type;
    double pb;
    double expec;
    vector<node*> c;
};
void flip(node* n){
	n->pb = 1.0 - n->pb;
}
bool str(node *a, node *b);
bool rev(node *a, node *b);

class myworld{
	public :
	node *root;
	map< string , double > probabilities;
	vector<node*> ev;
	vector<string> tree, statement;
	void construction_of_tree() {
	    repeat(tree.size()) {
			node* n;
	        if(tree[fl] == no) {
	            n = ev.back();
	            if(n->type & 4)flip(n);
	            else n->type = (n->type)^2;
	            continue;
	        } 
	        if(tree[fl] == an) {
	            n = new node;
	            n->type = 0;
	            n->c.clear();
	            n->c.add(ev.back()); ev.del();
	            n->c.add(ev.back()); ev.del();
	            ev.add(n);
	            continue;	            
	        } 
	        if(tree[fl] == o) {
	            n = new node;
	            n->type = 1;
	            n->c.clear();
	            n->c.add(ev.back()); ev.del();
	            n->c.add(ev.back()); ev.del();
	            ev.add(n);
	            continue;
	        }
            n = new node;
            n->type = -1;
            n->pb = probabilities[tree[fl]];
            n->expec = 1;
            n->c.clear();
            ev.add(n);
	    }
	    root = ev.back();
	}
	
	void _removeNot(node *n, bool toNot) {
	    if(n->type == -1) {
	        if(toNot)flip(n);
	        return ;
	    }
	    if(toNot) n->type ^= 2;
	    if(n->type & 2) {
	        n->type ^= (2 | 1);
	        _removeNot(n->c[0], true);
	        _removeNot(n->c[1], true);
	    } else {
	        _removeNot(n->c[0], false);
	        _removeNot(n->c[1], false);
	    }
	}
	
	void toRPN() {
	    vector<string> temp;
	    repeat(statement.size()) {
	        if(statement[fl] == left){
				temp.add(statement[fl]);
				continue;
			}
	        if(statement[fl] == right) {
	            while(!temp.empty() && temp.back() != left) {
	                tree.add(temp.back());
	                temp.del();
	            }
	            temp.del();
	            continue;
	        } 
	        if(statement[fl] == o) {
	            while(!temp.empty() && (temp.back() == an || temp.back() == no)) {
	                tree.add(temp.back());
	                temp.del();
	            }
	            temp.add(statement[fl]);
	            continue;
	        }
	        if(statement[fl] == an) {
	            while(!temp.empty() && temp.back() == no) {
	                tree.add(temp.back());
	                temp.del();
	            }
	            temp.add(statement[fl]);
	            continue;
	        } 
	        if(statement[fl] == no) {
	            temp.add(statement[fl]);
	            continue;
	        } 
	        probabilities[statement[fl]] = 0;
	        tree.add(statement[fl]);
	    }
	    while(!temp.empty()) {
	        tree.add(temp.back());
	        temp.del();
	    }
	}
	 
	void _compressSimple(node *n) {
	    if(n->type == -1) return;
	    vector<node*> compressed_neighbours;
	    for(int i = 0; i < n->c.size(); i++) {
	        node *c = n->c[i];
	        _compressSimple(c);
	        if(c->type == n->type) {
	            for(int j = 0; j < c->c.size(); j++) {
	                node *cc = c->c[j];
	                compressed_neighbours.add(cc);
	            }
	            delete c;
	        } else {
	            compressed_neighbours.add(c);
	        }
	    }
	    n->c = compressed_neighbours;
	}
	 
	void reduceIt() {
	    _removeNot(root, false);
	    _compressSimple(root);
	}
	void clearIt(){
		clearIt(root);
	}
	void clearIt(node *n) {
	    if(n->type == -1) {
	        delete n;
	        return;
	    }
	    for(int i = 0; i < n->c.size(); i++) {
	        node *c = n->c[i];
	        clearIt(c);
	    }
	    delete n;
	}
	void evalIt(){
		evalIt(root);
	}
	
	void evalIt(node *n) {
	    if(n->type == -1) return;
	    if(n->type == 0) {
	        for(int i = 0; i < n->c.size(); i++) {
	            node *c = n->c[i];
	            evalIt(c);
	        }
	        sort(n->c.begin(), n->c.end(), str );
	        double r = n->c.back()->expec;
	        double pr = n->c.back()->pb;
	        for(int i = n->c.size() - 2; i >= 0; i--) {
	            node *c = n->c[i];
	            r *= c->pb ;
	            r += c->expec;
	            pr *= c->pb ;
	        }
	        n->expec = r;
	        n->pb = pr;
	    } else {
	        for(int i = 0; i < n->c.size(); i++) {
	            node *c = n->c[i];
	            evalIt(c);
	        }
	        sort(n->c.begin(), n->c.end(), rev );
	        double r = n->c.back()->expec;
	        double pr = 1.0 - n->c.back()->pb;
	        for(int i = n->c.size() - 2; i >= 0; i--) {
	            node *c = n->c[i];
	            r *= 1.0 - c->pb ;
	            r += c->expec;
	            pr *= 1.0 - c->pb ;
	        }
	        n->expec = r;
	        n->pb = 1.0 - pr;
	    }
	}
}; 
bool str(node *a, node *b) {
	double pnega = 1.0- a->pb;
	double pnegb = 1.0 - b->pb;
	if((a->expec/pnega) < (b->expec / pnegb))return true;
	else return false;
}
	 
bool rev(node *a, node *b) {
    if((a->expec / a->pb) < (b->expec / b->pb))return true;
    else return false;
}
	
int main() {
    int T;
    cin>>T;
    string asdf;
    getline(cin,asdf);//to avoid the new line
    repeat(T) {
		myworld mw;
        string temp,temp2="";mw.statement.clear();
        getline(cin,temp);
        for(int i = 0; i<temp.length(); i++) {
			if(temp[i]=='(' || temp[i]==')'){
				if(temp2 !="")mw.statement.add(temp2);
				if(temp[i]=='(')mw.statement.add(left);
				if(temp[i]==')')mw.statement.add(right);
				temp2="";
			}
            else if(temp[i]==' ') {
                if(temp2 != "")mw.statement.add(temp2);
                temp2="";
            } 
            else{
				temp2 += temp[i];
           }
        }
        if(temp2 != "")mw.statement.add(temp2);
        mw.toRPN();
        for(int i = 0; i < mw.probabilities.size(); i++) {
            string v; double p;
            cin >> v >> p;
            mw.probabilities[v] = p;
        }
        mw.construction_of_tree();mw.reduceIt();mw.evalIt();
        double ret = mw.root->expec;
        cout << fixed << setprecision(6) << ret << endl;
        mw.clearIt();
        getline(cin,temp);
    }
    return 0;
}
 
