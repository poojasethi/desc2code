#include <bits/stdc++.h>
using namespace std;
#define add(x) push_back(x)
#define repeat(x) for(int fl = 0;fl <x; fl ++)
#define del() pop_back()
#define left "("
#define right ")"
#define an "and"
#define o "or"
#define no "not"
#define pi 3.14159265358
#define print cout<<i;
#define $ "  "

class node {
	public :    
	vector<node*> c;
    short type;
    double pb;
    double expec;
};
void flip(node* n){
	n->pb = 1.0 - n->pb;
}
bool str(node *a, node *b);
bool rev(node *a, node *b);

class myworld{
	public :
	node *root;
	map< string , double > probabilities;
	vector<node*> ev;
	vector<string> tree, statement;
	void input_analyse() {
	    vector<string> temp;
	    repeat(statement.size()) {
	        if(statement[fl] == left){
				temp.add(statement[fl]);
				continue;
			}
	        if(statement[fl] == right) {
	            while(!temp.empty() && temp.back() != left) {
	                tree.add(temp.back());
	                temp.del();
	            }
	            temp.del();
	            continue;
	        } 
	        if(statement[fl] == o) {
	            while(!temp.empty() && (temp.back() == an || temp.back() == no)) {
	                tree.add(temp.back());
	                temp.del();
	            }
	            temp.add(statement[fl]);
	            continue;
	        }
	        if(statement[fl] == an) {
	            while(!temp.empty() && temp.back() == no) {
	                tree.add(temp.back());
	                temp.del();
	            }
	            temp.add(statement[fl]);
	            continue;
	        } 
	        if(statement[fl] == no) {
	            temp.add(statement[fl]);
	            continue;
	        } 
	        probabilities[statement[fl]] = 0;
	        tree.add(statement[fl]);
	    }
	    while(!temp.empty()) {
	        tree.add(temp.back());
	        temp.del();
	    }
	}
	 
	void construction_of_tree() {
	    repeat(tree.size()) {
			node* n;
	        if(tree[fl] == no) {
	            n = ev.back();
	            if(n->type & 4)flip(n);
	            else n->type = (n->type)^2;
	            continue;
	        } 
	        if(tree[fl] == an) {
	            n = new node;
	            n->type = 0;n->c.clear();
	            n->c.add(ev.back()); ev.del(); n->c.add(ev.back()); ev.del(); ev.add(n);
	            continue;	            
	        } 
	        if(tree[fl] == o) {
	            n = new node;
	            n->type = 1;n->c.clear();
	            n->c.add(ev.back()); ev.del();n->c.add(ev.back()); ev.del(); ev.add(n);
	            continue;
	        }
            n = new node;
            n->type = -1;n->pb = probabilities[tree[fl]];n->expec = 1;
            n->c.clear();ev.add(n);
	    }
	    root = ev.back();
	}
	
	void reduce(node *n, bool toNot) {
	    if(n->type == -1) {
	        if(toNot==true)flip(n);return ;
	    }
	    if(toNot)n->type = n->type^2;
	    if(n->type & 2) {
	        n->type = n->type^(1 | 2);
	        reduce(n->c[0], true); reduce(n->c[1], true);
	    } 
	    else {
	        reduce(n->c[0], false); reduce(n->c[1], false);
	    }
	}
	
	void simplify(node *n) {
	    if(n->type != -1) {
		    vector<node*> compressed_neighbours;
		    for(int i = 0; i < n->c.size(); i++) {
		        node *temp = n->c[i];
		        simplify(temp);
		        if(temp->type == n->type) {
		            for(int j = 0; j < temp->c.size(); j++) {
		                node *cc = temp->c[j];
		                compressed_neighbours.add(cc);
		            }
		            delete temp;
		        } else {
		            compressed_neighbours.add(temp);
		        }
		    }
		    n->c = compressed_neighbours;
		}
	}
	 
	void reduceIt() {
	    reduce(root, false);
	    simplify(root);
	}

	void find_answer(){
		find_answer(root);
	}
	
	void find_answer(node *n) {
	    if(n->type == -1) return;
	    if(n->type == 0) {
	        for(int i = 0; i < n->c.size(); i++) {
	            node *c = n->c[i];
	            find_answer(c);
	        }
	        sort(n->c.begin(), n->c.end(), str );
	        double r = n->c.back()->expec;
	        double pr = n->c.back()->pb;
	        for(int i = n->c.size() - 2; i >= 0; i--) {
	            node *c = n->c[i];
	            r *= c->pb ;
	            r += c->expec;
	            pr *= c->pb ;
	        }
	        n->expec = r;
	        n->pb = pr;
	    } else {
	        for(int i = 0; i < n->c.size(); i++) {
	            node *c = n->c[i];
	            find_answer(c);
	        }
	        sort(n->c.begin(), n->c.end(), rev );
	        double r = n->c.back()->expec;
	        double pr = 1.0 - n->c.back()->pb;
	        for(int i = n->c.size() - 2; i >= 0; i--) {
	            node *c = n->c[i];
	            r *= 1.0 - c->pb ;
	            r += c->expec;
	            pr *= 1.0 - c->pb ;
	        }
	        n->expec = r;
	        n->pb = 1.0 - pr;
	    }
	}
}; 
bool str(node *a, node *b) {
	double pnega = 1.0- a->pb;
	double pnegb = 1.0 - b->pb;
	if((a->expec/pnega) < (b->expec / pnegb))return true;
	else return false;
}
	 
bool rev(node *a, node *b) {
    if((a->expec / a->pb) < (b->expec / b->pb))return true;
    else return false;
}
	
int main() {
    int test;cin>>test;
    string asdf;
    getline(cin,asdf);//to avoid the new line
    repeat(test) {
		myworld mw;
        string temp,temp2="";mw.statement.clear();
        getline(cin,temp);
        for(int i = 0; i<temp.length(); i++) {
			if(temp[i]=='(' || temp[i]==')'){
				if(temp2 !="")mw.statement.add(temp2);
				if(temp[i]=='(')mw.statement.add(left);
				if(temp[i]==')')mw.statement.add(right);
				temp2="";
			}
            else if(temp[i]==' ') {
                if(temp2 != "")mw.statement.add(temp2);
                temp2="";
            } 
            else{
				temp2 += temp[i];
           }
        }
        if(temp2 != "")mw.statement.add(temp2);
        mw.input_analyse();
        for(int i = 0; i < mw.probabilities.size(); i++) {
            string v; double p;
            cin >> v >> p;
            mw.probabilities[v] = p;
        }
        mw.construction_of_tree();mw.reduceIt();mw.find_answer();
        double ret = mw.root->expec;
        cout << fixed << setprecision(6) << ret << endl;
        getline(cin,temp);
    }
}
