#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define m	55
#define unt	unsigned int
#define For(i,a,b)	for(int i=a;i<=b;i++)

unt		S[2005];
int		N,M,T,test,Q[2],B[m],p[m];
struct	Nod{unt sta,tot;}Bas[2005],F[2][10000005];
char	A[m][m],ss[1005][m];
bool	V[2005];

bool	Cmp(int a,int b)	{return	B[a]<B[b];}
bool	Cmp1(Nod a,Nod b)	{return	a.tot<b.tot;}
bool	Cmp2(Nod a,Nod b)	{
		return	a.sta<b.sta||a.sta==b.sta&&a.tot<b.tot;
}
bool	Cmp3(Nod a,Nod b)	{return	a.sta>b.sta;}

int		main(){
	//	freopen("allegro.in","r",stdin);
	//	freopen("allegro.out","w",stdout);
		for	(scanf("%d",&test);test--;T=0){
			scanf("%d%d",&N,&M);	int D=(1<<N)-1,num=0;
			For(i,1,M)	scanf("%s",ss[i]+1);
			if	(!M)	{puts("0");continue;}
			For(i,1,M){
				int zyb=1;
				For(j,1,num){
					int flag=1;
					For(k,1,N)	if	(A[j][k]!=ss[i][k])	{flag=0;break;}
					if	(flag)	{zyb=0;break;}
				}
				if	(zyb)	{
					num++;	For(j,1,N)	A[num][j]=ss[i][j];
				}
			}	M=num;
			if	(M==(1<<N))	{puts("0");continue;}

			For(i,0,D)	{
				For(j,1,M)	B[j]=0,p[j]=j;	int cnt=N,len=0;
				For(j,1,N)	if	((1<<j-1)&i){
					cnt--;	len++;
					For(k,1,M)	if	(A[k][j]<'a')	B[k]|=1<<j;
				}	cnt=1<<cnt;

				sort(p+1,p+M+1,Cmp);
				for	(int i=1,j;i<=M;i=j+1){
					for	(j=i;j<M&&B[p[j+1]]==B[p[i]];j++);
					if	(j-i+1!=cnt)	continue;	Bas[++T]=(Nod){0,len};
					For(k,i,j)	Bas[T].sta|=1ll<<p[k]-1;
				}
			}

			F[0][Q[0]=1]=(Nod){0,0};
			sort(Bas+1,Bas+T+1,Cmp3);
			unt Ans=1<<30,U=(1ll<<M)-1;
			For(i,1,T)	V[i]=0;	S[T+1]=D=0;
			For(i,1,T)	For(j,1,T)	if	(i^j)
				if	((Bas[i].sta&Bas[j].sta)==Bas[j].sta)	V[j]=1;
			for	(int i=T;i;i--)	S[i]=S[i+1]|Bas[i].sta;

			For(i,1,T)	if	(!V[i]){
				int p=(++D)&1,q=p^1,Now=0;	Q[p]=0;
				For(j,1,Q[q])	if	((F[q][j].sta|S[i])==U){
					if	(F[q][j].tot<Ans)	F[p][++Q[p]]=F[q][j];
						else continue;
					if	(F[q][j].tot+Bas[i].tot>=Ans)	continue;
					if	((F[q][j].sta&Bas[i].sta)==Bas[i].sta)	continue;
					F[p][++Q[p]]=(Nod){F[q][j].sta|Bas[i].sta,F[q][j].tot+Bas[i].tot};
					if	(F[p][Q[p]].sta==U)	Ans=min(Ans,F[p][Q[p]].tot);
				}

				sort(F[p]+1,F[p]+Q[p]+1,Cmp2);
				For(j,1,Q[p])
					if	(j==1||F[p][j].sta!=F[p][j-1].sta)	F[p][++Now]=F[p][j];
				Q[p]=Now;
			}	printf("%d\n",(int)Ans);
		}
}
