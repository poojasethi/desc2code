#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<set>
#include<map>
#include<vector>
#define N 1205
#define D 777 
#define mo
#define For(i,l,r) for(int i=l;i<=r;i++)
#define Dor(i,r,l) for(int i=r;i>=l;i--)
using namespace std;
bool cmp(const int &i,const int &j){return i>j;}
map < unsigned int ,int > G[505][D+5];
map < unsigned int ,int > :: iterator Rzz;
int n,m,Ans=1000000,Q[N]; unsigned int P[N];
int Sum,Cnt,Num[N],F[N][N],inf;
int son[N],next[N*N],ed[N*N],cnt,du[N];
void dfs(int x,unsigned int S,int Ret){
	if(Ret>=Ans) return;
	if( S==(1LL<<inf)-1 ){Ans=Ret; return;}
	if(x>m) return;
	
	Rzz=G[x][S%D].find(S);
	if(Rzz!=G[x][S%D].end() && Rzz->second<=Ret) return;
	G[x][S%D][S]=Ret;
	
	for(int i=son[x];i;i=next[i]) du[ed[i]]--;
	

	int flag=1;
	for(int i=son[x];i;i=next[i])
	if(!(S&(1LL<<ed[i]-1)) && !du[ed[i]]){flag=0; break;}
	
	if(flag) dfs(x+1,S,Ret);
	
	
	if( (S&P[x])!=P[x] ) dfs(x+1,S|P[x],Ret+Num[Q[x]]);
	
	
	for(int i=son[x];i;i=next[i]) du[ed[i]]++;
}
bool biaoshi(int S,int T){
	For(i,1,n){
		int PS=S%3; S/=3;
		int PT=T%3; T/=3;
		if(PT && PS!=PT) return 0;
	}
	return 1;
}
void Link(int x,int y){next[++cnt]=son[x]; son[x]=cnt; ed[cnt]=y;}
int Tmp[N];
void writeln(int S){
	For(i,1,n){
		Tmp[i]=S%3; S/=3;
	}
	Dor(i,n,1) printf("%d",Tmp[i]);
}
char s[N]; int Val[N];
int main(){
	int Q_Q; scanf("%d",&Q_Q);
	while(Q_Q--){
		scanf("%d%d",&n,&m);
		For(t,1,m){
			int Ret=0; scanf("%s",s);
			For(i,0,n-1) Ret=Ret*3+(s[i]=='A'+i)+1; Val[t]=Ret;
		}
		
		
		sort(Val+1,Val+1+m); inf=unique(Val+1,Val+1+m)-Val-1; m=0;
		Sum=1; For(i,1,n) Sum*=3; Sum--;
		
		For(S,0,Sum) For(T,0,Sum) F[S][T]=biaoshi(S,T);
		
		For(S,0,Sum){
			int Time=0; unsigned int Ret=0;
			Num[S]=Num[S/3]+(S%3!=0);
			
			int flag=0;
			For(i,1,m) if(F[S][Q[i]]){flag=1; break;}
			if(flag) continue;
			
			For(t,1,inf) if(F[Val[t]][S]){
				Time++;
				Ret|=(1LL<<t-1);
			}
			if( Time == (1<<n-Num[S]) ) Q[++m]=S,P[m]=Ret;
			else continue;
		}
		
		For(i,1,m){
			int S=Q[i]; For(t,1,inf) if(F[Val[t]][S]) du[t]++,Link(i,t);
		}
		
		dfs(1,0,0);
		
		printf("%d\n",Ans);
		
		For(i,1,m) For(S,0,D-1) G[i][S].clear();
		For(i,1,m) son[i]=0; cnt=0;
		For(t,1,inf) du[t]=0;
		Ans=1000000;
	}
	
}