#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <utility>
#include <algorithm>

using namespace std;

typedef long long ll;
typedef pair<int, int> Pair;
const int kMaxN = 100000;
int n, a[kMaxN + 1], b[kMaxN + 1], na[kMaxN + 1], nb[kMaxN + 1];
int sa[kMaxN + 1], sb[kMaxN + 1];
int axis[kMaxN + 1], m;
int ssa[kMaxN + 1];

int Count(int x, int d) {
	int res = 0;
	while (x) {
		if ((x % 10) == d) ++ res;
		x /= 10;
	}
	return res;
}

int Pow(int a, int b) {
	int res = 1;
	while (b --) res *= a;
	return res;
}

struct IndexTree {
#define LB(x) ((x) & (-(x)))
	int v[kMaxN + 2];
	void clear() {
		memset(v, 0, sizeof(v));
	}
	void add(int i, int d) {
		for (++ i; i <= m; i += LB(i))
			v[i] += d;
	}
	int sum(int i) {
		int res = 0;
		for (++ i; i; i -= LB(i))
			res += v[i];
		return res;
	}
#undef LB
} idt;

int main() {
	//freopen("t.in", "r", stdin);
	int t;
	for (scanf("%d", &t); t --; ) {
		scanf("%d", &n);
		for (int i = 1, x; i <= n; ++ i) {
			scanf("%d", &x);
			a[i] = Count(x, 4);
			b[i] = Count(x, 7);
		}
		for (int i = 1; i <= n; ++ i) {
			sa[i] = sa[i - 1] + a[i];
			sb[i] = sb[i - 1] + b[i];
		}
		int next;
		next = n + 1;
		for (int i = n; i >= 1; -- i) {
			na[i] = next;
			if (a[i]) next = i;
		}
		next = n + 1;
		for (int i = n; i >= 1; -- i) {
			nb[i] = next;
			if (b[i]) next = i;
		}
		ll res = 0;
		for (int i = 1; i <= n; ++ i)
			if (!a[i]) {
				res += na[i] - i - (upper_bound(sb + i, sb + na[i], sb[i - 1] + 2) - lower_bound(sb + i, sb + na[i], sb[i - 1] + 2));
			}
		for (int i = 1; i <= n; ++ i) {
			int lb = lower_bound(sa + i, sa + n + 1, sa[i - 1] + 1) - sa;
			int rb = upper_bound(sa + i, sa + n + 1, sa[i - 1] + 1) - sa;
			res += rb - lb - (upper_bound(sb + lb, sb + rb, sb[i - 1] + 2) - lower_bound(sb + lb, sb + rb, sb[i - 1] + 2));
		}
		m = 0;
		for (int i = 0; i <= n; ++ i) axis[m ++] = sa[i] - i;
		sort(axis, axis + m);
		m = unique(axis, axis + m) - axis;
		for (int i = 0; i <= n; ++ i) ssa[i] = lower_bound(axis, axis + m, sa[i] - i) - axis;
		idt.clear();
		int last_l = 0, last_k = 0;
		for (int i = 1; i <= n; ++ i) {
			if (sa[n] - sa[i - 1] < 3) break;
			int j = lower_bound(sa + i, sa + n + 1, sa[i - 1] + 3) - sa;
			if (sb[j] - sb[i - 1] > 1) continue;
			int k = upper_bound(sb + i, sb + n + 1, sb[i - 1] + 1) - sb;
			int l = lower_bound(sb + i, sb + n + 1, sb[i - 1] + 1) - sb;
			k = max(j, k), l = max(j, l);
			res += l - j;
			int upper = ssa[i - 1];
			if (last_l == 0) {
				for (int j = l; j < k; ++ j) idt.add(ssa[j], 1);
				last_l = l, last_k = k;
			}
			else {
				for (int j = last_l; j < l; ++ j) idt.add(ssa[j], -1);
				for (int j = last_k; j < k; ++ j) idt.add(ssa[j], 1);
				last_l = l, last_k = k;
			}
			res += idt.sum(upper);
		}
		for (int i = 1; i <= n; ++ i) {
			if (sa[n] - sa[i - 1] < 3) break;
			if (sb[n] - sb[i - 1] < 3) break;
			int j = lower_bound(sa + i, sa + n + 1, sa[i - 1] + 3) - sa;
			j = max(j, lower_bound(sb + i, sb + n + 1, sb[i - 1] + 3) - sb);
			int ca = sa[j] - sa[i - 1], cb = sb[j] - sb[i - 1];
			while (true) {
				if (pow(ca, cb) > n + 1E-6) break;
				if (j > n) break;
				int k = min(na[j], nb[j]);
				if (cb != 2) {
					int lim = Pow(ca, cb);
					res += max(0, min(k - j, k - i - lim + 1));
				}
				if (k <= n) {
					ca += a[k];
					cb += b[k];
				}
				j = k;
			}
		}
		printf("%lld\n", res);
	}
	return 0;
}