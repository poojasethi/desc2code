#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;

#define REP0(i, n) for (int i = 0; i < n; i++)
#define REP1(i, n) for (int i = 1; i <= n; i++)
#define REP(i, l, r) for (int i = l; i <= r; i++)
#define RP(i, r, l) for (int i = r; i >= l; i--)
#define FORE(i, x) for (int i = fi[x]; i != -1; i = e[i].n)

#define MAX_N 110000
#define oo 0x7fffffff
#define A first
#define B second
#define MP make_pair

typedef pair < int, int > PT;
struct nodeE { int t, n; } e[MAX_N << 1];
int wi[MAX_N], fi[MAX_N];
int n, m, tot;

inline void insert(int x, int y) { e[++tot] = (nodeE) { y, fi[x] }, fi[x] = tot; }
namespace DFS
{
	struct BIT
	{
	   	int a[MAX_N];
	   	void add(int x, int y) { while (x <= n) a[x] += y, x += x & -x; }
	   	int get(int x) { int t = 0; while (x) t += a[x], x -= x & -x; return t; }
	} ss;
	int q[MAX_N], ls[MAX_N], rs[MAX_N], tot;
	void DFS(int x, int fa = -1)
	{
		 q[ls[x] = ++tot] = x;
		 FORE(i, x) if (e[i].t != fa) DFS(e[i].t, x);
		 rs[x] = tot;
	}	
	void add(int x) { ss.add(ls[x], 1); }
	int get(int x) { return ss.get(rs[x]) - ss.get(ls[x] - 1); }
}

namespace BFS
{
	int q[MAX_N], id[MAX_N], fa[MAX_N], ls[MAX_N], rs[MAX_N];
	typedef struct node* ntp;
    ntp ta, rt;
	struct node
	{
		ntp lc, rc; int l, r, mid, fl;  PT s;
		inline void upd(void)
        {
               if (!lc->s.B) s = rc->s;
               else if (!rc->s.B) s = lc->s;
               else s = min(lc->s, rc->s);
               if (!s.B) s.A = oo;
        }
		void build(int x, int y)
		{
			l = x, r = y, mid = (x + y) >> 1, fl = 0;
			if (x == y) { s = MP(wi[q[x]], q[x]); return ; }
			(lc = ++ta)->build(l, mid), (rc = ++ta)->build(mid + 1, r), upd();
		}
		inline void push(void)
		{ lc->s.A += fl, rc->s.A += fl, lc->fl += fl, rc->fl += fl, fl = 0; }
		void modify(int x, int y, int z)
		{
			if (x <= l && r <= y) { s.A += z, fl += z; return ; }
			push();
			if (x <= mid) lc->modify(x, y, z);
			if (y > mid) rc->modify(x, y, z);
			upd();
		}
		void del(int x)
		{
			 if (l == r) { s = MP(oo, 0); return ; }
			 push(); if (x <= mid) lc->del(x); else rc->del(x);   upd();
		}
	} ua[MAX_N << 1];
	void BFS(int x)
	{
		 fill(fa, fa + n + 1, -1), fa[q[1] = x] = 0;
		 for (int h = 1, t = 1, x, tt; h <= t; h++)
		 {
			 ls[x = q[h]] = t + 1, id[x] = h;
			 FORE(i, x) if (fa[tt = e[i].t] == -1) fa[q[++t] = tt] = x;
			 rs[x] = t;
		 }
	//	 REP1(i, n) printf ("%d ", q[i]); puts("");
		 (rt = ta = ua)->build(1, n);
	}
	void modify(int x, int a, int b)
	{
         //printf ("%d %d %d[%d %d]\n", a, b, -x, ls[a], ls[b]);
		 if (!x || a > b) return ;
		// printf ("%d %d %d[%d %d]\n", a, b, -x, ls[q[a]], rs[q[b]]);
		 rt->modify(a, b, -x), modify(x >> 1, ls[q[a]], rs[q[b]]);
	}
	void maintain(void)
	{ while (rt->s.A <= 0) { int x = rt->s.B;/* printf ("Del %d %d\n", rt->s.A, x);*/ rt->del(id[x]), DFS::add(x); } }
	void modify(int x, int y)
	{
		// printf ("%d %d\n", id[x], -y);
		 rt->modify(id[x], id[x], -y), y >>= 1;
		 if (y) modify(y, ls[x], rs[x]);
		 for (int i = fa[x]; i && y; x = i, i = fa[i], y >>= 1)
		 {
			rt->modify(id[i], id[i], -y);
		//		 printf ("%d %d\n", id[i], -y);
		//	printf ("KK %d %d %d[%d %d] [%d %d]\n", x, i, y >> 1, ls[i], id[x] - 1, id[x] + 1, rs[i]);
		 	modify(y >> 1, ls[i], id[x] - 1), modify(y >> 1, id[x] + 1, rs[i]);
		 }
		 maintain();
	}
}

int main(void)
{
    scanf("%d", &n), tot = 1, fill(fi, fi + n + 1, -1);
    REP1(i, n) scanf("%d", wi + i);
    REP1(i, n - 1) { int x, y; scanf ("%d%d", &x, &y), insert(x, y), insert(y, x); }
    BFS::BFS(1), DFS::DFS(1);
    scanf ("%d", &m);
    REP1(i, m)
    {
		int t, x, y; scanf ("%d%d", &t, &x);
		if (t == 1) scanf("%d", &y), BFS::modify(x, y);
		else if (t == 2) printf ("%d\n", DFS::get(x));
	}
    return 0;
}
