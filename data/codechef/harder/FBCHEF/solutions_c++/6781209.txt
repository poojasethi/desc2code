#include <set>
#include <map>
#include <vector>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

const int nn = 110000;

ll mi[nn*4], o[nn*4], add[nn*4];
int w[nn], value[nn], L[nn][32], R[nn][32], le[nn], ri[nn], fa[nn], q[nn], d[nn], v[nn];
int N;
vector<int> e[nn];

void build(int p, int l, int r) {
	add[p] = 0;
	if (l == r) {
		mi[p] = value[w[l]];
		o[p] = l;
		return;
	}
	int mid = l+r>>1, lc = p<<1, rc = lc+1;
	build(lc, l, mid);
	build(rc, mid+1, r);
	mi[p] = 1ll<<60;
	if (mi[lc] < mi[p]) mi[p] = mi[lc], o[p] = o[lc];
	if (mi[rc] < mi[p]) mi[p] = mi[rc], o[p] = o[rc];
}
void update(int p, int l, int r, int x, int y, ll z) {
	if (y < l || r < x) return;
	if (x <= l && r <= y) {
		add[p] += z;
		mi[p] += z;
		return;
	}
	int mid = l+r>>1, lc = p<<1, rc = lc+1;
	if (add[p]) {
		add[lc] += add[p]; mi[lc] += add[p];
		add[rc] += add[p]; mi[rc] += add[p];
		add[p] = 0;
	}
	update(lc, l, mid, x, y, z);
	update(rc, mid+1, r, x, y, z);
	mi[p] = 1ll<<60;
	if (mi[lc] < mi[p]) mi[p] = mi[lc], o[p] = o[lc];
	if (mi[rc] < mi[p]) mi[p] = mi[rc], o[p] = o[rc];
}
struct FTREE {
	int C[nn];
	void insert(int x) {
		for (; x <= N; x += x & -x) C[x]++;
	}
	int query(int x) {
		int res = 0;
		for (; x; x -= x & -x) res += C[x];
		return res;
	}
} ftree;
void query() {
	while (mi[1] <= 0) {
		ftree.insert(le[w[o[1]]]);
		update(1, 1, N, o[1], o[1], (ll)1e18);
	}
	int x; scanf("%d", &x);
	printf("%d\n", ftree.query(ri[x]) - ftree.query(le[x]-1));
}
void put(int x, int y) {
	for (int i = 0; y; ++i, y /= 2) {
		if (L[x][i] > R[x][i]) break;
		update(1, 1, N, L[x][i], R[x][i], y);
	//	cout << L[x][i] << ' ' << R[x][i] << ' ' << y << endl;
	}
}
void work() {
	int x, y;
	scanf("%d%d", &x, &y);
	for (int last = -1; y && x; last = x, x = fa[x], y >>= 1) {
		put(x, -y);
		if (last > 0) put(last, y >> 1);
	}
}
int oo;
void dfs(int x) {
	le[x] = ++oo;
	for (int i = 0; i < e[x].size(); ++i) {
		int j = e[x][i];
		if (j == fa[x]) continue;
		dfs(j);
	}
	ri[x] = oo;
}
int main() {
	
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i) scanf("%d", &value[i]);
	for (int i = 1; i < N; ++i) {
		int x, y;
		scanf("%d%d", &x, &y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	
	memset(L, 0x7f, sizeof(L));
	memset(R, 0, sizeof(R));
	memset(le, 0x7f, sizeof(le));
	memset(ri, 0, sizeof(ri));
	
	int l = 0, r = 1;
	q[1] = 1; v[1] = 1; d[1] = 1;
	while (l < r) {
		int x = q[++l];
		le[x] = ri[x] = l;
		w[l] = x;
		for (int i = 0, xx = x; xx && i <= 30; ++i, xx = fa[xx]) {
			L[xx][i] = min(L[xx][i], l);
			R[xx][i] = max(R[xx][i], l);
		}
		for (int i = 0; i < e[x].size(); ++i) {
			int j = e[x][i];
			if (v[j]) continue;
			d[j] = d[x] + 1;
			v[j] = 1;
			fa[j] = x;
			q[++r] = j;
		}
	}
	dfs(1);
	build(1, 1, N);
	
	
	int Q; scanf("%d", &Q);
	while (Q--) {
		int k; scanf("%d", &k);
		if (k == 2) {
			query();
			continue;
		}
		work();
	}
	return 0;
}