#include <algorithm>
#include <iostream>
#include <utility>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <cassert>
#include <iomanip>                          
#include <vector>
#include <string>
#include <cstdio>
#include <cmath>
#include <queue>
#include <ctime>
#include <stack>
#include <set>
#include <map>
 
using namespace std;
 
#define name ""
#define ll long long
#define ull unsigned ll
#define inf 1000000000
#define INF 1000000000000000000ll
#define F first
#define S second
#define mp make_pair
#define pb push_back

const int N = 10005;
const int M = 50005;

int p[N], rank[N];
bool have_cycle[N];

inline void make_set(int x){
	p[x] = x;
	rank[x] = 1;
	have_cycle[x] = false;
}

int find_set(int x){
	if(p[x] == x)
		return x;
	return p[x] = find_set(p[x]);
}

int t;
int n, m;
pair < int , pair < int , int > > edges[M];
 
int main (){	
    #ifndef ONLINE_JUDGE
    freopen ("in", "r", stdin);
    freopen ("out", "w", stdout);
    #endif
    scanf("%d", &t);
    while(t --){
    	scanf("%d%d", &n, &m);
    	for(int i = 1;i <= n;++ i)
    		make_set(i);
    	for(int i = 1;i <= m;++ i)
    		scanf("%d%d%d", &edges[i].S.F, &edges[i].S.S, &edges[i].F);
		sort(edges + 1, edges + m + 1, greater < pair < int , pair < int , int > > > ());
		int res = 0, cnt_added_edge = 0;
		for(int i = 1;i <= m;++ i){
			if(cnt_added_edge + (m - i + 1) < n)
				break;			
			pair < int , int > e = edges[i].S;
			int a = find_set(e.F), b = find_set(e.S);
			if(a == b){
				if(have_cycle[a])
					continue;
				have_cycle[a] = true;
				res += edges[i].F;
				++ cnt_added_edge;
			}
			else {
				if((have_cycle[a] & have_cycle[b]))
					continue;
				if(rank[a] > rank[b])
					swap(a, b);
				if(rank[a] == rank[b])
					++ rank[b];
				p[a] = b;
				have_cycle[b] |= have_cycle[a];
				res += edges[i].F;
				++ cnt_added_edge;
			}
		}
		if(cnt_added_edge < n)
			puts("impossible");
		else
			printf("%d\n", res);
    }
	return 0;
} 