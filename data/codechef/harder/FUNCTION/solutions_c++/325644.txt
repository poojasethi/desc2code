#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;

#define rep(i,n) for(int i=0;i<(n);++i)
#define clr(a,v) memset(a,v,sizeof(a))

int const max_n = 10100;
int const max_m = 50100;

int par[max_n], lvl[max_n], cyc[max_n];

int root(int i){
    if(par[i] != par[par[i]]) par[i] = root(par[i]);
    return par[i];
}

void merge(int a, int b){
    if(lvl[a] < lvl[b]) par[a] = b, cyc[b] |= cyc[a];
    else{
        par[b] = a, cyc[a] |= cyc[b];
        if(lvl[a] == lvl[b]) lvl[a]++;
    }
}

struct edge_t{
    int a, b, v;
    bool operator<(edge_t const &e) const
    { return v > e.v; }
} edge[max_m];

void doit(){
    int n, m;
    scanf("%d%d", &n, &m);
    rep(i, n+1) par[i] = i, lvl[i] = 0, cyc[i] = 0;
    
    rep(i, m) scanf("%d%d%d", &edge[i].a, &edge[i].b, &edge[i].v);
    sort(edge, edge + m);
    
    int res = 0, e = 0;
    rep(i, m){
        int a = root(edge[i].a), b = root(edge[i].b);
        if(a != b){
            if(!(cyc[a] && cyc[b])){
                res += edge[i].v;
                e++;
                merge(a, b);
            }
             
        }else{
            if(!cyc[a]){
                res += edge[i].v;
                e++;
                
                cyc[a] = 1;    
            }
        }
    }
    
    if(e < n) 
        printf("impossible\n");
    else
        printf("%d\n", res);
}

int main(){
    int t; scanf("%d", &t);
    while(t--) doit();
}
