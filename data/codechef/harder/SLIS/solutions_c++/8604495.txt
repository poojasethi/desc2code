#include<cstdio>
#include<vector>
#include<map>
#include<set>
#include<algorithm>
using namespace std;
#define getcx getchar
inline void in(int &n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
int a[100005],b[100005];
int memoFirst[400005],memoSecond[400005],cntFirst[400005],cntSecond[400005];
#define pii pair< int , int >
void init(int node,int s,int e)
{
    if(s==e)
    {
        memoFirst[node]=0;
        memoSecond[node]=0;
        cntFirst[node]=0;
        cntSecond[node]=0;
        return;
    }
    int mid=(s+e)>>1;
    int lc=node<<1;
    int rc=1+lc;
    init(lc,s,mid);
    init(rc,mid+1,e);
    memoFirst[node]=0;
    memoSecond[node]=0;
    cntFirst[node]=0;
    cntSecond[node]=0;
    return;
}
#define mod 1000000007
void update(int node,int s,int e,int pos,pair< pii , pii > &res)
{
    if(s>pos || e<pos)
    {
        return;
    }
    if(s==e && e==pos)
    {
        pair< int , int > p,q;

        p.first=memoFirst[node];
        p.second=cntFirst[node];

        q.first=memoSecond[node];
        q.second=cntSecond[node];

        memoFirst[node]=max( max(p.first,q.first) , max(res.first.first,res.second.first) );
        cntFirst[node]=0;
        if(p.first==memoFirst[node])
        {
            cntFirst[node]+=p.second;
            if(cntFirst[node]>=mod)
                cntFirst[node]%=mod;
        }
        if(q.first==memoFirst[node])
        {
            cntFirst[node]+=q.second;
            if(cntFirst[node]>=mod)
                cntFirst[node]%=mod;
        }
        if(res.first.first==memoFirst[node])
        {
            cntFirst[node]+=res.first.second;
            if(cntFirst[node]>=mod)
                cntFirst[node]%=mod;
        }
        if(res.second.first==memoFirst[node])
        {
            cntFirst[node]+=res.second.second;
            if(cntFirst[node]>=mod)
                cntFirst[node]%=mod;
        }


        if(memoFirst[node]==0)
        {
            memoSecond[node]=0;
            cntSecond[node]=0;
        }
        else
        {
            memoSecond[node]=memoFirst[node]-1;
            cntSecond[node]=0;

            if(p.first+1==memoFirst[node])
            {
                cntSecond[node]+=p.second;
                if(cntSecond[node]>=mod)
                    cntSecond[node]%=mod;
            }
            if(q.first+1==memoFirst[node])
            {
                cntSecond[node]+=q.second;
                if(cntSecond[node]>=mod)
                    cntSecond[node]%=mod;
            }
            if(res.first.first+1==memoFirst[node])
            {
                cntSecond[node]+=res.first.second;
                if(cntSecond[node]>=mod)
                    cntSecond[node]%=mod;
            }
            if(res.second.first+1==memoFirst[node])
            {
                cntSecond[node]+=res.second.second;
                if(cntSecond[node]>=mod)
                    cntSecond[node]%=mod;
            }
        }
        return ;
    }
    int mid=(s+e)>>1;

    int lc=node<<1;
    int rc=1+lc;

    update(lc,s,mid,pos,res);
    update(rc,mid+1,e,pos,res);

    memoFirst[node]=max( max(memoFirst[lc],memoSecond[lc]) , max(memoFirst[rc],memoSecond[rc]) );
    cntFirst[node]=0;
    if(memoFirst[lc]==memoFirst[node])
    {
        cntFirst[node]+=cntFirst[lc];
        if(cntFirst[node]>=mod)
            cntFirst[node]%=mod;
    }
    if(memoSecond[lc]==memoFirst[node])
    {
        cntFirst[node]+=cntSecond[lc];
        if(cntFirst[node]>=mod)
            cntFirst[node]%=mod;
    }
    if(memoFirst[rc]==memoFirst[node])
    {
        cntFirst[node]+=cntFirst[rc];
        if(cntFirst[node]>=mod)
            cntFirst[node]%=mod;
    }
    if(memoSecond[rc]==memoFirst[node])
    {
        cntFirst[node]+=cntSecond[rc];
        if(cntFirst[node]>=mod)
            cntFirst[node]%=mod;
    }


    if(memoFirst[node]==0)
    {
        memoSecond[node]=0;
        cntSecond[node]=0;
    }
    else
    {
        memoSecond[node]=memoFirst[node]-1;
        cntSecond[node]=0;

        if(memoFirst[lc]+1==memoFirst[node])
        {
            cntSecond[node]+=cntFirst[lc];
            if(cntSecond[node]>=mod)
                cntSecond[node]%=mod;
        }
        if(memoSecond[lc]+1==memoFirst[node])
        {
            cntSecond[node]+=cntSecond[lc];
            if(cntSecond[node]>=mod)
                cntSecond[node]%=mod;
        }
        if(memoFirst[rc]+1==memoFirst[node])
        {
            cntSecond[node]+=cntFirst[rc];
            if(cntSecond[node]>=mod)
                cntSecond[node]%=mod;
        }
        if(memoSecond[rc]+1==memoFirst[node])
        {
            cntSecond[node]+=cntSecond[rc];
            if(cntSecond[node]>=mod)
                cntSecond[node]%=mod;
        }
    }
    return ;
}
pair< pii , pii > query(int node,int s,int e,int l,int r)
{
    if(s>r || e<l)
    {
        pair< int , int > p,q;
        p.first=p.second=q.first=q.second=0;
        return pair< pii , pii >(p,q);
    }
    if(s>=l && e<=r)
    {
        pair< int , int > p,q;
        p.first=memoFirst[node];
        p.second=cntFirst[node];
        q.first=memoSecond[node];
        q.second=cntSecond[node];
        return pair< pii , pii >(p,q);
    }
    int mid=(s+e)>>1;
    int lc=node<<1;
    int rc=1+lc;

    pair< pii , pii > p=query(lc,s,mid,l,r);
    pair< pii , pii > q=query(rc,mid+1,e,l,r);
    pair< int , int > resP;
    pair< int , int > resQ;
    pair< pii , pii > res;

    resP.first = max( max(p.first.first,p.second.first) , max(q.first.first,q.second.first) );
    resP.second=0;//count
    if(p.first.first==resP.first)
    {
        resP.second+=p.first.second;
        if(resP.second>=mod)
            resP.second%=mod;
    }
    if(p.second.first==resP.first)
    {
        resP.second+=p.second.second;
        if(resP.second>=mod)
            resP.second%=mod;
    }
    if(q.first.first==resP.first)
    {
        resP.second+=q.first.second;
        if(resP.second>=mod)
            resP.second%=mod;
    }
    if(q.second.first==resP.first)
    {
        resP.second+=q.second.second;
        if(resP.second>=mod)
            resP.second%=mod;
    }

    vector<pii> v(4);
    v.push_back(pii(p.first.first,p.first.second));
    v.push_back(pii(p.second.first,p.second.second));
    v.push_back(pii(q.first.first,q.first.second));
    v.push_back(pii(q.second.first,q.second.second));

    resQ.first=0;
    resQ.second=0;
    for(int i=0; i<v.size(); i++)
    {
        if(v[i].first!=resP.first)
        {
            resQ.first=max(resQ.first,v[i].first);
        }
    }
    for(int i=0; i<v.size(); i++)
    {
        if(v[i].first==resQ.first)
        {
            resQ.second+=v[i].second;
            if(resQ.second>=mod)
                resQ.second%=mod;
        }
    }
    res.first=resP;
    res.second=resQ;
    return res;
}
int ans[100005];
int main()
{
    int t;
    in(t);
    while(t--)
    {
        int n;
        in(n);
        vector<int> v;
        for(int i=1; i<=n; i++)
        {
            in(a[i]);
            v.push_back(a[i]);
        }
        sort(v.begin(),v.end());
        map< int , int > M;
        int cnt=0;
        for(int i=0; i<v.size(); i++)
        {
            if(M.find(v[i])==M.end())
            {
                cnt++;
                M.insert(pair<int,int>(v[i],cnt));
            }
        }
        for(int i=1; i<=n; i++)
        {
            b[i]=M[a[i]];
        }
        init(1,1,cnt);
        int lis=0;
        for(int i=1; i<=n; i++)
        {
            pair< pii , pii > res;
            if(b[i]==1)
            {
                res.first.first=0;
                res.first.second=0;
                res.second.first=0;
                res.second.second=0;
            }
            else
            {
                res=query(1,1,cnt,1,b[i]-1);
            }
            //printf("\nafter query\n");
            //printf("so res.first.first and res.first.second is %d %d\n",res.first.first,res.first.second);
            //printf("so res.second.first and res.second.second is %d %d\n",res.second.first,res.second.second);
            if(res.first.first==0 && res.second.first==0)//both zero
            {
                res.first.first++;//val
                res.first.second++;//cnt
            }
            else if(res.second.first==0)//only only zero
            {
                res.first.first++;//val

                res.second.first++;//val
                res.second.second++;//cnt
            }
            else//both non-zero
            {
                res.first.first++;
                res.second.first++;
            }
            ans[res.first.first]+=res.first.second;
            if(ans[res.first.first]>=mod)
                ans[res.first.first]%=mod;

            ans[res.second.first]+=res.second.second;
            if(ans[res.second.first]>=mod)
                ans[res.second.first]%=mod;

            if(res.first.second>=mod)
                res.first.second%=mod;

            if(res.second.second>=mod)
                res.second.second%=mod;

            lis=max(lis,max(res.first.first,res.second.first));
            //printf("\nbefore update\n");
            //printf("so res.first.first and res.first.second is %d %d\n",res.first.first,res.first.second);
            //printf("so res.second.first and res.second.second is %d %d\n",res.second.first,res.second.second);
            update(1,1,cnt,b[i],res);
        }
        printf("%d\n",ans[lis-1]);
        for(int i=0; i<=lis; i++)
        {
            ans[i]=0;
        }
    }
    return 0;
}
