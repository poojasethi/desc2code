/*
shangjingbo's solution:
K numbers a1, a2, ... ak canbe sides of a k convex polygon if and only if a1 + a2 + .. + ak > 2 * max(a1, a2, ..., ak)

Consider the sequence:
F[1] = F[2] = ... = F[k - 1] = 1;
With i >= k: F[i] = F[i - 1] + F[i - 2] + .. + F[i - k + 1] + 1

F[i] will exceed 10^9 soon so when n is large (approximately >= 70) the answer will be "YES".
We can find k consecutive numbers to be the sides of the first convex polygon and then find the sides of the second convex polygon in the same way.

If we can find one convex polygon in an sorted array of numbers, its sides will be the adjacent numbers.
Using this we can deal with the case when n is small.
*/

#pragma comment(linker, "/STACK:16777216")
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <string>
#include <memory.h>
#include <sstream>
#include <complex>

#define REP(i,n) for(int i = 0, _n = (n); i < _n; i++)
#define REPD(i,n) for(int i = (n) - 1; i >= 0; i--)
#define FOR(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)
#define FORD(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)

using namespace std;

int n, k;
int a[1222], Index[1222];

bool cmpIndex(int x, int y) {
    return a[x] < a[y];
}

void solveBig() {
    cout << "Yes" << endl;

    //find the first convex polygon

    FOR (i, k, n) {
        long long sum = 0;
        FOR (j, 1, k - 1) sum += a[Index[i - j]];

        if (sum > a[Index[i]]) {
            FOR (j, 1, k) printf("%d ", Index[i - j + 1]);

            //remove those k numbers from the array
            FOR (j, i + 1, n)
                Index[j - k] = Index[j];

            break;
        }
    }
    n -= k;

    //find the second convex polygon
    FOR (i, k, n) {
        long long sum = 0;
        FOR (j, i - k + 1, i - 1) sum += a[Index[j]];

        if (sum > a[Index[i]]) {
            FOR (j, i - k + 1, i) printf("%d ", Index[j]);
            break;
        }
    }
}

int bit(int s, int b) {
    return ((s >> b) & 1);
}

int countBit(int s) {
    int cnt = 0;

    while (s) {
        cnt += (s & 1);
        s /= 2;
    }

    return cnt;
}

bool used[1222];

void solveSmall() {
    FOR (s, 0, (1 << (2 * k)))
        if (countBit(s) == k)
            FOR (start, 1, n - 2 * k + 1) {
                long long sum = 0;
                int aMax = 0;

                FOR (i, 0, 2 * k - 1)
                    if (bit(s, i)) {
                        sum += a[Index[start + i]];
                        aMax = max(aMax, a[Index[start + i]]);
                    }

                if (sum <= 2 * aMax) continue;

                //we found the first polygon

                memset(used, false, sizeof(used));
                FOR (i, 0, 2 * k - 1)
                    if (bit(s, i))
                        used[start + i] = true;


                //the sides of the second polygon if it exist will be k consecutive numbers in the sorted array
                FOR (i, 1, n)
                if (!used[i]) {
                    aMax = a[Index[i]];
                    sum = 0;
                    int cnt = 0;

                    FORD (j, i - 1, 1)
                        if (!used[j]) {
                            cnt++;
                            sum += a[Index[j]];
                            if (cnt == k - 1) break;
                        }

                    if (cnt == k - 1 && sum > aMax) {
                        cout <<"Yes" << endl;
                        FOR (b, 0, 2 * k - 1)
                            if (bit(s, b)) cout << Index[start + b] <<" ";

                        cnt = 0;
                        FORD (j, i, 1)
                            if (!used[j]) {
                                cnt++;
                                cout << Index[j] << " ";
                                if (cnt == k) break;
                            }
                        return;
                    }
                }
            }

    cout <<"No" << endl;
}

int main() {
    cin >> n >> k;
    FOR (i, 1, n) cin >> a[i];
    FOR (i, 1, n) Index[i] = i;

    sort(Index + 1, Index + 1 + n, cmpIndex);

    if (n <= 70) solveSmall();
    else solveBig();

    return 0;
}
