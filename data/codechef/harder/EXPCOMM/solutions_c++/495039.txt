#pragma comment(linker, "/STACK:10000000")

#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <bitset>
#include <sstream>

#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>

#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>

using namespace std;

#define forn(i, n) for(int i = 0; i < int(n); ++i)
#define for1(i, n) for(int i = 1; i <= int(n); ++i)
#define ford(i, n) for(int i = int(n) - 1; i >= 0; --i)
#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)
#define sz(v) int((v).size())
#define all(v) (v).begin(), (v).end()
#define pb push_back
#define X first
#define Y second
#define mp make_pair
#define debug(x) {cerr << #x << " = " << x << endl;}
template<typename T> inline T abs(T a){ return ((a < 0) ? -a : a); }
template<typename T> inline T sqr(T a){ return a * a; }

typedef long long li;
typedef long double ld;
typedef pair<li, int> pt;

const int INF = (int)1E9 + 7;
const ld EPS = 1E-9;
const ld PI = 3.1415926535897932384626433832795;
const li mod = 1000000007;
const int NMAX = 2000*1000;

bool pr[NMAX];
li ps[NMAX];
int szp = 0;

void gen(){
    fore(i, 2, NMAX){
        if(!pr[i]){
            ps[szp++] = i;
            for(int j =i+i; j < NMAX; j += i)
                pr[j] = true;
        }
    }
}

li powmod(li a, li b, li M=mod){
    a %= M;

    li ans = 1 % M;
    while(b > 0){
        if(b & 1)
            ans = (ans * a) % M;
        b >>= 1;
        a = (a * a) % M;
    }

    return ans;
}

vector<pt> Fact(li v){
    vector<pt> ans;
    if(v == 1) 
        return ans;
    forn(i, szp){
        li d = ps[i];
        if(d*d > v) break;
        
        int st = 0;
        while(v % d == 0){
            v /= d;
            st++;
        } 

        if(st != 0)
            ans.pb(mp(d, st));    

        if(d&1)
            d++;
    }
    if(v != 1)
        ans.pb(mp(v, 1));
    return ans;
}

inline li PHI(li p, int e){
    return (powmod(p, e-1)*((p-1) % mod)) % mod;
}

li NN(li p, int e){
    li ans = 0;
    li mul = sqr(PHI(p,e)) % mod;
    forn(j, e){
        li cur = ((sqr(j+1)%mod) * PHI(p, e-j)) % mod;
        ans = (ans + cur) % mod;
    }    
    ans = (ans * mul) % mod;

    li c0 = (2*powmod(p,e)-1+mod) % mod;
    forn(a, e)
        forn(b, e){
            if(a+b >= e){
                c0 = (c0 + (PHI(p, e-a)*PHI(p, e-b)) % mod) % mod;
            }
        }
    ans = (ans + sqr(c0)%mod) % mod;
    return ans;
}

li N(li x){
    if(x == 1) return 1;
    vector<pt> fc = Fact(x);

    li ans = 1%mod;

    forn(i, sz(fc)){
        li p = fc[i].X;
        int e = fc[i].Y;
        ans = (ans*NN(p,e)) % mod;
    }
    return ans;
}

int stupid(int p){
    int ans = 0;
    for1(a, p*(p-1))
        for1(b, p*(p-1))
            ans += int(powmod(a,b,p) == powmod(b,a,p));         
    return ans;            
}

int main() {
//    freopen("input.txt", "rt", stdin);
//    freopen("output.txt", "wt", stdout);
    gen();
    int test;
    cin >> test;
    forn(TT, test){
        li p;
        cin >> p;

        cout << (powmod(p-1, 2) + N(p-1)) % mod << endl;
    }    

    return 0;
}

