#include <stdio.h>

#define MAX 10000000
#define SQRTMAX 3162
#define MAXP 665000
#define MAXL 8

char composite[MAX+1];
int primes[MAXP];
int mu1[MAX+1];

char mu1lr[MAXL+1][2] = {{0,0},{1,-1},{-2,1},{3,-1},{-4,1},{5,-1},{-6,1},{7,-1},{-8,1}};

void genmu1(int d, int k, int r, int l) {
	int p;

	mu1[d] = mu1lr[l][r];

	int ub=MAX/d;
	if(!r && (p=primes[k])<=ub)
		genmu1(d*p, k, 1, l);

	k++;
	l++;
	for( ; (p=primes[k])<=ub; k++)
		genmu1(d*p, k, r, l);
}

void init() {
	int i;
	composite[1] = 1;
	for(i=3; i<=SQRTMAX; i+=2) if(!composite[i]) {
		int i2 = i<<1;
		for(int j=i*i; j<=MAX; j+=i2) composite[j] = 1;
	}

	primes[1]=2;
	int nump=2;
	for(i=3; i<=MAX; i+=2) if(!composite[i]) primes[nump++] = i;
	primes[0] = primes[nump] = MAX+1;

	genmu1(1, 0, 0, 0);
	for(i=2; i<=MAX; i++) mu1[i] += mu1[i-1];
}

long long compute(int a, int b) {
	int m = a<b ? a : b;
	long long rslt = 0;
	int nd;
	for(int d=1; d<m; d=nd) {
		int ad = a/(d+1), bd = b/(d+1);
		int	na = a/ad, nb = b/bd;
		nd = na<nb ? na : nb;

		rslt += (long long)(mu1[nd]-mu1[d])*bd*ad;
	}
	return rslt;
}

int main() {
	int tests;
	init();
	scanf("%d", &tests);
	while(tests--) {
		int a, b;
		scanf("%d %d", &a, &b);
		printf("%lld\n", compute(a, b));
	}
	return 0;
}