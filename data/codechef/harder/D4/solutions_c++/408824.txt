/*
* Author : Nikhil Garg
* Date   : 2010-12-29
* Team Proof's C++ template
*/

#include<iostream>
#include<sstream>
#include<vector>
#include<stack>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<bitset>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cctype>
using namespace std;

#define pb								push_back
#define s(n)								scanf("%d",&n)
#define sl(n) 								scanf("%lld",&n)
#define sf(n) 								scanf("%lf",&n)
#define fill(a,v) 							memset(a, v, sizeof a)
#define INF								(int)1e9
#define EPS								1e-9

typedef long long LL;
typedef pair<int, int > PII;

int testCases, testNum;

const int maxn = (int)1e7 + 100;

bool isComposite[maxn / 2];
int factor[maxn];
int primes[670000];
int P;
int A,B;

void seive()
{
	for(int i = 3; i <= 3200; i += 2)
	{
		if(isComposite[i >> 1]) continue;
		for(int j = i * i; j < maxn; j += i)
			if( j & 1 )
				isComposite[j >> 1] = true;
	}

	P = 1;
	primes[P++] = 2;
	for(int i = 3; i < maxn;  i += 2)
	{
		if(!isComposite[i >> 1])
				primes[P++] = i;
	}
	primes[0] = primes[P++] = INF;
	
}

void fillMu(int soFar, int lastPrime, int one, bool two)
{
	
	factor[soFar] = two ? ( (one & 1) ? -1 : 1) : ( (one & 1) ?  one : - one);
	int limit = maxn / soFar;
	int p = primes[lastPrime];
	
	if( !two &&  p <=limit)
		fillMu( soFar * p, lastPrime, one, true);

	for(lastPrime++ , one++; ( p = primes[lastPrime]) <= limit; lastPrime++)
		fillMu( soFar * p, lastPrime, one, two);
}

void precompute()
{
	fillMu(1,0,0,0);
	for(int i = 1; i < maxn; i++)
		factor[i] += factor[i-1];
	for(int i = maxn - 1; i >= 1; i--)
		factor[i] = factor[i-1];
}


void solve()
{
	if( A > B)		swap(A,B);
	LL ans = 0LL;
	int nd,a,b,prod;
	
	for(int d = 1; d <= A; d = nd)
	{
		a = A / d; b = B / d;
		nd =  min( A/a , B/b ) + 1;
		ans += 1LL * a * b * (factor[nd] - factor[d]);
	}
	printf("%lld\n", ans);
}

bool input()
{
	s(A); s(B);
	return true;
}

int main()
{
	seive();
	precompute();
	s(testCases);
	for(testNum = 1; testNum <= testCases; testNum ++)
	{
		if(!input()) break;
		solve();
	}
}