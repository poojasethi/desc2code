// Primes in the GCD table
// http://www.codechef.com/problems/D4/

#include <stdio.h>
#define	MAX_P		10000000
#define	MAX_SQRT	3162
#define	MAX_PRIMES	(664579 + 1)

#define	PRO			30030	// 2*3*5*7*11*13
#define	PHI			5760	// 1*2*4*6*10*12
#define	NEXT_P		17		// Next prime with PRO.

typedef long long sint;

int	factors[MAX_P / 2];
int	primes[MAX_PRIMES];
int	upper[MAX_PRIMES];

#define	set(K, F)		{ factors[(K) >> 1] = (F); }
#define	composed(K)		( factors[(K) >> 1] != 0 )
#define	get_factor(K)	( factors[(K) >> 1] ) 

#define	mod_add(X, Y, M)	{ (X) += (Y); if ((X) >= (M))	(X) -= (M);	}
#define	mod_inc(X, M)		mod_add(X, 1, M)

void	mark13()
{	//mark using primes {2, 3, 5, 7, 11 and 13}
	int	adder[PHI];		// add from this to next mod number

	int	m3 = 0, m5 = 3, m7 = 3, m11 = 3, m13 = 3;
	int	ps = 0;		//pos
	int	old = 1;	//previous pairwise prime mod
	for (int I = 3; I <= PRO + 1; I += 2) {
		int	F;
		if (m3 != 0 && m5 != 0 && m7 != 0 && m11 != 0 && m13 != 0) {
			adder[ps] = I - old;
			old = I;
			ps++;
			F = 0;
		} else {
			F = m3 == 0 ? 3 : m5 == 0 ? 5 : m7 == 0 ? 7 : m11 == 0 ? 11 : 13;
		}
		set(I, F);
		mod_add(m3, 2, 3);
		mod_add(m5, 2, 5);
		mod_add(m7, 2, 7);
		mod_add(m11, 2, 11);
		mod_add(m13, 2, 13);
	}

	for (int I = PRO + 1; I <= MAX_P; I += 2)
		set(I, get_factor(I - PRO));

	for (int I = NEXT_P, apos = 1; I <= MAX_SQRT; ) {
		if (!composed(I)) {
			for (int J = I * I, adj = apos; J <= MAX_P; ) {
				set(J, I); J += adder[adj] * I; mod_inc(adj, PHI);	
			}	
		}
		I += adder[apos]; mod_inc(apos, PHI);
	}	
}

int	tt[MAX_P + 1];
char	uu[MAX_P + 1];
// tt[1] = 0
// tt[I] = 1 for I = prime
// tt[I] = - sum(tt[J]) for all J = divisor of I
// result(a,b) = sum(i=2 to a of f(a,b)) 
// f(a,b) = how many numbers j from 1 to b have gcd(a, j) = prime
// f(a,b) = sum(d * tt[d] * [b / d]) for all divisors d of a.
// => result(a,b) = sum(i=2 to a of [a/d]*tt[d]*[b/d])
// because a divisor d of a appears [a/d] times from [1 to a]

void	fast_init()
{
	tt[1] = 0;
	tt[2] = 1;
	uu[1] = 0;
	uu[2] = 0;
	for (int i = 3; i <= MAX_P; i++) {
		int	p = 2;
		if (i & 1)
			p = get_factor(i);
		if (p == 0 || p == i) {
			uu[i] = 0;
			tt[i] = 1 + tt[i - 1];
			continue;
		}
		int	e = 1;
		int	j = i / p;
		while (j % p == 0) {
			j /= p;
			e++;
		}
		uu[i] = uu[j] + e - 1;
		int	ti = 0;
		int	tj = tt[j] - tt[j - 1];
		if (uu[i] == 0) {
			ti = (tj <= 0 ? 1 : -1) - tj;
		} else
			if (uu[i] == 1) {
				ti = (uu[j] == 0 ? (tj <= 0 ? -1 : 1) : -tj);
			}
		tt[i] = ti + tt[i - 1];
	}
}

sint	fast_count(int a, int b)
{	// O( sqrt(min(a,b)) )
	if (a > b)
		return	fast_count(b, a);
	//now a <= b
	sint	res = 0;

	/*	ref slow code:
	for (int i = 2; i <= a; i++) {
		res += (sint)((a / i) * (tt[i] - tt[i - 1])) * (b / i);
	}
	*/

	//[a/k] = m for k = [a/(m+1)] + 1 to [a/m]
	//100 / 25 = 4 for k = 100/5 + 1 to 100/4 = 21 to 25
	int	md;
	for (int m = 1; m < a; m = md) {
		int	ka = a / (m + 1);	//[a/k] has value = m for k into [ka+1 to prev_ka]
		int	kb = b / (m + 1);	//[b/k] has value = m for k into [kb+1 to prev_kb]
		int	ma = a / ka;	//[a/ka] = m + 1
		int	mb = b / kb;	//[b/kb] = m + 1 (same value for m = m + 1 to min(ma, mb))
		//prove: min(ma, mb) >= m + 1 [OK] because: floor[a / (m + 1)] <= a / (m + 1)
		// => a / floor[a / (m + 1)] >= a / (a / (m + 1)) = (m + 1)
		md = ma < mb ? ma : mb;
		res += (sint)((tt[md] - tt[m]) * ka) * kb;
	}
	return	res;
}

int	main()
{
	mark13();
	fast_init();

	int	T;
	scanf("%d", &T);
	while (--T >= 0) {
		int	a, b;
		scanf("%d%d", &a, &b);
		printf("%lld\n", fast_count(a, b));
	}

	return	0;
}
