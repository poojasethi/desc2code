#include<bits/stdc++.h>

using namespace std;

// The codes which I use are taken from the book Competitive Programming 3 written by Steven Halim
// Shortcuts for "common" data types in contests
typedef long long int ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef set<int> si;
typedef map<string, int> msi;
// To simplify repetitions/loops, Note: define your loop style and stick with it!
#define s(i) scanf("%d",&i)
#define sl(i) scanf("%ld",&i)
#define sll(i) scanf("%lld",&i)
#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define NREP(i,a,b) \
for (int i = int(a); i >= int(b); i--)
#define TRvi(c, it) \
for (vi::iterator it = (c).begin(); it != (c).end(); it++)
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
#define TRmsi(c, it) \
for (msi::iterator it = (c).begin(); it != (c).end(); it++)
#define MOD 1000000007
#define INF 2000000000 // 2 billion
#define EPS 1e-9

ll _sieve_size; // ll is defined as: typedef long long ll;
bitset<400000> bs; // 10^7 + small extra bits should be enough for most prime-related problems
vi primes; // compact list of primes in form of vector<int>
void sieve(ll upperbound) { // create list of primes in [0 .. upperbound]
_sieve_size = upperbound + 1; // add 1 to include upperbound
bs.reset(); bs.flip(); // set all numbers to 1
bs.set(0, false); bs.set(1, false); // except index 0 and 1
for (ll i = 2; i <= _sieve_size; i++) if (bs.test((size_t)i)) {
// cross out multiples of i starting from i * i!
for (ll j = i * i; j <= _sieve_size; j += i) bs.set((size_t)j, false);
primes.push_back((int)i); // also add this vector containing list of primes
}
} // call this method in main method
bool isPrime(ll N) { // a good enough deterministic prime tester
if (N < _sieve_size) return bs.test(N); // O(1) for small primes
REP (i, 0, primes.size() - 1)
{
    if (N % primes[i] == 0)
        return false;
    if(primes[i] > sqrt(N))
        return true;
}
return true; // it takes longer time if N is a large prime!
} // Note: only work for N <= (last prime in vi "primes")^2
// in int main()

vector < vi > masks;
vi bigfac , smafac;
int factors[3009] , n , dp[2][1 << 16] , m ;

void primeFactors(ll N)
{
    ll PF_idx = 0;
    ll PF = primes[PF_idx];
    while(PF*PF <= N)
    {
        while(N%PF == 0)
        {
            N /= PF;
            factors[PF] ^= 1;
        }
        PF = primes[++PF_idx];
    }
    if(N > 1)
        factors[N] ^= 1;
    return;
}

void recurse( int idx , int no , int mask , int id )
{
    if( no > n )
        return ;
    if( idx == smafac.size() || idx == id )
    {
        masks[id].push_back( mask );
        return ;
    }
    if( ( mask & ( 1 << idx ) ) == 0  )
        recurse( idx + 1 , no * smafac[idx] , mask | ( 1 << idx ) , id );
    recurse( idx + 1 , no , mask , id );
}

int main()
{
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    sieve( 3009) ;
    int t ; s(t) ;
    while( t-- )
    {
        s(n);s(m);
        memset( factors , 0 , sizeof(factors) ) ;
        memset( dp , 0 , sizeof(dp) ) ;
        bigfac.clear();
        smafac.clear();
        REP( i , 2 , n )
            primeFactors(i);
        for( int i = 2 ; i <= n ; i++ )
        {
            if( factors[i] )
            {
                if( i * i <= n )
                {
       //             cout << i << " " << "small" << endl;
                    smafac.push_back( i );
                }
                else
                {
        //            cout << i << " " << "big" << endl;
                    bigfac.push_back( i );
                }
            }
        }
        masks.clear();
        masks.resize( smafac.size() + bigfac.size() );
        REP( i , 0 , masks.size() - 1 )
        {
            if( i >= smafac.size() )
                recurse( 0 , bigfac[i - smafac.size()] , 0 , i );
            else
            {
                masks[i].push_back( 0 );
                recurse( 0 , smafac[i] , 1 << i , i );
            }
        }
        n = masks.size();
        int sz = smafac.size();
        dp[n % 2][( 1 << sz ) - 1] = 1 % m;
        NREP( i , n - 1 , 0 )
        {
            REP( j , 0 , ( 1 << sz ) - 1 )
            {
                dp[i % 2][j] = 0 ;
                REP( k , 0 , masks[i].size() - 1 )
                {
                    if( ( j & masks[i][k] ) == 0 )
                        dp[i % 2][j] = ( dp[i % 2][j] + dp[(i + 1) % 2][j | masks[i][k]] ) % m;
                }
            }
        }
        printf("%d\n",( 2 * dp[0][0] ) % m);
    }
    return 0;
}
