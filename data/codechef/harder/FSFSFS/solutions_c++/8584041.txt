#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cassert>
#include <map>
using namespace std;

#define sq 300
#define maxn 1000010
#define mod 1000000007

vector<int> p,nr;
int n,m, bigger, smaller;
map<int,int> M1,M2;
vector<int> batch[3010];
int dp[1<<16], newdp[1<<16];

void addFactor(int f, int cnt)
{
	for (int i = 0; i < p.size(); ++i)
	{
		if (p[i] == f)
		{
			nr[i] += cnt;
			return;
		}
	}
	p.push_back(f);
	nr.push_back(cnt);
}

vector<pair<int,int> > factor(int x)
{
	vector<pair<int,int> > factorization;
	for (int i = 2; i*i <= x; ++i)
	{
		if (x % i == 0)
		{
			int cnt = 0;
			while (x % i == 0)
			{
				x /= i;
				++cnt;
			}

			factorization.push_back(make_pair(i,cnt));
		}
	}

	if (x != 1)
		factorization.push_back(make_pair(x,1));
	return factorization;
}

void reset()
{
	p.clear();
	nr.clear();
	for (int i = 0; i <= bigger; ++i)
		batch[i].clear();
	bigger = 0;
	smaller = 0;
	M1.clear();
	M2.clear();
	memset(dp,0,sizeof(dp));
}

int main()
{
	//freopen("test.in","r",stdin);
	int test;
	cin >> test;

	for (;test; --test)
	{
		reset();
		cin >> n >> m;

		for (int i = 2; i <= n; ++i)
		{
			vector<pair<int,int> > pr = factor(i);
			for (int i = 0; i < pr.size(); ++i)
				addFactor(pr[i].first, pr[i].second);
		}

		for (int i = 0; i < nr.size(); ++i)
		{
			if (nr[i]&1)
			{
				if (p[i] > 53)
				{
					++bigger;
					M2[p[i]] = bigger;
				}
				else
				{
					++smaller;
					M1[p[i]] = smaller;
				}
			}
		}

		for (int i = 2; i <= n; ++i)
		{
			vector<pair<int,int> > pr = factor(i);
			bool good = true;
			int which = 0;
			int conf = 0;
            for (int i = 0; i < pr.size(); ++i)
            {
				if (M1.find(pr[i].first) == M1.end() && M2.find(pr[i].first) == M2.end() || pr[i].second != 1)
				{
					good = false;
					break;
				}
				else if (M1.find(pr[i].first) != M1.end())
				{
					conf += (1<<(M1[pr[i].first]-1));
				}
				else
				{
					which = M2[pr[i].first];
				}
            }

            if (good)
            {
				batch[which].push_back(conf);
            }
		}

		dp[0] = 1;

		if (batch[0].size() > 0)
		for (int i = 0; i <= bigger; ++i)
		{
			for (int x = 0; x < (1<<smaller); ++x)
			{
				newdp[x] = 0;
			}

			for (int j = 0; j < batch[i].size(); ++j)
			{
				for (int x = 0; x < (1<<smaller); ++x)
				{
					if ((x&batch[i][j]) == 0)
					{
						int t = (x|batch[i][j]);
						newdp[t] = (newdp[x|batch[i][j]] + dp[x]);
						if (newdp[t] >= m)
							newdp[t] -= m;
						if (i == 0)
						{
							newdp[t] = (newdp[x|batch[i][j]] + newdp[x]);
							if (newdp[t] >= m)
								newdp[t] -= m;
						}
					}
				}
			}

			for (int x = 0; x < (1<<smaller); ++x)
			{
				dp[x] = newdp[x];
			}
		}

		cout << dp[(1<<smaller)-1]*2%m << "\n";
	}
}
