#include <stdio.h>
#include <stdlib.h>
using namespace std;

int cnt,g[305];

#define inf 1000000000
struct Minimum_cost_flow
{
	#define Graph_vertex 605
	#define Graph_edge 300005
	#define flow_value int
	#define cost_value int
	#define dist_inf 1000000000
	
	int n,i,tot,u,v,ll,rr;
	int son[Graph_vertex],next[Graph_edge],ed[Graph_edge],from[Graph_vertex],q[Graph_vertex];
	flow_value flow[Graph_edge],max_flow;
	cost_value dist[Graph_vertex],cost[Graph_edge],ans;
	bool inq[Graph_vertex];
	
	inline void clear(int N){for(n=N,tot=1,i=0;i<=n;++i)son[i]=0;}
	inline void add(int u,int v,flow_value f,cost_value c)
	{
		next[++tot]=son[u];son[u]=tot;ed[tot]=v;flow[tot]=f;cost[tot]=c;
    	next[++tot]=son[v];son[v]=tot;ed[tot]=u;flow[tot]=0;cost[tot]=-c;
	}
	
	void SPFA(int S)
	{
		for(i=0;i<=n;++i)dist[i]=dist_inf;
		ll=0;q[rr=1]=S;dist[S]=0;
		while(ll!=rr)
		{
			++ll;if(ll==Graph_vertex)ll=1;
			u=q[ll];inq[u]=false;
			for(i=son[u];i;i=next[i])
			if(flow[i]&&dist[u]+cost[i]<dist[v=ed[i]])
			{
				dist[v]=dist[u]+cost[from[v]=i];
				if(!inq[v])
				{
					++rr;if(rr==Graph_vertex)rr=1;
					q[rr]=v;inq[v]=true;
				}
			}
		}
	}
	
	cost_value cost_flow(int S,int T)
	{
		ans=0;
		for(;;)
		{
			SPFA(S);
			if(dist[T]==dist_inf)break;
			max_flow=1;
			for(u=T;u!=S;u=ed[i^1])
			{
				i=from[u];
				if(flow[i]<max_flow)max_flow=flow[i];
			}
			ans+=dist[T]*max_flow;
			for(u=T;u!=S;u=ed[i^1])
			{
				i=from[u];
				flow[i]-=max_flow;
				flow[i^1]+=max_flow;
			}
			g[++cnt]=ans;
		}
		return ans;
	}
	
	#undef Graph_vertex
	#undef Graph_edge
	#undef flow_value
	#undef cost_value
	#undef dist_inf
}G;

int n,m,K,i,j,k,u,v,c,ans;
int f[305][305];

int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(i=1;i<=n;++i)
	for(j=1;j<=n;++j)
	f[i][j]=10000;
	for(;m;--m)
	{
		scanf("%d%d%d",&u,&v,&c);
		if(c<f[u][v])f[u][v]=c;
	}
	for(k=1;k<=n;++k)
	for(i=1;i<=n;++i)
	for(j=1;j<=n;++j)
	if(f[i][k]+f[k][j]<f[i][j])
	f[i][j]=f[i][k]+f[k][j];
	G.clear(n+n+1);
	for(i=1;i<=n;++i)
	{
		G.add(0,i,1,0);
		for(j=1;j<=n;++j)G.add(i,j+n,1,f[i][j]);
		G.add(i+n,n+n+1,1,0);
	}
	G.cost_flow(0,n+n+1);
	for(;K;--K)
	{
		scanf("%d",&c);ans=n*c;
		for(i=1;i<=n;++i)if(g[i]+(n-i)*c<ans)ans=g[i]+(n-i)*c;
		printf("%d\n",ans);
	}
}