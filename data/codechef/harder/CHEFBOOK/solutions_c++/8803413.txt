#include <stdio.h>
#include <stdlib.h>
using namespace std;

#define inf 1000000000
struct Minimum_cost_flow
{
	#define Graph_vertex 305
	#define Graph_edge 50005
	#define flow_value int
	#define cost_value int
	#define dist_inf 1000000000
	
	int n,i,tot,u,v,ll,rr;
	int son[Graph_vertex],next[Graph_edge],ed[Graph_edge],from[Graph_vertex],q[Graph_vertex];
	flow_value flow[Graph_edge],max_flow;
	cost_value dist[Graph_vertex],cost[Graph_edge],ans;
	bool inq[Graph_vertex];
	
	inline void clear(int N){for(n=N,tot=1,i=0;i<=n;++i)son[i]=0;}
	inline void add(int u,int v,flow_value f,cost_value c)
	{
		next[++tot]=son[u];son[u]=tot;ed[tot]=v;flow[tot]=f;cost[tot]=c;
    	next[++tot]=son[v];son[v]=tot;ed[tot]=u;flow[tot]=0;cost[tot]=-c;
	}
	
	void SPFA(int S)
	{
		for(i=0;i<=n;++i)dist[i]=dist_inf;
		ll=0;q[rr=1]=S;dist[S]=0;
		while(ll!=rr)
		{
			++ll;if(ll==Graph_vertex)ll=1;
			u=q[ll];inq[u]=false;
			for(i=son[u];i;i=next[i])
			if(flow[i]&&dist[u]+cost[i]<dist[v=ed[i]])
			{
				dist[v]=dist[u]+cost[from[v]=i];
				if(!inq[v])
				{
					++rr;if(rr==Graph_vertex)rr=1;
					q[rr]=v;inq[v]=true;
				}
			}
		}
	}
	
	cost_value cost_flow(int S,int T)
	{
		ans=0;
		for(;;)
		{
			SPFA(S);
			if(dist[T]==dist_inf)break;
			max_flow=inf;
			for(u=T;u!=S;u=ed[i^1])
			{
				i=from[u];
				if(flow[i]<max_flow)max_flow=flow[i];
			}
			ans+=dist[T]*max_flow;
			for(u=T;u!=S;u=ed[i^1])
			{
				i=from[u];
				flow[i]-=max_flow;
				flow[i^1]+=max_flow;
			}
		}
		return ans;
	}
	
	#undef Graph_vertex
	#undef Graph_edge
	#undef flow_value
	#undef cost_value
	#undef dist_inf
}G1;

struct SPFA_shortest_path
{
	#define Graph_n 305
	#define Graph_m 30005
	#define dist_value int
	#define dist_inf 1000000000
	
	int son[Graph_n],next[Graph_m],ed[Graph_m],q[Graph_n],ll,rr;
	dist_value dist[Graph_n],cost[Graph_m];
	int n,i,tot,u,v;
	bool inq[Graph_n];
	
	inline void clear(int N){for(n=N,tot=i=0;i<=n;++i)son[i]=0;}
	inline void add(int u,int v,int c){next[++tot]=son[u];son[u]=tot;ed[tot]=v;cost[tot]=c;}
	void SPFA()
	{
		ll=rr=0;
		for(i=1;i<=n;++i)q[++rr]=i,dist[i]=0,inq[i]=true;
		while(ll!=rr)
		{
			++ll;if(ll==Graph_n)ll=1;
			u=q[ll];inq[u]=false;
			for(i=son[u];i;i=next[i])
			{
				v=ed[i];
				if(dist[u]+cost[i]<dist[v])
				{
					dist[v]=dist[u]+cost[i];
					if(!inq[v])
					{
						++rr;if(rr==Graph_n)rr=1;
						q[rr]=v;inq[v]=true;
					}
				}
			}
		}
	}
	
	#undef Graph_n
	#undef Graph_m
	#undef dist_value
	#undef dist_inf
}G2;

int Test,S,T,n,m,i,j,k,sum;
int x[10005],y[10005],l[10005],s[10005],t[10005];
int cnt[205],d[205][205],d_[205][205];

void Min(int &a,int b){if(b<a)a=b;}

int main()
{
	scanf("%d",&Test);
	for(;Test;--Test)
	{
		scanf("%d%d",&n,&m);sum=0;
		S=0;T=n+n+1;G1.clear(T);
		for(i=1;i<=n+n;++i)cnt[i]=0;
		for(i=1;i<=n+n;++i)
		for(j=1;j<=n+n;++j)
		if(i==j)d[i][j]=0;else d[i][j]=inf;
		for(i=1;i<=m;++i)
		{
			scanf("%d%d%d%d%d",&x[i],&y[i],&l[i],&s[i],&t[i]);
			++cnt[x[i]];++cnt[y[i]+n];
			sum+=l[i];s[i]-=l[i];t[i]-=l[i];
			G1.add(y[i]+n,x[i],inf,t[i]);
			G1.add(x[i],y[i]+n,inf,-s[i]);
			Min(d[y[i]+n][x[i]],t[i]);
			Min(d[x[i]][y[i]+n],-s[i]);
		}
		for(i=1;i<=n+n;++i)
		for(j=1;j<=n+n;++j)
		d_[i][j]=d[i][j];
		for(k=1;k<=n+n;++k)
		for(i=1;i<=n+n;++i)
		for(j=1;j<=n+n;++j)
		Min(d_[i][j],d_[i][k]+d_[k][j]);
		for(i=1;i<=n+n;++i)
		if(d_[i][i]<0)
		{
			printf("Unlike\n");
			break;
		}
		if(i<=n+n)continue;
		for(i=1;i<=n;++i)G1.add(i,T,cnt[i],0);
		for(i=n+1;i<=n+n;++i)G1.add(S,i,cnt[i],0);
		printf("%d\n",sum+G1.cost_flow(S,T));
		for(i=k=1;i<=m;++i)
		{
			k+=2;if(G1.flow[k])Min(d[x[i]][y[i]+n],-t[i]);
			k+=2;if(G1.flow[k])Min(d[y[i]+n][x[i]],s[i]);
		}
		G2.clear(n+n);
		for(i=1;i<=n+n;++i)
		for(j=1;j<=n+n;++j)
		if(i!=j&&d[i][j]<inf)
		G2.add(i,j,d[i][j]);
		G2.SPFA();
		k=0;
		for(i=1;i<=n+n;++i)if(G2.dist[i]<k)k=G2.dist[i];
		for(i=1;i<=n+n;++i)G2.dist[i]-=k;
		for(i=1;i<=n;++i)printf("%d ",G2.dist[i]);printf("\n");
		for(i=n+1;i<=n+n;++i)printf("%d ",G2.dist[i]);printf("\n");
	}
}