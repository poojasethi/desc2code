#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define memcle(a) memset(a, 0, sizeof(a))
#define fo(i, a, b) for (i = a; i <= b; i++)
#define fd(i, a, b) for (i = a; i >= b; i--)
#define rep(i, n) for (i = 1; i <= n; i++)
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;

const int N = 100100;
const int M = N * 200;

bool submit = 1;
/*
int lson[M], rson[M], base[M], root[N];
LL sum[M];
*/

int L[N], R[N], a[N];
LL S[N], sum_ori[N];

int f[320][N];
LL sum[320], tree[N];

int n, m, tn;
/*
struct segment_tree
{
	int ins_point(int x, int l, int r, int p, int v)
	{
		if (x == 0) x = ++tn;
		base[x] += v;
		if (l == r) return x;
		int mid = (l + r) >> 1;
		if (p <= mid)
		{
			lson[x] = ins_point(lson[x], l, mid, p, v);
		} else 
		{
			rson[x] = ins_point(rson[x], mid + 1, r, p, v);
		}
		base[x] = base[lson[x]] + base[rson[x]];
		return x;
	}
	
	void modify(int x, int l, int r, int ql, int qr, int v)
	{
		if (x == 0) return;
		ql = max(ql, l); qr = min(qr, r); if (ql > qr) return;
		if (ql == l && qr == r) {sum[x] += LL(v) * base[x]; return;}
		
		int mid = (l + r) >> 1;
		modify(lson[x], l, mid, ql, qr, v);
		modify(rson[x], mid + 1, r, ql, qr, v);
		sum[x] = sum[lson[x]] + sum[rson[x]];
	}
	
	LL count(int x)
	{
		return sum[x];
	}
	
} seg;

void make_tree(int x, int p, int v)
{
	if (p == 0) return;
	for (; x <= n; x += (x & -x)) 
		root[x] = seg.ins_point(root[x], 1, n, p, v);
}

void modify(int x, int l, int r, int plus)
{
	for (; x <= n; x += (x & -x))
		seg.modify(root[x], 1, n, l, r, plus);
}

LL count(int x)
{
	LL ret = 0;
	for (; x; x -= (x & -x))
		ret += seg.count(root[x]);
	return ret;
}
*/
void read(int &x)
{
	char c = getchar();
	for (; c < '0' || c > '9'; ) c = getchar();
	x = 0;
	for (; c >= '0' && c <= '9'; ) x = x * 10 + c - '0', c = getchar();
}

void ins(int x, int v) 
{
	for (; x <= n; x += (x & -x)) tree[x] += v;
}

LL count(int x) 
{
	LL ret = 0;
	for (; x; x -= (x & -x)) ret += tree[x];
	return ret;
}

int main()
{
	int i;
	int j;
	int type;
	int x;
	int y;
	
	read(n);
	rep(i, n) read(a[i]), S[i] = S[i - 1] + a[i];
	rep(i, n) 
	{
		read(L[i]); read(R[i]);
		L[i]--;
		sum_ori[i] = sum_ori[i - 1] + S[R[i]] - S[L[i]];
		//make_tree(i, L[i], -1); make_tree(i, R[i], 1);
		//make_tree(i + 1, L[i], 1); make_tree(i + 1, R[i], -1);
	}
	
	int len = sqrt(n);
	
	for (int st = 1, p = 1; st <= n; st += len, p++)
	{
		int en = min(st + len - 1, n);
		fo(i, st, en) 
		{
			f[p][L[i]]--;
			f[p][R[i]]++;
		}
		fd(i, n - 1, 1) f[p][i] += f[p][i + 1];
	}
	
	read(m);
	rep(i, m) 
	{
		read(type); read(x); read(y);
		if (type == 1)
		{
			int plus = y - a[x]; a[x] = y;
			//for (int j = 1; j <= n; j++) modify(j, x, n, plus);
			
			for (int st = 1, p = 1; st <= n; st += len, p++) sum[p] += LL(plus) * f[p][x];
			ins(x, plus);
		} else 
		{
			/*x--;
			LL ans = count(y) - count(x);
			ans += sum_ori[y] - sum_ori[x];
			if (submit) printf("%lld\n", ans); else printf("%I64d\n", ans);*/
			
			ULL ans = sum_ori[y] - sum_ori[x - 1];
			for (j = x; (j - 1) % len != 0 && j <= y; j++) ans += count(R[j]) - count(L[j]);
			for (; j + len <= y; j += len) ans += sum[(j - 1) / len + 1];
			for (; j <= y; j++) ans += count(R[j]) - count(L[j]);
			if (submit) printf("%llu\n", ans); else printf("%I64u\n", ans);
		}
	}
	
	
	return 0;
}
