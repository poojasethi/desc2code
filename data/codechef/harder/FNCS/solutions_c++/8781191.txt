// Author: thecodekaiser
#include <bits/stdc++.h>
using namespace std;
 
typedef unsigned long long int ll;
#define MXN_1 100010
#define SQRT_1 350
 
ll mBIT[MXN_1], sum_BIT[SQRT_1], bBIT[SQRT_1][MXN_1], bCNT[SQRT_1][MXN_1];
int arr[MXN_1];
int func[MXN_1][3];
int N, L, R, X, Q, cmd, MXN, SQRT;
int no_of_blocks, block_size;

// Updates point in a BIT
void upd(ll * tree, int idx, ll val)
{ 	while(idx <= MXN){ tree[idx] += val; idx += (idx & -idx); }  }
 
// Gets point value from a BIT
ll get(ll * tree, int idx)
{	ll ret = 0; while(idx > 0) { ret += tree[idx]; idx -= (idx & -idx); } return ret; }
 
// Updates a range in a BIT
void range_upd(ll * tree, int i, int j, ll val)
{
	upd(tree, i, val);
	upd(tree, j+1, -val);
}

// Returns range query on a tree..basically mBIT
ll range_query(ll * tree, int i, int j)
{
	if(i > j) return 0LL;
	ll ret = get(tree, j) - get(tree, i-1);
	return ret;
}

void init_sqrt_tree()
{
	for(int i = 0; i < SQRT; i++)
	{
		for(int j = 0; j < MXN; i++)
		{
			mBIT[j] = 0; 
			bBIT[i][j] = 0;
			bCNT[i][j] = 0;
		}
		sum_BIT[i] = 0;
	}
}

void build_sqrt_tree()
{
	block_size   = sqrt(N);
	no_of_blocks = ceil((double) N / block_size);

	for(int i = 1; i <= no_of_blocks; i++)
	{
		for(int j = (i-1) * block_size + 1; j <= (i) * block_size and j <= N; j++)
		{
			L = func[j][0], R = func[j][1];
			range_upd(bBIT[i], L, R, 1LL);
			sum_BIT[i] += (range_query(mBIT, L, R));
		}

		for(int j = 1; j <= N; j++)
		{
			bCNT[i][j] = get(bBIT[i], j);
		}
	}
}
 
void update(int idx, int val)
{
	ll new_val = X - arr[idx];
	arr[idx] = X;
	upd(mBIT, idx, new_val);

	for(int i = 1; i <= no_of_blocks; i++)
	{
		int cnt = bCNT[i][idx];
		sum_BIT[i] += (new_val * (ll)cnt);
	}
	return;
}

ll query(int L, int R)
{
	int begin = ceil((float)L / block_size);
	int end   = ceil((float)R / block_size);

	if(begin == end)
	{
		ll ret = 0;
		for(int i = L; i <= R; i++)
			ret += (range_query(mBIT, func[i][0], func[i][1]));

		return ret;
	}
	else
	{
		ll ret = 0;

		for(int i = L; i <= begin * block_size ; i++)
		{
			ret += (range_query(mBIT, func[i][0], func[i][1]));
		}

		for(int i = (end-1) * block_size + 1; i <= R; i++)
		{
			ret += (range_query(mBIT, func[i][0], func[i][1]));
		}

		for(int i = begin+1; i <= end-1; i++)
		{
			ret += sum_BIT[i];
		}

		return ret;
	}
}


// Main solver
void solve()
{
	scanf("%d", &N);
	MXN = N + 1;
	SQRT = sqrt(N) + 1;

	for(int i = 1; i <= N; i++)
	{
		scanf("%d", &arr[i]);
		upd(mBIT, i, arr[i]);
	}

	for(int i = 1; i <= N; i++)
	{
		scanf("%d %d", &func[i][0], &func[i][1]);
	} 

 	build_sqrt_tree();
 
	scanf("%d", &Q);
	int begin, end;
 
	for(int i = 0; i < Q; i++)
	{
		scanf("%d", &cmd);
		if(cmd == 2)
		{
			scanf("%d %d", &L, &R);		// Sum from Lth to Rth function
			printf("%llu\n", query(L, R));
		}
		else
		{
			scanf("%d %d", &L, &X);
 			update(L, X);
		}
	}
 
	return;
}
 
int main()
{
	solve();
	return 0;
} 