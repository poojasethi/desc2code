#include <algorithm>
#include <memory.h>
#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <map>
#include <vector>
#include <ctime>
#include <iostream>
#define SQR(x) (x)*(x)
#define EPS 1e-8
using namespace std;
 
struct Point{
	
	double x, y, val, mul;
	void input() {
		scanf("%lf%lf", &x, &y);
	}
}P[105], S[105];
 
int N, sn;
double aa, bb, cc, dd, ee, ff, A1, B1, C1;
double ta, tb, tc, td, te, A2, B2, C2;
double ans = 1e15;
 
double multi(const Point &a, const Point &b, const Point &c) {
	return (c.x - a.x) * (c.y - b.y) - (c.x - b.x) * (c.y - a.y);
}
 
double dist(const Point &a, const Point &b) {
	return hypot(a.x - b.x, a.y - b.y);
}
 
double scalar(const Point &a, const Point &b, const Point &c) {
	return ((b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y));
}
 
bool cmp(const Point &a, const Point &b) {
	return a.val < b.val;
}
 
void add(const Point &a) {
	aa += SQR(a.x);
	bb += a.x;
	cc += SQR(a.y);
	dd += a.y;
	ee += a.x * a.y;
	ff++;
}
 
void subtract(const Point &a) {
	aa -= SQR(a.x);
	bb -= a.x;
	cc -= SQR(a.y);
	dd -= a.y;
	ee -= a.x * a.y;
	ff--;
}
 
double calc() {
	double t1, t2;
	
	if (ff == 0) t1 = 0;
	else {
		A1 = aa - SQR(bb) / ff;
		B1 = cc - SQR(dd) / ff;
		C1 = -2 * (ee - bb * dd / ff);
		t1 = (A1 + B1 - sqrt(SQR(B1 - A1) + SQR(C1))) / 2.0;
	}
	
	if (ff == N) t2 = 0;
	else {
		A2 = (ta - aa) - SQR(tb - bb) / (N - ff);
		B2 = (tc - cc) - SQR(td - dd) / (N - ff);
		C2 = -2 * ((te - ee) - (tb - bb) * (td - dd) / (N - ff));
		t2 = (A2 + B2 - sqrt(SQR(B2 - A2) + SQR(C2))) / 2.0;
	}
	return t1 + t2;
}
 
void Try(const Point &a, const Point &b) {
	ans = min(ans, calc());
	add(a);
	ans = min(ans, calc());
	add(b);
	ans = min(ans, calc());
	subtract(a);
	ans = min(ans, calc());
	subtract(b);
}
 
int main() {
	
	int i, j, k;
	scanf("%d", &N);
	for (i = 0; i < N; i++) {
		P[i].input();
		ta += SQR(P[i].x);
		tb += P[i].x;
		tc += SQR(P[i].y);
		td += P[i].y;
		te += P[i].x * P[i].y;
	}
	for (i = 0; i < N; i++) {
		for (j = i + 1; j < N; j++) {
			aa = bb = cc = dd = ee = ff = 0;
			for (sn = k = 0; k < N; k++) {
				if (k == i || k == j) continue;
				S[sn] = P[k];
				S[sn].mul = multi(P[i], P[j], P[k]);
				if (S[sn].mul > EPS) add(P[k]);
				S[sn++].val = scalar(P[i], P[j], P[k]);
			}
			
			sort(S, S + sn, cmp);
			Try(P[i], P[j]);
			
			for (k = 0; k < sn; k++) {
				if (S[k].mul > EPS) subtract(S[k]);
				else add(S[k]);
				Try(P[i], P[j]);
				if (k && fabs(S[k].val - S[k - 1].val) < EPS) {
					if (S[k - 1].mul > EPS) add(S[k - 1]);
					else subtract(S[k - 1]);
					Try(P[i], P[j]);
					if (S[k - 1].mul > EPS) subtract(S[k - 1]);
					else add(S[k - 1]);
				}
			}
		}
	}
	printf("%.10lf\n", ans / N);
}