#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <map>
#include <set>
#include <queue>
using namespace std;

#define For(i,n) for(int i=0;i<n;i++)
#define sz(i) int(i.size())
#define mst(i,n) memset(i,n,sizeof(i))
#define eps 1e-7
#define MOD 1000000007
#define LL long long
#define pi acos(-1)
#define ALL(n) n.begin(),n.end()
#define pb push_back
#define mp make_pair

int n;
#define type_t double

type_t x[105], y[105];
int X[105], Y[105];

inline type_t sqr(type_t a) {return a*a;}

class PCA
{
public:
int num;
type_t sumX, sumY, sumX2, sumY2, sumXY;
type_t normalizedSumX, normalizedSumY, normalizedSumX2, normalizedSumY2, normalizedSumXY;
type_t avgX, avgY;
type_t p, q, r;
/*matrix:
|p r|
|r q|
*/
PCA(){
num = 0;
sumX = sumY = sumX2 = sumY2 = sumXY = 0;
};
~PCA(){};
void addNode(type_t x, type_t y){
    //cout << x << " " << y << endl;
num++;
sumX  += x;
sumY  += y;
sumX2 += x*x;
sumY2 += y*y;
sumXY += x*y;
}
void delNode(type_t x, type_t y){
num--;
sumX  -= x;
sumY  -= y;
sumX2 -= x*x;
sumY2 -= y*y;
sumXY -= x*y;
}
type_t update(){
if(num <= 2)
return 0;
avgX = sumX / num;
avgY = sumY / num;
normalizedSumX  = sumX - avgX * num;
normalizedSumY  = sumY - avgY * num;
normalizedSumX2 = sumX2 - sqr(sumX) / num;
normalizedSumY2 = sumY2 - sqr(sumY) / num;
normalizedSumXY = sumXY - sumX * sumY / num;

p = normalizedSumX2;
q = normalizedSumY2;
r = normalizedSumXY;//
//x^2 + bx + c = 0;
type_t b = - p - q;
type_t c = p * q - sqr(r);
type_t delta = sqr(b) - c * 4;
type_t sol1 = (- b - sqrt(delta)) / 2;
type_t sol2 = (- b + sqrt(delta)) / 2;
type_t lambda = min(sol1, sol2);
type_t root = sqrt(sqr(r) + sqr(p - lambda));
//cout << delta << endl;
//cout << root << endl;
if(fabs(root) < eps)
//if(root == 0)
            return min(normalizedSumX2, normalizedSumY2);
type_t a1 = r / root, a2 = (lambda - p) / root;
//cout << a1 << " " << a2 << endl;
// x * a1 + y * a2 : mapping to the normal vector
// the answer is sum( sqr(x * a1 + y * a2) )
// x^2*a1^2 + y^2*a2 ^2 + 2*xy*a1*a2
//return sumX2 * sqr(a1) + sumY2 * sqr(a2) + sumXY * a1 * a2 * 2;
//cout << normalizedSumX2 * sqr(a1) + normalizedSumY2 * sqr(a2) + normalizedSumXY * a1 * a2 * 2 << endl;
return normalizedSumX2 * sqr(a1) + normalizedSumY2 * sqr(a2) + normalizedSumXY * a1 * a2 * 2;
}
};

int main(){
cin >> n;
PCA pca;
LL expand = 1LL;
For(i, n) {
double a, b;
    cin >> a >> b;
    X[i] = a * 10;
    Y[i] = b * 10;
    x[i] = a * expand + eps;
    y[i] = b * expand + eps;
    pca.addNode(x[i], y[i]);
}
//printf("%.8lf\n",pca.update());
    //cout << pca.update() << endl;
//return 0;
type_t ans = pca.update();
For(i, n)
For(j, n) if(i != j){
vector<pair<pair<int, int> , int> >mapLength;
For(k, n){
//map point Pk to vector Pj-Pi
int dotP = (X[k]-X[i]) * (X[j]-X[i]) + (Y[k]-Y[i]) * (Y[j]-Y[i]);
//and should break the tie!!!
int crossP = (X[k]-X[i]) * (Y[j]-Y[i]) - (Y[k]-Y[i]) * (X[j]-X[i]);
if(i < j)
                    crossP *= -1;
//dotP /= sqrt( sqr(x[j]-x[i]) + sqr(y[j]-y[i]) );
mapLength.pb(mp(mp(dotP, crossP), k));
}
sort(ALL(mapLength));
PCA pca1, pca2;
//initialize
bool side[105];
For(k, n){
if(k == min(i,j) || (x[k]-x[i]) * (y[j]-y[i]) - (y[k]-y[i]) * (x[j]-x[i]) < 0 )
pca1.addNode(x[k], y[k]), side[k] = true;
else
pca2.addNode(x[k], y[k]), side[k] = false;
}
ans = min(ans, pca1.update() + pca2.update());
//scan
For(kk, n){
    int k = mapLength[kk].second;
if(side[k]){
pca1.delNode(x[k], y[k]);
pca2.addNode(x[k], y[k]);
}
else{
pca1.addNode(x[k], y[k]);
pca2.delNode(x[k], y[k]);
}
ans = min(ans, pca1.update() + pca2.update());
//cout << pca1.update() << " " << pca2.update() << endl;
//cout << pca1.num << " " << pca2.num << endl;
}
}
printf("%.15lf\n", double(ans)/expand/expand/n);
}