#include <cstdio>
#include <cassert>
#include <queue>
#include <utility>
#include <stack>
using namespace std;
 
const int MOD=68681729;
const int TWO_INV=(MOD+1)/2, MAX_N=19;
const int OMEGA=378, OMEGA_INV=64502682;
 
inline int add(int a, int b){
	a+=b;
	if(a>=MOD)
		a-=MOD;
	return a;
}
 
inline int sub(int a, int b){
	a-=b;
	if(a<0)
		a+=MOD;
	return a;
}
 
inline int mul(int a, int b){
	return (long long)a*b%MOD;
 
}
 
int power(int base, int exponent){
	int sq=base, res=1;
	for(; exponent; exponent>>=1){
		if(exponent&1)
			res=mul(res, sq);
		sq=mul(sq, sq);
	}
	return res;
}
 
 
void bit_reverse(int *arr, int N, int bits=0, int a=0, int b=0){
	if(bits==N){
		if(a<b){
			int tmp=arr[a];
			arr[a]=arr[b];
			arr[b]=tmp;
		}
	}else{
		bit_reverse(arr, N, bits+1, a<<1, b);
		bit_reverse(arr, N, bits+1, (a<<1)+1, b+(1<<bits));
	}
}
 
void inplace_fft(int *arr, int N, int w){
	if(N==1){
		assert(w==(MOD-1));
		int E=arr[0], O=arr[1];
		arr[0]=add(E, O);
		arr[1]=sub(E, O);
	}else{
		int ww=mul(w, w);
		int sh=1<<(N-1);
		inplace_fft(arr, N-1, ww);
		inplace_fft(arr+sh, N-1, ww);
		int p=1;
		for(int i=0; i<sh; i++){
			int E=arr[i], O=mul(arr[i+sh], p);
			arr[i]=add(E, O);
			arr[i+sh]=sub(E, O);
			p=mul(p, w);
		}
	}
}
 
void fft(int *arr, int N){
	bit_reverse(arr, N);
	inplace_fft(arr, N, power(OMEGA, 1<<(MAX_N-N)));
}
 
void fft_inv(int *arr, int N){
	bit_reverse(arr, N);
	inplace_fft(arr, N, power(OMEGA_INV, 1<<(MAX_N-N)));
	int p=power(TWO_INV, N);
	for(int i=0; i<1<<N; i++)
		arr[i]=mul(arr[i], p);
}
 
int land[666][666], pattern[666][666], score[666][666];
int landsum[667][667], landsqsum[667][667];
int buf1[1<<19], buf2[1<<19];
int R, C, H, W, K, ri, rj;
#define inrect(arr, r, c) (arr[r+H][c+W]-arr[r+H][c]-arr[r][c+W]+arr[r][c])
 
void read(){
	scanf("%d %d", &R, &C);
	for(int i=0; i<R; i++)
	for(int j=0; j<C; j++)
		scanf("%d", &land[i][j]);
	scanf("%d %d", &H, &W);
	for(int i=0; i<H; i++)
	for(int j=0; j<W; j++)
		scanf("%d", &pattern[i][j]);
	scanf("%d %d %d", &ri, &rj, &K);
	ri--;
	rj--;
}
 
void solve(){
	for(int i=0; i<R; i++)
	for(int j=0; j<C; j++){
		landsum[i+1][j+1]=land[i][j]+landsum[i+1][j]+landsum[i][j+1]-landsum[i][j];
		landsqsum[i+1][j+1]=land[i][j]*land[i][j]+landsqsum[i+1][j]+landsqsum[i][j+1]-landsqsum[i][j];
	}
	int psum=0, psqsum=0;
	for(int i=0; i<H; i++)
	for(int j=0; j<W; j++){
		psum+=pattern[i][j];
		psqsum+=pattern[i][j]*pattern[i][j];
	}
	for(int i=0; i<R; i++)
	for(int j=0; j<C; j++){
		buf1[i*C+j]=sub(land[i][j], 0);
		buf2[i*C+j]=(i<H && j<W) ? sub(pattern[i][j], 0) : 0;
	}
	fft(buf1, 19);
	fft(buf2, 19);
	for(int i=0; i<1<<19; i++)
		buf1[i]=mul(buf1[i], buf2[-i&((1<<19)-1)]);
	fft_inv(buf1, 19);
	for(int i=0; i<1<<19; i++)
		if(buf1[i]>MOD/2)
			buf1[i]-=MOD;
	for(int i=0; i+H<=R; i++)
	for(int j=0; j+W<=C; j++)
		score[i][j]=W*H*land[i+ri][j+rj]*land[i+ri][j+rj]+inrect(landsqsum, i, j)+psqsum
			+2*land[i+ri][j+rj]*(psum-inrect(landsum, i, j))-2*buf1[i*C+j];
}
 
void print(){
	priority_queue<pair<int, pair<int, int> > > pq;
	for(int i=0; i+H<=R; i++)
	for(int j=0; j+W<=C; j++){
		pq.push(make_pair(score[i][j], make_pair(i, j)));
		if(pq.size()>K)
			pq.pop();
	}
	stack<pair<int, pair<int, int> > > st;
	while(!pq.empty()){
		st.push(pq.top());
		pq.pop();
	}
	while(!st.empty()){
		printf("%d %d %d\n", st.top().second.first+1, st.top().second.second+1, st.top().first);
		st.pop();
	}
}
 
int main(){
	read();
	solve();
	print();
	return 0;
} 