#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
#include <queue>
#include <cmath>
#include <set>
#include <map>
#include <stack>
#include <cassert>
#include <algorithm>
using namespace std;

const int BUFFSIZE = 10240;
char BUFF[BUFFSIZE + 1], *ppp = BUFF;
int RR, CHAR, SIGN, BYTES = 0;
#define GETCHAR(c) { \
        if(ppp-BUFF==BYTES && (BYTES==0 || BYTES==BUFFSIZE)) { BYTES = fread(BUFF,1,BUFFSIZE,stdin); ppp=BUFF; } \
        if(ppp-BUFF==BYTES && (BYTES>0 && BYTES<BUFFSIZE)) { BUFF[0] = 0; ppp=BUFF; } \
        c = *ppp++; \
}

#define DIGIT(c) (((c) >= '0') && ((c) <= '9'))
#define MINUS(c) ((c)== '-')
#define GETNUMBER(n) { \
        n = 0; SIGN = 1; do { GETCHAR(CHAR); } while(!(DIGIT(CHAR) || MINUS(CHAR))); \
        if(MINUS(CHAR)) { SIGN = -1; GETCHAR(CHAR); } \
        while(DIGIT(CHAR)) { n = 10*n + CHAR-'0'; GETCHAR(CHAR); } if(SIGN == -1) { n = -n; } \
}

typedef unsigned long long ll;

#define XX double

struct P {
	XX x, y;
	P() {
	}
	P(XX x, XX y) :
		x(x), y(y) {
	}
	inline P operator-(const P b) {
		return P(x - b.x, y - b.y);
	}
	inline P operator+(const P b) {
		return P(x + b.x, y + b.y);
	}
	inline P operator*(const P b) {
		return P(x * b.x - y * b.y, x * b.y + y * b.x);
	}
	inline P operator/(const P b) {
		P s = P(x * b.x + y * b.y, y * b.x - x * b.y);
		s.x /= (b.x * b.x + b.y * b.y);
		s.y /= (b.x * b.x + b.y * b.y);
		return s;
	}
};
// (a,b) * (c,d) = (ac-bd, ad+bc)
// (a,b) / (c,d) = ( (ac+bd) / (c^2+d^2), (bc-ad) / (c^2+d^2) )


const double PI = 3.141592653589793;

void fft(P *a, int n, bool invert) {
	for (register int i = 1, j = 0; i < n; ++i) {
		int bit = n >> 1;
		for (; j >= bit; bit >>= 1)
			j -= bit;
		j += bit;
		if (i < j)
			swap(a[i], a[j]);
	}
	for (register int len = 2; len <= n; len <<= 1) {
		double ang = 2 * PI / len * (invert ? -1 : 1);
		P wlen(cos(ang), sin(ang));
		for (int i = 0; i < n; i += len) {
			P w(1, 0);
			for (int j = 0; j < len / 2; ++j) {
				P u = a[i + j], v = a[i + j + len / 2] * w;
				a[i + j] = u + v;
				a[i + j + len / 2] = u - v;
				w = w * wlen;
			}
		}
	}
	if (invert)
		for (int i = 0; i < n; ++i)
			a[i].x /= n, a[i].y /= n;
}

int r, c, h, w, k, ii, jj;
int F[700][700];
int Pa[700][700];

int SumSumF[700][700];
int SumF[700][700];

P A[1200000], B[1200000];

int ptr;

stack< pair<int, pair<int, int> > > s;
priority_queue< pair<int, pair<int, int> > > q;
int SumP, SumSumP , score;

inline int correct(double val) {
	if(val < 0) return val - 0.5;
	return val + 0.5;
}

int main() {
	//scanf("%d%d", &r, &c);
	GETNUMBER(r);GETNUMBER(c);
	for(int i = 0;i<r;i++)
		for(int j = 0;j<c;j++) {
			//scanf("%d", &F[i][j]);
			GETNUMBER(F[i][j]);

			A[i * c + j].x = F[i][j];
			SumSumF[i+1][j+1] = F[i][j] * F[i][j];
			SumF[i+1][j+1] = F[i][j];

			SumSumF[i+1][j+1] += SumSumF[i][j+1] + SumSumF[i+1][j] - SumSumF[i][j];
			SumF[i+1][j+1] += SumF[i][j+1] + SumF[i+1][j] - SumF[i][j];
		}

	//scanf("%d%d", &h, &w);
	GETNUMBER(h);GETNUMBER(w);

	for(int i = 0;i<h;i++)
		for(int j = 0;j<w;j++) {
			//scanf("%d", &Pa[i][j]);
			GETNUMBER(Pa[i][j]);
			B[i * c + j].x = Pa[i][j];

			SumSumP += Pa[i][j] * Pa[i][j];
			SumP += Pa[i][j];
		}

	//scanf("%d%d%d", &ii, &jj, &k);
	GETNUMBER(ii);GETNUMBER(jj);GETNUMBER(k);
	ii--;jj--;

	int nn = 1;
	while((1<<nn) <= r * c) ++nn;
	nn = 1<<nn;

	fft(A, nn, false);
	fft(B, nn, false);

	for(int i = 0;i<nn;i++)
		A[i] = A[i] * B[-i & (nn-1)];

	fft(A, nn, true);


	for(int i = 0;i<r-h+1;i++)
		for(int j = 0;j<c-w+1;j++) {
			score = h * w * F[ i+ii ][ j+jj ] * F[ i+ii ][ j+jj ];
			score += SumSumP;
			score += SumSumF[i+h][j+w] - SumSumF[i][j+w] - SumSumF[i+h][j] + SumSumF[i][j];
			score += 2 * F[ i+ii ][ j+jj ] * SumP;
			score -= 2 * F[ i+ii ][ j+jj ] * ( SumF[i+h][j+w] - SumF[i][j+w] - SumF[i+h][j] + SumF[i][j] );
			score -= 2 *  correct(A[ i * c + j ].x);

			q.push( make_pair( score, make_pair(i+1, j+1) ) );
			if((int) q.size() >  k)
				q.pop();
		}

	while(q.size()) {
		s.push( q.top() );
		q.pop();
	}


	while(!s.empty()) {
		printf("%d %d %d\n", s.top().second.first, s.top().second.second, s.top().first);
		s.pop();
	}
	return 0;
}
