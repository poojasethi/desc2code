// This is Oleg's solution
// I'm only using this to see if it passes the strict time limits
// because my similar solution isn't.
#include <assert.h> 
#include <ctype.h> 
#include <float.h> 
#include <math.h> 
#include <stdio.h> 
#include <string> 
#include <stdlib.h> 
#include <time.h> 
#include <algorithm> 
#include <numeric> 
#include <functional> 
#include <utility> 
#include <vector> 
#include <list> 
#include <set> 
#include <map> 
#include <queue> 
#include <stack> 
#include <sstream> 
#include <iostream> 
#include <memory.h>
#include <complex> 

using namespace std; 

int nextInt()
{
	int t;
	scanf(" %d", &t);
	return t;
}

int land[700][700];
int layout[350][350];

struct Result
{
	int i, j;
	int score;

	bool operator<(const Result& r) const {
		if (score != r.score)
			return score < r.score;

		if (i != r.i)
			return i < r.i;
		return j < r.j;
	}
};


int sum[700][700];
int sum2[700][700];

Result res[700 * 700];

int landHeight, landWidth;
int layoutHeight, layoutWidth;

int multTable[700][700];
int multTableBf[700][700];

void CreateMultTableBF()
{
	for (int i = 0; i <= landHeight - layoutHeight; i++)
	{
		for (int j = 0; j <= landWidth - layoutWidth; j++)
		{
			int s = 0;
			for (int ii = 0; ii < layoutHeight; ii++)
			{
				for (int jj = 0; jj < layoutWidth; jj++)				
					s += land[i + ii][j + jj] * layout[ii][jj];
			}

			multTableBf[i][j] = s;
		}
	}
}

#define M_PI 3.14159265358979323846

struct base
{
	double real;
	double imag;
};


base a[(1 << 20) + 7];
base b[(1 << 20) + 7];


void fft (base* a, int n, bool invert) 
{ 
	for (int i=1, j=0; i<n; ++i) 
	{
		int bit = n >> 1;
		for (; j>=bit; bit>>=1)
			j -= bit;
		j += bit;
		if (i < j)
			swap (a[i], a[j]);
	}

	for (int len=2; len<=n; len<<=1) 
	{
		double ang = 2*M_PI/len * (invert ? -1 : 1);
		
		double cs = cos(ang);
		double sn = sin(ang);

		for (int i=0; i<n; i+=len) 
		{
			int hlen = len >> 1;

			double wreal = 1;
			double wimag = 0;
			base u;

			base* pa1 = a + i;
			base* pa2 = a + i + hlen;

			for (int j=0; j<hlen; ++j) 
			{
				base& a1 = *pa1++;
				base& a2 = *pa2++;

				u = a1;

				double vreal = a2.real * wreal - a2.imag * wimag;
				double vimag = a2.real * wimag + a2.imag * wreal;

				a1.real += vreal;
				a1.imag += vimag;

				a2.real = u.real - vreal;
				a2.imag = u.imag - vimag;

				double wreal2 = wreal;

				wreal = wreal * cs - wimag * sn;
				wimag = wreal2 * sn + wimag * cs;


			}
		}
	}
	if (invert)
		for (int i= n; i >= 0; --i)
			a[i].real /= n;
}

inline base multiply(const base& left, const base& right)
{
	base res;
	res.real = left.real * right.real - left.imag * right.imag;
	res.imag = left.real * right.imag + left.imag * right.real;

	return res;
}
void multiply (int n, base* a, base* b, base* res)
{
	fft (a, n, false);
	fft (b, n, false);

	for (int i=0; i<n; ++i)
	{
		res[i] = multiply(a[i], b[i]);
	}

	fft (res, n, true);
}

void CreateMultTableFast()
{
	int sz = landHeight * landWidth;

	int cur = sz - 1;
	for (int i = 0; i < landHeight; i++)
	{
		for (int j = 0; j < landWidth; j++)
		{
			a[cur--].real = land[i][j];
		}
	}
	cur = 0;

	for (int i = 0; i < layoutHeight; i++)
	{
		for (int j = 0; j < layoutWidth; j++)
		{
			b[cur++].real = layout[i][j];
		}
		cur += landWidth - layoutWidth;
	}


	int n = 1;
	while (n < (int) sz * 2 )  n <<= 1;
	n >>= 1;

	assert(n <= (1 << 20));


	multiply(n, a, b, a);

	assert (clock() < 7 * CLOCKS_PER_SEC);

	for (int i = 0; i <= landHeight - layoutHeight; i++)
	{
		for (int j = 0; j <= landWidth - layoutWidth; j++)
		{
			double r = a[sz - 1 - (i * landWidth + j)].real;
			int res2 = r >= 0 ? int(r + 0.5) : int(r - 0.5);

			multTable[i][j] = res2;
		}
	}
}

#if 0
void CreateMultTableFast2()
{
	int nPolyHeight = (landHeight + 1) / 2;
	assert (layoutHeight <= nPolyHeight);

	int sz = nPolyHeight * landWidth;
	int cur = sz  - 1;
	
	for (int i = 0; i < nPolyHeight; i++)
	{
		for (int j = 0; j < landWidth; j++)
		{
			a[cur--].real = land[i][j];
		}
	}
	cur = 0;

	for (int i = 0; i < layoutHeight; i++)
	{
		for (int j = 0; j < layoutWidth; j++)
		{
			b[cur++].real = layout[i][j];
		}
		cur += landWidth - layoutWidth;
	}


	int n = 1;
	while (n < (int) sz * 2 )  n <<= 1;

	assert(n <= (1 << 19));

	prepare(n);

	multiply(n, a, b, a);
	

	assert (clock() < 4 * CLOCKS_PER_SEC); // 4.42 

	for (int i = 0; i < nPolyHeight; i++)
	{
		for (int j = 0; j <= landWidth - layoutWidth; j++)
		{
			double r = a[sz - 1 - (i * landWidth + j)].real;
			int res2 = r >= 0 ? int(r + 0.5) : int(r - 0.5);

			multTable[i][j] = res2;
		}
	}

	memset(a, 0, sizeof(a));
	memset(b, 0, sizeof(b));

	cur = sz  - 1;

	for (int i = 0; i < nPolyHeight; i++)
	{
		for (int j = 0; j < landWidth; j++)
		{
			a[cur--].real = land[2 * nPolyHeight - 1 - i][landWidth - 1 - j];
		}
	}
	cur = 0;

	for (int i = 0; i < layoutHeight; i++)
	{
		for (int j = 0; j < layoutWidth; j++)
		{
			b[cur++].real = layout[layoutHeight - 1 - i][layoutWidth - 1 - j];
		}
		cur += landWidth - layoutWidth;
	}

	assert (clock() < 7 * CLOCKS_PER_SEC); 

	multiply(n, a, b, a);

	for (int i = 0; i < nPolyHeight; i++)
	{
		for (int j = 0; j <= landWidth - layoutWidth; j++)
		{
			double r = a[sz - 1 - (i * landWidth + j)].real;
			int res2 = r >= 0 ? int(r + 0.5) : int(r - 0.5);

			multTable[2 * nPolyHeight - layoutHeight - i][landWidth - layoutWidth - j] += res2;
		}
	}


#if 0
	for (int i = 0; i <= landHeight - layoutHeight; i++)
	{
		for (int j = 0; j <= landWidth - layoutWidth; j++)
		{
			
			assert (multTableBf[i][j] == multTable[i][j]);
		}
	}
#endif
}
#endif


void Generate()
{
	landHeight = 100;
	landWidth = 100;
	printf("%d %d\n", landHeight, landWidth);

	for (int i = 0; i < landHeight; i++)
	{
		for (int j = 0; j < landWidth; j++)
		{
			printf("%d ", rand() % 61 - 30);
		}
		printf("\n");
	}

	layoutHeight = 50;
	layoutWidth = 50;
	printf("%d %d\n", layoutHeight, layoutWidth);

	for (int i = 0; i < layoutHeight; i++)
	{
		for (int j = 0; j < layoutWidth; j++)
		{
			printf("%d ", rand() % 61 - 30);
		}
		printf("\n");
	}

	printf("1 1 1000");
}

int main(int argc, char* argv[])
{
#if 0
	//Generate();
	//return 0;
#endif
	landHeight = nextInt();
	landWidth = nextInt();

	assert (landHeight <= 666);
	assert (landWidth <= 666);

	for (int i = 0; i < landHeight; i++)
	{
		for (int j = 0; j < landWidth; j++)
		{
			land[i][j] = nextInt();

		}
	}
	layoutHeight = nextInt();
	layoutWidth = nextInt();

	assert (layoutHeight <= 350);
	assert (layoutWidth <= 350);

	int layoutSum = 0, layoutSum2 = 0;

	for (int i = 0; i < layoutHeight; i++)
	{
		for (int j = 0; j < layoutWidth; j++)
		{
			int a = nextInt();
			layout[i][j] = a;

			layoutSum += a;
			layoutSum2 += a * a;

			assert(a >= -30 && a <= 30);
		}
	}


	CreateMultTableFast();


	int oy = nextInt() - 1;
	int ox = nextInt() - 1;


	int K = nextInt();


	for (int i = 0; i < landHeight; i++)
	{
		for (int j = 0; j < landWidth; j++)
		{
			int a = land[i][j];

			sum[i + 1][j + 1] = a + sum[i][j + 1] + sum[i + 1][j] - sum[i][j];
			sum2[i + 1][j + 1] = a * a + sum2[i][j + 1] + sum2[i + 1][j] - sum2[i][j];
		}
	}

	int resCount = 0;
	int layoutArea = layoutHeight * layoutWidth;
	for (int i = 0; i <= landHeight - layoutHeight; i++)
	{
		for (int j = 0; j <= landWidth - layoutWidth; j++)
		{

			res[resCount].i = i;
			res[resCount].j = j;
			int base = land[i + oy][j + ox];

			int score = sum2[i + layoutHeight][j + layoutWidth] - sum2[i][j + layoutWidth] - sum2[i + layoutHeight][j] + sum2[i][j];
			score += base * base * layoutArea;
			score += layoutSum2;

			score -= (sum[i + layoutHeight][j + layoutWidth] - sum[i][j + layoutWidth] - sum[i + layoutHeight][j] + sum[i][j]) * base * 2;
			score -= (multTable[i][j] * 2);
			score += layoutSum * base * 2;


			res[resCount].score = score;

			resCount++;
		}
	}


	nth_element(res, res + K, res + resCount);
	sort(res, res + K);

	for (int i = 0; i < K; i++)
	{
		printf("%d %d %d\n", res[i].i + 1, res[i].j + 1, res[i].score);
	}

#ifndef ONLINE_JUDGE
	// printf("%d\n", clock());
#endif

	return 0;
}     
