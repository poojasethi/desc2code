#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<map>
#include<vector>
#include<algorithm>
#include<cmath>
#include<cstdlib>
using namespace std;
#define INF 2000000000
#define FOR(i,x,n) for(int i=x;i<=n;i++)
#define REV(i,x,n) for(int i=x;i>=n;i--)
#define si(x) scanf("%d",&x)
#define sl(x) scanf("%lld",&x)
#define sd(x) scanf("%lf",&x)
#define LL long long
#define test int T;scanf("%d",&T);while(T--)
#define pb push_back
#define pob() pop_back()
#define b() begin()
#define e() end()
#define s() size()
#define cl() clear()
#define mp make_pair
#define fi first
#define se second
#define LD long double
#define SZ 105
 
int dp[SZ][SZ],dist[SZ][SZ],wt[SZ][SZ];
vector<int> adj[SZ];
int vis[SZ],best[SZ];
int n,d;
 
void distcal(int r,int u,int sum)
{
        if(dist[r][u]>=0) return;
        dist[r][u]=sum;
        FOR(i,0,adj[u].s()-1) 
                {
                        int v=adj[u][i];
                        distcal(r,v,sum+wt[u][v]);
                }
                
        }
        
void fn(int u)//dp :-u rooted tree with centre c
        {
                int p=u;
                vis[u]=1;
                
                FOR(i,0,adj[u].s()-1)
                {
                        int v=adj[u][i];
                        if(vis[v]) {p=v;continue;}
                        
                        fn(v);
                }
                        
                        best[u]=0;
                        FOR(c,0,n-1)
                        {
                                if(dist[u][c] > d) continue;
                                dp[u][c]=0;
                                
                                FOR(i,0,adj[u].s()-1)
                                        {
                                                int v=adj[u][i];
                                                if(p==v) continue;//p===parent
                                                
                                                if(dist[u][c]==dist[u][v]+dist[v][c])//i.e.c is in subtree rooted at v
                                                        dp[u][c]+=wt[u][v]+dp[v][c];
                                                else if(dist[v][c] <= d)//i.e. c is not in the subtree but within d
                                                        dp[u][c]+=max(best[v],wt[u][v]+dp[v][c]);
                                                else//i.e. c is not in the subtree and unreachable
                                                        dp[u][c]+=best[v];
                                                        
                                                }
                                if(dist[p][c]==dist[p][u]+dist[u][c]) best[u]=max(best[u],dp[u][c]);
                                
                        }
                        
                }
                
                                                
                                
        
int main()
{
        test{
                si(n);si(d);
                
                FOR(i,1,n-1)
                {int u,v,w;
                si(u);si(v);si(w);
                adj[u].pb(v);adj[v].pb(u);
                wt[u][v]=wt[v][u]=w;}
                
                memset(dist,-1,sizeof(dist));
                
                FOR(i,0,n-1)
                distcal(i,i,0);
                
                /*FOR(i,0,n-1)
                {FOR(j,0,n-1)
                cout<<dist[i][j]<<' ';
                cout<<endl;}*/
                
                
                memset(vis,0,sizeof(vis));
                fn(0);
                printf("%d\n",best[0]);
                
                FOR(i,0,n-1) adj[i].cl();
        }
        
        //cin>>T;
        return 0;
        }
 