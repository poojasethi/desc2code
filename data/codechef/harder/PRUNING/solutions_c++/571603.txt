#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 101;

#define node first
#define weight second

int N, D;
int test;

vector < pair < int, int > > adj[ MAXN ];
int can[ MAXN ][ MAXN ];

int dp[ MAXN ][ MAXN + 10 ];

// root the tree and find matrix can[x][y] -> x can reach y
void reach( int curr, int dad, int sum, int center )
{
  if ( sum > D ) return;

  for ( int i = 0; i < adj[curr].size(); ++i ) {
    int next = adj[curr][i].node; if ( next == dad ) continue;
    int w = adj[curr][i].weight;
    if ( sum + w <= D ) {
      can[center][next] = test;
      can[next][center] = test;
      reach( next, curr, sum + w, center );
    }
  }
}

int solve( int curr, int dad, int center )
{
  int &ref = dp[curr][center+1];
  if ( ref != -1 ) return ref;
  ref = 0;

  if ( center == -1 ) {
    for ( int i = 0; i < N; ++i )
      if ( can[curr][i] == test ) 
	ref = max( ref, solve( curr, dad, i ) ); // all centers
    return ref; 
  }

  for ( int i = 0; i < adj[curr].size(); ++i ) {
    int next = adj[curr][i].node; if ( next == dad ) continue;
    int w = adj[curr][i].weight;
    int tmp = solve( next, curr, -1 ); // stop path here and find new

    if ( can[center][next] == test ) 
      tmp = max( tmp, w + solve( next, curr, center ) ); // add to path
    
    ref += tmp;
  }

  return ref;
}

void process()
{
  for ( int i = 0; i < N; ++i ) adj[i].clear();

  scanf( "%d%d", &N, &D );

  for ( int i = 0; i+1 < N; ++i ) {
    int a, b, c; scanf( "%d%d%d", &a, &b, &c ); //--a, --b;
    adj[a].push_back( make_pair( b, c ) );
    adj[b].push_back( make_pair( a, c ) );
  }

  for ( int i = 0; i < N; ++i ) {
    reach( i, -1, 0, i );
    can[i][i] = test;
  }

  memset( dp, -1, sizeof dp );
  int sol = (!D) ? 0 : solve( 1, -1, -1 );
  printf( "%d\n", sol );
}

int main()
{
  memset( can, -1, sizeof can );
  scanf( "%d", &test );
  while ( test-- ) process();
}
