#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long ll;
struct EQ {
	ll a, m;
	EQ() {}
	EQ(ll a_, ll m_) : a(a_), m(m_) {}
};
struct VE {
	EQ v[5];
};

#define UPT(a, b, m) { \
	(a) += (b); \
	if ((a) >= (m)) (a) -= (m); \
}

inline ll Mul(ll a, ll b, ll m) {
	if (a < b) swap(a, b);
	ll res = 0;
	while (b) {
		if (b & 1) UPT(res, a, m);
		b >>= 1;
		UPT(a, a, m);
	}
	return res;
}

inline ll Pow(ll a, ll b, ll m) {
	ll res = 1;
	while (b) {
		if (b & 1) res = Mul(res, a, m);
		b >>= 1;
		a = Mul(a, a, m);
	}
	return res;
}

namespace fun {
	ll Gcd(ll a, ll b) {
		return (b ? Gcd(b, a % b) : a);
	}

	ll ExGcd(ll a, ll b, ll &x, ll &y) {
		if (!b) {
			x = 1, y = 0;
			return a;
		}
		else {
			ll g = ExGcd(b, a % b, x, y);
			ll t = x;
			x = y, y = t - (a / b) * x;
			return g;
		}
	}

	ll CalcInv(ll x, ll m) {
		ll p, q;
		x %= m;
		ExGcd(x, m, p, q);
		p = (p % m + m) % m;
		return p;
	}

	ll SolveVE(VE mat) {
		int n = 2;
		for (int i = 1; i < n; ++ i) {
			ll g = fun::Gcd(mat.v[i - 1].m, mat.v[i].m);
			ll t = mat.v[i].a - mat.v[i - 1].a;
			t = (t % mat.v[i].m + mat.v[i].m) % mat.v[i].m;
			ll x, y;
			fun::ExGcd(mat.v[i - 1].m / g, mat.v[i].m / g, x, y);
			x = (x % (mat.v[i].m / g) + (mat.v[i].m / g)) % (mat.v[i].m	/ g);
			x = Mul(x, t / g, mat.v[i].m / g);
			mat.v[i].m = mat.v[i].m / g * mat.v[i - 1].m;
			mat.v[i].a = mat.v[i - 1].a;
			UPT(mat.v[i].a, Mul(x, mat.v[i - 1].m, mat.v[i].m), mat.v[i].m);
		}
		return mat.v[n - 1].a;
	}

	ll SolveVEQ(VE mat, ll M) {
		static ll inv[5][5];
		static bool calced = false;
		if (!calced) {
			calced = true;
			for (int i = 0; i < 5; ++ i)
				for (int j = 0; j < 5; ++ j)
					inv[i][j] = fun::CalcInv(mat.v[j].m, mat.v[i].m);
		}
		ll val[5];
		for (int i = 0; i < 5; ++ i) val[i] = mat.v[i].a;
		for (int i = 0; i < 5; ++ i)
			for (int j = 0; j < i; ++ j) {
				ll tmp = (val[i] - val[j] + mat.v[i].m) % mat.v[i].m;
				val[i] = tmp * inv[i][j] % mat.v[i].m;
			}
		ll res = 0;
		for (int i = 4; i >= 0; -- i) {
			res = Mul(res, mat.v[i].m % M, M) + val[i];
			res %= M;
		}
		return res;
	}
}

namespace fft {
	const int kPrime[5] = {2095054849, 2099249153, 2113929217, 2114977793, 2130706433};
	const int kRoot[5] = {11, 3, 5, 3, 3};
	const int kMaxL = 1 << 16;
	ll w[5][kMaxL][2];
	bool inited;
	ll a[kMaxL], b[kMaxL], c[kMaxL];
	ll fft_a[kMaxL], fft_b[kMaxL], fft_c[kMaxL];
	VE mat[kMaxL];
	int T;
	ll MOD;

	void Init(int L) {
		if (inited) return;
		T = L;
		inited = true;
		for (int i = 0; i < 5; ++ i) {
			ll a = Pow(kRoot[i], (kPrime[i] - 1) / L, kPrime[i]);
			ll b = fun::CalcInv(a, kPrime[i]);
			w[i][0][0] = w[i][0][1] = 1;
			for (int j = 1; j < L; ++ j) {
				w[i][j][0] = w[i][j - 1][0] * a % kPrime[i];
				w[i][j][1] = w[i][j - 1][1] * b % kPrime[i];
			}
		}
	}

	void FFT(int pri, ll *des, ll *src, int len, int sgn) {
		if (len == 1) {
			des[0] = src[0];
			return;
		}
		ll *rec[2];
		for (int i = 0; i < 2; ++ i) {
			rec[i] = des + (len >> 1) * i;
			FFT(pri, rec[i], src + T / len * i, len >> 1, sgn);
		}
		for (int i = 0, j = 0; i < (len >> 1); ++ i, j += T / len) {
			ll a = rec[0][i] + w[pri][j][sgn] * rec[1][i] % kPrime[pri];
			ll b = rec[0][i] - w[pri][j][sgn] * rec[1][i] % kPrime[pri];
			if (a >= kPrime[pri]) a -= kPrime[pri];
			if (b < 0) b += kPrime[pri];
			des[i] = a;
			des[i + (len >> 1)] = b;
		}
	}

	void Run(ll *A, ll *B, ll *C, int L) {
		Init(L);
		for (int i = 0; i < 5; ++ i) {
			for (int j = 0; j < L; ++ j) a[j] = A[j] % kPrime[i];
			for (int j = 0; j < L; ++ j) b[j] = B[j] % kPrime[i];
			FFT(i, fft_a, a, L, 0);
			FFT(i, fft_b, b, L, 0);
			for (int j = 0; j < L; ++ j) fft_c[j] = fft_a[j] * fft_b[j] % kPrime[i];
			FFT(i, c, fft_c, L, 1);
			ll e = fun::CalcInv(L, kPrime[i]);
			for (int j = 0; j < L; ++ j) mat[j].v[i] = EQ(c[j] * e % kPrime[i], kPrime[i]);
		}
		for (int i = 0; i < L; ++ i) C[i] = fun::SolveVEQ(mat[i], MOD);
	}
}

namespace solve {
	const int kBufSize = 1 << 17;
	const int kMaxD = 20000;
	ll M, Q, P[kMaxD + 13], NN;
	int D;
	char N[kBufSize];

	void Split(ll M, ll &M1, ll &M2) {
		M1 = M;
		for ( ; ; ) {
			ll g = fun::Gcd(M1, Q - 1);
			if (g == 1) break;
			M1 /= g;
		}
		M2 = M / M1;
	}

	namespace solve1 {
		const int kMaxL = 1 << 16;
		ll p[kMaxL], q[kMaxL], a[kMaxL], y[kMaxL];
		int L;
		ll fac_inv[kMaxD], fac[kMaxD];

		ll Run(ll M) {
			fft::MOD = M;
			L = 1;
			while (L < (D << 1)) L <<= 1;
			fac_inv[0] = fac[0] = 1;
			for (int i = 1; i < D; ++ i) {
				fac_inv[i] = Mul(fac_inv[i - 1], fun::CalcInv(i, M), M);
				fac[i] = Mul(fac[i - 1], i % M, M);
			}

			memset(p, 0, sizeof(ll) * L);
			memset(q, 0, sizeof(ll) * L);
			for (int i = 0; i < D; ++ i) p[i] = Mul(P[i] % M, fac_inv[i], M);
			for (int i = 0; i < D; ++ i) {
				q[i] = fac_inv[i];
				if (i & 1) q[i] = M - q[i];
			}
			fft::Run(p, q, a, L);
			for (int i = 0; i < D; ++ i) a[i] = Mul(a[i], fac[i], M);

			NN = 0;
			for (int i = 0, sz = strlen(N); i < sz; ++ i) {
				NN = Mul(NN, 10 % M, M);
				UPT(NN, (N[i] - '0') % M, M);
			}

			memset(p, 0, sizeof(ll) * L);
			memset(q, 0, sizeof(ll) * L);
			p[0] = 1, q[0] = fun::CalcInv(((1 - Q) % M + M) % M, M);
			for (int i = 1; i < D; ++ i) {
				p[i] = Mul(p[i - 1], ((NN - i + 1) % M + M) % M, M);
				p[i] = Mul(p[i], fun::CalcInv(i, M), M);
				q[i] = Mul(q[i - 1], Q % M, M);
				q[i] = Mul(q[i], q[0], M);
			}
			fft::Run(p, q, y, L);

			ll QN = 1;
			static ll powQ[10];
			powQ[0] = 1;
			for (int i = 1; i < 10; ++ i) powQ[i] = Mul(powQ[i - 1], Q % M, M);
			for (int i = 0, sz = strlen(N); i < sz; ++ i) {
				ll tmp = QN;
				QN = Mul(QN, QN, M);
				QN = Mul(QN, QN, M);
				QN = Mul(QN, tmp, M);
				QN = Mul(QN, QN, M);
				QN = Mul(QN, powQ[N[i] - '0'], M);
			}
			ll res = 0;
			for (int i = 0; i < D; ++ i) {
				ll t = q[i];
				t -= Mul(QN, y[i], M);
				if (t < 0) t += M;
				UPT(res, Mul(t, a[i], M), M);
			}
			return res;
		}
	}

	namespace solve2 {
		const int kMaxL = 1 << 16;
		ll DD;
		ll comb[kMaxD + 14];
		ll T[kMaxD + 13];
		int L;
		ll p[kMaxL], q[kMaxL], t[kMaxL];
		ll fac[kMaxD + 13], fac_inv[kMaxD + 13];

		ll Run(ll M) {
			NN = 0;
			for (int i = 0, sz = strlen(N); i < sz; ++ i) {
				NN = Mul(NN, 10 % M, M);
				UPT(NN, (N[i] - '0') % M, M);
			}
			fft::inited = false;
			fft::MOD = M;
			int u = 0;
			ll cur = 1 % M;
			while (cur) {
				++ u;
				cur = Mul(cur, (Q - 1) % M, M);
			}
			comb[0] = 1;
			for (int i = 1; i <= D; ++ i) {
				comb[i] = Mul(comb[i - 1], ((D - i + 1) % M + M) % M, M);
				comb[i] = Mul(comb[i], fun::CalcInv(i, M), M);
			}
			if (!u) return 0LL;
			DD = D + u - 1;
			for (int i = D; i < DD; ++ i) {
				P[i] = 0;
				for (int j = 1; j <= D; ++ j) {
					ll tmp = Mul(comb[j], P[i - j] % M, M);
					if ((j - 1) & 1) tmp = M - tmp;
					UPT(P[i], tmp, M);
				}
			}
			ll powQ = 1 % M;
			for (int i = 0; i < DD; ++ i) {
				T[i] = Mul(P[i] % M, powQ, M);
				powQ = Mul(powQ, Q % M, M);
			}

			fac[0] = fac_inv[0] = 1 % M;
			for (int i = 1; i < DD; ++ i) {
				fac[i] = Mul(fac[i - 1], i % M, M);
				fac_inv[i] = Mul(fac_inv[i - 1], fun::CalcInv(i, M), M);
			}
			L = 1;
			while (L < (DD << 1)) L <<= 1;
			memset(p, 0, sizeof(ll) * L);
			memset(q, 0, sizeof(ll) * L);
			for (int i = 0; i < DD; ++ i) p[i] = Mul(T[i], fac_inv[i], M);
			for (int i = 0; i < DD; ++ i) {
				q[i] = fac_inv[i];
				if (i & 1) q[i] = M - q[i];
			}
			fft::Run(p, q, t, L);
			for (int i = 0; i < DD; ++ i) t[i] = Mul(t[i], fac[i], M);
			
			comb[0] = 1;
			for (int i = 1; i <= DD; ++ i) {
				comb[i] = Mul(comb[i - 1], ((NN - i + 1) % M + M) % M, M);
				comb[i] = Mul(comb[i], fun::CalcInv(i, M), M);
			}
			ll res = 0;
			for (int i = 0; i < DD; ++ i)
				UPT(res, Mul(t[i], comb[i + 1], M), M);
			return res;
		}
	}

	void Run() {
		scanf("%lld%lld%s%d", &M, &Q, N, &D);
		++ D;
		for (int i = 0; i < D; ++ i) scanf("%lld", &P[i]);
		if (Q == 0) {
			printf("%lld\n", P[0]);
			return;
		}
		ll M1, M2;
		Split(M, M1, M2);
		VE mat;
		mat.v[0] = EQ(solve1::Run(M1), M1);
		mat.v[1] = EQ(solve2::Run(M2), M2);
		ll ans = fun::SolveVE(mat) % M;
		printf("%lld\n", ans);
	}
}

int main() {
	int T;
	for (scanf("%d", &T); T --; ) {
		fft::inited = false;
		solve::Run();
	}
	return 0;
}
