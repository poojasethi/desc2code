#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
 
typedef long long LL;
typedef unsigned long long ULL;
 
struct BigDec {
	LL n; // integer part
	double a; // fractional part
 
	BigDec(){}
	BigDec(LL n_, double a_) { n=n_; a=a_; }
	double val() { return n+a; }
 
	bool operator<(const BigDec &r) const	{
		return n<r.n || (n==r.n && a<r.a);
	}
 
	bool operator==(const BigDec &r) const	{
		return n==r.n && fabs(a-r.a)<1e-14;
	}
 
	BigDec operator+(const BigDec &r) const {
		LL sn = n + r.n;
		double sa = a + r.a;
		if(sa>=1-1e-14) sa-=1., sn++;
		return BigDec(sn,sa);
	}
 
	void print() {
		char s[111];
		sprintf(s,"%.13lf",a);
		printf("%lld%s\n",n,s+1);
	}
};
 
BigDec cool_sqrt(ULL x)
{
	if(x==0) return BigDec(0,0.);
	ULL n = ULL(sqrt(x+0.));
	if(n*n<=x)
		for(;(n+1)*(n+1)<=x;n++);
	else
		for(;n*n>x;n--);
	return BigDec(n, (x-n*n)/(sqrt(x+0.)+n));
}
 
ULL norm2(LL x, LL y)
{
	return ULL(x*x)+ULL(y*y);
}
 
struct point
{
	int x,y;
	int u,v; // v<0 for changing sign
	point(){}
	point(int x_,int y_,int u_,int v_) { x=x_; y=y_; u=u_; v=v_; }
	int halfplane() const { return y>0 || y==0 && x>0 ? 0 : 1; }
	bool operator<(const point &p) const
	{
		int hp=halfplane();
		int php=p.halfplane();
		if(hp!=php) return hp<php;
		return x * LL(p.y) > y * LL(p.x);
	}
	bool operator==(const point &p) const
	{
		return halfplane() == p.halfplane() && x * LL(p.y) == y * LL(p.x);
	}
};
 
const int maxN = 500;
const int maxX = 1000000;
int n,k;
int x[maxN],y[maxN];
pair<int,int> xy[maxN];
int ax,ay,bx,by,cx,cy;
 
point a[maxN*(maxN+1)];
int p[maxN];
int sgn[maxN];
int inpos[maxN];
int posx,posy;
int b[maxN*(maxN+1)];
 
bool lessp(int u,int v)
{
	return p[u]<p[v];
}
 
void add(int u) 
{
	if(sgn[u]>0 && p[u]<k && !inpos[u]) {
		posx+=x[u];
		posy+=y[u];
		inpos[u]=1;
	}
}
 
void del(int u) 
{
	if(sgn[u]>0 && p[u]<k && inpos[u]) {
		posx-=x[u];
		posy-=y[u];
		inpos[u]=0;
	}
}
 
int main()
{
	scanf("%d %d", &n, &k);
	scanf("%d %d", &ax, &ay);
	scanf("%d %d", &bx, &by);
	scanf("%d %d", &cx, &cy);
 
	int i,j,h,l;
	int m=0;
	for(i=0;n--;)
	{
		int xi,yi;
		scanf("%d %d", &xi, &yi);
		if(xi==0 && yi==0) continue;
		x[i]=xi; y[i]=yi;
		xy[i]=make_pair(xi,yi);
		a[m++] = point(xi,yi,i,-1);
		a[m++] = point(-xi,-yi,i,-1);
		i++;
	}
	n=i;
 
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
			if(xy[i]!=xy[j])
				a[m++]=point(x[i]-x[j],y[i]-y[j],i,j);
	sort(a,a+m);
 
	int x0=2*maxX+1,y0=-1;
	pair<LL,int> v[maxN];
	for(i=0;i<n;i++)
		v[i]=make_pair(LL(x0)*y[i]-LL(y0)*x[i],i);
	sort(v,v+n);
	reverse(v,v+n);
 
	posx=ax, posy=ay;
	for(i=0;i<n;i++)
	{
		j=v[i].second;
		p[j]=i;
		sgn[j] = v[i].first<0 ? -1 : 1;
		add(j);
	}
 
	BigDec ans = cool_sqrt(norm2(bx-ax,by-ay)) + cool_sqrt(norm2(cx-ax,cy-ay));
 
	int mark[maxN][maxN]={0};
	int id=0;
	for(i=0;i<m;i=j)
	{
		int blen=0;
		id++;
		for(j=i;j<m && a[i]==a[j];j++)
		{
			int u=a[j].u;
			int v=a[j].v;
			if(v<0) {
				del(u);
				sgn[u]=-sgn[u];
				add(u);
			} else {
				b[blen++]=u;
				b[blen++]=v;
				mark[u][v]=mark[v][u]=id;
			}
		}
		sort(b,b+blen,lessp);
		blen = unique(b,b+blen)-b;
		for(h=0;h<blen;h=l)
		{
			for(l=h+1;l<blen && (mark[b[l]][b[h]]==id || xy[b[l]]==xy[b[h]]);l++);
			for(int h1=h,l1=l-1;h1<l1;h1++,l1--)
			{
				int u=b[h1];
				int v=b[l1];
				del(u);
				del(v);
				swap(p[u],p[v]);
				add(u);
				add(v);
			}
		}
		BigDec cur = cool_sqrt(norm2(LL(bx)-posx,LL(by)-posy)) +
					 cool_sqrt(norm2(LL(cx)-posx,LL(cy)-posy));
		if (ans < cur) {
			ans=cur;
		}
	}
	ans = ans + cool_sqrt(norm2(bx-cx,by-cy));
	ans.print();
	return 0;
}
 