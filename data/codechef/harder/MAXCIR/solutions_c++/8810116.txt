#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
const int inf=1061109567;
//const ll inf=1000000000000000000ll;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int dx[4]={1,0,-1,0}; int dy[4]={0,1,0,-1};
#define x1 x192837465
#define x2 x123456789
#define y1 y192837465
#define y2 y123456789
struct point{
	ll x,y;
	void r(){
		gn(x);gn(y);
	}
}A,B,C,p[555];
int tms[555];
point operator+(const point&a,const point&b){return (point){a.x+b.x,a.y+b.y};}
point operator-(const point&a,const point&b){return (point){a.x-b.x,a.y-b.y};}
point operator*(const point&a,int k){return (point){a.x*k,a.y*k};}
ull dq(const point&a,const point&b){return ull(1ll*(a.x-b.x)*(a.x-b.x))+ull(1ll*(a.y-b.y)*(a.y-b.y));}
ll cross(const point&a,const point&b){return 1ll*a.x*b.y-1ll*a.y*b.x;}
ll dot(const point&a,const point&b){return 1ll*a.x*b.x+1ll*a.y*b.y;}
int n,k;

int ff(const point&a){
	if(a.y<0 || a.y==0 && a.x<0)return 0;
	else return 1;
}
int cmpp(const point&a,const point &b){
	int aa=ff(a),bb=ff(b);
	if(aa!=bb)return aa<bb;
	return cross(a,b)>0;
}
struct ev{
	point p;
	int a,b;
}a[333333];int atot;
int cmp(const ev&a,const ev&b){
	int x=cmpp(a.p,b.p),y=cmpp(b.p,a.p);
	if(!x && !y)return a.b<b.b;
	else return x;
}

point ppp;
int cmpd(int i,int j){
	return dot(p[i],ppp)>dot(p[j],ppp);
}

int ord[555];
int pos[555];
point pre[555];
int pcnt[555];
void sw(int i){//i and i+1
	int a=ord[i],b=ord[i+1];
	swap(pos[a],pos[b]);
	swap(ord[i],ord[i+1]);
	pre[i]=pre[i-1]+p[ord[i]]*tms[ord[i]];
	pre[i+1]=pre[i]+p[ord[i+1]]*tms[ord[i+1]];
	pcnt[i]=pcnt[i-1]+tms[ord[i]];
	pcnt[i+1]=pcnt[i]+tms[ord[i+1]];
}


struct num{
	ull i;
	db d;
	num operator+(const num&b){
		ull x=i+b.i;db y=d+b.d;
		if(y>1)x++,y-=1;
		return (num){x,y};
	}
	int operator<(const num&b){
		if(i!=b.i)return i<b.i;
		else return d<b.d;
	}
	void sq(ull s){
		if(s==0)i=0,d=0.0;
		else{
			i=(ull)(sqrt(db(s)));
			d=(s-1ull*i*i)/((db)i+sqrt(db(s)));
		}
	}
}an;

void calc(point a){
	num x,y;
	x.sq(dq(A+a,B));
	y.sq(dq(A+a,C));
	x=x+y;
	if(an<x)an=x;
}
void upd(){
	int l=1,r=n,mid;
	while(l<=r){
		mid=l+r>>1;
		if(dot(p[ord[mid]],ppp)>0)l=mid+1;
		else r=mid-1;
	}
	if(pcnt[r]<=k)calc(pre[r]);
	else{
		l=1,r=n;
		while(l<=r){
			mid=l+r>>1;
			if(pcnt[mid]<=k)l=mid+1;
			else r=mid-1;
		}
		calc(pre[r]+p[ord[l]]*(k-pcnt[r]));
	}
}
char s[11111];

point getmid(point a,point b){
	if(cross(a,b)==0)return (point){-a.y,a.x};
	else return a+b;
}
int main()
{
	//freopen("1.in","r",stdin);
	gn(n);gn(k);
	A.r();B.r();C.r();
	for (int i=1;i<=n;i++)p[i].r();
	for (int i=1;i<=n;i++)if(p[i].x==0 && p[i].y==0){
		swap(p[i],p[n]);
		n--;
		i--;
	}
	for (int i=1;i<=n;i++){
		tms[i]=1;
		for (int j=i+1;j<=n;j++)if(p[i].x==p[j].x && p[i].y==p[j].y){
			tms[i]++;
			swap(p[j],p[n]);
			n--;
			j--;
		}
	}
	atot=0;
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++){
			point x=p[j]-p[i];
			point y=(point){-x.y,x.x};
			a[++atot]=(ev){y,i,j};
			y.x*=-1,y.y*=-1;
			a[++atot]=(ev){y,j,i};
		}
	for (int i=1;i<=n;i++){
		point x=(point){-p[i].y,p[i].x};
		a[++atot]=(ev){x,0,i};
		x.x*=-1,x.y*=-1;
		a[++atot]=(ev){x,i,0};
	}
	sort(a+1,a+1+atot,cmp);

	ppp=getmid(a[1].p,a[atot].p);
	for (int i=1;i<=n;i++)ord[i]=i;
	sort(ord+1,ord+1+n,cmpd);
	for (int i=1;i<=n;i++)pos[ord[i]]=i;
	for (int i=1;i<=n;i++)pre[i]=pre[i-1]+p[ord[i]]*tms[ord[i]],pcnt[i]=pcnt[i-1]+tms[ord[i]];
	upd();
	for (int i=1;i<atot;i++){
		ppp=getmid(a[i].p,a[i+1].p);
		if(a[i].a && a[i].b){
			while(pos[a[i].a]>pos[a[i].b])sw(pos[a[i].b]);
		}
		upd();
	}
	num x;x.sq(dq(B,C));an=an+x;
	sprintf(s+1,"%.13lf",double(an.d));
	cout<<an.i;
	printf("%s\n",s+2);
} 
