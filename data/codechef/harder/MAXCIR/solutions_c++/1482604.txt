#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cassert>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <ctime>
#include <map>
#include <set>
using namespace std;
#define SIZE(A) ((int)A.size())
#define LENGTH(A) ((int)A.length())
#define MP(A,B) make_pair(A,B)
#define PB(A) push_back(A)
const int base = 1e9;
const int MAXN = 999;
int n, k;
long long x[MAXN], y[MAXN];
int q[MAXN];
long double val[MAXN];
long long xx, yy;
long long Ax, Ay, Bx, By, Cx, Cy;
struct big
{
int a[400];
int n;
void operator = (const int x) {memset(a, 0, sizeof(a)); a[0] = x; n = 1;}
void operator = (long long x)
{
memset(a, 0, sizeof(a));
n = 0;
for (int i = 0; x; i++)
{
a[i] = x%base;
x /= base;
n++;
}
}
bool operator < (const big &b)
{
if (b.n != n) return n<b.n;
for (int i = n-1; i >= 0; i--)
if (b.a[i]!=a[i]) return a[i]<b.a[i];
return 0;
}
void operator *= (const int x)
{
long long cur;
for (int i = 0, carry = 0; i < n || carry; i++)
{
if (i == n) a[n++] = 0;
cur = carry + 1LL*a[i]*x;
carry = cur/base;
a[i] = cur%base;
}
for (; n > 1 && !a[n-1]; n--);
}
big operator * (const big &b)
{
big c;
c = 0;
c.n = b.n+n+1;
long long cur;
for (int i = 0; i < n; i++)
for (int j = 0, carry = 0; j < b.n || carry; j++)
{
cur = carry + c.a[i+j];
if (j < b.n) cur += 1LL*a[i]*b.a[j];
carry = cur/base;
c.a[i+j] = cur%base;
}
for (; c.n > 1 && !c.a[c.n-1]; c.n--);
return c;
}
void operator += (const big &b)
{
for (int i = 0, carry = 0; i < b.n || carry; i++)
{
if (i == n) a[n++] = 0;
a[i] += carry;
if (i < b.n) a[i] += b.a[i];
carry = a[i]>=base;
if (carry) a[i] -= base;
}
}
void div2()
{
for (int i = n-1, t = 0, tmp; i >= 0; i--)
{
tmp = a[i]+t*base;
a[i] = tmp/2;
t = tmp&1;
}
for (; n > 1 && !a[n-1]; n--);
}
void write()
{
vector <int> val, vv;
val.clear();
for (int i = n-1; i >= 0; i--)
{
for (int j = 0, x = a[i]; j < 9; j++, x /= 10)
vv.PB(x%10);
for (; SIZE(vv); vv.pop_back())
val.PB(vv.back());
}
reverse(val.begin(), val.end());
// cerr << SIZE(val) << endl;
for (; SIZE(val)>19 && !val.back(); val.pop_back());
while (SIZE(val)<19) val.PB(0);
for (int i = SIZE(val)-1; i > 17; i--)
printf("%d", val[i]);
printf(".");
for (int i = 17; i > 4; i--)
printf("%d", val[i]);
}
};
big one;
inline big sqrt(big &b, long long up)
{
big ret; ret = 0;
big l, r, m, v; l = max(up-2, 0LL); r = max(up-2, 1LL);
for (int i = 0; i < 2; i++)
l *= 1000000000,
r *= 1000000000;
r *= 10;
 
for (; l < r;)
{
m = l;
m += r;
m.div2();
v = m*m;
if (b < v)
r = m;
else
{
l = m;
l += one;
}
}
return l;
}
long double tmp, cur, cur_tt, bst;
long long v1, v2, v3;
big best, cur_tot, A, B, C, ten7;
bool cmp(const int i, const int j)
{
return val[i]>val[j];
}
void do_calc(long long Ax, long long Ay)
{
cur_tt = 0;
cur = 0;
tmp = (Ax-Bx); tmp *= tmp;
cur += tmp;
tmp = (Ay-By); tmp *= tmp;
cur += tmp;
cur_tt += sqrt(cur);
v1 = sqrt(cur);
cur = 0;
tmp = (Ax-Cx); tmp *= tmp;
cur += tmp;
tmp = (Ay-Cy); tmp *= tmp;
cur += tmp;
cur_tt += sqrt(cur);
v2 = sqrt(cur);
cur = 0;
tmp = (Bx-Cx); tmp *= tmp;
cur += tmp;
tmp = (By-Cy); tmp *= tmp;
cur += tmp;
cur_tt += sqrt(cur);
v3 = sqrt(cur);
if (cur_tt+1 > bst)
{
A = 0; C = 0;
B = abs(Ax-Bx); B = B*B;
C += B;
B = abs(Ay-By); B = B*B;
C += B;
for (int i = 0; i < 4; i++)
C *= 1000000000;
A += sqrt(C, v1);
C = 0;
B = abs(Ax-Cx); B = B*B;
C += B;
B = abs(Ay-Cy); B = B*B;
C += B;
for (int i = 0; i < 4; i++)
C *= 1000000000;
A += sqrt(C, v2);
C = 0;
B = abs(Cx-Bx); B = B*B;
C += B;
B = abs(Cy-By); B = B*B;
C += B;
for (int i = 0; i < 4; i++)
C *= 1000000000;
A += sqrt(C, v3);
if (best < A)
bst = cur_tt,
best = A;
}
}

vector < pair <long long, long long> > qv;
int main()
{
double start = clock();
one = 1;
cin >> n >> k;
cin >> Ax >> Ay >> Bx >> By >> Cx >> Cy;
for (int i = 0; i < n; i++)
scanf("%lld%lld", x+i, y+i);
x[n] = 2*Ax-Bx-Cx; y[n] = 2*Ay-By-Cy;
do_calc(Ax, Ay);
for (int i = 0; i < n; i++)
	for (int j = i+1; j <= n; j++)
	{
	 	long long xx = y[j]-y[i], yy = x[i]-x[j];
	 	long long g = __gcd(abs(xx), abs(yy));
	 	if (g)
	 	{
	 		xx /= g, yy /= g;
	 		if (xx < 0 || (xx == 0 && yy < 0))
	 			xx = -xx,
	 			yy = -yy;
	 		qv.PB(MP(xx, yy));
	 	}
	}
sort(qv.begin(), qv.end());
qv.resize(unique(qv.begin(), qv.end())-qv.begin());
if (k)
{
for (int i = 0; i < SIZE(qv); i++)
{
int t = 0;
long long xx = qv[i].first, yy = qv[i].second;
for (int j = 0; j < n; j++)
{
	val[j] = 1.*xx*x[j] + 1.*yy*y[j];
	q[t++] = j;
}

sort(q, q + t, cmp);
xx = yy = 0;
for (int j = 0; j < k; j++)
{
xx += x[q[j]]; yy += y[q[j]];
do_calc(Ax+xx, Ay+yy);
}
xx = yy = 0;
for (int j = 0; j < k; j++)
{
xx += x[q[n-j-1]]; yy += y[q[n-j-1]];
do_calc(Ax+xx, Ay+yy);
}

if ((clock()-start)>2.6*CLOCKS_PER_SEC) break;
}
for (int i = 0; i <= n; i++)
{
int t = 0;
long long xx = x[i], yy = y[i];
for (int j = 0; j < n; j++)
{
	val[j] = 1.*xx*x[j] + 1.*yy*y[j];
	q[t++] = j;
}

sort(q, q + t, cmp);
xx = yy = 0;
for (int j = 0; j < k; j++)
{
xx += x[q[j]]; yy += y[q[j]];
do_calc(Ax+xx, Ay+yy);
}
xx = yy = 0;
for (int j = 0; j < k; j++)
{
xx += x[q[n-j-1]]; yy += y[q[n-j-1]];
do_calc(Ax+xx, Ay+yy);
}

if ((clock()-start)>2.8*CLOCKS_PER_SEC) break;
}
}
best.write();
return 0;
}