// -*- C++ -*-
// File: a.cpp
// Copyright (C) 2013
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>
//#include <complex>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int,int> pii;

/*** TEMPLATE CODE ENDS HERE */

//typedef complex<double> base;

struct complex {
	long double im, re;
	complex() : re(0), im(0) {}
	complex(long double re) : re(re), im(0) {}
	complex(long double re, long double im) : re(re), im(im) {}
	complex operator+(const complex &a) {
		return complex(re+a.re,im+a.im);
	}
	complex operator-(const complex &a) {
		return complex(re-a.re,im-a.im);
	}
	complex operator*(const complex &a) {
		return complex(re*a.re-im*a.im, re*a.im+im*a.re);
	}
	complex& operator*=(const complex &a) {
		long double r = re*a.re-im*a.im, i = re*a.im+im*a.re;
		re = r;
		im = i;
		return *this;
	}
	complex& operator/=(double a) {
		re /= a;
		im /= a;
		return *this;
	}
	long double real() const { return re; }
};

typedef complex base;


int rev(int i, int lg_n) {
	int j = 0;
	int res = 0;
	while(i) {
		if(i&1) res |= 1<<(lg_n-1-j);
		++j;
		i>>=1;
	}
	return res;
}

void fft(vector<base> &a, bool inverse) {
	const int n = (int)a.size();
	int lg_n = 0;
	while((1<<lg_n)<n) ++ lg_n;
	
	for(int i = 0; i < n; ++i)
		if(i < rev(i, lg_n))
			swap(a[i], a[rev(i,lg_n)]);
	
	for(int len = 2; len <= n; len <<= 1) {
		double angle = 2*M_PI/len * (inverse ? -1 : 1);
		base delta(cos(angle), sin(angle));
		for(int i = 0; i < n; i += len) {
			base root(1,0);
			for(int j = 0; j < len/2; ++j) {
				base u = a[i+j];
				base v = a[i+j+len/2]*root;
				a[i+j] = u + v;
				a[i+j+len/2] = u - v;
				root *= delta;
			}
		}
	}
	
	if(inverse)
		for(int i = 0; i < n; ++i) a[i] /= n;
}

//void fft (vector<base> & a, bool invert) {
//	int n = (int) a.size();
//	 
//	for (int i=1, j=0; i<n; ++i) {
//		int bit = n >> 1;
//		for (; j>=bit; bit>>=1)
//			j -= bit;
//		j += bit;
//		if (i < j) {
//			swap (a[i], a[j]);			
//		}
//	}
// 
//	for (int len=2; len<=n; len<<=1) {
//		double ang = 2*M_PI/len * (invert ? -1 : 1);
//		base wlen (cos(ang), sin(ang));
//		for (int i=0; i<n; i+=len) {
//			base w (1);
//			for (int j=0; j<len/2; ++j) {
//				base u = a[i+j],  v = a[i+j+len/2] * w;
//				a[i+j] = u + v;
//				a[i+j+len/2] = u - v;
//				w *= wlen;
//			}
//		}
//	}
//	if (invert)
//		for (int i=0; i<n; ++i)
//			a[i] /= n;
//}

int N;
ll A[1<<18];

ll solve_small() { //number of sub-arrays <= 2,001,000; S <= 4*10^10; N <= 2000
	ll *s = new ll[2010];
    ll *t = new ll[2001000];        
    rep(i,N) s[i] = (i?s[i-1]:0) + A[i];
    int k = 0;    
	rep(i,N) rep(j,i+1) t[k++] = s[i] - (j?s[j-1]:0ll);
    sort(t,t+k);
    int res = unique(t,t+k)-t;
    delete[] s;
    delete[] t;
    return res;
}

ll solve_medium() { //number of sub-arrays <= 200,010,000; S <= 20,000,000; 2000 < N <= 20,000
	vector<ll> s(20010,0);
	bool *was = new bool[20000010];
	//memset(was,0,20000010ll * sizeof(bool));
	assert(N<20000010);
	rep(i,N) s[i] = (i?s[i-1]:0ll) + A[i];
	rep(i,N) rep(j,i+1) was[ s[i] - (j?s[j-1]:0ll) ] = true;
	ll ans = 0;
	rep(i,20000010) if(was[i]) ++ans;	
	delete [] was;
	return ans;
}

//----------------------------------------------------------------------
 // p is of the form 2^SHIFT * k + 1
  // we find DFT modulo p using primitive root of p
  int p = 2130706433;
  int gp = 3;
 
  // 1<<SHIFT > 2 * NS/N2
  const int SHIFT = 22;
  int w[1 << SHIFT];
  int a[1 << SHIFT];
  int b[1 << SHIFT];
  int x[1 << SHIFT];
  int y[1 << SHIFT];
  int c[1 << SHIFT];
 
  void DFT(int *a, int *b, int n, int step = 1)
  {
    if (n <= 1)  {
      *b = *a;
      return;
    }
    n /= 2;
    DFT(a, b, n, step * 2);
    DFT(a + step, b + n, n, step * 2);
    for (int i = 0; i < n; ++i) {
      int c = (ll)b[i + n] * w[i * step] % p;
 
      // b[i + n] = (b[i] - c) % p
      b[i + n] = b[i] < c ? b[i] - c + p : b[i] - c;
 
      // b[i] = (b[i] + c) % p
      // since p is almost MAXINT we should do this carefully
      b[i] += b[i] < p - c ? c : c - p;
    }
  }
 
  // returns A^N mod M
  // exponentiation by squaring
  int powmod(int A, int N, int M) {
    int res = 1;
    while (N > 0) {
      if (N % 2 == 1) {
        res = (ll)res * A % M;
      }
      N /= 2;
      if (N > 0) {
        A = (ll)A * A % M;
      }
    }
    return res;
  }
 
  // returns x from 1 to m-1 such that m divides a*x-1
  // precondition gcd(a, m) = 1
  ll inv(ll a, ll m) {
    ll x0 = 1, x1 = 0;
    ll b = m;
    while (b > 0) {
 
      ll q = a / b;
 
      // (a; b) := (b; a - q * b)
      ll c = a - q * b;
      a = b;
      b = c;
 
      // (x0; x1) := (x1; x0 - q * x1)
      ll x = x0 - q * x1;
      x0 = x1;
      x1 = x;
    }
    return x0 < 0 ? x0 + m : x0;
  }
 
  // save convolution of x and y modulo p into c
  // preconditions:
  //    p = 2^h * k + 1 is prime, where 2^h > n_ + m_
  void convolution(int n_, int m_)
  {
    // finding the least power of two which is >= n_ + m_ - 1
    int h = 0;
    for(; (1 << h) < n_ + m_ - 1; ++h);
    int n = 1 << h;
 
    // g will now have order 2^h in Zp as needed for DFT
    int g = powmod(gp, (p-1) >> h, p);
 
    // w[] will contain powers of g
    w[0] = 1;
    for(int i = 1; i < n; i++) {
      w[i] = (ll)w[i - 1] * g % p;
    }
 
    // DFT (Discrete Fourier Transform) of x[]
    // is the sequence P(1), P(g), P(g^2), ..., P(g^(n-1)) modulo p
    // where P(t) = x[0] + x[1] * t + ... + x[n-1] * t^(n-1) and n=2^h-1
    // Since order of g in Zp is n-1 all values 1, g, g^2, ..., g^(n-1)
    // are different modulo p and it is quite improtant.
 
    DFT(x, a, n); // now a is DFT of x
    DFT(y, b, n); // now b is DFT of y
 
    // we multiply b and a
    for(int i = 0; i < n; i++) {
      b[i] = (ll)b[i] * a[i] % p;
    }
 
    // to make inverse DFT we need inverse roots
    int invg = inv(g, p);
    w[0] = 1;
    for(int i = 1; i < n; i++) {
      w[i] = (ll)w[i-1] * invg % p;
    }
 
    // and now a[] contains almost convolution of a_[] and b_[]
    DFT(b, a, n);
 
    // we need only to divide all by n = 2^h >= n_ + m_ - 1
    int invn = inv(n, p);
    for (int i = 0; i < n_ + m_ - 1; ++i) {
      c[i] = (ll)a[i] * invn % p;
    }
  }



ll solve_large() { // number of sub-arrays <= 20,000,100,000; S <= 2,000,000; 20,000 < N â‰¤ 200,000
	
	const int S = accumulate(A,A+N,0ll);
	
	assert(S <= 2000000);
	
	int n = 1;
	while(n < (S+1)) n <<= 1;
	n <<= 1;
	
	vector<base> xx(n), yy(n);	
	int s = 0;
	
	rep(i,N+1) {
		xx[s] = base(1,0);
		yy[S-s] = base(1,0);
		s += A[i];
	}

//	rep(i,N+1) {
//		x[s] = 1;
//		y[S-s] = 1;
//		s += A[i];
//	}
//
//	convolution(S+1,S+1);
//    int res=0;
//    for(int i=0;i<S;i++) if(c[i]) res++;
//	return res;
//	
	fft(xx,false);
	fft(yy,false);	
	rep(i,n) xx[i] *= yy[i];
	fft(xx,true);
	
	int ans = 0;
	
	rep(i,S) {
		ll t = ll(xx[i].real()+0.5);
		if(t>0) ++ans;
	}

	return ans;
}

int main() {
#ifdef LOCAL_HOST
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
#endif

    ios_base::sync_with_stdio(false);
	
	cin >> N;
	rep(i,N) cin >> A[i];
	
	if(N <= 2000) {
		cout << solve_small()-1 << endl;
	}
	else if(N <= 20000) {
		cout << solve_medium()-1 << endl;
	}
	else {
		cout << solve_large()-1 << endl;
	}

#ifdef LOCAL_HOST
    printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC);
#endif

    return 0;
}
