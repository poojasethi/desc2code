#include <cstdio>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

int hash[20000005];

struct cpx
{
    cpx(){}
    cpx(double aa):a(aa){}
    cpx(double aa, double bb):a(aa), b(bb){}      
    double a;
    double b;
    
    double modsq(void) const
    {
        return a*a + b*b;       
    }
    
    cpx bar(void) const
    {
        return cpx(a, -b);    
    }
};

cpx operator +(cpx a, cpx b)
{
    return cpx(a.a + b.a, a.b + b.b);    
}

cpx operator *(cpx a, cpx b)
{
    return cpx(a.a*b.a - a.b*b.b, a.a*b.b + b.a*a.b);    
}

cpx operator /(cpx a, cpx b)
{
    cpx r = a*b.bar();
    return cpx(r.a/b.modsq(), r.b/b.modsq());    
}

cpx EXP(double theta)
{
    return cpx(cos(theta), sin(theta));    
}

const double two_pi = 4 * acos(0);

void FFT(cpx *in, cpx *out, int step, int size, int dir)
{
    if (size < 1)
        return;
    
    if (size == 1)
    {
       out[0] = in[0];      
       return;
    }
    
    FFT(in, out, 2*step, size/2, dir);
    FFT(in + step, out + size/2, 2*step, size/2, dir);
    
    for (int i=0 ; i<size/2 ; i++)
    {
        cpx even = out[i];
        cpx odd  = out[i + size/2];
        out[i] = even + EXP (dir * i * two_pi / size)*odd;
        out[i + size/2] = even + EXP (dir * ( i + size / 2 ) * two_pi / size)*odd;    
    }      
}

cpx X[1<<23], Y[1<<23], out1[1<<23], out2[1<<23];

void IFFT(cpx *in, cpx *out, int size)
{
    FFT(in, out, 1, size, -1);
    
    for (int i=0 ; i<size ; i++)
       out[i] = out[i] / size;              
}

unsigned int nextPowerOf2(unsigned int n)
{
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n++;
    return n;
}

int main()
{
    int n;
    scanf("%d", &n);
    
    int num[n+1];
    for (int i=1 ; i<=n ; i++)
        scanf("%d", &num[i]);
            
    if (n<=2000)
    {
        vector<long long> vec;
        for (int i=1 ; i<=n ; i++)
        {
            long long value = 0;
            for (int j=i ; j<=n ; j++)
            {
                value += (long long)num[j];
                vec.push_back(value);    
            }    
        }     
                      
        sort(vec.begin(), vec.end());
        vec.erase( unique(vec.begin(), vec.end()), vec.end());
        printf("%d\n", vec.size() - 1);
    }
    else if (n>2000 && n<=80000)
    {
         for (int i=1 ; i<=20000004 ; i++)
             hash[i] = 0;
             
         for (int i=1 ; i<=n ; i++)
         {
             int value = 0;
             for (int j=i ; j<=n ; j++)
             {
                 value += num[j];
                 hash[value] = 1;    
             }    
         }
         
         int ans = -1;
         for (int i=1 ; i<=20000004 ; i++)
         {
             if (hash[i])
                 ans++;    
         }
         printf("%d\n", ans);
    }
    else
    {
        // This part will be completed by FFT and IFFT
        int S[n+1];
        S[0] = 0;
        for (int i=1 ; i<=n ; i++)
            S[i] = S[i-1] + num[i];
        
        long long m = S[n] + 1;
        m |= m >> 1;
        m |= m >> 2;
        m |= m >> 4;
        m |= m >> 8;
        m |= m >> 16;
        m ^= m >> 1;
        m <<= 2; 
        //printf("%d\n", m);   
           
        X[0].a = Y[0].a = 1.0;   
        X[0].b = Y[0].b = 0.0;
        for (int i=1 ; i<1<<22 ; i++)
        {
            X[i].a = Y[i].a = 0.0;
            X[i].b = Y[i].b = 0.0;    
        }
            
        int su = S[n];
        Y[su].a = 1.0;
        
        for (int i=1 ; i<=n ; i++)
        {
            X[S[i]].a = Y[su - S[i]].a = 1.00;    
        }
        
        /*for (int i=0 ; i<=S[n] ; i++)
        {
            printf("X[%d] : %lf\n", i, X[i].a);
        }
        printf("\n");
        for (int i=0 ; i<=S[n]+1 ; i++)
        {
            printf("Y[%d] : %lf\n", i, Y[i].a);
        }
        printf("\n");*/
        
        FFT(X, out1, 1, m, 1);
        FFT(Y, out2, 1, m, 1);
        
        for (int i=0 ; i < m ; i++)
        {
            X[i] = out1[i]*out2[i]; 
        }
    
        IFFT(X, Y, m);
        int ans = 0;
        for (int i=su+1 ; i < 1<<22 ; i++)
        {
            if (Y[i].a > 1e-6 )
            {
               //printf("%lf\n", Y[i].a);  
               ans++;
            }   
        }
        printf("%d\n", ans - 1);
    }
    
    //int x;
    //scanf("%d", &x);
    return 0;    
}
