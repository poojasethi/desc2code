#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 8200005
#define M 200005
#define mo 998244353
#define Long long long
#define For(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
Long w[M],G[N/2];
void Forces(int n){
	int tot=0,Ans=0;
	For(i,1,n) For(j,i,n) G[++tot]=w[j]-w[i-1];
	sort(G+1,G+1+tot);
	for(int i=1,j=1;i<=tot;i=j){
		for(;G[i]==G[j] && j<=tot;j++);
		Ans++;
	}
	printf("%d\n",--Ans);
}
struct complex{double re,im;};
complex operator + (const complex &A,const complex &B){return (complex){A.re+B.re,A.im+B.im};}
complex operator - (const complex &A,const complex &B){return (complex){A.re-B.re,A.im-B.im};}
complex operator * (const complex &A,const complex &B){return (complex){A.re*B.re-A.im*B.im,A.re*B.im+A.im*B.re};}
complex A[N],B[N],W[N][2];
const double pi=acos(-1);
int rev[N];
void Init(int n){
	For(i,0,n-1){
		int x=i,y=0;
		for(int k=1;k<n;k<<=1){
			y<<=1; y|=x&1;
			x>>=1;
		}
		rev[i]=y;
	}
	For(i,0,n-1) W[i][0]=W[i][1]=(complex){cos(2*pi*i/n),sin(2*pi*i/n)},W[i][1].im=-W[i][1].im;
}
void NWT(complex a[],int f,int n){
	for(int i=0;i<n;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	complex x,y;
	for(int i=1;i<n;i<<=1)
	for(int j=0,t=n/(i<<1);j<n;j+=(i<<1))
	for(int k=0,l=0;k<i;k++,l+=t){
		x=a[k+j],y=a[k+j+i]*W[l][f];
		a[k+j]=x+y;
		a[k+j+i]=x-y;
	}
	if(f) for(int i=0;i<n;i++) a[i].re/=n;
}
void NTT(complex A[],complex B[],int m){
	int n,Ans=0;
	for(n=1;n<=m;n<<=1); n<<=1;
	
	Init(n);
	NWT(A,0,n); NWT(B,0,n);
	for(int i=0;i<n;i++) A[i]=A[i]*B[i];
	NWT(A,1,n);
	for(int i=m+1;i<n;i++) if((int)(A[i].re+0.5)) Ans++;
	printf("%d\n",--Ans);
}

int main(){
	int n; scanf("%d",&n);
	For(i,1,n) scanf("%lld",&w[i]);
	For(i,1,n) w[i]+=w[i-1];
	
	if(n<=2500){Forces(n); return 0;}
	
	For(i,1,n) A[w[i]].re=1;
	For(i,0,n-1) B[w[n]-w[i]].re=1;
	
	NTT(A,B,w[n]);
}
