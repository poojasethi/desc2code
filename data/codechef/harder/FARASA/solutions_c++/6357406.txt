#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef complex<double> Complex;
typedef vector<Complex> vc;

vector<int> nums;

const double PI = 3.141592653589793238460;

int rev(int k, int m) {
	int res,bit;
	res = 0;
	while(m--) {
		bit = (k & 1);
		res = (res<<1) + bit;
		k>>=1;
	}
	return res;
}

void bit_rev_copy(vector<complex<double> > &a) {
	int k, lg_n=0,n = a.size();
	vector<complex<double> > va(n);
	for(int k=0; k<n; ++k) va[k] = a[k];

	k = 1;	
	while(n>>k) {
		k++;	
		lg_n++;
	}

	for(k=0; k<n; ++k) 
		a[rev(k,lg_n)] = va[k];
	
}

void fft(vector<complex<double> > &a) {

	int i,j,k,n;
	int s,m,lg_n=0;
	complex<double> wn,w,t,u;

	n = a.size();
	bit_rev_copy(a);
	while((n&(1<<lg_n)) == 0)
		lg_n++;
	
	for(s=1; s<=lg_n; ++s) {
		m = 1<<s;	
		wn = polar(1.0, 2.0*PI/m);

		for(k=0; k<=n-1; k+=m) {
			w = polar(1.0, 0.0);
			for(j=0; j<=m/2 - 1; j++) {
				t = w * a[k + j + m/2];	
				u = a[k + j];
				a[k+j] = u + t;
				a[k+ j + m/2] = u - t;
				w = w*wn;
			}
		}
	}
	
}

void ifft(vector<complex<double> > &a) {
	int i,n;
	n = a.size();
	for(i=0; i<n; i++)
		a[i] = conj(a[i]);

	fft(a);

	for(i=0; i<n; i++) {
		a[i] = conj(a[i]);
		a[i] /= n;
	}
}

void solve1() {
	int i,j,cnt=0;
	ll res,temp;

	vector<ll> arrsum;
	for(i=0; i<nums.size(); i++) {
		temp = 0;
		for(j=i; j<nums.size(); j++) {
			temp += nums[j];
			arrsum.push_back(temp);
		}
	}

	sort(arrsum.begin(), arrsum.end());
	temp = -1;
	for(i=0; i<arrsum.size(); i++) {
		if(arrsum[i] != temp) {
			cnt++;	
		} 
		temp = arrsum[i];
	}

	printf("%d\n",cnt-1);
}

void solve2() {
	int i,j,cnt=0;
	ll temp,sm=0;
	vector<char> b;
	for(i=0; i<nums.size(); i++)
		sm += nums[i];

	b.resize(sm+9,0);

	for(i=0; i<nums.size(); i++) {
		temp = 0;
		for(j=i; j<nums.size(); j++) {
			temp += nums[j];
			b[temp] = 1;
		}
	}
	for(i=0; i<b.size(); i++)
		if(b[i]) cnt++;

	printf("%d\n",cnt-1);
}

void solve3() {
	int sz,i,j,temp, n ,res,sm,cnt=0;	
	temp = sm = 0; 
	for(i=0; i<nums.size(); i++)
		sm += nums[i];

	sz = 0;
	temp = sm;
	while(temp) {
		sz++;	
		temp >>= 1;
	}

	sz+=1;
	n = (1<<sz);
		
	temp = 0;
	vc x(n,Complex(0.0,0.0)),y(n,Complex(0.0,0.0));

	x[0] = Complex(1.0,0.0); 

	sm = 0;
	for(i=0; i<nums.size(); i++) {
		sm += nums[i];	
		x[sm] = Complex(1.0,0);
	}

	y[sm] = Complex(1.0,0.0);
	for(i=0; i<nums.size(); i++) {
		temp += nums[i];	
		y[sm - temp] = Complex(1.0,0);
	}

	fft(x);		
	fft(y);		

	//multiply them..
	for(i=0; i<n; i++)
		x[i] *= y[i];
	
	ifft(x);
	
	for(i=sm+1; i<n; i++) {
		if(x[i].real() >= 1e-6) {
			cnt++;
		}
	}
		
	printf("%d\n",cnt-1);
}

int main() {
	int n,i,j,temp;
	ll sum = 0;
	scanf("%d",&n);

	nums.resize(n);

	for(i=0; i<n; i++) {
		scanf("%d",&nums[i]);
		sum += nums[i];
	}
	
	//cases..
	if(n <= 4000)
		solve1();
	else if(n <= 20000) 
		solve2();
	else {
		solve3();
	} 
	
	return 0;
}
