// -*- C++ -*-
// File: a.cpp
// Copyright (C) 2013
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>
//#include <complex>
 
using namespace std;
 
#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))
 
typedef long long ll;
typedef vector<int> VI;
typedef pair<int,int> pii;
 
/*** TEMPLATE CODE ENDS HERE */
 
 
// returns x from 1 to m-1 such that m divides a*x-1
  // precondition gcd(a, m) = 1
  ll inv(ll a, ll m) {
    ll x0 = 1, x1 = 0;
    ll b = m;
    while (b > 0) {
 
      ll q = a / b;
 
      // (a; b) := (b; a - q * b)
      ll c = a - q * b;
      a = b;
      b = c;
 
      // (x0; x1) := (x1; x0 - q * x1)
      ll x = x0 - q * x1;
      x0 = x1;
      x1 = x;
    }
    return x0 < 0 ? x0 + m : x0;
  }
  
    // returns A^N mod M
  // exponentiation by squaring
  int powmod(int A, int N, int M) {
    int res = 1;
    while (N > 0) {
      if (N % 2 == 1) {
        res = (ll)res * A % M;
      }
      N /= 2;
      if (N > 0) {
        A = (ll)A * A % M;
      }
    }
    return res;
  }
  
//----------------------------------------------------------  
typedef unsigned long long ULL;
 
template<class T>
T power(T a, ULL b) {
  T res = T(1);
  while(b) {
    if(b&1u) res *= a;
    b >>= 1;
    a = a*a;
  }
  return res;
}
 
template<unsigned MOD>
class Modulo {
  unsigned v;
 public:
  Modulo() {}
  Modulo(unsigned x):v(x%MOD) {}
  int get() const { return v; }
  Modulo operator+(Modulo b) const { return Modulo(v+b.v); }
  void operator+=(Modulo b) { *this = *this + b; }
  Modulo operator-(Modulo b) const { return Modulo(v+MOD-b.v); }
  void operator-=(Modulo b) { *this = *this - b; }
  Modulo operator*(Modulo b) const { 
	  //return Modulo(unsigned(ULL(v) * ULL(b.v) % MOD)); 	  
    unsigned div, mod;
    asm("mul %3; div %4": "=a" (div), "=&d" (mod): "a" (v), "r" (b.v), "r" (MOD));
    return Modulo(mod);
  }  
  void operator*=(Modulo b) { *this = *this * b; }
  Modulo operator/(Modulo b) const { return *this * b.inverse(); }
  void operator/=(Modulo b) { *this = *this / b; }
  Modulo inverse() const { return power(*this, MOD-2); }
};
 
const int PRIME = 2013265921; //(11<<21) + 1;
const int MAXN = 1<<22;
 
typedef Modulo<PRIME> Mod; 
Mod root = Mod(440564289);
 
Mod tmp[MAXN];
void fft(Mod *a, int shift, const int n, Mod w) {
	
	if(n==1) return;
	
	Mod w2 = w*w;
	int n2 = n/2;
	
	fft(a,shift+1,n2,w2);
	fft(a+(1<<shift),shift+1,n2,w2);
	
	Mod wx = 1;
	
	for(int i = 0; i < n2; ++i) {
		Mod u = a[i<<(shift+1)];
		Mod v = a[(i<<(shift+1))+(1<<shift)] * wx;
		tmp[i] = u + v;
		tmp[n2+i] = u - v;
		wx *= w;
	}
	
	for(int i = 0; i < n; ++i) a[i<<shift] = tmp[i];
}
 
//----------------------------------------------------------
 
 
int N;
ll v[1<<18];
 
ll solve_small() { //number of sub-arrays <= 2,001,000; S <= 4*10^10; N <= 2000
	ll *s = new ll[2010];
    ll *t = new ll[2001000];        
    rep(i,N) s[i] = (i?s[i-1]:0) + v[i];
    int k = 0;    
	rep(i,N) rep(j,i+1) t[k++] = s[i] - (j?s[j-1]:0ll);
    sort(t,t+k);
    int res = unique(t,t+k)-t;
    delete[] s;
    delete[] t;
    return res;
}
 
ll solve_medium() { //number of sub-arrays <= 200,010,000; S <= 20,000,000; 2000 < N <= 20,000
	vector<ll> s(20010,0);
	bool *was = new bool[20000010];
	//memset(was,0,20000010ll * sizeof(bool));
	assert(N<20000010);
	rep(i,N) s[i] = (i?s[i-1]:0ll) + v[i];
	rep(i,N) rep(j,i+1) was[ s[i] - (j?s[j-1]:0ll) ] = true;
	ll ans = 0;
	rep(i,20000010) if(was[i]) ++ans;	
	delete [] was;
	return ans;
}
 
//--------------------------------------------------
 
//const int mod = 2013265921;
//const int root = 3;
//const int root_1 = inv(root, mod);
//const int root_pw = 1<<20;
// 
//void fft (vector<int> & a, bool invert) {
//	int n = (int) a.size();
// 
//	for (int i=1, j=0; i<n; ++i) {
//		int bit = n >> 1;
//		for (; j>=bit; bit>>=1)
//			j -= bit;
//		j += bit;
//		if (i < j)
//			swap (a[i], a[j]);
//	}
//	
//	int lg_n = 0;
//	while((1<<lg_n)<n) ++ lg_n;
//	
//	// g will now have order 2^h in Zp as needed for DFT
//    int g = powmod(root, (mod-1) >> lg_n, mod);
//	if(invert) g = inv(g, mod);
// 
//    // w[] will contain powers of g
////    w[0] = 1;
////    for(int i = 1; i < n; i++) {
////      w[i] = (ll)w[i - 1] * g % mod;
////    }
// 
//	for (int len=2; len<=n; len<<=1) {
//		//int wlen = invert ? root_1 : root;
//		int wlen = g;
//		for (int i=len; i<root_pw; i<<=1)
//			wlen = int (wlen * 1ll * wlen % mod);
//		for (int i=0; i<n; i+=len) {
//			int w = 1;
//			for (int j=0; j<len/2; ++j) {
//				int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
//				a[i+j] = u+v < mod ? u+v : u+v-mod;
//				a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
//				w = int (w * 1ll * wlen % mod);
//			}
//		}
//	}
//	if (invert) {
//		int nrev = inv (n, mod);
//		for (int i=0; i<n; ++i)
//			a[i] = int (a[i] * 1ll * nrev % mod);
//	}
//}
//---------------------------------------------------------------
 
ll solve_large() { // number of sub-arrays <= 20,000,100,000; S <= 2,000,000; 20,000 < N Ã¢ï¿½Â¤ 200,000
	
	const int S = accumulate(v,v+N,0ll);
	
	assert(S <= 2000000);
	
	Mod roots[28];
	rep(k,28) roots[k] = power(root, 1ULL << 27 - k); 

	int m = 1;
	while(m < (S+1)) m <<= 1;
	m <<= 1;
	
	assert(m<=(1<<22));
	
	vector<Mod> A(m), B(m);
   	
    rep(i,m) A[i] = B[i] = 0;
	
	int s = 0;
	rep(i,N+1) {
		A[s] = 1;
		B[S-s] = 1;
		if(i<N) s += v[i];
	}
 
	// important to choose root properly
    int k = 0;
    for (int mm = m; mm > 1; mm >>= 1) k++;
    Mod w = roots[k];	
    
	fft(&A[0],0,m,w);
	fft(&B[0],0,m,w);
	
    rep(i,m) A[i] = A[i] * B[i];
    
	fft(&A[0], 0, m, power(w, m - 1));
	Mod iv = power(Mod(m), PRIME - 2);
	rep(i,m) A[i] = A[i] * iv;
 
    int ans = 0;
    FOR(i,S+1,m) ans +=!! A[i].get();
	return ans;  
}
 
int main() {
#ifdef LOCAL_HOST
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
#endif
 
    ios_base::sync_with_stdio(false);
	
	cin >> N;
	rep(i,N) cin >> v[i];
	
	
	if(N <= 2000) {
		cout << solve_small()-1 << endl;
	}
	else if(N <= 20000) {
		cout << solve_medium()-1 << endl;
	}
	else {
		cout << solve_large()-1 << endl;
	}
 
#ifdef LOCAL_HOST
    printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC);
#endif
	
    return 0;
}