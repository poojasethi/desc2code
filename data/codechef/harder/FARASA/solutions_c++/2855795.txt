// -*- C++ -*-
// File: a.cpp
// Copyright (C) 2013
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>
//#include <complex>
 
using namespace std;
 
#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))
 
typedef long long ll;
typedef vector<int> VI;
typedef pair<int,int> pii;
 
/*** TEMPLATE CODE ENDS HERE */
 
 
// returns x from 1 to m-1 such that m divides a*x-1
  // precondition gcd(a, m) = 1
  ll inv(ll a, ll m) {
    ll x0 = 1, x1 = 0;
    ll b = m;
    while (b > 0) {
 
      ll q = a / b;
 
      // (a; b) := (b; a - q * b)
      ll c = a - q * b;
      a = b;
      b = c;
 
      // (x0; x1) := (x1; x0 - q * x1)
      ll x = x0 - q * x1;
      x0 = x1;
      x1 = x;
    }
    return x0 < 0 ? x0 + m : x0;
  }
  
    // returns A^N mod M
  // exponentiation by squaring
  int powmod(int A, int N, int M) {
    int res = 1;
    while (N > 0) {
      if (N % 2 == 1) {
        res = (ll)res * A % M;
      }
      N /= 2;
      if (N > 0) {
        A = (ll)A * A % M;
      }
    }
    return res;
  }
  
//----------------------------------------------------------  
typedef unsigned long long ULL;
 
template<class T>
T power(T a, ULL b) {
  T res = T(1);
  while(b) {
    if(b&1u) res *= a;
    b >>= 1;
    a = a*a;
  }
  return res;
}
 
template<unsigned MOD>
class Modulo {
  unsigned v;
 public:
  Modulo() {}
  Modulo(unsigned x):v(x%MOD) {}
  int get() const { return v; }
  Modulo operator+(Modulo b) const { return Modulo(v+b.v); }
  void operator+=(Modulo b) { *this = *this + b; }
  Modulo operator-(Modulo b) const { return Modulo(v+MOD-b.v); }
  void operator-=(Modulo b) { *this = *this - b; }
  Modulo operator*(Modulo b) const { return Modulo(unsigned(ULL(v) * ULL(b.v) % MOD)); }
  void operator*=(Modulo b) { *this = *this * b; }
  Modulo operator/(Modulo b) const { return *this * b.inverse(); }
  void operator/=(Modulo b) { *this = *this / b; }
  Modulo inverse() const { return power(*this, MOD-2); }
};
 
const int PRIME = 2013265921; //(11<<21) + 1;
const int MAXN = 1<<22;
 
typedef Modulo<PRIME> Mod;
 
//const Mod W = Mod(3u);
//const Mod W_INV = W.inverse();
 
//Mod root = Mod(440564289);
 
Mod tmp[MAXN];
void fft(Mod *a, int shift, const int n, Mod w) {
	
	if(n==1) return;
	
	Mod w2 = w*w;
	int n2 = n/2;
	
	fft(a,shift+1,n2,w2);
	fft(a+(1<<shift),shift+1,n2,w2);
	
	Mod wx = 1;
	
	for(int i = 0; i < n2; ++i) {
		Mod u = a[i<<(shift+1)];
		Mod v = a[(i<<(shift+1))+(1<<shift)] * wx;
		tmp[i] = u + v;
		tmp[n2+i] = u - v;
	}
	
	for(int i = 0; i < n; ++i) a[i<<shift] = tmp[i];
}
 
//----------------------------------------------------------
 
 
int N;
ll *v;
 
ll solve_small() { //number of sub-arrays <= 2,001,000; S <= 4*10^10; N <= 2000
	ll *s = new ll[2010];
    ll *t = new ll[2001000];        
    rep(i,N) s[i] = (i?s[i-1]:0) + v[i+1];
    int k = 0;    
	rep(i,N) rep(j,i+1) t[k++] = s[i] - (j?s[j-1]:0ll);
    sort(t,t+k);
    int res = unique(t,t+k)-t;
    delete[] s;
    delete[] t;
    return res;
}
 
ll solve_medium() { //number of sub-arrays <= 200,010,000; S <= 20,000,000; 2000 < N <= 20,000
	vector<ll> s(20010,0);
	bool *was = new bool[20000010];
	//memset(was,0,20000010ll * sizeof(bool));
	assert(N<20000010);
	rep(i,N) s[i] = (i?s[i-1]:0ll) + v[i+1];
	rep(i,N) rep(j,i+1) was[ s[i] - (j?s[j-1]:0ll) ] = true;
	ll ans = 0;
	rep(i,20000010) if(was[i]) ++ans;	
	delete [] was;
	return ans;
}
 
//--------------------------------------------------
 
//const int mod = 2013265921;
//const int root = 3;
//const int root_1 = inv(root, mod);
//const int root_pw = 1<<20;
// 
//void fft (vector<int> & a, bool invert) {
//	int n = (int) a.size();
// 
//	for (int i=1, j=0; i<n; ++i) {
//		int bit = n >> 1;
//		for (; j>=bit; bit>>=1)
//			j -= bit;
//		j += bit;
//		if (i < j)
//			swap (a[i], a[j]);
//	}
//	
//	int lg_n = 0;
//	while((1<<lg_n)<n) ++ lg_n;
//	
//	// g will now have order 2^h in Zp as needed for DFT
//    int g = powmod(root, (mod-1) >> lg_n, mod);
//	if(invert) g = inv(g, mod);
// 
//    // w[] will contain powers of g
////    w[0] = 1;
////    for(int i = 1; i < n; i++) {
////      w[i] = (ll)w[i - 1] * g % mod;
////    }
// 
//	for (int len=2; len<=n; len<<=1) {
//		//int wlen = invert ? root_1 : root;
//		int wlen = g;
//		for (int i=len; i<root_pw; i<<=1)
//			wlen = int (wlen * 1ll * wlen % mod);
//		for (int i=0; i<n; i+=len) {
//			int w = 1;
//			for (int j=0; j<len/2; ++j) {
//				int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
//				a[i+j] = u+v < mod ? u+v : u+v-mod;
//				a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
//				w = int (w * 1ll * wlen % mod);
//			}
//		}
//	}
//	if (invert) {
//		int nrev = inv (n, mod);
//		for (int i=0; i<n; ++i)
//			a[i] = int (a[i] * 1ll * nrev % mod);
//	}
//}
//---------------------------------------------------------------
 
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i < (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i <= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i >= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i >= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")
 
#define mod 2013265921
#define root 440564289
#define ex 27
 
ll roots[ex + 1];
ll ipow(ll b, ll e) {
  if (e == 0) return 1;
  if (e == 1) return b;
  if (e & 1) return ipow(b, e - 1) * b % mod;
  return ipow(b * b % mod, e >> 1);
}
 
void dft(ll *p, int n, ll w, ll *fp) {
  if (n == 1) {
    *fp = *p;
    return;
  }
  int nh = n >> 1;
  int j = 0;
  for (int i = 0; i < n; i += 2) fp[j++] = p[i];
  for (int i = 1; i < n; i += 2) fp[j++] = p[i];
  ll ww = w * w % mod;
  dft(fp,      nh, ww, p);
  dft(fp + nh, nh, ww, p + nh);
  ll pw = 1;
  fr(i,nh) {
    fp[i] =      (p[i] + pw * p[nh + i]) % mod;
    fp[nh + i] = (p[i] - pw * p[nh + i]) % mod;
    pw = pw * w % mod;
  }
}
void idft(ll *p, int n, ll w, ll *fp) {
  dft(p, n, ipow(w, n - 1), fp);
  ll iv = ipow(n, mod - 2);
  fr(i,n) fp[i] = fp[i] * iv % mod;
}
 
 
ll solve_large() { // number of sub-arrays <= 20,000,100,000; S <= 2,000,000; 20,000 < N â�¤ 200,000
	
	//const int S = accumulate(v,v+N,0ll);
//	
//	assert(S <= 2000000);
//	
//	Mod roots[29];
//	const int ex = 27;
//	rep(k,28) roots[k] = power(root, 1ULL << (ex - k));
//	
////	int n = 1;
////	while(n < (S+1)) n <<= 1;
////	n <<= 1;
//
//	
//    int n = S + 1;
//    n |= n >> 1;
//    n |= n >> 2;
//    n |= n >> 4;
//    n |= n >> 8;
//    n |= n >> 16;
//    n ^= n >> 1;
//    n <<= 2;
//		
////	vector<base> xx(n), yy(n);	
//	vector<Mod> xx(n), yy(n);	
//	int s = 0;
//	
//	rep(i,N+1) {
//		xx[s] = 1;
//		yy[S-s] = 1;
//		s += A[i];
//	}
//	
//	int k = 0;
//    for (int mm = n; mm > 1; mm >>= 1) k++;
//    Mod w = roots[k];
//	
//	fft(&xx[0],0,n,w);
//	fft(&yy[0],0,n,w);	
//	
//	rep(i,n) xx[i] = xx[i] * yy[i];
//		
//	Mod w_inv = power(w,n-1);
//		
//	fft(&xx[0],0,n,w_inv);
//	Mod inv_n = Mod(n).inverse();
//	rep(i,n) xx[i] = inv_n * xx[i] ;
//
//	int ans = 0;
//	
//	rep(i,S) {
//		//ll t = ll(xx[i].real()+0.5);
//		unsigned t = xx[i].get();
//		if(t>0) ++ans;
//	}
//
//	return ans;
 
ll *A;
ll *B;
ll *C;
 
Mod *AAA;
 
rep(k,28) {
    roots[k] = ipow(root, 1 << ex - k);
  }
 
 ll s = v[N];
    ll m = s + 1;
    m |= m >> 1;
    m |= m >> 2;
    m |= m >> 4;
    m |= m >> 8;
    m |= m >> 16;
    m ^= m >> 1;
    m <<= 2;
    A = alok(m, ll);
    B = alok(m, ll);
    C = alok(m, ll);
	AAA = alok(m, Mod);
    fr(i,m) A[i] = B[i] = 0;
    fe(i,0,N) A[v[i]] = 1;
    fe(i,0,N) B[v[N] - v[i]] = 1;
 
    int k = 0;
    for (int mm = m; mm > 1; mm >>= 1) k++;
    ll w = roots[k];
    dft(A, m, w, C);
//	rep(i,m) AAA[i] = unsigned(A[i]);
//	fft(AAA, 0, m, Mod(unsigned(w)));
//	rep(i,m) C[i] = AAA[i].get();
    dft(B, m, w, A);
    fr(i,m) B[i] = A[i] * C[i] % mod;
    idft(B, m, w, C);
 
    int ans = 0;
    fo(i,v[N]+1,m) ans +=!! C[i];
	return ans;  
}
 
int main() {
#ifdef LOCAL_HOST
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
#endif
 
    ios_base::sync_with_stdio(false);
	
	sf("%d", &N);
  v = alok(N + 1, ll) + 1;
	fr(i,N) sf("%lld", v + i);
	*--v = 0;	
	
	if(N <= 2000) {
		cout << solve_small()-1 << endl;
	}
	else if(N <= 20000) {
		cout << solve_medium()-1 << endl;
	}
	else {
		fr(i,N) v[i + 1] += v[i];
		cout << solve_large()-1 << endl;
	}
 
#ifdef LOCAL_HOST
    printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC);
#endif
	
    return 0;
}
 