#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<complex>
using namespace std;

#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define per(i, s, t) for (int i = (s); i >= (t); --i)
#define REP(i, n) rep(i, 1, n)
#define PER(i, n) per(i, n, 1)
#define Rep(i, n) rep(i, 0, n - 1)
#define INF 1000000010
#define mk make_pair
#define X first
#define Y second
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;
struct CLX{
    LD x, y;
    CLX(LD _x, LD _y) {x = _x; y = _y;}
    CLX() {}
    CLX operator + (const CLX &b) const{
        return CLX(x + b.x, y + b.y);
    }
    CLX operator - (const CLX &b) const{
        return CLX(x - b.x, y - b.y);
    }
    CLX operator * (const CLX &b) const{
        return CLX(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
//typedef complex<LD> CLX;
LD pi = M_PI;
const int MAX_N = 222222;
LL a[MAX_N], b[2222 * 2222];
int n;

void Rider(){
     int N = 0;
     REP(i, n){
        int s = 0;
        rep(j, i, n){
           s += a[j];
           b[++N] = s;
        }
     }
     sort(b + 1, b + 1 + N);
     printf("%d\n", unique(b + 1, b + 1 + N) - b - 2);
}

bool hash[22222222];

void Saber(){
     memset(hash, 0, sizeof hash);
     LL ans = 0; 
     REP(i, n){
        int s = 0;
        rep(j, i, n){
           s += a[j];
           ans += !hash[s];
           hash[s] = 1;
        }
     }
     cout << ans - 1 << endl;
}

CLX A[2222222 * 4], B[2222222 * 4];
int N;

int rev(int x, int N){
    int res = 0, tot = 0;
    for (int i = N >> 1; i; i >>= 1){
        res |= ((x & i) > 0) << (tot++);
    }
    return res;
}

void DFT(CLX A[], int N, int fh){
    REP(i, N - 2){
        int j = rev(i, N);
        if (i < j) swap(A[i], A[j]);
    }
    for (int d = 1; d < N; d <<= 1){
        int m = d, m2 = d << 1;
        LD ang = fh * 2 * pi / m2;
        CLX unit = CLX(cos(ang), sin(ang));
        for (int S = 0; S < N; S += m2){
            CLX r = CLX(1, 0);
            Rep(i, m){
                CLX y0 = A[S + i], y1 = A[S + m + i];
                A[S + i] = y0 + r * y1;
                A[S + m + i] = y0 - r * y1;
                r = r * unit;
            }
        }
    }
}

void Rin(){
    int S = 0;
    REP(i, n) S += a[i];
    int ns = 0;
    REP(i, n + 1)
        A[ns] = CLX(1, 0),
        B[S - ns] = CLX(1, 0),
        ns += a[i];
    N = 1;
    while (N < S + 1) N <<= 1;
    N <<= 1;
    //Rep(i, N) printf("A %lf %lf\n", A[i].x, A[i].y);
    //Rep(i, N) printf("B %lf %lf\n", B[i].x, B[i].y);
    DFT(A, N, 1);
    DFT(B, N, 1);
    Rep(i, N) A[i] = A[i] * B[i];
    DFT(A, N, -1);
    int ans = 0;
    rep(i, S, N - 1){
        LL fk = LL(A[i].x / N + 1e-2);
        if (fk > 0) ans++;
    }
    cout << ans - 2 << endl;
}

int main(){
    scanf("%d", &n);
    REP(i, n) scanf("%I64d", &a[i]);
    if (n <= 2000) Rider();
    if (2000 < n && n <= 20000) Saber();
    if (20000 < n && n <= 200000) Rin();
    //Rin();
    //system("pause");
}
/*
3
1 2 3
*/
