// #includes {{{
#include <algorithm>
#include <numeric>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cassert>
#include <cstring>
#include <cmath>
#include <complex>
#include <functional>
using namespace std;
// }}}
// pre-written code {{{
#define REP(i,n) for(int i=0;i<(int)(n);++i)
#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)
#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)
#define ALL(c) (c).begin(), (c).end()
#define MP make_pair
#define PB push_back
#define CLEAR(c) memset((c),-1,sizeof(c))

typedef long long Int;
typedef long long ll;
typedef long double ld;

typedef pair<int,int> pii;
// }}}

int sign(int x){
	if(x>0)return 1;
	if(x<0)return -1;
	return 0;
}

int M,N,C,K;

const int MAX=32;

char c[MAX][MAX];
vector<pii> pat[MAX];
int ct;

//int ghost[MAX][MAX];

int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
int gi[MAX],gx[MAX][2],gnx[MAX][2],gd[MAX][2];
int b[MAX],d[MAX];

bool valid(int x,int y){
	return 0<=x and x<M and 0<=y and y<N and c[x][y]!='#';
}

void print(int b[MAX]){
	REP(i,M){
		int c=b[i+1];
		c>>=1;
		REP(i,N){
			printf("%d",c%2);
			c/=2;
		}
		printf("\n");
	}
	printf("\n");
}

void main2(){
//	if(ct>3)assert(false);
	scanf("%d%d%d%d",&M,&N,&C,&K);
	REP(i,C){
		pat[i].clear();
		int L;scanf("%d",&L);
		REP(j,L){
			int x,y;scanf("%d%d",&x,&y);
			pat[i].PB(pii(y,x));
		}
	}
	REP(i,M)scanf("%s",c[i]);
	memset(b,0,sizeof(b));
	memset(d,0,sizeof(d));
	REP(i,M)REP(j,N)if(valid(i,j))d[i+1]|=(1<<(j+1));
	REP(i,C)gi[i]=0,gx[i][0]=pat[i][0].first,gx[i][1]=pat[i][0].second;
	int sx,sy,ex,ey;
	REP(i,M)REP(j,N){
		if(c[i][j]=='@')sx=i,sy=j;
		else if(c[i][j]=='$')ex=i,ey=j;
	}
	b[sx+1]|=(1<<(sy+1));
	int ans=-1;
	for(int s=0;s<=K;s++){
/*		REP(i,M)cout<<b[i]<<endl;
		cout<<endl;*/
//		if(ct>=2)print(b);
		if(b[ex+1]&(1<<(ey+1))){
			ans=s;break;
		}
		REP(i,C){
			if(gx[i][0]==pat[i][gi[i]].first and gx[i][1]==pat[i][gi[i]].second){
				int nextg=gi[i]+1;
				if(nextg==pat[i].size())nextg=0;
				gd[i][0]=sign(pat[i][nextg].first-pat[i][gi[i]].first);
				gd[i][1]=sign(pat[i][nextg].second-pat[i][gi[i]].second);
				gi[i]=nextg;
			}
		}
		REP(i,C)gnx[i][0]=gx[i][0]+gd[i][0],gnx[i][1]=gx[i][1]+gd[i][1];
		int bn[MAX];
		memset(bn,0,sizeof(bn));
		REP(i,M){
			bn[i+1]|=b[i+1];
			bn[i+1]|=(b[i+1]<<1);
			bn[i+1]|=(b[i+1]>>1);
			bn[i+1]|=b[i];
			bn[i+1]|=b[i+2];
		}
		REP(i,C){
			bn[gx[i][0]+1]&=(~(1<<(gx[i][1]+1)));
			bn[gnx[i][0]+1]&=(~(1<<(gnx[i][1]+1)));
		}
		REP(i,MAX)bn[i]&=d[i];
		memcpy(b,bn,sizeof(b));
		REP(i,C)gx[i][0]=gnx[i][0],gx[i][1]=gnx[i][1];
	}
	printf("%d\n",ans);
	//	assert(false);
}

int main() {
	int T;scanf("%d", &T);
	for(ct=0;ct<T;ct++)main2();
	return 0;
}

