#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
void gn(int &x){
    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
    if(c=='-')sg=-1,x=0;else x=c-'0';
    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
    x*=sg;
}
void gn(ll &x){
    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
    if(c=='-')sg=-1,x=0;else x=c-'0';
    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
    x*=sg;
}
//int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
//int gcd(int a,int b){return b?gcd(b,a%b):a;}
//const int mo=1000000007;

ll mul(ll x,ll y,ll z){if(z<=2e9)return (x%z)*(y%z)%z;else return (x*y-(ll)(x/(long double)z*y+1e-3)*z+z)%z;}
ll qp(ll a,ll b,ll mo){ll ans=1;do{if(b&1)ans=mul(ans,a,mo);a=mul(a,a,mo);}while(b>>=1);return ans;}
ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
int pr[9]={2,3,5,7,11,13,17,19,23};
int mr(ll n){
	if(n<=1)return 0;
	for (int i=0,a;i<9;i++){
		if((a=pr[i])==n)return 1;
		ll t=n-1;int k=0;
		while(~t&1)t>>=1,k++;
		ll c=qp(a,t,n);
		if(c==1)continue;
		int bo=0;
		for (int i=0;i<k;i++){
			if(c==n-1){bo=1;break;}
			c=mul(c,c,n);
		}
		if(!bo)return 0;
	}
	return 1;
}
int n;
struct num{
	ll nu;int cn;
}a[555];
int col[555]={0};
vector<int>ve[555];
///////////////////////////////////////////////
////////////////////////////////////
typedef ll nu;
const nu inf=ll(2e18);
const int MAXV=1111+5;
const int MAXE=100000+5;
////////////////////////////////////
int s,t;
struct edge{int v,next;nu f;}e[MAXE*2];int g[MAXV],etot;
void ae(int u,int v,nu f){
	e[etot].v=v;e[etot].f=f;e[etot].next=g[u];g[u]=etot++;
	e[etot].v=u;e[etot].f=0;e[etot].next=g[v];g[v]=etot++;
}
int d[MAXV],qu[MAXV];
int lb(int s,int t){
	for (int i=1;i<=::t;i++)d[i]=0;
	int p=0,q=0;
	qu[q++]=s,d[s]=1;
	while(p!=q){
		int u=qu[p++];
		for (int i=g[u];~i;i=e[i].next)if(e[i].f && !d[e[i].v]){
			d[e[i].v]=d[u]+1;
			if(e[i].v==t)return 1;
			qu[q++]=e[i].v;
		}
	}return 0;
}
nu aug(int u,nu mi,int t){
	if(u==t)return mi;
	nu su=0,del;
	for (int i=g[u];~i;i=e[i].next)if(e[i].f && d[e[i].v]==d[u]+1){
		del=aug(e[i].v,min(mi,e[i].f),t);
		mi-=del;
		e[i].f-=del;e[i^1].f+=del;
		su+=del;
		if(!mi)break;
	}
	if(!su)d[u]=-1;
	return su;
}
ll flow=0;
void dinic(){
	while(lb(s,t))flow+=aug(s,inf,t);
}
int eid[555];
int main()
{
	gn(n);
	for (int i=1;i<=n;i++){
		gn(a[i].nu);
		gn(a[i].cn);
	}
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++){
			ll x=min(a[i].nu,a[j].nu);
			ll y=max(a[i].nu,a[j].nu);
			if(y%x==0 && mr(y/x)){
				ve[i].push_back(j);
				ve[j].push_back(i);
			}
		}
	for (int u=1;u<=n;u++)if(!col[u]){
		int p=0,q=0;
		qu[q++]=u;col[u]=1;
		while(p!=q){
			int u=qu[p++];
			for (int i=0;i<ve[u].size();i++){
				int v=ve[u][i];
				if(!col[v]){
					col[v]=3-col[u];
					qu[q++]=v;
				}
			}
		}
	}
	etot=0;
	memset(g,-1,sizeof(g));
	s=n+1,t=n+2;
	for (int i=1;i<=n;i++){
		eid[i]=etot;
		if(col[i]==1)ae(s,i,a[i].cn);
		else ae(i,t,a[i].cn);
	}
	for (int u=1;u<=n;u++)if(col[u]==1)
		for (int i=0;i<ve[u].size();i++){
			int v=ve[u][i];
			ae(u,v,inf);
		}
	dinic();
	ll old=flow;
	ll mi=inf;
	for (int i=1;i<=n;i++){
		if(e[eid[i]].f){
			mi=min(mi,a[i].nu);
			continue;
		}
		if(col[i]==1){
			int v=e[eid[i]].v;
			e[eid[i]^1].f--;
			if(lb(t,v))flow-=aug(t,1,v);
			dinic();
			if(flow==old){
				mi=min(mi,a[i].nu);
			}
			e[eid[i]].f++;
			dinic();
		}else{
			int v=e[eid[i]^1].v;
			e[eid[i]^1].f--;
			if(lb(v,s))flow-=aug(v,1,s);
			dinic();
			if(flow==old){
				mi=min(mi,a[i].nu);
			}
			e[eid[i]].f++;
			dinic();
		}
	}
	if(mi==inf){
		printf("Tyrion\n");
	}else{
		printf("Bran %lld\n",mi);
	}
	return 0;
}
