#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

int prime[]={0,2,3,5,7,11,13,17,19,23,29};

long long mult(long long a,long long b,long long p)
{
	a%=p;b%=p;if(a<0)a+=p;if(b<0)b+=p;
	long long ans=(long long)((long double)a*b/p);
	ans=a*b-ans*p;
	if(ans>=p)ans-=p;if(ans<0)ans+=p;
	return ans;
}

long long Power(long long a,long long b,long long p)
{
	long long ans=1;
	for(;b;b>>=1,a=mult(a,a,p))if(b&1)ans=mult(ans,a,p);
	return ans;
}

bool Miller_Rabin(long long n)
{
	if(n<=1)return false;
	if(n==2)return true;
	if(n%2==0)return false;
	long long i,j,k=0,m=n-1,a;
	while(m%2==0)m/=2,++k;
	for(i=1;i<=10;++i)
	{
		if(prime[i]==n)return true;
		a=Power(prime[i],m,n);
		if(a==1)continue;
		for(j=1;j<=k;++j)
		{
			if(a==n-1)break;
			a=mult(a,a,n);
		}
		if(j>k)return false;
	}
	return true;
}

#define inf 1000000000
struct Dinic_maximum_flow
{
	#define Graph_vertex 605
	#define Graph_edge 600005
	#define flow_value long long
	
	int son[Graph_vertex],next[Graph_edge],ed[Graph_edge],d[Graph_vertex],q[Graph_vertex],ll,rr;
	flow_value flow[Graph_edge],sum,tmp;
	int n,S,T,tot,i,u,v;
	bool vis[Graph_vertex];
	
	inline void clear(int N){for(n=N,tot=1,i=0;i<=n;++i)son[i]=0;}
	inline void add(int u,int v,flow_value c)
	{
		next[++tot]=son[u];son[u]=tot;ed[tot]=v;flow[tot]=c;
		next[++tot]=son[v];son[v]=tot;ed[tot]=u;flow[tot]=0;
	}
	flow_value find(int now,flow_value Flow)
	{
		if(now==T||!Flow)return Flow;
		flow_value tmp,w=0;
		for(int i=son[now];i&&w<Flow;i=next[i])
		if(flow[i]&&d[now]+1==d[ed[i]])
		{
			tmp=find(ed[i],min(Flow-w,flow[i]));
			flow[i]-=tmp;flow[i^1]+=tmp;w+=tmp;
		}
		if(!w)d[now]=inf;
		return w;
	}
	bool bfs()
	{
		for(i=0;i<=n;++i)vis[i]=false;
		q[rr=1]=S;vis[S]=true;
		for(ll=0;ll<rr&&!vis[T];)
		{
			u=q[++ll];
			for(i=son[u];i;i=next[i])
			if(flow[i]&&!vis[ed[i]])
			{
				v=ed[i];
				q[++rr]=v;
				d[v]=d[u]+1;
				vis[v]=true;
			}
		}
		return vis[T];
	}
	flow_value dinic(int s,int t)
	{
		S=s;T=t;
		for(sum=d[S]=0;bfs();)sum+=find(S,inf);
		return sum;
	}
	
	#undef Graph_vertex
	#undef Graph_edge
	#undef flow_value
}G;

int S,T,n,i,j,k,u,v;
int b[505],c[505],fa[505],d[505],link[505];
long long a[505],sum1,sum2,flow;
bool e[505][505];

inline bool cmp(const int &x,const int &y){return a[x]<a[y];}
int get(int x)
{
	if(fa[x]==x)return x;
	get(fa[x]);
	d[x]^=d[fa[x]];
	fa[x]=fa[fa[x]];
	return fa[x];
}

int main()
{
	scanf("%d",&n);S=0;T=n+1;
	G.clear(n+1);
	for(i=1;i<=n;++i)scanf("%lld%d",&a[i],&c[i]),b[i]=i;
	for(i=1;i<=n;++i)fa[i]=i;
	for(i=1;i<=n;++i)
	for(j=1;j<=n;++j)
	if(a[i]%a[j]==0&&Miller_Rabin(a[i]/a[j]))
	{
		e[i][j]=e[j][i]=true;
		u=get(i);v=get(j);
		if(u==v)continue;
		fa[u]=v;d[u]=d[i]^d[j]^1;
	}
	for(i=1;i<=n;++i)get(i);
	for(i=1;i<=n;++i)
	if(d[i])
	{
		sum1+=c[i];
		G.add(S,i,c[i]);link[i]=G.tot;
		for(j=1;j<=n;++j)
		if(e[i][j])G.add(i,j,inf);
	}else G.add(i,T,c[i]),sum2+=c[i],link[i]=G.tot;
	if(G.dinic(S,T)==max(sum1,sum2))printf("Tyrion\n");
	else
	{
		sort(b+1,b+n+1,cmp);
		printf("Bran");
		for(i=1;i<=n;++i)
		{
			k=b[i];
			u=G.flow[link[k]-1];
			v=G.flow[link[k]];
			if(v<c[k])
			{
				printf(" %lld\n",a[k]);
				return 0;
			}
			G.flow[link[k]-1]=G.flow[link[k]]=0;
			if(d[k])flow=G.dinic(S,k);
			else flow=G.dinic(k,T);
			if(flow>=1)
			{
				printf(" %lld\n",a[k]);
				return 0;
			}
			G.flow[link[k]-1]=u;
			G.flow[link[k]]=v;
		}
	}
}