#include <vector>
#include <iostream>
#include <algorithm>
#include <stdio.h>
#include <string.h>
#include <queue>
using namespace std;
 
const int maxn = 557, maxnum = 0x3f3f3f3f;
typedef long long ll;
namespace RHO {
  ll mulMod(ll a, ll b, ll n) {
    if(a == 0 || b <= (1LL << 62) / a) return a * b % n;
    ll result = 0;	
    if(a < b) swap(a,b);
    for(; b != 0; b >>= 1) {
      if(b & 1) {
        result += a; if(result >= n) result -= n;
      }
      a <<= 1; if(a >= n) a -= n;
    }
    return result;
  }
 
  ll powMod(ll a, ll exp, ll n) {
    ll result = 1;
    for(; exp != 0; exp >>= 1) {
      if(exp & 1) {
        result = mulMod(result, a, n);
      }
      a = mulMod(a, a, n);
    }
    return result;
  }
 
  ll f(ll x, ll c, ll n) {
    ll result = mulMod(x, x, n);
    result += c; if(result >= n) result -= n;
    return result;
  }
 
  ll gcd(ll u, ll v) {
    while(u) v %= u, swap(u,v); return v;
  }
 
  bool primeTestMillerRabin(ll n, ll a) {
    ll d = n-1, x;
    int s = 0, r;
    while ((d & 1) == 0 && d != 0) s++, d >>= 1;
    while (a >= n) a >>= 1;
    x = powMod(a, d, n);
    if (x != 1 && x != n-1) {
      r = 1;
      while (r <= s-1 && x != n-1) {
        x = mulMod(x, x, n);
        if (x == 1) return false; else r++;
      }
      if (x != n-1) return false;
    }
    return true;
  }
 
  bool multipleMillerRabin(ll n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if ((n & 1) == 0) return false;
    return primeTestMillerRabin(n, 2) && 
      primeTestMillerRabin(n, 3) && primeTestMillerRabin(n, 5) && primeTestMillerRabin(n, 7) && (n < 3215031751LL || (primeTestMillerRabin(n, 11) && (n < 2152302898747LL || (primeTestMillerRabin(n, 13) && (n < 3474749660383LL || (primeTestMillerRabin(n, 17) && (n < 341550071728321LL ||(primeTestMillerRabin(n, 23)))))))));
  }
 
  ll pollardsRho(ll n, bool testPrime) {
    for (int count = 0, c = 1;;) {
      ll x = 2, y = 2, pot = 1, lam = 1, d;
      do {
        ++count;
        if (count == 12) {
          if (testPrime) return multipleMillerRabin(n) ? n : 1;
          else if (multipleMillerRabin(n)) return n;
        }
        if(pot == lam) x = y, pot <<= 1, lam = 0;
        y = f(y,c,n), lam++;
        d = gcd(x >= y ? x - y : y - x, n);
      } while (d == 1);
      if (d != n) return d; else c++;
    }
  }
 
  bool tripleMillerRabin(int x) {
    return primeTestMillerRabin(x, 2) && primeTestMillerRabin(x, 7) && primeTestMillerRabin(x, 61);
  }
 
  bool isPrime(ll n) {
    if (n <= 0x7fffffff) return tripleMillerRabin((int)n);
    else return pollardsRho(n, true) == n;
  }
 
  int gao(ll u, ll v) {
    if(v > u) return v % u == 0 && isPrime(v/u);
    if(u > v) return u % v == 0 && isPrime(u/v);
    return 0;
  }
};

namespace MaxFlow
{
    const int N = maxn;
    const int M = 1000007;
 
    int n, m, x[N], y[N];
 
    int edgeCount, firstEdge[N], to[M], capacity[M], nextEdge[M], currentEdge[N];
    int source, target, flow, pre[N], sign;
 
    void addEdge(int u, int v, int w) {
        to[edgeCount] = v;
        capacity[edgeCount] = w;
        nextEdge[edgeCount] = firstEdge[u];
        firstEdge[u] = edgeCount ++;
    }
 
    void insert(int u, int v, int w)
    {
        addEdge(u, v, w);
        addEdge(v, u, 0);
    }
 
    int level[N], queue[N];
 
    bool bfs(int s, int t) {
        memset(level, -1, sizeof(level));
        sign=t;
        level[t] = 0;
        int tail = 0;
        queue[tail ++] = t;
        int head = 0;
        while (head != tail && level[s] == -1) {
            int v = queue[head ++];
            for (int iter = firstEdge[v]; iter != -1; iter = nextEdge[iter]) {
                if (capacity[iter ^ 1] > 0 && level[to[iter]] == -1) {
                    level[to[iter]] = level[v] + 1;
                    queue[tail ++] = to[iter];
                }
            }
        }
        return level[s] != -1;
    }
 
    inline void push()
    {
        int delta=maxnum,u,p;
        for (u=target;u!=source;u=to[p]){
            p=pre[u];
            delta=min(delta,capacity[p]);
            p^=1;
        }
 
        for (u=target;u!=source;u=to[p]){
            p=pre[u];
            capacity[p]-=delta;
            if (!capacity[p]){
                sign=to[p^1];
            }
            capacity[p^=1]+=delta;
        }
        flow+=delta;
    }
 
    void dfs(int u) {
        if (u == target) {
            push();
            return;
        }
        for (int &iter = currentEdge[u]; iter != -1; iter = nextEdge[iter]) {
            if (capacity[iter] > 0 && level[u] == level[to[iter]] + 1) {
                pre[to[iter]]=iter;
                dfs(to[iter]);
                if (level[sign]>level[u]) return;
                sign=target;
            }
        }
        level[u]=-1;
    }
 
    void initNetwork(int nodes)
    {
        n = nodes;
        edgeCount = 0;
        for (int i = 0; i <= n; ++i)
            firstEdge[i] = -1;
    }
 
    int maxFlow(int s, int t)
    {
        source = s;
        target = t;
 
        flow=0;
        while (bfs(source, target)) {
            for (int i = 0; i < n; ++ i) {
                currentEdge[i] = firstEdge[i];
            }
            dfs(source);
        }
 
        return flow;
    }
}

int N;
bool cnt[maxn][maxn], use[maxn], ODD[maxn];
struct NODE
{
    long long a;
    int c;
    bool operator < (const NODE &p) const
    {
        return a < p.a;
    }
} p[maxn];
 
void Fill(int x, int order)
{
    use[x] = true;
    if (order) ODD[x] = false;
    else       ODD[x] = true;
    for (int xx = 1; xx <= N; xx++)
        if (cnt[x][xx] && !use[xx]) Fill(xx, order^1);
}

int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N; i++) scanf("%lld%d", &p[i].a, &p[i].c);
    sort(p+1, p+1+N);
    for (int i = 1; i <= N; i++)
        for (int j = 1; j <= N; j++) cnt[i][j] = false;
    for (int i = 1; i <= N; i++)
        for (int j = i+1; j <= N; j++)
            if (RHO::gao(p[i].a, p[j].a)) cnt[i][j] = cnt[j][i] = true;
    for (int i = 1; i <= N; i++) use[i] = false;
    for (int i = 1; i <= N; i++)
        if (!use[i]) Fill(i, 0);
    int first = N+1, last = first+1;
    MaxFlow::initNetwork(last+1);
    for (int i = 1; i <= N; i++)
        if (ODD[i]) MaxFlow::insert(first, i, p[i].c);
        else        MaxFlow::insert(i, last, p[i].c);
    for (int i = 1; i <= N; i++)
        for (int j = 1; j <= N; j++)
            if (ODD[i] && !ODD[j] && cnt[i][j]) MaxFlow::insert(i, j, maxnum);
    MaxFlow::maxFlow(first, last);
    long long res = -1;
    for (int i = 1; i <= N; i++)
    {
        if (ODD[i]) MaxFlow::insert(i, last, 1);
        else        MaxFlow::insert(first, i, 1);
        if (MaxFlow::bfs(first, last))
        {
            res = p[i].a;
            break;
        }
        if (ODD[i]) MaxFlow::insert(first, i, 1);
        else        MaxFlow::insert(i, last, 1);
        MaxFlow::maxFlow(first, last);
    }
    if (res == -1) puts("Tyrion");
    else           printf("Bran %lld\n", res);
    return 0;
}
