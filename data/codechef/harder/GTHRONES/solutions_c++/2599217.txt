#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;

#define ll unsigned long long

unsigned long long mulmod(unsigned long long a, unsigned long long b,
		unsigned long long c) {
	unsigned long long sum = 0, y = a % c;
	while (b) {
		if (b & 1) {
			sum += y;
			if (sum >= c)
				sum -= c;
		}
		y += y;
		if (y >= c)
			y -= c;
		b >>= 1;
	}
	return sum;
}

// Calculates a^b mod P
unsigned long long modulo(unsigned long long a, unsigned long long b,
		unsigned long long P) {
	unsigned long long ans = 1;
	while (b) {
		if (b & 1)
			ans = mulmod(ans, a, P);
		a = mulmod(a, a, P);
		b >>= 1;
	}
	return ans;
}

// Miler rabin primality test
const int maxIter = 10;
bool isPrime(unsigned long long N) {
	if (N < 2)
		return false;
	if (N % 2 == 0)
		return N == 2;
	if (N % 3 == 0)
		return N == 3;
	if (N % 5 == 0)
		return N == 5;
	if (N % 7 == 0)
		return N == 7;
	int d = 0;
	long long odd = N - 1;
	while ((odd & 1) == 0) {
		d++;
		odd >>= 1;
	}

	for (int i = 0; i < maxIter; i++) {
		long long a = rand() % (N - 1) + 1;
		long long mod = modulo(a, odd, N);
		bool passes = (mod == 1 || (ll)mod == (N - 1));

		for (int r = 1; r < d && !passes; r++) {
			mod = mulmod(mod, mod, N);
			passes = passes || (ll)mod == N - 1;
		}

		if (!passes)
			return false;
	}
	return true;
}

#define N 1005
int mat[502][502];

vector<pair<ll, int> > izq,der;
ll rep[502], num[502];
ll flujo, total, suma[N];
bool vis[N];
int n, I, D;

const int MAXN = 5005;
const int MAXA = 1000005;
const int oo = 1e9;
int node, fuente, dest, A;

int to[MAXA], next[MAXA], flow[MAXA], cap[MAXA];
int head[MAXN], dist[MAXN], Q[MAXN], work[MAXN];

void init() {
	node = I + D + 2;
	fuente = node - 1;
	dest = node - 2;

	for(int i = 0; i < node; ++i)
		head[i] = -1;
	A = 0;
}

void addEdge(int u, int v, int c)	{
	to[A] = v, cap[A] = c, flow[A] = 0, next[A] = head[u], head[u] = A++;
	to[A] = u, cap[A] = 0, flow[A] = 0, next[A] = head[v], head[v] = A++;
}

bool dinic_bfs() {
	for (int i = 0; i < node; i++)
		dist[i] = -1;

	dist[fuente] = 0;
	int sizeQ = 0;
	Q[sizeQ++] = fuente;
	for (int front = 0; front < sizeQ; front++) {
		for (int u = Q[front], e = head[u]; e >= 0; e = next[e]) {
			int v = to[e];
			if (flow[e] < cap[e] && dist[v] < 0){
				dist[v] = dist[u] + 1;
				Q[sizeQ++] = v;
			}
		}
	}
	return dist[dest] >= 0;
}

int dinic_dfs(int u, int bot) {
	if (u == dest)
		return bot;
	for (int i = work[u]; i >= 0; i = next[i], work[u] = i) {
		int v = to[i], tmp;
		if (flow[i] < cap[i] && dist[v] == dist[u] + 1
				&& (tmp = dinic_dfs(v, min(bot, cap[i] - flow[i]))) > 0) {
			flow[i] += tmp;
			flow[i ^ 1] -= tmp;
			return tmp;
		}
	}
	return 0;
}

ll flowM() {
	ll result = 0;
	while (dinic_bfs()) {
		for (int i = 0; i < node; i++)
			work[i] = head[i];
		while (true) {
			int delta = dinic_dfs(fuente, oo);
			if (delta == 0)
				break;
			result += delta;
		}
	}
	return result;
}

void construir(int x){
	int I = izq.size(), ind, D = der.size();
	init();
	for(int i = 0; i < x; ++i){
		ind = izq[i].second;
		addEdge(fuente,i,rep[ind]);
		for(int j = 0; j < (int)der.size(); ++j){
			if(mat[ind][der[j].second]){
				addEdge(i,I + j, (int)1e9);
			}
		}
	}
	for(int i= 0; i < D; ++i){
		addEdge(I+i, dest, rep[der[i].second]);
	}
}

void dfs(int x, int flag) {
	if (vis[x])
		return;
	vis[x] = true;
	if (flag == 0)
		izq.push_back(make_pair(num[x], x));
	else
		der.push_back(make_pair(num[x], x));

	for(int i = 0; i < n; ++i)
		if (mat[x][i])
			dfs(i, 1 - flag);
}


ll solve(){
	sort(izq.begin(), izq.end());
	reverse(izq.begin(), izq.end());
	I = izq.size();
	D = der.size();
	suma[I] = 0;
	for(int i = I-1; i >= 0; --i){
		suma[i] = suma[i+1] + rep[izq[i].second];
	}
	if(flujo == suma[0])
		return (ll)1e18;

	int lo = 0, hi = I-1, mid;
	while(lo < hi){
		mid = (lo + hi)/2;
		construir(mid+1);
		if(flujo - flowM() == suma[mid+1]){
			hi = mid;
		}
		else{
			lo = mid+1;
		}
	}
	return izq[lo].first;

}


int main() {
	scanf("%d",&n);
	for(int i = 0; i < n; ++i){
		scanf("%lld%lld",&num[i], &rep[i]);
		total += rep[i];
	}

	ll u, v;
	for(int i = 0; i < n; ++i){
		u = num[i];
		for(int j = i+1; j < n; ++j){
			v = num[j];
			if(u > v && u % v == 0 && isPrime(u / v)){
				mat[i][j] = mat[j][i] = 1;
			}
			else if(v > u && v % u == 0 && isPrime(v / u)){
				mat[i][j] = mat[j][i] = 1;
			}
		}
	}

	for(int i = 0; i < n; ++i)
		if(!vis[i])
			dfs(i, 0);
	I = izq.size();
	D = der.size();

	construir(izq.size());
	flujo = flowM();
	if(2LL*flujo == total){
		printf("Tyrion\n");
		return 0;
	}

	ll a = solve();
	swap(izq,der);
	ll b = solve();
	printf("Bran %lld\n",min(a,b));

	return 0;
}