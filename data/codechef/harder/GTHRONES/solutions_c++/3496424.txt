#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
typedef long long LL;
struct node{
	LL d;int c;
}d[550];
int n;
int cmp(const node &a,const node &b){
	return a.d < b.d;
}
void read(){
	scanf("%d",&n);
	for (int i = 1;i <= n;i++)
		scanf("%lld%d",&d[i].d,&d[i].c);
	sort(d+1,d+n+1,cmp);
}
LL mul(LL a,LL b,LL mo){
	LL s = 0;
	a %= mo;
	while (b){
		if (b & 1){
			s += a;
			if (s > mo) s -= mo;
		}
		a <<= 1;
		if (a > mo) a -= mo;
		b >>= 1;
	}
	return s;
}
LL ksm(LL a,LL b,LL mo){
	LL k = 1;
	while (b){
		if (b & 1) k = mul(k,a,mo);
		b >>= 1;
		a = mul(a,a,mo);
	}
	return k;
}
int check(LL n,LL m,LL j){
	LL a = rand()%(n-2) + 2;
	LL x = ksm(a,m,n);
	for (int i = 1;i <= j;i++){
		LL y = mul(x,x,n);
		if ((y == 1) && (x != 1) && (x != n-1)) return false;
		x = y;
		if (y == 1) return true;
	}
	return false;
}
int Miller_Rabin(LL x){
	if (x == 2) return true;
	if (!(x & 1)) return false;
	LL m = x - 1;int j = 0;
	while (!(m & 1)) j++ , m >>= 1;
	for (int i = 1;i <= 5;i++){
		if (!check(x,m,j)) return false;
	}
	return true;
}


struct E{
	int from,to,n;
}g[250100];
int h[100100],col[100100];
int ecnt = 1;
void add(int from,int to){
	g[++ecnt] = (E){from,to,h[from]};h[from] = ecnt;
}
void prepare(){
	for (int i = 1;i <= n;i++)
		for (int j = i;j <= n;j++)
			if (i != j){
				int x = i,y = j;
				if (d[x].d < d[y].d) swap(x,y);
				if ((d[x].d % d[y].d) != 0) continue;
				
				LL pri = d[x].d/d[y].d;
				if (Miller_Rabin(pri))
					add(x,y),add(y,x);
			}
}
int bipartite(int u){
	for (int i = h[u];i;i = g[i].n){
		int v = g[i].to;
		if (col[u] == col[v]) return false;
		if (!col[v]){
			col[v] = 3 - col[u];
			if (!bipartite(v)) return false;
		}
	}
	return true;
}
void setcol(){
	for (int i = 1;i <= n;i++)
		if (!col[i]){
			col[i] = 1;
			bipartite(i);
		}
}
struct edge{
	int from,to;long long cap,flow,n;
}a[250100];
int head[100100];
int s,t,e = 1;
const LL oo = (1LL << 60);
void addedge(int from,int to,LL cap){
	a[++e] = (edge){from,to,cap,0,head[from]};head[from] = e;
	a[++e] = (edge){to,from,0,0,head[to]};head[to] = e;
}
void build(){
	s = n+1,t = n+2;
	for (int i = 1;i <= n;i++)
		if (col[i] == 1) addedge(s,i,d[i].c);
		else addedge(i,t,d[i].c);
	for (int i = 2;i <= ecnt;i += 2){
		int x = g[i].from,y = g[i].to;
		if (col[x] == 1) addedge(x,y,oo);
		else addedge(y,x,oo);
	}
}
int cur[1100],dis[1100],vis[1100];
int Bfs(){
	memset(vis,0,sizeof(vis));
	queue <int> Q;
	Q.push(t);dis[t] = 0;vis[t] = 1;
	while (!Q.empty()){
		int x = Q.front();Q.pop();
		for (int i = head[x];i;i = a[i].n){
			edge &e = a[i ^ 1];
			if (!vis[e.from] && e.cap > e.flow){
				dis[e.from] = dis[x] + 1;
				vis[e.from] = 1;
				Q.push(e.from);
			}
		}
	}
	return vis[s];
}
LL Dfs(int x,LL now){
	if (x == t || now == 0)return now;
	LL flow = 0,f;
	for (int &i = cur[x];i;i = a[i].n)
		if (dis[x] == dis[a[i].to] + 1 && (f = Dfs(a[i].to,min(now,a[i].cap - a[i].flow))) > 0){
			a[i].flow += f;
			a[i ^ 1].flow -= f;
			now -= f;
			flow += f;
			if (now == 0) break;
		}
	return flow;
}
LL Maxflow(){
	LL flow = 0;
	while (Bfs()){
		for (int i = 1;i <= t;i++)
			cur[i] = head[i];
		flow += Dfs(s,oo);
	}
	return flow;
}
LL ans = (1LL << 60),minn = (1LL << 60),sum = 0,mark = 0;
int ok[11000];
void tree(int x,int o){
	if (vis[x] == mark) return;
	vis[x] = mark;
	if (o == 1){
		ans = min(ans,d[x].d);
		if (col[x] == 1){
			for (int i = head[x];i;i = a[i].n)
				if (a[i].cap > 0 && a[i].cap > a[i].flow)
					tree(a[i].to,0);
		}else {
			for (int i = head[x];i;i = a[i].n)
				if (a[i ^ 1].cap > 0 && a[i ^ 1].cap > a[i ^ 1].flow)
					tree(a[i ^ 1].from,0);
		}
	}else {
		if (col[x] == 1){
			for (int i = head[x];i;i = a[i].n)
				if (a[i].cap > 0 && a[i].flow > 0)
					tree(a[i].to,1);
		}else {
			for (int i = head[x];i;i = a[i].n)
				if (a[i ^ 1].cap > 0 && a[i ^ 1].flow > 0)
					tree(a[i ^ 1].from,1);
		}
	}
}
void findans(){
	memset(vis,0,sizeof(vis));
	for (int x = 1;x <= n;x++){
		minn = min(minn,d[x].d);
		sum += d[x].c;
		for (int i = head[x];i;i = a[i].n)
			if (a[i].to == s){
				int j = i ^ 1;
				if (a[j].cap > a[j].flow) ok[x] = a[j].cap - a[j].flow;
				else ok[i] = 0;
				break;
			}else if (a[i].to == t){
				if (a[i].cap > a[i].flow) ok[x] = a[i].cap - a[i].flow;
				else ok[i] = 0;
				break;
			}
	}
	ok[s] = ok[t] = 0;
	for (int x = 1;x <= n;x++)
		if (ok[x] > 0)
			mark++,tree(x,1);
}

int main(){
	read();
	prepare();
	setcol();
	build();
	LL flow = Maxflow();
	findans();
	if (flow*2 != sum){
		printf("Bran %lld\n",ans);
	}else 
		printf("Tyrion\n");
	return 0;
}
