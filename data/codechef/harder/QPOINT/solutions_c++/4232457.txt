#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;

#define REP0(i, n) for (int i = 0; i < n; i++)
#define REP1(i, n) for (int i = 1; i <= n; i++)
#define REP(i, l, r) for (int i = l; i <= r; i++)
#define RP(i, r, l) for (int i = r; i >= l; i--)
#define FORE(i, x) for (int i = fi[x]; i != -1; i = e[i].n)

#define A first
#define B second
#define MP make_pair 

typedef long long m64;
inline int gi(void)
{
       static int s, flag; static char c;
       while (c = getchar()) if (('0' <= c && c <= '9') || c == '-') break;
       if (c == '-') flag = -1, c = getchar(); else flag = 1;
       for (s = 0; '0' <= c && c <= '9'; c = getchar()) s = s * 10 + c - '0';
       return s * flag; 
}

template < typename T > inline int sgn(T x) { return x ? (x > 0 ? 1 : -1) : 0; }
typedef pair < int, int > PT;
inline m64 det(PT a, PT b) { return a.A * 1LL * b.B - a.B * 1LL * b.A; }
inline m64 det(PT o, PT a, PT b)
{ return (a.A - o.A) * 1LL * (b.B - o.B) - (a.B - o.B) * 1LL * (b.A - o.A); }
inline m64 fdet(PT a, PT b) { return sgn(a.A * 1LL * b.B - a.B * 1LL * b.A); }
inline m64 fdet(PT o, PT a, PT b)
{ return sgn((a.A - o.A) * 1LL * (b.B - o.B) - (a.B - o.B) * 1LL * (b.A - o.A)); }

#define MAX_N 110000
#define MAX_M 310000

PT *poly[MAX_N];
int pn[MAX_N], n, m, en;

struct Event
{
       PT seg, x; int type;
       inline bool operator < (const Event& a) const 
       { return x != a.x ? x < a.x : type < a.type; }
} ei[MAX_M << 1];

inline bool cmp(PT a, PT b) //判断a<b 
{
       PT pA = poly[a.A][a.B], pB = poly[a.A][a.B + 1], qA = poly[b.A][b.B],
          qB = poly[b.A][b.B + 1]; if (pA > pB) swap(pA, pB); if (qA > qB) swap(qA, qB);
       if (pB == qA) return true; if (pA == qB) return false;
       if (pA == qA) return fdet(pA, pB, qB) > 0; if (pB == qB) return fdet(pB, qA, pA) > 0;
       int c1 = fdet(pA, pB, qA), c2 = fdet(pA, pB, qB);
       if (c1 > 0 && c2 > 0) return true;
       if (c1 < 0 && c2 < 0) return false;
       if (c1 > 0) return det(qA, qB, pB) < 0;
       return det(qB, qA, pA) > 0;
}

inline bool onleft(PT a, PT b)
{
       PT pA = poly[a.A][a.B], pB = poly[a.A][a.B + 1];
       if (pA > pB) swap(pA, pB);
       return det(pA, pB, b) >= 0;
}

#define MAX_L 11000000
#define lc c[0]
#define rc c[1]

typedef struct node* ntp;
struct node { PT key; int w; ntp c[2]; } pool[MAX_L], *ua = pool;

inline ntp newa(void) { if (ua != pool + MAX_L) return ua++; return new node; }
inline void rot(ntp &x, int d) { ntp y = x->c[!d]; x->c[!d] = y->c[d], y->c[d] = x, x = y; }
inline int rands(void) { return ((rand() << 16) | rand()); }
ntp ins(ntp u, PT key)
{
    ntp v = newa(); if (!u) { v->key = key, v->w = rands(), v->lc = v->rc = NULL; return v; }
    *v = *u; int d = !cmp(key, u->key); v->c[d] = ins(u->c[d], key);
    if (v->c[d]->w < v->w) rot(v, !d);
    return v;
}

void delx(ntp &x)
{
     if (!x->lc && !x->rc) { x = NULL; return ; } ntp y = newa();
     int d = !(x->lc && (!x->rc || x->lc->w < x->rc->w));
     *y = *x->c[d], x->c[d] = y, rot(x, !d), delx(x->c[!d]);     
}

ntp del(ntp x, PT key)
{
    ntp y = newa(); *y = *x;
    if (x->key == key) delx(y);
    else { int d = !cmp(key, x->key); y->c[d] = del(x->c[d], key); }
    return y;    
}

ntp query(ntp x, PT key)
{
    ntp res = NULL;
    while (x) if (onleft(x->key, key)) res = x, x = x->rc; else x = x->lc;
    return res;
}

void print(ntp x)
{
     if (!x) return ;
     print(x->lc), printf ("[%d %d] ", x->key.A, x->key.B), print(x->rc);
}

ntp rt[MAX_M << 1];
void Init(void)
{
     REP1(i, n)
     {
         m64 sum = 0;
         REP0(j, pn[i]) sum += det(poly[i][j], poly[i][j + 1]);
         if (sum < 0) reverse(poly[i], poly[i] + pn[i]), poly[i][pn[i]] = poly[i][0];
     }
     REP1(i, n) REP0(j, pn[i])
     {
         PT pA = poly[i][j], pB = poly[i][j + 1]; if (pA > pB) swap(pA, pB);
         ei[++en] = (Event) { MP(i, j), pA, 0 }, ei[++en] = (Event) { MP(i, j), pB, 1 };
     }
     sort(ei + 1, ei + en + 1); ntp cur = NULL;
     REP1(i, en)
     {
         Event e = ei[i];
         if (!e.type) cur = ins(cur, e.seg); else cur = del(cur, e.seg);
         rt[i] = cur;
     }
}

inline bool cmp1(Event x, PT y) { if (x.x != y) return x.x < y; else return !x.type; }
int Query(PT x)
{
    int l = 1, r = en, mid;
    while (l <= r)
    {
          mid = (l + r) >> 1;
          if (cmp1(ei[mid], x)) l = mid + 1; else r = mid - 1;
    }
    if (--l == 0) return -1;
    ntp v = query(rt[l], x); PT s;
    if (!v) return -1; else s = v->key;
    if (det(poly[s.A][s.B], poly[s.A][s.B + 1], x) < 0) return -1;
    return s.A;
}

int main(void)
{
    srand(812387123), scanf ("%d", &n);
    REP1(i, n)
    {
        pn[i] = gi(), poly[i] = new PT[pn[i] + 1];
        REP0(j, pn[i]) { int x = gi(), y = gi(); poly[i][j] = MP(x, y); }
        poly[i][pn[i]] = poly[i][0];
    }
    Init(), scanf ("%d", &m);
    REP1(i, m) { int x = gi(), y = gi(); printf ("%d\n", Query(MP(x, y))), fflush(stdout); }
	return 0;
}
