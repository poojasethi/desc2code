#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <vector>
#include <algorithm>
#define inf 1000000000
using namespace std;

int n,m,i,j,k,ll,rr,aim,u,v,ans;
int pcnt[100005],pool_x[1000005],pool_y[1000005],*px[100005],*py[100005],*x,*y,cnt;
int dis[1000005],dis_cnt;
int xl[1000005],xr[1000005],d;
long long S;

long long calc(int x1,int y1,int x2,int y2){return (long long)x1*y2-(long long)x2*y1;}
int get_id(int x)
{
	int l=1,r=d,mid,aim;
	while(l<=r)
	{
		mid=l+r>>1;
		if(x>=xl[mid])aim=mid,l=mid+1;
		else r=mid-1;
	}
	return aim;
}

struct line
{
	int xl,xr,yl,yr,id;
	double calc(double X)const{return yl+(yr-yl)/(double)(xr-xl)*(X-xl);}
}now;
bool flag;

double Abs(double x){if(x<0)return -x;return x;}
inline bool cmp(const line &a,const line &b)
{
	double X=(double)(max(min(a.xl,a.xr),min(b.xl,b.xr))+min(max(a.xl,a.xr),max(b.xl,b.xr)))/2;
	double A=a.calc(X),B=b.calc(X);
	if(Abs(A-B)>0.000001)return A<B;
	int fa=a.xl<a.xr,fb=b.xl<b.xr;
	return fa<fb;
}

vector<line> L[2400005];

void B(int x,int l,int r)
{
	sort(L[x].begin(),L[x].end(),cmp);
	if(l==r)return;
	int mid=l+r>>1;
	B(x<<1,l,mid);
	B(x<<1|1,mid+1,r);
}

void C(int x,int l,int r)
{
	if(l>=ll&&r<=rr)
	{
		L[x].push_back(now);
		return;
	}
	int mid=l+r>>1;
	if(rr<=mid)C(x<<1,l,mid);
	else if(ll>mid)C(x<<1|1,mid+1,r);
		else C(x<<1,l,mid),C(x<<1|1,mid+1,r);
}

void work(vector<line> &L)
{
	if(!L.size())return;
	int l=0,r=L.size()-1,aim=-1,mid,xl,xr,yl,yr;
	long long c;
	while(l<=r)
	{
		mid=l+r>>1;
		xl=L[mid].xl;yl=L[mid].yl;xr=L[mid].xr;yr=L[mid].yr;
		if(xl>xr)swap(xl,xr),swap(yl,yr);
		c=calc(u-xl,v-yl,xr-xl,yr-yl);
		if(c==0)ans=L[mid].id;
		if(c>=0)aim=mid,r=mid-1;
		else l=mid+1;
	}
	if(aim==-1)return;
	if(flag){now=L[aim];flag=false;return;}
	if(cmp(L[aim],now))now=L[aim];
}

void Q(int x,int l,int r)
{
	work(L[x]);
	if(l==r)return;
	int mid=l+r>>1;
	if(aim<=mid)Q(x<<1,l,mid);
	else Q(x<<1|1,mid+1,r);
}

struct node
{
	int l,r,id;
}t[10000005];
int root[2400005],tot;

void C2(int &x,int l,int r)
{
	if(!x)x=++tot;
	if(l>=ll&&r<=rr)
	{
		t[x].id=k;
		return;
	}
	int mid=l+r>>1;
	if(rr<=mid)C2(t[x].l,l,mid);
	else if(ll>mid)C2(t[x].r,mid+1,r);
		else C2(t[x].l,l,mid),C2(t[x].r,mid+1,r);
}

void Q2(int x,int l,int r)
{
	if(t[x].id){ans=t[x].id;return;}
	if(!x||l==r)return;
	int mid=l+r>>1;
	if(aim<=mid)Q2(t[x].l,l,mid);
	else Q2(t[x].r,mid+1,r);
}

int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;++i)
	{
		scanf("%d",&m);pcnt[i]=m;
		px[i]=x=pool_x+cnt;
		py[i]=y=pool_y+cnt;
		cnt+=m+2;
		for(j=1;j<=m;++j)scanf("%d%d",&x[j],&y[j]);
		x[0]=x[m];y[0]=y[m];
		S=0;
		for(j=1;j<=m;++j)S+=calc(x[j-1],y[j-1],x[j],y[j]);
		if(S>0)
		{
			for(j=1;j<=m/2;++j)swap(x[j],x[m-j+1]),swap(y[j],y[m-j+1]);
			x[0]=x[m];y[0]=y[m];
		}
		for(j=1;j<=m;++j)dis[++dis_cnt]=x[j];
	}
	sort(dis+1,dis+dis_cnt+1);
	k=-1;
	for(i=1;i<=dis_cnt;++i)
	if(dis[i]!=k)
	{
		if(dis[i]!=k+1)xl[++d]=k+1,xr[d]=dis[i]-1;
		xl[++d]=dis[i];xr[d]=dis[i];k=dis[i];
	}
	if(k!=inf)xl[++d]=k+1,xr[d]=inf;
	for(i=1;i<=n;++i)
	{
		x=px[i];y=py[i];m=pcnt[i];
		for(j=1;j<=m;++j)
		{
			now.xl=x[j-1];now.yl=y[j-1];
			now.xr=x[j];now.yr=y[j];
			if(now.xl==now.xr)
			{
				ll=now.yl;rr=now.yr;k=i;
				if(ll>rr)swap(ll,rr);
				C2(root[get_id(now.xl)],0,inf);
			}
			else
			{
				now.id=i;
				ll=get_id(now.xl);
				rr=get_id(now.xr);
				if(ll>rr)swap(ll,rr);
				--rr;
				C(1,1,d);
				ll=rr=now.yl;k=i;
				C2(root[get_id(now.xl)],0,inf);
				ll=rr=now.yr;k=i;
				C2(root[get_id(now.xr)],0,inf);
			}
		}
	}
	B(1,1,d);
	scanf("%d",&m);
	for(;m;--m)
	{
		scanf("%d%d",&u,&v);ans=-1;
		aim=v;Q2(root[get_id(u)],0,inf);
		if(ans==-1)
		{
			aim=get_id(u);flag=true;
			Q(1,1,d);
			if(ans==-1)
			{
				if(flag)ans=-1;
				else
				{
					if(now.xl<now.xr)ans=now.id;
					else ans=-1;
				}
			}
		}
		printf("%d\n",ans);
		fflush(stdout);
	}
}