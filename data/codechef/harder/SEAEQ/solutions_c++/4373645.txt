#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <cmath>
#include <sstream>
#include <set>
#include <utility>
#include <queue>
#include <cassert>
#include <ctime>
using namespace std;

#define PB push_back
#define MP make_pair
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
#define get(a) scanf("%d", &a)

#define MAXn 500
#define MAXe 125000
#define MOD 1000000007

int ncr[MAXn+5][MAXn+5], fact[MAXn+5], fact_inv[MAXn+5][MAXe+5], n, e;
Long ans;

void Fact()
{
  Long a = 1;
  fact[0] = 1;
  ITR(i, 1, MAXn+1) {
    a *= i;
    a %= MOD;
    fact[i] = a;
  }
}

void nCr()
{
  REP(i, MAXn+1) {
    ncr[i][0] = 1;
    ITR(j, 1, i+1) {
      ncr[i][j] = ncr[i-1][j] + ncr[i-1][j-1];
      if(ncr[i][j] >= MOD) ncr[i][j] -= MOD;
    }
  }
}

void Fact_inv()
{
  REP(j, MAXe+1) fact_inv[1][j] = 1;
  ITR(i, 2, MAXn+1) {
    REP(j, MAXe+1) {
      fact_inv[i][j] = fact_inv[i-1][j];
      if(j-i >= 0) fact_inv[i][j] -= fact_inv[i-1][j-i];
      if(fact_inv[i][j] < 0) fact_inv[i][j] += MOD;
      if(j) fact_inv[i][j] += fact_inv[i][j-1];
      if(fact_inv[i][j] >= MOD) fact_inv[i][j] -= MOD;
    }
  }
}

int main()
{
  Fact();
  nCr();
  Fact_inv();

  ios_base::sync_with_stdio(0); cin.tie(0);
  int t;
  cin >> t;

  while(t--) {
    cin >> n >> e;
    e = min(e, MAXe);
    ans = 0;

    ITR(i, 1, n+1) {
      Long a = ( (Long)ncr[n][i] * fact[n-i] ) % MOD;
      a = (a*a) % MOD;
      a = (a * (n-i+1)) % MOD;
      ans += ( (a * fact_inv[i][e]) % MOD );
      ans %= MOD;
    }
    cout << ans << endl;
  }

  return 0;
}