#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<map>
#include<vector>
#include<list>
#include<set>
#include<queue>
#include<numeric>
#include<sstream>
#include<string>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;

//#define inf 1001001010010010100ll
#define pb		push_back
#define mp 		make_pair
#define EPS		1e-9
#define ll long long
#define vi vector<int>
#define pii pair<int,int>
#define fi first
#define se second
#define inf 1000000000
#define mod 1009419529
#define N 100010
#define M 30002
void read(int &x)
{
	char c;
	while(1) {
		c = getchar();
		if(c >= '0' && c <= '9') break;
	}
	x = c - '0';
	while(1) {
		c = getchar();
		if(c >= '0' && c <= '9') x = 10 * x + (c - '0');
		else break;
	}
}
int gcd(int a,int b)
{
 if(a<0)a=-a;
 if(b<0)b=-b;
 if(a<b)swap(a,b);
 while(b)
 {
  	int r=b;
  	b=a%b;a=r;
 }
 return a;
}
struct tree
{
 int lt,rt,diff,lx,rx,flag;
}a[N*4];
struct edge{int v,next;}g[N];
int head[N],f[N],fa[N],w[N],size[N],son[N],dep[N],top[N],val[N],cnt,m;
void init(int p,int l,int r)
{
 a[p].lt=l,a[p].rt=r;
 if(l==r)
 {
  a[p].diff=a[p].flag=0;
  a[p].lx=a[p].rx=val[l];
  return;
 }
 int mid=(l+r)>>1;
 init(2*p,l,mid);init(2*p+1,mid+1,r);
 int d=gcd(a[2*p].diff,a[2*p+1].diff);
 d=gcd(d,abs(a[2*p].rx-a[2*p+1].lx));
 a[p].diff=d;
 a[p].lx=a[2*p].lx;a[p].rx=a[2*p+1].rx;
}
void down(int p)
{
 int f=a[p].flag;
 a[2*p].flag+=f;
 a[2*p+1].flag+=f;
 a[2*p].lx+=f;a[2*p+1].rx+=f;
 a[2*p].rx+=f;a[2*p+1].lx+=f;
 a[p].flag=0;
}
void update(int l,int r,int p,int v)
{
 if(l==a[p].lt&&r==a[p].rt)
 {
  a[p].flag+=v;
  a[p].lx+=v;a[p].rx+=v;return;
 }
 if(a[p].flag)down(p);
 if(r<=a[2*p].rt)update(l,r,2*p,v);
 else if(l>a[2*p].rt)update(l,r,2*p+1,v);
 else
 {
  update(l,a[2*p].rt,2*p,v);
  update(a[2*p+1].lt,r,2*p+1,v);
 }
 int d=gcd(a[2*p].diff,a[2*p+1].diff);
 d=gcd(d,abs(a[2*p].rx-a[2*p+1].lx));
 a[p].diff=d;
 a[p].lx=a[2*p].lx;a[p].rx=a[2*p+1].rx;
}
int query(int l,int r,int p)
{
 if(l==a[p].lt&&r==a[p].rt)
 return gcd(a[p].lx,a[p].diff);
 if(a[p].flag)down(p);
 if(r<=a[2*p].rt)return query(l,r,2*p);
 else if(l>a[2*p].rt)return query(l,r,2*p+1);
 else
 {
  return gcd(query(l,a[2*p].rt,2*p),query(a[2*p+1].lt,r,2*p+1));
 }
}
void add(int u,int v)
{
 g[cnt].v=v;g[cnt].next=head[u];head[u]=cnt++;
}
void dfs(int u)
{
 size[u]=1;son[u]=0;
 for(int i=head[u];i!=-1;i=g[i].next)
 {
  int v=g[i].v;
  if(v==fa[u])continue;
  fa[v]=u;dep[v]=dep[u]+1;
  dfs(v);
  if(size[v]>size[son[u]])son[u]=v;
  size[u]+=size[v];
 }
}
void dfs(int u,int tp)
{
 w[u]=++m;
 top[u]=tp;
 val[m]=f[u];
 if(son[u])dfs(son[u],tp);
 for(int i=head[u];i!=-1;i=g[i].next)
 {
  int v=g[i].v;
  if(v==fa[u]||v==son[u])continue;
  dfs(v,v);
 }
}
int find(int x,int y)
{
 int fx=top[x],fy=top[y];
 int ans=0;
 while(fx!=fy)
 {
  if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
  ans=gcd(ans,query(w[fx],w[x],1));
  x=fa[fx];fx=top[x];
 }
 if(dep[x]>dep[y])swap(x,y);
 return gcd(ans,query(w[x],w[y],1));
}
void find(int x,int y,int z)
{
 int fx=top[x],fy=top[y];
 while(fx!=fy)
 {
  if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
  update(w[fx],w[x],1,z);
  x=fa[fx];fx=top[x];
 }
 if(dep[x]>dep[y])swap(x,y);
 update(w[x],w[y],1,z);
}
int main()
{
	//freopen("in.txt","r",stdin);
	int T,i,j,k,n,p,q;
	//scanf("%d",&T);
	//while(T--)
	scanf("%d",&n);
	{
	 int root=rand()%n+1;
	 memset(head,-1,sizeof(head));
	 cnt=0;
	 for(i=1;i<n;i++)
	 {
	  	read(p),read(q);
	  	p++,q++;
	  	add(p,q);add(q,p);
	 }
	 for(i=1;i<=n;i++)read(f[i]);
	 fa[root]=dep[root]=son[0]=0;m=0;
	 dfs(root);
	 dfs(root,root);
	 init(1,1,m);
	 read(n);
	 char s[20];
	 while(n--)
	 {
	  scanf("%s",s);
	  if(s[0]=='C')
	  {
	   read(i);read(j);read(k);
	   i++,j++;
	   find(i,j,k);
	  }
	  else
	  {
	  	read(i);read(j);i++,j++;
	  	printf("%d\n",find(i,j));
	  }
	 }
	}
	return 0;
}
