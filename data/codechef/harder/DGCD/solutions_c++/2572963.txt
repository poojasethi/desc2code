#include <cstdio>
#include <iostream>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cctype>
 #define ill long long
#define s(n)     scanf("%d",&n)
#define sc(n)    scanf("%c",&n)
#define sl(n)    scanf("%lld",&n)
#define sf(n)    scanf("%lf",&n)
#define ss(n)    scanf("%s",n)
#define INF      0x3f3f3f3f
#define EPS      1e-9
#define bitcount __builtin_popcount

#define forall(i,a,b) for(int i=a; i<b; i++)
#define foreach(v, c) for( typeof( (c).begin()) v = (c).begin();   v != (c).end();  ++v)
#define all(a) a.begin(), a.end()
#define in(a,b) ( (b).find(a) != (b).end())
#define pb  push_back
#define fill(a,v) memset(a, v, sizeof a)
#define sz(a) ((int)(a.size()))
#define mp  make_pair
#define maX(a,b) ( (a) > (b) ? (a) : (b))
#define miN(a,b) ( (a) < (b) ? (a) : (b))
#define checkbit(n,b)  ( (n >> b) & 1)
#define DREP(a) sort(all(a));  a.erase(unique(all(a)),a.end())
#define INDEX(arr,ind) (lower_bound(all(arr),ind)-arr.begin())
#define pii pair<int, int>
#define x first
#define y second
#define MAX 50100
#define rep while
using namespace std;

int costs[MAX];
vector<int> g[MAX]; 
int parent[MAX];
int subsize[MAX];
int which[MAX];
int head[MAX];
int depth[MAX];
int wer[MAX];
int chain;

struct state {
    int first, last;
    int carry;
    int gcd;
    state(){
        last =gcd = first = carry = 0;
    }
};
int GCD(int a,int b){
  int r;
  if(a<0) a=-a;
  if(b<0) b=-b;
  while(a){r=b; b=a; a=r%a;}
  return b;
}
void push(const state &a, const state &b, state &c) {
    c.first = a.first;
    c.last = b.last;
    c.gcd = GCD(a.gcd, GCD(b.first - a.last, b.gcd));
}

 
class segment {
    vector<state> tree;
    vector<int> arr;
    int s;

public:
    segment() {
        s = 0;
    }
    int size() {
        return s;
    }
    void add(int first) {
        s++;
        arr.pb(first);
    }
    void build() {
        tree.resize((s<<2));
        init(0, 0, s-1);
        arr.clear();
    }
    void init(int idx, int b, int e) {
        if(e <b) return;
        if(b == e) {

            tree[idx].last = tree[idx].first= arr[b];

            return;
        }
        init((idx <<1)+1, b, (b+e)/2);
        init((idx <<1)+2, (b+e)/2+1, e);

        push(tree[(idx<<1)+1], tree[(idx<<1)+2], tree[idx]);

    }

    void update(int idx, int b, int e, int i, int j, int val) {

        if(j < b || i > e) return;

        if(b >= i && e <= j) {
            tree[idx].first += val;
            tree[idx].last += val;
            tree[idx].carry += val;
            return;
        }
        int total = tree[idx].carry;
        if(total) {
            tree[idx].carry = 0; 
            tree[(idx<<1)+1].first += total;
            tree[(idx<<1)+1].last  += total;
            tree[(idx<<1)+1].carry += total;

            tree[(idx<<1)+2].first += total;
            tree[(idx<<1)+2].last += total;
            tree[(idx<<1)+2].carry += total;
        }

        update((idx <<1)+1 , b, (b+e)/2, i,  j, val);
        update((idx <<1)+2 , ((b+e)/2)+1, e, i,  j, val);

        push(tree[(idx<<1)+1], tree[(idx<<1)+2], tree[idx]);
    }
    int query(int idx, int b, int e, int i, int j) {
        if(b >j || i > e) return 0;
        if(b >= i && e <=j) {
            
            return GCD(tree[idx].first,tree[idx].gcd);
        }

        int total = tree[idx].carry;
        if(total) {
            tree[idx].carry = 0; 
            tree[(idx<<1)+1].first += total;
            tree[(idx<<1)+1].last  += total;
            tree[(idx<<1)+1].carry += total;

            tree[(idx<<1)+2].first += total;
            tree[(idx<<1)+2].last += total;
            tree[(idx<<1)+2].carry += total;
        }

        int p1 = query((idx<<1)+1, b, (b+e)/2, i, j);
        int p2 = query((idx<<1)+2, (b+e)/2+1, e, i, j);

        return GCD(p1, p2);
    }
};
vector<segment> hl;

int dfs(int u, int p) {
    parent[u] = p;
    subsize[u] = 1;
    forall(i, 0, sz(g[u])) {
        int v = g[u][i];
        if(v != p) {
            depth[v] = depth[u] +1;
            subsize[u] += dfs(v, u);
        }   
    }
    return subsize[u];
}
void hld(int u, int p) {
    if(head[chain] == -1) {
        
        head[chain] = u;
        
    }
    wer[u]  = hl[chain].size();
    hl[chain].add(costs[u]);
    which[u] = chain;
        
    int ma = -1, id = -1;
    forall(i, 0, sz(g[u])){
        int v = g[u][i];
        if(v == p) continue;
        if(subsize[v] >ma) {
            ma = subsize[v];
            id = i;
        }
    }
    if(id < 0) return ;
    else {
        hld(g[u][id], u);
    }
    forall(i, 0, sz(g[u])){
        int v = g[u][i];
        if(v == p || i == id) continue;
        chain++;
        hld(v, u);
    }

}
int lca(int a, int b) {
    while (which[a] != which[b] ) {
        
        if (depth[head[which[a]]] < depth[head[which[b]]])
            b = parent[head[which[b]]];
        else
            a = parent[head[which[a]]];
    }
    if (depth[a] < depth[b])
        return a;
    return b;
}
int query(int a, int b) {
    
    if(a == b)
        return hl[which[b]].query(0, 0, hl[which[b]].size()-1, wer[b], wer[b]);

    int mx = 0;
    while(which[a] != which[b]) {
        
        int chb = which[b];
        int pos = wer[b];
        mx = GCD(hl[chb].query(0, 0, hl[chb].size()-1, 0, wer[b]), mx);
        b = parent[head[chb]];
        
    }
    

    mx= GCD (hl[which[b]].query(0, 0, hl[which[b]].size()-1, wer[b], wer[b]),  mx);
    if(b == a)
        return mx;

    int ch = which[b];
    int posa = wer[a];
    int posb = wer[b]-1;    
    
    mx = GCD(hl[ch].query(0, 0 ,hl[ch].size()-1, posa, posb), mx);
    
    return mx;
}
void update(int a, int b, int val) {
    
    
    while(which[a] != which[b]) {
        int ch = which[b];
        int pos = wer[b];
        hl[ch].update(0, 0, hl[ch].size()-1, 0, pos, val);
        b = parent[head[ch]];
    }

    
    hl[which[b]].update(0, 0, hl[which[b]].size()-1, wer[b], wer[b], val);

    if(b == a)
        return ;
    int ch = which[a];
    int posa = wer[a];
    int posb = wer[b]-1;
    
    hl[ch].update(0, 0 ,hl[ch].size()-1, posa, posb, val);
    
    return ;
}


int main() {
    int t, n, a, b, c;


    t=1;
    char str[100];
    forall(tt, 0, t) {
        hl.clear();
        chain = 0;
        s(n);
        forall(i, 0, n+5) {
            g[i].clear();
        }
        forall(i, 1, n) {
            s(a);   s(b);
            
            g[a].pb(b);
            g[b].pb(a);
            
        }

        forall(i, 0, n) {
            s(costs[i]);
        }

        hl.resize(n+1);
        fill(head, -1);
        
        depth[0] = 1;
        dfs(0, 0);
        hld(0, -1);

        forall(i, 0, chain+1) {
            hl[i].build();
        }

        int q;
        s(q);
        char str[10];
        while(q--) {
            
            
            ss(str);
            
            if(str[0] == 'F') {
                s(a);   s(b);
                if(a == b) {
                    printf("%d\n", hl[which[b]].query(0, 0, hl[which[b]].size()-1, wer[b], wer[b]));
                    continue;
                }
                int l = lca(a, b);
                
                printf("%d\n", GCD(query(l, a),query(l, b)) );
            } else {
                s(a);   s(b); s(c);
                int l = lca(a, b);
                update(l, b, c);
                update(l, a, c);
                update(l, l, -c);
            } 
        }
    }
    return 0;
}
