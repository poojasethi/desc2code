#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<cstring>
#include<stack>
using namespace std;

typedef long long LL;
typedef vector<vector<int> > Mat;
const int INF=1<<29;


LL gcd(LL a, LL b) { return b?gcd(b, a%b):a; }

struct SegTree {
    int n, m;
    vector<LL>left, right, diff, lazy;
    SegTree(int n) :n(n) {
	m=1;
	for (;m<n;) m*=2;
	left=right=diff=lazy=vector<LL>(m*2);
    }
    void add(int x, int y, LL v) { add(x, y, 1, 0, m, v); }
    void add(int x, int y, int k, int l, int r, LL v) {
	if (x<=l && r<=y) {
	    left[k]+=v;
	    right[k]+=v;
	    lazy[k]+=v;
	} else if (x<r && l<y) {
	    add(x, y, k*2, l, (l+r)/2, v);
	    add(x, y, k*2+1, (l+r)/2, r, v);
	    diff[k]=gcd(abs(right[k*2]-left[k*2+1]), gcd(diff[k*2], diff[k*2+1]));
	    left[k]=left[k*2]+lazy[k];
	    right[k]=right[k*2+1]+lazy[k];
	}
    }
    LL query(int x, int y) { return query(x, y, 1, 0, m, 0); }
    LL query(int x, int y, int k, int l, int r, LL v) {
	if (r<=x || y<=l) return 0;
	if (x<=l && r<=y) return gcd(diff[k], left[k]+v);
	v += lazy[k];
	return gcd(query(x, y, k*2, l, (l+r)/2, v),
		   query(x, y, k*2+1, (l+r)/2, r, v));
    }
};


struct HeavyLightDecomposition {
    static const int EMPTY=-1, LIGHT=0, HEAVY=1;
    int N;
    vector<int>parent, sz, depth, color, skip, file, rank;
    Mat group;

    HeavyLightDecomposition(){}
    HeavyLightDecomposition(const Mat&G) { // G:tree
	N=G.size();
	parent=sz=depth=color=skip=vector<int>(N);
	init(G);
	paint(G);
	link(G);
	build(G);
    }
    void init(const Mat&G) {
	stack<int>kk, pp, st;
	kk.push(0); pp.push(-1);
	while (!kk.empty()) {
	    int k=kk.top(), p=pp.top(); kk.pop(); pp.pop();
	    st.push(k);
	    parent[k]=p;
	    if (p>=0) depth[k]=depth[p]+1;
	    for (int i=0; i<int(G[k].size()); i++) {
		if (G[k][i]==p) continue;
		kk.push(G[k][i]); pp.push(k);
	    }
	}
	while (!st.empty()) {
	    int k=st.top(); st.pop();
	    sz[k]++;
	    for (int i=0; i<int(G[k].size()); i++) sz[k]+=sz[G[k][i]];
	}
    }
    void paint(const Mat&G) {
	color[0]=EMPTY;
	for (int k=1; k<N; k++) {
	    int p=parent[k];
	    if (sz[p]<=2*sz[k]) color[k]=HEAVY;
	    else color[k]=LIGHT;
	}
    }
    void link(const Mat&G) {
	stack<int>st; st.push(0);
	for (;!st.empty();) {
	    int k=st.top(); st.pop();
	    if (color[k]==HEAVY) skip[k]=skip[parent[k]];
	    else skip[k]=k;
	    for (int i=0; i<int(G[k].size()); i++) {
		if (G[k][i]!=parent[k]) st.push(G[k][i]);
	    }
	}
    }
    void build(const Mat&G) {
	file=rank=vector<int>(N);
	stack<int>st; st.push(0);
	for (;!st.empty();) {
	    int k=st.top(); st.pop();
	    if (color[k]==HEAVY) {
		file[k]=file[parent[k]];
		rank[k]=rank[parent[k]]+1;
		group[file[k]].push_back(k);
	    } else {
		file[k]=group.size();
		rank[k]=0;
		group.push_back(vector<int>(1, k));
	    }
	    for (int i=0; i<int(G[k].size()); i++) {
		if (G[k][i]!=parent[k]) st.push(G[k][i]);
	    }
	}
    }
    int LCA(int u, int v) {
// 	while (depth[u]<depth[v]) v=parent[v];
// 	while (depth[u]>depth[v]) u=parent[u];
// 	while (u!=v) { v=parent[v]; u=parent[u]; }
// 	return u;

	if (file[u]==file[v]) return rank[u]<rank[v]?u:v;
	int last=0, uu=u, vv=v;
	while (u!=v) {
	    if (depth[u]>depth[v]) swap(u, v), swap(uu, vv);
	    vv=v;
	    if (color[v]==LIGHT) {
		last=0;
		v=parent[v];
	    } else {
		last=v;
		v=skip[v];
	    }
	}

	//if (last==0) return u;
	if (file[vv]==file[uu]) return depth[vv]<depth[uu]? vv:uu;
	return u;
	//return last?last:u;
	//return depth[u]>depth[v]?v:u;
    }
    int length(int u, int v) {
	int r=0;
	while (file[u]!=file[v]) {
	    if (depth[u]>depth[v]) swap(u, v);
	    if (color[v]==LIGHT) v=parent[v], r++;
	    else r+=rank[v], v=skip[v];
	}
	if (depth[u]>depth[v]) swap(u, v);
	r += depth[v] - depth[u];
	return r;
    }

};


// Segment Tree (RMQ)
struct HLDSegTree {
    HeavyLightDecomposition hld;
    vector<SegTree> data;
    HLDSegTree(const HeavyLightDecomposition&hld):hld(hld) {
	int m=hld.group.size();
	for (int i=0; i<m; i++) {
	    data.push_back(SegTree(hld.group[i].size()));
	}
    }
    void add(int x, int y, LL v) {
	int z=hld.LCA(x, y);
	while (hld.file[x]!=hld.file[z]) {
	    data[hld.file[x]].add(0, hld.rank[x]+1, v);
	    x=hld.parent[hld.skip[x]];
	}
	while (hld.file[y]!=hld.file[z]) {
	    data[hld.file[y]].add(0, hld.rank[y]+1, v);
	    y=hld.parent[hld.skip[y]];
	}
	if (hld.depth[y]<hld.depth[x]) swap(x, y);
	data[hld.file[x]].add(hld.rank[x], hld.rank[y]+1, v);
    }

    LL query(int x, int y) {
	int z=hld.LCA(x, y);
	LL ret=0;
	while (hld.file[x]!=hld.file[z]) {
	    ret=gcd(ret, data[hld.file[x]].query(0, hld.rank[x]+1));
	    x=hld.parent[hld.skip[x]];
	}
	while (hld.file[y]!=hld.file[z]) {
	    ret=gcd(ret, data[hld.file[y]].query(0, hld.rank[y]+1));
	    y=hld.parent[hld.skip[y]];
	}
	if (hld.rank[y]<hld.rank[x]) swap(x, y);
	ret=gcd(ret, data[hld.file[x]].query(hld.rank[x], hld.rank[y]+1));
	return ret;
    }
};

int main() {
    int N, Q;
    scanf("%d", &N);
    Mat G(N);
    for (int i=1; i<N; i++) {
	int a, b;
	scanf("%d%d", &a, &b);
	G[a].push_back(b);
	G[b].push_back(a);
    }

    HLDSegTree hldseg = HLDSegTree(HeavyLightDecomposition(G));
    for (int i=0; i<N; i++) {
	int a; scanf("%d", &a);
	hldseg.add(i, i, a);
    }

    scanf("%d", &Q);
    for (;Q--;) {
	char s[16]; scanf("%s", s);
	if (s[0]=='F') {
	    int a, b;
	    scanf("%d%d", &a, &b);
	    LL x=hldseg.query(a ,b);
	    printf("%d\n", int(x));
	    //cout<<hldseg.query(a, b)<<endl;
	    //cout<<hldseg.hld.LCA(a, b)+1<<endl;
	} else {
	    int a, b, v;
	    scanf("%d%d%d", &a, &b, &v);
	    hldseg.add(a, b, v);
	}
    }
	
    return 0;
}
