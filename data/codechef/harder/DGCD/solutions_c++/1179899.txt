#include <string>
#include <vector>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <fstream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cassert>
#include <stack>
#include <queue>
#include <ctime>
#include <vector>
#include <map>
#include <set>
#include <utility>

using namespace std;

#define FORALL(i,a,b) for (ll i = (a); i <= (b); i++)
#define FOR(i,n) for (ll i=0;i<n;i++)
#define FORB(i,a,b) for (ll i = (a); i >= (b); i--)
#define FORIN(it,type,b) for(type::iterator it = (b).begin(); it != (b).end(); it++)
#define pb push_back
#define mp make_pair
typedef int ll;
typedef long double ld;

#define in cin
#define out cout
#define dout if(true) out

#define MAXN 50005
#define NODES 4
#define MAXNODE NODES*MAXN
#define MAXM MAXN

//for each node i
vector<ll> E[MAXN];
ll V[MAXN];
ll depth[MAXN];
ll parent[MAXN];
ll P[MAXN];
ll ord[MAXN];
ll weight[MAXN];

//for each important path
vector<ll> T[MAXM];	//gcd
vector<ll> S[MAXM];	//sum
ll sz[MAXM];
ll H[MAXM];

ll gcd(ll a, ll b)
{
	if (a<0) return gcd(-a,b);
	if (b<0) return gcd(a,-b);
	if (b==0) return a;
	return gcd(b,a%b);
}

//add a value v to every leaf-node from low to high on the k'th segment tree
void update_tree(ll k, ll low, ll high, ll v, ll a, ll b, ll i)
{
	assert(low==high);	//at least for this problem, you should only update one node at a time
	if (high<a || low>b) return;
	S[k][i] += v;
	if (a==b){
		T[k][i] = S[k][i];
	}else{
		ll m = (a+b)/2;
		update_tree(k,low,high,v,a,m,2*i+1);
		update_tree(k,low,high,v,m+1,b,2*i+2);
		T[k][i] = gcd(T[k][2*i+1],T[k][2*i+2]);
	}
}

//get the gcd of a range in the k'th segment tree
ll query_tree(ll k, ll low, ll high, ll a, ll b, ll i)
{
	assert(low<=high&&a<=b);
	if (high<a || low >b) return 0;
	if (low<=a&&b<=high) return T[k][i];
	ll m = (a+b)/2;
	ll x = query_tree(k,low,high,a,m,2*i+1);
	ll y = query_tree(k,low,high,m+1,b,2*i+2);
	return gcd(x,y);
}

//get the sum of a range
ll sum_tree(ll k, ll low, ll high, ll a, ll b, ll i)
{
	assert(low<=high&&a<=b);
	if (high<a || low >b) return 0;
	if (low<=a&&b<=high) return S[k][i];
	ll m = (a+b)/2;
	ll x = sum_tree(k,low,high,a,m,2*i+1);
	ll y = sum_tree(k,low,high,m+1,b,2*i+2);
	return x+y;
}

ll numPaths = 0;

void dfs(ll i)
{
	if (i==0) depth[i] = 0;
	else depth[i] = depth[parent[i]]+1;

	weight[i] = 1;
	ll numE = E[i].size();
	FOR(x,numE){
		ll j = E[i][x];
		if (j==parent[i]) continue;
		parent[j] = i;
		dfs(j);
		weight[i] += weight[j];
	}
	
	FOR(x,numE){
		ll j = E[i][x];
		if (j==parent[i]) continue;
		if (weight[j] >= (weight[i]+1)/2){	//heavy edge
			P[i] = P[j];
			ord[i] = ord[j]+1;
		}
	}
	
	//no heavy edges
	if (P[i] == 0){
		numPaths++;
		P[i] = numPaths;
		ord[i] = 0;
	}
}

ll lcamemo[MAXN][20];
ll lg[MAXN];

void make_lca(ll N)
{
	FOR(i,N) lcamemo[i][0] = parent[i];
	FORALL(k,1,19){
		FOR(i,N){
			ll pkm1 = lcamemo[i][k-1];
			if (pkm1 >= 0) lcamemo[i][k] = lcamemo[pkm1][k-1];
			else lcamemo[i][k] = pkm1;
		}
	}
	
	lg[0] = 0;
	lg[1] = 0;
	lg[2] = 1;
	for(ll i = 2;i<MAXN;i*=2) lg[i] = lg[i/2]+1;
	FORALL(i,1,MAXN-1) lg[i] = max(lg[i],lg[i-1]);
}

ll lca(ll a, ll b)
{
	if (depth[a] < depth[b]) swap(a,b);
	
	while(depth[a] > depth[b]){
		ll dist = depth[a]-depth[b];
		a = lcamemo[a][lg[dist]];
	}
	assert(depth[a] == depth[b]);
	while (a != b){
		ll p = 1;
		while(lcamemo[a][p] != lcamemo[b][p]) p++;
		p--;
		a = lcamemo[a][p];
		b = lcamemo[b][p];
	}
	
	return a;
}

void update(ll a, ll b, ll d)
{
	//update b by d
	//update the child of a on its important path (if existant) by -d
	ll t = a;
	while (t>=0 && depth[t] >= depth[b]){
		ll k = P[t];
		ll s = (depth[b]<depth[H[k]])?H[k]:b;
		update_tree(k,ord[s],ord[s],d,0,sz[k]-1,0);
		if (ord[t] != 0) update_tree(k,ord[t]-1,ord[t]-1,-d,0,sz[k]-1,0);
		t = parent[s];
	}
	//if (ord[a] != 0) update_tree(P[a],ord[a]-1, ord[a]-1,-d,0,sz[P[a]]-1,0);
}

ll query(ll a, ll b){
	ll ans = 0;
	while(a >= 0 && depth[a] >= depth[b]){
		ll k = P[a];
		ll s = (depth[b]<depth[H[k]])?H[k]:b;
		ll v1 = 0;
		if (ord[s] > ord[a]) v1 = query_tree(k,ord[a],ord[s]-1,0,sz[k]-1,0);
		ll v2 = sum_tree(k,ord[s],sz[k]-1,0,sz[k]-1,0);
		
		//cout << a << " " << b << " " << s << " " << v1 << " " << v2 << " " << k << " " << ord[a] << " " << ord[s] << " " << sz[k] << endl;
		ll newq = gcd(v1,v2);
		ans = gcd(ans,newq);
		a = parent[s];
	}
	
	return ans;
}

int main()
{
	ll N;
	//in >> N;
	scanf("%d\n",&N);
	ll a,b;
	FOR(i,N-1) scanf("%d %d\n",&a,&b), E[a].pb(b), E[b].pb(a);
	FOR(i,N) scanf("%d\n",&V[i]);
	
	memset(parent,-1,sizeof(parent));
	memset(H,-1,sizeof(H));
	dfs(0);
	make_lca(N);
	
	FOR(i,N){
		ll k = P[i];
		sz[k]++;
		if (H[k] == -1 || depth[i] < depth[H[k]]) H[k] = i;
	}
	
	FORALL(k,1,numPaths){
		T[k].resize(sz[k]*NODES,0);
		S[k].resize(sz[k]*NODES,0);
	}
	
	FOR(i,N){
		ll k = P[i];
		ll val = V[i]-((i==H[k])?0:V[parent[i]]);
		update_tree(k,ord[i],ord[i],val,0,sz[k]-1,0);
	}
	
	/*
	FOR(i,N) cout << depth[i] << " "; cout << endl;
	FOR(i,N) cout << parent[i] << " "; cout << endl;
	FOR(i,N) cout << P[i] << " "; cout << endl;
	FOR(i,N) cout << ord[i] << " "; cout << endl;
	FOR(i,N) cout << weight[i] << " "; cout << endl;
	
	cout << endl;
	FORALL(m,1,numPaths) cout << sz[m] << " "; cout << endl;
	FORALL(m,1,numPaths) cout << H[m] << " "; cout << endl;*/
	
	ll Q;
	in >> Q;
	
	FOR(qq,Q){
		char a[2];
		ll b,c,d;
		scanf("%s %d %d",a,&b,&c);
		//cout << a << " " << b << " " << c << endl;
		if (a[0]=='C'){
			//in >> d;
			scanf("%d",&d);
			if (d==0) continue;
			ll x = lca(b,c);
			update(b,x,d);
			update(c,x,d);
			update(x,x,-d);
			//cout << x << endl;
			//FOR(i,N) cout << sum_tree(P[i],ord[i],sz[P[i]]-1,0,sz[P[i]]-1,0) << " "; cout << endl;
		}else{
			ll x = lca(b,c);
			printf("%d\n",gcd(query(b,x),query(c,x)));
		}
	}
}
