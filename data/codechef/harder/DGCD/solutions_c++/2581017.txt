#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <cmath>
#include <algorithm>
#include <functional>
#include <numeric>
#include <bitset>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <map>
#include <cassert>

#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define S1(x) scanf("%lld",&x)
#define epsilon 0.000000000000001
#define pie acos (-1.0)
#define MAXNODES 100001
#define sz size()
#define MAX 50009
using namespace std;

int a[MAX];
int b[MAX];
int parent[MAX];
int d[MAX];
int level[MAX];
vector < vector <int> > s;

int chainhead[MAX];
int which[MAX];
int where[MAX];
int ssize[MAX];
int chain;

struct state
{
    int first;
    int last;
    int carry;
    int g;
    state ()
    {
        first = last = carry = g = 0;
    }
};
typedef struct state state;


class seg
{
    private:

    public:
        vector <int> s;
        vector <struct state> a;
        int ss;

        int gcd (int a, int b)
        {
            a = abs (a);
            b = abs (b);
            if (a == 0) {
                return b;
            }
            if (b == 0) {
                return a;
            }
            return gcd (b, a%b);
        }

        void add (int index)
        {
            s.pb (index);
            ss++;
        }

        seg ()
        {
            ss = 0;
        }

        void init (int node, int x, int y)
        {
            if (x > y) {
                return;
            }
            if (x == y) {
                a[node].first = a[node].last = s[x];
                a[node].g = a[node].carry = 0;
                return;
            }
            int mid = (x+y)/2;
            init (2*node, x, mid);
            init (2*node + 1, mid+1, y);

            a[node].first = a[2*node].first;
            a[node].last = a[2*node + 1].last;
            a[node].g = gcd (a[2*node].g, gcd (a[2*node + 1].g, a[2*node +1].first-a[2*node].last));
        }

        void build ()
        {
            init (1, 0, ss-1);
        }

        void space ()
        {
            a.resize (4*ss + 10);
        }

        void update (int node, int x, int y, int sx, int sy, int value)
        {
            if (sx > y || sy < x) {
                return;
            }

            if (sx <= x && sy >= y) {
                a[node].first = a[node].first + value;
                a[node].last = a[node].last + value;
                a[node].carry = a[node].carry + value;
                return;
            }

            if (a[node].carry != 0) {
                a[2*node].first = a[2*node].first + a[node].carry;
                a[2*node].last = a[2*node].last + a[node].carry;
                a[2*node].carry = a[2*node].carry + a[node].carry;

                a[2*node +1].first = a[2*node +1].first + a[node].carry;
                a[2*node +1].last = a[2*node +1].last + a[node].carry;
                a[2*node +1].carry = a[2*node +1].carry + a[node].carry;
                a[node].carry  = 0;
            }

            int mid = (x+y)/2;
            update (2*node, x, mid, sx, sy, value);
            update (2*node + 1, mid+1, y, sx, sy, value);

            a[node].first = a[2*node].first;
            a[node].last = a[2*node + 1].last;
            a[node].g = gcd (a[2*node].g, gcd (a[2*node + 1].g, a[2*node +1].first-a[2*node].last));
        }

        int query (int node, int x, int y, int sx, int sy)
        {
            if (sy < x || sx > y) {
                return 0;
            }
            if (sx <= x && sy >= y) {
                return gcd (a[node].first, a[node].g);
            }

            if (a[node].carry != 0) {
                a[2*node].first = a[2*node].first + a[node].carry;
                a[2*node].last = a[2*node].last + a[node].carry;
                a[2*node].carry = a[2*node].carry + a[node].carry;

                a[2*node +1].first = a[2*node +1].first + a[node].carry;
                a[2*node +1].last = a[2*node +1].last + a[node].carry;
                a[2*node +1].carry = a[2*node +1].carry + a[node].carry;
                a[node].carry  = 0;
            }

            int xx,yy,mid=(x+y)/2;

            xx = query (node*2, x, mid, sx, sy);
            yy = query (2*node + 1, mid+1, y, sx, sy);
            return gcd (xx, yy);
        }

};
vector <seg> segment;


void dfs (int index, int p)
{
    d[index] = 1;
    parent[index] = p;
    int i;

    F (i, 0, s[index].size()) {
        int x = s[index][i];
        if (x == p) {
            continue;
        }
        level[x] = level[index] + 1;
        dfs (x, index);
        d[index] = d[index] + d[x];
    }
}

void hld (int index, int p)
{
    if (chainhead[chain] == -1) {
        chainhead[chain] = index;
    }
    which[index] = chain;
    where[index] = ssize[chain];
    ssize[chain]++;
    segment[chain].add (a[index]);

    int i,j=-1,xx=-1;

    F (i, 0, s[index].size()) {
        int x = s[index][i];
        if (x == p) {
            continue;
        }
        if (d[x] > xx) {
            xx = d[x];
            j = x;
        }
    }

    if (j == -1) {
        return;
    }
    hld (j, index);

    F (i, 0, s[index].size()) {
        int x = s[index][i];
        if (x == p || x == j) {
            continue;
        }
        chain++;
        hld (x, index);
    }
}

int lca(int a, int b)
{
    while (which[a] != which[b]) {
        int a1 = chainhead[which[a]];
        int b1 = chainhead[which[b]];
        if (level[a1] < level[b1]) {
            b = parent[b1];
        } else {
            a = parent[a1];
        }
    }
    if (a == -1 || b == -1) {
        return 0;
    }
    if (level[a] < level[b]) {
        return a;
    }
    return b;
}

void update (int x, int y, int value)
{
    if (level[x] > level[y]) {
        swap (x, y);
    }

    while (which[x] != which[y]) {
        int cc = which[y];
        segment[cc].update (1, 0, ssize[cc]-1, 0, where[y], value);
        cc = chainhead[cc];
        cc = parent[cc];
        y = cc;
    }
    int cc = which[x];
    segment[cc].update (1, 0, ssize[cc]-1, where[x], where[y], value);
}

int gcd (int a, int b)
{
    a = abs (a);
    b = abs (b);
    if (a == 0) {
        return b;
    }
    if (b == 0) {
        return a;
    }
    return gcd (b, a%b);
}

int query (int x, int y)
{
    if (level[x] > level[y]) {
        swap (x, y);
    }

    int sum = 0;
    while (which[x] != which[y]) {
        int cc = which[y];
        sum = gcd (sum, segment[cc].query (1, 0, ssize[cc]-1, 0, where[y]));
        cc = chainhead[cc];
        cc = parent[cc];
        y = cc;
    }

    int cc = which[x];
    //cout << cc << " " << ssize[cc]-1 << " " << where[x] << " " << where[y] << endl;
    sum = gcd (sum, segment[cc].query (1, 0, ssize[cc]-1, where[x], where[y]));
    return sum;
}



int main()
{
    //freopen ("input.txt", "r", stdin);

    while (1) {
        int i,n;
        S (n);

        s.clear();      s.resize (n);
        F (i, 0, n-1) {
            int x,y;
            S (x);      S (y);
            s[x].pb (y);
            s[y].pb (x);
        }

        F (i, 0, n) {
            S (a[i]);
        }

        level[0] = 0;
        dfs (0, -1);

        segment.clear();
        segment.resize (n+3);
        chain = 0;
        memset (chainhead, -1, sizeof(chainhead));
        memset (ssize, 0, sizeof(ssize));
        hld (0, -1);


        F (i, 0, chain+4) {
            segment[i].space();
            segment[i].build();
        }



        int qq;
        S (qq);

        while (qq--) {
            char str[25];
            scanf ("%s", str);
            if (str[0] == 'C') {
                int a,b,c;
                S (a);  S (b);  S (c);
                int l = lca (a, b);
                update (a, l, c);
                update (b, l, c);
                update (l, l, -c);
                continue;
            }
            int aa,bb;
            S (aa);     S (bb);
            int l = lca (aa, bb);
            printf ("%d\n", gcd (query (aa, l), query (bb, l)));
        }
        break;
     }
    return 0;
}
