    #include <algorithm>
    #include <iostream>
    #include <cassert>
    #include <cstring>
    #include <cstdio>
    #include <vector>
    #include <cmath>
    #include <ctime>
    #include <map>
    #include <set>
     
    using namespace std;
     
    #define SIZE(A) ((int)A.size())
    #define LENGTH(A) ((int)A.length())
    #define MP(A,B) make_pair(A,B)
    #define PB(A) push_back(A)
    #define MAXN 30
    #define MAXV MAXN*MAXN
    #define inf (1<<26)
     
    int fx[] = {0, 0, 1, -1}, fy[] = {1, -1, 0, 0};
     
    int n, m, k, V, best, curCost, col, col2;
    int p[MAXN][MAXN], c[MAXN][MAXN], ver[MAXN][MAXN];
     
    vector <int> q;
     
    int w[MAXV], used[MAXV], calced[MAXV], cost[MAXV], type[MAXV];
    vector <int> ed[MAXV];
     
    void giveans()
    {
    if (best == inf)
    puts("-1");
    else
    printf("%d\n", best);
    exit(0);
    }
     
    void doDijekstra();
    void graphbuild()
    {
    for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
    {
    ver[i][j] = i*m + j;
    cost[ver[i][j]] = c[i][j];
    type[ver[i][j]] = p[i][j];
    }
    for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
    {
    if (p[i][j] == -1) continue;
     
    for (int idx = 0; idx < 4; idx++)
    {
    int xx = i+fx[idx], yy = j+fy[idx];
    if (xx >= 0 && yy >= 0 && xx < n && yy < m && p[xx][yy] != -1)
    {
    ed[ver[i][j]].PB(ver[xx][yy]);
    }
    }
    }
    }
     
    //DIJEKSTRA
    int d[MAXV], val[MAXV];
    int dist[MAXV][MAXV];
    set < pair <int, int> > Heap;
     
    int list_size;
    int List[10];
     
    inline int doCalc(int k, int u)
    {
    list_size = 0;
    for (int i = 1; i <= V; i++)
    val[i] = inf;
    for (int i = 0; i < V; i++)
    if (type[i]!=-1 && used[type[i]]!=col)
    val[type[i]] = min(val[type[i]], min(d[i], dist[u][i]));
    for (int i = 0; i < V; i++)
    {
    List[list_size] = val[i];
     
    for (int j = list_size; j > 0 && List[j]<List[j-1]; j--)
    swap(List[j], List[j-1]);
     
    if (list_size < k) list_size++;
    }
     
    int ret = 0;
    for (int i = 0; i < list_size; i++)
    ret += List[i];
    return ret;
    }
     
    inline void doGreedy(int needed)
    {
    for (; needed > 0;)
    {
    int curBest = inf, who = -1;
     
    col2++;
    for (int i = 0; i < SIZE(q); i++)
    {
    for (int j = 0, curAdd; j < SIZE(ed[q[i]]); j++)
    if (w[ed[q[i]][j]]!=col && calced[ed[q[i]][j]]!=col2)
    {
    calced[ed[q[i]][j]] = col2;
     
    curAdd = doCalc(needed, ed[q[i]][j])+cost[ed[q[i]][j]];
     
    if (curAdd < curBest)
    {
    curBest = curAdd;
     
    who = ed[q[i]][j];
    }
    }
    }
     
    if (curBest == inf) return;
     
    w[who] = col;
    q.PB(who);
    curCost += cost[who];
    if (used[type[who]]!=col)
    {
    used[type[who]] = col;
    needed--;
    }
     
    if (curCost >= best) return;
    }
     
    if (curCost >= best) return;
     
    best = curCost;
    }
     
    int main()
    {
    scanf("%d%d%d", &n, &m, &k); V = n*m;
    for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
    scanf("%d", &p[i][j]);
    for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
    scanf("%d", &c[i][j]);
     
    graphbuild();
     
    for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
    if (p[i][j]!=-1)
    {
    w[ver[i][j]] = ++col;
    doDijekstra();
    for (int k = 0; k < V; k++)
    dist[ver[i][j]][k] = d[k];
    }
     
    best = inf;
     
    for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
    if (p[i][j]!=-1)
    {
    used[0] = ++col;
    q.PB(ver[i][j]);
    w[ver[i][j]] = col;
    used[p[i][j]] = col;
    curCost = c[i][j];
     
    for (int idy = 0; idy < V; idy++)
    d[idy] = dist[ver[i][j]][idy];
     
    doGreedy(k - (p[i][j]!=0));
     
    curCost = 0;
    q.clear();
    }
    giveans();
     
    return 0;
    }
     
    inline void doDijekstra()
    {
    for (int idx = 0; idx < V; idx++)
    if (w[idx] == col)
    d[idx] = 0;
    else
    d[idx] = inf;
     
    for (int i = 0; i < V; i++)
    Heap.insert(MP(d[i], i));
     
    for (int i = 0; i <= V; i++)
    val[i] = inf;
     
    for (int u; SIZE(Heap);)
    {
    u = Heap.begin()->second;
    Heap.erase(Heap.begin());
     
    if (d[u] == inf) break;
     
    for (int i = 0; i < SIZE(ed[u]); i++)
    if (cost[ed[u][i]] + d[u] < d[ed[u][i]])
    {
    Heap.erase(Heap.find(MP(d[ed[u][i]], ed[u][i])));
    d[ed[u][i]] = cost[ed[u][i]]+d[u];
    Heap.insert(MP(d[ed[u][i]], ed[u][i]));
    }
    }
    }  