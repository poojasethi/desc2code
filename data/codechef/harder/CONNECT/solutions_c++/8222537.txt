#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

#define n	20
#define m	230
#define INF	(1<<29)
#define For(i,a,b)	for(int i=a;i<=b;i++)

const	int	cx[]={-1,0,0,1},cy[]={0,-1,1,0};
int		N,M,T,K,D,Ans,G[m],st[m],col[m],val[m],now[m],Trans[m],F[1<<7][m],Q[m*100];
bool	V[m];

struct	Lin{int v,next;}E[m<<2];
void	Link(int u,int v){
		E[++D]=(Lin){v,st[u]};	st[u]=D;
}

namespace	Pre{
		int 	A[n][n],B[n][n],D[n][n];

		void	Main(){
			scanf("%d%d%d",&N,&M,&K);
			For(i,1,N)	For(j,1,M)	{
				scanf("%d",&A[i][j]);
				if	(A[i][j]!=-1)	D[i][j]=++T,col[T]=A[i][j];
				if	(A[i][j]>0)	G[++*G]=A[i][j];
			}
			For(i,1,N)	For(j,1,M)	{
				scanf("%d",&B[i][j]);
				if	(D[i][j])	val[D[i][j]]=B[i][j];
			}
			For(i,1,N)	For(j,1,M)	if	(D[i][j])
			For(k,0,3)	{
				int x=i+cx[k],y=j+cy[k];
				if	(x&&x<=N&&y&&y<=M&&D[x][y])	Link(D[i][j],D[x][y]);
			}
			sort(G+1,G+*G+1);	*G=unique(G+1,G+*G+1)-G-1;
		}
};

void	Work(){
		For(i,1,N*M)Trans[i]=0;
		For(i,1,K)	{
			int x=rand()%(*G)+1;
			for (;Trans[G[x]];)	x=rand()%(*G)+1;
			Trans[G[x]]=i;
		}
		For(i,1,*G)	if	(!Trans[G[i]])	Trans[G[i]]=rand()%K+1;

		For(i,1,T)	now[i]=Trans[col[i]];	int U=(1<<K)-1;
		For(i,0,U)	For(j,1,T)	F[i][j]=INF;
		For(i,1,T)	F[now[i]?(1<<(now[i]-1)):0][i]=val[i];

		For(d,0,U)	{
			for (int t=(d-1)&d;;t=(t-1)&d){
				if	(t<=(d^t))	break;
				For(i,1,T)	F[d][i]=min(F[d][i],F[t][i]+F[d^t][i]-val[i]);
			}

			*Q=0;
			For(i,1,T)	V[i]=0;
			For(i,1,T)	if	(F[d][i]<Ans)	Q[++*Q]=i,V[i]=1;

			for (int l=0,r=*Q;l<r;){
				int u=Q[++l];	V[u]=0;
				for (int i=st[u],v;i;i=E[i].next)
				if	(F[d][u]+val[v=E[i].v]<F[d][v]){
					F[d][v]=F[d][u]+val[v];
					if	(!V[v]&&F[d][v]<Ans){
						V[Q[++r]=v]=1;
						if	(F[d][Q[r]]<F[d][Q[l+1]])	swap(Q[l+1],Q[r]);
					}
				}
			}
		}
		For(i,1,T)	Ans=min(Ans,F[U][i]);
}

int		main(){
		Pre::Main();
		if	(*G<K)	return	puts("-1"),0;
		srand(time(0));	Ans=INF;
		for (int Tim=300;Tim--;)	Work();
		printf("%d\n",Ans==INF?-1:Ans);
}