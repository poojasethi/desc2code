#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <vector>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <deque>
#include <cassert>

using namespace std;

#ifdef WIN32
	#define I64 "%I64d"
#else
	#define I64 "%lld"
#endif

typedef long long ll;

#define f first
#define s second
#define mp make_pair
#define pb push_back
#define all(s) s.begin(), s.end()
#define sz(s) (int(s.size()))
#define fname "a"
#define ms(a,x) memset(a, x, sizeof(a))
#define forit(it,s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); ++it)
#define MAXV 100001
#define MOD 1000000007
#define MAXN 100001
#define MAXM 505
#define block 400

inline int add(int a, int b)
{
	a += b;
	if (a >= MOD)
		a -= MOD;
	return a;
}

inline int sub(int a, int b)
{
	a -= b;
	if (a < 0)
		a += MOD;
	return a;
}

inline int mult(int a, int b)
{
	return (1LL * a * b) % MOD;
}

int n, m;
int a[MAXN];
int b[MAXM];
int lp[MAXV];
int pr[MAXV], npr;
int num[MAXV];
vector <int> g[MAXV];
int p[MAXV];
int ansv[MAXM * MAXM];
vector < pair< pair<int, int>, int> > q;
int curans;
int w[10001];

inline bool comp(pair< pair<int, int>, int> a, pair< pair<int, int>, int> b)
{
	int ind1 = a.f.f / block;
	int ind2 = b.f.f / block;
	if (ind1 != ind2) return ind1 < ind2;
	return a.f.s > b.f.s;
}

inline void process(int val)
{
	for (int j = 0; j < sz(g[val]); ++j)
	{
		int ind = g[val][j];
		curans = sub(curans, mult(w[ind], w[ind]));
		w[ind]++;
		curans = add(curans, mult(w[ind], w[ind]));
	}
}

inline void process2(int val)
{
	for (int j = 0; j < sz(g[val]); ++j)
	{
		int ind = g[val][j];
		curans = sub(curans, mult(w[ind], w[ind]));
		w[ind]--;
		curans = add(curans, mult(w[ind], w[ind]));
	}
}

inline void solve()
{
	for (int i = 2; i < MAXV; ++i)
	{
		if (lp[i] == 0)
		{
			lp[i] = i;
			num[i] = npr;
			pr[npr++] = i;
		}
		for (int j = 0; j < npr && pr[j] <= lp[i] && i * pr[j] < MAXV; ++j)
			lp[i * pr[j]] = pr[j];
	}

	for (int i = 2; i < MAXV; ++i)
	{
		int t = i;
		while(t % lp[i] == 0)
			t /= lp[i];
		g[i].pb(num[lp[i]]);
		p[i] = t;
		for (int j = 0; j < sz(g[t]); ++j)
			g[i].pb(g[t][j]);
	}

	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; ++i)
		scanf("%d", &a[i]);
	for (int i = 0; i < m; ++i)
		scanf("%d", &b[i]);

	for (int i = 0; i < m; ++i)
		for (int j = 0; j < m; ++j)
		{
			int L = (b[i] + b[j]) % n;
			int R = (b[i] - b[j] + n) % n;
			if (L > R) swap(L, R);
			q.pb(mp(mp(L, R), i * m + j));
		}
	
	sort(all(q), comp);
	curans = 0;
	int cl = 0, cr = 0;
	for (int i = 0; i < sz(q); ++i)
	{
		int L = q[i].f.f;
		int R = q[i].f.s;
		while(cl < L)
			process2(a[cl++]);
		while(cl > L)
			process(a[--cl]);
		while(cr <= R)
			process(a[cr++]);
		while(cr - 1 > R)
			process2(a[--cr]);
		int ind = q[i].s;
		ansv[ind] = curans;
	}

	int ans = 0;
	for (int i = 0; i < m; ++i)
	{
		int res = 1;
		for (int j = 0; j < m; ++j)
			res = mult(res, ansv[i * m + j]);
		ans = add(ans, res);
	}
	printf("%d\n", ans);
}

int main()
{
	#ifdef LOCAL
	freopen(fname".in", "r", stdin);
	freopen(fname".out", "w", stdout);
	#endif

	solve();

	return 0;
}
