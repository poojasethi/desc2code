#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
using namespace std;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar_unlocked();
    }
    return x;
}
const int N = 100001;
const int M = 501;
const int MM = 250001;
const int mod = 1e9 + 7;
const int SQN = 330;
#define query pair < int , pair < int , pair < int , int > > >
#define block first
#define R second.first
#define L second.second.first
#define idx second.second.second //because struct is too maintream
#define mq(b,r,l,i) mp(b,mp(r,mp(l,i)))
#define lt list<int>::iterator
query Q[MM];
int n , m ;
int arr[N];
int b[N];
list<int> prime[N];
int cnt[N]={0};
int answer[M];
int main(){
    n = scan() , m = scan() ;
    for ( int i = 1 ; i <= n ; ++i ){
        arr[i] = scan();
        if(prime[arr[i]].empty()){
            int temp = arr[i];
            for( int j = 2 ; j*j <= temp ; ++j ){
                bool x = 0;
                while( temp%j == 0 ){
                    temp/=j;
                    x = 1;
                }
                if(x){
                    prime[arr[i]].pb(j);
                }
            }
            if(temp>1){
                prime[arr[i]].pb(temp);
            }
        }
    }
    for ( int i = 1 ; i <= m ; ++i ){
        answer[i] = 1;
        b[i] = scan();
    }
    int cur = 0;
    for ( int i = 1 ; i <= m ; ++i ){
        for ( int j = 1 ; j <= m ; ++j ){
            int l = b[i] + b[j];
            if(l>=n){
                l -= n;
            }
            int r = b[i] - b[j];
            if(r<0){
                r += n;
            }
            if(l>r){
                l^=r^=l^=r;
            }
            int blok = l/SQN;
            Q[++cur] = mq(blok,r+1,l+1,i);
        }
    }
    sort(Q+1 , Q + cur + 1);
    int curl  = 1 , curr = 0 , ans = 0;
    for ( int i = 1 ; i <= cur ; ++i ){
        int l = Q[i].L;
        int r = Q[i].R;
        int index = Q[i].idx;
        while(l < curl){
            curl--;
            for( lt it = prime[arr[curl]].begin() ; it != prime[arr[curl]].end() ; ++it ){
                int p = *it;
                ++ans;
                ans += cnt[p] + cnt[p];
                if(ans>=mod){
                    ans-=mod;
                }
                ++cnt[p];
            }
        }
        while(r > curr){
            ++curr;
            for( lt it = prime[arr[curr]].begin() ; it != prime[arr[curr]].end() ; ++it ){
                int p = *it;
                ++ans;
                ans += cnt[p] + cnt[p];
                if(ans>=mod){
                    ans-=mod;
                }
                ++cnt[p];
            }
        }
        while(l > curl){
            for( lt it = prime[arr[curl]].begin() ; it != prime[arr[curl]].end() ; ++it ){
                int p = *it;
                ++ans;
                ans -= cnt[p] + cnt[p];
                if(ans<0){
                    ans+=mod;
                }
                --cnt[p];
            }
            ++curl;
        }
        while(r<curr){
            for( lt it = prime[arr[curr]].begin() ; it != prime[arr[curr]].end() ; ++it ){
                int p = *it;
                ++ans;
                ans -= cnt[p] + cnt[p];
                if(ans<0){
                    ans+=mod;
                }
                --cnt[p];
            }
            --curr;
        }
        answer[index] = (1LL*answer[index]*ans)%mod;
    }
    int final = 0;
    for(int i = 1 ; i <= m ; ++i ){
        final += answer[i];
        if(final >= mod){
            final -= mod;
        }
    }
    printf("%d\n",final);
} 