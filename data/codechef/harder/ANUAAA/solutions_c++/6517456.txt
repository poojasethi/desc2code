#include <cstdio>
#include <cassert>
#include <algorithm>
#include <vector>
using namespace std;
 
#define N (NLIMIT + 100)
#define M (MLIMIT + 100)
#define A (ALIMIT + 100)
#define BLOCK 300
 
#define NLIMIT 100000
#define MLIMIT 500
#define ALIMIT 100000
#define MOD 1000000007
 
int a[N], b[M], ans[M*M], c[A], square[A];
vector <int> primeFactors[A];
 
long long answer = 1;
 
int expmod(int a, int b) {
	long long x = 1, y = a;
	while(b) {
		if(b&1) x = (x * y) % MOD;
		y = (y * y) % MOD;
		b >>= 1;
	}
	return (int) x;
}
 
void updatePrime(int prime, int v) {
	answer -= square[c[prime]];
	c[prime] += v;
	answer += square[c[prime]];
}
 
void add(int i) {
	int x = a[i];
	for(int j=0; j<primeFactors[x].size(); j++) {
		updatePrime(primeFactors[x][j], 1);
	}
}
 
void remove(int i) {
	int x = a[i];
	for(int j=0; j<primeFactors[x].size(); j++) {
		updatePrime(primeFactors[x][j], -1);
	}
}
 
struct node {
	int l, r, i;
}q[M*M];
 
bool cmp(node a, node b) {
	return ( (a.l/BLOCK < b.l/BLOCK) || ((a.l/BLOCK == b.l/BLOCK) && a.r < b.r) );
}
 
int main() {
	square[0] = 0;
	for(int i=1; i<A; i++) {
		c[i] = 0;
		square[i] = ((long long)i * i) % MOD;
		int x = i;
		for(int j=2; j*j <= x; j++)
			if(x % j == 0) {
				primeFactors[i].push_back(j);
				while(x % j == 0) {
					x /= j;
				}
			}
		if(x > 1) {
			primeFactors[i].push_back(x);
		}
	}
 
	int n, m;
	scanf("%d%d", &n, &m);
 
	assert(1 <= n && n <= NLIMIT);
	assert(1 <= m && m <= MLIMIT);
 
	for(int i=0; i<n; i++) {
		scanf("%d", &a[i]);
		assert(1 <= a[i] && a[i] <= ALIMIT);
	}
 
	for(int i=0; i<m; i++) {
		scanf("%d", &b[i]);
		assert(0 <= b[i] && b[i] < n);
	}
 
	for(int i=0; i<m; i++)
		for(int j=0; j<m; j++)
		{
			int tt = i*m+j;
			q[tt].l = (b[i] + b[j]) % n;
			q[tt].r = (b[i] - b[j] + n) % n;
			if(q[tt].l > q[tt].r) {
				swap(q[tt].l, q[tt].r);
			}
			q[tt].i = tt;
		}
 
	int pm = m;
	m *= m;
	sort(q, q+m, cmp);
 
	int curL = 0, curR = 0;
	answer = 0;
 
	for(int qq=0; qq<m; qq++) {
		int l = q[qq].l;
		int r = q[qq].r;
		while(curL > l) {
			add(--curL);
		}
		while(curR <= r) {
			add(curR++);
		}
		while(curL < l) {
			remove(curL++);
		}
		while(curR > r+1) {
			remove(--curR);
		}
		answer %= MOD;
		if(answer < 0) {
			answer += MOD;
		} 
		ans[q[qq].i] = (int)answer;
	}
 
	answer = 0;
	for(int i=0; i<pm; i++) {
		long long cur = 1;
		for(int j=0; j<pm; j++) {
			(cur *= ans[i*pm+j]) %= MOD;
		}
		answer += cur;
		if(answer >= MOD) {
			answer -= MOD;
		}
	}
	printf("%lld\n", answer);
}
