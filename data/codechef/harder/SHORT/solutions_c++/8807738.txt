#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
const db pi=acos(-1.0);
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
const int inf=1061109567;
//const ll inf=1000000000000000000ll;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
#define eps 1e-6
#define x1 x192837465
#define x2 x123456789
#define y1 y192837465
#define y2 y123456789


class Bignum{
	private:
		int base;vector<int>a;
		inline void clear(){base=10000;a.resize(1);a[0]=0;}
		inline void set(int n){
			if(clear(),n){			
				int t;a.clear();
				while(n)a.push_back(n-(t=n/base)*base),n=t;
			}
		}
		inline void set(ll n){
			if(clear(),n){			
				ll t;a.clear();
				while(n)a.push_back(n-(t=n/base)*base),n=t;
			}
		}
		inline void clearzero(){
			int l=a.size();
			while(l>1 && a[l-1]==0)l--;
			a.resize(l);
		}
	public:
		Bignum(){clear();}
		Bignum(int n){set(n);}
		Bignum(ll n){set(n);}
		Bignum& operator=(int a){set(a);return *this;}
		Bignum& operator=(ll a){set(a);return *this;}
		inline int size()const{return a.size();}
		inline void output()const{
			for (int i=a.size()-1;i>=0;i--)
				if(i==a.size()-1)printf("%d",a[i]);
				else printf("%04d",a[i]);
		}
		inline int input(){
			char c;vector<int> s;a.clear();
			while(((c=getchar())<'0' || c>'9') && c!=EOF);if(c==EOF)return 0;s.push_back(c-'0');
			while((c=getchar())>='0'&&c<='9')s.push_back(c-'0');          
            int l=s.size();
			for (int i=l-1;i-3>=0;i-=4)a.push_back(s[i]+s[i-1]*10+s[i-2]*100+s[i-3]*1000);
            if(l&3){
                       int tmp=0;
                       for (int i=0;i<(l&3);i++)tmp=tmp*10+s[i];
                       a.push_back(tmp);
            }
            return 1;
		}
		int comp(const Bignum&x)const{
			if(a.size()<x.a.size())return 1;
			if(a.size()>x.a.size())return -1;
			for (int i=a.size()-1;i>=0;i--)
				if(a[i]<x.a[i])return 1;
				else if(a[i]>x.a[i])return -1;
			return 0;
		}
		int operator<(const Bignum&x)const{return comp(x)==1;}
		int operator>(const Bignum&x)const{return comp(x)==-1;}
		int operator<=(const Bignum&x)const{return comp(x)!=-1;}
		int operator>=(const Bignum&x)const{return comp(x)!=1;}
		int operator!=(const Bignum&x)const{return comp(x)!=0;}
		int operator==(const Bignum&x)const{return comp(x)==0;}	
		Bignum& operator+=(const Bignum&x){
			int l=max(a.size(),x.a.size())+1;
			a.resize(l);
			for (int i=0;i<x.a.size();i++)a[i]+=x.a[i];
			for (int i=0;i<l;i++)if(a[i]>=base)a[i]-=base,a[i+1]++;
			clearzero();return *this;
		}
		Bignum& operator-=(const Bignum&x){
			for (int i=0;i<x.a.size();i++)a[i]-=x.a[i];
			for (int i=0;i<a.size();i++)if(a[i]<0)a[i]+=base,a[i+1]--;
			clearzero();return *this;
		}
		Bignum operator+(const Bignum&x)const{Bignum y=*this;y+=x;return y;}		
		Bignum operator-(const Bignum&x)const{Bignum y=*this;y-=x;return y;}		
		Bignum operator*(const Bignum&x)const{
			int l=a.size()+x.a.size();
			Bignum z;z.a.resize(l);			
			for (int i=0;i<x.a.size();i++)
				for (int j=0;j<a.size();j++){
					z.a[i+j]+=x.a[i]*a[j];
					if(z.a[i+j]>=2000000000){ 
						z.a[i+j]-=2000000000;
						z.a[i+j+1]+=200000;
					}
				}
			for (int i=0;i<l;i++)if(z.a[i]>=base){
				int t=z.a[i]/base;
				z.a[i]-=t*base;
				z.a[i+1]+=t;
			}
			z.clearzero();return z;
		}
		Bignum operator*(const int x)const{
			if(x>=base)return *this * Bignum(x);
			int l=a.size()+2;
			Bignum z;z.a.resize(l);
			for (int i=0;i<a.size();i++)z.a[i]=a[i]*x;
			for (int i=0;i<l;i++)z.a[i+1]+=z.a[i]/base,z.a[i]%=base;
			z.clearzero();return z;
		}
		Bignum& operator*=(const int x){return *this=*this*x;}
		Bignum& operator*=(const Bignum&x){return *this=*this*x;}		
		Bignum operator/(const Bignum &x)const{
			Bignum b=*this,q,tmp;q.a.resize(b.size());	
			for(int i=b.size()-x.size();b>=x;i--,b.clearzero()){
				tmp.a.assign(b.a.begin()+i,b.a.end());				
				int l=0,r=base-1,m;
				while(l<=r){
					m=(l+r)>>1;
					if(x*m<=tmp)l=m+1;
					else r=m-1;
				}
				for (int j=0;j<tmp.size();j++)b.a[j+i]=0;
				q.a[i]=r;tmp-=x*r;
				for (int j=0;j<tmp.size();j++)b.a[j+i]=tmp.a[j];
			}
			q.clearzero();return q;
		}
		Bignum operator%(const Bignum &x)const{return *this - *this/x*x;}
		Bignum& operator/=(const Bignum &x){return *this=*this/x;}
		Bignum& operator%=(const Bignum &x){return *this=*this%x;}
		Bignum operator^(int x)const{
			Bignum ans=1,p=*this;
			while(x){
				if(x&1)ans*=p;
				p*=p;
				x>>=1;
			}
			return ans;
		}
		Bignum& operator^=(const int x){return *this=*this^x;}
};
Bignum max(const Bignum &a,const Bignum &b){return a>b?a:b;}
Bignum min(const Bignum &a,const Bignum &b){return a<b?a:b;}
Bignum gcd(Bignum a,Bignum b){Bignum t;while(b!=0)t=b,b=a%b,a=t;return a;}
void output(const Bignum &a){a.output();}
void outputln(const Bignum &a){a.output();putchar('\n');}
int n;
ll k;


int vis[500005]={0};
int pr[500005],tot=0;
int lp[555555],deg[555555],go[555555];
void sieve(int n){
	lp[1]=1111111111;
	for (int i=2;i<=n;i++){
		if(!vis[i]){
			pr[tot++]=i;
			lp[i]=i,deg[i]=1,go[i]=1;
		}
		for (int j=0;j<tot && pr[j]*i<=n;j++){
			vis[i*pr[j]]=1;
			if(i%pr[j]==0){
				lp[i*pr[j]]=pr[j];
				deg[i*pr[j]]=deg[i]+1;
				go[i*pr[j]]=go[i];
				break;
			}else {
				lp[i*pr[j]]=pr[j];
				deg[i*pr[j]]=1;
				go[i*pr[j]]=i;
			}
		}
	}
}
int pp[20],pdeg[20],ptot;
void init(int a,int b){
	ptot=0;
	while(a>1 || b>1){
		if(lp[a]==lp[b]){
			pp[++ptot]=lp[a];
			pdeg[ptot]=deg[a]+deg[b];
			a=go[a];b=go[b];
		}else{
			if(lp[a]>lp[b])swap(a,b);
			pp[++ptot]=lp[a];
			pdeg[ptot]=deg[a];
			a=go[a];
		}
	}
}
int a;
ll ans;
void dfs(int i,ll cur){
	if(i==ptot+1){
		ll p=(cur+a)/(a-n);
		if(p*(a-n)!=cur+a)return;
		ll b=1ll*n*(a-1)/cur+n;
		if(b>=k || b<a)return;
		ans++;
	}else{
		for (int j=0;j<=pdeg[i];j++){
			dfs(i+1,cur);
			cur*=pp[i];
		}
	}
}
void work(){
	ans=0;
	gn(n);gn(k);
	if(n==0){
		Bignum t=k;
		t-=1;
		t=t*t;
		outputln(t);
		return;
	}
	int up=min(k-1,ll(3.42*n));
	for (a=n+1;a<=up;a++){
		if(a>=n+3000)break;
		init(n,a-1);
		dfs(1,1ll);
	}
	for(;a<=up;a++){
		ll up=(1ll*a*a-n)/(a-n)/(a-n);
		for (int p=2;p<=up;p++){
			ll d=1ll*p*(a-n)-a;
			if(d<=0)continue;
			ll c=1ll*n*(a-1)/d;
			if(1ll*d*c!=1ll*n*(a-1))continue;
			ll b=n+c;
			if(b>=k || b<a)continue;
			ans++;
		}
	}
	ans*=2;
	for (a=n+1;a<=up;a++)if((1ll*a*a-n)%(1ll*(a-n)*(a-n))==0)ans--;
	cout<<ans<<endl;
}
int main()
{
	sieve(345000);
	int te;gn(te);
	while(te--){
		work();
	}
	return 0;
}
