#include<cstdio>
#include<cstring>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

const int M=1000000007;

void kmp_build(const char *pttn,int *fail){
	int n=strlen(pttn);
	fail[0]=-1;
	for(int i=1,j=-1;i<=n;i++){
		while(j>=0 && pttn[j]!=pttn[i-1]) j=fail[j];
		fail[i]=++j;
	}
}

int kmp_search(const char *s,const char *pttn,const int *fail){
	int m=strlen(s),n=strlen(pttn),j=0;
	int cnt=0;
	rep(i,m){
		while(j>=0 && s[i]!=pttn[j]) j=fail[j];
		j++;
		if(j==n) return n;
	}
	return j;
}

int decode(char c){
	if('a'<=c && c<='z') return c-'a';
	return c-'A'+26;
}

void decode(int n,const char *s,char *t){
	for(int i=0;s[i];i++) rep(j,5) {
		t[5*i+j]=(decode(s[i])>>4-j)&1?'1':'0';
	}
	t[n]='\0';
}

int main(){
	int T; scanf("%d",&T);
	while(T--){
		int m,n;
		static char in1[200001],in2[200001]; scanf("%d%s%d%s",&m,in1,&n,in2);

		static char s[1000001],t[1000001];
		decode(m,in1,s);
		decode(n,in2,t);

		static int fail[1000001];
		kmp_build(s,fail);

		int pos=kmp_search(t,s,fail);
		if(pos==m){ puts("0"); continue; }

		// rematch : 今 s[0..i-1] までマッチしていて, s[i] でマッチが失敗した.
		//           次に rematch[i] からマッチを再開する. つまり, s[0..rematch[i]-1] はすでにマッチできている.
		//           failure link とは, s[i] で失敗したと言う情報を使っているかどうかが違う.
		static int rematch[1000000];
		rematch[0]=0;
		for(int i=1;i<m;i++){
			if(s[fail[i]]!=s[i]) rematch[i]=fail[i]+1;
			else                 rematch[i]=rematch[fail[i]];
		}

		static int P[1000001];
		P[0]=0;
		rep(i,m){
			P[i+1]=2*P[i]-P[rematch[i]]-2;
			P[i+1]%=M; if(P[i+1]<0) P[i+1]+=M;
		}

		int E0=-P[m]; if(E0<0) E0+=M;
		printf("%d\n",(P[pos]+E0)%M);
	}

	return 0;
}
