#ifdef _WIN32
#  define LL "%I64d"
#else
#  define LL "%Ld"
#endif

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <ctime>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <bitset>
#include <string>
#include <algorithm>
#include <complex>
#include <utility>
using namespace std;
#define null NULL
#define mp make_pair
#define pb(a) push_back(a)
#define sz(a) ((int)(a).size())
#define all(a) a.begin() , a.end()
#define fi first
#define se second
#define relaxMin(a , b) (a) = min((a),(b))
#define relaxMax(a , b) (a) = max((a),(b))
#define SQR(a) ((a)*(a))
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef long long ll;
#define MOD 1000000007
string tar , base;
char buf[200010];
void read(string& to){
  int how; to.clear();
  scanf("%d %s" , &how , &buf);
  int L = strlen(buf);
  for(int i=0;i<L;++i){
   int C = (buf[i]>='a' && buf[i]<='z') ? buf[i]-'a' : 26 + buf[i]-'A';
   for(int j=0;j<5;++j){
    if(sz(to) >= how)break;
    if(C&(1<<(4-j)))to += '1';
    else to += '0';
                       }
                      }
}
vi preffix_function(string w){
  vi ret(sz(w) , 0);
  for(int i=1;i<sz(w);++i){
   int len = ret[i-1];
   while(len > 0 && w[len] != w[i])len = ret[len-1];
   ret[i] = len + ((w[len] == w[i])?1:0);
                          }
  return ret;
}
int aut[1000010][2];
void set_aut(string fr){
  fr += '$';
  vi pf = preffix_function(fr);
  for(int i=0;i<sz(fr);++i)
   for(int j=0;j<2;++j){
    if(i==0 || fr[i] == j+'0')aut[i][j] = i + (fr[i] == j+'0');
    else aut[i][j] = aut[ pf[i-1] ][j];
                       }
}
void out(vi w){
  for(int i=0;i<sz(w);++i)
   cout<<w[i]<<' ';
  cout<<endl;
}
int koef[1000010] , sc[1000010];
ll POW(ll w , ll step){
  ll ret = 1;
  for(;step>0;step>>=1 , w=(w*w)%MOD)
   if(step&1)ret = (ret*w)%MOD;
  return ret;
}
ll OEM(ll w){
  return POW(w , MOD-2);
}
void doit(){
  read(tar);
  read(base);
  int N = sz(tar) , M = sz(base);
  set_aut(tar);
  int CL = 0;
  for(int i=0;i<M;++i){
   CL = aut[CL][base[i]-'0'];
   if(CL == N){
    puts("0");
    return;
              }
                      }
  koef[0] = 1; sc[0] = 0;
  int tmp;
  for(int i=1;i<=N;++i){
   tmp  = aut[i-1][ (tar[i-1]-'0')^1 ];
   if(tmp != i){
    koef[i] = 2*koef[i-1];
    if(koef[i] >= MOD)koef[i] -= MOD;
    koef[i] -= koef[tmp];
    if(koef[i] < 0)koef[i] += MOD;
    sc[i] = 2*sc[i-1]; if(sc[i]>=MOD)sc[i] -= MOD;
    sc[i] -= sc[tmp]; if(sc[i] < 0)sc[i] += MOD;
    sc[i] -= 2; if(sc[i] < 0)sc[i] += MOD;
               }
   else{
    koef[i] = koef[i-1];
    sc[i] -= 1; if(sc[i] < 0)sc[i] += MOD;
       }
                       }
  ll ic = ( -sc[N] * OEM(koef[N]) )%MOD;
  if(ic<0)ic += MOD;
  ll ans = (ic * koef[ CL ] + sc[ CL ])%MOD;
  printf("%d\n" , (int)( (ans + MOD)%MOD ));
}
int main(){
  int Q; scanf("%d",&Q);
  while(Q--)doit();
  return 0;
}
