#include <iostream>
#include <stdio.h>
#include <vector>
#include <map>
#include <list>
#include <string>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <queue>
#include <stack>
using namespace std;

#define fore(i, l, r) for(int i = l; i < r; i++)
#define forn(i, n) fore(i, 0, n)
#define pb push_back
#define mp make_pair
#define x first
#define y second

typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int, int> pii;
typedef vector<pii> vpii;
typedef vector<ll> vll;

int md = 1000000007;

void failTable(int arr[], int T[], int n){
  T[0] = -1, T[1] = 0;
  int i = 2, m = 0;
  while(i < n + 1){
    if (arr[i - 1] == arr[m]) T[i++] = ++m;
    else if (m == 0) T[i++] = 0;
    else m = T[m];
  }
}

void decode(char arr[], int vrr[], int l){
  forn(i, l){
    int v = 0;
    if (arr[i] >= 'a' && arr[i] <= 'z') v = arr[i] - 'a';
    else v = arr[i] - 'A' + 26;
    forn(j, 5){
      vrr[i*5+ 4 - j] = (v & (1 << j)) >> j;
    }
  }
}

ll powr(ll n, int p){
  if (p == 0) return 1;
  else if (p == 1) return n;
  else if (p & 1){
    ll v = powr(n, p >> 1);
    v *= v;
    if (v >= md) v %= md;
    v *= n;
    if (v >= md) v %= md;
    return v;
  }
  else {
    ll v = powr(n, p >> 1);
    v *= v;
    if (v >= md) v %= md;
    return v;
  }
}

int kmpMatch(int s1[], int n1, int s2[], int T[], int n2){
  int i = 0, j = 0;
  while (i < n1){
    if (s1[i] == s2[j]){
      if (j == n2 - 1) return -1;
      i++; j++;
    }
    else if (j == 0) i++;
    else j = T[j];
  }
  return j;
}


char arr1[200005], arr2[200005]; 
int A[1000005], B[1000005], PS[2][1000005];
ll P[1000005], Q[1000005];

int main(){
  int t;
  scanf("%d", &t);
  
  while(t--){
    int n1, n2;
    scanf("%d", &n1);
    scanf("%s", arr1);
    int l1 = strlen(arr1);
    scanf("%d", &n2);
    scanf("%s", arr2);
    int l2 = strlen(arr2);

    decode(arr1, A, l1);
    decode(arr2, B, l2);
    
    // forn(i, n1) cout<<A[i]; cout<<endl;
    // forn(i, n2) cout<<B[i]; cout<<endl;

    int T[n1 + 1];
    failTable(A, T, n1);
    
    PS[A[0]][0] = 1;
    PS[!A[0]][0] = 0;
    
    fore(i, 1, n1){
      PS[A[i]][i] = i + 1;
      PS[!A[i]][i] = PS[!A[i]][T[i]];
    }

    ll E;
    P[1] = md - 2, Q[1] = 1; 
    P[0] = 0; Q[0] = 1;
    T[0] = 0;
    fore(i, 2, n1 + 1){
      int m = PS[!A[i - 1]][i - 1];
      P[i] = (P[i - 1] << 1) + md - P[m] + md -  2;
      if (P[i] >= md) P[i] %= md;
      Q[i] = (Q[i - 1] << 1) + md - Q[m];
      if (Q[i] >= md) Q[i] %= md;
    }
    
    // fore(i, 1, n1 + 1)
    //   cout<<i<<" "<<T[i]<<" "<<P[i]<<" "<<Q[i]<<endl;

    ll inv = powr(Q[n1], md - 2);
    inv *= (md - P[n1]);
    if (inv >= md) inv %= md;
    
    E = inv;
    int m = kmpMatch(B, n2, A, T, n1);
    
    // cout<<E<<" "<<m<<endl;

    if (m == -1){
      printf("0\n");
    }
    else {
      E = E * Q[m];
      if (E >= md) E %= md;
      E += P[m];
      if (E >= md) E %= md;
      printf("%lld\n", E);
    }
  }
}
