#include <cstdio>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int T, n, m, i;

const int INF = 1000000000;
struct item
{
	int d;
	int c;
};
struct box
{
	int v;
	double p;
};

box b[50];
item a[50];
int h[35][35], j, k, t;
int minDol[35][35];
int mxDi[35];
double res = 0;
double dp[33][33][33];
vector <pair <int, double> >G1[32], G2[32];
int up[50][50], c1, c2, mask;

vector <double > sum[31];


double ret;
bool cmp(box a, box b)
{
	if (a.v > b.v)
		return true;
	if (a.v < b.v)
		return false;
	return a.p > b.p;
}
bool cmp2(item a, item b)
{
	if (a.d < b.d)
		return true;
	if (a.d>  b.d)
		return false;
	return a.c < b.c;
}
int l, r,mm;
int mnful[35];
double probSum[31][31];
int main()
{
	//freopen("input.txt","r",stdin);
	cin >> T;
	while (T--)
	{



		cin >> n >> m;
		int tmp;
		
		for (i = 0; i < 30; i++)
		{
			G1[i].clear();
			G2[i].clear();
			sum[i].clear();
		}


		for (i = 0; i < n; i++)
		{
			cin >> b[i].v >> tmp;
			b[i].p = tmp / 100.;
		}
		for (i = 0; i < m; i++)
			cin >> a[i].c >> a[i].d;
		sort(b, b+ n, cmp);
		for (i = 0; i <=n; i++)
			for (j = 0; j <=m; j++)
				h[i][j] = INF;
		//sort(a, a + m, cmp2);
		h[0][0] = 0;
		
		for (k = 0; k < m; k++)
		{
			for (i = n; i >= 0; i--)
				for (j = m; j >= 0; j--)
				{
					if (h[i][j] == INF)
						continue;
					if (i + a[k].d > n)
						continue;
					if (h[i + a[k].d][j + 1] > h[i][j] + a[k].c)
						h[i + a[k].d][j + 1] = h[i][j] + a[k].c;
				}
		}
		
	for (i = 0; i<=32; i++)
		for (j = 0; j <=32; j++)
			minDol[i][j] = INF;
	for (i = n; i >=0; i--)
		for (j = m; j >=0; j--)
			for ( k = i; k>=0; k--)
				minDol[i][j] = min(minDol[i][j],h[k][j]);

	




		for (mask = 0; mask < (1 << n / 3); mask++)
		{
			int d = 0;
			double prob = 1;
			int c = 0;
			for (j = 0; j < n/3; j++)
			{
				if (mask & (1 << j))
				{
					prob *= b[j].p;
					c += b[j].v;
				}else
				{
					prob *= (1 - b[j].p);
					d ++;
				}
			}
			G1[d].push_back(make_pair(c,prob));
		}
		
		int n2 = n - n/3;
		for (mask = 0; mask < (1 << n2); mask++)
		{
			int d = 0;
			double prob = 1;
			int c = 0;
			for (j = 0; j < n2; j++)
			{
				if (mask & (1 << j))
				{
					prob *= b[j + n/3].p;
					c += b[j + n/3].v;
				}else
				{
					prob *= (1 - b[j + n/3].p);
					d ++;
				}
			}
			G2[d].push_back(make_pair(c,prob));
		}

	for (i = 0; i < 30; i++)
	{
		sort(G1[i].begin(), G1[i].end());
		sort(G2[i].begin(), G2[i].end());
	}
	for (i = 0; i < 30; i++)
	{
		double s = 0;
		for (j = 0; j < G2[i].size(); j++)
		{
			s+= G2[i][j].second;
			sum[i].push_back(s);
		}
	}







	for (i = n; i >=0; i--)
		for (j = 0; j <=m; j++)
			if (minDol[i][j] != INF)
				mxDi[i] = j;

	/*for (k = 0; k < n; k++)
	{
		for (i = 0; i <= 31; i++)
			for (j = 0; j<=31; j++)
				dp[k][i][j] = 0;
		dp[k][k][0] = 1;
		for (i = k; i < n; i++)
			for (j = 0; j < n; j++)
			{
				dp[k][i + 1][j + 1] += dp[k][i][j] * (1 - b[i].p);
				dp[k][i + 1][j] += dp[k][i][j] * b[i].p;
			}
	}
	int d;
	for (d = 0; d < n; d++)
		for (j = 0; j <= n; j++)
			for (i = 0; i<=j; i++)
				if (d + i <=n)
					up[d][j] = max(up[d][j], minDol[d + i][mxDi[d+i]]);*/

	res = 0;


	double p1, p2, prob;
	int d1, d2, d, c, ll, rr, mm, k1, k2;
	
	for (d = 0; d <=n; d++)
		for (j = 0; minDol[d][j] != INF; j++)
		{
			//probability of  gettin exactly d diamonds and money between c1 & c2;
			c1 = minDol[d][j];
			c2 = minDol[d][j + 1];
			prob = 0;
			for(d1 = 0; d1 <=d; d1++)
			{
				d2 = d - d1;
				for (i = 0; i < G1[d1].size(); i++)
				{
					c = G1[d1][i].first;
					p1 = G1[d1][i].second;
					if (c >= c2)
						continue;
					if (G2[d2].size() == 0)
						continue;
					// getProb of gettin c1 - c2 money from G2
					ll = 0;
					rr = G2[d2].size();
					while (ll != rr)
					{
						mm = (ll + rr) / 2;
						if (G2[d2][mm].first < c1 - c)
							ll = mm + 1;
						else
							rr = mm;
					}
					k1 = ll;

					if (k1 == G2[d2].size())
						continue;
					ll = 0;
					rr = G2[d2].size();

					while (ll != rr)
					{
						mm = (ll + rr) / 2;
						if (G2[d2][mm].first < c2 - c)
							ll = mm + 1;
						else
							rr = mm;
					}

					if (ll == 0)
						continue;
					k2 = ll- 1;

					prob += sum[d2][k2] * p1;
					if (k1 > 0)
						prob -= sum[d2][k1 - 1] * p1;
				}
			}
			res += prob * j;
		}
					

	printf("%.4lf\n", res);
	}
	return 0;
}