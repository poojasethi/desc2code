#include <cassert>
#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <climits>
#include <cstddef>
#include <cctype>
#include <cmath>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <iterator>
#include <numeric>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <list>
#include <string>
#include <functional>
#include <utility>
using namespace std;
typedef long long llint;
int const N = 30;
int const N1 = 18;
int n, m;
int box[N][2];
int item[N][2];
vector <int> gp[N + 1];
int best[N + 1][N + 2];
int n1, n2;
double res;
bool readin()
{
	int i;
	if (scanf("%d%d", &n, &m) == EOF)
	{
		return false;
	}
	for (i = 0; i < n; ++i)
	{
		scanf("%d%d", &box[i][0], &box[i][1]);
	}
	for (i = 0; i < m; ++i)
	{
		scanf("%d%d", &item[i][0], &item[i][1]);
	}
	return true;
}
inline int ceil(int x, int y)
{
	return x % y != 0 ? x / y + 1 : x / y;
}
void check(int s, int a[])
{
	int num = accumulate(a, a + N, 0);
	int sum = 0;
	int i, j;
	for (i = 1; i <= s; ++i)
	{
		if (int(gp[i].size()) < a[i])
		{
			return;
		}
		for (j = 0; j < a[i]; ++j)
		{
			sum += gp[i][j];
		}
	}
	best[s][num] = min(best[s][num], sum);
	for (i = 0; i < int(gp[0].size()); ++i)
	{
		sum += gp[0][i];
		best[s][num + i + 1] = min(best[s][num + i + 1], sum);
	}
}
void dfs(int s, int r, int prev, int a[])
{
	int i;
	if (r == 0)
	{
		check(s, a);
		return;
	}
	for (i = min(r, prev); i >= 1; --i)
	{
		++a[i];
		dfs(s, r - i, i, a);
		--a[i];
	}
}
void work_item()
{
	int a[N] = {0};
	int i, j;
	for (i = 0; i <= N; ++i)
	{
		gp[i].clear();
	}
	for (i = 0; i < m; ++i)
	{
		gp[item[i][1]].push_back(item[i][0]);
	}
	for (i = 0; i <= N; ++i)
	{
		sort(gp[i].begin(), gp[i].end());
	}
	for (i = 0; i <= n; ++i)
	{
		best[i][0] = 0;
		for (j = 1; j <= m; ++j)
		{
			best[i][j] = i > 0 ? best[i - 1][j] : INT_MAX;
		}
		best[i][m + 1] = INT_MAX;
		dfs(i, i, INT_MAX, a);
	}
}
void work_subset(int mask, int start, int num, int &money, int &diamond, double &probability)
{
	int i;
	money = diamond = 0;
	probability = 1.0;
	for (i = 0; i < num; ++i)
	{
		if (mask & (1 << i))
		{
			money += box[start + i][0];
			probability *= box[start + i][1] / 100.0;
		}
		else
		{
			++diamond;
			probability *= (100 - box[start + i][1]) / 100.0;
		}
	}
}
void work_box()
{
	vector <pair <int, double> > q[N1 + 1];
	vector <double> sum[N1 + 1];
	int mask;
	int money, diamond;
	double probability;
	int idx, pre;
	int i, j;
	// first half
	n1 = ceil(n * 6, 10);
	for (mask = 0; mask < (1 << n1); ++mask)
	{
		work_subset(mask, 0, n1, money, diamond, probability);
		q[diamond].push_back(make_pair <int,double>(money, probability));
	}
	for (i = 0; i <= n1; ++i)
	{
		sort(q[i].begin(), q[i].end());
		for (j = 0; j < int(q[i].size()); ++j)
		{
			sum[i].push_back((j > 0 ? sum[i][j - 1] : 0.0) + q[i][j].second);
		}
	}
	// second half
	res = 0.0;
	n2 = n - n1;
	for (mask = 0; mask < (1 << n2); ++mask)
	{
		work_subset(mask, n1, n2, money, diamond, probability);
		for (i = 0; i <= n1; ++i)
		{
			pre = 0;
			for (j = 0; j <= m; ++j)
			{
				idx = lower_bound(q[i].begin(), q[i].end(), make_pair <int, double>(best[i + diamond][j + 1] - money, -1.0)) - q[i].begin();
				res += ((idx > 0 ? sum[i][idx - 1] : 0.0) - (pre > 0 ? sum[i][pre - 1] : 0.0)) * probability * j;
				pre = idx;
			}
		}
	}
}
void solve()
{
	work_item();
	work_box();
	printf("%.4lf\n", res);
}
int main()
{
	int tc;
	scanf("%d", &tc);
	while (tc--)
	{
		readin();
		solve();
	}
	return 0;
}
