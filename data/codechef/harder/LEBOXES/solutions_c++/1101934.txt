#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <functional>
#include <set>
 
using namespace std;

#define REP(i,n)     for(i=0; i<n; i++)

int dp[33][33][33];
int V[33],D[33],C[33];
double P[33],sum[33][25000];
vector<pair<int,double> > sub[33];
int T,N,M,a,b;
double res=0;

int cmp(const pair<int, double> &a,const  pair<int, double> &b)
{
	return a.first < b.first;
}

int sol(int ind,int boxes,int dia)
{
    if(dia<0)return (1<<25);
    if(boxes==0)return 0;
    if(ind==M)return (1<<25);
    if(dp[ind][boxes][dia]!=-1)return dp[ind][boxes][dia];
    
    return dp[ind][boxes][dia]=min(sol(ind+1,boxes,dia),sol(ind+1,boxes-1,dia-D[ind])+C[ind]);     
}


int main()
{
 cin>>T;
 while(T--)
 {
           res = 0.0;
           int i,j,k;
           memset(dp,-1,sizeof dp);
           cin>>N>>M;
           REP(i,N)
           {
                   sub[i].clear();
                   cin>>V[i]>>P[i];
                   P[i]/=100.0;
           }
           REP(i,M)cin>>C[i]>>D[i];
           
           a = (N<10)?(N/2):(N/2+2);
           b = N-a;
           
           sol(0,M,30);
           REP(i,(1<<a))
           {
                      double p = 1;
                      int c = 0, d = 0;
                      REP(j,a)
                      {
                          if(i&(1<<j))
                          {
                           p*=P[j];
                           c+=V[j];            
                          }        
                          else
                          {
                           p*=(1-P[j]);
                           d++;    
                          }
                      }
                      sub[d].push_back(make_pair(c,p));
           }
           
           for(i=0;i<=a;i++)
           {
                           sort(sub[i].begin(),sub[i].end());
                           for(j=0;j<sub[i].size();j++)
                           sum[i][j]=sub[i][j].second+((j==0)?0:sum[i][j-1]);
           }
           REP(i,(1<<b))
           {         
                      double p = 1;
                      int c = 0, d = 0; 
                      REP(j,b)
                      {
                          if(i&(1<<j))
                          {
                           p*=P[a+j];
                           c+=V[a+j];            
                          }        
                          else
                          {
                           p*=(1-P[a+j]);
                           d++;    
                          }
                      }
                      for(j=d;j<=N;j++)
                      {
                          if(sub[j-d].size()==0)continue;
                         int x,y,l,r;
                          for(k=M;k>=0;k--)
                          {
                            if(k!=M)y = x-1;
                            else y=(1<<25);
                            x = sol(0,k,j)-c;    
                             if(y<0)break;
		                    if(k!=M)
		                    r = l-1;
		                    else
                            r = upper_bound(sub[j-d].begin(), sub[j-d].end(), make_pair(y,0),cmp) - sub[j-d].begin() - 1;
                            
                            l = lower_bound(sub[j-d].begin(), sub[j-d].end(), make_pair(x,0),cmp) - sub[j-d].begin();
                            if(l<=r&&l>=0){
                              if(sub[j-d][l].first>=x&&sub[j-d][r].first<=y)
                            res+=p*k*(sum[j-d][r]-((l==0)?0:sum[j-d][l-1]));}
                          }
                      }
           }
		printf("%0.4f\n", res);
           
 }   
    
    
}
