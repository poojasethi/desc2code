#include<iostream>
#include<sstream>
#include<cstdio>
#include<memory.h>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<string>
#include<map>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<assert.h>
#include<set>
#include<deque>
#include<climits>
#include<utility>

using namespace std;

#define SI ({int _x; scanf("%d",&_x); _x;})
#define SLL ({long long _x; scanf("%lld",&_x); _x;})
#define SLF ({double _x; scanf("%lld",&_x); _x;})
#define SC ({char _x; scanf("%c",&_x); _x;})
#define sscan(n) scanf("%s",n)
#define lc(i) (i<<1)
#define rc(i) ((i<<1)+1)
#define MP make_pair
#define PB push_back
#define LL long long
#define FILL(a,x) memset(a,x,sizeof a)
#define REP(i,n) for(int i=0;i<(n);++i)
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define FORD(i,a,b) for(int i=(b)-1;i>=(a);--i)
#define REPD(i,b) for(int i=(b)-1;i>=0;--i)
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)>(b)?(b):(a))
#define ABS(a) ((a)<0?-(a):(a))

typedef vector<int> VI; 
typedef pair<int,int> PI; 
#define SZ(a) int((a).size()) 
#define ALL(c) (c).begin(),(c).end() 
#define SORT(a) sort(ALL(a))
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) 
#define present(c,x) ((c).find(x) != (c).end()) 
#define dbg(x) cout<<#x<<" = "<<x<<endl
#define RAND(x) ((int)(((rand()*1.0)/RAND_MAX)*(x)))

int n,m;
int v[33];
double p[33];
int c[33], d[33];

int dp[33][33][33];

const int INF = 1123456789;
vector <pair <int,double> > with[33];
vector <double> cumm[33];

void firstHalf(int a)
{
	REP(i,a+1) with[i].clear();
	REP(i,1<<a)
	{
		double prob = 1.0;
		int diam = 0, money = 0;
		REP(j,a)
		{
			if(i&(1<<j))
			{
				money += v[j];
				prob *= p[j];
			}
			else
			{
				++diam;
				prob *= (1 - p[j]);
			}
		}
		with[diam].PB(MP(money,prob));
	}
	REP(i,a+1) sort(ALL(with[i]));
	REP(i,a+1)
	{
		int sz = SZ(with[i]);
	//	cerr<<"i = "<<i<<endl;
	//	cerr<<"sz = "<<sz<<endl;
		cumm[i].resize(sz,0);
		cumm[i][0] = with[i][0].second;
		FOR(j,1,sz) cumm[i][j] = cumm[i][j-1] + with[i][j].second;
	}
	return;
}

double findProb(int diams, int least, int most)
{
//	dbg(diams); dbg(least); dbg(most);
	int sz = SZ(with[diams]);
	int start = -1, end = -1;
	if(with[diams][0].first > most) return 0.0;
	if(with[diams][sz-1].first < least) return 0.0;

	if(with[diams][0].first >= least) start = 0;
	else
	{
		int lo = 0, hi = sz-1;
		while(lo + 1 < hi)
		{
			int mid = (lo + hi)/2;
			if(with[diams][mid].first < least) lo = mid;
			else hi = mid;
		}
		start = hi;
	}

	if(with[diams][sz-1].first <= most) end = sz-1;
	else
	{
		int lo = 0, hi = sz-1;
		while(lo+1 < hi)
		{
			int mid = (lo+hi)/2;
			if(with[diams][mid].first <= most) lo = mid;
			else hi = mid;
		}
		end = lo;
	}

//	dbg(start); dbg(end);

	double ret = cumm[diams][end];
	if(start - 1 >= 0) ret -= cumm[diams][start - 1];
	return ret;
}

double secondHalf(int a, int b)
{
	double ret = 0;
	REP(i,1<<b)
	{
		double prob = 1.0;
		int diam = 0, money = 0;
		REP(j,b)
		{
			if(i&(1<<j))
			{
				money += v[n-1-j];
				prob *= p[n-1-j];
			}
			else
			{
				++diam;
				prob *= (1 - p[n-1-j]);
			}
		}
		for(int c = m; c>0; --c)
		{
			for(int rem = 0; rem<=a; ++rem)
			{
				int total = rem + diam;
				int required = dp[c][m-1][total];
				int upper_bnd;
				if(c == m) upper_bnd = INF;
				else upper_bnd = dp[c+1][m-1][total] - 1;
				double pb = findProb(rem, required-money, upper_bnd-money) * prob;
				ret += pb*c;
			}
		}
	}
	return ret;
}

int main()
{
	int t = SI;
	while(t--)
	{
		n = SI; m = SI;
		REP(i,n) { v[i] = SI; p[i] = SI/100.0; }
		REP(i,m) { c[i] = SI; d[i] = SI; }
		REP(i,m+1) REP(j,m+1) REP(k,n+1) dp[i][j][k] = INF;
		FOR(i,d[0],n+1) dp[1][0][i] = c[0];
		REP(i,n+1) dp[0][0][i] = 0;

		FOR(i,1,m) REP(j,m+1) REP(k,n+1)
		{
			if(j == 0) { dp[j][i][k] = 0; continue; }
			int temp = dp[j][i-1][k];
			int temp2 = INF;
			if(j-1>=0 && k-d[i] >= 0) temp2 = dp[j-1][i-1][k-d[i]] + c[i];
			dp[j][i][k] = MIN(temp,temp2);
		}

	//	dbg(dp[2][1][0]); dbg(dp[2][1][1]); dbg(dp[2][1][2]);
	//	dbg(dp[1][1][0]); dbg(dp[1][1][1]); dbg(dp[1][1][2]);
	//	dbg(dp[0][1][0]); dbg(dp[0][1][1]); dbg(dp[0][1][2]);

		int a = n/2, b = n - a;
		if(n > 10)
		{
			LL mini = 1ll<<55;
			for(int t = 2; t<=n-2; ++t)
			{
				b = n-t;
				LL temp = (1ll<<t)*t + (1ll<<b)*t*t*m;
				if(mini > temp) { mini = temp; a = t; }
			}
			b = n-a;
		}
		firstHalf(a);

		/*
		REP(diamonds,n+1)
		{
			dbg(diamonds);
			int sz = SZ(with[diamonds]);
			REP(j,sz) cout<<with[diamonds][j].first<<" "<<with[diamonds][j].second<<endl;
		}
		*/
		double ans = secondHalf(a,b);
		printf("%.4lf\n",ans);
	}
	return 0;
}