#include <iostream>   
#include <sstream>   
#include <cstdio>   
#include <cstdlib>   
#include <cmath>   
#include <memory.h>   
#include <cctype>   
#include <string>   
#include <vector>   
#include <list>   
#include <queue>   
#include <deque>   
#include <stack>   
#include <map>   
#include <set>   
#include <algorithm>   
using namespace std;  
   
#define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))  
#define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))  
#define CLEAR(a) memset((a),0,sizeof(a))  
#define INF 1000000000
#define PB push_back  
#define ALL(c) (c).begin(), (c).end()  
#define pi 2*acos(0.0)  
#define SQR(a) (a)*(a)  
#define MP make_pair  
#define MAX 32
   
typedef long long Int;  
 
int n, m, a, b;
int P[MAX];
int V[MAX];
int D[MAX];
int C[MAX];
int Q[MAX][MAX][MAX];
int R[MAX][MAX];
pair<int, double> F[MAX][25000];
int Z[MAX];
int W[MAX][25000];
double S[MAX][25000];
 
bool Cmp(pair<int, double> a, pair<int, double> b)
{
	return a.first < b.first;
}
 
int main()
{
	//freopen("C:\\Users\\ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ°ÃÂÃÂ»ÃÂÃÂÃÂÃÂº\\Desktop\\Witaliy\\CodeChef Problems\\Little Elephant and Boxes\\input4.txt", "r", stdin);
	//freopen("C:\\Users\\ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ°ÃÂÃÂ»ÃÂÃÂÃÂÃÂº\\Desktop\\Witaliy\\CodeChef Problems\\Little Elephant and Boxes\\output4.txt", "w", stdout);
	
	int T;
	cin >> T;
	FOR (t,0,T)
	{
		FOR (i,0,MAX)
			Z[i] = 0;
 
		cin >> n >> m;
 
		FOR (i,0,n)
			cin >> V[i] >> P[i];
		FOR (i,0,m)
			cin >> C[i] >> D[i];
 
		FOR (i,0,MAX)
			FOR (j,0,MAX)
			{
				R[i][j] = INF;
				FOR (k,0,MAX)
					Q[i][j][k] = INF;
			}
		Q[0][0][0] = 0;
		FOR (i,0,m)
			FOR (j,0,i+1)
				FOR (k,0,n+1)
				{
					if (Q[i][j][k] >= INF)
						continue;
					Q[i][j][k+1] = min(Q[i][j][k+1], Q[i][j][k]);
					Q[i+1][j][k] = min(Q[i+1][j][k], Q[i][j][k]);
					if (k + D[i] <= n)
						Q[i+1][j+1][k+D[i]] = min(Q[i+1][j+1][k+D[i]], Q[i][j][k] + C[i]);
				}
		FOR (i,0,m+1)
			FOR (j,0,n+1)
				R[i][j] = Q[m][i][j];
 
		// R[i][j] - minimal possible number of money to buy exactly i things using no more than j diamonds.
 
		a = n/2;
		b = n-a;
 
		if (n > 15)
		{
			a += 2;
			b = n-a;
		}
 
		FOR (i,0,(1 << a))
		{
			Int c = 0, d = 0;
			double p = 1.0;
			FOR (j,0,a)
				if ((i & (1 << j)) != 0)
				{
					c += V[j];
					p = p*P[j]/100.0;
				}
				else
				{
					d++;
					p = p*(100.0-P[j])/100.0;
				}
			F[d][Z[d]] = MP(c, p);
			Z[d]++;
		}
 
		// F[d] - list of pairs (money; prob.) for number of diamonds d.
 
		FOR (i,0,a+1)
		{
			//sort(ALL(F[i]));
			sort(F[i], F[i] + Z[i], Cmp);
			FOR (j,0,Z[i])
			{
				W[i][j] = F[i][j].first;
				S[i][j] = ((j == 0 ? 0 : S[i][j-1]) + F[i][j].second);
			}
		}
 
		double res = 0.0;
 
 
		FOR (i,0,(1 << b))
		{
			Int c = 0, d = 0;
			double p = 1.0;
			FOR (j,0,b)
				if ((i & (1 << j)) != 0)
				{
					c += V[a+j];
					p = p*P[a+j]/100.0;
				}
				else
				{
					d++;
					p = p*(100.0-P[a+j])/100.0;
				}
			FOR (j,0,a+1)
			{
				Int last = 1000000000000LL;
				int iMin2 = -1;
				for (int k = m; k>=0; k--)
				{
					// having d+j diamonds and c dollars we want to buy k things.
					Int t = R[k][d+j] - c;
					// x + c >= t; x >= t-c
					Int Min = t, Max = last-1;
					if (Max < 0)
						break;
					int iMin = lower_bound(W[j], W[j] + Z[j], Min) - W[j];
					int iMax;
					if (iMin2 == -1)
						iMax = upper_bound(W[j], W[j] + Z[j], Max) - W[j] - 1;
					else
						iMax = iMin2 - 1;
					iMin2 = iMin;
 
					if (iMin < Z[j])
						if (iMax >= 0)
							if (iMin <= iMax)
							{
								double sum = S[j][iMax] - (iMin == 0 ? 0 : S[j][iMin-1]);
								sum *= p;
								res += sum*k;
							}
					
					last = Min;				
				}
			}
		}
 
		printf("%0.4f\n", res);
	}
		
 
 
	return 0;
}  
