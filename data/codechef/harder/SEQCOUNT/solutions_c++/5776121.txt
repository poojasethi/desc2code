#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <cmath>
#include <sstream>
#include <set>
#include <utility>
#include <queue>
#include <cassert>
#include <ctime>
using namespace std;
 
#define PB push_back
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
 
#define MAX_N 100005
#define MAX_K 450
#define MOD 1000000007
int dp[MAX_N][MAX_K], sum[MAX_N];
int n, k, d;
 
int solve(int rem, int cnt)
{
if(rem < 0)
return 0;
if(rem == 0)
return 1;
if(!cnt)
return 0;
if(dp[rem][cnt] != -1)
return dp[rem][cnt];
 
int &res = dp[rem][cnt];
res = solve(rem, cnt-1);
for(int i = 2; i <= d; i++) {
if(rem - (i-1) * cnt < 0)
break;
res = ( res + solve(rem - (i-1) * cnt, cnt-1) ) % MOD;
}
 
return res = res % MOD;
}
 
int solve(int rem, bool p)
{
if(rem < 0)
return 0;
if(rem == 0)
return 1;
 
dp[0][0] = sum[0] = 1;
ITR(i, 1, k+1) {
dp[0][i] = 1;
 
ITR(j, 1, rem+1) {
sum[j] = dp[j][i-1];
if(j-i >= 0)
sum[j] = (sum[j] + sum[j-i]) % MOD;
}
ITR(j, 1, rem+1) {
dp[j][i] = dp[j][i-1];
 
if(j - i < 0)
continue;
else if(j - d*i < 0)
dp[j][i] = (dp[j][i] + sum[j-i]) % MOD;
else if(j - d*i >= 0) {
dp[j][i] = (dp[j][i] + sum[j-i]) % MOD;
dp[j][i] = (dp[j][i] - sum[j - d*i] + MOD) % MOD;
}
}
}
 
return (dp[rem][k] % MOD);
}
 
int main()
{
scanf("%d %d %d", &n, &k, &d);
//WRITE("abc.txt");
 
//printf("Case n:%d k:%d d:%d : ", n, k, d);
//mem(dp, -1);
//printf("%d\n", solve( n - ((k * (k+1)) / 2), k ));
printf("%d\n", solve( n - ((k * (k+1)) / 2), true ));
 
return 0;
}
