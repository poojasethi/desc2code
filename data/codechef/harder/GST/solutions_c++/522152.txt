/*
 * Author: hanshuai
 * Created Time:  2011-4-14 15:31:48
 * File Name: gst.cpp
 */
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long LL;
const LL lcm30 = 2329089562800LL;
const LL INF = lcm30 * 1000;
struct ST{
    int t1, t2;
    LL v;
    void input(){
        int p1, p2;
        scanf("%d%d%d/%d", &t1, &t2, &p1, &p2);
        v = (LL)p1 * lcm30 / p2;
    }
}e[105];
const int maxn = 205;
struct Graph{
    struct Adj{
        int v; LL c; int b;
        Adj(int _v, LL _c, int _b):v(_v), c(_c), b(_b){}
    };
    vector<Adj> adj[maxn];
    int n, h[maxn], cnt[maxn], S, T;
    void clear(){
        for(int i = 0; i < n; i ++) adj[i].clear();
        n = 0;
    }
    void insert(int u, int v, LL c){
        //printf("%d %d %d\n", u, v, c);
        n = max(n, max(u, v) + 1);
        adj[u].push_back(Adj(v, c, adj[v].size()));
        adj[v].push_back(Adj(u, 0, adj[u].size()-1));
    }
    LL maxflow(int _S, int _T){
        S = _S; T = _T;
        fill(cnt, cnt+n, 0);
        fill(h, h+n, 0);
        LL ret = 0;
        while(h[S] < n){
            ret += dfs(S, INF);
            //printf("%I64d\n", ret);
        }
        return ret;
    }
    LL dfs(int u, LL flow){
        if(u == T) return flow;
        int minh = n - 1;
        LL ct = 0;
        for(vector<Adj>::iterator it = adj[u].begin(); flow && it != adj[u].end(); it++){
            if(it->c){
                if(h[u] == h[it->v] + 1){
                    LL k = dfs(it->v, min(flow, it->c));
                    ct += k;
                    it->c -= k;
                    adj[it->v][it->b].c += k;
                    flow -= k;
                    if(h[S] >= n) return ct;
                }
                minh = min(minh, h[it->v]);
            }
        }
        if(ct) return ct;
        if(--cnt[h[u]] == 0) h[S] = n;
        h[u] = minh + 1;
        cnt[h[u]] ++;
        return ct;
    }
    
}g, g2;
int N, M;
bool vis[205];
void dfs(int u){
    if(vis[u]) return;
    vis[u] = true;
    for(vector<Graph::Adj>::iterator it = g2.adj[u].begin(); it != g2.adj[u].end(); it++){
        if(it->c) dfs(it->v);
    }
}
void output(){
    printf("2\n");
    memset(vis, false, sizeof(vis));
    dfs(0);
    vector<int> ans;
    for(int i = 1; i <= M; i ++){
        if(vis[N+i]){
            ans.push_back(e[i].t1);
            ans.push_back(e[i].t2);
        }
    }
    sort(ans.begin(), ans.end());
    ans.erase(unique(ans.begin(), ans.end()), ans.end());
    printf("%d\n", ans.size());
    for(int i = 0; i < (int)ans.size(); i ++){
        if(i != 0) printf(" ");
        printf("%d", ans[i]);
    }
    printf("\n");
}
void solve(){
    LL sum = 0;
    for(int i = 1; i <= M; i ++){
        sum += e[i].v;
    }
    //printf("sum = %I64d n-1 = %I64d\n", sum, lcm30*(N-1));
    if(sum != lcm30*(N-1)){
        printf("1\n"); return;
    }
    int S = 0, T = N + M + 1;
    LL base = 0;
    g.clear();
    for(int i = 1; i <= M; i ++){
        int t1 = e[i].t1, t2 = e[i].t2;
        g.insert(S, i+N, e[i].v);
        g.insert(i+N, t1, INF);
        g.insert(i+N, t2, INF);
        base += e[i].v;
    }
    for(int i = 1; i <= N; i ++){
        g.insert(i, T, lcm30);
    }
    //g.insert(S, N+4, 3*lcm30);
    //printf("%I64d %I64d\n", base, g.maxflow(S, T));
    base -= g.maxflow(S, T);
    //printf("%I64d\n", base);
    for(int one = 1; one <= M; one ++){
        g2 = g;
        g2.insert(S, one+N, 2*lcm30+2);
        LL ans = 0;
        if(base - g2.maxflow(S, T) > -lcm30){
            output(); return;
        }
    }
    printf("GST\n");
}
int main() {
    //g.clear();
    //int S = 0, T = 1;
    //g.insert(S, 2, 100);
    //g.insert(2, T, 34);
    //printf("%I64d\n", g.maxflow(S, T));
    int test;
    scanf("%d", &test);
    while(test --){
        scanf("%d%d", &N, &M);
        for(int i = 1; i <= M; i ++){
            e[i].input();
        }
        solve();
        printf("\n");
    }
    return 0;
}

