#include <stdio.h>
#include <iostream>
#include <string.h>
#include <string>
#include <stdlib.h>
#include <algorithm>
#include <map>
#include <queue>
#include <vector>
#include <set>
#include <math.h>

#define pii pair<int,int>
#define A first
#define B second
#define FOR(i,a,b) for (int i = a; i <= (int) b; i++)
#define FOD(i,a,b) for (int i = a; i >= (int) b; i--)

using namespace std;

long long M;
int K, tc;
int xa, ya, xb, yb, xc, yc;
int dx[3], dy[3];
vector <pii> L1, L2;

struct TRI{
    pii coord[3];
    int diffx, diffy;
    TRI(){};
    TRI(int a, int b, int c, int d){
        coord[0].A = 0;
        coord[0].B = 0;
        coord[1].A = a;
        coord[1].B = b;
        coord[2].A = c;
        coord[2].B = d;
        int minx = 0, miny = 0;
        for (int i = 1; i < 3; i++){
            minx = min(coord[i].A,minx);
            miny = min(coord[i].B,miny);
        }
        diffx = 0, diffy = 0;
        for (int i = 0; i < 3; i++){
            coord[i].A += -minx;
            coord[i].B += -miny;
            diffx = max(diffx, coord[i].A);
            diffy = max(diffy, coord[i].B);
        }
        sort(coord,coord+3);
    }
};

bool operator < (const TRI &a, const TRI &b){
    for (int i = 0; i < 3; i++) if (a.coord[i] != b.coord[i]) return (a.coord[i] < b.coord[i]);
    return false;
}

int issquare(int a){
    double D = sqrt(a);
    int b = (int) ceil(D)+1e-6;
    if (b*b == a) return b;
    return -1;
}

inline int ABS(int a){
    if (a < 0) return -a;
    return a;
}

int dist(int a, int b, int c, int d){
    int dx = a-c;
    int dy = b-d;
    return dx*dx+dy*dy;
}

int main(){
    scanf("%d",&tc);
    FOR(TC, 1, tc){
        printf("Case #%d:\n",TC);
        scanf("%lld %d",&M,&K);
        for (int k = 0; k < K; k++){
            long long ans = 0;
            L1.clear(); L2.clear();
            scanf("%d%d%d%d%d%d",&xa,&ya,&xb,&yb,&xc,&yc);
            int dx = xa - xb;
            int dy = ya - yb;
            int z1 = dx*dx + dy*dy;
            for (int i = 0; i <= M; i++){
                int rem = z1 - i*i;
                if (rem < 0) break;
                int len = issquare(rem);
                if (len != -1){
                    L1.push_back(pii(i,len));
                    L1.push_back(pii(-i,len));
                    L1.push_back(pii(i,-len));
                    L1.push_back(pii(-i,-len));
                }
            }
            int dx2 = xb - xc;
            int dy2 = yb - yc;
            int dx3 = ABS(xa - xc);
            int dy3 = ABS(ya - yc);
            int z2 = dx2*dx2 + dy2*dy2;
            for (int i = 0; i <= M; i++){
                int rem = z2 - i*i;
                if (rem < 0) break;
                int len = issquare(rem);
                if (len != -1){
                    L2.push_back(pii(i,len));
                    L2.push_back(pii(-i,len));
                    L2.push_back(pii(i,-len));
                    L2.push_back(pii(-i,-len));
                }
            }
            int zz = dx3*dx3 + dy3*dy3;
            long long diffx;
            long long diffy;
            set <TRI> S;
            for (int i = 0; i < L1.size(); i++) for (int j = 0; j < L2.size(); j++){
                int a = L1[i].first;
                int b = L1[i].second;
                int c = L2[j].first;
                int d = L2[j].second;
                if (dist(a,b,c,d) == zz){
                    TRI tri(a,b,c,d);
                    if (tri.diffx <= M && tri.diffy <= M && S.find(tri) == S.end()){
                        S.insert(tri);
                        ans += (M+1-tri.diffx) * (M+1-tri.diffy);
                    }
                }
            }
            printf("%lld\n",ans);
        }
        printf("\n");
    }
    return 0;
}


