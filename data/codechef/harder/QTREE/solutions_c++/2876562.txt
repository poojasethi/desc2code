/*
	Author: Shafaet
	Heavy Light
*/
#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#include <assert.h>
 
#define stream istringstream
#define rep(i,n) for(int i=0; i<(int)n; i++)
#define repv(i,n) for(int i=n-1; i>=0; i--)
#define repl(i,n) for(int i=1; i<=(int)n; i++)
#define replv(i,n) for(int i=n; i>=1; i--)
 
#define SZ(x) (int)x.size()
#define INF (1061109567)
#define pb(x) push_back(x)
#define ppb pop_back
#define all(x) x.begin(),x.end()
#define mem(x,y) memset(x,y,sizeof(x));
#define eps 1e-9
#define pii pair<int,int>
#define pll pair<int,int>
#define pmp make_pair
#define sdi(x) scanf("%d",&x)
#define sdii(x,y) scanf("%d%d",&x,&y)
#define sds(x) scanf("%s",x)
#define pfi(x) printf("%d\n",x);
#define uu first
#define vv second
using namespace std;
template<class T> inline T sqr(T x){return x*x;}
double dist(double x1,double y1,double x2,double y2){return sqrt(sqr(x1-x2)+sqr(y1-y2));}
template<class T> inline T lcm(T a,T b) {if(a<0)return
lcm(-a,b);if(b<0)return lcm(a,-b);return a*(b/__gcd(a,b));}
template<class T> T power(T N,T P){ return (P==0)?  1: N*power(N,P-1); }
template<class T> string itoa(T a){if(!a) return "0";string ret;for(T i=a; i>0; i=i/10) ret.pb((i%10)+48);reverse(all(ret));return ret;}
typedef long long i64;
typedef unsigned long long ui64;
double log(double N,double B){  return (log10l(N))/(log10l(B)); }
vector< string > token( string a, string b ) {const char *q = a.c_str();while( count( b.begin(), b.end(), *q ) ) q++;vector< string > 
	oot;while( *q ) {const char *e = q;while( *e && !count( b.begin(), b.end(), *e ) ) e++;oot.push_back( string( q, e ) );q = e;while( count( b.begin(), 
	b.end(), *q ) ) q++;}return oot;
}
#define on(n,pos) n=(n | (1<<pos))
#define off(n,pos) n= n & ~(1<<pos)
#define isOn(n,pos) (bool)(n & (1<<pos))
string toBin(int n){ string s; repv(i,10)s+=(isOn(n,i)+'0');return s;}
//bool operator < ( const node& p ) const {      return w < p.w;   }
 
#define READ(f) freopen(f, "r", stdin)
#define WRITE(f) freopen(f, "w", stdout)
#define pks printf("Case %d: ",++ks);

///////
#define DEBUG if(0)
///////


#define mxn 210012
vector<int>g[mxn];
vector<int>cost[mxn];
vector<int>sav;
int numRoot[mxn],cn[mxn],lone,csz,ass;

	int vis[mxn],PAR[mxn],pcost[mxn]={0};
	int ttime=0,found=0;
	void find_cycle(int from,int u)
	{
		if(found) return;
		if(!vis[u])
		{
			vis[u]=++ttime;
			
			rep(i,SZ(g[u]))
			{
				if(found) break;
				int v=g[u][i];
				if(v==from) continue;
				PAR[v]=u;
				
				pcost[u]=cost[u][i];
				find_cycle(u,v);
			}
		}
		else if(vis[u]<vis[from])
		{
			int v=u;
			int c=0;
			while(1)
			{
				csz++;
				numRoot[v]=++c;
				sav.pb(v);
				v=PAR[v];
				if(v==u) break;
			}
			found=1;
		}
	}

		int n,a[mxn];
		
		
		struct info
		{
			int pre,suf,best,sum;
			info(int _pre,int _suf,int _best,int _sum):pre(_pre),suf(_suf),best(_best),sum(_sum){}
			info(){info(0,0,0,0);}
			void mult()
			{
				
				pre*=-1;
				suf*=-1;
				best*=-1;
				sum*=-1;
			}
		};
		struct data
		{
			info MAX,MIN;
			int carry;
		};
		data tree[mxn*3];
		info evalMAX(info p1,info p2,int flag=0)
		{
			
			if(p1.sum==-INF) return p2;
			if(p2.sum==-INF) return p1;
			if(p1.sum==-INF and p2.sum==-INF) {return p1;}
			if(flag==1) swap(p1.pre,p1.suf);
			
			
			info ret;
			ret.pre=max(p1.pre,p1.sum+p2.pre);
			ret.suf=max(p2.suf,p2.sum+p1.suf);
			ret.best=max(p1.suf+p2.pre,max(p1.best,p2.best));
			ret.sum=p1.sum+p2.sum;
			return ret;
		}

		info evalMIN(const info &p1,const info &p2)
		{			
			
			if(p1.sum==-INF) return p2;
			if(p2.sum==-INF) return p1;
			if(p1.sum==-INF and p2.sum==-INF) return p1;
		
			info ret;
			ret.pre=min(p1.pre,p1.sum+p2.pre);
			ret.suf=min(p2.suf,p2.sum+p1.suf);
			ret.best=min(p1.suf+p2.pre,min(p1.best,p2.best));
			ret.sum=p1.sum+p2.sum;
			return ret;
		}

		void init(int  node,int  b,int  e)
		{
			if(b==e)
			{
				tree[node].MAX=tree[node].MIN=info(a[b],a[b],a[b],a[b]);
				return;
			}
			int mid=(b+e)/2;
			int Left=(node*2);
			int Right=(node*2)+1;
			init(Left,b,mid);
			init(Right,mid+1,e);
			tree[node].MAX=evalMAX(tree[Left].MAX,tree[Right].MAX);
			tree[node].MIN=evalMIN(tree[Left].MIN,tree[Right].MIN);
		}
		void FLIP(data &ret)
		{			
			swap(ret.MAX,ret.MIN);
			ret.MAX.mult();
			ret.MIN.mult();
		}
		void update(int node,int  b,int e,int i,int j,int flip)
		{
			if(i>j) return;
			
			if (i > e || j < b)
			{
				tree[node].carry^=flip;
				if(flip==1) FLIP(tree[node]);
				return;
			}
			if(b>=i and e<=j)
			{				
				flip=flip^1;
				tree[node].carry^=flip;
				
				if(flip==1) FLIP(tree[node]);
				return;
			}
			int mid=(b+e)/2;
			int Left=(node*2);
			int Right=(node*2)+1;
			update(Left,b,mid,i,j,flip^tree[node].carry);
			update(Right,mid+1,e,i,j,flip^tree[node].carry);
			tree[node].carry=0;
			tree[node].MAX=evalMAX(tree[Left].MAX,tree[Right].MAX);
			tree[node].MIN=evalMIN(tree[Left].MIN,tree[Right].MIN);
		}
		info query(int node,int b,int e,int i,int j,int flip)
		{
			if(i>j) return info(-INF,-INF,-INF,-INF);
			if (i > e || j < b)return info(-INF,-INF,-INF,-INF);
			if(b>=i and e<=j)
			{				
				if(flip==0) return tree[node].MAX;
				info temp=tree[node].MIN;
				temp.mult();
				return temp;
			}
			int mid=(b+e)/2;
			int Left=(node*2);
			int Right=(node*2)+1;
			info p1=query(Left,b,mid,i,j,flip^tree[node].carry);
			info p2=query(Right,mid+1,e,i,j,flip^tree[node].carry);
			info ret=evalMAX(p1,p2);
			return ret;
		}
		int treeroot[mxn];
		int chainldr[mxn];
		int par[mxn];
		int level[mxn];
		int chain[mxn];
		int pos[mxn];
		int subt[mxn];
		int real[mxn];
		int lightcost[mxn];
		int dfs(int from,int u,int dep,int nt)
		{
			treeroot[u]=nt;
			par[u]=from;
			subt[u]=1;
			level[u]=dep;
			rep(i,SZ(g[u]))
			{
				int v=g[u][i];
				if(v==from or numRoot[v]) continue;
				lightcost[v]=cost[u][i];
				subt[u]+=dfs(u,v,dep+1,nt);
			}
			return subt[u];
		}
		
		int nc=0,np=0;
		void decompose(int u,int  k,int islight)
		{
			if(islight)	{
				k=++nc;
				chainldr[k]=u;
			}
			
			chain[u]=k;
			pos[u]=++np;
			real[np]=u;
			int maxi=-1;
			rep(i,SZ(g[u]))
			{
				int v=g[u][i];
				if(par[u]==v or numRoot[v]) continue;
				if(maxi==-1) maxi=v;
				else if(subt[v]>subt[maxi])maxi=v;
			}
			if(maxi==-1) return;
			decompose(maxi,k,false);
			rep(i,SZ(g[u]))
			{
				int v=g[u][i];
				if(par[u]==v or numRoot[v] or maxi==v) continue;
				decompose(v,0,true);
			}
		}


	int  LCA(int  u,int  v)
	{	
		while(chain[u]!=chain[v]){		
			if(level[chainldr[chain[u]]]<level[chainldr[chain[v]]])	v = par[chainldr[chain[v]]];
			else u = par[chainldr[chain[u]]];
		}
		if( level[u] < level[v] ) return u;
		else return v;
	}
	info climb(int  s,int  t)
	{
		stack<info>q;
		while(chain[s]!=chain[t])
		{
			q.push(query(1,1,n,pos[chainldr[chain[t]]],pos[t]-1,0));
			q.push(info(lightcost[chainldr[chain[t]]],lightcost[chainldr[chain[t]]],lightcost[chainldr[chain[t]]],lightcost[chainldr[chain[t]]]));
			t=par[chainldr[chain[t]]];
		}
		q.push(query(1,1,n,pos[s],pos[t]-1,0));
		while(SZ(q)>1)
		{
			info p1=q.top(); q.pop();
			info p2=q.top(); q.pop();
			q.push(evalMAX(p1,p2));
		}
		return q.top();
	}
	int  dif(int  u,int v)
	{
		if(u>v) return csz-u+v;
		return v-u;
	}
	info solve(int u,int  v)
	{
		if(cn[u]<cn[v]) return query(1,1,n,cn[u],cn[v]-1,0);
		return evalMAX(query(1,1,n,cn[u],ass-1,0),evalMAX(info(lone,lone,lone,lone),query(1,1,n,np+1,cn[v]-1,0)));
	}
	void up(int  u,int  v)
	{
		
		if(cn[u]<cn[v]){update(1,1,n,cn[u],cn[v]-1,0); return; }
		update(1,1,n,cn[v],ass-1,0);
		lone*=-1;
		update(1,1,n,np+1,cn[u]-1,0);
	}
	
	int HLquery(int  u,int  v)
	{
		if(treeroot[u]==treeroot[v])
		{
			int lc=LCA(u,v);
			info p1=climb(lc,u);
			info p2=climb(lc,v);
			return evalMAX(p1,p2,1).best;
		}
		else
		{
			int ru=treeroot[u];
			int rv=treeroot[v];
			info tu=climb(ru,u);
			info tv=climb(rv,v);
			int nu=numRoot[ru];
			int nv=numRoot[rv];
			if(dif(nu,nv)>dif(nv,nu))return evalMAX(evalMAX(tu,solve(ru,rv),1),tv).best;
			else return evalMAX(evalMAX(tv,solve(rv,ru),1),tu).best;
			
			
		}
		return -1;
	}
	void updateclimb(int  s,int  t)
	{
		while(chain[s]!=chain[t])
		{
			update(1,1,n,pos[chainldr[chain[t]]],pos[t]-1,0);
			lightcost[chainldr[chain[t]]]*=-1;
			t=par[chainldr[chain[t]]];
		}
		update(1,1,n,pos[s],pos[t]-1,0);
	}
	void update(int u,int v)
	{
		if(treeroot[u]==treeroot[v])
		{			
			int  lc=LCA(u,v);
			updateclimb(lc,u);
			updateclimb(lc,v);
		}
		else
		{
			int ru=treeroot[u];
			int rv=treeroot[v];
			updateclimb(ru,u);
			updateclimb(rv,v);
			int nu=numRoot[ru];
			int nv=numRoot[rv];
			info get,ret;
			if(dif(nu,nv)>dif(nv,nu))up(ru,rv);
			else up(rv,ru);
		}
	}



int main()
{
	//READ("in2");
	//WRITE("sout");
	
	cin>>n;
	repl(i,n)
	{
		int u,v,w;
		sdii(u,v);
		if(u>v) swap(u,v);
		sdi(w);
		g[u].pb(v);
		g[v].pb(u);
		cost[u].pb(w);
		cost[v].pb(w);
	}
	find_cycle(0,1);
	repl(i,n)
	{
			if(!numRoot[i]) continue;
			dfs(0,i,0,i);
			decompose(i,0,true);
	}
	repl(i,n)
	{
		rep(j,SZ(g[i]))
		{
			int u=i;
			int v=g[i][j];
			int w=cost[i][j];
			if(par[v]!=u) continue;
			if(chain[u]==chain[v])	a[pos[v]-1]=w;
		}
	}
	
	ass=np;
	repv(i,SZ(sav))
	{
		int u=sav[i];
		cn[u]=++ass;
		if(!i) {lone=pcost[u];break;}
		a[ass]=pcost[u];
	}
	n=ass;
	init(1,1,n);
	int q;
	sdi(q);
	rep(i,q){
		char s[10];
		sds(s);
		int u,v;
		if(s[0]=='?')
		{
			
			sdii(u,v);
			int ans=HLquery(u,v);
			printf("%d\n",max(0,ans));
			
		}
		else
		{			
			sdii(u,v);
			update(u,v);
		}
	}
	return 0;
}
