#include <bits/stdc++.h>
using namespace std;

const int MAXN = 112345, INFTY = 0x3f3f3f3f;
struct node{
    int esq_0, esq_1, dir_0, dir_1, sum_0, sum_1, maxi_0, maxi_1, lazy;
} VAZIO;
vector < pair<int,int> > grafo[MAXN];
vector <node> tree[MAXN];
int dp[20][MAXN], pai[MAXN], prof[MAXN], head[MAXN], sz[MAXN], N, sub[MAXN], cost[MAXN];
vector <int> lista[MAXN];
int cor[MAXN], pilha[2][MAXN], topo, CYCLE_IDX, CYCLE_SIZE, root[MAXN], pos[MAXN];
bool achei, mrk[MAXN], pertence[MAXN], VAI;
vector < pair<int,int> > ciclo;

void build_dp() {
    for (int i=1; i<=N; i++) dp[0][i] = pai[i];
    for (int k=1; k<20; k++) {
        for (int i=1; i<=N; i++) dp[k][i] = dp[k-1][dp[k-1][i]];
    }
}

int LCA(int a, int b) {
    if (prof[a] < prof[b]) swap(a,b);
    for (int k=19; k>=0; k--) {
        if (prof[dp[k][a]] >= prof[b]) a = dp[k][a];
    }
    if (a == b) return a;
    for (int k=19; k>=0; k--) {
        if (dp[k][a] != dp[k][b]) {
            a = dp[k][a];
            b = dp[k][b];
        }
    }
    return pai[a];
}

node merge(node a, node b) {
   // if (VAI) printf("merge -> (%d,%d,%d,%d) U (%d,%d,%d,%d)\n",a.esq_0,a.dir_0,a.sum_0,a.maxi_0,b.esq_0,b.dir_0,b.sum_0,b.maxi_0);
    node c;
    c.esq_0 = max(a.esq_0,a.sum_0+b.esq_0);
    c.esq_1 = max(a.esq_1,a.sum_1+b.esq_1);
    c.dir_0 = max(b.dir_0,b.sum_0+a.dir_0);
    c.dir_1 = max(b.dir_1,b.sum_1+a.dir_1);
    c.sum_0 = a.sum_0+b.sum_0;
    c.sum_1 = a.sum_1+b.sum_1;
    c.maxi_0 = max(max(a.maxi_0,b.maxi_0),max(0,a.dir_0+b.esq_0));
    c.maxi_1 = max(max(a.maxi_1,b.maxi_1),max(0,a.dir_1+b.esq_1));
   // printf("deu (%d,%d,%d,%d)\n",c.esq_0,c.dir_0,c.sum_0,c.maxi_0);
    c.lazy = 0;
    return c;
}

void build(int t, int idx, int ini, int fim) {
    if (ini == fim) {
     //   printf("cost[lista[%d][%d] = %d] = %d\n",t,ini-1,lista[t][ini-1],cost[lista[t][ini-1]]);
        tree[t][idx].esq_0 = tree[t][idx].dir_0 = tree[t][idx].sum_0 = cost[lista[t][ini-1]];
        tree[t][idx].maxi_0 = max(0,cost[lista[t][ini-1]]);
        tree[t][idx].esq_1 = tree[t][idx].dir_1 = tree[t][idx].sum_1 = -cost[lista[t][ini-1]];
        tree[t][idx].maxi_1 = max(0,-cost[lista[t][ini-1]]);
        tree[t][idx].lazy = 0;
        return;
    }
    int mid = (ini+fim)/2;
    build(t,2*idx,ini,mid);
    build(t,2*idx+1,mid+1,fim);
    tree[t][idx] = merge(tree[t][2*idx],tree[t][2*idx+1]);
}

void refresh(int t, int idx, int ini, int fim) {
    if (tree[t][idx].lazy == 0) return;
    swap(tree[t][idx].esq_0,tree[t][idx].esq_1);
    swap(tree[t][idx].dir_0,tree[t][idx].dir_1);
    swap(tree[t][idx].sum_0,tree[t][idx].sum_1);
    swap(tree[t][idx].maxi_0,tree[t][idx].maxi_1);
    if (ini != fim) {
        tree[t][2*idx].lazy ^= 1;
        tree[t][2*idx+1].lazy ^= 1;
    }
    tree[t][idx].lazy = 0;
}

void update(int t, int idx, int ini, int fim, int x, int y) {
    if (x > y) return;
    refresh(t,idx,ini,fim);
    if (ini > y || fim < x) return;
    if (x <= ini && fim <= y) {
        tree[t][idx].lazy ^= 1;
        refresh(t,idx,ini,fim);
        return;
    }
    int mid = (ini+fim)/2;
    update(t,2*idx,ini,mid,x,y);
    update(t,2*idx+1,mid+1,fim,x,y);
    tree[t][idx] = merge(tree[t][2*idx],tree[t][2*idx+1]);
}

node query(int t, int idx, int ini, int fim, int x, int y) {
    if (x > y) return VAZIO;
    refresh(t,idx,ini,fim);
    if (x <= ini && fim <= y) return tree[t][idx];
    int mid = (ini+fim)/2;
    if (y <= mid) return query(t,2*idx,ini,mid,x,y);
    if (x > mid) return query(t,2*idx+1,mid+1,fim,x,y);
    return merge(query(t,2*idx,ini,mid,x,y),query(t,2*idx+1,mid+1,fim,x,y));
}

void build_DFS(int v, int r) {
    mrk[v] = true;
    root[v] = r;
    int tam = grafo[v].size();
    sub[v] = 1;
    for (int i=0; i<tam; i++) {
        int w = grafo[v][i].first;
        if (mrk[w] || pertence[w]) continue;
        prof[w] = prof[v]+1;
        cost[w] = grafo[v][i].second;
        pai[w] = v;
        build_DFS(w,r);
        sub[v] += sub[w];
    }
    mrk[v] = false;
}

void build_heavy_light(int v) {
    mrk[v] = true;
    int tam = grafo[v].size();
    for (int i=0; i<tam; i++) {
        int w = grafo[v][i].first;
        if (mrk[w] || pertence[w]) continue;
        if (sub[w]*2 > sub[v]) {
            head[w] = head[v];
            lista[head[v]].push_back(w);
            sz[head[v]]++;
        }
        else {
            head[w] = w;
            lista[w].push_back(w);
            sz[w]++;
        }
        build_heavy_light(w);
    }
    if (sz[v] != 0) {
   //     printf("sz[%d] = %d\n",v,sz[v]);
        tree[v].resize(4*sz[v]+1);
        build(v,1,1,sz[v]);
    }
    mrk[v] = false;
}

node query_vtx(int a, int lca) {
  //  printf("query_vtx(%d,%d)\n",a,lca);
    int cur = a, chefe = head[a];
  //  printf("no inicio, cur = %d, chefe = %d\n",cur,chefe);
    node resp = VAZIO;
  //  printf("resp = (%d,%d,%d,%d)\n",resp.esq_0,resp.dir_0,resp.sum_0,resp.maxi_0);
    while (prof[lca] < prof[chefe]) {
        resp = merge(query(chefe,1,1,sz[chefe],1,prof[cur]-prof[chefe]+1),resp);
  //      printf("resp = (%d,%d,%d,%d)\n",resp.esq_0,resp.dir_0,resp.sum_0,resp.maxi_0);
        cur = pai[chefe];
        chefe = head[cur];
  //      printf("agora cur = %d, chefe = %d\n",cur,chefe);
    }
    if (cur == lca) return resp;
  //  printf("agora cur = %d, chefe = %d\n",cur,chefe);
    resp = merge(query(chefe,1,1,sz[chefe],prof[lca]-prof[chefe]+2,prof[cur]-prof[chefe]+1),resp);
  //  printf("resp = (%d,%d,%d,%d)\n",resp.esq_0,resp.dir_0,resp.sum_0,resp.maxi_0);
    return resp;
}

int query_1(int a, int b) {
  //  printf("query_1(%d,%d)\n",a,b);
    int lca = LCA(a,b);
    node x = query_vtx(a,lca);
    node y = query_vtx(b,lca);
    return max(max(x.maxi_0,y.maxi_0),x.esq_0+y.esq_0);
}

int query_pair(int a, int b) {
  //  printf("query_pair(%d,%d)\n",a,b);
    if (a == b) return 0;
    if (root[a] == root[b]) return query_1(a,b);
    if (pos[root[a]] > pos[root[b]]) swap(a,b);
 //   printf("a = %d, b = %d\n",a,b);
    node r1 = query_vtx(a,root[a]);
    node r2 = query_vtx(b,root[b]);
 //   printf("r1 = (%d,%d,%d,%d), r2 = (%d,%d,%d,%d)\n",r1.esq_0,r1.dir_0,r1.sum_0,r1.maxi_0,r2.esq_0,r2.dir_0,r2.sum_0,r2.maxi_0);
    node r3, r4;
    int x = pos[root[a]], y = pos[root[b]];
    if ((y-x)*2 < CYCLE_SIZE) {
        r3 = query(CYCLE_IDX,1,1,CYCLE_SIZE,x,y-1);
        r2 = merge(r3,r2);
        return max(max(r1.maxi_0,r2.maxi_0),r1.esq_0+r2.esq_0);
    }
    else {
        r3 = query(CYCLE_IDX,1,1,CYCLE_SIZE,1,x-1);
        r4 = query(CYCLE_IDX,1,1,CYCLE_SIZE,y,CYCLE_SIZE);
        r3 = merge(r4,r3);
        r1 = merge(r3,r1);
        return max(max(r1.maxi_0,r2.maxi_0),r1.esq_0+r2.esq_0);
    }
}

void update_vtx(int a, int lca) {
    int cur = a, chefe = head[a];
    while (prof[lca] < prof[chefe]) {
        update(chefe,1,1,sz[chefe],1,prof[cur]-prof[chefe]+1);
        cur = pai[chefe];
        chefe = head[cur];
    }
    if (cur == lca) return;
    update(chefe,1,1,sz[chefe],prof[lca]-prof[chefe]+2,prof[cur]-prof[chefe]+1);
}

int update_1(int a, int b) {
    int lca = LCA(a,b);
    update_vtx(a,lca);
    update_vtx(b,lca);
}

void update_pair(int a, int b) {
    if (root[a] == root[b]) {
        update_1(a,b);
        return;
    }
    update_vtx(a,root[a]);
    update_vtx(b,root[b]);
    int x = pos[root[a]], y = pos[root[b]], tam;
    if (x > y) swap(x,y);
    if ((y-x)*2 > CYCLE_SIZE) {
        update(CYCLE_IDX,1,1,CYCLE_SIZE,1,x-1);
        update(CYCLE_IDX,1,1,CYCLE_SIZE,y,CYCLE_SIZE);
    }
    else update(CYCLE_IDX,1,1,CYCLE_SIZE,x,y-1);
}

void build_cycle(int v) {
   // printf("build_cycle(%d)\n",v);
    int cur = 1;
    while (cur <= topo && pilha[0][cur] != v) cur++;
 //   printf("cur = %d\n",cur);
    for (int i=cur; i<=topo; i++) {
        ciclo.push_back(make_pair(pilha[0][i],pilha[1][i]));
  //      printf("coloquei %d,%d no ciclo\n",pilha[0][i],pilha[1][i]);
    }
    CYCLE_IDX = N+1;
    CYCLE_SIZE = ciclo.size();
    tree[CYCLE_IDX].resize(4*CYCLE_SIZE+1);
    for (int i=0; i<CYCLE_SIZE; i++) {
        lista[CYCLE_IDX].push_back(ciclo[i].first);
        cost[ciclo[i].first] = ciclo[i].second;
        pos[ciclo[i].first] = i+1;
        pertence[ciclo[i].first] = true;
        mrk[ciclo[i].first] = true;
    }
  //  printf("olar\n");
    build(CYCLE_IDX,1,1,CYCLE_SIZE);
  //  printf("tchau\n");
}

void find_cycle(int v) {
  //  printf("find_cycle(%d)\n",v);
    cor[v] = 1;
    int tam = grafo[v].size();
    for (int i=0; i<tam; i++) {
        if (achei) return;
        int w = grafo[v][i].first, c = grafo[v][i].second;
        if (pai[v] == w) continue;
   //     printf("filho(%d) = %d\n",v,w);
        if (cor[w] == 1) {
            topo++;
            pilha[0][topo] = v;
            pilha[1][topo] = c;
     //       printf("w ta marcado!!! bora fazer\n");
            build_cycle(w);
            achei = true;
        }
        else {
            topo++;
            pilha[0][topo] = v;
            pilha[1][topo] = c;
            pai[w] = v;
            find_cycle(w);
            topo--;
        }
    }
}

int main() {
    VAZIO.esq_0 = VAZIO.esq_1 = VAZIO.dir_0 = VAZIO.dir_1 = VAZIO.maxi_0 = VAZIO.maxi_1 = -INFTY;
    VAZIO.sum_0 = VAZIO.sum_1 = 0;
    int a, b, c, Q;
    char op;
    scanf("%d",&N);
    for (int i=1; i<=N; i++) {
        scanf("%d %d %d",&a,&b,&c);
        grafo[a].push_back(make_pair(b,c));
        grafo[b].push_back(make_pair(a,c));
    }
 //   VAI = true;
    find_cycle(1);
    for (int i=1; i<=N; i++) {
        if (pertence[i]) {
            pai[i] = i;
            prof[i] = 0;
            cost[i] = 0;
            build_DFS(i,i);
            head[i] = i;
            sz[i] = 1;
            lista[i].push_back(i);
            build_heavy_light(i);
        }
    }
    build_dp();
    scanf("%d",&Q);
 //   VAI = true;
    while (Q--) {
        scanf(" %c %d %d",&op,&a,&b);
        if (op == '?') printf("%d\n",query_pair(a,b));
        else update_pair(a,b);
    }
    return 0;
}
