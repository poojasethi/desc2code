#include <cmath>
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <string>
#include <vector>
#include <sstream>
#include <iostream>
#include <algorithm>
 
using namespace std;
 
#define sz(c) ((int) (c).size())
#define pb push_back
#define mp make_pair
#define f first
#define s second

struct Interval {
  bool lazy;
  int sum;
  int maxi, mini;
  int pMax, pMin;
  int sMax, sMin;

  Interval(int value=0) {
    lazy=false;
    sum=value;
    maxi=pMax=sMax=max(value,0);
    mini=pMin=sMin=min(value,0);
  }

  Interval join(Interval r) {
    Interval res;
    res.lazy=false;
    res.sum=sum+r.sum;
    res.maxi=max(maxi,r.maxi);
    res.maxi=max(res.maxi,sMax+r.pMax);
    res.mini=min(mini,r.mini);
    res.mini=min(res.mini,sMin+r.pMin);
    res.pMax=max(pMax,sum+r.pMax);
    res.pMin=min(pMin,sum+r.pMin);
    res.sMax=max(r.sMax,sMax+r.sum);
    res.sMin=min(r.sMin,sMin+r.sum);
    return res;
  }

  Interval inverse() {
    Interval res;
    res.lazy=!lazy;
    res.sum=-sum;
    res.maxi=-mini;
    res.mini=-maxi;
    res.pMax=-pMin;
    res.pMin=-pMax;
    res.sMax=-sMin;
    res.sMin=-sMax;
    return res;
  }

  Interval reverse() {
    Interval res;
    res.lazy=lazy;
    res.sum=sum;
    res.maxi=maxi;
    res.mini=mini;
    res.pMax=sMax;
    res.pMin=sMin;
    res.sMax=pMax;
    res.sMin=pMin;
    return res;
  }
};

struct LazyTree {
  int n;
  vector<Interval> node;

  LazyTree(vector<int> data=vector<int>()) {
    n=sz(data);
    if (n>0) {
      node.resize(4*n);
      build(data,0,0,n-1);
    }
  }

  void build(vector<int> &data, int v, int l, int r) {
    assert(v<4*n);
    if (l==r) {
      node[v]=Interval(data[l]);
    } else {
      int m=(l+r)/2;
      build(data,2*v+1,l,m);
      build(data,2*v+2,m+1,r);
      node[v]=node[2*v+1].join(node[2*v+2]);
    }
  }
  
  void invert(int i, int j) {
    invert(0,0,n-1,i,j);
  }

  void invert(int v, int l, int r, int i, int j) {
    assert(v<4*n);
    if (i>j || r<i || l>j) return;
    if (l>=i && r<=j) {
      node[v]=node[v].inverse();
      return;
    }
    if (node[v].lazy) {
      node[2*v+1]=node[2*v+1].inverse();
      node[2*v+2]=node[2*v+2].inverse();
    }
    int m=(l+r)/2;
    invert(2*v+1,l,m,i,j);
    invert(2*v+2,m+1,r,i,j);
    node[v]=node[2*v+1].join(node[2*v+2]);
  }

  Interval get_best(int i, int j) {
    return get_best(0,0,n-1,i,j);
  }

  Interval get_best(int v, int l, int r, int i, int j) {
    assert(v<4*n);
    if (i>j || r<i || l>j)
      return Interval(0);
    if (l>=i && r<=j)
      return node[v];
    if (node[v].lazy) {
      node[2*v+1]=node[2*v+1].inverse();
      node[2*v+2]=node[2*v+2].inverse();
      node[v]=node[2*v+1].join(node[2*v+2]);
    }
    int m=(l+r)/2;
    Interval left=get_best(2*v+1,l,m,i,j);
    Interval right=get_best(2*v+2,m+1,r,i,j);
    return left.join(right);
  }
};

// Graph
int N;
vector<int> a[111111];
vector<int> w[111111];

bool was[111111];

// Cycle
vector<int> cycle;
vector<int> cycleVals;
bool inCycle[111111];
LazyTree cycleTree;

// Trees
int tree[111111];
int treeSize[111111];
int parent[111111];
int depth[111111];

// HLD
vector<vector<int> > chain;
vector<vector<int> > chainVals;
pair<int,int> chainPos[111111];
vector<LazyTree> chainTrees;

pair<int,int> find_cycle(int v, int pr, int we) {
  was[v]=true;
  for (int i=0; i<sz(a[v]); ++i) {
    int u=a[v][i];
    if (was[u]) {
      if (u!=pr) {
        cycle.pb(v);
        cycleVals.pb(we);
        inCycle[v]=true;
        return mp(u,w[v][i]);
      }
    } else {
      pair<int,int> p=find_cycle(u,v,w[v][i]);
      int r=p.f;
      if (r!=-1) {
        cycle.pb(v);
        cycleVals.pb(v==r ? p.s : we);
        inCycle[v]=true;
        return v==r ? mp(-1,-1) : p;
      }
    }
  }
  return mp(-1,-1);
}

void dfs(int v, int pr, int tr, int de) {
  tree[v]=tr;
  depth[v]=de;
  parent[v]=pr;
  treeSize[v]=1;
  for (int i=0; i<sz(a[v]); ++i) {
    int u=a[v][i];
    if (u!=pr && !inCycle[u]) {
      dfs(u,v,tr,de+1);
      treeSize[v]+=treeSize[u];
    }
  }
}

void decompose(int v, int we, bool heavy) {
  int h=-1;
  for (int i=0; i<sz(a[v]); ++i) {
    int u=a[v][i];
    if (u!=parent[v] && !inCycle[u]) {
      if (treeSize[u]*2>=treeSize[v])
        h=i;
      else
        decompose(u,w[v][i],false);
    }
  }
  if (h!=-1)
    decompose(a[v][h],w[v][h],true);
  int i=sz(chain)-1;
  int j=sz(chain[i]);
  chain[i].pb(v);
  chainVals[i].pb(we);
  chainPos[v]=mp(i,j);
  if (parent[v]!=-1 && !heavy) {
    chain.pb(vector<int>());
    chainVals.pb(vector<int>());
  }
}

int get_lca(int a, int b) {
  assert(tree[a]==tree[b]);
  int i=chainPos[a].f;
  int j=chainPos[b].f;
  while (i!=j) {
    int u=parent[chain[i].back()];
    int v=parent[chain[j].back()];
    if (u!=-1 && (v==-1 || depth[u]>depth[v])) {
      a=parent[chain[i].back()];
      i=chainPos[a].f;
    } else {
      b=parent[chain[j].back()];
      j=chainPos[b].f;
    }
  }
  if (depth[a]<depth[b])
    return a;
  return b;
}

void invert_path(int a, int b) {
  assert(tree[a]==tree[b]);
  assert(depth[a]>=depth[b]);
  int i=chainPos[a].f;
  int j=chainPos[a].s;
  int ii=chainPos[b].f;
  int jj=chainPos[b].s;
  while (i!=ii) {
    int n=sz(chain[i]);
    chainTrees[i].invert(j,n-1);
    a=parent[chain[i].back()];
    i=chainPos[a].f;
    j=chainPos[a].s;
  }
  assert(j<=jj);
  chainTrees[i].invert(j,jj-1);
}

Interval get_best(int a, int b) {
  assert(tree[a]==tree[b]);
  assert(depth[a]>=depth[b]);
  int i=chainPos[a].f;
  int j=chainPos[a].s;
  int ii=chainPos[b].f;
  int jj=chainPos[b].s;
  Interval res;
  while (i!=ii) {
    int n=sz(chain[i]);
    res=res.join(chainTrees[i].get_best(j,n-1));
    a=parent[chain[i].back()];
    i=chainPos[a].f;
    j=chainPos[a].s;
  }
  assert(j<=jj);
  res=res.join(chainTrees[i].get_best(j,jj-1));
  return res;
}

void invert(int a, int b) {
  int i=tree[a];
  int j=tree[b];
  int C=sz(cycle);
  if (i==j) {
    int c=get_lca(a,b);
    invert_path(a,c);
    invert_path(b,c);
  } else {
    invert_path(a,cycle[i]);
    invert_path(b,cycle[j]);
    if (j-i<C+i-j) {
      cycleTree.invert(i,j-1);
    } else {
      cycleTree.invert(0,i-1);
      cycleTree.invert(j,C-1);
    }
  }
}

int get_max(int a, int b) {
  int i=tree[a];
  int j=tree[b];
  int C=sz(cycle);
  Interval res(0);
  if (i==j) {
    int c=get_lca(a,b);
    Interval besta=get_best(a,c);
    Interval bestb=get_best(b,c);
    res=besta.join(bestb.reverse());
  } else {
    Interval besta=get_best(a,cycle[i]);
    Interval bestb=get_best(b,cycle[j]);
    if (j-i<C+i-j) {
      Interval bestc=cycleTree.get_best(i,j-1);
      res=besta.join(bestc).join(bestb.reverse());
    } else {
      Interval bestc=cycleTree.get_best(0,i-1);
      Interval bestd=cycleTree.get_best(j,C-1);
      res=bestb.join(bestd).join(bestc).join(besta.reverse());
    }
  }
  return res.maxi;
}
 
int main() {
  scanf("%d",&N);
  assert(N>2);
  for (int i=0; i<N; ++i) {
    int u,v,z;
    scanf("%d%d%d",&u,&v,&z);
    --u;
    --v;
    a[u].pb(v);
    a[v].pb(u);
    w[u].pb(z);
    w[v].pb(z);
  }

  // Find cycle
  find_cycle(0,-1,-1);

  // BUILD HLD
  for (int i=0; i<sz(cycle); ++i)
    dfs(cycle[i],-1,i,1);

  for (int i=0; i<sz(cycle); ++i) {
    chain.pb(vector<int>());
    chainVals.pb(vector<int>());
    decompose(cycle[i],0,false);
  }

  // BUILD Interval Trees
  for (int i=0; i<sz(chain); ++i)
    chainTrees.pb(LazyTree(chainVals[i]));
  cycleTree = LazyTree(cycleVals);

  int Q;
  scanf("%d\n",&Q);
  while (Q--) {
    char q;
    int a,b;
    scanf("%c %d %d\n",&q,&a,&b);
    --a,--b;
    if (tree[a]>tree[b])
      swap(a,b);
    if (q=='f')
      invert(a,b);
    else
      printf("%d\n",get_max(a,b));
  }

  return 0;
}
