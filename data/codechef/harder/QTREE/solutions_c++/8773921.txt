#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	100005
#define INF	(1<<30)
#define min(a,b)	((a)<(b)?(a):(b))
#define max(a,b)	((a)>(b)?(a):(b))
#define For(i,a,b)	for(int i=a;i<=b;i++)

#define CH	(ch=getchar())
int		IN(){
		int x=0,f=0,ch;
		for	(;CH<'0'||ch>'9';)	f=(ch=='-');
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	f?-x:x;
}

int		N,R1,R2,A[n],W[n],F[n],Dep[n],Top[n],Dfn[n],Seq[n];
char	s[5];

struct	Nod{
		int 	rev,Sum,LMin,LMax,RMin,RMax,TMin,TMax;
		Nod()	{rev=Sum=0;LMin=RMin=TMin=INF;LMax=RMax=TMax=-INF;}
		Nod	operator +	(const Nod&b){
			Nod	a=*this,c;
			c.Sum=a.Sum+b.Sum;
			c.LMin=min(a.LMin,a.Sum+b.LMin);
			c.LMax=max(a.LMax,a.Sum+b.LMax);
			c.RMin=min(b.RMin,b.Sum+a.RMin);
			c.RMax=max(b.RMax,b.Sum+a.RMax);
			c.TMin=min(min(a.TMin,b.TMin),a.RMin+b.LMin);
			c.TMax=max(max(a.TMax,b.TMax),a.RMax+b.LMax);
			return	c;
		}
		void	Rev(){
			rev^=1;	Sum*=-1;
			LMin*=-1;LMax*=-1;	swap(LMin,LMax);
			RMin*=-1;RMax*=-1;	swap(RMin,RMax);
			TMin*=-1;TMax*=-1;	swap(TMin,TMax);
		}
		void	Upd(int w)	{Sum=w;LMin=RMin=TMin=min(0,w);LMax=RMax=TMax=max(0,w);}
}T[n<<2];

void	Up(int u)	{T[u]=T[u<<1]+T[u<<1|1];}
void	Dn(int u)	{
		if	(T[u].rev)	T[u<<1].Rev(),T[u<<1|1].Rev(),T[u].rev=0;
}
void	Build(int u,int l,int r){
		if	(l==r)	{T[u].Upd(W[A[Seq[l]]]);return;}	int	Mid=l+r>>1;
		Build(u<<1,l,Mid);	Build(u<<1|1,Mid+1,r);	Up(u);
}

void	Modify(int u,int l,int r,int x,int y){
		if	(x<=l&&r<=y){T[u].Rev();return;}	int Mid=l+r>>1;	Dn(u);
		if	(x<=Mid)	Modify(u<<1,l,Mid,x,y);
		if	(Mid<y)		Modify(u<<1|1,Mid+1,r,x,y);	Up(u);
}
Nod		Query(int u,int l,int r,int x,int y){
		if	(x<=l&&r<=y)return	T[u];	int Mid=l+r>>1;	Dn(u);
		if	(y<=Mid)	return	Query(u<<1,l,Mid,x,y);
		if	(x>Mid)		return	Query(u<<1|1,Mid+1,r,x,y);
		return	Query(u<<1,l,Mid,x,y)+Query(u<<1|1,Mid+1,r,x,y);
}

namespace	Tree{
		int		C,D,st[n],siz[n],son[n];
		struct	Lin{int v,next;}E[n<<1];
		bool	V[n];

		void	Link(int u,int v){
			E[++D]=(Lin){v,st[u]};	st[u]=D;
			E[++D]=(Lin){u,st[v]};	st[v]=D;
		}
		void	DFS0(int u,int f){
			V[u]=1;
			for	(int i=st[u],v;i;i=E[i].next)
			if	((v=E[i].v)!=f){
				if	(!V[v])	DFS0(v,u);
					else	R1=u,R2=v,A[u]=i/2;
			}
		}

		void	DFS1(int u,int f){
			for	(int i=st[u],v;i;i=E[i].next)
			if	(i/2!=A[R1]&&(v=E[i].v)!=f){
				Dep[v]=Dep[u]+1;F[v]=u;	A[v]=i/2;
				DFS1(v,u);	siz[u]+=siz[v];
				if	(siz[v]>siz[son[u]])son[u]=v;
			}	siz[u]++;
		}
		void	DFS2(int u,int f,int c){
			Dfn[u]=++C;	Seq[C]=u;	Top[u]=c;
			if	(son[u])	DFS2(son[u],u,c);
			for	(int i=st[u],v;i;i=E[i].next)
				if	(i/2!=A[R1]&&(v=E[i].v)!=f&&v!=son[u])	DFS2(v,u,v);
		}
		void	Main(){
			N=IN();	D=1;
			For(i,1,N)	Link(IN(),IN()),W[i]=IN();
			DFS0(1,0);	DFS1(R1,0);	DFS2(R1,0,R1);
		}
};

int		LCA(int u,int v){
		for	(;Top[u]!=Top[v];v=F[Top[v]])
			if	(Dep[Top[u]]>Dep[Top[v]])	swap(u,v);
		return	Dep[u]<Dep[v]?u:v;
}
int		Dis(int u,int v){return	Dep[u]+Dep[v]-2*Dep[LCA(u,v)];}
Nod		GTW(Nod a){
		swap(a.LMax,a.RMax);swap(a.LMin,a.RMin);
		return	a;
}

void	Work1(int u,int v){
		for	(int fx=Top[u],fy=Top[v];fx!=fy;){
			if	(Dep[fx]>Dep[fy])	swap(u,v),swap(fx,fy);
			Modify(1,1,N,Dfn[fy],Dfn[v]);	v=F[fy];fy=Top[v];
		}
		if	(Dep[u]>Dep[v])	swap(u,v);
		if	(Dfn[u]+1<=Dfn[v])	Modify(1,1,N,Dfn[u]+1,Dfn[v]);
}
Nod		Work2(int u,int v){
		Nod	l=Nod(),r=Nod();
		for	(int fx=Top[u],fy=Top[v];fx!=fy;)
		if	(Dep[fx]>Dep[fy])	l=l+GTW(Query(1,1,N,Dfn[fx],Dfn[u])),u=F[fx],fx=Top[u];
			else	r=Query(1,1,N,Dfn[fy],Dfn[v])+r,v=F[fy],fy=Top[v];
		if	(Dfn[u]+1<=Dfn[v])	l=l+Query(1,1,N,Dfn[u]+1,Dfn[v]);
		if	(Dfn[v]+1<=Dfn[u])	l=l+GTW(Query(1,1,N,Dfn[v]+1,Dfn[u]));
		return	l+r;
}

int		main(){
		Tree::Main();	Build(1,1,N);
		for	(int Q=IN(),u,v,Ans;Q--;)	{
			scanf("%s",s);	u=IN();	v=IN();
			int d1=Dis(u,v),d2=Dis(u,R1)+Dis(v,R2)+1,d3=Dis(u,R2)+Dis(v,R1)+1,d=min(d1,min(d2,d3));
			if	(d2>d3)	swap(u,v);

			if	(s[0]=='f')	{
				if	(d1==d)	Work1(u,v);
					else	Work1(u,R1),Work1(v,R2),Modify(1,1,N,Dfn[R1],Dfn[R1]);
			}	else	{
				if	(d1==d)	Ans=Work2(u,v).TMax;
					else	Ans=(Work2(u,R1)+Query(1,1,N,Dfn[R1],Dfn[R1])+Work2(R2,v)).TMax;
				printf("%d\n",max(0,Ans));
			}
		}
}