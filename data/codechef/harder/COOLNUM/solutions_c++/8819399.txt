#include <cstdio>
#include <algorithm>
#include <vector>
#include <memory.h>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define REP(i,x,y) for(int i=x;i>=y;i--)
struct bign
{
	int len,a[201];
	int& operator [](int x)
	{
		return a[x];
	}
} ds;
struct b2
{
	int len,a[1002];
	int& operator [](int x)
	{
		return a[x];
	}
};
bool operator <(bign a,bign b)
{
	if(a.len<b.len)return true;
	if(b.len<a.len)return false;
	REP(i,a.len,1)
	{
		if(a[i]<b[i])return true;
		if(b[i]<a[i])return false;
	}
	return false;
}
vector<bign> v;
b2 read()
{
	b2 ans,tem;
	ans.len=0;
	char s;
	while(true)
	{
		s=getchar();
		//putchar(s);
		if(s=='\n'||s==EOF)break;
    ans[++ans.len]=s-'0';
	}
	tem.len=ans.len;
  rep(i,1,ans.len)
  	tem[i]=ans[ans.len+1-i];
  return tem;
}
void write(bign num)
{
	printf("%d",num[num.len]);
	REP(i,num.len-1,1)
	{
		int now=100000,t=num[i];
		REP(j,6,1)
		{
			putchar('0'+t/now);
			if(j==1)break;
			t%=now;
			now/=10;
		}
  }
	//putchar('\n');
	return;
}
void write(b2 num)
{
	REP(i,num.len,1)
		putchar(num[i]+'0');
	//putchar('\n');
	return;
}
bign operator *(bign bas,int k)
{
	bign ans;
	int s=0;
	rep(i,1,bas.len)
	{
		ans[i]=s+bas[i]*k;
		s=ans[i]/1000000;
		ans[i]%=1000000;
	}
	ans.len=bas.len;
	while(s>0)
	{
		ans[++ans.len]=s%1000000;
		s/=1000000;
	}
	return ans;
}
int ss[1000000];
int getsum(bign x)
{
	int ans=0;
	rep(i,1,x.len)
		ans+=ss[x[i]];
	return ans;
}
bool can[28][4],cans[370];
int sum[10];
bool check(bign x,int s)
{
	memset(sum,0,sizeof(sum));
	rep(i,1,x.len)
	{
		int t=x[i];
		while(t>0)
		{
			sum[t%10]++;
			t/=10;
		}
		//sum[x[i]]++;
	}
	//if(x.len-sum[0]<=3)return false;
	rep(i,0,9)
		if(sum[i]>0)
		{
			if(s==i)return true;
			sum[i]--;
			rep(j,i,9)
				if(sum[j]>0)
				{
					if(s==i+j)return true;
					sum[j]--;
					int t=s-i-j;
					if(t>=0&&t<=9&&sum[t]>0)return true;
					sum[j]++;
				}
			sum[i]++;
		}
	return false;
}
int now,n,m,p[10],q[10],big=0,bt=0;
void dfs(int k,int t,bign x)
{
	if(k>n)
	{
		int o=getsum(x);
		if(o-now<t||o-now>27)return;
		if(check(x,o-now))
		{
			//if(now>big)big=now;
			v.push_back(x);
			cans[now]=true;
			//if(now>250)bt+=x.len;
		}
		return;
	}
	rep(i,0,27*q[k])
	{
		dfs(k+1,max(t,(i-1)/q[k]+1),x);
		if(i<27*q[k])x=x*p[k];
	}
	return;
}
void docan()
{
	cans[2]=true;cans[3]=true;cans[4]=true;cans[5]=true;cans[6]=true;cans[7]=true;cans[8]=true;cans[9]=true;cans[10]=true;cans[11]=true;cans[12]=true;cans[13]=true;cans[14]=true;cans[15]=true;cans[16]=true;cans[17]=true;cans[18]=true;cans[19]=true;cans[20]=true;cans[21]=true;cans[22]=true;cans[23]=true;cans[24]=true;cans[25]=true;cans[26]=true;cans[27]=true;cans[28]=true;cans[29]=true;cans[30]=true;cans[31]=true;cans[32]=true;cans[33]=true;cans[34]=true;cans[35]=true;cans[36]=true;cans[37]=true;cans[38]=true;cans[39]=true;cans[40]=true;cans[41]=true;cans[42]=true;cans[43]=true;cans[44]=true;cans[45]=true;cans[46]=true;cans[47]=true;cans[48]=true;cans[49]=true;cans[50]=true;cans[51]=true;cans[52]=true;cans[53]=true;cans[54]=true;cans[55]=true;cans[56]=true;cans[57]=true;cans[58]=true;cans[59]=true;cans[60]=true;cans[61]=true;cans[62]=true;cans[63]=true;cans[64]=true;cans[65]=true;cans[66]=true;cans[67]=true;cans[68]=true;cans[69]=true;cans[70]=true;cans[72]=true;cans[73]=true;cans[74]=true;cans[75]=true;cans[76]=true;cans[77]=true;cans[78]=true;cans[79]=true;cans[80]=true;cans[81]=true;cans[82]=true;cans[83]=true;cans[84]=true;cans[85]=true;cans[86]=true;cans[87]=true;cans[88]=true;cans[89]=true;cans[90]=true;cans[91]=true;cans[92]=true;cans[93]=true;cans[94]=true;cans[95]=true;cans[96]=true;cans[98]=true;cans[99]=true;cans[100]=true;cans[102]=true;cans[103]=true;cans[104]=true;cans[105]=true;cans[106]=true;cans[108]=true;cans[109]=true;cans[110]=true;cans[111]=true;cans[112]=true;cans[114]=true;cans[115]=true;cans[116]=true;cans[117]=true;cans[118]=true;cans[119]=true;cans[120]=true;cans[121]=true;cans[122]=true;cans[123]=true;cans[124]=true;cans[125]=true;cans[126]=true;cans[127]=true;cans[128]=true;cans[129]=true;cans[130]=true;cans[131]=true;cans[132]=true;cans[133]=true;cans[134]=true;cans[135]=true;cans[136]=true;cans[137]=true;cans[138]=true;cans[139]=true;cans[140]=true;cans[141]=true;cans[142]=true;cans[143]=true;cans[144]=true;cans[145]=true;cans[146]=true;cans[147]=true;cans[148]=true;cans[149]=true;cans[150]=true;cans[151]=true;cans[152]=true;cans[153]=true;cans[154]=true;cans[155]=true;cans[156]=true;cans[158]=true;cans[159]=true;cans[161]=true;cans[162]=true;cans[163]=true;cans[164]=true;cans[165]=true;cans[166]=true;cans[168]=true;cans[169]=true;cans[170]=true;cans[171]=true;cans[172]=true;cans[174]=true;cans[175]=true;cans[176]=true;cans[177]=true;cans[178]=true;cans[179]=true;cans[180]=true;cans[182]=true;cans[183]=true;cans[184]=true;cans[185]=true;cans[186]=true;cans[187]=true;cans[188]=true;cans[189]=true;cans[190]=true;cans[192]=true;cans[194]=true;cans[195]=true;cans[196]=true;cans[198]=true;cans[199]=true;cans[201]=true;cans[202]=true;cans[203]=true;cans[204]=true;cans[205]=true;cans[206]=true;cans[207]=true;cans[208]=true;cans[209]=true;cans[210]=true;cans[211]=true;cans[212]=true;cans[213]=true;cans[214]=true;cans[215]=true;cans[216]=true;cans[217]=true;cans[218]=true;cans[219]=true;cans[221]=true;cans[222]=true;cans[223]=true;cans[224]=true;cans[225]=true;cans[226]=true;cans[227]=true;cans[228]=true;cans[229]=true;cans[230]=true;cans[231]=true;cans[232]=true;cans[233]=true;cans[234]=true;cans[235]=true;cans[236]=true;cans[237]=true;cans[238]=true;cans[242]=true;cans[243]=true;cans[244]=true;cans[245]=true;cans[246]=true;cans[247]=true;cans[248]=true;cans[251]=true;cans[252]=true;cans[253]=true;cans[254]=true;cans[255]=true;cans[256]=true;cans[261]=true;cans[262]=true;cans[264]=true;cans[265]=true;cans[266]=true;cans[268]=true;cans[269]=true;cans[271]=true;cans[272]=true;cans[273]=true;cans[275]=true;cans[279]=true;cans[282]=true;cans[286]=true;cans[287]=true;cans[288]=true;cans[297]=true;cans[301]=true;cans[302]=true;cans[304]=true;cans[306]=true;cans[314]=true;cans[315]=true;cans[325]=true;
	return;
}
bign doit(b2 x)
{
	bign ans;
	ans.len=0;
	rep(i,1,x.len/6)
	{
		ans[++ans.len]=x[i*6-5];
		int now=1;
		REP(j,4,0)
		{
			now*=10;
			ans[ans.len]=ans[ans.len]+now*x[i*6-j];
		}
	}
	if(x.len%6>0)ans[++ans.len]=0;
	int now=1;
	rep(i,1,x.len%6)
	{
		ans[ans.len]+=now*x[x.len/6*6+i];
		now*=10;
	}
	return ans;
}
int main()
{
	int ttt=0;
	memset(cans,false,sizeof(cans));
	docan();
	ss[0]=0;
	rep(i,1,1000000)
		ss[i]=ss[i/10]+i%10;
	v.clear();
	rep(i,1,325)
	if(cans[i])
	{
		//printf("%d\n",i);
		//cans[i]=false;
		n=0;
		now=i;
		int t=i,j=2;
		while(t>1)
		{
			if(t%j==0)
			{
				p[++n]=j;
				q[n]=0;
				while(t%j==0)
				{
					t/=j;
					q[n]++;
				}
			}
			j++;
		}
		ds.len=1;
		ds[1]=1;
		dfs(1,0,ds);
		//if(cans[i])printf("cans[%d]=true;",i);
	}
	sort(v.begin(),v.end());
//	printf("%d\n",bt);
	//printf("%d\n",big);
	//printf("%d\n",v.size());
	rep(i,0,v.size()-1)
	{
	//	write(v[i]);
	}
	int T;
	scanf("%d",&T);getchar();
	while(T--)
	{
	//	printf("%d\n",T);
		b2 rd=read(),ans1,ans2;
		//write(rd);
		int sums=0,place;
		ans1.len=ans2.len=rd.len;
		REP(i,rd.len,1)
		{
			ans1[i]=ans2[i]=rd[i];
			if(rd[i]>0)sums++;
			if(sums>3)ans1[i]=ans2[i]=0;
			if(sums<=3&&rd[i]!=0)place=i;
		}
		if(sums<3)place=1;
		ans2[place]++;
		int j=place;
		while(ans2[j]>9&&j<ans2.len)
		{
			ans2[j+1]+=1;
			ans2[j]-=10;
			j++;
		}
		if(ans2[j]>9)
		{
			ans2[j]-=10;
			ans2[++ans2.len]=1;
		}
		ds=doit(rd);
		int t1=0,t2=v.size()-1;
		while(t1<t2)
		{
			int mid=1+((t1+t2)>>1);
			if(ds<v[mid])t2=mid-1;
				else t1=mid;
		}
		if(!(ds<v[t1])&&doit(ans1)<v[t1])write(v[t1]);
			else write(ans1);
		putchar(' ');
		while(t1<v.size()&&!(ds<v[t1]))t1++;
		if(t1==v.size()||doit(ans2)<v[t1])write(ans2);
			else write(v[t1]);
		putchar('\n');
	}
	return 0;
}