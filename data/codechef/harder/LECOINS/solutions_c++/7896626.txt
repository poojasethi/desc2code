#include <cstdio>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
 
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<int> VI;
 
const int maxV = 200000;
const LL maxS = 1000000000000000000LL;
 
inline void updMin(LL &A, LL B) {
	A > B ? A = B : 0;
}
 
int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}
 
void update(vector<VLL> &dp, VI V) {
	sort(V.begin(), V.end());
	V.erase(unique(V.begin(), V.end()), V.end());
 
	int m = dp[0].size(); // min(Vi)
	int cnt = dp.size(); // number of processed colors before
	dp.push_back(VLL(m, maxS + 1)); // we add row corresponding to this color
 
	for (int k = cnt - 1; k >= 0; --k) {
		for (int i = 0; i < V.size(); ++i) {
			int y = V[i] % m;
			for (int x = 0; x < m; ++x) {
				updMin(dp[k+1][y], dp[k][x] + V[i]);
				++y == m ? y = 0 : 0;
			}
		}
	}
 
	for (int k = 0; k <= cnt; ++k) {
		for (int i = 0; i < V.size(); ++i) {
			int v = V[i] % m;
			int d = gcd(v, m); // the number of cycles
			for (int x = 0; x < d; ++x) {
				int y0 = x;
				for (int y = x; y < m; y += d ) {
					if (dp[k][y0] > dp[k][y]) {
						y0 = y;
					}
				}
				int y = y0;
				do {
					int z = y + v;
					z >= m ? z -= m : 0;
					updMin(dp[k][z], dp[k][y] + V[i]);
					y = z; // we move y to the next vertex of the cycle
				} while (y != y0);
			}
		}
	}
}
 
int main() {
	int n;
	scanf("%d", &n);
	int m = maxV + 1;
	map<int, VI> coins; 
	for (int i = 0; i < n; ++i) {
		int V, C; 
		scanf("%d%d", &V, &C);
		coins[C].push_back(V); 
		m = min(m, V); // update m
	}
 
	// create dp array
	// initially it has only one row filled by INF
	vector<VLL> dp(1, VLL(m, maxS + 1));
	dp[0][0] = 0; // with only one 0
 
	// C++11 where are you?
	// disgusting iterating over map
	for (map<int, VI>::iterator it = coins.begin(); it != coins.end(); ++it) {
		// it->second is the list of coins of the current color
		// so we do update of dp by it
		update(dp, it->second);
	}
 
	// processing queries
	int Q;
	scanf("%d", &Q);
	for (int q = 0; q < Q; ++q) {
		LL s;
		scanf("%lld", &s);
		int ans = -1;
		int r = s % m;
		for (int k = int(dp.size()) - 1; k >= 0; --k) {
			// the largest value of k with this inequality is the answer
			// note that dp[][r] is not necessary increasing
			// so binary search is inapplicable
			if (dp[k][r] <= s) {
				ans = k;
				break;
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}  
