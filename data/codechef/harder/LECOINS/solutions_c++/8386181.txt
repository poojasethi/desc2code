#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cstdio>
#include<queue>
using namespace std;
#define MAXN 55
#define MAXV 200200
#define MAXQ 200200
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
typedef long long qword;
//#define HAHA
//#define register 
#define HAHA __attribute((optimize("O2")))
#define pmod(x,p) (((x)>=(p))?((x)-(p)):(x))
HAHA inline qword nextqword()
{
		register qword x=0;
		register char ch;
		while (ch=getchar(),ch<'0' || ch>'9');
		while (x=x*10+ch-'0',ch=getchar(),ch<='9' && ch>='0');
		return x;
}
qword dis[MAXN][MAXV];
pair<int,int> coins[MAXN];
qword qur[MAXQ];
vector<int> cs;
HAHA bool cmp_second(pair<int,int> p1,pair<int,int> p2)
{
		return p1.second<p2.second;
}
HAHA inline void deal(qword &x,qword y)
{
		if (x>y)x=y;
}
short vis[MAXV];
HAHA void shortest_path(vector<int> trs,qword dist[],register int mod)
{
		for (int i=0;i<trs.size();++i)
		{
				register int t=trs[i],tt=trs[i]%mod;
				for (register int j=0;j<mod;++j)vis[j]=0;
				qword mnv=INFL;
				for (register int j=0;j<mod;++j)
				{
						if (vis[j])continue;
						if (dist[j]==INFL)continue;
						register int x=j;
						while (vis[x]<=1)
						{
								if (vis[x] && dist[x]==mnv)
										break;
								mnv=min(mnv,dist[x]);
								vis[x]++;
								deal(dist[pmod(x+tt,mod)],dist[x]+t);
								x=pmod((x+tt),mod);
						}
				}
		}
}
qword dist[MAXV];
int res[MAXV];
int qurp[MAXQ];


HAHA int main()
{
		int n,m;
		n=(int)nextqword();
		for (int i=0;i<n;++i)
		{
				coins[i].first=(int)nextqword();
				coins[i].second=(int)nextqword();
				//scanf("%d%d",&coins[i].first,&coins[i].second);
				cs.push_back(coins[i].second);
		}
		sort(coins,coins+n);
		sort(cs.begin(),cs.end());
		cs.erase(unique(cs.begin(),cs.end()),cs.end());
		m=(int)nextqword();
		for (int i=0;i<m;++i)
				qur[i]=nextqword();
		int minv=INF;
		int minc;
		for (int i=0;i<n;++i)
				if (coins[i].first<minv)
						minv=coins[i].first,minc=coins[i].second;
		for (int i=0;i<m;i++)qurp[i]=qur[i]%minv;
		for (int i=0;i<=m;++i)
				res[i]=-INF;
		memset(dis,INF,sizeof(dis));
		dis[0][0]=0;
		for (int i=0;i<(int)cs.size();++i)
		{
				if (cs[i]==minc)continue;
				vector<int> vec;
				for (int j=0;j<n;++j)
						if (coins[j].second==cs[i])
								vec.push_back(coins[j].first);
				for (int j=n-1;j>=0;j--)
				{
						for (register int k=0;k<minv;++k)dist[k]=INFL;
						for (register int k=0;k<minv;++k)
								for(register int k2=0;k2<(int)vec.size();++k2)
										deal(dist[(k+vec[k2])%minv],dis[j][k]+vec[k2]);
						shortest_path(vec,dist,minv);
						for (register int k=0;k<minv;++k)
								deal(dis[j+1][k],dist[k]);
				}
		}
		for (int k=0;k<=n;++k)
		{
				for (int i=0;i<m;++i)
				{
						if (dis[k][qurp[i]]==qur[i])
								res[i]=max(res[i],k);
						if (dis[k][qurp[i]]<qur[i])
								res[i]=max(res[i],k+1);
				}
		}
		vector<int> vec;
		for (int j=0;j<n;++j)
				if (coins[j].second==minc)
						vec.push_back(coins[j].first);
		for (int j=n-1;j>=0;j--)
		{
				for (register int k=0;k<minv;++k)dist[k]=INFL;
				for (register int k=0;k<minv;++k)
						for(register int k2=0;k2<(int)vec.size();++k2)
								deal(dist[(k+vec[k2])%minv],dis[j][k]+vec[k2]);
				shortest_path(vec,dist,minv);
				for (register int k=0;k<minv;++k)
						deal(dis[j+1][k],dist[k]);
		}
		for (register int i=0;i<m;++i)
		{
				for (register int k=0;k<=n;++k)
						if (dis[k][qurp[i]]<=qur[i])
								res[i]=max(res[i],k);
		}
		for (register int i=0;i<m;++i)
		{
				if (res[i]==-INF)
						printf("-1\n");
				else
						printf("%d\n",res[i]);
		}
}