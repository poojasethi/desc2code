#include <cstdio>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;

// useful typedefs
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<int> VI;

const int maxV = 200000;
const LL maxS = 1000000000000000000LL;

// set A to min(A, B)
inline void updMin(LL &A, LL B) {
	A > B ? A = B : 0;
}

// needed to find the number of cycles described above
int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

// update dp array by coins of some color
// V contains values of all coins of the given color
// We will add additional row to dp in this routine
void update(vector<VLL> &dp, VI V) {
	// just an heuristic to speed up the solution at some cases
	// it does not change the max-time
	// we don't need to process equal coin values
	sort(V.begin(), V.end());
	V.erase(unique(V.begin(), V.end()), V.end());

	int m = dp[0].size(); // min(Vi)
	int cnt = dp.size(); // number of processed colors before
	dp.push_back(VLL(m, maxS + 1)); // we add row corresponding to this color

	// the first step of update
	for (int k = cnt - 1; k >= 0; --k) {
		for (int i = 0; i < V.size(); ++i) {
			// y will be equal to (x + V) % m
			int y = V[i] % m;
			for (int x = 0; x < m; ++x) {
				updMin(dp[k+1][y], dp[k][x] + V[i]);
				// the optimization to avoid modulo operation
				++y == m ? y = 0 : 0;
			}
		}
	}

	// the second step of update
	for (int k = 0; k <= cnt; ++k) {
		for (int i = 0; i < V.size(); ++i) {
			int v = V[i] % m;
			int d = gcd(v, m); // the number of cycles
			// x is the first vertex of each cycle
			// the cycle has the form x -> (x+V)%m -> (x+2*V)%m -> ... -> x
			// but using some simple number theory we see
			// that all vertexes in this cycle are x, x+d, x+2*d, ..., x+m-d
			for (int x = 0; x < d; ++x) {
				// y0 will be the vertex of this cycle with the smallest dp-value
				int y0 = x;
				// convenient loop over cycle by the remark above
				for (int y = x; y < m; y += d ) {
					// compare dp-values and update y0 if necessary
					if (dp[k][y0] > dp[k][y]) {
						y0 = y;
					}
				}
				// now we do updates starting from y0
				int y = y0;
				do {
					// z = (y + v) % m
					// this way avoids heavy modulo operation
					int z = y + v;
					z >= m ? z -= m : 0;
					updMin(dp[k][z], dp[k][y] + V[i]);
					y = z; // we move y to the next vertex of the cycle
				} while (y != y0);
			}
		}
	}
}

int main() {
	// we us scanf and printf since input and output files are quite large
	int n;
	scanf("%d", &n);
	int m = maxV + 1;
	map<int, VI> coins; // contains list of coin values for each color
	for (int i = 0; i < n; ++i) {
		int V, C; // value and color of the current coin
		scanf("%d%d", &V, &C);
		coins[C].push_back(V); // add V to the list of coins of color C
		m = min(m, V); // update m
	}

	// create dp array
	// initially it has only one row filled by INF
	vector<VLL> dp(1, VLL(m, maxS + 1));
	dp[0][0] = 0; // with only one 0

	// C++11 where are you?
	// disgusting iterating over map
	for (map<int, VI>::iterator it = coins.begin(); it != coins.end(); ++it) {
		// it->second is the list of coins of the current color
		// so we do update of dp by it
		update(dp, it->second);
	}

	// processing queries
	int Q;
	scanf("%d", &Q);
	for (int q = 0; q < Q; ++q) {
		LL s;
		scanf("%lld", &s);
		int ans = -1;
		int r = s % m;
		for (int k = int(dp.size()) - 1; k >= 0; --k) {
			// the largest value of k with this inequality is the answer
			// note that dp[][r] is not necessary increasing
			// so binary search is inapplicable
			if (dp[k][r] <= s) {
				ans = k;
				break;
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}