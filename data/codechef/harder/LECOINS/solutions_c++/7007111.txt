#include <iostream>
#include <cstdio>
#include <sstream>
 
#include <algorithm>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>
 
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <bitset>
#include <ctime>
 
using namespace std;
 
typedef long long int64;
 
#define endl '\n'
#define SZ(c) ((int)((c).size()))
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
#define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i)
#define ALL(c) (c).begin(), (c).end()
 
struct IO {
	int cur;
	inline char nextChar() { return cur = getc_unlocked(stdin); }
	inline char peekChar() { return cur; }
	inline operator bool() { return (peekChar() != 0); }
	inline static bool isSpace(char c) { return (c < '0' && c); }
	inline bool skipBlanks() { while (isSpace(nextChar())); return peekChar() != 0; }
	IO() : cur(0) {}
 
	inline IO& operator >> (int & n) {
		if (skipBlanks()) {
			int sign = +1;
			if (peekChar() == '-') {
				sign = -1;
				n = nextChar() - '0';
			}
			else
				n = peekChar() - '0';
			while (!isSpace(nextChar())) {
				n *= 10;
				n += peekChar() - '0';
			}
			n *= sign;
		}
		return *this;
	}
 
	inline IO& operator >> (int64 & n) {
		if (skipBlanks()) {
			int sign = +1;
			if (peekChar() == '-') {
				sign = -1;
				n = nextChar() - '0';
			}
			else
				n = peekChar() - '0';
			while (!isSpace(nextChar())) {
				n *= 10;
				n += peekChar() - '0';
			}
			n *= sign;
		}
		return *this;
	}
 
	#define cin io
} io;
 
const int
	MAXN = 31,
	MAXV = 200001,
	MAXQ = 200001;
 
const int64
	oo = (1LL << 62);
 
int queryCount, N, C;
 
int cnt[MAXN];
//vector< int > coins[MAXN];
int coins[MAXN][MAXN];
int coinsMod[MAXN][MAXN];
 
int64 dp[MAXN][MAXV]; // minimum value possible with i coins
 
 
bitset< MAXV > inQueue[MAXN];
 
int ans[MAXQ];
int64 query[MAXQ];
 
int minCoin;
 
map< int, int > toId;
 
struct fastQueue
{
	static const int
		MAXCAP = MAXV + 1;
 
	int Q[MAXCAP];
	int head, tail;
 
	void clear()
	{
		head = tail = 0;
	}
 
	inline bool empty()
	{
		return head == tail;
	}
 
	inline void push(int s)
	{
		Q[tail++] = s;
		if (tail >= MAXCAP)
			tail = 0;
	}
 
	inline int pop()
	{
		int r = Q[head++];
		if (head >= MAXCAP)
			head = 0;
		return r;
	}
 
	int peek()
	{
		return Q[head];
	}
 
} Q[MAXN];
 
inline void tryPush(int maxColors, int value)
{
	//assert(maxColors <= C);
	if (!inQueue[maxColors][value])
	{
		Q[maxColors].push(value);
		inQueue[maxColors][value] = true;
	}
}
 
inline int pop(int maxColors)
{
	int top = Q[maxColors].pop();
	inQueue[maxColors][top] = false;
	return top;
}
 
int maxColors;
 
bitset< MAXV > mark;
 
void bfs(int groupId)
{
	maxColors++;
 
	for (int c = 0; c <= maxColors; ++c)
		Q[c].clear();
 
	// pre bfs
	for (int c = maxColors - 1; c >= 0; --c)
	REP(j, minCoin) if (dp[c][j] != oo)
	{
		REP(i, cnt[groupId])
		{
			int curCoin = coins[groupId][i];
			int curCoinMod = coinsMod[groupId][i];
			int nextValue = (j + curCoinMod);
			if (nextValue >= minCoin)
				nextValue -= minCoin;
 
			int64 cost = dp[c][j] + curCoin;
			if (cost < dp[c + 1][nextValue])
			{
				dp[c + 1][nextValue] = cost;
				tryPush(c + 1, nextValue);
			}
		}
	}
 
	// post bfs
	for (int c = 1; c <= maxColors; ++c)
	{
		while (!Q[c].empty())
		{
			int top = pop(c);
			int64 topDist = dp[c][top];
			REP(i, cnt[groupId]) //if (i > 0 || (!avoidFirst))
			{
				int curCoin = coins[groupId][i];
				int curCoinMod = coinsMod[groupId][i];
				int nextValue = top + curCoinMod;
				if (nextValue >= minCoin)
					nextValue -= minCoin;
				int64 cost = topDist + curCoin;
				if (cost < dp[c][nextValue])
				{
					dp[c][nextValue] = cost;
					tryPush(c, nextValue);
				}
			}
		}
	}
}
 
int order[MAXN];
 
void solve()
{
	maxColors = 0;
 
	for (int i = 0; i <= C; ++i)
		for (int j = 0; j < minCoin; ++j)
			dp[i][j] = oo;
 
	dp[0][0] = 0; // 0 coins for 0
 
	for (int c = 0; c < C; ++c)
		bfs(order[c]);
 
	REP(i, queryCount)
	{
		int64 q = query[i];
		for (int j = C; j > 0; --j)
			if (q >= dp[j][q % minCoin])
			{
				ans[i] = max(ans[i], j);
				break;
			}
	}
}
 
bool lessCmp(int a, int b)
{
	return cnt[a] < cnt[b];
	//return coins[a][0] < coins[b][0];
}
 
int main()
{
	ios::sync_with_stdio(0);
 
	cin >> N;
 
	minCoin = MAXV;
 
	REP(i, N)
	{
		int v, c;
		cin >> v >> c;
		if (!toId.count(c))
			toId[c] = C++;
		c = toId[c];
		//coins[ c ].push_back(v);
		coins[ c ][ cnt[c]++ ] = v;
		minCoin = min(minCoin, v);
	}
 
	cin >> queryCount;
	REP(i, queryCount)
	{
		cin >> query[i];
		//assert(query[i] > 0 && query[i] < oo);
		ans[i] = -1;
	}
 
	REP(i, C)
	{
		sort(coins[i], coins[i] + cnt[i]);
		cnt[i] = unique(coins[i], coins[i] + cnt[i]) - coins[i];
		order[i] = i;
	}
 
	//sort(order, order + C, lessCmp);
	random_shuffle(order, order + C);
 
	REP(c, C)
	REP(j, cnt[c])
	{
		coinsMod[c][j] = coins[c][j] % minCoin;
		//coins[C][ cnt[C]++ ] = coins[c][i];
		//coinsMod[C][j] = coins[c][j] % minCoin;
	}
 
	//sort(coins, coins + C);
 
	/*
	cout << C << " coin groups" << endl;
	REP(i, C)
	{
		cout << "group " << (i+1) << endl;
		REP(j, SZ(coins[i]))
			cout << coins[i][j] << " ";
		cout << endl;
	}
	*/
 
	solve();
 
	REP(i, queryCount)
	{
		//assert(ans[i] <= C);
		//assert(ans[i] != 0);
		printf( "%d\n", ans[i] ); // cout << ans[i] << endl;
	}
 
	return 0;
} 