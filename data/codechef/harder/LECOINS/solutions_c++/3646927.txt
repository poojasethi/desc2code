#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<map>
#include<ctime>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<bitset>
#include<functional>
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=30+2;
const int NUM=200000+10;

int N,L,sum;
pair<int,int> c[MAX];
int dp[2][MAX*NUM],now,last;//to get number a,the smallest number
LL di[MAX][NUM];//the smallest one that L%g can be get by i number
int que[NUM],head,end;
int que2[NUM],head2,end2;
int hash[NUM],T,tmp[NUM];

void work(int len,LL* di)
{
    int i,j,top=0;
    head=end=0;
    REP(j,0,sum)
        if(dp[now][j]==len && di[j%L]==-1)
        {
            di[j%L]=j;
            que[end++]=j%L;
        }
    REP(i,1,N)
    {
        T++;
        //two queue
        int w=c[i].y;
        head2=end2=0;
        top=0;
        while(head<end || head2<end2)
        {
            int u;
            if(head<end && (head2==end2 || di[ que[head] ]<di[ que2[head2] ]))
                u=que[head++];
            else u=que2[head2++];
            if(hash[u]==T)
                continue;
            hash[u]=T;
            tmp[top++]=u;

            int v=(u+w) % L;
            if(di[v]==-1 || di[v]>di[u]+w)
            {
                di[v]=di[u]+w;
                que2[end2++]=v;
            }
        }
        REP2(j,0,top)
            que[j]=tmp[j];
        head=0;
        end=top;
    }
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
    int i,j;
    scanf("%d",&N);
    REP(i,1,N)
        scanf("%d%d",&c[i].y,&c[i].x);
    sort(c+1,c+N+1);

    L=c[1].y;
    REP(i,1,N)
        L=min(L,c[i].y);

    now=0,last=1;
    memset(dp,-1,sizeof dp);

    dp[now][0]=0;
    int all=0;
    for(i=1;i<=N;)
    {
        ++all;
        swap(now,last);
        int x=c[i].x;
        int tmp=i;
        for(;i<=N && c[i].x==x;++i)
            sum+=c[i].y;
        int l=i;
        REP(j,0,sum)
            dp[now][j]=dp[last][j];
        for(i=tmp;i!=l;++i)
            for(j=0;j+c[i].y<=sum;++j)
                if(dp[last][j]!=-1 && dp[last][j]+1>dp[now][j+c[i].y])
                    dp[now][j+c[i].y]=dp[last][j]+1;
    }
    memset(di,-1,sizeof di);
    REP(i,1,all)
        work(i,di[i]);

    int Q;
    scanf("%d",&Q);
    while(Q--)
    {
        LL S;
        cin>>S;
        int ans=-1;
        for(j=all;j>=1;--j)
            if(di[j][S%L]<=S && di[j][S%L]!=-1)
            {
                ans=j;
                break;
            }
        printf("%d\n",ans);
    }
    return 0;
}
