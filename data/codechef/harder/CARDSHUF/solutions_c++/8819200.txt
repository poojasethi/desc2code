
#include<bits/stdc++.h>
using namespace std;
#define D(x)        cout<<#x " = "<<(x)<<endl
#define un(x)       x.erase(unique(x.begin(),x.end()), x.end())
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define pb          push_back
#define mp          make_pair
#define xx          first
#define yy          second
#define hp          (LL) 999983
#define MAX         100000
typedef long long int LL;


// Treap- Dynamic Array
struct Treap{
    int val, prior, cnt;
    bool revflg;
    Treap *l, *r;
    Treap(int v): l(NULL), r(NULL), val(v), prior((rand() << 15) + rand()), cnt(1), revflg(false) {}
}; // initialize the root if declared locally

int sz(Treap *t) {return (t == NULL) ? 0:t->cnt;}

void upd_sz(Treap *t){
    if(t) t->cnt = 1 + sz(t->l) + sz(t->r);
}

inline void prop(Treap *t)
{
    if(!t || !t->revflg) return;
    swap(t->l, t->r);

    if(t->l) t->l->revflg ^= 1;
    if(t->r) t->r->revflg ^= 1;
    t->revflg = 0;
}

void split(Treap *t, Treap *&l, Treap *&r, int pos, int add = 0)
{
    prop(t);
    if(!t) return void(l = r = NULL);
    int cur_pos = add + sz(t->l) + 1;
    if(cur_pos <= pos) split(t->r, t->r, r, pos, cur_pos), l = t;
    else split(t->l, l ,t->l, pos, add), r = t;
    upd_sz(t);
}

void merge(Treap *&t, Treap *l, Treap *r) //needed to erase something
{
    prop(l);
    prop(r);

    if(!l || !r) t = l? l:r;
    else if(l->prior > r->prior) {merge(l->r, l->r, r); t = l;}
    else {merge(r->l, l, r->l);t = r;}
    upd_sz(t);
}

void insert(Treap *&t, int pos, int val)
{
    Treap *l, *r, *cur = new Treap(val);
    split(t, l, r, pos-1);
    merge(t, l, cur);
    merge(t, t, r);
}

void erase(Treap *&t, int pos)
{
    Treap *l, *r, *g;
    split(t, l, r, pos-1);
    split(r, g, r, 1);
    merge(t, l, r);
}

int find_kth(Treap *t, int k, int add = 0)
{
    prop(t);
    assert(t);
    int cur_pos = add + sz(t->l) + 1;
    if(cur_pos == k) return t-> val;
    if(cur_pos < k) return find_kth(t->r, k, cur_pos);
    return find_kth(t->l, k, add);
}

void rmv(Treap *u)
{
    if(!u) return;
    rmv(u->l);
    rmv(u->r);
    delete(u);
}

void go(Treap *&t, int A, int B, int C)
{
    Treap *l, *r, *mid;

    split(t, l, r, A);
    split(r, mid, r, B); // mid matters
    merge(t, l, r); // l and r doesn't matter from now on
    split(t, l, r, C); // l = C cards, R = rest of the cards

    mid->revflg ^= 1;
    merge(t, mid, r);
    merge(t, l, t);
}


int main()
{
    //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);
    //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);

    int i, j, k, n, q, l, r;
    int A, B, C;
    Treap *rt = 0;

    sff(n,q);
    for(i = 1; i <= n; i++)
        insert(rt, i, i);

    while(q--)
    {
        sfff(A,B,C);
        go(rt, A,B,C);
    }

    for(i = 1; i <= n; i++)
        printf("%d ", find_kth(rt, i));
    return 0;
}



