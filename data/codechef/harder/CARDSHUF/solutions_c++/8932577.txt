//Pranet Verma
#include <bits/stdc++.h>
using namespace std;
typedef struct Node* pNode;
struct Node
{
    int prior,cnt;
    bool rev;
    pNode l,r;
    int id;
    Node(int value):prior(rand()),rev(false),cnt(1),l(NULL),r(NULL){id=value;}
};
int sz(pNode &u)
{
    return u?u->cnt:0;
}
void update(pNode u)
{
    if(!u)
        return;
    u->cnt=1+sz(u->l)+sz(u->r);
}
void lazyProp(pNode u)
{
    if(!u)
        return;
    if(u->rev)
    {
        swap(u->l,u->r);
        if(u->l)
            u->l->rev^=1;
        if(u->r)
            u->r->rev^=1;
        u->rev=0;        
    }
}
void merge(pNode &u,pNode l,pNode r)
{
    lazyProp(l);
    lazyProp(r);
    if(!l || !r)
        u=l?l:r;
    else if(l->prior > r->prior)
    {
        merge(l->r,l->r,r);
        u=l;
    }
    else
    {
        merge(r->l,l,r->l);
        u=r;
    }
    update(u);
}   
void split(pNode u,pNode &l,pNode &r,int key,int add)
{
    if(!u)
        l=r=NULL;
    else
    {
        lazyProp(u);
        int rank=add+sz(u->l)+1;
        if(rank<=key)
        {
            split(u->r,u->r,r,key,rank);
            l=u;
        }
        else
        {
            split(u->l,l,u->l,key,add);
            r=u;
        }
        update(u);
    }
}
void assignIDs(pNode u,int &id)
{
    if(!u)
        return;
    assignIDs(u->l,id);
    u->id=id++;
    assignIDs(u->r,id);
}
void printNode(pNode u)
{
    if(!u)
        return;
    lazyProp(u);
    printNode(u->l);
    cout<<u->id<<" ";
    printNode(u->r);
}
void display(pNode u)
{
    if(!u)
        return;
    cout<<"At "<<u->id<<endl;
    cout<<"Going left "<<endl;
    display(u->l);
    cout<<"Back At "<<u->id<<endl;
    cout<<"Going right "<<endl;
    display(u->r);
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    pNode root=NULL;
    for(int i=1;i<=n;++i)
        merge(root,root,new Node(i));
    int id=1;
    assignIDs(root,id);
    assert(id==n+1);
    while(m--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        assert(a+b<=n);
        assert(b+c<=n);
        pNode A,B,C,temp,temp2;
        split(root,A,temp,a,0);
        split(temp,B,temp2,b,0);
        merge(temp,A,temp2);
        split(temp,C,temp2,c,0);
        if(B)
            B->rev^=1;
        merge(temp,B,temp2);
        merge(root,C,temp);
    }
    printNode(root);
}