// just testing shdut's solution

#define _CRT_SECURE_NO_DEPRECATE
#define _SCL_SECURE_NO_WARNINGS

#include <cstdio>
#include <cstdlib>
#include <algorithm>

using namespace std;

#define SZ 100000
struct node{
	node():l(0),r(0),cnt(1),f(0){}
	node *l, *r;
	int v, cnt;
	int w; int f;
};
node nl[SZ];
int pos;
void norm(node *x){
	if (x->f){
		x->f=0, swap(x->l, x->r);
		if (x->l) x->l->f^=1;
		if (x->r) x->r->f^=1;
	}
}
void disp(node *x){
	if (!x) return;
	norm(x);
	disp(x->l); printf("%d ", x->v+1); disp(x->r);
}
int count(node *x){return x?x->cnt:0;}
void split(node *p, node *&A, node *&B, int cnt){
	if (!p){A=B=0; return;}
	norm(p);
	if (cnt<=count(p->l)){
		node *u;
		split(p->l, A, u, cnt);
		p->l=u;
		B=p;
		p->cnt-=count(A);
	}else{
		node *u;
		split(p->r, u, B, cnt-count(p->l)-1);
		p->cnt-=count(B);
		p->r=u;
		A=p;
	}
}
node *merge(node *root, node *a){
	if (!root) return a;
	if (!a) return root;
	norm(root); norm(a);
	if (root->w>=a->w){
		root->cnt+=count(a);
		root->l=merge(root->l, a);
		return root;
	}else{
		a->cnt+=count(root);
		a->r=merge(root, a->r);
		return a;
	}
}
int main(){
	int n, m;
	scanf("%d %d", &n, &m);
	pos=0;
	node *root=nl;
	root->v=0;
	for(int i=0;i<n-1;i++){
		node *a=nl+i+1;
		a->v=i+1;
		a->w=rand();
		root=merge(a, root);
	}
	for(int i=0;i<m;i++){
		int a, b, c;
		scanf(" %d %d %d", &a, &b, &c);
		node *an, *bn;
		an=bn=0;
		split(root, an, root, a);
		split(root, bn, root, b);
		if (bn) bn->f^=1;
		root=merge(root, an);
		an=0;
		split(root, an, root, c);
		root=merge(root, bn);
		root=merge(root, an);
	}
	disp(root); printf("\n");
	return 0;
}
