#include<bits/stdc++.h>
 
using namespace std;
 
#define sd(x) scanf("%d" , &x)
 
typedef long long int LL;

#define MOD 1000000007
 
#define PB push_back
 
#define TS 1123456
#define N 1123456
 
struct Node{
    int a, b, p;
    int sb;
    int aa, mb;
    int mxa, mna;
    int lid, rid;
    int sz;
    bool flag;
} node[TS];
 
void norm(int &x){
    if(x >= MOD){
        x -= MOD;
    }
}
 
void adda(int id, int x){
    if(id < 0){
        return;
    }
    node[id].aa += x;
    node[id].flag = true;
}
 
void mulb(int id, int x){
    if(id < 0){
        return;
    }
    node[id].mb = (LL(x) * node[id].mb) % MOD;
    node[id].flag = true;
}
 
int get_sz(int id){
    return (id >= 0 ? node[id].sz : 0);
}
 
void update_sz(int id){
    if(id >= 0){
        node[id].sz = 1 + get_sz(node[id].lid) + get_sz(node[id].rid);
    }
}
 
void push(int id){
    if(id < 0){
        return;
    }
 
    node[id].mxa += node[id].aa;
    node[id].mna += node[id].aa;
    node[id].a += node[id].aa;
 
    adda(node[id].lid, node[id].aa);
    adda(node[id].rid, node[id].aa);
    node[id].aa = 0;
 
    node[id].b = (LL(node[id].mb) * node[id].b) % MOD;
    node[id].sb = (LL(node[id].mb) * node[id].sb) % MOD;
 
    mulb(node[id].lid, node[id].mb);
    mulb(node[id].rid, node[id].mb);
    node[id].mb = 1;
 
    node[id].flag = false;
}
 
int get_sb(int id){
    if(id < 0){
        return 0;
    }
    if(node[id].flag == true){
        push(id);
    }
    return node[id].sb;
}
 
int get_mxa(int id){
    if(id < 0){
        return -MOD;
    }
    if(node[id].flag == true){
        push(id);
    }
    return node[id].mxa;
}
 
int get_mna(int id){
    if(id < 0){
        return MOD;
    }
    if(node[id].flag == true){
        push(id);
    }
    return node[id].mna;
}
 
void update_node(int id){
	if(node[id].flag == true){
		push(id);
	}
    node[id].sb = get_sb(node[id].lid) + get_sb(node[id].rid);
    norm(node[id].sb);
    node[id].sb += node[id].b;
    norm(node[id].sb);
 
    node[id].mna = min(get_mna(node[id].lid), get_mna(node[id].rid));
    node[id].mna = min(node[id].mna, node[id].a);
 
    node[id].mxa = max(get_mxa(node[id].lid), get_mxa(node[id].rid));
    node[id].mxa = max(node[id].mxa, node[id].a);
 
    update_sz(id);
}
 
void split(int id, int x, int &l, int &r){
    if(id == -1){
        l = r = -1;
    }
    else{
        if(node[id].flag == true){
            push(id);
        }
        if(x < node[id].a || (x == node[id].a && abs(rand()) % 2 == 0)){
            split(node[id].lid, x, l, node[id].lid);
            r = id;
        }
        else{
            split(node[id].rid, x, node[id].rid, r);
            l = id;
        }
        update_node(id);
    }
}
 
int inserT(int id1, int id2){
    if(id1 < 0){
        return id2;
    }
    if(id2 < 0){
    	return id1;
    }
    if(node[id1].flag == true){
        push(id1);
    }
    if(node[id1].p > node[id2].p){
        if((node[id1].a > node[id2].a) || (node[id1].a == node[id2].a && abs(rand()) % 2 == 0)){
            node[id1].lid = inserT(node[id1].lid, id2);
        }
        else{
            node[id1].rid = inserT(node[id1].rid, id2);
        }
        update_node(id1);
        return id1;
    }
    else{
        split(id1, node[id2].a, node[id2].lid, node[id2].rid);
        update_node(id2);
        return id2;
    }
}
 
int query_sb(int id, int x, bool fl = false){
    if(id < 0){
        return 0;
    }
    if(node[id].flag == true){
        push(id);
    }
    if(node[id].mxa < x){
        return 0;
    }
    if(node[id].mna >= x){
        return node[id].sb;
    }
    if(node[id].a < x){
        return query_sb(node[id].rid, x);
    }
    int ret = node[id].b;
    ret += get_sb(node[id].rid);
    norm(ret);
    ret += query_sb(node[id].lid, x);
    norm(ret);
    return ret;
}
 
void make(int ctr, int v, int _p, int _b){
	node[ctr].a = v;
    node[ctr].mxa = v;
    node[ctr].mna = v;
    
    node[ctr].b = _b;
    node[ctr].sb = _b;
    
    node[ctr].p = _p;
    
    node[ctr].lid = -1;
    node[ctr].rid = -1;
    
    node[ctr].sz = 1;
    
    node[ctr].flag = false;
    node[ctr].mb = 1;
    node[ctr].aa = 0;
}

int val[N];
int rt[N];
int ans[N], pr[TS];
int ctr = 0, ctr2;
bool vis[N];
vector<int> adj[N], child[N];
LL pre[N], suf[N];
 
int dump(int id1, int id2){
    if(id2 < 0){
        return id1;
    }
    if(node[id2].flag == true){
        push(id2);
    }
    id1 = dump(id1, node[id2].lid);
    id1 = dump(id1, node[id2].rid);
    node[id2].lid = -1;
    node[id2].rid = -1;
    update_node(id2);
    return inserT(id1, id2);
}
 
int dump_cpy(int id1, int id2, LL pb, bool flag = false){
    if(id2 < 0){
        return id1;
    }
    if(node[id2].flag == true){
        push(id2);
    }
    ctr2++;
    make(TS - ctr2, node[id2].a, pr[TS - ctr2],  (pb * node[id2].b) % MOD);
    id1 = inserT(id1, TS - ctr2);
    id1 = dump_cpy(id1, node[id2].lid, pb);
    id1 = dump_cpy(id1, node[id2].rid, pb);
    return id1;
}
 
int dfs2(int id1, int id2, LL pb, int x){
    if(id2 == -1){
        return 0;
    }
    if(node[id2].flag == true){
        push(id2);
    }
    LL cv = pb * query_sb(id1, x - node[id2].a);
    cv %= MOD;
    cv *= node[id2].b;
    cv %= MOD;
    int ret = dfs2(id1, node[id2].lid, pb, x);
    ret += dfs2(id1, node[id2].rid, pb, x);
    norm(ret);
    ret += cv;
    norm(ret);
    return ret;
}
 
int depth = 0;
 
void dfs(int u){
	int i, v, c;
    vis[u] = true;
    child[u].clear();
    for(i = adj[u].size() - 1; i >= 0; i--){
        v = adj[u][i];
        if(vis[v] == false){
            dfs(v);
            child[u].PB(v);
        }
    }
    int mi, ms, s;
    int r;
    rt[u] = ctr;
    make(ctr, val[u], pr[u], 1);
    ctr++;
    r = rt[u];
    c = child[u].size();
    LL pb = 1;
    for(i = 0; i < c; ++i){
        v = child[u][i];
        adda(rt[v], val[u]);
        pb = (pb * ans[v]) % MOD;
    }
    ans[u] = (val[u] >= 0 ? pb : 0);
    if(c == 0){
    	return;
    }
    node[r].b = pb;
    if(c == 1){
        ans[u] += query_sb(rt[v], 0);
        norm(ans[u]);
        node[r].sb = node[r].b;
        rt[u] = inserT(rt[v], rt[u]);
        return;
    }
    mi = 0;
    ms = -1;
    suf[c] = 1;
    for(i = 0; i < c; ++i){
        v = child[u][i];
        s = node[rt[v]].sz;
        if(s > ms){
            ms = s;
            mi = i;
        }
    }
    swap(child[u][mi], child[u][0]);
    ctr2 = 1;
    pb = 1;
    pre[0] = ans[child[u][0]];
    r = -1;
    suf[c] = 1;
    for(i = c - 1; i >= 0; --i){
    	suf[i] = (suf[i + 1] * ans[child[u][i]]) % MOD;
    }
    for(i = 1; i < c; ++i){
        v = child[u][i];
        ans[u] += dfs2(rt[child[u][0]], rt[v], (pb * suf[i + 1]) % MOD, val[u]);
        norm(ans[u]);
        if(i > 1){
            ans[u] += dfs2(r, rt[v], suf[i + 1], val[u]);
            norm(ans[u]);
        }
        mulb(r, ans[v]);
        r = dump_cpy(r, rt[v], pre[i - 1], true);
        pb *= ans[v];
        pb %= MOD;
        pre[i] = (pre[i - 1] * ans[v]) % MOD;
    }
    for(i = c - 1; i >= 0; i--){
        v = child[u][i];
        if(i == 0){
            mulb(rt[v], suf[i + 1]);
        }
        else if(i == c - 1){
            mulb(rt[v], pre[i - 1]);
        }
        else{
            mulb(rt[v], (pre[i - 1] * suf[i + 1]) % MOD);
        }
        ans[u] += query_sb(rt[v], 0);
        norm(ans[u]);
    }
    v = child[u][0];
    for(i = c - 1; i > 0; --i){
        rt[v] = dump(rt[v], rt[child[u][i]]);
    }
    update_node(rt[u]);
    rt[u] = inserT(rt[v], rt[u]);
}
 
void solve(){
    int n;
    sd(n);
    ctr = 0;
    for(int i = 0; i < n; ++i){
        sd(val[i]);
        adj[i].clear();
        vis[i] = false;
    }
    for(int u, v, i = 1; i < n; ++i){
        sd(u); sd(v);
        --u;
        --v;
        adj[u].PB(v);
        adj[v].PB(u);
    }
    dfs(0);
    printf("%d\n", ans[0]);
}
 
int main(){
    int t;
    for(t = 0; t < TS; t++){
        pr[t] = t;
    }
    random_shuffle(pr, pr + TS);
    sd(t);
    while(t--){
        solve();
    }
    return 0;
}  