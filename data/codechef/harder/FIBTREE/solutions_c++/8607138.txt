#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#define s1(x) ((x)<0?0:sum1[x])
#define s2(x) ((x)<0?0:sum2[x])
#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)
#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)
using namespace std;
typedef long long LL;
typedef double db;
inline void read(int &x){
	x=0;char p=getchar();
	while(!(p<='9'&&p>='0'))p=getchar();
	while(p<='9'&&p>='0')x*=10,x+=p-48,p=getchar();
}
int n,Q;
const int P=1000000009;
inline void add(int &x,int y){x+=y;if(x>=P)x-=P;}
const int sqrt5=383008016;
const int inv2=500000005;
const int N=110000;
int po1[N],po2[N];
int sum1[N],sum2[N];
inline int Pow(int a,int b){
	int c=1;
	for(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;
	return c;
}
int pre;
//---------begin Segment Tree
int tim;
int root[N];int segtot;
int cl[N*400],cr[N*400],tag1[N*400],tag2[N*400],tag3[N*400],tag4[N*400],sum[N*400],val[N*400];
int ask(int me,int l,int r,int x,int y){
	if(!me)return 0;
	int ans=0;
	if(x<=l&&r<=y){add(ans,sum[me]);add(ans,val[me]);return ans;}
	if(l<=x&&y<=r){
		if(x^l)add(ans,tag1[me]*1ll*(sum1[y-l]+P-sum1[x-l-1])%P);else add(ans,tag1[me]*1ll*(sum1[y-l])%P);
		if(y^r)add(ans,tag2[me]*1ll*(sum1[r-x]+P-sum1[r-y-1])%P);else add(ans,tag2[me]*1ll*(sum1[r-x])%P);
		if(x^l)add(ans,(P-tag3[me])*1ll*(sum2[y-l]+P-sum2[x-l-1])%P);else add(ans,(P-tag3[me])*1ll*(sum2[y-l])%P);
		if(y^r)add(ans,(P-tag4[me])*1ll*(sum2[r-x]+P-sum2[r-y-1])%P);else add(ans,(P-tag4[me])*1ll*(sum2[r-x])%P);
	}
	else
	if(x>=l&&x<=r){
		add(ans,tag1[me]*1ll*(sum1[r-l]+P-sum1[x-l-1])%P);
		add(ans,tag2[me]*1ll*sum1[r-x]%P);
		add(ans,(P-tag3[me])*1ll*(sum2[r-l]+P-sum2[x-l-1])%P);
		add(ans,(P-tag4[me])*1ll*sum2[r-x]%P);
	}
	else{
		add(ans,tag1[me]*1ll*sum1[y-l]%P);
		add(ans,tag2[me]*1ll*(sum1[r-l]+P-sum1[r-y-1])%P);
		add(ans,(P-tag3[me])*1ll*sum2[y-l]%P);
		add(ans,(P-tag4[me])*1ll*(sum2[r-l]+P-sum2[r-y-1])%P);
	}
	int mid=(l+r)>>1;
	//printf("___%d %d %d %d %d\n",l,r,x,y,ans*1ll*Pow(sqrt5,P-2)%P);
	if(x<=mid)add(ans,ask(cl[me],l,mid,x,y));
	if(y>mid)add(ans,ask(cr[me],mid+1,r,x,y));
	//if(l==1&&r==n)printf("ask %d %d %d\n",x,y,ans*1ll*Pow(sqrt5,P-2)%P);
	return ans;
}
void touadd(int &me,int l,int r,int x,int y,int stk){
	//if(l==1&&r==n)printf("tou %d %d %d\n",x,y,stk);
	++segtot;
	//if(segtot>100000*300)for(;;);
	tag1[segtot]=tag1[me];
	tag2[segtot]=tag2[me];
	tag3[segtot]=tag3[me];
	tag4[segtot]=tag4[me];
	sum[segtot]=sum[me];
	val[segtot]=val[me];
	cl[segtot]=cl[me];
	cr[segtot]=cr[me];
	me=segtot;
	if(x<=l&&r<=y){
		add(tag1[me],po1[stk+l-x]);
		add(val[me],po1[stk+l-x]*1ll*sum1[r-l]%P);
		add(tag3[me],po2[stk+l-x]);
		add(val[me],(P-po2[stk+l-x])*1ll*sum2[r-l]%P);
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)touadd(cl[me],l,mid,x,y,stk);
	if(y>mid)touadd(cr[me],mid+1,r,x,y,stk);
	sum[me]=sum[cl[me]];
	add(sum[me],sum[cr[me]]);
	add(sum[me],val[cl[me]]);
	add(sum[me],val[cr[me]]);
}
void weiadd(int &me,int l,int r,int x,int y,int stk){
	//if(x!=1)return;
	//if(l==1&&r==n)printf("wei %d %d %d\n",x,y,stk);
	++segtot;
	//if(segtot>100000*300)for(;;);
	tag1[segtot]=tag1[me];
	tag2[segtot]=tag2[me];
	tag3[segtot]=tag3[me];
	tag4[segtot]=tag4[me];
	sum[segtot]=sum[me];
	val[segtot]=val[me];
	cl[segtot]=cl[me];
	cr[segtot]=cr[me];
	me=segtot;
	if(x<=l&&r<=y){
		add(tag2[me],po1[stk+y-r]);
		add(val[me],po1[stk+y-r]*1ll*sum1[r-l]%P);
		add(tag4[me],po2[stk+y-r]);
		add(val[me],(P-po2[stk+y-r])*1ll*sum2[r-l]%P);
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)weiadd(cl[me],l,mid,x,y,stk);
	if(y>mid)weiadd(cr[me],mid+1,r,x,y,stk);
	sum[me]=sum[cl[me]];
	add(sum[me],sum[cr[me]]);
	add(sum[me],val[cl[me]]);
	add(sum[me],val[cr[me]]);
}
inline int Getsum(int l,int r){
	if(l>r)return 0;
	return ask(root[tim],1,n,l,r);
}
//----------end Segment Tree
//---------begin slpf
int f[17][N];
int head[N],p[N*2],np[N*2],tot;
int st[N],ed[N];int dfntot;
int size[N],fa[N];
int fatson[N];
int bel[N],dep[N],top[N];
int ltot;
void dfs(int x){
	size[x]=1;dep[x]=dep[fa[x]]+1;
	for(int u=head[x];u;u=np[u])if(p[u]^fa[x]){
		int y=p[u];
		fa[p[u]]=x;
		dfs(y);
		size[x]+=size[y];
		if(size[fatson[x]]<size[y])fatson[x]=y;
	}
	if(size[x]==1){
		bel[x]=++ltot;
	}
	else{
		for(int u=head[x];u;u=np[u])if(fa[p[u]]==x){
			if(p[u]==fatson[x]){
				bel[x]=bel[p[u]];
			}
			else{
				top[bel[p[u]]]=p[u];
			}
		}
	}
}
void dd(int x){
	st[x]=++dfntot;
	if(size[x]==1){
		ed[x]=st[x];
		return;
	}
	dd(fatson[x]);
	for(int u=head[x];u;u=np[u])if(fa[p[u]]==x&&p[u]!=fatson[x])
	dd(p[u]);
	ed[x]=dfntot;
}
inline int lca(int x,int y){
	while(1){
		if(bel[x]==bel[y]){
			if(dep[x]>dep[y])return y;
			else return x;
		}
		if(dep[top[bel[x]]]>dep[top[bel[y]]]){
			x=fa[top[bel[x]]];
		}
		else{
			y=fa[top[bel[y]]];
		}
	}
}
int getff(int x,int dp){
	int u=dep[x]-dp;
	per(i,16,0)if((1<<i)&u)x=f[i][x];
	return x;
}
int GetChain(int x,int y){
	int ans=0;int _x=x;int _y=y;
	//printf("%d %d %d\n",_x,_y,ans*1ll*Pow(sqrt5,P-2)%P);
	while(1){
		if(bel[x]==bel[y]){
			add(ans,Getsum(st[y],st[x]));
			break;
		}
		if(dep[top[bel[x]]]>dep[top[bel[y]]]){
			add(ans,Getsum(st[top[bel[x]]],st[x]));
			x=fa[top[bel[x]]];
		}
		else{
			add(ans,Getsum(st[top[bel[y]]],st[y]));
			y=fa[top[bel[y]]];
		}
	}
	//printf("%d %d %d\n",_x,_y,ans*1ll*Pow(sqrt5,P-2)%P);
	return ans;
}
void Zheng(int x,int y){
	int tou=1;
	while(1){
		if(bel[x]==bel[y]){
			weiadd(root[tim],1,n,st[y],st[x],tou);
			break;
		}
		weiadd(root[tim],1,n,st[top[bel[x]]],st[x],tou);
		tou+=dep[x]-dep[fa[top[bel[x]]]];
		x=fa[top[bel[x]]];
	}
}
void Fan(int x,int y,int stk){
	int tou=stk;
	while(1){
		if(bel[x]==bel[y]){
			touadd(root[tim],1,n,st[y],st[x],stk-(dep[x]-dep[y]));
			break;
		}
		touadd(root[tim],1,n,st[top[bel[x]]],st[x],stk-(dep[x]-dep[top[bel[x]]]));
		stk-=(dep[x]-dep[fa[top[bel[x]]]]);
		x=fa[top[bel[x]]];
	}
}
//---------end slpf
int main(){
	read(n);read(Q);
	
	po1[0]=1;
	int bb=(1+sqrt5)*1ll*inv2%P;
	rep(i,1,n)po1[i]=po1[i-1]*1ll*bb%P;
	sum1[0]=1;rep(i,1,n)sum1[i]=(sum1[i-1]+po1[i])%P;
	
	po2[0]=1;
	bb=(P+1-sqrt5)*1ll*inv2%P;
	rep(i,1,n)po2[i]=po2[i-1]*1ll*bb%P;
	sum2[0]=1;rep(i,1,n)sum2[i]=(sum2[i-1]+po2[i])%P;
	
	rep(i,1,n-1){
		int x,y;read(x);read(y);
		++tot;p[tot]=y;np[tot]=head[x];head[x]=tot;
		++tot;p[tot]=x;np[tot]=head[y];head[y]=tot;
	}
	dfs(1);
	dd(1);
	rep(i,1,n)f[0][i]=fa[i];
	rep(j,1,16)rep(i,1,n)f[j][i]=f[j-1][f[j-1][i]];
	int lastans=0;
	//rep(i,1,n)printf("%d %d %d\n",i,st[i],ed[i]);
	for(tim=1;tim<=Q;tim++){
		root[tim]=root[pre];
		char opt[6];scanf("%s",opt+1);
		if(opt[1]!='R')pre=tim;
		if(opt[1]=='A'){
			int x,y;scanf("%d%d",&x,&y);
			
			x^=lastans;
			
			int lp=lca(x,y);
			Zheng(x,lp);
			if(lp!=y)
			Fan(y,getff(y,dep[lp]+1),dep[x]+dep[y]-2*dep[lp]+1);
		}
		if(opt[1]=='R'){
			
			int x;scanf("%d",&x);
			
			x^=lastans;
			
			pre=x;root[tim]=root[pre];pre=tim;
		}
		if(opt[1]=='Q'&&opt[2]=='S'){
			int x,y;scanf("%d%d",&x,&y);
			
			x^=lastans;
			
			if(x==y){
				lastans=Getsum(1,n);
				lastans=lastans*1ll*Pow(sqrt5,P-2)%P;
				printf("%d\n",lastans);
				continue;
			}
			if(st[y]<=st[x]&&ed[x]<=ed[y]){
				int xx=getff(x,dep[y]+1);
				//printf("___%d\n",xx);
				lastans=Getsum(1,st[xx]-1)+Getsum(ed[xx]+1,dfntot);
				if(lastans>=P)lastans-=P;
				lastans=lastans*1ll*Pow(sqrt5,P-2)%P;
				printf("%d\n",lastans);
				continue;
			}
			else{
				lastans=Getsum(st[y],ed[y]);
				lastans=lastans*1ll*Pow(sqrt5,P-2)%P;
				printf("%d\n",lastans);
				continue;
			}
		}
		if(opt[1]=='Q'&&opt[2]=='C'){
			int x,y;scanf("%d%d",&x,&y);
			
			x^=lastans;
			
			
			int lp=lca(x,y);
			lastans=GetChain(x,lp);
			if(y^lp){
				lastans+=GetChain(y,getff(y,dep[lp]+1));
			}
			if(lastans>=P)lastans-=P;
			lastans=lastans*1ll*Pow(sqrt5,P-2)%P;
			printf("%d\n",lastans);
		}
	}
	return 0;
}
