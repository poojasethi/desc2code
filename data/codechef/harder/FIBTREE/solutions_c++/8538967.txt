#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#include <ctime>
using namespace std;
typedef unsigned long long LL;
const int Maxn=100005,mod=1000000009,g=383008016;//g=sqrt(5)
const int invg=276601605,inv2=(mod+1)/2,inv2g=LL(inv2)*invg%mod;
const int cx=LL(mod+3-g)*inv2g%mod,cy=LL(g-1)*inv2g%mod,
		dx=LL(mod*2-3-g)*inv2g%mod,dy=LL(g+1)*inv2g%mod,
		x1=LL(g+1)*inv2%mod,x2=LL(mod+1-g)*inv2%mod;
int n,m,ans=0,now;
int head[Maxn],next[Maxn*2],to[Maxn*2],En=0;
int fa[Maxn][20],depth[Maxn],lv[Maxn],top[Maxn],in[Maxn],ou[Maxn];
int fib[Maxn],px1[Maxn],px2[Maxn],sumx1[Maxn],sumx2[Maxn];

inline int get() {
	char ch;
	while (!isdigit(ch=getchar()));
	int v=ch-48;
	while (isdigit(ch=getchar())) v=v*10+ch-48;
	return v;
}

void build() {
	static int Q[Maxn],size[Maxn],w[Maxn],ne[Maxn*2];
	int l=1,r=2;
	depth[Q[1]=1]=1;
	while (l<r) {
		int x=Q[l++];
		ne[x<<1]=x<<1|1;
		for (int k=0;fa[fa[x][k]][k]!=0;k++)
			fa[x][lv[x]=k+1]=fa[fa[x][k]][k];
		for (int k=head[x];k;k=next[k])
			if (fa[x][0]!=to[k]) {
				Q[r++]=to[k];
				fa[to[k]][0]=x;
				depth[to[k]]=depth[x]+1;
			}
	}
	for (int i=n,x=Q[i];i>1;x=Q[--i]) {
		size[fa[x][0]]+=++size[x];
		if (size[w[fa[x][0]]]<size[x])
			w[fa[x][0]]=x;
	}
	for (int i=1,x=Q[i];i<=n;x=Q[++i]) {
		if (!top[x]) top[x]=x;
		for (int k=head[x];k;k=next[k])
			if (fa[x][0]!=to[k]&&w[x]!=to[k]) {
				ne[to[k]<<1|1]=ne[x<<1];
				ne[x<<1]=to[k]<<1;
			}
		if (w[x]) {
			top[w[x]]=top[x];
			ne[w[x]<<1|1]=ne[x<<1];
			ne[x<<1]=w[x]<<1;
		}
	}
	for (int p=2,tot=0;p;p=ne[p])
		if (p&1) ou[p>>1]=tot;
		else in[p>>1]=++tot;
	fib[1]=fib[2]=1;
	for (int i=3;i<=n+1;i++)
		fib[i]=(fib[i-1]+fib[i-2])%mod;
	px1[0]=px2[0]=1;
	for (int i=1;i<=n;i++) {
		px1[i]=LL(px1[i-1])*x1%mod;
		sumx1[i]=(sumx1[i-1]+px1[i])%mod;
		px2[i]=LL(px2[i-1])*x2%mod;
		sumx2[i]=(sumx2[i-1]+px2[i])%mod;
	}
}

struct node;
node *NewNode(node *p);

inline void GetFib(int a,int b,int len,int &x,int &y) {
	int c=(LL(a)*cx+LL(b)*cy)%mod,
		d=(LL(a)*dx+LL(b)*dy)%mod;
	x=(LL(c)*px1[len+1]+LL(d)*px2[len+1])%mod;
	y=(LL(c)*px1[len+2]+LL(d)*px2[len+2])%mod;
}

inline int GetSum(int a,int b,int len) {
	int c=(LL(a)*cx+LL(b)*cy)%mod,
		d=(LL(a)*dx+LL(b)*dy)%mod;
	return (LL(c)*sumx1[len]+LL(d)*sumx2[len])%mod;
}

struct node{
	node *lc,*rc;
	int lx,ly,rx,ry,sum,tag;
	void addl(int x,int y,int len) {
		if ((lx+=x)>=mod) lx-=mod;
		if ((ly+=y)>=mod) ly-=mod;
		if ((sum+=GetSum(x,y,len))>=mod) sum-=mod;
	}
	void addr(int x,int y,int len) {
		if ((rx+=x)>=mod) rx-=mod;
		if ((ry+=y)>=mod) ry-=mod;
		if ((sum+=GetSum(x,y,len))>=mod) sum-=mod;
	}
	void update() {
		sum=lc->sum+rc->sum;
		if (sum>=mod) sum-=mod;
	}
	void PushDown(int l,int r) {
		if (lx==0&&ly==0&&rx==0&&ry==0) return;
		lc=NewNode(lc);
		rc=NewNode(rc);
		int mid=(l+r)>>1,tx,ty;
		if (lx||ly) {
			lc->addl(lx,ly,mid-l+1);
			GetFib(lx,ly,mid-l+1,tx,ty);
			rc->addl(tx,ty,r-mid);
			lx=ly=0;
		}
		if (rx||ry) {
			rc->addr(rx,ry,r-mid);
			GetFib(rx,ry,r-mid,tx,ty);
			lc->addr(tx,ty,mid-l+1);
			rx=ry=0;
		}
	}
}Po,*pn,*null;

node *NewNode(node *p=&Po) {
	if (p->tag==now) return p;
	static const int N=100000;
	if (!pn) {
		pn=new node[N];
		for (int i=0;i+1<N;i++)
			(pn+i)->lc=pn+i+1;
	}
	node *ret=pn;
	pn=pn->lc;
	*ret=*p;
	ret->tag=now;
	return ret;
}

class SegmentTree{
	node *root;
	int ret;
	node *modify(node *o,int l,int r,int s,int t,int x,int y,bool f) {//f true->right false->left
		node *p=NewNode(o);
		if (s==l&&t==r) {
			if (f) p->addr(x,y,r-l+1);
			else p->addl(x,y,r-l+1);
			return p;
		}
		p->PushDown(l,r);
		int mid=(l+r)>>1;
		if (t<=mid) p->lc=modify(p->lc,l,mid,s,t,x,y,f);
		else if (s>mid) p->rc=modify(p->rc,mid+1,r,s,t,x,y,f);
		else {
			int x0,y0,x1,y1;
			if (f) {
				x1=x; y1=y;
				GetFib(x,y,t-mid,x0,y0);
			}
			else {
				x0=x; y0=y;
				GetFib(x,y,mid-s+1,x1,y1);
			}
			p->lc=modify(p->lc,l,mid,s,mid,x0,y0,f);
			p->rc=modify(p->rc,mid+1,r,mid+1,t,x1,y1,f);
		}
		p->update();
		return p;
	}
	node *query(node *o,int l,int r,int s,int t) {
		if (s<=l&&t>=r) {
			if ((ret+=o->sum)>=mod) ret-=mod;
			return o;
		}
		node *p=NewNode(o);
		p->PushDown(l,r);
		int mid=(l+r)>>1;
		if (s<=mid) p->lc=query(p->lc,l,mid,s,t);
		if (t>mid) p->rc=query(p->rc,mid+1,r,s,t);
		return p;
	}
	public:
		void build() {
			Po.tag=-1;
			null=NewNode();
			null->lc=null->rc=null;
			root=null;
		}
		void modify(int s,int t,int x,int y,bool f) {
			root=modify(root,1,n,s,t,x,y,f);
		}
		int query(int s,int t) {
			ret=0;
			root=query(root,1,n,s,t);
			return ret;
		}
}T[Maxn];

int Lca(int u,int v) {
	while (top[u]!=top[v])
		if (depth[top[u]]>depth[top[v]]) u=fa[top[u]][0];
		else v=fa[top[v]][0];
	return depth[u]<depth[v]?u:v;
}

void Modify(int x,int y) {
	int z=Lca(x,y),s=1,t=depth[x]+depth[y]-2*depth[z]+1;
	while (top[x]!=top[z]) {
		T[now].modify(in[top[x]],in[x],fib[s],fib[s+1],true);
		s+=depth[x]-depth[top[x]]+1;
		x=fa[top[x]][0];
	}
	T[now].modify(in[z],in[x],fib[s],fib[s+1],true);
	while (top[y]!=top[z]) {
		t-=depth[y]-depth[top[y]]+1;
		T[now].modify(in[top[y]],in[y],fib[t+1],fib[t+2],false);
		y=fa[top[y]][0];
	}
	if (y!=z) {
		t-=depth[y]-depth[z];
		T[now].modify(in[z]+1,in[y],fib[t+1],fib[t+2],false);
	}
}

int KthParent(int x,int k) {
	for (int i=0;k;i++,k>>=1)
		if (k&1)
			x=fa[x][i];
	return x;
}

void QuerySubtree(int x,int y) {
	ans=0;
	if (x==y) ans=T[now].query(1,n);
	else {
		if (in[y]<=in[x]&&ou[y]>=in[x]) {
			x=KthParent(x,depth[x]-depth[y]-1);
			ans=(T[now].query(1,n)-T[now].query(in[x],ou[x])+mod)%mod;
		}
		else ans=T[now].query(in[y],ou[y]);
	}
	printf("%d\n",ans);
}

void QueryChain(int x,int y) {
	ans=0;
	while (top[x]!=top[y]) {
		if (depth[top[x]]>depth[top[y]]) {
			ans=(ans+T[now].query(in[top[x]],in[x]))%mod;
			x=fa[top[x]][0];
		}
		else {
			ans=(ans+T[now].query(in[top[y]],in[y]))%mod;
			y=fa[top[y]][0];
		}
	}
	if (depth[x]>depth[y]) swap(x,y);
	ans=(ans+T[now].query(in[x],in[y]))%mod;
	printf("%d\n",ans);
}

int main() {
	n=get(); m=get();
	for (int i=1,x,y;i<n;i++) {
		x=get(); y=get();
		next[++En]=head[x]; head[x]=En; to[En]=y;
		next[++En]=head[y]; head[y]=En; to[En]=x;
	}
	build();
	T[0].build();
	for (now=1;now<=m;now++) {
		char opx;
		while (!isupper(opx=getchar()));
		if (opx=='Q') opx=getchar();
		int x=get()^ans,y=opx=='R'?0:get();
		T[now]=T[now-1];
		if (opx=='A') Modify(x,y);
		if (opx=='S') QuerySubtree(x,y);
		if (opx=='C') QueryChain(x,y);
		if (opx=='R') T[now]=T[x];
	}
	return 0;
}
