#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
const int ljz = 1000000009;
int mul(int x, int y){long long a = x, b = y; return (a * b) % ljz;}
void MOD(int &x){if (x >= ljz) x -= ljz; if (x < 0) x += ljz;}
 
void gi(int &x){char ch = getchar(); x = 0; while (ch < '0' || ch > '9') ch = getchar(); while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();}
void pi(int x){if (x > 9) pi(x / 10); putchar(x % 10 + 48);}
 
int F[202020];
int kth(int f1, int f2, int k)
{if(k==1)return f1;int a=mul(F[k - 2], f1)+mul(F[k - 1], f2); MOD(a); return a;}
int SUM(int f1, int f2, int k)
{int a = mul(F[k], f1) + mul(F[k + 1] - 1, f2); MOD(a); return a;}
 
const int sz0 = 30000000;
//ä¸�è¦�æ�³äº�ï¼�9.29ä¹�å��ccä¸�ç©ºé�´æ��å°�ç��é�½æ�¯550M
int sum[sz0], f1[sz0], f2[sz0], g1[sz0], g2[sz0], l[sz0], r[sz0], N;
int copy(int x){N++; f1[N] = f1[x]; f2[N] = f2[x]; g1[N] = g1[x]; g2[N] = g2[x]; l[N] = l[x]; r[N] = r[x]; sum[N] = sum[x]; return N;}
 
void pushdown(int x, int xl, int xr){
  if (f1[x] == 0 && f2[x] == 0 && g1[x] == 0 && g2[x] == 0) return;
  int xm = (xl + xr) >> 1, F1 = f1[x], F2 = f2[x];
  l[x] = copy(l[x]); r[x] = copy(r[x]);
  MOD(f1[l[x]] += f1[x]); MOD(f2[l[x]] += f2[x]);
  MOD(sum[l[x]] += SUM(f1[x], f2[x], xm - xl + 1));
  f1[x] = kth(F1, F2, xm - xl + 2); f2[x] = kth(F1, F2, xm - xl + 3);
  MOD(f1[r[x]] += f1[x]); MOD(f2[r[x]] += f2[x]);
  MOD(sum[r[x]] += SUM(f1[x], f2[x], xr - xm));
 
  F1 = g1[x]; F2 = g2[x];
  MOD(g1[r[x]] += g1[x]); MOD(g2[r[x]] += g2[x]);
  MOD(sum[r[x]] += SUM(g1[x], g2[x], xr - xm));
  g1[x] = kth(F1, F2, xr - xm + 1); g2[x] = kth(F1, F2, xr - xm + 2);
  MOD(g1[l[x]] += g1[x]); MOD(g2[l[x]] += g2[x]);
  MOD(sum[l[x]] += SUM(g1[x], g2[x], xm - xl + 1));
  f1[x] = f2[x] = g1[x] = g2[x] = 0;
}
 
int add(int x, int xl, int xr, int L, int R, int F1, int F2, int G1, int G2){
  int xm = (xl + xr) >> 1;
  if (L > xr || R < xl) return x;
  if (L < xl) L = xl; if (R > xr) R = xr;
  int n = copy(x), t1, t2;
  if (L <= xl && R >= xr){
    MOD(f1[n] += F1); MOD(f2[n] += F2);
    MOD(g1[n] += G1); MOD(g2[n] += G2);
    MOD(sum[n] += SUM(F1, F2, xr - xl + 1));
    MOD(sum[n] += SUM(G1, G2, xr - xl + 1));
  } else {
    if (L <= xm || R >= xl){
      t1 = kth(G1, G2, max(0, R - xm) + 1);
      t2 = kth(G1, G2, max(0, R - xm) + 2);
      l[n] = add(l[x], xl, xm, L, R, F1, F2, t1, t2);
    }
    if (L <= xr || R > xm){
      t1 = kth(F1, F2, max(-1, xm - L) + 2);
      t2 = kth(F1, F2, max(-1, xm - L) + 3);
      r[n] = add(r[x], xm + 1, xr, L, R, t1, t2, G1, G2);
    }
    MOD(sum[n] = sum[l[n]] + sum[r[n]]);
    MOD(sum[n] += SUM(f1[n] + g1[n], f2[n] + g2[n], xr - xl + 1));
  }
  return n;
}
 
int Sum(int x, int xl, int xr, int L, int R){
  int xm = (xl + xr) >> 1, s;
  if (L > xr || R < xl) return 0;
  if (L <= xl && R >= xr) return sum[x];
  pushdown(x, xl, xr);
  MOD(s = Sum(l[x], xl, xm, L, R) + Sum(r[x], xm + 1, xr, L, R)); return s;
}
 
const int sz = 202020;
int node[sz], next[sz], to[sz], e;
int n, m;
void ins(int x, int y){e++; next[e] = node[x]; node[x] = e; to[e] = y;}
 
int q[sz], par[sz], siz[sz], pfc[sz], dep[sz];
void bfs(){
  int i, j, k, l, r;
  q[l = r = 1] = 1;
  while (l <= r){
    k = q[l++];
    for (j = node[k]; j; j = next[j])
      if (par[k] != to[j]){
	par[q[++r] = to[j]] = k;
	dep[to[j]] = dep[k] + 1;
      }
  }
 
  for (i = n; i; i--){
    k = q[i]; siz[k] = 1;
    for (j = node[k]; j; j = next[j])
      if (par[k] != to[j]){
	siz[k] += siz[to[j]];
	if (siz[to[j]] > siz[pfc[k]])
	  pfc[k] = to[j];
      }
  }
}
 
int sta[sz], R[sz], tp[sz], seq[sz], pos[sz], ir[sz], ff[sz], I, top;
void ens(int x){sta[++top] = x; R[x] = node[x]; seq[pos[x] = ++I] = x;}
void dfs(){
  int i, j, k;
  ens(1); tp[1] = 1;
  while (top){
    k = sta[top];
    if (R[k] == 0){ir[k] = I; top--;}
    else if (pfc[k] && !ff[k]){
      ff[k] = 1; tp[pfc[k]] = tp[k]; ens(pfc[k]);
    } else{
      i = to[R[k]]; R[k] = next[R[k]];
      if (i != pfc[k] && i != par[k]){ens(i); tp[i] = i;}
    }
  }
}
 
void init(){
  int i, x, y;
  gi(n); gi(m);
  for (i = 1; i < n; i++){gi(x); gi(y); ins(x, y); ins(y, x);}
  bfs(); dfs();
}
 
int nodecnt(int x, int y){
  int s = dep[x] + dep[y];
  while (tp[x] != tp[y])
    if (dep[tp[x]] >= dep[tp[y]]) x = par[tp[x]]; else y = par[tp[y]];
  if (dep[x] < dep[y]) y = x; return s - dep[y] - dep[y] + 1;
}
 
int root[sz], cur, tot;
void A(int x, int y){
  int px = 1, py = nodecnt(x, y), t1, t2, l;
  root[tot + 1] = root[cur]; cur = ++tot;
  while (tp[x] != tp[y])
    if (dep[tp[x]] >= dep[tp[y]]){
      root[cur] = add(root[cur], 1, n, pos[tp[x]], pos[x], 0, 0, F[px], F[px + 1]);
      px += (pos[x] - pos[tp[x]] + 1);
      x = par[tp[x]];
    } else {
      py -= (pos[y] - pos[tp[y]] + 1);
      root[cur] = add(root[cur], 1, n, pos[tp[y]], pos[y], F[py + 1], F[py + 2], 0, 0);
      y = par[tp[y]];
    }
  if (dep[x] >= dep[y]) root[cur] = add(root[cur], 1, n, pos[y], pos[x], 0, 0, F[px], F[px + 1]);
  else{
    py -= (pos[y] - pos[x] + 1);
    root[cur] = add(root[cur], 1, n, pos[x], pos[y], F[py + 1], F[py + 2], 0, 0);
  }
}
 
int QS(int x, int y){
  root[tot + 1] = root[cur]; cur = ++tot;
  if (x == y) return sum[root[cur]];
  else if (pos[x] >= pos[y] && pos[x] <= ir[y]){
    while (dep[tp[x]] > dep[y] + 1) x = par[tp[x]]; x = tp[x];
    if (dep[x] <= dep[y]) x = pfc[y];
    MOD(x = sum[root[cur]] - Sum(root[cur], 1, n, pos[x], ir[x]));
    return x;
  } else return Sum(root[cur], 1, n, pos[y], ir[y]);
}
 
int QC(int x, int y){
  int s = 0;
  root[tot + 1] = root[cur]; cur = ++tot;
  while (tp[x] != tp[y])
    if (dep[tp[x]] >= dep[tp[y]]){
      MOD(s += Sum(root[cur], 1, n, pos[tp[x]], pos[x]));
      x = par[tp[x]];
    } else {
      MOD(s += Sum(root[cur], 1, n, pos[tp[y]], pos[y]));
      y = par[tp[y]];
    }
  if (dep[x] < dep[y]) swap(x, y);
  MOD(s += Sum(root[cur], 1, n, pos[y], pos[x]));
  return s;
}
 
int la = 0, online = 1;
char c;
int main(){
  int i, x, y;
  init();
  for (F[1] = F[2] = 1, i = 3; i <= n + 2; i++) MOD(F[i] = F[i - 1] + F[i - 2]);
  while (m--){
    do c = getchar(); while (c < 'A' || c > 'Z');
    if (c == 'Q') c = getchar();
    gi(x); if (online) x ^= la;
    if (c != 'R') gi(y);
    if (c == 'A') A(x, y);
    else if (c == 'S') pi(la = QS(x, y)), putchar('\n');
    else if (c == 'C') pi(la = QC(x, y)), putchar('\n');
    else root[cur = ++tot] = root[x];
  }
  return 0;
}