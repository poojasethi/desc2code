#include<iostream>
#include<vector>
#include<algorithm>
#include<set>
using namespace std;

struct Edge {
  int x, y, w;
};

struct Graph { // directed
  vector<int> adj[1000];
  Edge e[20000];
  int ne;
  
  void init(int _n) {
    int i;
    
    for (i = 0; i < _n; i ++) adj[i].clear();
    ne = 0;
  }
  
  void ae(int _x, int _y, int _w) {
    e[ne].x = _x; e[ne].y = _y; e[ne].w = _w;
    adj[_x].push_back(ne);
    ne ++;
  }
} g;

int n, m;
vector<int> C;
int f[500], d[1000], pre[1000];

void dijkstra(int s, int t) {
  int x, y, dist;
  vector<int>::iterator it; Edge edge;
  set<pair<int, int> > heap;
  
  fill(d,    d    + 2 * n, 1000000000);
  fill(pre,  pre  + 2 * n, -1);
  d[s] = 0;
  heap.insert(make_pair(0, s));
  while (!heap.empty()) {
    x = (*heap.begin()).second;
    heap.erase(heap.begin());
    if (x == t || d[x] >= 1000) break;
    for (it = g.adj[x].begin(); it != g.adj[x].end(); it ++) {
      edge = g.e[*it];
      y = edge.y, dist = d[x] + edge.w;
      if (dist < d[y]) {
        heap.erase (make_pair(d[y], y));
        d[y] = dist; pre[y] = x;
        heap.insert(make_pair(d[y], y));
      }
    }
  }
}

void simplify() {
  int a, b, l, sz;
  static int fst[10000];
  
  fill(fst, fst + n, -1);
  sz = C.size();
  for (b = 0; b < sz; b ++) {
    a = fst[C[b]];
    if (a == -1) fst[C[b]] = b;
    else {
      l = b - a;
      C.erase(C.begin(),     C.begin() + a);
      C.erase(C.begin() + l, C.end());
      break;
    }
  }
}

bool solve() {
  int i, j, x, y, w;
  double tmp;
  bool wrong;
  
  C.clear();
  cin >> n >> m;
  for (i = 0; i < n; i ++) {
    cin >> tmp;
    f[i] = (int) (tmp * 1000 + 0.5);
  }
  g.init(2 * n);
  wrong = false;
  for (i = 0; i < m; i ++) {
    cin >> x >> y;
    if (f[x] + f[y] > 1000 && !wrong) {
      wrong = true;
      C.push_back(x);
      C.push_back(y);
    }
    if (f[x] && f[y]) {
      w = 1000 - f[x] - f[y];
      g.ae(x,     y + n, w);
      g.ae(y + n, x,     w);
      g.ae(y,     x + n, w);
      g.ae(x + n, y,     w);
    }
  }
  if (wrong) return false;
  for (i = 0; i < n; i ++) {
    dijkstra(i, i + n);
    if (pre[i + n] == -1) continue;
    /**
     * (2k + 1) * 1000 - sum (i=0..2k) [f(v_i) + f(v_{(i + 1) % (2k + 1)})] < 1000
     * <=>
     * (2k + 1) * 1000 - 2 * sum (i=0..2k) [f(v_i)] < 1000
     * <=>
     * sum(i=0..2k) [f(v_i)] > k * 1000
     */
    if (d[i + n] >= 1000) continue;
    j = i + n; while (j != i) C.push_back(j % n), j = pre[j];
    simplify();
    return false;
  }
  return true;
}

int main() {
  int t;
  vector<int>::iterator it;
  
  C = vector<int>();
  cin >> t;
  while (t --) {
    bool ok = solve();
    if (ok) cout << "Ok" << endl;
    else {
      cout << "Bad Cycle:";
      for (it = C.begin(); it != C.end(); it ++) cout << " " << *it;
      cout << " -1" << endl;
    }
  }
}
