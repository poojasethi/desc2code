#include<cstdio>
#include<cassert>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
const db pi=acos(-1);
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
const int inf=1061109567;
//const ll inf=1000000000000000000ll;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
#define x1 x192837465
#define x2 x123456789
#define y1 y192837465
#define y2 y123456789
void upd(int &a,int b){a=(a+b)%mo;}
int ans;
int n,lmi,x,k,l;


int col[6];
int tms[6];

int dom(int h){
	if(h==0)return qp(120,mo-2);
	if(h==1)return qp(6,mo-2);
	if(h==2)return qp(2,mo-2);
	if(h==3)return qp(2,mo-2);
	return 1;
}
int has(int *tms){
	if(tms[5]==1)return 0;
	if(tms[1]==1 && tms[4]==2)return 1;
	if(tms[1]==1 && tms[3]==2 && tms[2]==2)return 2;
	if(tms[1]==1 && tms[3]==3)return 3;
	if(tms[1]==2 && tms[2]==3)return 4;
	if(tms[1]==1 && tms[2]==4)return 5;
	return 6;
}
map<int,int>ma;
map<int,int>maa[111];

int f(ll n,int h) {
	if(h==0){
		int an=1;
		for (int i=5;i>=1;i--)an=1ll*an*(n+i)%mo;
		an=1ll*an*qp(120,mo-2)%mo;
		return an;
	}else if(h==1){
		return (1ll*(n+1)*(n+3)%mo*(n+3)%mo*(n+5)+(n%2==0)*3)%mo*qp(48,mo-2)%mo;
	}else if(h==2){
		return (1ll*(n+1)*(n+3)%mo*(n+5)+(n%2==0)*3ll*(n+3))%mo*qp(24,mo-2)%mo;
	}else if(h==3){
		return (1ll*(n+1)*(n+4)%mo*(n+4)+(n+1ll)%3*2)%mo*qp(18,mo-2)%mo;
	}else if(h==4){
		return (1ll*(n+1)*(n+5)+(n%2==0)*3ll+(n%3==0)*4ll)%mo*qp(12,mo-2)%mo;
	}else if(h==5){
		return (n/4ll+1ll)*(n+1ll-n/4ll*2ll)%mo;
	}else{
		return n/5+1;
	}
}
int doit(int cm,int id){
	int ans=0;
	for (int i=0;i<(1<<cm);i++){
		ll up=l;
		int sg=1;
		for (int j=0;j<cm;j++)if(1<<j&i){
			up-=1ll*x*tms[j+1];
			sg*=-1;
		}
		if(up+1>=6)upd(ans,sg*f(up+1-6,id));
	}
	return (ans+mo)%mo;
}
int calc(int cm,int ii){
	memset(tms,0,sizeof(tms));
	for (int i=1;i<=5;i++)tms[col[i]]++;
	sort(tms+1,tms+1+cm);
	int h=has(tms);
	if(maa[ii].find(h)!=maa[ii].end())return maa[ii][h];
	else return maa[ii][h]=doit(cm,h);
}
int nei[1111][6],an[1111];int tot;
int ff[1111];

int ok(int i,int j){
	for (int k=1;k<=5;k++)
		for (int l=k+1;l<=5;l++)if(nei[i][k]==nei[i][l] && nei[j][k]!=nei[j][l]){
			return 0;
		}
	return 1;
}
int F(int i){
	if(~ff[i])return ff[i];
	int ans=an[i];
	for (int j=1;j<=tot;j++)if(i!=j && ok(i,j)){
		ans=(ans-F(j)+mo)%mo;
	}
	return ff[i]=ans;
}

void dfs(int i,int cm){
	if(i==6){
		++tot;
		int f;
		
		for (l=lmi;l<=n;l++){
			f=calc(cm,l-lmi);
			f=((qp(x,cm)-f)%mo+mo)%mo;
			upd(an[tot],f);
		}

		for (int j=1;j<=5;j++)nei[tot][j]=col[j];
		return;
	}
	for (int j=1;j<=cm;j++){
		col[i]=j;
		dfs(i+1,cm);
	}
	col[i]=cm+1;
	dfs(i+1,cm+1);
}
int work(){
	tot=0;
	dfs(1,0);
	for (int i=1;i<=tot;i++)ff[i]=-1;
	for (int i=1;i<=tot;i++)F(i);
	int ans=0;
	ma.clear();
	for (int i=1;i<=tot;i++){
		int bo=1;
		int cm=0;
		for (int j=1;j<5;j++)if(nei[i][j]>nei[i][j+1]){
			bo=0;
			break;
		}
		if(!bo)continue;
		memset(tms,0,sizeof(tms));
		for (int j=1;j<=5;j++)cm=max(cm,nei[i][j]),tms[nei[i][j]]++;
		sort(tms+1,tms+1+cm);
		if(tms[cm]>k)continue;
		int h=has(tms);
		if(ma.find(h)!=ma.end())continue;
		ma[h]=1;
		ans=(ans+1ll*ff[i]*dom(h))%mo;
	}
	return ans;
}
int main()
{
	gn(n);gn(lmi);gn(x);gn(k);
	int ans=work();
	printf("%d\n",(ans+mo)%mo);
	return 0;
}
