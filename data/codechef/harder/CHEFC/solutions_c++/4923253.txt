#include <iostream>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <vector>
#include <queue>
#include <cstdio>
#include <algorithm>
#include <numeric>
#include <climits>
#include <sstream>
#include <cstring>
#include <cassert>
#include <stack>
#include <cmath>
#include <map>
#include <set>
#include <utility>
#include <memory.h>
#include <time.h>
#include <list>
#include <deque>
#include <functional>
#include <iterator>

#define MX 110000
using namespace std;

struct Data {
	int f, l, r;
	int val, sz, ans;
	int mi, ma;
	void clear() {
		f = l = r = 0;
		val = sz = ans = 0;	
	}	
} t[MX];

int ROOT, N, Q;

inline int Getpre(int x) {
	
	x = t[x].l;
	if (x == 0) return x;
	else return t[x].ma;
}

inline int Getnex(int x) {
	x = t[x].r;
	if (x == 0) return x;
	else return t[x].mi;
}

inline int get_root(int x) {
	return t[x].mi;
}

inline void Upd(int x) {
	
	int pl = t[x].l, pr = t[x].r;
	t[x].sz = t[pl].sz + t[pr].sz + 1;
	t[x].ans = t[pl].ans + t[pr].ans;
	int ne = Getnex(x);
	int pe = Getpre(x);
	if (ne && (ne != N + 1) && (t[ne].val != t[x].val)) t[x].ans ++;
	if (pe && (pe != N + 1) && (t[pe].val != t[x].val)) t[x].ans ++;
}

inline void r_rotate(int x) {
	int f = t[x].f, l = t[x].l;
	(t[f].l == x ? (t[f].l) : (t[f].r)) = l; t[l].f = f;
	t[x].l = t[l].r, t[t[x].l].f = x;
	t[l].r = x, t[x].f = l;
	t[l].ma = t[x].ma;
	if (t[x].l == 0) t[x].mi = x;
	else t[x].mi = t[t[x].l].mi;
	Upd(x);
}

inline void l_rotate(int x) {
	int f = t[x].f, r = t[x].r;
	(t[f].l == x ? (t[f].l) : (t[f].r)) = r; t[r].f = f;
	t[x].r = t[r].l, t[t[x].r].f = x;
	t[r].l = x, t[x].f = r;
	t[r].mi = t[x].mi;
	if (t[x].r == 0) t[x].ma = x;
	else t[x].ma = t[t[x].r].ma;
	Upd(x);
}

inline void splay(int x, int rootf) {

	t[0].clear();
	for (; t[x].f != rootf; )
	{
		int f = t[x].f, g = t[f].f;
		if (g == rootf)
			if (t[f].l == x)
				r_rotate(f);
			else
			l_rotate(f);
		else
		if (t[g].l == f)
			if (t[f].l == x)
				r_rotate(g),
				r_rotate(f);
			else
			l_rotate(f),
			r_rotate(g);
		else
		if (t[f].r == x)
			l_rotate(g),
			l_rotate(f);
		else
		r_rotate(f),
		l_rotate(g);
	}
	Upd(x);
	if (!rootf) ROOT = x;
	t[0].clear();
}

int get_pos(int sz) {
	
	int x, root = get_root(ROOT), pr, cnt, v;
	splay(root, 0);
	
	x = root;
	cnt = 0;
	while (1) {
		v = cnt + t[t[x].l].sz + 1;
		if (v == sz) {
			return x;
		} else if (v > sz) {
			x = t[x].l;	
		} else {
			cnt += t[t[x].l].sz + 1;
			x = t[x].r;
		}
	}
}
int calc(int l, int r) {
	
	if (l == r) return 0;
	int pl = get_pos(l);
	splay(pl, 0);
	int pr = get_pos(r);
	splay(pr, pl);

	int ans = 0, x;
	ans += t[t[pr].l].ans;
	x = Getnex(pl);
	if (x && (t[x].val != t[pl].val)) ans ++;
	x = Getpre(pr);
	if (x && (t[x].val != t[pr].val)) ans ++;
	return ans;
}

int main() {
	
//	freopen("3.in", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	int i, k, T;
	for (cin >> T; T --; ) {
		
		scanf("%d", &N);
		t[0].clear(); t[N + 1].clear();
		for (i = 1; i <= N; i ++) {
			t[i].clear();
			scanf("%d", &t[i].val);
			if (i > 1) {
				t[i - 1].r = i;
				t[i].f = i - 1;	
			}
			t[i].sz = N - i + 2;
			t[i].mi = i, t[i].ma = N + 1;
		}
		t[N].r = N + 1;
		t[N + 1].f = N; t[N + 1].sz = 1;

		for (i = N - 1; i >= 1; i --)
			t[i].ans = t[i + 1].ans + (t[i].val != t[i + 1].val);
		
		ROOT = 1;
		int type, l, r;
		for (cin >> Q; Q --; ) {

			scanf("%d", &type);
			if (type == 1) {
				scanf("%d%d", &l, &r);
				printf("%d\n", calc(l, r) + 1);
			} else {
				
				scanf("%d%d", &l, &r);
				if (l == 1) continue;
				int pl = get_pos(l - 1);
				splay(pl, 0);
				int pr = get_pos(r + 1);
				splay(pr, pl);

				int x = t[pr].l;
				t[x].f = 0; t[pr].l = 0;
				splay(pr, 0);

				int root = get_root(ROOT);
				splay(root, 0);
				t[root].l = x; t[x].f = root;
				splay(x, 0);
			}
		}
	}
	return 0;	
}
