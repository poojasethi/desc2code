#include <iostream>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <vector>
#include <queue>
#include <cstdio>
#include <algorithm>
#include <numeric>
#include <climits>
#include <sstream>
#include <cstring>
#include <cassert>
#include <stack>
#include <cmath>
#include <map>
#include <set>
#include <utility>
#include <memory.h>
#include <time.h>
#include <list>
#include <deque>
#include <functional>
#include <iterator>

#define MN 10000
#define ML 400
#define MX 100005
#define rep(i, n) for (int i = 0; i < n; i ++)

using namespace std;

int val[MN], size[MN];
int a[MN][ML + 5];
int N, A[MX], Q, an;
int n;
int ID[ML * 10], NID[ML * 10];
int tot, ntot;

inline void get_val(int id) {
	val[id] = 0;
	rep(i, size[id] - 1) val[id] += a[id][i] != a[id][i + 1];
}

void init() {
	n = tot = 0;
	int i, k;
	for (i = 0; i < N; i += ML) {
		size[n] = 0;
		for (k = 0; k < ML && i + k < N; k ++) a[n][size[n] ++] = A[i + k];
		get_val(n);
		ID[tot ++] = n ++;
	}
	an = 0;
}

inline void get(int v, int &id, int &p) {
	int x;
	rep(i, tot) {
		x = ID[i];
		if (size[x] > v) {
			id = i;	
			p = v;
			return;
		}
		v -= size[x];
	}	
}

inline int get_new() {
	if (an) {
		an --;
		size[A[an]] = 0;
		return A[an];
	}
	size[n] = 0;
	return n ++;
}

void update(int st, int en) {
	int i, nid, id, ids, ide, ps, pe;
	int sum, j, k, t;
	
	get(st, ids, ps);
	get(en, ide, pe);
	
	ntot = 0;
	if (ids == ide) {
		id = ID[ids];
		if (!ps && pe == size[id] - 1) NID[ntot ++] = id;	
		else {
			nid = get_new();
			for (i = ps; i <= pe; i ++) a[nid][size[nid] ++] = a[id][i];
			NID[ntot ++] = nid;
			get_val(nid);
		}
	}
	else {
		id = ID[ids];
		if (!ps) NID[ntot ++] = id;
		else {
			nid = get_new();
			for (i = ps; i < size[id]; i ++) a[nid][size[nid] ++] = a[id][i];
			NID[ntot ++] = nid;
			get_val(nid);
		}
		for (i = ids + 1; i < ide; i ++) NID[ntot ++] = ID[i];
		id = ID[ide];
		if (pe == size[id] - 1) NID[ntot ++] = id;
		else {
			nid = get_new();
			for (i = 0; i <= pe; i ++) a[nid][size[nid] ++] = a[id][i];
			NID[ntot ++] = nid;
			get_val(nid);
		}
	}
	for (i = 0; i < ids; i ++) NID[ntot ++] = ID[i];
	id = ID[ids];
	if (ps) {
		nid = get_new();
		for (i = 0; i < ps; i ++) a[nid][size[nid] ++] = a[id][i];
		NID[ntot ++] = nid;	
		get_val(nid);
	}
	id = ID[ide];
	if (pe < size[id] - 1) {
		nid = get_new();
		for (i = pe + 1; i < size[id]; i ++) a[nid][size[nid] ++] = a[id][i];
		NID[ntot ++] = nid;
		get_val(nid);
	}
	for (i = ide + 1; i < tot; i ++) NID[ntot ++] = ID[i];
	if (ids == ide) {
		id = ID[ids];
		if (ps || pe < size[id] - 1) A[an ++] = id;	
	}
	else {
		id = ID[ids];
		if (ps) A[an ++] = id;
		id = ID[ide];
		if (pe < size[id] - 1) A[an ++] = id;
	}
	tot = 0;
	for (i = 0; i < ntot; i ++) {
		sum = 0;
		for (k = i; k < ntot; k ++) {
			id = NID[k];
			if (sum + size[id] > ML) break;
			sum += size[id];	
		}
		k --;
		if (i == k) {
			ID[tot ++] = NID[i];
			continue;
		}
		nid = get_new();
		val[nid] = 0;
		for (j = i; j <= k; j ++) {
			id = NID[j];
			A[an ++] = id;
			for (t = 0; t < size[id]; t ++) a[nid][size[nid] ++] = a[id][t];	
			val[nid] += val[id];
			if (j > i) val[nid] += a[id][0] != a[NID[j - 1]][size[NID[j - 1]] - 1];
		}
		ID[tot ++] = nid;
		i = k;
	}
}

int find(int st, int en) {
	int i, nid, ids, ide, ps, pe, id, res(0);
	get(st, ids, ps);
	get(en, ide, pe);
	id = ID[ids];
		
	if (ids == ide) {
		for (i = ps; i < pe; i ++) res += a[id][i] != a[id][i + 1];
		return res;	
	}
	for (i = ps; i < size[id] - 1; i ++) res += a[id][i] != a[id][i + 1];
	for (i = ids + 1; i < ide; i ++) {
		nid = ID[i];
		res += a[nid][0] != a[id][size[id] - 1];
		id = nid;	
		res += val[id];
	} 
	nid = ID[ide];
	res += a[nid][0] != a[id][size[id] - 1];
	for (i = 0; i < pe; i ++) res += a[nid][i] != a[nid][i + 1];
	return res;
}

int main() {
	
	int tn;
	cin >> tn;
	
	while (tn --) {
		cin >> N ;
		rep(i, N) scanf("%d", A + i);
		init();
		
		int t, l, r;
		scanf("%d", &Q);
		while (Q --) {
			scanf("%d%d%d", &t, &l, &r);
			l --, r --;
			if (t == 2) update(l, r);
			else {
			 	printf("%d\n", find(l, r) + 1);
			}
		}
	}
	return 0;
}
