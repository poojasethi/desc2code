#include <bits/stdc++.h>
using namespace std;

class Treap{

    struct _node{
        int mini, maxi, resp, val, cnt, pri;
        _node *l, *r;

        _node() {}
        _node(int _val) {
            mini = maxi = val = _val;
            resp = 0;
            cnt = 1;
            pri = (rand()<<16)^rand();
            l = r = NULL;
        }
        ~_node() { delete l; delete r; }

        void refresh() {
            cnt = 1;
            mini = maxi = val;
            resp = 0;
            if (l) {
                cnt += l->cnt;
                mini = l->mini;
                resp += (l->resp);
                if (val == l->maxi) resp++;
            }
            if (r) {
                cnt += r->cnt;
                maxi = r->maxi;
                resp += (r->resp);
                if (val == r->mini) resp++;
            }
        }
    };

    typedef _node* node;

    node root;

    node merge(node l, node r) {
        if (!l) return r;
        if (!r) return l;
        if (l->pri < r->pri) {
            l->r = merge(l->r,r);
            l->refresh();
            return l;
        }
        else {
            r->l = merge(l,r->l);
            r->refresh();
            return r;
        }
    }

    void split(node v, int sobra, node &l, node &r) {
        l = r = NULL;
        if (!v) return;
        node esq = v->l;
        if ((!esq && sobra > 0) || (esq && esq->cnt < sobra)) {
            if (esq) sobra -= esq->cnt;
            sobra--;
            split(v->r,sobra,v->r,r);
            l = v;
        }
        else {
            split(v->l,sobra,l,v->l);
            r = v;
        }
        v->refresh();
    }

    int do_query(node v, int ini, int fim, int x, int y) {
        if (!v || ini > y || fim < x) return 0;
        if (x <= ini && fim <= y) return v->resp;
        node esq = v->l;
        node dir = v->r;
        int resp = 0;
        if (!dir) {
            resp = do_query(esq,ini,fim-1,x,y);
            if (x <= fim-1 && fim <= y) resp += (v->val == esq->maxi);
            return resp;
        }
        if (!esq) {
            resp = do_query(dir,ini+1,fim,x,y);
            if (x <= ini && ini+1 <= y) resp += (v->val == dir->mini);
            return resp;
        }
        int mid = ini+(esq->cnt);
        resp = do_query(esq,ini,mid-1,x,y) + do_query(dir,mid+1,fim,x,y);
        if (x <= mid-1 && mid <= y) resp += (v->val == esq->maxi);
        if (x <= mid && mid+1 <= y) resp += (v->val == dir->mini);
        return resp;
    }

public:
    Treap() { root = NULL; }

    void clear() { root = NULL; }

    int size() {
        if (!root) return 0;
        return root->cnt;
    }

    void insert(int x, int y) {
        node l, r;
        split(root,x-1,l,r);
        root = merge( merge(l, new _node(y)), r );
    }

    void update(int x, int y) {
        node l, m, r;
        split(root,x-1,l,m);
        split(m,y-x+1,m,r);
        root = merge(merge(m,l),r);
    }

    int query(int x, int y) {
        return (y-x+1 - do_query(root,1,size(),x,y));
    }

} treap;

int main() {
    int N, M, T, op, x, y;
    scanf("%d",&T);
    while (T--) {
        treap.clear();
        scanf("%d",&N);
        for (int i=1; i<=N; i++) {
            scanf("%d",&x);
            treap.insert(i,x);
        }
        scanf("%d",&M);
        while (M--) {
            scanf("%d %d %d",&op,&x,&y);
            if (op == 2) treap.update(x,y);
            else printf("%d\n",treap.query(x,y));
        }
    }
    return 0;
}
