#include <set>
#include <map>
#include <vector>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define rep(i,a,b) for (int i=a;i<=b;++i)
#define dep(i,a,b) for (int i=a;i>=b;--i)
#define pb push_back
#define mp make_pair
using namespace std;

const int nn=1100000;
struct pp{
	int p,l,i;
} q[nn];
int n,L,node[nn][2],height[nn],rank[nn],g[nn],sa[nn],other[nn],next[nn],f[nn],sz[nn],ans[nn],c[nn],es;
char s[nn];
vector<int> E[nn];


bool cmpp(int x,int y)
{
  return s[x]<s[y];
}
void suffix(char *S,int L,int *rank,int *sa,int *height)
{
    rep(i,0,L+10) rank[i]=sa[i]=height[i]=0;
     
    rep(i,1,L) sa[i]=i;
    sort(sa+1,sa+1+L,cmpp);
    rank[sa[1]]=1;
    rep(i,2,L)
    {
        if (S[sa[i]] == S[sa[i-1]]) rank[sa[i]]=rank[sa[i-1]];
        else rank[sa[i]]=rank[sa[i-1]]+1;
    }
     
    for (int p=1;1;p<<=1)
    {
        for (int i=1;i<=L;++i)
        {
            node[i][0]=rank[i];
            node[i][1]=(i+p>L)?0:rank[i+p];
        }
         
        rep(i,0,L) g[i]=0;
        es=0;
        rep(i,1,L)
        {
            other[++es]=i;
            next[es]=g[node[i][1]];
            g[node[i][1]]=es;
        }
         
        int cnt=0;
        dep(i,L,0)
        {
            for (int p=g[i];p;p=next[p])
                sa[++cnt]=other[p];
        }
         
        rep(i,0,L) g[i]=0;
        es=0;
        rep(i,1,L)
        {
            other[++es]=sa[i];
            next[es]=g[node[sa[i]][0]];
            g[node[sa[i]][0]]=es;
        }
         
        cnt=0;
        rep(i,0,L)
        {
            for (int p=g[i];p;p=next[p])
                sa[++cnt]=other[p];
        }
         
        int f=0;
        rank[sa[1]]=1;
        rep(i,2,L)
            if (node[sa[i]][0]==node[sa[i-1]][0] && node[sa[i]][1]==node[sa[i-1]][1])
                rank[sa[i]] = rank[sa[i-1]];
            else
            {
                rank[sa[i]] = rank[sa[i-1]]+1;
                if (rank[sa[i]] == L) f=1;
            }
        if (f) break;
    }
     
    int H=0;
    rep(i,1,L)
    {
        if (rank[i]==0) { H=height[0]=0;continue; }
        if (H) H--;
        int j=sa[rank[i]-1];
        while (j+H<=L && i+H<=L && S[j+H]==S[i+H]) H++;
        height[rank[i]]=H;
    }
}
int find(int x) {
	if (f[x]!=x) f[x]=find(f[x]);
	return f[x];
}
bool cmp(pp x,pp y) {
	return x.l<y.l;
}
int main()
{
	scanf("%s",s+1); L=strlen(s+1); n=L;
	suffix(s,L,rank,sa,height);
	rep(i,2,n) E[height[i]].pb(i);
	rep(i,1,n) f[i]=i,sz[i]=1; c[1]=n;
	int Q;scanf("%d",&Q);
	rep(i,1,Q) scanf("%d%d",&q[i].l,&q[i].p),q[i].i=i;
	sort(q+1,q+1+Q,cmp);
	int j=Q;
	for (int i=n;i>=1;--i) {
		rep(k,0,(int)E[i].size()-1) {
			int tmp=E[i][k];
			int fx=find(tmp-1),fy=find(tmp);
			if (fx==fy) continue;
			--c[sz[fx]];--c[sz[fy]];sz[fx]+=sz[fy];c[sz[fx]]++;
			f[fy]=fx;
		}
		while (j && q[j].l==i) {
			ans[q[j].i]=c[q[j].p];
			if (q[j].p==1) ans[q[j].i]-=q[j].l-1;
			j--;
		}
	}
	rep(i,1,Q) printf("%d\n",ans[i]);
	return 0;
}
