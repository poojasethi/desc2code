// Suffix Automata
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<set>
#include<map>
#include<utility>
#include<vector>
#include<string>
#include<stack>
#include<queue>
using namespace std;               //REMEMBER TO TAKE DOUBLE SIZED ARRAY
#define MAXLEN 200006
struct State
{
    int len, link;
    map < char , int > nxtc;
} SA[2*MAXLEN];
int NumOcc[2*MAXLEN];
char str[MAXLEN];
vector < pair < int , int > > lenState;
vector < vector < int > > octost(MAXLEN);
struct qq
{
    int length, occ, idx, ans;
    qq() {}
    qq(int l, int o, int i) {length = l, occ = o, idx = i;}
};
vector < qq > queries;
int BIT[MAXLEN];
void update(int N, int idx, int val)
{
    while (idx <= N)
    {
        BIT[idx] += val;
        idx += idx & -idx;
    }
}
int query(int idx)
{
    int ret = 0;
    while (idx > 0)
    {
        ret += BIT[idx];
        idx -= idx & -idx;
    }
    return ret;
}
bool cmpo(qq a, qq b)
{
    return a.occ < b.occ;
}
bool cmpi(qq a, qq b)
{
    return a.idx < b.idx;
}

class SuffixAutomata
{
    int sz, last, lm;
    int fnl;
    void init(int idx)
    {
        SA[idx].len = 0, SA[idx].link = -1;
        SA[idx].nxtc.clear();
    }
public:
    SuffixAutomata()
    {
        sz = last = 0;
        init(0);
        lenState.clear();
        lm = 0;
        ++sz;
    }
    int size() {return sz;}
    void extend(char ch, int idx = -1)
    {
        int p, q, clone, cur = sz++;
        lm = fnl = cur;
        init(cur);
        SA[cur].len = SA[last].len + 1;
        lenState.push_back(make_pair(SA[cur].len, cur));
        for (p = last; p != -1 && SA[p].nxtc.count(ch) == 0; p = SA[p].link) SA[p].nxtc[ch] = cur;
        if (p == -1) SA[cur].link = 0;
        else
        {
            q = SA[p].nxtc[ch];
            if (SA[p].len + 1 == SA[q].len) SA[cur].link = q;
            else
            {
                clone = sz++;
                init(clone);
                SA[clone] = SA[q];
                SA[clone].len = SA[p].len + 1;
                for (; p != -1 && SA[p].nxtc[ch] == q; p = SA[p].link) SA[p].nxtc[ch] = clone;
                SA[cur].link = SA[q].link = clone;
                lenState.push_back(make_pair(SA[clone].len, clone));
            }
        }
        last = cur;
    }
    void numOcc()
    {
        int i,p,q;
        map < char, int > :: iterator im;
        memset(NumOcc, 0, sizeof(NumOcc));
        NumOcc[lm] = 1;
        sort(lenState.begin(), lenState.end());
        for (i=lenState.size()-1; i>=0; --i)
        {
            p = lenState[i].second;
            if (p < 1) continue;
            map < char , int > &M = SA[p].nxtc;
            for (im = M.begin(); im != M.end(); ++im)
            {
                q = im -> second;
                NumOcc[p] += NumOcc[q];
            }
        }
        for (q=1; q<sz; ++q) octost[NumOcc[q]].push_back(q);
    }
    void prep(int N, int occ)
    {
        int i,st,nd,q;
        for (i=0; i<octost[occ].size(); ++i)
        {
            q = octost[occ][i];
            nd = SA[q].len;
            q = SA[q].link;
            st = SA[q].len + 1;
            update(N, st, 1);
            update(N, nd+1, -1);
        }
    }
    void undo(int N, int occ)
    {
        int i,st,nd,q;
        for (i=0; i<octost[occ].size(); ++i)
        {
            q = octost[occ][i];
            nd = SA[q].len;
            q = SA[q].link;
            st = SA[q].len + 1;
            update(N, st, -1);
            update(N, nd+1, 1);
        }
    }
};
int main()
{
    int i;
    int N,Q,q;
    int l,o;
    int last;
    while(scanf("%s", str) != EOF)
    {
        SuffixAutomata temp;
        for (i=0; str[i]; ++i) temp.extend(str[i], i);
        N = strlen(str) + 2;
        for (i=0; i<=N; ++i) octost[i].clear();
        temp.extend('$');
        temp.numOcc();
        scanf("%d", &Q);
        queries.clear();
        for (q=0; q<Q; ++q)
        {
            scanf("%d %d", &l, &o);
            queries.push_back(qq(l,o,q));
        }
        sort (queries.begin(), queries.end(), cmpo);
        last = 0;
        memset(BIT, 0, sizeof(BIT));
        for (q=0; q<Q; ++q)
        {
            l = queries[q].length, o = queries[q].occ;
            if (o != last)
            {
                temp.undo(N,last);
                temp.prep(N,o);
                last = o;
            }
            queries[q].ans = query(l) - (o == 1);
        }
        sort (queries.begin(), queries.end(), cmpi);
        for (q=0; q<Q; ++q) printf("%d\n", queries[q].ans);
    }
    return 0;
}
