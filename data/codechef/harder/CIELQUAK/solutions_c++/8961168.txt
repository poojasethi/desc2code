#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
using namespace std;
typedef double LD;
typedef long long LL;
const int Maxn=8,Maxc=55,MaxN=7000;
int T,R,N;
LL C;
int ne[Maxn][MaxN][4];
LD P,f[Maxc][Maxn][MaxN];

struct info{
	int u,b[Maxn];
	bool operator <(const info &rhs)const{
		if (u!=rhs.u) return u<rhs.u;
		for (int i=0;i<R;i++)
			if (b[i]!=rhs.b[i])
				return b[i]<rhs.b[i];
		return false;
	}
}st[MaxN];

int a[Maxn];

void dfs(int i,int u) {
	if (i==R) {
		if (u==-1) return;
		++N;
		st[N].u=u;
		memcpy(st[N].b,a,sizeof a);
		return;
	}
	a[i]=i;
	dfs(i+1,u);
	if (u==-1) dfs(i+1,i);
	for (int j=i-1;j>=0;j=a[j]-1) {
		a[i]=a[j];
		dfs(i+1,u);
	}
}

int find(const info &x) {
	return lower_bound(st+1,st+N+1,x)-st;
}

void init() {
	static int lastR=0;
	info tmp;
	if (R==lastR) return;
	lastR=R;
	N=0;
	dfs(0,-1);
	sort(st+1,st+N+1);
	for (int j=0;j<R;j++) {
		for (int s=1;s<=N;s++) {
			//0:none
			tmp=st[s];
			if (tmp.b[j]==j) {
				int id=R;
				for (int k=j+1;k<R;k++)
					if (tmp.b[k]==j) {
						id=min(id,k);
						tmp.b[k]=id;
					}
				if (tmp.u==j) tmp.u=id==R?-1:id;
			}
			tmp.b[j]=j;
			if (tmp.u==-1) ne[j][s][0]=-1;
			else ne[j][s][0]=find(tmp);
			//1:-
			if (j>0) {
				tmp=st[s];
				if (tmp.b[j]==j) {
					int id=R;
					for (int k=j+1;k<R;k++)
						if (tmp.b[k]==j) {
							id=min(id,k);
							tmp.b[k]=id;
						}
					if (tmp.u==j) tmp.u=id==R?-1:id;
				}
				tmp.b[j]=tmp.b[j-1];
				if (tmp.u==-1) ne[j][s][1]=-1;
				else ne[j][s][1]=find(tmp);
			}
			//2:|
			ne[j][s][2]=s;
			//3:_|
			if (j>0) {
				tmp=st[s];
				int t0=tmp.b[j],t1=tmp.b[j-1];
				if (t0<t1) swap(t0,t1);
				for (int k=0;k<R;k++)
					if (tmp.b[k]==t0)
						tmp.b[k]=t1;
				if (tmp.u==t0) tmp.u=t1;
				ne[j][s][3]=find(tmp);
			}
		}
	}
}

double Pow(double a,LL x) {
	double ret=1;
	for (;x;x>>=1,a*=a)
		if (x&1) ret*=a;
	return ret;
}

void work(int R,int C) {
	memset(f,0,sizeof f);
	f[1][0][1]=1;
	for (int i=1;i<=C;i++)
		for (int j=0;j<R;j++) {
			if (i==1&&j==0) continue;
			LD *cur=f[i][j],*last=j==0?f[i-1][R-1]:f[i][j-1],P0,P1,P2,P3;
			if (i>1&&j>0) {
				P0=P*P;
				P1=P*(1-P);
				P2=P*(1-P);
				P3=(1-P)*(1-P);
			}
			if (i>1&&j==0) {
				P0=P;
				P1=0;
				P2=1-P;
				P3=0;
			}
			if (i==1&&j>0) {
				P0=P;
				P1=1-P;
				P2=0;
				P3=0;
			}
			if (i==1&&j==0) {
				P0=1;
				P1=0;
				P2=0;
				P3=0;
			}
			for (int s=1;s<=N;s++) {
				if (ne[j][s][0]!=-1)
					cur[ne[j][s][0]]+=P0*last[s];
				if (j>0&&ne[j][s][1]!=-1)
					cur[ne[j][s][1]]+=P1*last[s];
				if (i>1)
					cur[ne[j][s][2]]+=P2*last[s];
				if (i>1&&j>0)
					cur[ne[j][s][3]]+=P3*last[s];
			}
		}
}

LD calc(int C) {
	LD ret=0,*cur=f[C][R-1];
	for (int i=1;i<=N;i++)
		if (st[i].b[R-1]==st[i].u)
			ret+=cur[i];
	return ret;
}

int main() {
	for (cin>>T;T;T--) {
		cin>>R>>C>>P;
		init();
		work(R,min(C,50LL));
		if (C>50) {
			LD t0=calc(49),t1=calc(50),ans=t0<1e-8?0:t0*Pow(t1/t0,C-49);
			printf("%.13lf\n",double(ans));
		}
		else printf("%.13lf\n",double(calc(C)));
	}
	return 0;
}