#include <cstdio>
#include <cstdlib>
#include <memory.h>
using namespace std;

#define N 210000
typedef long long int64;

struct T {
	int s, pre, d;
	int64 sum;
	T *fa, *pf, *son[2];
} f2[N], *f1 = f2, *f[N], *null;

int Time, n, i, x, y, len, m, k, time1, h, L[N], s[N], R[N], till[N], go[N], next[N], c[N], l1[N], r1[N], zhan[N], I[N];
int64 d[N], ans, b[N];

void read(int &x) {
	char k;
	for (k = getchar(); k <= 32; k = getchar());
	for (x = 0; '0' <= k; k = getchar())	x = x * 10 + k - '0';
}

void add(int x, int y) {
	next[++len] = till[x];
	till[x] = len;
	go[len] = y;
}

// void dfs(int k, int fa) {
// 	L[k] = ++Time;
// 	l1[k] = ++time1;
// 	s[k] = 1;
// 	if (fa >= 0)	f[k] -> pf = f[fa];
// 	else	f[k] -> pf = null;
// 	f[k] -> pre = f[k] -> d = k;
// 	for (int i = till[k]; i; i = next[i])
// 		if (go[i] != fa) {
// 			dfs(go[i], k);
// 			s[k] += s[go[i]];
// 			d[k] += d[go[i]];
// 		}
// 	d[k] += s[k] - 1;
// 	f[k] -> sum = f[k] -> s = s[k];
// 	R[k] = Time;
// 	r1[k] = ++time1;
// }

void in(int x) {
	I[x] = till[x];
	L[x] = ++Time;
	l1[x] = ++time1;
	s[x] = 1;
	d[x] = 0;
	if (zhan[h - 1] >= 0)	f[x] -> pf = f[zhan[h - 1]];
	else	f[x] -> pf = null;
	f[x] -> pre = f[x] -> d = x;
}

void out(int x) {
	d[x] += s[x] - 1;
	f[x] -> sum = f[x] -> s = s[x];
	R[x] = Time;
	r1[x] = ++time1;
	if (zhan[h - 1] >= 0) {
		s[zhan[h - 1]] += s[x];
		d[zhan[h - 1]] += d[x];
	}
}

void dfs() {
	zhan[0] = -1;
	zhan[h = 1] = 0;
	in(0);
	while (h) {
		if (!I[zhan[h]]) {
			out(zhan[h]);
			h--;
		}else {
			if (go[I[zhan[h]]] == zhan[h - 1]) {
				I[zhan[h]] = next[I[zhan[h]]];
				continue;
			}else {
				zhan[h + 1] = go[I[zhan[h]]];
				I[zhan[h]] = next[I[zhan[h]]];
				in(zhan[++h]);
			}
		}
	}
}

int64 get(int x) {
	int64 sum = 0;
	for (; x; x -= x & -x)	sum += b[x];
	return sum;
}

void modify(int x, int64 y) {
	for (; x <= n; x += x & -x)	b[x] += y;
}

void modifyc(int x, int y) {
	for (; x <= 2 * n; x += x & -x)	c[x] += y;
}

int getc(int x) {
	int sum = 0;
	for (; x; x -= x & -x)	sum += c[x];
	return sum;
}

void Modify(T *x, int t) {
	if (x == null)	return ;
	modify(L[x -> pre], (x -> sum - s[x -> pre]) * t);
	modifyc(l1[x -> pre], t);
	modifyc(r1[x -> pre], -t);
}

void update(T *x) {
	x -> sum = x -> son[0] -> sum + x -> son[1] -> sum + x -> s;
	if (x -> son[0] == null)	x -> pre = x -> d;
	else	x -> pre = x -> son[0] -> pre;
}

void rotate(T *x, bool t) {
	T *y = x -> fa, *z = y -> fa;
	if (z != null)	z -> son[y == z -> son[1]] = x;
	x -> fa = z;
	x -> pf = y -> pf;
	y -> son[t] = x -> son[!t];
	x -> son[!t] -> fa = y;
	x -> son[!t] = y;
	y -> fa = x;
	update(y);
}

void splay(T *x) {
	T *y, *z;
	bool t1, t2;
	while (x -> fa != null) {
		y = x -> fa, z = y -> fa;
		t1 = (x == y -> son[1]); t2 = (y == z -> son[1]);
		if (z != null) {
			if (t1 == t2)	rotate(y, t2), rotate(x, t1);
			else	rotate(x, t1), rotate(x, t2);
		}else	rotate(x, t1);
	}
	update(x);
}

void CutR(T *x) {
	Modify(x, -1);
	T *p = x -> son[1];
	Modify(p, 1);
	p -> fa = null;
	p -> pf = x;
	x -> son[1] = null;
	update(x);
	Modify(x, 1);
}

void link(T *x) {
	T *p = x -> pf;
	Modify(x, -1);
	Modify(p, -1);
	p -> son[1] = x;
	x -> fa = p;
	update(p);
	Modify(p, 1);
}

void access(T *x) {
	splay(x);
	CutR(x);
	while (x -> pf != null) {
		splay(x -> pf);
		CutR(x -> pf);
		link(x);
		splay(x);
	}
}

int main() {
	int tt;
	read(tt);
	while (tt--) {
		null = new T; null -> son[0] = null -> son[1] = null -> fa = null; null -> sum = null -> s = 0;
		read(n);
		f1 = f2;
		Time = time1 = len = 0;
		memset(till, 0, sizeof(till));
		memset(c, 0, sizeof(c));
		memset(b, 0, sizeof(b));
		for (i = 0; i < n; i++)	f[i] = ++f1, f1 -> son[0] = f1 -> son[1] = f1 -> fa = null;
		for (i = 1; i < n; i++) {
			read(x); read(y);
			add(x, y);
			add(y, x);
		}
		dfs();
		for (i = 1; i < n; i++)	modifyc(l1[i], 1), modifyc(r1[i], -1);
		read(m);
		while (m--) {
			for (k = getchar(); k <= 32; k = getchar());
			if (k == 'q') {
				read(x);
				ans = d[x];
				ans -= get(R[x]) - get(L[x] - 1);
				splay(f[x]);
				if (f[x] -> son[0] != null)	ans -= f[x] -> son[1] -> sum;
				printf("%.8lf\n", 1.0 * ans / (R[x] - L[x] + 1) + getc(l1[x]));
			}else {
				read(x);
				access(f[x]);
			}
		}
	}
}
