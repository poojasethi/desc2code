#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
using namespace std;
typedef long long LL;
const int Maxn=100005,inf=999999999+208;
int n,now;
int head[Maxn],next[Maxn*2],to[Maxn*2],En;
int Q[Maxn],fa[Maxn],top[Maxn],dep[Maxn],size[Maxn],wp[Maxn];
LL sf[Maxn];
vector <int> lis[Maxn];

inline int get() {
	char ch;
	while (!isdigit(ch=getchar()));
	int v=ch-48;
	while (isdigit(ch=getchar())) v=v*10+ch-48;
	return v;
}

struct node{
	node *lc,*rc;
	LL f,df,sum;
	int size,col,cnte;
	bool flag;
	void update() {
		sum=lc->sum+rc->sum;
		cnte=lc->cnte+rc->cnte;
		flag=lc->flag|rc->flag;
	}
	void addf(LL _df,int _col) {
		sum=0;
		cnte=0;
		f+=_df;
		df+=_df;
		col=_col;
	}
	void pushdown() {
		if (col) {
			lc->addf(df-rc->sum,col);
			rc->addf(df,col);
			df=0;
			col=0;
		}
	}
}po[Maxn*2],*pn;

int Getcol(int u);
void Change(int u);

class SegmentTree{
	node *root;
	int L,R;
	vector <int> *Lis;
	void build(node *&x,int l,int r,vector <int> &lis) {
		x=++pn;
		if (l==r) {
			x->cnte=lis[l-L]!=1;
			x->f=sf[lis[l-L]];
			x->size=size[lis[l-L]];
			x->sum=x->size;
			x->col=++now;
			return;
		}
		int mid=(l+r)>>1;
		build(x->lc,l,mid,lis);
		build(x->rc,mid+1,r,lis);
		x->update();
	}
	int getcol(node *x,int l,int r,int p) {
		if (l==r) return x->col;
		x->pushdown();
		int mid=(l+r)>>1;
		return p<=mid?getcol(x->lc,l,mid,p):getcol(x->rc,mid+1,r,p);
	}
	void modifye(node *x,int l,int r,int p) {
		if (l==r) {
			x->sum=x->size;
			x->cnte=1;
			return;
		}
		x->pushdown();
		int mid=(l+r)>>1;
		if (p<=mid) modifye(x->lc,l,mid,p);
		else modifye(x->rc,mid+1,r,p);
		x->update();
	}
	LL modify(node *x,int l,int r,int s,int t,LL df,int col) {
		if (s==l&&t==r&&(l==r||!x->flag)) {
			LL ret=x->sum;
			int &y=wp[(*Lis)[l-L]];
			if (x->flag&&y) {
				if (x->col==Getcol(y)) {
					df+=size[y];
					ret-=size[y];
					Change(y);
				}
				y=0;
				x->flag=false;
			}
			x->addf(df,col);
			return ret;
		}
		x->pushdown();
		int mid=(l+r)>>1;
		if (t<=mid) {
			LL ret=modify(x->lc,l,mid,s,t,df,col);
			x->update();
			return ret;
		}
		if (s>mid) {
			LL ret=modify(x->rc,mid+1,r,s,t,df,col);
			x->update();
			return ret;
		}
		LL ret=modify(x->rc,mid+1,r,mid+1,t,df,col);
		ret+=modify(x->lc,l,mid,s,mid,df-ret,col);
		x->update();
		return ret;
	}
	LL query(node *x,int l,int r,int p) {
		if (l==r) return x->f;
		x->pushdown();
		int mid=(l+r)>>1;
		return p<=mid?query(x->lc,l,mid,p):query(x->rc,mid+1,r,p);
	}
	int cnte(node *x,int l,int r,int s,int t) {
		if (s==l&&t==r) return x->cnte;
		x->pushdown();
		int mid=(l+r)>>1;
		if (t<=mid) return cnte(x->lc,l,mid,s,t);
		if (s>mid) return cnte(x->rc,mid+1,r,s,t);
		return cnte(x->lc,l,mid,s,mid)+cnte(x->rc,mid+1,r,mid+1,t);
	}
	void flag(node *x,int l,int r,int p) {
		if (l==r) {
			x->flag=true;
			return;
		}
		x->pushdown();
		int mid=(l+r)>>1;
		if (p<=mid) flag(x->lc,l,mid,p);
		else flag(x->rc,mid+1,r,p);
		x->update();
	}
	public:
		void build(int _L,vector <int> &lis) {
			Lis=&lis;
			L=_L; R=L+lis.size()-1;
			build(root,L,R,lis);
		}
		LL modify(int s,int t,LL d,int col) {
			return modify(root,L,R,s,t,d,col);
		}
		int getcol(int p) {
			return getcol(root,L,R,p);
		}
		void modifye(int p) {
			modifye(root,L,R,p);
		}
		LL query(int p) {
			return query(root,L,R,p);
		}
		int cnte(int s,int t) {
			return cnte(root,L,R,s,t);
		}
		void flag(int p) {
			flag(root,L,R,p);
		}
}T[Maxn];

void init() {
	memset(dep+1,0,n<<2);
	memset(size+1,0,n<<2);
	memset(top+1,0,n<<2);
	memset(wp+1,0,n<<2);
	memset(sf+1,0,n<<3);
	int l=1,r=2;
	dep[Q[1]=1]=1;
	while (l<r) {
		int x=Q[l++];
		for (int k=head[x];k;k=next[k])
			if (!dep[to[k]]) {
				Q[r++]=to[k];
				fa[to[k]]=x;
				dep[to[k]]=dep[x]+1;
			}
	}
	for (int i=n,x=Q[i];i;x=Q[--i]) {
		sf[x]+=size[x];
		sf[fa[x]]+=sf[x];
		size[fa[x]]+=++size[x];
	}
	size[0]=-inf;
	for (int i=1,x=Q[i];i<=n;x=Q[++i]) {
		if (!top[x]) {
			top[x]=x;
			lis[x].clear();
		}
		lis[top[x]].push_back(x);
		int w=0;
		for (int k=head[x];k;k=next[k])
			if (fa[to[k]]==x&&size[to[k]]>size[w])
				w=to[k];
		top[w]=top[x];
	}
	pn=po;
	now=0;
	memset(po+1,0,2*n*sizeof(node));
	for (int i=1;i<=n;i++)
		if (top[i]==i)
			T[i].build(dep[i],lis[i]);
}

int Getcol(int u) {
	return T[top[u]].getcol(dep[u]);
}

void Change(int u) {
	T[top[u]].modifye(dep[u]);
}

double query(int u) {
	LL ret=T[top[u]].query(dep[u]);
	int cnte=0,x=u;
	while (u) {
		int v=top[u];
		cnte+=T[v].cnte(dep[v],dep[u]);
		u=fa[v];
	}
	return double(ret)/size[x]+cnte;
}

void modify(int u) {
	++now;
	LL d=0;
	int v=0;
	while (u) {
		int tmp=Getcol(u);
		if (wp[u]!=0&&tmp==Getcol(wp[u])) {
			d-=size[wp[u]];
			Change(wp[u]);
			wp[u]=0;
		}
		else {
			int v=dep[u]-dep[top[u]]+1;
			if (v!=lis[top[u]].size()&&tmp==Getcol(lis[top[u]][v]))
				d-=size[lis[top[u]][v]],
				T[top[lis[top[u]][v]]].modifye(dep[lis[top[u]][v]]);
		}
		int y=v;
		v=top[u];
		d+=T[v].modify(dep[v],dep[u],-d,now);
		wp[u]=y;
		if (y)
			T[top[u]].flag(dep[u]);
		u=fa[v];
	}
}

int main() {
	for (int T=get();T;T--) {
		n=get();
		memset(head+1,0,n<<2);
		En=0;
		for (int i=1,u,v;i<n;i++) {
			u=get()+1; v=get()+1;
			next[++En]=head[u]; head[u]=En; to[En]=v;
			next[++En]=head[v]; head[v]=En; to[En]=u;
		}
		init();
		for (int q=get();q;q--) {
			char opx;
			while (!isalpha(opx=getchar()));
			if (opx=='O') modify(get()+1);
			else {
				int u=get()+1;
				printf("%.7lf\n",query(u));
			}
		}
	}
	return 0;
}