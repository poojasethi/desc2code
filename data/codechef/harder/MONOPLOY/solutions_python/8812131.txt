#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
namespace IO
{
	const int MAXL=1<<15;
	char buf[MAXL],*S,*T,ch;
	inline char igetch()
	{
		if(S==T)T=(S=buf)+fread(buf,1,MAXL,stdin);
		return S==T?EOF:*S++;
	}
	inline void read(int &x)
	{
		x=0;
		while(!isdigit(ch=igetch()));
		do{x=x*10+(ch^'0');}while(isdigit(ch=igetch()));
	}
	inline void readc(char &x){while(!isalpha(x=igetch()));}
}
typedef long long LL;
const int MAXN=100010;
int n,st[MAXN],ed[MAXN],idx,head[MAXN],tot;
namespace BIT
{
	LL B[MAXN],C[MAXN];
	inline int lowbit(int x){return x&-x;}
	inline void add_B(int x,int y){for(;x;x-=lowbit(x))B[x]+=y;}
	inline void add_C(int x,int y){for(int i=x;i<=n;i+=lowbit(i))C[i]+=x*y;}
	inline LL sum_B(int x){LL ret=0;for(;x<=n;x+=lowbit(x))ret+=B[x];return ret;}
	inline LL sum_C(int x){LL ret=0;for(;x;x-=lowbit(x))ret+=C[x];return ret;}
	inline LL sum(int x){return x?sum_B(x)*x+sum_C(x-1):0;}
	inline void add(int l,int r,int k)
	{
		add_B(r,k),add_C(r,k);
		if(l>1)add_B(l-1,-k),add_C(l-1,-k);
	}
	inline LL sum(int l,int r){return sum(r)-sum(l-1);}
	void init()
	{
		memset(B,0,sizeof(B));
		memset(C,0,sizeof(C));
	}
}
namespace LCT
{
	struct node
	{
		node *ch[2],*fa;
	}pool[MAXN],*null,*anc[MAXN];
	inline void init()
	{
		null=pool;
		for(int i=0;i<=n;i++)(pool+i)->ch[0]=(pool+i)->ch[1]=(pool+i)->fa=null;
	}
	inline void rotate(node *&u,int d)
	{
		node *t=u->ch[d^1];
		u->ch[d^1]=t->ch[d],t->ch[d]=u;
		t->fa=u->fa,u->fa=t,u->ch[d^1]->fa=u;
		u=t;
	}
	void splay(node *&u,int k)
	{
		int d=(k?(u->ch[1]==anc[k-1]):-1);
		if(~d)
		{
			k--;
			node *&t=u->ch[d];
			int d2=(k?(t->ch[1]==anc[k-1]):-1);
			if(~d2)
			{
				k--;
				splay(t->ch[d2],k);
				if(d==d2)rotate(u,d^1);
				else rotate(u->ch[d],d);
			}
			rotate(u,d^1);
		}
	}
	inline bool isroot(node *u){return u->fa->ch[0]!=u&&u->fa->ch[1]!=u;}
	inline void splay(node *u)
	{
		int cnt=0;
		for(;!isroot(u);u=u->fa)anc[cnt++]=u;
		splay(u,cnt);
	}
	inline void access(node *u)
	{
		for(node *v=null;u!=null;v=u,u=u->fa)
		{
			splay(u);
			if(u->ch[1]!=null)
			{
				node *t=u->ch[1];
				while(t->ch[0]!=null)t=t->ch[0];
				BIT::add(st[t-pool],ed[t-pool],1);
			}
			u->ch[1]=v;
			if(u->ch[1]!=null)
			{
				node *t=u->ch[1];
				while(t->ch[0]!=null)t=t->ch[0];
				BIT::add(st[t-pool],ed[t-pool],-1);
			}
		}
	}
}
struct edge{int adj,next;}e[MAXN<<1];
inline void add_edge(int u,int v)
{
	tot++;
	e[tot].adj=v,e[tot].next=head[u];
	head[u]=tot;
}
void DFS(int u,int fa)
{
	st[u]=++idx;
	for(int i=head[u];i;i=e[i].next)
	{
		int &v=e[i].adj;
		if(v==fa)continue;
		DFS(v,u);
		(LCT::pool+v)->fa=(LCT::pool+u);
	}
	ed[u]=idx;
}
inline void init()
{
	IO::read(n);
	BIT::init();
	LCT::init();
	memset(head,0,sizeof(head)),tot=0;
	for(int i=1;i<n;i++)
	{
		int u,v;
		IO::read(u),IO::read(v);
		u++,v++;
		add_edge(u,v),add_edge(v,u);
	}
	idx=0;
	DFS(1,0);
	for(int i=2;i<=n;i++)BIT::add(st[i],ed[i],1);
}
inline void solve()
{
	int q,u;
	char opt;
	IO::read(q);
	while(q--)
	{
		IO::readc(opt),IO::read(u);
		u++;
		if(opt=='q')printf("%.9lf\n",(double)BIT::sum(st[u],ed[u])/(ed[u]-st[u]+1));
		else LCT::access(LCT::pool+u);
	}
}
int main(void)
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		init();
		solve();
	}
	return 0;
}
