#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxN=110000;
struct tree{
	int l,r,father;
}t[maxN];
int n,m,p[maxN],dfs[maxN],r[maxN],sign,tot,len,num;
struct bian{
	int next,point;
}b[maxN<<1];
long long A[maxN],B[maxN];
void ade(int k1,int k2){
	b[++len]=(bian){p[k1],k2}; p[k1]=len;
}
void add(int k1,int k2){
	ade(k1,k2); ade(k2,k1);
}
void add(long long *A,int k1,int k2){
	if (k1==0) return;
	for (;k1<=n;k1+=k1&(-k1)) A[k1]+=k2;
}
void addin(int l,int r,int k1){
//	cout<<"add "<<l<<" "<<r<<" "<<k1<<endl;
	if (l==1) tot+=k1; num++;
	add(A,l-1,-k1*(l-1)); add(B,l-1,-k1); 
	add(A,r,k1*r); add(B,r,k1);
}
void dfs1(int k1,int k2){
	dfs[k1]=++sign;
	for (int i=p[k1];i;i=b[i].next){
		int j=b[i].point;
		if (j!=k2){
			t[j].father=k1; dfs1(j,k1);
		}
	}
	r[k1]=sign; addin(dfs[k1],r[k1],1);
}
void zig(int k){
	int f=t[k].father;
	if (t[t[f].father].l==f) t[t[f].father].l=k; else if (t[t[f].father].r==f) t[t[f].father].r=k;
	t[k].father=t[f].father; t[f].l=t[k].r; t[t[f].l].father=f; t[k].r=f; t[f].father=k;
}
void zag(int k){
	int f=t[k].father;
	if (t[t[f].father].l==f) t[t[f].father].l=k; else if (t[t[f].father].r==f) t[t[f].father].r=k;
	t[k].father=t[f].father; t[f].r=t[k].l; t[t[f].r].father=f; t[k].l=f; t[f].father=k;
}
int splay_root(int k){
	return t[k].father&&(t[t[k].father].l==k||t[t[k].father].r==k);
}
void splay(int k){
	while (splay_root(k)){
		int f1=t[k].father,f2=t[f1].father;
		if (!splay_root(f1)){
			if (k==t[f1].l) zig(k); else zag(k);
			return;
		}
		if (f1==t[f2].l){
			if (k==t[f1].l){zig(f1); zig(k);} else {zag(k); zig(k);}
		} else if (k==t[f1].l){zig(k); zag(k);} else {zag(f1); zag(k);}
	}
}
int findl(int k){
	while (t[k].l) k=t[k].l; return k;
}
int access(int k){
	int now=0;
	while (k){
		splay(k); int where=findl(k);
		addin(dfs[where],r[where],-1); //splay(where);
		if (t[k].r){
			where=findl(t[k].r); addin(dfs[where],r[where],1);// splay(where);
		}
		/*splay(k);*/ t[k].r=now; now=k; k=t[k].father;
	}
	return now;
}
long long find(long long *A,int k1){
	long long ans=0; for (;k1;k1-=k1&(-k1)) ans+=A[k1]; return ans;
}
long long find(int k1){
//	cout<<"find "<<k1<<" "<<tot<<" "<<(tot-find(B,k1))*k1+find(A,k1)<<endl;
	return (tot-find(B,k1))*k1+find(A,k1);
}
void solve(){
	scanf("%d",&n); num=0;
	for (int i=1;i<=n;i++){
		p[i]=0; t[i]=(tree){0,0,0}; A[i]=0; B[i]=0;
	}
	len=0; tot=0; sign=0;
	for (int i=1;i<n;i++){
		int k1,k2; scanf("%d%d",&k1,&k2); k1++; k2++; add(k1,k2);
	}
	dfs1(1,0);
	scanf("%d",&m);
	for (;m;m--){
		char ch[5]; scanf("%s",ch+1);
		if (ch[1]=='O'){
			int k1; scanf("%d",&k1); k1++; access(k1); addin(1,n,1);
		} else {
			int k1; scanf("%d",&k1); k1++;
			long long ans=find(r[k1])-find(dfs[k1]-1);// cout<<"get "<<dfs[k1]<<" "<<r[k1]<<endl;
			printf("%.11lf\n",(double)ans/(double)(r[k1]-dfs[k1]+1)-1);
		}
	}
}
int main(){
	int t; scanf("%d",&t);
	for (;t;t--) solve();
	return 0;
}