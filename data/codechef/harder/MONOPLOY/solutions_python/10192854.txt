#include <stdio.h>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cstring>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <iostream>
#include <algorithm>

#define REP(I,A,B) for (int I=(A),_END_=(B);I<=_END_;I++)
#define REPD(I,A,B) for (int I=(A),_END_=(B);I>=_END_;I--)
#define FOR(I,A,B) for (int I=(A),_END_=(B);I<_END_;I++)
#define GCH getchar()
#define PCH(X) putchar(X)
#define MS(X,Y) memset(X,Y,sizeof(X))
#define fr first
#define sc second
#define RI(X) scanf("%d",&X)
#define RII(X,Y) scanf("%d%d",&X,&Y)
#define RIII(X,Y,Z) scanf("%d%d%d",&X,&Y,&Z)
#define RL(X) X=Readll()
#define RLL(X,Y) RL(X),RL(Y)
#define RLLL(X,Y,Z) RL(X),RL(Y),RL(Z)
#define RS(X) scanf("%s",X)
#define RD(X) scanf("%lf",&X)
#define lch(p) ((p)+(p))
#define rch(p) ((p)+(p)+1)
#define lowbit(x) ((x)&(-(x)))
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define pb(X) push_back(X)
#define mp(X,Y) make_pair(X,Y)

using namespace std;

typedef vector<int> vi;
typedef pair<int,int> poi;

inline long long Readll()
{
	long long ret=0;
	int f=1;
	char ch;
	do{
		ch=GCH;
		if (ch=='-') f=-1;
	}while (ch>=0 && ( ch<'0' || ch>'9' ));
	while (ch>='0' && ch<='9')
	{
		ret=ret*10+ch-'0';
		ch=GCH;
	}
	return ret*f;
}

void open()
{
	freopen("MONOPLOY.in","r",stdin);
	freopen("MONOPLOY.out","w",stdout);
}
void close()
{
	fclose(stdin);
	fclose(stdout);
}

const int MAXN = 101010;

int tot;
int nxt[MAXN*2];
int to[MAXN*2];
int hd[MAXN];

int sz[MAXN];
int w[MAXN];
int l[MAXN];
int r[MAXN];

int am[MAXN];

long long sm[MAXN<<2];
int lz[MAXN<<2];
int ln[MAXN<<2];

struct node{
	int fa;
	int c[2];
	bool rt;
}t[MAXN];

inline void setc(int p,int x,int ch){
	if (p) t[p].c[ch]=x;
	if (x) t[x].fa=p;
}

int n,m;

inline void add(const int &x,const int &y){
	tot++;
	to[tot]=y;
	nxt[tot]=hd[x];
	hd[x]=tot;
}

void init()
{
	tot=0;
	MS(hd,0);
	RI(n);
	int x,y;
	FOR(i,1,n)
	{
		RII(x,y);
		x++;
		y++;
		add(x,y);
		add(y,x);
	}
}

void dfs(int p,int fa=0){

	++tot;
	am[tot]=p;
	l[p]=tot;

	t[p].c[0]=t[p].c[1]=0;
	t[p].rt=true;
	t[p].fa=fa;
	sz[p]=1;
	for (int i=hd[p];i;i=nxt[i])
	if (to[i]!=fa)
	{
		w[to[i]]=w[p]+1;
		dfs(to[i],p);
		sz[p]+=sz[to[i]];
	}

	r[p]=tot;
}
void build(int p,int l,int r){
	sm[p]=lz[p]=0;
	ln[p]=(r-l+1);
	if (l==r)
	{
		sm[p]=w[am[l]];
		return ;
	}
	int mid=(l+r)/2;
	build(lch(p),l,mid);
	build(rch(p),mid+1,r);
	sm[p]=sm[lch(p)]+sm[rch(p)];
}

void rotate(int x){
	if (t[x].rt) return ;
	int p=t[x].fa;
	int mark=t[p].c[1]==x;
	if (t[p].rt)
	{
		swap(t[p].rt,t[x].rt);
		t[x].fa=t[p].fa;
	}
	else
		setc(t[p].fa,x,t[t[p].fa].c[1]==p);
	setc(p,t[x].c[mark^1],mark);
	setc(x,p,mark^1);
}

void splay(int x){
	while (!t[x].rt)
	{
		if (t[t[x].fa].rt)
		{
			rotate(x);
			break;
		}
		if ( ( t[x].fa==t[t[t[x].fa].fa].c[0] ) == ( x==t[t[x].fa].c[0] ) )
			rotate(t[x].fa);
		else
			rotate(x);
		rotate(x);
	}
}

int find(int w)
{
	while (t[w].c[0])
		w=t[w].c[0];
	splay(w);
	return w;
}

void pushdown(int p)
{
	if (lz[p]!=0)
	{
		sm[lch(p)]+=1ll*ln[lch(p)]*lz[p];
		sm[rch(p)]+=1ll*ln[rch(p)]*lz[p];
		lz[lch(p)]+=lz[p];
		lz[rch(p)]+=lz[p];
		lz[p]=0;
	}
}

void add(int p,int l,int r,int ll,int rr,int vl){
	if (l==ll && r==rr)
	{
		sm[p]+=ln[p]*vl;
		lz[p]+=vl;
		return ;
	}
	pushdown(p);
	int mid=(l+r)/2;
	if (rr<=mid)
		add(lch(p),l,mid,ll,rr,vl);
	else if (mid<ll)
		add(rch(p),mid+1,r,ll,rr,vl);
	else
		add(lch(p),l,mid,ll,mid,vl),
		add(rch(p),mid+1,r,mid+1,rr,vl);
	sm[p]=sm[lch(p)]+sm[rch(p)];
}
long long query(int p,int l,int r,int ll,int rr){
	if (l==ll && r==rr)
		return sm[p];
	pushdown(p);
	int mid=(l+r)/2;
	if (rr<=mid)
		return query(lch(p),l,mid,ll,rr);
	else if (mid<ll)
		return query(rch(p),mid+1,r,ll,rr);
	else
		return query(lch(p),l,mid,ll,mid)+query(rch(p),mid+1,r,mid+1,rr);
}

void modify(int &w,int vl)
{
	if (w)
	{
		w=find(w);
		add(1,1,n,l[w],r[w],vl);
	}
}

void access(int x){
	int y=0;
	do
	{
		splay(x);
		t[t[x].c[1]].rt=true;

		if (t[x].c[1]!=y)
		{
			modify(t[x].c[1],1);
			modify(y,-1);
			t[x].c[1]=y;
		}

		t[y].rt=false;
		y=x;
		x=t[x].fa;
	}while (x);
}

void work()
{
	char op[10];
	int x;
	RI(m);
	REP(i,1,m)
	{
		RS(op);
		RI(x);
		x++;
		if (op[0]=='q')
			printf("%.10lf\n",query(1,1,n,l[x],r[x])*1./sz[x]);
		else
			access(x);
	}
}

int main()
{
	int _=0;
	RI(_);
	REP(__,1,_)
	{
		init();
		tot=0;
		dfs(1);
		build(1,1,n);
		work();
	}
	close();
	return 0;
}
