//pb_ds 20160123_4
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cmath>
using namespace std;
#define RG register
#define set_file(File) freopen(File ".in", "r", stdin), freopen(File ".out", "w", stdout)
#define close_file() fclose(stdin), fclose(stdout)
#define For(i, a, b) for(RG int i = a, ___u = b; i <= ___u; ++i)
#define ForDown(i, a, b) for(RG int i = b, ___d = a; i >= ___d; --i)
#define cmax(i, j) ((i) < (j) ? (i) = (j) : (i))
#define cmin(i, j) ((i) > (j) ? (i) = (j) : (i))
#define dmax(i, j) ((j) < (i) ? (i) : (j))
#define dmin(i, j) ((i) < (j) ? (i) : (j))
#define ddel(i, j) ((i) > (j) ? (i) - (j) : (j) - (i))
#define dabs(i) ((i) > 0 ? (i) : -(i))
#define dsqr(x) ((x) * (x))
#define lowbit(i) ((i) & -(i))
typedef unsigned uint;
typedef long long ll;
typedef double db;
typedef long double ld;
 
namespace io
{
	const int MAXBUF = 1 << 15;
	const int OUTPUT = 1 << 23;
	char b[MAXBUF], *S = b, *T = b;
	#define getc() (S == T && (T = (S = b) + fread(b, 1, MAXBUF, stdin), S == T) ? 0 : *S++)
	#define fastcall __attribute__((optimize("-O3")))
	#define IL __inline__ __attribute__((always_inline))
	template<class Type> IL Type read()
	{
		RG Type aa = 0; RG bool bb = 0; RG char ch, *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? bb = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		io::S = S, io::T = T; return bb ? -aa : aa;
	}
	int (*F)() = read<int>;
	template<> IL double read()
	{
		RG double aa = 0, bb;
		RG bool cc = 0;
		RG char ch;
		RG char *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? cc = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		if(ch == '.')
		{
			bb = 1;
			while(ch = getc(), ch >= '0' && ch <= '9')
				aa += (bb *= 0.1) * (ch - '0');
		}
		io::S = S, io::T = T;
		return cc ? -aa : aa;
	}

	IL int gets(RG char *s)
	{
		RG char *iter = s, *S = io::S, *T = io::T;
		while(*iter = getc(), *iter == ' ' || *iter == '\n' || *iter == '\r')
			;
		while(*++iter = getc(), *iter != ' ' && *iter != '\n' && *iter != '\r')
			;
		*iter = 0;		
		io::S = S, io::T = T;
		return iter - s;
	}
	IL char get()
	{
		RG char ch;
		while(ch = getc(), ch == ' ' || ch == '\n' || ch == '\r')
			;
		return ch;
	}
	
	char buff[OUTPUT], *iter = buff;
	template<class T>IL void P(RG T x, RG char ch = '\n')
	{
///*lgg*/cout << "Output = " << x << ch; return;
		static int stack[110]; RG int O = 0; RG char *iter = io::iter;
		if(!x)*iter++ = '0';
		else
		{
			(x < 0) ? x = -x, *iter++ = '-' : 1;
			for(; x; x /= 10) stack[++O] = x % 10;
			for(; O; *iter++ = '0' + stack[O--])
				;
		}
		*iter++ = ch, io::iter = iter;
	}

	IL void puts(RG const char *s) {while(*s) *iter++ = *s++;}
	IL void output() {fwrite(buff, 1, iter - buff, stdout), iter = buff;}
}

//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/hash_policy.hpp>
//typedef __float128 lld;
#include <vector>

namespace pb_ds
{
	const int MAXN = 200010;

	struct Pointer {int to; Pointer *next;} mem[MAXN << 1], *tot, *fir[MAXN];
	IL void link(RG int a, RG int b)
	{
		*++tot = (Pointer) {b, fir[a]}, fir[a] = tot;
		*++tot = (Pointer) {a, fir[b]}, fir[b] = tot;
	}

	int lef[MAXN], rig[MAXN], timer;

	namespace TA
	{
		db sum0[MAXN], sum1[MAXN];
		IL void modify0(RG int i, RG db v)
		{
			for(; i; i -= lowbit(i)) sum0[i] += v;
		}
		IL void modify1(RG int i, RG db v)
		{
			for(; i <= timer; i += lowbit(i)) sum1[i] += v;
		}
		IL db query0(RG int i)
		{
			RG db ans = 0;
			for(; i <= timer; i += lowbit(i)) ans += sum0[i];
			return ans;
		}
		IL db query1(RG int i)
		{
			RG db ans = 0;
			for(; i; i -= lowbit(i)) ans += sum1[i];
			return ans;
		}
		IL void clear()
		{
			memset(sum0 + 1, 0, timer * sizeof(db));
			memset(sum1 + 1, 0, timer * sizeof(db));
		}
	}
	IL void modify(RG int l, RG int r, RG db v)
	{
		using namespace TA;
		#define modify_point(r, c) (modify0((r), (c)), modify1((r), (r) * (c)))
		modify_point(r, v);
		if(l != 1) modify_point(l - 1, -v);
	}
	IL db query(RG int l, RG int r)
	{
		using namespace TA;
		#define query_point(x) (query0(x) * (x) + query1((x) - 1))
		RG db ans = query_point(r);
		if(l != 1) ans -= query_point(l - 1);
		return ans;
	}

	struct Node *null;
	struct Node
	{
		Node *fa, *son[2];
		IL bool type() {return fa->son[1] == this;}
		IL bool check() {return fa->son[type()] == this;}
		IL void rotate()
		{
			RG Node *f = fa;
			RG bool d = type();
			(fa = f->fa), f->check() ? fa->son[f->type()] = this : 0;
			(f->son[d] = son[!d]) != null ? son[!d]->fa = f : 0;
			(son[!d] = f)->fa = this;
		}
		IL void splay()
		{
			for(; check(); rotate()) if(fa->check())
				type() != fa->type() ? rotate() : fa->rotate();
		}
		IL void modify(RG int d)
		{
			//if(this == null) return;
///*lgg*/printf("modify %d += %d\n", int(this - null), d);
			pb_ds::modify(lef[this - null], rig[this - null], d);
		}
		IL Node* find()
		{
			RG Node *o = this;
			while(o->son[0] != null) o = o->son[0];
			return o;
		}
	} node[MAXN];

	IL void access(RG Node *i)
	{
		for(RG Node *j = null; i != null; i = (j = i)->fa)
		{
///*lgg*/printf("access i = %d\n", int(i - node));
			i->splay();
			if(i->son[1] != null)
				i->son[1]->find()->modify(1);
			if((i->son[1] = j) != null)
				j->find()->modify(-1);
		}
	}

	void dfs(RG int i)
	{
		lef[i] = ++timer;
		node[i].son[0] = node[i].son[1] = null;
		for(RG Pointer *iter = fir[i]; iter; iter = iter->next)
			if(!lef[iter->to])
			{
				node[iter->to].fa = node + i;
				dfs(iter->to);
			}
		rig[i] = timer;
	}

	IL void print(RG db x)
	{
		io::P(int(x), '.');
		x -= int(x);
		x += 5e-11;
		for(RG int t = 10; t--; )
		{
			x *= 10;
			*io::iter++ = '0' + int(x);
			x -= int(x);
		}
		*io::iter++ = '\n';
	}

	IL void main()
	{
		RG int (*F)() = io::F;
		RG char (*G)() = io::get;
		null = node;
		null->fa = null;
		For(__, 1, F())
		{
			RG int n = F();

			node[1].fa = null;
			tot = mem;
			memset(fir + 1, 0, n * sizeof *fir);
			memset(lef + 1, 0, n << 2);

			For(i, 2, n) link(F() + 1, F() + 1);
			timer = 0;
			dfs(1);
///*lgg*/printf("timer = %d\n", timer);
			TA::clear();
			For(i, 1, n) node[i].modify(1);
			RG int x;
			For(__, 1, F())
			{
///*lgg*/printf("__ = %d\n", __);
				if(G() == 'q')
				{
					x = F() + 1;
///*lgg*/printf("sum = %.0lf\n", query(lef[x], rig[x]));
					print(query(lef[x], rig[x]) / (rig[x] - lef[x] + 1) - 1);
				}
				else
				{
					x = F() + 1;
					access(node + x);
				}
			}
		}
	}
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("D.in", "r", stdin);
    freopen("std.out", "w", stdout);
#endif

	//set_file("tle");
	pb_ds::main();
	io::output();
	close_file();
}
/*
10 0
1 4 0 5 8 1 6 6 4 4
^/\*lgg\*/
