#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	100005
#define I64	long long
#define CH	(ch=getchar())
#define For(i,a,b)	for(int i=a;i<=b;i++)

char	s[5];
int		N,C,D,L[n],R[n],st[n];
struct	Lin{int v,next;}E[n<<1];

namespace	Seg{
		int laz[n<<2],siz[n<<2];	I64	Sum[n<<2];

		void	Build(int u,int l,int r){
			int Mid=l+r>>1;	Sum[u]=laz[u]=0;siz[u]=r-l+1;
			if	(l^r)	Build(u<<1,l,Mid),Build(u<<1|1,Mid+1,r);
		}
		void	Upd(int x,int t)	{Sum[x]+=t*siz[x];laz[x]+=t;}
		void	Dn(int x)	{
			if	(laz[x])	Upd(x<<1,laz[x]),Upd(x<<1|1,laz[x]),laz[x]=0;
		}
		void	Up(int x)	{Sum[x]=Sum[x<<1]+Sum[x<<1|1];}

		void	Modify(int u,int l,int r,int x,int y,int t){
			if	(x<=l&&r<=y){Upd(u,t);return;}	int Mid=l+r>>1;	Dn(u);
			if	(x<=Mid)	Modify(u<<1,l,Mid,x,y,t);
			if	(y>Mid)		Modify(u<<1|1,Mid+1,r,x,y,t);	Up(u);
		}
		I64		Query(int u,int l,int r,int x,int y){
			if	(x<=l&&r<=y)return	Sum[u];	int Mid=l+r>>1;	Dn(u);
			if	(y<=Mid)	return	Query(u<<1,l,Mid,x,y);
			if	(x>Mid)		return	Query(u<<1|1,Mid+1,r,x,y);
			return	Query(u<<1,l,Mid,x,y)+Query(u<<1|1,Mid+1,r,x,y);
		}
};

namespace	LCT{
		int	F[n],ch[n][2];

		void	ReSet(int x,int f)	{F[x]=f;ch[x][0]=ch[x][1]=0;}
		bool	Top(int x)	{return	ch[F[x]][0]!=x&&ch[F[x]][1]!=x;}

		void	Rot(int x){
			int y=F[x],z=F[y],k=ch[y][0]==x,t;
			if	(t=ch[y][!k]=ch[x][k])	F[t]=y;
			if	(ch[z][0]==y)	ch[z][0]=x;
			if	(ch[z][1]==y)	ch[z][1]=x;
			F[x]=z;	ch[F[y]=x][k]=y;
		}
		void	Splay(int x){
			for (;!Top(x);Rot(x)){
				int y=F[x],z=F[y];
				if	(!Top(y))	(ch[y][0]==x^ch[z][0]==y)?Rot(x):Rot(y);
			}
		}

		void	Acc(int x){
			for (int y=0,t;x;x=F[y=x]){
				Splay(x);
				if	(ch[x][1]){
					for (t=ch[x][1];ch[t][0];t=ch[t][0]);
					Seg::Modify(1,1,C,L[t],R[t],1);
				}
				if	(y)	{
					for (t=y;ch[t][0];t=ch[t][0]);
					Seg::Modify(1,1,C,L[t],R[t],-1);
				}	ch[x][1]=y;
			}
		}
};

int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}
void	Link(int u,int v){
		E[++D]=(Lin){v,st[u]};	st[u]=D;
		E[++D]=(Lin){u,st[v]};	st[v]=D;
}
void	DFS(int u,int f){
		LCT::ReSet(u,f);	L[u]=++C;
		for (int i=st[u],v;i;i=E[i].next)
			if	((v=E[i].v)^f)	DFS(v,u);	R[u]=C;
		if	(u!=1)	Seg::Modify(1,1,N,L[u],R[u],1);
}

int		main(){
		for (int T=IN();T--;C=D=0){
			N=IN();		For(i,1,N)	st[i]=0;
			For(i,2,N)	Link(IN()+1,IN()+1);
			Seg::Build(1,1,N);	DFS(1,0);

			for (int Q=IN();Q--;){
				scanf("%s",s);	int x=IN()+1;
				if	(s[0]=='O')	LCT::Acc(x);
					else	printf("%.8lf\n",1.*Seg::Query(1,1,N,L[x],R[x])/(R[x]-L[x]+1));
			}
		}
}