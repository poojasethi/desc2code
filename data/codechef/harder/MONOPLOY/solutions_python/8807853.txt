#include<bits/stdc++.h>
using namespace std;
typedef long long int64;
struct Ttree{
	static const int maxn=100010;
	struct Tedge{
		int son; Tedge *pre;
		void add(int s_,Tedge *p_){ son=s_,pre=p_; }
	}edge[maxn<<1],*pos[maxn];
	int tot;
	void add(int a,int b){ edge[++tot].add(b,pos[a]),pos[a]=edge+tot; }
	void clear(int n){ tot=0; for(int i=1;i<=n;++i) pos[i]=0; }
}t;
struct Tsegment_tree{
	static const int maxn=300010;
	struct Tseg{
		int add; int64 sum;
	}t[maxn];
	int n;
	void build(int p,int l,int r,int v[]){
		t[p].add=0; if(l==r){ t[p].sum=v[l]; return; }
		int mid=(l+r)>>1,lc=p<<1,rc=lc|1;
		build(lc,l,mid,v),build(rc,mid+1,r,v);
		t[p].sum=t[lc].sum+t[rc].sum;
	}
	void build(int newn,int v[]){ n=newn,build(1,1,n,v); }
	
	void modify(int p,int l,int r,int a,int b,int64 c){
		if(l>=a && r<=b){ t[p].add+=c,t[p].sum+=(r-l+1)*c; return; }
		int mid=(l+r)>>1,lc=p<<1,rc=lc|1;
		if(a<=mid) modify(lc,l,mid,a,b,c);
		if(b>mid) modify(rc,mid+1,r,a,b,c);
		t[p].sum=(r-l+1LL)*t[p].add+t[lc].sum+t[rc].sum;
	}
	int64 query(int p,int l,int r,int a,int b){
		if(l>=a && r<=b) return t[p].sum;
		int mid=(l+r)>>1,lc=p<<1,rc=lc|1;
		int64 ans=(min(b,r)-max(a,l)+1LL)*t[p].add;
		if(a<=mid) ans+=query(lc,l,mid,a,b);
		if(b>mid) ans+=query(rc,mid+1,r,a,b);
		return ans;
	}
	inline void modify(int a,int b,int c){ modify(1,1,n,a,b,c); }
	inline int64 query(int a,int b){ return query(1,1,n,a,b); }
}seg;
void modify_subtree(int x,int v);
struct Tlink_cut_tree{
	static const int maxn=100010;
	struct Tspy{
		Tspy *c[2],*f; int n;
	}t[maxn],*null;
	int tot;
	inline Tspy *newnode(){
		++tot; t[tot].c[0]=t[tot].c[1]=t[tot].f=null,t[tot].n=2; 
		return t+tot;
	}
	void clear(int n){
		null=t,null->c[0]=null->c[1]=null,tot=0;
		for(int i=1;i<=n;++i) newnode();
	}
	inline void link(int u,int v){ t[u].f=t+v; }
	
	void rotate(Tspy *x){
		Tspy *y=x->f,*z=y->f; int nx=x->n,ny=y->n;
		x->f=z,x->n=ny; if(ny!=2) z->c[ny]=x;
		z=x->c[1-nx];
		y->f=x,y->n=1-nx,x->c[1-nx]=y;
		z->f=y,z->n=nx,y->c[nx]=z;
	}
	void splay(Tspy *x){
		while(x->n!=2){
			(x->n==x->f->n)?rotate(x->f):rotate(x);
			if(x->n!=2) rotate(x);
		}
	}
	Tspy *head(Tspy *x){
		for(splay(x);x->c[0]!=null;x=x->c[0]);
		return x;
	}
	
	void access(int u){
		for(Tspy *x=t+u,*y=null;x!=null;y=x,x=x->f){
			splay(x),x->c[1]->n=2;
			if(x->c[1]!=null)
				modify_subtree(head(x->c[1])-t,+1);
			if(y!=null)
				modify_subtree(head(y)-t,-1);
			x->c[1]=y,y->n=1;
		}
	}
}lct;
const int maxn=100010;
int l[maxn],r[maxn],o[maxn],sign;
int fa[maxn],dep[maxn],n,m;

void dfs(int x){
	++sign,o[sign]=x,l[x]=sign;
	for(Ttree::Tedge *i=t.pos[x];i;i=i->pre)
		if(i->son!=fa[x]){
			fa[i->son]=x,lct.link(i->son,x);
			dep[i->son]=dep[x]+1,dfs(i->son);
		}
	r[x]=sign;
}
void init(){
	scanf("%d",&n),t.clear(n),lct.clear(n);
	for(int i=1,a,b;i<=n-1;++i){
		scanf("%d%d",&a,&b),++a,++b;
		t.add(a,b),t.add(b,a);
	}
	fa[1]=0,dep[1]=0,sign=0,dfs(1);
	for(int i=1;i<=n;++i)
		o[i]=dep[o[i]];
	seg.build(n,o),scanf("%d",&m);
}

void modify_subtree(int x,int v){ seg.modify(l[x],r[x],v); }
double query_subtree(int x){ return seg.query(l[x],r[x])/(r[x]-l[x]+1.0); }
int main(){
	int T; scanf("%d",&T);
	for(int run=1;run<=T;++run){
		init();
		for(int i=1;i<=m;++i){
			char s[2]; int u;
			scanf("%s%d",s,&u); ++u;
			if(s[0]=='q')
				printf("%.6f\n",query_subtree(u));
			else lct.access(u);
		}
	}
	return 0;
}