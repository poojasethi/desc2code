#include <cstdio>
#include <cstring>
#include <algorithm>
#define memcle(a) memset(a, 0, sizeof(a))
using namespace std;
typedef long long ll;

const int N = 201000, M = 2 * N;
int adj[M], next[M], last[N], size[N], left[N], right[N];
ll ans, f[N], sum[N * 4], tag[N * 4];
int par[N], fa[N], son[N][2], path[N], fx[N], que[N];
int n, mm, q, DFN;

inline int max(int x, int y) {return x > y ? x : y;}
inline int min(int x, int y) {return x < y ? x : y;}

void init()
{
	//memcle(last); memcle(left); memcle(right);
	for (int i = 1; i <= n; i++) last[i] = left[i] = right[i] = par[i] = fa[i] = son[i][0] = son[i][1] = 0, f[i] = 0;
	for (int i = 1; i <= 4 * n; i++) sum[i] = tag[i] = 0;
	n = mm = q = DFN = 0; ans = 0;
}

void link(int x, int y) {adj[++mm] = y, next[mm] = last[x], last[x] = mm;}

void spread(int x, int l, int r)
{
	if (tag[x])
	{
		int mid = (l + r) >> 1;
		sum[x + x] += tag[x] * (mid - l + 1);
		tag[x + x] += tag[x];
		sum[x + x + 1] += tag[x] * (r - mid);
		tag[x + x + 1] += tag[x];
		tag[x] = 0;
	}
}

void make(int x, int l, int r)
{
	if (l == r) {sum[x] = f[que[l]]; return;}
	int mid = (l + r) >> 1;
	make(x + x, l, mid);
	make(x + x + 1, mid + 1, r);
	sum[x] = sum[x + x] + sum[x + x + 1];
}

void modi(int x, int l, int r, int ql, int qr, int d)
{
	ql = max(l, ql), qr = min(r, qr); if (ql > qr) return;
	if (ql == l && qr == r)
	{
		sum[x] += d * (r - l + 1);
		tag[x] += d;
		return;
	}
	//spread(x, l, r);
	int mid = (l + r) >> 1;
	if (mid >= ql) modi(x + x, l, mid, ql, qr, d);
	if (mid + 1 <= qr) modi(x + x + 1, mid + 1, r, ql, qr, d);
	sum[x] = sum[x + x] + sum[x + x + 1] + tag[x] * (r - l + 1);
}

ll getsum(int x, int l, int r, int ql, int qr)
{
	ql = max(l, ql), qr = min(r, qr); if (ql > qr) return 0;
	if (ql == l && qr == r) return sum[x];
	//spread(x, l, r);
	int mid = (l + r) >> 1;
	ll ret = tag[x] * (qr - ql + 1);
	return ret + getsum(x + x, l, mid, ql, qr) + getsum(x + x + 1, mid + 1, r, ql, qr);
}

void maketree(int x)
{
	left[x] = ++DFN;
	que[DFN] = x;
	size[x] = 1;
	for (int p = last[x]; p; p = next[p])
		if (adj[p] != par[x])
		{
			f[adj[p]] = f[x] + 1;
			par[adj[p]] = x;
			maketree(adj[p]);
			size[x] += size[adj[p]];
		}
	right[x] = DFN;
}

void rotate(int x, int fx)
{
	int y = fa[x];
	int z = fa[y];
	int a = son[x][fx ^ 1];
	
	par[x] = par[y]; par[y] = 0;
	
	if (a) fa[a] = y;
	son[y][fx] = a;
	
	fa[y] = x;
	son[x][fx ^ 1] = y;
	
	fa[x] = z;
	if (z) son[z][son[z][1] == y] = x;
}

void splay(int x)
{
	int m = 0;
	for (int i = x; i; i = fa[i]) path[++m] = i;
	for (int i = 1; i < m; i++) fx[i] = (son[path[i + 1]][1] == path[i]);
	for (int i = 1; i < m; i += 2)
	{
		if (i == m - 1) rotate(x, fx[i]); else 
		if (fx[i] == fx[i + 1]) rotate(path[i + 1], fx[i + 1]), rotate(x, fx[i]); else 
		rotate(x, fx[i]), rotate(x, fx[i + 1]);
	}
}

int ml(int x) 
{
	splay(x);
	for (; son[x][0]; ) x = son[x][0];
	return x;
}

void split(int x)
{
	splay(x);
	int y = son[x][1];
	if (y)
	{
		son[x][1] = fa[y] = 0;
		par[y] = x;
		int z = ml(y);
		modi(1, 1, n, left[z], right[z], 1);
	}
}

void merge(int x, int y)
{
	splay(x);
	splay(y);
	
	int z = ml(y);
	modi(1, 1, n, left[z], right[z], -1);
	
	par[y] = 0;
	fa[y] = x;
	son[x][1] = y;
}

void access(int x)
{
	split(x);
	int y = x;
	for (x = par[x]; x; y = x, x = par[x]) 
	{
		split(x);
		merge(x, y);
	}
}

char read()
{
	char c = getchar();
	for (; c != 'q' && c != 'O'; ) c = getchar();
	return c;
}

int main()
{
	int test;
	scanf("%d", &test);
	for (; test--; )
	{
	init();
	scanf("%d", &n);
	for (int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		u++;
		v++;
		link(u, v);
		link(v, u);
	}
	
	maketree(1);
	make(1, 1, n);
	
	scanf("%d", &q);
	
	for (int i = 1, u; i <= q; i++)
	{
		if (read() == 'q')
		{
			scanf("%d", &u); u++;
			ans = getsum(1, 1, n, left[u], right[u]);
			printf("%.10f\n", ans * 1.0 / size[u]);
		} else 
		{
			scanf("%d", &u); u++;
			access(u);
		}
	}
	}
	return 0;
}