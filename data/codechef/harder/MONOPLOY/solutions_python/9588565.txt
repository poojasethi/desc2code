// Claris you are our red sun, I can not live without you.
// NanoApe you are our red sun, I can not live without you.
// YJQ you are our red sun, I can not live without you.
#include <bits/stdc++.h>
using namespace std;
inline int getint() {
	int x=0, c=getchar();
	for(; c<48||c>57; c=getchar());
	for(; c>47&&c<58; x=x*10+c-48, c=getchar());
	return x;
}
typedef long long ll;
const int N=100015;
int ihead[N], cnt, FF[N], LL[N], fa[N], fid, n, c2[N];
ll c1[N], a[N];
struct E {
	int next, to;
}e[N<<1];
void add(int x, int y) {
	e[++cnt]=(E){ihead[x], y}; ihead[x]=cnt;
	e[++cnt]=(E){ihead[y], x}; ihead[y]=cnt;
}
void upd(int x, int g) {
	for(ll t=(ll)g*x; x<=n; x+=x&-x) {
		c1[x]+=t;
		c2[x]+=g;
	}
}
void upd(int l, int r, int g) {
	upd(l, g);
	upd(r+1, -g);
}
ll sum(int y) {
	ll a=0, b=0;
	for(int x=y; x; x-=x&-x) {
		a+=c1[x];
		b+=c2[x];
	}
	return b*(y+1)-a;
}
ll sum(int l, int r) {
	return sum(r)-sum(l-1)+a[r]-a[l-1];
}
namespace Lct {
	struct node *null;
	struct node {
		node *c[2], *f;
		int x, l;
		void init(int _x=0) {
			c[0]=c[1]=f=null;
			x=l=_x;
		}
		void setc(node *x, bool d) {
			c[d]=x;
			x->f=this;
		}
		bool d() {
			return f->c[1]==this;
		}
		bool isson() {
			return f->c[0]==this || f->c[1]==this;
		}
		void up() {
			l=c[0]==null?x:c[0]->l;
		}
	}Po[N], *iT=Po;
	void rot(node *x) {
		node *f=x->f;
		bool d=x->d();
		f->isson()?f->f->setc(x, f->d()):(void)(x->f=f->f);
		f->setc(x->c[!d], d);
		x->setc(f, !d);
		f->up();
	}
	void splay(node *x) {
		for(; x->isson(); rot(x)) {
			if(x->f->isson()) {
				x->d()==x->f->d()?rot(x->f):rot(x);
			}
		}
		x->up();
	}
	node *access(node *x) {
		node *y=null;
		for(; x!=null; y=x, x=x->f) {
			splay(x);
			node *z=x->c[1];
			x->c[1]=y;
			if(y!=null) {
				upd(FF[y->l], LL[y->l], -1);
			}
			if(z!=null) {
				upd(FF[z->l], LL[z->l], 1);
			}
		}
		return y;
	}
	void init() {
		iT=Po;
		null=iT++;
		null->init();
	}
}
Lct::node *nd[N];
void dfs(int x, int s=0) {
	FF[x]=++fid;
	a[fid]=s;
	nd[x]=Lct::iT++;
	nd[x]->init(x);
	nd[x]->f=nd[fa[x]];
	for(int i=ihead[x]; i; i=e[i].next) {
		int y=e[i].to;
		if(y!=fa[x]) {
			fa[y]=x;
			dfs(y, s+1);
		}
	}
	LL[x]=fid;
}
int main() {
	for(int T=getint(); T--; ) {
		n=getint();
		memset(ihead, 0, sizeof(int)*(n+1));
		memset(c1, 0, sizeof(ll)*(n+1));
		memset(c2, 0, sizeof(int)*(n+1));
		cnt=fid=0;
		for(int i=1; i<n; ++i) {
			add(getint()+1, getint()+1);
		}
		Lct::init();
		nd[0]=Lct::null;
		dfs(1);
		for(int i=2; i<=n; a[i]+=a[i-1], ++i);
		for(int m=getint(); m--; ) {
			char c=getchar();
			for(; !(c=='q'||c=='O'); c=getchar());
			int x=getint()+1;
			if(c=='O') {
				Lct::access(nd[x]);
			}
			else {
				printf("%.10f\n", (double)sum(FF[x], LL[x])/(LL[x]-FF[x]+1));
			}
		}
	}
	return 0;
}