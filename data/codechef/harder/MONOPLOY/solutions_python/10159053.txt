#include <bits/stdc++.h>
using namespace std;

template<typename T>inline void Read(T &x)
{
    int f = 1;
    char t = getchar();
    while (t < '0' || t > '9') {
        if (t == '-') f = -1;
        t = getchar();
    }
    x = 0;
    while (t >= '0' && t <= '9') {
        x = x * 10 + t - '0';
        t = getchar();
    }
    x *= f;
}

template<typename T>inline void Write(T x)
{
    static int output[20];
    int top = 0;
    if (x < 0) putchar('-'), x = -x;
    do {
        output[++top] = x % 10;
        x /= 10;
    } while (x > 0);
    while (top > 0) putchar('0' + output[top --]);
    putchar('\n');
}

template<typename T>inline void chkmin(T &x, T y) { if (x > y) x = y; }
template<typename T>inline void chkmax(T &x, T y) { if (x < y) x = y; }

const int maxn = 200005;
const int inf = 0x3f3f3f3f;

int n;
int q;
vector<int> e[maxn];

namespace SEGT
{
    long long add[maxn << 2];
    long long sum[maxn << 2];

    void init()
    {
        memset(add, 0, sizeof(add));
        memset(sum, 0, sizeof(sum));
    }

    void pushdown(int cn, int l, int r)
    {
        if (add[cn]) {
            int mid = (l + r) >> 1;
            add[cn << 1] += add[cn];
            add[cn << 1 | 1] += add[cn];
            sum[cn << 1] += add[cn] * (mid - l + 1);
            sum[cn << 1 | 1] += add[cn] * (r - mid);
            add[cn] = 0;
        }
    }

    inline void update(int cn)
    {
        sum[cn] = sum[cn << 1] + sum[cn << 1 | 1];
    }

    void getadd(int cn, int l, int r, int l0, int r0, long long v)
    {
        if (l == l0 && r == r0) {
            sum[cn] += v * (r - l + 1);
            add[cn] += v;
            return;
        }
        pushdown(cn, l, r);
        int mid = (l + r) >> 1;
        if (r0 <= mid) getadd(cn << 1, l, mid, l0, r0, v);
        else if (l0 > mid) getadd(cn << 1 | 1, mid + 1, r, l0, r0, v);
        else getadd(cn << 1, l, mid, l0, mid, v), getadd(cn << 1 | 1, mid + 1, r, mid + 1, r0, v);
        update(cn);
    }

    long long query(int cn, int l, int r, int l0, int r0)
    {
        if (l == l0 && r == r0) return sum[cn];
        pushdown(cn, l, r);
        int mid = (l + r) >> 1;
        long long ret;
        if (r0 <= mid) ret = query(cn << 1, l, mid, l0, r0);
        else if (l0 > mid) ret = query(cn << 1 | 1, mid + 1, r, l0, r0);
        else ret = query(cn << 1, l, mid, l0, mid) + query(cn << 1 | 1, mid + 1, r, mid + 1, r0);
        return ret;
    }
};

namespace LCT
{
    struct node
    {
        int sz;
        int fa;
        int id;
        int dep;
        int minv;
        int c[2];

        node()
        {
            sz = fa = id = dep = 0;
            minv = inf;
            c[0] = c[1] = 0;
        }
    };

    node T[maxn];
    int in[maxn];
    int out[maxn];
    int dfn[maxn];
    int counter;

#define Lc(x) T[T[x].c[0]]
#define Rc(x) T[T[x].c[1]]
#define Fa(x) T[T[x].fa]
#define isroot(x) ((Fa(x).c[0] != x) && (Fa(x).c[1] != x))

    void init(int n)
    {
        counter = 0;
        for (int i = 1; i <= n; i++) {
            in[i] = 0;
            out[i] = 0;
            T[i] = node();
        }
        SEGT::init();
    }

    inline void setc(int x, int y, bool mark)
    {
        if (x) T[x].fa = y;
        if (y) T[y].c[mark] = x;
    }

    inline void update(int cn)
    {
        T[cn].minv = min(Lc(cn).minv, T[cn].id);
    }

    inline void rotate(int x)
    {
        if (isroot(x)) return;
        int p = T[x].fa;
        bool mark = (x == T[p].c[1]);
        if (isroot(p)) T[x].fa = T[p].fa;
        else setc(x, T[p].fa, p == Fa(p).c[1]);
        setc(T[x].c[mark ^ 1], p, mark);
        setc(p, x, mark ^ 1);
        update(p);
    }

    inline void splay(int x)
    {
        while (!isroot(x)) {
            int p = T[x].fa;
            if (!isroot(p)) {
                if ((x == Fa(x).c[1]) ^ (p == Fa(p).c[1])) rotate(x);
                else rotate(p);
            }
            rotate(x);
        }
        update(x);
    }

    inline void access(int x)
    {
        int to;
        for (int r = 0; x > 0; r = x, x = T[x].fa) {
            splay(x);
            if (T[x].c[1]) {
                to = dfn[Rc(x).minv];
                SEGT::getadd(1, 1, n, in[to], out[to], 1);
            }
            T[x].c[1] = r;
            if (r > 0) {
                to = dfn[T[r].minv];
                SEGT::getadd(1, 1, n, in[to], out[to], -1);
            }
            update(x);
        }
    }

    inline double query(int x)
    {
        return SEGT::query(1, 1, n, in[x], out[x]) * 1.0 / T[x].sz;
    }

    void dfs(int cn, int pr)
    {
        T[cn].sz = 1;
        in[cn] = out[cn] = ++counter;
        dfn[counter] = cn;
        T[cn].id = T[cn].minv = counter;
        for (vector<int>::iterator i = e[cn].begin(); i != e[cn].end(); i++) {
            if (*i != pr) {
                T[*i].dep = T[cn].dep + 1;
                T[*i].fa = cn;
                dfs(*i, cn);
                T[cn].sz += T[*i].sz;
                chkmax(out[cn], out[*i]);
            }
        }
    }

    void build(int cn, int l, int r)
    {
        using namespace SEGT;
        if (l == r) {
            sum[cn] = T[dfn[l]].dep;
            return;
        }
        int mid = (l + r) >> 1;
        build(cn << 1, l, mid);
        build(cn << 1 | 1, mid + 1, r);
        SEGT::update(cn);
    }
};

void input()
{
    Read(n);
    for (int i = 1; i <= n; i++) e[i].clear();
    for (int i = 1; i < n; i++) {
        static int x, y;
        Read(x);
        Read(y);
        e[x + 1].push_back(y + 1);
        e[y + 1].push_back(x + 1);
    }
    Read(q);
}

void prepare()
{
    LCT::init(n);
    LCT::dfs(1, 0);
    LCT::build(1, 1, n);
}

void solve()
{
    char type[2];
    int x;
    while (q --) {
        scanf("%s", type + 1);
        Read(x);
        if (type[1] == 'q') {
            printf("%.6f\n", LCT::query(x + 1));
        } else {
            LCT::access(x + 1);
        }
    }
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int T;
    Read(T);
    while (T --) {
        input();
        prepare();
        solve();
    }

#ifndef ONLINE_JUDGE
    cerr << (double) clock() / CLOCKS_PER_SEC << " s" << endl;
    fclose(stdin);
    fclose(stdout);
#endif
    return 0;
}
