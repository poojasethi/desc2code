#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)
#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)
using namespace std;
typedef long long LL;
typedef double db;
const int N=110000;
inline void read(int &x){
	x=0;char p=getchar();
	while(!(p<='9'&&p>='0'))p=getchar();
	while(p<='9'&&p>='0')x*=10,x+=p-48,p=getchar();
}
int head[N],np[N<<1],p[N<<1],tot;
int n,Q;
int st[N],ed[N],dfn,fa[N],dep[N],idx[N];
inline void link(int a,int b){
	++tot;p[tot]=b;np[tot]=head[a];head[a]=tot;
	++tot;p[tot]=a;np[tot]=head[b];head[b]=tot;
}
void dfs(int x){
	st[x]=++dfn;dep[x]=dep[fa[x]]+1;idx[dfn]=x;
	for(int u=head[x];u;u=np[u])if(p[u]^fa[x]){
		fa[p[u]]=x;dfs(p[u]);
	}
	ed[x]=dfn;
}
//segment tree
LL sum[N*4],tag[N*4];
inline void down(int me,int l,int r){
	int mid=(l+r)>>1;
	tag[me<<1]+=tag[me];tag[me<<1|1]+=tag[me];
	sum[me<<1]+=tag[me]*1ll*(mid-l+1);
	sum[me<<1|1]+=tag[me]*1ll*(r-mid);
	tag[me]=0;
}
void add(int me,int l,int r,int x,int y,int v){
	if(l^r)down(me,l,r);
	if(x<=l&&r<=y){
		sum[me]+=(r-l+1)*1ll*v;
		tag[me]+=1ll*v;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)add(me<<1,l,mid,x,y,v);
	if(y>mid)add(me<<1|1,mid+1,r,x,y,v);
	sum[me]=sum[me<<1]+sum[me<<1|1];
}
LL ask(int me,int l,int r,int x,int y){
	if(l^r)down(me,l,r);
	if(x<=l&&r<=y)return sum[me];
	LL ret=0;
	int mid=(l+r)>>1;
	if(x<=mid)ret+=ask(me<<1,l,mid,x,y);
	if(y>mid)ret+=ask(me<<1|1,mid+1,r,x,y);
	return ret;
}
void build(int me,int l,int r){
	if(l==r){
		sum[me]=dep[idx[l]]-1;
		return;
	}
	int mid=(l+r)>>1;
	build(me<<1,l,mid);
	build(me<<1|1,mid+1,r);
	sum[me]=sum[me<<1]+sum[me<<1|1];
}
//end
//LCT
namespace lct{
	int l[N],r[N],fa[N];
	inline bool top(int x){return (!fa[x])||(l[fa[x]]!=x&&r[fa[x]]!=x);}
	inline void left(int x){
		int y=fa[x];int z=fa[y];
		r[y]=l[x];if(l[x])fa[l[x]]=y;
		fa[x]=z;if(l[z]==y)l[z]=x;else if(r[z]==y)r[z]=x;
		fa[y]=x;l[x]=y;
	}
	inline void right(int x){
		int y=fa[x];int z=fa[y];
		l[y]=r[x];if(r[x])fa[r[x]]=y;
		fa[x]=z;if(l[z]==y)l[z]=x;else if(r[z]==y)r[z]=x;
		fa[y]=x;r[x]=y;
	}
	inline void splay(int x){
		while(!top(x)){
			int y=fa[x];int z=fa[y];
			if(top(y)){
				if(l[y]==x)right(x);else left(x);
			}
			else{
				if(l[z]==y){
					if(l[y]==x)right(y),right(x);
					else left(x),right(x);
				}
				else{
					if(r[y]==x)left(y),left(x);
					else right(x),left(x);
				}
			}
		}
	}
	inline int findleft(int x){
		splay(x);
		int y=x;while(l[y])y=l[y];
		return y;
	}
	inline int access(int x){
		int y=0;
		for(;x;y=x,x=fa[x]){
			splay(x);
			int tmp=r[x];
			if(y){
				int g1=findleft(y);
				add(1,1,n,st[g1],ed[g1],-1);
			}
			r[x]=y;
			if(tmp){
				int gg=findleft(tmp);
				add(1,1,n,st[gg],ed[gg],1);
			}
		}
		return y;
	}
};
//end
void init(){
	rep(i,1,tot)np[i]=p[i]=0;
	tot=0;
	rep(i,1,n)head[i]=0;
	rep(i,1,n)st[i]=ed[i]=0;
	dfn=0;
	rep(i,1,n)fa[i]=0;
	rep(i,1,n*4)sum[i]=tag[i]=0;
	rep(i,1,n)lct::fa[i]=lct::l[i]=lct::r[i]=0;
}
void Main(){
	read(n);
	init();
	rep(i,1,n-1){
		int a,b;read(a);read(b);a++;b++;
		link(a,b);
	}
	dfs(1);
	build(1,1,n);
	read(Q);
	rep(i,1,n)lct::fa[i]=fa[i];
	while(Q--){
		char opt[5];scanf("%s",opt+1);
		if(opt[1]=='O'){
			int x;read(x);++x;
			lct::access(x);
		}
		else{
			int x;read(x);++x;
			printf("%.10lf\n",(ask(1,1,n,st[x],ed[x])*1.)/(ed[x]-st[x]+1));
		}
	}
}
int main(){
	int T;read(T);
	while(T--)Main();
	return 0;
}


