#include <cmath>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
 
#define n	55
#define m	40005
#define P	1000000007
#define For(i,a,b)	for(int i=a;i<=b;i++)
#define Rep(i,a,b)	for(int i=a;i>=b;i--)
 
#define CH	(ch=getchar())
int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}
int		Pow(int a,int b,const int&mo=P){
		int ret=1;
		for (;b;b>>=1,a=1ll*a*a%mo)
			if	(b&1)	ret=1ll*ret*a%mo;
		return	ret;
}
 
#define I64	long long
const	I64	LIM=1ll<<61;
const	int	mo[3]={167772161,469762049,1004535809};
int 	T,Q,Max,L[m],R[m],GT[m],Ans[m*20];
I64		t[n][n],ret[m][4];
 
struct	Nod{int K,ID;};
vector<Nod>G[n][n]; 
 
struct	Mat{
		int	N,A[n][n];

		void	Init(int _N)	{
			N=_N;
			For(i,1,N)	For(j,1,N)	A[i][j]=(i==j);
		}
 
		Mat	operator *	(const Mat&b){
			Mat	c,a=*this;	c.N=N;
			For(i,1,N)	For(j,1,N)	t[i][j]=0;
			For(k,1,N)	For(i,1,N)	if	(a.A[i][k])
			For(j,i,N)	if	(b.A[k][j])	{
				t[i][j]=1ll*a.A[i][k]*b.A[k][j]+t[i][j];
				if	(t[i][j]>=LIM)	t[i][j]%=P;
			}
			For(i,1,N)	For(j,i,N)	c.A[i][j]=c.A[j][i]=t[i][j]%P;
			return	c;
		}
		int		DET(){
			int ret=1;
			for	(int i=1,j;i<=N;i++){
				for (j=i;j<=N&&!A[j][i];j++);
				if	(j>N)	return	0;
				if	(j!=i)	{
					ret*=-1;
					For(k,i,N)	swap(A[j][k],A[i][k]);
				}
 
				For(j,i+1,N)if	(A[j][i]){
					int t=1ll*A[j][i]*Pow(A[i][i],P-2)%P;
					For(k,i,N)	if	(A[i][k])	A[j][k]=(-1ll*t*A[i][k]+A[j][k])%P;
				}
			}
			For(i,1,N)	ret=1ll*ret*A[i][i]%P;
			return	ret;
		}
		int		tra(){
			int ret=0;
			For(i,1,N)	ret=(ret+A[i][i])%P;
			return	ret;
		}
};
 
struct	Gra{
		int 	N,M,A[n],B[n],Y[n],F[n],G[n],Ans[m];
		Mat		H;
 
		void	Init(){
			N=IN();	M=IN();	H.Init(N);
			For(i,1,M){
				int u=IN(),v=IN();	H.A[u][v]=H.A[v][u]=1;
			}
		}
		void	Main(){
			For(d,0,N)	{
				Mat	tmp=H;	For(i,1,N)	tmp.A[i][i]-=d;	Y[d]=tmp.DET();
			}	B[0]=1;
			For(i,1,N)	B[i]=1ll*B[i-1]*i%P;
			For(i,0,N)	B[i]=Pow(B[i],P-2);
 
			G[0]=1;
			For(i,0,N)	{
				For(j,0,N)	F[j]=G[j],G[j]=0;
				For(j,0,N)	G[j+1]=(G[j+1]+F[j])%P,G[j]=(-1ll*F[j]*i+G[j])%P;
			}
 
			For(i,0,N)	{
				int x=1ll*Y[i]*B[i]%P*B[N-i]*(((N-i)&1)?-1:1)%P;
				For(j,0,N+1)	F[j]=G[j];
				Rep(j,N+1,1)	{
					int t=F[j];
					F[j-1]=(1ll*t*i+F[j-1])%P;
					A[j-1]=(1ll*t*x+A[j-1])%P;
				}
			}
			For(i,0,N-1)A[i]=1ll*A[i]*Pow(A[N],P-2)%P;	A[N]=1;
 
			Mat	tmp;	tmp.Init(N);
			For(i,1,N)	tmp=tmp*H,Ans[i]=tmp.tra();
			For(i,N+1,Max)	For(j,0,N-1)
				Ans[i]=(-1ll*A[j]*Ans[i-N+j]+Ans[i])%P;
			Ans[0]=N;
			For(i,0,Max)	Ans[i]=(Ans[i]+P)%P;
		}
}A[n];
 
struct	CON{
		int 	M,mo,Ans,A[m],B[m],rev[m],w[2][m];
 
		void	reset(){
			for (int i=0;i<M;i++)	A[i]=0;	Ans=0;
		}
		void	Pre(int p){
			for	(M=1;M<=Max;M<<=1);	M<<=1;	mo=p;
			int a=Pow(3,(mo-1)/M,mo),b=Pow(a,mo-2,mo);
 
			for (int i=0;i<M;i++)	{
				w[0][i]=i?1ll*w[0][i-1]*a%mo:1;
				w[1][i]=i?1ll*w[1][i-1]*b%mo:1;
				for (int x=i,t=1;t<M;t<<=1,x>>=1)	(rev[i]<<=1)|=x&1;
			}
		}
		void	NTT(int*A,int f){
			for (int i=0;i<M;i++)
				if	(rev[i]>i)	swap(A[i],A[rev[i]]);
			for (int i=1;i<M;i<<=1)
			for (int j=0,t=M/(i<<1);j<M;j+=i<<1)
			for (int k=0,l=0;k<i;k++,l+=t){
				int	x=A[j+k],y=1ll*A[j+k+i]*w[f][l]%mo;
				A[j+k]=(x+y)%mo;	A[j+k+i]=(x-y)%mo;
			}
			if	(f)	{
				int rev=Pow(M,mo-2,mo);
				for (int i=0;i<M;i++)	A[i]=1ll*A[i]*rev%mo;
			}
		}
		void	Mult(){	
			NTT(A,0);
			for (int i=0;i<M;i++)	A[i]=1ll*A[i]*B[i]%mo;	NTT(A,1);
		}
}FFT[3];
 
int		main(){
		T=IN();
		For(i,1,T)	A[i].Init();	Q=IN();
		For(i,1,Q)	{
			int l=IN(),r=IN(),k=IN();	Max=max(Max,k);
			G[l][r].push_back((Nod){k,i});
		}
 
		L[0]=1;
		For(i,1,Max)	L[i]=1ll*L[i-1]*i%P;
		For(i,0,Max)	R[i]=Pow(L[i],P-2);
		For(i,1,T)	A[i].Main();
 
		For(k,0,2)	{
			FFT[k].Pre(mo[k]);
			For(i,0,Max)	FFT[k].B[i]=(((i&1)?-1:1)*R[i]+P)%P%mo[k];
			FFT[k].NTT(FFT[k].B,0);
		}
 
 		int	inv1=Pow(mo[0],mo[1]-2,mo[1]),inv2=Pow(1ll*mo[0]*mo[1]%mo[2],mo[2]-2,mo[2]);
		For(l,1,T)	{
			For(i,0,Max)	GT[i]=R[i];
			For(r,l,T){
				For(i,0,Max)GT[i]=1ll*GT[i]*A[r].Ans[i]%P;
				if	(!G[l][r].size())	continue;
 
				For(k,0,2)	FFT[k].reset();
				For(i,0,Max)For(k,0,2)	FFT[k].A[i]=GT[i]%mo[k];
				For(k,0,2)	{
					FFT[k].Mult();
					For(i,0,Max)	ret[i][k]=(FFT[k].A[i]+mo[k])%mo[k];
				}

				For(i,0,Max)	{
					I64	x=ret[i][0]+1ll*(ret[i][1]-ret[i][0]+mo[1])%mo[1]*inv1%mo[1]*mo[0];
					I64	y=x+1ll*(ret[i][2]-x%mo[2]+mo[2])%mo[2]*inv2%mo[2]*mo[0]%P*mo[1];
					ret[i][3]=y%P;
				}

				int siz=G[l][r].size();	ret[0][3]=0;
				For(i,1,Max)	{
					ret[i][3]=1ll*ret[i][3]*L[i]+ret[i-1][3];
					if	(ret[i][3]>=LIM)	ret[i][3]%=P;
				}
				For(i,1,siz)	Ans[G[l][r][i-1].ID]=ret[G[l][r][i-1].K][3]%P;
			}
		}
		For(i,1,Q)	printf("%d\n",(Ans[i]+P)%P);
}