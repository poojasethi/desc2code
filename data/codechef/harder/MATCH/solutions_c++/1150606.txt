#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <map>

using namespace std;

int n, m;
double P[5][100];
vector<unsigned> Hsys_arr;
map<unsigned, unsigned> Hsys_ind; // map Hall systems to [0, #Hsystems-1]
unsigned subsets[32]; // if a Hall system contains a Hall set, then it will contain all its subsets as well (that is why #Hsys << 2^2^n)
unsigned next_Hsys_ind[7580][32]; // [i][j] Hall system index if the last Hall system was i and the new node in the set V is connected to the set j of nodes from set U

unsigned get_Hsys_ind(unsigned Hsys) {
    if (!Hsys_ind.count(Hsys)) {
        Hsys_ind[Hsys] = Hsys_arr.size();
        Hsys_arr.push_back(Hsys);
    }
    return Hsys_ind[Hsys];
}
unsigned expand_Hsys(unsigned Hsys_base) { // include all subsets of every set in Hsys_base
    for (unsigned i=0; i<(1u<<n) && (1u<<i)<=Hsys_base; ++i) {
        if (Hsys_base & (1u<<i)) {
            Hsys_base |= subsets[i];
        }
    }
    return Hsys_base;
}
void genall(unsigned Hsys) {
    Hsys = expand_Hsys(Hsys);
    if (Hsys_ind.count(Hsys)) {
        return;
    }
    get_Hsys_ind(Hsys);
    for (unsigned i=0; i<(1u<<n); ++i) {
        if (!(Hsys & (1u<<i))) {
            genall(Hsys | (1u<<i));
        }
    }
}

double dp[2][7580]; // [i&1][j] sum of probabilities that U and the first i nodes of V are connected in such a way that j is the Hall set of the graph
double conn_prob[100][32]; // [i][j] probability that v_i is connected to the set j of U nodes

int bc[32];
int maxmatch(unsigned Hsys) { // size of max-match if the graph has Hall system Hsys
    // equals the size of the largest set in the Hall system
    int ret = 0;
    for (int i=(1<<n); i>0; --i) {
        if (Hsys & (1u<<i)) {
            ret = max(ret, bc[i]);
        }
    }
    return ret;
}

int main() {
    cin >> n >> m;
    for (int i=0; i<n; ++i) {
        for (int j=0; j<m; ++j) {
            cin >> P[i][j];
        }
    }
    for (unsigned i=0; i<(1u<<n); ++i) {
        unsigned s = 1; // the empty set is a subset of any set
        for (unsigned u=i; u>0; u=(u-1u)&i) {
            s |= (1u<<u);
        }
        subsets[i] = s;
    }
    bc[0] = 0;
    for (unsigned i=1u; i<(1u<<n); ++i) {
        bc[i] = bc[i>>1u] + (i&1u);
    }

    genall(1u);
    for (int i=0; i<(int)Hsys_arr.size(); ++i) {
        unsigned Hsys = Hsys_arr[i];
        for (unsigned j=0; j<(1u<<n); ++j) {
            unsigned next = Hsys;
            for (unsigned k=0; k<(1u<<n); ++k) {
                if (Hsys & (1u<<k)) {
                    for (int l=0; l<n; ++l) {
                        if (j & (1u<<l)) {
                            next |= (1u<<(k|(1u<<l)));
                        }
                    }
                }
            }
            next_Hsys_ind[i][j] = get_Hsys_ind(next);
        }
    }

    for (int i=0; i<m; ++i) {
        for (unsigned u=0; u<(1u<<n); ++u) {
            double p = 1.0;
            for (int j=0; j<n; ++j) {
                p *= (u&(1u<<j)) ? P[j][i] : 1.0 - P[j][i];
            }
            conn_prob[i][u] = p;
        }
    }

    dp[1][get_Hsys_ind(1u)] = 1.0;
    for (int i=0; i<m; ++i) {
        int cur = i&1;
        int prev = 1 - cur;
        for (int Hsys_idx=0; Hsys_idx<(int)Hsys_arr.size(); ++Hsys_idx) {
            if (dp[prev][Hsys_idx] > 0.0) {
                for (unsigned u=0; u<(1u<<n); ++u) {
                    dp[cur][next_Hsys_ind[Hsys_idx][u]] += conn_prob[i][u]*dp[prev][Hsys_idx];
                }
                dp[prev][Hsys_idx] = 0.0;
            }
        }
    }

    double sol = 0.0;
    for (int i=0; i<(int)Hsys_arr.size(); ++i) {
        sol += dp[(m+1)&1][i] * maxmatch(Hsys_arr[i]);
    }
    printf("%.8lf\n", sol);

	return 0;
}
