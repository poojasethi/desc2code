/**
 * June 2012 Codechef Long Contest
 *
 * Problem:     MATCH
 * Author:      Anton Lunyov (Tester)
 * Complexity:  O(S * 2^N * N + M * 2^N * S), where S defined below
 * Timing:      0.03 out of 3
 *
 * Description:
 * Recall that we have two sets of vertexes U with |U|=n<=6
 * and V that can be quite large. We call subsets of vertexes in U by masks.
 * We scan vertexes in V one by one. At each moment we should know
 * what probability has each possible graph. But since we care only about
 * value of maximum matching we unite all graphs in several groups.
 * Namely the only thing that we should know is what masks satisfy Hall lemma
 * in the current graph. Mask T satisfies Hall lemma if
 * for each submask S of T we have |ADJ(S)|>=|S|
 * where ADJ(S) is the set of vertexes from V of the graph
 * that are adjacent to some vertex of S. We store this set of masks
 * as a "supermask" of length 2^n (since n<=6 we can use 64bit integer type).
 * Such supermasks will be our DP states.
 * Surprisingly but there is relatively small number of such states.
 */
 
#include <cstdio>
 
typedef unsigned long long ULL;
 
inline int bit(int n) {
    return 1 << n;
}
 
inline ULL bitULL(int n) {
    return ((ULL)1) << n;
}
 
const int maxN = 6; // this solution is so fast that can handle n=6 easily
const int max2N = 1 << maxN;
const int maxM = 100;
 
const int maxS = 3762; // the number of DP states for n=6
 
// sizes[i] = NextPrime[2 * len[i]]
// where len[i] is the number of DP states for n=i
// It is used as the size of hash table when n=i
const int sizes[maxN + 1] = {0, 5, 11, 37, 137, 821, 7529};
const int maxSZ = 7529; // the maximum size for hash table
 
// "bfs" is the queue of DP states traversed in some convenient order
// but it is not real queue; we do not erase old states
// "len" is the current number of states in "bfs"
// After precalc "len" is equal to the total number of DP states
int len;
ULL bfs[maxS];
 
// hash table for efficient finding whether the DP state is new
int SZ; // size of hash table
 
// "what[i]" is some DP state; they are stored in quite random order here
ULL what[maxSZ];
 
// bfs[ind[i]] = what[i]
// So "ind[i]" is the index of DP state "what[i]" in "bfs" array
int ind[maxSZ];
 
// return the index of DP state "state" in the array "bfs"
// if this state is new then insert it to the hash table and to the array "bfs"
int get_ind(ULL state) {
    // position where we try to insert "state"
    int pos = state % SZ;
    while (true) {
        // if "state" has already been before we break
        if (what[pos] == state) {
            break;
        }
        // if this position is empty (note that all states are > 0)
        // we insert it here and add to "bfs"
        if (what[pos] == 0) {
            what[pos] = state;
            bfs[len] = state;
            ind[pos] = len;
            ++len;
            return len-1;
        }
        
        // else we proceed to the next position in circular manner
        // hash function is good; hence this will happen O(1) times in average
        ++pos;
        if (pos==SZ) {
            pos = 0;
        }
    }
    // in the end "what[pos]" is always equal to "state"
    // so "ind[pos]" is correct index of "state" in "bfs"
    return ind[pos];
}
 
// next[mask][k] is the index of DP state (in "bfs" array)
// that we obtain from the DP state "bfs[k]"
// when we add a new vertex v from V such that ADJ(v) = mask to the graph
int next[max2N][maxS];
 
// match[k] is the size of maximum matching of DP state "bfs[k]"
int match[maxS];
 
void precalc(int n) {
    int N = bit(n);
 
    // fixed_size[i] is the supermask of masks that has bitcnt = i
    ULL fixed_size[maxN + 1] = {0};
    for (int mask = 0; mask < N; ++mask)
    {
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            if (mask & bit(i)) { 
                cnt++;
            }
        }
        // "cnt" is now the number of 
        fixed_size[cnt] |= bitULL(mask);
    }
 
    // initialization of hash table and "bfs" array
    SZ = sizes[n];
    for (int k = 0; k < SZ; ++k) {
        what[k] = 0;
    }
    len=0;
 
    // state = 1 represents empty graph
    get_ind(1);
 
    for (int k = 0; k < len; ++k) {
        // our current state
        ULL state = bfs[k];
 
        // pred_hall[i] is the supermask of masks
        // that will satisfy Hall lemma condition if we add edge (U[i],v)
        // to the graph with the given DP state
        // (with possible exclusion of some masks from the current "state")
        // One can see that pred_hall[i] can be obtained
        // by including vertex "i" to each "mask" of the "state"
        ULL pred_hall[maxN] = {0};
        for (int mask = 0; mask < N; ++mask) {
            if (state & bitULL(mask)) {
                for (int i = 0; i < n; ++i) {
                    pred_hall[i] |= bitULL(mask | bit(i));
                }
            }
        }
 
        // looping through all possible masks
        for (int mask = 0; mask < N; ++mask) {
            // "nxt" is the DP state that we obtain
            // after adding edges (U[i],v) for all "i" in "mask"
            // to the graph that has DP state "state"
            // One can see that this state is the union of all states that
            // will be obtained by adding each of the edge separately
            ULL nxt = state;
            for (int i = 0; i < n; ++i) {
                if (mask & bit(i)) {
                    nxt |= pred_hall[i];
                }
            }
 
            // we call "get_ind" that make all needed things with "nxt":
            // check whether it is the new DP state, add it to the "bfs" if yes
            // and return its index in "bfs" in both cases
            next[mask][k] = get_ind(nxt);
        }
        // Thus dealing with one state takes only O(2^n * n) (recall that we use
        // efficient hash table instead of, for example, very slow stl map)
        // TODO: Is it possible to make this in O(2^n)?
 
        // awesome O(n) routine to find maximum matching of DP state
        // we can simply check in O(1) time
        // whether "state" has at least one "mask" of size "i"
        for (int i = n; i >= 0; --i) {
            if (state & fixed_size[i]) {
                match[k]=i;
                break;
            }
        }
    }
}
 
double p[maxN][maxM]; // probability adjacent matrix
double prev[maxS]; // previous row of DP values
double cur[maxS]; // current row of DP values
 
double expectedMaximumMatching(int n, int m) {
    // initialization of "prev"
    prev[0]=1.;
    for (int k=1;k<len;k++) {
        prev[k] = 0.0;
    }
 
    int N = bit(n);
    // looping though all vertexes of V
    for (int j = 0; j < m; ++j) {
        // initialization of "cur"
        for (int k = 0; k < len; ++k) {
            cur[k] = 0.0;
        }
 
        // looping through all possible masks = ADJ(V[j])
        for (int mask = 0; mask < N; ++mask) {
            // "prob" is the probability that ADJ(V[j]) = mask
            double prob = 1.0;
            for (int i = 0; i < n; ++i) {
                prob *= mask & bit(i) ? p[i][j] : 1.0 - p[i][j];
            }
 
            // if we were previously in the state "bfs[k]"
            // then adding all edges (U[i],V[j]) for all "i" from "mask"
            // will bring us to the DP state with index "next[mask][k]"
            for (int k = 0; k < len; ++k)
                cur[next[mask][k]] += prob * prev[k];
        }
 
        // copying of "prev" to "cur"
        for (int k = 0; k < len; ++k) {
            // We need this in order to avoid dealing with numbers
            // less than 1e-308. This can be several times slower
            // than with usual numbers. There was a discussion of this effect
            // at Codeforces after some TopCoder SRM.
            if (prev[k] < 1e-100) {
                prev[k] = 0.0;
            }
            prev[k] = cur[k];
        }
    }
 
    // calcultating the answer
    double ans = 0.0;
    for (int k = 0; k < len; ++k) {
        ans += prev[k] * match[k];
    }
    return ans;
}
 
int main() {
    int n, m;
    scanf("%d %d", &n, &m);
 
    precalc(n);
 
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            scanf("%lf", &p[i][j]);
        }
    }
 
    double ans = expectedMaximumMatching(n, m);
    printf("%.8lf\n", ans);
 
    return 0;
}
 