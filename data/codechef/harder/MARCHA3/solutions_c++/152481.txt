/*
证前面的判断中至少有几处是错的。
n<=100000,
sol:
1.sort,枚举=,和开区间，更新答案。
2.=:x right的>,x left的<,x+1 right >=,x-1 left <=,+equ-(1)+(1)
3.(a,b)
*/
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>

using namespace std;
const int maxn=101000;
const string nam[6]={"<",">","=","!=","<=",">="};

int id[maxn],op[maxn],px[maxn],nx[maxn];
string op1,op2;
int ans,n,tst,ct,equ;
int s[6][maxn],sp[6][maxn];

bool cmp(int i,int j){
	return px[i]<px[j];
}
void work(){//ok
	//equal
	ans=10000000;
	for(int i=1;i<=ct;i++){
		int tmp=sp[1][i]+sp[0][i]+equ;
		if(sp[2][i])tmp-=sp[2][i];
		if(sp[3][i])tmp+=sp[3][i];
		if(i<ct)tmp+=sp[5][i+1];
		if(i>1)tmp+=sp[4][i-1];
		ans=min(ans,tmp);
	}
	//range
	for(int i=1;i<ct;i++)if(nx[i]<nx[i+1]-1){
		int tmp=equ+s[5][i+1]+s[4][i]+s[1][i+1]+s[0][i];
		ans=min(ans,tmp);
	}
	cout<<ans<<endl;
}
void init(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>op1>>px[i]>>op2;
		int k;
		for(k=0;k<3;k++)if(op1==nam[k])break;
		if(op2[0]=='N')k=5-k;
		op[i]=k;
	}
	px[n+1]=1;px[n+2]=1000000000;
	op[n+1]=-1;op[n+2]=-1;
	n+=2;
//get px,op
	for(int i=1;i<=n;i++)id[i]=i;
	memset(s,0,sizeof(s));
	memset(sp,0,sizeof(sp));
	sort(id+1,id+n+1,cmp);
	for(int i=1;i<=n;i++){
		s[0][i]=s[0][i-1];
		s[4][i]=s[4][i-1];
		if(op[id[i]]==0)s[0][i]++;
		if(op[id[i]]==4)s[4][i]++;
	}
	for(int i=n;i;i--){
		s[1][i]=s[1][i+1];
		s[5][i]=s[5][i+1];
		if(op[id[i]]==1)s[1][i]++;
		if(op[id[i]]==5)s[5][i]++;
	}

	equ=0;
	for(int i=1;i<=n;i++){
		if(op[id[i]]==2){
			s[2][i]=1;
			equ++;
		}
		if(op[id[i]]==3)s[3][i]=1;
	}
//get s,key equal are not only one
	int lst=1;ct=0;
	for(int i=1;i<=n;i++)
		if(i==n||px[ id[i] ]!=px[ id[i+1] ]){
			ct++;
			nx[ct]=px[id[i]];
			sp[0][ct]=s[0][i];
			sp[4][ct]=s[4][i];
			sp[1][ct]=s[1][lst];
			sp[5][ct]=s[5][lst];
			for(int j=i;j>=lst;j--)
				if(s[2][j])sp[2][ct]++;
			for(int j=i;j>=lst;j--)
				if(s[3][j])sp[3][ct]++;
			lst=i+1;
		}
//get sp
}
int main(){
	cin>>tst;
	while(tst--){
		init();
		work();
	}
	return 0;
}
