#include <stdio.h>
//#include <conio.h>
//#include <iostream>
//using namespace std;

class Input
{
public:
	char buffer[1048576];
	int bufferMax,nextToRead;

	Input(){bufferMax = nextToRead = 0;}

	void refill()
	{
		//printf("refill\n");
		bufferMax = fread(buffer,1,1048576,stdin);
		nextToRead = 0;
	}

	int getNextChar()
	{
		if ( nextToRead == bufferMax )
			refill();

		return buffer[nextToRead++];
	}

	int getInt()
	{
		int ret = 0; int c;
		while((c = getNextChar()) < 48);
		do
		{
			ret = 10*ret + c - 48;
		}
		while((c = getNextChar()) > 47);
		return ret;
	}

	void getHint(char &op, int& number, bool & yesOrNo)
	{
		short int c;
		while((c = getNextChar()) == 10);
		op = c;
		number = getInt();
		yesOrNo = getNextChar() == 89;
		while((c = getNextChar()) > 64);
	}
};

typedef struct segment
{
	int low, high, confirmes;
	segment *parent, *leftChild, *rightChild;
	segment(int low, int high, int confirmes, segment * parent) {this->low = low, this->high = high; this->confirmes = confirmes; this->parent = parent; leftChild = rightChild = NULL;}
} node;

node * tree;
Input input;

enum hintType {equals, lower, greater};

class Hints
{
public:
	hintType ht1,ht2;
	int number1, number2, hintsNumber;

	Hints()
	{
		int number; char op; bool yesOrNo;

		input.getHint(op, number, yesOrNo);
		//printf("hint: op = %c, number = %d, logical = %d\n",op,number,yesOrNo);

		switch (op)
		{
		case '=':
			if (yesOrNo)
			{
				this->number1 = number;
				this->ht1 = equals;
				this->hintsNumber = 1;
			}
			else
			{
				this->number1 = number - 1;
				this->ht1 = lower;
				this->number2 = number + 1;
				this->ht2 = greater;
				this->hintsNumber = 2;
			}
			break;

		case '<':
			if (yesOrNo)
			{
				this->ht1 = lower;
				this->number1 = number - 1;
				this->hintsNumber = 1;
			}
			else
			{
				this->ht1 = greater;
				this->number1 = number;
				this->hintsNumber = 1;
			}
			break;

		default:
			if (yesOrNo)
			{
				this->ht1 = greater;
				this->number1 = number +1;
				this->hintsNumber = 1;
			}
			else
			{
				this->ht1 = lower;
				this->number1 = number;
				this->hintsNumber = 1;
			}
		}
		//printf("hint1: type = %d, number = %d\n",this->ht1,this->number1);
		//if (this->hintsNumber == 2) printf("hint2: type = %d, number = %d\n",this->ht2,this->number2);
	}
};

void addInequal(hintType ht, int number)
{
	node * search = tree;
	int splitPoint;

	if (ht == greater)
	{
		if ( number <= 1000000000 )
		{
			while ( search->rightChild )
			{
				splitPoint = search->rightChild->low;
				if ( number < splitPoint )
				{
					search->rightChild->confirmes++;
					search = search->leftChild;
				}
				else
				{
					search = search->rightChild;
				}
			}

			if ( number == search->low )
				search->confirmes++;
			else
			{
				search->leftChild = (node*) new node(search->low,number-1,search->confirmes,search);
				search->rightChild = (node*) new node(number,search->high,search->confirmes+1,search);
				search->confirmes = 0;
			}
		}
	}
	else
	{
		if ( number >= 1 )
		{
			while ( search->rightChild )
			{
				splitPoint = search->rightChild->low;
				if ( number < splitPoint )
				{
					search = search->leftChild;
				}
				else
				{
					search->leftChild->confirmes++;
					search = search->rightChild;
				}
			}

			if ( number == search->high )
				search->confirmes++;
			else
			{
				search->leftChild = (node*) new node(search->low,number,search->confirmes+1,search);
				search->rightChild = (node*) new node(number+1,search->high,search->confirmes,search);
				search->confirmes = 0;
			}
		}
	}
}

void addEqual(int number)
{
	node * search = tree;
	int splitPoint;

	while ( search->rightChild )
	{
		splitPoint = search->rightChild->low;
		number < splitPoint ? search = search->leftChild : search = search->rightChild;
	}
	
	if ( search->low == search->high ) search->confirmes++;
	else if ( number == search->low )
	{
		search->leftChild = (node*)new node(number,number,search->confirmes+1,search);
		search->rightChild = (node*)new node(number+1,search->high,search->confirmes,search);
		search->confirmes = 0;
	}
	else if ( number == search->high )
	{
		search->leftChild = (node*)new node(search->low,number-1,search->confirmes,search);
		search->rightChild = (node*)new node(number,number,search->confirmes+1,search);
		search->confirmes = 0;
	}
	else
	{
		if (search->high-number > number-search->low)
		{
			search->leftChild = (node*)new node(search->low,number-1,search->confirmes,search);
			search->rightChild = (node*)new node(number,search->high,0,search);
			search->rightChild->leftChild = (node*)new node(number,number,search->confirmes+1,search->rightChild);
			search->rightChild->rightChild = (node*)new node(number+1,search->high,search->confirmes,search->rightChild);
			search->confirmes = 0;
		}
		else
		{
			search->rightChild = (node*)new node(number+1,search->high,search->confirmes,search);
			search->leftChild = (node*)new node(search->low,number,0,search);
			search->leftChild->rightChild = (node*)new node(number,number,search->confirmes+1,search->leftChild);
			search->leftChild->leftChild = (node*)new node(search->low,number-1,search->confirmes,search->leftChild);
			search->confirmes = 0;
		}
	}
}

int maximumTruths(node * root)
{
	int max;
	if (root->leftChild)
	{
		int leftCount = maximumTruths(root->leftChild);
		int rightCount = maximumTruths(root->rightChild);
		int maxChild = rightCount > leftCount ? rightCount : leftCount;
		max = root->confirmes + maxChild;
	}
	else
		max = root->confirmes;

	delete root;
	return max;
}


int main()
{
	int cases, hints;
	cases = input.getInt();
	//printf("cases: %d\n",cases);

	for (int i = 0 ; i < cases ; i++)
	{
		hints = input.getInt();
		//printf("hints: %d\n",hints);
		tree = (node*)new node(1,1000000000,0,NULL);

		for ( int hintCnt = 0 ; hintCnt < hints ; hintCnt++ )
		{
			Hints hint;
			hintType ht = hint.ht1;
			
			if (ht == 0)
				addEqual(hint.number1);
			else
				addInequal(hint.ht1, hint.number1);

			if (hint.hintsNumber == 2)
			{
				ht = hint.ht2;
				if (ht == 0)
					addEqual(hint.number2);
				else
					addInequal(hint.ht2, hint.number2);
			}
		}

		int lies = hints - maximumTruths(tree);
		printf("%d",lies);
		if (i < cases - 1)
			printf("\n");
	}

	//getch();
	return 0;
}