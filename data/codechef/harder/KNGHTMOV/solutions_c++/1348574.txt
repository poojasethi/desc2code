/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <functional>
#include <set>
#include <sstream>

using namespace std;

#define INT_MAX 2147483647
#define INT_MIN -2147483648
#define MAX(a,b)   (((a)>(b))?(a):(b))
#define MIN(a,b)   (((a)<(b))?(a):(b))
#define CMAX(a,b)  if((a)<(b)) a=b
#define CMIN(a,b)  if((a)>(b)) a=b
#define FOR(i,a,b)   for(i=a; i<b; i++)
#define REVI(i,a,b)  for(int i= a ; i >= b ; --i)
#define LET(x,a)     __typeof(a) x(a)
#define IFOR(i,a,b)  for(LET(i,a);i!=(b);++i)
#define DFOR(i,a,b)  for(LET(i,a);i<(b);++i)
#define EACH(it,v)   IFOR(it,v.begin(),v.end())
#define SWAP(a,b,t)  t=a,a=b,b=t
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define gint(t)      scanf("%d", &t);
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define ALL(x)       (x).begin(), (x).end()

#ifdef JAI_ARENA
#define debug(args...) {dbg,args; cerr<<endl;}
#define dline cerr<<endl
#else
#define debug(args...) {};
#endif

typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
	{
	    cerr<<v<<" ";
	    return *this;
	}
} dbg;


#define BUF 4096
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
	fread(ibuf, 1, BUF, stdin);
	ipt = 0;
	while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; char neg = 0;
    if(ipt !=0 && ibuf[ipt-1] == '-') neg = 1;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
	fread(ibuf, 1, BUF, stdin);
	ipt = 0;
	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return neg?-n:n;
}

#define MODN 1000000007
#define MAXN 1000000
ll fact[1000000];
ll invfact[1000000];
int power(int x, unsigned n) {
    ll intermediateProduct = x;
    ll result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%MODN;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%MODN;
    }
    return result;
}
int inverse(int x){
    return power(x, MODN-2);
}
void factAndInvfact(){
    fact[0]=1;
    for(int i=1; i<=MAXN; i++)
	fact[i]=((long long)i*fact[i-1])%MODN;
    invfact[MAXN]=inverse(fact[MAXN]);
    for(int i=MAXN; i>0; i--)
	invfact[i-1]=((long long)i*invfact[i])%MODN;
}

ll nCr(int n1, int n2)
{
    return ((fact[n1+n2]*invfact[n1]%MODN)*invfact[n2])%MODN;
}
int gcd(int a, int b)
{
    int x;
    while(b)
    {
	x = a%b;
	a = b;
	b = x;
    }
    return a;
}

int delta;
ll getNumWays(int x, int y,
	      int ax, int ay, int bx, int by)
{
    
    if(delta==0) return 0;
    int numalpha = x*by-y*bx;
    int numbeta  = y*ax-x*ay;
    //debug("pars", x, y, ax, ay, bx, by, numalpha, numbeta, delta);
    if(numalpha%delta != 0) return 0;
    if(numbeta %delta != 0) return 0;
    int n1 = numalpha/delta;
    int n2 = numbeta /delta;
    //debug(n1, n2);
    if(n1<0 || n2<0) return 0;
    return nCr(n1,n2);
}
#define ES 2010
#define DFS_DEPTH 2000
char inf_list[2*ES];
char done[2*ES];
char in_parent[2*ES];
int nm[2*ES];
int nm2[2*ES];
set<int> blist; int dfs_x, dfs_ax, dfs_bx, ax, ay, bx, by, x, y;
void dfs_set_inf_list(int sx, int depth)
{
    if(blist.find(sx)!=blist.end()) return;
    done[sx] = 1;
    int v1 = sx+dfs_ax;
    int v2 = sx+dfs_bx;
    if(v1<0||v1>=2*ES || v2<0 || v2>=2*ES) return;
    if(depth<0) return;
    in_parent[sx] = 1;
    if(!done[sx+dfs_ax]) dfs_set_inf_list(sx+dfs_ax, depth-1);
    else if(in_parent[sx+dfs_ax]) inf_list[sx] = 1;
    if(dfs_bx != dfs_ax && !done[sx+dfs_bx]) dfs_set_inf_list(sx+dfs_bx, depth-1);
    else if(dfs_bx!=dfs_ax && in_parent[sx+dfs_bx]) inf_list[sx] = 1;
    in_parent[sx] = 0;
}
int bfs_get_num_ways(int sx)
{
    int *n1 = nm;
    int *n2 = nm2;
    memset(nm, 0, sizeof nm);
    n1[sx] = 1;
    debug("in bfs", (int)inf_list[dfs_x], dfs_x, (int)inf_list[dfs_x-2], (int)inf_list[1006]);
    EACH(it, blist) { n2[*it] = 0; inf_list[*it] = 0; debug(*it, "set to zero!");}
    REP(ki, 1000) {
	REP(ni, 2*ES)
	{
	    if(inf_list[ni]) continue;
	    if(blist.find(ni)!=blist.end()) continue;
	    n2[ni] = 0;
	    int k = ni-dfs_ax;
	    if(1) {
		if(k>=0 && k<2*ES) {
		    if(inf_list[k]) {inf_list[ni]=1; if(ni==dfs_x)debug("from", k, dfs_ax);}
		    n2[ni] += n1[k];
		}
	    }
	    if(dfs_bx != dfs_ax) {
		k = ni-dfs_bx;
		if(k>=0 && k<2*ES) {
		    if(inf_list[k]) {inf_list[ni]=1; if(ni==dfs_x)debug("from", k);}
		    n2[ni] += n1[k];
		}
	    }
	    n2[ni]%=MODN;
	}
	//debug("in bfs", (int)inf_list[dfs_x], dfs_x);
	if(inf_list[dfs_x]) return -1;
	n2[sx] = 1; //debug(sx, "set to zero");
	//EACH(it, blist) { n2[*it] = 0; inf_list[*it] = 0; debug(*it, "set to zero!");}
	int *tmp = n1; n1=n2; n2=tmp;
    }
    return n1[dfs_x];
}
void solve()
{
    int k; gint(x); gint(y); gint(k);
    gint(ax); gint(ay); gint(bx); gint(by);
    dfs_x = x+ES;
    //debug(x, y, ax, ay, bx, by);
    int blocked[k+2][2];
    REP(ki, k) {
	gint(blocked[ki][0]);
	gint(blocked[ki][1]);
    }
    if(ax==0 && ay==0 && bx==0 && by==0)
    {
	if(x==0 && y==0) { pint(-1); return; }
	else {pint(0); return;}
    }
    delta = ax*by-bx*ay;
    blocked[k][0] = 0;   blocked[k][1] = 0;
    blocked[k+1][0] = x; blocked[k+1][1] = y;
    if(x>0 && ax<=0 && bx<=0) { pint(0); return; }
    if(x<0 && ax>=0 && bx>=0) { pint(0); return; }
    if(y>0 && ay<=0 && by<=0) { pint(0); return; }
    if(y<0 && ay>=0 && by>=0) { pint(0); return; }
    if(delta ==0) {
	blist.clear();
	int gx = gcd(abs(ax), abs(bx));
	int gy = gcd(abs(ay), abs(by));
	if(ax == 0 && ay == 0)
	{
	    if(bx*by<0) gy = -gy;
	}
	else if((ax*ay)<0){
	    gy = -gy;
	}
	dfs_ax = ax; dfs_bx = bx; dfs_x = x+ES;
	bool flag = false;
	if(ax==0 && bx==0) {
	    flag = true;
	    dfs_ax=ay; dfs_bx = by; dfs_x = y+ES;
	}
	if(gx == 0)
	{
	    if(x!=0 || y %gy !=0) {pint(0); return;}
	}
	else if(gy == 0)
	{
	    if(y!=0 || x %gx !=0) {pint(0); return;}
	}else {
	    if(x%gx!=0 || y%gy !=0 || x/gx != y/gy) { pint(0); return; }
	}
	REP(ki, k)
	{
	    if(gx == 0)
	    {
		if(blocked[ki][0]!=0 || blocked[ki][1] %gy !=0) continue;
	    }
	    else if(gy == 0)
	    {
		if(blocked[ki][1]!=0 || blocked[ki][0] %gx !=0) continue;
	    }else {
		if(blocked[ki][0]%gx!=0 ||blocked[ki][1]%gy!=0 || 
		   blocked[ki][0]/gx != blocked[ki][1]/gy ) continue;
	    }
	    if(!flag)
		blist.insert(blocked[ki][0]+ES);
	    else
		blist.insert(blocked[ki][1]+ES);
	}
	EACH(it, blist) debug("blocked", *it, dfs_ax,dfs_bx);
	debug("inf list 4", (int)inf_list[dfs_x], dfs_x);
	memset(inf_list,  0, sizeof inf_list);
	memset(in_parent, 0, sizeof in_parent);
	memset(done,      0, sizeof done);
	
	dfs_set_inf_list(ES,DFS_DEPTH);
	int ways = bfs_get_num_ways(ES);
	pint(ways); return;
        // greedy solve to check that there is exactly one way or there are infinitely many.
        // dfs for initial cycle finding.
        // bfs to extend the cycles or finite no of ways
	return;
    }
    int nump = k+2;
    ll res[1<<nump];
    int s[1<<nump];
    int e[1<<nump];
    ll r=0;
    
    REP(ni, 1<<nump) {
	int numc = __builtin_popcount(ni);
	if(numc <=1) { continue;}
	if(numc == 2)
	{
	    int p1=k+3; int p2;
	    while(((1<<p1)&ni) == 0) p1--;
	    p2 = p1-1;
	    while(((1<<p2)&ni) == 0) p2--;
	    res[ni] = getNumWays(blocked[p2][0] - blocked[p1][0], blocked[p2][1] - blocked[p1][1], ax, ay, bx, by);
	    
	    if(res[ni] > 0)
	    {
		s[ni] = p1; e[ni] = p2;
	    }else {
		res[ni] = getNumWays(blocked[p1][0] - blocked[p2][0], blocked[p1][1] - blocked[p2][1], ax, ay, bx, by);
		s[ni] = p2; e[ni] = p1;
	    }
	}else {
	    res[ni] = 0;
	    //bool flag=false;
	    REP(mi, nump)
	    {
		int k = ni&(~(1<<mi));
		if(k==ni||res[k] == 0) continue;
		int l = (1<<e[k])|(1<<mi);
		if(e[k]<0 || e[k]>=nump) while(1);
		if(s[l] != e[k] || res[l] == 0) continue;
		res[ni] = (res[k]*res[l])%MODN;
		s[ni] = s[k];
		e[ni] = mi;
		//if(flag == true) debug("error");
		//debug(ni, k, s[k], e[k], l);
		//flag = true;
		break;
		//break;
	    }
	}
	if(s[ni]==k && e[ni]==k+1){
	    if(numc&1) r=(r-res[ni])%MODN;
	    else       r=(r+res[ni])%MODN;
	    //debug(ni, r, nump);
	}
	//debug("vals", ni, res[ni], s[ni], e[ni]);
    }
    if(r<0) r+=MODN;
    printf("%lld\n", r);
}

int main()
{
    int t; cin>>t;
    factAndInvfact();
    while(t--)
    {
	solve();
    }
    //printf("wonng");
    return 0;
}
