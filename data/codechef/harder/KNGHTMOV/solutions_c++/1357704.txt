#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
using namespace std;

#define rep(i,l,r) for(int i=l;i<=r;i++)
#define drep(i,r,l) for(int i=r;i>=l;i--)
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define LL long long
#define Travel(E, u) for(int i=E.start[u],v;v=E.e[i].a,i;i=E.e[i].next)
#define eps 1e-10
#define sqr(x) ((x)*(x))
#define pb push_back

struct arr
{
	int x, y;
	arr(){}
	arr(int x1, int y1){x = x1; y = y1;}
	int operator%(arr &t)
	{
		return x * t.y - y * t.x;	
	}	
	bool operator<(const arr &t)const
	{
		return x < t.x || x == t.x && y < t.y;	
	}
}t, d1, d2, A[200008], b[200008];
const int st = 2000, maxn = 8008;
int ni[2000008], func[2000008]; 
const int pp = 1e9+7;
int f[8008], k, tot, h[500008];
int d[8008];
bool in[8008], huan[8008];
const int maxt = 1e6;
struct Tedge
{
	int start[maxn], tot;
	struct arr
	{
		int a, next;	
	}e[maxn<<3];
	void clear()
	{
		tot = 0; memset(start, 0, sizeof(start));	
	}	
	void Add(int x, int y)
	{
		e[++tot].a = y; e[tot].next = start[x]; start[x] = tot;	
	}
}E;
struct Ttarjian//tajian
{
	int dfn[maxn], low[maxn], tot, stack[maxn];
	bool flag[maxn];
	void dfs(int u)
	{
		dfn[u] = low[u] = ++tot;
		stack[++stack[0]] = u; flag[u] = 1;
		Travel(E, u)
		{
			if (!dfn[v])
			{
				dfs(v); low[u] = min(low[u], low[v]);
			}
			else if (flag[v]) low[u] = min(dfn[v], low[u]);
			d[v]++;
		}
		if (low[u] == dfn[u])
		{
			int cnt = 0, p;
			do
			{
				p = stack[stack[0]--]; cnt++;	
				flag[p] = 0;
			}while (p != u);
			if (cnt >= 2) rep(i,stack[0]+1,stack[0]+cnt) huan[stack[i]] = 1; 
		}
	}
	void work(int a, int b)
	{
		E.clear();
		memset(d, 0, sizeof(d));//度数 
		rep(i,0,st-505) E.Add(i, i+1);
		E.Add(st-505, 0);
		rep(i,st+505,st*2) E.Add(i, i+1);
		E.Add(st*2, st+505);
		rep(i,0,st*2)
			{
				if (i+a <= st*2 && i+a >= 0 && !in[i+a]) E.Add(i, i+a);
				if (a != b) if (i+b <= st*2 && i+b >= 0 && !in[i+b]) E.Add(i, i+b);
			}
		memset(huan, 0, sizeof(huan));
		memset(dfn, 0, sizeof(dfn));
		tot = 0;
		if (a == 0 || b == 0)
			rep(i,0,st*2) huan[i] = 1;
		else
			dfs(st);//从原点出发 
	}
}Tarjian;
struct Program
{
	void Open()
	{
		freopen("1.in", "r", stdin);
		freopen("1.out", "w", stdout);
	}	
	void Close()
	{
		fclose(stdin);
		fclose(stdout);	
	}
	void Init()
	{
		scanf("%d%d%d", &t.x, &t.y, &k);
		scanf("%d%d%d%d", &d1.x, &d1.y, &d2.x, &d2.y);
		rep(i,1,k) scanf("%d%d", &A[i].x, &A[i].y);
	}
	arr Count(arr &d1, arr &d2, arr &t)//不共线情况求解 
	{
		arr g; g.x = -1;
		int t1 = t % d1, t2 = t % d2, t3 = d1 % d2;
		if (t1 % t3) return g;
		if (t2 % t3) return g;//实数 
		int n = t1 / -t3;
		int m = t2 / t3;
		if (n < 0 || m < 0) return g;//小于0 
		return arr(n, m);
	}
	int C(int x, int y)//组合数 
	{
		return (LL)func[x] * ni[y] % pp * ni[x - y] % pp;	
	}
	int gcd(int x, int y)
	{
		if (!y) return x;
		return gcd(y, x % y);	
	}
	void Work1()//共线情况 
	{
		int a = d1.x, b = d2.x, c = t.x;
		int g = gcd(a, b);
		if (c % g) {printf("0\n"); return;} 
		a /= g; b /= g; c /= g;
		memset(in, 0, sizeof(in)); 
		rep(i,1,k)//障碍点标记 
		{
			if (A[i] % d1 || A[i] % d2) continue;
			if (A[i].x % g) continue; 
			in[A[i].x / g + st] = 1;
		}
		Tarjian.work(a, b);//把环标记出来 
		memset(f, 0, sizeof(f));
		if (huan[st]) f[st] = -1;
		else f[st] = 1;
		int l = 1, r = 1; h[1] = st;
		while (l <= r)
		{
			int u = h[l++];
			Travel(E, u)
			{
				d[v]--; 
				if (huan[v] && f[v] != -1) f[v] = -1, h[++r] = v;//如果是环，方案数是无限 
				if (!huan[v]) 	
				{
					if (f[u] == -1)  f[v] = -1;
					else
					{
						f[v] += f[u]; 
						if (f[v] >= pp) f[v] -= pp;
					}
					if (!d[v]) h[++r] = v;	
				}
			}
		}
		if (f[c+st] == -1) printf("-1\n");
		else printf("%d\n", f[c+st]);
	}
	void Work()
	{
		if (d1 % d2 == 0)//共线情况 
		{
			if (t % d1 || t % d2) printf("0\n");
			else
			{
				if (d1.x == 0 && d2.x == 0)
				{
					if (d1.y == 0 && d2.y == 0)
					{
						if (t.x == 0 && t.y == 0) printf("-1\n");
						else printf("0\n");
						return;
					}
					swap(d1.x, d1.y);
					swap(d2.x, d2.y);
					swap(t.x, t.y);
					rep(i,1,k) swap(A[i].x, A[i].y);
				}
				Work1();
			}
		}
		else//不共线,ac
		{
			arr g = Count(d1, d2, t);
			if (g.x == -1) {printf("0\n"); return;}
			tot = 0;
			rep(i,1,k)
			{
				arr p = Count(d1, d2, A[i]);
				if (p.x != -1 && p.x <= g.x && p.y <= g.y) b[++tot] = p;
			}
			b[++tot] = g;
			sort(b+1, b+tot+1);
			rep(i,1,tot)//进行DP 
			{
				f[i] = C(b[i].x+b[i].y, b[i].x);
				rep(j,1,i-1) if (b[j].x <= b[i].x && b[j].y <= b[i].y)
				{
					f[i] -= (LL)f[j] * C(b[i].x-b[j].x+b[i].y-b[j].y, b[i].x-b[j].x) % pp;
					if (f[i] < 0) f[i] += pp;
				}
			}
			printf("%d\n", f[tot]);
		}
	}
}program;

int pow(int x, int n)
{
	int ans = 1, tmp = x;
	while (n)
	{
		if (n & 1) ans = (LL)ans * tmp % pp;
		tmp = (LL)tmp * tmp % pp; n >>= 1; 	
	}	
	return ans;
}
int main()
{
	//program.Open();
	func[0] = ni[0] = 1;
	rep(i,1,maxt) func[i] = (LL)func[i-1] * i % pp;
	ni[maxt] = pow(func[maxt], pp-2);
	drep(i,maxt-1,1) ni[i] = (LL)ni[i+1] * (i + 1) % pp;
	int t;
	scanf("%d", &t);
	rep(i,1,t)
	{
		program.Init();
		program.Work();
	}
	//program.Close();
	return 0;
}
