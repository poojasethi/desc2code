#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#define p 1000000007
using namespace std;

int T,n,X,Y,X_,Y_,K,Ax,Ay,Bx,By,A,B,Cx,Cy,i,j,k,l,r;
int fac[1000005],fac_inv[1000005],f[105],a[105];
int q[1000005],Init[1000005],*init=Init+500000,G[1000005],*g=G+500000;
bool Vis[1000005],*vis=Vis+500000;

struct node
{
	int x,y,a,b;
}t[105];
inline bool cmp(const node &a,const node &b)
{
	if(a.a!=b.a)return a.a<b.a;
	return a.b<b.b;
}

int C(int n,int m)
{
	if(m>n||n<0)return 0;
	return (long long)fac[n]*fac_inv[m]%p*fac_inv[n-m]%p;
}

int Power(int a,int b)
{
	int ans=1;
	for(;b;b>>=1,a=(long long)a*a%p)if(b&1)ans=(long long)ans*a%p;
	return ans;
}

bool trans(int x,int y,int &x_,int &y_)
{
	int D=Ax*By-Ay*Bx;
	x_=x*By-y*Bx;
	y_=y*Ax-x*Ay;
	if(x_%D||y_%D)return false;
	x_/=D;y_/=D;
	if(x_<0||y_<0)return false;
	return true;
}

int calc(int x,int y,int z)
{
	int x_=0,y_=0;
	for(i=1;i<=1000;++i)
	{
		for(j=1;j<=K;++j)if(x_==t[j].x&&y_==t[j].y)return 0;
		if(x_==X&&y_==Y)return z;
		x_+=x;y_+=y;
	}
	return 0;
}

void dfs(int x)
{
	if(vis[x]||x>300000||x<-300000)return;
	vis[x]=true;
	dfs(x+A);
	dfs(x+B);
}

int main()
{
	fac[0]=1;
	for(i=1;i<=1000000;++i)fac[i]=(long long)fac[i-1]*i%p;
	fac_inv[1000000]=Power(fac[1000000],p-2);
	for(i=1000000;i>=1;--i)fac_inv[i-1]=(long long)fac_inv[i]*i%p;
	scanf("%d",&T);
	for(;T;--T)
	{
		scanf("%d%d%d",&X,&Y,&K);
		scanf("%d%d%d%d",&Ax,&Ay,&Bx,&By);
		for(i=1;i<=K;++i)scanf("%d%d",&t[i].x,&t[i].y);
		if(Ax*By-Ay*Bx==0)
		{
			if(!Ax&&!Ay){printf("%d\n",calc(Bx,By,-1));continue;}
			if(!Bx&&!By){printf("%d\n",calc(Ax,Ay,-1));continue;}
			if(Ax==Bx&&Ay==By){printf("%d\n",calc(Ax,Ay,1));continue;}
			Cx=__gcd(Ax,Bx);Cy=__gcd(Ay,By);
			if(Ax>0&&Cx<0)Cx=-Cx;if(Ax<0&&Cx>0)Cx=-Cx;
			if(Ay>0&&Cy<0)Cy=-Cy;if(Ay<0&&Cy>0)Cy=-Cy;
			if((Cx&&X%Cx)||(Cy&&Y%Cy)){printf("0\n");continue;}
			if(Cx&&Cy&&X/Cx!=Y/Cy){printf("0\n");continue;}
			n=0;
			if(Cx)A=Ax/Cx,B=Bx/Cx,X_=X/Cx;
			else A=Ay/Cy,B=By/Cy,X_=Y/Cy;
			for(i=1;i<=K;++i)
			{
				if(!Cx)
				{
					if(t[i].x==0&&t[i].y%Cy==0)
					a[++n]=t[i].y/Cy;
					continue;
				}
				if(!Cy)
				{
					if(t[i].y==0&&t[i].x%Cx==0)
					a[++n]=t[i].x/Cx;
					continue;
				}
				if(t[i].x%Cx==0&&t[i].y%Cy==0&&t[i].x/Cx==t[i].y/Cy)
				a[++n]=t[i].x/Cx;
			}
			for(i=-300000;i<=300000;++i)vis[i]=false,init[i]=g[i]=0;
			for(i=1;i<=n;++i)vis[a[i]]=true;
			dfs(0);
			for(i=1;i<=n;++i)vis[a[i]]=false;
			if(!vis[X_]){printf("0\n");continue;}
			g[0]=1;r=0;
			for(i=-300000;i<=300000;++i)if(vis[i])++init[i+A],++init[i+B];
			if(!init[0])q[++r]=0;
			if(X_==0)
			{
				if(init[0])printf("-1\n");
				else printf("1\n");
				continue;
			}
			for(l=1;l<=r;++l)
			{
				k=q[l];
				if(vis[k+A])
				{
					--init[k+A];
					if(!init[k+A])q[++r]=k+A;
					g[k+A]+=g[k];if(g[k+A]>=p)g[k+A]-=p;
				}
				if(vis[k+B])
				{
					--init[k+B];
					if(!init[k+B])q[++r]=k+B;
					g[k+B]+=g[k];if(g[k+B]>=p)g[k+B]-=p;
				}
			}
			if(init[X_])printf("-1\n");
			else printf("%d\n",g[X_]);
		}
		else
		{
			if(!trans(X,Y,X_,Y_)){printf("0\n");continue;}
			n=0;
			for(i=1;i<=K;++i)
			if(trans(t[i].x,t[i].y,t[i].a,t[i].b))
			t[++n]=t[i];
			sort(t+1,t+n+1,cmp);
			t[n+1].a=X_;t[n+1].b=Y_;
			for(i=1;i<=n+1;++i)
			{
				f[i]=C(t[i].a+t[i].b,t[i].a);
				for(j=1;j<i;++j)
				if(t[j].a<=t[i].a&&t[j].b<=t[i].b)
				f[i]=(f[i]+p-(long long)f[j]*C(t[i].a+t[i].b-t[j].a-t[j].b,t[i].a-t[j].a)%p)%p;
			}
			printf("%d\n",f[n+1]);
		}
	}
}