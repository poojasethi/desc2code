#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <vector>
#include <map>
#include <algorithm>
#include <utility>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define mp make_pair
#define MOD (1000000007LL)
typedef long long Int;

// a^x mod m
Int modpow(Int a, Int x) {
    if (x==0) return 1;
    return x%2 ? a*modpow(a, x-1)%MOD : modpow(a*a%MOD, x/2);
}

int gcd(int a, int b) { return b == 0 ? a : gcd(b, a%b); }

#define SZ (1000000)
Int inv[SZ];
Int fact[SZ], invfact[SZ];
//Int C_[SZ][SZ];
int X, Y, K;
int ax, ay, bx, by;
pair<int, int> ps[20];

map<pair<int, int>, int> memo;

Int C(int n, int k) {
    Int r = fact[n];
    r = r * invfact[k] % MOD;
    r = r * invfact[n-k] % MOD;
    return r;
}

pair<int, int> calc(int X, int Y) {
    const int base = ax*by - bx*ay;
    const int A = by*X - bx*Y;
    const int B = ax*Y - ay*X;
    if (abs(A)%abs(base) != 0 || abs(B)%abs(base) != 0) return mp(-1, -1);
    const int x = A/base, y = B/base;
    if (x < 0 || y < 0) return mp(-1, -1);
    return mp(x, y);
}

int limi(int x) {
    int y = x;
    if (y < -600) y = -600;
    if (y > 600) y = 600;
    return y+600;
}

vector<int> gr[1300];
int obj[1300];
Int dp[2][1300];
bool nz[2][1300];

int solve1D() {
    map<pair<int, int>, int> of;
    int gx = gcd(abs(ax), abs(bx)), gy = gcd(abs(ay), abs(by));
    if (ax < 0) gx = -gx;
    if (ay < 0) gy = -gy;
    if (gx == 0 && gy == 0) {
        return X == 0 && Y == 0 ? -1 : 0;
    }
    for (int i = -1200; i <= 1200; i++) {
        of[mp(gx*i, gy*i)] = i;
    }
    if (of.count(mp(X, Y)) == 0) return 0;
    const int si = limi(of[mp(0, 0)]);
    const int gi = limi(of[mp(X, Y)]);
    rep (i, 1300) gr[i].clear();
    for (int i = -1200; i <= 1200; i++) {
        const int from = limi(i);
        const pair<int, int> pa(gx*i+ax, gy*i+ay);
        if (of.count(pa)) gr[from].push_back(limi(of[pa]));
        const pair<int, int> pb(gx*i+bx, gy*i+by);
        if (of.count(pb)) gr[from].push_back(limi(of[pb]));
    }
    rep (i, 1300) {
        sort(gr[i].begin(), gr[i].end());
        gr[i].erase(unique(gr[i].begin(), gr[i].end()), gr[i].end());
    }
    memset(obj, 0, sizeof(obj));
    rep (i, K) if (of.count(ps[i])) {
        obj[limi(of[ps[i]])] = 1;
    }
    memset(dp, 0, sizeof(dp));
    memset(nz, 0, sizeof(nz));
    Int *cur = dp[0], *nxt = dp[1];
    bool *cnz = nz[0], *nnz = nz[1];
    cur[si] = 1;
    cnz[si] = 1;
    Int ans = 0;
    bool upd = false;
    rep (_, 2000) {
        upd = false;
        memset(nxt, 0, sizeof(dp[0]));
        memset(nnz, 0, sizeof(nz[0]));
        ans = (ans + cur[gi]) % MOD;
        bool some = false;
        rep (i, 1300) if (cnz[i]) rep (j, gr[i].size()) {
            const int to = gr[i][j];
            if (!obj[to]) {
                some = true;
                nxt[to] = (nxt[to] + cur[i]) % MOD;
                nnz[to] = true;
                if (to == gi) upd = true;
            }
        }
        swap(cur, nxt);
        swap(cnz, nnz);
        if (!some) break;
        if (_ > 1300 && upd) return -1;
    }
    return ans;
}

int solve2D() {
    const pair<int, int> cc = calc(X, Y);
    if (cc.first < 0) return 0;
    if (cc == mp(0, 0)) return 0;
    const int old = K;
    K = 0;
    rep (i, old) {
        if (calc(ps[i].first, ps[i].second).first >= 0) ps[K++] = ps[i];
    }
    const int kk = 1<<K;
    Int ans = 0;
    rep (b, kk) {
        vector<pair<int, int> > ts;
        int ct = 0;
        bool ok = true;
        rep (i, K) if (b&(1<<i)) {
            const pair<int, int> t = calc(ps[i].first, ps[i].second);
            ts.push_back(t);
            if (t.first < 0) { ok = false; break; }
            ct++;
        }
        if (!ok) continue;
        sort(ts.begin(), ts.end());
        ts.push_back(cc);
        if (ts[0].first < 0) continue;
        rep (i, ts.size()-1) {
            if (ts[i].first > ts[i+1].first || ts[i].second > ts[i+1].second) {
                ok = false;
            }
        }
        if (!ok) continue;
        Int s = 1;
        int cx = 0, cy = 0;
        rep (i, ts.size()) {
            const int dx = ts[i].first-cx, dy = ts[i].second-cy;
//            while (dx+dy >= 5000);
            s = s*C(dx+dy, dx) % MOD;
            cx += dx, cy += dy;
        }
        if (ct % 2) ans = (ans - s + MOD) % MOD;
        else ans = (ans + s) % MOD;
    }
    return ans;
}

int main() {
    rep (i, SZ) inv[i] = modpow(i, MOD-2);
    /*
    C_[0][0] = 1;
    rep (i, SZ-1) rep (j, SZ-1) {
        C_[i+1][j] = (C_[i+1][j] + C_[i][j]) % MOD;
        C_[i+1][j+1] = (C_[i+1][j+1] + C_[i][j]) % MOD;
    }
    */
    fact[0] = invfact[0] = 1;
    rep (i, SZ-1) fact[i+1] = (i+1)*fact[i]%MOD;
    rep (i, SZ-1) invfact[i+1] = inv[i+1]*invfact[i]%MOD;
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d%d", &X, &Y, &K);
        scanf("%d%d%d%d", &ax, &ay, &bx, &by);
        rep (i, K) {
            int x, y;
            scanf("%d%d", &x, &y);
            ps[i] = mp(x, y);
        }
        sort(ps, ps+K);
        K = unique(ps, ps+K) - ps;
        int ans = -1;
        if (ax*by == bx*ay) {
            ans = solve1D();
        }
        else {
            ans = solve2D();
        }
        printf("%d\n", ans);
    }
    return 0;
}
