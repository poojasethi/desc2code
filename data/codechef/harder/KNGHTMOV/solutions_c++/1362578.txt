#include <cassert>
#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <cstring>

using namespace std;

const long long mod = 1000000007;
const int MAXCHOOSE = 1000100;

long long F[MAXCHOOSE + 1];
long long invF[MAXCHOOSE + 1];
long long modinv[MAXCHOOSE + 1];

const int UNREACHABLE = -123456789;
int Cx[16], Cy[16];

const int OFFSET = 2010;
long long ways[2*OFFSET + 1];
bool blocked[2*OFFSET + 1];

long long choose(int n, int k) {
    if (n < k) {
        return 0;
    }
    assert(n <= MAXCHOOSE);
    return F[n]*invF[k]%mod*invF[n-k]%mod;
}

inline int ABS(int x) {
    return x<0 ? -x : x;
}
int gcd(int m, int n) {
    m = ABS(m);
    n = ABS(n);
    while (m > 0) {
        int tmp = n;
        n = m;
        m = tmp%m;
    }
    return n;
}

void checkadd(long long &a, int pos) {
    pos += OFFSET;
    if (pos>=0 && pos<=2*OFFSET) {
        a += ways[pos];
        if (a >= mod) {
            a -= mod;
        }
    }
}

// a*Ax + b*Bx = u
// a*Ay + b*By = v
// u->a, v->b
bool convert(int u, int v, int Ax, int Ay, int Bx, int By, int &a, int &b) {
    // Cramer's rule
    int det_a = u*By - v*Bx;
    int det_b = Ax*v - Ay*u;
    int det = Ax*By - Bx*Ay;
    assert(det != 0);
    if (det < 0) { // swap rows
        det = -det;
        det_a = -det_a;
        det_b = -det_b;
    }

    if (det_a<0 || det_b<0 || det_a%det!=0 || det_b%det!=0) {
        return false;
    }
    a = det_a/det;
    b = det_b/det;
    return true;
}
int calc(int X, int Y, int K, int Ax, int Ay, int Bx, int By) {
    int det = Ax*By - Ay*Bx;

    if (det == 0) { // linearly dep.
        if (Ax==0 && Ay==0 && Bx==0 && By==0) {
            return (X==0 && Y==0 ? -1 : 0);
        }

        int gx = gcd(Ax, Bx);
        int gy = gcd(Ay, By);
        // can't move in x or y direction but need to
        if ((gx==0 && X!=0) || (gy==0 && Y!=0)) {
            return 0;
        }

        // all reachable points are of the form k*(gx, gy), i.e. on a line
        if ((gx!=0 && X%gx!=0) || (gy!=0 && Y%gy!=0)) {
            return 0;
        }

        for (int i=0; i<K; ++i) {
            if ((gx==0 && Cx[i]!=0) || (gy==0 && Cy[i]!=0)
                    ||
                (gx!=0 && Cx[i]%gx!=0) || (gy!=0 && Cy[i]%gy!=0)) {
                Cx[i] = UNREACHABLE;
            }
        }

        if (gx != 0) {
            Ax /= gx; Bx /= gx; X /= gx;
            for (int i=0; i<K; ++i) {
                if (Cx[i] != UNREACHABLE) {
                    Cx[i] /= gx;
                }
            }
        }

        if (gy != 0) {
            Ay /= gy; By /= gy; Y /= gy;
            for (int i=0; i<K; ++i) {
                if (Cx[i] != UNREACHABLE) {
                    Cy[i] /= gy;
                }
            }
        }

        // this is a degenerate case where A is a 0-vector and we're interested
        // in moving (mostly) with B
        // - in this case, the answer will be either 0 or -1
        if (Ax==0 && Ay==0) {
            swap(Ax, Bx);
            swap(Ay, By);
        }

        // now there are several cases
        // the new A and B moves move the knight along a line which has been transformed
        // to either one of the axes of the coordinate system (e.g. if gx==0, then the y-axis)
        // or to one of the diagonals (major or minor diagonal)
        // we have already checked if (X, Y) is on an axis if gx==0 or gy==0, but it still
        // remains to check whether it is on the diagonal if that is the case we're in.
        if (gx!=0 && gy!=0) { // diagonal case
            assert(ABS(Ax) == ABS(Ay));
            assert(ABS(Bx) == ABS(By));
            // this is because we made sure A is not (0, 0), both gcds are positive and
            // the determinant is 0
            assert(Ax*Ay != 0);
            bool maindiag = (Ax*Ay > 0); // signs match
            if (ABS(X)!=ABS(Y) || (maindiag && X*Y<0) || (!maindiag && X*Y>0)) {
                return 0;
            }

            for (int i=0; i<K; ++i) {
                if (Cx[i] != UNREACHABLE) {
                    if (ABS(Cx[i])!=ABS(Cy[i]) || (maindiag && Cx[i]*Cy[i]<0)
                            || (!maindiag && Cx[i]*Cy[i]>0)) {
                        Cx[i] = UNREACHABLE;
                    }
                }
            }
        }

        // since all the points are on a line, i.e. there is a 1-1 correspondence
        // of x and y coordinates, we will count the paths only for the x coordiante
        // -> this breaks down if the line is aligned with the y axis because
        // then all x moves are 0... in that case we just copy y-coordinates to
        // x-coordinates and continue
        if (gx == 0) {
            X = Y;
            Ax = Ay;
            Bx = By;
            for (int i=0; i<K; ++i) {
                if (Cx[i] != UNREACHABLE) {
                    Cx[i] = Cy[i];
                }
            }
        }

        // now solve the 1d case
        memset(blocked, 0, sizeof blocked);
        for (int i=0; i<K; ++i) {
            if (Cx[i] != UNREACHABLE) {
                blocked[Cx[i] + OFFSET] = 1;
            }
        }
        memset(ways, 0, sizeof ways);
        for (int iter=0; iter<=4*OFFSET+1; ++iter) {
            bool change = false;
            for (int at=-OFFSET; at<=OFFSET; ++at) {
                if (blocked[at+OFFSET]) {
                    continue;
                }
                long long nval = (at == 0);
                checkadd(nval, at-Ax);
                if (Bx != Ax) {
                    checkadd(nval, at-Bx);
                }
                if (nval != ways[at+OFFSET]) {
                    if (at == X) {
                        change = true;
                    }
                    ways[at+OFFSET] = nval;
                }
            }
            if (change && iter>2*OFFSET) {
                return -1; // there's a viable cycle because otherwise we would have converged
            }
        }
        return int(ways[X + OFFSET]);
    } else { // linearly indep.
        // for every point (u, v), there is at most one way to reach it using A and B
        // steps, i.e. we need to solve the system
        // a*Ax + b*Bx = u
        // a*Ay + b*By = v
        // we know that the determinant is nonzero so there is a unique solution
        // but we must also check if that solution is integer and a>=0, b>=0 
        // because other solutions aren't feasible for the problem
        if (!convert(X, Y, Ax, Ay, Bx, By, X, Y)) {
            return 0;
        }
        vector< pair<int, int> > blocked;
        for (int i=0; i<K; ++i) {
            if (!convert(Cx[i], Cy[i], Ax, Ay, Bx, By, Cx[i], Cy[i]) || Cx[i]>X || Cy[i]>Y) {
                continue;
            }
            blocked.push_back(make_pair(Cx[i], Cy[i]));
        }

        K = blocked.size();
        sort(blocked.begin(), blocked.end());
        long long sol = 0;
        for (int mask=0; mask<(1<<K); ++mask) {
            vector< pair<int, int> > path;
            path.push_back(make_pair(0, 0));
            for (int i=0; i<K; ++i) {
                if (mask & (1<<i)) {
                    path.push_back(blocked[i]);
                }
            }
            path.push_back(make_pair(X, Y));
            bool skip = false;
            for (int i=1; i<(int)path.size(); ++i) {
                assert(path[i].first >= path[i-1].first);
                if (path[i].second < path[i-1].second) { // can't retract B moves
                    skip = true;
                    break;
                }
            }
            if (!skip) {
                long long w = 1;
                for (int i=1; i<(int)path.size(); ++i) {
                    int a = path[i].first - path[i-1].first;
                    int b = path[i].second - path[i-1].second;
                    assert(a>=0 && b>=0);
                    w = w*choose(a+b, a)%mod;
                }
                sol = (sol + (path.size()&1 ? -1 : +1) * w + mod) % mod;
            }
        }
        return int(sol);
    }
}
int main() {
    modinv[1] = 1;
    for (int i=2; i<=MAXCHOOSE; ++i) {
        assert(mod%i != 0); // this only works for prime moduli
        // define j = mod%i = mod - mod/i*i
        // obviously, j < i, i.e. we already know its inverse
        // we had by extended gcd
        //   sj + tmod = 1 => j^-1 = s = modinv[j]
        //   sj = 1 = s(mod - mod/i*i) = s*mod - s*mod/i*i
        //      = -s*mod/i*i = -s*mod/i*i + s*mod*i (to make it positive)
        //      = (mod - mod/i)*s*i
        //  => i^-1 = (mod - mod/i)*s
        //  therefore, modinv[i] = (mod - mod/i) * modinv[mod%i] % mod
        modinv[i] = (mod - mod/i) * modinv[mod%i] % mod;
    }
    F[0] = invF[0] = 1;
    for (int i=1; i<=MAXCHOOSE; ++i) {
        F[i] = F[i-1]*i%mod;
        invF[i] = invF[i-1]*modinv[i]%mod;
    }

    int T;
    scanf("%d", &T);
    while (T--) {
        int X, Y, K;
        scanf("%d %d %d", &X, &Y, &K);
        int Ax, Ay, Bx, By;
        scanf("%d %d %d %d", &Ax, &Ay, &Bx, &By);
        for (int i=0; i<K; ++i) {
            scanf("%d %d", Cx+i, Cy+i);
        }

        printf("%d\n", calc(X, Y, K, Ax, Ay, Bx, By));
    }
	return 0;
}
