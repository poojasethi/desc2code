#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	5005
#define lf	else if
#define For(i,a,b)	for(int i=a;i<=b;i++)

namespace	Graph{
		int		N,D,L,R,F[n],Q[n],st[n],Pre[n],Mat[n],Tim[n];
		bool	V[n],vis[n];

		struct	Lin{int v,next;}E[n];

		void	clear(int t)	{
			For(i,1,t)	st[i]=Mat[i]=0;	D=0;N=t;
		}
		void	Link(int u,int v){
			E[++D]=(Lin){v,st[u]};	st[u]=D;
			E[++D]=(Lin){u,st[v]};	st[v]=D;
		}

		int		LCA(int u,int v){
			for (++*Tim;u;u=Pre[Mat[u]])	Tim[u=F[u]]=*Tim;
			for (;;v=Pre[Mat[v]])	if	(Tim[v=F[v]]==*Tim)	return	v;
		}
		void	Upd(int u,int w){
			for (;u!=w;)	{
				int v=Mat[u];
				Tim[F[u]]=Tim[F[v]]=*Tim;	v=Pre[v];
				if	(F[v]!=w)	Pre[v]=Mat[u];	u=v;
			}
		}

		void	Cir(int u,int v){
			int w=LCA(u,v);	++*Tim;
			Upd(u,w);	if	(F[u]!=w)	Pre[u]=v;
			Upd(v,w);	if	(F[v]!=w)	Pre[v]=u;
			For(i,1,N)	if	(Tim[F[i]]==*Tim)	{
				F[i]=w;
				if	(!V[i])	V[Q[++R]=i]=1;
			}
		}

		bool	Find(int S){
			For(i,1,N)	Pre[i]=V[i]=0,F[i]=i;	V[Q[1]=S]=1;
			for (L=0,R=1;L<R;)	{
				int u=Q[++L];	vis[u]=1;
				for (int i=st[u],v;i;i=E[i].next)
				if	(F[v=E[i].v]!=F[u]&&Mat[u]!=v)
				if	(v==S||Mat[v]&&Pre[Mat[v]])	Cir(u,v);
				else	if	(!Pre[v]){
					Pre[v]=u;
					if	(Mat[v]){
						if	(!V[Mat[v]])	V[Q[++R]=Mat[v]]=1;
					}	else	{
						for (u=v;u;){
							v=Pre[u];	int w=Mat[v];
							Mat[u]=v;	Mat[v]=u;	u=w;
						}	return	1;
					}
				}
			}	return	0;
		}

		int		Main(){
			int Ans=0;
			For(i,1,N)	if	(!Mat[i])	Find(i);
			For(i,1,N)	Ans+=(Mat[i]>0);
			return	Ans>>1;
		}
};

const	int	cx[]={-1,-1,-1,0,0,1,1,1},cy[]={-1,0,1,-1,1,-1,0,1};

int		T,N,M,C,A[55][55],B[55][55],X[55][55],Y[55][55],Q[n][2];
char	s[55][55];

bool	IN(int x,int y)	{return	x>=1&&x<=N&&y>=1&&y<=M;}

void	Work(int Sx,int Sy){
		Q[1][0]=Sx;	Q[1][1]=Sy;	B[Sx][Sy]=++C;
		for	(int l=0,r=1;l<r;)	{
			int	ux=Q[++l][0],uy=Q[l][1];

			if	(A[ux][uy])	{
				if	(X[ux][uy])	Y[ux][uy]=C;
					else	X[ux][uy]=C;
				continue;
			}

			For(k,0,7)	{
				int vx=ux+cx[k],vy=uy+cy[k];
				if	(IN(vx,vy)&&s[vx][vy]!='*'&&B[vx][vy]!=C)
					Q[++r][0]=vx,Q[r][1]=vy,B[vx][vy]=C;
			}
		}
}

int		main()	{
		scanf("%d",&T);
		for	(;T--;C=0)	{
			scanf("%d%d",&N,&M);
			For(i,1,N)	scanf("%s",s[i]+1);
			For(i,1,N)	For(j,1,M){
				A[i][j]=B[i][j]=X[i][j]=Y[i][j]=0;
				For(k,0,7)	if	(IN(i+cx[k],j+cy[k])&&s[i+cx[k]][j+cy[k]]=='*')	A[i][j]++;
			}
			For(i,1,N)	For(j,1,M)	if	(s[i][j]!='*'&&!A[i][j]&&!B[i][j])	Work(i,j);

			int	Ans=C;	Graph::clear(C);
			For(i,1,N)	For(j,1,M)	if	(s[i][j]=='*'||!B[i][j])	Ans++;
				else	if	(A[i][j]&&X[i][j]&&Y[i][j])	Graph::Link(X[i][j],Y[i][j]);
			Ans-=Graph::Main();
			printf("%d\n",Ans);
		}
}