#include <iostream>
#include <set>
#include <ctime>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cassert>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
#define traverse(v,it) for (typeof(v.begin()) it=v.begin();it!=v.end();it++)

// Gabow's O(N^3) implementation of Edmonds' general matching algorithm

namespace MATCHING {
	enum LinkType {LTunlinked, LTdegenerate, LTpointer, LTpair};

	typedef struct {
		LinkType type; int l; int b1; int b2; int top;
	} Link;

	vector<vector<int> > g;
	int mate[2000];
	Link link[2000];
	char flag[2000];

	char done[2000][2000];

	void Rematch(int f, int v) {
		int w=mate[v];
		mate[v]=f;
		if (w!=-1 && mate[w]==v) {
			if (link[v].type==LTpointer) {
				mate[w]=link[v].l;
				Rematch(w,link[v].l);
			} else if (link[v].type==LTpair) {
				Rematch(link[v].b1,link[v].b2);
				Rematch(link[v].b2,link[v].b1);
			} else {
				assert(1==2);
			}
		}
	}

	int First_Free(int v) {
		if (mate[v]==-1) return -1;
		if (link[mate[v]].type==LTunlinked) {
			return mate[v];
		} else if (link[v].type==LTpair) {
			return link[v].top;
		} else {
			assert(link[mate[v]].type==LTpair);
			return link[mate[v]].top;
		}
	}

	void Pair_Link(int base1, int base2, queue<pair<int,int> > &todo) {
		int u[2]={First_Free(base1), First_Free(base2)};
		if (u[0]==u[1]) return;
		flag[u[0]]=1; flag[u[1]]=1;
		int tip=-1;
		while (tip==-1 && (u[0]!=-1 || u[1]!=-1)) { // find tip
			for (int i=0;i<=1;i++) {
				if (u[i]==-1) continue;
				u[i]=First_Free(link[mate[u[i]]].l);
				if (u[i]==-1) continue;
				if (flag[u[i]]) { tip=u[i]; break; }
				flag[u[i]]=1;
			}
		}
		for (int i=0;i<=1;i++) { // assign pair links from base1 and base2 to tip
			int v;
			if (i==0) v=First_Free(base1); else v=First_Free(base2);
			while (v!=tip) {
				link[v].type=LTpair;
				link[v].b1=base1; link[v].b2=base2; link[v].top=tip;
				flag[v]=0;
				for (int j=0;j<g[v].size();j++) todo.push(make_pair(v,g[v][j]));
				v=First_Free(link[mate[v]].l);
			}
		}
		int v=tip; // remove flags
		while (v!=-1 && flag[v]) {
			flag[v]=0;
			v=First_Free(link[mate[v]].l);
		}
		for (int i=0;i<g.size();i++) { // update top
			if (link[i].type==LTpair) {
				if (link[link[i].top].type!=LTunlinked) link[i].top=tip;
			}
		}
	}

	int Match() {
		for (int i=0;i<g.size();i++) mate[i]=-1;
		for (int e=0;e<g.size();e++) {
			if (mate[e]==-1) {
				for (int j=0;j<g.size();j++) {
					link[j].type=LTunlinked;
					for (int k=0;k<g[j].size();k++) { done[j][g[j][k]]=0; done[g[j][k]][j]=0; }
				}
				link[e].type=LTdegenerate;
				queue<pair<int,int> > todo;
				for (int j=0;j<g[e].size();j++) todo.push(make_pair(e,g[e][j]));
				while (!todo.empty()) {
					int x=todo.front().first, y=todo.front().second; todo.pop();
					if (e<x || e<y) continue;
					if (mate[x]==y) continue;
					if (done[x][y]) continue;
					done[x][y]=1;

					if (mate[y]==-1) {
						mate[y]=x; Rematch(y,x); break;
					} else if (link[y].type!=LTunlinked) {
						done[y][x]=1;
						Pair_Link(y,x,todo);
					} else if (link[mate[y]].type==LTunlinked) {
						done[y][x]=1;
						int v=mate[y];
						link[v].type=LTpointer; link[v].l=x;
						for (int j=0;j<g[v].size();j++) {
							todo.push(make_pair(v,g[v][j]));
						}
					} else {
					}
				}
			}
		}
		int m=0;
		for (int i=0;i<g.size();i++) if (mate[i]!=-1 && i<mate[i]) m++;
		return m;
	}
}

// ------------------------

int N,M;
int g[100][100];

int on(int i, int j) {
	return 0<=i && 0<=j && i<N && j<M;
}

int v[100][100], id;
void flood(int i, int j) {
	if (v[i][j]!=-1 || g[i][j]!=0) return;
	v[i][j]=id;
	for (int di=-1;di<=1;di++) for (int dj=-1;dj<=1;dj++) {
		if (on(i+di,j+dj)) flood(i+di,j+dj);
	}
}

int layout;
int solve() {
	int click=0;

	// numer of neighbouring mines
	for (int i=0;i<N;i++) for (int j=0;j<M;j++) if (g[i][j]!=-1) {
		int m=0;
		for (int di=-1;di<=1;di++) for (int dj=-1;dj<=1;dj++) {
			int i2=i+di, j2=j+dj;
			if (on(i2,j2) && g[i2][j2]==-1) m++;
		}
		g[i][j]=m;
	}

	// connected components of zeros
	memset(v,-1,sizeof(v));
	int nodes=0;
	id=0;
	for (int i=0;i<N;i++) for (int j=0;j<M;j++) if (g[i][j]==0 && v[i][j]==-1) {
		flood(i,j); nodes++; id++;
	}

	// generate edges (positive cells, connecting two components of zeros)
	set<pair<int,int> > edges;
	for (int i=0;i<N;i++) for (int j=0;j<M;j++) {
		if (g[i][j]>0) {
			set<int> neigh;
			for (int di=-1;di<=1;di++) for (int dj=-1;dj<=1;dj++) {
				int i2=i+di, j2=j+dj;
				if (on(i2,j2) && g[i2][j2]==0) neigh.insert(v[i2][j2]);
			}
			if (neigh.size()==2) edges.insert(make_pair(*neigh.begin(),*(++neigh.begin())));
			if (neigh.size()==0) click++;
		} else if (g[i][j]==-1) {
			click++;
		}
	}

	vector<int> a[nodes];
	traverse(edges,it) {
		a[it->first].push_back(it->second);
		a[it->second].push_back(it->first);
	}

	MATCHING::g.clear();
	for (int i=0;i<nodes;i++) MATCHING::g.push_back(a[i]);
	int r1=MATCHING::Match();

	return click+nodes-r1;
}


int main() {
	int tests;
	scanf("%d",&tests);
	while (tests--) {
		scanf("%d %d",&N,&M);
		for (int i=0;i<N;i++) {
			char line[105];
			scanf("%s",line);
			for (int j=0;j<M;j++) {
				if (line[j]=='.') g[i][j]=0; else g[i][j]=-1;
			}
		}
		printf("%d\n",solve());
	}
	return 0;
}
