/* Author :: Yash */
#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) 
#define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)
#define REP(i,n) FOR(i,0,n)
#define DEP(i,n) REV(i,n,0)
#define PB push_back
#define PP pop()
#define EM empty()
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a) 	    __typeof(a) x(a)
#define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i)
#define EACH(it,v)  	IFOR(it,v.begin(),v.end())
#define PRESENT(c,x) 	((c).find(x) != (c).end())
#define SZ(x) 		x.size()
#define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end())
#define CLR(a,v)        memset((a),(v),sizeof(a))
#define D(N) 		int N
#define S(N)		scanf("%d",&N)
#define FASTIO          1

typedef pair<int,int>   PI;
typedef pair<int,PI>    TRI;
typedef V( int )        VI;
typedef V( PI  )        VII;
typedef V( string )     VS;
typedef long long       LL;
typedef long double     LD;

/* FastIO, generally required these days ;) */

#ifndef FASTIO
char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20];
inline int input(int flag=0) {

	while(*ipos <= 32) ++ipos;
	if ( flag  ) return (*ipos++ - '0'); /* For getting Boolean Characters */
	int x=0, neg = 0;char c;
	while( true ) {
		c=*ipos++; if(c == '-') neg = 1;
		else {
			if (c<=32) return neg?-x:x;
			x=(x<<1)+(x<<3)+c-'0';
		}
	}
}
inline void output(int x,int flag) {
	int y,dig=0;
	while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}
	while (dig--) *opos++=DIP[dig];
	*opos++= flag ? '\n' : ' ';
}
inline void InitFASTIO() {
	ipos = InpFile; opos = OutFile;
	fread_unlocked(InpFile,20000000,1,stdin);
}
inline void FlushFASTIO() {
	fwrite_unlocked(OutFile,opos-OutFile,1,stdout);	
}
#endif

/* Main Code Starts from here */




#define MAXN 175 
int cap[MAXN][MAXN], flow[MAXN][MAXN], cost[MAXN][MAXN]; 
int s[MAXN], e[MAXN], v[MAXN], w[MAXN];
int n, sink, source, total_cost;


inline int cf(int i, int j) { 
   return cap[i][j];
} 

inline int costf(int i, int j) { 
    return cost[i][j]; 
} 

inline void pushf(int i, int j, int x) { 
    total_cost += costf(i, j) * x; 
    cap[i][j] -= x; cap[j][i] += x;
} 

int augment(void) { 
    int dist[MAXN], prev[MAXN]; 
    bool reach[MAXN]; 
    bool changed; 
    int i, j; 
    CLR(reach,0); 
    reach[source] = changed = true; 
    dist[source] = 0; 
    while (changed) { 
        changed = false; 
        REP(i,n) if (reach[i]) REP(j,n) if (cf(i, j)) 
            if (!reach[j] || dist[i] + costf(i, j) < dist[j]) { 
                reach[j] = changed = true; 
                dist[j] = dist[i] + costf(i, j); 
                prev[j] = i; 
            } 
    } 
    if (!reach[sink]) return 0;

    int ret = 2000; 
    for (i = sink; i != source; i = prev[i]) ret = min(ret, cap[prev[i]][i]); //pushf(prev[i], i, 1); 
    for (i = sink; i != source; i = prev[i]) pushf(prev[i], i, ret); 
    return ret; 
} 

int mcmf(void) { 
    int ret, x; 
    CLR(flow,0); 
    ret = total_cost = 0; 
    while (x = augment()) ret += x; 
    return ret; 
} 

int main() {

   int kases, N, M; scanf("%d",&kases);
   while(kases--) {
      scanf("%d%d",&N,&M);
      REP(i,N) {
	 scanf("%d%d%d",s+i,e+i,v+i);
      }
      REP(i,M) scanf("%d",w+i);

      int nodes = 0;
      source = nodes++;

      memset(cap,0,sizeof cap); memset(cost,0,sizeof cost);

      REP(i,M) {
	 cap[nodes][nodes+1]  = w[i]; ++nodes;
      } ++nodes;
      REP(i,N) {
	 
	 cap[source][nodes] = 1; 
	 cap[nodes][s[i]+1] = 1; cost[nodes][s[i]+1] = -v[i]; cost[s[i]+1][nodes] = v[i];
	 cap[nodes][e[i]+1] = 2000;
	 ++nodes;
      }
      sink = nodes++; n = nodes;
      REP(i,M) {
	 int total = 0; REP(j,nodes) if(cap[j][i+2] == 2000) ++total;
	 cap[i+2][sink] = total;
      }

      mcmf(); cout << -total_cost << endl;
   }
   return 0;
}

