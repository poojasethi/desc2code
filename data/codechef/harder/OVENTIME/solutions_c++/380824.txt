/* Author :: Yash */
#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) 
#define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)
#define REP(i,n) FOR(i,0,n)
#define DEP(i,n) REV(i,n,0)
#define PB push_back
#define PP pop()
#define EM empty()
#define INF 1000000000
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a) 	    __typeof(a) x(a)
#define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i)
#define EACH(it,v)  	IFOR(it,v.begin(),v.end())
#define PRESENT(c,x) 	((c).find(x) != (c).end())
#define SZ(x) 		x.size()
#define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end())
#define CLR(a,v)        memset((a),(v),sizeof(a))
#define D(N) 		int N
#define S(N)		scanf("%d",&N)
#define FASTIO          1

typedef pair<int,int>   PI;
typedef pair<int,PI>    TRI;
typedef V( int )        VI;
typedef V( PI  )        VII;
typedef V( string )     VS;
typedef long long       LL;
typedef long double     LD;

/* FastIO, generally required these days ;) */

#ifndef FASTIO
char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20];
inline int input(int flag=0) {

   while(*ipos <= 32) ++ipos;
   if ( flag  ) return (*ipos++ - '0'); /* For getting Boolean Characters */
   int x=0, neg = 0;char c;
   while( true ) {
      c=*ipos++; if(c == '-') neg = 1;
      else {
	 if (c<=32) return neg?-x:x;
	 x=(x<<1)+(x<<3)+c-'0';
      }
   }
}
inline void output(int x,int flag) {
   int y,dig=0;
   while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}
   while (dig--) *opos++=DIP[dig];
   *opos++= flag ? '\n' : ' ';
}
inline void InitFASTIO() {
   ipos = InpFile; opos = OutFile;
   fread_unlocked(InpFile,20000000,1,stdin);
}
inline void FlushFASTIO() {
   fwrite_unlocked(OutFile,opos-OutFile,1,stdout);	
}
#endif

/* Main Code Starts from here */


struct edge {
   int to, back, cap, cost;
   edge() {to = back = cap = (cost = 0) - 1;}
   edge(int _to, int _cap, int _back) : to(_to), cap(_cap), back(_back) { cost = 0; }
   edge(int _to, int _cap, int _cost, int _back) : to(_to), cap(_cap), back(_back) {
      cost = _cost;
   }
};

class FlowDinics {
   private:
      vector<vector<edge> > graph;
      VI Layers,now;
      int n, source, sink;

   public:
      friend class MinCostFlow;
      FlowDinics(int _n,int _source,int _sink) : n(_n), source(_source), sink(_sink) {
	 graph.resize(n);Layers.resize(n);now.resize(n);
	 REP(i,n) graph[i].clear();
      }
      ~FlowDinics() {
	 REP(i,n) graph[i].clear();
      }
      void insert(int i,int j,int cap) {
	 graph[i].PB(edge(j,cap,graph[j].size()));
	 graph[j].PB(edge(i,0,graph[i].size()-1));
      }
      int bfs() {

	 fill(ALL(Layers),-1);

	 Layers[sink] = 0;
	 queue<int> Q; Q.push(sink);
	 int top, from, to, cap, index;
	 while(!Q.empty()) {
	    top = Q.front(); Q.pop();
	    REP(i,graph[top].size()) {
	       from = graph[top][i].to; index = graph[top][i].back;
	       if(graph[from][index].cap && Layers[from] == -1) {
		  Layers[from] = Layers[top] + 1;
		  Q.push(from);
	       }
	    }
	 }
	 return (Layers[source] != -1);
      }
      int dfs(int node,int val) {
	 if(node == sink) {
	    return val;
	 }
	 int flow, to, cap;
	 for(int& start = now[node] ; start < graph[node].size(); ++start) {
	    to  = graph[node][start].to;
	    cap = graph[node][start].cap;
	    if(cap > 0 && Layers[node] == Layers[to] + 1) {
	       flow = dfs(to,min(val,cap));
	       if(flow) {
		  graph[node][start].cap -= flow;
		  graph[to][graph[node][start].back].cap += flow; return flow;
	       }
	    }
	 }
	 return 0;
      }
      int flow() {
	 int ret = 0, flow = 0;
	 while(bfs()) {
	    fill(ALL(now),0);
	    while(flow = dfs(source,INF)) ret += flow;
	 }
	 return ret;
      }
};


class MinCostFlow {
   private:
      vector< vector<edge> > graph;
      int n, source, sink;
   public:
      friend class FlowDinics;
      MinCostFlow(int _n, int _source, int _sink) : n(_n), source(_source), sink(_sink) {
	 graph.resize(n); REP(i,n) graph[i].clear();
      }
      ~MinCostFlow() {
	 REP(i,n) graph[i].clear(); graph.clear(); 
      }
      void insert(int i, int j, int cap, int cost) {
	 graph[i].PB(edge(j,cap,cost,graph[j].size()));
	 graph[j].PB(edge(i,0,-cost,graph[i].size()-1));
      }
      int getMinCostFlow() {

	 FlowDinics initialFlow(n,source,sink);
	 initialFlow.graph = graph;
	 int flow = initialFlow.flow();

	 /* We have set up an initial basic feasible solution, Now detect cycles using Bellman Ford Algorithm */

	 if(flow == 0) return 0;


	 vector< vector<edge> > residual = initialFlow.graph;
	 int dist[n], prev[n], index[n];


	 while(true) {

	    fill(dist,dist+n,0);
	    fill(prev,prev+n,-1);
	    REP(loop,n) { 
	       REP(i,n) REP(k,residual[i].size()) if(residual[i][k].cap) {
		  int j = residual[i][k].to, cost = residual[i][k].cost;
		  if(dist[j] > dist[i] + cost) {
		     dist[j] = dist[i] + cost;
		     prev[j] = i; index[j] = k; 
		  }
	       }
	    }

	    bool cycle = false; int cVertex = -1;
	    REP(i,n) {
	       REP(k,residual[i].size()) if(residual[i][k].cap) {
		  int j = residual[i][k].to, cost = residual[i][k].cost;
		  if(dist[j] > dist[i] + cost) {
		     cycle = true;
		     dist[j] = dist[i] + cost;
		     prev[j] = i; index[j] = k; 
		     cVertex = j; break;
		  }
	       }
	       if(cycle) break;
	    }

	    bool used[n]; CLR(used,0);
	    while(cVertex != -1 && !used[cVertex]) { used[cVertex] = 1; cVertex = prev[cVertex];}

	    if(cVertex == -1) break;

	    if(cycle) {
	       int add = INF;
	       for(int j = cVertex ; cycle || j != cVertex ; j = prev[j]) {
		  cycle = false;
		  add = min(add, residual[prev[j]][index[j]].cap);
	       } cycle = true;
	       for(int j = cVertex ; cycle || j != cVertex ; j = prev[j]) {
		  cycle = false;
		  residual[prev[j]][index[j]].cap -= add;
		  residual[j][residual[prev[j]][index[j]].back].cap += add;
	       } 
	    }
	    else break;
	 }
	 int cost = 0;
	 REP(i,n) REP(j,graph[i].size()) if(graph[i][j].cap > residual[i][j].cap) {
	    cost += graph[i][j].cost * (graph[i][j].cap - residual[i][j].cap);
	 }
	 return cost;
      }
}; 


int main() {

   //freopen("input.txt", "rt", stdin);
   //freopen("output.txt", "wt", stdout);

   int s[175], e[175], v[175], w[175], cap[175][175], cost[175][175];

   int kases, N, M; scanf("%d",&kases);
   while(kases--) {
      scanf("%d%d",&N,&M);
      REP(i,N) {
	 scanf("%d%d%d",s+i,e+i,v+i);
      }
      REP(i,M) scanf("%d",w+i);

      MinCostFlow sol(N+M+3,0,N+M+2);

      int nodes = 0;
      int source = nodes++;

      memset(cap,0,sizeof cap); memset(cost,0,sizeof cost);

      REP(i,M) {
	 cap[nodes][nodes+1]  = w[i]; 
	 sol.insert(nodes,nodes+1,w[i],0);
	 ++nodes;
      } ++nodes;

      REP(i,N) {

	 cap[source][nodes] = 1; sol.insert(source,nodes,1,0);
	 cap[nodes][s[i]+1] = 1; cost[nodes][s[i]+1] = -v[i]; cost[s[i]+1][nodes] = v[i];
	 sol.insert(nodes,s[i]+1,1,-v[i]);


	 cap[nodes][e[i]+1] = 2000;
	 sol.insert(nodes,e[i]+1,2000,0);
	 ++nodes;
      }
      int sink = nodes++, n = nodes;
      REP(i,M) {
	 int total = 0; REP(j,nodes) if(cap[j][i+2] == 2000) ++total;
	 cap[i+2][sink] = total;
	 sol.insert(i+2,sink,total,0);
      }
      cout << -sol.getMinCostFlow() << endl;
   }
   return 0;
}

