#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<map>
#include<set>
#include<stack>
#include<list>
#include<vector>
#include<queue>
using namespace std;
#define maxn 100010
vector <int> ds[maxn];
int n,pos[maxn][20],f[maxn][20],depth[maxn],pa[maxn],num[maxn];
pair < pair <int, int>, int> a[maxn];
bool visited[maxn];
//dfs to determine the distance from the capital to the city u (depth[u]) and the parent of the city u (pa(u)) in the tree.
void dfs(int u) 
{
	int i, v, z=ds[u].size();
	for(i=0;i<z;i++) 
    {
		v=ds[u][i];
		if(!depth[v]){depth[v]=depth[u]+1;pa[v]=u;dfs(v);}
	}
}	
void init() 
{
	memset(depth, 0, sizeof(depth));
	depth[1]=1; pa[0]=0; pa[1]=1; dfs(1);  
    int i, k;                                   //use f for finding lca
	memset(f, 0, sizeof(f));
	for(i=1;i<=n;i++) f[i][0]=pa[i];
    for(f[1][0]=0,k=1;k<18;k++)for(i=1;i<=n;i++)f[i][k]=f[f[i][k-1]][k-1];
}
void suffix() 
{                                  //sort the pathes by applying the method similar to building the suffix array
	int i, k;
    for(i=1;i<=n;i++) pos[i][0]=num[i];
	for(k=1;k<18;k++) 
    {
		for(i=1;i<=n;i++) 
        {
			a[i].first.first=pos[i][k-1];
			if(depth[i]<=(1<<(k-1))) a[i].first.second=-1;
			else a[i].first.second=pos[f[i][k-1]][k-1];
			a[i].second=i;
		}
		for(sort(a+1, a+1+n), pos[a[1].second][k]=1, i=2;i<=n;i++) 
        {
			pos[a[i].second][k]=pos[a[i-1].second][k];
			if(a[i-1].first!=a[i].first && a[i-1].second!=a[i].second) pos[a[i].second][k]++;
		}
	}
}
int lcp(int u, int v) 
{                                  //return the longest common prefix of the path from u to 1 and from v to 1.
	int k, len=0;
	if(pos[u][17]==pos[v][17]) return min(depth[u],depth[v]);
    for(k=17;k>=0;k--)if(pos[u][k]==pos[v][k]) 
    {
	    len+=(1<<k);
	    u=f[u][k];
	    v=f[v][k];
	    if(u==0 || v==0)break;
	}
	return len;
}
int main() 
{
       long long res=0;
       int i, u, v;
       for(cin>>n,i=1;i<=n;i++){ds[i].clear();num[i]=0;}
	   for(i=1;i<n;i++) 
       {
		  scanf("%d%d",&u,&v);
		  ds[u].push_back(v);  
          ds[v].push_back(u);
		  num[u]++;     
          num[v]++;
	   }  
	   for(init(),suffix(),res+=depth[a[1].second],i=2;i<=n;i++) 
       res+=depth[a[i].second]-lcp(a[i].second,a[i-1].second);
	   cout<<res;
       return 0;
}
