#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct obj
{
    int A[2], P;
};

int N;
vector<int> V[100002];
int level[100002];
int grad[100002], maxstep;
int P[20][100002], ST[100002], T[20][100002];
obj L[100002];
bool S[100002];

void Dfs(int x)
{
    S[x] = true;
    ST[++ST[0]] = x;

    for (int i = 0; i <= 18; ++i)
    {
        if ((1 << i) < ST[0]) T[i][x] = ST[ST[0] - (1 << i)];
        else                  T[i][x] = 0;
    }

    for (vector<int>::iterator it = V[x].begin(); it != V[x].end(); ++it)
        if (!S[*it])
        {
            level[*it] = level[x] + 1;
            Dfs(*it);
        }
    --ST[0];
}

class comparator
{
    public:
        inline bool operator () (const obj& O1, const obj& O2)
        {
            return O1.A[0] != O2.A[0] ? O1.A[0] < O2.A[0] : O1.A[1] < O2.A[1];
        }
};
inline int LCP(int i1, int i2)
{
    int result = 0;
    for (int stepnow = maxstep; stepnow >= 0 && i1 != 0 && i2 != 0; --stepnow)
        if (P[stepnow][i1] == P[stepnow][i2])
        {
            if ((1 << stepnow) <= max(level[i1], level[i2])) result += (1 << stepnow);
            else                                             result += max(level[i1], level[i2]);
            i1 = T[stepnow][i1];
            i2 = T[stepnow][i2];
        }
    return result;
}

int main()
{
    //freopen("trips.in", "r", stdin);
    //freopen("trips.out", "w", stdout);

    cin >> N;
    for (int i = 1, nod1, nod2; i < N; ++i)
    {
        cin >> nod1 >> nod2;
        V[nod1].push_back(nod2);
        V[nod2].push_back(nod1);
        ++grad[nod1];
        ++grad[nod2];
    }

    level[1] = 1;
    Dfs(1);

    for (int i = 1; i <= N; ++i)
        P[0][i] = grad[i];
    for (int step = 1; ((1 << step) >> 1) <= N; ++step)
    {
        maxstep = step;
        for (int j = 1; j <= N; ++j)
        {
            L[j].A[0] = P[step - 1][j];
            if ((1 << (step - 1)) < level[j]) L[j].A[1] = P[step - 1][T[step - 1][j]];
            else                              L[j].A[1] = 0;
            L[j].P = j;
        }
        sort(L + 1, L + N + 1, comparator());

        int pnow = 0;
        for (int j = 1; j <= N; ++j)
            P[step][L[j].P] = ((L[j].A[0] == L[j - 1].A[0] && L[j].A[1] == L[j - 1].A[1] && j != 1) ? pnow : ++pnow);
    }

    long long result = 0;
    for (int i = 1; i <= N; ++i)
        result += level[i];
    for (int i = 1; i < N; ++i)
        result -= LCP(L[i].P, L[i + 1].P);

    cout << result << '\n';
}
