#include <map>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	200005
#define I64	long long
#define Map	map<int,int>
#define For(i,a,b)	for(int i=a;i<=b;i++)

int		N,D,S[n],st[n],Now[n];
struct	Lin{int v,next;}E[n];

namespace	SAM{
		int 	T=1,F[n],Q[n],V[n],Max[n];
		I64		R[n];
		Map		A[n];

		int		Extend(int p,int x){
			int	np=++T,q,nq;	Max[np]=Max[p]+1;
			for	(;p&&!A[p][x];p=F[p])	A[p][x]=np;
			if	(!p)	F[np]=1;else
			if	(Max[q=A[p][x]]==Max[p]+1)	F[np]=q;
			else	{
				Max[nq=++T]=Max[p]+1;	F[nq]=F[q];	A[nq]=A[q];
				for	(F[q]=F[np]=nq;p&&A[p][x]==q;p=F[p])	A[p][x]=nq;
			}	R[np]++;
			return	np;
		}
		bool	Cmp(int a,int b)	{return	Max[a]>Max[b];}

		void	DFS(int u){
			if	(V[u])	return;	V[u]=1;
			for	(Map::iterator t=A[u].begin();t!=A[u].end();t++)	DFS(t->second);
		}
		void	Work(){
			DFS(1);
			For(i,1,T)	if	(V[i])	Q[++*Q]=i;
			sort(Q+1,Q+*Q+1,Cmp);
			For(i,1,*Q)	{
				int u=Q[i];	R[F[u]]+=R[u];	R[u]=!!R[u];
				for	(Map::iterator t=A[u].begin();t!=A[u].end();t++)	R[u]+=R[t->second];
			}
		}
};

#define CH	(ch=getchar())
int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}

void	Link(int u,int v){
		E[++D]=(Lin){v,st[u]};	st[u]=D;S[u]++;
		E[++D]=(Lin){u,st[v]};	st[v]=D;S[v]++;
}
void	DFS(int u,int f){
		Now[u]=SAM::Extend(Now[f],S[u]);
		for (int i=st[u],v;i;i=E[i].next)
			if	((v=E[i].v)!=f)	DFS(v,u);
}

int		main(){
		N=IN();
		For(i,2,N)	Link(IN(),IN());
		Now[0]=1;	DFS(1,0);	SAM::Work();
		printf("%lld\n",SAM::R[1]-1);
}