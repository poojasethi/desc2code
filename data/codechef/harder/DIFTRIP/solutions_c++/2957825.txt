/*
The original version of this problem is couting number of different sub-string of a given string.
We can apply the idea of building the suffix array algorithm to sort all the path from the each city to the capital and also, determine the longest common prefix of two path in the sorted array.
*/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <list>
#include <vector>
#include <queue>

using namespace std;

#define PI acos(-1)
#define MP make_pair
#define PB push_back
#define VI vector <int>
#define PII pair <int, int>
#define LL long long
#define SET(v,i) memset(v, i, sizeof(v))
#define FOR(i,a,b) for (int i = (a); i <= (b); i++)
#define FORD(i,a,b) for (int i = (a); i >= (b); i--)
#define FORN(i,a,b) for (int i = (a); i < (b); i++)
#define DOWN(i,a,b) for (int i = (a); i > (b); i--)
#define FIT(it,v) for (typeof(v.begin()) it = v.begin(); it != v.end(); it++)
#define FITD(it,v) for (typeof(v.rbegin()) it = v.rbegin(); it != v.rend(); it++)
#define FREOPEN freopen("1.in", "r", stdin); freopen("a.out", "w", stdout)

#define maxn 100010

int n;
VI ds[maxn];
int pos[maxn][20], f[maxn][20];
int depth[maxn], pa[maxn];
pair < PII, int> a[maxn];


bool visited[maxn];
int num[maxn];


//dfs to determine the distance from the capital to the city u (depth[u]) and the parent of the city u (pa(u)) in the tree.
void dfs(int u) {
	int z = ds[u].size();
	FOR (i, 0, z - 1) {
		int v = ds[u][i];
		if (!depth[v]) {
			depth[v] = depth[u] + 1;
			pa[v] = u;
			dfs(v);
		}
	}
}	

void init() {
	SET (depth, 0);
	depth[1] = 1;
	pa[0] = 0;
	pa[1] = 1;
	dfs(1);
	
	//use f for finding lca
	SET (f, 0);
	FOR (i, 1, n) f[i][0] = pa[i];
	f[1][0] = 0;
	
	FOR (k, 1, 17) 
	FOR (i, 1, n) f[i][k] = f[f[i][k - 1]][k - 1];
}

void suffix() {
	//sort the pathes by applying the method similar to building the suffix array
	FOR (i, 1, n) pos[i][0] = num[i];
	
	FOR (step, 1, 17) {
		FOR (i, 1, n) {
			a[i].first.first = pos[i][step - 1];
			if (depth[i] <= (1 << (step - 1))) a[i].first.second = -1;
			else a[i].first.second = pos[f[i][step - 1]][step - 1];
			
			a[i].second = i;
		}
		
		sort (a + 1, a + 1 + n);
		
		pos[a[1].second][step] = 1;
		FOR (i, 2, n) {
			pos[a[i].second][step] = pos[a[i - 1].second][step];
			
			if (a[i - 1].first != a[i].first && a[i - 1].second != a[i].second) 
				pos[a[i].second][step]++;
		}
	}
}

int lcp (int u, int v) { //return the longest common prefix of the path from u to 1 and from v to 1.

	int len = 0;
	if (pos[u][17] == pos[v][17]) return min(depth[u], depth[v]);
	
	FORD (k, 17, 0) 
		if (pos[u][k] == pos[v][k]) {
			len += (1 << (k));
			u = f[u][k];
			v = f[v][k];
			if (u == 0 || v == 0) break;
		}
	
	return len;
}

void count() {
	//counting the number of different trips.
	//we just determine the sum of all the paths and minus all the lcp of two consecutive paths in the sorted array.
	long long res = 0;
	
	res += depth[a[1].second];
	
	FOR (i, 2, n)
		res += depth[a[i].second] - lcp(a[i].second, a[i - 1].second);
	
	cout << res;
}

void enter() {
	cin >> n;
	
	FOR (i, 1, n) {
		ds[i].clear();
		num[i] = 0;
	}
	
	FOR (i, 1, n - 1) {
		int u, v;
		scanf("%d%d", &u, &v);
		ds[u].PB(v);
		ds[v].PB(u);
		num[u] ++;
		num[v] ++;
	}
}

int main() {

	enter();
	init();
	suffix();
	count();
	
	return 0;
}