#include <cassert>
#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <climits>
#include <cstddef>
#include <cctype>
#include <cmath>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <iterator>
#include <numeric>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <list>
#include <string>
#include <functional>
#include <utility>
using namespace std;
typedef long long llint;
int const N = 100000;
int const B = 20;
int n;
vector <int> adj[N + 1];
int deg[N + 1];
int st[N + 1][B];
int depth[N + 1];
int rank[N + 1][B];
int sa[N + 1];
llint res;
bool readin()
{
	int u, v;
	int i;
	if (scanf("%d", &n) == EOF)
	{
		return false;
	}
	for (i = 1; i <= n; ++i)
	{
		adj[i].clear();
	}
	memset(deg, 0, sizeof(deg));
	for (i = 1; i < n; ++i)
	{
		scanf("%d%d", &u, &v);
		adj[u].push_back(v);
		adj[v].push_back(u);
		++deg[u];
		++deg[v];
	}
	return true;
}
void dfs(int r)
{
	for (vector <int>::iterator it = adj[r].begin(); it != adj[r].end(); ++it)
	{
		if (depth[*it] == -1)
		{
			depth[*it] = depth[r] + 1;
			st[*it][0] = r;
			dfs(*it);
		}
	}
}
class Cmp
{
public:
	Cmp(int level) : level(level)
	{
	}
	bool operator () (int const &u, int const &v)
	{
		int st_u = st[u][level - 1], st_v = st[v][level - 1];
		if (rank[u][level - 1] != rank[v][level - 1])
		{
			return rank[u][level - 1] < rank[v][level - 1];
		}
		if (st_u != 0 && st_v != 0)
		{
			return rank[st_u][level - 1] < rank[st_v][level - 1];
		}
		else
		{
			return st_v != 0;
		}
	}
private:
	int level;
};
int sort_gao()
{
	int bs;
	int max_d = *(max_element(depth + 1, depth + (n + 1)));
	int i, j;
	for (i = 1; i <= n; ++i)
	{
		sa[i] = i;
	}
	for (i = 1; i <= n; ++i)
	{
		rank[i][0] = deg[i];
	}
	for (bs = 1; (1 << (bs - 1)) < max_d; ++bs)
	{
		Cmp h(bs);
		sort(sa + 1, sa + (n + 1), h);
		for (i = 1, j = 0; i <= n; ++i)
		{
			if (i > 1 && h(sa[i - 1], sa[i]))
			{
				++j;
			}
			rank[sa[i]][bs] = j;
			st[i][bs] = st[st[i][bs - 1]][bs - 1];
		}
	}
	return bs - 1;
}
int get_lcp(int x, int y, int bs)
{
	int ret = 0;
	int i;
	for (i = bs; i >= 0 && x != 0 && y != 0; --i)
	{
		if (rank[x][i] == rank[y][i])
		{
			ret += min((1 << i), min(depth[x], depth[y]));
			x = st[x][i];
			y = st[y][i];
		}
	}
	return ret;
}
void solve()
{
	int bs;
	int i;
	memset(st, 0, sizeof(st));
	memset(depth, -1, sizeof(depth));
	depth[1] = 1;
	dfs(1);
	bs = sort_gao();
#if 0
	for (int i = 1; i <= n; ++i)
	{
		int r = sa[i];
		printf("%6d:", rank[r][bs]);
		while (r != 0)
		{
			printf("%6d", deg[r]);
			r = st[r][0];
		}
		printf("\n");
	}
#endif
	res = 0;
	for (i = 1; i <= n; ++i)
	{
		res += depth[sa[i]] - (i > 1 ? get_lcp(sa[i - 1], sa[i], bs) : 0);
	}
#ifdef __MY_PC
	printf("%I64d\n", res);
#else
	printf("%lld\n", res);
#endif
}
int main()
{
	readin();
	solve();
	return 0;
}
