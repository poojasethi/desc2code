#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

#define MAXN 100005
#define MAXM 100001
#define LOGN 19

int c[MAXN], *ar, *na, *ra, *nr, a[LOGN][MAXN], r[LOGN][MAXN], p[LOGN][MAXN], hh[MAXN], h[MAXN], e[MAXN<<1][2], ew;
void SAT(int s[], int f[], int d[], int n) {
// s[0..n):value in range [0..MAXM), f[0..n):father OR -1, d[0..n):0 base depth; update ar, ra, hh, h
// ar[i]=k : path k-root is i th smallest
// ra[i]=k : path i-root is k th smallest
// hh[i]: length of longest common prefix of path i-root and the one just smaller than it
// h[i]: length of longest common prefix of i th and (i-1) th path to root
// 先加dummy root with value = -INF
    int D = 0;
    for (int i=0; i<n; ++i) D = max(D, d[i]);
    for (int i=0; (1<<i)<=(D<<1); ++i) 
        for (int j=0; j<n; ++j) 
            p[i][j] = i==0 ? f[j] : (p[i-1][j] == -1 ? -1 : p[i-1][p[i-1][j]]);
    ar = a[0]; na = a[1]; ra = r[0]; nr = r[1];
    memset(c, 0, sizeof(c));
    for (int i=0; i<n; ++i) c[s[i]]++;
    for (int i=1; i<MAXM; ++i) c[i] += c[i-1];
    for (int i=n-1; i>=0; --i) ar[--c[s[i]]] = i;
    ra[ar[0]] = 0;
    for (int i=1; i<n; ++i) ra[ar[i]] = ra[ar[i-1]] + (s[ar[i]] != s[ar[i-1]]);
    int k, K;
    for (k=0, K=1; K<D && ra[ar[n-1]]<n-1; ++k, K<<=1) {
        memset(h, -1, sizeof(h));
        ew = 0;
        for (int i=0; i<n; ++i) if (p[k][i] != -1) e[ew][0] = i, e[ew][1] = h[p[k][i]], h[p[k][i]] = ew++;
        for (int i=0; i<n; ++i) c[ra[ar[i]]] = i+1;
        for (int i=n-1; i>=0; --i) for (int j=h[ar[i]]; j!=-1; j=e[j][1]) na[--c[ra[e[j][0]]]] = e[j][0]; 
        for (int i=n-1; i>=0; --i) if (d[ar[i]] < K) na[--c[ra[ar[i]]]] = ar[i];
        nr[na[0]] = 0;
        for (int i=1; i<n; ++i) nr[na[i]] = nr[na[i-1]] + ( ra[na[i]]!=ra[na[i-1]] || ( p[k][na[i]]!=-1 && p[k][na[i-1]]!=-1 && ra[p[k][na[i]]]!=ra[p[k][na[i-1]]] ) );
        ar = a[k+1]; na = a[k+2]; ra = r[k+1]; nr = r[k+2];
    }
    memset(h, 0, sizeof(h));
    for (int i=1; i<n; ++i) {
        int x = ar[i-1], y = ar[i];
        for (int j=k, J=K; x!=-1 && y!=-1 && j>=0; --j, J>>=1) {
            if (r[j][x] == r[j][y]) {
                h[i] += min(J, min(d[x]+1, d[y]+1));
                x = p[j][x];
                y = p[j][y];
            }
        }
    }
    for (int i=0; i<n; ++i) ra[ar[i]] = i;
    for (int i=0; i<n; ++i) hh[i] = h[ra[i]];
//for (int i=0; i<n; ++i) printf("%3d", ar[i]); printf(" ar\n");
//for (int i=0; i<n; ++i) printf("%3d", ra[i]); printf(" ra\n");
//for (int i=0; i<n; ++i) printf("%3d", h[i]); printf(" h\n");
//for (int i=0; i<n; ++i) printf("%3d", hh[i]); printf(" hh\n");
}

int n, x, y, g[MAXN];
void adde(int x, int y) {
    e[ew][0] = y;
    e[ew][1] = h[x];
    h[x] = ew++;
    g[x]++;
}
int q[MAXN], qr, qw, f[MAXN], d[MAXN];
bool b[MAXN];
void bfs(int S) {
    memset(b, true, sizeof(b));
    qr = qw = 0;
    q[qw++] = S;
    f[S] = -1;
    d[S] = 0;
    b[S] = false;
    while (qr != qw) {
        x = q[qr++];
        for (int i=h[x]; i!=-1; i=e[i][1]) {
            y = e[i][0];
            if (b[y]) {
                q[qw++] = y;
                f[y] = x;
                d[y] = d[x]+1;
                b[y] = false;
            }
        }
    }
}
int main(){
    scanf("%d", &n);
    memset(h, -1, sizeof(h));
    ew = 0;
    memset(g, 0, sizeof(g));
    for (int i=0; i<n-1; ++i) {
        scanf("%d%d", &x, &y);
        x--;
        y--;
        adde(x, y);
        adde(y, x);
    }
    adde(n, 0);
    adde(0, n);
    g[n]--;
    g[0]--;
    bfs(n);
    SAT(g, f, d, n+1);
    long long ans = 0;
    for (int i=0; i<n; ++i) {
        ans += max(0, d[i] - hh[i]);
    }
    cout << ans << endl;
    return 0;
}
