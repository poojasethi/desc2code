#include <cstdio>
#include <cmath>
#include <algorithm>
#include <memory.h>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
const int P=1999993;
int q,n,p,a,b,c,x,y,z,tes,cell[P],cnum,cell2[P],cnum2,rsum,T,rem[10010],tim[10010],od[10010],osum,bg,ed;
long long l,r;
bool tf,visit[10010];
struct matrix
{
    int c[3][3];
} trans,rev,zr,now,proc;
struct vec
{
	int c[3];
} fir,nows[10010],now2;
struct ce
{
    int data,next,t;
    matrix m;
} cel[1500000];
struct ce2
{
	int data,next,t;
} cel2[1500000];
inline matrix operator *(matrix a,matrix b)
{
    matrix ans;
    rep(i,0,2)
        rep(j,0,2)
        {
            ans.c[i][j]=0;
            rep(k,0,2)
                ans.c[i][j]+=a.c[i][k]*b.c[k][j];
            ans.c[i][j]%=p;
        }       
    return ans;
}
inline vec operator *(vec a,matrix b)
{
	vec ans;
	rep(i,0,2)
	{
		ans.c[i]=0;
		rep(j,0,2)
			ans.c[i]+=a.c[j]*b.c[j][i];
		ans.c[i]%=p;
	}
	return ans;
}
bool operator ==(matrix a,matrix b)
{
	rep(i,0,2)
		rep(j,0,2)
			if(a.c[i][j]!=b.c[i][j])return false;
  return true;
}
inline bool operator ==(vec a,vec b)
{
    rep(i,0,1)
      if(a.c[i]!=b.c[i])return false;
    return true;
}
int ksm(int bas,int k,int p)
{
    if(k==0)return 1;
    if(k==1)return bas;
    int ans=ksm(bas,k>>1,p);
    ans=ans*ans%p;
    if(k&1==1)ans=ans*bas%p;
    return ans;
}
int getsum(matrix m)
{
    int ans=0;   
    rep(i,0,2)
        rep(j,0,2)
            ans=ans*p+m.c[i][j];
    if(ans<0)ans=-ans;
  return ans; 
}
inline int getsum(vec m)
{
    int ans=0;   
    rep(i,0,1)
      ans=ans*p+m.c[i];
  return ans; 
}
void ins(matrix m,int b)
{
    int t=getsum(m);
    cnum++;
    //if(cnum>5000000)return;
    cel[cnum].m=m;
    cel[cnum].data=b;
    cel[cnum].next=cell[t%P];
    cel[cnum].t=t;
    cell[t%P]=cnum;
    return;
}
void ins(vec m,int b)
{
    int t=getsum(m);
    cnum2++;
    cel2[cnum2].t=t;;
    cel2[cnum2].data=b;
    cel2[cnum2].next=cell2[t%P];
    cell2[t%P]=cnum2;
    return;
}
int find(matrix m)
{   
    int t=getsum(m),tt=cell[t%P],ans=-1;
    while(tt!=0)
    {
        if(t==cel[tt].t&&m==cel[tt].m&&(cel[tt].data>0||tf==false))
        {
            if(ans==-1||cel[tt].data<ans)ans=cel[tt].data;
      }
        tt=cel[tt].next;
    }
    return ans;
}
int find(vec m)
{   
    int t=getsum(m),tt=cell2[t%P],ans=-1;
    while(tt!=0)
    {
        if(t==cel2[tt].t)
        {
            if(ans==-1||cel2[tt].data<ans)ans=cel2[tt].data;
      }
        tt=cel2[tt].next;
    }
    return ans;
}
long long getans(long long x)
{
    if(x<0||osum==0)return 0;
    long long ans=x/T*osum,shd=x-x/T*T;
    int t1=1,t2=osum;
    while(t1<t2)
    {
        int mid=(t1+t2)/2;
        if(od[mid]<=shd)t1=mid+1;
            else t2=mid;
    }
    ans+=t1;
    if(od[t1]>shd)ans--;
    return ans;
}
long long getans2(long long x)
{
    long long ans=0;
    if(x==0)return ans;
    if(c==a)ans+=1;
    if(x<od[c]||od[c]==0)return ans;
    if(od[c]<bg)return ans+1;
    x-=bg-1;
    ans+=x/(ed-bg+1);
    x%=(ed-bg+1);
    ans+=x>=od[c]-bg+1?1:0;
    return ans;
}
int main()
{
    memset(zr.c,0,sizeof(zr.c));
    zr.c[0][0]=zr.c[1][1]=zr.c[2][2]=1;
    scanf("%d",&tes);
    while(tes--)
    {
        scanf("%d%d%d%d%d%d%d%d",&a,&b,&x,&y,&z,&p,&c,&q);
        if(y==0)
        {
            memset(od,0,sizeof(od));
            int fa=b;
            rep(i,2,p+2)
            {
                if(od[fa]>0)
                {
                    bg=od[fa];
                    ed=i-1;
                    break;
                }
                od[fa]=i;
                fa=(fa*x+z)%p;
            }
            rep(i,1,q)
            {
                scanf("%lld%lld",&l,&r);
                printf("%lld\n",getans2(r)-getans2(l-1));
            }
            continue;
        }
        memset(trans.c,0,sizeof(trans.c));
        memset(fir.c,0,sizeof(fir.c));
        memset(rev.c,0,sizeof(rev.c));
        trans.c[0][1]=y;
        trans.c[1][0]=trans.c[2][2]=fir.c[2]=rev.c[0][1]=rev.c[2][2]=1;
        trans.c[1][1]=x;
        trans.c[2][1]=z;
        fir.c[0]=a;
        fir.c[1]=b;
        rev.c[0][0]=(p-x)*ksm(y,p-2,p)%p;
        rev.c[1][0]=ksm(y,p-2,p);
        rev.c[2][0]=(p-z)*ksm(y,p-2,p)%p;
        memset(cell,0,sizeof(cell));
        cnum=0;
        now=zr;
        rep(i,0,p-1)
        {
            ins(now,i);
            now=now*rev;
        }
        proc=trans;
        rep(i,1,p-1)
            proc=proc*trans;
        now=zr;
        rep(i,0,p)
        {
            if(i==0)tf=true;else tf=false;
            int t=find(now);
            if(t!=-1)
            {
                T=i*p+t;
                break;
            }
            now=now*proc;
        }
        memset(cell2,0,sizeof(cell2));
        cnum2=0;
        now2=fir;
        int block=floor(sqrt((long long)T*p)/2.0);
        rep(i,0,block-1)
        {
            ins(now2,i);
            now2=now2*trans;
        }
        proc=rev;
        rep(i,1,block-1)
            proc=proc*rev;
        rep(i,0,p-1)
        {
            memset(nows[i].c,0,sizeof(nows[i].c));
            nows[i].c[0]=c;
            nows[i].c[1]=i;
            nows[i].c[2]=1;
            rem[i]=i;
            tim[i]=floor(2e9);
        }
        rsum=p;
        tf=false;
        rep(i,0,T/block)
        {
            if(rsum==0)break;
            int j=0;
            while(j<rsum)
            {
                int t=find(nows[rem[j]]);
                nows[rem[j]]=nows[rem[j]]*proc;
                if(t!=-1)
                {
                    tim[rem[j]]=i*block+t;
                    rsum--;
                    rem[j]=rem[rsum];
                }
                else j++;
            }
        }
        osum=0;
        rep(i,0,p-1)
            if(tim[i]!=floor(2e9))od[++osum]=tim[i];
        sort(od+1,od+1+osum);
        rep(i,1,q)
        {
            scanf("%lld%lld",&l,&r);
            printf("%lld\n",getans(r-1)-getans(l-2));
        }
    }
    return 0;
}