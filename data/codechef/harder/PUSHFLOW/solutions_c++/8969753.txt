#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <map>
using namespace std;

const int maxN = 400005;
const int oo = 2000000001;

struct Tedge{
	int v, c, next;
}edge[maxN];
int dad[maxN], edges;

struct Te{
	int u, v, c;
}e[maxN];

void insertedge(int u, int v, int c){
	edges++;
	edge[edges].v=v;
	edge[edges].c=c;
	edge[edges].next = dad[u];
	dad[u] = edges;
	e[edges].u = u;
	e[edges].v = v;
	e[edges].c = c;
}

int n, m;

int getnum(){
    int ret = 0;
    char ch = getchar();
    for (;!('0' <= ch && ch <= '9'); ch = getchar());
    for (;'0' <= ch && ch <= '9'; ch = getchar())
        ret = (ret<<3) + (ret<<1) + ch - 48;
    return ret;
}

void Readln(){
	n = getnum();
	m = getnum();
	for (int i=1; i<=m; i++){
		int u, v, c;
		u = getnum();
		v = getnum();
		c = getnum();
		insertedge(u, v, c);
		insertedge(v, u, c);
	}
}

int Loops;
struct Data_Loop{
	int L, R;
}Loop[maxN];

int Lpnds;
struct Loop_node{
	int v, p;
}Lpnd[maxN];

int Last[maxN], sta[maxN];
bool vis[maxN], in[maxN];
int path[maxN];

void dfs(){
	Loops = Lpnds = 0;
	int tot = 1;
	sta[1] = 1;
	for (int i=1; i<=n; i++) Last[i] = dad[i];
	in[1] = true;
	while (tot > 0){
		int now = sta[tot];
		if (Last[now] == 0){
			in[now] = false;
			vis[now] = true;
			tot--;
			continue;
		}
		int nowE = Last[now];
		int nex = edge[Last[now]].v;
		Last[now] = edge[Last[now]].next;
		if (vis[nex] || nex == sta[tot-1]) continue;
		if (in[nex]){
			Loops++;
			Lpnds++;
			Loop[Loops].L = Lpnds;
			Lpnd[Lpnds].v = nex;
			Lpnd[Lpnds].p = ((nowE-1)^1)+1;
			for (int i=tot; sta[i] != nex; i--){
				Lpnd[++Lpnds].v = sta[i];
				Lpnd[Lpnds].p = ((path[i]-1)^1)+1;
			}
			Loop[Loops].R = Lpnds;
			Lpnds++;
			Lpnd[Lpnds].v = nex;
			continue;
		}
		sta[++tot] = nex;
		path[tot] = nowE;
		in[nex] = true;
	}
}

int lev[maxN], que[maxN];
bool flag[maxN];

void bfs(){
	int head = 1, tail = 1;
	que[1] = 1;
	lev[1] = 1;
	while (head <= tail){
		int now = que[head];
		head++;
		for (int i=dad[now]; i!=0; i=edge[i].next)
		if (lev[edge[i].v] == 0 && !flag[i]){
			lev[edge[i].v] = lev[now] + 1;
			tail++;
			que[tail] = edge[i].v;
		}
	}
}

struct Tseg{
	int minI, minV;
}tree[2*maxN], nul;
int M;
int cut[maxN];
int cir[maxN], Segid[maxN], id[maxN];

struct Tnode{
	Tnode *f, *son[2];
	long long val, minV, add;
	bool rev;
}node[200005];

void init(){
	nul.minI = 0; nul.minV = oo;
	dfs();
	for (int i=1; i<=Loops; i++){
		int L = Loop[i].L, R = Loop[i].R;
		int minI = 0, minV = oo;
		for (int j=L; j<=R; j++)
		if (edge[Lpnd[j].p].c < minV){
			minV = edge[Lpnd[j].p].c;
			minI = Lpnd[j].p;
		}
		flag[minI] = true;
		flag[((minI-1)^1)+1] = true;
		cut[i] = minI;
		for (int j=L; j<=R; j++){
			cir[Lpnd[j].p] = cir[((Lpnd[j].p-1)^1)+1] = i;
			Segid[Lpnd[j].p] = Segid[((Lpnd[j].p-1)^1)+1] = j;
		}
	}
	bfs();
	for (int i=1; i<=n; i++){
		(node + i) -> val = (node + i) -> minV = oo;
	}
	int nodes = n;
	for (int j=1; j<=n; j++){
		int now = que[j];
		for (int i=dad[now]; i!=0; i=edge[i].next)
		if (lev[edge[i].v] == lev[now] + 1 && !flag[i]){
			nodes++;
			(node + nodes) -> val = edge[i].c;
			(node + nodes) -> val += edge[cut[cir[i ]]].c;
			(node + nodes) -> minV = (node + nodes) -> val;
			(node + nodes) -> f = (node + now);
			(node + edge[i].v) -> f = (node + nodes);
			id[i] = nodes;
			id[((i-1)^1)+1] = nodes;
		}
	}
	if (Lpnds > 0){
		for (M=1; M<Lpnds+2; M<<=1);
		for (int i=M; i<M+M; i++) tree[i].minV = oo;
		for (int i=1; i<=Lpnds; i++){
			tree[i+M].minI = Lpnd[i].p;
			if (Lpnd[i].p == 0 || flag[Lpnd[i].p])
				tree[i+M].minV = oo;
					else tree[i+M].minV = edge[Lpnd[i].p].c;
		}
		for (int i=M-1; i>=1; i--)
		if (tree[i<<1].minV < tree[i<<1|1].minV)
			tree[i] = tree[i<<1];
				else tree[i] = tree[i<<1|1];			
	}
}

void inserttree(int P, int val){
	for (tree[P+=M].minV = val, P>>=1;P;P>>=1)
		if (tree[P<<1].minV < tree[P<<1|1].minV)
			tree[P] = tree[P<<1];
				else tree[P] = tree[P<<1|1];
}

Tseg asktree(int L, int R){
	Tseg ret = nul;
	for (L+=M-1, R+=M+1; L^R^1; L>>=1, R>>=1){
		if (L&1^1) if (tree[L+1].minV < ret.minV) ret = tree[L+1];
		if (R&1) if (tree[R-1].minV < ret.minV) ret = tree[R-1];
	}
	return ret;
}

void changenode(Tnode *u, int val){
	u -> add += val;
	u -> val += val;
	u -> minV += val;
}

inline void down(Tnode *u){
	if (u -> add != 0){
		if (u -> son[0]){
			u -> son[0] -> add += u -> add;
			u -> son[0] -> val += u -> add;
			u -> son[0] -> minV += u -> add;
		}
		if (u -> son[1]){
			u -> son[1] -> add += u -> add;
			u -> son[1] -> val += u -> add;
			u -> son[1] -> minV += u -> add;
		}
		u -> add = 0;
	}
	if (u -> rev){
		u -> rev ^= 1;
		swap(u -> son[0], u -> son[1]);
		if (u -> son[0]) u -> son[0] -> rev ^= 1;
		if (u -> son[1]) u -> son[1] -> rev ^= 1;
	}
}

inline void updata(Tnode *u){
	u -> minV = u -> val;
	if (u -> son[0] && u -> son[0] -> minV < u -> minV)
		u -> minV = u -> son[0] -> minV;
	if (u -> son[1] && u -> son[1] -> minV < u -> minV)
		u -> minV = u -> son[1] -> minV;
}

void rot(Tnode *u, int t){
	Tnode *v = u -> f;
	Tnode *w = v -> f;
	if (w){
		if (w -> son[0] == v) w -> son[0] = u;
		if (w -> son[1] == v) w -> son[1] = u;
	}
	u -> f = w;
	if (u -> son[t]) u -> son[t] -> f = v;
	v -> son[t^1] = u -> son[t];
	u -> son[t] = v;
	v -> f = u;
	updata(v);
}

void splay(Tnode *u){
	down(u);
	while (u -> f && (u -> f -> son[0] == u || u -> f -> son[1] == u)){
		Tnode *v = u -> f;
		Tnode *w = v -> f;
		if (w) down(w);
		if (v) down(v);
		down(u);
		if (!w || w -> son[0] != v && w -> son[1] != v){
			rot(u, v -> son[0] == u);
			break;
		}
		bool p = (v -> son[0] == u), q = (w -> son[0] == v);
		if (p^q) {rot(u, p); rot(u, q);}
			else {rot(v, q); rot(u, p);}
	}
	updata(u);
}

void expose(Tnode *u){
	for (Tnode *v = 0; u; v = u, u = v -> f){
		splay(u);
		u -> son[1] = v;
		updata(u);
	}
}

void changeroot(Tnode *u){
	expose(u);
	splay(u);
	u -> rev ^= 1;
}

void Replace(int x, int y, int valx, int valy, Tnode *now){
	int nowL = cir[x];
	Tnode *xu = (node + e[x].u);
	Tnode *xv = (node + e[x].v);
	
	changeroot(xu);
	expose(now);
	expose(xu);
	splay(xv);
	xv -> f = 0;
	
	Tnode *yu = (node + e[y].u);
	Tnode *yv = (node + e[y].v);
	
	changeroot(yv);
	now -> val = e[y].c + valy;
	now -> minV = now -> val;
	now -> add = 0;
	now -> son[0] = now -> son[1] = 0;
	now -> rev = 0;
	now -> f = yu;
	yv -> f = now;
	
	changeroot(xu);
	expose(xv);
	splay(xv);
	changenode(xv, valx - valy);
					
	cut[nowL] = x;
	id[y] = id[((y-1)^1)+1] = now - node;
	flag[x] = flag[((x-1)^1)+1] = true;
	flag[y] = flag[((y-1)^1)+1] = false;
	
	inserttree(Segid[x], oo);
	inserttree(Segid[y], e[y].c);
}

int q;

void Solve(){
	q = getnum();
	for (int i=1; i<=q; i++){
		int t;
		t = getnum();
		if (t == 0){
			int tu, tv;
			tu = getnum();
			tv = getnum();
			Tnode *u = node + tu, *v = node + tv;
			changeroot(u);
			expose(v);
			splay(v);
			printf( "%lld\n", v -> minV );
		}else{
			int x, c;
			x = getnum();
			c = getnum();
			x += x;
			int nowL = cir[x];
			if (!flag[x]){
				Tnode *now = (node + id[x]);
				if (cir[x] == 0 || c >= e[cut[nowL]].c){
					splay(now);
					now -> val = c + e[cut[nowL]].c;
					updata(now);
					if (cir[x]) inserttree(Segid[x], c);
				}else{
					e[x].c = c; e[x-1].c = c;
					Replace(x, cut[nowL], c, e[cut[nowL]].c, now);
				}
			}else{
				Tseg ret = asktree(Loop[nowL].L, Loop[nowL].R);
				if (ret.minV >= c){
					Tnode *u = (node + e[x].u);
					Tnode *v = (node + e[x].v);
					changeroot(u);
					expose(v);
					splay(v);
					changenode(v, c - e[x].c);
				}else{
					int tmp = e[x].c;
					e[x].c = c; e[x-1].c = c;
					Replace(ret.minI, x, ret.minV, tmp, node + id[ret.minI]);
				}
			}
			e[x].c = c; e[x-1].c = c;
		}
	}
}

int main(){
	Readln();
	init();
	Solve();
	return 0;
}