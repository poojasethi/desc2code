#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
using namespace std;
#define MAXN 101000
#define MAXT MAXA*40
#define MAXV MAXA*2
#define MAXE MAXA*4
#define MAXA MAXN*2
#define INF 0x7fffffff
#define smid ((l+r)>>1)
int n,m;
namespace task_st//线段树,区间最小值,维护环
{
		int tmp[MAXA];
		struct sgt_node
		{
				int lc,rc;
				int mnv;
		}sgt[MAXT];
		int topt;
		void Build_sgt(int &now,int l,int r)
		{
				now=++topt;
				if (l==r)
				{
						sgt[now].mnv=tmp[l];
						return ;
				}
				Build_sgt(sgt[now].lc,l,smid);
				Build_sgt(sgt[now].rc,smid+1,r);
				sgt[now].mnv=min(sgt[sgt[now].lc].mnv,sgt[sgt[now].rc].mnv);
		}
		void Modify_sgt(int &now,int l,int r,int pos,int v)
		{
				if (l==r)
				{
						sgt[now].mnv=v;
						return ;
				}
				if (pos<=smid)
						Modify_sgt(sgt[now].lc,l,smid,pos,v);
				else
						Modify_sgt(sgt[now].rc,smid+1,r,pos,v);
				sgt[now].mnv=min(sgt[sgt[now].lc].mnv,sgt[sgt[now].rc].mnv);
		}
		int Query_sgt(int &now,int l,int r,int x,int y)
		{
				if (x>y)
				{
						assert(x-1==y);
						return INF;
				}
				if (l==x && r==y)
						return sgt[now].mnv;
				if (y<=smid)
						return Query_sgt(sgt[now].lc,l,smid,x,y);
				else if (smid<x)
						return Query_sgt(sgt[now].rc,smid+1,r,x,y);
				else
						return min(Query_sgt(sgt[now].lc,l,smid,x,smid),Query_sgt(sgt[now].rc,smid+1,r,smid+1,y));

		}
}
struct Edge
{
		int np,val;
		Edge *next;
}E[MAXE],*V[MAXV];
int tope=-1;
void addedge(int x,int y,int z=0)
{
		//cout<<"Add "<<x<<" "<<y<<" "<<z<<endl;
		E[++tope].np=y;
		E[tope].val=z;
		E[tope].next=V[x];
		V[x]=&E[tope];
}
//tarjan
int cpdis[MAXN];
int cptr[MAXN];
int circ[MAXN];
int cpos[MAXN];
bool incirc[MAXN];
int ctop[MAXN];
int csiz[MAXN];
int croot[MAXN];
namespace task_tj//缩点
{
		int low[MAXN],dfn[MAXN],dfstime;
		int pnt[MAXN];
		int status[MAXN];
		int depth[MAXN];
		void tarjan(int now)
		{
				low[now]=dfn[now]=++dfstime;
				status[now]=1;
				Edge *ne;
				for (ne=V[now];ne;ne=ne->next)
				{
						if (ne->np==pnt[now])continue;
						if (status[ne->np]==1)
						{
								cptr[ne->np]=now;
								low[now]=min(low[now],dfn[ne->np]);
						}else if (!status[ne->np])
						{
								pnt[ne->np]=now;
								depth[ne->np]=depth[now]+1;
								tarjan(ne->np);
								low[now]=min(low[now],low[ne->np]);
						}
				}
				if (low[now]==dfn[now] && !cptr[now])
						cptr[now]=now;
				status[now]=2;
		}
}
//treesplit
int son[MAXV],top[MAXV],pnt[MAXV];
int q[MAXV];
int depth[MAXV];
int siz[MAXV];
int apos[MAXV],pos[MAXV],dfstime;
int spos[MAXV],tpos[MAXV];
int troot[MAXV];
void bfs(int now)
{
		Edge *ne;
		q[0]=now;
		int head=-1,tail=0;
		while (head<tail)
		{
				now=q[++head];
				for (ne=V[now];ne;ne=ne->next)
				{
						//if (ne->np==pnt[now])continue;
						pnt[ne->np]=now;
						depth[ne->np]=depth[now]+1;
						q[++tail]=ne->np;
				}
		}
		for (int i=tail;i>=0;i--)
		{
				now=q[i];
				int mxsiz=0;
				siz[now]=1;
				for (ne=V[now];ne;ne=ne->next)
				{
						//if (ne->np==pnt[now])continue;
						siz[now]+=siz[ne->np];
						if (siz[ne->np]>mxsiz)
								mxsiz=siz[ne->np],son[now]=ne->np;
				}
		}
}
int stack[MAXV],tops=-1;
void dfs(int now)
{
		Edge *ne;
		stack[++tops]=now;
		top[now]=now;
		int tot=0;
		while (~tops)
		{
				tot++;
				now=stack[tops--];
				tpos[now]=spos[now]=pos[now]=++dfstime;
				apos[dfstime]=now;
				for (ne=V[now];ne;ne=ne->next)
				{
						if (ne->np==son[now])continue;
						top[ne->np]=ne->np;
						stack[++tops]=ne->np;
				}
				if (son[now])
				{
						stack[++tops]=son[now];
						top[son[now]]=top[now];
				}
		}
		for (int i=tot-1;i>=0;i--)
		{
				now=q[i];
				Edge *ne;
				for (ne=V[now];ne;ne=ne->next)
						tpos[now]=max(tpos[now],tpos[ne->np]);
		}
}

struct edge
{
		int x,y,z;
		edge(){}
		edge(int x,int y,int z):x(x),y(y),z(z){};
}e[MAXE];
int rpdis[MAXA];
int main()
{
		scanf("%d%d",&n,&m);
		int x,y,z;
		//read graph
		for (int i=1;i<=m;i++)
		{
				scanf("%d%d%d",&x,&y,&z);
				e[i]=edge(x,y,z);
				addedge(x,y,z);
				addedge(y,x,z);
		}
		//find circle
		int totc=0;
		task_tj::tarjan(1);
		for (int i=1;i<=m;i++)
		{
				x=e[i].x,y=e[i].y,z=e[i].z;
				if (cptr[y]==x)swap(x,y);
				if (cptr[x]==y)
				{
						cpdis[y]=z;
						continue;
				}
				if (task_tj::pnt[y]==x)swap(x,y);
				assert(task_tj::pnt[x]==y);
				if (cptr[x])
						rpdis[x]=z;
				else
						cpdis[y]=z;
		}
		for (int i=1;i<=n;i++)
				if (cptr[i])
				{
						int x=cptr[i];
						int y=0;
						int z;
						totc++;
						rpdis[totc+n]=rpdis[i];
						rpdis[i]=0;
						while (x!=i)
						{
								cpos[x]=++y;
								task_st::tmp[y]=cpdis[x];
								circ[x]=totc;
								incirc[x]=true;
								x=task_tj::pnt[x];
						};
						cpos[x]=++y;
						task_st::tmp[y]=cpdis[x];
						circ[x]=totc;
						incirc[x]=true;
						ctop[totc]=x;
						csiz[totc]=y;
						task_st::Build_sgt(croot[totc],1,y);
				}
		memset(V,0,sizeof(V));tope=-1;
		for (int i=1;i<=n;i++)
				addedge(n+circ[i],i);
		int trt;
		for (int i=1;i<=totc;i++)
				if (task_tj::pnt[ctop[i]])
						addedge(task_tj::pnt[ctop[i]],n+i);
				else
						trt=i+n;
		bfs(trt);
		dfs(trt);
		int l=n+totc;
		memset(task_st::tmp,-1,sizeof(task_st::tmp));
		for (int i=1;i<=l;i++)
		{
				if (top[i]==i)continue;
				if (i<=n)
				{
						int c=circ[i];
						int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[i]);
						int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[i]+1,csiz[c]);
						task_st::tmp[pos[i]]=(t1==INF || t2==INF)?INF:t1+t2;
						if (task_st::tmp[pos[i]]<0)
								assert(task_st::tmp[pos[i]]>=0);
				}else
				{
						task_st::tmp[pos[i]]=rpdis[i];
				}
		}
		for (int i=1;i<=l;i++)
		{
				if (top[i]==i)
						task_st::Build_sgt(troot[i],spos[i],tpos[i]);
		}
		scanf("%d",&m);
		int opt;
		for (int i=1;i<=m;i++)
		{
				scanf("%d",&opt);
				if (opt==0)
				{
						scanf("%d%d",&x,&y);
						int sx=x,sy=y;
						int a;
						while (true)
						{
								if (top[x]==top[y])
								{
										a=(depth[x]<depth[y])?x:y;
										break;
								}
								if (depth[top[x]]<depth[top[y]])swap(x,y);
								x=pnt[top[x]];
						}
						if (a<=n)a=pnt[a];
						int ans=INF;
						x=sx;y=sy;
						for (int p=0;p<2;p++)
						{
								while (true)
								{
										if (top[a]==top[x])
										{
												if (a==x || a==pnt[x])break;
												ans=min(ans,task_st::Query_sgt(troot[top[x]],spos[top[x]],tpos[top[x]],pos[a]+2,pos[x]));
												x=apos[pos[a]+1];
												break;
										}
										ans=min(ans,task_st::Query_sgt(troot[top[x]],spos[top[x]],tpos[top[x]],spos[top[x]]+1,pos[x]));
										x=top[x];
										if (pnt[x]==a)break;
										if (x>n)
												ans=min(ans,rpdis[x]);
										else
										{
												int c=circ[x];
												int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[x]);
												int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[x]+1,csiz[c]);
												ans=min(ans,(t1==INF || t2==INF)?INF:t1+t2);
										}
										x=pnt[x];
								}
								swap(x,y);
						}
						if (cpos[x]>cpos[y])swap(x,y);
						if (cpos[x]<cpos[y])
						{
								assert(circ[x]==circ[y]);
								int c=circ[x];
								int t1=task_st::Query_sgt(croot[c],1,csiz[c],cpos[x]+1,cpos[y]);
								int t2=min(task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[x]),
												task_st::Query_sgt(croot[c],1,csiz[c],cpos[y]+1,csiz[c]));
								ans=min(ans,(t1==INF || t2==INF)?INF:t1+t2);
						}
						printf("%d\n",ans);
				}else
				{
						int d,v;
						scanf("%d%d",&d,&v);
						x=e[d].x;y=e[d].y;
						if (task_tj::depth[x]>task_tj::depth[y])swap(x,y);
						if (cptr[x]==y)
						{
								int c=circ[x];
								task_st::Modify_sgt(croot[c],1,csiz[c],1,v);
								int t;
								if ((t=son[circ[x]+n]))
								{
										if (t==ctop[circ[t]])
										{
												task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],INF);
										}else
										{
												int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[t]);
												int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[t]+1,csiz[c]);
												task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],(t1==INF || t2==INF)?INF:t1+t2);
										}
								}
						}else
						{
								assert(task_tj::pnt[y]==x);
								if (cptr[y])
								{
										int t;
										rpdis[t=circ[y]+n]=v;
										if (top[t]!=t)
										{
												task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],v);
										}
								}else
								{
										int c=circ[x];
										task_st::Modify_sgt(croot[c],1,csiz[c],cpos[x],v);
										int t;
										if ((t=son[circ[x]+n]))
										{
												if (t==ctop[circ[t]])
												{
														task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],INF);
												}else
												{
														int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[t]);
														int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[t]+1,csiz[c]);
														task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],(t1==INF || t2==INF)?INF:t1+t2);
												}
										}
								}
						}
				}
		}
		return 0;
}