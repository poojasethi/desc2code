#include<cstdio>
#include<vector>
#include<algorithm>

#define mp       make_pair
#define pb       push_back
#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef	vector<int>   vi;
typedef	pair<int,int> pii;

const int INF=(1<<31)-1;

int n,x[100000],y[100000];
pii school[100000];
vi polyline[400000];

void makeSegtree(int u,int l,int r){
	int yy=INF;
	for(int i=l;i<r;i++){
		if(y[i]<yy){ // strictly decreasing
			yy=y[i];
			polyline[u].pb(y[i]);
		}
	}

	if(l+1<r){
		int m=(l+r)/2;
		makeSegtree(2*u+0,l,m);
		makeSegtree(2*u+1,m,r);
	}
}

int query(int u,int l,int r,int x_min,int x_max,int &y_max){
	if(x_min<=x[l] && x[r-1]<=x_max){
		if(y_max<polyline[u].back()) return 0;

		// y_max 以下で最小の要素の番号
		int lo=0,hi=polyline[u].size()-1;
		while(lo<hi){
			int mi=(lo+hi)/2;
			if(polyline[u][mi]<=y_max) hi=mi;
			else                       lo=mi+1;
		}
		y_max=polyline[u].back()-1;
		return polyline[u].size()-hi;
	}

	if(l+1<r){
		int ans=0,m=(l+r)/2;
		if(x_min<=x[m-1]) ans+=query(2*u+0,l,m,x_min,x_max,y_max);
		if(x[ m ]<=x_max) ans+=query(2*u+1,m,r,x_min,x_max,y_max);
		return ans;
	}
}

int main(){
	scanf("%d",&n);
	rep(i,n) scanf("%d%d",&school[i].second,&school[i].first);
	sort(school,school+n);
	rep(i,n){
		x[i]=school[i].first;
		y[i]=school[i].second;
	}

	makeSegtree(1,0,n);

	int nq; scanf("%d",&nq);
	while(nq--){
		int d_max,f_min,f_max; scanf("%d%d%d",&d_max,&f_min,&f_max);
		printf("%d\n",query(1,0,n,f_min,f_max,d_max));
	}

	return 0;
}
