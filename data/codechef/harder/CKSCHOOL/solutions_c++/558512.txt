#include<map>
#include<set>
#include<list>
#include<cmath>
#include<queue>
#include<stack>
#include<cstdio>
#include<string>
#include<vector>
#include<complex>
#include<cstdlib>
#include<cstring>
#include<numeric>
#include<sstream>
#include<iostream>
#include<algorithm>
#include<functional>

#define mp       make_pair
#define pb       push_back
#define all(x)   (x).begin(),(x).end()
#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef	long long     ll;
typedef	vector<bool>  vb;
typedef	vector<int>   vi;
typedef	vector<vb>    vvb;
typedef	vector<vi>    vvi;
typedef	pair<int,int> pii;

const int INF=(1<<31)-1;

int n,x[100000],y[100000];
pii school[100000];
vi polyline[400000];

void makeSegtree(int u,int l,int r){
// printf("u=%d, l=%d, r=%d\n",u,l,r);
	int yy=INF;
	for(int i=l;i<r;i++){
		if(y[i]<yy){ // strictly decreasing
			yy=y[i];
			polyline[u].pb(y[i]);
		}
	}
// rep(j,polyline[u].size())printf("%d ",polyline[u][j]); puts("");

	if(l+1<r){
		int m=(l+r)/2;
		makeSegtree(2*u+0,l,m);
		makeSegtree(2*u+1,m,r);
	}
}

int query(int u,int l,int r,int x_min,int x_max,int &y_max){
	if(x[r-1]<x_min || x_max<x[l]) return 0;
// printf("%d [%d,%d] | [%d,%d] %d\n",u,x[l],x[r-1],x_min,x_max,y_max);
	if(x_min<=x[l] && x[r-1]<=x_max){
		// y_max 以下で最小の要素の番号
		if(y_max<polyline[u].back()) return 0;

		int lo=0,hi=polyline[u].size()-1;
		while(lo<hi){
			int mi=(lo+hi)/2;
			if(polyline[u][mi]<=y_max) hi=mi;
			else                       lo=mi+1;
		}
// printf("hi=%d, polyline=%d\n",hi,polyline[u][hi]);
		y_max=polyline[u].back()-1;
// printf("res %d\n",polyline[u].size()-hi);
		return polyline[u].size()-hi;
	}

	if(l+1<r){
		int m=(l+r)/2;
		// return query(u,l,m,x_min,x_max,y_max)+query(u,m,r,x_min,x_max,y_max);

	int res=query(2*u,l,m,x_min,x_max,y_max)+query(2*u+1,m,r,x_min,x_max,y_max);
	// printf("u=%d, res=%d\n",u,res);
	return res;
	}
}

int main(){
	scanf("%d",&n);
	rep(i,n) scanf("%d%d",&school[i].second,&school[i].first);
	sort(school,school+n);
	rep(i,n){
		x[i]=school[i].first;
		y[i]=school[i].second;
	}

	makeSegtree(1,0,n);

	int nq; scanf("%d",&nq);
	while(nq--){
		int d_max,f_min,f_max; scanf("%d%d%d",&d_max,&f_min,&f_max);
		printf("%d\n",query(1,0,n,f_min,f_max,d_max));
	}

	return 0;
}
