#include<cstdio>
#include<cassert>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
const db pi=acos(-1);
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
const int inf=1061109567;
//const ll inf=1000000000000000000ll;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
#define x1 x192837465
#define x2 x123456789
#define y1 y192837465
#define y2 y123456789
int up=17;
ll f[18][18];
int n;
ll c[18][18];
vector<pair<int,int> >g[20];


int dfn[20],low[20],ind;
int stk[20],ins[20];int top=0;int ccnt;int art=0;

#define mp make_pair
void tar(int u,int pr){
	dfn[u]=low[u]=++ind;
	ins[stk[++top]=u]=1;
	int bo=0;
	for (int i=0;i<g[u].size();i++)if(g[u][i].first!=pr){
		int v=g[u][i].second;
		if(!dfn[v]){
			tar(v,g[u][i].first);
			low[u]=min(low[u],low[v]);
			if(pr==-1)bo++;
			else if(low[v]>=dfn[u])bo=1;
		}else if(ins[v])low[u]=min(low[u],dfn[v]);
	}
	if(pr==-1){
		if(bo>=2)art=1;
	}else{
		if(bo)art=1;
	}
	if(low[u]==dfn[u]){
		while(stk[top]!=u)ins[stk[top--]]=0;
		ins[stk[top--]]=0;
	}
}
int check(int dep){
	if(dep<n-1)return 0;
	ind=0;ccnt=0;art=0;
	for (int i=1;i<=n;i++)dfn[i]=low[i]=0;
	for (int i=1;i<=n;i++)if(!dfn[i])tar(i,-1),ccnt++;
	return ccnt==1 && !art;
}
void dfs(int dep,int ok,int si,int sj){
	if(!ok)ok|=check(dep);
	/*if(ok){
		ll p=1;
		int e=n*(n-1)/2;
		for (int i=dep;i+n<=up;i++){
			f[n][i]+=p;
			p*=e;
		}
		return;
	}*/
	f[n][dep]+=ok;
	if(n+dep>=up)return;
	if(!ok && ccnt-1>(up-n-dep))return;
	for (int i=si;i<=n;i++)
		for (int j=(i==si?sj:i+1);j<=n;j++){
			g[i].push_back(mp(dep,j));
			g[j].push_back(mp(dep,i));
			dfs(dep+1,ok,i,j+1);
			g[i].pop_back();
			g[j].pop_back();
		}
}

ll po(ll x,int y){
	ll a=1;
	for (int i=1;i<=y;i++)a*=x;
	return a;
}
void calc(){
	dfs(0,0,1,2);
	//for (int i=1;i<=up;i++)f[n][i]*=c[i+n][n];
}
ll gpo(int n,int m){
	ll an=0;
	for (int i=m;i>=1;i--){
		if((m-i)%2==0)an+=c[m][i]*po(i,n);
		else an-=c[m][i]*po(i,n);
	}
	return an;
}
ll gg[20][20];
ll h[20];
ll p[20][20];
ll fac[20];


void cc(int headcnt,int vcnt,int bcnt,ll cur,int Sv){
	if(vcnt==n)p[vcnt][bcnt]+=cur;
	else{
		for (int sv=Sv;sv<=headcnt;sv++)
			for (int ssz=3;ssz+vcnt-1<=n;ssz++)
				for (int sb=1;sb<=ssz;sb++){
					if(p[ssz][sb]==0)continue;
					cc(headcnt,vcnt+ssz-1,bcnt+sb,cur*c[vcnt+ssz-1][ssz-1]*p[ssz][sb],sv+1);
				}
	}
}
ll  an[20];


ll ok[20]={0,0
,0
,1
,6
,25
,495
,5586
,93268
,2052513
,43258365ll
,1167393700ll
,34010847486ll
,1078391538159ll
,38595111963499ll
,1476893151785520ll
,61479081902937000ll
,2761923686066698561ll};
int main()
{
	int tes;gn(tes);
	while(tes--){
		int x;gn(x);
		cout<<ok[x]<<endl;
	}
	return 0;
	fac[0]=1;
	for (int i=1;i<=17;i++)fac[i]=fac[i-1]*i;
	c[0][0]=1;
	for (int i=1;i<=17;i++){
		c[i][0]=1;
		for (int j=1;j<=i;j++)c[i][j]=c[i-1][j-1]+c[i-1][j];
	}
	for (int i=2;i<=8;i++){
		n=i;
		calc();
	}

	for (int i=2;i<=8;i++){
		for (int j=1;j+i<=up;j++){
			ll su=0;
			for (int k=j;k>=1;k--){
				su+=gpo(j,k)*f[i][k];
			}
			gg[i][j]=su*c[i+j][i];
		}
	}
	/*for (int i=1;i<=8;i++){
		for (int j=1;j+i<=up;j++)printf("%I64d ",gg[i][j]);
		printf("\n");
	}*/
	for (int i=1;i<=8;i++){
		for (int j=1;j+i<=up;j++)h[i+j]+=gg[i][j];
	}
	h[3]=1;
	//for (int i=1;i<=up;i++)printf("%I64d ",h[i]);
	//
	//for (int i=3;i<=up;i++)p[i][1]=h[i];
	for (n=3;n<=up;n++){
		for (int i=3;i<=n;i++)
			cc(i,i,1,h[i],1);
		for (int i=1;i<=up;i++)
			an[n]+=(p[n][i]/=i);
	}
	for (int i=1;i<=up;i++)printf(",%I64d\n",an[i]);

	return 0;
}
