#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <stack>
 
using namespace std;
 
template <typename T> T sqr(T x) { return x * x; }
template <typename T> T abs(T x) { return x < 0? -x : x; }
 
const int MAXN = 10007;
const int MAXK = 80;
 
#define A first
#define S second
 
#define left dsalkhfas
#define right sdjkfhkas
 
typedef map < int, stack <int> > mmap;
 
int ans[MAXN];
mmap M;
int n, m, k;
int L, H, N;
int left, right;
 
vector < pair <int, int> > a, b;
map < int, int > f[MAXK][MAXK], g[MAXK][MAXK];
 
void solve(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK])
{
		for (int i = 0; i <= (int)a.size(); i++)
			for (int j = 0; j <= N; j++)
				f[i][j].clear();
				
		f[0][0][0] = 0;
		for (int i = 0; i < (int)a.size(); i++)
			for (int j = 0; j <= N; j++)
				for (int k = 0; k <= N - j && k * H <= a[i].S; k++)
					if ((a[i].S - k * H) % L == 0)
						for (map < int, int > :: iterator iter = f[i][j].begin(); iter != f[i][j].end(); iter++)
							f[i + 1][j + k][(iter->first + (k + (a[i].S - k * H) / L) * (long long)a[i].A) % m] = k;
}
 
 
void recovery(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK], int x, int y, int z)
{
	while (x)
	{
		int c = f[x][y][z];
		x--;
		
		stack <int> &st = M[a[x].A]; 
		for (int i = 0; i < c; i++)
		{
			for (int j = 0; j < H; j++)
			{
				ans[left + k * j] = st.top();
				st.pop();
			}
			left++;
		}
		
		for (int i = 0; i < (a[x].S - c * H) / L; i++)
		{
			for (int j = 0; j < L; j++)
			{
				ans[right + k * j] = st.top();
				st.pop();
			}
			right--;
		}
		
		z = ((z - (c + (a[x].S - c * H) / L) * (long long)a[x].A) % m + m) % m;
		y -= c;
	}	
}
 
int main()
{
	#ifndef ONLINE_JUDGE
		freopen("in", "r", stdin);
		freopen("out", "w", stdout);
	#endif
	int t;
	scanf("%d", &t);
	while (t--)
	{
		M.clear();
		scanf("%d %d %d", &n, &m, &k);
		for (int i = 0; i < n; i++)
		{
			int x;
			scanf("%d", &x);
			M[x % m].push(x);
		}
		if ((int)M.size() > k)
		{
			puts("-1");
			continue;
		}
		a.clear();
		b.clear();
		for (mmap :: iterator iter = M.begin(); iter != M.end(); ++iter)
		{
			if (a.size() == b.size())
				a.push_back(make_pair(iter->first, iter->second.size()));
			else
				b.push_back(make_pair(iter->first, iter->second.size()));
		}
		
		H = n / k + 1;
		L = H - 1;
		N = n % k;
		
		solve(a, f);
		solve(b, g);
		
		bool flg = false;
		left = 0;
		right = k - 1;
		for (int i = 0; i <= N && !flg; i++)
			for (map < int, int > :: iterator iter = f[(int)a.size()][i].begin(); iter != f[(int)a.size()][i].end(); iter++)
				if (g[(int)b.size()][N - i].find((m - iter->first) % m) != g[(int)b.size()][N - i].end())
				{
					recovery(a, f, a.size(), i, iter->first);
					recovery(b, g, b.size(), N - i, (m - iter->first) % m);
					flg = true;
					break;
				}
 
		if (!flg)
		{
			puts("-1");
			continue;
		}
		
		for (int i = 0; i < n; i++)
		{
			if (i) printf(" ");
			printf("%d", ans[i]);
		}
		printf("\n");
	}
	
	return 0;
} 