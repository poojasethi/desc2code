/* Author :: Yash */
#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) 
#define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)
#define REP(i,n) FOR(i,0,n)
#define DEP(i,n) REV(i,n,0)
#define PB push_back
#define PP pop()
#define EM empty()
#define INF 1000000000
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a) 	    __typeof(a) x(a)
#define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i)
#define EACH(it,v)  	IFOR(it,v.begin(),v.end())
#define PRESENT(c,x) 	((c).find(x) != (c).end())
#define SZ(x) 		x.size()
#define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end())
#define D(N) 		int N
#define S(N)		scanf("%d",&N)
#define FASTIO          1

typedef pair<int,int>   PI;
typedef pair<int,PI>    TRI;
typedef V( int )        VI;
typedef V( PI  )        VII;
typedef V( string )     VS;
typedef long long       LL;
typedef long double     LD;

/* FastIO, generally required these days ;) */

#ifndef FASTIO
char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20];
inline int input(int flag=0) {

   while(*ipos <= 32) ++ipos;
   if ( flag  ) return (*ipos++ - '0'); /* For getting Boolean Characters */
   int x=0, neg = 0;char c;
   while( true ) {
      c=*ipos++; if(c == '-') neg = 1;
      else {
	 if (c<=32) return neg?-x:x;
	 x=(x<<1)+(x<<3)+c-'0';
      }
   }
}
inline void output(int x,int flag) {
   int y,dig=0;
   while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}
   while (dig--) *opos++=DIP[dig];
   *opos++= flag ? '\n' : ' ';
}
inline void InitFASTIO() {
   ipos = InpFile; opos = OutFile;
   fread_unlocked(InpFile,20000000,1,stdin);
}
inline void FlushFASTIO() {
   fwrite_unlocked(OutFile,opos-OutFile,1,stdout);	
}
#endif

/* Main Code Starts from here */

#define Max  255
#define MaxN 35
#define MaxL 25

typedef short Int;
typedef unsigned char UC;

char text[Max];
char Patterns[MaxN][MaxL];

Int   lpatterns[MaxN], n, L, Position[Max][MaxN];

UC    dp1[Max], dp2[Max][MaxN][MaxL];
bool  mark1[Max], mark2[Max][MaxN][MaxL];

bool  dp11[Max][Max], dp22[Max][Max][MaxN][MaxL];
bool  newmark1[Max][Max], newmark2[Max][Max][MaxN][MaxL];


bool newRemove(Int st,Int ed);
bool newHelper(Int st,Int ed, Int k,Int end);
UC gogo1(Int ed);
UC gogo2(Int ed,Int k,Int end);

void process(int L) {
   // Character set came out to be 'a'-'z' using Assert. Can be changed if required.
   REP(i,26) {
      Position[0][i] = -1; char c = 'a' + i;
      FOR(j,1,L) {
	 Position[j][i] = Position[j-1][i];
	 if(text[j-1] == c) Position[j][i] = j-1;
      }
   }
}


bool newHelper(Int st,Int ed, Int k,Int end) {
   if(st > ed) return true;
   if(end <= 0) return newRemove(st,ed-1);

   bool& mark = newmark2[st][ed][k][end]; if(mark) return dp22[st][ed][k][end];
   bool& ret = dp22[st][ed][k][end];
   
   int tmp = Patterns[k][end-1] - 'a';
   Int i = Position[ed][tmp];
   while(i >= st) {
      if(newRemove(i+1,ed-1)) { // Now can we remove the text in between ?
	 if(newHelper(st,i,k,end-1)) {
	    ret = true;
	    break;
	 }
      }
      i = Position[i][tmp];
   }
   mark = 1;return ret;
}

bool newRemove(Int st, Int ed) {
   if(st > ed) return 1;

   bool& mark = newmark1[st][ed]; if(mark) return dp11[st][ed];
   bool& ret = dp11[st][ed];

   REP(i,n) if(text[ed] == Patterns[i][lpatterns[i]-1] && newHelper(st,ed,i,lpatterns[i]-1)) {
      ret = true; break;
   }
   mark = 1; return ret;
}

UC gogo2(Int ed,Int k,Int end) {

   Int st = 0;
   if(st > ed)  return 0;
   if(end <= 0) return gogo1(ed-1);

   bool& mark = mark2[ed][k][end]; if(mark) return dp2[ed][k][end];
   UC& ret = dp2[ed][k][end];

   ret = 255; int tmp = Patterns[k][end-1] - 'a';
   Int i = Position[ed][tmp];
   while(i >= st) {
      if(newRemove(i+1,ed-1)) { // Now can we remove the text in between ?
	 ret = min(ret,gogo2(i,k,end-1));
      }
      i = Position[i][tmp];
   }
   mark = 1;return ret;
}
UC gogo1(Int end) {

   Int start = 0;
   if(start > end) return 0;

   bool& mark = mark1[end]; if(mark) return dp1[end];
   UC& ret = dp1[end];

   ret = gogo1(end-1) + 1; // Something better ?
   REP(i,n) {
      if(end - start + 1 < lpatterns[i]) continue;
      if(text[end] == Patterns[i][lpatterns[i]-1]) { // Can we do some matching ? How exactly ?
	 ret = min(ret, gogo2(end,i,lpatterns[i]-1));
      }
   }
   mark = 1;return ret;
}

int main() {

   scanf(" %s%hd",text,&n);
   REP(i,n) {
      scanf(" %s",Patterns[i]);
      lpatterns[i] = strlen(Patterns[i]);
   }
   L = strlen(text); process(L);
   printf("%d\n",gogo1(L-1));
}