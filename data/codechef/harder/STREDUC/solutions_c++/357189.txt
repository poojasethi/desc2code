#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <queue>
using namespace std;
#define   sqr(a)         ((a)*(a))
#define   rep(i,a,b)  for(int i=(a);i<(b);i++)
#define   per(i,a,b)  for(int i=((a)-1);i>=(b);i--)
#define   PER(i,n)     per(i,n,0)
#define   REP(i,n)     rep(i,0,n)
#define   FOREACH(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)
#define   clr(a)      memset((a),0,sizeof (a))
#define   mabs(a)     ((a)>0?(a):(-(a)))
#define   inf         1000000001
#define  MAXN     261
#define  eps      1e-6
char cs[MAXN];
char pt[35][35];
int N;
int dp[MAXN];
int tcan[MAXN][MAXN];
int pcan[MAXN][MAXN][30][30];
int len[35];
int n;
int checkcan(int bg,int ed);
int checkpcan(int bg,int ed,int idx,int c)
{
    if(bg>ed)
    {
        if(c+1>=len[idx])return 1;
    }
    int &ret=pcan[bg][ed][idx][c];
    if(ret!=-1) return ret;
    ret=0;
    if(c+1>=len[idx]) return ret=checkcan(bg,ed);
    rep(i,bg,ed+1)
    {
        if(cs[i]==pt[idx][c])
        {
            if(checkcan(bg,i-1)&&checkpcan(i+1,ed,idx,c+1)) return ret=1;
        }
    }
    return ret;
}
int checkcan(int bg,int ed)
{
    if(bg>ed) return 1;
    int &ret=tcan[bg][ed];
    if(ret!=-1) return ret;
    ret=0;
    REP(i,N)
    {
        if(ed-bg+1<len[i]) continue;
        if(cs[bg]==pt[i][0]&&cs[ed]==pt[i][len[i]-1])
        {
            if(checkpcan(bg+1,ed-1,i,1)) return ret=1;
        }
    }
    rep(i,bg,ed)
    {
        int f1=checkcan(bg,i);
        int f2=checkcan(i+1,ed);
        if(f1&&f2) return ret=1;
    }
    return ret;
}
int main()
{
    scanf("%s%d",cs,&N);
    n=strlen(cs);
    REP(i,N) scanf("%s",pt[i]);
    REP(i,N) len[i]=strlen(pt[i]);
    memset(tcan,0xff,sizeof tcan);
    memset(pcan,0xff,sizeof pcan);
    REP(i,MAXN) dp[i]=inf;
    dp[0]=0;
    rep(i,1,n+1)
    {
        dp[i]=dp[i-1]+1;
        rep(j,1,i+1)
        {
            if(checkcan(j-1,i-1)) dp[i]=min(dp[i],dp[j-1]);
        }
    }
    printf("%d\n",dp[n]);
    return 0;
}
