
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <cmath>
#include <cstring>

#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define REP(i,b) for(int i=0;i<(b);i++)

using namespace std;

#define MAXN 1111111
int N, M;
vector<pair<int, int> > graph[MAXN];

// <Distance from Start, vertex>, <source edge, up / down>
typedef pair<pair<long long, int>, pair<int, bool> > State;
priority_queue<State> pq;

map<pair<int, pair<int, bool> >, long long> dp;

void add(long long d, int v, int from, bool up) {
  pair<int, pair<int, bool> > tmp = make_pair(v, make_pair(from, up));
  if (dp.count(tmp) && dp[tmp] <= d) return;
  dp[tmp] = d;
  pq.push(make_pair(make_pair(-d, v), make_pair(from, up)));
}

int MinFrom[MAXN], MaxFrom[MAXN];

void solve(int Start, int End) {
  while (!pq.empty()) pq.pop();
  REP(i, N) { MinFrom[i] = 1000000001; MaxFrom[i] = 0; }
  dp.clear();
  add(0, Start, 0, 1);
  while (!pq.empty()) {
    long long d = -pq.top().first.first;
    int v = pq.top().first.second, from = pq.top().second.first;
    bool up = pq.top().second.second;
    pq.pop();
   
    if (v == End) { printf("%lld\n", d); return; }
    if (!up) {
      MaxFrom[v] = max(MaxFrom[v], from);
      REP(i, graph[v].size()) {
        if (graph[v][i].first >= from) break;
        if (MinFrom[graph[v][i].second] <= graph[v][i].first) continue;
        add(d + graph[v][i].first, graph[v][i].second, graph[v][i].first, !up);
      }
    }
    else {
      MinFrom[v] = min(MinFrom[v], from);
      FORD(i, (int)graph[v].size() - 1, 0) {
        if (graph[v][i].first <= from) break;
        if (MaxFrom[graph[v][i].second] >= graph[v][i].first) continue;
        add(d + graph[v][i].first, graph[v][i].second, graph[v][i].first, !up);
      }
    }
  }
  printf("No Solution\n");
}

int main(int argc, char *argv[]) {
  int T;
  scanf("%d", &T);
  while (T--) {
    scanf("%d%d", &N, &M);
    REP(i, N) graph[i].clear();
    REP(i, M) {
      int x, y, z;
      scanf("%d%d%d", &x, &y, &z); x--; y--;
      graph[x].push_back(make_pair(z, y));
      graph[y].push_back(make_pair(z, x));
    }
    REP(i, N) sort(graph[i].begin(), graph[i].end());
    int Start, End;
    scanf("%d%d", &Start, &End); Start--; End--;
    solve(Start, End);
  }
  return 0;
}