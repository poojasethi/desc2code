#include<iostream>
#include<cstring>
#include<stdio.h>
#include<assert.h>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#include<stack>
#include<map>
#include<set>
#define mp make_pair
#define pb push_back
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define F first
#define S second
#define ll long long
#define pp pair<int,int>
#define SS system("pause")
#define INF 2000000000000000000ll
#define vec vector<ll>
using namespace std;
const int N=100005;
int n,m,i,j,x[500005][2],z[500005],T,A,B;
int u,v,ind,U,V,IND,D,Y;
vector<pair<pp,int> > g[N][2];
ll dis[500005][2][2],d,ans;


priority_queue<pair<pair<ll,int>, pp> > Q;

void dijkstra(){
    while(Q.size())Q.pop();
    for(i=0;i<g[A][0].size();i++){
        d=g[A][1][i].F.F;
        ind=g[A][1][i].F.S;
        v=g[A][1][i].S;
        //dis[ind][0][v]=MIN(dis[ind][0][v],d);//mandzili ind wibos me-v wveromde 0 ti anu zrdit
        Q.push(mp(mp(-d,ind),mp(1,v)));
    }

    while(Q.size()){
        while(Q.size() && dis[Q.top().F.S][Q.top().S.F][Q.top().S.S]!=INF)Q.pop();
        if(!Q.size())break;

        d=-Q.top().F.F;
        ind=Q.top().F.S;//ind indeeqsi
        u=Q.top().S.F;// zrdit tu klebit , v romel wverozea
        v=Q.top().S.S;
        dis[ind][u][v]=d;
        Q.pop();

        //cout<<ind<<' '<<u<<' '<<v<<' '<<dis[ind][u][v]<<endl;

        Y=x[ind][v];
        while(g[Y][u].size()){
            D=g[Y][!u].back().F.F;

            if(u==0 && D<=z[ind])break;
            if(u==1 && D>=z[ind])break;
            IND=g[Y][!u].back().F.S;
            U=g[Y][!u].back().S;
            g[Y][!u].pop_back();

           // cout<<z[ind]<<endl;

            //cout<<IND<<' '<<D<<' '<<U<<endl;
           // cout<<D+d<<' '<<IND<<' '<<!u<<' '<<U<<endl<<endl;

            Q.push(mp(mp(-D-d,IND),mp(!u,U)));

        }

       // SS;
    }


}


int main()
{scanf("%d",&T);
 while(T--){
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d%d",&x[i][0],&x[i][1],&z[i]);
        g[x[i][0]][0].pb(mp(mp(z[i],i),1));
        g[x[i][1]][0].pb(mp(mp(z[i],i),0));
        dis[i][0][0]=dis[i][1][0]=INF;
        dis[i][0][1]=dis[i][1][1]=INF;
    }

    for(i=1;i<=n;i++){
        sort(g[i][0].begin(),g[i][0].end());
        g[i][1]=g[i][0];
        reverse(g[i][0].begin(),g[i][0].end());
    }


    scanf("%d%d",&A,&B);

    dijkstra();

    ans=INF;
    for(i=1;i<=m;i++){
        int t;
        if(x[i][0]==B)t=0;else
        if(x[i][1]==B)t=1;else continue;
        ans=MIN(ans,dis[i][0][t]);
        ans=MIN(ans,dis[i][1][t]);
    }

    //ans datvla

    if(ans==INF)printf("No Solution\n");else
        printf("%lld\n",ans);

    for(i=1;i<=n;i++){
        g[i][0].clear();
        g[i][1].clear();
    }
 }



 return 0;
}
