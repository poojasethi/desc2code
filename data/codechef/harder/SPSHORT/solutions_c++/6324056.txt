#include<bits/stdc++.h>
#define pb(x) push_back(x)
#define all(x) x.begin(), x.end()
#define cout2(x, y) cout << x << " " << y <<  endl
#define MAXV 100004

#define MAXE 1000005
#define INF (1LL<<60)

using namespace std;

int W[MAXE], next[MAXE], last[MAXV], to[MAXE], E;

void addEdge(int u, int v, int w){
	
	next[E] = last[u], to[E] = v, W[E] = w, last[u] = E++; 	
	next[E] = last[v], to[E] = u, W[E] = w, last[v] = E++;
}

struct nod{
	
	int id, tipe;
	long long dis;	
	
	nod(){}
	nod(int _id, int _tipe, long long _dis){ id = _id; tipe = _tipe; dis = _dis; }
	
};

bool operator <(const nod &n1, const nod &n2){ return n1.dis > n2.dis; }


long long D[2][MAXE];
bool vis[2][MAXE];

long long solve(int source, int target){ // tipe 0 --> this will be greater than the next one
	
	for(int i = 0; i < E; i++){
		
		D[0][i] = D[1][i] = -1;
		vis[0][i] = vis[1][i] = false;
	}

	priority_queue<nod>Q;
	
	for(int e = last[source]; e != -1; e = next[e]){
		
		D[0][e] = W[e];
		Q.push(nod(e, 0, W[e]));
	}
	
	while(!Q.empty()){
		
		nod best = Q.top(); 
		Q.pop();
		
		int u = to[best.id];
		int tipe = best.tipe;
		
		if(vis[tipe][best.id])continue;
		vis[tipe][best.id] = true;
		
		if(u == target)return best.dis;
		
		for(int e = last[u]; e != -1; e = next[e]){
			
			if(tipe == 0 && W[e] >= W[best.id])continue;	
			if(tipe == 1 && W[e] <= W[best.id])continue;
			
			if(D[tipe^1][e] == -1 || D[tipe^1][e] > best.dis + W[e]){
				
				D[tipe^1][e] = best.dis + W[e];
				Q.push(nod(e, tipe^1, D[tipe^1][e]));
			}
		}
		
		
	}
	
	return -1;
}


int main(){

	int tc = 0;
	scanf("%d", &tc);
	
	while(tc--){
			
		int n, m;
		scanf("%d%d", &n, &m);
		
		for(int i = 0; i <= n; i++)last[i] = -1;
		int u, v, w;
		
		E = 0;
		
		for(int i = 0; i < m; i++){
			
			scanf("%d%d%d", &u, &v, &w);
			addEdge(u, v, w);
		}
		
		int source, target;
		scanf("%d%d", &source, &target);
		
		long long ans = solve(source, target);
		
		if(ans ==  -1)printf("No Solution\n");
		else printf("%lld\n", ans);

	}
}

