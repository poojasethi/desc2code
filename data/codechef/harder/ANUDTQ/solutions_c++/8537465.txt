#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
const int mo=1000000007;
#define INF 2100000000
struct node{int ch[2],p,v,sz,ad;ll su;}t[400005];
int rt=0;
void pu(int x){
	t[x].su=t[t[x].ch[0]].su+t[t[x].ch[1]].su+t[x].v;
	t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz+(x&1);
}
void add(int x,int d){
    if(x){
	    t[x].v+=(x&1)*d;
	    t[x].su+=1ll*t[x].sz*d;
	    t[x].ad+=d;
    }
}
void pd(int x){
    if(t[x].ad){
	    add(t[x].ch[0],t[x].ad);
	    add(t[x].ch[1],t[x].ad);
	    t[x].ad=0;
    }
}
int n;
void rot(int x){
    int y=t[x].p;pd(y);pd(x);
    if(rt==y)rt=x;
    int f=t[y].ch[0]==x;
    t[y].ch[!f]=t[x].ch[f];if(t[x].ch[f])t[t[x].ch[f]].p=y;
    t[x].p=t[y].p;if(t[y].p)t[t[y].p].ch[t[t[y].p].ch[1]==y]=x;
    t[x].ch[f]=y;t[y].p=x;
    pu(y);
}
void splay(int x,int goal=0){
	if(t[x].p==goal)pd(x);
	else{
		while(t[x].p!=goal){
			int y=t[x].p;
			if(t[y].p==goal)rot(x);
			else{
				int z=t[y].p,f=t[z].ch[1]==y;
				if(t[y].ch[f]==x){
					rot(y);rot(x);
				}else rot(x),rot(x);
			}
		}
	}
}
void downall(int x){
	if(t[x].p)downall(t[x].p);
	pd(x);
}
inline int gmin(int x){
	while(t[x].ch[0])x=t[x].ch[0];
	return x;
}
inline int gmax(int x){
	while(t[x].ch[1])x=t[x].ch[1];
	return x;
}
inline int succ(int x){
	if(t[x].ch[1])return gmin(t[x].ch[1]);
	else{
		while(t[t[x].p].ch[1]==x)x=t[x].p;
		return t[x].p;
	}
}
inline int pred(int x){
	if(t[x].ch[0])return gmax(t[x].ch[0]);
	else{
		while(t[t[x].p].ch[0]==x)x=t[x].p;
		return t[x].p;
	}
}
void adleaf(int pr,int ne,int v){
	int v1=ne*2+3,v2=ne*2+4;
	t[v1].v=t[v1].su=v;t[v1].sz=1;
	t[v1].ch[1]=v2;t[v2].p=v1;

	int v0=pr*2+3;
	if(t[v0].ch[1]){
		int p=gmin(t[v0].ch[1]);
		downall(p);
		t[p].ch[0]=v1;
		t[v1].p=p;
	}else{
		downall(v0);
		t[v0].ch[1]=v1;
		t[v1].p=v0;
	}
	splay(v2);
}
void extra(int x){
	int v0=pred(x*2+3),v1=succ(x*2+4);
	splay(v0);
	splay(v1,rt);
}
struct edge{int v,next;}e[222222];int etot=0;int g[111111];
void ae(int u,int v){e[etot].v=v;e[etot].next=g[u];g[u]=etot++;}
int qu[111111],pre[111111];
void bfs(int rt){
	int p=0,q=0;qu[q++]=rt;
	pre[rt]=-1;
	while(p!=q){
		int u=qu[p++];
		for (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){
			pre[e[i].v]=u;
			qu[q++]=e[i].v;
		}
	}
}

int val[111111];
int main()
{
	int n;
	gn(n);
	memset(g,-1,sizeof(g));
	for (int i=0;i<n;i++){
		gn(val[i]);
	}
	for (int i=1;i<n;i++){
		int x,y;gn(x);gn(y);
		ae(x,y);ae(y,x);
	}
	bfs(0);
	t[1].sz=1;t[1].ch[1]=2;t[2].p=1;rt=1;
	for (int i=0;i<n;i++)adleaf(pre[qu[i]],qu[i],val[qu[i]]);

	int ma=n;
	int m;gn(m);
	ll la=0;
	while(m--){
		int opt;gn(opt);
		ll u;gn(u);
		u+=la;
		if(opt==1){
			int x;gn(x);
			adleaf(u,ma++,x);
		}else if(opt==2){
			int x;gn(x);
			extra(u);
			add(t[t[rt].ch[1]].ch[0],x);
			pu(t[rt].ch[1]);
			pu(rt);
		}else if(opt==3){
			extra(u);
			t[t[rt].ch[1]].ch[0]=0;
			pu(t[rt].ch[1]);
			pu(rt);
		}else{
			extra(u);
			printf("%lld\n",la=t[t[t[rt].ch[1]].ch[0]].su);
		}
	}
	return 0;
}
