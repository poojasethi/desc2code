#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define REP0(i, n) for (int i = 0; i < n; i++)
#define REP1(i, n) for (int i = 1; i <= n; i++)
#define REP(i, l, r) for (int i = l; i <= r; i++)
#define RP(i, r, l) for (int i = r; i >= l; i--)
#define FORE(i, x) for (int i = fi[x]; i != -1; i = e[i].n)

#define MAX_N 410000
#define MAX_M 210000
#define l(_) c[_][0]
#define r(_) c[_][1]

typedef long long m64;
int p[MAX_N], c[MAX_N][2], sz[MAX_N], key[MAX_N], ss[MAX_N], add[MAX_N];
m64 sum[MAX_N];

struct nodeE { int t, n; } e[MAX_M];
int fi[MAX_M], li[MAX_M], ord[MAX_N], ri[MAX_M], st[MAX_N];
int n, m, tot, cnt, rt; m64 ans;

inline void insert(int x, int y) { e[++tot] = (nodeE) { y, fi[x] }, fi[x] = tot; }
void DFS(int x)
{
	 ord[li[x] = ++tot] = x, key[tot] = st[x], ss[tot] = 1;
	 FORE(i, x) DFS(e[i].t);
	 ord[ri[x] = ++tot] = x, ss[tot] = 0;
}

inline void sc(int x, int y, int d) { if (x) if (c[x][d] = y) p[y] = x; }
inline void upd(int x)
{ if (x) sum[x] = sum[l(x)] + sum[r(x)] + key[x], sz[x] = sz[l(x)] + sz[r(x)] + ss[x]; }
inline void addx(int x, int y)
{ if (x) add[x] += y, key[x] += ss[x] * y, sum[x] += sz[x] * 1LL * y; }
inline void down(int x)
{
	   if (!add[x] || !x) return ;
	   addx(l(x), add[x]), addx(r(x), add[x]), add[x] = 0;
}
void push(int x)
{ int top = 0; while (x) st[++top] = x, x = p[x]; while (top) down(st[top--]); }
inline int d(int x) { return r(p[x]) == x; }

inline void rot(int x)
{
	   int f = p[x], dd = d(x);
	   if (!p[f]) p[rt = x] = 0; else sc(p[f], x, d(f));
	   sc(f, c[x][!dd], dd), sc(x, f, !dd), upd(f);
}

void splay(int x, int y = 0)
{
	 push(x);
	 while (p[x] != y)
	 {
           //printf ("%d %d\n", x, y);
		   int f = p[x];
		   if (p[f] == y) rot(x);
		   else if (d(f) == d(x)) rot(f), rot(x);
		   else rot(x), rot(x);
	 }
	 upd(x);
}

int build(int x, int y)
{
    if (x > y) return 0;
    int mid = (x + y) >> 1;
    sc(mid, build(x, mid - 1), 0), sc(mid, build(mid + 1, y), 1), upd(mid);
    return mid;
}
int getnext(int x) { splay(x); int t = r(x); while (l(t)) t = l(t); return t; }
int getpre(int x) { splay(x); int t = l(x); while (r(t)) t = r(t); return t; }

void ins(int a, int b, int c)
{
     ord[tot + 1] = ord[tot + 2] = a;
     li[b] = tot + 1, ri[b] = tot + 2, key[++tot] = c, ss[tot] = 1;
     int t = getnext(li[a]); splay(t, rt);
     sc(t, tot, 0), sc(tot, tot + 1, 1), splay(++tot);
}

void adds(int x, int y)
{
     int u = getpre(li[x]), v = getnext(ri[x]);
     splay(u), splay(v, u), addx(l(v), y), splay(l(v));
}

void del(int x)
{
     int u = getpre(li[x]), v = getnext(ri[x]);
     splay(u), splay(v, u), sc(v, 0, 0), splay(v);
}

void get(int x)
{
     int u = getpre(li[x]), v = getnext(ri[x]);
    // printf ("%d %d %d -> %d %d\n", x, li[x], u, ri[x], v), fflush(stdout);
     splay(u), splay(v, u), printf ("%lld\n", ans = sum[l(v)]), splay(l(v));
}

void print(int x)
{
     if (!x) return ;
     print(l(x)), printf("%d ", ord[x]), print(r(x));
}
void print(void) { print(rt); }

int main(void)
{

	scanf ("%d", &n), fill(fi, fi + n + 1, -1);
	REP1(i, n) scanf ("%d", st + i);
	REP1(i, n - 1) { int x, y; scanf ("%d%d", &x, &y), insert(++x, ++y); }
	tot = 1, DFS(1), tot++, rt = build(1, tot), cnt = n;
	//print(), printf ("\n %d %lld\n", sz[rt], sum[rt]);
	//REP1(i, tot) printf ("%d ", key[i]);
	scanf ("%d", &m);
	REP1(i, m)
	{
        int op, y; scanf ("%d", &op); m64 x; scanf ("%lld", &x), x += ans + 1;
        if (op <= 2) scanf ("%d", &y);
        if (op == 1) ins((int)x, ++cnt, y);
        else if (op == 2) adds((int)x, y);
        else if (op == 3) del((int)x);
        else if (op == 4) get((int)x);
	}
	return 0;
}
