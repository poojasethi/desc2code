
#define MYDEBUG 0

#include <cstdio>
#include <cstring>
#include <cassert>
#include <algorithm>
#include <bitset>
#include <vector>
#include <iostream>
#define REP(i, n) for(int i = 0; i < (int)(n); ++i)
using namespace std;
typedef long long ll;


struct Node {
  Node *pp, *lp, *rp;
  int cnt;  // 実際の木での、このノードを根とする部分木のサイズ
  int cntQ; // 平衡木内での、このノード以下のcntに加算すべき値
  ll inc;  // 実際の木での、このノードを根とする部分木に加えられている値
  ll incS; // 平衡木内での、このノード以下のincの和
  ll sum;  // 実際の木での、このノードを根とする部分木の、cnt*incの和
  ll sumQ; // 平衡木内での、このノード以下のsumに加算すべき値
  Node() {}
  Node(int v) {
    pp = lp = rp = NULL;
    cnt = 1;
    cntQ = 0;
    sum = v;
    sumQ = 0;
    inc = v;
    incS = v;
  }
  bool isRoot() const {
    return pp == NULL || (pp->lp != this && pp->rp != this);
  }
  void propagateDown() { // このノードを根とする平衡木への操作を（平衡木内で）伝播する
    if(rp){
      rp->refresh();
      rp->cntQ += cntQ;
      rp->sumQ += sumQ;
      sumQ += cntQ * rp->incS;
    }
    refresh();
    sumQ += cntQ * inc;
    cnt += cntQ;
    sum += sumQ;
    if(lp){
      lp->cntQ += cntQ;
      lp->sumQ += sumQ;
    }
    cntQ = 0;
    sumQ = 0;

  }
  void refresh() { // 平衡木内の、このノード以下の情報でこのノードを更新する
    incS = inc;
    if(lp){
      incS += lp->incS;
    }
    if(rp){
      incS += rp->incS;
    }
  }
  void rotr() {
    Node *x = pp, *y = x->pp;
//     assert(x->lp == this);
    x->propagateDown(); propagateDown();
    if((x->lp=rp)) rp->pp = x;
    rp = x; x->pp = this;
    if((pp=y)){
      if(y->lp == x) y->lp = this;
      if(y->rp == x) y->rp = this;
    }
    x->refresh(); refresh();
  }
  void rotl() {
    Node *x = pp, *y = x->pp;
//     assert(x->rp == this);
    x->propagateDown(); propagateDown();
    if((x->rp=lp)) lp->pp = x;
    lp = x; x->pp = this;
    if((pp=y)){
      if(y->rp == x) y->rp = this;
      if(y->lp == x) y->lp = this;
    }
    x->refresh(); refresh();
  }
  void splay() {
    while(!isRoot()){
      Node *x = pp;
      if(x->isRoot()){ // zig
	if(x->lp == this) rotr();
	else rotl();
      }else{
	Node *y = pp->pp;
	if(y->lp == x){
	  if(x->lp == this) { x->rotr(); rotr(); } // zig-zig
	  else { rotl(); rotr(); } // zig-zag
	}else{
	  if(x->rp == this) { x->rotl(); rotl(); } // zig-zig
	  else { rotr(); rotl(); } // zig-zag
	}
      }
    }
    propagateDown(); // useful
  }
};
void expose(Node *x) {
  Node *rp = NULL;
  for(Node *p = x; p; p = p->pp){
    p->splay();
    p->rp = rp;
    p->refresh();
    rp = p;
  }
  x->splay();
}
inline int getCnt(Node *x) { // 実際の木での、xを根とする部分木のサイズを返す
  expose(x);
  return x->cnt;
}
inline ll getSum(Node *x) { // 実際の木での、xを根とする部分木の、cnt*incの和を返す
  expose(x);
  return x->sum;
}
inline ll getIncS(Node *x) { // 実際の木での、ルートからxの親までのincの和、を返す
  expose(x);
  return x->incS - x->inc;
}

//##############################



inline void increase(Node *x, ll v) {
  expose(x);
  x->inc += v;
  x->incS += v;
  x->sumQ += x->cnt*v;
  expose(x);
}
inline void cut(Node *x) {
  expose(x);
  Node *p = x->lp;
  x->lp = NULL;
  p->pp = NULL;
  int removedCnt = getCnt(x);
  ll removedSum = getSum(x);
#if MYDEBUG
  cerr << "cut : rCnt = " << removedCnt << " rSum = " << removedSum << endl;
#endif
//   fprintf(stderr, ">>>>%p\n", p);
  p->cntQ -= removedCnt;
  p->sumQ -= removedSum;
  expose(p);
}
inline void link(Node *x, Node *p) {
  expose(p);
  expose(x);
  ll offsInc = p->incS;
  x->inc -= offsInc;
  x->sumQ -= offsInc * x->cnt;
  expose(x);
  p->cntQ += x->cnt;
  p->sumQ += x->sum;
  expose(x);
  expose(p);
  x->pp = p;
  p->rp = x;
  expose(x);

//   int addedCnt = getCnt(x);
//   ll addedSum = getSum(x);
// #if MYDEBUG
//   cerr << "link : aCnt = " << addedCnt << " aSum = " << addedSum << endl;
// #endif
//   p->cntQ += addedCnt;
//   p->sumQ += addedSum;
//   expose(x);
//   expose(p);
//   x->pp = p;
//   p->rp = x;
//   expose(x);
}



const int MAX_INI_N = 100000;
const int MAX_QUERY = 100000;






Node* nodes[MAX_INI_N+MAX_QUERY+10];
Node nodes_[MAX_INI_N+MAX_QUERY+10];

void debugPrint(const char* msg, int n) {
#if MYDEBUG
  fprintf(stderr, "---- %s\n", msg);
  REP(i, n){
    Node* v = nodes[i];
//     if(n >= 7)
//       expose(nodes[6]);
    expose(v);
//     fprintf(stderr, "nodes[%d]=%p : sum=%lld, cnt=%d, sumQ=%lld, cntQ=%d, pp=%p, lp=%p, rp=%p\n", 
// 	    i, v, getSum(v), getCnt(v), v->sumQ, v->cntQ, v->pp, v->lp, v->rp);
    fprintf(stderr, "nodes[%d]=%p : sum=%lld, cnt=%d, sumQ=%lld, cntQ=%d, inc=%lld, incS=%lld, pp=%p, lp=%p, rp=%p\n", 
 	    i, v, v->sum, v->cnt, v->sumQ, v->cntQ, v->inc, v->incS, v->pp, v->lp, v->rp);
  }
#endif
}


inline int toKey(ll ekey, ll special, int n) {
  ll res = ekey + special;
//   assert(0 <= res);
//   assert(res < n);
  return res;
}

int main(void) {
  int n;
  scanf("%d", &n);
  
  REP(i, n){
    int v;
    scanf("%d", &v);
    nodes_[i] = Node(v);
    nodes[i] = &nodes_[i];
  }
  
#if MYDEBUG
  debugPrint("before link", n);
#endif
  REP(iEdge, n-1){
    int a, b; // a->b
    scanf("%d%d", &a, &b);
    link(nodes[b], nodes[a]);
#if MYDEBUG
    debugPrint("linked", n);
#endif
  }
  
  int nQuery;
  scanf("%d", &nQuery);
  ll special = 0;
  REP(iQuery, nQuery){
    int type;
    ll ekey;
    int key;
    scanf("%d%lld", &type, &ekey);
    key = toKey(ekey, special, n);
#if MYDEBUG
    cerr << "n=" << n << ", key=" << key << ", ekey=" << ekey << ", type=" << type << endl;
#endif
    
    if(type == 1){ // add
      ll v;
      scanf("%lld", &v);
      nodes_[n] = Node(v);
      nodes[n] = &nodes_[n];
      link(nodes[n], nodes[key]);
      n++;
      
    }else if(type == 2){ // increase
      ll v;
      scanf("%lld", &v);
      increase(nodes[key], v);
      
    }else if(type == 3){ // remove
      cut(nodes[key]);
      
    }else{ // output
      ll tmp1 = getIncS(nodes[key]);
      ll tmp2 = getCnt(nodes[key]);
      ll tmp3 = getSum(nodes[key]);
      ll res = tmp1 * tmp2 + tmp3;
      printf("%lld\n", res);
#if MYDEBUG
      cerr << "res = " << res << endl;
#endif
      special = res;
    }
    debugPrint("done", n);

  }
  
  return 0;
}
