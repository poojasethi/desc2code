#include<iostream>
#include<cstring>
#include<string>
#include<vector>
#include<cassert>
#include<algorithm>
using namespace std;
const int mx_nodes = 100;
 
enum Op {
	PL,
	MI,
	MU,
	ID
};
 
struct Parse_Node {
	int id;
	Op op;
	Parse_Node * lc, * rc;
	int num_vars;
};
 
string s;
int n;
long long l, h;
long long a[15];
int match[mx_nodes];
int num_nodes;
vector<pair<long long,int> > vals[mx_nodes][1 << 12];
 
Parse_Node* go(int lo, int hi) {
	while (match[lo] == hi - 1) lo ++, hi --;
	Parse_Node* res = new Parse_Node;
	int lvl = 0;
	int pos_pl = -1, pos_mi = -1, pos_mu = -1;
	for (int i = lo; i < hi; i ++) {
		if (s[i] == '(') lvl ++; else
		if (s[i] == ')') lvl --; else
		if (lvl == 0 && s[i] == '+') pos_pl = i; else
		if (lvl == 0 && s[i] == '-') pos_mi = i; else
		if (lvl == 0 && s[i] == '*') pos_mu = i;
	}
	int pos = -1;
	if (pos_pl >= 0) {
		res -> op = PL;
		pos = pos_pl;
	}
	else if (pos_mi >= 0) {
		res -> op = MI;
		pos = pos_mi;
	}
	else if (pos_mu >= 0) {
		res -> op = MU;
		pos = pos_mu;
	}
	else {
		res -> op = ID;
		res -> num_vars = 1;
	}
	if (pos >= 0) {
		res -> lc = go(lo, pos);
		res -> rc = go(pos + 1, hi);
		res -> num_vars = res -> lc -> num_vars + res -> rc -> num_vars;
	}
	res -> id = num_nodes ++;
	return res;
}
 
Parse_Node* parse() {
	vector<int> a;
	memset(match,-1,sizeof(match));
	int len = s.size();
	for (int i = 0; i < len; i ++) {
		if (s[i] == '(') a.push_back(i); else
		if (s[i] == ')') match[a.back()] = i, a.pop_back();
	}
	num_nodes = 0;
	return go(0, len);
}
 
pair<long long, int> t[5000000];
// int its;
void calc(Parse_Node* node) {
	int cnt_t;
	if (node -> op == ID) {
		for (int i = 0; i < n; i ++) {
			vals[node -> id][1 << i].push_back(make_pair(a[i], 1));
		}
	}
	else {
		calc(node -> lc);
		calc(node -> rc);
		for (int i = 0; i < (1 << n); i ++) if (__builtin_popcount(i) == node -> num_vars) {
			cnt_t = 0;
			for (int i1 = i; i1 != 0; i1 = (i1 - 1) & i) if (__builtin_popcount(i1) == node -> lc -> num_vars) {
				// its += vals[node -> lc -> id][i1].size() * vals[node -> rc -> id][i ^ i1].size();
				vector<pair<long long,int> >::iterator p1, p2;
				if (node -> op == PL)
				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++)
					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++)
						t[cnt_t].first = (*p1).first + (*p2).first,
						t[cnt_t].second = (*p1).second * (*p2).second,
						cnt_t ++;
				else if (node -> op == MI)
				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++)
					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++)
						t[cnt_t].first = (*p1).first - (*p2).first,
						t[cnt_t].second = (*p1).second * (*p2).second,
						cnt_t ++;
				else
				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++)
					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++)
						t[cnt_t].first = (*p1).first * (*p2).first,
						t[cnt_t].second = (*p1).second * (*p2).second,
						cnt_t ++;
			}
			sort(t, t + cnt_t);
			for (int j = 0; j < cnt_t; j ++) {
				if (j < cnt_t - 1 && t[j + 1].first == t[j].first)
					t[j + 1].second += t[j].second;
				else vals[node -> id][i].push_back(make_pair(t[j].first, t[j].second));
			}
		}
	}
}
 
void solve() {
	cin >> n >> l >> h;
	for (int i = 0; i < n; i ++) cin >> a[i];
	cin >> s;
	Parse_Node* root = parse();
	for (int i = 0; i < mx_nodes; i ++) for (int j = 0; j < (1 << 12); j ++) vals[i][j].clear();
	// cout << num_nodes << endl;
	calc(root);
	
	int res = 0;
	vector<pair<long long,int> > m = vals[root -> id][(1 << n) - 1];
	vector<pair<long long,int> >::iterator it;
	for (it = m.begin(); it != m.end(); it ++) {
		if ((*it).first >= l && (*it).first <= h) res += (*it).second;
		// cout << (*it).first << " (" << (*it).second << ")" << endl;
	}
	int b[10]; memset(b,0,sizeof(b));
	for (int i = 0; i < n; i ++) b[a[i]] ++;
	for (int i = 0; i < 10; i ++) {
		for (int j = 1; j <= b[i]; j ++) res /= j;
	}
	cout<<res<<endl;
}
 
int main() {
	int T; cin >> T; while (T--) solve();
}