#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <limits>
using namespace std;

const int DIG = 9, BASE = 1000000000;
const unsigned long long OVER = numeric_limits <unsigned long long> :: max () - (unsigned long long) BASE * BASE;

struct bignum
{
    int D, digits [3];

    inline void trim ()
    {
        while (D > 1 && digits [D - 1] == 0)
            D--;
    }

    inline void init (long long x)
    {
        memset (digits, 0, sizeof (digits));
        D = 0;

        do
        {
            digits [D++] = x % BASE;
            x /= BASE;
        }
        while (x > 0);
    }

    inline bignum (long long x)
    {
        init (x);
    }

    inline bignum (int x = 0)
    {
        init (x);
    }

    inline char *str ()
    {
        trim ();
        char *buf = new char [DIG * D + 1];
        int pos = 0, d = digits [D - 1];

        do
        {
            buf [pos++] = d % 10 + '0';
            d /= 10;
        }
        while (d > 0);

        reverse (buf, buf + pos);

        for (int i = D - 2; i >= 0; i--, pos += DIG)
            for (int j = DIG - 1, t = digits [i]; j >= 0; j--)
            {
                buf [pos + j] = t % 10 + '0';
                t /= 10;
            }

        buf [pos] = '\0';
        return buf;
    }

    inline bignum operator + (const bignum &o) const
    {
        bignum sum = o;
        int carry = 0;

        for (sum.D = 0; sum.D < D || carry > 0; sum.D++)
        {
            sum.digits [sum.D] += (sum.D < D ? digits [sum.D] : 0) + carry;

            if (sum.digits [sum.D] >= BASE)
            {
                sum.digits [sum.D] -= BASE;
                carry = 1;
            }
            else
                carry = 0;
        }

        sum.D = max (sum.D, o.D);
        sum.trim ();
        return sum;
    }

    inline bignum operator - (const bignum &o) const
    {
        bignum diff = *this;

        for (int i = 0, carry = 0; i < o.D || carry > 0; i++)
        {
            diff.digits [i] -= (i < o.D ? o.digits [i] : 0) + carry;

            if (diff.digits [i] < 0)
            {
                diff.digits [i] += BASE;
                carry = 1;
            }
            else
                carry = 0;
        }

        diff.trim ();
        return diff;
    }

    inline bignum operator * (const bignum &o) const
    {
        bignum prod = 0;
        unsigned long long sum = 0, carry = 0;

        for (prod.D = 0; prod.D < D + o.D - 1 || carry > 0; prod.D++)
        {
            sum = carry % BASE;
            carry /= BASE;

            for (int j = max (prod.D - o.D + 1, 0); j <= min (D - 1, prod.D); j++)
            {
                sum += (unsigned long long) digits [j] * o.digits [prod.D - j];

                if (sum >= OVER)
                {
                    carry += sum / BASE;
                    sum %= BASE;
                }
            }

            carry += sum / BASE;
            prod.digits [prod.D] = sum % BASE;
        }

        prod.trim ();
        return prod;
    }
};

const int LOG = 45, START = 5, BOUND = 5000;
const long long BIG = (long long) 1e18;

int T;
long long N, A, B;
long long big [LOG], cache [LOG][BOUND];

inline long long binom (long long a, int b, bool check = false)
{
    if (b >= START)
    {
        if (a >= big [b])
            return BIG;
        else if (cache [b][a] != -1)
            return cache [b][a];
    }

    long long val = 1;

    for (int i = 0; i < b; i++)
        if (check && (double) val * (a - i) > BIG)
        {
            val = BIG;
            break;
        }
        else
            val = val * (a - i) / (i + 1);

    if (b >= START && a < big [b])
    {
        cache [b][a] = val;

        if (val >= BIG)
            big [b] = a;
    }

    return val;
}

inline long long words (long long cost)
{
    long long total = 0;

    for (int b = 0; b * B <= cost && total < N; b++)
    {
        long long a = (cost - b * B) / A;
        total += binom (a + b + 1, b + 1, true);
    }

    return total;
}

inline bignum sum (long long cost)
{
    bignum total = (bignum) N * (bignum) (A + B);
    long long num = 0;

    for (int b = 0; b * B <= cost; b++)
    {
        long long a = (cost - b * B) / A;
        num += binom (a + b + 1, b + 1);
        total = total + (bignum) (B * b) * (bignum) binom (a + b + 1, b + 1);
        total = total + (bignum) (A * (b + 1)) * (bignum) binom (a + b + 1, b + 2);
    }

    total = total - (bignum) (num - N) * cost;
    return total;
}

int main ()
{
    memset (cache, -1, sizeof (cache));

    for (int i = 0; i < LOG; i++)
        big [i] = BOUND;

    for (scanf ("%d", &T); T > 0; T--)
    {
        scanf ("%lld %lld %lld", &A, &B, &N);
        N--;

        if (A > B)
            swap (A, B);

        if (N == 0)
        {
            printf ("%lld\n", A);
            continue;
        }

        long long lo = 0, hi = B * (64 - __builtin_clzll (N));

        while (lo < hi)
        {
            long long mid = (lo + hi) >> 1;

            if (words (mid) < N)
                lo = mid + 1;
            else
                hi = mid;
        }

        printf ("%s\n", sum (lo).str ());
    }

    return 0;
}

