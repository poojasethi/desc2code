#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
typedef pair <ll, int> li;

const int Maxn = 200005;
const int Maxm = 1048576;

int n;
ll a[Maxn], b[Maxn], c[Maxn];
vector <ll> un;
int leaf[Maxn];
bool isleaf[Maxm];
li mx[Maxm];
li L[Maxm], R[Maxm];

void Create(int v, int l, int r)
{
	L[v] = R[v] = li(0, r - l + 1);
	if (l == r) { leaf[l] = v; isleaf[v] = true; }
	else {
		int m = l + r >> 1;
		Create(2 * v, l, m); Create(2 * v + 1, m + 1, r);
	}
}

li getMax(int v, int l, int r, int a, int b)
{
	if (l == a && r == b) return mx[v];
	else {
		int m = l + r >> 1;
		if (b <= m) return getMax(2 * v, l, m, a, b);
		if (m + 1 <= a) return getMax(2 * v + 1, m + 1, r, a, b);
		return max(getMax(2 * v, l, m, a, m), getMax(2 * v + 1, m + 1, r, m + 1, b)); 
	}
}

void updateMax(int v, int l, int r, int a, ll val)
{
	if (l == r) mx[v] = li(val, l);
	else {
		int m = l + r >> 1;
		if (a <= m) updateMax(2 * v, l, m, a, val);
		else updateMax(2 * v + 1, m + 1, r, a, val);
		mx[v] = max(mx[2 * v], mx[2 * v + 1]);
	}
}

int lenRight(int v, ll val)
{
	if (val >= R[v].first) return 0;
	if (val == 0 || isleaf[v]) return R[v].second;
	if (val >= R[2 * v].first) return lenRight(2 * v + 1, val);
	else return R[v].second - R[2 * v].second + lenRight(2 * v, val);
}

int lenLeft(int v, ll val)
{
	if (val >= L[v].first) return 0;
	if (val == 0 || isleaf[v]) return L[v].second;
	if (val >= L[2 * v + 1].first) return lenLeft(2 * v, val);
	else return L[v].second - L[2 * v + 1].second + lenLeft(2 * v + 1, val);
}

void Update(int x, ll val)
{
	int v = leaf[x]; L[v] = R[v] = li(val, 1);
	v /= 2;
	while (v) {
		L[v].first = R[v].first = max(L[2 * v].first, L[2 * v + 1].first);
		L[v].second = L[2 * v + 1].second + lenLeft(2 * v, L[2 * v + 1].first);
		R[v].second = R[2 * v].second + lenRight(2 * v + 1, R[2 * v].first);
		v /= 2;
	}
}

int Get(int x)
{
	int v = leaf[x];
	ll lmx = L[v].first, rmx = R[v].first;
	int res = 0;
	int lst = v; v /= 2;
	while (v) {
		if (2 * v == lst) { res += lenRight(2 * v + 1, rmx); rmx = max(rmx, R[2 * v + 1].first); }
		else { res += lenLeft(2 * v, lmx); lmx = max(lmx, L[2 * v].first); }
		lst = v; v /= 2;
	}
	return res;
}

int main()
{
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%lld %lld", &a[i], &b[i]);
		un.push_back(b[i]);
		if (a[i] == 0 || a[i] == 2) scanf("%lld", &c[i]);
		if (a[i] == 2) un.push_back(c[i]);
	}
	sort(un.begin(), un.end()); un.erase(unique(un.begin(), un.end()), un.end());
	Create(1, 0, un.size() - 1);
	for (int i = 0; i < n; i++) {
		b[i] = lower_bound(un.begin(), un.end(), b[i]) - un.begin();
		if (a[i] == 0) { updateMax(1, 0, un.size() - 1, b[i], c[i]); Update(b[i], c[i]); }
		else if (a[i] == 1) { updateMax(1, 0, un.size() - 1, b[i], 0); Update(b[i], 0); }
		else {
			c[i] = lower_bound(un.begin(), un.end(), c[i]) - un.begin();
			int mid = getMax(1, 0, un.size() - 1, min(b[i], c[i]), max(b[i], c[i])).second;
			printf("%d\n", Get(b[i]) + Get(c[i]) - 2 * Get(mid));
		}
	}
	return 0;
}