#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
struct Que{
	int o,ku,kv,d;
}Q[200020];
int key[200020];
int n,cnt;
void read(){
	scanf("%d",&n);
	for (int i = 1;i <= n;i++){
		int o,ku,kv,d;
		scanf("%d",&o);
		if (o == 0){
			scanf("%d%d",&ku,&d);
			Q[i] = (Que){0,ku,0,d};
			key[++cnt] = ku;
		}else if (o == 1){
			scanf("%d",&ku);
			Q[i] = (Que){1,ku,0,0};
		}else{
			scanf("%d%d",&ku,&kv);
			Q[i] = (Que){2,ku,kv,0};
		}
	}
	sort(key + 1,key + cnt + 1);
	for (int i = 1;i <= n;i++){
		Q[i].ku = lower_bound(key + 1,key + cnt + 1,Q[i].ku) - key;
		if (Q[i].o == 2)
			Q[i].kv = lower_bound(key + 1,key + cnt + 1,Q[i].kv) - key;
	}
}
struct node{
	int lenp,lens,maxn,mxp,l,r;
}a[1000000];
void build(int o,int l,int r){
	if (l == r) {a[o].l = a[o].r = r;return;}
	int mid = (l+r) >> 1;
	build(o*2,l,mid);
	build(o*2+1,mid+1,r);
	a[o].l = l,a[o].r = r;
}
int rankp(int o,int mx){
	if (mx > a[o].maxn) return 0;
	if (mx == 0 || a[o].l == a[o].r) return a[o].lenp;
	if (a[o * 2].maxn <= mx)
		return rankp(o * 2 + 1,mx);
	return rankp(o*2,mx) + a[o].lenp - a[o*2].lenp;
}
int ranks(int o,int mx){
	if (mx > a[o].maxn) return 0;
	if (mx == 0 || a[o].l == a[o].r) return a[o].lens;
	if (a[o*2+1].maxn <= mx)
		return ranks(o*2,mx);
	return a[o].lens - a[o*2+1].lens + ranks(o*2+1,mx);
}
void upd(int o,int d){
	if (a[o*2].maxn > a[o*2+1].maxn)
		a[o].maxn = a[o*2].maxn,a[o].mxp = a[o*2].mxp;
	else a[o].maxn = a[o*2+1].maxn,a[o].mxp = a[o*2+1].mxp;
	a[o].lenp = a[o*2].lenp + rankp(o*2+1,a[o*2].maxn);
	a[o].lens = a[o*2+1].lens + ranks(o*2,a[o*2+1].maxn);
}
void ins(int o,int l,int r,int p,int d,int w1,int w2){
	if (l == r){
		a[o].lenp = w1,a[o].lens = w2;
		a[o].maxn = d;a[o].mxp = l;
		return;
	}
	int mid = (l+r) >> 1;
	if (p <= mid) ins(o*2,l,mid,p,d,w1,w2);
	else ins(o*2 + 1,mid + 1,r,p,d,w1,w2);
	upd(o,d);
}
int lcad,lcap;
void quemax(int o,int l,int r,int ln,int rn){
	if (ln <= l && r <= rn){
		if (lcad < a[o].maxn)
			lcad = a[o].maxn,lcap = a[o].mxp;
		return;
	}
	int mid = (l+r) >> 1;
	if (ln <= mid) quemax(o*2,l,mid,ln,rn);
	if (mid+1 <= rn) quemax(o*2+1,mid+1,r,ln,rn);
}
int get_leaf(int p){
	int o = 1,l = 1,r = cnt;
	while (l != r){
		int mid = (l+r) >> 1;
		if (p <= mid) o*=2,r = mid;
		else o = o * 2 + 1,l = mid + 1;
	}
	return o;
}
int right_dep(int o){
	int mx = a[o].maxn;
	int dep = 0;
	while (o != 1){
		int fa = o/2;
		if ((o & 1) == 0){
			dep += rankp(fa*2+1,mx);
			mx = max(mx,a[fa*2+1].maxn);
		}
		o = fa;
	}
	return dep;
}
int left_dep(int o){
	int mx = a[o].maxn;
	int dep = 0;
	while (o != 1){
		int fa = o/2;
		if (o & 1){
			dep += ranks(fa*2,mx);
			mx = max(mx,a[fa*2].maxn);
		}
		o = fa;
	}
	return dep;
}
int depth(int p){
	int o = get_leaf(p);
	int dep = right_dep(o);
	dep += left_dep(o);
	return dep;
}
void work(){
	build(1,1,cnt);
	for (int i = 1;i <= n;i++)
		if (Q[i].o == 0){
			ins(1,1,cnt,Q[i].ku,Q[i].d,1,1);
		}else if (Q[i].o == 1){
			ins(1,1,cnt,Q[i].ku,0,0,0);
		}else {
			lcad = lcap = 0;
			int u = Q[i].ku,v = Q[i].kv;
			if (u > v) swap(u,v);
			quemax(1,1,cnt,u,v);
			printf("%d\n",depth(Q[i].ku) + depth(Q[i].kv) - 2*depth(lcap));
		}
}

int main(){
	read();
	work();
	return 0;
}
