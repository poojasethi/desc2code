#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;

#define n	800005
#define unt	unsigned int
#define CH	(ch=getchar())
#define For(i,a,b)	for(unt i=a;i<=b;i++)

unt		N,A[n],O[n][3];

struct	Seg{
		unt Max[n],Pos[n],Len[n],Num[n];

		unt		Cal(unt x,unt start){
			if	(start>=Max[x])	return	0;
			if	(Len[x]==1)	return	1;
			if	(start>=Max[x<<1])	return	Cal(x<<1|1,start);
			return	Cal(x<<1,start)+Len[x]-Len[x<<1];
		}
		void	Up(unt x){
			Max[x]=max(Max[x<<1],Max[x<<1|1]);
			if	(Max[x<<1]>Max[x<<1|1])	Pos[x]=Pos[x<<1];
				else	Pos[x]=Pos[x<<1|1];
			Len[x]=Len[x<<1]+Cal(x<<1|1,Max[x<<1]);
		}

		void	INS(unt u,unt l,unt r,unt x,unt y){
			if	(l==r)	{
				Max[u]=Num[l]=y;	Pos[u]=l;	Len[u]=1;
				return	;
			}	unt Mid=l+r>>1;
			x<=Mid?INS(u<<1,l,Mid,x,y):INS(u<<1|1,Mid+1,r,x,y);	Up(u);
		}
		void	DEL(unt u,unt l,unt r,unt x)	{
			if	(l==r)	{
				Max[u]=Pos[u]=Len[u]=Num[l]=0;	return	;
			}	unt Mid=l+r>>1;
			x<=Mid?DEL(u<<1,l,Mid,x):DEL(u<<1|1,Mid+1,r,x);	Up(u);
		}
		unt		Query(unt u,unt l,unt r,unt x,unt y,unt&start){
			if	(x<=l&&r<=y)	{
				unt ret=Cal(u,start);	start=max(start,Max[u]);
				return	ret;
			}	unt Mid=l+r>>1,ret=0;
			if	(x<=Mid)ret+=Query(u<<1,l,Mid,x,y,start);
			if	(y>Mid)	ret+=Query(u<<1|1,Mid+1,r,x,y,start);
			return	ret;
		}
		unt		RMQ(unt u,unt l,unt r,unt x,unt y){
			if	(x<=l&&r<=y)	return	Pos[u];
			unt Mid=l+r>>1,a=0,b=0;
			if	(x<=Mid)a=RMQ(u<<1,l,Mid,x,y);
			if	(y>Mid)	b=RMQ(u<<1|1,Mid+1,r,x,y);
			return	Num[a]>Num[b]?a:b;
		}
}L,R;

unt		IN(){
		unt x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}
unt		Find(unt x)	{
		return	lower_bound(A+1,A+*A+1,x)-A;
}
unt		Ask(unt x){
		unt start=0,ret=0;
		ret=L.Query(1,1,*A,x,*A,start);
		ret+=R.Query(1,1,*A,(*A)-x+1,*A,start=0);
		return	ret-2;
}

int		main(){
		N=IN();
		For(i,1,N)	{
			*O[i]=IN();
			if	(O[i][0]==1)	O[i][1]=IN();
				else	O[i][1]=IN(),O[i][2]=IN();
			if	(O[i][0]==0)	A[++*A]=O[i][1];
		}	sort(A+1,A+*A+1);

		For(i,1,N)	{
			if	(O[i][0]==0){
				unt x=Find(O[i][1]),y=O[i][2];
				L.INS(1,1,*A,x,y);	R.INS(1,1,*A,(*A)-x+1,y);
			}	else
			if	(O[i][0]==1){
				unt x=Find(O[i][1]);
				L.DEL(1,1,*A,x);	R.DEL(1,1,*A,(*A)-x+1);
			}	else{
				unt x=Find(O[i][1]),y=Find(O[i][2]),z=L.RMQ(1,1,*A,min(x,y),max(x,y));
				printf("%d\n",Ask(x)+Ask(y)-2*Ask(z));
			}
		}
}