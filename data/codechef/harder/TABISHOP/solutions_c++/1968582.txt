#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <map>
#include <string>
#include <string.h>
#include <queue>
#include <set>
using namespace std;
struct point
{
	int x,y,tx,ty;
	bool tp;
	point(){}
	point(int _x,int _y,int _tx,int _ty,bool _tp):x(_x),y(_y),tx(_tx),ty(_ty),tp(_tp){}
};
struct elem
{
	int y,x1,x2;
	bool tp;
	elem(){}
	elem(int _y,int _x1,int _x2,bool _tp):y(_y),x1(_x1),x2(_x2),tp(_tp){}
}e[600000];
pair<int,int> p[600000];
vector<point> pt[2];
int tree[1200000];
bool inline cmpy(const point &a,const point &b)
{
	if(a.ty==b.ty) return a.tx<b.tx;
	return a.ty<b.ty;
}
bool inline cmpy2(const elem &a,const elem &b)
{
	if(a.y==b.y) return a.tp>b.tp;
	return a.y<b.y;
}
bool inline cmpx(const point &a,const point &b)
{
	if(a.tx==b.tx) return a.ty<b.ty;
	return a.tx<b.tx;
}
int inline getidx(int s,int t)
{
	return s+t|s!=t;
}
void Operate(int l,int r,int s,int t,int v)
{
	int nowidx=getidx(l,r);
	tree[nowidx]+=v;
	if(l==s&&r==t) return;
	int mid=l+r>>1;
	int lch=getidx(l,mid),rch=getidx(mid+1,r);
	if(s<=mid)
	{
		if(t<=mid) Operate(l,mid,s,t,v);
		else
		{
			Operate(l,mid,s,mid,v);
			Operate(mid+1,r,mid+1,t,v);
		}
	}
	else Operate(mid+1,r,s,t,v);
}
int Query(int l,int r,int s,int t)
{
	int nowidx=getidx(l,r);
	if(l==s&&r==t) return tree[nowidx];
	int mid=l+r>>1;
	int lch=getidx(l,mid),rch=getidx(mid+1,r);
	if(s<=mid)
	{
		if(t<=mid) return Query(l,mid,s,t);
		return Query(l,mid,s,mid)+Query(mid+1,r,mid+1,t);
	}
	return Query(mid+1,r,s,t);
}
int main()
{
	int n,k,m,x,y,e_sz,p_sz;
	scanf("%d %d %d",&n,&k,&m);
	for(int i=0;i<k;i++)
	{
		scanf("%d %d",&x,&y);
		if(x+y&1) pt[0].push_back(point(x,y,(x+1+y)/2,(x+1-y)/2,0));
		else pt[1].push_back(point(x,y,(x+y)/2,(x-y)/2,0));
	}
	for(int i=0;i<m;i++)
	{
		scanf("%d %d",&x,&y);
		if(x+y&1) pt[0].push_back(point(x,y,(x+y+1)/2,(x+1-y)/2,1));
		else pt[1].push_back(point(x,y,(x+y)/2,(x-y)/2,1));
	}
	long long ans=0;
	for(int i=0;i<2;i++)
	{
		p_sz=e_sz=0;
		sort(pt[i].begin(),pt[i].end(),cmpy);
		for(int j=0;j<pt[i].size();j++)
		{
			if(pt[i][j].tp==0)
			{
				int x1,x2;
				if(j>0&&pt[i][j].ty==pt[i][j-1].ty) x1=pt[i][j-1].tx+1;
				else x1=pt[i][j].tx-min(pt[i][j].x,pt[i][j].y)+1;
				bool ok=0;
				int j1=j+1;
				while(j1<pt[i].size()&&pt[i][j1].ty==pt[i][j].ty)
				{
					if(pt[i][j1].tp==1)
					{
						x2=pt[i][j1].tx-1;
						ok=1; j=j1;
						break;
					}
					j1++;
				}
				if(!ok)
				{
					x2=pt[i][j].tx+min(n-pt[i][j].x,n-pt[i][j].y);
					j=j1-1;
				}
				p[p_sz++]=make_pair(x1,e_sz+1);
				p[p_sz++]=make_pair(x2,-e_sz-1);
				e[e_sz++]=elem(pt[i][j].ty,x1,x2,0);
				ans+=x2-x1+1;
			}
		}
		sort(pt[i].begin(),pt[i].end(),cmpx);
		for(int j=0;j<pt[i].size();j++)
		{
			if(pt[i][j].tp==0)
			{
				int y1,y2;
				if(j>0&&pt[i][j].tx==pt[i][j-1].tx) y1=pt[i][j-1].ty+1;
				else y1=pt[i][j].ty-min(pt[i][j].x,n-pt[i][j].y+1)+1;
				bool ok=0;
				int j1=j+1;
				while(j1<pt[i].size()&&pt[i][j1].tx==pt[i][j].tx)
				{
					if(pt[i][j1].tp==1)
					{
						y2=pt[i][j1].ty-1;
						ok=1; j=j1;
						break;
					}
					j1++;
				}
				if(!ok)
				{
					y2=pt[i][j].ty+min(n-pt[i][j].x,pt[i][j].y-1);
					j=j1-1;
				}
				p[p_sz++]=make_pair(pt[i][j].tx,e_sz+1);
				e[e_sz++]=elem(y1,pt[i][j].tx,1,1);
				p[p_sz++]=make_pair(pt[i][j].tx,e_sz+1);
				e[e_sz++]=elem(y2+1,pt[i][j].tx,-1,1);
				ans+=y2-y1+1;
			}
		}
		sort(p,p+p_sz);
		int N=0;
		for(int i=0;i<p_sz;)
		{
			int j=i;
			for(;j<p_sz&&p[i].first==p[j].first;j++)
			{
				if(p[j].second>0) e[p[j].second-1].x1=N;
				else e[-p[j].second-1].x2=N;
			}
			i=j;
			N++;
		}
		memset(tree,0,2*N<<2);
		sort(e,e+e_sz,cmpy2);
		for(int i=0;i<e_sz;i++)
		{
			if(e[i].tp==1)
			{
				int nowv=tree[getidx(e[i].x1,e[i].x1)];
				if(e[i].x2==1&&nowv==0) Operate(0,N-1,e[i].x1,e[i].x1,1);
				if(e[i].x2==-1&&nowv==1) Operate(0,N-1,e[i].x1,e[i].x1,-1);
			}
			else ans-=Query(0,N-1,e[i].x1,e[i].x2);
		}
	}
	printf("%lld\n",ans);
}