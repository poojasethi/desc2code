//
// bischop.cpp -- Bischop - http://www.codechef.com/COOK32/problems/TABISHOP
//
// Siwakorn Sriakaokul - ping128
// Written on Monday, 25 March 2013.
//

#include <cstdio>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <cmath>
#include <algorithm>
#include <map>
#include <ctype.h>

using namespace std;

typedef pair<int, int> Point;
typedef long long LL;

typedef struct Segment_st {
	int x, y1, y2;

	bool operator == (const Segment_st &o) const {
		return x == o.x && y1 == o.y1 && y2 == o.y2;
	}
	bool operator < (const Segment_st &o) const {
		if(x != o.x)
			return x < o.x;
		if(y1 != o.y1)
			return y1 < o.y1;
		return y2 < o.y2;
	}
}Segment;

LL gen_segments(vector<Point> &bishops, vector<Point> &others, int sa, int sb, int da, int db, vector<Segment> &v){
	v.clear();
	sort(others.begin(), others.end()); // sort other chess pieces
	int sz_b = bishops.size();
	for(int i = 0; i < sz_b; i++ ){
		int x = bishops[i].first;
		int y = bishops[i].second;

		// init y1,y2 by board boundary
		int y1 = max(sa - x, x - db);
		int y2 = min(sb - x, x - da);

		// seek for other chess pieces in the same column
		int j = lower_bound(others.begin(), others.end(), bishops[i]) - others.begin();
		// update y2 if we have other chess piece with the same x and larger y
		if(j < others.size() && others[j].first == x)
			y2 = min(y2, others[j].second - 1);
		// update y1 if we have other chess piece with the same x and smaller y
		if(j > 0 && others[j - 1].first == x)
			y1 = max(y1, others[j - 1].second + 1);

		Segment cur = {x, y1, y2};
		v.push_back(cur);
	}

	// sort and unique segments
	// after that they all will be non-intersecting
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	// sum their lengths

	LL res = 0;
	for(int i = 0; i < v.size(); i++ )
		res += v[i].y2 - v[i].y1 + 1;
	return res;
}

struct Event {
	int x;
	int tp;
	int y1,y2;
	Event(){}
	Event(int x_,int tp_,int y1_,int y2_=0){x=x_;tp=tp_;y1=y1_;y2=y2_;}
	bool operator<(const Event &e) const {
		return x<e.x || x==e.x && tp<e.tp;
	}
};

LL intersect(vector<Segment> &a, vector<Segment> &b)
{
	// creating the list of all unique y values for horizontal segments
	vector<int> y;
	for(int i = 0; i < b.size(); i++ ){
		y.push_back(b[i].x);
	}

	sort(y.begin(), y.end());
	y.erase(unique(y.begin(), y.end()), y.end());

	// creating events
	vector<Event> ev;
	for(int i = 0; i < a.size(); i++ )
		// count event for vertical segments
		ev.push_back(Event(a[i].x, 0, a[i].y1, a[i].y2));

	for(int i = 0; i < b.size(); i++ ){
		// add and del events for horizontal segments
		ev.push_back(Event(b[i].y1, -1, b[i].x));
		ev.push_back(Event(b[i].y2, +1, b[i].x));
	}
	sort(ev.begin(), ev.end());

	int n = ev.size();
	vector<int> BIT(n+1,0); // binary index tree 
	LL ans=0;
	for(int i=0;i<ev.size();i++)
	{
		int tp = ev[i].tp;
		if(tp) {
			// add or del event
			int j = lower_bound(y.begin(), y.end(), ev[i].y1) - y.begin() + 1;
			for(; j <= n; j += (j & (-j)))
				BIT[j]-=tp;
		} else {
			// count event
			// we count the number of marked y between j1 and j2
			int j1 = lower_bound(y.begin(), y.end(), ev[i].y1) - y.begin();
			int j2 = upper_bound(y.begin(), y.end(), ev[i].y2) - y.begin();
			for(int j=j2;j>0;j-=j&-j) ans+=BIT[j];
			for(int j=j1;j>0;j-=j&-j) ans-=BIT[j];
		}
	}
	return ans;
}


// sa <= x + y <= sb && da <= x - y <= db, board constraints
LL cal(vector<Point> &bishops, vector<Point> &others, int sa, int sb, int da, int db){
	LL res = 0;

	vector<Segment> vertical;
	// gen unique safe vertical segments for each bishop
	// and add their total length to the answer
	res += gen_segments(bishops, others, sa, sb, da, db, vertical);

	// the swap trick to use the same routine for both vertical and horizontal segments
	for(int i = 0; i < bishops.size(); i++ )
		swap(bishops[i].first, bishops[i].second);
	for(int i = 0; i < others.size(); i++ )
		swap(others[i].first, others[i].second);
	vector<Segment> horizontal;
	// gen safe horizontal segments for each bishop
	// and add their total length to the answer
	res += gen_segments(bishops, others, sa, sb, -db, -da, horizontal);

	// subtract intersection
	res -= intersect(vertical, horizontal);
	return res;

}

int main()
{
	int N, B, O;
	scanf("%d %d %d", &N, &B, &O);
	vector<Point> bishops[2], others[2];
	for(int i = 0; i < B; i++ ){
		int x, y;
		scanf("%d %d", &x, &y);
		int r = (x + y) % 2;
		int rr = (x + y - r) / 2;
		int cc = (x - y - r) / 2;
		bishops[r].push_back(Point(rr, cc));
	}

	for(int i = 0; i < O; i++ ){
		int x, y;
		scanf("%d %d", &x, &y);
		int r = (x + y) % 2;
		int rr = (x + y - r) / 2;
		int cc = (x - y - r) / 2;
		others[r].push_back(Point(rr, cc));
	}

	LL ans = 0;
	ans += cal(bishops[0], others[0], 1, N, 1, N);
	ans += cal(bishops[1], others[1], 0, N - 1, 1, N); 
	cout << ans << endl;
	return 0;
}
