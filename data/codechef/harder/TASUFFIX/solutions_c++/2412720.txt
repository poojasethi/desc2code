#ifdef _WIN32
#  define LL "%I64d"
#else
#  define LL "%Ld"
#endif

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <ctime>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <bitset>
#include <string>
#include <algorithm>
#include <complex>
#include <utility>
using namespace std;
#define null NULL
#define mp make_pair
#define pb(a) push_back(a)
#define sz(a) ((int)(a).size())
#define all(a) a.begin() , a.end()
#define fi first
#define se second
#define relaxMin(a , b) (a) = min((a),(b))
#define relaxMax(a , b) (a) = max((a),(b))
#define SQR(a) ((a)*(a))
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef long long ll;
// Dekartovoe derevo
struct node{
  bool flip;
  int lo , hi , sts;
  int height;
  node *l , *r;
  int len(){return abs(lo-hi)+1;}
  node(int lo=0 , int hi = 0):lo(lo),hi(hi){
   l = r = null;
   height = rand();
   flip = false;
   sts = len();
                                           }
};
node* root;
int get(node* vr){
  return vr ? vr->sts : 0;
}
void update(node* vr){
  if(!vr)return;
  vr->sts = vr->len() + get(vr->l) + get(vr->r);
}
void push_down(node* vr){
  if(!vr || !vr->flip)return;
  if(vr->l)vr->l->flip ^= true;
  if(vr->r)vr->r->flip ^= true;
  vr->flip = false;
  swap(vr->l , vr->r);
  swap(vr->lo , vr->hi);
}
vector<pii> out;
void print(node* vr){
  if(!vr)return;
  push_down(vr);
  if(vr->l)print(vr->l);
  out.pb(mp(vr->lo , vr->hi));
  if(vr->r)print(vr->r);
}
node* merge(node* f , node* s){
  if(!f || !s)
   return f ? f : s;
  push_down(f) , push_down(s);
  if(f->height < s->height){
   f->r = merge(f->r , s);
   update(f);
   return f;
                           }
  s->l = merge(f , s->l);
  update(s);
  return s;
}
void ensure(node*& vr , int how){
  if(!vr || how == 0)return;
  push_down(vr);
  if(get(vr->l) > how)ensure(vr->l , how);
  else{
   how -= get(vr->l);
   if(how == 0)return;
   if(how < vr->len()){
    int dlt = (vr->lo <= vr->hi)?1:-1;
    node *p1 = new node(vr->lo , vr->lo + (how-1)*dlt),
         *p2 = new node(vr->lo + how*dlt , vr->hi);
    p1->l = vr->l;
    p1->r = merge(p2 , vr->r);
    delete(vr);
    vr = p1;
    update(vr);
    return;
                      }
   how -= vr->len();
   ensure(vr->r , how);
      }
}
void split(node* vr , int how , node*& L , node*& R){
  if(!vr){
   L = R = null;
   return;
         }
  push_down(vr);
  int mid = get(vr->l);
  if(how <= mid){
   split(vr->l , how , L , vr->l);
   R = vr; update(R);
                }
  else{
   how -= mid + vr->len();
   split(vr->r , how , vr->r , R);
   L = vr; update(L);
      }
}
void create(int lo , int hi){
  root = new node(lo , hi);
}
void flip(int lo , int hi){
  ensure(root , lo);
  ensure(root , hi+1);
  node *L , *M , *R;
  split(root , hi+1 , M , R);
  split(M , lo , L , M);
  if(M)M->flip ^= true;
  root = merge(L , merge(M , R));
}
void shift(int lo , int hi){
  ensure(root , lo);
  ensure(root , hi+1);
  node *L , *M , *R;
  split(root , hi+1 , M , R);
  split(M , lo , L , M);
  root = merge(M , merge(L , R));
}
// </end>
#define MOD 1000000007
int N , M;
int TO_POW = 0;
map<int , int> id;
vi sum;
int get_pos(int w){
  int pos = 0;
  int gid = (--id.lower_bound(w+1))->se;
  if(gid)pos = sum[gid-1];
  if(out[gid].fi <= w)return pos + w - out[gid].fi;
  return pos + out[gid].fi - w;
}
int main(){
  scanf("%d%d" , &N , &M);
  create(0 , N-1);
  for(int i=0;i<M;++i){
   int op , lo , hi;
   scanf("%d%d%d" , &op , &lo , &hi);
   --lo , --hi;
   if(op == 0)shift(lo , hi);
   else flip(lo , hi);
                      }
  print(root);
  sum.resize(sz(out));
  for(int i=0;i<sz(sum);++i){
   sum[i] = abs(out[i].fi - out[i].se)+1;
   if(i)sum[i] += sum[i-1];
                            }
  for(int i=0;i<sz(out);++i)
   id[min(out[i].fi , out[i].se)] = i;
  vector<pii> TRY;
  for(int i=0;i<sz(out);++i){
   int dlt = (out[i].fi <= out[i].se) ? 1 : -1;
   if(i+1 < sz(out))TRY.pb(mp(out[i].se , out[i+1].fi));
   if(i-1 >= 0)TRY.pb(mp(out[i-1].se , out[i].fi));
   if(out[i].fi != out[i].se){
    int dlt = (out[i].fi < out[i].se)?1:-1;
    TRY.pb(mp(out[i].fi , out[i].fi + dlt));
    TRY.pb(mp(out[i].se - dlt , out[i].se));
                             }
                            }
  sort(all(TRY));
  TRY.erase(unique(all(TRY)) , TRY.end());
  TO_POW = N-1-sz(TRY);
  for(int i=0;i<sz(TRY);++i){
   int lo = TRY[i].fi , hi = TRY[i].se;
   int lo1 = lo+1 , hi1 = hi+1;
   if(hi1 == N)continue;
   if(lo1 == N){
    ++TO_POW;
    continue;
               }
   if(get_pos(lo1) < get_pos(hi1))
    ++TO_POW;
                            }
  ll ans = 1 , cur = 2;
  for(;TO_POW>0;TO_POW>>=1 , cur = (cur*cur)%MOD)
   if(TO_POW&1)ans = (ans*cur)%MOD;
  cout<<ans<<'\n';
  return 0;
}
