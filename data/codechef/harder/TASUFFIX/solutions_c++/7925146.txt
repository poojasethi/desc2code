#include <cmath>
#include <algorithm>
#include <vector>
#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <cstring>
#include <ctime>
using namespace std;
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Ford(i,a,b) for(int i=a;i>=b;i--)
#define Rep(i,c) for((type of c.begin()) i;i!=c.end();i++)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define sr(x) (int)x.size()
#define modul 1000000007
#define nmax 200010
#define BUG(x) {cout << #x << " = " << x << endl;}
#define PR(x,a,b) {cout << #x << " = "; For(_,a,b) cout << x[_] << ' '; cout << endl;}
#define fillchar(x,a,b,delta) For(_,a,b) x[_]=delta;
#define Bit(s,i) (s&(1<<i))
#define Two(x) (1<<x)
#define pii pair<int,int>
#define ll long long
#define e 1e-6
#define pi acos(-1)
int n,m,top;
struct node {
    int x,y,size,rev;
    node *le,*ri,*pa;
};
pii st[nmax],a[nmax];
typedef node *pointer;
pointer Root;
void SetLink(pointer x,pointer p,bool Isleft) {
    if (x!=NULL) x->pa=p;
    if (p==NULL) return;
    if (Isleft) p->le=x; else p->ri=x;
}
void count(pointer p) {
    p->size=abs(p->x-p->y)+1;
    if (p->le!=NULL) p->size+=p->le->size;
    if (p->ri!=NULL) p->size+=p->ri->size;
}
void reverse(pointer x) {
    x->rev=0;swap(x->x,x->y);
    pointer u=x->le;pointer v=x->ri;
    if (u!=NULL) {SetLink(u,x,false);u->rev=1-u->rev;} else x->ri=NULL;
    if (v!=NULL) {SetLink(v,x,true);v->rev=1-v->rev;} else x->le=NULL;
    count(x);
}
void DFS(pointer R) {
    if (R->rev) reverse(R);
    if (R->le!=NULL) DFS(R->le);
  //  printf("%d %d\n",R->x,R->y);
    top++;st[top].fi=R->x;st[top].se=R->y;
    if (R->ri!=NULL) DFS(R->ri);
}
 
 
void uptree(pointer x) {
    pointer p=x->pa,pp=p->pa;
    if (p->le==x) {
        if (x->ri!=NULL) SetLink(x->ri,p,true); else p->le=NULL;
        SetLink(p,x,false);
    } else {
        if (x->le!=NULL) SetLink(x->le,p,false); else p->ri=NULL;
        SetLink(p,x,true);
    }
    if (pp==NULL) x->pa=NULL; else SetLink(x,pp,pp->le==p);
    count(p);count(x);
}
void Splay(pointer &R,pointer x) {
    while (x->pa!=NULL) {
        pointer p=x->pa,pp=p->pa;
        if (pp==NULL) uptree(x);
        else if ((pp->le==p)==(p->le==x)) {uptree(p);uptree(x);}
        else {uptree(x);uptree(x);}
    }
    R=x;
}
 
pointer findk(pointer R,int x) {
    if (x>R->size) return NULL;
    if (R->rev) reverse(R);
    int u;if (R->le==NULL) u=0; else u=R->le->size;
    int leng=abs(R->x-R->y)+1;
    if (u+1==x) return R;
    if (u>=x) return findk(R->le,x);
    if (u+leng<x) return findk(R->ri,x-u-leng);
    int hs;
    if (R->x<R->y) hs=1; else hs=-1;
    x-=u;
    pointer p=new node; p->x=R->x+x*hs-hs;p->y=R->y;
    R->y=p->x-hs;
    SetLink(R->ri,p,false);p->le=NULL;
    SetLink(p,R,false);p->rev=R->rev;
    count(p);count(R);
    return p;
}
void Split(pointer &R,int u,int v,pointer &t1,pointer &t2,pointer &t3) {
    pointer y=findk(R,v+1);
    pointer x=findk(R,u);
    Splay(R,x);if (R->le!=NULL) {t1=R->le;R->le=NULL;t1->pa=NULL;count(R);} else t1=NULL;
    if (v==n) {t2=R;t3=NULL;return;}
    Splay(R,y);t2=R->le;t2->pa=NULL;R->le=NULL;count(R);t3=R;
}
void anion(pointer &R,pointer p) {
    if (R==NULL) {R=p;return;}
    if (p==NULL) return;
    Splay(p,findk(p,1));
    SetLink(R,p,true);R=p;count(R);
}
void Join(pointer &R,pointer t1,pointer t2,pointer t3) {
    R=t1;anion(R,t2);anion(R,t3);
}
 
int get(int x) {
    if (x>n) return 0;
    int l=1,r=top,pos;
    while (l<=r) {
        int mid=(l+r)/2;
        if (a[mid].fi<=x) {
            pos=mid;l=mid+1;
        } else r=mid-1;
    }
    return a[pos].se;
}
 
int check(int u,int v) {
    int x=get(u+1),y=get(v+1);
    if (x<y) return true;
    if (x>y) return false;
    if ((u<v)==(st[x].fi<st[x].se)) return true;
    return false;
}
 
int pow(int i,int j) {
    if (j==1) return 2;
    if (j==0) return 1;
    int tg=pow(i,j/2);tg=(tg*(ll)tg)%modul;
    if (j%2==1) tg=((ll)tg*i)%modul;
    return tg;
}
 
int main()
{
   // freopen("codechef.inp","r",stdin);
    scanf("%d%d",&n,&m);
    Root=new node; Root->pa=NULL;Root->le=NULL;Root->ri=NULL;Root->size=n;Root->x=1;Root->y=n;Root->rev=0;
    For(i,1,m) {
        int t,u,v;
        scanf("%d%d%d",&t,&u,&v);
        pointer t1,t2,t3;
        Split(Root,u,v,t1,t2,t3);
        if (t==0) Join(Root,t2,t1,t3); else {
            t2->rev=1;Join(Root,t1,t2,t3);
        }
    }
    DFS(Root);
    int ans=0;
    For(i,1,top) {a[i].fi=min(st[i].fi,st[i].se);a[i].se=i;}
    sort(a+1,a+top+1);
    For(i,1,top) {
      //  BUG(i);
        if (st[i].fi!=st[i].se) {
            ans+=abs(st[i].fi-st[i].se)-1;
            if (st[i].fi<st[i].se) ans+=check(st[i].se-1,st[i].se);
            else ans+=check(st[i].fi,st[i].fi-1);
         //   BUG(ans);
        }
        if (i==top) continue;
        ans+=check(st[i].se,st[i+1].fi);
      //  BUG(ans);
    }
    int res=pow(2,ans);
    cout << res;
    return 0;
}
 
 
 
 
 
 
 
 
 