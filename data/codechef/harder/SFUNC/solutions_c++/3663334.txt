#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<set>
#include<map>
#include<utility>
#include<vector>
#include<string>
#include<stack>
#include<queue>
#include<assert.h>
using namespace std;
unsigned long long MOD;
#define RANGE 1000001
vector < int > Primes;
vector < pair <unsigned long long, int> > ppf;
vector < pair < unsigned long long , bool > > divset;
bool sieve[RANGE+6];
void primeTable()
{
    int i,j;
    Primes.clear();
    Primes.push_back(2);
    int lim = sqrt((double) RANGE)+2;
    for (i=4; i<RANGE; i+=2) sieve[i] = true;
    for (i=3; i<lim; i+=2)
    {
        if (!sieve[i])
        {
            Primes.push_back(i);
            for (j=i*i; j<=RANGE; j += (i<<1)) sieve[j] = true;
        }
    }
    for (; i<RANGE; i+=2)
    {
        if (!sieve[i]) Primes.push_back(i);
    }
}
void factor(unsigned long long N)
{
    ppf.clear();
    unsigned long long n = N,p;
    int freq,i;
    for (i = 0; n != 1 && i < Primes.size(); ++i)
    {
        p = Primes[i];
        if (Primes[i] > sqrt((double) n)+1) break;
        if (n % p == 0)
        {
            freq = 0;
            while(n % p == 0)
            {
                n /= p;
                ++freq;
            }
            ppf.push_back(make_pair(p, freq));
        }
    }
    if (n>1) ppf.push_back(make_pair(n, 1));
    //for (i=0; i<ppf.size(); ++i) printf("%llu %d", ppf[i].first, ppf[i].second);
}
void divisor(unsigned long long N)
{
    factor(N);
    divset.clear();
    divset.push_back(make_pair(1,0));
    unsigned long long p,m;
    int i,j,f,exs,c;
    for (i=0; i<ppf.size(); ++i)
    {
        p = ppf[i].first, f = ppf[i].second;
        c = 1;
        m = 1, exs = divset.size();
        while(f--)
        {
            m *= p;
            for (j=0; j<exs; ++j) divset.push_back(make_pair(divset[j].first*m,(divset[j].second+c)&1));
            break;
            ++c;
        }
    }
    sort(divset.begin(), divset.end());
    //for (i=0; i<divset.size(); ++i) printf("%llu %d\n", divset[i].first, divset[i].second); puts("");
}
#define SIZE 13
unsigned long long temp[SIZE][SIZE];
unsigned long long multiply(unsigned long long a, unsigned long long b)
{
    unsigned long long result = 0;
    a %= MOD;
    b %= MOD;
    if ( a > b ) swap( a, b );
    while ( a )
    {
        if ( a % 2 )
        {
            result += b;
            if ( result >= MOD ) result -= MOD;
            a -= 1;
        }
        a /= 2;
        b += b;
        if ( b >= MOD ) b -= MOD;
    }
    return result;
    /*unsigned long long ret = 0;
    int i,j;
    a %= MOD;
    b %= MOD;
    if (a > b) swap(a,b);
    for (i=0; i<64; ++i)
    {
        if (((1LLU)<<i) > a) break;
        if (((1LLU)<<i) & a)
        {
            ret = (ret + b);
            if (ret >= MOD) ret -= MOD;
        }
        b <<= 1;
        if (b >= MOD) b -= MOD;
    }
    return ret;*/
}
unsigned long long bigmod(unsigned long long a, unsigned long long k)
{
    if (k == 0) return 1LLU;
    if (k % 2) return multiply(a,bigmod(a,k-1));
    unsigned long long ret = bigmod(a, k/2);
    return multiply(ret,ret);
}
class Matrix
{
public:
    int N;
    unsigned long long matrix[SIZE][SIZE];
    Matrix(int n) {N = n;}
    int getDim() {return N;}
    void setZer() {memset(matrix, 0, sizeof(matrix));}
    void setVal(unsigned long long array[][SIZE])
    {
        int i,j;
        for (i=0; i<N; ++i)
        {
            for (j=0; j<N; ++j) matrix[i][j] = array[i][j];
        }
    }
    Matrix operator+ (Matrix &A)
    {
        Matrix ret(N);
        int i,j;
        for (i=0; i<N; ++i)
        {
            for (j=0; j<N; ++j) ret.matrix[i][j] = (matrix[i][j] + A.matrix[i][j]) % MOD;
        }
        return ret;
    }
    Matrix operator* (Matrix &A)
    {
        Matrix ret(N);
        int i,j,k;
        unsigned long long temp;
        for (i=0; i<N; ++i)
        {
            for (j=0; j<N; ++j)
            {
                ret.matrix[i][j] = 0;
                for (k=0; k<N; ++k)
                {
                    temp = multiply(matrix[i][k],A.matrix[k][j]);
                    ret.matrix[i][j] = (ret.matrix[i][j] + temp)%MOD;
                }
            }
        }
        return ret;
    }
    void printMatrix()
    {
        int i,j;
        puts("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
        for (i=0; i<N; ++i)
        {
            for (j=0; j<N; ++j) printf("%3llu ", matrix[i][j]);
            puts("");
        }
        puts("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
    }
} base(SIZE), ret(SIZE);
vector < Matrix > VM;
/*Matrix bigmodmat(unsigned long long K)
{
    if (K==1) return base;
    if (K%2)
    {
        ret = bigmodmat(K-1);
        ret = ret * base;
        return ret;
    }
    ret = bigmodmat(K/2);
    ret = ret*ret;
    return ret;
}*/
unsigned long long bigmodmat2(unsigned long long K)
{
    unsigned long long ans[SIZE] = {0}, backup[SIZE] = {0};
    int S = ret.N;
    ans[S-1] = 1;
    ret = base;
    --K;
    int c = 0;
    int i,j;
    while (K)
    {
        if (K % 2)
        {
            for (i=0; i<S; ++i)
            {
                for (j=0; j<S; ++j) backup[i] = (backup[i] + multiply(VM[c].matrix[i][j], ans[j])) % MOD;
            }
            for (i=0; i<S; ++i)
            {
                ans[i] = backup[i];
                backup[i] = 0;
            }
            //ret = ret * VM[c];
        }
        K /= 2, ++c;
    }
    return ans[0];
}
void prep(int K, unsigned long long N = (1LLU<<50))
{
    memset(temp, 0, sizeof(temp));
    int i,j;
    temp[0][0] = temp[K+1][K+1] = 1;
    for (i=K; i>=0; --i)
    {
        temp[i][K+1] = 1;
        for (j=K; j>=0; --j) temp[i][j] = temp[i+1][j] + temp[i+1][j+1];
    }
    for (i=1; i<=K+1; ++i) temp[0][i] = temp[1][i];
    base.N = ret.N = K+2;
    base.setVal(temp);
    VM.clear();
    VM.push_back(base);
    for (i=1; i<=40; ++i)
    {
        if ((1LLU<<i) > N) break;
        base = base * base;
        VM.push_back(base);
    }
    base.setVal(temp);
}
unsigned long long sumnk(unsigned long long n, int k)
{
    //base.setVal(temp);
    return bigmodmat2(n);
}
int main()
{
    primeTable();
    unsigned long long N,ans,now;
    int K,i;
    while (scanf("%llu %d %llu", &N, &K, &MOD) != EOF)
    {
        prep(K,N);
        ans = 0;
        divisor(N);
        ans = sumnk(N,K);
        for (i=1; i<divset.size(); ++i)
        {
            now = multiply(sumnk(N/divset[i].first,K),bigmod(divset[i].first,K));
            if (divset[i].second) now = MOD - now;
            ans = (ans + now) % MOD;
        }
        printf("%llu\n", ans);
    }
    return 0;
}
