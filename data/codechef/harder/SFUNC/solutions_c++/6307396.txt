#include<iostream>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<utility>
#include<sstream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<string>
#include<cctype>
#include<queue>
#include<deque>
#include<stack>
#include<cmath>
#include<ctime>
#include<list>
#include<map>
#include<set>
#define pi (acos(-1.0))
#define Abs(a) (((a)<0) ? (-(a)) :(a) )
#define rep(i,n) for((i)=0;(i)<(n);(i)++)
#define Rep(i,n) for(int i=0;i<(n);i++)
#define Rrep(i,n) for(int i=n-1;i>=0;i--)
#define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--)
#define Pii pair<int,int>
#define PB push_back
#define Size(x) ((int)(x.size()))
#define lim 1000001
using namespace std;
typedef long long mint;
typedef unsigned long long umint;
mint prime[200],pw[200],cnt;
void TLE(bool val)
{
    while(!val){}
}
mint mulmod(mint a,mint b,mint m)
{
    mint ans=0;
    int i;
    for(i=62;i>=0;i--)
    {
        ans=(2*ans)%m;
        if((1LL<<i)&a)
            ans=(ans+b)%m;
    }
    return ans;
}
mint bgmd(mint val,mint ex,mint m)
{
    //cout<<"entering "<<val<<" "<<ex<<" "<<m<<endl;
    mint ans=1;
    while(ex)
    {
        if(ex%2)
            ans=mulmod(ans,val,m);
        ex/=2;
        val=mulmod(val,val,m);
        //cout<<"oria "<<ans<<" "<<ex<<" "<<val<<endl;
    }
    return ans;
}
mint f(mint n,int k,mint m)
{
    mint y[20],x[20],ans=0,a[20],b[20],g,val;
    int i,tot,j,sgn;
    rep(i,k+2)
    {
        x[i]=i;
        if(i==0)
            y[i]=0;
        else
            y[i]=(y[i-1]+bgmd(i,k,m))%m;
        //cout<<x[i]<<" "<<y[i]<<" seti"<<endl;
    }
    rep(i,k+2)
        {
            tot=0;
            sgn=1;
            rep(j,k+2)
            {
                if(i==j)
                    continue;
                a[tot]=Abs(x[i]-x[j]);
                if(x[i]<x[j])
                    sgn*=(-1);
                b[tot++]=Abs(n-x[j]);
                if(n<x[j])
                    sgn*=(-1);
                //cout<<a[tot-1]<<" dlksjflsdj "<<b[tot-1]<<endl;
            }
            rep(j,tot)
            {
                Rep(l,tot)
                {
                    g=__gcd(a[j],b[l]);
                    TLE(g);
                    a[j]/=g;
                    b[l]/=g;
                }
                //cout<<a[j]<<endl;
                assert(a[j]==1);
            }
            val=y[i];
            rep(j,tot)
                val=mulmod(val,b[j],m);
            ans=(ans+sgn*val)%m;
            ans=(ans+m)%m;
        }
    return ans;
}
mint orin;
mint fsol(int k,mint cur,mint m,int totp,int pos)
{
    //cout<<cur<<" "<<pos<<endl;
    if(pos<0)
    {
        //cout<<"gudd "<<cur<<" "<<k<<" "<<m<<" "<<f(cur,k,m)<<" "<<totp<<endl;
        mint val=f(cur,k,m);
        val=mulmod(val,bgmd(orin/cur,k,m),m);
        //cout<<val<<" "<<totp<<endl;
        if(totp%2)
            return (m-val)%m;
        else
            return val%m;
    }
    mint ans=0;
    for(int i=0;i<pw[pos]-1;i++)
    {
        cur*=prime[pos];
    }
    ans+=fsol(k,cur,m,totp+1,pos-1);
    ans=(ans%m+m)%m;
    cur*=prime[pos];
    ans+=fsol(k,cur,m,totp,pos-1);
    ans=(ans%m+m)%m;
    return ans;
}
int main()
{
	//freopen("in.txt","r",stdin);
	mint n,k,m;
	mint i;
	cin>>n>>k>>m;
	orin=n;
	for(i=2;i*i<=n;i++)
	{
	    if(n%i==0)
	    {
	        prime[cnt]=i;
	        //cout<<i<<endl;
	        while(n%i==0)
	        {
	            pw[cnt]++;
	            n/=i;
	        }
	        //cout<<pw[cnt]<<endl;
	        cnt++;
	    }
	}
	if(n>1)
	{
	    //cout<<n<<endl;
	    prime[cnt]=n;
	    pw[cnt++]=1;
	}
	cout<<fsol(k,1,m,0,cnt-1)<<endl;
	return 0;
}
 
 