#include <cstdio>
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <string>
#include <ctime>
#include <cassert>
#include <utility>

using namespace std;

#define MAXN 100050

int N, M;
vector<pair<int, long long> > A[MAXN];
long long R;
long long P[MAXN];
bool v[MAXN];
int lvl[MAXN];
long long S[MAXN];
map<long long, int> H;
long long ans;
int E;
int a, b;

long long getNext() {
    return R = R * 1337LL + 12345LL;
}

void dfs2(int node, int prev) {
    v[node] = true;
    S[node] = P[node];
    for (vector<pair<int, long long> > :: iterator it = A[node].begin(); it != A[node].end(); it++) {
        if (!v[it->first]) {
            dfs2(it->first, node);
            S[node] ^= S[it->first];
        }
    }
}

void add(long long s) {
    long long crt = 0;
    if (H.count(s)) {
        crt = H[s];
    }
    H[s] = crt + 1;
}

void dfs3(int node, int prev) {
    v[node] = true;

    for (vector<pair<int, long long> > :: iterator it = A[node].begin(); it != A[node].end(); it++) {
        if (it->first != prev) {
            if (!v[it->first]) {
                long long s = S[it->first];
                if (s == 0) {
                    E++;
                    ans += M - E;
                }
                else {
                    if (H.count(s) > 0) {
                        ans += H[s];
                    }
                    add(s);
                }
                dfs3(it->first, node);
            }
            else if (lvl[it->first] < lvl[node]) {
                if (H.count(it->second) > 0) {
                    ans += H[it->second];
                }
                add(it->second);
            }
        }
    }
}

void dfs(int node, int prev) {
    if (prev == -1) {
        lvl[node] = 0;
    }
    else {
        lvl[node] = lvl[prev] + 1;
    }
    v[node] = true;
    for (vector<pair<int, long long> > :: iterator it = A[node].begin(); it != A[node].end(); it++) {
        if (it->first != prev) {
            if (!v[it->first]) {
                dfs(it->first, node);
            }
            else if (lvl[it->first] < lvl[node]) {
                P[it->first] ^= it->second;
                P[node] ^= it->second;
            }
        }
    }
}

int main() {
//	freopen("date.in", "r", stdin);
//	freopen("date.out","w", stdout);
	
	scanf("%d %d", &N, &M);
	R = time(0);
	for (int i = 0; i < M; i++) {
	    scanf("%d %d", &a, &b);
	    a--; b--;
	    long long c = getNext();
	    A[a].push_back(make_pair(b, c));
	    A[b].push_back(make_pair(a, c));
	}
	
	dfs(0, -1);
	
	fill(v, v + N, false);
	dfs2(0, -1);
	
	fill(v, v + N, false);
	ans = 0;
	dfs3(0, -1);
	
	cout << ans << '\n';
	
	return 0;
}
