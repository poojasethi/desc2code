#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <climits>
#include <ctime>
#include <cassert>
#include <cctype>
#include <algorithm>
#include <numeric>
#include <map>
#include <set>
#include <queue>
#include <string>
#include <vector>
#include <bitset>

#define X first
#define Y second
#define pb push_back
#define bit(x) (1 << (x))
#define bnum(x) (__builtin_popcount(x))
#define sqr(x) ((x) * (x))
#define sz(x) ((int)(x.size()))
#define PQ priority_queue

using namespace std;
typedef long long LL;
typedef pair<int, int> pii;
typedef vector<int> vi;

template <class T> inline void chkmin(T &a, T b) {
	if (b < a) a = b;
}
template <class T> inline void chkmax(T &a, T b) {
	if (a < b) a = b;
}

#define MX 100005
int n, num, brdg;
int d[MX], low[MX], dp[MX];

vector<pii> adj[MX];
#define MOD 1000000007
LL val[MX], val1[MX], val2[MX];

void add(int p, int x) {
	for (; p <= n; p += p & -p) {
		if (x > 0) val[p]++;
		else val[p]--;
		(val1[p] += 1LL * x * x * x % MOD) %= MOD;
		(val2[p] += 1LL * x * abs(x) % MOD) %= MOD;
	}
}
pii get(int p, int &x) {
	LL rlt1 = 0, rlt2 = 0;
	x = 0;
	for(; p; p -= p & -p) {
		x += val[p];
		rlt1 += val1[p], rlt2 += val2[p];
	}
	
	return pii(rlt1 % MOD, rlt2 % MOD);
}

void delval(int p) {
	int x, q = p;
	pii tp = get(p, x);
	for (; p <= n; p += p & -p) {
		val[p] -= x;
		(val1[p] -= tp.X) %= MOD, (val2[p] -= tp.Y) %= MOD;
	}
	for (p = q + 1; p <= n; p += p & -p) {
		val[p] += x;
		(val1[p] += tp.X) %= MOD, (val2[p] += tp.Y) %= MOD;
	}
}

map<pii, int> H;
void count(int p) {
	int x;
	pii tp = get(p, x);
	if (tp.X < 0) tp.X += MOD;
	if (tp.Y < 0) tp.Y += MOD;
	//cout << p << " " << tp.X << " " << tp.Y << endl;     
	if (x == 0) return;                                             
	H[tp]++;
	if (x == 1 && H[tp] == 1) H[tp] = 2;
}

void DFS(int u, int dep) {
	int i, v;
	d[u] = low[u] = ++num;
	dp[u] = dep;
	
	for (i = 0; i < sz(adj[u]); i++) {
		v = adj[u][i].X;
		if (d[v] > 0 && dp[v] < dp[u] - 1) {
			chkmin(low[u], d[v]);
			add(dp[v], adj[u][i].Y);
			add(dp[u], -adj[u][i].Y);
		}
	}
	
	for (i = 0; i < sz(adj[u]); i++) {
		v = adj[u][i].X;
		if (!d[v]) {
			delval(dep);
			DFS(v, dep + 1);
			count(dep);
			chkmin(low[u], low[v]);
			if (low[v] > d[u]) brdg++;
		}
	}
}

main() {
	#ifndef ONLINE_JUDGE
	freopen("data1.in", "r", stdin);
	freopen("out.txt", "w", stdout);
	#endif

	int i, j, k, m, u, v;
	scanf("%d%d", &n, &m);
	for (i = 0; i < m; i++) {
		scanf("%d%d", &u, &v);
		adj[u].pb(pii(v, i + 1));
		adj[v].pb(pii(u, i + 1));
	}
	
	DFS(1, 1);
	LL ans = 1LL * brdg * (m - 1) - 1LL * brdg * (brdg - 1) / 2;
//	cout << brdg << endl;
	
	for (map<pii, int>::iterator it = H.begin(); it != H.end(); it++) {
		//cout <<it->Y << endl;
		ans += 1LL * (it->Y) * (it->Y - 1) / 2;
	}
	cout << ans << endl;
}