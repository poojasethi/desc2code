#pragma comment(linker,"/STACK:16777216")
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100005
int parent[MAXN],visited[MAXN],low[MAXN],disc[MAXN];
int visited2[MAXN],degree[MAXN];
vector<int> adj[MAXN];
int n,m;
int t;
long long num_bridges;
void dfs(int u)
{
    visited[u]++;
    disc[u] = low[u] = ++t;
    for(vector<int>::iterator it=adj[u].begin(); it!=adj[u].end(); ++it)
    {
        int v = *it;
        if(!visited[v])
        {
            parent[v] = u;
            dfs(v);
            low[u] = min(low[u],low[v]);
            if(low[v]>disc[u])
            {
                num_bridges++;
                degree[u]--;
                degree[v]--;
            }
        }
        else if(v!=parent[u])
        {
            low[u] = min(low[u],disc[v]);
        }
    }
}
long long path_len,ans;
int dfs2(int u,int p)
{
    visited2[u]++;
    if(degree[u]>2)
    {
        ans += path_len*(path_len-1)/2;
        for(vector<int>::iterator it=adj[u].begin(); it!=adj[u].end(); ++it)
        {
            int v = *it;
            if(!visited2[v]&&(low[v]<=disc[u])&&(low[u]<=disc[v]))
            {
                path_len = 1;
                dfs2(v,u);
            }
        }
    }
    else
    {
        for(vector<int>::iterator it=adj[u].begin(); it!=adj[u].end(); ++it)
        {
            int v = *it;
            if(v!=p && (low[v]<=disc[u])&&(low[u]<=disc[v]))
            {
                if(visited2[v])
                {
                    path_len++;
                    ans += path_len*(path_len-1)/2;
                    path_len = 0;
                }
                else
                {
                    path_len++;
                    dfs2(v,u);
                }
            }
        }
    }
}
int main()
{
   scanf("%d%d",&n,&m);
    for(int i=0; i<m; i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        adj[u].push_back(v);
        degree[u]++;
        adj[v].push_back(u);
        degree[v]++;
    }
    // count bridges
    dfs(1);
    // we can remove any 2 bridges
    ans += num_bridges * (num_bridges-1)/2;
    // we can remove one bridge and any non-bridge edge
    ans += num_bridges * (m-num_bridges);
    // run dfs in each biconnected component to find paths
    for(int i=1; i<=n; i++)
    {
        if(!visited2[i]&&degree[i]>2)
        {
            dfs2(i,0);
        }
    }
    for(int i=1; i<=n; i++)
    {
        if(!visited2[i])
        {
            dfs2(i,0);
        }
    }
    printf("%lld\n",ans);
    return 0;
}
