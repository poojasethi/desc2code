// Tapopadma Tripathy , date : 15/10/2014
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;

int const M = 1e5+2;
int cases,capacity,no_men,wt_men,x,y,X[M],Y[M],no_node,vertex,no_round_trip,minv;
bool visited[M];
double distanc,food_need[M],food,fuel,food_last_trip,food_round_trip,new_food,mn;

int main() {
    cin>>cases;
    while(cases--) {
        cin>>capacity;
        memset(visited,0,sizeof visited);
        no_men = 0;
        while(1) {
            cin>>wt_men;
            if(wt_men == -1) break;
            ++no_men;
            capacity -= wt_men;
        }
        no_node = 0;
        while(1) {
            cin>>x>>y;
            if(!x and !y) break;
            X[no_node] = x , Y[no_node] = y;
            ++no_node;
        }
        for(int i=0;i<no_node;++i) food_need[i] = -1 ;
        vertex = no_node - 1 ;
        food_need[vertex] = 0;
        while(1) {
            visited[vertex] = 1;mn = -1 , minv = 0;
            if(vertex == 0) {
                cout<<ceil(food_need[0])<<'\n';
                break;
            }
            for(int i=0;i<no_node;++i) {
                if(!visited[i]) {
                    distanc = sqrt((X[vertex]-X[i])*(X[vertex]-X[i])+(Y[vertex]-Y[i])*(Y[vertex]-Y[i]));
                    food = no_men*distanc;
                    fuel =  distanc;
                    /*If a single trip is sufficient to meet the need of food at this rig*/
                    if(food+fuel+food_need[vertex] <= capacity) {
                        if(food_need[i] == -1 or food+food_need[vertex] < food_need[i]) {
                            food_need[i] = food+food_need[vertex];
                        }
                    }
                    /* In case if we need round trips to store food at the rig as per huge need at this rig*/
                    else if(2*food+fuel < capacity) {
                        food_last_trip = capacity - food - fuel;
                        food_round_trip = (food_need[vertex]-food_last_trip);
                        no_round_trip = ceil(food_round_trip/(capacity-2*food-fuel));
                        new_food = no_round_trip*2*food + food*1 + food_need[vertex];
                        if(food_need[i] == -1 or new_food < food_need[i]) {
                            food_need[i] = new_food;
                        }
                    }
                    if((mn == -1 or mn > food_need[i]) and food_need[i]!=-1) {
                        mn = food_need[i] , minv = i;
                    }
                }
            }
            vertex = minv;
        }
    }
    return 0;
}
