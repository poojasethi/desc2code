#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <bitset>
#include <sstream>
#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>

using namespace std;

#define forn(i, n) for(int i = 0; i < int(n); ++i)
#define for1(i, n) for(int i = 1; i <= int(n); ++i)
#define ford(i, n) for(int i = int(n) - 1; i >= 0; --i)
#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)
#define forit(it, s) for(typeof((s).begin()) it = (s).begin(); it != (s).end(); ++it)
#define sz(v) int((v).size())
#define all(v) (v).begin(), (v).end()
#define pb push_back
#define X first
#define Y second
#define mp make_pair
template<typename T> inline T abs(T a){ return ((a < 0) ? -a : a); }
template<typename T> inline T sqr(T a){ return a * a; }

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

const int INF = (int)1E9 + 7;
const ld EPS = 1E-9;
const ld PI = 3.1415926535897932384626433832795;

const int NMAX = 2000000;


//node of the tree in ukkonen algo
struct node{
    int l, r, par, link, dep, idx;
    map<char, int> next;

    node() {
        l = r = par = dep = 0;
        link = -1, idx = -1;
    }

    node(int l, int r, int par, int dep) : l(l), r(r), par(par), dep(dep){
        link = -1, idx = -1;
    }
};

//position on the tree, vertex and length of the path of the edge
struct position{
    int V, L, dep;
    position() {
        V = L = dep = 0;
    }
    position(int V, int L, int dep) : V(V), L(L), dep(dep){
    } 
};


char s[NMAX];
int head, tail;

node t[2 * NMAX + 1];
int szt;

//returns length of the edge
int leng(int v){
    return t[v].r - t[v].l;
}

//function that adds edge to parent, creates new vertex
int add_edge_to_parent(int l, int r, int parent){
    int nidx = szt++;
    t[nidx] = node(l, r, parent, t[parent].dep + (r - l));
    
    if(r == NMAX){
        t[nidx].idx = NMAX - t[nidx].dep;
        t[parent].idx = max(t[parent].idx, t[nidx].idx);
    }
    
    return (t[parent].next[s[l]] = nidx);
}

//function that adds edge to parent, but doesn't create new vertex
//it uses vertex nidx
int add_edge_to_parent_idx(int l, int r, int parent, int nidx){
    t[nidx].l = l;
    t[nidx].r = r;
    t[nidx].par = parent;
    t[nidx].dep = t[parent].dep + (r - l);
    
    if(r == NMAX){
        t[nidx].idx = NMAX - t[nidx].dep;
        t[parent].idx = max(t[parent].idx, t[nidx].idx);
    }
    
    return (t[parent].next[s[l]] = nidx);
}

//split edge on two parts
int split_edge(position pos){
    int v = pos.V, up = pos.L, down = leng(v) - up;

    if(up == 0) return v;
    if(down == 0) return t[v].par;

    int mid = add_edge_to_parent(t[v].l, t[v].l + down, t[v].par);
    t[v].l += down, t[v].par = mid;
    t[mid].next[s[t[v].l]] = v;
    t[mid].idx = t[v].idx;
    
    return mid;
}

//function that move current position in the tree by one character
//acts like fast go down, but it doesn't know if the character can be read
position read_char(position pos, char c){
    int v = pos.V, up = pos.L;
    if(up > 0)
        return s[t[v].r - up] == c ? position(v, up - 1, pos.dep + 1) : position(-1, -1, -1);
    else{
        int nextv = t[v].next.count(c) ? t[v].next[c] : -1;
        return nextv != -1 ? position(nextv, leng(nextv) - 1, pos.dep + 1) : position(-1, -1, -1);
    }
}

//function that reads some substring from some vertex
//this function knows that this substring can be found from the position
position fast_go_down(int v, int l, int r){
    if(l == r) return position(v, 0, t[v].dep);
    while(true){
        v = t[v].next[s[l]];
        if(leng(v) >= r - l)
            return position(v, leng(v) - (r - l), t[v].dep - leng(v) + (r - l));
        l += leng(v);
    }
    throw;
}

//function that returns suffix link from the vertex
int link(int v){
    if(t[v].link == -1)
        t[v].link = split_edge(fast_go_down(link(t[v].par), t[v].l + int(t[v].par == 0), t[v].r));
    return t[v].link;
}

//global deque of suffixes, and current sum of all edges in suffix tree
//all suffixes stored by decreasing of their length
deque<int> suffixes;
li cntSubstrings;

//add char to position in the tree
//step of ukkonen algo
position add_char_to_tree(position pos, int i){
    while(true){
        position npos = read_char(pos, s[i]);
        if(npos.V != -1)
            return npos;

        int mid = split_edge(pos);

        int leaf = add_edge_to_parent(i, NMAX, mid);
        suffixes.pb(leaf);
        cntSubstrings += leng(leaf);

        int nmid = link(mid);
        pos = position(nmid, 0, t[nmid].dep);

        if(mid == 0)
            return pos;
    }
    throw;
}

node root;
position pos;

//initialize of the tree
void make_tree(){
    szt = 0; suffixes = deque<int>(); cntSubstrings = 0;
    root = node(-1, -1, -1, 0), root.link = 0, t[szt++] = root;
    pos = position(0, 0, 0);
}

//function that adds char to the tree (add operation)
void add_char(char c){
    s[tail++] = c;
    pos = add_char_to_tree(pos, tail - 1);
}

//function that deletes inner vertex of degree 2 from the tree
void delete_vertex(int v){
    assert(v > 0);
    assert(sz(t[v].next) == 1);
    
    int posdown = leng(pos.V) - pos.L;
    
    int par = t[v].par, npar = t[v].next.begin()->Y;
    int nleaf = t[npar].idx;
    
    #ifdef ssu1
    cout << "delete " << v << endl;
    cout << "leaf = " << nleaf << endl;
    #endif
    
    int nleng = leng(v) + leng(npar);
    
    if(!t[npar].next.empty()){
        add_edge_to_parent_idx(nleaf + t[t[v].par].dep, nleaf + t[t[v].par].dep + nleng, par, npar);
    }else{
        add_edge_to_parent_idx(nleaf + t[t[v].par].dep, NMAX, par, npar);
    }
    
    if(pos.V == v){
        pos.V = npar, pos.L = leng(npar) - posdown;
    }else if(pos.V == npar){
    //    cerr << "down = " << posdown + leng(v) << endl;
        pos.L = leng(npar) - (posdown + leng(v));
    }
}

//returns suffix link position to position pos
//as link but uses positions terms
position position_link(position pos){
//    if(pos.dep == 0) return pos;
    
    assert(pos.dep > 0);
    int v = pos.V, l = t[v].l, r = t[v].r - pos.L;
    
//    cerr << v << " " << l << " " << r << " " << t[v].par << endl;
    
    position ans = fast_go_down(link(t[v].par), l + int(t[v].par == 0), r);
    
//    cerr << ans.V << " " << leng(ans.V) - ans.L << " " << ans.dep << endl;
    
    assert(ans.dep + 1 == pos.dep);
    return ans;
}

//function that deletes largest suffix from the tree
//so it makes delete operation
void delete_char(){
    assert(head < tail);
    assert(sz(suffixes) > 0);
    
    int deepest = suffixes.front();
    
    assert(t[deepest].r == NMAX);
    
    if(pos.V == deepest){
        #ifdef ssu1
        cout << 'y' << endl;
        #endif
        
        cntSubstrings -= leng(deepest);
        pos = position_link(pos);
        int v = pos.V, up = pos.L, down = leng(v) - up;
        
        int cur = sz(suffixes);
        t[deepest].l = head + cur + t[t[deepest].par].dep;
        t[deepest].dep = t[t[deepest].par].dep + leng(deepest);
        t[deepest].idx = head + cur;
        
        if(v == deepest)
            pos.L = leng(v) - down;
        
        suffixes.pb(deepest);
        cntSubstrings += leng(deepest);
    }else{
        #ifdef ssu1
        cout << 'x' << endl;
        #endif
        
        int par = t[deepest].par;
        t[par].next.erase(s[t[deepest].l]);
        cntSubstrings -= leng(deepest);
        
        if(par > 0 && sz(t[par].next) == 1)
            delete_vertex(par);
    }
    
    head++;
    suffixes.pop_front();
}

//function that returns the number of distinct substrings
li count_distinct_substrings(){
    li ans = cntSubstrings;
//    int szs = tail - head;

    ans -= li(NMAX) * sz(suffixes);
    ans += li(tail) * sz(suffixes);
    
    return ans;        
}

//just debug function, you can debug tree with it
void print(int v, int L){
    printf("%d (leaf = %d) (dep = %d = %d): ", v, t[v].idx, t[v].dep, L);
    
    assert(t[v].dep == L);
    
    forit(it, t[v].next){
        int u = it->Y;
        
        string curs;
        int l = t[u].l, r = min(tail, t[u].r);
        fore(i, l, r)
            curs += s[i];
        
        printf("%s (%d %d) %d; ", curs.c_str(), t[u].l, t[u].r, u);
    }
    printf("\n");
    
    forit(it, t[v].next){
        int u = it->Y;
        print(u, L + leng(u));
    }
}

const int mod = 1000000000 + 7;

int main() {
    #ifdef ssu1
    freopen("input.txt", "rt", stdin);
    //freopen("output.txt", "wt", stdout);
    #endif
    
    make_tree();

    int n;
    cin >> n;
    
//    print(0, 0);
    li ans = 0;
    forn(i, n){
        char type;
        scanf(" %c ", &type);
        
        if(type == '+'){
            char c;
            scanf(" %c ", &c);
            
            add_char(c);
        }else{
            assert(type == '-');
            
            delete_char();
        }

        #ifdef ssu1
        cout << "suffixes: " << sz(suffixes) << endl;
        forn(i, sz(suffixes))
            cout << suffixes[i] << " ";
        cout << endl;            
        cout << "pos:" << pos.V << " " << leng(pos.V) - pos.L << " " << pos.dep << endl; 
        print(0, 0); printf("\n");
        
        cout << "substr = " << count_distinct_substrings() << endl;
        cout << endl;
        #endif
        
        ans = (ans + count_distinct_substrings()) % mod;
//        printf("%I64d\n", ans);
//        if(i > 5) break;
    }
    cout << ans << endl;
//    cerr << clock() << endl;    
    return 0;
}