#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cmath>
#include <queue>
#include <list>
#include <algorithm>
#include <map>
#include <set>
#include <ctime>
#include <cassert>
#include <stack>
using namespace std;
 
#define ALL(c) (c).begin(),(c).end()
#define PRESENT(c,x) (find(c.begin(),c.end(),x) != (c).end())
#define REP(i,n) for (int i=0;i<(n);i++)
#define INIT(a,v) memset(a,v,sizeof(a))
template<class A, class B> A cvt(B x) { stringstream ss; ss<<x; A y; ss>>y; return y; }
 
typedef long long int64;
typedef pair<int,int> PII;
 
/* modified suffix tree implementation from http://e-maxx.ru/algo/ukkonen */
 
string s;
int n;
 
struct node {
	int l, r, par, link;
	//map<char,int> next;
	int next[26];
	int ch;
	int linked;
 
	node (int l=0, int r=0, int par=-1)
		: l(l), r(r), par(par), link(-1) { ch=0; INIT(next,-1); linked=0; }
	int len()  {  return r - l;  }
	int &get (char c) {
		//if (!next.count(c))  next[c] = -1;
		return next[c-'a'];
	}
};
 
vector<node> t;
int sz,leaves;
 
struct state {
	int v, pos;
	state (int v, int pos) : v(v), pos(pos)  {}
};
state ptr (0, 0);
 
state go (state st, int l, int r) {
	while (l < r)
		if (st.pos == t[st.v].len()) {
			st = state (t[st.v].get( s[l] ), 0);
			if (st.v == -1)  return st;
		}
		else {
			if (s[ t[st.v].l + st.pos ] != s[l])
				return state (-1, -1);
			if (r-l < t[st.v].len() - st.pos)
				return state (st.v, st.pos + r-l);
			l += t[st.v].len() - st.pos;
			st.pos = t[st.v].len();
		}
	return st;
}
 
int split (state st) {
	if (st.pos == t[st.v].len())
		return st.v;
	if (st.pos == 0)
		return t[st.v].par;
	node v = t[st.v];
	int id = sz++;
	t.push_back(node (v.l, v.l+st.pos, v.par));
	t[v.par].get( s[v.l] ) = id;
	t[id].get( s[v.l+st.pos] ) = st.v;
	t[id].ch=1;
	t[st.v].par = id;
	t[st.v].l += st.pos;
	return id;
}
 
int get_link (int v) {
	if (t[v].link != -1)  return t[v].link;
	if (t[v].par == -1)  return 0;
	int to = get_link (t[v].par);
	int sp = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));
	t[v].link = sp;
	if (sp!=-1) t[sp].linked++;
	return t[v].link;
}
 
void print(int v, int pos, string path="") {
	path+=s.substr(t[v].l,min(t[v].r,pos)-t[v].l);
	printf("%d: %d-%d %s\n",v,t[v].l,t[v].r,path.c_str());
	for (char c='a';c<='z';c++) if (t[v].get(c)!=-1) {
		print(t[v].get(c),pos,path);
	}
}
 
int64 substr;
 
queue<int> qleaves;
 
void tree_extend (int pos) {
	substr+=leaves;
	for(;;) {
		state nptr = go (ptr, pos, pos+1);
		if (nptr.v != -1) {
			ptr = nptr;
			return;
		}
 
		int mid = split (ptr);
		int leaf = sz++;
		substr++;
		leaves++;
		qleaves.push(leaf);
		t.push_back( node (pos, n, mid));
		t[mid].get( s[pos] ) = leaf;
		t[mid].ch++;
 
		ptr.v = get_link (mid);
		ptr.pos = t[ptr.v].len();
		if (!mid)  break;
	}
}
 
void tree_delete(int pos) {
	assert(!qleaves.empty());
	int leaf = qleaves.front();
	qleaves.pop();
	int par=t[leaf].par;
	while (t[leaf].ch==0) {
		if (ptr.v!=leaf) {
			assert(0<=par && par<sz);
			int l=t[leaf].l;
			t[par].get(s[l])=-1;
			substr-=min(t[leaf].r,pos)-t[leaf].l;
			t[par].ch--;
			assert(t[leaf].linked==0);
			int ll = t[leaf].link;
			if (ll!=-1) t[ll].linked--;
			leaf=par;
			par=t[leaf].par;
		} else {
			if (ptr.pos==min(t[leaf].r,pos)-t[leaf].l) {
				break;
			}
			int mid = split (ptr);
			ptr.v=mid;
			int l=t[leaf].l;
			substr-=min(t[leaf].r,pos)-l;
			t[mid].get(s[l])=-1;
			t[mid].ch--;
			assert(t[leaf].linked==0);
			int ll = t[leaf].link;
			if (ll!=-1) t[ll].linked--;
 
			t[leaf]=t[mid];
			t[t[mid].par].get( s[t[mid].l] )=leaf;
			t.pop_back();
			sz--;
 
			break;
		}
		assert(0<=leaf && leaf<sz);
	}
	if (t[leaf].ch!=0) leaves--;
	else {
		qleaves.push(leaf);
		// retreat ptr from leaf
		int to = (t[leaf].par==0)?0:t[t[leaf].par].link;
		ptr = go (state(to,t[to].len()), t[leaf].l + (t[leaf].par==0), t[leaf].r);
		t[leaf].l=pos-t[leaf].len();
		t[leaf].r=n;
	}
}
 
char op[1000005],ch[1000005];
int q;
 
int main() {
	scanf("%d",&q);
	n=0;
	int add=0,del=0;
	s="";
	REP (i,q) {
		scanf(" %c",&op[i]);
		if (op[i]=='+') {
			scanf(" %c",&ch[i]);
			s+=ch[i];
			n++;
		}
	}
	t.reserve(7000000);
	t.push_back(node(0));
	sz = 1;
	leaves = 0;
	substr = 0;
	add=0; del=0;
	int64 sum=0;
	//print(0,add);
	for (int i=0; i<q; ++i) {
		if (op[i]=='+') {
			tree_extend(add);
			add++;
		} else {
			//assert(add>del+1);
			tree_delete(add);
			del++;
			if (add==del) {
				leaves=0;
				substr=0;
				while (!qleaves.empty()) qleaves.pop();
				t[0]=node(0);
			}
		}
		//print(0,add);
		//cout << substr << endl;
		sum=(sum+substr)%1000000007;
	}
	printf("%lld\n",sum);
	return 0;
}
 
