#include <iostream>
#include <vector>
#include <queue>
#include <cstdio>
#include <memory>
#include <algorithm>
#include <memory.h>
#include <cstring>
 
using namespace std;
 
#define MX 1000006
#define MOD 1000000007
 
struct state{
	int v, p;
	state(int v, int p): v(v), p(p) {}
}ptr(0, 0);
 
struct node {
	int l, r, par, link;
	int nxt[26], ch;
	node(int l = 0, int r = 0, int par = -1):
		l(l), r(r), par(par), link(-1), ch(0) {memset(nxt, -1, sizeof(nxt)); }
	inline int len() { return r - l; }
	inline int &get(char c) { return nxt[c - 'a']; }
};
 
vector <node> t;
queue <int> qleaf;
int sz = 1, n, leaves;
long long rlt, substr;
string s;
 
int add_edge(int l, int r, int par) {
	int id = sz++;
	t.push_back(node(l, r, par));
	t[par].ch++;
	t[par].get(s[l]) = id;
	return id;
}
 
int split(state st) {
	if (st.p == t[st.v].len()) return st.v;
	if (!st.p) return t[st.v].par;
	
	int v = st.v;
	int id = add_edge(t[v].l, t[v].l + st.p, t[v].par);
	t[t[v].par].ch--;
	t[id].ch++;
	t[id].get(s[t[v].l + st.p]) = v;
	t[v].par = id;
	t[v].l += st.p;
	return id;
}
 
state go(state st, int l, int r) {
	while (l < r) {
		if (st.p == t[st.v].len()) {
			st = state(t[st.v].get(s[l]), 0);
			if (st.v == -1) return st;
		}
		if (s[l] != s[t[st.v].l + st.p]) return state(-1, -1);
		if (r - l < t[st.v].len() - st.p) return state(st.v, st.p + r - l);
		l += t[st.v].len() - st.p;
		st.p = t[st.v].len();
	}
	return st;
}
 
int get_link(int id) {
	if (t[id].link != -1) return t[id].link;
	if (t[id].par == -1) return 0;
	int to = get_link(t[id].par);
	return t[id].link = split(go(state(to, t[to].len()), t[id].l + (t[id].par == 0), t[id].r));
}
 
void tree_extend(int pos) {
	while (true) {
		state tptr = go(ptr, pos, pos + 1);
		if (tptr.v != -1) {
			ptr = tptr;
			break;
		}
		
		int id = split(ptr);
		leaves++;
		qleaf.push(add_edge(pos, n, id));
		
		ptr.v = get_link(id);
		ptr.p = t[ptr.v].len();
		if (!id) break;
	}
	substr += leaves;
}
 
void tree_delete(int pos) {
	int leaf = qleaf.front();
	int par = t[leaf].par;
	qleaf.pop();
	while (t[leaf].ch == 0) {
		if (ptr.v != leaf) {
			substr -= min(pos, t[leaf].r) - t[leaf].l;
			t[par].ch--;
			t[par].get(s[t[leaf].l]) = -1;
			leaf = par;
			par = t[leaf].par;
		} else {
			substr -= min(pos, t[leaf].r) - t[leaf].l - ptr.p;
			t[leaf].r = t[leaf].l + ptr.p;
			
			int to = (t[leaf].par)? t[t[leaf].par].link: 0;
			ptr = go(state(to, t[to].len()), t[leaf].l + (t[leaf].par == 0), t[leaf].r);
			qleaf.push(leaf);
			t[leaf].link = -1;
			t[leaf].l = pos - t[leaf].len();
			t[leaf].r = n;
			return;
		}
	}
	leaves--;
}
 
char op[MX], c;
int add, Q;
 
main() {
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	scanf("%d", &Q);
	t.reserve(MX * 2 + 105);
	t.push_back(node());
	
	for (int i = 0; i < Q; i++) {
		scanf(" %c", op + i);
		if (op[i] == '+') {
			scanf(" %c", &c);
			s += c;
			n++;
		}
	}
	
	for (int i = 0; i < Q; i++) {
		if (op[i] == '+') tree_extend(add++);
		else tree_delete(add);
		rlt = (rlt + substr) % MOD;
	}
	cout << rlt << endl;
}
 