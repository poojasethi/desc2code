#include<cassert>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
 
const int INF = 1000000000, C = 26, N = 1000005, MOD = 1000000007;
 
int pos;
 
struct Node {
	int l, r;
	
	Node *suf, *ch[C];
 
	int dgr;
 
	Node *fa;
	
	Node (int l = -1, int r = INF) : l(l), r(r) {
		suf = 0;
		memset(ch, 0, sizeof(ch));
		dgr = 0;
		fa = NULL;
	}
 
	int len() {
		return min(r, pos + 1) - l;
	}
};
 
int top;
 
Node pool[N << 1];
 
Node *root, *nxtSuf, *cur;
 
int text[N];
 
int remCnt, curP, curLen;
 
long long size, live;
 
queue<Node*> leaves;
 
void init() {
	top = 0, pos = -1;
	remCnt = 0, curP = 0, curLen = 0;
	nxtSuf = NULL;
	root = cur = new(pool + (top++)) Node(-1, -1);
	size = 0, live = 0;
}
 
void link(Node *u) {
	if (nxtSuf) {
		nxtSuf->suf = u;
	}
	nxtSuf = u;
}
 
bool walk(Node *u) {
	int len = u->len();
	if (curLen >= len) {
		curP += len;
		curLen -= len;
		cur = u;
		return true;
	}
	return false;
}
 
void extend(int c) {
	text[++pos] = c;
	nxtSuf = NULL;
	++remCnt;
	while (remCnt) {
		curP = curLen ? curP : pos;
		int curE = text[curP];
		if (!cur->ch[curE]) {
			Node* leaf = new(pool + (top++)) Node(pos);
			++live;
			cur->ch[curE] = leaf;
			++(cur->dgr);
			leaf->fa = cur;
			leaves.push(leaf);
			link(cur);
		} else {
			Node *nxt = cur->ch[curE];
			if (walk(nxt)) {
				continue;
			}
			if (text[nxt->l + curLen] == c) {
				++curLen;
				link(cur);
				break;
			}
			Node *split = new(pool + (top++)) Node(nxt->l, nxt->l + curLen);
			cur->ch[curE] = split;
			split->fa = cur;
			Node* leaf = new(pool + (top++)) Node(pos);
			++live;
			split->ch[c] = leaf;
			leaf->fa = split;
			++(split->dgr);
			leaves.push(leaf);
			nxt->l += curLen;
			split->ch[text[nxt->l]] = nxt;
			nxt->fa = split;
			++(split->dgr);
			link(split);
		}
		--remCnt;
		if (cur == root && curLen > 0) {
			--curLen;
			curP = pos - remCnt + 1;
		} else {
			cur = cur->suf ? cur->suf : root;
		}
	}
	size += live;
}
 
void eraseUp(Node *&u) {
	size -= u->len();
	int ch = text[u->l];
	Node *tmp = u;
	u = u->fa;
	assert(u->ch[ch] == tmp);
	u->ch[ch] = NULL;
	--(u->dgr);
}
 
void erase() {
	Node *u = leaves.front();
	leaves.pop();
	--live;
	while (u->dgr == 0 && u != cur) {
		eraseUp(u);
	}
	if (u == cur) {
		if (cur->dgr == 0 && curLen == 0) {
			int len = u->len();
			curLen = len;
			curP = pos - len + 1;
			cur = cur->fa;
			eraseUp(u);
		}
		if (curLen) {
			int curE = text[curP];
			if (!cur->ch[curE]) {
				Node* leaf = new(pool + (top++)) Node(pos - curLen + 1);
				size += leaf->len();
				++live;
				cur->ch[curE] = leaf;
				++(cur->dgr);
				leaf->fa = cur;
				leaves.push(leaf);
				--remCnt;
				if (cur == root && curLen > 0) {
					--curLen;
					curP = pos - remCnt + 1;
				} else {
					cur = cur->suf ? cur->suf : root;
				}
				while (curLen && walk(cur->ch[text[curP]])) {
					continue;
				}
			}
		}
	}
}
 
int n;
 
int main() {
	int t;
	scanf("%d", &t);
	init();
	int ans = 0;
	while (t--) {
		char op[2];
		scanf("%s", op);
		if (op[0] == '+') {
			scanf("%s", op);
			extend(op[0] - 'a');
		} else {
			erase();
		}
		ans = (ans + size) % MOD;
	}
	printf("%d\n", ans);
	return 0;
}