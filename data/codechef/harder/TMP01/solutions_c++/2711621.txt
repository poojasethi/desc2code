#include <iostream>
#include <memory.h>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <queue>
#include <map>
#define MAXN 1000005
#define MOD 1000000007
using namespace std;

string s;
struct Node {
	
	int l, r, par, link, ch;
	map <char, int> next;
	
	Node(int l = 0, int r = 0, int par = -1) : l(l), r(r), par(par), link(-1), ch(0) {}
	
	int len() {return r - l;}
	int &get(char c) {
		if (next.count(c)) return next[c];
		return next[c] = -1;
	}
}t[2 * MAXN];

int sz = 1;
queue <int> Q;
long long substr, rlt, leaves, n;
char op[MAXN], c;

struct state {
	int v, pos;
	state(int v, int pos) : v(v), pos(pos) {}
}ptr(0, 0);

state go(state st, int l, int r) {
	while (l < r) {
		if (st.pos == t[st.v].len()) {
			st = state(t[st.v].get(s[l]), 0);
			if (st.v == -1) return st;
		}
		if (s[st.pos + t[st.v].l] != s[l]) return state(-1, -1);
		if (r - l < t[st.v].len() - st.pos) return state(st.v, st.pos + r - l);
		
		l += t[st.v].len() - st.pos;
		st.pos = t[st.v].len();
	}
	return st;
}

int split(state st) {
	if (st.pos == t[st.v].len()) return st.v;
	if (st.pos == 0) return t[st.v].par;
	
	int id = sz++;
	t[id] = Node(t[st.v].l, t[st.v].l + st.pos, t[st.v].par);
	t[t[st.v].par].get(s[t[st.v].l]) = id;
	t[id].ch = 1;
	t[id].get(s[t[st.v].l + st.pos]) = st.v;
	t[st.v].par = id;
	t[st.v].l += st.pos;
	return id;
}

int get_link(int id) {
	if (t[id].link != -1) return t[id].link;
	if (t[id].par == -1) return 0;
	
	int to = get_link(t[id].par);
	return t[id].link = split(go(state(to, t[to].len()), t[id].l + (t[id].par == 0), t[id].r));
}

void tree_extend(int pos) {
	substr += leaves;
	for (;;) {
		state nptr = go(ptr, pos, pos + 1);
		if (nptr.v != -1) {
			ptr = nptr;
			return;
		}
		
		int mid = split(ptr);
		int leaf = sz++;
		t[leaf] = Node(pos, n, mid);
		t[mid].ch++;
		t[mid].get(s[pos]) = leaf;
		
		leaves++, substr++;
		Q.push(leaf);
		ptr.v = get_link(mid);
		ptr.pos = t[ptr.v].len();
		if (mid == 0) return;
	}
}

void tree_delete(int pos) {
	int leaf = Q.front();
	Q.pop();
	int par = t[leaf].par;
	
	while (t[leaf].ch == 0) {
		if (leaf != ptr.v) {
			t[par].ch--;
			t[par].get(s[t[leaf].l]) = -1;
			substr -= min(pos, t[leaf].r) - t[leaf].l;
			leaf = par;
			par = t[leaf].par;
		}
		else {
			if (min(t[leaf].r, pos) - t[leaf].l == ptr.pos) break;
			int mid = split(ptr);
			substr -= min(pos, t[leaf].r) - t[leaf].l;
			t[mid].ch--;
			t[mid].get(s[t[leaf].l]) = -1;
			t[leaf] = t[mid];
			t[t[mid].par].get(s[t[leaf].l]) = leaf;
			sz--;
			break;
		}
	}
	if (t[leaf].ch) {
		leaves--;
		return;
	}
	
	Q.push(leaf);
	int to = (t[leaf].par) ? t[t[leaf].par].link: 0;
	ptr = go(state(to, t[to].len()), t[leaf].l + (t[leaf].par == 0), t[leaf].r);
	t[leaf].l = pos - t[leaf].len();
	t[leaf].r = n;
}

int main() {
	
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	int q, i, pos = 0;
	scanf("%d", &q);
	t[0] = Node(0, 0, -1);
	for (i = 0; i < q; i++) {
		scanf(" %c", op + i);
		
		if (op[i] == '+') {
			scanf(" %c", &c);
			s += c;
			n++;
		}
	}
	
	for (i = 0; i < q; i++) {
  		if (op[i] == '+') {
			tree_extend(pos);
			pos++;
		}
		else tree_delete(pos);
		rlt = (rlt + substr) % MOD;
	}
	
	cout << rlt << endl;
}
