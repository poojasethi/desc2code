#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
#include <iostream>

using std::min;

struct Suffix_Tree {
    static const int N = 1000000 + 10;
    
    struct Node {
        int left, right, parent, link, size, linked;
        int children[26];

        // linked: amount of nodes which has linked to itself
        // size: amount of nodes of its subtree

        Node(int l = 0, int r = 0, int p = -1): left(l), right(r), parent(p) {
            link = -1;
            size = linked = 0;
            memset(children, -1, sizeof(children));
        }
        int len() {
            return right - left;
        }
        int &get(char token) {
            return children[token - 'a'];
        }
    };

    struct State {
        int v, pos;
        State(int v = 0, int pos = 0): v(v), pos(pos) {}
    } current;

    Suffix_Tree() {
        clear();
    }

    char string[N];
    int n;

    std::vector<Node> nodes;
    std::queue<int> all_leaves;

    int node_count, leaves;
    long long substr; // amount of substrings

    void clear() {
        nodes.clear();
        nodes.push_back(Node(0));
        while (!all_leaves.empty()) {
            all_leaves.pop();
        }        
        
        node_count = 1;
        leaves = substr = 0;
        // current = State(0, 0);
    }

    void initialise(char* s) {
        nodes.reserve(7000000);
        clear();
        
        strcpy(string, s);
        n = strlen(string);
    }

    State go(State st, int l, int r) {
        while (l < r) {
            if (st.pos == nodes[st.v].len()) {
                st = State(nodes[st.v].get(string[l]), 0);
                if (st.v == -1) {
                    return st;
                }
            } else {
                if (string[nodes[st.v].left + st.pos] != string[l]) {
                    return State(-1, -1);
                }
                if (r - l < nodes[st.v].len() - st.pos) {
                    return State(st.v, st.pos + r - l);
                }
                l += nodes[st.v].len() - st.pos;
                st.pos = nodes[st.v].len();
            }
        }
        return st;
    }

    int split(State st) {
        if (st.pos == nodes[st.v].len()) {
            return st.v;
        }
        if (st.pos == 0) {
            return nodes[st.v].parent;
        }
        Node v = nodes[st.v];
        int id = node_count ++;
        nodes.push_back(Node(v.left, v.left + st.pos, v.parent));
        nodes[v.parent].get(string[v.left]) = id;
        nodes[id].get(string[v.left + st.pos]) = st.v;
        nodes[id].size = 1;
        nodes[st.v].parent = id;
        nodes[st.v].left += st.pos;
        return id;
    }

    int get_link(int v) {
        if (nodes[v].link != -1) {
            return nodes[v].link;
        }
        if (nodes[v].parent == -1) {
            return 0;
        }
        int to = get_link(nodes[v].parent);
        int sp = split(go(State(to, nodes[to].len()), nodes[v].left + (nodes[v].parent == 0), nodes[v].right));
        nodes[v].link = sp;
        if (sp != -1) {
            nodes[sp].linked ++;
        }
        return nodes[v].link;
    }

    void print(int v, int pos, std::string path = "") {
        for (int i = nodes[v].left; i < min(nodes[v].right, pos); ++ i) {
            path += string[i];
        }
        printf("%d: %d-%d %s\n", v, nodes[v].left, nodes[v].right, path.c_str());
        for (char token = 'a'; token <= 'z'; ++ token) {
            if (nodes[v].get(token) != -1) {
                print(nodes[v].get(token), pos, path);
            }
        }
    }

    void extend(int pos) {
        // Extend a character at the end of string
        substr += leaves;
        while (1) {
            State next = go(current, pos, pos + 1);
            if (next.v != -1) {
                current = next;
                return;
            }
            int mid = split(current);
            int leaf = node_count ++;
            substr ++;
            leaves ++;
            all_leaves.push(leaf);
            nodes.push_back(Node(pos, n, mid));
            nodes[mid].get(string[pos]) = leaf;
            nodes[mid].size ++;

            current.v = get_link(mid);
            current.pos = nodes[current.v].len();
            if (mid == 0) {
                break;
            }
        }
    }

    void erase(int pos) {
        // erase the front of string
        int leaf = all_leaves.front();
        int par = nodes[leaf].parent;
        all_leaves.pop();
        while (nodes[leaf].size == 0) {
            if (current.v != leaf) {
                int x = nodes[leaf].left;
                nodes[par].get(string[x]) = -1;
                substr -= min(nodes[leaf].right, pos) - nodes[leaf].left;
                nodes[par].size --;

                int k = nodes[leaf].link;
                if (k != -1) {
                    nodes[k].linked --;
                }
                leaf = par;
                par = nodes[leaf].parent;
            } else {
                if (current.pos == min(nodes[leaf].right, pos) - nodes[leaf].left) {
                    break;
                }
                int mid = split(current);
                current.v = mid;
                int x = nodes[leaf].left;
                substr -= min(nodes[leaf].right, pos) - x;
                nodes[mid].get(string[x]) = -1;
                nodes[mid].size --;

                int k = nodes[leaf].link;
                if (k != -1) {
                    nodes[k].linked --;
                }
                nodes[leaf] = nodes[mid];
                nodes[nodes[mid].parent].get(string[nodes[mid].left]) = leaf;
                nodes.pop_back();
                node_count --;
                break;
            }
        }
        if (nodes[leaf].size != 0) {
            leaves --;
        } else {
            all_leaves.push(leaf);
            int to = nodes[leaf].parent == 0 ? 0 : nodes[nodes[leaf].parent].link;
            current = go(State(to, nodes[to].len()), nodes[leaf].left + (nodes[leaf].parent == 0), nodes[leaf].right);
            nodes[leaf].left = pos - nodes[leaf].len();
            nodes[leaf].right = n;
        }
    }
} tree;

const int N = 1000000 + 10;
const int MOD = 1000000000 + 7;

struct Query {
    char command[2], string[2];
    void input() {
        scanf("%s", command);
        if (*command == '+') {
            scanf("%s", string);
        }
    }
} queries[N];

char string[N];

int main() {
    // freopen("input", "r", stdin);
    int q;
    scanf("%d", &q);
    int length = 0;
    for (int i = 0; i < q; ++ i) {
        queries[i].input();
        if (queries[i].command[0] == '+') {
            string[length ++] = queries[i].string[0];
        }
    }
    string[length] = 0;
    tree.initialise(string);

    long long answer = 0;
    for (int i = 0, left = 0, right = 0; i < q; ++ i) {
        char command = queries[i].command[0];
        char key = queries[i].string[0];
        if (command == '+') {
            tree.extend(right ++);
        } else {
            tree.erase(right);
            left ++;
            if (left == right) {
                tree.clear();
            }
        }
        (answer += tree.substr) %= MOD;
    }
    std::cout << answer << '\n';
    return 0;
}
