#include <cstdio>

#define KONJ 42 - 42
#define MOD 1000000007

typedef long long zak;

using namespace std;

int T, R, S, K;
int fact[40010], inv[40010];

int pow( int a, int b ){

    if ( b == 0 ){ return 1; }
    
    if ( b & 1 ){ return (zak) a * pow( a, b - 1 ) % MOD; }
    int x = pow( a, b / 2 ) % MOD;
    
    return (zak) x * x % MOD;   

}

void init(){

     fact[0] = fact[1] = 1;
     inv[0] = inv[1] = 1;
     
     for ( int i = 2; i <= 40000; ++i ){
         fact[i] = (zak)fact[i - 1] * i % MOD;
         inv[i] = pow( fact[i], MOD - 2 );
     }

}

int povrh( int x, int y ){ // x povrh y xD

    if ( x < y ){ return 0; }  
    int ret = (zak) fact[x] * inv[y] % MOD;
    
    return (zak) ret * inv[x - y] % MOD;  

}

void solve(){

     scanf( "%d%d%d", &R, &S, &K );
     
     int sol = 0;
     for ( int i = 0; i < R; ++i ){
         for ( int j = 0; j < S; ++j ){
             int possible = (zak) povrh( R, i ) * povrh( S, j ) % MOD;
             if ( ( i + j ) & 1 ){
                sol = ( (zak)sol - (zak)povrh( ( R - i ) * ( S - j ), K ) * possible ) % MOD; 
             } else {
                sol = ( (zak)sol + (zak)povrh( ( R - i ) * ( S - j ), K ) * possible ) % MOD; 
             }
         }
     } 
     
     printf( "%d\n", ( sol + MOD ) % MOD ); 

}

int main( void ){
    
    init();
    
    scanf( "%d", &T );
    for ( int i = 0; i < T; ++i ){ solve(); }
    
    return KONJ;

}
