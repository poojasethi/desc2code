#include <bits/stdc++.h>
 
using namespace std;
 
#define FOR(i, a, b) for(int i = a; i < b; i++)
#define REP(i, n) FOR(i, 0, n)
#define ll long long
#define pb push_back
#define mp make_pair
 
#define mod 1000000007
#define N 100005
#define base (1<<17)
 
vector<int> a[N];
int n, m, s[N], f[N], gb = 0, par[N][17], lev[N];
ll val[base<<1];
 
void dfs(int u = 1, int pre = 0, int l = 0)
{
    lev[u] = l;
    par[u][0] = pre;
    s[u] = gb;
    val[gb++] = u;
    f[u] = s[u];
    REP(i, a[u].size())
    {
        int v = a[u][i];
        if(v == pre) continue;
        dfs(v, u, l+1);
        f[u] = max(f[u], f[v]);
    }
}
 
bool ancof(int u, int v)
{
    return s[u] <= s[v] and s[v] <= f[u];
}
 
int get(int u, int k)
{
    for(int x = 0; x < 17; x++) if(k&(1<<x)) u = par[u][x];
    return u;
}
 
int maxx[base<<1], inc[base<<1];
ll prod[base<<1];
 
void relax(int n, int L, int R)
{
    if(inc[n] == 0) return;
    maxx[n] += inc[n];
    if(L != R)
    {
        inc[n<<1] += inc[n];
        inc[n<<1|1] += inc[n];
    }
    inc[n] = 0;
}
 
void update(int l, int r, int x, int n = 1, int L = 0, int R =base-1)
{
    relax(n, L, R);
    if(l == L and r == R)
    {
        inc[n] += x;
        return;
    }
    int m = (L+R)>>1;
    if(r <= m) update(l, r, x, n<<1, L, m);
    else if(l > m) update(l, r, x, n<<1|1, m+1, R);
    else update(l, m, x, n<<1, L, m), update(m+1, r, x, n<<1|1, m+1, R);
    relax(n<<1, L, m); relax(n<<1|1, m+1, R);
    if(maxx[n<<1] > maxx[n<<1|1])
    {
        maxx[n] = maxx[n<<1];
        prod[n] = prod[n<<1];
    }
    else if(maxx[n<<1] < maxx[n<<1|1])
    {
        maxx[n] = maxx[n<<1|1];
        prod[n] = prod[n<<1|1];
    }
    else
    {
        maxx[n] = maxx[n<<1];
        prod[n] = (prod[n<<1]*prod[n<<1|1]) % mod;
    }
}
 
int main()
{
    scanf("%d%d", &n, &m);
    REP(i, n-1)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        a[u].pb(v);
        a[v].pb(u);
    }
    dfs();
    for(int j = 1; j < 17; j++) FOR(u, 1, n+1) par[u][j] = par[par[u][j-1]][j-1];
    REP(i, n) prod[base+i] = val[i];
    FOR(i, n, base) prod[base+i] = 1;
    for(int i = base-1; i >= 1; i--)
        prod[i] = prod[i<<1]*prod[i<<1|1] % mod;
    int cnt = 0;
    while(m--)
    {
        char t; int u, v;
        scanf(" %c%d%d", &t, &u, &v);
        int z = (t == '+' ? 1 : -1);
        cnt += z;
        if(ancof(v, u)) swap(u, v);
        if(ancof(u, v))
        {
            update(s[v], f[v], z);
            int x = get(v, lev[v]-lev[u]-1);
            update(s[1], f[1], z);
            update(s[x], f[x], -z);
        }
        else
        {
            update(s[u], f[u], z);
            update(s[v], f[v], z);
        }
        relax(1, 0, base-1);
        printf("%lld\n", maxx[1] == cnt ? prod[1] : -1);
    }
    return 0;
} 