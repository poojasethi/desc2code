#include <algorithm>
#include <string>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <iomanip>
#include <cassert>
#include <queue>
#include <cstdlib>
#include <set>
#include <map>
#include <stack>
#include <cmath>
#include <ctime>

#define	st first
#define	nd second
#define	mp make_pair
#define	pb push_back
#define	lli long long int
#define	all( gg )	gg.begin(),gg.end()
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	FP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )
#define	FM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;

#define	orta	(bas+son)/2
#define	sol		root*2,bas,orta
#define	sag		root*2+1,orta+1,son

#define	mod		1000000007LL

using namespace std;

class	segment{
	public:
		lli	maxi,pro,art;
		segment(){
			maxi = 0;
			pro = 1;
			art = 0;
		}
}kd[400000];

segment	merge( segment a,segment b ){
	if( a.maxi>b.maxi )	return	a;
	if( a.maxi<b.maxi )	return	b;
	a.pro = a.pro*b.pro%mod;
	return	a;
}

int	F[200000];

segment	init( int root,int bas,int son ){
	if( bas==son ){
		kd[root].pro = F[bas];
		return	kd[root];
	}
	return	kd[root] = merge( init( sol ),init( sag ) );
}

segment	update( int	root,int bas,int son,int x,int y,int val ){
	if( son<x or y<bas )	return	kd[root];
	if( x<=bas and son<=y ){
		kd[root].maxi += val;
		kd[root].art += val;
		return	kd[root];
	}
	segment	a = merge( update( sol,x,y,val ),update( sag,x,y,val ) );
	a.maxi += kd[root].art;
	kd[root].maxi = a.maxi;
	kd[root].pro = a.pro;
	return	kd[root];
}

int	n,m,Time,ts[200000],tf[200000],deg[200000],root[200000][20];
vector<int>	v[200000];

void	dfs( int nod,int pre,int d ){
	ts[nod] = ++Time;
	F[Time] = nod;
	deg[nod] = d;
	root[nod][0] = pre;
	FP( k,1,18 )	root[nod][k] = root[ root[nod][k-1] ][k-1];
	foreach( v[nod],it )
		if( *it!=pre )
			dfs( *it,nod,d+1 );
	tf[nod] = Time;
}

int	lca( int x,int y ){
	if( deg[x]<deg[y] )	swap( x,y );
	FM( i,18,0 )	if( deg[ root[x][i] ]>=deg[y] )	x = root[x][i];
	if( x==y )	return	x;
	FM( i,18,0 )
		if( root[x][i]!=root[y][i] ){
			x = root[x][i];
			y = root[y][i];
		}
	return	root[x][0];
}

int	go( int x,int t ){
	FM( i,18,0 )	if( t&(1<<i) )	x = root[x][i];
	return	x;
}

int	sbridge;

void	findsol(){
	if( kd[1].maxi!=sbridge )	cout << -1 << endl;
	else	cout << kd[1].pro << endl;
}

int main(){

	ios_base::sync_with_stdio( false );
	cin >> n >> m;
	
	FP( i,1,n-1 ){
		int	x,y;
		cin >> x >> y;
		v[x].pb(y);
		v[y].pb(x);
	}
	
	dfs( 1,1,0 );
	init( 1,1,n );
	
	while( m-- ){
		char	c;
		int	x,y,val;
		cin >> c >> x >> y;
		if( x==y ){
			findsol();
			continue;
		}
		val = (c=='+')*2-1;
		sbridge+=val;
		if( lca(x,y)==y )	swap( x,y );
		if( lca(x,y)==x ){
			update( 1,1,n,ts[y],tf[y],val );
			update( 1,1,n,1,n,val );
			int	p = go( y,deg[y]-deg[x]-1 );
			update( 1,1,n,ts[p],tf[p],-val );
		}
		else{
			update( 1,1,n,ts[x],tf[x],val );
			update( 1,1,n,ts[y],tf[y],val );
		}
		findsol();
	}

}