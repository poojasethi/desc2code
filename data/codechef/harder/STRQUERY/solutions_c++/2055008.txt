#ifdef _MONYURA_
#pragma comment(linker,"/STACK:256000000")
#endif

#include <iostream>
#include <iomanip>
#include <cstdio>
#include <bitset>
#include <memory>
#include <algorithm>
#include <set>
#include <map>
#include <vector>
#include <list>
#include <string>
#include <cstring>
#include <fstream>
#include <functional>
#include <stack>
#include <complex>
#include <wchar.h>
#include <wctype.h>
#include <cmath>
#include <queue>
#include <ctime>
#include <numeric>


using namespace std;

template<typename T> T mabs(const T &a){ return a<0?-a:a;}
#define rep(x,y,z) for(int x=(y),e##x=(z);x<e##x;x++)
#define SQR(x) ((x)*(x))
#define all(c) (c).begin(), (c).end()

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef short int si;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

const double PI = acos(-1.0);
int maxOpersDone=723;

const int INF = 1e9;
const int MAX_N = 200100;

struct SuffTreeNode
{
	int to[27];
	int l,r;
	int s;
	int pr;

	int dyn;
	bool was;
	int tin;
	int tout;
	int getLen()
	{
		return r-l+1;
	}
	void clear()
	{
		was = false;
		dyn=0;
		memset(to,-1,sizeof(to));
	}
};

struct SuffTreePos
{
	int v;
	int offset;
};

struct SuffTree
{
	SuffTreeNode tr[2*MAX_N+2];
	SuffTreePos pos;
	int last;
	char *str;
	int n;
	int ind;
	int time;
	int Ends[MAX_N];
	bool canGo(const SuffTreePos &p,char c)
	{
		if (p.offset>0)
			return str[tr[p.v].r - p.offset+1]==c;
		return tr[p.v].to[c-'a']!=-1;
	}

	void go(SuffTreePos &p,char c)
	{
		if (p.offset>0)
			p.offset--;
		else
		{
			p.v = tr[p.v].to[c-'a'];
			p.offset = tr[p.v].getLen()-1;
		}
	}

	void TryAndSplit(SuffTreePos &p,char c)
	{
		if (p.offset>0)
		{
			tr[last].clear();
			tr[last].l = tr[p.v].l;
			tr[p.v].l = tr[p.v].r - p.offset + 1;
			tr[last].r = tr[p.v].l - 1;
			tr[last].pr = tr[p.v].pr;
			tr[tr[p.v].pr].to[str[tr[last].l]-'a'] = last;
			tr[p.v].pr = last;
			tr[last].to[str[tr[p.v].l]-'a'] = p.v;
			p.v = last;
			p.offset = 0;
			last++;
		}
		tr[p.v].to[c-'a'] = last;
		tr[last].clear();
		tr[last].pr = p.v;
		tr[last].l = ind;
		tr[last].r = INF;
		last++;
	}

	SuffTreePos quickGoDown(int v,int l,int r)
	{
		while (l<=r)
		{
			v = tr[v].to[str[l]-'a'];
			l+=tr[v].getLen();
		}
		SuffTreePos res;
		res.v = v;
		res.offset = l-r-1;
		return res;
	}

	void addChar(SuffTreePos &p,int i)
	{
		char c = str[i];
		ind = i;
		while (!canGo(p,c))
		{
			TryAndSplit(p,c);
			if (p.v==0)
				return;
			SuffTreePos prev = p;
			p = quickGoDown(tr[tr[p.v].pr].s,tr[p.v].l + (tr[p.v].pr==0),tr[p.v].r);
			tr[prev.v].s = p.offset == 0 ? p.v : last;
		}
		go(p,c);
	}
	void build(char *Str)
	{
		str = Str;
		n = strlen(str);
		pos.v = 0;
		pos.offset = 0;
		tr[0].clear();
		tr[0].l = 0;
		tr[0].r = -1;
		tr[0].s = 0;
		tr[0].pr = 0;
		last = 1;
		str[n]='z'+1;
		for (int i=0;i<=n;i++)
			addChar(pos,i);
		str[n]=0;
		proc();
	}

	void dfs(int k,int len)
	{
		tr[k].tin=++time;
		if (tr[k].r==INF)
		{
			tr[k].r = n;
			tr[k].dyn = 1;
			len+=tr[k].getLen();
			Ends[n+1-len] = k;
		}
		else
			rep(i,0,27)
			if (tr[k].to[i]!=-1)
			{
				dfs(tr[k].to[i],len + tr[k].getLen());
				tr[k].dyn += tr[tr[k].to[i]].dyn;
			}
			tr[k].tout = ++time;
	}

	void proc()
	{
		time = 0;
		dfs(0,0);
	}
	int contains(char *str,int delBeg=0,int delEnd=0)
	{
		SuffTreePos p;
		p.v = 0;
		p.offset = 0;
		int i=0;
		for (;str[i] && canGo(p,str[i]);i++)
			go(p,str[i]);
		if (str[i]) return 0;
		int res = tr[p.v].dyn;
		rep(j,0,delBeg)
			res -= tr[Ends[j]].tin >= tr[p.v].tin && tr[Ends[j]].tout <= tr[p.v].tout;
		for (int j=max(delBeg,n-i-delEnd+1);j+i<=n;j++)
			res -= tr[Ends[j]].tin >= tr[p.v].tin && tr[Ends[j]].tout <= tr[p.v].tout;
		return res;
	}
};

void buildZfunc(char *str,int *Z,int n)
{
	int l=-1,r=0;
	for (int i=1;i<n;i++)
	{
		int z = 0;
		if (i<=r)
			z = min(r-i+1,Z[i-l]);
		while (i+z<n && str[i+z]==str[z])
			++z;
		if (i+z-1>r)
		{
			r=i+z-1;
			l=i;
		}
		Z[i]=z;
	}
}

int calcAddCnt1(char *str,char *pat,int strl,int patl)
{
	static char A[310150];
	static int Z[310150];
	strcpy(A,pat);
	A[patl]='#';
	A[patl+1] = 0;
	strncpy(A+patl+1,str,strl);
	buildZfunc(A,Z,strl+patl+1);
	int res=0;
	rep(i,patl+1,strl+2)
		if (Z[i]==patl) ++res;
	return res;
}


struct charDeq
{
	char str[2*MAX_N+2];
	char *maxBot, *minTop;
	char *prevTop, *prevBot;
	char *top, *bot;
	bool usedTree;
	SuffTree tree;

	void init(char *Str)
	{
		int n = strlen(Str);
		maxBot = bot = prevBot = str+MAX_N;
		minTop = top = prevTop = str+MAX_N + n-1;
		strcpy(bot,Str);
		*(top+1) = 0;
		if (n>maxOpersDone-2)
		{
			tree.build(Str);
			usedTree = true;
		}
		else
		{
			usedTree = false;
		}
	}
	void push_top(char c)
	{
		*++top=c;
	}
	char pop_top()
	{
		if (--top<minTop)
			minTop = top;
		return top[1];
	}
	void push_bottom(char c)
	{
		*--bot = c;
	}
	char pop_bottom()
	{
		if (++bot>maxBot)
			maxBot = bot;
		return bot[-1];
	}

	int contains(char *str)
	{
		int n = strlen(str);
		if (top-bot+1<n) return 0;
		int res = 0;
		//cout<<usedTree<<endl;
		if (usedTree)
		{
			res += tree.contains(str,maxBot-prevBot, prevTop - minTop);
			if (bot<maxBot)
			{
				int strl = min(top-bot+1,n + maxBot-bot-1);
				res += calcAddCnt1(bot,str,strl,n);
			}
			if (minTop<top)
			{
				int strl = min(top-maxBot+1,n + top-minTop-1);
				res += calcAddCnt1(top-strl+1,str,strl,n);
			}
		}
		else
		{
			res += calcAddCnt1(bot,str,top-bot+1,n);
		}
		if ((prevTop - minTop) + (maxBot - prevBot) + (top-minTop) + (maxBot - bot) >maxOpersDone-2)
		{
			if (top-bot + 1 > maxOpersDone)
			{
				top[1]=0;
				tree.build(bot);
				usedTree = true;
				minTop = prevTop = top;
				maxBot = prevBot = bot;
			}
			else
			{
				usedTree = false;
			}
		}
		return res;
	}
	int size() const
	{
		return top-bot+1;
	}
};

int calcAddCnt2(char *A,int n,char *B,int m,char *pat,int len)
{
	static char str[310150];
	static int Z[310150];
	strcpy(str,pat);
	str[len]='#';
	str[len+1]=0;
	strncat(str+len+1,A,n);
	strncat(str+len+1,B,m);
	buildZfunc(str,Z,n+m+len+1);
	int res=0;
	rep(i,len+1,n+m+2)
		if (Z[i]==len)
			++res;
	return res;
}

charDeq dA;
charDeq dB;

void init(char *str)
{
	int n = strlen(str);
	dB.init(str+n/2);
	char was = str[n/2];
	str[n/2] =0;
	dA.init(str);
	str[n/2] = was;
}

void addTop(char c)
{
	if (dA.size()==dB.size())
		dB.push_top(c);
	else
	{
		char frst = dB.pop_bottom();
		dA.push_top(frst);
		dB.push_top(c);
	}
}

void delTop()
{
	if (dA.size()==dB.size())
	{
		dB.pop_top();
		char lst = dA.pop_top();
		dB.push_bottom(lst);
	}
	else
		dB.pop_top();
}

void addMid(char c)
{
	if (dA.size()==dB.size())
		dB.push_bottom(c);
	else
		dA.push_top(c);
}
void delMid()
{
	if (dA.size()==dB.size())
	{
		dB.pop_bottom();
		char lst = dA.pop_top();
		dB.push_bottom(lst);
	}
	else
		dB.pop_bottom();
}

void addBot(char c)
{
	if (dA.size() == dB.size())
	{
		dA.push_bottom(c);
		char lst = dA.pop_top();
		dB.push_bottom(lst);
	}
	else
		dA.push_bottom(c);
}

void delBot()
{
	if (dA.size() == dB.size())
		dA.pop_bottom();
	else
	{
		dA.pop_bottom();
		char frst = dB.pop_bottom();
		dA.push_top(frst);
	}
}

int getCnt(char *str)
{
	int res = dA.contains(str);
	res += dB.contains(str);
	int n = strlen(str);
	if (n<=dA.size()+dB.size())
	{
		int lena = min(dA.size(),n-1);
		char *posA = dA.top - lena+1;
		int lenb = min(dB.size(),n-1);
		char *posB = dB.bot;
		res += calcAddCnt2(posA,lena,posB,lenb,str,n);
	}
	return res;
}


char qer[1500150];
void run()
{
	/*while (1)
	{
	char P[10000];
	char T[10000];
	scanf("%s",T);
	if (strcmp(T,"exit")==0) break;
	scanf("%s",P);
	int a,b;
	scanf("%d%d",&a,&b);
	st.build(T);
	int res = st.contains(P,a,b);
	cout<<res<<endl;
	}*/
	/*char str[1000];
	scanf("%s",str);
	deq.init(str);
	while (!feof(stdin))
	{
	char arg[100],com[100];
	scanf("%s",com);
	if (strcmp(com,"add_top")==0)
	{
	scanf("%s",arg);
	deq.push_top(arg[0]);
	}
	if (strcmp(com,"add_bot")==0)
	{
	scanf("%s",arg);
	deq.push_bottom(arg[0]);
	}
	if (strcmp(com,"del_top")==0)
	{
	deq.pop_top();
	}
	if (strcmp(com,"del_bot")==0)
	{
	deq.pop_bottom();
	}
	if (strcmp(com,"q")==0)
	{
	scanf("%s",arg);
	int res = deq.contains(arg);
	cout<<res<<endl;
	}
	}*/
	char str[20];
	scanf("%s",str);
	init(str);
	int q;
	cin>>q;
	char com[20];
	char arg;

	rep(i,0,q)
	{
		scanf(" %s",com);
		if (strcmp(com,"INSERT_LEFT")==0)
		{
			scanf(" %c",&arg);
			addBot(arg);
		}
		else if (strcmp(com,"INSERT_RIGHT")==0)
		{
			scanf(" %c",&arg);
			addTop(arg);
		}
		else if (strcmp(com,"INSERT_MIDDLE")==0)
		{
			scanf(" %c",&arg);
			addMid(arg);
		}
		else if (strcmp(com,"DELETE_LEFT")==0)
		{
			delBot();
		}
		else if (strcmp(com,"DELETE_RIGHT")==0)
		{
			delTop();
		}
		else if (strcmp(com,"DELETE_MIDDLE")==0)
		{
			delMid();
		}
		else if (strcmp(com,"QUERY")==0)
		{
			scanf("%s",qer);
			int res = getCnt(qer);
			printf("%d\n",res);
		}
	}
}

int main()
{
#ifdef _MONYURA_
	freopen("test.in","r",stdin);
	//freopen("test.out","w",stdout);
	time_t st=clock();
#else
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
#endif
	run();
#ifdef _MONYURA_
	printf( "=============\n");
	printf("Time: %.2lf sec\n",(clock()-st)/double(CLOCKS_PER_SEC));
#endif

	return 0;
} 
