#pragma comment(linker, "/STACK:102400000,102400000")
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <queue>
#include <set>
#include <cmath>
#include <fstream>
#include <assert.h>
#include <complex>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 100005
 
template <class T> inline void Min(T &a,T b){if(a>b)a=b;}
template <class T> inline void Max(T &a,T b){if(a<b)a=b;}
 
int a[N],num=0,b[N],n,h[N];
struct node{
    node *l,*r;
    int sz,v,rg;
    node(int _v=0):v(_v),sz(1),rg(rand()*RAND_MAX+rand()),l(NULL),r(NULL){}
    friend void up(node *x){
        x->sz=1+(x->l?x->l->sz:0)+(x->r?x->r->sz:0);
    }
    friend int Getsize(node *x){
        return x?x->sz:0;
    } 
    friend void rot_left(node* &x){
        node *y=x->r;
        x->r=y->l;
        y->l=x;
        up(x);up(y);
        x=y;
    }
    friend void rot_right(node* &x){
        node *y=x->l;
        x->l=y->r;
        y->r=x;
        up(x);up(y);
        x=y;
    }
    friend node* merge(node *a,node *b){
        if(a==NULL)return b;
        if(b==NULL)return a;
        if(a->rg<b->rg){
            a->r=merge(a->r,b);
            up(a);
            return a;
        }
        b->l=merge(a,b->l);
        up(b);
        return b;
    }
    friend void split(node *rt,node* &a,node* &b,int sz){
        //cerr<<rt->sz<<" "<<sz<<"\n";
        if(rt==NULL){
            a=b=NULL;return;
        }
        int my=Getsize(rt->l)+1;
        if(my<=sz){
            split(rt->r,rt->r,b,sz-my);
            a=rt;
            up(a);
        }
        else{
            split(rt->l,a,rt->l,sz);
            b=rt;
            up(b);
        }
    }
    friend void Index(node *rt){
        if(rt==NULL)return;
        Index(rt->l);
        b[rt->v]=++num,h[num]=rt->v;
        Index(rt->r);
    }
};
struct Fen{
    int n;
    vi f;
    void init(int m){
        n=m;
        f.resize(n+1,0);
    }
    void upd(int x,int v){
        while(x<=n)f[x]+=v,x+=x&-x;
    }
    int query(int x){
        int ans=0;
        while(x>0)ans+=f[x],x-=x&-x;
        return ans;
    }
    int find(int y){
        int l=1,r=n,m;
        while(l<=r){
            m=(l+r)>>1;
            if(query(m)>=y)r=m-1;
            else l=m+1;
        }
        return r+1;
    }
};
vi st[N<<2];
int *sb[N<<2],q[N],d[N];
ll ans=0;
void build(int p,int l,int r){
    if(l==r){
        st[p].pb(d[h[l]]);
        sb[p]=new int[2];
        return void(sb[p][0]=sb[p][1]=0);
    }
    int m=(l+r)>>1;
    build(p<<1,l,m);
    build(p<<1|1,m+1,r);
    st[p].resize(st[p<<1].size()+st[p<<1|1].size());
    merge(all(st[p<<1]),all(st[p<<1|1]),st[p].begin());
    sb[p]=new int[r-l+2];
    for(int i=0;i<=r-l+1;i++)sb[p][i]=0;
}
void up(int x,int *f,int sz){
    while(x<sz)f[x]++,x+=x&-x;
}
int qu(int x,int *f){
    int ans=0;
    while(x>0)ans+=f[x],x-=x&-x;
    return ans;
}
void upd(int p,int l,int r,int x,int v){
    if(l==r){
        up(1,sb[p],r-l+2);
        return;
    }
    int m=(l+r)>>1;
    if(x<=m){
        int id=lower_bound(all(st[p<<1|1]),v)-st[p<<1|1].begin();
        ans+=qu(id,sb[p<<1|1]);
        upd(p<<1,l,m,x,v);
    }
    else{
        int id=upper_bound(all(st[p<<1]),v)-st[p<<1].begin();
        ans+=qu(st[p<<1].size(),sb[p<<1])-qu(id,sb[p<<1]);
        upd(p<<1|1,m+1,r,x,v);
    }
    int id=lower_bound(all(st[p]),v)-st[p].begin();
    up(id+1,sb[p],r-l+2);
}
 
int main()
{
    int i,j,k,ca=0,m;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    Fen T;T.init(n);
    for(i=1;i<=n;i++)T.upd(i,1);
    node *rt=NULL;
    for(i=0;i<m;i++){
        int l,r,z;
        scanf("%d%d%d",&l,&r,&z);
        node *aa=NULL,*b=NULL,*c;
        split(rt,aa,b,z-1);
        //DBG(a->sz)DBG(b->sz)
        for(j=l;j<=r;j++){
            int x=T.find(l);T.upd(x,-1);
            d[q[i]+j-l]=a[x];
            c=new node(q[i]+j-l);
            aa=merge(aa,c);
        }
        rt=merge(aa,b);
        q[i+1]=q[i]+r-l+1;
    }
    Index(rt);
    build(1,1,n);
    ans=0;
    for(i=0;i<m;i++){
        for(j=0;j<q[i+1]-q[i];j++){
            int x=q[i]+j,y=d[x];
            //cerr<<b[x]<<" "<<y<<"\n";
            upd(1,1,n,b[x],y);
        }
        printf("%lld\n",ans);
    }
    return 0;
} 