#pragma comment(linker, "/STACK:100000000")
#define _CRT_SECURE_NO_WARNINGS
#pragma GCC optimize("O500")
#include <algorithm>
#include <iostream>
#include <memory.h>
#include <cstdlib>
#include <complex>
#include <sstream>
#include <cstring>
#include <fstream>
#include <vector>
#include <cstdio>
#include <string>
#include <bitset>
#include <queue>
#include <stack>
#include <ctime>
#include <cmath>
#include <map>
#include <set>
 
using namespace std;
 
typedef unsigned long long ull;
typedef complex < double > cd;
typedef long double ld;
typedef long long ll;
 
template < class T > void read(T &x) { char c, mi = 0; while(c = getchar(), c <= 32); if(c == '-') mi = 1, x = 0; else if(c < 48 || c > 57) return void(x = c); else x = c - 48; while(c = getchar(), c > 32) x = 10 * x + c - 48; if(mi == 1) x = -x; }
template < class T > void read(T &x, T &y) { read(x); read(y); }
template < class T > void read(T &x, T &y, T &z) { read(x, y); read(z); }
template < class T > void reada(T *a, int n) { for(int i = 0; i < n; ++i) read(a[i]); }
template < class T > void write(T x) { static char s[20]; char pt = 0, mi = (x < 0); if(mi == 1) x = -x; while(!pt || x > 0) { s[++pt] = (char)(x % 10 + '0'); x /= 10; } if(mi == 1) putchar('-'); while(pt > 0) putchar(s[pt--]); }
template < class T > void write(T x, T y) { write(x); putchar(' '); write(y); }
template < class T > void write(T x, T y, T z) { write(x, y); putchar(' '); write(z); }
template < class T > void writeln(T x) { write(x); puts(""); }
template < class T > void writea(T *a, int n) { for(int i = 0; i < n; ++i) { write(a[i]); putchar(i + 1 == n ? '\n' : ' '); } }
template < class T > T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
template < class T > T lcm(T a, T b) { return a / gcd(a, b) * b; }
template < class T > T qpom(T a, T b, int mod = 1000000007) { T r = 1; while(b > 0) { if(b & 1) r = r * a % mod; a = a * a % mod; b /= 2; } return r; }
template < class T > T qpow(T a, T b) { T r = 1; while(b > 0) { if(b & 1) r *= a; a *= a; b /= 2; } return r; }
template < class T > T imin(T a, T b) { return a < b ? a : b; }
template < class T > T imax(T a, T b) { return a > b ? a : b; }
template < class T > inline void rmin(T &a, const T &b) { if(a > b) a = b; }
template < class T > inline void rmax(T &a, const T &b) { if(a < b) a = b; }
template < class T > T sqr(const T &a) { return a * a; }
 
#define debug(x) cout << #x << "=" << x
#define debuge(x, c) cout << #x << "=" << x << (c)
#define debugn(x) cout << #x << "=" << x << "\n"
#ifndef DEBUG
#define eprintf(...) fprintf(stderr, "%s -> ", string(to_string((long long)__LINE__)).c_str()), fprintf(stderr, __VA_ARGS__)
#else
#define eprintf(...)
#endif
 
#define ppb pop_back
#define pb push_back
#define mp make_pair
#define fs first
#define sd second
 
#define inf 1000000007
#define nmax 100010
#define mmax 300010
#define eps 1e-9

struct Trie {
	int to[2];
	int last;
} t[33 * nmax];

vector < pair < int, unsigned > > gr[nmax];
int n, pt;
unsigned val[nmax], ans;

inline void add(unsigned mask, int id) {
	int cur = 0;
	for(int bit = 31; bit >= 0; --bit) {
		int val = (mask >> bit) & 1;
		if(!t[cur].to[val]) {
			t[cur].to[val] = ++pt;
		}
		cur = t[cur].to[val];
	}
	t[cur].last = id;
}

inline pair < unsigned, int > get(unsigned mask) {
	int cur = 0;
	unsigned ret = 0;
	for(int bit = 31; bit >= 0; --bit) {
		int val = (mask >> bit) & 1;
		if(t[cur].to[1 - val] != 0) {
			ret |= 1U << bit;
			cur = t[cur].to[1 - val];
		} else {
			cur = t[cur].to[val];
		}
	}
	return make_pair(ret, t[cur].last);
}

void dfs(int v, int p) {
	for(int i = 0; i < (int)gr[v].size(); ++i) {
		int to = gr[v][i].first;
		unsigned cost = gr[v][i].second;
		if(to == p) {
			continue;
		}
		val[to] = val[v] ^ cost;
		dfs(to, v);
	}
}

void solve() {
	scanf("%d", &n);
	for(int i = 1; i < n; ++i) {
		int x, y;
		unsigned c;
		scanf("%d%d%u", &x, &y, &c);
		gr[x].push_back(make_pair(y, c));
		gr[y].push_back(make_pair(x, c));
	}
	dfs(1, -1);
	for(int i = 1; i <= n; ++i) {
		add(val[i], i);
	}
	ans = 0U;
	for(int i = 1; i <= n; ++i) {
		pair < unsigned, int > temp = get(val[i]);
		if(temp.first > ans) {
			ans = temp.first;
		}
	}
	printf("%u\n", ans);
	for(int i = 1; i <= n; ++i) {
		gr[i].clear();
		val[i] = 0;
	}
	memset(t, 0, sizeof(t));
	pt = 0;
}

int main() {
//	freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout);
//	freopen("invers.in", "r", stdin); freopen("invers.out", "w", stdout);
	int tests;
	scanf("%d", &tests);
	while(tests --> 0) {
		solve();
	}
	getchar(); getchar();
	return 0;
}   