// LUCIFER <3 SLS <3

#include <bits/stdc++.h>

using namespace std;

#define get getchar_unlocked
#define pb push_back
#define mp make_pair

int scan()
{
    int n = 0, ch = get();
    while (ch < '0' || ch > '9')
        ch = get();
    while (ch >= '0' && ch <= '9') {
        n = (n << 3) + (n << 1) + ch - 48;
        ch = get();
    }
    return n;
}

struct node
{
    struct node *l, *r;
};

void toString(int x, string &a)
{
    while (x != 0) {
        a.pb(x%2+48);
        x >>= 1;
    }
    while (a.size() < 31)
        a.pb('0');
    reverse(a.begin(), a.end());
}

void insert(struct node *head, string &a)
{
    struct node *tmp;
    tmp = head;
    for (int i = 0; i < a.size(); i++) {
        if (a[i] == '0') {
            if (tmp->l == NULL) {
                struct node *tmp2 = (struct node *)malloc(sizeof(struct node));
                tmp2->l = tmp2->r = NULL;
                tmp->l = tmp2;
            }
            tmp = tmp->l;
        }
        else {
            if (tmp->r == NULL) {
                struct node *tmp2 = (struct node *)malloc(sizeof(struct node));
                tmp2->l = tmp2->r = NULL;
                tmp->r = tmp2;
            }
            tmp = tmp->r;
        }
    }
}

int max_xor(struct node *head, string &a)
{
    struct node *tmp = head;
    int i, j;
    string b;
    for (i = 0; i < a.size(); i++) {
        if (a[i] == '0') {
            if (tmp->r != NULL) {
                b.pb('1');
                tmp = tmp->r;
            }
            else {
                b.pb('0');
                tmp = tmp->l;
            }
        }
        else {
            if (tmp->l != NULL) {
                b.pb('1');
                tmp = tmp->l;
            }
            else {
                b.pb('0');
                tmp = tmp->r;
            }
        }
    }
    int ans = 0;
    for (i = b.size()-1, j = 0; i >= 0; i--, j++) {
        if (b[i] == '1')
            ans += (1 << j);
    }
    return ans;
}

void dfs(int s[], int cn, int pn, vector < pair <int, int> > v[])
{
    vector < pair <int, int> > q;
    q.pb(mp(cn, pn));
    int top = 0, i;
    while (top != q.size()) {
        cn = q[top].first;
        pn = q[top].second;
        top++;
        for (i = 0; i < v[cn].size(); i++) {
            if (v[cn][i].first != pn) {
                s[v[cn][i].first] = s[cn]^v[cn][i].second;
                q.pb(mp(v[cn][i].first, cn));
            }
        }
    }
}

int main()
{
    //freopen("input2.txt", "r", stdin);
    //freopen("output5.txt", "w", stdout);
    int ans, tmp, t, n, s[100111], i, x, y, z;
    string a;
    t = scan();
    toString(0, a);
    while (t--) {
        n = scan();
        //cerr << n << endl;
        vector < pair <int, int> > v[n+1];
        for (i = 1; i < n; i++) {
            x = scan();
            y = scan();
            z = scan();
            v[x].pb(mp(y, z));
            v[y].pb(mp(x, z));
        }
        s[1] = 0;
        dfs(s, 1, -1, v);
        struct node *head = (struct node *)malloc(sizeof(struct node));
        head->l = head->r = NULL;
        insert(head, a);
        ans = 0;
        for (i = 2; i <= n; i++) {
            string b;
            toString(s[i], b);
            tmp = max_xor(head, b);
            ans = max(tmp, ans);
            insert(head, b);
        }
        printf("%d\n", ans);
    }
    return 0;
}
