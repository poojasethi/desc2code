// Nipun Poddar , CSE, MNNIT Allahabad

#include<iostream>
#include<cstdio>
#include<vector>
#include<map>
#include<queue>
#include<stack>
#include<cstring>
#include<algorithm>

#define in(n) scanf("%d",&n)
#define in2(n,m) scanf("%d%d",&n,&m)
#define inll(n) scanf("%lld",&n)
#define inll2(n,m) scanf("%lld%lld",&n,&m)
#define out(n) printf("%d\n",n)
#define out2(n,m) printf("%d %d\n",n,m)
#define outll(n) printf("%lld\n",n)
#define outll2(n,m) printf("%lld %lld\n",n,m)
#define inc(n) scanf("%c",&n)
#define minm(a,b) (a<b?a:b)
#define maxm(a,b) (a<b?b:a)
#define loop(n) for(i=0;i<n;i++)
#define loop1(n) for(i=1;i<=n;i++)
#define fill0(x) memset(x,0,sizeof(x))
#define fill1(x) memset(x,-1,sizeof(x))
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define pii pair<int,int>
#define ppii pair<int,pii>

#define MOD 1000000007
#define MOD_INV 1000000006
#define MAX 100009
#define INF 999999999

using namespace std;

vector<pii > V[MAX];
int trie[33*MAX][2];
int no_nodes;
int vis[MAX];
int xor_sum[MAX];

void dfs(int u,int p)
{
	vis[u]=1;
	xor_sum[u]=p;
	int i,v,w;
	for(i=0;i<V[u].size();i++)
	{
		v=V[u][i].F;
		w=V[u][i].S;
		if(!vis[v])
		{
			dfs(v,p^w);
		}
	}	
}

// Trie used where right child of a node indicates that bit is set  and left child indicates that, that bit is off

// Insertion in Trie
void insert_trie(int n)
{
	int j,curr=0;
	for(j=31;j>=0;j--)
	{
		if(n&(1<<j))	// Going down right child
		{
			if(trie[curr][1]!=-1)
			{
				curr=trie[curr][1];	
			}
			else
			{
				no_nodes++;	// if no node then create a node
				trie[no_nodes][0]=trie[no_nodes][1]=-1;
				trie[curr][1]=no_nodes;
				curr=no_nodes;
			}
		}
		else	// Going down left child
		{
			if(trie[curr][0]!=-1)
			{
				curr=trie[curr][0];
			}
			else
			{
				no_nodes++;		// if no node then create a node
				trie[no_nodes][0]=trie[no_nodes][1]=-1;
				trie[curr][0]=no_nodes;
				curr=no_nodes;
			}
		}
	}
}

// Query in Trie to get max
int query_trie(int n)
{
	int ans=0;
	int j;
	int curr=0;
	for(j=31;j>=0;j--)
	{
		if(n&(1<<j))	// Going down left child since maximising XOR
		{
			if(trie[curr][0]!=-1)
			{
				curr=trie[curr][0];
				ans^=(1<<j);
			}
			else
			{
				curr=trie[curr][1];
			}
		}
		else	// Going down right child since maximising XOR
		{
			if(trie[curr][1]!=-1)
			{
				curr=trie[curr][1];
				ans^=(1<<j);
			}
			else
			{
				curr=trie[curr][0];
			}
		}
	}
	return ans;
}

int main()
{
	int t,i,j,n,ans,u,v,w;
	in(t);
	while(t--)
	{
		in(n);
		loop(n+1)
		{
			V[i].clear();
			vis[i]=0;
		}
		loop(n-1)
		{
			in2(u,v);
			u--;
			v--;
			in(w);
			V[u].PB(MP(v,w));
			V[v].PB(MP(u,w));
		}
		dfs(0,0);
		no_nodes=0;
		trie[0][0]=trie[0][1]=-1;
		loop(n)
			insert_trie(xor_sum[i]);
		j=0;
		ans=0;
		loop(n)
		{
			j=query_trie(xor_sum[i]);
			ans=maxm(ans,j);
		}
		out(ans);
	}
	return 0;
}
