#define _CRT_SECURE_NO_WARNINGS
#pragma comment(linker, "/stack:16777216")
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility> 
using namespace std;

#define FOR(i,a,b) for(int i = (a); i < (b); ++i)
#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)
#define REP(i,N) FOR(i, 0, N)
#define RREP(i,N) RFOR(i, N, 0)
#define FILL(A,value) memset(A,value,sizeof(A))

#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UINT;
typedef vector <int> VI;
typedef pair <int, int> PII;

const int INF = 1000000000;
const int MAX = 200000;
const int MAX2 = 2000000;
const int BASE = 1000000000;
const int CNT = 30;

struct test
{
	int n;
	VI U;
	VI V;
	VI W;
};

int cnt;
vector <PII> G[MAX];
int N[MAX*(CNT + 1) + 7][2];
VI Q;

// DFS from the root to find the XOR-sum from the root to each vertex
void dfs(int v, int p, int x)
{
	Q.PB(x);
	FOR(i, 0, SZ(G[v]))
	{
		int to = G[v][i].first;
		int w = G[v][i].second;
		if (to == p)
			continue;
		dfs(to, v, x ^ w);
	}
}

// Add binary integer to the trie
void add(int x)
{
	int cur = 0;
	// Iterate through all bits
	for (int i = CNT; i >= 0; --i)
	{
		int d = ((x & (1 << i)) != 0);
		// If there is no corresponding vertex, add it
		if (N[cur][d] == -1)
		{
			N[cnt][0] = N[cnt][1] = -1;
			N[cur][d] = cnt++;
		}
		cur = N[cur][d];
	}
}

// Find the best result
int get(int x)
{
	int res = 0, cur = 0;
	// Iterate through all bits
	for (int i = CNT; i >= 0; --i)
	{
		int d = ((x & (1 << i)) == 0);
		// Try to go through the edge with opposite value
		if (N[cur][d] != -1)
		{
			res += (1 << i);
			cur = N[cur][d];
		}
		else
			cur = N[cur][!d];
	}
	return res;
}

int test_cnt;

int solve(test& T)
{
	int n = T.n;
	FOR(i, 0, n)
		G[i].clear();
	FOR(i, 0, n - 1)
	{
		G[T.U[i]].PB(MP(T.V[i], T.W[i]));
		G[T.V[i]].PB(MP(T.U[i], T.W[i]));
	}
	cnt = 1;
	N[0][0] = N[0][1] = -1;

	int res = 0;
	Q.clear();
	// DFS
	dfs(0, -1, 0);
	// Add all values
	FOR(i, 0, SZ(Q))
		add(Q[i]);
	// Try to get the best result using get function
	FOR(i, 0, SZ(Q))
		res = max(res, get(Q[i]));
	return res;
}


// Read the input
test read()
{
	test res;
	int n;
	cin >> n;
	res.n = n;
	FOR(i, 0, n - 1)
	{
		int u, v, w;
		//cin >> u >> v >> w;
		scanf("%d %d %d", &u, &v, &w);
		res.U.PB(u - 1);
		res.V.PB(v - 1);
		res.W.PB(w);
	}
	return res;
}


int main()
{
	// Read all the tests and solve them
	int test_cnt;
	cin >> test_cnt;
	FOR(i, 0, test_cnt)
	{
		test q;
		q = read();
		cout << solve(q) << endl;
	}
	return 0;
}
