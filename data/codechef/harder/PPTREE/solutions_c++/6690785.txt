/*

Paras Kumar Meena
~~~ Never Show Your Arrogance.Keep In Mind,You Were Born From A Drop Of Impure Liquid ~~~

*/

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000007
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){ return N=N | (1<<pos);}
int RESET(int N,int pos){   return N= N & ~(1<<pos);}
int check(int N,int pos){   return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){   printf("("); for(int i=6;i>=1;i--)  {bool x=check(N,i);cout<<x;}    puts(")");}
int mod(int a, int b) { return a - a/b * b;}
void Print(vector<int> Vec) { for(int i = 0; i < Vec.size(); ++i) cout<<Vec[i] << " ";puts("");}void Print(vector<ll> Vec) {for(int i = 0; i < Vec.size(); ++i) cout<< Vec[i] << "  "; puts("");}
void Print(vector<string> Vec) {for(int i = 0; i < Vec.size(); ++i) cout<< Vec[i] << " ";puts("");}
void Print(vector<double> Vec) {for(int i = 0; i < Vec.size(); ++i) cout<< Vec[i] << " ";puts("");}

int Tree[800000][3];
int N;
int IDX;
ll Arr[600000];
vector<pair<int, ll> > Gra[MXN + 10];


void init()
{
	Tree[0][0] = -1;
	Tree[0][1] = -1;
	IDX = 1;
	
	for(int i = 0; i < N; ++i)
		Gra[i].clear();
}

void insert(ll Num, int index)
{
	int idx = 31;
	int root = 0;
	while(idx >= 0) {
		int data = (Num & (1 << idx)) ? 1 : 0;
		if(Tree[root][data] == -1) {
			Tree[root][data] = IDX;
			Tree[IDX][0] = Tree[IDX][1] = -1;
			IDX++;
		}
		
		
		root = Tree[root][data];
		idx--;
	}
}

ll Query_max(ll Num)
{
	
	int idx = 31;
	int root = 0;
	ll ans = 0;
	
	while(idx >= 0) {
		int data = (Num & (1 << idx)) ? 1 : 0;
		int wanted = !data;
			
		if(Tree[root][wanted] != -1) {
			
			root = Tree[root][wanted];
			ans |= 1 << idx;
		
		} else {	
			root = Tree[root][data];
		}
		
		idx--;
	}
	
	return ans;
}


struct trie {
	trie * arr[2];
};
 
void insert (trie * t, int n, int index) {
	if (index < 0)
		return;
	int val = (n >> index) & 1;
	
	if (t->arr[val] == NULL) {
		t->arr[val] = new trie();
		insert (t->arr[val], n, index - 1);
	} else {
		insert (t->arr[val], n, index - 1);
	}
}
 
ll search (trie * t, int n, int index) {
	if (index < 0)
		return 0;
	int val = (n >> index) & 1;
 
	if (t->arr[val ^ 1] != NULL) {
		return (1 << index) + search (t->arr[val ^ 1], n, index - 1);
	} else {
		return search (t->arr[val], n, index - 1);
	}
}

void dfs(int idx, int prev, ll xr, int depth = 0)
{
	
	int size = Gra[idx].size();
	for(int i = 0; i < size; ++i) {
		pair<int, int> pp = Gra[idx][i];
		
		
		int v = pp.ff;
		ll w = pp.ss;
		
		if(v == prev)
			continue;
		
		ll nwxr = xr ^ w;
		Arr[v] = nwxr;
		dfs(v, idx, nwxr, depth + 1);
	}
}

int main()
{
	int T;
	scanf("%d", &T);
	
	while(T--) {
		
		scanf("%d", &N);
		
		
		init();
		
		
		for(int i = 0; i < N - 1; ++i) {
			int u;
			int v;
			ll w;
			scanf("%d%d%lld", &u, &v, &w);
			u--;
			v--;
			Gra[u].pb(mpa(v, w));
			Gra[v].pb(mpa(u, w));
		}
		
		dfs(0, 0, 0);
		
		trie* head = new trie();
		
		for(int i = 0; i < N; ++i) {
			insert(head, Arr[i], 31);	
		}
		
		ll ans = -1e18;
		
		for(int i = 0; i < N; ++i) {
			ll temp = search(head, Arr[i], 31);
			ans = max(ans, temp);		
		}
		printf("%lld\n", ans);
	}
	
	return 0;
}

/*

6
1 2 2
2 5 2
5 6 1
1 3 2
3 4 1

*/