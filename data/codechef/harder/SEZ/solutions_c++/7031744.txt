#include <iostream>
#include <vector>
#include <queue>
using namespace std;
 
const int MAXN=100009;
 
class HopcroftKarp
{
vector<int> adj[MAXN];
int match_left[MAXN];
int match_right[MAXN];
vector<int> left;
vector<int> right;
int d[MAXN];
int NIL;
int inf;

public:
 
HopcroftKarp(int n,vector<int> left_list,vector<int> right_list)
{
left=left_list;
right=right_list;
NIL=n;
inf=NIL+3;
}

void addEdge(int u,int v)
{
adj[u].push_back(v);
adj[v].push_back(u);
}

bool bfs()
{
queue<int> q;
for(int i=0;i<left.size();i++)
{
if(match_left[left[i]]==NIL)
{d[left[i]]=0;q.push(left[i]);}
else
d[left[i]]=inf;
}
d[NIL]=inf;
while(!q.empty())
{
int u=q.front();q.pop();
if(d[u]<d[NIL])
{
for(int i=0;i<adj[u].size();i++)
{
if(d[match_right[adj[u][i]]]==inf)
{d[match_right[adj[u][i]]]=d[u]+1;q.push(match_right[adj[u][i]]);}
}
}
}
return d[NIL]!=inf;
}

bool dfs(int u)
{
if(u!=NIL)
{
for(int i=0;i<adj[u].size();i++)
{
if(d[match_right[adj[u][i]]]==d[u]+1 && dfs(match_right[adj[u][i]]))
{match_left[u]=adj[u][i];match_right[adj[u][i]]=u;return true;}
}
d[u]=inf;
return false;
}
return true;
}

int getMaxMatching()
{
for(int i=0;i<left.size();i++)
match_left[left[i]]=NIL;
for(int i=0;i<right.size();i++)
match_right[right[i]]=NIL;
int matching=0;
while(bfs())
{
for(int i=0;i<left.size();i++)
if(match_left[left[i]]==NIL && dfs(left[i]))
matching++;
}
return matching;
}
 
};
 
int main() 
{
vector<int> left,right;
int n,m;
cin>>n>>m;
for(int i=0;i<n;i++)
left.push_back(i);
for(int i=n;i<2*n;i++)
right.push_back(i);
HopcroftKarp hk(2*n,left,right);
for(int i=0;i<m;i++)
{
int u,v;
cin>>u>>v;
hk.addEdge(u-1,n+v-1);
hk.addEdge(v-1,n+u-1);
}
cout<<n-hk.getMaxMatching()<<"\n";
}