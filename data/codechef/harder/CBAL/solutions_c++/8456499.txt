#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define m	325
#define n	100005
#define I64	long long
#define For(i,a,b)	for(int i=a;i<=b;i++)
#define Rep(i,a,b)	for(int i=a;i>=b;i--)

int		T,N,Q,S,L,A[n],B[n],V[n],G[n],D[m];
char	s[n];

struct	Nod{
		I64	a,b,c;
		Nod(I64 x=0,I64 y=0,I64 z=0)	{a=x;b=y;c=z;}
		void	Add(I64 k,int t=2)	{
			if	(t==0)	a++;
			if	(t==1)	a++,b+=k;
			if	(t==2)	a++,b+=k,c+=k*k;
		}
		void	DEL(I64 k,int t=2)	{
			if	(t==0)	a--;
			if	(t==1)	a--,b-=k;
			if	(t==2)	a--,b-=k,c-=k*k;
		}
		void	Up(const Nod&x,I64 k,int t=-1){
			if	(t==0)	a+=x.a;
			if	(t==1)	b+=x.a*k-x.b;
			if	(t==2)	c+=x.a*k*k-2*x.b*k+x.c;
			if	(t==-1)	a+=x.a,b+=x.a*k-x.b,c+=x.a*k*k-2*x.b*k+x.c;
		}
		void	Dn(const Nod&x,I64 k,int t=-1){
			if	(t==0)	a+=x.a;
			if	(t==1)	b-=x.a*k-x.b;
			if	(t==2)	c+=x.a*k*k-2*x.b*k+x.c;
			if	(t==-1)	a+=x.a,b-=x.a*k-x.b,c+=x.a*k*k-2*x.b*k+x.c;
		}
		Nod	operator -	(const Nod&x)	{return	Nod(a-x.a,b-x.b,c-x.c);}
}P[n],F[m][n],Ans[m][m];

I64		Work(int l,int r,int t){
		Nod	ret=Nod();
		if	(G[l]==G[r]||G[l]+1==G[r]){
			For(i,l,r)	ret.Up(P[A[i]],i,t),P[A[i]].Add(i,t);
			For(i,l,r)	P[A[i]].DEL(i,t);
		}	else	{
			ret=Ans[G[l]+1][G[r]-1];
			Rep(i,D[G[l]+1]-1,l)	ret.Dn(F[G[r]-1][A[i]]-F[G[l]][A[i]],i,t),F[G[r]-1][A[i]].Add(i,t);
			For(i,D[G[r]],r) ret.Up(F[G[r]-1][A[i]]-F[G[l]][A[i]],i,t),F[G[r]-1][A[i]].Add(i,t);
			Rep(i,D[G[l]+1]-1,l)	F[G[r]-1][A[i]].DEL(i,t);
			For(i,D[G[r]],r)	F[G[r]-1][A[i]].DEL(i,t);
		}
		return	(!t)?ret.a:(t==1?ret.b:ret.c);
}

#define CH	(ch=getchar())
int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}

int		main(){
		T=IN();
		for (;T--;*A=*B=S=0)	{
			scanf("%s",s+1);	N=strlen(s+1);
			For(i,1,N)	A[i]=A[i-1]^(1<<s[i]-'a');
			For(i,0,N)	B[++*B]=A[i];

			L=(int)(sqrt(N)+.5);
			sort(B+1,B+*B+1);	*B=unique(B+1,B+*B+1)-B-1;
			For(i,0,N)	A[i]=lower_bound(B+1,B+*B+1,A[i])-B;
			For(i,0,N)	V[i]=!(i%L),S+=V[i],G[i]=S;
			For(i,0,N)	if	(V[i])	D[G[i]]=i;	D[S+1]=N+1;	V[N+1]=1;G[N+1]=S+1;

			For(i,1,S)	{
				For(j,1,*B)	F[i][j]=Nod();
				For(j,0,D[i+1]-1)	F[i][A[j]].Add(j);
			}

			For(i,1,S)	{
				For(j,1,*B)	P[j]=Nod();	Nod	ret=Nod();
				For(j,D[i],N)	{
					ret.Up(P[A[j]],j),P[A[j]].Add(j);
					if	(V[j+1])Ans[i][G[j+1]-1]=ret;
				}
			}
			For(j,1,*B)	P[j]=Nod();

			Q=IN();
			for (I64 a=0,b=0;Q--;)	{
				int l=(IN()+a)%N+1,r=(IN()+b)%N+1;
				if	(l>r)	swap(l,r);
				I64 ret=Work(l-1,r,IN());
				printf("%lld\n",ret);	a=b;b=ret;
			}
		}
}