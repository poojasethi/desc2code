#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <cstdio>
#include <sstream>
#include <iostream>
#include <cstring>
#define REP(i,x,v)for(int i=x;i<=v;i++)
#define REPD(i,x,v)for(int i=x;i>=v;i--)
#define FOR(i,v)for(int i=0;i<v;i++)
#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)
#define pb push_back
#define sz size()
#define mp make_pair
#define fi first
#define se second
#define ll long long
#define pii pair<int,int>
#define vi vector<int>
#define IN(x,y) ((y).find((x))!=(y).end())
#define LOLDBG1
#ifdef LOLDBG
#define DBG(vari) cout<<#vari<<" = "<<vari<<endl;
#define DBG2(v1,v2) cout<<(v1)<<" - "<<(v2)<<endl;
#else
#define DBG(vari)
#define DBG2(v1,v2)
#endif
#define CZ(x) scanf("%d",&(x));
#define CZ2(x,y) scanf("%d%d",&(x),&(y));
#define ALL(x) (x).begin(),(x).end()
#define INF 2000000000
using namespace std;
template<typename T,typename TT> ostream &operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";}
template<typename T>ostream &operator<<(ostream &s,vector<T> t){s<<"{";FOR(i,t.sz)s<<t[i]<<(i==t.sz-1?"":",");return s<<"}"<<endl;}

int H,W;
int g[100][100];

const int maxnode=100000+5;
const int maxedge=100000+5;
const int oo=1000000000;

int node,src,dest,nedge;
int head[maxnode],point[maxedge],next[maxedge],flow[maxedge],capa[maxedge];
int dist[maxnode],Q[maxnode],work[maxnode];

void init(int _node,int _src,int _dest)
{
	node=_node;
	src=_src;
	dest=_dest;
	for (int i=0;i<node;i++) head[i]=-1;
	nedge=0;
}
void addedge(int u,int v,int c1,int c2)
{
	point[nedge]=v,capa[nedge]=c1,flow[nedge]=0,next[nedge]=head[u],head[u]=(nedge++);
	point[nedge]=u,capa[nedge]=c2,flow[nedge]=0,next[nedge]=head[v],head[v]=(nedge++);
}
bool dinic_bfs()
{
	for (int i=0;i<node;i++) dist[i]=-1;
	dist[src]=0;
	int sizeQ=0;
	Q[sizeQ++]=src;
	for (int cl=0;cl<sizeQ;cl++)
		for (int k=Q[cl],i=head[k];i>=0;i=next[i])
			if (flow[i]<capa[i] && dist[point[i]]<0)
			{
				dist[point[i]]=dist[k]+1;
				Q[sizeQ++]=point[i];
			}
	return dist[dest]>=0;
}
int dinic_dfs(int x,int exp)
{
	if (x==dest) return exp;
	int res=0;
	for (int &i=work[x];i>=0;i=next[i])
	{
		int v=point[i],tmp;
		if (flow[i]<capa[i] && dist[v]==dist[x]+1 && (tmp=dinic_dfs(v,min(exp,capa[i]-flow[i])))>0)
		{
			flow[i]+=tmp;
			flow[i^1]-=tmp;
			res+=tmp;
			exp-=tmp;
			if (exp==0) break;
		}
	}
	return res;
}
int dinic_flow()
{
	int result=0;
	while (dinic_bfs())
	{
		for (int i=0;i<node;i++) work[i]=head[i];
		result+=dinic_dfs(src,oo);
	}
	return result;
}



int r1,c1,r2,c2;
int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
int getID(int r, int c) { return r*W+c; }

int main()
{

    int t;CZ(t);
    while(t--)
    {
        scanf("%d %d",&H,&W);
        DBG(H);
        
		scanf("%d %d %d %d",&r1,&c1,&r2,&c2);
		r1--; c1--; r2--; c2--;
		init(H*W*5,getID(r1,c1)*5+4,getID(r2,c2)*5+4);
		for (int i=0;i<H;i++) for (int j=0;j<W;j++) scanf("%d",&g[i][j]);
		DBG(g[0][0]);
		
		for (int i=0;i<H;i++) {
			for (int j=0;j<W;j++) {
				vector<pii> neigh;
				for (int d=0;d<4;d++) {
					int i2=i+dir[d][0], j2=j+dir[d][1];
					if (i2<0 || H<=i2 || j2<0 || W<=j2) continue;
					neigh.push_back(make_pair(g[i2][j2]-g[i][j]+1,getID(i2,j2)));
				}
				while (neigh.size()<4) neigh.push_back(make_pair(-1,-1));
				sort(neigh.begin(),neigh.end());
				for (int k=0;k<4;k++) {
					int dif=neigh[k].first, id=neigh[k].second, fl;
					if (dif<0) fl=0; else fl=dif;
					if (getID(i,j)==getID(r2,c2)) fl=INF;
					addedge(getID(i,j)*5+k, getID(i,j)*5+k+1, fl,0);
					if (id!=-1 && dif>=0) {
						addedge(id*5+4, getID(i,j)*5+k, INF,0);
					}
				}
			}
		}

        //FOR(i,kr.sz) wypisz(kr[i]);
        int ff=dinic_flow();
        if (ff>=INF) cout<<-1<<endl;
        else
            cout<<ff<<endl;
    }

    return 0;
}
