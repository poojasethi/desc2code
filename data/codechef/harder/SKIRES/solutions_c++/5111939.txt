#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define REP(i,n) for (int i=1;i<=n;++i)
#define FOR(i,n) for (__typeof(n.begin())i=n.begin();i!=n.end();++i)
using namespace std;

const int INF=1999999999;
const int dx[4]={1,0,-1,0};
const int dy[4]={0,1,0,-1};
struct VVVV{int s,e,c,nxt;} v[8000800];
int a[55][55];
int num[55][55];
int h[20020],vh[20020];
int first[20020];
int now[20020];
int Tim,n,m,ans,sx,sy,ex,ey,pppp,nnnn,S,T;

bool Inmap(int x,int y) {
	return (1<=x)&&(x<=n)&&(1<=y)&&(y<=m);
}

void Add(int x,int y,int z) {
//	printf("%d %d %d\n",x,y,z);
	v[++pppp].s=x; v[pppp].e=y; v[pppp].c=z;
	v[pppp].nxt=first[x]; first[x]=now[y]=pppp;
	v[++pppp].s=y; v[pppp].e=x; v[pppp].c=0;
	v[pppp].nxt=first[y]; first[y]=now[y]=pppp;
}

int Sap(int k,int full) {
	if (k==T) return full;
	int ret=0;
	for (int p=now[k];p;now[k]=p=v[p].nxt)
		if (h[v[p].e]+1==h[k] && v[p].c) {
			int tmp=Sap(v[p].e,min(v[p].c,full-ret));
			ret+=tmp;
			v[p].c-=tmp;
			v[p^1].c+=tmp;
			if (ret==full) return ret;
		}
	--vh[h[k]];
	if (!vh[h[k]]) h[S]=nnnn+2;
	++h[k];
	++vh[h[k]];
	now[k]=first[k];
	return ret;
}

int main() {
	scanf("%d",&Tim);
	REP(T_T,Tim) {
		scanf("%d%d",&n,&m);
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
		REP(i,n) REP(j,m) scanf("%d",&a[i][j]);
		pppp=1;
		memset(first,0,sizeof(first));
		memset(now,0,sizeof(now));
		nnnn=0;
		REP(i,n) REP(j,m) num[i][j]=++nnnn;
		S=num[sx][sy];
		T=num[ex][ey];
		REP(i,n) REP(j,m) {
			if (num[i][j]==S) continue;
			vector< pair<int,int> > v;
			v.clear();
			REP(k,4) {
				int x=i+dx[k-1];
				int y=j+dy[k-1];
				if (!Inmap(x,y)) continue;
				if (a[x][y]>=a[i][j]) {
					if (num[i][j]!=T)
						v.push_back(make_pair(-(a[x][y]-a[i][j]+1),num[x][y]));
					else
						v.push_back(make_pair(-INF,num[x][y]));
				}
			}
			sort(v.begin(),v.end());
			int now=num[i][j];
			FOR(p,v) {
				Add(++nnnn,now,-p->first);
				Add(p->second,nnnn,INF);
				now=nnnn;
			}
		}
		memset(h,0,sizeof(h));
		memset(vh,0,sizeof(vh));
		vh[0]=nnnn;
		ans=0;
		while (h[S]<=nnnn+1) {
			ans+=Sap(S,INF);
			if (ans>=INF) {ans=-1;break;}
		}
		printf("%d\n",ans);
//		return 0;
	}
	return 0;
}
