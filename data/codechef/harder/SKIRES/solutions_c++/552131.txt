#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
#include <iostream>
#include <ctime>

using namespace std;
typedef long long i64;
typedef unsigned long u32;

template<class T> int size(const T & a) {
	return int(a.size());
}
template<class T> T sqr(const T &a) {
	return a * a;
}
const int max_n = 50, max_v = 4 * max_n * max_n, max_e = max_v * 4 * 2;
struct Edge {
	int v;
	int f;
	int c;
	int cost;
	Edge* p;
	Edge* next;
	void Add(int v, int c, Edge* p, Edge* &head) {
		this->v = v;
		this->f = 0;
		this->c = c;
		this->p = p;
		this->next = head;
		head = this;
	}
	void Add(int v, int c, int cost, Edge* p, Edge* &head) {
		this->v = v;
		this->f = 0;
		this->c = c;
		this->p = p;
		this->cost = cost;
		this->next = head;
		head = this;
	}
};
struct Graph {
	Edge* h[max_v];
	Edge* it[max_v];//for Dinic
	Edge edges[max_e];
	Edge* e;
	void init(int n) {
		for (int i = 0; i < n; i++) h[i] = 0;
		e = edges;
	}
	void init_it(int n) {
		for (int i = 0; i < n; i++) {
			it[i] = h[i];
		}
	}
	void AddEdge(int v1, int v2, int c) {
		(e + 0)->Add(v2, c, e + 1, h[v1]);
		(e + 1)->Add(v1, 0, e + 0, h[v2]);
		e += 2;
	}
	inline Edge* head(int v) const{
		return h[v];
	}
	inline Edge*& begin(int v) {
		return it[v];
	}
} g;
struct Dinic {
	int was[max_v];
	int st[max_v];
	int s, t, n;
	void bfs() {
		was[s] = 1;
		st[0] = s;
		for (int down = 0, up = 1; down < up; down++) {
			int i = st[down];
			if (i == t) {
				break;
			}
			for (Edge* e = g.head(i); e; e = e->next) {
				if (e->f < e->c && !was[e->v]) {
					was[e->v] = was[i] + 1;
					st[up++] = e->v;
				}
			}
		}
	}
	int dfs(int i, int mf) {
		if (i == t) return mf;
		int sdf = 0;
		for (Edge* &e = g.begin(i); e; e = e->next) {
			if (e->f < e->c && was[i] + 1 == was[e->v]) {
				int df = dfs(e->v, min(mf, e->c - e->f));
				if (df) {
					e->f += df;
					e->p->f -= df;
					sdf += df;
					mf -= df;
				}
				if (mf == 0) break;
			}
		}
		return sdf;
	}
	int dinic(int s, int t, int n) {
		this->s = s;
		this->t = t;
		this->n = n;
		int flow = 0;
		while (1) {
			for (int i = 0; i < n; i++) {
				was[i] = 0;
			}
			g.init_it(n);
			bfs();
			if (was[t]) {
				for (int d = 0; (d = dfs(s, int(1e9)));) {
					flow += d;
				}
			} else {
				break;
			}
		}
		return flow;
	}
} dinic;

int a[max_n][max_n];
const int di[4] = {-1, 1, 0, 0};
const int dj[4] = {0, 0, -1, 1};
struct Pair {
	int v, h;
	void Init(int v, int h) {
		this->v = v;
		this->h = h;
	}
	bool operator < (const Pair &p) const {
		return h < p.h;
	}
} b[4];

int main() {
#ifdef pperm
	freopen("input.txt", "r", stdin);
#endif
	int T;
	scanf("%d", &T);
	while (T--) {
		int n, m;
		scanf("%d %d", &n, &m);
		int sr, sc, tr, tc;
		scanf("%d %d %d %d", &sr, &sc, &tr, &tc);
		sr--,sc--;
		tr--,tc--;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				scanf("%d", &a[i][j]);
			}
		}
		if (a[sr][sc] < a[tr][tc]) {
			printf("0\n");
			continue;
		}
		if (abs(sr - tr) + abs(sc - tc) <= 1) {
			printf("-1\n");
			continue;
		}
		int s = sr * m + sc, t = tr * m + tc;
		int nV = n * m;
		g.init(nV * 4);
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				int u = 0;
				int v0 = i * m + j;
				for (int dir = 0; dir < 4; dir++) {
					int r = i + di[dir], c = j + dj[dir];
					if (r >= 0 && r < n && c >= 0 && c < m && a[r][c] >= a[i][j]) {
						int v = r * m + c;
						if (t == v0) {
							b[u++].Init(nV, int(2e9));
						} else {
							b[u++].Init(nV, a[r][c] - a[i][j] + 1);
						}
						g.AddEdge(v, nV++, int(2e9));
					}
				}
				if (u) {
					sort(b, b + u);
					g.AddEdge(b[0].v, v0, b[0].h);
					for (int i = 1; i < u; i++) {
						g.AddEdge(b[i].v, b[i - 1].v, b[i - 1].h);
						g.AddEdge(b[i].v, v0, b[i].h - b[i - 1].h);
					}
				}
			}
		}
		printf("%d\n", dinic.dinic(s, t, nV));
	}
	return 0;
}
