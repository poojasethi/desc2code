#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
 
#define X 55
#define N (X*X*5)
#define M (N*10)
#define INF 1000000000
 
int n, m, A[X][X], num, t, S, T, a[N], nx[M], to[M], h[N], f[M], gap[N];
 
int sap(int v, int m)
{
	if (v == T) return m;
	int l = m;
	for (int p = a[v]; p; p = nx[p])
		if (f[p] && h[v] == h[to[p]] + 1)
		{
			int d = sap(to[p], min(l, f[p]));
			f[p] -= d, f[p ^ 1] += d, l -= d;
			if (h[S] == num || !l) return m - l;
		}
	if (--gap[h[v]])
		++gap[++h[v]];
	else
		h[S] = num;
	return m - l;
}
int qu[N];
 
int maxflow()
{
	for (int i = 0; i <= num; ++i)
		h[i] = num, gap[i] = 0;
	h[qu[1] = T] = 0;
	for (int op = 0, cl = 1; op < cl;)
	{
		int x = qu[++op];
		gap[h[x]]++;
		for (int i = a[x], j; j = to[i], i; i = nx[i])
			if (h[j] == num && f[i ^ 1])
				h[qu[++cl] = j] = h[x] + 1;
	}
	int ret = 0;
	while (h[S] < num)
		ret += sap(S, INF);
	return ret;
}
 
 
 
const int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};
inline int code(int x, int y, int z)
{
	return ((x - 1) * m + y) * 5 - z;
}
 
void add(int x, int y, int z)
{
	nx[++t] = a[x];
	to[a[x] = t] = y;
	f[t] = z;
	nx[++t] = a[y];
	to[a[y] = t] = x;
	f[t] = 0;
}
 
int main()
{
//	freopen("ski.in", "r", stdin);
//	freopen("ski.out", "w", stdout);
	int ts;
	for (scanf("%d", &ts); ts--;)
	{
		int xs, ys, xt, yt;
		scanf("%d%d%d%d%d%d", &n, &m, &xs, &ys, &xt, &yt);
		num = n * m * 5;
		S = code(xs, ys, 0);
		T = code(xt, yt, 0);
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				scanf("%d", &A[i][j]);
		if (A[xs][ys] < A[xt][yt])
		{
			puts("0");
			continue;
		}
		if (abs(xs - xt) + abs(ys - yt) <= 1)
		{
			puts("-1");
			continue;
		}
		t = 1;
		memset(a, 0, sizeof a);
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
			{
				int ds[6];
				int d = 0, x, y;
				for (int k = 0; k < 4; ++k)
					if (A[i][j] <= A[x = i + dx[k]][y = j + dy[k]] && x && x <= n && y && y <= m)
						ds[d++] = A[x][y] - A[i][j] + 1;
				sort(ds, ds + d);
				d = unique(ds, ds + d) - ds;
				reverse(ds, ds + d);
				for (int k = 0; k < 4; ++k)
					if (A[i][j] <= A[x = i + dx[k]][y = j + dy[k]] && x && x <= n && y && y <= m)
						for (int s = 0; s < d; ++s)
							if (A[x][y] - A[i][j] + 1 == ds[s])
							{
								add(code(x, y, 0), code(i, j, s + 1), INF);
								break;
							}
				for (int k = 0; k < d; ++k)
					add(code(i, j, k + 1), code(i, j, k), (i - xt || j - yt) ? ds[k]: INF);
			}
		printf("%d\n", maxflow());
	}
	return 0;
}
 