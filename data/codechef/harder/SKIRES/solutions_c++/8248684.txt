#include <cstdio>
#include <cmath>
#include <algorithm>
 
using namespace std;
const int max_n = 50, max_v = max_n * max_n * 4, max_e = max_v * 4 * 2;
struct Edge {
	int v;
	int f;
	int c;
	Edge* p;
	Edge* next;
	void Add(int v, int c, Edge* &head, Edge* p) {
		this->v = v;
		this->f = 0;
		this->c = c;
		this->next = head;
		this->p = p;
		head = this;
	}
} edges[max_e];
Edge* h[max_v];
Edge* w[max_v];
int a[max_n][max_n];
int st[max_v];
int was[max_v];
Edge* p[max_v];
const int di[4] = {-1, 1, 0, 0};
const int dj[4] = {0, 0, -1, 1};
 
void AddEdge(int v1, int v2, int c, Edge* &e) {
	(e + 0)->Add(v2, c, h[v1], e + 1);
	(e + 1)->Add(v1, 0, h[v2], e + 0);
	e += 2;
}
struct Pair {
	int v, h;
	void Init(int v, int h) {
		this->v = v;
		this->h = h;
	}
	bool operator < (const Pair &p) const {
		return h < p.h;
	}
} b[4];
int s, t;
int dfs(int i, int d) {
	if (i == t) return d;
	for (;w[i]; w[i] = w[i]->next) {
		if (w[i]->f < w[i]->c && was[i] + 1 == was[w[i]->v]) {
			int c = dfs(w[i]->v, min(d, w[i]->c - w[i]->f));
			if (c) {
				w[i]->f += c;
				w[i]->p->f -= c;
				return c;
			}
		}
	}
	return 0;
}
int main() {
#ifdef pperm
	freopen("input.txt", "r", stdin);
#endif
	int T;
	scanf("%d", &T);
	while (T--) {
		int n, m;
		scanf("%d %d", &n, &m);
		int sr, sc, tr, tc;
		scanf("%d %d %d %d", &sr, &sc, &tr, &tc);
		sr--,sc--;
		tr--,tc--;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				scanf("%d", &a[i][j]);
			}
		}
		if (a[sr][sc] < a[tr][tc]) {
			printf("0\n");
			continue;
		}
		if (abs(sr - tr) + abs(sc - tc) <= 1) {
			printf("-1\n");
			continue;
		}
		for (int i = 0; i < n * m; i++) {
			h[i] = 0;
		}
		Edge* e = edges;
		s = sr * m + sc, t = tr * m + tc;
		int nV = n * m;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				int u = 0;
				int v0 = i * m + j;
				for (int dir = 0; dir < 4; dir++) {
					int r = i + di[dir], c = j + dj[dir];
					if (r >= 0 && r < n && c >= 0 && c < m && a[r][c] >= a[i][j]) {
						int v = r * m + c;
						if (t == v0) {
							b[u++].Init(nV, int(2e9));
						} else {
							b[u++].Init(nV, a[r][c] - a[i][j] + 1);
						}
						h[nV] = 0;
						AddEdge(v, nV++, int(2e9), e);
					}
				}
				if (u) {
					sort(b, b + u);
					AddEdge(b[0].v, v0, b[0].h, e);
					for (int i = 1; i < u; i++) {
						AddEdge(b[i].v, b[i - 1].v, b[i - 1].h, e);
						AddEdge(b[i].v, v0, b[i].h - b[i - 1].h, e);
					}
				}
			}
		}
		int flow = 0;
		n = nV;
		while (1) {
			for (int i = 0; i < n; i++) {
				was[i] = 0;
				w[i] = h[i];
			}
			was[s] = 1;
			st[0] = s;
			p[s] = 0;
			for (int down = 0, up = 1; down < up; down++) {
				int i = st[down];
				if (i == t) {
					break;
				}
				for (Edge* e = h[i]; e; e = e->next) {
					if (e->f < e->c && !was[e->v]) {
						was[e->v] = was[i] + 1;
						st[up++] = e->v;
					}
				}
			}
			if (was[t]) {
				for (int d; d = dfs(s, int(1e9));) {
					flow += d;
				}
			} else {
				break;
			}
		}
		printf("%d\n", flow);
	}
	return 0;
}  