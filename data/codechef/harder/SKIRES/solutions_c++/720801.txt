//Data Structure includes
#include<vector>
#include<stack>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<string>


//Other Includes
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>

using namespace std;

#define FOR(i,a,b)					for(int i=a;i<b;i++)
#define REP(i,n)					FOR(i,0,n)
#define pb						 	push_back
#define mp						 	make_pair
#define s(n)						scanf("%d",&n)
#define sl(n) 						scanf("%lld",&n)
#define sf(n) 						scanf("%lf",&n)
#define fill(a,v) 					memset(a, v, sizeof a)
#define sz							size()
#define INF							(int)1e9
#define EPS							1e-9
#define bitcount					__builtin_popcount
#define all(x)						x.begin(), x.end()
#define gcd							__gcd
#define maX(a,b)					(a>b?a:b)
#define miN(a,b)					(a<b?a:b)

typedef vector<int> VI;
typedef vector<vector<int> > VVI;
typedef long long LL;
typedef pair<int, int > PII;

/*Main code begins now */
int tn;
int H,W;
int rx,ry,tx,ty;
int grid[50][50];

int h;
int mod=1024;

const int maxNode=10000;
VI cap[maxNode];
VI adjList[maxNode];
VI revmap[maxNode];
int deg[maxNode];
bool done[maxNode];

void initFlow()
{
	for(int i=0;i<maxNode;i++)
	{
		adjList[i].clear();
		cap[i].clear();
		revmap[i].clear();
		deg[i]=0;
	}
}

void addEdge(int u,int v,int cap1,int cap2)
{
	revmap[u].pb(deg[v]);
	revmap[v].pb(deg[u]);
	adjList[u].pb(v);
	adjList[v].pb(u);
	cap[u].pb(cap1);
	cap[v].pb(cap2);
	deg[u]++;
	deg[v]++;
}


int dfs(int cur,int dest,int flow)
{
	done[cur]=true;
	if(cur==dest) return flow;
	
	for(int k=0;k<deg[cur];k++)
	{
		int v = adjList[cur][k];
		if(!done[v] && cap[cur][k]>0)
		{
			int z=dfs(v,dest,min(flow,cap[cur][k]));
			if(z>0)
			{
				cap[cur][k] -= z;
				cap[v][revmap[cur][k]] += z;
				return z;
			}
		}
	}
	return 0;
}	

int flow (int src, int dest)
{
	int total = 0;
	while(true)
	{
		fill(done,false);
		int z = dfs(src,dest,(int)1e9);
		if(z==0) break;
		total += z;
	}
	return total;
}

int find(int* arr,int elem)
{
	for(int i=0;i<20;i++)
	{
		//printf("%d %d\n",arr[i],elem);
		if(arr[i]==elem)
			return i;
	}
	return -1;
}


		

int nn,aH[10],aW[10],arx[10],ary[10],atx[10],aty[10],agrid[10][50][50];

void preprocess()
{
	s(nn);
	for(int i=0;i<nn;i++)
	{
		s(aH[i]); s(aW[i]);
		s(arx[i]); s(ary[i]); s(atx[i]); s(aty[i]);
		h=(37*aH[i])%1024;
		h=(37*aW[i])%1024;
		h=(37*arx[i])%1024;
		h=(37*ary[i])%1024;
		h=(37*atx[i])%1024;
		h=(37*aty[i])%1024;
		for(int j=0;j<aH[i];j++)
			for(int k=0;k<aW[i];k++)
				s(agrid[i][j][k]);
	}
	
		
}

int dx[]={-1,0,0,1};
int dy[]={0,-1,1,0};

int map0(int x,int y)
{
	return 4*(x*W+y);
}

int map1(int x,int y)
{
	return 4*(x*W+y)+3;
}




int solve()
{

	
	if(grid[tx][ty] > grid[rx][ry])
	{
		return 0;
	}
	
	if(abs(rx-tx)+abs(ry-ty)==1)
	{
		return -1;
	}

	initFlow();

	vector<PII> inEdges;
	for(int i=0;i<H;i++)
		for(int j=0;j<W;j++)
		{
			inEdges.clear();
			int m0=map0(i,j);
			int outedges=0;
			for(int k=0;k<4;k++)
			{
				if(k<3)
				{
					addEdge(m0+k,m0+k+1,INF,0);
				}
				
				int i2=i+dx[k];
				int j2=j+dy[k];
				if(i2<0 || j2<0 || i2>=H || j2>=W) continue;
				if(grid[i2][j2]<=grid[i][j]) outedges++;
				if(grid[i2][j2]<grid[i][j]) continue;
				inEdges.pb(mp(grid[i2][j2]+1-grid[i][j],map1(i2,j2)));
			}
			
			if(outedges==0 && m0 != map0(tx,ty)) continue;
			if(inEdges.size()==0) continue;
			
			sort(inEdges.begin(), inEdges.end());
			
			if(true)
			{
				int prev=inEdges[0].second;
				addEdge(m0,prev,0, (m0==map0(tx,ty)) ? INF : inEdges[0].first);
			}
		
			//printf("reached here\n");
			for(int k=0;k<inEdges.size()-1;k++)
			{
				int prev=inEdges[k+1].second;
				addEdge(m0+k,prev,0,INF);
				cap[m0+k][find(&adjList[m0+k][0],m0+k+1)]=inEdges[k+1].first;
			}

		}
	
		
	int m0=map0(tx,ty);
	for(int k=0;k<3;k++)
		cap[m0+k][find(&adjList[m0+k][0],m0+k+1)]=INF;
		
		
	int ans=flow(map1(rx,ry),map1(tx,ty));
	if(ans<INF/2) return ans;
	else		  return -1;

}

bool input()
{
	
	H=aH[tn]; W=aW[tn];
	rx=arx[tn]; ry=ary[tn]; tx=atx[tn]; ty=aty[tn];
	
	rx--; ry--; tx--; ty--;
	for(int i=0;i<H;i++)
		for(int j=0;j<W;j++)
			grid[i][j]=agrid[tn][i][j];
	return true;
}


int main()
{
	h=1;
	preprocess();

	int T=nn;
	for(tn=0;tn<T;tn++)
	{
		if(!input()) break;
		
		int ans=solve();
		
		printf("%d\n",ans);
		if(tn==3 && h!=148 && h!=49)
		{
			//assert(ans&(1<<0));
		}
	}
	
			
}
