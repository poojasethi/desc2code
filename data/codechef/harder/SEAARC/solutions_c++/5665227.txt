/*
Test case:
Input

13
1 2 2 1 2 2 1 2 2 1 2 2 1

Output

120

100000
1 2 3 1 2 3 ....

685182122


100000
1 2 1 2 ....
479166697

10
2 1 2 1 2 2 1 2 1 2



100000
1 2 3 ..... 200 1 2 3 ...200 .....
418024485

100000
1 2 3 ... 5000 1 2 3 .. 5000 1 2 3 ....
216748838



1000000
1 2 3 4 ... 100 1 2 3 .. 100 ...   101 102 103... 116 ....     1 2 3 ..  100
623330716
*/


#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
#define N 100000
#define MAX 200
int ar[N + 1];
int mark[N + 1];
vector <int> pos[N + 1];
vector <int> C1,C2;
ll mod;
vector <ll> Values;
ll bit[N + 1],CL[N + 1];
ll sum[N + 1],cnt[N + 1];
ll T[N + 1];
ll invmod[30];
void Update(int pt,ll val)
{
    while(pt > 0)
    {
        bit[pt] = bit[pt] + val;
        if(bit[pt] >= mod) bit[pt] = bit[pt] - mod;
        pt -= (pt & -pt);
    }
}
ll Query(int pt,int n)
{
    ll sum = 0;
    while(pt <= n)
    {
        sum = sum + bit[pt];
        pt += (pt & -pt);
        if(sum >= mod) sum = sum - mod;
    }
    return sum;
}
ll Compute()
{
    int sz = Values.size();
    ll sum = 0,sqsum = 0;
    ll ans = 0;
    for(int k = 1 ; k<=sz ; k++)
    {
        ll val = Values[k-1];
        //printf("%lld ",val);
        ll K = (ll) k;
        ll Two = (ll) 2;
        sqsum = (sqsum + K*((val*val)%mod) + Two*((val*sum)%mod))%mod;
        sum = (sum + K*val)%mod;
        ll temp = sqsum + mod - sum;
        if(temp >= mod) temp = temp - mod;
        ans = ans + temp;
        if(ans >= mod) ans = ans - mod;
        //printf("%lld %lld %lld\n",ans,sqsum,sum);
    }
    //printf("\n");
    ans = (ans * invmod[2]) %mod;
    return ans;
}
/*ll Func(ll v)
{
    ll temp1 = ((v*(v+1))/2)%mod;
    ll temp2 = (temp1 * (temp1 - 7))%mod;
    if(temp2 < 0) temp2 = temp2 + mod;
    ll selfoverlaps = 0;
    selfoverlaps = (temp2*invmod[6] + v)%mod;
    int V = (int) v;
    ll selfIntersections = tarcs[V];
    ll tot = -selfoverlaps + selfIntersections + mod;
    if(tot >= mod) tot = tot - mod;
    return tot;
}*/
ll Func(ll v)
{
    ll t1 = ((v*(v-1))/2)%mod;
    ll t2 = ((v*(v-1)*(v-2))/6)%mod;
    ll t3 = (v*(v-1)*(v-2))%mod;
    t3 = (t3*(v-3))%mod;
    t3 = (t3 * invmod[24])%mod;
    ll res = (t1 + t2 + t3)%mod;
    return res;
}
void PreProcess()
{
    mod = pow(10,9) + 7;
    invmod[1] = 1;
    for(int i = 2 ; i<=30 ; i++)
    {
        ll I = (ll) i;
        int MOD = (int) mod;
        invmod[i] = (-(mod/I)*invmod[MOD%i])%mod + mod;
    }
}
int main()
{
    PreProcess();
    int n,i;
    //n = pow(10,5);
    scanf("%d",&n);
    //int l = n/2;
    /*for(i = 1 ; i<=10000 ; i++)
    {
        ar[i] = 1 + (i-1)%100;
    }
    int faltu = 1;
    for(i = n - 10000 + 1 ; i<=n ; i++)
    {
        if(faltu == 101) faltu = 1;
        ar[i] = faltu;
        faltu++;
    }
    faltu = 101;
    for(i = 10001 ; i<=n-10000 ; i++)
    {
        if(faltu == 117) faltu = 101;
        ar[i] = faltu;
        faltu++;
    }*/
    for(i = 1 ; i<=n ; i++)
    {
        //ar[i] = 1 + i%2;
        //ar[n-i+1] = 1 + i%2;
        //ar[i] = 1 + i/l;
        //ar[i] = 1 + (i-1)%5000;
        scanf("%d",&ar[i]);
        pos[ar[i]].push_back(i);
    }
    //printf("uttam\n");
    //for(int i = 0 ; i<n ; i++) cout<<ar[i+1] <<" ";
    //cout<<endl;
    //printf("here\n");
    for(i = 1 ; i<=N ; i++)
    {
        if(pos[i].size() > MAX)
        {
            C1.push_back(i);
            mark[i] = 1;
        }
        else
        {
            if(pos[i].size() > 0)
            {
                C2.push_back(i);
                mark[i] = 2;
            }
        }
        //if(pos[i].size() > 0) printf("%d %d\n",i,pos[i].size());
    }
    //cout<<C1.size();
    //cout<<C2.size();
    ll overlaps = 0;
    // C2 overlapped by C2
    for(i = 1 ; i<=n ; i++)
    {
        if(mark[ar[i]] == 2)
        {
            int sz = pos[ar[i]].size();
            int j;
            for(j = 0 ; j<sz ; j++)
            {
                if(pos[ar[i]][j] == i) break;
            }
            for(int k = j-1 ; k>=0 ; k--)
            {
                ll temp = Query(pos[ar[i]][k],n);
                overlaps = overlaps + temp;
                if(overlaps >= mod) overlaps = overlaps - mod;
                Update(pos[ar[i]][k],1);
            }
        }
    }
    //printf("%lld\n",overlaps);
    // C1 overlapped by C2;
    int sz1 = C1.size();
    int sz2 = C2.size();
    //cout<<sz1<<endl;
    //cout<<sz2<<endl;
    for(i = 0 ; i<sz2 ; i++)
    {
        //printf("%d %d\n",i,sz2);
        int sz = pos[C2[i]].size();
        for(int j = 0 ; j<sz1 ; j++)
        {
            Values.clear();
            for(int k = 1 ; k<sz ; k++)
            {
                int l = pos[C2[i]][k-1];
                int h = pos[C2[i]][k];
                vector <int> :: iterator itl = upper_bound(pos[C1[j]].begin(),pos[C1[j]].end(),l);
                vector <int> :: iterator ith = upper_bound(pos[C1[j]].begin(),pos[C1[j]].end(),h);
                int c = ith-itl;
                ll C = (ll)c;
                Values.push_back(C);
                //printf("%lld ",C);
            }
            //printf("\n");
            ll temp = Compute();
            overlaps = overlaps + temp;
            if(overlaps >= mod) overlaps = overlaps - mod;
            //int X;scanf("%d",&X);
        }
    }
    //printf("%lld\n",overlaps);
    // C1 and C2 overlapped by C1
    for(i = 0 ; i<sz1 ; i++)
    {
        ll tot = 0;
        for(int j = 1 ; j<=n ; j++)
        {
            if(ar[j] == C1[i])
            {
                tot = tot + 1;
                sum[j] = sum[j-1] + 1;
            }
            else sum[j] = sum[j-1];
        }
        for(int j = 1 ; j<=N ; j++) CL[j] = 0;
        for(int j = 1 ; j<=n ; j++)
        {
            ll f = 0;
            if(ar[j] == C1[i]) f = 1;
            ll temp = ((tot - sum[j]+f)*(CL[ar[j]]))%mod;
            CL[ar[j]] = CL[ar[j]] + sum[j];
            if(CL[ar[j]] >= mod) CL[ar[j]] = CL[ar[j]] - mod;
            overlaps = overlaps + temp;
            if(overlaps >= mod) overlaps = overlaps - mod;
        }
        ll temp1 = ((tot*(tot - 1))/2)%mod;
        overlaps = overlaps - temp1 + mod;
        if(overlaps >= mod) overlaps = overlaps - mod;
    }
    //printf("%lld\n",overlaps);
    for(i = 1 ; i<=N ; i++) CL[i] = 0;
    ll ans = 0;
    for(i = 1 ; i<=n ; i++)
    {
        T[i] = T[i-1] + cnt[ar[i]];
        if(T[i] >= mod) T[i] = T[i] - mod;
        ll temp = (cnt[ar[i]] * T[i])%mod - CL[ar[i]] + mod;
        if(temp >= mod) temp = temp - mod;
        ans = ans + temp;
        if(ans >= mod) ans = ans - mod;
        CL[ar[i]] = CL[ar[i]] + T[i];
        if(CL[ar[i]] >= mod) CL[ar[i]] = CL[ar[i]] - mod;
        cnt[ar[i]] = cnt[ar[i]] + 1;
        //printf("%lld %lld %lld %lld\n",T[i],CL[1],cnt[1],ans);
    }
    //printf("%lld",ans-overlaps);
    ans = ans - overlaps + mod;
    if(ans >= mod) ans = ans - mod;
    //printf("%lld\n",ans);
    for(i = 1 ; i<=N ; i++)
    {
        //if(cnt[i] == 0) continue;
        ll temp = Func(cnt[i]);
        ans = ans - temp + mod;
        if(ans >= mod) ans = ans - mod;
    }
    //printf("uttam\n");
    printf("%lld\n",ans);
    return 0;
}
