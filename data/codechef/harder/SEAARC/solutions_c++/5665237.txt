/*
Test case:
Input

13
1 2 2 1 2 2 1 2 2 1 2 2 1

Output

120


*/


#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
#define N 100000
#define MAX 200
int ar[N + 1];
int mark[N + 1];
vector <int> pos[N + 1];
vector <int> C1,C2;
ll mod;
vector <ll> Values;
ll bit[N + 1],CL[N + 1];
ll sum[N + 1],cnt[N + 1];
ll T[N + 1];
ll tarcs[N + 1];
ll invmod[105];
void Update(int pt,ll val)
{
    while(pt > 0)
    {
        bit[pt] = bit[pt] + val;
        if(bit[pt] >= mod) bit[pt] = bit[pt] - mod;
        pt -= (pt & -pt);
    }
}
ll Query(int pt,int n)
{
    ll sum = 0;
    while(pt <= n)
    {
        sum = sum + bit[pt];
        pt += (pt & -pt);
        if(sum >= mod) sum = sum - mod;
    }
    return sum;
}
ll Compute()
{
    int sz = Values.size();
    ll sum = 0,sqsum = 0;
    ll ans = 0;
    for(int k = 1 ; k<=sz ; k++)
    {
        ll val = Values[k-1];
        //printf("%lld ",val);
        ll K = (ll) k;
        ll Two = (ll) 2;
        sqsum = (sqsum + K*val*val + Two*val*sum)%mod;
        sum = (sum + K*val)%mod;
        ll temp = sqsum + mod - sum;
        if(temp >= mod) temp = temp - mod;
        ans = ans + temp;
        if(ans >= mod) ans = ans - mod;
        //printf("%lld %lld %lld\n",ans,sqsum,sum);
    }
    //printf("\n");
    ans = (ans * invmod[2]) %mod;
    return ans;
}
ll Func(ll v)
{
    ll temp1 = ((v*(v+1))/2)%mod;
    ll temp2 = (temp1 * (temp1 - 7))%mod;
    if(temp2 < 0) temp2 = temp2 + mod;
    ll selfoverlaps = 0;
    selfoverlaps = (temp2*invmod[6] + v)%mod;
    //cout<<selfoverlaps<<endl;
    ll selfIntersections = tarcs[v];
    //cout<<selfIntersections<<endl;
    ll tot = -selfoverlaps + selfIntersections + mod;
    if(tot >= mod) tot = tot - mod;
    return tot;
}
int main()
{
    invmod[1] = 1;
    mod = pow(10,9) + 7;
    int n,i;
    for(i = 2 ; i<=10 ; i++)
    {
        ll I = (ll) i;
        invmod[i] = (-(mod/I)*invmod[mod%I])%mod + mod;
    }
    ll arcsum = 0;
    for(i = 1 ; i<=N ; i++)
    {
        ll I = (ll) i;
        ll arcs = 0;
        arcs = (I*(I-1)/2)%mod;
        ll temp = ((arcs)*(I - 1) - arcsum + mod)%mod;
        tarcs[i] = tarcs[i-1] + temp;
        if(tarcs[i] >= mod) tarcs[i] = tarcs[i] - mod;
        arcsum = arcsum + arcs;
        if(arcsum >= mod) arcsum = arcsum - mod;
    }
    //n = pow(10,5);
    scanf("%d",&n);
    for(i = 1 ; i<=n ; i++)
    {
        //ar[i] = 1 + i%2;
        scanf("%d",&ar[i]);
        pos[ar[i]].push_back(i);
    }
    ll overlaps = 0;
    for(i = 1 ; i<=N ; i++)
    {
        if(pos[i].size() > MAX)
        {
            C1.push_back(i);
            mark[i] = 1;
        }
        else
        {
            if(pos[i].size() > 0)
            {
                C2.push_back(i);
                mark[i] = 2;
            }
        }
    }

    // C2 overlapped by C2
    for(i = 1 ; i<=n ; i++)
    {
        if(mark[ar[i]] == 2)
        {
            int sz = pos[ar[i]].size();
            int j;
            for(j = 0 ; j<sz ; j++)
            {
                if(pos[ar[i]][j] == i) break;
            }
            for(int k = j-1 ; k>=0 ; k--)
            {
                ll temp = Query(pos[ar[i]][k],n);
                overlaps = overlaps + temp;
                if(overlaps >= mod) overlaps = overlaps - mod;
                Update(pos[ar[i]][k],1);
            }
        }
    }
    //printf("%lld\n",overlaps);
    // C1 overlapped by C2;
    int sz2 = C2.size();
    int sz1 = C1.size();
    for(i = 0 ; i<sz2 ; i++)
    {
        int sz = pos[C2[i]].size();
        for(int j = 0 ; j<sz1 ; j++)
        {
            Values.clear();
            for(int k = 1 ; k<sz ; k++)
            {
                int l = pos[C2[i]][k-1];
                int h = pos[C2[i]][k];
                vector <int> :: iterator itl = upper_bound(pos[C1[j]].begin(),pos[C1[j]].end(),l);
                vector <int> :: iterator ith = upper_bound(pos[C1[j]].begin(),pos[C1[j]].end(),h);
                int c = ith-itl;
                ll C = (ll)c;
                Values.push_back(C);
            }
            ll temp = Compute();
            overlaps = overlaps + temp;
            if(overlaps >= mod) overlaps = overlaps - mod;
        }
    }
    //printf("%lld\n",overlaps);
    // C1 and C2 overlapped by C1
    for(i = 0 ; i<sz1 ; i++)
    {
        ll tot = 0;
        for(int j = 1 ; j<=n ; j++)
        {
            if(ar[j] == C1[i])
            {
                tot = tot + 1;
                sum[j] = sum[j-1] + 1;
            }
            else sum[j] = sum[j-1];
        }
        for(int j = 1 ; j<=N ; j++) CL[j] = 0;
        for(int j = 1 ; j<=n ; j++)
        {
            ll f = 0;
            if(ar[j] == C1[i]) f = 1;
            ll temp = ((tot - sum[j]+f)*(CL[ar[j]]))%mod;
            CL[ar[j]] = CL[ar[j]] + sum[j];
            if(CL[ar[j]] >= mod) CL[ar[j]] = CL[ar[j]] - mod;
            overlaps = overlaps + temp;
            if(overlaps >= mod) overlaps = overlaps - mod;
        }
        ll temp1 = ((tot)*(tot - 1)/2)%mod;
        overlaps = overlaps - temp1 + mod;
        if(overlaps >= mod) overlaps = overlaps - mod;
    }
    //printf("%lld\n",overlaps);
    for(i = 1 ; i<=N ; i++) CL[i] = 0;
    ll ans = 0;
    for(i = 1 ; i<=n ; i++)
    {
        T[i] = T[i-1] + cnt[ar[i]];
        if(T[i] >= mod) T[i] = T[i] - mod;
        ll temp = (cnt[ar[i]] * T[i])%mod - CL[ar[i]] + mod;
        if(temp >= mod) temp = temp - mod;
        ans = ans + temp;
        if(ans >= mod) ans = ans - mod;
        CL[ar[i]] = CL[ar[i]] + T[i];
        if(CL[ar[i]] >= mod) CL[ar[i]] = CL[ar[i]] - mod;
        cnt[ar[i]] = cnt[ar[i]] + 1;
        //printf("%lld %lld %lld %lld\n",T[i],CL[1],cnt[1],ans);
    }
    ans = ans - overlaps + mod;
    if(ans >= mod) ans = ans - mod;
    //printf("%lld\n",ans);
    for(i = 1 ; i<=N ; i++)
    {
        if(cnt[i] == 0) continue;
        ll temp = Func(cnt[i]);
        ans = ans - temp + mod;
        if(ans >= mod) ans = ans - mod;
    }
    printf("%lld\n",ans);
    return 0;
}
