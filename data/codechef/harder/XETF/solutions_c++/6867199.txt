#include <bits/stdc++.h>
#define ll long long
#define eps 1e-9
#define PI 2 * acos (0.0)
using namespace std;

const int mod = 1000000000 + 7;

// inverse mod of i%prime = bigmod(i,prime-2)
int bigmod (int k, int p)
{
	if (p == 0)
		return 1;
	if (p == 1)
		return k;
	int q = bigmod(k, p / 2);
	q = (q * 1LL * q) % mod;
	if (p % 2 == 0)
		return q;
	else
		return (q * 1LL * k) % mod;
}

int ncr[1002][1002]; // calculate nCr upto max_power+1

void cal_ncr()
{
    int a,b;
    for(a=0;a<=1001;a++) ncr[a][0]=1;
    for(a=1;a<=1001;a++) ncr[0][a]=0;

    for(a=1;a<=258;a++)
    {
        for(b=1;b<=a;b++)
        {
            ncr[a][b]=ncr[a-1][b]+ncr[a-1][b-1];
            if(ncr[a][b]>=mod) ncr[a][b]=ncr[a][b]-mod;
        }
    }
}

ll sum[1002];


ll power_sum(ll N,ll K)
{
    ll p,x,y,s,z;
    int k,a;
    p=(N+1)%mod;
    sum[0]=N%mod;

    z=(N+1)%mod;

    for(k=1;k<=K;k++)
    {
        p=(p*z)%mod;
        s=p-1; if(s<0) s=s+mod;
        y=0;
        for(a=k-1;a>=0;a--)
        {
            x=(ncr[k+1][k-a+1]*sum[a])%mod;
            y=(y+x)%mod;
        }
        s=s-y; if(s<0) s=s+mod;
        s=(s*bigmod(ncr[k+1][1],mod-2))%mod;

        sum[k]=s;
    }
    return sum[K];
}

int prime[78500];
int sieve() // RETURNS ACTUAL SIZE!!! NOT SIZE+1!!!! REMEMBER WELL!! >_<
{
    int a,b,c;
    c=0; prime[c]=2;
    bool *m=(bool *)calloc(1000006,sizeof(bool));
    for(a=3;a<=1000000;a=a+2)
    {
        if(!m[a])
        {
            prime[++c]=a;
            for(b=2*a;b<=1000000;b=b+a) m[b]=true;
        }
    }
    free(m);
    return c;
}

 // Here, max (N) < = 10^12

ll factors[22];

ll B[1005];


void compute_bernoulli_number()
{
    B[0]=1;

    ll a,b,c,x,y,s;

    for(a=1;a<=258;a++)
    {
        s=0;
        for(b=0;b<=a-1;b++)
        {
            s=( s+  ( ( (B[b]*ncr[a][b])%mod)*bigmod(a-b+1,mod-2))%mod )%mod;
            //cout<<bigmod(a-b+1,mod-2)<<" "<<<<endl;
        }
        B[a]=(1-s+mod);
        if(B[a]>=mod) B[a]=B[a]-mod;
        //cout<<B[a]<<endl;
    }
}



ll power_sum_bernoulli(ll N,ll K)
{
    ll a,b,c,x,y,z;

    z=0;

    y=N;

    for(a=K;a>=0;a--)
    {
          z=(z+ (((ncr[K+1][a]*B[a])%mod) *y )%mod)%mod;
          y=(y*N)%mod;
        //bigmod(N%mod,K+1-a))
    }

    return z;
}

void calc(ll N,ll K,ll sz)
{

    ll c,d,x,y,z,sum;

    z=N;

    int i,a,b,n,e;

    n=0;

    y=bigmod(K+1,mod-2);

    for(a=0;a<=sz && prime[a]*prime[a]*1ll<=N;a++)
    {
        i=prime[a];
        if(!(z%i))
        {
            factors[n++]=i;
            while(1)
            {
                if((z%i)) break;
                z=z/i;
            }
        }
    }

    if(z>1) factors[n++]=z;

    sum=0;

    //cout<<"Testing "<<N<<endl;

    for(a=0;a<(1<<n);a++)
    {
        x=1;
        e=0;
        for(b=0;b<n;b++)
        {
            if((a&(1<<b))){ e++; x=x*factors[b]; }
        }

        z=(y*power_sum_bernoulli((N/x)%mod,K))%mod;

        z=(bigmod((x%mod),K)*z)%mod;

        //cout<<"Factor "<<x<<" sum "<<power_sum(N/x,K)<<" total sum = "<<z<<endl;
        if((e%2))
        {
            sum=sum-z;
            if(sum<0) sum=sum+mod;
        }
        else
        {
            sum=sum+z;
            if(sum>=mod) sum=sum-mod;
        }
    }
    printf("%lld\n",sum);
}



int main()
{

    //freopen("0.in","r",stdin);
    //freopen("0.out","w",stdout);


	cal_ncr();

	compute_bernoulli_number();

	ll N,K,t;

	ll a,b,c,d,e,x,y,z,sz;

	sz=sieve();

	scanf("%lld",&t);

	while(t--)
	{
        scanf("%lld %lld",&N,&K);

        if(K>256)
        {
            z=0;
            for(a=1;a<=N;a++)
            {
                if(__gcd(a,N)==1)
                {
                    z=(z+bigmod(a,K))%mod;
                }
            }
            printf("%lld\n",z);
            continue;
        }

        calc(N,K,sz);
	}

    return 0;
}
