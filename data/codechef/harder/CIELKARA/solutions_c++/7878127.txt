/**
 * January Cook-Off 2013
 *
 * Problem:     CIELKARA - Ciel and Karaoke
 * Author:      Anton Lunyov (Tester)
 * Complexity:  O(IT^[(N-1)/2]) per test, where IT depends on the accuracy of the answer
 * Timing:      0.12 out of 2.013
 *
 * Description:
 * By scaling we can assume that K=1.
 * We fix values g(A[i]) = x[i], 1<=i<N. Then the minimal value of the integral
 * of 2*|g(t)-B[i]| over the interval [A[i], A[i+1]] could be easily calculated
 * in terms of d[i] = A[i+1]-A[i], x[i] and x[i+1] (see function area(d,x,y))
 * Then we should minimize the sum of such areas as a function of N-1 variables
 * x[1], ..., x[N-1] subject to conditions |x[i]-x[i+1]|<=d[i]
 * This function has the form
 * f[0](x[1]) + f[1](x[1],x[2]) + ... + f[N-2](x[N-2],x[N-1]) + f[N-1](x[N-1])
 * where f[j] is a convex piecewise quadratic function.
 * Due to this special form and convexity we could apply
 * the following tricky nested ternary search:
 * we do nested ternary search for variables x[2], x[4], ...
 * and then for each of the remaining variables do separate ternary searchs
 * since we have separate optimization problems.
 * We use golden section search here to reduce the number of calculations.
 */
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;
 
//clock_t start=clock();
//fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));
 
inline double sqr(double x) {
	return x * x;
}
 
const int maxN = 8;
 
int n;
// d[1], d[2], ..., d[N-2] length of segments
// b[0], b[1], ..., b[N-1] function values
int d[maxN], b[maxN];
// minB = min{b[i]}, maxB = max{b[i]}
int minB, maxB;
 
// x[1], ..., x[n-1] our variables
double x[maxN];
 
// return the minimal integral of 2|g(t)| over [0,d]
// where g(0)=x, g(d)=y and |g(t1)-g(t2)|<=|t1-t2| for all t1,t2
// see editorial for derivation of the formula
double area(double d, double x, double y) {
	double dif = fabs(x + y) - d;
	return x * x + y * y - (dif <= 0 ? 0 : dif * dif / 2);
}
 
// return the minimal integral of 2|g(t)| over [A[j-1], A[j+1]]
// where g(A[j-1]) = x[j-1], g(A[j]) = xj, g(A[j+1]) = x[j+1]
// and |g(t1)-g(t2)| <= |t1-t2| for all t1,t2
// Here A[0] = -inf, A[N] = inf
double area(int j, double xj) {
	double res = 0;
	if(j > 1) {
		res += area(d[j-1], x[j-1] - b[j-1], xj - b[j-1]);
	} else {
		res += sqr(xj - b[j-1]);
	}
	if(j < n-1) {
		res += area(d[j], xj - b[j], x[j+1] - b[j]);
	} else {
		res += sqr(xj - b[j]);
	}
	return res;
}
 
// the stuff needed for ternary search
double phi = (1+sqrt(5.))/2;
double coef1 = (phi+1)/(2*phi+1);
double coef2 = phi/(2*phi+1);
 
// the minimal value of iterations allowing desirable precision
const int IT = 27;
 
// the recursive routine that loop over variables x[2], x[4], ...
// do golden section search for each of them
// and consecutive golden section search
// for each of the remaining variables after fixing all x[2*k]
// i is even number - the inxed of variables we want to fix now
// prevx is the value we assign to x[i-2] is it exists
double func(int i, double prevx) {
	if (i > 2) {
		x[i-2] = prevx;
	}
	if (i >= n) {
		// this means we have already fix all x[2*k]
		// so we calculate the final result
		double res = 0;
		// we choose the optimal value for each of x[2*k-1]
		for (int j = 1; j < n; j += 2) {
			// L and R are end of the segment containing optimal value of x[j]
			// we initialize them by min{b[i]} and max{b[i]} resprectively
			// since it is clear that optimal g(t)
			// must satisfy inequalities minB <= g(t) <= maxB
			double L = minB, R = maxB;
			// but we also need to ensure inequalities |g(t1)-g(t2)|<=|t1-t2|
			// for t1=A[j], t2=A[j-1] if j>1 and
			// for t1=A[j], t2=A[j+1] if j<n-1
			if (j > 1) {
				// which transforms to |x[j] - x[j-1]| <= d[j-1], if j > 1
				L = max(L, x[j-1] - d[j-1]);
				R = min(R, x[j-1] + d[j-1]);
			}
			if (j < n-1) {
				// and to |x[j] - x[j+1]| <= d[j], if j < n-1
				L = max(L, x[j+1] - d[j]);
				R = min(R, x[j+1] + d[j]);
			}
			// cur is the minimal value of area(x[j])=A(x[j-1],x[j])+A(x[j],x[j+1])
			// from editorial, where x[j-1], x[j+1] are fixed and we seek for x[j]
			double cur = 1e100;
 
			// Golden Section Search
			double fL = area(j, L * coef1 + R * coef2);
			double fR = area(j, L * coef2 + R * coef1);
			for (int it = 0; ; ++it) {
				cur = min(cur, fL);
				cur = min(cur, fR);
				if (it == IT) {
					break;
				}
				if(fL < fR) {
					R = L * coef2 + R * coef1;
					fR = fL;
					fL = area(j, L * coef1 + R * coef2);
				} else {
					L = L * coef1 + R * coef2;
					fL = fR;
					fR = area(j, L * coef2 + R * coef1);
				}
			}
			// the optimal value of x[j]
			// we can use it to print the optimal vector x in the end just for fun
			x[j] = (L + R) / 2;
			res += cur;
		}
		// if n is odd then we need to add the integral from x[n-1] to infinity
		if (n % 2) {
			res += sqr(x[n-1] - b[n-1]);
		}
		return res;
	}
	// L and R are end of the segment containing optimal value of x[j]
	// we initialize them by min{b[i]} and max{b[i]} resprectively
	double L = minB, R = maxB;
	if (i > 2) {
		// but also need to enusr |g(A[i-2])-g(A[i])|<=|A[i-2]-A[i]|
		L = max(L, x[i-2] - d[i-2] - d[i-1]);
		R = min(R, x[i-2] + d[i-2] + d[i-1]);
	}
	// Golden Section Search for x[i]
	// almost coincide with the above one
	// I don't know how to avoid copy-pasting here
	double res = 1e100;
	double fL = func(i+2, L * coef1 + R * coef2);
	double fR = func(i+2, L * coef2 + R * coef1);
	for (int it = 0; ; ++it) {
		res = min(res, fL);
		res = min(res, fR);
		if (it == IT) {
			break;
		}
		if(fL < fR) {
			R = L * coef2 + R * coef1;
			fR = fL;
			fL = func(i+2, L * coef1 + R * coef2);
		} else {
			L = L * coef1 + R * coef2;
			fL = fR;
			fR = func(i+2, L * coef2 + R * coef1);
		}
	}
	x[i] = (L + R) / 2;
	return res;
}
 
int main() {
#ifndef ONLINE_JUDGE
	//freopen("in.txt","r",stdin);
	freopen("0.in","r",stdin);
	freopen("0_my.out","wb",stdout);
#endif
	int T;
	cin >> T;
	for (int t = 0; t < T; ++t)	{
		cin >> n; // n is defined globally
		int k;
		cin >> k;
		int a[maxN];
		for (int i = 1; i < n; ++i) {
			cin >> a[i];
		}
		// we care only about lengths of the segments where area(t) is constant
		// we do scaling to simplify the job and assume that k = 1
		// to handle this we simply need divide the answer by k
		for (int i = 1; i < n-1; ++i) {
			d[i] = k * (a[i+1] - a[i]); // d[] is defined globally
		}
 
		// minB and maxB defined globally
		minB = 20130120, maxB = 0;
		for (int i = 0; i < n; ++i)
		{
			cin >> b[i];
			minB = min(minB, b[i]);
			maxB = max(maxB, b[i]);
		}
 
		// we consider this case just for fun :)
		if (n == 2) {
			double res = sqr(double(b[0] - b[1])) / (4 * k);
			printf("%.10lf\n", res);
			continue;
		}
		double res = func(2, -1);
		res /= 2 * k;
		printf("%.10lf\n", res);
	}
	return 0;
}