#include <bits/stdc++.h>
using namespace std;
#define md int(2e5+100)
#define modul int(1e9+7)
#define inf int(1e9+7)
#define pii pair<int,int>
#define FOR(i,a,b) for( int i=(a),_b=(b);i<=_b;i++)
#define DOW(i,b,a) for( int i=(b),_a=(a);i>=_a;i--)
int xx[4]={0,0,1,-1};
int yy[4]={1,-1,0,0};
typedef long long ll;
int n,m;

vector<int> a[md];
int dep[md],par[md],nchild[md];
int head[md],pos[md],r[md], chain[md],que[md],nchain;
int h[md];
pii t[2][md*4];
int f[md];
priority_queue< pii > heap[md];

void dp(int x)
{
    nchild[x]=1;
    FOR(i,0,a[x].size()-1)
    {
        int y=a[x][i];
        dep[y]=dep[x]+1;
        par[y]=x;
        dp(y);
        nchild[x]+=nchild[y];
    }
}

int p;

void dfs(int x)
{
    if (head[nchain]==0) head[nchain]=x;
    p++;
    pos[x]=p;
    chain[x]=nchain;
    que[p]=x;
    int m=0;
    FOR(i,0,a[x].size()-1)
    {
        int y=a[x][i];
        if (nchild[m]<nchild[y])
        {
            m=y;
        }
    }
    if (m==0) { r[x]=p; return ;}
    dfs(m);
    FOR(i,0,a[x].size()-1)
    {
        int y=a[x][i];
        if (y==m) continue;
        nchain++;
        dfs(y);
    }
    r[x]=p;
}


void update(int x, pii p, int k)
{
    int node=h[x];
    t[k][node]=p;
    while (node/2!=0)
    {
        node/=2;
        t[k][node]=max(t[k][node*2],t[k][node*2+1]);
    }
}

pii ask(int a, int b, int l ,int r, int node, int k)
{
    if (l>b || r<a) return pii(-inf,-inf);
    if (a<=l && r<=b)
    {
        //cout<<l<<" "<<r<<" "<<t[k][node].first<<" "<<t[k][node].second<<endl;
        return t[k][node];
    }
    return max(ask(a,b,l,(l+r)/2,node*2,k),ask(a,b,(l+r)/2+1,r,node*2+1,k));
}

pii get(int l ,int r, int k)
{
    return ask(l,r,1,n,1,k);
}

void on(int x)
{
    f[x]=0;
    int d=dep[x];
    update(pos[x],make_pair(d,x),1);
    int v=x;
    while (x!=0)
    {
        heap[x].push(make_pair(d-2*dep[x],v));
        update(pos[x],heap[x].top(),0);
        x=par[head[chain[x]]];
    }
}

void off(int x)
{
    f[x]=1;
    int d=dep[x];
    update(pos[x],make_pair(-inf,-inf),1);
    int v=x;
    while (x!=0)
    {
        while (!heap[x].empty() && f[heap[x].top().second]==1)
        {
            heap[x].pop();
        }
        if (!heap[x].empty()) update(pos[x],heap[x].top(),0);
        else update(pos[x],pii(-inf,-inf),0);
        x=par[head[chain[x]]];
    }
}

void build(int l , int r, int node)
{
    t[0][node]=pii(-inf,-inf);
    t[1][node]=pii(-inf,-inf);
    if (l==r)
    {
        h[l]=node;
        return;
    }
    build(l,(l+r)/2,node*2);
    build((l+r)/2+1,r,node*2+1);
}


int solve(int x)
{
    pair<int,int> res=make_pair(-inf,-inf);
    int d=dep[x];
    res=get(pos[x],r[x],1); res.first-=d;
    while (x!=0)
    {
        int c=chain[x];
        pii tmp=get(pos[head[c]],pos[x]-1,0); tmp.first+=d;
        res=max(res,tmp);
        x=head[c];
        if (par[x]!=0)
        {
            int lef=pos[x];
            int rig=r[x];
            x=par[x];
            tmp=max(get(pos[x],lef-1,1),get(rig+1,r[x],1));
            tmp.first+=d-2*dep[x];
            res=max(res,tmp);
        }
        else break;
    }
    return res.second;
}

int main()
{
    //freopen("inp.txt","r",stdin);
    //freopen("o1.txt","w",stdout);
    int tcase;
    scanf("%d",&tcase);
    FOR(o,1,tcase)
    {
        scanf("%d%d",&n,&m);
        nchain=0;
        p=0;
        FOR(i,1,n)
        {
            a[i].clear();
            f[i]=0;
            head[i]=0;
            while (!heap[i].empty()) heap[i].pop();
        }
        FOR(i,2,n)
        {
            int x;
            scanf("%d",&x);
            a[x].push_back(i);
        }
        dp(1);
        dfs(1);
        build(1,n,1);
        FOR(i,1,n) on(i);
        FOR(i,1,m)
        {
            int x;
            scanf("%d",&x);
            bool done=false;
            if (f[x]==1)
            {
                on(x);
                done=true;
            }
            printf("%d\n",solve(x));
            if (!done)
            {
                off(x);
            }
        }
    }
}
