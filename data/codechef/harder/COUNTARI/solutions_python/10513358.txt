/*
WA ? 

#include <stdio.h>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <ctime>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <vector>

#define REP(I,A,B) for(register int I=A,_END_=B;I<=_END_;I++)
#define REPD(I,A,B) for(register int I=A,_END_=B;I>=_END_;I--)
#define FOR(I,A,B) for(int I=A,_END_=B;I<_END_;I++)
#define RI(X) scanf("%d",&X)
#define RII(X,Y) RI(X),RI(Y)
#define RIII(X,Y,Z) RI(X),RI(Y),RI(Z)
#define RL(X) X=Readint()
#define RLL(X,Y) RL(X),RL(Y)
#define RLLL(X,Y,Z) RL(X),RL(Y),RL(Z)
#define RS(X) scanf("%s",X)
#define RD(X) scanf("%lf",&X)
#define GCH getchar()
#define PCH(X) putchar(X)
#define MS(X,Y) memset(X,Y,sizeof(X))
#define MC(X,Y,var,len) memcpy(X,Y,sizeof(var)*(len))
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define pb(X) push_back(X)
#define mp(A,B) make_pair(A,B)
#define fr first
#define sc second
#define lch(p) (p+p)
#define rch(p) (p+p+1)
#define lowbit(X) ((X)&(-(X)))

using namespace std;

typedef pair<int,int> poi;
typedef vector<int> vi;
typedef pair<double,double> com;

inline long long Readint()
{
	long long ret=0;
	int f=1;
	char ch;
	do
	{
		ch=GCH;
		if (ch=='-') f*=-1;
	}while(ch>=0 && (ch<'0' || ch>'9'));

	while ('0'<=ch && ch<='9')
	{
		ret=ret*10+ch-'0';
		ch=GCH;
	}
	return ret*f;
}

void open()
{
	freopen("COUNTARI.in","r",stdin);
	freopen("COUNTARI.out","w",stdout);
}
void close()
{
	fclose(stdin);
	fclose(stdout);
}

const int MAXL = 66666;
const int MAXA = 33333;
const int MAXN = 101010;
const double pi = acos(-1);

com operator + (const com &a,const com &b){
	return mp(a.fr+b.fr,a.sc+b.sc);
}
com operator - (const com &a,const com &b){
	return mp(a.fr-b.fr,a.sc-b.sc);
}
com operator * (const com &a,const com &b){
	return mp(a.fr*b.fr-a.sc*b.sc,a.fr*b.sc+a.sc*b.fr);
}
com operator /(const com &a,const double &k){
	return mp(a.fr/k,a.sc/k);
}

int rev[MAXL];
com w[2][MAXL];
com A[MAXL];
com B[MAXL];
int N;
int bk;
int tt;

int pre[MAXL];
int suf[MAXL];
int n;
int mx;

int a[MAXN];

long long ans;

void prepare_fft(){
	int L=1;
	while ((1<<L) <= mx+mx) L++;
	N=1<<L;
	FOR(i,1,N) rev[i]=(rev[i>>1] >> 1) | ( (i&1)<<(L-1) );
	com omega=mp(cos(2*pi/N),sin(2*pi/N));
	w[0][0]=w[1][0]=w[0][N]=w[1][N]=mp(1,0);
	FOR(i,1,N) w[1][N-i]=w[0][i]=w[0][i-1]*omega;
}
void fft(com *x,int N,int way){
	FOR(i,1,N) if (rev[i]>i) swap(x[i],x[rev[i]]);
	register int step,l;
	register com *L,*R,*W,dt;
	for (register int i=2;i<=N;i<<=1)
	{
		l=i/2;
		step=N/i;
		for (register int j=0;j<N;j+=i)
		{
			L=x+j;
			R=x+j+l;
			W=w[way];
			FOR(k,0,l)
			{
				dt= (*R) * (*W);
				*R=*L-dt;
				*L=*L+dt;
				L++;
				R++;
				W+=step;
			}
		}
	}
	if (way)
		FOR(i,0,N) x[i]=x[i]/N;
}

int check(int mx){
	return (int)(sqrt(mx*log(mx)/log(2)));
}

void init(){
	RI(n);
	mx=0;
	FOR(i,0,n) RI(a[i]),mx=max(mx,a[i]);
	bk=max(check(mx*2),1);
	tt=(n-1)/bk;
}

void work(){
	register int L,R;
	register int aim;
	// 3 in 
	REP(i,0,tt)
	{
		L=i*bk;
		R=min((i+1)*bk-1,n-1);

		FOR(j,L,R)
		{
			pre[a[j]]++;
			REP(k1,j+2,R)
			{
				aim=a[j+1]*2-a[k1];
				if (aim>=0) ans+=pre[aim];
			}
		}

		FOR(j,L,R) pre[a[j]]--;
	}

	// 2 in and 1 in
	L=0; R=min(bk-1,n-1);
	FOR(i,R+1,n) suf[a[i]]++;

	FOR(k1,L,R)
	REP(k2,k1+1,R)
	{
		aim=a[k2]*2-a[k1];
		if (aim>=0) ans+=suf[aim];
	}
	
	REP(i,L,R) pre[a[i]]++;
	FOR(i,1,tt)
	{
		L=i*bk;
		R=min((i+1)*bk-1,n-1);
		REP(j,L,R) suf[a[j]]--;

		FOR(k1,L,R)
		REP(k2,k1+1,R)
		{
			aim=a[k1]*2-a[k2];
			if (aim>=0) ans+=pre[aim];
			aim=a[k2]*2-a[k1];
			if (aim>=0) ans+=suf[aim];
		}

		FOR(j,0,N) A[j]=B[j]=mp(0,0);
		REP(j,1,mx) A[j]=mp(pre[j],0),B[j]=mp(suf[j],0);
		fft(A,N,0);
		fft(B,N,0);
		FOR(j,0,N) A[j]=A[j]*B[j];
		fft(A,N,1);
		REP(j,L,R) ans+=(long long)(A[a[j]*2].fr+0.5);

		REP(j,L,R) pre[a[j]]++;
	}

	L=tt*bk;
	R=n-1;
	REP(i,L,R) suf[a[i]]--;

	FOR(k1,L,R)
	REP(k2,k1+1,R)
	{
		aim=a[k1]*2-a[k2];
		if (aim>=0 && aim<=mx) ans+=pre[aim];
	}

}

int main()
{

	open();
	int _=0;
	init();
	prepare_fft();
	work();
	cout << ans << endl;
	close();
	return 0;
}


*/
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
  
const double pi = acos(-1);
 
struct Complex {
    double x,y;
    Complex() {}
    Complex(double tx,double ty) {
        x = tx;
        y = ty;
    }
    Complex operator + (Complex b) {
        return Complex(x + b.x,y + b.y);
    }
    Complex operator - (Complex b) {
        return Complex(x - b.x,y - b.y);
    }
    Complex operator * (Complex b) {
        return Complex(x * b.x - y * b.y,x * b.y + y * b.x);
    }
    Complex operator *= (Complex b) {
        *this = Complex(x * b.x - y * b.y,x * b.y + y * b.x);
        return *this;
    }
};
 
Complex a[700010],b[700010];
int R[700010];
int num[700010],l[700010],r[700010],st[700010],ed[700010];
int n;
  
void fft(Complex *a,int f) {
    for (int i = 0; i < n; i++)
        if (i < R[i])
            swap(a[i],a[R[i]]);
    for (int i = 1; i < n; i <<= 1) {
        Complex wn(cos(pi / i),f * sin(pi / i));
        for (int j = 0; j < n; j += (i << 1)) {
            Complex w(1,0);
            for (int k = 0; k < i; k++) {
                Complex x = a[j + k],y = w * a[j + k + i];
                a[j + k] = x + y;
                a[j + k + i] = x - y;
                w *= wn;
            }
        }
    }
    if (f == -1)
        for (int i = 0; i < n; i++)
            a[i].x /= n;
}
 
int main() {
    int nn;
    scanf("%d",&nn);
    int mx = 0;
    for (int i = 1; i <= nn; i++) {
        scanf("%d",&num[i]);
        mx = max(mx,num[i]);
        r[num[i]]++;
    }
    mx++;
    mx = mx * 2 - 1;
    int L = 0;
    for (n = 1; n <= mx; n <<= 1)
        L++;
    for (int i = 0; i < n; i++)
        R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));
    int sz = 2000;
    int m = (nn - 1) / sz + 1;
    for (int i = 1; i <= m; i++) {
        st[i] = ed[i - 1] + 1;
        ed[i] = i * sz;
    }
    ed[m] = nn;
    long long ans = 0;
    for (int i = 1; i <= m; i++) {
        for (int j = st[i]; j <= ed[i]; j++)
            r[num[j]]--;
        for (int j = 0; j < n; j++)
            a[j] = Complex(l[j],0);
        for (int j = 0; j < n; j++)
            b[j] = Complex(r[j],0);
        fft(a,1);
        fft(b,1);
        for (int j = 0; j < n; j++)
            a[j] *= b[j];
        fft(a,-1);
        for (int j = st[i]; j <= ed[i]; j++)
            ans += ((long long)(a[2 * num[j]].x + 0.5));
        for (int j = st[i]; j <= ed[i]; j++) {
            for (int k = st[i]; k < j; k++)
                if (2 * num[j] - num[k] >= 0)
                    ans += r[2 * num[j] - num[k]];
            for (int k = j + 1; k <= ed[i]; k++)
                if (2 * num[j] - num[k] >= 0)
                    ans += l[2 * num[j] - num[k]];
            l[num[j]]++;
        }
    }
    cout << ans << endl;
    return 0;
} 