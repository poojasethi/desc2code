/********************************************
*                                           *
*    Solved By : Bir Bahadur Khatri(B'ru)   *
*      Be Positive,be Happy.                *
*                                           *
*********************************************/

#define ff first
#define D double
#define sz size()
#define ss second
#define PB push_back
#define SQR(n) (n*n)
#define CHR getchar()
#define NL printf("\n")
#include<bits/stdc++.h>
#define ULL unsigned LL
#define pi 2.0*acos(0.0)
#define LL long long int
#define S1(a) a=in<int>()
#define SL1(a) a=in<LL>()
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define all(a) a.begin(),a.end()
#define _Max(a,b,c) Max(a,Max(b,c))
#define _Min(a,b,c) Min(a,Min(b,c))
#define SL2(a,b) a=in<LL>(),b=in<LL>()
#define F(i,a,b) for(int i=a;i<b; i++)
#define S2(a,b) a=in<int>(),b=in<int>()
#define R(i,a,b) for(int i=a-1;i>=b; i--)
#define BitCnt(a) __builtin_popcountll(a)
#define MEM(a,val) memset(a,val,sizeof(a))
#define SL3(a,b,c) a=in<LL>(),b=in<LL>(),c=in<LL>()
#define S3(a,b,c) a=in<int>(),b=in<int>(),c=in<int>()
#define cp printf("***** here here here here *****\n");
#define trace1(x)                cerr << #x << ": " << x << endl;
#define InpOut freopen("A.in","r",stdin),freopen("A1.out","w",stdout)
#define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
#define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
#define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;

using namespace std;
template <typename T> T in(){char ch;T n = 0;bool ng = false;while (1){ch = getchar();if (ch == '-'){ng = true;ch = getchar();break;}if (ch>='0' && ch<='9')     break;}while (1){n = n*10 + (ch - '0');ch = getchar();if (ch<'0' || ch>'9')   break;}return (ng?-n:n);}
template<typename T>inline T POW(T B,T P){ if(P==0) return 1; if(P&1) return B*POW(B,P-1);  else return SQR(POW(B,P/2));}
template<typename T>inline T Gcd(T a,T b){if(a<0)return Gcd(-a,b);if(b<0)return Gcd(a,-b);return (b==0)?a:Gcd(b,a%b);}
template<typename T>inline T Lcm(T a,T b) {if(a<0)return Lcm(-a,b);if(b<0)return Lcm(a,-b);return a*(b/Gcd(a,b));}
long long Bigmod(long long base, long long power, long long MOD){long long ret=1;while(power){if(power & 1)ret=(ret*base)%MOD;base=(base*base)%MOD;power>>=1;}return ret;}
bool isVowel(char ch){ ch=toupper(ch); if(ch=='A'||ch=='U'||ch=='I'||ch=='O'||ch=='E') return true; return false;}
long long ModInverse(long long number, long long MOD){return Bigmod(number, MOD-2, MOD);}
bool isConst(char ch){if (isalpha(ch) && !isVowel(ch)) return true; return false;}
int toInt(string s)  { int sm; stringstream ss(s); ss>>sm; return sm; }

///**********************************************************//

#define MD1 1000000007ULL
#define MD2 1000000009ULL
#define MD3 1000000021ULL
#define BS1 10000019ULL
#define BS2 10000079ULL
#define BS3 10000103ULL
#define PUL pair<ULL,ULL>

///         0123456789
#define MX  100007
#define MOD 1000000007
#define INF 2000000000
#define EPS 1e-9
/// ==========================================////

struct base
{
    double real, imag;
    base(){real=0.0; imag=0.0;}
    inline void clr(){real=0.0; imag=0.0;}
} a[MX], b[MX];



void fft (base* a, int n, bool invert)
{
	for (int i=1, j=0; i<n; ++i)
	{
		int bit = (n >> 1);
		for (; j>=bit; bit>>=1)
			j -= bit;
		j += bit;
		if (i < j)
			swap (a[i], a[j]);
	}

	for (int len=2; len<=n; len<<=1)
	{
		double ang = 2*pi/len * (invert ? -1 : 1);

		double cs = cos(ang);
		double sn = sin(ang);

		for (int i=0; i<n; i+=len)
		{
			int hlen = (len >> 1);

			double wreal = 1;
			double wimag = 0;
			base u;

			base* pa1 = a + i;
			base* pa2 = a + i + hlen;

			for (int j=0; j<hlen; ++j)
			{
				base& a1 = *pa1++;
				base& a2 = *pa2++;

				u = a1;

				double vreal = a2.real * wreal - a2.imag * wimag;
				double vimag = a2.real * wimag + a2.imag * wreal;

				a1.real += vreal;
				a1.imag += vimag;

				a2.real = u.real - vreal;
				a2.imag = u.imag - vimag;

				double wreal2 = wreal;

				wreal = wreal * cs - wimag * sn;
				wimag = wreal2 * sn + wimag * cs;


			}
		}
	}
	if (invert)
		for (int i= n; i >= 0; --i)
			a[i].real /= n;
}

inline base multiply(const base& left, const base& right)
{
	base res;
	res.real = left.real * right.real - left.imag * right.imag;
	res.imag = left.real * right.imag + left.imag * right.real;

	return res;
}
void calc_fft(){

        int n = 1 , mx = 30000;
        while (n <  mx )  n <<= 1;
        n<<=1;


        fft(a, n, false);
        fft(b, n, false);
        for(int i=0;i<n;i++)
        {
            a[i] = multiply(a[i], b[i]);
        }
        fft(a, n, true);
}


int ar[100005];
int br[100005];
int st[355];

int F[30009][55];
int R[30009][55];
int n;

int vis[30007];

LL Solve(int sq) {
    int l=st[sq];
    MEM(vis,0);
    int r=min(n-1,st[sq+1]-1);
    int id=0;
    for(int i=l;i<=r;i++) {
        br[id++]=ar[i];
    }
    LL ans=0;

    for(int i=0;i<id;i++) {
        for(int j=i+1;j<id;j++) {
            int tp=2*br[i]-br[j];
            if(tp>=0&&tp<30000) {
                ans+=vis[ tp ];
                ans+=F[ tp ][ sq-1 ];
            }
        }
        vis[ br[i] ]++;
    }

    for(int i=id-1;i>=0;i--) {
        for(int j=i-1;j>=0;j--) {
            int tp=br[i]*2-br[j];
            if(tp>=0&&tp<30000) {
                ans+=R[ tp ][sq+1];
            }
        }
    }
    return ans;
}




LL DekhiFft(int sq) {
   for(int i=0;i<MX;i++) {
      a[i].real=b[i].real=0;
      a[i].imag=b[i].imag=0;
   }

   for(int i=0;i<30000;i++) {
      a[i].real=F[i][sq-1];
      b[i].real=R[i][sq+1];
   }
   calc_fft();
   LL ans=0;
   //cout<< "heeeeeeeeeeeeeeee\n";
   int l=st[sq];
   int r=min(n-1,st[sq+1]-1);
   //cout<<l<< " "<<r<<endl;
   for(int i=l;i<=r;i++) {
       ans+=(LL)( a[ ar[i]*2 ].real+0.5  );
   }
   return ans;
}

int main()
{
    S1(n);

    for(int i=0;i<n;i++) S1(ar[i]),ar[i]--;

    //n=100000;
    int sq=2875;
    //sq=sqrt(n);
    int fr=0;
    for(int i=0;i<n;i++) {
        if(i%sq==0) {
            fr++;
            st[fr]=i;
            for(int j=0;j<30000;j++) {
                F[j][fr]=F[j][fr-1];
            }
        }
        F[ ar[i] ][fr]++;
    }
    st[ fr+1 ]=n;

    int tot=fr;
    fr++;

    for(int i=n-1;i>=0;i--) {
        if((i+1)%sq==0||i==n-1) {
            fr--;
            for(int j=0;j<30000;j++) {
                R[j][fr]=R[j][fr+1];
            }
        }

        R[ ar[i] ][fr]++;
    }
    LL ans=0;

    for(int sqr=1;sqr<=tot;sqr++) {
        ans+=Solve(sqr);
        ans+=DekhiFft(sqr);
    }

    printf("%lld\n",ans);


    return 0;
}
///============= Thank You ===================///
