#include<bits/stdc++.h>
typedef long long int64;
const int maxn=100015,maxc=30015,maxb=515;
struct complex{
	double r,i;
	inline complex operator +(const complex &b){return (complex){r+b.r,i+b.i};}
	inline complex operator -(const complex &b){return (complex){r-b.r,i-b.i};}
	inline complex operator *(const complex &b){return (complex){r*b.r-i*b.i,r*b.i+i*b.r};}
	inline complex operator /(const int &b){return (complex){r/b,i/b};}
	inline complex operator *(const int &b){return (complex){r*b,i*b};}
};
struct FFT{
	static const int maxn=(1<<16)+15;
	int n,r[maxn];
	void assign(int _n){
		for (n=1;n<=_n<<1;n<<=1);
		for (int i=1;i<n;++i) r[i]=r[i-(i&-i)]+(n>>1)/(i&-i);
	}
	inline void clear(complex a[]){memset(a,0,sizeof(complex)*n);}
	inline void fft(complex a[],int rev){
		for (int i=0;i<n;++i) if (r[i]>i) std::swap(a[i],a[r[i]]);
		for (int s=2;s<=n;s<<=1){
			complex w0=(complex){cos(2*M_PI/s),sin(rev*2*M_PI/s)};
			for (int i=0;i<n;i+=s){
				complex w=(complex){1,0};
				for (int j=i;j<i+(s>>1);++j,w=w*w0){
					complex u=a[j],v=w*a[j+(s>>1)];
					a[j]=u+v;a[j+(s>>1)]=u-v;
				}
			}
		}
		if (rev==-1) for (int i=0;i<n;++i) a[i]=a[i]/n;
	}
}pol;
int n,siz,num,a[maxn],l[maxb],r[maxb];
void init(){
	using namespace std;
	scanf("%d",&n);siz=min(n,(int)sqrt(21*n));
	for (int i=0;i<n;++i) scanf("%d",&a[i]);
	for (int x=0;x<n;x+=siz){l[++num]=x;r[num]=min(n-1,x+siz-1);}
}
int64 ans;
int cnt[maxc];
void work(){
	pol.assign(30000);
	for (int i=1;i<=num;++i){
		memset(cnt,0,sizeof(cnt));
		for (int j=r[i]+1;j<n;++j) ++cnt[a[j]];
		for (int j=l[i]+1;j<=r[i];++j)
			for (int k=l[i];k<=j-1;++k){
				int t=2*a[j]-a[k];
				if (t>=0&&t<=30000) ans+=cnt[t];
			}
		memset(cnt,0,sizeof(cnt));
		for (int j=l[i]-1;j>=0;--j) ++cnt[a[j]];
		for (int j=r[i]-1;j>=l[i];--j)
			for (int k=r[i];k>=j+1;--k){
				int t=2*a[j]-a[k];
				if (t>=0&&t<=30000) ans+=cnt[t];
			}
		memset(cnt,0,sizeof(cnt));
		for (int j=l[i]+1;j<=r[i];++j) ++cnt[a[j]];
		for (int j=l[i];j<=r[i]-1;++j){
			for (int k=l[i];k<=j-1;++k){
				int t=2*a[j]-a[k];
				if (t>=0&&t<=30000) ans+=cnt[t];
			}
			--cnt[a[j+1]];
		}
		static complex A[FFT::maxn],B[FFT::maxn];
		pol.clear(A);pol.clear(B);
		for (int j=0;j<l[i];++j) A[a[j]].r+=1;
		for (int j=r[i]+1;j<n;++j) B[a[j]].r+=1;
		pol.fft(A,1);pol.fft(B,1);for (int j=0;j<pol.n;++j) A[j]=A[j]*B[j];pol.fft(A,-1);
		for (int j=l[i];j<=r[i];++j) if (2*a[j]<pol.n) ans+=(int64)round(A[2*a[j]].r);
	}
	printf("%lld\n",ans);
}
int main(){
	init();
	work();
	return 0;
}