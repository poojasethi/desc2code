#include"cstdio"
#include"queue"
#include"cmath"
#include"stack"
#include"iostream"
#include"algorithm"
#include"cstring"
#include"queue"
#include"map"
#include"set"
#include"vector"
#include"bitset"
#define LL long long
#define ull unsigned long long
#define clr(a,b,c) for(int i=0;i<a;i++) b[i]=c
#define mems(a,b) memset(a,b,sizeof(a))
#define ls pos<<1
#define rs pos<<1|1
#define lson L,mid,pos<<1
#define rson mid+1,R,pos<<1|1
#pragma comment(linker, "/STACK:1024000000,1024000000")
using namespace std;

const int N = 1e5+5;
const int M = 30005;
const int MOD = 313;
const int maxn = 1e5+5;
const int INF = 1e9+7;
const double PI = acos(-1.0);
/*namespace FFT{
    struct complex{
        double r , i;
        complex(double r=0 , double i=0):r(r),i(i){}
        complex operator+(const complex &a) const{
            return complex(r+a.r , i+a.i);
        }
        complex operator-(const complex &a) const{
            return complex(r-a.r , i-a.i);
        }
        complex operator*(const complex &a) const{
            return complex(r*a.r-i*a.i , r*a.i+i*a.r);
        }
    }x[N] , y[N];

    void change(complex y[] , int len){
        int i,j,k;
        for(i=1 , j=len/2 ; i<len-1 ; i++){
            if(i<j) swap(y[i],y[j]);
            k = len/2;
            while(j>=k){
                j-=k;
                k/=2;
            }
            if(j<k) j+=k;
        }
    }

    void fft(complex y[] , int len , int on){
        change(y , len);
        for(int i=2 ; i<=len ; i<<=1){
            complex wn(cos(-on*2*PI/i) , sin(-on*2*PI/i));
            for(int j=0 ; j<len ; j+=i){
                complex w(1,0);
                for(int k=j ; k<j+i/2 ; k++){
                    complex u = y[k];
                    complex t = w*y[k+i/2];
                    y[k] = u+t;
                    y[k+i/2] = u-t;
                    w = w*wn;
                }
            }
        }
        if(on==-1)
            for(int i=0 ; i<len ; i++)
                y[i].r /= len;

    }
    //a[] 与 b[] 的卷积保存到 c[] 中 ， 保证c[]可保存到长度是2倍
    void multiply(int *a , int *b , LL *c , int k ){
        for(int i=0 ; i<k ; i++) x[i] = complex(a[i] , 0);
        for(int i=0 ; i<k ; i++) y[i] = complex(b[i] , 0);

        fft(x , k , 1); fft(y , k , 1);
        for(int i=0 ; i<k ; i++)
            x[i] = x[i]*y[i];
        fft(x , k , -1);

        for(int i=0 ; i<k ; i++) c[i] = (LL)(x[i].r+0.5);
    }
};*/
struct Complex
{
    double r,i;
    Complex (double _r=0,double _i=0):r(_r),i(_i){}
    friend Complex operator + (const Complex &a,const Complex &b);
    friend Complex operator - (const Complex &a,const Complex &b);
    friend Complex operator * (const Complex &a,const Complex &b);
};

Complex operator + (const Complex &a,const Complex &b) {return Complex(a.r+b.r,a.i+b.i);}
Complex operator - (const Complex &a,const Complex &b) {return Complex(a.r-b.r,a.i-b.i);}
Complex operator * (const Complex &a,const Complex &b) {return Complex(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}

int rev[maxn];

void FFT(Complex *a,int N,int f)
{
    for (int i=0;i<N;i++) if (i<rev[i]) swap(a[i],a[rev[i]]);
    for (int i=1;i<N;i<<=1)
    {
        Complex wn(cos(M_PI/i),f*sin(M_PI/i));
        for (int j=0;j<N;j+=(i<<1))
        {
            Complex w(1,0);
            for (int k=0;k<i;k++,w=w*wn)
            {
                Complex x=a[j+k],y=w*a[j+k+i];
                a[j+k]=x+y,a[j+k+i]=x-y;
            }
        }
    }
    if (f==-1) for (int i=0;i<N;i++) a[i].r/=N;
}

Complex tempA[maxn],tempB[maxn],tempC[maxn];

void Polynomial_Multyply(int *a,int *b,int n,int m,LL *c)
{
    int N=1;
    while (N<n+m-1) N<<=1;
    for (int i=0;i<N;i++) rev[i]=(rev[i>>1]>>1)|((i&1)*(N>>1));
    for (int i=0;i<n;i++) tempA[i].r=a[i],tempA[i].i=0;for (int i=n;i<N;i++) tempA[i].r=tempA[i].i=0;
    for (int i=0;i<m;i++) tempB[i].r=b[i],tempB[i].i=0;for (int i=m;i<N;i++) tempB[i].r=tempB[i].i=0;
    FFT(tempA,N,1);FFT(tempB,N,1);
    for (int i=0;i<N;i++) tempC[i]=tempA[i]*tempB[i];
    FFT(tempC,N,-1);
    for (int i=0;i<N;i++) c[i]=(LL)(tempC[i].r+0.1);
}

int a[N],b[N];
LL c[N];
int lcnt[N],w[N],rcnt[N];
int n,unit=2300;
LL ans;

void solve_block(){
    for(int st=1;st<n;st+=unit){
        int ed=min(n,st+unit-1);
        for(int i=st;i<=ed;i++) rcnt[w[i]]--;
        for(int i=st;i<=ed;i++){
            for(int j=i+1;j<=ed;j++){
                if(w[j]*2-w[i]>=0) ans+=(LL)rcnt[w[j]*2-w[i]];
                if(w[i]*2-w[j]>=0) ans+=(LL)lcnt[w[i]*2-w[j]];
            }
            lcnt[w[i]]++;
        }
    }
}

void solve(){
    for(int st=unit+1,ed=st+unit-1;st<n;st+=unit,ed+=unit){
        mems(a,0);
        mems(b,0);
        if(ed>=n) return;
        int mxa=0,mxb=0;
        for(int i=1;i<st;i++) a[w[i]]++,mxa=max(w[i],mxa);
        for(int i=ed+1;i<=n;i++) b[w[i]]++,mxb=max(w[i],mxb);
        mxa++;mxb++;
        //int k=1;
        //while(k<mxa+mxb-1) k<<=1;
        //FFT:(a,b,c,k);
        Polynomial_Multyply(a,b,mxa,mxb,c);
        for(int i=st;i<=ed;i++) ans+=(LL)c[w[i]*2];
    }
}

int main(){
    //freopen("in.txt","r",stdin);
    while(~scanf("%d",&n)){
        mems(lcnt,0);
        mems(rcnt,0);
        ans=0;
        for(int i=1;i<=n;i++){
            scanf("%d",&w[i]);
            rcnt[w[i]]++;
        }
        solve_block();
        solve();
        printf("%lld\n",ans);
    }
    return 0;
}
