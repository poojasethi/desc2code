#include"cstdio"
#include"queue"
#include"cmath"
#include"stack"
#include"iostream"
#include"algorithm"
#include"cstring"
#include"queue"
#include"map"
#include"set"
#include"vector"
#include"bitset"
#define LL long long
#define ull unsigned long long
#define clr(a,b,c) for(int i=0;i<a;i++) b[i]=c
#define mems(a,b) memset(a,b,sizeof(a))
#define ls pos<<1
#define rs pos<<1|1
#define lson L,mid,pos<<1
#define rson mid+1,R,pos<<1|1
#pragma comment(linker, "/STACK:1024000000,1024000000")
using namespace std;

const int N = 1e5+5;
const int M = 30005;
const int MOD = 313;
const int maxn = 1e5+5;
const int INF = 1e9+7;
const double PI = acos(-1.0);
namespace FFT{
    struct complex{
        double r , i;
        complex(double r=0 , double i=0):r(r),i(i){}
        complex operator+(const complex &a) const{
            return complex(r+a.r , i+a.i);
        }
        complex operator-(const complex &a) const{
            return complex(r-a.r , i-a.i);
        }
        complex operator*(const complex &a) const{
            return complex(r*a.r-i*a.i , r*a.i+i*a.r);
        }
    }x[N] , y[N];

    void change(complex y[] , int len){
        int i,j,k;
        for(i=1 , j=len/2 ; i<len-1 ; i++){
            if(i<j) swap(y[i],y[j]);
            k = len/2;
            while(j>=k){
                j-=k;
                k/=2;
            }
            if(j<k) j+=k;
        }
    }

    void fft(complex y[] , int len , int on){
        change(y , len);
        for(int i=2 ; i<=len ; i<<=1){
            complex wn(cos(-on*2*PI/i) , sin(-on*2*PI/i));
            for(int j=0 ; j<len ; j+=i){
                complex w(1,0);
                for(int k=j ; k<j+i/2 ; k++){
                    complex u = y[k];
                    complex t = w*y[k+i/2];
                    y[k] = u+t;
                    y[k+i/2] = u-t;
                    w = w*wn;
                }
            }
        }
        if(on==-1)
            for(int i=0 ; i<len ; i++)
                y[i].r /= len;

    }
    //a[] 与 b[] 的卷积保存到 c[] 中 ， 保证c[]可保存到长度是2倍
    void multiply(int *a , int *b , LL *c , int la,int lb ){
        int k=1;
        while(k<la+lb-1) k<<=1;
        for(int i=0 ; i<k ; i++) {
            if(i<la) x[i]=complex(a[i],0);
            else x[i]=complex(0,0);
            if(i<lb) y[i]=complex(b[i],0);
            else y[i]=complex(0,0);
        }

        fft(x , k , 1); fft(y , k , 1);
        for(int i=0 ; i<k ; i++)
            x[i] = x[i]*y[i];
        fft(x , k , -1);

        for(int i=0 ; i<k ; i++) c[i] = (LL)(x[i].r+0.5);
    }
};

int a[N],b[N];
LL c[N];
int lcnt[N],w[N],rcnt[N];
int n,unit=2300;
LL ans;

void solve_block(){
    for(int st=1;st<n;st+=unit){
        int ed=min(n,st+unit-1);
        for(int i=st;i<=ed;i++) rcnt[w[i]]--;
        for(int i=st;i<=ed;i++){
            for(int j=i+1;j<=ed;j++){
                if(w[j]*2-w[i]>=0) ans+=(LL)rcnt[w[j]*2-w[i]];
                if(w[i]*2-w[j]>=0) ans+=(LL)lcnt[w[i]*2-w[j]];
            }
            lcnt[w[i]]++;
        }
    }
}

void solve(){
    for(int st=unit+1,ed=st+unit-1;st<n;st+=unit,ed+=unit){
        mems(a,0);
        mems(b,0);
        if(ed>=n) return;
        int mxa=0,mxb=0;
        for(int i=1;i<st;i++) a[w[i]]++,mxa=max(w[i],mxa);
        for(int i=ed+1;i<=n;i++) b[w[i]]++,mxb=max(w[i],mxb);
        mxa++;mxb++;
        FFT::multiply(a,b,c,mxa,mxb);
        for(int i=st;i<=ed;i++) ans+=(LL)c[w[i]*2];
    }
}

int main(){
    //freopen("in.txt","r",stdin);
    while(~scanf("%d",&n)){
        mems(lcnt,0);
        mems(rcnt,0);
        ans=0;
        for(int i=1;i<=n;i++){
            scanf("%d",&w[i]);
            rcnt[w[i]]++;
        }
        solve_block();
        solve();
        printf("%lld\n",ans);
    }
    return 0;
}
