#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <utility>
#include <cstring>
#include <bitset>
#include <string>
#include <vector>
#include <queue>
#include <cmath>
#include <map>
#include <set>
using namespace std;

typedef double db;
typedef long long LL;
typedef pair< int, int > PII;
typedef pair< LL, LL > PLL;
typedef pair< db, db > PDD;

const db dInf = 1E90, pi = acos( -1 ), eps = 1E-4;
const LL lInf = ( LL ) 1E16;
const int Inf = 0x23333333;
const int N = 100005, M = ( 1<<16 )+5;

#define it iterator
#define rbg rbegin()
#define ren rend()
#define fdi( i, x ) for ( typeof( x.rbg ) i=x.rbg; i!=x.ren; ++i )
#define foi( i, x ) for ( typeof( x.begin() ) i=x.begin(); i!=x.end(); ++i )
#define fd( i, y, x ) for ( int i=( y )-1, LIM=x; i>=LIM; --i )
#define fo( i, x, y ) for ( int i=x, LIM=y; i<LIM; ++i )
#define mkp( A, B ) make_pair( A, B )
#define pub( x ) push_back( x )
#define pob( x ) pop_back( x )
#define puf( x ) push_front( x )
#define pof( x ) pop_front( x )
#define fi first
#define se second

inline PDD operator+( const PDD &A, const PDD &B ) { return PDD( A.fi+B.fi, A.se+B.se ); }
inline PDD operator-( const PDD &A, const PDD &B ) { return PDD( A.fi-B.fi, A.se-B.se ); }
inline PDD operator/( const PDD &A, const int v ) { return PDD( A.fi/v, A.se/v ); }
inline PDD operator*( const PDD &A, const PDD &B ) { return PDD( A.fi*B.fi-A.se*B.se, A.fi*B.se+A.se*B.fi ); }

int a[N];
int n, m;

namespace FFT
{
	const int m = ( 1<<16 );
	int rev[N];
	PDD ret[M], t[M], w[2][M];
	PDD f[2][M];

	void preprocessing()
	{
		fo ( i, 0, m + 1 ) 
		{
			w[1][i] = mkp( cos( 2*pi*i/m ), sin( 2*pi*i/m ) );
			w[0][i] = mkp( w[1][i].fi, -w[1][i].se );
		}
		fo ( i, 0, m )
		{
			int temp = i, x = 0;
			fo ( j, 0, 16 ) x = x<<1 | ( temp&1 ), temp>>=1;
			rev[i] = x;
		}
	}
	void modify( int x, int v, int ict ) { f[x][v].fi += ict; }
	void transfer( PDD a[], int sig )
	{
		fo ( i, 0, m ) t[ rev[i] ] = a[i];

		for ( int l=2, half=1; l<=m; l<<=1, half<<=1 )
			for ( int grp=0; grp<m; grp+=l ) fo ( i, 0, half )
			{
				PDD u = t[ grp+i ], v = t[ grp+half+i ] * w[ ( sig+1 )>>1 ][ i*m/l ];
				t[ grp+i ] = ( u + v ) , t[ grp+half+i ] = ( u - v ) ;
			}

		fo ( i, 0, m ) a[i] = t[i] / ( sig>0 ? 1 : m ); 
	}
	void calc() 
	{ 
		fo ( i, 0, 2 ) transfer( f[i], 1 );
		fo ( i, 0, m ) ret[i] = f[0][i] * f[1][i];
		fo ( i, 0, 2 ) transfer( f[i], -1 );
		transfer( ret, -1 );
	}
	LL getret( int v ) { return ( v<0 ? 0 : ( LL ) ( ret[v].fi + eps ) ); }
	int getcnt( int x, int v ) { return ( v<0 ? 0 : ( int ) ( f[x][v].fi + eps ) ); }
}

namespace brute
{
	int f[2][M];

	void build( int l, int r )
	{
		fill( f[0], f[0] + ( M>>1 ), 0 );
		fo ( i, l, r ) ++f[1][ a[i] ];
	}

	void modify( int x, int v, int ict ) { f[x][v] += ict; }
	int getcnt( int x, int v ) { return ( v<0 ? 0 : f[x][v] ); }
}

void preprocessing()
{
	scanf( "%d", &n ), m = ( int ) 2500;
	fo ( i, 0, n ) scanf( "%d", &a[i] );
	FFT :: preprocessing();
}

void solve()
{
	int pre = 0, nxt = 0;
	LL ret = 0;
	fo ( i, 0, n ) FFT :: modify( 1, a[i], 1 );
	fo ( i, 0, n ) 
	{
		if ( i>=nxt ) 
		{
			fo ( j, pre, nxt ) FFT :: modify( 0, a[j], 1 );
			pre = nxt, nxt = min( nxt+m, n );
			fo ( j, pre, nxt ) FFT :: modify( 1, a[j], -1 );
			FFT :: calc(), brute :: build( pre, nxt );
		}
		brute :: modify( 1, a[i], -1 );
		ret += FFT :: getret( a[i]<<1 );
		fo ( j, pre, i ) ret += FFT :: getcnt( 1, ( a[i]<<1 )-a[j] );
		fo ( j, i+1, nxt ) 
		{
			ret += brute :: getcnt( 0, ( a[i]<<1 )-a[j] );
			ret += FFT :: getcnt( 0, ( a[i]<<1 )-a[j] );
		}
		brute :: modify( 0, a[i], 1 ); 
	}
	printf( "%lld\n", ret );
}

int main()
{

	preprocessing();
	solve();

	return 0;
}
