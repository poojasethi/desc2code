//pb_ds
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cmath>
#include <vector>
#include <set>
#include <utility>
#include <queue>
#define For(i, a, b) for(register int i = a, ___u = b; i <= ___u; ++i)
#define ForDown(i, a, b) for(register int i = b, ___d = a; i >= ___d; --i)
#define cmax(i, j) ((i) < (j) ? (i) = (j) : (i))
#define cmin(i, j) ((i) > (j) ? (i) = (j) : (i))
#define dmax(i, j) ((j) < (i) ? (i) : (j))
#define dmin(i, j) ((i) < (j) ? (i) : (j))
#define ddel(i, j) ((i) > (j) ? (i) - (j) : (j) - (i))
#define dabs(i) ((i) > 0 ? (i) : -(i))
#define dsqr(x) ((x) * (x))
#define lowbit(i) ((i) & -(i))
 
namespace io
{
	const int MAXBUF = 1 << 23;
	char B[MAXBUF], *S = B, *T = B;
	#define getc() (S == T && (T = (S = B) + fread(B, 1, MAXBUF, stdin), S == T) ? 0 : *S++)
	#define fastcall __attribute__((optimize("-O3")))
	#define inline __inline__ __attribute__((always_inline))
	template<class Type> inline Type read()
	{
		register Type aa = 0;
		register bool bb = 0;
		register char ch, *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? bb = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		io::S = S, io::T = T;
		return bb ? -aa : aa;
	}
	int (*F)() = read<int>;
	 
	template<> inline double read()
	{
		register double aa = 0, bb;
		register bool cc = 0;
		register char ch;
		register char *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? cc = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		if(ch == '.')
		{
			bb = 1;
			while(ch = getc(), ch >= '0' && ch <= '9')
				aa += (bb *= 0.1) * (ch - '0');
		}
		io::S = S, io::T = T;
		return cc ? -aa : aa;
	}
	 
	char buff[MAXBUF], *iter = buff;
	template<class T>inline void P(register T x, register char ch = '\n')
	{
///*lgg*/return (void) (std::cout << x << ch);
		static int stack[110];
		register int O = 0;
		register char *iter = io::iter;
		if(!x)*iter++ = '0';
		else
		{
			(x < 0) ? x = -x, *iter++ = '-' : 1;
			for(; x; x /= 10)
				stack[++O] = x % 10;
			for(; O; *iter++ = '0' + stack[O--])
				;
		}
		*iter++ = ch, io::iter = iter;
	}
 
	inline int gets_a(register char *o)
	{
		register char *s = o, ch = getc();
		register char *S = io::S, *T = io::T;
		for(; ch < 'a' || 'z' < ch; ch = getc())
			;
		for(; 'a' <= ch && ch <= 'z'; ch = getc())
			*s++ = ch;
		*s = 0;
		io::S = S, io::T = T;
		return s - o;
	}
 
	inline char get_A()
	{
		register char ch = getc();
		while(ch < 'A' || 'Z' < ch) ch = getc();
		//puts("1");
		return ch;
	}
	 
	inline void putc(register char ch) {*iter++ = ch;}
	inline void puts(register const char *s) {while(*s) *iter++ = *s++;}
	 
	inline void output() {fwrite(buff, 1, iter - buff, stdout), iter = buff;}
}
 
 
#define RG register
#define set_file(FILE) freopen(FILE ".in", "r", stdin), freopen(FILE ".out", "w", stdout)
#define close_file() fclose(stdin), fclose(stdout)
//#include <stdarH.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
 
namespace pb_ds
{
	using io::P;

	const int MAXN = 500010;

	struct Complex
	{
		double r, i;
		inline Complex operator + (RG const Complex &o) const
		{
			return (Complex) {r + o.r, i + o.i};
		}
		inline Complex operator - (RG const Complex &o) const
		{
			return (Complex) {r - o.r, i - o.i};
		}
		inline Complex operator * (RG const Complex &o) const
		{
			return (Complex) {r * o.r - i * o.i, r * o.i + i * o.r};
		}
	} a[MAXN], b[MAXN], c[MAXN], y[MAXN], one = (Complex) {1, 0};
	
	int val[MAXN], lef[MAXN], rig[MAXN], rev[MAXN];
	int beg[MAXN], end[MAXN];

	inline void fft(RG Complex *a, RG int n, RG int flag)
	{
		RG const double pi = acos(-1.0);
		RG Complex w, wn, x, y, temp;
		for(RG int i = n >> 1, j = 1, k; j < n; ++j)
		{
			if(i < j) temp = a[i], a[i] = a[j], a[j] = temp;
			for(k = n >> 1; i & k; i ^= k, k >>= 1)
				;
			i ^= k;
		}
		for(RG int i = 1, j, k; i < n; i <<= 1)
		{
			w = one;
			wn = (Complex) {cos(pi / i), flag * sin(pi / i)};
			for(j = 0; j < n; j += i << 1, w = one) for(k = 0; k < i; ++k, w = w * wn)
				x = a[j + k], y = w * a[j + k + i], a[j + k] = x + y, a[j + k + i] = x - y;
		}
		if(flag < 0) For(i, 0, n - 1)
			a[i].r /= n;
	}

	inline void main()
	{
		RG int (*F)() = io::F;
		RG int n = F(), max = 0;
		For(i, 1, n)
		{
			val[i] = F();
			cmax(max, val[i]);
			++rig[val[i]];
		}
		max = (max + 1) * 2 - 1;
		RG int m = 1, len = 0;
		while(m <= max) m <<= 1, ++len;
		max = m;
		For(i, 0, max - 1)
		{
			RG int x = i, y = 0;
			For(j, 1, len) 
				y = (y << 1) | (x & 1), x >>= 1;
			rev[i] = y;
		}
		RG int size = 2000;
		m = (n - 1) / size + 1;
		For(i, 1, m) beg[i] = end[i - 1] + 1, end[i] = i * size;
		end[m] = n;
		RG long long ans = 0;
		For(i, 1, m)
		{
			For(j, beg[i], end[i]) --rig[val[j]];
			For(j, 0, max - 1) 
			{
				a[j] = (Complex) {(double) lef[j], 0.0};
				b[j] = (Complex) {(double) rig[j], 0.0};
			}
			fft(a, max, 1);
			fft(b, max, 1);
			For(j, 0, max - 1)
				c[j] = a[j] * b[j];
			fft(c, max, -1);
			For(j, beg[i], end[i])
			{
				RG int temp = val[j] << 1;
				ans += (long long) (c[temp].r + 0.5);
				For(k, beg[i], j - 1) if(temp - val[k] >= 0) ans += rig[temp - val[k]];
				For(k, j + 1, end[i]) if(temp - val[k] >= 0) ans += lef[temp - val[k]];
				++lef[val[j]];
			}
		}
		io::P(ans);
	}	
}
 
int main()
{
	//set_file("hike");
	pb_ds::main();
	io::output();
	close_file();
}
/*

11 14 100
 
1 9
1 7
2 7
11 8
 
1 2
2 3
2 4
2 5
2 6
5 7
1 8
8 9
1 10
9 11
^/\*lgg\*/