#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#define fo(i, a, b) for (i = a; i <= b; i++)
#define rep(i, n) for (i = 0; i < n; i++)
#define memcle(a) memset(a, 0, sizeof(a)) 
using namespace std;

typedef double LD;
typedef long long LL;

const int N = 100010;
const int M = 32768;
const int P = 40000;
const LD pi = acos(-1);

struct complex
{
	LD a, b;
	complex (LD _a = 0, LD _b = 0) {a = _a, b = _b;}
} ;

inline complex operator+(const complex &x, const complex &y) {return complex(x.a + y.a, x.b + y.b);}
inline complex operator-(const complex &x, const complex &y) {return complex(x.a - y.a, x.b - y.b);}
inline complex operator*(const complex &x, const complex &y) {return complex(x.a * y.a - x.b * y.b, x.a * y.b + x.b * y.a);}

LD icos[16][P], isin[16][P];
complex A[P], B[P], temp[P];
int a[N];
int front[P], back[P], mid[P], rev[P];
int n, L, H;
LL ans;

void dft(complex *a, int sig)
{
	int i;
	int j;
	int k;
	int m;
	
	rep(i, M) temp[i] = a[rev[i]];
	
	for (m = 2, k = 0; m <= M; m <<= 1, k++)
	{
		int half = m / 2;
		rep(i, half)
		{
			complex w = complex(icos[k][i], sig * isin[k][i]);
			for (j = i; j < M; j += m)
			{
				complex u = temp[j], v = temp[j + half] * w;
				temp[j] = u + v;
				temp[j + half] = u - v;
			}
		}
	}
	
	rep(i, M) a[i] = temp[i];
}

void mult(complex *a, complex *b)
{
	dft(a, 1);
	dft(b, 1);
	for (int i = 0; i < M; i++) a[i] = a[i] * b[i];
	dft(a, -1);
	for (int i = 0; i < M; i++) a[i] = a[i] * complex(1.0 / M);
}

void init()
{
	int i;
	int j;
	int k;
	int m;
	
	rep(i, M) 
	{
		int x = i, y = 0;
		rep(j, 15) y = (y << 1) + (x & 1), x >>= 1;
		rev[i] = y;
	}
	
	for (m = 2, k = 0; m <= M; m <<= 1, k++)
		rep(i, m / 2) 
			icos[k][i] = cos(2 * pi * i / m), isin[k][i] = sin(2 * pi * i / m);
}

int main()
{
	
	int i;
	int j;
	int h;
	
	init();
	
	scanf("%d", &n);
	rep(i, n) scanf("%d", &a[i]);
	
	L = max(n / 30, 1); // length of one segment
	H = (n / L) + 1; if (n % L == 0) H--; // num of segments
	
	rep(i, n) back[a[i]]++;
	
	rep(h, H)
	{
		int st = h * L, en = min(n - 1, st + L - 1);
		
		fo(i, st, en) back[a[i]]--;
		
		// 3 numbers in this segment 
		//or 2 numbers in this segment and another in other segment
		
		fo(i, st, en) 
		{
			fo(j, i + 1, en) back[a[j]]++;
			fo(j, i + 1, en)
			{
				back[a[j]]--;
				int k = a[j] + a[j] - a[i];
				if (k >= 0 && k <= 30000) ans += back[k];
				
				k = a[i] + a[i] - a[j];
				if (k >= 0 && k <= 30000) ans += front[k];
			}
		}
		
		// one number in this segment , one in front segments and one in back segments
		
		if (h > 0 && h < H - 1)
		{
			memcle(mid);
			fo(i, st, en) mid[a[i]]++;
			
			memcle(A);
			memcle(B);
			
			for (i = 0; i <= 30000; i += 2) A[i / 2] = complex(front[i], 0);
			for (i = 0; i <= 30000; i += 2) B[i / 2] = complex(back[i], 0);
			
			mult(A, B);
			
			rep(i, 30001)
			{
				ans = ans + LL(A[i].a + 0.001) * mid[i];
			}
			
			memcle(A);
			memcle(B);
			
			for (i = 1; i <= 30000; i += 2) A[i / 2] = complex(front[i], 0);
			for (i = 1; i <= 30000; i += 2) B[i / 2 + 1] = complex(back[i], 0);
			
			mult(A, B);
			
			rep(i, 30001)
			{
				ans = ans + LL(A[i].a + 0.001) * mid[i];
			}			
		}	
		
		fo(i, st, en) front[a[i]]++;
	}
	
	cout << ans << endl;
	
	return 0;
}
