#include<bits/stdc++.h>

using namespace std;

#define in(a,x,y) (a>=x && a<=y)
#define out(a,x,y) (!in(a,x,y))
#define sz(a) ((int)a.size())
#define repv(i,a) for(int i=0;i<sz(a);i++)
#define revv(i,a) for(int i=sz(a)-1;i>=0;i--)
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define rev(i,a,b) for(int i=a;i>=b;i--)
#define all(a) a.begin(),a.end()
#define pb push_back

#define AND(a,b) ((a) & (b))
#define OR(a,b) ((a)|(b))
#define XOR(a,b) ((a) ^ (b))
#define xx first
#define yy second
#define mp make_pair
#define sqr(x) ((x)*(x))
#define sqrt(x) sqrt(1.0*(x))

#define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val.
#define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val.
#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)
#define left nokol_left
#define right nokol_right
#define countbit(x) __builtin_popcountll((ll)x)
#define PQ priority_queue
#define FAST ios_base::sync_with_stdio(0);cin.tie(0);
#define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin())
#define READ(f) freopen(f, "r", stdin)
#define WRITE(f) freopen(f, "w", stdout)

typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<long long,long long> pll;
typedef vector<int> vi;
typedef vector<long long> vll;

template<class T>T __sqr(const T x){return x*x;}
template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; }
template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);}
template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;}
inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);}
template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}}
template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}}
template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;}
template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}

template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; }
template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); }
template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); }
template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}

void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; }
pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }

const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103};
//const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};

#define pi acos(-1.0)
#define eps  1e-12
#define MX   (lmt+20)
#define inf  1000000000000000000LL
#define MOD  1000000007LL
//---------->0123456789123465789
#define lmt  4*65536
#define M    30000
#define Block_num 30


int in[MX] ;
int aft[MX] , bfr[MX] , inside[MX];
int N;
//long long nums[200000+10];
struct base
{
    double real, imag;
    base(){real=0.0; imag=0.0;}
    inline void clr(){real=0.0; imag=0.0;}
} a[MX], b[MX];
//bool c[MX],d[MX];
void fft (base* a, int n, bool invert);
inline base multiply(const base& left, const base& right);

void calc_fft(){

        int n = 1 , mx = max(M , M);
        while (n <  mx )  n <<= 1;
        n<<=1;

        if(n > lmt) assert(0);

        fft(a, n, false);
        fft(b, n, false);
        for(int i=0;i<n;i++)
        {
            a[i] = multiply(a[i], b[i]);
        }
        fft(a, n, true);
}

int main()
{

        scanf("%d",&N);
        rep(i,0,N-1){
            scanf("%d",in+i);
            in[i]--;
        }//okay

        ll ans = 0 ;
        ll per = (N + Block_num - 1) / Block_num;

        memset(bfr , 0 , sizeof bfr);
        memset(aft , 0 , sizeof aft);
        rep(i,0,N-1) aft[ in[i] ]++;

//        cout<<aft[4]<<endl;
//        return 0;
        //okay

        rep(block,0,Block_num-1){
            ll st = block * per;//start of the block
            ll ed = (block + 1) * per;

            ed = min(ed - 1 , (ll)N-1);

            rep(i,st,ed) aft[ in[i] ]--;
            rep(i,0,M-1)   inside[ i ] = 0;//ok

            int mx=  0;
            rep(i,st,ed){
                rep(j,i+1,ed) if(in[i]!=in[j]){
                    int d = in[i] - (in[j] - in[i]);
                    if(in(d,0,M-1)) ans += bfr[d] + inside[d];
                    d = in[j] + (in[j] - in[i]);
                    if(in(d,0,M-1)) ans += aft[d];
                }
                inside[ in[i] ]++;

                mx = max(mx , inside[ in[i] ]);
            }

//             for the same value calculation
            rep(i,0,M-1){
                // all inside
                ans += (ll)inside[i]*(ll)(inside[i]-1)*(ll)(inside[i]-2) / 6;
                // two of them inside
                ans += (ll)((ll)inside[i]*(ll)(inside[i]-1)/2) *(ll) (bfr[i] + aft[i]);
            }
            // first and last bad dite hobe
            if(block && block+1 < Block_num){

                rep(i,0,lmt){
                    a[i].real = b[i].real = 0 ;
                    a[i].imag = b[i].imag = 0 ;
                }
                rep(i,0,M-1) a[i].real = bfr[i] , b[i].real = aft[i];
                calc_fft();

//                if(1==aft[4] && 1==bfr[4]) {cout<<" kutta "<<endl;
//                rep(i,0,20){
//                    cout<<a[i].real<<" ";
//                }
//
//                cout<<endl; }

                rep(i,0,M-1) ans += (ll)inside[i] *  (ll)( a[i*2].real + 0.5 );
            }

//            printf("%d %d\n",aft[4],bfr[4]);
            rep(i,st,ed) bfr[ in[i] ]++;

//            getchar();
        }

//        cout<<"where";
        printf("%lld\n",ans);
//    }

    return 0;
}

/*
3
5 5 5
*/

void fft (base* a, int n, bool invert)
{
	for (int i=1, j=0; i<n; ++i)
	{
		int bit = (n >> 1);
		for (; j>=bit; bit>>=1)
			j -= bit;
		j += bit;
		if (i < j)
			swap (a[i], a[j]);
	}

	for (int len=2; len<=n; len<<=1)
	{
		double ang = 2*pi/len * (invert ? -1 : 1);

		double cs = cos(ang);
		double sn = sin(ang);

		for (int i=0; i<n; i+=len)
		{
			int hlen = (len >> 1);

			double wreal = 1;
			double wimag = 0;
			base u;

			base* pa1 = a + i;
			base* pa2 = a + i + hlen;

			for (int j=0; j<hlen; ++j)
			{
				base& a1 = *pa1++;
				base& a2 = *pa2++;

				u = a1;

				double vreal = a2.real * wreal - a2.imag * wimag;
				double vimag = a2.real * wimag + a2.imag * wreal;

				a1.real += vreal;
				a1.imag += vimag;

				a2.real = u.real - vreal;
				a2.imag = u.imag - vimag;

				double wreal2 = wreal;

				wreal = wreal * cs - wimag * sn;
				wimag = wreal2 * sn + wimag * cs;


			}
		}
	}
	if (invert)
		for (int i= n; i >= 0; --i)
			a[i].real /= n;
}

inline base multiply(const base& left, const base& right)
{
	base res;
	res.real = left.real * right.real - left.imag * right.imag;
	res.imag = left.real * right.imag + left.imag * right.real;

	return res;
}
