#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <string>
#include <cstring>
#include <ctime>
#include <string.h>
 
using namespace std;
 
typedef long long int64;
typedef unsigned long long uint64;
#define two(X) (1<<(X))
#define twoL(X) (((int64)(1))<<(X))
#define contain(S,X) (((S)&two(X))!=0)
#define containL(S,X) (((S)&twoL(X))!=0)
const double pi=acos(-1.0);
const double eps=1e-11;
template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}
template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}
template<class T> inline T sqr(T x){return x*x;}
typedef pair<int,int> ipair;
#define SIZE(A) ((int)A.size())
#define LENGTH(A) ((int)A.length())
#define MP(A,B) make_pair(A,B)
#define PB(X) push_back(X)
 
const int bufsize=128*1024;
int bufL=0,nowL=0;
char buf[bufsize];
 
char next_char()
{
	if (nowL==bufL) 
	{
		nowL=fread(buf,sizeof(char),bufsize,stdin);
		if (nowL==0) return 0;
		bufL=0;
	}
	return buf[bufL++];
}
int next_int()
{
	char c;
	do{ c=next_char(); } while (c<'0' || c>'9');
	int n=0;
	for (;c>='0' && c<='9';c=next_char()) n=n*10+(c-'0');
	return n;
}
 
const int maxn=100000+5;
const int maxsize=32768;
const int D=50;
 
struct complex
{
	double x,y;
};
 
int n,a[maxn];
complex last_odd[maxsize],last_even[maxsize];
complex odd[maxsize],even[maxsize];
complex all_odd[maxsize],all_even[maxsize];
int c1[maxsize],c2[maxsize];
complex p[maxsize];
bool bready=false;
double bsinp[15][maxsize/2],bcosp[15][maxsize/2];
 
void prepareFFT(complex w[],int m,int d,int &pos)
{
	if (m==maxsize)
		p[d]=w[pos++];
	else
	{
		prepareFFT(w,m<<1,d,pos);
		prepareFFT(w,m<<1,d+m,pos);
	}
}
void FFT(int direction,complex w[maxsize])
{
	if (!bready)
	{
		bready=true;
		for (int d=0;(1<<d)<maxsize;d++)
		{
			int m=(1<<d);
			double p0=2*pi/double(m*2);
			for (int i=0;i<m;i++)
			{
				bsinp[d][i]=sin(p0*i);
				bcosp[d][i]=cos(p0*i);
			}
		}
	}
	int pos=0;
	prepareFFT(w,1,0,pos);
	for (int d=0;(1<<d)<maxsize;d++)
	{
		int m=(1<<d);
		for (int i=0;i<maxsize;i+=(m*2))
			if (direction==1)
				for (int j=0;j<m;j++)
				{
					double tx=bcosp[d][j]*p[i+j+m].x-bsinp[d][j]*p[i+j+m].y;
					double ty=bcosp[d][j]*p[i+j+m].y+bsinp[d][j]*p[i+j+m].x;
					p[i+j+m].x=p[i+j].x-tx;
					p[i+j+m].y=p[i+j].y-ty;
					p[i+j].x+=tx;
					p[i+j].y+=ty;  
				}
			else
				for (int j=0;j<m;j++)
				{
					double tx=bcosp[d][j]*p[i+j+m].x+bsinp[d][j]*p[i+j+m].y;
					double ty=bcosp[d][j]*p[i+j+m].y-bsinp[d][j]*p[i+j+m].x;
					p[i+j+m].x=p[i+j].x-tx;
					p[i+j+m].y=p[i+j].y-ty;
					p[i+j].x+=tx;
					p[i+j].y+=ty;  
				}
	}
	memcpy(w,p,maxsize*sizeof(complex));
}
void buildall(int c[maxsize],complex odd[maxsize],complex even[maxsize])
{
	memset(odd,0,maxsize*sizeof(complex));
	memset(even,0,maxsize*sizeof(complex));
	for (int i=1;i<maxsize;i+=2) odd[i>>1].x=c[i];
	for (int i=0;i<maxsize;i+=2) even[i>>1].x=c[i];
	FFT(1,odd);
	FFT(1,even);
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	n=next_int();
	for (int i=0;i<n;i++) a[i]=next_int();
	memset(c1,0,sizeof(c1));
	memset(c2,0,sizeof(c2));
	for (int i=0;i<n;i++) c2[a[i]]++;
	buildall(c2,all_odd,all_even);
	memcpy(last_odd,all_odd,maxsize*sizeof(complex));
	memcpy(last_even,all_even,maxsize*sizeof(complex));
	int L=(n-1)/D+1;
	double R=0;
	for (int s=0;s<n;)
	{
		int t=min(n,s+L);
		for (int i=0;i<maxsize;i++)
		{
			last_odd[i].x=all_odd[i].x-last_odd[i].x;
			last_odd[i].y=all_odd[i].y-last_odd[i].y;
			last_even[i].x=all_even[i].x-last_even[i].x;
			last_even[i].y=all_even[i].y-last_even[i].y;
		}
		for (int i=s;i<t;i++)
		{
			c2[a[i]]--;
			for (int j=s;j<i;j++)
			{
				int w1=a[i]+a[i]-a[j];
				if (w1>=0 && w1<maxsize) R+=c2[w1];
				int w2=a[j]+a[j]-a[i];
				if (w2>=0 && w2<maxsize) R+=c1[w2];
			}
		}
		if (t==n) break;
		for (int i=s;i<t;i++) c1[a[i]]++;
		buildall(c2,odd,even);
		if (s>0)
		{
			for (int i=0;i<maxsize;i++)
			{
				double ox=last_odd[i].x*odd[i].x-last_odd[i].y*odd[i].y;
				double oy=last_odd[i].x*odd[i].y+last_odd[i].y*odd[i].x;
				double ex=last_even[i].x*even[i].x-last_even[i].y*even[i].y;
				double ey=last_even[i].x*even[i].y+last_even[i].y*even[i].x;
				last_odd[i].x=ox;
				last_odd[i].y=oy;
				last_even[i].x=ex;
				last_even[i].y=ey;
			}
			FFT(-1,last_odd);
			FFT(-1,last_even);
			for (int i=s;i<t;i++)
			{
				R+=floor(last_even[a[i]].x/maxsize+0.5);
				R+=floor(last_odd[a[i]-1].x/maxsize+0.5);
			}
		}
		memcpy(last_odd,odd,maxsize*sizeof(complex));
		memcpy(last_even,even,maxsize*sizeof(complex));
		s=t;
	}
	if (R<0) R=0;
	printf("%.0lf\n",R);
	return 0;
} 