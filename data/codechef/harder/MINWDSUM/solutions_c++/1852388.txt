#include <iostream>
#include <vector>
using namespace std;

// returns length of the decimal representation of M
int len(int M) {
	return M ? len(M / 10) + 1 : 0;
}

const int maxM = 3141592;
int Smin[maxM];
vector<int> q[314 * 7 + 1];
int Lmin[maxM]; // the decimal length of Nmin(R)
int bfs[maxM]; // usual queue for bfs
unsigned Nmin[maxM]; // the value of f(Nmin(R)), range of unsigned is [0, 2^32)

int main() {
	int T;
	cin >> T;
	for (int t = 0; t < T; ++t) {
		int M;
		cin >> M;

		vector<int> W(10);
		int maxW = 0;
		for (int D = 0; D < 10; ++D) {
			cin >> W[D];
			maxW = max(maxW, W[D]);
		}
		// maxW = max(W[0], W[1], ..., W[9])

		// Smin(R) <= WS(R) <= max(W[D]) * len(R)  <= max(W[D]) * len(M-1)
		// hence such upper bound on Smin
		int maxS = maxW * len(M - 1) + 1;
		for (int R = 0; R < M; ++R) {
			Smin[R] = maxS;
		}
		for (int S = 0; S < maxS; ++S) {
			q[S].clear();
		}
		// the shortest path to 0 is 0
		q[0].push_back(0);
		Smin[0] = 0;
		int cnt = 0; // the number of vertexes with already correct shortest path
		for (int S = 0; S < maxS && cnt < M; ++S) {
			for (int k = 0; k < q[S].size() && cnt < M; ++k) {
				// exctract the current vertex
				int R = q[S][k];
				// we skip vertex R if Smin[R] != S as in standard
				// implementation of Dijkstra algorithm using priority_queue
				if (Smin[R] != S) {
					continue;
				}
				++cnt;
				// Smin[R] == S means that we have final value of Smin for R
				// so we update other vertexes
				int RD = 10 * R % M; // we calculate 10 * R % M only once
				for (int D = 0; D < 10; ++D) {
					// RD is the neighboring vertex for R via edge D
					// SD is the path from 0 to RD through R
					int SD = S + W[D];
					// the relaxation of the shortest path of RD
					if (Smin[RD] > SD)
					{
						Smin[RD] = SD; // update the Smin value 
						q[SD].push_back(RD); // and add the vertex RD to the corresponding queue
					}
					// the tricky optimization to reduce modulo operation
					if (++RD == M) {
						RD = 0;
					}
				}
			}
		}

		long long res = 0; // will contain value of required sum
		// M is an upper bound on Lmin since any simple path
		// in any graph of M vertexes has < M vertexes :)
		for (int R = 0; R < M; ++R) {
			Lmin[R] = M;
		}		
		// the init of vertex 0
		int len = 0;
		bfs[len++] = 0;
		Lmin[0] = 0;
		Nmin[0] = 0;
		for (int k = 0; k < len; ++k) {
			// extract the current vertex
			int R = bfs[k];
			int L = Lmin[R]; // the decimal length of Nmin(R)
			res += Nmin[R]; // Nmin[R] is the correct value of f(Nmin(R)) so we update res
			// iterating over edges from R as in the above loop
			int RD = 10 * R % M;
			for (int D = 0; D < 10; ++D) {
				// the first condition here is that edge belongs to the shortest path to RD
				// the second is that we not visit vertex RD earlier in this bfs
				if (Smin[RD] == Smin[R] + W[D] && Lmin[RD] == M)
				{
					// standard update in bfs:
					Lmin[RD] = L + 1; // update of distance
					bfs[len++] = RD; // add to to the queue
					Nmin[RD] = 3141 * Nmin[R] + D; // unsigned overflow is equivalent to mod 2^32 operation
				}
				if (++RD == M) {
					RD = 0;
				}
			}
		}
		cout << res << endl;
	}
	return 0;
}