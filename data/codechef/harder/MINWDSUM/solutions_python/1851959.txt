#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <climits>
#include <cstring>
#include <ctime>
#include <cmath>
#include <cassert>
#include <vector>
#include <queue>
#include <stack>
#include <list>
#include <set>
#include <map>
#include <bitset>
#include <algorithm>
#include <utility>
#include <numeric>
#include <functional>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
#define forl(i, n) for (int i = 1; i <= int(n); i++)
#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)
#define fore(i, l, r) for (int i = int(l); i <= int(r); i++)
#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))
#define all(a) (a).begin(), (a).end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
#define mp(x, y) make_pair((x), (y))
#define ft first
#define sc second
#define x first
#define y second
 
using namespace std;
 
typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;
 
template<typename X> inline X abs(const X& a) { return a < 0? -a: a; }
template<typename X> inline X sqr(const X& a) { return a * a; }
 
const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;
 
int m, w[10];
 
inline bool read()
{
	if (scanf("%d", &m) != 1)
		return false;
		
	forn(i, 10)
		assert(scanf("%d", &w[i]) == 1);
		
	return true;
}
 
typedef unsigned int uint;
 
const int N = 4 * 1000 * 1000 + 3, C = (1 << 9) + 3;
 
int szcur, sznext;
int cur[N], next[N];
int minPos[N];
uint ans[N];
int u = 0, used[N];
int d1[N], d2[N];
queue<int> q[C];
 
inline void solve(int test)
{
	forn(i, m) d1[i] = d2[i] = INF;
	
	d1[0] = 0;
	q[d1[0]].push(0);
	
	for (int qq = 0, dd = 0; ; qq = (qq + 1) & 511, dd++)
	{
		bool end = true; forn(i, 512) end &= q[i].empty();
		if (end) break;
		
		while (!q[qq].empty())
		{
    		int v = q[qq].front();
    		q[qq].pop();
    		
    		if (d1[v] != dd) continue;
    		
    		int nrm = v * 10;
    		(nrm >= m) && (nrm %= m);
    		
    		int dd1 = d1[v];
    		
    		forn(i, 10)
    		{
    			int next = nrm + i;
    			while (next >= m) next -= m;
    			int nd1 = dd1 + w[i];
    			
    			if (d1[next] > nd1)
    			{
    				d1[next] = nd1;
    				q[d1[next] & 511].push(next);
    			}
    		}
		}
	}
	
	cerr << clock() << endl;
	
	queue<int> qq;
	d2[0] = 0;
	qq.push(0);
	ans[0] = 0;
	
	while (!qq.empty())
	{
		int v = qq.front();
		qq.pop();
		
		int nrm = v * 10;
		(nrm >= m) && (nrm %= m);
		
		int dd1 = d1[v];
		int dd2 = d2[v];
		
		forn(i, 10)
		{
			int next = nrm + i;
			while (next >= m) next -= m;
			int nd1 = dd1 + w[i];
			int nd2 = dd2 + 1;
			
			if (d1[next] == nd1 && d2[next] > nd2)
			{
				d2[next] = nd2;
				ans[next] = ans[v] * 3141 + i;
				qq.push(next);
			}
		}
 	}
	
	//forn(i, m) assert(d[i].ft < INF / 2);
	
	cerr << clock() << endl;
	
	/*forn(i, m) minPos[i] = INF;
	
	u++;
	used[0] = u;
	szcur = 0;
	cur[szcur++] = 0;
	ans[0] = 0;
	
	li res = 0;
	int sum = 0;
	
	while (szcur > 0)
	{
		sum += szcur;
		
		forn(t, szcur)
		{
			int v = cur[t];
			res += ::ans[v];
			
    		forn(i, 10)
    		{
    			int next = (v * 10 + i) % m;
    			
    			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1) minPos[next] = min(minPos[next], t);
    		}
    	}
    	
		sznext = 0;
		
		forn(t, szcur)
		{
			int v = cur[t];
			
    		forn(i, 10)
    		{
    			int next = (v * 10 + i) % m;
    			
    			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1 && minPos[next] == t && used[next] != u)
    			{
    				used[next] = u;
    				ans[next] = ans[v] * 3141 + i;
    				::next[sznext++] = next;
    			}
    		}
    	}
    	
    	//sort(next, next + sznext);
    	
    	szcur = sznext;
    	forn(i, szcur) cur[i] = next[i];
	}
	
	//cerr << sum << ' ' << m << endl;
	assert(sum == m);*/
	
	li res = 0;
	
	forn(i, m) res += ans[i];
	
	cout << res << endl;
	
	cerr << clock() << endl;
}
 
int main()
{
#ifdef SU2_PROJ
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt", stdout);
#endif
    
    cout << setprecision(10) << fixed;
    cerr << setprecision(5) << fixed;
    
    int testCount;
    cin >> testCount;
    
    forn(test, testCount)
    {
	    assert(read());
		solve(test);
	}
	
    return 0;
}
