#include<set>
#include<map>
#include<queue>
#include<algorithm>
#include<string>
#include<utility>
#include<cassert>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long

int cost[4000000];
unsigned minN[4000000];
char vis[4000000];

int main(){
  int T, M, W[10];
  int sumM = 0;

  int i, j, k, d, nc, qi;
  queue<int> q[3141];

  queue<int> qq;
  ll res;

  assert( scanf("%d",&T)==1 );
  assert( 1<=T && T<=3141 );
  while(T--){
    assert( scanf("%d",&M)==1 );
    assert( 1<=M && M<=3141592 );
    sumM += M; assert( sumM <= 3141592 );
    rep(i,10) assert( scanf("%d",W+i)==1 );
    rep(i,10) assert( 0<=W[i]&&W[i]<=314 );

    /* calculate the minimum cost (Smin(R)) by 012-bfs */
    /* maximum cost does not exceeded 314 * (digits of M) */
    rep(i,M) cost[i] = 1000000000;
    cost[0] = 0;
    rep(i,3141) while(q[i].size()) q[i].pop();

    q[0].push(0); /* q[k] has the nodes with cost = k */
    rep(qi,3141) while(q[qi].size()){
      i = q[qi].front(); q[qi].pop();
      if(cost[i] != qi) continue;

      k = (i*10)%M;
      rep(d,10){
        nc = qi + W[d];
        if(nc < cost[k]){
          cost[k] = nc;
          q[nc].push(k);
        }
        k++; if(k==M) k = 0;
      }
    }

    /* calculate the minimum N (Nmin(R)) by standard bfs */
    /* by using bfs, we can bet MINIMUM N :) */
    while(qq.size()) qq.pop();
    rep(i,M) vis[i] = 0;
    minN[0] = 0; vis[0] = 1;
    qq.push(0);
    while(qq.size()){
      i = qq.front(); qq.pop();

      k = (i*10)%M;
      rep(d,10){
        if(vis[k]==0 && cost[k]==cost[i]+W[d]){ /* if not visited && cost is match */
          minN[k] = minN[i]*3141+d;
          vis[k] = 1;
          qq.push(k);
        }
        k++; if(k==M) k = 0;
      }
    }

    res = 0;
    rep(i,M) res += minN[i];
    printf("%lld\n",res);
  }

  return 0;
}