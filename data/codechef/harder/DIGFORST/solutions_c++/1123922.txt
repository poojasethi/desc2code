#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <sstream>
#include <set>
#include <map>
#include <queue>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <bitset>
#include <cassert>

#define MOD 420

using namespace std;

int dig[100];
int adj[100][100];

struct nodo
{
	int ind, gcd, val, dist;
	nodo(int n1, int n2, int n3, int n4)
	{
		ind = n1;
		gcd = n2;
		val = n3;
		dist = n4;
	}
};

bool operator <(nodo a, nodo b)
{
	return a.dist > b.dist;
}

bitset <672000> visited;

int main()
{
	set <int> S;
	for(int mask = 0; mask < (1<<7); mask++)
	{
		int k = 1;
		for(int i=0; i<7; i++)
			if(mask & (1<<i))
				k = k * (i + 1) / __gcd(k, i+1);
		if(k % 10 != 0) S.insert(k);
	}
	
	vector <int> v(S.begin(), S.end());
	int vsz = v.size();
	int enc_gcd[106];
	for(int i=0; i<vsz; i++)
		enc_gcd[v[i]] = i;

	int n;
	while(scanf("%d", &n) == 1)
	{
		if(n == 0) break;
		
		for(int i=0; i<n; i++)
			scanf("%d", &dig[i]);
		
		for(int i=0; i<n; i++)
			for(int j=0; j<n; j++)
				scanf("%d", &adj[i][j]);
		
		visited.reset();
		
		priority_queue <nodo> Q;
		Q.push(nodo(0, dig[0], dig[0], dig[0]));
		
		int ans = -1;
		while(!Q.empty())
		{
			nodo q = Q.top();
			Q.pop();
			
			int ind = q.ind, gcd = q.gcd, val = q.val, dist = q.dist;
			int idx = (ind * vsz + enc_gcd[gcd]) * 420 + val;

			if(visited[idx]) continue;
			visited[idx] = 1;
			
			if(ind == n - 1 && val % gcd == 0)
			{
				ans = dist;
				break;
			}
			
			for(int nind=0; nind<n; nind++)
			{
				if(adj[ind][nind])
				{
					int ngcd = gcd * dig[nind] / __gcd(gcd, dig[nind]);
					if(ngcd % 10 == 0) continue;
					
					int nval = (val * 10 + dig[nind]) % MOD;
					int nidx = (nind * vsz + enc_gcd[ngcd]) * 420 + nval;

					if(!visited[nidx]) Q.push(nodo(nind, ngcd, nval, dist + dig[nind]));
				}
			}
		}
		
		printf("%d\n", ans);
	}
	
	return 0;
}
