#include <stdio.h>
#include <queue>
#include <malloc.h>
#include <cstring>

#define DEBUG 0

using namespace std;

#define MODSL 4
int MODS[] = { 3, 4, 5, 7 };

struct State {
	int v; // vertex index
	char mods[4]; // 3, 4, 5, 7
	int contains;
	int sum;
};

inline void update( State* s, State* act, int v ) {
/*
	for ( int j = 0; j < MODSL; ++j )
		s->mods[j] = (act->mods[j] * 10 + v) % MODS[j];
	s->mods[2] = s->mods[2] == 0 ? 0 : 1;
*/
	s->mods[0] = (10 * act->mods[0] + v) % 3;
	//s->mods[1] = (act->mods[1] + v) | 3;
	s->mods[1] = (10 * act->mods[1] + v) % 4;
	//s->mods[2] = v == 5 ? 0 : 1;
	s->mods[2] = v == 5 ? 0 : 1;
	s->mods[3] = (10 * act->mods[3] + v) % 7;
}

class Compare {
public:
	bool operator() (State*& t1, State*& t2) {
		if ( t1->sum > t2->sum ) return true;
		return false;
	}
};

void statePrint( State* s, int d ) {
	if (DEBUG) {
		if (d) printf( "DEBUG: " );
		printf( "{%d, %d, ", s->v, s->sum );
		for ( int i = 6; i >= 0; --i ) printf( "%d", (s->contains & (1<<i)) > 0 ? 1 : 0 );
		printf( ", [ %d", s->mods[0] );
		for ( int i = 1; i < MODSL; ++i ) printf( ", %d", s->mods[i] );
		printf( " ] }\n");
	}
}

void statePrint( State* s) {
	statePrint( s, 1 );
}

int N;

int stateFinal( State* s ) {
	if (DEBUG) { printf("DEBUG: stateFinal | s="); statePrint(s, 0); }
	if ( s->v != N-1 ) return 0;
	for ( int i = 0; i < MODSL; ++i )
		if ( s->contains & (1 << (MODS[i]-1) ) )
			if ( s->mods[i]) return 0;
	if ( s->contains & 2) // contains 2
		if ( s->mods[1] & 1 ) return 0; // mod4%2 == 1
	if ( (s->contains & (1<<5) ) )
		if ( (s->mods[1] & 1) || (s->mods[0]) ) return 0; // mod4%2 != 0 || mod3 != 0
	return 1;
}

//char vis[3][4][2][7][100][1<<7];
#define IDX(a, b, c, d, e, f) ((((((((a*3+b)*4+c)*2)+d)*7)+e)*100)+f)
char vis[3 *4 *2 *7 *100 *(1<<7)];

void init() {
	if (DEBUG) printf( "DEBUG: size=%d, calc=%d\n", sizeof(vis), 3*4*5*7*100*(1<<7)*sizeof(int) );
	memset( vis, '0', sizeof(vis) );
	//memset( vis[0][0][0][0][0], 0, sizeof(vis[0][0][0][0][0]) );
}

int main( int argc, char** argv ) {
	if (DEBUG) {
		State s;
		// stateFinal | s={3, 7, 0000111, [ 1, 0, 0, 5 ] }
		s.v = 3;
		s.sum = 7;
		s.contains = 1 + 2 + 8;
		printf( "stateFinal=%d", stateFinal(&s) );
	}
	scanf( "%d", &N );
	if (DEBUG) printf("DEBUG: N=%d\n", N);
	
	while ( N ) {
		init();
		int v[N];
		for ( int i = 0; i < N; ++i ) scanf( "%d", &v[i]);
		if (DEBUG) { printf( "DEBUG:" ); for (int i = 0; i < N; ++i ) printf(" %d", v[i] ); printf("\n"); }
		
		int e[N][N];
		for ( int i = 0; i < N; ++i ) for ( int j = 0; j < N; ++j ) scanf("%d", &e[i][j] );
		if (DEBUG) {
			printf("DEBUG: start {\n");
			for (int i = 0; i < N; ++i ) {
				printf("DEBUG: ");
				for ( int j = 0; j < N; ++j ) printf( "%d ", e[i][j] );
				printf("\n");
			}
			printf("DEBUG: } end\n");
		}
		
		// solution
		State* f = (State*)malloc( sizeof(State) );
		f->v = 0;
		for ( int i = 0; i < MODSL; ++i ) {
			f->mods[i] = v[0] % MODS[i];
		}
		f->mods[2] = f->mods[2] == 0 ? 0 : 1;
		f->contains = (1 << (v[0] - 1));
		f->sum = v[0];
		statePrint(f);
		
		priority_queue<State*, vector<State*>, Compare > pq;
		pq.push( f );
		
		int res = -1;
		while ( !pq.empty() ) {
			State* act = pq.top();
			if (DEBUG) { printf("DEBUG: act="); statePrint( act, 0 ); }
			if ( stateFinal(act) ) {
				res = act->sum;
				pq.pop();
				// free memory
				free(act);
				while ( !pq.empty() ) {
					State* act = pq.top();
					pq.pop();
					free(act);
				}
				break;
			} else {
				pq.pop();
				// add neighbors
				for ( int i = 0; i < N; ++i ) {
					if ( e[act->v][i] ) {
						State* s = (State*) malloc( sizeof(State) );
						s->v = i;
						update( s, act, v[i]);
						//for ( int j = 0; j < MODSL; ++j )
						//	s->mods[j] = (act->mods[j] * 10 + v[i]) % MODS[j];
						//s->mods[2] = s->mods[2] == 0 ? 0 : 1;

						int cont = act->contains | (1 << (v[i]-1));
						s->contains = cont;
						int m0 = s->mods[0];
						int m1 = s->mods[1];
						int m2 = s->mods[2];
						int m3 = s->mods[3];
						int vi = IDX(m0,m1,m2,m3,i,cont);
						if ( vis[vi] == '1' ) {
							free(s);
						} else {
							vis[vi] = '1';
							s->sum = act->sum + v[i];
							if (DEBUG) { printf( "DEBUG: neighbor=" ); statePrint( s, 0 ); }
							pq.push( s );
						}
					}
				}
				free(act);
			}
		}
		printf("%d\n", res );

		// solution
		scanf( "%d", &N );
	}

	return 0;
}
