#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <cstring>
#include <string>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <bitset>
#include <vector>
#include <stack>
#include <list>
#include <utility>
#include <queue>
#include <set>
#include <map>
using namespace std;

typedef long long ll;
typedef pair<int, int> PII;
typedef vector<int> VI;
typedef vector<PII> VP;
typedef vector<string> VS;

#define FOR(i,a,b) for(i=(a);i<(b);i++)
#define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ALL(x) x.begin(),x.end()
#define CLR(x, v) memset((x),v,sizeof (x))
#define gcd(a, b) __gcd(a, b)
#define PB push_back 
#define MP make_pair
#define INF 2000000007

int toInt(string s){ istringstream sin(s); int t; sin>>t; return t; }
template<class T> string toString(T x){ ostringstream sout; sout<<x; return sout.str(); }
template<class T> void chmin(T &t, T f) { if (t > f) t = f; }
template<class T> void chmax(T &t, T f) { if (t < f) t = f; }


int n,d[110];
VI g[110];
int best;
int inq[110][65][84];
int opt[110][65][84];
bool ok[65][84];
struct state
{
	int x, mask, r;
	state(int a, int b, int c) : x(a), mask(b), r(c) {}
	state() {}
};
int main()
{
	int i, j, k;
	FOR(i,0,(1<<6)) FOR(j,0,84) {
		FOR(k,0,6) {
			if(k==3) continue;
			if((i&(1<<k))&&j%(k+2)) break;
		}
		if(k==6) ok[i][j] = true;
	}
	while(cin>>n) {
		if(n==0) break;
		FOR(i,0,n) scanf("%d", d+i);
		FOR(i,0,n) {
			g[i].clear();
			int a;
			FOR(j,0,n) {
				scanf("%d", &a);
				if(a) g[i].PB(j);
			}
		}
		CLR(inq,0);
		CLR(opt,-1);
		best = INF;
		queue<state> q = queue<state>();
		state init = state(0,0,d[0]);
		if(d[0]>1) init.mask |= (1<<d[0]-2);
		q.push(init);
		inq[0][init.mask][d[0]] = 1;
		opt[0][init.mask][d[0]] = d[0];
		while(!q.empty()) {
			state st = q.front();
			q.pop();
			int sum = opt[st.x][st.mask][st.r];
			inq[st.x][st.mask][st.r] = 0;
			if(st.x == n-1 && ok[st.mask][st.r]) {
				if((st.mask&(1<<3))==0||d[n-1]==5)
					chmin(best, sum);
			}
			FORE(it,g[st.x]) {
				int y = *it;
				int nsum = sum + d[y];
				int nmask = st.mask;
				if(d[y]>1) nmask |= (1<<d[y]-2);
				int nr = (st.r*10+d[y])%84;
		//		if((nmask&(1<<3)) && d[n-1]!=5) continue;
				int &t = opt[y][nmask][nr];
				if(nsum >= best) continue;
				if(t < 0 || nsum < t) {
					t = nsum;
					if(!inq[y][nmask][nr]) {
						q.push(state(y,nmask,nr));
						inq[y][nmask][nr] = 1;
					}
				}
			}
		}
		if(best == INF) puts("-1");
		else printf("%d\n", best);
	}
	return 0;
}
