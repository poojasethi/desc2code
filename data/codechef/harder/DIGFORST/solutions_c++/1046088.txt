#include <stdio.h>
#include <queue>
#include <malloc.h>
#include <cstring>

#define DEBUG 0
#define DEBUG_BASIC 0
#define DEBUG_READ 0

#define IDX(a, b, c, d, e, f) ((((((((a*3+b)*4+c)*2)+d)*7)+e)*100)+f)
//#define IDX(a, b, c, d, e, f) ( f | e<<7 | d << 10 | c << 11 | b << 13 | a << 15 )

int N;
//char vis[4 *4 *2 *8 *128 *(1<<7)];
char vis[3 *4 *2 *7 *100 *(1<<7)];

using namespace std;

struct State {
	int v; // vertex index
	char mod3;
	char mod4;
	char mod5;
	char mod7;
	int contains;
	int sum;
};

class Compare {
public:
	bool operator() (State*& t1, State*& t2) {
		if ( t1->sum > t2->sum ) return true;
		return false;
	}
};

void statePrint( State* s, int d ) {
	if (DEBUG) {
		if (d) printf( "DEBUG: " );
		printf( "{%d, %d, ", s->v, s->sum );
		for ( int i = 6; i >= 0; --i ) printf( "%d", (s->contains & (1<<i)) > 0 ? 1 : 0 );
		printf( ", [ %d, %d, %d, %d ] }\n", s->mod3, s->mod4, s->mod5, s->mod7 );
	}
}

void statePrint( State* s) {
	statePrint( s, 1 );
}

int stateFinal( State* s ) {
	if (DEBUG) { printf("DEBUG: stateFinal | s="); statePrint(s, 0); }

	if ( s->v != N-1 ) return 0;

	if (s->contains & ( 1<<(2-1) ) ) if ( s->mod4&1 ) return 0;
	if (s->contains & ( 1<<(3-1) ) ) if ( s->mod3 ) return 0;
	if (s->contains & ( 1<<(4-1) ) ) if ( s->mod4 ) return 0;
	if (s->contains & ( 1<<(5-1) ) ) if ( s->mod5 ) return 0;
	if (s->contains & ( 1<<(6-1) ) ) if ( s->mod3 + (s->mod4&1) ) return 0;
	if (s->contains & ( 1<<(7-1) ) ) if ( s->mod7 ) return 0;

	return 1;
}

int main( int argc, char** argv ) {
	if (DEBUG) printf( "DEBUG: main\n");
/*	if (DEBUG) {
		State s;
		// stateFinal | s={3, 7, 0000111, [ 1, 0, 0, 5 ] }
		s.v = 3;
		s.sum = 7;
		s.contains = 1 + 2 + 8;
		printf( "DEBUG: stateFinal=%d\n", stateFinal(&s) );
	}*/
	scanf( "%d", &N );
	if (DEBUG_BASIC) printf("DEBUG: N=%d\n", N);
	
	while ( N ) {
		//init();
		int v[N];
		for ( int i = 0; i < N; ++i ) scanf( "%d", &v[i]);
		if (DEBUG_READ) { printf( "DEBUG:" ); for (int i = 0; i < N; ++i ) printf(" %d", v[i] ); printf("\n"); }

		//char vis[3][4][2][7][N][1<<7];
		//  char vis[3 *4 *2 *7 *N *(1<<7)];
		memset( vis, '0', sizeof(vis) );
		
		int e[N][N];
		for ( int i = 0; i < N; ++i ) for ( int j = 0; j < N; ++j ) scanf("%d", &e[i][j] );
		if (DEBUG_READ) {
			printf("DEBUG: start {\n");
			for (int i = 0; i < N; ++i ) {
				printf("DEBUG: ");
				for ( int j = 0; j < N; ++j ) printf( "%d ", e[i][j] );
				printf("\n");
			}
			printf("DEBUG: } end\n");
		}
		
		// solution
		State* f = (State*)malloc( sizeof(State) );
		f->v = 0;
		f->mod3 = v[0] % 3;
		f->mod4 = v[0] % 4;
		f->mod5 = (v[0] == 5 ? 0 : 1);
		//f->mod5 = v[0] % 5;
		f->mod7 = v[0] % 7;
		f->contains = (1 << (v[0] - 1));
		f->sum = v[0];
		statePrint(f);
		
		priority_queue<State*, vector<State*>, Compare > pq;
		pq.push( f );

		int res = -1;
		while ( !pq.empty() ) {
			State* act = pq.top();
			if (DEBUG) { printf("DEBUG: act="); statePrint( act, 0 ); }
			if ( stateFinal(act) ) {
				if (DEBUG) printf( "DEBUG: final\n");
				res = act->sum;
				pq.pop();
				// free memory
				free(act);
				while ( !pq.empty() ) {
					State* act = pq.top();
					pq.pop();
					free(act);
				}
				break;
			} else {
				if (DEBUG) printf( "DEBUG: not final\n");
				pq.pop();
				// add neighbors
				for ( int i = 0; i < N; ++i ) {
					if (DEBUG) printf( "DEBUG: neighbors - i=%d\n", i);
					if ( e[act->v][i] ) {
						State* s = (State*) malloc( sizeof(State) );
						s->v = i;
						s->mod3 = (act->mod3*10 + v[i])%3;
						s->mod4 = (act->mod4*10 + v[i])%4;
						//s->mod5 = (act->mod5*10 + v[i])%5;
						s->mod5 = (v[i] == 5 ? 0 : 1);
						s->mod7 = (act->mod7*10 + v[i])%7;
						int cont = act->contains | (1 << (v[i]-1));
						s->contains = cont;
						int m0 = s->mod3;
						int m1 = s->mod4;
						int m2 = s->mod5;
						int m3 = s->mod7;
						//if ( vis[ IDX(m0,m1,m2,m3,i,cont) ] ) {
						//int vi = idx(m0,m1,m2,m3,i,cont);
						int vi = IDX(m0,m1,m2,m3,i,cont);
						if (DEBUG) printf( "DEBUG: checking vis[%d]\n", vi );
						if ( vis[ vi ] == '1' ) {
							free(s);
						} else {
							//vis[ IDX(m0,m1,m2,m3,i,cont) ] = 1;
							vis[ vi ] = '1';
							s->sum = act->sum + v[i];
							if (DEBUG) { printf( "DEBUG: neighbor=" ); statePrint( s, 0 ); }
							pq.push( s );
						}
					}
				}
				free(act);
			}
		}
		printf("%d\n", res );

		// solution
		scanf( "%d", &N );
		if (DEBUG_BASIC) printf("DEBUG: N=%d\n", N);
	}
	
	if (DEBUG) printf("end");

	return 0;
}
