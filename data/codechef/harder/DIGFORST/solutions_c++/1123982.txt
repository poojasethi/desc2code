#include<stdio.h>
#include<queue>
#include <algorithm>
#include <vector>
#include <functional>
#define oo 2000000000
using namespace std;

int values[100];
bool adj[100][100];
int N;
bool marked[100][1<<7][420];
int distances[100][1<<7][420];

int lcms[] = {0, 1, 2, 2, 3, 3, 6, 6, 4, 4, 4, 4, 12, 12, 12, 12, 5, 5, 10, 10, 15, 15, 30, 30, 20, 20, 20, 20, 60, 60, 60, 60, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 7, 7, 14, 14, 21, 21, 42, 42, 28, 28, 28, 28, 84, 84, 84, 84, 35, 35, 70, 70, 105, 105, 210, 210, 140, 140, 140, 140, 420, 420, 420, 420, 42, 42, 42, 42, 42, 42, 42, 42, 84, 84, 84, 84, 84, 84, 84, 84, 210, 210, 210, 210, 210, 210, 210, 210, 420, 420, 420, 420, 420, 420, 420, 420};
struct Node {
	public:
    int vertex;
	int bitm;
	int remainder;
	int distance;
    int getage() const {
        return distance;
    }
};
struct DereferenceCompareNode : public std::binary_function<Node, Node, bool>
{
    bool operator()(Node lhs, Node rhs)
    {
        return lhs.getage() > rhs.getage();
    }
}; 

void print()
{
	for(int i=0;i<N;i++)
	{
		for(int j=0;j<N;j++)printf("%d",adj[i][j]);
		printf("\n");
	}
}
int djikstra()
{
	priority_queue<Node, vector<Node>, DereferenceCompareNode> q;
	for(int i=0;i<N;i++)
	{
		for(int j=0;j<(1<<7);j++)
		{
			for(int k=0;k<420;k++)
			{
					marked[i][j][k]=0;
					distances[i][j][k]=oo;
			}			
		}
	}
	
	Node k1;
	k1.vertex=0;
	k1.bitm=1<<(values[0] - 1);
	k1.distance=values[0];
	k1.remainder=values[0];
	
	q.push(k1);
	int res=oo;
	while(!q.empty())
	{
		//printf("here\n");
		Node k=q.top();
		q.pop();
		int node=k.vertex;
		int rem=k.remainder;
		int bitmask=k.bitm;
		int dist=k.distance;
		//printf("%d %d %d %d\n",node,rem,bitmask,dist);
		if (marked[node][bitmask][rem]) 
			continue;
		if(node==N-1)
		{
			if(rem%lcms[bitmask]==0)return dist;
			
        }
		marked[node][bitmask][rem]=1;
		for(int i=0;i<N;i++)
		{
			int newrem = ((rem << 3) + (rem << 1) + values[i]) % 420;
			int newbitmask = bitmask | (1 << (values[i] - 1));
			//printf("%d %d %d %d %d\n",i,newrem,newbitmask,dist+values[i],adj[node][i]);
			if (adj[node][i] && !marked[i][newbitmask][newrem] && dist + values[i] < distances[i][newbitmask][newrem]) 
			{
					//printf("%d %d %d %d\n",i,newrem,newbitmask,dist+values[i]);
					Node tmp;
					tmp.vertex=i;
					tmp.bitm=newbitmask;
					tmp.distance=dist+values[i];
					tmp.remainder=newrem;
                    q.push(tmp);
                    distances[i][newbitmask][newrem] = dist + values[i];
             }
		}
	}
	return res;
}
int main()
{
	int temp;
	while(1)
	{
		scanf("%d",&N);
		if(!N)break;
		for(int i=0;i<N;i++)scanf("%d",&values[i]);
		//printf("%d\n",values[0]);
		for(int i=0;i<N;i++)
		{
			for(int j=0;j<N;j++)
			{
				scanf("%d",&temp);
				adj[i][j]=temp;
				if (values[N- 1] % 2 != 0 && values[i] % 2 == 0) {
                            adj[i][j] = 0;
                        }
                        if (values[N - 1] % 5 != 0 && values[i] % 5 == 0) {
                            adj[i][j] = 0;
                        }
				
			}
			//printf("\n");
		}
		int min=djikstra();
		if(min==oo)
		{
			printf("-1\n");
		}
		else
		{
			printf("%d\n",min);
		}
	}
	return 0;
}