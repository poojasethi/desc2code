#define _CRT_SECURE_NO_WARNINGS
#pragma comment (linker, "/STACK:16777216")
#include <iostream>
#include <algorithm>
#include <numeric>
#include <vector>
#include <queue>
#include <list>
#include <stack>
#include <string>
#include <fstream>
#include <math.h>
#include <limits>
#include <set>
#include <map>
#include <sstream>
#include <stdio.h>
#include <time.h>
#include <memory.h>
#include <cassert>
#include <complex>
using namespace std;

///////////////// macros and typedefs ///////////////////
#define rep(i, n) for (int i = 0, _n = (n); i < _n; ++i)
#define repd(i, n) for (int i = (n)-1; i >= 0; --i)
#define _fill(a, x) memset((a), (x), sizeof((a)))
#define DEB(k) cerr<<"debug: "#k<<"="<<k<<endl;
#define all(c) (c).begin(), (c).end()
#define mp(a, b) make_pair(a, b)
#define l(c) (int)((c).size())
#define sqr(a) ((a)*(a))
#define inf 0x7f7f7f7f
#define pb push_back
#define ppb pop_back
#define x first
#define y second
typedef long long ll;
typedef vector<int> vi;
typedef vector<double> vd;
typedef pair<int,int> pi;

//#define infl 0x7f7f7f7f7f7f7f7fLL

struct Node {
	int v;
	int r3, r4, r5, r7;
	int mask;
	int cost;
	bool operator< (const Node& n2) const {
		return cost > n2.cost;
	}
};

int n;
int d[100];
bool g[100][100];
// 5,376,000
int dist[100][3][4][5][7][1<<7];

bool good(const Node& node) {
	return node.v == n-1 &&
			(!((node.mask>>(2-1))&1) || node.r4%2 == 0) &&
			(!((node.mask>>(3-1))&1) || node.r3 == 0) &&
			(!((node.mask>>(4-1))&1) || node.r4 == 0) &&
			(!((node.mask>>(5-1))&1) || node.r5 == 0) &&
			(!((node.mask>>(6-1))&1) || (node.r4%2 == 0 && node.r3 == 0)) &&
			(!((node.mask>>(7-1))&1) || node.r7 == 0);
}

void solveCase() {
	rep(i, n)
		scanf("%d", d+i);
	rep(i, n) rep(j, n) {
		int v;
		scanf("%d", &v);
		g[i][j] = v;
	}
	rep(i, n)
		_fill(dist[i], 0x7f);
	Node init = {0, d[0]%3, d[0]%4, d[0]%5, d[0]%7, 1<<(d[0]-1), d[0]};
	priority_queue<Node> pq;
	pq.push(init);
	dist[init.v][init.r3][init.r4][init.r5][init.r7][init.mask] = init.cost;
	int ret = inf;
	if (good(init))
		ret = init.cost;
	int iter = 0;
	while (!pq.empty()) {
		Node cur = pq.top();
		pq.pop();
		if (dist[cur.v][cur.r3][cur.r4][cur.r5][cur.r7][cur.mask] < cur.cost)
			continue;
		if (++iter == 1000)
			break;
		dist[cur.v][cur.r3][cur.r4][cur.r5][cur.r7][cur.mask] = -1;
		if (cur.cost >= ret) break;
		rep(i, n) if (g[cur.v][i]) {
			Node nxt = {i, (cur.r3*10+d[i])%3, (cur.r4*10+d[i])%4, (cur.r5*10+d[i])%5, (cur.r7*10+d[i])%7, cur.mask | (1<<(d[i]-1)), cur.cost+d[i]};
			if (dist[nxt.v][nxt.r3][nxt.r4][nxt.r5][nxt.r7][nxt.mask] > nxt.cost) {
				dist[nxt.v][nxt.r3][nxt.r4][nxt.r5][nxt.r7][nxt.mask] = nxt.cost;
				pq.push(nxt);
				if (good(nxt)) {
					ret = min(ret, nxt.cost);
					printf("%d\n", ret);
					return;
				}
			}
		}
	}
	if (ret == inf) ret = -1;
	printf("%d\n", ret);
	DEB(iter);
}

void solution()
{
	for ( ;; ) {
		scanf("%d", &n);
		if (n == 0) break;
		solveCase();
	}
}

int main()
{
#ifdef MY_JUDGE
    freopen("my.in", "rt", stdin);
    //freopen("my.out", "wt", stdout);
#endif
    solution();
#ifdef MY_JUDGE
    fprintf(stderr, "Time: %.2lf sec\n", (clock()*1./CLOCKS_PER_SEC));
#endif
    return 0;
}