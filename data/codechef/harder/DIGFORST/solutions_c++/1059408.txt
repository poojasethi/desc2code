#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
using namespace std;
typedef long long LL;
typedef vector<int> VI;
typedef pair<int,int> PI;
#define PB(x) push_back(x)
#define MP(x,y) make_pair(x,y)
#define F first
#define S second
#define SET(v,x) memset(v,x,sizeof v)
#define FOR(i,a,b) for(int _n(b),i(a);i<_n;i++) 
#define EACH(it,v) for(typeof((v).begin()) it = (v).begin();it!=(v).end();it++)
#define REP(i,n) FOR(i,0,n)
#define ALL(v) (v).begin(),(v).end()
#define SORT(v) sort(ALL(v))
#define SZ(v) int(v.size())
#define SI ({int x;scanf("%d",&x);x;})

#define MX 102

int N, dig[MX];
VI G[MX];
bool can[8];
int dd[] = {2, 3, 4, 6, 7};

struct node
{
	int cv, cd, m3, m4, m7;
	node(){}
	node(int v,int d,int mm3,int mm4,int mm7){ cv=v; cd=d; m3=mm3; m4=mm4; m7=mm7; }
};

bool operator < (const node& a, const node & b)
{ return a.cd > b.cd; }

int cmods[8], nmods[8];
int dist[100][3][4][7];
const int inf = (int)1e9;

int dijkstra()
{
	for(int i=0;i<N;i++) for(int m3=0;m3<3;m3++)
		for(int m4=0;m4<4;m4++) for(int m7=0;m7<7;m7++)
			dist[i][m3][m4][m7] = inf;
			
	priority_queue<node> pq;
	int d = dig[0];
	
	pq.push(node(0,d,d%3,d%4,d%7));
	
	while(!pq.empty())
	{
		node cur = pq.top(); pq.pop();
		
		if( dist[cur.cv][cur.m3][cur.m4][cur.m7] == -1 ) continue;
		
		dist[cur.cv][cur.m3][cur.m4][cur.m7] = -1;
				
		cmods[7] = cur.m7; cmods[4] = cur.m4; cmods[3] = cur.m3;
		cmods[2] = cmods[4]%2;
		cmods[6] = (cmods[2]==0 && cmods[3]==0) ? 0 : 1;
		cmods[1] = 0;
		cmods[5] = dig[cur.cv]%5;
		
		if(cur.cv==N-1)
		{
			bool ok = true;
			for(int i=1;i<=7;i++) if(can[i] && cmods[i]!=0) ok = false;
			if(ok) return cur.cd;
		}
		
		EACH(it,G[cur.cv])
		{
			int nv = *it;
			if(!can[dig[nv]]) continue;
			
			nmods[3] = ( cmods[3] * 10 + dig[nv] ) % 3;
			nmods[4] = ( cmods[4] * 10 + dig[nv] ) % 4;
			nmods[7] = ( cmods[7] * 10 + dig[nv] ) % 7;
			
			int nd = cur.cd + dig[nv];
			
			if( nd < dist[nv][nmods[3]][nmods[4]][nmods[7]] )
			{ 
				dist[nv][nmods[3]][nmods[4]][nmods[7]] = nd;	
				pq.push(node(nv,nd,nmods[3],nmods[4],nmods[7]));
			}
		}
	}
	return -1;
}

bool done[(1<<8)];

int main()
{
	#ifndef ONLINE_JUDGE
		freopen("in1.in","r",stdin);
		//freopen("out1.out","w",stdout);
	#endif

	while(1)
	{
		N = SI;
		if(N==0) break;
		REP(i,N) dig[i] = SI;
		REP(i,N)
		{
			G[i].clear();
			REP(j,N){ int x = SI; if(x) G[i].PB(j); }
		}
		if(N==1)
			printf("%d\n",dig[0]);
		else
		{
			int ans = -1;
			SET(done,false);
			for(int i=0;i<(1<<5);i++)
			{
				SET(can,false);
				can[1] = true;
				for(int j=0;j<5;j++) if((i&(1<<j))) can[dd[j]] = true;
				can[dig[0]] = true;
				can[dig[N-1]] = true;
				//if(can[6]) can[2] = true, can[3] = true;
				//if(can[4]) can[2] = true;
				int cmask = 0;
				for(int j=1;j<8;j++) if(can[j]) cmask|=(1<<j);
				if(done[cmask]) continue;
				done[cmask] = true;
				int cans = dijkstra();
				if(cans!=-1 && (ans==-1 || cans<ans)) ans = cans;
			}
			printf("%d\n",ans);
		}
	}
		
	return 0;	
}