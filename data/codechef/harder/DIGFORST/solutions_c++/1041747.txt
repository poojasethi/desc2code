#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>
#include <tr1/unordered_map>
#include <tr1/functional>
#include <cmath>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> ii;
typedef long double real;

///////////////////////////////UTIL/////////////////////////////////
#define ALL(x) (x).begin(),x.end()
#define CLEAR(v) memset(v, 0, sizeof(v))
#define REP(i,n) for(int i = 0; i<n; i++)
#define REPP(i,a,n) for(int i = a; i<n; i++)
#define REPD(i,n) for(int i = n-1; i>-1; i--)
#define REPDP(i,a,n) for(int i = a; i>-1; i--)
/////////////////////////////NUMERICAL//////////////////////////////
#define INCMOD(a,b) a = (a+b)%MOD
#define DECMOD(a,b) a = (a+MOD-1)%mod
#define ROUNDINT(a) (int)((double)a + 0.5)
#define INF 2000000000
/////////////////////////////BITWISE////////////////////////////////
#define CHECK(S, j) (S & (1 << j))
#define CHECKFIRST(S) (S & (-S))  //PRECISA DE UMA TABELA PARA TRANSFORMAR EM INDICE
#define SET(S, j) S |= (1 << j)
#define SETALL(S, j) S = (1 << j)-1  //J PRIMEIROS
#define UNSET(S, j) S &= ~(1 << j)
#define TOOGLE(S, j) S ^= (1 << j)
#define MAX 100
#define MOD 420

int best[MAX][64][MOD];
int digit[MAX];
int grafo[MAX][MAX];
int grau[MAX];
int n;

class VERTEX{
	public:

	int i, dig, rem, sum;

	bool operator() (const VERTEX &a, const VERTEX &b){
		if(a.sum != b.sum) return (a.sum > b.sum);
		return (a.i > b.i);
	}

};

bool check(int dig, int mod) {
    for (int i = 0; i < 6; i++) {
        if ((dig & (1 << i)) && (mod % (i + 2)))
            return false;
    }

    return true;
}

int dik(int start, int end)
{
	int res = INF;
	memset(best, 127, sizeof(best));
	VERTEX u, v;
	u.i = start;
	u.dig = 0;
    if(digit[start] > 1) u.dig = 1 << (digit[start] - 2);
	u.rem = digit[start]%MOD;
	u.sum = digit[start];

	priority_queue<VERTEX, vector<VERTEX>, VERTEX> q;
	q.push(u);

	best[u.i][u.dig][u.rem] = u.sum;

	//cout << "SETANDO BEST[" << u.i << "][" << u.dig << "][" << u.rem << "] = " << u.sum << endl;

	while(!q.empty()){

		u = q.top(); q.pop();
		//cout << "TIRANDO DA FILA O VERT: " << u.i << " " << u.dig << " " << u.rem << " " << u.sum << endl;
		//cout << " BEST PRA ELE EH " << best[u.i][u.dig][u.rem] << endl;

		if(u.sum == best[u.i][u.dig][u.rem])
		REP(j, grau[u.i]){
			v.i = grafo[u.i][j];
			v.dig = u.dig;
            if (digit[v.i] > 1) v.dig |= (1 << (digit[v.i] - 2));
			v.rem = (u.rem * 10 + digit[v.i])%MOD;
			v.sum = u.sum + digit[v.i];
			if(v.sum < best[v.i][v.dig][v.rem]){
				if(v.i == end){
					if( check(v.dig, v.rem) && v.sum < res) res = v.sum;
				}
				best[v.i][v.dig][v.rem] = v.sum;
				if(v.sum + digit[end] < res) q.push(v);
			}
		}
		//else cout << " NAO EH ESSE O CERTO \n";
	}
	return res;
}

int main()
{
	int a;
	scanf(" %d ", &n);
	while(n){	
		CLEAR(grau);
		REP(i, n) scanf(" %d ", &digit[i]);
		REP(i, n)
		REP(j, n){
			scanf(" %d ", &a);
			if(a){
				grafo[i][grau[i]++] = j;
			}
		}
		int res = dik(0, n-1);
		if(res == INF) printf("-1\n");
		else{
			printf("%d\n", res);
		}
		scanf(" %d ", &n);
	}
}
