#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>
#include <tr1/unordered_map>
#include <tr1/functional>
#include <cmath>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> ii;
typedef long double real;

///////////////////////////////UTIL/////////////////////////////////
#define ALL(x) (x).begin(),x.end()
#define CLEAR(v) memset(v, 0, sizeof(v))
#define REP(i,n) for(int i = 0; i<n; i++)
#define REPP(i,a,n) for(int i = a; i<n; i++)
#define REPD(i,n) for(int i = n-1; i>-1; i--)
#define REPDP(i,a,n) for(int i = a; i>-1; i--)
/////////////////////////////NUMERICAL//////////////////////////////
#define INCMOD(a,b) a = (a+b)%MOD
#define DECMOD(a,b) a = (a+MOD-1)%mod
#define ROUNDINT(a) (int)((double)a + 0.5)
#define INF 2000000000
/////////////////////////////BITWISE////////////////////////////////
#define CHECK(S, j) (S & (1 << j))
#define CHECKFIRST(S) (S & (-S))  //PRECISA DE UMA TABELA PARA TRANSFORMAR EM INDICE
#define SET(S, j) S |= (1 << j)
#define SETALL(S, j) S = (1 << j)-1  //J PRIMEIROS
#define UNSET(S, j) S &= ~(1 << j)
#define TOOGLE(S, j) S ^= (1 << j)
#define MAX 100
#define MOD 420

int best[MAX][64][MOD];
bool inq[MAX][64][MOD];
int digit[MAX];
int grafo[MAX][MAX];
int grau[MAX];
int n;

typedef struct struct_vertex{
	public:

	int i, dig, rem;

} VERTEX;

bool check(int dig, int mod) {
    for (int i = 0; i < 6; i++) {
        if ((dig & (1 << i)) && (mod % (i + 2)))
            return false;
    }

    return true;
}

int bel(int start, int end)
{
	int res = INF;
	memset(best, 127, sizeof(best));
	memset(inq, 0, sizeof(inq));
	VERTEX u, v;
	u.i = start;
	u.dig = 0;
    if(digit[start] > 1) u.dig = 1 << (digit[start] - 2);
	u.rem = digit[start]%MOD;

	queue<VERTEX> q;
	q.push(u);

	best[u.i][u.dig][u.rem] = digit[start];
	inq[u.i][u.dig][u.rem] = true;

	//cout << "SETANDO BEST[" << u.i << "][" << u.dig << "][" << u.rem << "] = " << u.sum << endl;

	while(!q.empty()){

		u = q.front(); q.pop();
		inq[u.i][u.dig][u.rem] = false;
		//cout << "TIRANDO DA FILA O VERT: " << u.i << " " << u.dig << " " << u.rem << " " << u.sum << endl;
		//cout << " BEST PRA ELE EH " << best[u.i][u.dig][u.rem] << endl;
		REP(j, grau[u.i]){
			v.i = grafo[u.i][j];
			v.dig = u.dig;
            if (digit[v.i] > 1) v.dig |= (1 << (digit[v.i] - 2));
			v.rem = (u.rem * 10 + digit[v.i])%MOD;
			if(best[u.i][u.dig][u.rem]+digit[v.i] < best[v.i][v.dig][v.rem]){
				best[v.i][v.dig][v.rem] = best[u.i][u.dig][u.rem]+digit[v.i];
				if(!inq[v.i][v.dig][v.rem]){
					if(best[v.i][v.dig][v.rem] + digit[end] < res){
						q.push(v);
						inq[v.i][v.dig][v.rem] = true;
					}
						
					if(v.i == end){
						if( check(v.dig, v.rem) && best[v.i][v.dig][v.rem] < res) res = best[v.i][v.dig][v.rem];
					}
				}
			}
		}
		//else cout << " NAO EH ESSE O CERTO \n";
	}
	return res;
}

int main()
{
	int a;
	scanf(" %d ", &n);
	while(n){	
		CLEAR(grau);
		REP(i, n) scanf(" %d ", &digit[i]);
		REP(i, n)
		REP(j, n){
			scanf(" %d ", &a);
			if(a){
				grafo[i][grau[i]++] = j;
			}
		}
		int res = bel(0, n-1);
		if(res == INF) printf("-1\n");
		else{
			printf("%d\n", res);
		}
		scanf(" %d ", &n);
	}
}
