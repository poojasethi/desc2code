#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<cctype>
#include<cstdio>
#include<string>
#include<sstream>
#include<cstring>
#include<cstdlib>
#include<fstream>
#include<iterator>
#include<iostream>
#include<algorithm>
 
using namespace std;
 
#pragma comment(linker,"/STACK:16777216")
#pragma warning(disable:4786)
 
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define myabs(a) ((a)<0?(-(a)):(a))
#define pi acos(-1.0)
#define inf (1<<25)
#define CLR(a) memset(a,0,sizeof(a))
#define SET(a) memset(a,-1,sizeof(a))
#define pb push_back
#define all(a) a.begin(),a.end()
#define xx first
#define yy second
#define eps 1e-9
#define i64 long long
#define MX 102
#define MOD 420
 
typedef pair<int,int> pii;
 
struct node{
int u,bt,md;
int cost;
node(){}
node(int uu,int bbt,int mmd,int c){
u=uu;
bt=bbt;
md=mmd;
cost=c;
}
bool operator <(const node &a)const{
return cost>a.cost;
}
};
 
int val[MX],n;
vector<int> g[MX];
int d[MX][MX][500];
int dv[MX];
 
int dijkstra(node u){
priority_queue<node> q;
node v;
int i,sz;
memset(d,1,sizeof(d));
d[u.u][u.bt][u.md]=u.cost;
q.push(u);
while(!q.empty()){
u=q.top();q.pop();
if(u.u==n && u.md%dv[u.bt]==0){
return u.cost;
}
sz=g[u.u].size();
for(i=0;i<sz;i++){
v.u=g[u.u][i];
if(val[v.u]>1)v.bt=u.bt|(1<<(val[v.u]-2));
else v.bt=u.bt;
v.md=(u.md*10+val[v.u])%MOD;
v.cost=u.cost+val[v.u];
if(v.cost<d[v.u][v.bt][v.md]){
d[v.u][v.bt][v.md]=v.cost;
q.push(v);
}
}
}
return inf;
}
 
int gcd(int a,int b){
return a==0?b:gcd(b%a,a);
}
 
int lcm(int a,int b){
int g=gcd(a,b);
return a*b/g;
}
 
int main()
{
//freopen("in.txt","r",stdin);
int i,j,x;
int res;
for(i=0;i<64;i++){
dv[i]=1;
for(j=0;j<6;j++){
if(i&(1<<j)){
dv[i]=lcm(dv[i],j+2);
}
}
}
while(scanf("%d",&n)==1 && n){
for(i=1;i<=n;i++)scanf("%d",&val[i]);
for(i=1;i<=n;i++){
g[i].clear();
for(j=1;j<=n;j++){
scanf("%d",&x);
if(x)g[i].pb(j);
}
}
if(val[1]>1)i=1<<(val[1]-2);
else i=0;
res=dijkstra(node(1,i,val[1],val[1]));
if(res>=inf){
printf("-1\n");
}
else printf("%d\n",res);
}
return 0;
}
 