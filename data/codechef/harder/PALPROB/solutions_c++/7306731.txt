#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<cmath>
#include<stack>
#include<set>
#include<queue>
#include<string>
#include<iostream>
#include<map>
#include<cstdlib>
#include<ctime> 
#include<sstream>
using namespace std;

//freopen("in.txt","r",stdin);  FILE-IO 
//fclose(stdin);        FILE-IO
//srand (time(NULL));       RANDOM NUMBERS

#define sd(a) scanf("%lld",&a)
#define pd(a) printf("%lld\n",(a))
#define clr(a) memset(a,0,sizeof(a))
#define LL long long
#define F first
#define S second
#define MP make_pair
#define PB push_back
struct node
{
	long long en,l;
	vector<long long> adj;
	vector<long long> rev;
	long long cnt;
	long long suff;
	long long f[30];
	node(long long e,long long len,long long sl)
	{
		cnt=1;
		en=e;
		l=len;
		suff=sl;
		adj.clear();
		rev.clear();
		for(long long i=0;i<26;++i)
			f[i]=0;
	}
	node()
	{
		cnt=1;
		en=0;
		l=0;
		suff=0;
		adj.clear();
		rev.clear();
		for(long long i=0;i<26;++i)
			f[i]=0;
	}
};
vector<node> tree;
char s[100010];
long long first[30];
long long p[100010];
void buildtree()
{
	tree.clear();
	tree.PB(node(0,-1,0));
	tree.PB(node(0,0,0));
	tree[0].rev.PB(1);
	long long cur,next=0;
	long long pos=-1;
	long long l=strlen(s);
	for(pos=-1;pos<l-1;++pos)
	{
		cur=next;
		while(!(pos-tree[cur].l>=0&&s[pos+1]==s[pos-tree[cur].l]))
		{
			cur=tree[cur].suff;
		}
		if(tree[cur].f[s[pos+1]-'a']==0)
		{
			next=tree.size();
			tree.PB(node(pos+1,tree[cur].l+2,-1));
			tree[cur].f[s[pos+1]-'a']=next;
			tree[next].en=pos+1;
			cur=tree[cur].suff;
			while(!(pos-tree[cur].l>=0&&s[pos+1]==s[pos-tree[cur].l]))
			{
				cur=tree[cur].suff;
			}
			cur=tree[cur].f[s[pos+1]-'a'];
			if(cur==next)
			{
				tree[next].suff=1;
				tree[1].rev.PB(next);
			}
			else	
			{
				tree[next].suff=cur;
				tree[cur].rev.PB(next);
			}
		}
		else
		{
			next=tree[cur].f[s[pos+1]-'a'];
			tree[next].cnt++;
		}
	}
}
long long go(long long cur)
{
	long long i;
	for(i=0;i<tree[cur].rev.size();++i)
	{
		tree[cur].cnt=tree[cur].cnt+go(tree[cur].rev[i]);
	}
	return tree[cur].cnt;
}
long long ans;
void calc(long long cur)
{
	long long i;
	if(tree[cur].l==1)
	{
		p[tree[cur].l]=1;
		ans=ans+tree[cur].cnt;
	}
	else if(tree[cur].l>1)
	{
		p[tree[cur].l]=1+p[(tree[cur].l)/2];
		ans=ans+(1+p[(tree[cur].l)/2])*tree[cur].cnt;
	}
	for(i=0;i<tree[cur].rev.size();++i)
	{
		calc(tree[cur].rev[i]);
	}
	p[tree[cur].l]=0;
}
int main()
{
	long long t,i;
	sd(t);
	while(t--)
	{
		ans=0;
		scanf("%s",&s);
		buildtree();
		go(0);
		long long l=strlen(s);
		for(i=0;i<l;++i)
			p[i]=0;
		calc(0);
		printf("%lld\n",ans);
	}
	/*for(long long i=0;i<tree.size();++i)
	{
		cout<<"i:"<<i<<"\n";
		cout<<"length:"<<tree[i].l<<"\n";
		cout<<"en:"<<tree[i].en<<"\n";
		cout<<"suff:"<<tree[i].suff<<"\n";
		cout<<"size:"<<tree[i].rev.size()<<"\n";
		cout<<"cnt:"<<tree[i].cnt<<"\n";
		for(long long j=0;j<tree[i].rev.size();++j)
			cout<<tree[i].rev[j]<<' ';
		cout<<'\n';
		for(long long j=tree[i].en;j>=tree[i].en-tree[i].l+1;--j)
			cout<<s[j];
		cout<<" -----------\n\n";
	}
	*/

}