#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

int n_,n,m,i,j,k,u,v,ans;
int son[100005],next[200005],ed[200005],tot;
int son2[100005],next2[200005],ed2[200005],cost[200005];
int size[100005],deep[100005];
int tfa[100005],heavy[100005],head[100005];
int st[100005],en[100005],id[100005],cnt;
int stk[100005],top;
int app[100005],appT;
int Max[400005],now[100005],l;

void update(int x){if(now[Max[x<<1]]>now[Max[x<<1|1]])Max[x]=Max[x<<1];else Max[x]=Max[x<<1|1];}

int get_fa(int u,int d)
{
	for(;deep[head[u]]>d;u=tfa[head[u]]);
	return id[st[u]-(deep[u]-d)];
}

struct node
{
	int x,r;
}t[100005];
inline bool cmp(const node &a,const node &b){return st[a.x]<st[b.x];}

int LCA(int u,int v)
{
	for(;head[u]!=head[v];)
	if(deep[head[u]]>deep[head[v]])u=tfa[head[u]];
	else v=tfa[head[v]];
	if(deep[u]<deep[v])return u;
	return v;
}

void dfs(int x)
{
	size[x]=1;
	for(int i=son[x];i;i=next[i])
	if(!size[ed[i]])
	{
		tfa[ed[i]]=x;
		deep[ed[i]]=deep[x]+1;
		dfs(ed[i]);
		size[x]+=size[ed[i]];
		if(size[ed[i]]>size[heavy[x]])heavy[x]=ed[i];
	}
	en[x]=cnt;
}

void dfss(int x)
{
	st[x]=++cnt;id[cnt]=x;
	if(!head[x])head[x]=x;
	if(heavy[x])head[heavy[x]]=head[x],dfss(heavy[x]);
	for(int i=son[x];i;i=next[i])
	if(!head[ed[i]])dfss(ed[i]);
	en[x]=cnt;
}

int Sum,root,root_sum,D;
int fa[100005][30],dist[100005][30];
int pool[10000005],pool_cnt;
int *sum,*sum1[100005],*sum2[100005],d1[100005],d2[100005];
bool vis[100005];

void dfs1(int x)
{
	vis[x]=true;
	size[x]=1;
	for(int i=son[x];i;i=next[i])
	if(!vis[ed[i]])
	{
		dfs1(ed[i]);
		size[x]+=size[ed[i]];
	}
	vis[x]=false;
}

void dfs2(int x)
{
	vis[x]=true;
	int now=Sum-size[x];
	for(int i=son[x];i;i=next[i])
	if(!vis[ed[i]])
	{
		dfs2(ed[i]);
		if(size[ed[i]]>now)now=size[ed[i]];
	}
	if(now<root_sum)root=x,root_sum=now;
	vis[x]=false;
}

void dfs3(int x,int y)
{
	vis[x]=true;
	fa[x][++fa[x][0]]=root;
	dist[x][fa[x][0]]=y;
	if(x<=n_)
	{
		++sum[y];
		if(y>D)D=y;
	}
	for(int i=son[x];i;i=next[i])
	if(!vis[ed[i]])dfs3(ed[i],y+1);
	vis[x]=false;
}

void dfs4(int x,int y)
{
	vis[x]=true;
	if(x<=n_)
	{
		++sum[y];
		if(y>D)D=y;
	}
	for(int i=son[x];i;i=next[i])
	if(!vis[ed[i]])dfs4(ed[i],y+1);
	vis[x]=false;
}

int work(int x)
{
	int i,j;
	dfs1(x);
	Sum=size[x];
	root_sum=1000000;
	dfs2(x);
	x=root;
	D=0;sum=sum1[x]=pool+pool_cnt;
	dfs3(x,0);
	for(i=1;i<=D;++i)sum[i]+=sum[i-1];
	d1[x]=D;pool_cnt+=D+2;
	vis[x]=true;
	for(i=son[x];i;i=next[i])
	if(!vis[ed[i]])
	{
		int y=work(ed[i]);
		D=0;sum=sum2[y]=pool+pool_cnt;
		dfs4(ed[i],1);
		for(j=1;j<=D;++j)sum[j]+=sum[j-1];
		d2[y]=D;pool_cnt+=D+2;
	}
	vis[x]=false;
	return x;
}

int get_sum(int x,int r,int *sum,int d)
{
	if(r<0)return 0;
	if(r>d)return sum[d];
	return sum[r];
}

int calc(int x,int r)
{
	int i,y,z,ans=get_sum(x,r,sum1[x],d1[x]);
	for(i=fa[x][0]-1;i;--i)
	{
		y=fa[x][i];z=fa[x][i+1];
		ans+=get_sum(y,r-dist[x][i],sum1[y],d1[y]);
		ans-=get_sum(z,r-dist[x][i],sum2[z],d2[z]);
	}
	return ans;
}

int main()
{
	scanf("%d",&n);n_=n;
	for(i=n-1;i;--i)
	{
		scanf("%d%d",&u,&v);++n;
		++tot;next[tot]=son[u];son[u]=tot;ed[tot]=n;
		++tot;next[tot]=son[n];son[n]=tot;ed[tot]=u;
		++tot;next[tot]=son[v];son[v]=tot;ed[tot]=n;
		++tot;next[tot]=son[n];son[n]=tot;ed[tot]=v;
	}
	dfs(1);dfss(1);
	work(1);
	scanf("%d",&m);
	for(l=1;l<n;l<<=1);
	for(;m;--m)
	{
		scanf("%d",&cnt);++appT;
		for(i=1;i<=cnt;++i)
		{
			scanf("%d%d",&t[i].x,&t[i].r);
			app[t[i].x]=appT;t[i].r*=2;
		}
		sort(t+1,t+cnt+1,cmp);
		for(i=cnt;i>1;--i)
		{
			u=LCA(t[i].x,t[i-1].x);
			if(app[u]!=appT)app[u]=appT,t[++cnt].x=u,t[cnt].r=-1;
		}
		sort(t+1,t+cnt+1,cmp);
		stk[top=1]=t[1].x;
		tot=0;
		for(i=2;i<=cnt;++i)
		{
			u=t[i].x;
			for(;;--top)
			{
				v=stk[top];
				if(st[v]<=st[u]&&en[v]>=en[u])break;
			}
			++tot;next2[tot]=son2[u];son2[u]=tot;ed2[tot]=v;cost[tot]=deep[u]-deep[v];
			++tot;next2[tot]=son2[v];son2[v]=tot;ed2[tot]=u;cost[tot]=deep[u]-deep[v];
			stk[++top]=u;
		}
		for(i=1;i<=cnt;++i)
		{
			u=t[i].x;now[u]=t[i].r;
			Max[j=l+u-1]=u;
			for(j>>=1;j;j>>=1)update(j);
		}
		for(;Max[1];)
		{
			u=Max[1];
			Max[i=l+u-1]=0;
			for(i>>=1;i;i>>=1)update(i);
			for(i=son2[u];i;i=next2[i])
			if(now[u]-cost[i]>now[ed2[i]])
			{
				now[ed2[i]]=now[u]-cost[i];
				for(j=l+ed2[i]-1>>1;j;j>>=1)update(j);
			}
		}
		for(i=1;i<=cnt;++i)t[i].r=now[t[i].x];
		ans=0;
		for(i=1;i<=cnt;++i)ans+=calc(t[i].x,t[i].r);
		stk[top=1]=t[1].x;
		for(i=2;i<=cnt;++i)
		{
			u=t[i].x;
			for(;;--top)
			{
				v=stk[top];
				if(st[v]<=st[u]&&en[v]>=en[u])break;
			}
			if(now[u]+now[v]>=deep[u]-deep[v])
			{
				k=(deep[u]+deep[v]+now[v]-now[u])/2;
				ans-=calc(get_fa(u,k),now[u]-(deep[u]-k));
			}
			stk[++top]=u;
		}
		printf("%d\n",ans);
		for(i=1;i<=cnt;++i)son2[t[i].x]=0;
	}
}