#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef double db;
const db pi=acos(-1);
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
const int inf=1061109567;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
#define x1 x192837465
#define x2 x123456789
#define y1 y192837465
#define y2 y123456789
int n;
struct edge{
	int v,next;
}e[211111];int g[105555];int etot=0;
void ae(int u,int v){
	e[etot].v=v;e[etot].next=g[u];g[u]=etot++;
}
int ind;
int lef[105555]={0},rig[105555];int eid[105555];
int h[105555];
int eu[19][211111];int eutot=0;
int pre[19][211111];
int inline gmi(int x,int y){
	if(eid[x]<eid[y])return x;
	else return y;
}
void dfs(int u){
	lef[u]=++ind;
	eu[0][++eutot]=u;
	eid[u]=eutot;
	for (int i=g[u];~i;i=e[i].next)if(!lef[e[i].v]){
		h[e[i].v]=h[u]+1;
		pre[0][e[i].v]=u;
		dfs(e[i].v);
		eu[0][++eutot]=u;
	}
	rig[u]=ind;
}
int l2[211111];
void ini(){
	l2[1]=0;
	for (int i=2;i<=201111;i++)l2[i]=i&(i-1)?l2[i-1]:l2[i-1]+1;
	for (int i=1;i<=18;i++){
		int le=1<<i;
		for (int u=1;u+le-1<=eutot;u++)eu[i][u]=gmi(eu[i-1][u],eu[i-1][u+(1<<i-1)]);
		for (int u=1;u<=n+n-1;u++)pre[i][u]=pre[i-1][pre[i-1][u]];
	}
}
int up(int u,int h){
	for (int i=0;h;i++)if(h&1<<i)u=pre[i][u],h^=1<<i;
	return u;
}
int lca(int u,int v){
	if(eid[u]>eid[v])swap(u,v);
	int le=l2[eid[v]-eid[u]+1];
	return gmi(eu[le][eid[u]],eu[le][eid[v]-(1<<le)+1]);
}
int dis(int u,int v){
	int l=lca(u,v);
	return h[u]+h[v]-2*h[l];
}
struct node{
	int v,d;
}li[1055555];
int cmp(const node&a,const node&b){
	return lef[a.v]<lef[b.v];
}
edge e2[211111];int g2[105555];int etot2;
void ae2(int u,int v){
	e2[etot2].v=v;e2[etot2].next=g2[u];g2[u]=etot2++;
}
int stk[105555];int top;
int go[105555];

struct qnode{
	int v,d;
};
int operator<(const qnode &a,const qnode&b){
	return a.d<b.d;
}
priority_queue<qnode>quu;



int off[111111]={0};
int qu[111111],sz[111111],pr[111111],bo[111111];
int findc(int x){
	int p=0,q=0;
	qu[q++]=x;
	pr[x]=0;
	while(p!=q){
		int u=qu[p++];
		sz[u]=1;
		bo[u]=1;
		for (int i=g[u];~i;i=e[i].next)if(!off[e[i].v] && e[i].v!=pr[u]){
			pr[e[i].v]=u;
			qu[q++]=e[i].v;
		}
	}
	for (int i=q-1;i>=0;i--){
		int u=qu[i];
		if(bo[u] && sz[u]*2>=q)return u;
		sz[pr[u]]+=sz[u];
		if(sz[u]*2>q)bo[pr[u]]=0;
	}
}
int C[19][111111],V[19][111111];
int buf[11111111]={0};int *ptr=buf;
int *cnt[111111],*vcnt[19][111111];
int cntlen[111111],vcntlen[19][111111];


int hh[111111];
void mark(int v,int dep,int cc){
	int p=0,q=0;
	qu[q++]=v;pr[v]=0;
	hh[v]=1;
	while(p!=q){
		int u=qu[p++];
		for (int i=g[u];~i;i=e[i].next)if(!off[e[i].v] && e[i].v!=pr[u]){
			pr[e[i].v]=u;
			hh[e[i].v]=hh[u]+1;
			qu[q++]=e[i].v;
		}
	}
	int mh=hh[qu[q-1]];
	vcntlen[dep][v]=mh;
	vcnt[dep][v]=ptr;ptr+=mh+2;
	for (int i=0;i<q;i++){
		V[dep][qu[i]]=v;
		C[dep][qu[i]]=cc;
		if(qu[i]<=n)vcnt[dep][v][hh[qu[i]]]++;
	}
	for (int i=1;i<=mh;i++)vcnt[dep][v][i]+=vcnt[dep][v][i-1];
}

void df(int x,int dep){
	int rt=findc(x);
	off[rt]=1;
	C[dep][rt]=rt;
	int mh=0;
	for (int i=g[rt];~i;i=e[i].next)if(!off[e[i].v]){
		mark(e[i].v,dep,rt);
		mh=max(mh,vcntlen[dep][e[i].v]);
	}
	cntlen[rt]=mh;
	cnt[rt]=ptr;ptr+=mh+2;
	if(rt<=n){
		cnt[rt][0]=1;
	}
	for (int i=g[rt];~i;i=e[i].next)if(!off[e[i].v]){
		for (int j=1,up=vcntlen[dep][e[i].v];j<=up;j++)cnt[rt][j]+=vcnt[dep][e[i].v][j]-vcnt[dep][e[i].v][j-1];
	}
	for (int i=1;i<=mh;i++)cnt[rt][i]+=cnt[rt][i-1];
	for (int i=g[rt];~i;i=e[i].next)if(!off[e[i].v]){
		df(e[i].v,dep+1);
	}
}
int query(int rt,int len){
	if(len<0)return 0;
	int ans=0;
	for (int dep=0;C[dep][rt]!=rt;dep++){
		int u=C[dep][rt],v=V[dep][rt];
		int d=dis(u,rt);
		if(d>len)continue;
		ans+=cnt[u][min(len-d,cntlen[u])]-vcnt[dep][v][min(len-d,vcntlen[dep][v])];
	}
	ans+=cnt[rt][min(len,cntlen[rt])];
	return ans;
}
int main()
{
	memset(g,-1,sizeof(g));
	gn(n);
	for (int i=1;i<n;i++){
		int u,v;gn(u);gn(v);
		ae(u,n+i);
		ae(n+i,u);
		ae(n+i,v);
		ae(v,n+i);
	}
	dfs(1);
	ini();
	
	df(1,0);
	int q;
	gn(q);
	/*while(q--){
		int u,d;
		gn(u);gn(d);d*=2;
		printf("%d\n",query(u,d));
	}*/
	while(q--){
		int k;
		gn(k);
		for (int i=1;i<=k;i++)gn(li[i].v),gn(li[i].d),li[i].d*=2;
		sort(li+1,li+1+k,cmp);
		int ok=k;
		for (int i=1;i<ok;i++)li[++k]=(node){lca(li[i].v,li[i+1].v),-2};
		sort(li+1,li+1+k,cmp);
		for (int i=1;i<=k;i++)g2[li[i].v]=-1,go[li[i].v]=-2;
		etot2=0;
		top=0;
		stk[++top]=li[1].v;
		for (int i=1;i<=k;i++){
			if(li[i].d!=-2){
				go[li[i].v]=li[i].d;
				quu.push((qnode){li[i].v,go[li[i].v]});
			}
			if(i==1 || li[i].v==li[i-1].v)continue;
			int v=li[i].v;
			while(top && !(lef[v]>=lef[stk[top]] && rig[v]<=rig[stk[top]]))top--;
			ae2(stk[top],v);
			ae2(v,stk[top]);
			stk[++top]=v;
		}
		while(!quu.empty()){
			qnode t=quu.top();quu.pop();
			if(t.d!=go[t.v])continue;
			for (int i=g2[t.v];~i;i=e2[i].next){
				int tmp=go[t.v]-dis(t.v,e2[i].v);
				if(tmp>go[e2[i].v]){
					go[e2[i].v]=tmp;
					quu.push((qnode){e2[i].v,tmp});
				}
			}
		}
		int ans=0;
		for (int i=1;i<=k;i++){
			if(i>1 && li[i].v==li[i-1].v)continue;
			int u=li[i].v;
			ans+=query(u,go[u]);
			for (int j=g2[li[i].v];~j;j=e2[j].next)if(e2[j].v>u){
				int v=e2[j].v;
				int l=lca(u,v);
				int d=h[u]+h[v]-2*h[l];
				int ud=(d+go[u]-go[v])>>1;
				int md;
				if(ud<=h[u]-h[l])md=up(u,ud);
				else md=up(v,d-ud);
				int ml=(go[u]+go[v]-d)>>1;
				ans-=query(md,ml);
			}
		}
		printf("%d\n",ans);
	}
}
