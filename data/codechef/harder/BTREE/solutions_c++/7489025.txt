#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<string>
#include<cmath>
#include<stack>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
#include<ctime>
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;

#define pb push_back
#define VEC vector
#define For(i,a,b) for(int i=a;i<=b;i++)
#define For_(i,a,b) for(int i=a;i>=b;i--)
#define mem(a,k) memset(a,k,sizeof(a))
#define sqr(a) ((a)*(a))
#define getc getchar_unlocked
//#define getc getchar
inline void read(int &x)//mini fast input function
{
    x=0;
    int ch=getc();int sign=1;
    while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getc();}
    while(ch>='0'&&ch<='9')
        x=(x<<3)+(x<<1)+ch-'0',ch=getc();
    x=x*sign;
}
const int maxn=100010;
const int maxdep=21;
//TreeInfo
int head[maxn],next[maxn<<1],to[maxn<<1],tot;
inline void Add(int x,int y)
{
    next[++tot]=head[x];
    to[tot]=y;head[x]=tot;
}
int F[maxdep][maxn],DEP[maxn];
int Size[maxn],dfn[maxn],dnft;
int n;
inline void DFS(int u,int fa)
{
    F[0][u]=fa;
    for(int i=1;i<maxdep;i++)
        F[i][u]=F[i-1][F[i-1][u]];
    DEP[u]=DEP[fa]+1;
    dfn[u]=++dnft; Size[u]=1;
    for(int i=head[u];i;i=next[i])
    {
        int v=to[i];
        if(v==fa)continue;
        DFS(v,u);
        Size[u]+=Size[v];
    }
}
inline int Jump(int u,int k)
{
    for(int i=maxdep-1;i>=0;i--)
        if(k & (1<<i))u=F[i][u];
    return u;
}
inline int LCA(int u,int v)
{
    if(DEP[u]<DEP[v])swap(u,v);
    int dx=DEP[u]-DEP[v];
    for(register int i=maxdep-1;i>=0;i--)
        if(dx & (1<<i))u=F[i][u];
    if(u==v)return u;
    for(register int i=maxdep-1;i>=0;i--)
        if(F[i][u]!=F[i][v])
            u=F[i][u],v=F[i][v];
    return F[0][u];
}
//Query
struct Query{
    int id,v,sign;
    Query(){}
    Query(int a,int b,int c):id(a),v(b),sign(c){}
};
VEC<Query>Q[maxn];
int Ans[maxn];
//ImagTreeInfo
VEC<int>G[maxn];
int V[maxn],fa[maxn];
int Case[maxn];
int A[maxn];
inline bool cmp(const int &a,const int &b)
{
    return dfn[a]<dfn[b];
}
inline void PushUp(int u)
{
    for(int i=0;i<(int)G[u].size();i++)
    {
        int v=G[u][i];
        PushUp(v);
        V[u]=max(V[u],V[v]-(DEP[v]-DEP[u]));
    }
}
inline void PushDown(int u)
{
    for(int i=0;i<(int)G[u].size();i++)
    {
        int v=G[u][i];
        V[v]=max(V[v],V[u]-(DEP[v]-DEP[u]));
        PushDown(v);
    }
}
//Node DivideAndConquer
int sol[maxn];
int Sum[maxn],dep[maxn];
int ch[maxn],cnt;
int dsum[maxn];
//Calc the successor
inline void GetSuc(int u,int fa)
{
    dep[u]=dep[fa]+1;
    ch[++cnt]=u;
    if(u*2<=n)dsum[dep[u]]++;
    sol[u]=1;
    for(register int i=head[u];i;i=next[i])
        if(!sol[to[i]])GetSuc(to[i],u);
    sol[u]=0;
}
void Solve(int u)
{
    //GetCenter
    for(int i,v,f=0;;)
    {
        for(i=head[u];i;i=next[i])
            if(!sol[v=to[i]] && v!=f && Size[v]*2>Size[u])
                break;
        if(!i)break;
        int dx=Size[u]-Size[v];
        Size[u]=dx; Size[v]+=dx;
        f=u; u=v;
    }
    sol[u]=1; dep[u]=0;
    for(int i=0;i<=Size[u];i++)Sum[i]=0;
    if(u*2<=n)Sum[0]=1;//If center is a real node
    ch[cnt=1]=u;
    for(int k=head[u];k;k=next[k])
    {
        int v=to[k];
        if(sol[v])continue;
        int st=cnt+1;
        GetSuc(v,u);
        for(int i=1;i<=Size[v];i++)dsum[i]+=dsum[i-1];
        for(int i=st;i<=cnt;i++)
        {
            int w=ch[i];
            for(int j=0;j<(int)Q[w].size();j++)
            {
                int d=min(Size[v],Q[w][j].v-dep[w]);
                if(d<0)continue;
                Ans[Q[w][j].id]-=Q[w][j].sign*dsum[d];
            }
        }
        for(int i=Size[v];i;i--)Sum[i]+=dsum[i]-dsum[i-1],dsum[i]=0;
        Sum[0]+=dsum[0];dsum[0]=0;
    }
    for(int i=1;i<=Size[u];i++)Sum[i]+=Sum[i-1];
    for(int i=1;i<=cnt;i++)
    {
        int w=ch[i];
        for(int j=0;j<(int)Q[w].size();j++)
        {
            int d=min(Size[u],Q[w][j].v-dep[w]);
            if(d<0)continue;
            Ans[Q[w][j].id]+=Q[w][j].sign*Sum[d];
        }
    }
    for(int i=head[u];i;i=next[i])
        if(!sol[to[i]])Solve(to[i]);
}
int main()
{
    #ifndef ONLINE_JUDGE
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
    #endif
    read(n);
    for(int i=1;i<n;i++)
    {
        int x,y;
        read(x),read(y);
        Add(x,i+n);Add(i+n,x);
        Add(y,i+n);Add(i+n,y);
    }
    n*=2;
    DFS(1,0);
    int m,q;
    read(q);
    for(int ca=1;ca<=q;ca++)
    {
        read(m);
        for(int i=1;i<=m;i++)
        {
            int a,r;
            read(a),read(r);
            Case[a]=ca; V[a]=r*2;
            A[i]=a;
        }
        //BuildImagTree
        sort(A+1,A+1+m,cmp);
        for(int i=m;i>1;i--)A[++m]=LCA(A[i],A[i-1]);
        sort(A+1,A+1+m,cmp);
        m=unique(A+1,A+1+m)-A-1;
        for(int i=1;i<=m;i++)
            if(Case[A[i]]!=ca)V[A[i]]=-1;
        for(int i=2;i<=m;i++)
        {
            fa[A[i]]=LCA(A[i],A[i-1]);
            G[fa[A[i]]].pb(A[i]);
        }
        PushUp(A[1]);
        PushDown(A[1]);
        for(int i=1;i<=m;i++)
        {
            int u=A[i],f=fa[u];
            if(V[u]>=0)Q[u].pb(Query(ca,V[u],1));
            if(i!=1 && V[u]>=0 && V[f]>=0)
            {
                int r=V[u]+V[f]-(DEP[u]-DEP[f]);
                if(r>=0)
                {
                    r/=2;
                    Q[Jump(u,V[u]-r)].pb(Query(ca,r,-1));
                }
            }
            G[u].clear();
        }
    }
    Solve(1);
    for(int i=1;i<=q;i++)
        printf("%d\n",Ans[i]);
    return 0;
}