#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <algorithm>
#include <vector>

using namespace std;

#define LOCAL 0
#define USE_BRUTE_FORCE 0
#define DEBUG 0
#define NMAX 50011
#define SMAX 1111
#define HMAX 666

vector<int> vec[NMAX];
int N;

void ReadTree() {
	int i, j, k;
	if (LOCAL) {
		srand(12345);
		N = 30000;
	} else scanf("%d", &N);
	for (k = 1; k < N; k++) {
		if (LOCAL) {
			i = k + 1;
			//if (k <= 10) j = 1 + (rand() % k);
			//else j = k - 9 + (rand() % 10);
			j = k;
		} else scanf("%d %d", &i, &j);
		vec[i].push_back(j);
		vec[j].push_back(i);
	}
}

vector<int> child[NMAX];
char visited[NMAX];
int parent[NMAX], level[NMAX], depth[NMAX], hmax, dfsmin[NMAX], dfsmax[NMAX], dfsnum;

void DFS1(int x) {
	visited[x] = 1;
	depth[x] = 0;
	if (level[x] > hmax) hmax = level[x];
	dfsnum++;
	dfsmin[x] = dfsnum;
	for (int y = 0; y < vec[x].size(); y++)
		if (!visited[vec[x][y]]) {
			child[x].push_back(vec[x][y]);
			parent[vec[x][y]] = x;
			level[vec[x][y]] = level[x] + 1;
			DFS1(vec[x][y]);
			if (1 + depth[vec[x][y]] > depth[x])
				depth[x] = 1 + depth[vec[x][y]];
		}
	dfsmax[x] = dfsnum;
}

int H;
char special[NMAX];
int snode[SMAX], nsnode, snodeidx[NMAX], snode_depth[SMAX], sparent[NMAX];
int lidx[NMAX], clmin[NMAX][HMAX], clmax[NMAX][HMAX];
int cntidx[SMAX][HMAX];

void DFS2(int x, int sidx) {
	if (x != snode[sidx]) {
		sparent[x] = snode[sidx];
		if (special[x]) return;
	}
	lidx[x] = ++cntidx[sidx][level[x] - level[snode[sidx]]];
	clmin[x][0] = clmax[x][0] = lidx[x];
	for (int j = 1; j < HMAX; j++)
		clmin[x][j] = clmax[x][j] = 0;
	for (int y = 0; y < child[x].size(); y++) {
		DFS2(child[x][y], sidx);
		for (int j = 1; j < HMAX; j++) {
			if (clmin[child[x][y]][j - 1] == 0) break;
			if (clmin[child[x][y]][j - 1] < clmin[x][j] || !clmin[x][j])
				clmin[x][j] = clmin[child[x][y]][j - 1];
			if (clmax[child[x][y]][j - 1] > clmax[x][j])
				clmax[x][j] = clmax[child[x][y]][j - 1];
		}
	}
	if (0&&DEBUG) {
		fprintf(stderr, "sidx=%d x=%d\n", sidx, x);
		for (int j = 0; j < HMAX; j++) {
			if (clmin[x][j] == 0) break;
			fprintf(stderr, "   j=%d: %d-%d\n", j, clmin[x][j], clmax[x][j]);
		}
	}
}

void SelectSpecialNodes() {
	int i, j;
	for (H = 1; H * H < N; H++);
	//H = 100;
	if (DEBUG) fprintf(stderr, "H=%d hmax=%d\n", H, hmax);
	for (nsnode = 0, i = 1; i <= N; i++)
		if ((level[i] % H) == 0 && (depth[i] >= H || level[i] == 0)) {
			special[i] = 1;
			nsnode++;
			snode[nsnode] = i;
			snodeidx[i] = nsnode;
		}
	for (i = 1; i <= nsnode; i++) {
		DFS2(snode[i], i);
		snode_depth[i] = 0;
		for (j = 1; j < HMAX; j++)
			if (cntidx[i][j] > 0) {
				snode_depth[i] = j;
				cntidx[i][j] += cntidx[i][j - 1];
			}
		if (DEBUG) {
			fprintf(stderr, "snode[%d]=%d: snode_depth=%d\n", i, snode[i], snode_depth[i]);
			for (j = 0; j < HMAX; j++)
				if (cntidx[i][j] > 0) {
					fprintf(stderr, "   j=%d: cnt=%d\n", j, cntidx[i][j]);
				}
		}
	}
}

vector<int> snode_in_subtree[NMAX];

void DFS3(int x) {
	if (special[x]) snode_in_subtree[x].push_back(x);
	for (int y = 0; y < child[x].size(); y++) {
		DFS3(child[x][y]);
		for (int z = 0; z < snode_in_subtree[child[x][y]].size(); z++)
			snode_in_subtree[x].push_back(snode_in_subtree[child[x][y]][z]);
	}
}

int lca[NMAX][SMAX];

void DFS5(int x, int special_node_idx, int lca_node) {
	lca[x][special_node_idx] = lca_node;
	//if (special_node_idx == 4) fprintf(stderr, "LCA(x=%d, sidx=%d)=%d\n", x, special_node_idx, lca_node);
	for (int y = 0; y < child[x].size(); y++)
		DFS5(child[x][y], special_node_idx, lca_node);
}

void DFS4(int x) {
	for (int y = 0; y < snode_in_subtree[x].size(); y++)
		lca[x][snodeidx[snode_in_subtree[x][y]]] = x;
	for (int y = 0; y < child[x].size(); y++) {
		for (int z = 0; z < snode_in_subtree[child[x][y]].size(); z++)
			for (int w = 0; w < child[x].size(); w++)
				if (w != y) DFS5(child[x][w], snodeidx[snode_in_subtree[child[x][y]][z]], x);
		if (special[x]) {
			//fprintf(stderr, "---- %d %d\n", x, snodeidx[x]);
			DFS5(child[x][y], snodeidx[x], x);
		}
		DFS4(child[x][y]);
	}
}

void ComputeLCAs() {
	DFS3(1);
	DFS4(1);
}

char bfcovered[NMAX];
int qbf[NMAX], qli, qls, dbf[NMAX];

void BFCover(int x, int d) {
	memset(visited, 0, sizeof(visited));
	qbf[qli = qls = 0] = x;
	visited[x] = bfcovered[x] = 1;
	dbf[x] = 0;
	
	while (qli <= qls) {
		int i = qbf[qli++];
		if (dbf[i] == d) continue;
		for (int j = 0; j < vec[i].size(); j++) {
			int k = vec[i][j];
			if (visited[k]) continue;
			visited[k] = bfcovered[k] = 1;
			dbf[k] = dbf[i] + 1;
			qbf[++qls] = k;
		}
	}
}

void BFCheckAns(int ans) {
	int bfans = 0, i;
	for (i = 1; i <= N; i++) {
		bfans += bfcovered[i];
	}
	if (bfans != ans) {
		fprintf(stderr, "ans=%d bfans=%d\n", ans, bfans);
		exit(2);
	}
}

#define MAXINTV 20000000
int intv[MAXINTV][2], nextintv[MAXINTV], nintv;
vector<pair<int, int> > cintv;
vector<int> lev[SMAX];
int dmax[SMAX], touched[SMAX][HMAX], startintv[SMAX][HMAX], cntintv[SMAX][HMAX];

void ProcessOperations() {
	int Q, q, K, x, d, y, ans;
	int i, j, k, l, lca_node, di, dj, cnt1 = 0, cnt2 = 0, cnt3 = 0, cnt4 = 0;

	if (LOCAL) {
		Q = 50000;
	} else scanf("%d", &Q);

	for (q = 1; q <= Q; q++) {
		for (i = 1; i <= nsnode; i++) {
			lev[i].clear();
			dmax[i] = -1;
		}
		nintv = 0;

		if (USE_BRUTE_FORCE) {
			memset(bfcovered, 0, sizeof(bfcovered));
		}

		if (LOCAL) {
			K = 10;
		} else scanf("%d", &K);
		while (K--) {
			if (LOCAL) {
				x = 1 + (rand() % N);
				d = 1 + (rand() % N);
			} else scanf("%d %d", &x, &d);
			if (DEBUG) fprintf(stderr, "q=%d: x=%d d=%d\n", q, x, d);
			if (USE_BRUTE_FORCE) BFCover(x, d);
			for (i = 1; i <= nsnode; i++) {
				lca_node = lca[x][i];
				di = d - (level[x] - level[lca_node]) - (level[snode[i]] - level[lca_node]);
				if (di > dmax[i]) dmax[i] = di;
				if (lca_node == snode[i] && di < snode_depth[i] &&
					(x == snode[i] || sparent[x] == snode[i] ||
					 d - level[x] + (level[snode[i]] + snode_depth[i]) >= 0)) {
					cnt1++;
					y = x;
					while (y != snode[i] && sparent[y] != snode[i]) {
						y = sparent[y];
						cnt2++;
					}
					if (special[y] && y != snode[i]) y = parent[y];
					j = snode_depth[i];
					int check_dj = 1;
					while (j > dmax[i] && j >= 0) {
						cnt3++;
						if (check_dj) {
							dj = d - (level[x] - level[y]) - (level[snode[i]] + j - level[y]);
							if (dj < 0) {
								j--;
								continue;
							}
						}
						if (y != snode[i]) {
							dj = d - (level[x] - level[parent[y]]) - (level[snode[i]] + j - level[parent[y]]);
							if (dj >= 0) {
								y = parent[y];
								check_dj = 0;
								continue;
							}
						}
						if (clmin[y][level[snode[i]] + j - level[y]] != 0) {
							cnt4++;
							// Node y is the highest node which can influence level j.
							if (DEBUG) {
								dj = d - (level[x] - level[y]) - (level[snode[i]] + j - level[y]);
								fprintf(stderr, "i=%d y=%d j=%d dj=%d: %d-%d\n", i, y, j, dj, clmin[y][level[snode[i]] + j - level[y]], clmax[y][level[snode[i]] + j - level[y]]);
							}
							if (touched[i][j] != q) {
								touched[i][j] = q;
								lev[i].push_back(j);
								startintv[i][j] = cntintv[i][j] = 0;
							}
							nintv++;
							if (nintv >= MAXINTV) exit(111);
							intv[nintv][0] = clmin[y][level[snode[i]] + j - level[y]];
							intv[nintv][1] = clmax[y][level[snode[i]] + j - level[y]];
							nextintv[nintv] = startintv[i][j];
							startintv[i][j] = nintv;
							cntintv[i][j]++;
						}
						check_dj = 1;
						j--;
						if (level[snode[i]] + j < level[y]) y = parent[y];
					}
				}
			}
		}

		ans = 0;
		for (i = 1; i <= nsnode; i++) {
			if (DEBUG) fprintf(stderr, "i=%d dmax=%d\n", i, dmax[i]);
			if (dmax[i] >= 0) {
				if (dmax[i] < snode_depth[i]) ans += cntidx[i][dmax[i]];
				else ans += cntidx[i][snode_depth[i]];
			}
			for (j = 0; j < lev[i].size(); j++)
				if (lev[i][j] > dmax[i]) {
					k = lev[i][j];
					cintv.resize(cntintv[i][k]);
					nintv = 0;
					for (l = startintv[i][k]; l > 0; l = nextintv[l]) {
						cintv[nintv].first = intv[l][0];
						cintv[nintv++].second = intv[l][1];
					}
					sort(cintv.begin(), cintv.end());
					for (di = 0, dj = -1, l = 0; l < nintv; l++) {
						if (cintv[l].first > dj) {
							ans += (dj - di + 1);
							di = cintv[l].first;
							dj = cintv[l].second;
						} else if (cintv[l].second > dj)
							dj = cintv[l].second;
						}
					ans += (dj - di + 1);		
				}
		}
		if (!LOCAL) printf("%d\n", ans);
		if (USE_BRUTE_FORCE) BFCheckAns(ans);
	}

	fprintf(stderr, "cnt1=%d cnt2=%d cnt3=%d cnt4=%d\n", cnt1, cnt2, cnt3, cnt4);
}

int main() {
	int tstart = clock();
//	freopen("x.txt", "r", stdin);
	ReadTree();
	DFS1(1);
	SelectSpecialNodes();
	ComputeLCAs();
	ProcessOperations();
	fprintf(stderr, "Duration=%.3lf sec\n", (double) (clock() - tstart) / CLOCKS_PER_SEC);
	return 0;
}
