# include <cstdio>
# include <cstring>
# include <algorithm>
# define REP(i, n) for (int i = 1; i <= n; ++ i)
# define REP_0N(i, n) for (int i = 0; i <= n; ++ i)
# define FOR(i, a, b) for (int i = a; i <= b; ++ i)
# define CLR(a, x) memset (a, x, sizeof (a))
# define NR 50

using namespace std;
typedef long long ll;

int n, m, q0, a[NR], p[NR], M;
ll f[NR][NR];

ll dfs (int i, int j)
{
	if (j < 0 || j > n) return 0;
	if (i > n) return !j;
	if (f[i][j] != -1) return f[i][j];
	
	if (p[i] == -1)
	{
		if (i + j <= m)
		{
			f[i][j] = 0;
			FOR (t, m - (i + j - 1), n) f[i][j] += dfs (i + 1, j + t);
		}
		else
		{
			f[i][j] = dfs (i + 1, j);
			REP (t, n) f[i][j] += dfs (i + 1, j + t);
			if (i > M) f[i][j] += dfs (i + 1, j - 1);
		}
	}
	else
	{
		if (p[i] == i + j) f[i][j] = dfs (i + 1, j);
		else if (p[i] < i + j) f[i][j] = dfs (i + 1, j - 1);
		else f[i][j] = dfs (i + 1, j + p[i] - (i + j));
	}
//	printf ("%d %d %lld\n", i, j, f[i][j]);
	return f[i][j];
}

/*ll dfs (int i, int j, int k)
{
	if (j < 0 || k < 0) return 0;
	if (k - n > n - i + 1) return 0;
	if (i > n) return !j && k == n;
	if (f[i][j][k] != -1) return f[i][j][k];
	
	
	if (p[i] == -1) 
	{
		if (i + j <= m)
		{
			f[i][j][k] = 0;
			FOR (t, m - (i + j - 1), n)
				f[i][j][k] += dfs (i + 1, j + t, k - t);
		}
		else
		{
			f[i][j][k] = dfs (i + 1, j, k);
			REP (t, n) f[i][j][k] += dfs (i + 1, j + t, k - t);
			if (i > M) f[i][j][k] += dfs (i + 1, j - 1, k + 1);
		}
	}
	else
	{
		if (p[i] == i + j) f[i][j][k] = dfs (i + 1, j, k);
		else if (p[i] < i + j) f[i][j][k] = dfs (i + 1, j - 1, k + 1);
		else f[i][j][k] = dfs (i + 1, j + p[i] - (i + j - 1), k - p[i] + (i + j - 1));
	}
	
	printf ("%d %d %d %lld\n", i, j, k - n, f[i][j][k]);
	return f[i][j][k];
	//X Y
	//X-(i+j) Y-(i+j-1)
	//X+i Y+i-1
}*/

int main ()
{
	for (scanf ("%d", &q0); q0; -- q0)
	{
		scanf ("%d%d", &n, &m), M = 0;
		int lst = 0; CLR (f, -1);
		int ci = 1; bool valid = true;
		REP (i, n) p[i] = -1;
		REP (i, m) 
		{
			scanf ("%d", &a[i]), p[a[i]] = i;
			if (a[i] == ci) for (++ ci; p[ci] != -1 && ci <= n; ++ ci) ;
			else if (a[i] < lst) valid = false;
			else lst = a[i];
			M = max (a[i], M);
		}
		if (!valid) {puts ("0"); continue;}
		printf ("%lld\n", dfs (1, 0));
	}
	//while (1) ;
	return 0;
}
