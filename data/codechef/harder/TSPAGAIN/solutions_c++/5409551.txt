#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
 
#include <cmath>
#include <cstdio>
#include <queue>
#include <list>
#include <stack>
#include <utility>
#include <numeric>
#include <map>
#include <cctype>
#include <cstring>
#include <sstream>
#include <cstdlib>
#include <cassert>
#include <iomanip>
#include <set>
 
using namespace std;
 
#define F(a,b) for(int a=0;a<b;a++)
#define REP(a,b) for(int a=0;a<b;a++)
#define FOR(a,b,c) for(int a=b;a<c;a++)
#define FORD(a,b,c) for(int a=b;a>=c;a--)
 
#define S scanf
#define P printf
 
#define LEN(x) ((int)x.length())
#define SZ(x) ((int)x.size())
#define ALL(x) x.begin(), x.end()
#define MP(x,y) make_pair(x,y)
#define PB(x) push_back(x)
#define INF 1000000000
 
typedef long long LL;
typedef pair<int,int> PII;
typedef pair<int, PII> PIII;
typedef vector<int> VI;
typedef vector<bool> VB;
typedef vector<string> VS;
 
//int d[][2]={{-1.0},{1,0},{0,-1},{0,1}};
 
 
int n;
int k;
int cost[1001][1001];
int dp[1001][1001];
 
void calcCost()
{
REP(i,n)
{
FORD(j, n-1, 0 )
{
cost[i][j] += (i-1>=0?cost[i-1][j]:0) + (j+1<n?cost[i][j+1]:0) - ((i-1>=0 && j+1<n)?cost[i-1][j+1]:0) ;
}
}
}
 
/*void calcCost()
{
REP(i,n)
{
REP(j,n)
{
if( i!=j )
{
cost[i][j] = 0;
REP(l, k )
{
if( A[l][0] >= i && A[l][1] <= j ) cost[i][j]++;
}
}
else
{
cost[i][j] = INF;
}
P("%d ", cost[i][j] );
}
puts("");
}
}*/
 
inline int dist( int i, int j )
{
//distance between point i and point j
if( i==j) return 0;
return cost[j][i];
}
 
int solve()
{
//REP(i,n) REP(j,n) dp[i][j] = INF;
//REP(i,n) dp[i][i] = 0;
FORD( i, n-1, 0 )
{
FORD(j, n-1, 0 )
{
dp[i][j] = INF;
int xk = max( i, j ) + 1;
if( xk < n )
{
dp[i][j] = min( dist(i, xk) + dp[xk][j], dist(xk, j) + dp[i][xk] );
}
else
{
dp[i][j] = dist(i, n-1) + dist(n-1, j);
}
}
}
return dp[0][0];
}
 
 
int main()
{
int x,y;
int t; S("%d", &t );
while( t-- )
{
memset(cost,0,sizeof(cost));
S("%d%d", &n, &k );
REP(i, k )
{
S("%d%d", &x, &y );
cost[y][x] += 1;
}
calcCost();
P("%d\n", solve() );
}	
return 0;
}