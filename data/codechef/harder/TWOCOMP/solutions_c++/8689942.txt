#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
using namespace std;
const int Maxn=100005,Maxm=705,inf=999999999+208;
int n,m1,m2;
int head[Maxn],next[Maxn*2],to[Maxn*2],En=0;
int bx[Maxm],by[Maxm],bj[Maxm],bz[Maxm];
int gx[Maxm],gy[Maxm],gj[Maxm],gz[Maxm];
int Q[Maxn],fa[Maxn],depth[Maxn];
int in[Maxn],ou[Maxn],top[Maxn];

void bfs() {
	static int size[Maxn],w[Maxn],ne[Maxn*2];
	int l=1,r=2;
	depth[Q[1]=1]=1;
	while (l<r) {
		int x=Q[l++];
		ne[x<<1]=x<<1|1;
		for (int k=head[x];k;k=next[k])
			if (!depth[to[k]]) {
				ne[to[k]<<1|1]=ne[x<<1];
				ne[x<<1]=to[k]<<1;
				Q[r++]=to[k];
				depth[to[k]]=depth[x]+1;
				fa[to[k]]=x;
			}
	}
	for (int p=2,tot=0;p;p=ne[p])
		if (p&1) ou[p>>1]=tot;
		else in[p>>1]=++tot;
	for (int i=n,x=Q[i];i>1;x=Q[--i]) {
		size[fa[x]]+=++size[x];
		if (size[w[fa[x]]]<size[x])
			w[fa[x]]=x;
	}
	for (int i=1,x=Q[i];i<=n;x=Q[++i]) {
		if (!top[x]) top[x]=x;
		if (w[x]) top[w[x]]=top[x];
	}
}

int Lca(int u,int v) {
	while (top[u]!=top[v])
		if (depth[top[u]]>depth[top[v]])
			u=fa[top[u]];
		else
			v=fa[top[v]];
	return depth[u]<depth[v]?u:v;
}

bool OnPath(int u,int p) {
	return in[p]<=in[u]&&ou[p]>=ou[u];
}

bool OnPath(int u,int f,int p) {
	return OnPath(u,p)&&!OnPath(fa[f],p);
}

bool cross(int i,int j) {
	if (i==2&&j==1) {
		i=2; j=1;
	}
	return OnPath(bx[i],bz[i],gx[j])||OnPath(by[i],bz[i],gx[j])||
		OnPath(bx[i],bz[i],gy[j])||OnPath(by[i],bz[i],gy[j])||
		OnPath(bx[i],bz[i],gz[j])||OnPath(by[i],bz[i],gz[j])||
		OnPath(gx[j],gz[j],bx[i])||OnPath(gy[j],gz[j],bx[i])||
		OnPath(gx[j],gz[j],by[i])||OnPath(gy[j],gz[j],by[i])||
		OnPath(gx[j],gz[j],bz[i])||OnPath(gy[j],gz[j],bz[i]);
}

namespace MinCut{
	const int Maxp=Maxm*2,Maxe=Maxm*Maxm*2;
	int head[Maxp],next[Maxe],to[Maxe],v[Maxe],En=1;
	int depth[Maxp],Q[Maxp];
	int S,T;
	
	void init(int tot) {
		T=tot+1;
	}
	
	void add(int x,int y,int z) {
		next[++En]=head[x]; head[x]=En; to[En]=y; v[En]=z;
		next[++En]=head[y]; head[y]=En; to[En]=x; v[En]=0;
	}
	
	bool bfs() {
		int l=1,r=2;
		memset(depth,0,(T+1)<<2);
		depth[Q[1]=S]=1;
		while (l<r) {
			int x=Q[l++];
			for (int k=head[x];k;k=next[k])
				if (v[k]&&!depth[to[k]])
					depth[Q[r++]=to[k]]=depth[x]+1;
		}
		return depth[T]>0;
	}
	
	int dfs(int x,int f) {
		if (x==T) return f;
		int r=f,t;
		for (int k=head[x];k;k=next[k])
			if (v[k]&&depth[to[k]]==depth[x]+1) {
				t=dfs(to[k],min(r,v[k]));
				r-=t; v[k]-=t; v[k^1]+=t;
				if (!r) break;
			}
		if (f==r) depth[x]=0;
		return f-r;
	}
	
	int work() {
		int ret=0;
		while (bfs()) ret+=dfs(S,inf);
		return ret;
	}
}

int main() {
	scanf("%d%d%d",&n,&m1,&m2);
	for (int i=1,x,y;i<n;i++) {
		scanf("%d%d",&x,&y);
		next[++En]=head[x]; head[x]=En; to[En]=y;
		next[++En]=head[y]; head[y]=En; to[En]=x;
	}
	bfs();
	for (int i=1;i<=m1;i++) {
		scanf("%d%d%d",bx+i,by+i,bj+i);
		bz[i]=Lca(bx[i],by[i]);
	}
	for (int i=1;i<=m2;i++) {
		scanf("%d%d%d",gx+i,gy+i,gj+i);
		gz[i]=Lca(gx[i],gy[i]);
	}
	int ans=0;
	MinCut::init(m1+m2);
	for (int i=1;i<=m1;i++) {
		MinCut::add(MinCut::S,i,bj[i]);
		ans+=bj[i];
	}
	for (int i=1;i<=m1;i++)
		for (int j=1;j<=m2;j++)
			if (cross(i,j))
				MinCut::add(i,m1+j,inf);
	for (int i=1;i<=m2;i++) {
		MinCut::add(m1+i,MinCut::T,gj[i]);
		ans+=gj[i];
	}
	ans-=MinCut::work();
	printf("%d\n",ans);
	return 0;
}