#include <iostream>
#include <fstream>
#include <iomanip>
#include <sstream>

#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <vector>
#include <string>
#include <deque>
#include <bitset>
#include <algorithm>
#include <utility>

#include <functional>
#include <limits>
#include <numeric>
#include <complex>

#include <cassert>
#include <cmath>
#include <memory.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

using namespace std;

template<typename X> inline X abs(const X& a) { return (a < 0 ? -a : a); }
template<typename X> inline X sqr(const X& a) { return (a * a); }

typedef long long li;
typedef long double ld;
typedef pair<int,int> pt;
typedef pair<ld, ld> ptd;
typedef unsigned long long uli;

#define forn(i, n) for(int i = 0; i < int(n); i++)
#define fore(i, a, b) for(int i = int(a); i <= int(b); i++)
#define ford(i, n) for(int i = int(n - 1); i >= 0; i--)
#define foreach(it, a) for(__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)

#define pb push_back
#define mp make_pair
#define mset(a, val) memset(a, val, sizeof (a))
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define ft first
#define sc second
#define sz(a) int((a).size())
#define NMAX 100005
#define MMAX 1500
#define LN 20
#define gc getchar_unlocked
const int INF = int(1e9);
const li INF64 = li(INF) * li(INF);
const ld EPS = 1e-9;
const ld PI = ld(3.1415926535897932384626433832795);
int par[LN][NMAX];
int depth[NMAX];
int lca[MMAX];
int n, x, y;
vector<int> G[NMAX];
int fe[MMAX], fs[MMAX], ss[MMAX], se[MMAX], fj[MMAX], sj[MMAX];
int scan_f() {
  char c = gc();
  while(c<'0' || c>'9') c = gc();
  int ret = 0;
  while(c>='0' && c<='9') {
    ret = (ret<<3) +(ret<<1) + c - 48;
    c = gc();
  }
  return ret;
}
void dfs(int cur, int prev, int _depth)
{
     depth[cur] = _depth;
     par[0][cur] = prev;
     forn (i, sz(G[cur])) {
          if (G[cur][i] == prev) continue;
          dfs(G[cur][i], cur, _depth + 1);
     }
}
typedef pair<int,int> PII;
typedef vector<int> VI;

// Adjacency list implementation of FIFO push relabel maximum flow
// with the gap relabeling heuristic.  This implementation is
// significantly faster than straight Ford-Fulkerson.  It solves
// random problems with 10000 vertices and 1000000 edges in a few
// seconds, though it is possible to construct test cases that
// achieve the worst-case.
//
// Running time:
//     O(|V|^3)
//
// INPUT:
//     - graph, constructed using AddEdge()
//     - source
//     - sink
//
// OUTPUT:
//     - maximum flow value
//     - To obtain the actual flow values, look at all edges with
//       capacity > 0 (zero capacity edges are residual edges).


struct Edge {
  int from, to, cap, flow, index;
  Edge(int from, int to, int cap, int flow, int index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};

struct PushRelabel {
  int N;
  vector<vector<Edge> > G;
  vector<li> excess;
  vector<int> dist, active, count;
  queue<int> Q;

  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}

  void AddEdge(int from, int to, int cap) {
    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
    if (from == to) G[from].back().index++;
    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
  }

  void Enqueue(int v) {
    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); }
  }

  void Push(Edge &e) {
    int amt =(int)(min(excess[e.from], (li)(e.cap - e.flow)));
    if (dist[e.from] <= dist[e.to] || amt == 0) return;
    e.flow += amt;
    G[e.to][e.index].flow -= amt;
    excess[e.to] += amt;
    excess[e.from] -= amt;
    Enqueue(e.to);
  }

  void Gap(int k) {
    for (int v = 0; v < N; v++) {
      if (dist[v] < k) continue;
      count[dist[v]]--;
      dist[v] = max(dist[v], N+1);
      count[dist[v]]++;
      Enqueue(v);
    }
  }

  void Relabel(int v) {
    count[dist[v]]--;
    dist[v] = 2*N;
    for (int i = 0; i < G[v].size(); i++)
      if (G[v][i].cap - G[v][i].flow > 0)
	dist[v] = min(dist[v], dist[G[v][i].to] + 1);
    count[dist[v]]++;
    Enqueue(v);
  }

  void Discharge(int v) {
    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);
    if (excess[v] > 0) {
      if (count[dist[v]] == 1)
	Gap(dist[v]);
      else
	Relabel(v);
    }
  }

  li GetMaxFlow(int s, int t) {
    count[0] = N-1;
    count[N] = 1;
    dist[s] = N;
    active[s] = active[t] = true;
    for (int i = 0; i < G[s].size(); i++) {
      excess[s] += G[s][i].cap;
      Push(G[s][i]);
    }

    while (!Q.empty()) {
      int v = Q.front();
      Q.pop();
      active[v] = false;
      Discharge(v);
    }

    li totflow = 0;
    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;
    return totflow;
  }
};
int LCA(int u, int v) {
	if(depth[u] < depth[v]) swap(u,v);
	int diff = depth[u] - depth[v];
	for(int i=0; i<LN; i++) if( (diff>>i)&1 ) u = par[i][u];
	if(u == v) return u;
	for(int i=LN-1; i>=0; i--) if(par[i][u] != par[i][v]) {
		u = par[i][u];
		v = par[i][v];
	}
	return par[0][u];
}
bool cut(int i, int j)
{
     int l1 = lca[i];            // lca of s1, t1
     int l2 = lca[x+j];
     int l3 = LCA(l1,l2);          // lca of s2, t2
     if (l3 == l2 && (LCA(l1,ss[j]) == l1 || LCA(l1,se[j]) == l1))
          return 1;
	 else if (l3 == l1 && (LCA(l2,fs[i]) == l2 || LCA(l2,fe[i]) == l2))
          return 1;
	 else 
          return 0;
}
int main()
{
    n = scan_f();
    x = scan_f();
    y = scan_f();
    int p, q;
    int src = 0;
    int sum = 0;
    int snk = x + y + 1;
    struct PushRelabel solver(x+y+2);
    forn (i, n-1) {
         p = scan_f();
         q = scan_f();
         G[p].pb(q);
         G[q].pb(p);
    }
    mset(par, -1);
    dfs(1, -1, 0);
    
    fore (i, 1, LN-1) {
         fore (j, 1, n) {
              if (par[i-1][j] != -1) 
                 par[i][j] = par[i-1][par[i-1][j]];
         }
    }
    forn (i, x) {
         fs[i]= scan_f();
         fe[i]= scan_f();
         fj[i]= scan_f();
         sum += fj[i];
         solver.AddEdge(src, i+1, fj[i]);
         lca[i] = LCA(fs[i], fe[i]);
    }
    forn (i, y) {
         ss[i]= scan_f();
         se[i]= scan_f();
         sj[i]= scan_f();
         sum += sj[i];
         solver.AddEdge(x+i+1, snk, sj[i]);
         lca[x+i] = LCA(ss[i], se[i]);
    }
    forn (i, x) 
         forn (j, y) 
              if (cut(i, j)) 
                 solver.AddEdge(i+1, x+j+1, INF);
    sum -= solver.GetMaxFlow(src, snk);
    printf("%d", sum);
    return 0;
}
