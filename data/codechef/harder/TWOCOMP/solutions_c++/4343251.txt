#include "bits/stdc++.h"
#define lcm(a,b) (a*(b/__gcd(a,b)))
#define VI vector<int>
#define pii pair<int, int>
#define mp make_pair
#define INF 0x3f3f3f3f
using namespace std;


inline void inp(int *n)
{
    *n = 0;
    int ch = getchar_unlocked();
    int sign = 1;
    while(ch < '0' || ch > '9') 
    {
        if (ch == '-') 
            sign = -1;
        ch = getchar_unlocked();
    }
    while(ch >= '0' && ch <= '9')
        (*n) = ((*n)<<3) + ((*n)<<1) + ch - '0', ch = getchar_unlocked();
    *n = (*n)*sign;
}


/*
    Push-Relabel starts here...
*/

typedef long long LL;
 
struct Edge 
{
    int from, to, cap, flow, index;
    Edge(int from, int to, int cap, int flow, int index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};
 
struct PushRelabel 
{
    int N;
    vector<vector<Edge> > G;
    vector<LL> excess;
    vector<int> dist, active, count;
    queue<int> Q;
     
    PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}
     
    void AddEdge(int from, int to, int cap) 
    {
        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
        if (from == to) 
            G[from].back().index++;
        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
    }
     
    void Enqueue(int v) 
    {
        if (!active[v] && excess[v] > 0) 
        { 
            active[v] = true; 
            Q.push(v); 
        }
    }
     
    void Push(Edge &e) 
    {
        int amt = int(min(excess[e.from], LL(e.cap - e.flow)));
        if (dist[e.from] <= dist[e.to] || amt == 0) 
            return;
        e.flow += amt;
        G[e.to][e.index].flow -= amt;
        excess[e.to] += amt;
        excess[e.from] -= amt;
        Enqueue(e.to);
    }
    void Gap(int k) 
    {
        for (int v = 0; v < N; v++) 
        {
            if (dist[v] < k) 
                continue;
            count[dist[v]]--;
            dist[v] = max(dist[v], N+1);
            count[dist[v]]++;
            Enqueue(v);
        }
    }
     
    void Relabel(int v) 
    {
        count[dist[v]]--;
        dist[v] = 2*N;
        for (int i = 0; i < G[v].size(); i++)
            if (G[v][i].cap - G[v][i].flow > 0)
                dist[v] = min(dist[v], dist[G[v][i].to] + 1);
        count[dist[v]]++;
        Enqueue(v);
    }
     
    void Discharge(int v) 
    {
        for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) 
            Push(G[v][i]);
        if (excess[v] > 0) 
        {
            if (count[dist[v]] == 1)
                Gap(dist[v]);
            else
                Relabel(v);
        }
    }
     
    LL GetMaxFlow(int s, int t) 
    {
        count[0] = N-1;
        count[N] = 1;
        dist[s] = N;
        active[s] = active[t] = true;
        for (int i = 0; i < G[s].size(); i++) 
        {
            excess[s] += G[s][i].cap;
            Push(G[s][i]);
        }
        while (!Q.empty()) 
        {
            int v = Q.front();
            Q.pop();
            active[v] = false;
            Discharge(v);
        }
        LL totflow = 0;
        for (int i = 0; i < G[s].size(); i++) 
            totflow += G[s][i].flow;
        return totflow;
    }
};
/*
    Push-Relabel ends here...
*/


const int MAX = 1410;
const int MAXN = 100010;
int Bx[MAX], By[MAX], LCA[MAX];
int n, m1, m2;
vector< VI > graph;
int parent[MAXN], Level[MAXN], arrival_time[MAXN], dep_time[MAXN], timer = 0;
int P[MAXN][24];    //MAXN*log2(MAXN)
/*
void bfs(int v)
{
    queue< int > Q;
    Q.push(v);
    parent[v] = v;
    Level[v] = 0;
    int timer = 0;
    arrival_time[v] = ++timer;
    printf(" arrival_time[%d] is %d\n", v, arrival_time[v]);

    while(!Q.empty())
    {
        int cur = Q.front();
        Q.pop();
        visited[cur] = true;

        for (VI::iterator it = graph[cur].begin(); it != graph[cur].end(); ++it)
        {
            if(!visited[*it])
            {
                Q.push(*it);
                parent[*it] = cur;
                Level[*it] = Level[cur] + 1;
                arrival_time[*it] = ++timer;
                printf(" arrival_time[%d] is %d\n", *it, arrival_time[*it]);
            }
        }
        dep_time[cur] = ++timer;
        printf(" dep_time[%d] is %d\n", cur, dep_time[cur]);
    }
}
*/
void dfs(int src, int lev, int p)
{
  //  printf("doing dfs for %d\n",src );
    parent[src] = p;
    Level[src] = lev;
    arrival_time[src] = ++timer;
//    printf("parent of %d is %d\n",src, p );
    //printf("%d is at level %d\n",src, lev );
  //  printf(" arrival_time[%d] is %d\n", src, arrival_time[src]);

    int sz = graph[src].size();
    for (int i = 0; i < sz; ++i)
    {
        int y = graph[src][i];
        if(y == p)
            continue;
        dfs(y, lev+1, src);
    }

    dep_time[src] = ++timer;
//    printf(" dep_time[%d] is %d\n", src, dep_time[src]);
}
void pre_LCA()
{
    for (int i = 0; i < n; i++)
        for (int j = 0; 1 << j < n; j++)
            P[i][j] = -1;       // Here, P[i][j] is 2j'th ancestor of i

    for (int i = 0; i < n; ++i)
        P[i][0] = parent[i];

    for (int j = 1; 1 << j < n; ++j)
        for (int i = 0; i < n; ++i)
            if(P[i][j-1] != -1)
                P[i][j] = P[P[i][j-1]][j-1];
            
}

int query_LCA(int p, int q)
{
    if(Level[p] < Level[q])
        swap(p, q);

    int LOG = log2(Level[p]);

    for (int i = LOG; i >= 0; --i)
        if(Level[p] - (1<<i) >= Level[q])
            p = P[p][i];

    if(p == q)
        return p;

    for (int i = LOG; i >= 0; --i)
        if(P[p][i] != -1 && P[p][i] != P[q][i])
            p = P[p][i], q = P[q][i];
        
    return parent[p];
}

inline bool ancestor(int x, int y) //returns true if x is ancestor of y
{
    if(arrival_time[x] <= arrival_time[y] && dep_time[y] <= dep_time[x])
        return true;
    return false;
}

bool intersect(int u1,int v1,int p1,int u2,int v2,int p2){
    if(ancestor(p1,p2) && ancestor(p2,u1)) return true;
    if(ancestor(p1,u2) && ancestor(u2,u1)) return true;
    if(ancestor(p1,v2) && ancestor(v2,u1)) return true;

    if(ancestor(p1,p2) && ancestor(p2,v1)) return true;
    if(ancestor(p1,u2) && ancestor(u2,v1)) return true;
    if(ancestor(p1,v2) && ancestor(v2,v1)) return true;

    if(ancestor(p2,p1) && ancestor(p1,u2)) return true;
    if(ancestor(p2,u1) && ancestor(u1,u2)) return true;
    if(ancestor(p2,v1) && ancestor(v1,u2)) return true;

    if(ancestor(p2,p1) && ancestor(p1,v2)) return true;
    if(ancestor(p2,u1) && ancestor(u1,v2)) return true;
    if(ancestor(p2,v1) && ancestor(v1,v2)) return true;
    return false;

}



int main()
{
    int x, y, c;
    inp(&n);
    inp(&m1);
    inp(&m2);
    graph = vector< VI > (n);
    for (int i = 0; i < n-1; ++i)
    {
        inp(&x);
        inp(&y);
        x--, y--;
        graph[x].push_back(y);
        graph[y].push_back(x);
    }
    timer = 0;
    dfs(0, 0, 0);
    pre_LCA();

    int source = 0, sink = m1 + m2 + 1;
    long long int sums = 0;
    PushRelabel PR(sink + 1);

    for (int i = 1; i <= m1; ++i)
    {
        inp(&Bx[i]);
        inp(&By[i]);
        inp(&c);
        Bx[i]--, By[i]--;
        LCA[i] = query_LCA(Bx[i], By[i]);
        sums += c;
        PR.AddEdge(source, i, c);
    }
    for (int i = 1; i <= m2; ++i)
    {
        inp(&x);
        inp(&y);
        inp(&c);
        x--, y--;
        for (int j = 1; j <= m1; ++j)
        {
            if(intersect(x, y, query_LCA(x, y), Bx[j], By[j], LCA[j]))
                PR.AddEdge(j, i+m1, INF);
        }
        PR.AddEdge(i+m1, sink, c);
        sums += c;
    }

    printf("%lld\n", sums - PR.GetMaxFlow(source, sink));
    
    return 0;
}    