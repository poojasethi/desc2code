#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define INF	(1<<30)
#define For(i,a,b)	for(int i=a;i<=b;i++)

#define CH	(ch=getchar())
int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}

int		S,T,M1,M2;
struct	Nod{int u,v,c;};

namespace	Tree{
		#define n	100005

		int 	N,C,D,TA,TB,st[n],fa[n],siz[n],son[n],Dfn[n],Top[n],Dep[n];
		struct	Lin{int v,next;}E[n<<1];
		struct	Opt{int l,r;}A[n],B[n];

		void	Link(int u,int v){
			E[++D]=(Lin){v,st[u]};	st[u]=D;
			E[++D]=(Lin){u,st[v]};	st[v]=D;
		}

		void	DFS1(int u,int f){
			Dep[u]=Dep[f]+1;	fa[u]=f;
			for (int i=st[u],v;i;i=E[i].next)
			if	((v=E[i].v)!=f){
				DFS1(v,u);	siz[u]+=siz[v];
				if	(siz[v]>siz[son[u]])	son[u]=v;
			}	siz[u]++;
		}
		void	DFS2(int u,int f,int c){
			Dfn[u]=++C;	Top[u]=c;
			if	(son[u])	DFS2(son[u],u,c);
			for (int i=st[u],v;i;i=E[i].next)
				if	((v=E[i].v)!=son[u]&&v!=f)	DFS2(v,u,v);
		}

		bool	Cmp(Opt a,Opt b)	{return	a.l<b.l;}
		void	Work(int u,int v,int&TA,Opt*A){
			TA=0;
			for	(;Top[u]!=Top[v];){
				if	(Dep[Top[u]]>Dep[Top[v]])	swap(u,v);
				A[++TA]=(Opt){Dfn[Top[v]],Dfn[v]};	v=fa[Top[v]];
			}
			A[++TA]=(Opt){min(Dfn[u],Dfn[v]),max(Dfn[u],Dfn[v])};
			sort(A+1,A+TA+1,Cmp);
		}
		bool	Union(const Nod&a,const Nod&b){
			Work(a.u,a.v,TA,A);	Work(b.u,b.v,TB,B);
			for (int i=1,j=1;i<=TA;i++){
				for (;j<=TB&&B[j].r<A[i].l;j++);
				if	(j<=TB&&B[j].l<=A[i].r)	return	1;
			}	return	0;
		}

		void	Main(){
			N=IN();	M1=IN();M2=IN();
			For(i,2,N)	Link(IN(),IN());
			DFS1(1,0);	DFS2(1,0,1);
		}
		#undef	n
};

namespace	Flow{
		#define n	1505
		#define m	1000005

		int 	C,D,Q[n],st[n],Dis[n];
		struct	Lin{int v,f,next;}E[m];

		void	Init()	{C=M1+M2+2;S=C-1,T=C;D=1;}
		void	Link(int u,int v,int f){
			E[++D]=(Lin){v,f,st[u]};	st[u]=D;
			E[++D]=(Lin){u,0,st[v]};	st[v]=D;
		}

		bool	BFS(){
			For(i,1,C)	Dis[i]=-1;	Dis[Q[1]=S]=0;
			for (int l=0,r=1;l<r;)	{
				int u=Q[++l];
				for (int i=st[u],v;i;i=E[i].next)
				if	(E[i].f&&Dis[v=E[i].v]==-1){
					Dis[Q[++r]=v]=Dis[u]+1;
					if	(v==T)	return	1;
				}
			}	return	0;
		}
		int		DFS(int u,int Lim){
			if	(u==T)	return	Lim;	int ret=0;
			for (int i=st[u],v;i;i=E[i].next)
			if	(E[i].f&&Dis[u]+1==Dis[v=E[i].v]){
				int t=DFS(v,min(E[i].f,Lim-ret));
				if	(t)	{
					E[i].f-=t;	E[i^1].f+=t;ret+=t;
					if	(ret==Lim)	break;
				}	else	Dis[v]=-1;
			}	return	ret;
		}
		int		Main(){
			int ret=0;
			for	(;BFS();)	ret+=DFS(S,INF);
			return	ret;
		}
		#undef	n
		#undef	m
};

#define n	705
int		Sum;
Nod		A[n],B[n];

int		main(){
		Tree::Main();
		For(i,1,M1)	A[i]=(Nod){IN(),IN(),IN()},Sum+=A[i].c;
		For(i,1,M2)	B[i]=(Nod){IN(),IN(),IN()},Sum+=B[i].c;

		Flow::Init();
		For(i,1,M1)	Flow::Link(S,i,A[i].c);
		For(i,1,M2)	Flow::Link(M1+i,T,B[i].c);

		For(i,1,M1)	For(j,1,M2)
			if	(Tree::Union(A[i],B[j]))	Flow::Link(i,M1+j,INF);
		printf("%d\n",Sum-Flow::Main());
}