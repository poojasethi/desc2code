#include <bits/stdc++.h>
#define N 100005
using namespace std;

vector<int> adj[N];
int parent[N] , dp[N][18] , n;

void build(){
    for(int j = 0; 1<<j < n; ++j)
        for(int i = 0; i < n; ++i)
            dp[i][j] = -1;

    for(int i = 0; i < n; ++i)
        dp[i][0] = parent[i];
    for(int j = 1; 1<<j < n; ++j)
        for(int i = 0; i < n; ++i)
            if(dp[i][j-1]!=-1)
            dp[i][j] = dp[dp[i][j-1]][j-1];
}

int level[N];
int lca(int x,int y){
    if(level[x] < level[y]) swap(x,y);

    int rep = 1;
    for(;1<<rep<=level[x];rep++);
    rep--;

    for(int i = rep; i >= 0; i--)
        if(level[x] - (1<<i) >= level[y])
        x = dp[x][i];
    if(x == y) return x;

    for(int i = rep; i >= 0; i--)
        if(dp[x][i] != -1 && dp[x][i] != dp[y][i])
        x = dp[x][i] , y = dp[y][i];
    return parent[x];
}

bool vis[N];
void dfs(int u){
    vis[u] = 1;
    for(int j = 0; j < (int)adj[u].size(); ++j)
    {   int where = adj[u][j];
        if(!vis[where])
        {   parent[where] = u;
            level[where] = 1 + level[u];
            dfs(where);
        }
    }
}

const long long INF = 1000000000000000LL;

class MaximumFlow {
	int s, f;
public:
	struct edge {
		int u, v;
		long long capacity, flow;
		edge() { u = v = capacity = flow = 0;}
		edge(int u_, int v_, long long capacity_, long long flow_) :
		  u(u_), v(v_), capacity(capacity_), flow(flow_) {}
	};

	vector <edge> edges;
	vector <vector <int> > graph;
	vector <int> ptr, level;
	queue <int> q;
	int n;

	MaximumFlow() {}

	MaximumFlow(int number) {
		n = number;
		graph.resize(n);
		ptr.assign(n, 0);
		level.resize(n);
	}

	void addEdge(int u, int v, long long capacity) {
		int sz = (int)(edges.size());
		edges.push_back(edge(u, v, capacity, 0));
		edges.push_back(edge(v, u, 0, 0));
		graph[u].push_back(sz);
		graph[v].push_back(sz + 1);
	}

	void updateLevels() {
		level.assign(n, -1);
		q.push(s);
		level[s] = 0;
		while (!q.empty()) {
			int topq = q.front();
			q.pop();
			for (int index = 0; index < graph[topq].size(); ++index) {
				int i = graph[topq][index];
				int to = edges[i].v;
				if (edges[i].capacity - edges[i].flow == 0) {
					continue;
				}
				if (level[to] == -1) {
					level[to] = level[topq] + 1;
					q.push(to);
				}
			}
		}
	}

	long long pushFlow(int v, long long flow) {
		if (v == f || flow == 0) {
			return flow;
		}
		for (; ptr[v] < graph[v].size(); ++ptr[v]) {
			int index = graph[v][ptr[v]];
			int to = edges[index].v;
			if (level[v] + 1 == level[to]) {
				int pushed = pushFlow(to, min(flow, edges[index].capacity - edges[index].flow));
				if (pushed > 0) {
					edges[index].flow += pushed;
					edges[index ^ 1].flow -= pushed;
					return pushed;
				}
			}
		}
		return 0;
	}

	long long dinicFlow(int start, int finish) {
		s = start, f = finish;
		long long result = 0;
		while (true) {
			updateLevels();
			if (level[f] == -1) {
				break;
			}
			while (true) {
				long long pushed = pushFlow(start, INF);
				if (pushed == 0) {
					break;
				}
				result += pushed;
			}
			ptr.assign(n, 0);
		}
		return result;
	}
};


int AX[777] , AY[777] , AW[777] , BX[777] , BY[777] , BW[777];
int main(){

  //  freopen("in.c","r",stdin);
    int team01 , team02 , x , y ;
    scanf("%d %d %d",&n,&team01,&team02);

    for(int i = 1; i < n; ++i)
    {   scanf("%d %d",&x,&y); x--; y--;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }

    parent[0] = -1;
    dfs(0);
    build();

    for(int i = 0; i < team01; ++i)
       {    scanf("%d %d %d",&AX[i],&AY[i],&AW[i]); AX[i]--; AY[i]--; }
    for(int i = 0; i < team02; ++i)
       {    scanf("%d %d %d",&BX[i],&BY[i],&BW[i]); BX[i]--; BY[i]--; }


    n = team01 + team02 + 2;
    MaximumFlow dinic(n);
    int source = n - 2, sink = source + 1;
    for(int a = 0; a < team01; ++a)
        for(int b = 0; b < team02; ++b){
            int p1 = lca(AX[a],AY[a]);
            int p2 = lca(BX[b],BY[b]);

                if( (lca(p1,BX[b]) == p1 || lca(p1,BY[b]) == p1)
                   && (lca(p2,AX[a]) == p2 || lca(p2,AY[a]) == p2) )
                dinic.addEdge(a,b+team01,1<<30);
        }

    for(int i = 0; i < team01; ++i)
        dinic.addEdge(source,i,AW[i]);
    for(int i = 0; i < team02; ++i)
        dinic.addEdge(i + team01,sink,BW[i]);

    int tot = 0;
    for(int i = 0; i < team01; ++i) tot += AW[i];
    for(int i = 0; i < team02; ++i) tot += BW[i];

    printf("%d\n",tot - dinic.dinicFlow(source,sink));

    return 0;
}

