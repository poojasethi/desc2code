#include <bits/stdc++.h>
#define mp make_pair
#define pb push_back
// #define AIN(a,b,c) assert(a >= b && a < c)
using namespace std;
const int maxn = 1000, inf = 1e9;
int n, a, b, A[maxn][3], B[maxn][3];

namespace LCA{
	const int maxn = (int)1e5+5, lg = 17;
	int P[maxn][lg], D[maxn], S[maxn], I[maxn], O[maxn], timer;
	vector<int> e[maxn];
	void init(){
		for(int i=0;i<maxn;i++) e[i].clear();
		memset(P,-1,sizeof P); memset(D,0,sizeof D);
		memset(I,0,sizeof I); memset(O,0,sizeof O);
		timer = 0;
	}
	void dfs(int u, int p){
		I[u] = timer++;
		P[u][0] = p;
		if(p == -1) D[u] = 0;
		else D[u] = D[p]+1;
		for(int i=0;i<e[u].size();i++){
			int v = e[u][i];
			if(v == p) continue;
			dfs(v,u);
		}
		O[u] = timer++;
	}
	void lca_table(){
		// assert(timer == 2*n);
		for(int j=1;j<lg;j++){
			for(int i=0;i<n;i++){
				if(P[i][j-1] == -1) P[i][j] = -1;
				else P[i][j] = P[P[i][j-1]][j-1];
			}
		}
	}
	int parent(int u, int h){
		for(int i=lg-1;i>=0;i--)
			if(u!= -1 && h >= (1<<i)){
				u = P[u][i]; h -= (1<<i);
			}
		return u;
	}
	int lca(int u, int v){
		if(D[u] > D[v]) swap(u,v);
		v = parent(v,D[v]-D[u]);
		if(u == v) return u;
		for(int i=lg-1;i>=0;i--)
			if(P[u][i] != -1 && P[u][i] != P[v][i]){
				u = P[u][i]; v = P[v][i];
			}
		return P[u][0];
	}
}

namespace MaxFlow{
	// the maximum number of vertices
	#define NN 2005

	// adjacency matrix (fill this up)
	// If you fill adj[][] yourself, make sure to include both u->v and v->u.
	int cap[NN][NN], deg[NN], adj[NN][NN];

	// BFS stuff
	int q[NN], prv[NN];
	void init(){
		memset(cap,0,sizeof cap);
	}
	int dinic( int n, int s, int t ){	
		 // init the adjacency list adj[][] from cap[][]
	    memset( deg, 0, sizeof( deg ) );
	    for( int u = 0; u < n; u++ )
	        for( int v = 0; v < n; v++ ) if( cap[u][v] || cap[v][u] )
	            adj[u][deg[u]++] = v;

	    int flow = 0;

	    while(true){
	        // find an augmenting path
	        memset( prv, -1, sizeof( prv ) );
	        int qf = 0, qb = 0;
	        prv[q[qb++] = s] = -2;
	        while( qb > qf && prv[t] == -1 )
	            for( int u = q[qf++], i = 0, v; i < deg[u]; i++ )
	                if( prv[v = adj[u][i]] == -1 && cap[u][v] )
	                    prv[q[qb++] = v] = u;

	        // see if we're done
	        if( prv[t] == -1 ) break;

	        // try finding more paths
	        for( int z = 0; z < n; z++ ) if( cap[z][t] && prv[z] != -1 ){
	            int bot = cap[z][t];
	            for( int v = z, u = prv[v]; u >= 0; v = u, u = prv[v] )
	                bot = min(bot, cap[u][v]);
	            if( !bot ) continue;

	            cap[z][t] -= bot;
	            cap[t][z] += bot;
	            for( int v = z, u = prv[v]; u >= 0; v = u, u = prv[v] )
	            {
	                cap[u][v] -= bot;
	                cap[v][u] += bot;
	            }
	            flow += bot;
	        }
	    }

	    return flow;
	}
}

bool is_parent(int u, int v){
	return LCA::I[u] >= LCA::I[v] && LCA::O[u] <= LCA::O[v];
}

bool on_path(int u1, int v1, int l1, int u2, int v2, int l2){
	if(is_parent(u1,u2) && is_parent(u2,l1)) return 1;
	if(is_parent(u1,v2) && is_parent(v2,l1)) return 1;
	if(is_parent(u1,l2) && is_parent(l2,l1)) return 1;
	
	if(is_parent(v1,u2) && is_parent(u2,l1)) return 1;
	if(is_parent(v1,v2) && is_parent(v2,l1)) return 1;
	if(is_parent(v1,l2) && is_parent(l2,l1)) return 1;

	if(is_parent(u2,u1) && is_parent(u1,l2)) return 1;
	if(is_parent(u2,v1) && is_parent(v1,l2)) return 1;
	if(is_parent(u2,l1) && is_parent(l1,l2)) return 1;

	if(is_parent(v2,u1) && is_parent(u1,l2)) return 1;
	if(is_parent(v2,v1) && is_parent(v1,l2)) return 1;
	if(is_parent(v2,l1) && is_parent(l1,l2)) return 1;

	return 0;
}

int main(){
	ios_base::sync_with_stdio(0); cin.tie(0);
	LCA::init(); MaxFlow::init();
	cin >> n >> a >> b;
	for(int i=0;i<n-1;i++){
		int u,v; cin >> u >> v;
		u--; v--;
		LCA::e[u].pb(v); LCA::e[v].pb(u);
	}
	LCA::dfs(0,-1);
	LCA::lca_table();
	int total = 0;
	for(int i=0;i<a;i++){
		int x;
		cin >> A[i][0] >> A[i][1] >> x;
		A[i][0]--; A[i][1]--; A[i][2] = LCA::lca(A[i][0], A[i][1]);
		// assert(is_parent(A[i][0], A[i][2]));
		// assert(is_parent(A[i][1], A[i][2]));
 		total += x; MaxFlow::cap[0][i+1] = x;
	}
	for(int i=0;i<b;i++){
		int x;
		cin >> B[i][0] >> B[i][1] >> x;
		B[i][0]--; B[i][1]--; B[i][2] = LCA::lca(B[i][0], B[i][1]);
		// assert(is_parent(B[i][0], B[i][2]));
		// assert(is_parent(B[i][1], B[i][2]));
		total += x; MaxFlow::cap[a+i+1][a+b+1] = x;
	}
	for(int i=0;i<a;i++)
		for(int j=0;j<b;j++){
			if(on_path(A[i][0], A[i][1], A[i][2], B[j][0], B[j][1], B[j][2])) 
				MaxFlow::cap[i+1][a+j+1] = inf;
		}
	int flow = MaxFlow::dinic(a+b+2,0,a+b+1);
	total -= flow;
	// assert(total >= 0);
	cout << total << "\n";
	return 0;
}