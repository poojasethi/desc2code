#include "cstdio"
#include "iostream"
#include "algorithm"
#include "cmath"
#include "cstring"
#include "time.h"
#include "cstdlib"
#include "vector"
#include "queue"
#include "set"
#include "map"
#include "bitset"
#define runtime() ((double)clock() / CLOCKS_PER_SEC)
#define rep(i, n) for(int i=0; i<n; i++)
#define repp(i, a, b) for(int i=a; i<a+b; i++)
using namespace std;
#define SZ size()
#define PB push_back
#define MK make_pair
#define X first
#define Y second
#define ll long long
#define ITR iterator
#define LB lower_bound
#define UB upper_bound
#define PII pair<int, int>

int getint(){
    int s = 0, o = 1;
    char c;
    for(c = getchar(); c<'0'||c>'9';c = getchar()) if(c=='-') o = -1;
    for(;c>='0'&&c<='9'; c = getchar()) s *=10, s+=c-'0';
    return s*o;
}

//DINIC_BEGIN
const int maxV = 700*2 + 10, maxE = (700 * 700 + 700 * 2) * 2 + 10, oo = (int)2e9;
struct DINIC{

int hd[maxV], d[maxV], S, T, N, V, vis[maxV], q[maxV], cur[maxV];
int e[maxE], c[maxE], nt[maxE], tot, flow; 
int aug(int u, int lim){
    if(u==T) return lim;
    int now = lim;
    for(int &p = cur[u]; p; p = nt[p]) if(c[p]>0 && d[u] == d[e[p]] + 1){
        int &v = e[p];
        int push = aug(v, min(now, c[p]));
        c[p] -= push;
        c[p^1] += push;
        now -= push;
        if(!now) break;
    }
    if(lim==now) d[u] = -1;//DINIC 有木有 10倍的效率啊 
    return lim - now;
}
bool label(){
    q[0] = T;
    static int l, r;
    l = 0, r = 1;
    vis[T] = ++V; 
    while(l<r){
        int u = q[l++];
        for(int p = hd[u]; p; p = nt[p]) if(c[p^1]>0){
            int v = e[p];
            if(vis[v]<V) d[v] = d[u] + 1, vis[v] = V, q[r++] = v;
        }
    }
    return vis[S]==V;
}
void add(int u, int v, int cc){
    e[++tot] = v, c[tot] = cc, nt[tot] = hd[u], hd[u] = tot;
    e[++tot] = u, c[tot] = 0, nt[tot] = hd[v], hd[v] = tot;
}
void pre(int _S, int _T, int _N){
    S = _S, T = _T, N = _N;
    tot = 1;
    V = 0;
    for(int i=1; i<=N; i++) hd[i] = 0;
}
void run(){
    flow = 0;
    while(label()){
        for(int i=1; i<=N; i++) cur[i] = hd[i];
        flow += aug(S, oo);
    }
}

}F;
//DINIC_END

const int maxn = 100010;
int n,m1,m2,x,y,z,timer;

struct node{
    int x,y,z;
}a[maxn];

int f[maxn][18], d[maxn], tin[maxn], tout[maxn];
std::vector<int> e[maxn];
void dfs(int u, int F){
    tin[u] = timer++; 
    d[u] = d[F] + 1;
    f[u][0] = F;
    rep(i,17) f[u][i+1] = f[f[u][i]][i];
    rep(i, e[u].SZ) if(e[u][i]!=F){
        int v = e[u][i];
        dfs(v, u);
    }
    tout[u] = timer++;
}
int lca(int u,int v){
    if(d[u]<d[v]) swap(u,v);
    for(int i=17; i>=0; i--) if(d[f[u][i]]>=d[v]) u = f[u][i];
    if(u==v) return u;
    for(int i=17; i>=0; i--) if(f[u][i]!=f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
}

bool is_parent(int par, int son){
    return tin[par] <= tin[son] && tout[par] >= tout[son];
}
bool between(int a, int b, int c){
    return is_parent(a,b) && is_parent(b,c);
}
bool inter(int a, int b, int c, int d){
    return between(a,c,b) || between(a,d,b) || between(c,a,d) || between(c,b,d);
}

int main(int argc, char const *argv[])
{
    n = getint(), m1 = getint(), m2 = getint();
    rep(i,n-1){
        x = getint(), y = getint();
        e[x].PB(y);
        e[y].PB(x);
    }
    timer = 1;
    dfs(1,0);
    F.pre(m1+m2+1, m1+m2+2, m1+m2+2);
    int sum = 0;
    repp(i,1,m1){
        a[i].x = getint(), a[i].y = getint(), z = getint();
        a[i].z = lca(a[i].x, a[i].y);
        F.add(F.S, i, z);
        sum += z;
    }
    for(int i=m1+1; i<=m1+m2; i++){
        a[i].x = getint(), a[i].y = getint(), z = getint();
        a[i].z = lca(a[i].x, a[i].y);
        F.add(i, F.T, z);
        sum += z;
    }
    repp(i,1,m1)for(int j=m1+1; j<=m1+m2; j++){
        if(inter(a[i].z, a[i].x, a[j].z, a[j].x) || 
            inter(a[i].z, a[i].x, a[j].z, a[j].y) || 
            inter(a[i].z, a[i].y, a[j].z, a[j].x) || 
            inter(a[i].z, a[i].y, a[j].z, a[j].y) )
                F.add(i, j, oo);
    }
    F.run();
    printf("%d\n", sum - F.flow);
    return 0;
}