#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int,int> pii;

/*** TEMPLATE CODE ENDS HERE */

const int maxn = 100100;
const int log_n = 19;
VI G[maxn];
int D[maxn];
int up[maxn][log_n];
int tin[maxn], tout[maxn];

const int MAXN = 700 + 700 + 7;

struct route {
    int a, b, c, cost;
    route( int a = 0, int b = 0, int c = 0, int cost = 0 ) : a( a ), b( b ), c( c ), cost( cost ) {};
};

route r1[ 777 ], r2[ 777 ];

void dfs( int v, int prev ) {
    static int timer = 0;
    D[v] = D[prev] + 1;
    up[v][0] = prev;
    for ( int i = 1; i < 18; i++ ) up[v][i] = up[ up[v][i - 1] ][i - 1];
    tin[v] = ++timer;
    for ( int i = 0; i < (int)G[v].size(); i++ ) {
        int next = G[v][i];
        if ( next == prev ) continue;
        dfs( next, v );
    }
    tout[v] = timer;
}

bool is_parent( int parent, int child ) {
    return ( tin[ parent ] <= tin[ child ] && tout[ child ] <= tout[ parent ] );
}

int lca( int u, int v ) {
    if ( is_parent( u, v ) ) return u;
    if ( is_parent( v, u ) ) return v;
    for ( int i = log_n-1; i >= 0; i-- )
        if ( !is_parent( up[u][i], v ) )
            u = up[u][i];
    return up[u][0];
}

bool between( int a, int b, int c ) {
    return is_parent( a, b ) && is_parent( b, c );
}

bool intersect( int a, int b, int c, int d ) {
    return between( a, c, b ) || between( a, d, b ) || between( c, a, d ) || between( c, b, d );
}

bool intersect(int a, int b, int lca_ab, int c, int d, int lca_cd) {
    if ( intersect( lca_ab, a, lca_cd, c ) ) return true;
    if ( intersect( lca_ab, a, lca_cd, d ) ) return true;
    if ( intersect( lca_ab, b, lca_cd, c ) ) return true;
    if ( intersect( lca_ab, b, lca_cd, d ) ) return true;
    return false;
}

int N;
int S, T;

//const long long INFe = 90000000000LL;
//long long f[MAXN][MAXN];
//long long c[MAXN][MAXN];
//int h[MAXN];
//int ind[MAXN];
//long long e[MAXN];
//
//void Push(int v, int u) {
//    long long add = min(e[v], c[v][u] - f[v][u]);
//    e[v] -= add;
//    e[u] += add;
//    f[v][u] += add;
//    f[u][v] -= add;
//}
//
//void Lift(int v) {
//    int m = N + 2;
//    for (int u = 0; u < N; ++u) {
//        if (c[v][u] - f[v][u] > 0)
//            m = min(m, h[u]);
//    }
//    h[v] = m + 1;
//}
//
//void Discharge(int v) {
//    while (e[v] > 0) {
//        if (ind[v] >= N) {
//            Lift(v);
//            ind[v] = 0;
//        }
//        else {
//            int u = ind[v];
//            if (h[u] == h[v] - 1 && c[v][u] - f[v][u] > 0)
//                Push(v, u);
//            ++ind[v];
//        }
//    }
//}
//
//void max_flow() {
//    deque<int> L;
//    h[T] = 0;
//    h[S] = N;
//    for (int v = 0; v < N; ++v) {
//        f[S][v] = c[S][v];
//        f[v][S] = -f[S][v];
//        e[v] += c[S][v];
//    }
//    for (int v = 0; v < N; ++v) {
//        if (v != S && v != T)
//            L.push_back(v);
//    }
//    
//    deque<int>::iterator it = L.begin();
//    
//    while (it != L.end()) {
//        int u = *it;
//        int cur_h = h[u];
//        Discharge(u);
//        if (h[u] > cur_h) {
//            L.erase(it);
//            L.push_front(u);
//            it = L.begin();
//        }
//        ++it;
//    }
//    
//}


struct Edge {
	int u, v, cap, flow;
};

int d[MAXN], ptr[MAXN], q[MAXN];
vector<Edge> edge;
vector<int> g[MAXN];

void add_edge(int u, int v, int cap) {
	Edge e1 = {u, v, cap, 0};
	Edge e2 = {v, u, 0, 0};
	g[u].push_back((int)edge.size());
	edge.push_back(e1);
	g[v].push_back((int)edge.size());
	edge.push_back(e2);
}

bool bfs(const int source, const int sink) {
	memset(d, -1, N*sizeof(d[0]));
	d[source] = 0;
    
	int qh = 0, qt = 0;
	q[qt++] = source;
    
	while(qh<qt && d[sink]==-1) {
		int u = q[qh++];
		for(size_t i = 0; i < g[u].size(); ++i) {
			int id = g[u][i];
			int v = edge[id].v;
			if(d[v]==-1 && edge[id].flow < edge[id].cap) {
				d[v] = d[u] + 1;
				q[qt++] = v;
			}
		}
	}
    
	return d[sink] != -1;
}

int dfs(const int u, const int t, const int flow) {
	if(flow==0) return 0;
	if(u==t) return flow;
	for(int &i = ptr[u]; i < g[u].size(); ++i) {
		int id = g[u][i];
		int v = edge[id].v;
		if(d[v] != d[u] + 1) continue;
		int pushed = dfs(v, t, min(flow, edge[id].cap - edge[id].flow));
		if(pushed) {
			edge[id].flow += pushed;
			edge[id^1].flow -= pushed;
			return pushed;
		}
	}
	return 0;
}

int dinic(int source, int sink) {
	int flow = 0;
	while(bfs(source, sink)) {
		CL(ptr,0);
		while(int push = dfs(source, sink, INF)) flow += push;
	}
	return flow;
}

int main() {
#ifdef LOCAL_HOST
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
#endif

    ios_base::sync_with_stdio(false);
    
    int N, M1, M2;
    cin >> N >> M1 >> M2;
    
    rep(i,N-1) {
        int x,y;
        cin >> x >> y;
        --x, --y;
        G[x].pb(y);
        G[y].pb(x);
    }

    ::N = 2 + M1 + M2;
    S = ::N-2;
    T = ::N-1;

    D[0] = 0;
    dfs(0,0);
    
    rep(i,M1) {
        cin >> r1[i].a >> r1[i].b >> r1[i].cost;
        r1[i].a --;
        r1[i].b --;
        r1[i].c = lca(r1[i].a, r1[i].b);
    }
    
    rep(i,M2) {
        cin >> r2[i].a >> r2[i].b >> r2[i].cost;
        r2[i].a --;
        r2[i].b --;
        r2[i].c = lca(r2[i].a, r2[i].b);
    }
    
//    CL(c,0);
//    CL(f,0);
    
    ll ans = 0;
    
    rep(i,M1) {
        add_edge(S, i, r1[i].cost);
//        c[S][i] = r1[i].cost;
        ans += r1[i].cost;
    }
    
    rep(i,M2) {
        add_edge(i+M1, T, r2[i].cost);
//        c[i+M1][T] = r2[i].cost;
        ans += r2[i].cost;
    }
    
    rep(i,M1) rep(j,M2) {
//        int a = r1[i].a, b = r1[i].b, lca_ab = r1[i].c;
//        int c = r2[j].a, d = r2[j].b, lca_cd = r2[j].c;
//        bool flag = false;
//        if ( !flag && intersect( lca_ab, a, lca_cd, c ) ) flag = true;
//        if ( !flag && intersect( lca_ab, a, lca_cd, d ) ) flag = true;
//        if ( !flag && intersect( lca_ab, b, lca_cd, c ) ) flag = true;
//        if ( !flag && intersect( lca_ab, b, lca_cd, d ) ) flag = true;
////        if ( !flag ) continue;
//
////        if ( !flag && intersect( r1[i].c, r1[i].a, r2[j].c, r2[j].a ) ) flag = true;
////        if ( !flag && intersect( r1[i].c, r1[i].a, r2[j].c, r2[j].b ) ) flag = true;
////        if ( !flag && intersect( r1[i].c, r1[i].b, r2[j].c, r2[j].a ) ) flag = true;
////        if ( !flag && intersect( r1[i].c, r1[i].b, r2[j].c, r2[j].b ) ) flag = true;
//        if ( !flag ) continue;
//        cout << i << " " << j << endl;
//        add_edge( i, M1 + j, INF );
        if ( intersect(r1[i].a, r1[i].b, r1[i].c, r2[j].a, r2[j].b, r2[j].c) ) {
//            cout << i << " " << j << endl;
            add_edge( i, M1 + j, INF );
//        c[i][M1+j] = INF;
        }
    }
    
//    max_flow();
//    rep(i,N) ans -= f[S][i];
    
    ans -= dinic(S, T);
    
    cout << ans << endl;

#ifdef LOCAL_HOST
    printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC);
#endif

    return 0;
}
