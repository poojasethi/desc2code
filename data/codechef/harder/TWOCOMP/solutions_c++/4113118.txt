// #includes {{{
#include <algorithm>
#include <numeric>
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <list>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>
#include <cmath>
using namespace std;
// }}}
// pre-written code {{{
#define REP(i,n) for(int i=0;i<(int)(n);++i)
#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)
#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)
#define LET(x,a) __typeof(a) x(a)
//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)
#define ALL(c) (c).begin(), (c).end()
#define MP make_pair

#define EXIST(e,s) ((s).find(e)!=(s).end())

#define RESET(a) memset((a),0,sizeof(a))
#define SET(a) memset((a),-1,sizeof(a))
#define PB push_back
#define DEC(it,command) __typeof(command) it=command

const int INF=0x3f3f3f3f;

typedef long long Int;
typedef unsigned long long uInt;
#ifdef __MINGW32__
typedef double rn;
#else
typedef long double rn;
#endif

typedef pair<int,int> pii;

/*
#ifdef MYDEBUG
#include"debug.h"
#include"print.h"
#endif
*/
// }}}

//{{{ io
FILE *file_in=stdin,*file_out=stdout;
#define fin normal_in
#define fout normal_out
//const char fname[]="";
//FILE *fin=fopen(fname,"r"),*fout=fopen(fname,"w");
#ifdef __MINGW32__
#define LLD "%I64d"
#define LLU "%I64u"
#else
#define LLD "%lld"
#define LLU "%llu"
#endif
struct NORMAL_IN{
	bool cnt;
	NORMAL_IN():cnt(true){}
	operator int() const {return cnt;}
#define endl "\n"
	NORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,"%d",&n)!=EOF;return *this;}
	NORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,"%u",&n)!=EOF;return *this;}
	NORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}
	NORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}
	NORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,"%lf",&n)!=EOF;return *this;}
	NORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,"%Lf",&n)!=EOF;return *this;}
	NORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,"%s",c)!=EOF;return *this;}
	NORMAL_IN& operator>>(string &s){
		s.clear();
		for(bool r=false;;){
			const char c=getchar();
			if(c==EOF){ cnt=false; break;}
			const int t=isspace(c);
			if(!r and !t)r=true;
			if(r){
				if(!t)s.push_back(c);
				else break;
			}
		}
		return *this;
	}
	template<class T>
		NORMAL_IN& operator>>(vector<T> &v){
			int n;fscanf(file_in,"%d",&n);
			REP(i,n){
				T t;*this>>t;
				v.push_back(t);
			}
		}
} normal_in;

struct NORMAL_OUT{
	NORMAL_OUT& operator<<(const int &n){fprintf(file_out,"%d",n);return *this;}
	NORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,"%u",n);return *this;}
	NORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}
	NORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}
	NORMAL_OUT& operator<<(const double &n){fprintf(file_out,"%lf",n);return *this;}
	NORMAL_OUT& operator<<(const long double &n){fprintf(file_out,"%Lf",n);return *this;}
	NORMAL_OUT& operator<<(const char c[]){fprintf(file_out,"%s",c);return *this;}
	NORMAL_OUT& operator<<(const string &s){fprintf(file_out,"%s",s.c_str());return *this;}
} normal_out;
//}}}
int N,M1,M2;

//{{{ Graph
typedef Int Weight;
struct Edge {
	int src, dst, rev;
	Weight weight;
	Edge(int src, int dst, Weight weight=1,int rev=-1) :
		src(src), dst(dst), weight(weight), rev(rev) { }
};
bool operator < (const Edge &e, const Edge &f) {
	return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!
		e.src != f.src ? e.src < f.src : e.dst < f.dst;
}
typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

typedef vector<Weight> Array;
typedef vector<Array> Matrix;

//add bi-directional edge
void addBiEdge(Graph &g,int from ,int to, Weight w=1){
	while(g.size()<max(from,to)+1)g.push_back(Edges());
	g[from].push_back(Edge(from,to,w,g[to].size()));
	g[to].push_back(Edge(to,from,w,g[from].size()-1));
}
//add directional edge
void addEdge(Graph &g,int from ,int to, Weight w=1){
	while(g.size()<from+1)g.push_back(Edges());
	g[from].push_back(Edge(from,to,w));
}
#ifdef DEBUG
#include"graph/graphviz.h"
#endif
//}}}

/*
	MaxFlow mf(Graph g,int s,int t)
	mf.result
*/
//{{{ Dinic max_flow
void addFlowEdge(Graph &g,int src,int dst,Weight cap){
	while(g.size()<max(src,dst)+1)g.push_back(Edges());
	g[src].push_back(Edge(src,dst,cap,g[dst].size()));
	g[dst].push_back(Edge(dst,src,0,g[src].size()-1));
}
void addBiFlowEdge(Graph &g,int src,int dst,Weight cap){
	while(g.size()<max(src,dst)+1)g.push_back(Edges());
	g[src].push_back(Edge(src,dst,cap,g[dst].size()));
	g[dst].push_back(Edge(dst,src,cap,g[src].size()-1));
}

struct MaxFlow{
	static const Weight FLOW_INF=2e+14;
	const Graph &g;
	vector<vector<Weight> > res;
	const int n;
	vector<int> level,iter;
	Weight result;
	MaxFlow(Graph &g,int s,int t):g(g),n(g.size()){calc(s,t);}
	void bfs(vector<int> &level,int s){
		const int n=g.size();
		level.assign(n,-1);
		queue<int> q;
		level[s]=0;
		q.push(s);
		while(not q.empty()){
			int v=q.front();q.pop();
			for(int i=0;i<(int)g[v].size();i++){
				const Edge &e=g[v][i];
				if(res[v][i]>0 and level[e.dst]<0){
					level[e.dst]=level[v]+1;q.push(e.dst);
				}
			}
		}
	}
	Weight dfs(int v, int t, Weight f){
		const int n=g.size();
		if(v==t)return f;
		for(int &i=iter[v];i<(int)g[v].size();i++){
			const Edge &e=g[v][i];
			if(res[v][i]>0 and level[v]<level[e.dst]){
				Weight d=dfs(e.dst,t,min(f,res[v][i]));
				if(d>0){
					res[v][i]-=d;
					res[e.dst][e.rev]+=d;
					return d;
				}
			}
		}
		return Weight(0);
	}
	Weight calc(int s,int t){
		res.assign(n,vector<Weight>());
		REP(i,n)REP(j,g[i].size())res[i].push_back(g[i][j].weight);
		result=0;
		for(;;){
			bfs(level,s);
			if(level[t]<0)return result;
			iter.assign(n,0);
			Weight f;
			while((f=dfs(s,t,FLOW_INF))>0)result+=f;
		}
	}
	//additional feature
	bool decreaseable(int v0,int i0){
		if(res[v0][i0]>0)return true;
		vector<bool> vis(n,false);
		decrease_dfs(v0,i0,v0,vis);
		return vis[g[v0][i0].dst];
	}
	void decrease_dfs(int v0,int i0,int v,vector<bool> &vis){
		if(vis[v])return;
		vis[v]=true;
		REP(i,g[v].size()){
			if(res[v][i]==0)continue;
			decrease_dfs(v0,i0,g[v][i].dst,vis);
		}
	}
};
//}}}

int a[710][710];
//int Blce[710],Glce[710],BGlce[710][710][2][2];
int Blev[710],Glev[710];
Graph g;
int B[710][2],Bj[710];
int G[710][2],Gj[710];

const int LOGMAXN=17, MAXN=(1<<LOGMAXN);

int L[MAXN], T[MAXN];
void set_level(const Graph &g,int u,int p=-1,int l=0){
	L[u]=l;T[u]=p;
	FOR(e,g[u])if(e->dst!=p)set_level(g,e->dst,u,l+1);
}

int P[MAXN][LOGMAXN];
void process3(int N, int T[MAXN], int P[MAXN][LOGMAXN]){
	int i, j;

	//we initialize every element in P with -1
	for (i = 0; i < N; i++)
		for (j = 0; 1 << j < N; j++)
			P[i][j] = -1;

	//the first ancestor of every node i is T[i]
	for (i = 0; i < N; i++)
		P[i][0] = T[i];

	//bottom up dynamic programing
	for (j = 1; 1 << j < N; j++)
		for (i = 0; i < N; i++)
			if (P[i][j - 1] != -1)
				P[i][j] = P[P[i][j - 1]][j - 1];
}

int query(int N, int P[MAXN][LOGMAXN], int T[MAXN], int L[MAXN], int p, int q){
	int tmp, log, i;

	//if p is situated on a higher level than q then we swap them
	if (L[p] < L[q])
		tmp = p, p = q, q = tmp;

	//we compute the value of [log(L[p)]
	for (log = 1; 1 << log <= L[p]; log++);
	log--;

	//we find the ancestor of node p situated on the same level
	//with q using the values in P
	for (i = log; i >= 0; i--)
		if (L[p] - (1 << i) >= L[q])
			p = P[p][i];

	if (p == q)
		return p;

	//we compute LCA(p, q) using the values in P
	for (i = log; i >= 0; i--)
		if (P[p][i] != -1 && P[p][i] != P[q][i])
			p = P[p][i], q = P[q][i];
	return T[p];
}

bool intersect(int i,int j){
	int t=max(Blev[i],Glev[j]);
	REP(k,2)REP(l,2){
		int u = query(N,P,T,L,B[i][k],G[j][l]);
		if(t<=u)return true;
//		int t=BGlce[i][j][k][l];
//		int lc0=L[q[t].w];
//		if(lb0<=lc0 and lg0<=lc0)return true;
	}
	return false;
}

int main(){
	int sum=0;
	fin>>N>>M1>>M2;
	g.assign(N,Edges());
	int X,Y;
	REP(i,N-1){
		fin>>X>>Y;
		X--;Y--;
		addBiEdge(g,X,Y);
	}
	set_level(g,0);
	process3(N,T,P);
	REP(i,M1)fin>>B[i][0]>>B[i][1]>>Bj[i],B[i][0]--,B[i][1]--,sum+=Bj[i];
	REP(i,M2)fin>>G[i][0]>>G[i][1]>>Gj[i],G[i][0]--,G[i][1]--,sum+=Gj[i];
	REP(i,M1)Blev[i]=query(N,P,T,L,B[i][0],B[i][1]);
	REP(i,M2)Glev[i]=query(N,P,T,L,G[i][0],G[i][1]);
	memset(a,0,sizeof(a));
	REP(i,M1)REP(j,M2)if(intersect(i,j))a[i][j]=1;

	Graph h(M1+M2+2);
	int s=M1+M2,t=M1+M2+1;
	REP(i,M1)addFlowEdge(h,s,i,Bj[i]);
	REP(i,M2)addFlowEdge(h,i+M1,t,Gj[i]);
	REP(i,M1)REP(j,M2)if(a[i][j]==1)addFlowEdge(h,i,j+M1,2000000000ll);
	MaxFlow mf(h,s,t);
	fout<<sum-mf.result<<endl;
//	assert(false);
}