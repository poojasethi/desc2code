#include<cstdio>
#include<iostream>
#include<list>
#include<algorithm>
#include<vector>
#include<queue>
#include<climits>
using namespace std;
#define max1 100005
#define logmax1 20
#define inf INT_MAX
int n,m1,cnt,m2,P[max1][logmax1],visited[max1],L[max1],bx[710],by[710],LCA[710],N,par[1405],D[max1],F[max1],cap[1405][1405];
list<int> *adj;
vector<int> g[1500];
void dfs(int start,int prev,int level)
{
     L[start] = level;
     P[start][0]=prev;
     visited[start]=1;
     D[start]=++cnt;                                   //discovery time
     list<int> ::iterator it1;
     for(it1=adj[start].begin();it1!=adj[start].end();it1++)
     {
         if(!visited[*it1])
         dfs(*it1,start,level+1);
     }
     F[start]=++cnt;                                 //Finish time
}
bool anc(int u,int v)
{
    if(D[u]<=D[v] && F[v]<=F[u]) return true;
    return false;
}
bool intersect(int u1,int v1,int p1,int u2,int v2,int p2)
{
    if(anc(p1,p2) && anc(p2,u1)) return true;
    if(anc(p1,u2) && anc(u2,u1)) return true;
    if(anc(p1,v2) && anc(v2,u1)) return true;

    if(anc(p1,p2) && anc(p2,v1)) return true;
    if(anc(p1,u2) && anc(u2,v1)) return true;
    if(anc(p1,v2) && anc(v2,v1)) return true;

    if(anc(p2,p1) && anc(p1,u2)) return true;
    if(anc(p2,u1) && anc(u1,u2)) return true;
    if(anc(p2,v1) && anc(v1,u2)) return true;

    if(anc(p2,p1) && anc(p1,v2)) return true;
    if(anc(p2,u1) && anc(u1,v2)) return true;
    if(anc(p2,v1) && anc(v1,v2)) return true;
    return false;

}
int lca(int p,int q)
{
    if(L[p]<L[q])
    swap(p,q);
    int lg;
    for( lg=1;(1<<lg)<=L[p];lg++);
    lg--;
     for (int i = lg; i >= 0; i--)
          if (L[p] - (1 << i) >= L[q])
              p = P[p][i];
       if (p == q)
          return p;
     for (int i = lg; i >= 0; i--)
          if (P[p][i] != -1 && P[p][i] != P[q][i])
              p = P[p][i], q = P[q][i];
   
      return P[p][0];
}

void add_edge(int a,int b,int c)
{
     g[a].push_back(b);
     g[b].push_back(a);
     cap[a][b]=cap[a][b]+c;
}
bool bfs(int s,int t)
{
     queue<int> q1;
     q1.push(s);
     for(int i=0;i<N;i++)
     par[i]=-1;
     par[s]=-2;
     while(!q1.empty())
     {
         int a = q1.front();
         q1.pop();
         vector<int>::iterator it1;
         for(it1=g[a].begin();it1!=g[a].end();it1++)
         {
            if(par[*it1]==-1 && cap[a][*it1]>0)
            {
               par[*it1]=a;
               q1.push(*it1);
            }
         }
     }
     if(par[t]==-1)
     {
	 return false;}
     else {
     return true;}
}

int dinic (int s,int t)
{
    int flow=0,u,v,i;
    while(bfs(s,t))               //check if the path exist,bfs will fill array par[]  for each node,if unable to reach the end point it will terminate  
    {
         for(i=0;i<N;i++)
         {
              if(par[i]<0 || cap[i][t]<=0)
              continue;
              int f = cap[i][t];
              for(v=i,u=par[v];v!=s;v=u,u=par[v])
              f=min(f,cap[u][v]);                                 // we find the minimum flow on the path
              for(v=i,u=par[v];v!=s;v=u,u=par[v])
              {
                 cap[u][v]=cap[u][v]-f;                          //residual graph 
                 cap[v][u]=cap[v][u]+f;                          //in same direction decrement ,in opp direction increment
              }
              cap[i][t]-=f;
              cap[t][i]+=f;
              flow =flow+f;                                       //increment value of f
         }
    }
    return flow;
}
main()
{
      scanf("%d  %d %d",&n,&m1,&m2);
      int a,b,c;
      adj = new list<int>[n];
      for(int i=0;i<n-1;i++)
      {
              scanf("%d %d",&a,&b);
              adj[a-1].push_back(b-1);
              adj[b-1].push_back(a-1);
      }
      for(int i=0;i<max1;i++)
         for(int j=0;j<20;j++)
            P[i][j]=-1;
            
      dfs(0,-1,1);
      
      for(int j=1;(1<<j)<n;j++)                       //table for computing least common ancestor
         for(int i=0;i<n;i++)
            if(P[i][j-1]!=-1)
            P[i][j] = P[P[i][j-1]][j-1];
      int sum=0;
      int source = m1+m2;
      int sink = m1+m2+1;
      N=sink+1;
      for(int i=0;i<m1;i++)
      {
              scanf("%d %d %d",&bx[i],&by[i],&c);
              bx[i]--;
              by[i]--;
              LCA[i]=lca(bx[i],by[i]);
              add_edge(source,i,c);
              sum=sum+c;
      }
      for(int i=0;i<m2;i++)
      {
            scanf("%d %d %d",&a,&b,&c);
            a--;
            b--;
            for(int j=0;j<m1;j++)
            {
                if(intersect(a,b,lca(a,b),bx[j],by[j],LCA[j]))
                add_edge(j,i+m1,inf);
            }  
            add_edge(i+m1,sink,c);
            sum=sum+c;
      }
      int ans = sum-dinic(source,sink);
      printf("%d\n",ans);
      return 0;
}
