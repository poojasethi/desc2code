#include <bits/stdc++.h>
#define NN 100005
using namespace std;

vector<int> adj[NN];
int parent[NN] , dp[NN][18] , n;

void build(){
    for(int j = 0; 1<<j < n; ++j)
        for(int i = 0; i < n; ++i)
            dp[i][j] = -1;

    for(int i = 0; i < n; ++i)
        dp[i][0] = parent[i];
    for(int j = 1; 1<<j < n; ++j)
        for(int i = 0; i < n; ++i)
            if(dp[i][j-1]!=-1)
            dp[i][j] = dp[dp[i][j-1]][j-1];
}

int level[NN];
int lca(int x,int y){
    if(level[x] < level[y]) swap(x,y);

    int rep = 1;
    for(;1<<rep<=level[x];rep++);
    rep--;

    for(int i = rep; i >= 0; i--)
        if(level[x] - (1<<i) >= level[y])
        x = dp[x][i];
    if(x == y) return x;

    for(int i = rep; i >= 0; i--)
        if(dp[x][i] != -1 && dp[x][i] != dp[y][i])
        x = dp[x][i] , y = dp[y][i];
    return parent[x];
}

bool vis[NN];
void dfs(int u){
    vis[u] = 1;
    for(int j = 0; j < (int)adj[u].size(); ++j)
    {   int where = adj[u][j];
        if(!vis[where])
        {   parent[where] = u;
            level[where] = 1 + level[u];
            dfs(where);
        }
    }
}

typedef long long LL;

struct Edge {
  int from, to, cap, flow, index;
  Edge(int from, int to, int cap, int flow, int index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};

struct PushRelabel {
  int N;
  vector<vector<Edge> > G;
  vector<LL> excess;
  vector<int> dist, active, count;
  queue<int> Q;

  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}

  void AddEdge(int from, int to, int cap) {
    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
    if (from == to) G[from].back().index++;
    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
  }

  void Enqueue(int v) {
    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); }
  }

  void Push(Edge &e) {
    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));
    if (dist[e.from] <= dist[e.to] || amt == 0) return;
    e.flow += amt;
    G[e.to][e.index].flow -= amt;
    excess[e.to] += amt;
    excess[e.from] -= amt;
    Enqueue(e.to);
  }

  void Gap(int k) {
    for (int v = 0; v < N; v++) {
      if (dist[v] < k) continue;
      count[dist[v]]--;
      dist[v] = max(dist[v], N+1);
      count[dist[v]]++;
      Enqueue(v);
    }
  }

  void Relabel(int v) {
    count[dist[v]]--;
    dist[v] = 2*N;
    for (int i = 0; i < G[v].size(); i++)
      if (G[v][i].cap - G[v][i].flow > 0)
	dist[v] = min(dist[v], dist[G[v][i].to] + 1);
    count[dist[v]]++;
    Enqueue(v);
  }

  void Discharge(int v) {
    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);
    if (excess[v] > 0) {
      if (count[dist[v]] == 1)
	Gap(dist[v]);
      else
	Relabel(v);
    }
  }

  LL GetMaxFlow(int s, int t) {
    count[0] = N-1;
    count[N] = 1;
    dist[s] = N;
    active[s] = active[t] = true;
    for (int i = 0; i < G[s].size(); i++) {
      excess[s] += G[s][i].cap;
      Push(G[s][i]);
    }

    while (!Q.empty()) {
      int v = Q.front();
      Q.pop();
      active[v] = false;
      Discharge(v);
    }

    LL totflow = 0;
    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;
    return totflow;
  }
};

int AX[777] , AY[777] , AW[777] , BX[777] , BY[777] , BW[777];
int main(){

   // freopen("in.c","r",stdin);
    int team01 , team02 , x , y ;
    scanf("%d %d %d",&n,&team01,&team02);

    for(int i = 1; i < n; ++i)
    {   scanf("%d %d",&x,&y); x--; y--;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }

    parent[0] = -1;
    dfs(0);
    build();

    for(int i = 0; i < team01; ++i)
       {    scanf("%d %d %d",&AX[i],&AY[i],&AW[i]); AX[i]--; AY[i]--; }
    for(int i = 0; i < team02; ++i)
       {    scanf("%d %d %d",&BX[i],&BY[i],&BW[i]); BX[i]--; BY[i]--; }


    n = team01 + team02 + 2;

    PushRelabel dinic(n);

    int source = n - 2, sink = source + 1;
    for(int a = 0; a < team01; ++a)
        for(int b = 0; b < team02; ++b){
            int p1 = lca(AX[a],AY[a]);
            int p2 = lca(BX[b],BY[b]);

                if( (lca(p1,BX[b]) == p1 || lca(p1,BY[b]) == p1)
                   && (lca(p2,AX[a]) == p2 || lca(p2,AY[a]) == p2) )
                dinic.AddEdge(a,b+team01,1<<30);
        }

    for(int i = 0; i < team01; ++i)
        dinic.AddEdge(source,i,AW[i]);
    for(int i = 0; i < team02; ++i)
        dinic.AddEdge(i + team01,sink,BW[i]);

    int tot = 0;
    for(int i = 0; i < team01; ++i) tot += AW[i];
    for(int i = 0; i < team02; ++i) tot += BW[i];

    printf("%d\n",tot - (int)dinic.GetMaxFlow(source,sink));

    return 0;
}

