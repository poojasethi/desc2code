#include <iostream>
#include <sstream> 
#include <cstdio>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <list>
#include <utility>
#include <bitset>
#include <algorithm>
#include <cmath>
#include <cstdlib> 
#include <ctime>
#include <cassert>
#include <cstring>
#include <string>
#include <vector>

using namespace std;

typedef long long ll;
typedef long double ld;
template<typename T> T ABS(const T& val) { return val < 0 ? -val : val; }

const int MAXN = 1e5 + 11;
const int LOGMAXN = 19;
const int INF = 1e9;

const int MAXM = 703;
const int MAXV = 1 + MAXM + MAXM;

int N;
int M[2];

vector<vector<int> > edges;
vector<vector<int> > routes[2];

vector<char> used[2];
vector<int> lim[2];

int CAPSZ;
int near[MAXV][MAXM];
int csz[MAXV];
int reflow[MAXV][MAXV];

vector<vector<int> > lca_top[2];
vector<vector<char> > trans[2];

int parent[MAXN][LOGMAXN];
int dep[MAXN];

clock_t start;


inline void dfs_parents(int u, int par, int deep)
{
    if (used[0][u])
        return;
    used[0][u] = true;
    dep[u] = deep;
    parent[u][0] = par;

    for (int i = 0; i < edges[u].size(); ++i) {
        int v = edges[u][i];
        dfs_parents(v, u, deep + 1);
    }
}

inline int get_lca(int one, int two)
{
    if (dep[one] < dep[two])
        swap(one, two);

    int step = LOGMAXN - 1;
    int counter = 0;
    while (dep[one] > dep[two]) {
        while (dep[parent[one][step]] < dep[two]) {
            ++counter;
            --step;
            assert(counter < 1000);
        }
        one = parent[one][step];
    }

    if (one == two)
        return one;

    assert(dep[one] == dep[two]);

    step = LOGMAXN - 1;
    counter = 0;
    while (one != two) {
        while (step && parent[one][step] == parent[two][step]) {
            --step;
        }
        one = parent[one][step];
        two = parent[two][step];
    }

    return one;
}

inline void lca_mark()
{
    memset(parent, 0, sizeof(parent));
    used[0].assign(N, false);
    dfs_parents(0, 0, 0);

    for (int j = 1; j < LOGMAXN; ++j) {
        for (int i = 0; i < N; ++i) {
            parent[i][j] = parent[parent[i][j - 1]][j - 1];
        }
    }

    for (int iter = 0; iter < 2; ++iter) {
        trans[iter].assign(M[iter], vector<char> (M[1 - iter], false));
    }

    for (int iter = 0; iter < 2; ++iter) {
        for (int i = 0; i < M[iter]; ++i) {
            int a = routes[iter][i][0], b = routes[iter][i][1];
            int cab = get_lca(a, b);

            for (int j = 0; j < M[1 - iter]; ++j) {
                if (trans[iter][i][j])
                    continue;

                int c = routes[1 - iter][j][0], d = routes[1 - iter][j][1];
                int ccd = get_lca(c, d);

                if (get_lca(ccd, cab) == cab && (get_lca(a, ccd) == ccd ||
                                                 get_lca(b, ccd) == ccd))
                {
                    trans[iter][i][j] = true;
                    trans[1 - iter][j][i] = true;
                }

            }
        }
    }
}


inline bool lift(int u, vector<int>& h)
{
    int d = INF;

    for (int i = 0; i < csz[u]; ++i) {
        int v = near[u][i];
        if (reflow[u][v] > 0 && d > h[v] + 1) {
            d = h[v] + 1;
        }
    }

    if (d == INF)
        return false;
    h[u] = d;
    return true;
}

inline bool push(int u, vector<int>& h, vector<int>& e)
{
    bool pushed = false;

    for (int i = 0; i < csz[u] && e[u]; ++i) {
        int v = near[u][i];

        if (reflow[u][v] > 0 && h[u] == h[v] + 1) {
            pushed = true;
            int addf = min(reflow[u][v], e[u]);
            reflow[u][v] -= addf;
            reflow[v][u] += addf;
            e[u] -= addf;
            e[v] += addf;
        }
    }

    return pushed;
}

int preflow_push_maxh(int start, int targ)
{
    int n = CAPSZ;;
    vector<int> e(n);
    vector<int> h(n);
    h[start] = n - 1;

    for (int i = 0; i < csz[0]; ++i) {
        int v = near[start][i];
        int up = reflow[0][v];
        reflow[0][v] = 0;
        reflow[v][0] = up;
        e[v] = up;
    }

    int sz = true;
    bool pushed = true;

    while (sz) {
        sz = false;

        for (int u = 1; u + 1 < CAPSZ; ++u) {
            lift(u, h);

            while (e[u]) {
                if (!pushed && !lift(u, h))
                        break;
                pushed = push(u, h, e);
                sz = sz || pushed;
            }
        }
    }

    int res = 0;
    for (int i = 1; i < 1 + M[0]; ++i) {
        res += reflow[i][0];
    }

    return res;
}


int main ()
{
    while (scanf("%d %d %d", &N, &M[0], &M[1]) > 0) {
        start = clock();
        edges.assign(N, vector<int>());
        for (int i = 0; i < N - 1; ++i) {
            int u, v;
            scanf("%d %d", &u, &v);
            --u;
            --v;
            edges[u].push_back(v);
            edges[v].push_back(u);
        }

        for (int iter = 0; iter < 2; ++iter) {
            routes[iter].clear();
            for (int i = 0; i < M[iter]; ++i) {
                routes[iter].push_back(vector<int>(3, 0));

                for (int j = 0; j < 3; ++j) {
                    scanf("%d", &routes[iter].back()[j]);

                    if (j < 2)
                        --routes[iter].back()[j];
                }
                
            }
            random_shuffle(routes[iter].begin(), routes[iter].end());

            lim[iter].assign(M[iter], 0);
            for (int i = 0; i < routes[iter].size(); ++i) {
                lim[iter][i] = routes[iter][i][2];
            }
        }

        lca_mark();

        CAPSZ = 2 + M[0] + M[1];
        memset(near, 0, sizeof(near));
        memset(csz, 0, sizeof(csz));
        memset(reflow, 0, sizeof(reflow));

        int total = 0;
        int start = 0;
        int targ = 1 + M[0] + M[1];

        for (int i = 1; i <= M[0]; ++i) {
            near[start][csz[start]++] = i;
            reflow[start][i] = lim[0][i - 1];
            near[i][csz[i]++] = start;
            reflow[i][start] = 0;
            total += lim[0][i - 1];

            for (int j = 1 + M[0]; j < 1 + M[0] + M[1]; ++j) {
                if (i == 1) {
                    near[j][csz[j]++] = targ;
                    reflow[j][targ] = lim[1][j - (1 + M[0])];
                    near[targ][csz[targ]++] = j;
                    reflow[targ][j] = 0;
                    total += lim[1][j - (1 + M[0])];
                }

                bool found = trans[0][i - 1][j - (1 + M[0])];
                if (found) {
                    near[i][csz[i]++] = j;
                    reflow[i][j] = INF;
                    near[j][csz[j]++] = i;
                    reflow[j][i] = 0;
                }
            }
        }

        int ans = total - preflow_push_maxh(start, targ);
        printf("%d\n", ans);
    }


    return 0;
}
