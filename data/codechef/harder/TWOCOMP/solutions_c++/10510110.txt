#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
#define N 100050
#define M 1505
#define INF 0x3f7f7f7f
int n,m,p,ans,wz[M][4];
inline int Read()
 {
 	int x=0;char y;
 	do y=getchar(); while (y<'0'||y>'9');
 	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');
 	return x;
 }
namespace Graph
 {
 	queue <int> li;
 	int fi[M],S=M-1,T=M-2,c[M*M][3],cur[M],ss=1,h[M];
 	inline void Line(int x,int y,int z)
 	 {
 	 	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;c[ss][2]=z;
 	 	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;
 	 	return;
 	 }
 	bool BFS()
 	 {
 	 	memset(h,false,sizeof h);memcpy(cur,fi,sizeof cur);
 	 	h[S]=true;li.push(S);
 	 	while (!li.empty())
 	 	 {
 	 	 	int k=li.front();li.pop();
 	 	 	for (int i=fi[k];i;i=c[i][1])
 	 	 	 if (c[i][2]&&!h[c[i][0]])
 	 	 	   h[c[i][0]]=h[k]+1,li.push(c[i][0]);
 	 	 }
 	 	return h[T]>0;
 	 }
 	int DFS(int x,int y)
 	 {
 	 	int k,l=false;
 	 	if (x==T) return y;
 	 	for (int i=cur[x];i&&y;i=c[i][1])
 	 	 if (c[i][2]&&h[c[i][0]]==h[x]+1)
 	 	  {
 	 	  	 k=DFS(c[i][0],min(y,c[i][2]));cur[x]=i;
 	 	  	 if (k) c[i][2]-=k,c[i^1][2]+=k,y-=k,l+=k;
 	 	  }
 	 	if (!l) h[x]=-1;
 	 	return l;
 	 }
 	void Solve()
 	 {
 	 	int Cnt=false;
 	 	while (BFS()) ans -= DFS(S,INF),Cnt++;
 	 	return;
 	 }
 }
namespace Tree
 {
 	int fi[N],c[N*2][2],rf[N],wei[N],h[N],fa[N],sg[N][2];
 	int ss=1,st;
 	inline void Line(int x,int y)
 	 {
 	 	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;
 	 	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;
 	 	return;
 	 }
 	void DFS(int x)
 	 {
 	 	h[x]=h[fa[x]]+1;wei[x]=1;
 	 	for (int i=fi[x];i;i=c[i][1])
 	 	 if (c[i][0]!=fa[x])
 	 	   fa[c[i][0]]=x,DFS(c[i][0]),wei[x]+=wei[c[i][0]];
 	 	return;
 	 }
 	void DSF(int x,int y)
 	 {
 	 	int k=false;sg[x][0]=++st;rf[x]=y;
 	 	for (int i=fi[x];i;i=c[i][1])
 	 	 if (c[i][0]!=fa[x]&&wei[c[i][0]]>wei[k]) k=c[i][0];
 	 	if (k) DSF(k,y);
 	 	for (int i=fi[x];i;i=c[i][1])
 	 	 if (c[i][0]!=fa[x]&&c[i][0]!=k) DSF(c[i][0],c[i][0]);
 	 	sg[x][1]=st;
 	 	return;
 	 }
 	int LCA(int x,int y)
 	 {
 	 	while (rf[x]!=rf[y])
 	 	 {
 	 	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);
 	 	 	x=fa[rf[x]];
 	 	 }
 	 	return h[x]<h[y]?x:y;
 	 }
 	inline bool Aha(int x,int y)
 	 {return sg[x][0]>=sg[y][0]&&sg[x][1]<=sg[y][1];}
 	inline bool Init(int x,int y)
 	 {return Aha(x,wz[y][3])&&(Aha(wz[y][0],x)||Aha(wz[y][1],x));}
 	void Solve()
 	 {
 	 	DFS(1);DSF(1,1);
 	 	for (int i=1;i<=m+p;i++)
 	 	  wz[i][3]=LCA(wz[i][0],wz[i][1]);
 	 	for (int i=1;i<=m;i++)
 	 	 for (int j=m+1;j<=m+p;j++)
 	 	  {
 	 	  	 bool flag = false;
 	 	  	 flag = Init(wz[i][0],j) | Init(wz[i][1],j);
 	 	  	 flag |= Init(wz[j][0],i) | Init(wz[j][1],i);
 	 	  	 flag |= Init(wz[i][3],j) | Init(wz[j][3],i);
  	 	  	 if (flag) Graph::Line(i,j,INF);
 	 	  }
 	 	for (int i=1;i<=m;i++) Graph::Line(M-1,i,wz[i][2]);
 	 	for (int i=m+1;i<=m+p;i++) Graph::Line(i,M-2,wz[i][2]);
 	 	return;
 	 }
 }
int main()
 {
 	n=Read();m=Read();p=Read();
 	for (int i=1;i<n;i++) Tree::Line(Read(),Read());
 	for (int i=1;i<=m+p;i++)
 	 for (int j=0;j<3;j++) wz[i][j]=Read();
 	for (int i=1;i<=m+p;i++) ans += wz[i][2];
 	Tree::Solve();Graph::Solve();
 	cout <<ans<<endl;
 	return 0;
 }