#include<iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <utility>
#include <set>
#include <queue>
using namespace std;
#define getcx getchar
#define pii pair< int,int >
#define piii pair< int,pii >
inline void in(int &n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
struct Cmp
{
    bool operator()(const piii &a,const piii &b)
    {
        return a.first<b.first;
    }
};
#define V 100000
#define INFL 1000000000
#define temp 0
#define perm 1
vector<int> adj[V];
vector<int> chainOfelem[V];
int parent[V];
int depth[V], size[V] ,heavy[V],f[V];
int chain[V], head[V] ,sizeOfelem[V];
set<int> Set;
set<int>::iterator it;
int cap[1405][1405];
int done[V];
int m1,m2;

/*void heavylight_BFS(int n)
{
    int q[V];
    int node,child,i,j;
    queue<int> Q;

    parent[0] = -1;
    depth[0] = 0;
    Q.push(0);
    j=0;
    while(!(Q.empty()))
    {
        node=Q.front();
        q[j++]=node;
        Q.pop();
        for (i=0; i<adj[node].size(); i++)
        {
            child = adj[node][i];
            if (child == parent[node])
                continue;
            parent[child] = node;
            depth[child] = depth[node] + 1;
        }
    }

    memset(size, 0, sizeof(size));
    memset(heavy, -1, sizeof(heavy));


    //now decide the heavy node of all the nodes(that are parent)
    //q[] array contains the element in level order(because of bfs)
    //when we visit the nodes in q[], it is sure a node is always visited only after all its child is visited
    for (i=n-1; i>0; i--)
    {
        child=q[i];
        node=parent[q[i]];

        size[child]++;
        size[node] += size[child];

        //can this child be the heavy node of its parent(node)
        //if the node don't have any heavy child then this child will be the heavy node, otherwise check can it be a heavy child
        if (heavy[node] == -1 || size[child] > size[heavy[node]])
            heavy[node] = child;
    }

    //now decide the chain to which each element belongs
    //start from a element which could be the head of the chain or from which the chain begins
    //So start from a root(parent[i]=-1) or a node which is not a heavy child of its parent(so it will start a new chain)
    int c = 0;
    for (i=0; i<n; i++)
    {
        if (parent[i] == -1 || heavy[parent[i]] != i)
        {
            //on ce you have got the head of the chain, continue the chain until heavy child of a node is -1(ie a leaf node)
            for (j = i; j!=-1; j=heavy[j])
            {
                chain[j] = c;//the jth elem belongs to cth chain
                head[j] = i;//the head of the jth elem is i
                sizeOfelem[c]++;//sizeOf the current chain is increased
                f[j]=sizeOfelem[c];//the jth elem belongs f[j] position in its chain
                chainOfelem[c].push_back(j);
            }
            c++;
        }
    }
}*/
void heavylight_BFS(int N)
{
    int q[V],*qf,*qb;
qf = qb = q;
parent[0]=-1;
depth[0]=0;
*qb++ = 0;
while (qf < qb)
{
for (int i=*qf++, k=0; k<adj[i].size(); ++k)
{
int j = adj[i][k];

if (j == parent[i])
continue;

parent[j]=i;

depth[j] = depth[i] + 1;
*qb++ = j;
}
}

memset(size, 0, sizeof(size));
memset(heavy, -1, sizeof(heavy));

for (int k=N-1; k>0; --k)
{
int j = q[k], i = parent[q[k]];
size[j]++;
size[i] += size[j];
if (heavy[i] == -1 || size[j] > size[heavy[i]])
heavy[i] = j;
}
int c = 0;
for (int i=0; i<N; ++i)
{
if (parent[i]==-1 || heavy[parent[i]]!=i)
{
for (int k = i; k != -1; k = heavy[k])
{
chain[k] = c;//the kth elem belongs to cth chain
sizeOfelem[c]++;//size of cth chain is increased
f[k]=sizeOfelem[c];//f keeps the location of the kth elem in a single chain in which it is present
//hence push the kth element in cth chain
//chainOfelem[sizeOfelem[c]]=k;//parent is pushed first then its child
chainOfelem[c].push_back(k);
head[k] = i;
}
/*Initialise Segment Tree For c th chain as c th chain surely contains one or more elements*/
/*tmp=(SegmentTreeNode *)malloc(sizeof(SegmentTreeNode));
init(chain[i],tmp,1,sizeOfelem[chain[i]]);//chain,node,start,stop

start[chain[i]]=tmp;*/
c++;
}
}
}
set<piii,Cmp> S1[100005],S2[100005];
set<piii,Cmp>::iterator it1,it2;
void query(int i, int j, int x, int xyz)
{
    int low,high;
    while (chain[i] != chain[j])
    {
        if (depth[head[i]] > depth[head[j]])
        {
            low=f[head[i]];
            high=f[i];
            if(xyz==0)
            {
                S1[x].insert(piii(chain[i],pii(low,high)));
            }
            else
            {
                S2[x].insert(piii(chain[i],pii(low,high)));
            }
            i = parent[head[i]];
        }
        else
        {
            low=f[head[j]];
            high=f[j];
            if(xyz==0)
            {
                S1[x].insert(piii(chain[j],pii(low,high)));
            }
            else
            {
                S2[x].insert(piii(chain[j],pii(low,high)));
            }
            j = parent[head[j]];
        }
    }
    low=min(f[i],f[j]);
    high=max(f[i],f[j]);
    if(xyz==0)
    {
        S1[x].insert(piii(chain[i],pii(low,high)));
    }
    else
    {
        S2[x].insert(piii(chain[i],pii(low,high)));
    }
}
int max_flow();
int main()
{
    int n,p,q,w,i,j;
    in(n);
    in(m1);
    in(m2);
    for(i=1; i<n; i++)
    {
        in(p);
        in(q);
        p--;
        q--;
        adj[p].push_back(q);
        adj[q].push_back(p);
    }

    heavylight_BFS(n);

    int ans;
    ans=0;
    for(i=1; i<=m1; i++)
    {
        in(p);
        in(q);
        in(w);

        ans=ans+w;

        p--;
        q--;

        query(p,q,i,0);

        cap[0][i]=w;
    }

    for(i=1; i<=m2; i++)
    {
        in(p);
        in(q);
        in(w);

        ans=ans+w;

        p--;
        q--;

        query(p,q,i,1);

        cap[i+m1][m1+m2+1]=w;

    }

    int edge,chain_x,chain_y,lx,ly,rx,ry;
    for(i=1; i<=m1; i++)
    {
        for(j=1; j<=m2; j++)
        {
            it1=S1[i].begin();
            edge=0;
            for(; it1!=S1[i].end(); it1++)
            {
                it2=S2[j].begin();
                if(edge==1)
                {
                    break;
                }
                for(; it2!=S2[j].end(); it2++)
                {
                    chain_x=(*it1).first;
                    chain_y=(*it2).first;

                    lx=(*it1).second.first;
                    rx=(*it1).second.second;

                    ly=(*it2).second.first;
                    ry=(*it2).second.second;
                    if(chain_x==chain_y)
                    {
                        if( (ly>=lx && ly<=rx) || (ry>=lx && ry<=rx) )
                        {
                            edge=1;
                        }
                        else if( (lx>=ly && lx<=ry) || (rx>=ly && rx<=ry) )
                        {
                            edge=1;
                        }
                    }
                    else if(chain_x<chain_y)
                    {
                        break;
                    }
                }
            }
            if(edge)
            {
                cap[i][j+m1]=INFL;
            }
        }
    }

    ans=ans-max_flow();
    printf("%d\n",ans);


    return 0;
}
int find_path()//Using BFS
{
    int v,i,prev,brkwhile=0,from[1405],state[1405],path_cap;
    for(i=0; i<=m1+m2+1; i++)
    {
        from[i]=-1;
        state[i]=temp;
    }
    queue<int> Q;
    //push Q
    Q.push(0);//Push Source
    state[0]=perm;//Make Source As Visited
    while(!(Q.empty()))
    {
        v=Q.front();
        Q.pop();
        if(v==0)
        {
            for(i=1; i<=m1; i++)//source will search from rows
            {
                if(cap[v][i]>0 && state[i]==temp)
                {
                    Q.push(i);
                    state[i]=perm;
                    from[i]=v;
                }
            }
        }
        else//v is a row node or a col node
        {
            for(i=1; i<=m1+m2+1; i++)
            {
                if(cap[v][i]>0 && state[i]==temp)
                {
                    Q.push(i);
                    state[i]=perm;
                    from[i]=v;
                    state[i]=perm;
                    if(i==m1+m2+1)
                    {
                        brkwhile=1;
                        break;
                    }
                }
            }
        }
        if(brkwhile==1)
            break;
        }
        v=m1+m2+1;//it is is the sink
        path_cap=INFL;
        //If No Path Is Found,While Loop Will Not Be Executed
        while(from[v]>-1)
        {
            prev=from[v];
            path_cap=min(path_cap,cap[prev][v]);
            v=prev;
        }
        v=m1+m2+1;
        while(from[v]>-1)
        {
            prev=from[v];
            cap[prev][v]-=path_cap;
            cap[v][prev]+=path_cap;
            v=prev;
        }
        if(path_cap==INFL)
            return 0;
        else
            return path_cap;
    }
int max_flow()
{
    int result=0,path_capacity;
    while(1)
    {
        path_capacity=find_path();
        if(path_capacity==0)
            break;
        else
        {
            result+=path_capacity;
        }
    }
    return result;
}
