#include<bits/stdc++.h>
#define N 100000
#define M 700
#define INF 2000000
#define ll long long
#define pb push_back
using namespace std;

int B1[ M+5 ], B2[ M+5 ], B3[ M+5 ], G1[ M+5 ], G2[ M+5 ], G3[ M+5 ];
int tin[ N+5 ], tout[ N+5 ], H[ N+5 ], L[ 2*N+5 ] , E[ 2*N+5 ], pd[ 2*N+5 ][ 20 ]; 
bool vis[ N+5 ];
vector<int>adj[ N+5 ];
int n , m1 , m2, temp=0, ct = 0;

struct flow_graph{
    int MAX_V,E,s,t,head,tail;
    int *cap,*to,*next,*last,*dist,*q,*now;
    flow_graph(){}
    
    flow_graph(int V, int MAX_E){
        MAX_V = V; E = 0;
        cap = new int[2*MAX_E], to = new int[2*MAX_E], next = new int[2*MAX_E];
        last = new int[MAX_V], q = new int[MAX_V];
        dist = new int[MAX_V], now = new int[MAX_V];
        fill(last,last+MAX_V,-1);
    }
    
    void clear(){
        fill(last,last+MAX_V,-1);
        E = 0;
    }
    
    void add_edge(int u, int v, int uv,int vu=0){
        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;
        to[E] = u, cap[E] =vu , next[E] = last[v]; last[v] = E++;
    }
  
    bool bfs(){
        fill(dist,dist+MAX_V,-1);
        head = tail = 0;
        q[tail] = t; ++tail;
        dist[t] = 0;
        while(head<tail){
            int v = q[head]; ++head;
            for(int e = last[v];e!=-1;e = next[e]){
                if(cap[e^1]>0 && dist[to[e]]==-1){
                    q[tail] = to[e]; ++tail;
                    dist[to[e]] = dist[v]+1;
                }
            }
        }
        return dist[s]!=-1;
    }
  
    int dfs(int v, int f){
        if(v==t) return f;
        for(int &e = now[v];e!=-1;e = next[e]){
            if(cap[e]>0 && dist[to[e]]==dist[v]-1){
                int ret = dfs(to[e],min(f,cap[e]));
                if(ret>0){
                    cap[e] -= ret;
                    cap[e^1] += ret;
                    return ret;
                }
            }
        }
        return 0;
    }
  
    long long max_flow(int source, int sink){
        s = source; t = sink;
        long long f = 0,df;
        while(bfs()){
            for(int i = 0;i<MAX_V;++i) now[i] = last[i];
            while(true){
                df = dfs(s,INT_MAX);
                if(df==0) break;
                f += df;
            }
        }
        return f;
    }
};

flow_graph G;

void dfs( int u, int niv ){
	vis[ u ] =1;
	tin[ u ] = temp++;
	int sz = adj[ u ].size();
	for( int i=0 ; i<sz ; ++i ){
		int v = adj[ u ][ i ];
		if( !vis[ v ] ){
			E[ ct ] = v;
			L[ ct++ ] = niv+1;
			dfs( v, niv+1 );
			E[ ct ] = u;
			L[ ct++ ] = niv;
		}
	}
	tout[ u ] = temp++;
}

void calc( ){
	n = 2*n-1;
	for( int i =0 ; i<n ; ++i ) pd[ i ][ 0 ] = i;
	for( int j =1 ; (1<<j )<=n ; ++j ){
		for( int i =0 ; i<n ; ++i ){
			if(  i + ( 1<<( j-1) ) < n ){
				int p1 = pd[ i ][ j-1 ];
				int p2 = pd[ i + ( 1<<( j-1) ) ][ j-1 ];
				if( L[ p1 ]<L[ p2 ] ) pd[ i ][ j ] = p1;
				else pd[ i ][ j ] = p2;
			}
		}
	}
}

int lca( int x , int y ){
	if( H[ x ] >H[ y ] ) swap( x, y );
	int len = H[ y ] -  H[ x ]+1;
	int log = 31 - ( __builtin_clz( len ) );
	int p1 = pd[ H[ x ] ][ log ];
	int p2 = pd[ H[ y ] - ( 1<<log ) +1  ][ log ];
	if( L[ p1 ] < L[ p2 ] ) return E[ p1 ];
	return E[ p2 ];
}

bool anc( int a , int b , int c ){
	return ( tin[ b ]<=tin[ a ]  && tout[ b ]>=tout[ a ]  && tin[ c ]<=tin[ b ]  && tout[ c ]>=tout[ b ] );	
}

bool onpath( int c , int  a, int b, int LCA ){
	if( anc( a , c , LCA )  || anc( b , c , LCA ) ) return 1;  
	return 0;
}

bool inters( int x , int y ){
	int a = B1[ x ] , b =B2[ x ];
	int c = G1[ y ] , d =G2[ y ];
	int lca1 = lca( a , b ) , lca2 = lca( c, d );
	if( onpath( lca1 , c , d, lca2 ) || onpath( lca2 , a , b, lca1 ) )return 1;
	return 0;
}

int main(){
	int x, y;
	scanf("%d%d%d", &n, &m1, &m2 );
	for( int i=0 ; i<n-1; ++i ){
		scanf("%d%d", &x, &y );
		x-- , y--;
		adj[ x].pb( y ) , adj[ y ].pb( x );	
	}
	ll tot = 0 ;
	for( int i=0 ; i<m1 ; ++i ){
		scanf("%d%d%d" , &B1[ i ] , &B2[ i ] , &B3[ i ] );
		B1[ i ]-- , B2[ i ]--;
		tot+=B3[ i ];
	}
	for( int i=0 ; i<m2 ; ++i ){
		scanf("%d%d%d" , &G1[ i ] , &G2[ i ] , &G3[ i ] );
		G1[ i ]-- , G2[ i ]--;
		tot+=G3[ i ];
	}
	L[ ct ] = 0;
	E[ ct++ ]=0;
	dfs( 0, 0 );
	for( int i=0 ; i<n ; ++i )H[ i ] = -1;
	for( int i =0 ; i<ct ; ++i ){
		if( H[ E[ i ] ] ==-1 )H[ E[ i ] ] = i;
	}
	calc( );
	G = flow_graph( m1+m2+2  , m1*m2 +m1+m2 );
	int S =m1+m2 , T= S+1;
	for( int i =0 ; i<m1 ; ++i ){
		for( int j =0 ;j<m2 ; ++j ){
			if( inters( i , j ) ){
				G.add_edge( i, j+m1, INF );
			}
		}
	}
	for( int i =0 ; i<m1 ; ++i ){
		G.add_edge( S , i , B3[ i ] );
	}
	for( int i =0 ; i<m2 ; ++i ){
		G.add_edge( i+m1 , T , G3[ i ] );
	}
	printf("%lld\n" , tot - G.max_flow( S, T ) );
}