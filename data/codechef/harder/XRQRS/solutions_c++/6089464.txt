#include<cstdio>
#include<vector>
#include<algorithm>
#define SIZE 1200004
using namespace std;
int scan()
{
    int n=0;
    char ch = getchar_unlocked();
    while(ch<'0'||ch>'9')
        ch=getchar_unlocked();
    while(ch>='0' && ch<='9')
    {
        n = (n<<3)+(n<<1)+ch-'0';
        ch=getchar_unlocked();
    }
    return n;
}
//pre requisites: lower_bound(x) gives the index of the element that is >= x
//upper_bound(x) : gives the index to the element that is >x
 
//each node stores the indices of the elements that pass through that node
vector<int> node[SIZE];     //stores the trie parent:n left child:2*n right child:2*n+1
int arr[500004];        //stores the array elements
int size=0;         //number of elements
//to check if vector v contains atleast 1 element in the range [l,r]
int check(vector<int> &v,int l, int r)
{
    vector<int>::iterator it;
    it = lower_bound(v.begin(), v.end(), l);
    if(it!=v.end() && *it<=r)
        return 1;
    return 0;
}
//to insert an element in the tree, start from the MSB, if 0 go left else go right
//and at each node encountered, add the index of the element to the vector of the node
void insert(int x,int pos)
{
    int curr_node = 1;
    int curr_bit;
    for(curr_bit=1<<18;curr_bit>0;curr_bit>>=1)
    {
        if(curr_bit&x)      //bit is 1: go right
            curr_node = 2*curr_node + 1;
        else
            curr_node = curr_node*2;
        node[curr_node].push_back(pos);
    }
}
//to maximise xor, we will always need opposite bits as x
//i.e. to maximum 101, we will need 010
//hence if the bit is 0, go right(if possible)
//if bit is 1, go left
//before proceeding to the child node, we also have to check if the node contains atleast 1 index in the range[l,r]
int maximisexor(int l, int r, int x)
{
    int curr_node=1;
    int curr_bit;
    int ans=0;
    for(curr_bit=1<<18;curr_bit>0;curr_bit>>=1)
    {
        if(x&curr_bit)      //bit is 1: go towards left, but before check if the left node has atleast 1 index in range[l,r]
        {
            if(check(node[2*curr_node], l, r)){
                ans*=2;         //consider eg of 5: 0101: everytime a 0 is encountered we only have to do a left shift!
                                //but as 1 is encountered, we do a left shift and also add a 1 to that bit position (look ans++)
                curr_node = curr_node*2;
            }
            else{
                ans*=2;
                ans++;
                curr_node = 2*curr_node + 1;
            }
        }
        else
        {
            if(check(node[2*curr_node+1], l, r)){
                curr_node = 2*curr_node+1;
                ans*=2;
                ans++;
            }
            else{
                curr_node=2*curr_node;
                ans*=2;
            }
        }
    }
    return ans;
}
//to delete the last element, start with the MSB
//if 0, go left else go right
//and at each node, pop the last index (why only the last index?)coz while inserting, this element would have been inserted last!!
void deletek(int x)
{
    int curr_node=1;
    int curr_bit;
    for(curr_bit=1<<18;curr_bit>0;curr_bit>>=1)
    {
        if(x&curr_bit)
        {
            curr_node = 2*curr_node+1;
        }
        else
            curr_node = 2*curr_node;
        node[curr_node].pop_back();
    }
}
//if the current bit of x is 1, then all the elements in the left subtree will be smaller than x
//but we need to count only those who lie in the range [l,r] see distance()
//and then we proceed to the right subtree as we have counted all the valid elements from the left subtree
//but if the current bit is 0, we cannot guarantee how many will be less than x at this stage
//thus we simply move to the left subtree without changing the count
//and finally in the last leaf node we again count how many lie in the range[l,r] as there can be duplicate elements (some in the range and some not!!)
int countx(int l, int r, int x)
{
    int curr_node=1;
    int curr_bit;
    int ans=0;
    for(curr_bit=1<<18;curr_bit>0;curr_bit>>=1)
    {
        if(x&curr_bit)
        {
            ans+=distance(lower_bound(node[curr_node*2].begin(), node[2*curr_node].end(), l) , upper_bound(node[2*curr_node].begin(), node[2*curr_node].end(), r));
            curr_node = 2*curr_node+1;
        }
        else
            curr_node=2*curr_node;
    }
    ans+=distance(lower_bound(node[curr_node].begin(), node[curr_node].end(), l), upper_bound(node[curr_node].begin(), node[curr_node].end(), r));
    return ans;
}
//we look at how many elements are there in the left and right subtrees lying in the range[l,r]
//if the no of elements in the left subtree >= k
//it means our kth smallest element is in the left subtree
//and we left
//else the kth smallest element is in the right subtree
//k-=count; why? because we have eliminated the count elements from the left subtree
int kthElement(int l, int r, int k)
{
    int curr_node=1;
    int curr_bit;
    int ans=0;
    for(curr_bit=1<<18;curr_bit>0;curr_bit>>=1)
    {
        int count = distance(lower_bound(node[2*curr_node].begin(), node[2*curr_node].end(), l), upper_bound(node[2*curr_node].begin(), node[2*curr_node].end(), r));
        if(count>=k){
            curr_node = 2*curr_node;
            ans*=2;
        }
        else{
            k-=count;
            curr_node = 2*curr_node+1;
            ans*=2;
            ans++;
        }
    }
    return ans;
}
int main()
{
    int m;
    m=scan();
    while(m--)
    {
        int choice,x,k,l,r;
        choice=scan();
        switch(choice)
        {
            case 0:
                x=scan();
                insert(x,++size);
                arr[size] = x;
                break;
            case 1:
                l=scan();r=scan();x=scan();
                printf("%d\n",maximisexor(l, r, x));
                break;
            case 2:
                k=scan();
                while(k--)
                    deletek(arr[size--]);
                break;
            case 3:
                l=scan();r=scan();x=scan();
                printf("%d\n",countx(l, r, x));
                break;
            case 4:
                l=scan();r=scan();k=scan();
                printf("%d\n",kthElement(l, r, k));
                break;
        }
    }
} 