
#include <bits/stdc++.h>
using namespace std;
#define MOD 1000000007
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi  vector<int>
#define pb  push_back
#define mp  make_pair
#define M(a,x) memset(a,x,sizeof(a))
#define sci(x) scanf("%d",&x);
#define scl(x) scanf("%lld",&x);
#define scs(x) scanf("%s",x);
#define print(x) printf("%d",x);
#define nl printf("\n")
#define printl(x) printf("%lld",x)
#define F(i,a,n) for(int i=a;i<n;i++)
#define INF 100000000000000000LL
#define LL long long

const int N = 5e5+5;
const int LN = 18;
struct node {
    vector<int> idx;
    int left;int right;
    node() {
	left=right=-1;
	idx.clear();
    }
};
struct TRIE {
    node nodes[N*LN];
    int cur;
    TRIE() {
	cur=0;
    }
    inline void insert(int num,int pos) {
	int nd=0;
	for(int i=LN;i>=0;i--) {
	    if(num&(1<<i)) {
		if(nodes[nd].right==-1) {
		    nodes[nd].right=++cur;
		}
		nd=nodes[nd].right;
		nodes[nd].idx.pb(pos);
	    }
	    else {
		if(nodes[nd].left==-1) {
		    nodes[nd].left=++cur;
		}
		nd=nodes[nd].left;
		nodes[nd].idx.pb(pos);
	    }
	}
    }
    inline void erase(int num) {
	int nd=0;
	for(int i=LN;i>=0;i--) {
	    if(num&(1<<i)) {
		nd=nodes[nd].right;
	    }
	    else {
		nd=nodes[nd].left;
	    }
	    nodes[nd].idx.pop_back();
	}
    }
    inline int mxor(int l,int r,int val) {
	int ans=0;
	int nd=0;
	for(int i=LN;i>=0;i--) {
	    if(val&(1<<i)) {
		if(nodes[nd].left==-1) {
		    ans|=(1<<i);
		    nd=nodes[nd].right;
		}
		else {
		    vector<int> :: iterator it;
		    it=lower_bound(nodes[nodes[nd].left].idx.begin(),nodes[nodes[nd].left].idx.end(),l);
		    if(it!=nodes[nodes[nd].left].idx.end() && *it<=r) {
			nd=nodes[nd].left;
		    }
		    else {
			nd=nodes[nd].right;
			ans|=(1<<i);
		    }
		}
	    }
	    else {
		if(nodes[nd].right==-1) {
		    nd=nodes[nd].left;
		}
		else {
		    vector<int> ::iterator it;
		    it=lower_bound(nodes[nodes[nd].right].idx.begin(),nodes[nodes[nd].right].idx.end(),l);
		    if(it!=nodes[nodes[nd].right].idx.end() && *it<=r) {
			nd=nodes[nd].right;
			ans|=(1<<i);
		    }
		    else {
			nd=nodes[nd].left;
		    }
		}
	    }
	}
	return ans;
    }
    inline int kthnum(int l,int r, int k) {
	int ans=0;
	int nd=0;
	for(int i=LN;i>=0;i--) {
	    if(nodes[nd].left==-1) {
		nd=nodes[nd].right;
		ans|=(1<<i);
		continue;
	    }
	    int x=lower_bound(nodes[nodes[nd].left].idx.begin(),nodes[nodes[nd].left].idx.end(),r+1)-nodes[nodes[nd].left].idx.begin();
	    int y=lower_bound(nodes[nodes[nd].left].idx.begin(),nodes[nodes[nd].left].idx.end(),l)-nodes[nodes[nd].left].idx.begin();
	    int z=x-y;
	    if(k<=z) {
		nd=nodes[nd].left;
	    }
	    else {
		nd=nodes[nd].right;
		k-=z;
		ans|=(1<<i);
	    }
	}
	return ans;
    }
    inline int ksmall(int l,int r,int k) {
	k+=1;
	int ans=0;
	int nd=0;
	for(int i=LN;i>=0 && nd>=0;i--) {
	    if(k&(1<<i)) {
		int z=0;
		if(nodes[nd].left!=-1) {
		    int x=lower_bound(nodes[nodes[nd].left].idx.begin(),nodes[nodes[nd].left].idx.end(),r+1)-nodes[nodes[nd].left].idx.begin();
		    int y=lower_bound(nodes[nodes[nd].left].idx.begin(),nodes[nodes[nd].left].idx.end(),l)-nodes[nodes[nd].left].idx.begin();
		    z=x-y;
		}
		ans+=z;
		nd=nodes[nd].right;
	    }
	    else {
		nd=nodes[nd].left;
	    }
	}
	return ans;
    }
};
int arr[N];
TRIE trie;
int m;
int cur = 0;
int main(){
//    freopen("a.txt","r",stdin);
    sci(m);
    for(int i=1;i<=m;++i){
	int type;
	scanf("%d",&type);
	if(!type){
	    scanf("%d",&arr[++cur]);
	    trie.insert(arr[cur],cur);
	}
	else if(type==1){
	    int l,r,val;
	    scanf("%d%d%d",&l,&r,&val);
	    printf("%d\n",trie.mxor(l,r,val));
	}
	else if(type==2){
	    int k;
	    scanf("%d" ,&k);
	    while(k--){
		trie.erase(arr[cur--]);
	    }
	}
	else if(type==3){
	    int l,r,k;
	    scanf("%d%d%d",&l,&r,&k);
	    printf("%d\n",trie.ksmall(l,r,k));
	}
	else{
	    int l,r,k;
	    scanf("%d%d%d",&l,&r,&k);
	    printf("%d\n",trie.kthnum(l,r,k));
	}
    }
    return 0;
} 
