/*-----trie implementation-----*/
#include<bits/stdc++.h>
//#define DEBUG
//#ifdef DEBUG
//code to debug
//#endif
//#undef DEBUG
using namespace std;

const int mod=1e9+7;
#define F(i,p,n) for(int i=p;i<n;i++)
#define I(i,p,q) for(int i=p;i>=q;i--)
#define Ss(x) scanf("%s",x)
//#define S(x) scanf("%d",&x)
#define getcx getchar
inline void S(int& n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
#define Ps(x) printf("%d  ",x)
#define P(x) printf("%d\n",x)
typedef long long int LL;
#define Bug(x) cout << #x << "=" << x << endl
#define pii pair<int,int>
#define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int
#define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit

#define _indcount(v)  upper_bound(v.begin(),v.end(),r)-lower_bound(v.begin(),v.end(),l)


struct node
{
    vector<int> ind;
    struct node *zero,*one;
}*root=0;

vector<int> data;

inline bool _ispresent(node* temp,int l,int r)
{
    if(!temp->ind.size())
        return false;
    vector<int>::iterator it;
    it=lower_bound(temp->ind.begin(),temp->ind.end(),l);
    if(it!=temp->ind.end()&&*it>=l&&*it<=r)
        return true;
    return false;
}

/*inline int _indcount(node* temp)
{
    return upper_bound(temp->ind.begin(),temp->ind.end(),r)-lower_bound(temp->ind.begin(),temp->ind.end(),l);
}*/

node* _insert(node* temp,int num,int mask,int idx)
{

    if(!mask)
        return temp;

    if(!temp)
    {
        temp=new node();
        temp->zero=0;
        temp->one=0;

    }
    temp->ind.push_back(idx);
    if(!(num&(mask>>1)))
    {

        temp->zero=_insert(temp->zero,num,mask>>1,idx);
    }
    else
    {

        temp->one=_insert(temp->one,num,mask>>1,idx);
    }
    return temp;
}

node* _delete(node* temp,int num,int mask)
{
    if(mask==0)
        return 0;
    if(num&(mask>>1))
        temp->one=_delete(temp->one,num,mask>>1);
    else
        temp->zero=_delete(temp->zero,num,mask>>1);
    if(temp->ind.size()==1)
    {
        delete(temp);
        return 0;
    }
    temp->ind.pop_back();
    return temp;
}

/*void deletes(node* temp,int num,int mask)
{
    if(!mask)
        return;
    temp->ind.pop_back();
    if((mask>>1)&num)
    {
        deletes(temp->one,num,mask>>1);
    }
    else
    {
        deletes(temp->zero,num,mask>>1);
    }
    return;
}*/

int _kthsmall(node* temp,int l,int r,int k)
{
    if(!temp->zero&&!temp->one)
        return temp->ind[0];
    int cnt;
    if(temp->zero)
        cnt=_indcount(temp->zero->ind);
    else
        cnt=0;
    if(cnt>=k)
    {
        return _kthsmall(temp->zero,l,r,k);
    }
    else
    {
        return _kthsmall(temp->one,l,r,k-cnt);
    }
}

int _countnum(node* temp,int l,int r,int num,int mask)
{
    if(!temp)
        return 0;
    if(!temp->one&&!temp->zero)
    {
        return _indcount(temp->ind);
    }
    if(num&mask)
    {
        if(temp->zero)
        {
            return _indcount(temp->zero->ind)+_countnum(temp->one,l,r,num,mask>>1);
        }
        else
            return _countnum(temp->one,l,r,num,mask>>1);
    }
    else
    {
        return _countnum(temp->zero,l,r,num,mask>>1);
    }

}
int _maxxor(node* temp,int l,int r,int num,int mask)
{
    if(!temp->zero&&!temp->one)
        return temp->ind[0];

    if(!(mask&num))
    {
        if(temp->one&&_ispresent(temp->one,l,r))
        {
            return _maxxor(temp->one,l,r,num,mask>>1);
        }
        else
        {
            return _maxxor(temp->zero,l,r,num,mask>>1);
        }
    }
    else
    {
        if(temp->zero&&_ispresent(temp->zero,l,r))
        {
            return _maxxor(temp->zero,l,r,num,mask>>1);
        }
        else
        {
            return _maxxor(temp->one,l,r,num,mask>>1);
        }
    }
}

int main()
{
    int m,x,l,r;
    int tp,mask;

    S(m);
    while(m--)
    {
        S(tp);
        if(tp==0||tp==2)
        {
            mask=(1<<19);
            S(x);

            if(tp==0)
            {
                data.push_back(x);
                root=_insert(root,x,mask,(int)data.size());
            }
            else
            {
                F(i,0,x)
                {

                    root=_delete(root,data.back(),mask);
                    data.pop_back();
                }
            }
            //printf("\n");
        }
        else
        {
            int ans=0;
            S(l);
            S(r);
            S(x);
            if(tp==1)
            {
                ans=data[_maxxor(root,l,r,x,1<<18)-1];
            }
            else if(tp==3)
            {
                ans=_countnum(root,l,r,x,1<<18);
            }
            else
            {
                ans=data[_kthsmall(root,l,r,x)-1];
            }
            //printf("\n");
            P(ans);

        }
    }
    return 0;
}
