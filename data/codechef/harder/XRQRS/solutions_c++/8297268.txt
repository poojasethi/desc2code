#include<cstdio>
#define N 500005
using namespace std;
inline void I(int &a)
{
 register int c;
 a=0;
 do c=getchar_unlocked(); while(c<'0');
 do
 {
  a=(a<<1)+(a<<3)+c-'0';
  c=getchar_unlocked();
 }while(c >= '0');
}
inline void O(int a)
{
 register char s[21];
 register int t=-1;
 do s[++t]=a%10+'0',a/=10; while(a>0);
 while(t>=0) putchar_unlocked(s[t--]);
 putchar_unlocked('\n');
}
struct node
{
 int ch[2],sum;
}t[N*20];
int root[N],cnt;
int add_node(int sum,int l,int r)
{
    cnt++;
    t[cnt].ch[0]=l;
    t[cnt].ch[1]=r;
    t[cnt].sum=sum;
    return cnt;
}
void ins(int rt,int pre_rt,int x)
{
    int i,k;
    for(i=20;i>=0;i--)
    {
        k=(x>>i)&1;
        t[rt].ch[k]=add_node(t[t[pre_rt].ch[k]].sum+1,t[t[pre_rt].ch[k]].ch[0],t[t[pre_rt].ch[k]].ch[1]);
        rt=t[rt].ch[k];
        pre_rt=t[pre_rt].ch[k];
    }
}
int query(int l,int r,int x)
{
    int k,ret=0,i;
    for(i=20;i>=0;i--)
    {
        k=(x>>i)&1;
        if(t[t[r].ch[k^1]].sum-t[t[l].ch[k^1]].sum!=0)
        {
            ret+=(1<<i);
            r=t[r].ch[k^1],l=t[l].ch[k^1];
        }
        else
            r=t[r].ch[k],l=t[l].ch[k];
    }
    return ret;
}
int qnum(int l,int r,int x)
{
    int k,ret=0,i;
    for(i=20;i>=0;i--)
    {
        k=(x>>i)&1;
        if(k==1){
            ret+=t[t[r].ch[0]].sum-t[t[l].ch[0]].sum;
        }
        if(t[t[r].ch[k]].sum-t[t[l].ch[k]].sum)
            r=t[r].ch[k],l=t[l].ch[k];
        else
            break;
    }
    return ret;
}
int qval(int l,int r,int x)
{
    int ret=0,i,k,sum;
    for(i=20;i>=0;i--)
    {
        k=(x>>i)&1;
        sum=t[t[r].ch[0]].sum-t[t[l].ch[0]].sum;
        if(x<=sum)
            r=t[r].ch[0],l=t[l].ch[0];
        else
        {
            x-=sum;
            r=t[r].ch[1],l=t[l].ch[1];
            ret+=(1<<i);
        }
    }
    return ret;
}
int main()
{
    int q,l,r,x,op,n;
    I(q);
    n=cnt=0;
    while(q--)
    {
        I(op);
        if(op==0)
        {
            n++;
            root[n]=add_node(t[root[n-1]].sum+1,t[root[n-1]].ch[0],t[root[n-1]].ch[1]);
            I(x);
            ins(root[n],root[n-1],x);
        }
        else if(op==1)
        {
            I(l);I(r);I(x);
            O(x^query(root[l-1],root[r],x));
        }
        else if(op==2)
        {
            I(x);
            n-=x;
        }
        else if(op==3)
        {
           I(l);I(r);I(x);
           O(qnum(root[l-1],root[r],x+1));
        }
        else
        {
            I(l);I(r);I(x);
            O(qval(root[l-1],root[r],x));
        }
    }
}
