#include<stdio.h>
#define LL long long
const int maxe = 1e3+3;
const int mod = 1e9 + 7;
int T, N, M, L, R;
int yinzi[maxe][10];
bool isprime[maxe];
LL quitpow(LL n, LL m)  //快速幂求n^m
{
    LL res = 1, k = n%mod;
    while (m)
    {
        if (m & 1) res = (res*k) % mod;
        m >>= 1;
        k = (k*k) % mod;
    }
    return res;
}
void init()  //分解1000以内的因子
{
    for (int i = 2; i < maxe; i++){
        if(!isprime[i]){
            for(int j = i; j < maxe; j+=i)
            {
                isprime[j]=1;
                int &t = yinzi[j][0];
                int b=1,x=j;
                while(x%i==0) b*=i,x/=i;
                yinzi[j][++t]=b;
            }
        }
    }
}
int len,c,s[10];
LL dfs2(int in,int n,LL b)  //第二层容斥
{
    LL res=0;
    for(int i=in;i<=n;i++)
        res+=b/s[i]-dfs2(i+1,n,b/s[i]);
    return res;
}
LL dfs(int deep,int in,LL b) //容斥
{
    LL res = 0;
    for(int i=in;i<=len;i++)
    {
        s[deep]=yinzi[c][i];
        LL k = M-dfs2(0,deep,M);
        res = (res + quitpow(k, N) - dfs(deep+1, i+1, b*yinzi[c][i]))%mod;
    }
    return res;
}
int main()
{
    init();
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d%d%d", &N, &M, &L, &R);
        LL ans = 0;
        LL allsum = quitpow(M,N);
        for(int i=L;i<=R;i++)
        {
            len=yinzi[i][0],c=i;
            ans = (ans + (allsum - dfs(0, 1, 1))%mod)%mod;
        }
        printf("%lld\n", (ans+mod)%mod);
    }
    return 0;
}
