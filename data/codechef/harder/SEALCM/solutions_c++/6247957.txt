#include<bits/stdc++.h>
using namespace std;

const int md=1e9+7;
const int N=1010;
typedef long long ll;

int n,m,l,r;
map<int,int>G[N];

ll modpow(ll a,ll b) {
    if(b==0) {
        return 1ll;
    }
    ll p=modpow(a,b/2);
    p=p*p%md;
    if(b&1) {
        p=p*a%md;
    }
    return p;
}
void preprocess() {
    for(int i=1;i<N;i++) {
        int x=i;
        for(int prime=2;prime*prime<=x;prime++) {
            int cnt=0;
            while(x%prime==0) {
                x/=prime;
                cnt++;
            }
            if(cnt) {
                G[i][prime]=cnt;
            }
        }
        if(x>1) {
            G[i][x]=1;
        }
    }
    return;
}
int g[1<<5];
int solve(int d) {
    map<int,int>& store=G[d];
    vector<int>F;
    for(map<int,int>::iterator it=store.begin();it!=store.end();it++) {
        F.push_back(it->first);
    }
    int factors=F.size();
    memset(g,0,sizeof(g));
    for(int mask=0;mask<(1<<factors);mask++) {
        for(int i=1;i<=m;i++) {
            g[mask]++;
                for(int bit=0;bit<factors;bit++) {
                if(mask&(1<<bit)) {
                    if(G[i].count(F[bit])==0) {
                    } else if(G[i][F[bit]]<store[F[bit]]) {
                    } else {
                        g[mask]--;
                        break;
                    }
                }
            }
        }
    }
    ll ret=0;
    for(int mask=0;mask<(1<<factors);mask++) {
        ll here=modpow(g[mask],n);
        int bitcount=__builtin_popcount(mask);
        if(bitcount%2) {
            here=-here;
        }
        ret=ret+here;
        ret=(ret+md)%md;
    }
    return ret;
}
int main() {
    preprocess();
    int tt;
    scanf("%d",&tt);
    while(tt--) {
        scanf("%d%d%d%d",&n,&m,&l,&r);
        ll ans=0;
        for(int i=l;i<=r;i++) {
            ll here=solve(i);
            ans=ans+here;
            if(ans>=md) {
                ans-=md;
            }
        }
        printf("%lld\012",ans);
    }
    return 0;
}
