#include <bits/stdc++.h>
using namespace std;

#define PB push_back
#define MP make_pair
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
#define si(a) scanf("%d", &a)
#define sl(a) scanf("%lld", &a)
#define sd(a) scanf("%lf", &a)
#define sii(a, b) scanf("%d%d", &a, &b)
#define sll(a, b) scanf("%lld%lld", &a, &b)
#define sdd(a, b) scanf("%lf%lf", &a, &b)

const Long mod = 1000000007;
int N, M, L, R;

struct Matrix {
   #define MAXD (1<<4)
   int dim;
   Long val[MAXD][MAXD];

   Matrix(int dim) { this->dim = dim; }
   void unit() {
      mem(val, 0);
      REP(i, dim) val[i][i] = 1;
   }
   void print() {
      REP(i, dim) REP(j, dim) {
         if(!j) printf("\n%d", val[i][j]);
         else printf(" %d", val[i][j]);
      }
      puts("");
   }
   Matrix operator * (Matrix &B)
   {
      Matrix ret(this->dim);
      REP(i, dim) REP(j, dim) {
         Long sum = 0;
         REP(k, dim) sum = (sum + (val[i][k]*B.val[k][j]) % mod) % mod;
         ret.val[i][j] = sum;
      }
      return ret;
   }
};

Matrix bigmod(Matrix A, int pow)
{
   Matrix ret(A.dim);
   ret.unit();
   while(pow > 0) {
      if(pow & 1) ret = ret*A;
      A = A*A;
      pow >>= 1;
   }
   return ret;
}

#define MAX 1002
vector <int> prime;
vector < Pii > Cnt[MAX];
void seive()
{
   bool work[MAX];
   mem(work, true);
   ITR(i, 2, MAX) {
      if(!work[i]) continue;
      prime.PB(i);
      for(int j = i*i; j < MAX; j += i) work[i] = false;
   }
   ITR(i, 2, MAX) {
      int pos = 0, num = i;
      while(pos < prime.SZ && prime[pos] <= num) {
         if(num % prime[pos] != 0) {
            pos++;
            continue;
         }
         int cnt = 0;
         while(num % prime[pos] == 0) {
            cnt++;
            num /= prime[pos];
         }
         Cnt[i].PB(MP(prime[pos], cnt));
         pos++;
      }
      if(num > 1) Cnt[i].PB(MP(num, 1));
   }
}

int find(int pr, int num)
{
   REP(i, Cnt[num].SZ) if(Cnt[num][i].Fr == pr) return Cnt[num][i].Sc;
   return 0;
}

void initialize(Matrix &A, int D)
{
   mem(A.val, 0);
   REP(i, A.dim) {
      ITR(num, 1, M+1) {
         int msk = i;
         REP(j, Cnt[D].SZ) {
            int f = find(Cnt[D][j].Fr, num);
            if(f >= Cnt[D][j].Sc) msk |= (1<<j);
         }
         A.val[i][msk]++;
      }
   }
   //printf("D: %d dim: %d", D, A.dim);
   //A.print();
}

int main_()
{
   cin >> N >> M >> L >> R;
   Long ret = 0;
   //if(L == 1) ret++, L++;
   while(L <= R) {
      int dim = 1<<(int)Cnt[L].SZ;
      Matrix A(dim);
      initialize(A, L);
      A = bigmod(A, N);
      //printf("here: ");
      //A.print();
      ret = (ret + A.val[0][dim-1]) % mod;
      L++;
   }
   cout << ret << '\n';
}

int main()
{
   ios_base::sync_with_stdio(0); cin.tie(0);
   int t;
   cin >> t;
   seive();
   while(t--) main_();
   return 0;
}
/*
1
5 5 1 5
*/

// remember to add exception for 1
