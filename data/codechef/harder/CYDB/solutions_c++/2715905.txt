#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<cstdio>
#include<ctime>
#include<cctype>
#include<cassert>
#include<climits>
#include<cerrno>
#include<cfloat>
#include<ciso646>
#include<clocale>
#include<csetjmp>
#include<csignal>
#include<cstdarg>
#include<cstddef>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<cwchar>
#include<cwctype>

//containers
#include<vector>
#include<list>
#include<map>
#include<queue>
#include<deque>
#include<set>
#include<complex>
#include<string>
#include<stack>
#include<bitset>
#include<istream>
#include<valarray>

//IOs
#include<iostream>
#include<sstream>
#include<iomanip>
#include<fstream>
#include<exception>
#include<ios>
#include<iosfwd>
#include<ostream>
#include<iterator>
#include<stdexcept>
#include<streambuf>


//algorithm & miscellaneous
#include<algorithm>
#include<functional>
#include<numeric>
#include<utility>
#include<limits>
#include<locale>
#include<memory>
#include<new>

#define ll long long
#define ull unsigned long long
#define ld long double
#define mp make_pair
#define pb push_back
#define inf (ll)1e18
#define iinf (int)1e9
#define triple(a,b,c) make_pair(a,make_pair(b,c))
#define two(a,b) make_pair(a,b)
#define fi first
#define se second
#define pii pair<int,int>
#define pll pair<long long,long long>
#define psi pair<string,int>
#define pis pair<int,string>
#define pss pair<string,string>
//#define vi vector<int>
#define vl vector<long long>
#define vs vector<string>
#define vc vector<char>
#define vpii vector<pii>
#define GI ({int t;scanf("%d",&t);t;})
#define GD ({double t;scanf("%lf",&t);t;})
#define GF ({float t;scanf("%f",&t);t;})
#define GL ({long long t;scanf("%lld",&t);t;})
#define GLD ({long double t;scanf("%Lf",&t);t;})
#define clear(c,v) memset(c,v,sizeof(c))


int dx[] = {-1,0,0,1,-1,-1,1,1};
int dy[] = {0,-1,1,0,-1,1,-1,1};
const double eps = 1e-9;

using namespace std;

const int mw = 1, mwl = 1000001, mwp = 10000001, mc = 2;
const ll mod = 1000000007ll;

//int actrie[mwl*mw][mc], nm[mwl*mw][mc], fail[mwl*mw], score[mwl*mw], cnt[mwl*mw], indeg[mwl*mw], pos = 1, wd = 0;

int wlen, tlen, wlen1, tlen1 ;
//vector<int> outp[mwl*mw];

char a[mwl], b[mwp], c[mwl], na[mwl], nb[mwp], nc[mwl];
map<int,string> bin;

class node
{
    public:
            int len, score;
            node *go[2],*fail;
            node()
            {
                    len = 0,score = 0, fail = 0,go[0] = 0,go[1] = 0;
            }
};

inline int sqr(int x)
{
        return x*x;
}

inline int id(char c)
{
        if(c >= 'A' and c <= 'F')
                return c - 65 + 26;
        return c - 97;
}

void insert(node *n,int cur,int k)
{
                for(int i=cur;i<wlen;i++)
                {
                        if(c[i] == '1' and k<2)
                        {
                                             for(int j=0;j<mc;j++)
                                             {
                                                     n->go[j] = new node();
                                                     n->go[j]->len = n->len + 1;
                                                     insert(n->go[j], i+1, k+(j!=(a[i] - '0')));
                                             }
                                             break;
                        }
                        else
                        {
                                            int ch = a[i]-'0';
                                            n->go[ch] = new node();
                                            n->go[ch]->len = n->len + 1;
                                            n = n->go[ch];
                        }
                }
                return ;
}

void maketransitions()
{
                node *root = new node();

                insert(root,0,0);

                queue<node*> q;

                for(int i=0;i<mc;i++)
                {
                        if(root->go[i])
                        {
                                        q.push(root->go[i]);
                                        root->go[i]->fail = root;
                                        root->go[i]->score = sqr(root->go[i]->len);
                        }
                        else root->go[i] = root;
                }

                while(!q.empty())
                {
                                 node *cur = q.front();q.pop();

                                 for(int i=0;i<mc;i++)
                                         if(cur->go[i])
                                         {

                                                              q.push(cur->go[i]);

                                                              node *tmp = cur->fail;
                                                              node *tmp2 = cur->go[i];

                                                              while(!(tmp->go[i]))
                                                                                   tmp = tmp->fail;

                                                              tmp2->fail = tmp->go[i];
                                                              tmp2->score = tmp2->fail->score + sqr(tmp2->len);

                                                              //for(int j=0;j<(int)outp[fail[actrie[cur][i]]].size();j++)
                                                                //      outp[actrie[cur][i]].push_back(outp[fail[actrie[cur][i]]][j]);
                                         }
                }


                node *rt = root;

                ll res = 0;

                for(int i=0;i<tlen;i++)
                {
                        int ch = b[i] - '0';

                        while(!(rt -> go[ch]))
                                rt = rt->fail;

                        rt = rt->go[ch];

                        res += rt->score;
                }

                printf("%lld\n",res%mod);
}

string bina(int x)
{
        string res;
        while(x)
        {
                res += (char)((x%2) + '0');
                x/=2;
        }

        reverse(res.begin(),res.end());
        string add;
        for(int i=0;(i+res.size())<5;i++)
                add += '0';
        return add + res;
}
void decode()
{
        int st = 0;

        for(int i=0;i<wlen1;i++)
        {
                    string s = bin[id(na[i])];
                    for(int j=0;j<(int)s.size();j++)
                            a[st++] = s[j];
        }

        wlen = st;

        st = 0;

        for(int i=0;i<tlen1;i++)
        {
                    string s = bin[id(nb[i])];
                    for(int j=0;j<(int)s.size();j++)
                            b[st++] = s[j];
        }

        tlen = st;

        st = 0;

        for(int i=0;i<wlen1;i++)
        {
                    string s = bin[id(nc[i])];
                    for(int j=0;j<(int)s.size();j++)
                            c[st++] = s[j];
        }

        //cout<<a<<" "<<b<<" "<<c<<"\n";
        return ;
}
int main()
{
          for(int i=0;i<32;i++)
                bin[i] = bina(i);
          scanf("%s",na);
          wlen1 = strlen(na);
          scanf("%s",nb);
          tlen1 = strlen(nb);
          scanf("%s",nc);

          decode();
          maketransitions();


          scanf("\n");
          return 0;
}
