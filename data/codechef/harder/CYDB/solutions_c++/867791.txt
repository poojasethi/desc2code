#include <cassert>
#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <climits>
#include <cstddef>
#include <cctype>
#include <cmath>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <iterator>
#include <numeric>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <list>
#include <string>
#include <functional>
#include <utility>
using namespace std;
typedef long long llint;
int const L1 = 1000;
int const L2 = 10000000;
int const F = 5;
int const S = 1000000;
int const A = 2;
int const D = 2;
int const MOD = 1000000007;
int go[S][A];
int fail[S];
int score[S];
int num;
int root;
char a[L1 + 10], b[L2 + 10], c[L1 + 10];
int na, nb, nc;
int res;
bool readin() {
	return scanf("%s%s%s", a, b, c) != EOF;
}
void decode(char *s, int &n) {
	int l = strlen(s);
	int i, j, k;
	n = l * F;
	for (i = l - 1; i >= 0; --i) {
		j = islower(s[i]) ? (s[i] - 'a') : (s[i] - 'A' + 26);
		for (k = 0; k < F; ++k) {
			s[(i + 1) * F - k - 1] = '0' + (j % 2);
			j /= 2;
		}
	}
	s[n] = '\0';
}
void addWord(int cur, char *s, int pos = 0, int cnt = 0) {
	int ch;
	score[cur] = pos * pos;
	if (s[pos] == '\0') {
		return;
	}
	if (c[pos] == '1' && cnt < D) {
		for (ch = 0; ch < A; ++ch) {
			go[cur][ch] = num++;
			addWord(go[cur][ch], s, pos + 1,
				cnt + (((s[pos] - '0') != ch) ? 1 : 0));
		}
	} else {
		ch = s[pos] - '0';
		go[cur][ch] = num++;
		addWord(go[cur][ch], s, pos + 1, cnt);
	}
}
void buildTrie() {
	memset(go, -1, sizeof(go));
	root = 0;
	num = 1;
	addWord(root, a);
}
void acmatch() {
	queue <int> q;
	int u, v, t;
	int ch;
	memset(fail, -1, sizeof(fail));
	for (ch = 0; ch < A; ++ch) {
		if (go[root][ch] != -1) {
			fail[go[root][ch]] = root;
			q.push(go[root][ch]);
		} else {
			go[root][ch] = root;
		}
	}
	while (!q.empty()) {
		u = q.front();
		q.pop();
		for (ch = 0; ch < A; ++ch) {
			if (go[u][ch] != -1) {
				v = go[u][ch];
				q.push(v);
				t = fail[u];
				while (go[t][ch] == -1) {
					t = fail[t];
				}
				fail[v] = go[t][ch];
				score[v] = (score[v] + score[fail[v]]) % MOD;
			}
		}
	}
}
void solve() {
	int i, j;
	decode(a, na);
	decode(b, nb);
	decode(c, nc);
	buildTrie();
	acmatch();
	res = 0;
	for (j = root, i = 0; i < nb; ++i) {
		while (go[j][b[i] - '0'] == -1) {
			j = fail[j];
		}
		j = go[j][b[i] - '0'];
		res = (res + score[j]) % MOD;
	}
	printf("%d\n", res);
}
int main() {
	while (readin()) {
		solve();
	}
	return 0;
}
