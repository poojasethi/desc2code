#define _CRT_SECURE_NO_WARNINGS
//#define VERBOSE
//#define VERY_VERBOSE
 
#include <sys/types.h>
#include <regex.h>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <list>
#include <complex>
#include <queue>
#pragma comment(linker, "/STACK:266777216")
using namespace std;
 
#define assert(f) { if(!(f)) { fprintf(stderr,"Assertion failed: "); fprintf(stderr,#f); fprintf(stderr,"\n"); exit(1); } }
 
typedef long long LL;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<double> VD;
typedef pair<double,double> PDD;
 
#define pb push_back
#define sz size()
#define cl clear()
#define all(a) (a).begin(),(a).end()
#define fill(ar,val) memset((ar),(val),sizeof (ar))
 
clock_t start=clock();
//fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));
 
// since we do a lot of transforms with regexp
// the length is chosen large for safe
const int LEN = 101010;
int n;
char s[LEN];
bool valid;
char w[LEN];
int pos; // needed for recursive parsing
 
bool isParen(char c) {
  return c=='(' || c==')';
}
 
bool isSepar(char c) {
  return c==' ' || c=='(' || c==')';
}
 
bool isAlp(char c) {
  return '0'<=c && c<='9' || 'A'<=c && c<='Z' || c=='-';
}
 
// read regexp and add leading and trailing space
void read_regexp() {
  //fill(s,0);
  s[0]=' ';
  gets(s+1);
  n = strlen(s);
  assert(s[n-1]!=13);
  //if(s[n-1]==13) s[--n]=0;
  s[n++]=' ';
  s[n]=0;
  valid=true;
  assert(n<=1002);
  for(int i=0;i<n;i++)
    assert(isSepar(s[i]) || isAlp(s[i]) || 'a'<=s[i] && s[i]<='z');
}
 
void adjust_spaces() {
  // add spaces around parantheses
  //fill(w,0);
  int j=0;
  for(int i=0;i<n;i++)
  {
    char c = s[i];
    if(isParen(c)) w[j++]=' ';
    w[j++]=c;
    if(isParen(c)) w[j++]=' ';
  }
  w[n=j]=0;
  //fill(s,0);
  strcpy(s,w);
 
  // delete double spaces
  //fill(w,0);
  j=0;
  for(int i=0;i<n;i++)
    if(i==0 || s[i]!=' ' || s[i-1]!=' ') w[j++]=s[i];
  w[n=j]=0;
  //fill(s,0);
  strcpy(s,w);
#ifdef VERBOSE
  fprintf(stderr,"%s\n",s);
#endif
}
 
bool isStr(const string& p) {
  for(int i=0;i<p.sz;i++)
    if(!isAlp(p[i])) return false;
  return true;
}
 
int getN(const string& s) {
  int L = s.sz;
  if(L<1 || L>2 || s[0]=='0') return 0;
  int N=0;
  for(int i=0;i<L;i++)
  {
    char c=s[i];
    if(c<'0' || c>'9') return 0;
    N=10*N+c-'0';
  }
  return 2<=N && N<=12 ? N : 0;
}
 
string getBlock(int i) {
  string res = "";
  for(;i<n && s[i]!=' ';i++)
    res += s[i];
  assert(i<n && s[i]==' ');
  return res;
}
 
bool valid_to(char c1, char c2)
{
  if('0'<=c1 && c1<=c2 && c2<='9') return true;
  if('A'<=c1 && c1<=c2 && c2<='Z') return true;
  return false;
}
 
string range(char c1, char c2) {
  assert(valid_to(c1,c2));
  string s="[";
  s+=c1;
  s+='-';
  s+=c2;
  s+="]";
  return s;
}
 
string concat(const string& w) {
  if(w.sz==1) return w;
  string s="(";
  for(int i=0;i<w.sz;i++)
  {
    assert(isAlp(w[i]));
    s += w[i];
    s += i<w.sz-1 ? '+' : ')';
  }
  return s;
}
 
// Checking all space separated blocks for correctness and
// replacing sub-formats as follows:
// usual string s[0]...s[L] -> (s[0]+...+s[L])
// "optional" -> "?"
// "N times" -> "N'", where N'=N-1+'a'
// "or" -> "|"
// "a to b" -> "[a-b]"
// "digit" -> "[0-9]"
// "letter" -> "[A-Z]"
// "upto N digits" -> "[0-9]?N'"
// "exactly N digits" -> "[0-9]N'"
// "upto N letters" -> "[A-Z]?N'"
// "exactly N letters" -> "[A-Z]N'"
// Note that N' is the only possible occurence of small latins in regexp after this
void global_cleanup() {
  //fill(w,0);
  int j=0;
  for(int i=0;i<n;) {
    if(isSepar(s[i])) {
      w[j++]=s[i++];
    } else {
      string p = getBlock(i);
      i += p.sz;
      string t = "";
      if(p=="optional") {
        t = "?"; 
      } else if(p=="or") {
        t = "|";
      } else if(p=="digit") {
        t = range('0', '9');
      } else if(p=="letter") {
        t = range('A', 'Z');
      } else if(p=="upto" || p=="exactly") {
        i++;
        string sN = getBlock(i);
        i += sN.sz;
        int N = getN(sN);
        if(!N) { valid=false; break; }
        i++; // skip space after N
        if(strncmp(s+i,"digits ",7)==0) {
          t += range('0','9');
          i += 6;
        } else if(strncmp(s+i,"letters ",8)==0) {
          t += range('A','Z');
          i += 7;
        } else {
          valid=false;
          break;
        }
        if(p=="upto") t+="?";
        t+=char(N-1+'a');
      } else if(strncmp(s+i," times ", 7)==0) {
        int N = getN(p);
        if(!N) { valid=false; break; }
        t = N-1+'a';
        i += 6;
      } else if(strncmp(s+i," to ",4)==0) {
        i+=4;
        string q = getBlock(i);
        i += q.sz;
        if(p.sz!=1 || q.sz!=1) { valid=false; break; }
        if(!valid_to(p[0], q[0])) { valid=false; break; }
        t = range(p[0],q[0]);
      } else if(isStr(p)) {
        t = concat(p);
      } else {
        valid=false;
        break;
      }
      strcpy(w + j, t.c_str());
      j += t.sz;
    }
  }
  w[n=j]=0;
  //fill(s,0);
  strcpy(s,w);
#ifdef VERBOSE
  fprintf(stderr,"%s\n",s);
#endif
}
 
// delete unnessecary spaces and replace needed one by '+'
void concat_cleanup() {
  //fill(w,0);
  int j=0;
  for(int i=0;i<n;i++) {
    if(s[i]!=' ') {
      w[j++]=s[i]; 
    } else if(i>0 && i+1<n) {
      char c = s[i-1];
      if(c=='(' || c=='|') continue;
      c = s[i+1];
      if(c==')' || c=='|' || c=='?' || 'a'<=c && c<='z') continue;
      w[j++]='+';
    }
  }
  w[n=j]=0;
  //fill(s,0);
  strcpy(s,w);
#ifdef VERBOSE
  fprintf(stderr,"%s\n",s);
#endif
}
 
const int maxQ = 1000;
const int maxL = 2001;
int Q;
char quers[maxQ][maxL];
 
void read_queries() {
  scanf("%d ",&Q);
  assert(0<=Q && Q<=maxQ);
  for(int q=0;q<Q;q++)
    gets(quers[q]);
}
 
bool isUnar(char c) {
  return c=='?' || 'a'<=c && c<='z';
}
 
int calcSum();
 
int calcAtom() {
  if(pos==n) valid = false;
  if(!valid) return 0;
  int ans=0;
  if(s[pos]=='(')
  {
    pos++;
    ans = calcSum();
    if(s[pos]!=')') valid=false;
    pos++;
  } else if(s[pos]=='[') {
    assert(valid_to(s[pos+1],s[pos+3]));
    assert(s[pos+2]=='-');
    assert(s[pos+4]==']');
    ans = 1;
    pos += 5;
  } else if(isAlp(s[pos])) {
    ans = 1;
    pos++;
  } else {
    valid = false;
  }
  if(!valid) return 0;
  for(;pos<n && isUnar(s[pos]);pos++)
    if(s[pos]!='?')
      ans = min(ans * (s[pos]-'a'+1), maxL);
  return ans;
}
 
int calcOr() {
  int ans = 0;
  while(valid) {
    ans = max(ans, calcAtom());
    if(pos==n || s[pos]==')' || s[pos]=='+')  break;
    if(s[pos]=='|') {
      pos++;
    } else {
      valid = false;
    }
  }
  return ans;
}
 
int calcSum() {
  int ans = 0;
  while(valid) {
    ans = min(ans + calcOr(), maxL);
    if(pos==n || s[pos]==')')  break;
    if(s[pos]=='+') {
      pos++;
    } else {
      valid = false;
    }
  }
  return ans;
}
 
string fixSum();
 
string fixAtom() {
  string res = "";
  if(s[pos]=='(')
  {
    res += s[pos++];
    res += fixSum();
    res += s[pos++];
  } else if(s[pos]=='[') {
    for(int j=0;j<5;j++)
      res += s[pos++];
  } else {
    res += s[pos++];
  }
  for(;pos<n && isUnar(s[pos]);pos++)
  {
    res = "(" + res + ")";
    res += s[pos];
  }
  return "(" + res + ")";
}
 
string fixOr() {
  string res = "";
  while(true) {
    res += fixAtom();
    if(pos==n || s[pos]==')' || s[pos]=='+')  break;
    res += s[pos++];
  }
  return "(" + res + ")";
}
 
string fixSum() {
  string res = "";
  while(true) {
    res += fixOr();
    if(pos==n || s[pos]==')') break;
    res += s[pos++];
  }
  return "(" + res + ")";
}
 
void fixing_prior() {
  pos=0;
  string news = fixSum();
  strcpy(s, news.c_str());
  n=news.sz;
}
 
void convert_to_POSIX()
{
  int j=0;
  w[j++]='^';
  for(int i=0;i<n;i++)
    if('a'<=s[i] && s[i]<='z') {
      int N = s[i]-'a'+1;
      w[j++] = '{';
      if(N >= 10) w[j++] = N/10 + '0';
      w[j++] = N%10 + '0';
      w[j++] = '}';
    } else if(s[i]!='+') {
      w[j++] = s[i];
    }
  w[j++]='$';
  w[n=j]=0;
  strcpy(s,w);
#ifdef VERBOSE
  fprintf(stderr,"%s\n",s);
#endif
}
 
int main()
{
#ifndef ONLINE_JUDGE
  freopen("cpp.in","r",stdin);
  //freopen("out.txt","w",stdout);
#endif
  int TST;
  scanf("%d ",&TST);
  for(int tst=0;tst<TST;tst++)
  {
    read_regexp();
    adjust_spaces();
    // Now each '(' or ')' is surrounded by spaces,
    // s has no double spaces, but have one leading and one trailing space
    assert(s[0]==' ' && s[n-1]==' ');
    for(int i=1;i<n;i++) assert(s[i]!=' ' || s[i-1]!=' ');
 
    read_queries();
 
    global_cleanup();
    if(!valid) { puts("Format does not conform\n"); continue; }
    concat_cleanup();
 
    // check maximal possible len
    pos=0;
    int maxlen = calcSum();
    if(pos < n) valid = false;
    if(!valid) { puts("Format does not conform\n"); continue; }
    fprintf(stderr,"maxlen=%d\n", maxlen);
    if(maxlen==maxL) { puts("Matches too long ID"); continue; }
 
    //puts(s);
    fixing_prior();
    //puts(s);
    convert_to_POSIX();
    fprintf(stderr, "w=%s\n", w);
    //puts(s);
 
    regex_t reg;
    regcomp(&reg, s, REG_EXTENDED|REG_NOSUB);
    for(int q=0;q<Q;q++) {
      int res = regexec(&reg, quers[q], unsigned(0), NULL, 0);
      assert(res==0 || res==REG_NOMATCH);
      puts(!res?"Valid-ID":"Invalid-ID");
    }
    printf("\n");
  }
  //while(clock() - start < 0.95 * CLOCKS_PER_SEC);
  return 0;
}
 