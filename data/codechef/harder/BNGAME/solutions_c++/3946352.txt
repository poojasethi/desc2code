//In the name of Allah
 
#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <algorithm>
#include <bitset>
#include <math.h>
#include <queue>
#include <map>
#include <set>
#include <limits.h>
#include <limits>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sstream>
#include <assert.h>
using namespace std;
 
const int MAXN = 500005;
 
int N, K;

int first[4 * MAXN], last[4 * MAXN];
bool empty[4 * MAXN];

struct lm7_el_bsr{
    void reset(){
        for(int i = 0; i < 4 * MAXN; i++)
            empty[i] = true;
    }
    void add(int i, int L, int R, int u){
        if(u < L || R < u)return;
        if(L == R){
            empty[i] = false;
            first[i] = last[i] = L;
            return;
        }
        
        int mid = (L + R) / 2;
        add(2 * i, L, mid, u);
        add(2 * i + 1, mid + 1, R, u);
        
        if(empty[2 * i] && empty[2 * i + 1]){
            empty[i] = true;
            return;
        }
        empty[i] = false;
        if(empty[2 * i]){
            first[i] = first[2 * i + 1];
            last[i] = last[2 * i + 1];
            return;
        }
        if(empty[2 * i + 1]){
            first[i] = first[2 * i];
            last[i] = last[2 * i];
            return;
        }
        if(first[2 * i] == -1 || last[2 * i] == -1){
            first[i] = -1;
            last[i] = -1;
            return;
        }
        if(first[2 * i + 1] - last[2 * i] <= K){
            first[i] = first[2 * i];
            last[i] = last[2 * i + 1];
            return;
        }
        first[i] = -1;
        last[i] = -1;
    }
    void remove(int i, int L, int R, int u){
        if(u < L || R < u)return;
        if(L == R){
            empty[i] = true;
            return;
        }
        
        int mid = (L + R) / 2;
        remove(2 * i, L, mid, u);
        remove(2 * i + 1, mid + 1, R, u);
        
        if(empty[2 * i] && empty[2 * i + 1]){
            empty[i] = true;
            return;
        }
        empty[i] = false;
        if(empty[2 * i]){
            first[i] = first[2 * i + 1];
            last[i] = last[2 * i + 1];
            return;
        }
        if(empty[2 * i + 1]){
            first[i] = first[2 * i];
            last[i] = last[2 * i];
            return;
        }
        if(first[2 * i] == -1 || last[2 * i] == -1){
            first[i] = -1;
            last[i] = -1;
            return;
        }
        if(first[2 * i + 1] - last[2 * i] <= K){
            first[i] = first[2 * i];
            last[i] = last[2 * i + 1];
            return;
        }
        first[i] = -1;
        last[i] = -1;
    }
    bool winnable(){
        if(empty[1])return false;
        int L = first[1], R = last[1];
        
        if(L - (-1) <= K && N - R <= K)return true;
        else return false;
    }
};
 
pair < pair <int, int>, int> A[MAXN];
int main(){
    scanf("%d %d", &N, &K);
    for(int i = 0; i < N; i++){
        scanf("%d %d", &A[i].first.first, &A[i].first.second);
        A[i].second = i;
    }
    sort(A, A + N);
    
    set < pair <int, int> > ax, bx;
 
    lm7_el_bsr d;
    
    memset(empty, true, sizeof empty);
    
    int res = -1;
    for(int i = 0; i < N; i++){
        ax.insert(make_pair(A[i].first.first, i));
        bx.insert(make_pair(A[i].first.second, i));
        d.add(1, 0, N - 1, A[i].second);
        
        while(d.winnable()){
            set < pair <int, int> > :: iterator ea = ax.end();
            ea--;
            set < pair <int, int> > :: iterator eb = bx.end();
            eb--;

            int cur = ((*(ea)).first) * ((*(eb)).first);
            if(res == -1 || cur < res)res = cur;
            
            int ind = (*(eb)).second;
            
            ax.erase(make_pair(A[ind].first.first, ind));
            bx.erase(make_pair(A[ind].first.second, ind));
            d.remove(1, 0, N - 1, A[ind].second);
        }
        
    }
    printf("%d\n", res);
    
    return 0;
} 