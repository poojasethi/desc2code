#include<map>
#include<cmath>
#include<math.h>
#include<time.h>
#include<iomanip>
#include<iostream>
#include<assert.h>
#include<algorithm>

using namespace std;

#define		MAX		200
#define		PI		(acos(-1.0))
#define		PII		pair<int,int>
#define		TIME	0

typedef		long long		ll;

PII p[MAX];

bool comp(pair<int,int> x,pair<int,int> y){
	float d1 = atan2(x.second*1.,x.first*1.);
	if (d1<0) d1+=2*PI;
	float d2 = atan2(y.second*1.,y.first*1.);
	if (d2<0) d2+=2*PI;
	return d1<d2;
}

int main(){

#if (TIME)
	srand(time(NULL));
#endif

	cin.sync_with_stdio(false);

	int xi,xj,xk,yi,yj,yk;
	ll ai,aj,ak,add;
	map<PII,ll> mp;

	int n;
#if (TIME)
	n = 150;
#else
	cin >> n;
#endif
	for (int i=0;i<n;i++){
#if (TIME)
		p[i].first = (rand()*rand())%1000000*(rand()%2?-1:1);
		p[i].second = (rand()*rand())%1000000*(rand()%2?-1:1);
#else
		cin >> p[i].first >> p[i].second;
#endif
	}
#if (TIME)
	clock_t start = clock();
#endif
	int x,y;
	sort(p,p+n,comp);
	for (int i=0;i<n;i++){
		ai = 0;
		xi = p[i].first;
		yi = p[i].second;
		mp[p[i]];
		for (int j=i;j<n;j++){
			xj = xi+p[j].first;
			yj = yi+p[j].second;
			add = ((ll)xi*yj-(ll)xj*yi);
			aj = ai+ add;
			ll &k = mp[PII(xj,yj)];
			k = max(k,aj);
			for (int k=j;k<n;k++){
				xk = xj+p[k].first;
				yk = yj+p[k].second;
				add = ((ll)xj*yk-(ll)xk*yj);
				ak = aj+ add;
				ll &r = mp[PII(xk,yk)];
				r = max(r,ak);
			}
		}
	}

	ll ma = 0;
	for (map<PII,ll>::iterator it = mp.begin(),nit;it!=mp.end();it++){
		if (it->first.first>0 && (nit = mp.find(PII(-it->first.first,-it->first.second)))!=mp.end())
			ma = max(ma,it->second+nit->second);
	}
	if (ma&1)
		cout << ma/2 << ".5" << endl;
	else
		cout << ma/2 << ".0" << endl;

#if (TIME)
	cout << ((double)clock()-start)/CLOCKS_PER_SEC << endl;
#endif
	return 0;
}