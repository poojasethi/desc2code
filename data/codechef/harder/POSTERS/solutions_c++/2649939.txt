#
#include<cstdio>
#
#include<queue>
#
#include<string.h>
#
#include<vector>
#
#include<algorithm>
#
using namespace std;
#
#define MAX 110
#
int T;
#
int N;
#
vector<int> Adj[MAX];
#
FILE *in;
#
struct rect
#
{
#
int x0,y0,x1,y1;
#
bool operator <(const rect&r)const{
#
return x0==r.x0?x1<r.x1:x0<r.x0;
#
}
#
};
#
rect A[MAX];
#
inline bool intersects(int i,int j)
#
{
#
rect x=A[i];
#
rect y=A[j];
#
//return true if x intersects y
#
if(x.x0 < y.x0 && x.x1 <= y.x0)
#
return false;
#
if(x.x0 >= y.x1 && x.x1 > y.x1)
#
return false;
#
if(x.y0 < y.y0 && x.y1 <= y.y0)
#
return false;
#
if(x.y0 >= y.y1 && x.y1 > y.y1)
#
return false;
#
 
#
return true;
#
}
#
inline void take_input()
#
{
#
for(int i=1;i<=N;i++)
#
{
#
int a,b,c,d;
#
fscanf(in,"%d %d %d %d",&a,&b,&c,&d);
#
A[i]=(rect){a,c,b,d};
#
}
#
//to ensure order among the bipartite we build
#
sort(A+1,A+N+1);
#
//prepare an adjacency list
#
for(int i=1;i<=N;i++)
#
{
#
for(int j=i+1;j<=N;j++)
#
{
#
if(intersects(i,j))
#
Adj[i].push_back(j);
#
}
#
}
#
}
#
int Mx[MAX];
#
int My[MAX];
#
int Dx[MAX];
#
int Dy[MAX];
#
bool hk_dfs(int u)
#
{
#
for(int i=0;i<Adj[u].size();i++)
#
{
#
int v=Adj[u][i];
#
if(Dy[v]==Dx[u]+1)
#
{
#
Dy[v]=0;
#
if( (My[v]==-1) || hk_dfs(My[v]))
#
{
#
Mx[u]=v;
#
My[v]=u;
#
return true;
#
}
#
}
#
}
#
return false;
#
}
#
 
#
bool hk_bfs()
#
{
#
int Q[MAX];
#
int qi,qf;
#
qi=1;qf=0;
#
for(int i=1;i<=N;i++)
#
{
#
if(Mx[i]==-1)
#
Q[++qf]=i;
#
Dx[i]=0;
#
Dy[i]=0;
#
}
#
bool res=false;
#
while(qi<=qf)
#
{
#
int u=Q[qi++];
#
for(int i=0;i<Adj[u].size();i++)
#
{
#
int v=Adj[u][i];
#
if(Dy[v]==0)
#
{
#
Dy[v]=Dx[u]+1;
#
if(My[v]==-1)
#
res=true;
#
else
#
{
#
Dx[My[v]]=Dy[v]+1;
#
Q[++qf]=My[v];
#
}
#
}
#
}
#
}
#
return res;
#
}
#
int hopcraft()
#
{
#
int res=0;
#
memset(Mx,-1,sizeof(Mx));
#
memset(My,-1,sizeof(My));
#
while(hk_bfs())
#
{
#
for(int i=1;i<=N;i++)
#
res+=(Mx[i]==-1 && hk_dfs(i));
#
}
#
return res;
#
}
#
int main()
#
{
#
in=fopen("posters.txt","r");
#
in=stdin;
#
fscanf(in,"%d",&T);
#
while(T--)
#
{
#
fscanf(in,"%d",&N);
#
for(int i=0;i<MAX;i++)
#
Adj[i].clear();
#
take_input();
#
printf("%d\n",N-hopcraft());
#
}
#
return 0;
#
}