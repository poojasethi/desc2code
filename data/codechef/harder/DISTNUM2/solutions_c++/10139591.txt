#include <bits/stdc++.h>
#define lli unsigned long long
#define MAX 100005
#define bktSize 502
#define bkts 205

using namespace std;

struct node {

	lli A[1600];
	
	void init() {
		for ( int i = 0; i < 1600; i++ ) A[i] = 0;
	}
	
	void set(int x)
	{
		A[x/ 64] |= (1ULL << (x%64));
		return;
	}

	int Kth(int k)
	{
		int cnt = 0;
		for ( int i = 0; i < 1600; i++ ) {
			if ( cnt + (__builtin_popcountll(A[i])) >= k ) {
				for ( int j = 0; j < 64; j++ ) {
					if ( (A[i] & (1ULL << j)) > 0 ) cnt++;
					if ( cnt == k ) return i*64 + j;
				}
			}
			cnt += __builtin_popcountll(A[i]);
		}
		return -1;
	}
	
}bktVal[bkts], bktInRange[bkts][bkts];
int P[MAX], acVal[MAX];

node OR(node A, node B)
{
	node C;
	for ( int i = 0; i < 1600; i++ ) C.A[i] = A.A[i] | B.A[i];
	return C;
}

void pre(int n)
{
	assert((n - 1)/bktSize >= 0 && (n - 1)/bktSize <= 200);
	for ( int i = 0; i < n; i++ ) bktVal[i/bktSize].set(P[i]);
	for ( int i = 0; i <= (n - 1)/bktSize; i++ ) {
		bktInRange[i][i] = bktVal[i];
		for ( int j = i + 1; j <= (n - 1)/bktSize; j++ ) bktInRange[i][j] = OR(bktInRange[i][j - 1], bktVal[j]);
	}
	return;
}

//Code for FAST INPUT :)
template <typename T>
inline void fi(T *a)
{
    register char c=0;
    while (c<33) c=getchar_unlocked();
    *a=0;
    int tmp = 0;
    while (c>33)
    {
        if ( c == 45 ) tmp = 1;
        else *a=*a*10+c-'0';
        c=getchar_unlocked();
    }
    if ( tmp == 1 ) *a = 0-(*a);
}

int main()
{
	int n, q, cnt = 0, l, r, k;;
	lli a, b, c, d, ans = 0;
	map <int, int> mp;
	map <int, int> :: iterator it;
	
	fi(&n), fi(&q);
	
	assert(n >= 1 && n <= 100000);
	assert(q >= 1 && q <= 100000);

	for ( int i = 0; i < n; i++ ) {
		fi(&P[i]);
		assert(P[i] >= 1 && P[i] <= 1000000000);
		mp[P[i]] = 1;
	}
	
	for ( it = mp.begin(); it != mp.end(); it++ ) it->second = cnt++;
	
	for ( int i = 0; i < n; i++ ) {
		acVal[mp[P[i]]] = P[i];
		P[i] = mp[P[i]];
	}

	pre(n);

	while ( q-- ) {
		fi(&a), fi(&b), fi(&c), fi(&d), fi(&k);
		assert(a >= 0 && a <= n);
		assert(b >= 0 && b <= n);
		assert(c >= 0 && c <= n);
		assert(d >= 0 && d <= n);
		assert(k >= 1 && k <= n);
		l = (a * max(ans, 0ULL) + b) % n;
		r = (c * max(ans, 0ULL) + d) % n;
		if ( l > r ) swap(l, r);
		assert(l <= r);
		assert(l >= 0 && l < n);
		assert(r >= 0 && r < n);
		node query;
		query.init();
		if ( l/bktSize != r/bktSize ) {
			query = bktInRange[l/bktSize + 1][r/bktSize - 1];
			for ( int i = l; i < (l/bktSize + 1) * bktSize; i++ ) query.set(P[i]);
			for ( int i = (r/bktSize) * bktSize; i <= r; i++ ) query.set(P[i]);
		}
		else {
			for ( int i = l; i <= r; i++ ) query.set(P[i]);
		}
		ans = query.Kth(k);
		if ( ans == -1 ) {
			puts("-1");
			continue;
		}
		ans = acVal[ans];
		printf("%d\n", ans);
	}

	return 0;
}