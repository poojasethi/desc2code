#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define esp 1e-9
#define N 100100
#define vi vector<int>
#define pp pair<int, int>
#define mod 1000000007
#define BASE 555
#define mk 1562
typedef long long ll;
typedef long long ull;
typedef long double ld;
using namespace std;
int n, q, x, m;
pp a[N];
int val[N];
int th[N];
struct seg {
    ull mark[mk];
};
struct cut {
    int L, R;
};

seg c[200];
cut cc[200];

ull dp[mk];
ull f[200][200][1600];

int countBit(ull x) {
    return __builtin_popcountll(x);
}

int addNew(ull x, ull y) {
    int cn = 0;
    for (int j = 0; j < 64; j++)
        if (!((x >> j) & 1) && ((y >> j) & 1))
            cn++;
    return cn;
}

int query(int L, int R, int K) {
   // cout << L << " " << R << " " << K << "\n";
    memset(dp, 0, sizeof(dp));

    if (L / BASE ==  R / BASE) {
        for (int i = L; i <= R; i++) {
            int block = (val[i] / 64);
            int vt = val[i] % 64;
            dp[block] |= (1ull << vt);
        }
    }
    else {
        /// O(N / 64)
        //int totalStep = 0;

        int l = L / BASE + 1;
        int r = R / BASE - 1;
        if (l <= r)
            for (int i = 0; i < mk; i++) {
                dp[i] |= f[l][r][i];
              //  totalStep++;
            }

        /// sqrt(N)
        for (int i = L; i <= cc[L / BASE].R; i++) {
            int block = (val[i] / 64);
            int vt = val[i] % 64;
            dp[block] |= (1ull << vt);
        // totalStep++;
        }

        for (int i = cc[R / BASE].L; i <= R; i++) {
            int block = (val[i] / 64);
            int vt = val[i] % 64;
            dp[block] |= (1ull << vt);
        //    totalStep++;
        }
    }

    /// query O(N / 64)
    int block = -1;
    int cntbit = 0;
    for (int i = 0; i < mk; i++) {
        cntbit += countBit(dp[i]);
        if (cntbit >= K) {
            cntbit -= countBit(dp[i]);
            block = i;
            break;
        }
    }


    if (block == -1) return -1;
    int vt = K - cntbit;


    int tot = 0;
    for (int j = 0; j < 64; j++) {
        if ((dp[block] >> j) & 1) tot++;
        if (tot == vt) {
            return th[64 * block + j];
        }
    }
    /**/
}

int main() {
   //freopen("in.in", "r", stdin);
   //freopen("ou.ou", "w", stdout);

    scanf("%d%d", &n, &q);
    for (int i = 0; i < n; i++) {
        scanf("%d", &x);
        a[i] = mp(x, i);
    }
    sort(a, a + n);
    a[n].fi = -1;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        val[a[i].se] = cnt;
        if (a[i].fi != a[i + 1].fi) {
            th[cnt] = a[i].fi;
            cnt++;
        }
    }

    int m = 0;
    for (int i = 0; i < n; i += BASE) {
        cc[i / BASE].L = i;
        cc[i / BASE].R = min(n - 1, i + BASE - 1);
        m++;
    }

    for (int i = 0; i < n; i++) {
        int block = (val[i] / 64);
        int vt = val[i] % 64;
        c[i / BASE].mark[block] |= (1ull << vt);
    }

    /// pre-compute

    for (int i = 0; i < m; i++) {
        for (int k = 0; k < mk; k++)
            f[i][i][k] = c[i].mark[k];

        for (int j = i + 1; j < m; j++) {
            for (int k = 0; k < mk; k++)
                f[i][j][k] = (f[i][j - 1][k] | c[j].mark[k]);
        }
    }


    int ass = 0;
    int A, B, C, D, K;
    //int L, R;
    for (int i = 1; i <= q; i++) {
        scanf("%d%d%d%d%d", &A, &B, &C, &D, &K);
        int L = ((ll)A * max(ass, 0) + B) % n;
        int R = ((ll)C * max(ass, 0) + D) % n;
        //scanf("%d%d%d", &L, &R, &K);
        //L--;
        //R--;
        if (L > R)
            swap(L, R);
        ass = query(L, R, K);
       // printf("%d %d %d\n", L, R, K);
        printf("%d\n", ass);
    }

    /**/return 0;
}
