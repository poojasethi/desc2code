#include<bits/stdc++.h>
using namespace std;
#define F(a,b) for(int a=0;a<b;a++)
#define P printf
#define LEN(x) ((int)x.length())
#define SZ(x) ((int)x.size())
#define FORD(a,b,c) for(int a=b;a>=c;a--)
#define S scanf
#define MP(x,y) make_pair(x,y)
#define ALL(x) x.begin(), x.end()
#define REP(a,b) for(int a=0;a<b;a++)
#define FOR(a,b,c) for(int a=b;a<c;a++)
#define PB(x) push_back(x)
#define INF 1000000000
typedef long long LL;
typedef pair<int,int> PII;
typedef pair<int, PII> PIII;
typedef vector<int> VI;
typedef vector<bool> VB;
typedef vector<string> VS;
int tourCity[4000001], tourCost[23100001], tourNextCost[4000001];
vector< pair<pair<int, int>, int> > OR[100005];
int pointer[100005], maxOut[100005], visCount[100005], visNCount[100005];
bool visEdge[200010];
char *ipos, InpFile[20000000];
inline int input() { 
	while(*ipos <= 32) ++ipos;
	int x=0, neg = 0;char c;
	while( true ) {
		c=*ipos++; if(c == '-') neg = 1;
		else {
			if (c<=32) return neg?-x:x;
			x=(x<<1)+(x<<3)+c-'0';
		}
	}
}
inline LL inputll() {
	while(*ipos <= 32) ++ipos;
	LL x=0, neg = 0;char c;
	while( true ) {
		c=*ipos++; if(c == '-') neg = 1;
		else {
			if (c<=32) return neg?-x:x;
			x=(x<<1)+(x<<3)+c-'0';
		}
	}
}
int main()
{
	ipos = InpFile; 
	fread_unlocked(InpFile,20000000,1,stdin);
	int n,m,a,b,ca,cb,pathCount=0;
	n= input();
	m = input();
	REP(i,n+1) pointer[i] = 0;
	REP(i,m)
	{
		a=input();
		b=input();
		ca=input();
		cb=input();
		OR[a-1].PB( MP( MP( ca, b-1), 2*i));
		maxOut[a-1] = max( maxOut[a-1], ca );
 		OR[b-1].PB( MP( MP( cb, a-1), 2*i+1));
		maxOut[b-1] = max( maxOut[b-1], cb );
	}
	REP(i,n) sort(ALL(OR[i]));
        int finalInd = OR[0][0].second,ctr=0,city = 0,offset=0;
	bool flIn = false;
	while(1)
	{
		int ind = OR[city][pointer[city]].second;
		if(ctr>=2*m && finalInd == ind)
		{
			if( ! flIn )
			{
				offset = pathCount;
				flIn = true;
			}
			else break;
		}
		int tmpCity = OR[city][pointer[city]].first.second;
		if(flIn)
			tourCity[pathCount-offset] = OR[city][pointer[city]].first.second;
		tourCost[pathCount] = OR[city][pointer[city]].first.first;
		visCount[city]++;
		if( flIn ) visNCount[city]++;
		OR[city][pointer[city]].first.first = visCount[city]+maxOut[city];
		pointer[city]++;
		if( pointer[city] >= SZ(OR[city]) ) pointer[city]-=SZ(OR[city]);
		if(flIn)
			tourNextCost[pathCount-offset] = maxOut[city] + visCount[city];
		if(!visEdge[ind])
		{
			ctr++;
			visEdge[ind]=true;
		}
 
		city = tmpCity;
		pathCount++;
	}
 int query;
	LL k;
	query = input();
	while(query--)
	{
		k=inputll();
		if( k <= pathCount )	P("%d\n", tourCost[k-1] );
		else
		{
 
			int pathind = (k-1-offset)%(pathCount-offset);
			int times = (k-1-offset)/(pathCount-offset);
 			int pathPrev = pathind-1;
			if( pathPrev == -1 ) pathPrev = pathCount-1-offset;
			LL ans = tourNextCost[pathind];
			times--;
			ans += (LL)times*visNCount[tourCity[pathPrev]];
			P("%lld\n",ans);
		}
	}
} 