#include <algorithm>
 
#include <cassert>
 
#include <cstdio>
 
#include <cstdlib>
 
#include <cctype>
 
#include <cmath>
 
#include <iostream>
 
#include <sstream>
 
#include <string>
 
#include <utility>
 
#include <vector>
 
#include <cassert>
 
#include <ctime>
 
#include <queue>
 
using namespace std;
 
#define VAR(a,b) __typeof(b) a=(b)
 
#define REP(i,n) for(int _n=n, i=0;i<_n;++i)
 
#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)
 
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
 
#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)
 
#define ALL(c) (c).begin(),(c).end()
 
#define TRACE(x) cerr << "TRACE(" #x ")" << endl;
 
#define DEBUG(x) cerr << #x << " = " << x << endl;
 
 
 
template<class T>
 
ostream& operator<<(ostream&o, const vector<T>&v) {
 
o<<'{';
 
FOREACH(it,v) o<<*it<<',';
 
return o<<'}';
 
}
 
typedef long long LL;
 
const int INF = 1000000000; const LL INFLL = LL(INF) * LL(INF);
 
typedef vector<int> VI; typedef vector<string> VS; typedef vector<VI> VVI;
 
template<class T> inline int size(const T&c) { return c.size(); }
 
 
 
class INPUT {
 
static const int BUFSIZE = 1<<16;
 
static char buffer[];
 
char *bufpos;
 
char *bufend;
 
void grabBuffer();
 
public:
 
INPUT() { grabBuffer(); }
 
bool eof() { return bufend==buffer; }
 
char nextChar() { return *bufpos; }
 
inline char readChar();
 
inline void skipWS();
 
inline unsigned readUnsigned();
 
inline int readInt();
 
};
 
 
 
char INPUT::buffer[INPUT::BUFSIZE];
 
 
 
void INPUT::grabBuffer() {
 
bufpos = buffer;
 
bufend = buffer + read(0, buffer, BUFSIZE);
 
}
 
 
 
char INPUT::readChar() {
 
char res = *bufpos++;
 
if(bufpos==bufend) grabBuffer();
 
return res;
 
}
 
 
 
inline bool myisspace(char c) { return c<=' '; }
 
 
 
void INPUT::skipWS() {
 
while(!eof() && myisspace(nextChar())) readChar();
 
}
 
 
 
unsigned INPUT::readUnsigned() {
 
skipWS();
 
unsigned res = 0;
 
while(!eof() && isdigit(nextChar())) {
 
res = 10u * res + (readChar()-'0');
 
}
 
return res;
 
}
 
 
 
int INPUT::readInt() {
 
skipWS();
 
bool neg = false;
 
if(!eof() && nextChar()=='-') { neg=true; readChar(); }
 
int res = static_cast<int>(readUnsigned());
 
if(neg) res = -res;
 
return res;
 
}
 
 
 
class OUTPUT {
 
static const int BUFSIZE = 1<<16;
 
static char buffer[];
 
char *bufpos;
 
char *BUFLIMIT;
 
public:
 
void flushBuffer();
 
OUTPUT():bufpos(buffer),BUFLIMIT(buffer+BUFSIZE-100) {}
 
~OUTPUT() { flushBuffer(); }
 
inline void operator()(char c);
 
inline void operator()(unsigned x);
 
inline void operator()(int x);
 
inline void operator()(const char*s);
 
void operator()(const string&s) { operator()(s.c_str()); }
 
template<class A,class B>
 
void operator()(const A& a,const B& b) {
 
operator()(a); operator()(b);
 
}
 
template<class A,class B,class C>
 
void operator()(const A& a,const B& b,const C&c) {
 
operator()(a); operator()(b); operator()(c);
 
}
 
template<class A,class B,class C,class D>
 
void operator()(const A& a,const B& b,const C&c,const D&d) {
 
operator()(a); operator()(b); operator()(c); operator()(d);
 
}
 
template<class A,class B,class C,class D,class E>
 
void operator()(const A& a,const B& b,const C&c,const D&d,const E&e) {
 
operator()(a); operator()(b); operator()(c); operator()(d); operator()(e);
 
}
 
template<class A,class B,class C,class D,class E,class F>
 
void operator()(const A& a,const B& b,const C&c,const D&d,const E&e,const F&f) {
 
operator()(a); operator()(b); operator()(c); operator()(d); operator()(e); operator()(f);
 
}
 
};
 
 
 
char OUTPUT::buffer[OUTPUT::BUFSIZE];
 
 
 
void OUTPUT::flushBuffer() {
 
char *p = buffer;
 
while(p < bufpos) {
 
p += write(1, p, bufpos-p);
 
}
 
bufpos = buffer;
 
}
 
 
 
void OUTPUT::operator()(char c) {
 
*bufpos = c;
 
++bufpos;
 
if(bufpos >= BUFLIMIT) flushBuffer();
 
}
 
 
 
void OUTPUT::operator()(unsigned x) {
 
char *old = bufpos;
 
do {
 
*bufpos = char('0' + x % 10u);
 
x /= 10u;
 
++bufpos;
 
} while(x);
 
reverse(old, bufpos);
 
if(bufpos >= BUFLIMIT) flushBuffer();
 
}
 
 
 
void OUTPUT::operator()(int x) {
 
if(x<0) { operator()('-'); x = -x; }
 
operator()(static_cast<unsigned>(x));
 
}
 
 
 
void OUTPUT::operator()(const char*s) {
 
while(*s) operator()(*s++);
 
}
 
 
 
INPUT input;
 
OUTPUT output;
 
 
 
//}}}
 
 
 
const int TIME_SWITCH = 50;
 
const int SORT_THRESHOLD = 6;
 
const int MAX_DISTANCE = 100000;
 
 
 
struct Player {
 
int id;
 
int x0,v;
 
LL curPos;
 
};
 
 
 
struct Query {
 
int id;
 
int t,pos;
 
int answer;
 
};
 
 
 
vector<Player> players;
 
vector<Query> queries;
 
int nextQueryNr;
 
 
 
inline bool operator<(const Player &a, const Player &b) {
 
if(a.curPos != b.curPos) return a.curPos > b.curPos;
 
return a.id < b.id;
 
}
 
 
 
void readInput() {
 
int n = input.readInt();
 
players.resize(n);
 
REP(i,n) {
 
Player &p = players[i];
 
p.id = i;
 
p.v = input.readInt();
 
p.x0 = input.readInt();
 
}
 
int nq = input.readInt();
 
queries.resize(nq);
 
REP(i,nq) {
 
Query &q = queries[i];
 
q.id = i;
 
q.t = input.readInt();
 
q.pos = input.readInt()-1;
 
q.answer = -1;
 
}
 
}
 
 
 
struct cmpQueryTime {
 
inline bool operator()(const Query&a, const Query&b) const {
 
return a.t < b.t;
 
}
 
};
 
 
 
 
 
void sortQueries() {
 
sort(queries.begin(), queries.end(), cmpQueryTime());
 
nextQueryNr = 0;
 
}
 
 
 
void positionPlayers(int t) {
 
FOREACH(it, players) {
 
Player &p = *it;
 
p.curPos = p.x0 + LL(t) * LL(p.v);
 
}
 
}
 
 
 
 
 
void phase0() {
 
while(nextQueryNr < size(queries)) {
 
int t = queries[nextQueryNr].t;
 
if(t >= TIME_SWITCH) break;
 
int p = nextQueryNr+1;
 
while(p<size(queries) && queries[p].t == t) ++p;
 
positionPlayers(t);
 
if(p-nextQueryNr >= SORT_THRESHOLD) {
 
sort(players.begin(), players.end());
 
FOR(i,nextQueryNr,p-1) {
 
Query &q = queries[i];
 
q.answer = players[q.pos].id;
 
}
 
} else {
 
FOR(i,nextQueryNr,p-1) {
 
Query &q = queries[i];
 
nth_element(players.begin(), players.begin()+q.pos, players.end());
 
q.answer = players[q.pos].id;
 
}
 
}
 
nextQueryNr = p;
 
}
 
}
 
 
 
struct cmpVelocity {
 
inline bool operator()(const Player&a, const Player&b) const {
 
return a.v > b.v;
 
}
 
};
 
 
 
struct Event {
 
int t,a,b; // player with id a passes player b
 
Event(int t,int a,int b):t(t),a(a),b(b) {}
 
};
 
 
 
inline bool operator<(const Event &a, const Event &b) {
 
return a.t < b.t;
 
}
 
 
 
int nextEventNr;
 
vector<Event> events;
 
vector<int> playerAt; // id -> player position
 
 
 
void processEvents(int t) {
 
while(nextEventNr < size(events) && events[nextEventNr].t <= t) {
 
int idA = events[nextEventNr].a;
 
int idB = events[nextEventNr].b;
 
++nextEventNr;
 
int posA = playerAt[idA];
 
int posB = playerAt[idB];
 
if(posA > posB) {
 
playerAt[idA] = posB;
 
playerAt[idB] = posA;
 
swap(players[posA], players[posB]);
 
}
 
}
 
}
 
 
 
void phase1() {
 
sort(players.begin(), players.end(), cmpVelocity());
 
events.clear();
 
REP(a,size(players)) {
 
FOR(b,a+1,size(players)-1) {
 
int dv = players[a].v - players[b].v;
 
if(dv * TIME_SWITCH > MAX_DISTANCE) break;
 
if(dv==0) continue;
 
int dx = players[b].x0 - players[a].x0;
 
int aid = players[a].id;
 
int bid = players[b].id;
 
if(aid > bid) ++dx;
 
if(dx<=0) continue;
 
int t = (dx+dv-1)/dv;
 
if(t <= TIME_SWITCH) continue;
 
events.push_back(Event(t,aid,bid));
 
}
 
}
 
sort(events.begin(), events.end());
 
 
positionPlayers(TIME_SWITCH);
 
sort(players.begin(), players.end());
 
playerAt.resize(size(players));
 
REP(i,size(players)) {
 
playerAt[players[i].id] = i;
 
players[i].v = 0; // reuse as visited
 
}
 
nextEventNr=0;
 
while(nextQueryNr < size(queries)) {
 
Query &q = queries[nextQueryNr++];
 
processEvents(q.t);
 
q.answer = players[q.pos].id;
 
}
 
}
 
 
 
void solve() {
 
phase0();
 
phase1();
 
}
 
 
 
void print() {
 
vector<int> answers(size(queries),-1);
 
FOREACH(it,queries) {
 
Query &q = *it;
 
answers[q.id] = q.answer;
 
}
 
FOREACH(it, answers) output(*it + 1, '\n');
 
output('\n');
 
}
 
 
 
int main() {
 
int ntc = input.readInt();
 
REP(tc,ntc) {
 
readInput();
 
sortQueries();
 
solve();
 
print();
 
}
 
}