// Motorbike.cpp : Defines the entry point for the console application.
//

#include <stdio.h>
#include <vector>
#include <algorithm>

class BUFFER
{
	static const int BUFSIZE = 1<<16;
	char* buffer;
	char *bufpos;
	char *bufend;
public:
	BUFFER() { bufpos = buffer = new char[BUFSIZE];}
	~BUFFER() { delete[] buffer;}
protected:
	void grabBuffer()
	{
		bufpos = buffer;
		bufend = buffer + fread(buffer, sizeof(char), BUFSIZE, stdin);
	}
	void flushBuffer()
	{
		fwrite(buffer, sizeof(char), bufpos - buffer, stdout);
		bufpos = buffer;
	}
	inline char getChar()
	{
		if (bufpos==bufend) grabBuffer();
		return *bufpos++;
	}
	inline void putChar(char c)
	{
		*bufpos++ = c;
		if (bufpos >= buffer+BUFSIZE) flushBuffer();
	}
};

class IN : BUFFER
{
public:
	IN() { grabBuffer(); }
	int readInt()
	{
		int result = 0, c;
		do { c = getChar(); } while (c <= ' ');
		while (('0' <= c) && (c <= '9'))
		{
			result *= 10;
			result += c - '0';
			c = getChar();
		}
		return result;
	}
};

class OUT : BUFFER
{
public:
	~OUT() { flushBuffer(); }
	inline void write(char c)
	{
		putChar(c);
	}
	inline void write(int x)
	{
		if (x == 0) { putChar('0'); return; }
		char tmp[10];
		int tp = 0;
		while (x) { tmp[tp++] = x%10; x /= 10; }
		while (tp--) putChar(tmp[tp] + '0');
	}
	inline void write(const char*s)
	{
		while(*s) write(*s++);
	}
};

IN input;
OUT output;

struct bike
{
	int index;
	int v;
	int x;
	long long currPos;

	bike() {}
	bike(int i, int vel, int pos) : index(i), v(vel), x(pos) {}
	void calcPos(long long t) { currPos = x + v * t; }

	inline bool operator < (const bike& b2) const
	{
		if (currPos == b2.currPos)
			return index < b2.index;
		return currPos > b2.currPos;
	}
};

struct query
{
	int i, t, k, result;

	query(int index, int time, int pos) : i(index), t(time), k(pos) {}
	inline bool operator < (const query& rhs) const
	{
		return t<rhs.t || (t==rhs.t && k<rhs.k);
	}
};

inline bool Qpred (const query& q1, const query& q2)
{
	return q1.i < q2.i;
}

void doTestCase()
{
	bike bikes[20000];
	std::vector<query> queries;

	int nBikes = input.readInt();
	for (int j = 0; j < nBikes; ++j)
	{
		bikes[j].index = j;
		bikes[j].v = input.readInt();
		bikes[j].x = input.readInt();
	}

	int nQueries;
	nQueries = input.readInt();
	queries.reserve(nQueries);
	for (int i = 0; i < nQueries; ++i)
	{
		int t, pos;
		t = input.readInt();
		pos = input.readInt();
		queries.push_back(query(i, t, pos));
	}

	sort(queries.begin(), queries.end());
	bool stop = false;
	for (int i = 0; i < nQueries; ++i)
	{
		int thisPos = queries[i].k - 1;
		if (!stop)
		{
			long long time = queries[i].t;
			for (int j = 0; j < nBikes; ++j)
			{
				bikes[j].calcPos(time);
			}

			if (time <= 100000)
				std::nth_element(bikes, bikes + thisPos, bikes + nBikes);
			else
			{
				std::sort(bikes, bikes + nBikes);
				stop = true;
			}
		}
		queries[i].result = bikes[thisPos].index + 1;
	}
		
	sort(queries.begin(), queries.end(), Qpred);
	for (int i = 0; i < nQueries; ++i)
	{
		output.write(queries[i].result);
		output.write('\n');
	}
	output.write('\n');
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);
	freopen("output.txt","w",stdout);
#endif

	int nTests = input.readInt();
	for (int i = 0; i < nTests; ++i)
		doTestCase();

	return 0;
}
