    #include <algorithm>
    #include <bitset>
    #include <cctype>
    #include <cmath>
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    #include <ctime>
    #include <deque>
    #include <fstream>
    #include <functional>
    #include <iomanip>
    #include <iostream>
    #include <list>
    #include <map>
    #include <numeric>
    #include <queue>
    #include <set>
    #include <sstream>
    #include <string>
    #include <utility>
    #include <time.h>
    #include <vector>
    using namespace std;
    #define mp make_pair
    #define pb push_back
    #define fi(n) fo(i,n)
    #define fj(n) fo(j,n)
    #define fk(n) fo(k,n)
    #define fd(i,n) for(int i=(int)(n)-1; i>=0; --i)
    #define fo(i,n) fr(i,0,n)
    #define fr(i,a,b) for(int i=(int)a; i<(int)b; ++i)
    #define sz(x) ((int) (x).size())
    #define all(x) (x).begin(), (x).end()
    #define sqr(x) ((x) * (x))
    #define srt(x) sort(all(x))
    #define go(x,it) for(typeof((x).begin()) it=(x).begin(); it!=(x).end(); ++it)
    #define PQ(t) priority_queue< t, vector<t>, greater<t> >
    #define x first
    #define y second
    #define me (*this)
    #define CLR(a,v) memset(a, v, sizeof(a))
    #define UNIQUE(a) srt(a); a.resize(unique(all(a))-a.begin())
    #define RAND (((double)rand()/RAND_MAX) + ((double)rand()/RAND_MAX/RAND_MAX))
    typedef long long ll;
    typedef long double ld;
    typedef pair< int,int > ii;
    typedef vector< ii > vii;
    typedef vector< vii > vvii;
    typedef vector< int > vi;
    typedef vector< vi > vvi;
    typedef vector< double > vd;
    typedef vector< vd > vvd;
    typedef vector< ll > vll;
    typedef vector< vll > vvll;
    typedef vector< string > vs;
    const int INF = 1000*1000*1000+7;
    const double EPS = 1e-9;
    int bit_count(int x){ return x==0 ? 0 : 1+bit_count(x&(x-1)); }
    inline int low_bit(int x){ return x&-x; } 
    inline int sign(double x){ return x<-EPS ? -1 : x>EPS ? 1 : 0; }
    inline int sign(int x){ return (x>0)-(x<0); }
    template<class T> void chmin(T &t, T f){ if(t > f) t = f; }
    template<class T> void chmax(T &t, T f){ if(t < f) t = f; }
    int nextComb(int x){ 
    int smallest = x&-x; 
    int ripple = x+smallest; // xxx1 0000 0000
    int ones = x^ripple; // 0001 1111 0000 // necessary to kill leading ones
    ones = (ones>>2)/smallest; // 0000 0000 0111
    return ripple|ones; 
    }
    inline int getint(){
    int a;
    return scanf("%d", &a) ? a : (fprintf(stderr, "trying to read\n"),-1);
    }
    inline double getdouble(){
    double a;
    return scanf("%lf", &a) ? a : (fprintf(stderr, "trying to read\n"),-1.0);
    }
  
    pair< ii,int > edges[45];
    int adjacent[10][10];
    // Begin GCD
    int gcd_f(int a, int b){ while(b){ int r=a%b; a=b; b=r; } return a; }
    int gcd_t[1<<10][1<<10];
    void preprocess(){
    fi(1<<10)
    fj(1<<10)
    gcd_t[i][j] = i>j ? gcd_t[j][i] : gcd_f(i, j);
    fi(45)
    edges[i] = mp(ii(0,0), 0);
    fi(10)
    fj(10)
    adjacent[i][j] = -1;
  
    }
    inline int gcd(int a, int b){
    if(a < (1<<10) && b < (1<<10))
    return gcd_t[a][b];
    else
    return gcd_f(a, b);
	}
    struct Q{
    int n, d;
    Q(int _n=0, int _d=1): n(_n), d(_d){
    if(d != 1)
    normalise();
    }
    Q(const Q &q): n(q.n), d(q.d){}
    void normalise(){
    if(d < 0)
    n = -n, d = -d;
    int g = gcd(abs(n), d);
    if(g != 1){
    n /= g;
    d /= g;
    }
    }
    string toString(){
    char buffer[20];
    sprintf(buffer, "%d/%d", n, d);
    return buffer;
    }
    Q operator+(const Q &q){ return Q(n*q.d + q.n*d, d*q.d); }
    Q operator-(const Q &q) const{ return Q(n*q.d - q.n*d, d*q.d); }
    Q operator*(const Q &q){ return Q(n*q.n, d*q.d); }
    Q operator/(const Q &q){ return Q(n*q.d, d*q.n); }
    bool operator<(const Q &q){ return n*q.d < d*q.n; }
    bool operator>(const Q &q){ return n*q.d > d*q.n; }
    bool operator==(const Q &q){ return n==q.n && d==q.d; }
    bool operator!=(const Q &q){ return n!=q.n || d!=q.d; }
    };
    const Q ZERO(0, 1), MINUS_ONE(-1, 1);
    // End Rational
    // Begin Simplex
    const int MAX_M = 1<<10, MAX_N = 1<<8;
    struct Simplex{
    Q a[MAX_M][MAX_N];
    int rows[MAX_M], cols[MAX_N], nr, nc, m, n;
    Simplex(Q _a[MAX_M][MAX_N], Q b[MAX_M], Q c[MAX_N], int _m, int _n): m(_m), n(_n){
    fi(m) fj(n) a[i][j] = _a[i][j];
    fi(m) a[i][n] = b[i];
    fj(n) a[m][j] = c[j];
    a[m][n] = 0;
    }
    Q solve(){
    /*
    int debug = 0;
    */
    while(true){
  
    int j0 = -1;
    Q best(ZERO);
    fj(n)
    if(a[m][j] > best)
    j0 = j, best = a[m][j];
    if(j0 == -1)
    break;
    // find row
    int i0 = -1;
    best = MINUS_ONE;
    fi(m)
    if(a[i][j0] > ZERO && (best == MINUS_ONE || a[i][n]/a[i][j0] < best))
    best = a[i][n] / a[i][j0], i0 = i;
    if(i0 == -1)
    return fprintf(stderr, "unbounded feasible\n"), Q(INF,1);
    // optimise sparse matrices
    nr = nc = 0;
    fi(m+1) if(i != i0 && a[i][j0] != ZERO)
    rows[nr++] = i;
    fj(n+1) if(j != j0 && a[i0][j] != ZERO)
    cols[nc++] = j;
    Q piv = a[i0][j0], npiv = ZERO-a[i0][j0];
    a[i0][j0] = npiv; // becomes 1 / a[i][j] after row and col ops
    fi(m+1) a[i][j0] = a[i][j0] / npiv;
    fi(nr){
    int _i = rows[i];
    fj(nc){
    int _j = cols[j];
    a[_i][_j] = a[_i][_j] + (a[i0][_j] * a[_i][j0]); // a[i][j] = a[i][j] - a[i0][j] * a[i][j0] / a[i0][j0]
    }
    }
    fj(n+1) a[i0][j] = a[i0][j] / piv;
    }
    return a[m][n];
    }
    };
    Q a[MAX_M][MAX_N], b[MAX_M], c[MAX_N];
    int na;
    // for cycle finding
    int cy[11], e[10], seen[10];
    void cycle(int i, int d){
    cy[d] = i;
    // case cycle complete
    if(d > 0 && i == cy[0]){
    fi(d){ // for every edge on the cycle
    fj(d){ // the sum of every other edge is at least that of the 'i' edge
    int id = e[j];
    a[na][(id<<1)] = a[na][(id<<1)+1] = Q(i==j ? 1 : -1);
    }
    ++na;
    }
    return;
    }
    if(d >= 2)
    fj(10)
    if(adjacent[i][j] != -1 && seen[j] && j != cy[d-1] && j != cy[0])
    return;
    // look for more edges
    seen[i] = 1;
    int start = (d > 1 && cy[1] < cy[d]) ? cy[0] : cy[0]+1;
    fr(j,start,10) // for every person after me
    if(adjacent[i][j] != -1) // that I am adjacent to
    if(!seen[j] || j == cy[0]){ // that has not been seen, or is allowed to be seen
    e[d] = adjacent[i][j]; // go for a walk
    cycle(j, d+1);
    }
    seen[i] = 0;
    }
    void myCode(){
    // setup
    preprocess();
    // input
    int n=getint(), ne=getint();
    fk(ne){
    int i=getint(), j=getint(), d=getint();
    edges[k] = mp(ii(i,j), d);
    adjacent[i][j] = adjacent[j][i] = k;
    }
    // build tableau
    fi(n)
    cycle(i, 0);
    fk(ne){
    a[na][(k<<1)+1] = 1;
    b[na] = edges[k].y;
    ++na;
    c[(k<<1)] = -1;
    c[(k<<1)+1] = 1;
    }
    Simplex simplex(a, b, c, na, 2*ne);
    Q ret = simplex.solve();
    fk(ne)
    ret = ret + edges[k].y;
    printf("%s\n", ret.toString().c_str());
    }
    int main() {
    srand(time(NULL));
    myCode();
    return 0;
    } 
