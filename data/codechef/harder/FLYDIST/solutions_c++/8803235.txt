#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
using namespace std;
typedef long long ll;
typedef long double db;
void gn(int &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
void gn(ll &x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')sg=-1,x=0;else x=c-'0';
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';
	x*=sg;
}
const int mo=1000000007;
int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}

#define EPS 1e-6
#define INF 1e9
#define MAXM (3000+5)
#define MAXN (3000+5)
db a[MAXM][MAXN];
int idm[MAXM],idn[MAXN];
int m,n;
void pivot(int l,int e){
	swap(idm[l],idn[e]);
	static int next[MAXN];
	int i,j,last=MAXN-1;db tmp=-a[l][e];a[l][e]=-1.0;
	for (j=0;j<=n;j++)if(fabs(a[l][j])>EPS)a[l][last=next[last]=j]/=tmp;
	next[last]=-1;
	for (i=0;i<=m;i++)if(i!=l && fabs(tmp=a[i][e])>EPS)
		for (a[i][e]=0.0,j=next[MAXN-1];~j;j=next[j])a[i][j]+=tmp*a[l][j];
}
db sol(){
	int e,l;db ma,tmp;
	while(1){
		e=n+1;idn[e]=n+m+1;
		for (int i=1;i<=n;i++)if(a[0][i]>EPS)
			if(idn[i]<idn[e])e=i;
		if(e==n+1)return a[0][0];
		l=m+1;idm[l]=n+m+1;ma=-INF;
		for(int i=1;i<=m;i++)if(a[i][e]<-EPS && ((tmp=a[i][0]/a[i][e])>ma+EPS || tmp>ma-EPS && idm[i]<idm[l]))ma=tmp,l=i;
		if(l==m+1)return INF;
		pivot(l,e);
	}
} 
db solve(){
	for (int i=1;i<=n;i++)idn[i]=i;
	for (int i=1;i<=m;i++)idm[i]=i+n;
	static db tmp[MAXN];
	db mi=0.0;int l;
	for (int i=1;i<=m;i++)
		if(a[i][0]<mi)mi=a[i][0],l=i;
	if(mi>-EPS)return sol();

	idn[++n]=0;
	for (int i=1;i<=m;i++)a[i][n]=1.0;
	for (int i=0;i<=n;i++)tmp[i]=a[0][i],a[0][i]=0.0;
	a[0][n]=-1.0;

	pivot(l,n);
	if(sol()<-EPS)return -INF;
	for (int i=1;i<=m;i++)if(idm[i]==0){
		for (int j=1;j<=n;j++)if(fabs(a[0][j])>EPS){
			pivot(i,j);
			break;
		}
		break;
	}
	int e;for (e=1;e<=n;e++)if(idn[e]==0)break;
	for (int i=0;i<=m;i++)a[i][e]=a[i][n];
	idn[e]=idn[n];n--;
	
	for (int i=0;i<=n;i++)a[0][i]=0.0;
	for (int i=1;i<=m;i++)if(idm[i]<=n){
		for (int j=0;j<=n;j++)a[0][j]+=a[i][j]*tmp[idm[i]];
	}
	for (int i=1;i<=n;i++)if(idn[i]<=n)a[0][i]+=tmp[idn[i]];
	return sol();
}

struct node{
	int a,b,d;
}p[55];

int id[15][15];int idtot=0;
int ii[55][2];
int main()
{
	m=0;
	int N,M;
	gn(N);gn(M);
	for (int i=1;i<=M;i++)gn(p[i].a),gn(p[i].b),gn(p[i].d),p[i].a++,p[i].b++;
	for (int i=1;i<=N;i++)
		for (int j=i+1;j<=N;j++)id[i][j]=id[j][i]=++idtot;
	for (int i=1;i<=M;i++)ii[i][0]=++idtot,ii[i][1]=++idtot;
	for (int i=1;i<=N;i++)
		for (int j=i+1;j<=N;j++)
			for (int k=1;k<=M;k++)if(p[k].a==i || p[k].b==i){
				int is=p[k].a+p[k].b-i;
				++m;
				a[m][0]=p[k].d;
				a[m][ii[k][0]]+=1.0;
				a[m][ii[k][1]]-=1.0;
				a[m][id[is][j]]+=1.0;
				a[m][id[i][j]]-=1.0;
			}
	n=idtot;
	for (int i=1;i<=M;i++){
		m++;
		a[m][0]=-p[i].d;
		a[m][ii[i][0]]-=1.0;
		a[m][ii[i][1]]+=1.0;
		a[m][id[p[i].a][p[i].b]]+=1.0;

		m++;
		a[m][0]=p[i].d;
		a[m][ii[i][0]]+=1.0;
		a[m][ii[i][1]]-=1.0;
		a[m][id[p[i].a][p[i].b]]-=1.0;
	}
	for (int i=1;i<=M;i++)a[0][ii[i][0]]--,a[0][ii[i][1]]--;

	db ans=-solve();

	for (int i=1;i<=100000;i++)
	{
		double t=ans*i;
		if (fabs(t-int(t+EPS/2))<EPS) {printf("%d/%d\n",int(t+EPS/2),i);break;}
	}
	/*for (int i=1;i<=1000000;i++)if(fabs((int(i*ans+0.5))-i*ans)<1e-6){
		printf("%d/%d\n",int(i*ans+0.5),i);
		break;
	}*/
	return 0;
}
