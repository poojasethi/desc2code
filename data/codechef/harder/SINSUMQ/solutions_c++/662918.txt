#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

typedef long long ll;
template<typename T> int size(T& a){  return (int) a.size(); }
template<typename T> T sqr(T a){  return a * a; }
#define _(a, b) memset((a), (b), sizeof(a))
#define fs first
#define sc second
#define pb push_back
#define mp make_pair
#define all(a) a.begin(), a.end()
#define REP(i, a, b) for(int i = (a); i < (b); ++i)
#define REPD(i, a, b) for(int i = (b) - 1; i >= a; --i)

#define MAXQ 100000
#define MAXN 600500
int q[MAXQ][3];
vector<int> num;

int pos[MAXN][2];
double cotan(double x) { return 1. / tan(x); }
double sum_sin(int N) {
    return (sin(N) - cotan(0.5) * cos(N) + cotan(0.5)) * 0.5;
}
double sum_cos(int N) {
    return 0.5 * (cos(N) + cotan(0.5) * sin(N) - 1);
}

struct Node {
    int i;
    int left, right;
    double sin_sum, cos_sum;
    double add;
};
Node tree[MAXN << 2];
void make_tree(int i, int l, int r) {
    tree[i].i = i;
    tree[i].left = pos[l][0];
    tree[i].right = pos[r][1];
    tree[i].add = 0;
    if(l == r) {
	tree[i].sin_sum = sum_sin(pos[l][1]) - sum_sin(pos[l][0]) + sin(pos[l][0]);
	tree[i].cos_sum = sum_cos(pos[l][1]) - sum_cos(pos[l][0]) + cos(pos[l][0]);
	return;
    }
    make_tree(i << 1, l, (l + r) >> 1);
    make_tree((i << 1) + 1, ((l + r) >> 1) + 1, r);
    tree[i].sin_sum = tree[i << 1].sin_sum + tree[(i << 1) + 1].sin_sum;
    tree[i].cos_sum = tree[i << 1].cos_sum + tree[(i << 1) + 1].cos_sum;
}

void update(int i, int l, int r, double D, double add) {
    double n_sin_sum = tree[i].sin_sum * cos(add) + tree[i].cos_sum * sin(add);
    double n_cos_sum = tree[i].cos_sum * cos(add) - tree[i].sin_sum * sin(add);
    tree[i].sin_sum = n_sin_sum;
    tree[i].cos_sum = n_cos_sum;
    tree[i].add += add;
    if(l > tree[i].right || r < tree[i].left) {
	return;
    }
    if(l <= tree[i].left && r >= tree[i].right) {
	tree[i].add += D;
	double n_sin_sum = tree[i].sin_sum * cos(D) + tree[i].cos_sum * sin(D);
	double n_cos_sum = tree[i].cos_sum * cos(D) - tree[i].sin_sum * sin(D);
	tree[i].sin_sum = n_sin_sum;
	tree[i].cos_sum = n_cos_sum;
	return;
    }
    update(i << 1, l, r, D, tree[i].add);
    update((i << 1) + 1, l, r, D, tree[i].add);
    tree[i].sin_sum = tree[i << 1].sin_sum + tree[(i << 1) + 1].sin_sum;
    tree[i].cos_sum = tree[i << 1].cos_sum + tree[(i << 1) + 1].cos_sum;
    tree[i].add = 0;
}
double query(int i, int l, int r, double add) {
    if(l > tree[i].right || r < tree[i].left) return 0;
    if(l <= tree[i].left && r >= tree[i].right) {
	double ret = tree[i].sin_sum * cos(add) + tree[i].cos_sum * sin(add);
	return ret;
    }
    return query(i << 1, l, r, add + tree[i].add) + query((i << 1) + 1, l, r, add + tree[i].add);
}
int N, Q;
int main() {
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    scanf("%d %d", &N, &Q);
    num.pb(0);
    for(int i = 0; i < Q; i++) {
	scanf("%d%d%d", &q[i][0], &q[i][1], &q[i][2]);
	num.pb(q[i][0]);
	num.pb(q[i][1]);
    }
    sort(all(num));
    num.resize(unique(all(num)) - num.begin());
    N = 0;
    for(int i = 0; i < size(num); i++) {
	pos[N][0] = pos[N][1] = num[i];
	N++;
	if(i != size(num) - 1) {
	    if(num[i] + 1 != num[i + 1]) {
		pos[N][0] = num[i] + 1;
		pos[N][1] = num[i + 1] - 1;
		N++;
	    }
	}
    }
    make_tree(1, 0, N - 1);
    for(int i = 0; i < Q; i++) {
	int l = q[i][0], r = q[i][1];
	if(q[i][2] == 0) {
	    printf("%.10lf\n", query(1, l, r, 0));
	} else {
	    update(1, l, r, q[i][2], 0);
	}
    }
}