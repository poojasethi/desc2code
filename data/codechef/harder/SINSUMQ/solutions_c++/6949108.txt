#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef double fl;
const int Q = 100100;
int n,nn=1,m,a0[Q<<1];
fl sin05=sin(0.5);

struct Ope{int l,r,x;}q[Q];
struct SegTree{
	fl si,co;int tag;
	SegTree(){
		si=0.0,co=0.0;
		tag=0;
		return;
	}
}T[Q<<3];

void Change(int x,int d){
	T[x].tag+=d;
	fl si1=T[x].si,si2=sin(d),co1=T[x].co,co2=cos(d);
	T[x].si=si1*co2+co1*si2;
	T[x].co=co1*co2-si1*si2;
	return;
}

void Pushdown(int x){
	Change(x<<1,T[x].tag);
	Change(x<<1|1,T[x].tag);
	T[x].tag=0;
	return;
}

void Update(int x){
	T[x].si=T[x<<1].si+T[x<<1|1].si;
	T[x].co=T[x<<1].co+T[x<<1|1].co;
	return;
}

void Build(int a,int l,int r){
	if(l==r){
		int L=a0[l],R=a0[l+1]-1;
		T[a].si=(cos(L-0.5)-cos(R+0.5))/(2*sin05);
		T[a].co=(sin(R+0.5)-sin(L-0.5))/(2*sin05);
		return;
	}
	int mid=(l+r)>>1;
	Build(a<<1,l,mid);
	Build(a<<1|1,mid+1,r);
	Update(a);
	return;
}

void Modify(int a,int L,int R,int l,int r,int d){
	if(L<=l&&r<=R){Change(a,d);return;}
	if(T[a].tag) Pushdown(a);
	int mid=(l+r)>>1;
	if(L<=mid) Modify(a<<1,L,R,l,mid,d);
	if(R>mid) Modify(a<<1|1,L,R,mid+1,r,d);
	Update(a);
	return;
}

fl Query(int a,int L,int R,int l,int r){
	if(L<=l&&r<=R) return T[a].si;
	if(T[a].tag) Pushdown(a);
	int mid=(l+r)>>1;fl res=0.0;
	if(L<=mid) res+=Query(a<<1,L,R,l,mid);
	if(R>mid) res+=Query(a<<1|1,L,R,mid+1,r);
	return res;
}

int main(){
	scanf("%d%d",&n,&m);
	a0[++a0[0]]=0;a0[++a0[0]]=n;
	for(int l,r,x,i=1;i<=m;i++){
		scanf("%d%d%d",&l,&r,&x);
		q[i]=(Ope){l,r,x};
		a0[++a0[0]]=l;
		a0[++a0[0]]=r+1;
	}
	sort(a0+1,a0+a0[0]+1);
	for(int i=2;i<=a0[0];i++) if(a0[i]!=a0[i-1]) a0[++nn]=a0[i];
	nn--;Build(1,1,nn);
	for(int l,r,x,i=1;i<=m;i++){
		x=q[i].x;
		l=lower_bound(a0+1,a0+nn+1,q[i].l)-a0;
		r=lower_bound(a0+1,a0+nn+1,q[i].r+1)-a0-1;
		if(x) Modify(1,l,r,1,nn,x);
		else printf("%.10lf\n",Query(1,l,r,1,nn));
	}
	return 0;
}