#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
 
using namespace std;
 
#define maxn 100010
#define maxm 400010
#define lson root<<1, l, mid
#define rson root<<1|1, mid + 1, r
#define ld double
 
int n, m;
int L[maxn], R[maxn], x[maxn], num[maxn<<1], add[maxm<<2];
ld _sin[maxm<<2], _cos[maxm<<2], sin05 = sin(0.5);
 
void Pushdown(int x) {
	ld tmp = _sin[x<<1], s = sin(add[x]), c = cos(add[x]);
	_sin[x<<1] = _sin[x<<1] * c + _cos[x<<1] * s, _cos[x<<1] = c * _cos[x<<1] - s * tmp;
	tmp = _sin[x<<1|1];
	_sin[x<<1|1] = _sin[x<<1|1] * c + _cos[x<<1|1] * s, _cos[x<<1|1] = c * _cos[x<<1|1] - s * tmp;
	add[x<<1] += add[x], add[x<<1|1] += add[x], add[x] = 0;
}
 
ld query(int root, int l, int r, int s, int t) {
	if(l < r && add[root]) Pushdown(root);
	if(l >= s && t >= r) return _sin[root];
	int mid = (l + r) >> 1; ld ans = 0;
	if(mid >= s) ans = query(lson, s, t);
	if(t > mid) ans += query(rson, s, t);
	return ans;
}
 
void modify(int root, int l, int r, int s, int t, int x) {
	if(l < r && add[root]) Pushdown(root);
	if(l >= s && t >= r) {
		ld tmp = _sin[root], c = cos(x), s = sin(x);
		add[root] += x, _sin[root] = _sin[root] * c + _cos[root] * s, _cos[root] = c * _cos[root] - s * tmp;
		return ;
	}
	int mid = (l + r) >> 1;
	if(mid >= s) modify(lson, s, t, x);
	if(mid < t) modify(rson, s, t, x);
	_sin[root] = _sin[root<<1] + _sin[root<<1|1], _cos[root] = _cos[root<<1] + _cos[root<<1|1];
}
 
void Buildtree(int root, int l, int r) {
	if(l == r) {
		if(l & 1) {
			_sin[root] = sin(num[(l + 1) >> 1]), _cos[root] = cos(num[(l + 1) >> 1]);
		} else {
			double L =(double)num[l >> 1] + 1, R = (double)num[l / 2 + 1] - 1;
			_sin[root] = (cos(L - 0.5) - cos(R + 0.5)) / (sin05 * 2);  
			_cos[root] = (sin(R + 0.5) - sin(L - 0.5)) / (sin05 * 2);
		}
		return ;
	}
	int mid = (l + r) >> 1;
	Buildtree(lson), Buildtree(rson);
	_sin[root] = _sin[root<<1] + _sin[root<<1|1], _cos[root] = _cos[root<<1] + _cos[root<<1|1];
}
 
int find(int x) {
	int l = 1, r = n, mid;
	while(l <= r) {
		mid = (l + r) >> 1;
		if(num[mid] >= x) r = mid - 1;
		else l = mid + 1;
	}
	return l;
}
 
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++) {
		scanf("%d%d%d", &L[i], &R[i], &x[i]);
		num[2 * i - 1] = L[i], num[2 * i] = R[i];
	}
	sort(num + 1, num + 2 * m + 1);
	n = (unique(num + 1, num + 2 * m + 1) - num) - 1;
	Buildtree(1, 1, 2 * n - 1);
	for(int i = 1; i <= m; i++) {
		L[i] = 2 * find(L[i]) - 1, R[i] = 2 * find(R[i]) - 1;
	}
	for(int i = 1; i <= m; i++) {
		if(x[i] == 0) printf("%.10lf\n", query(1, 1, 2 * n - 1, L[i], R[i]));
		else modify(1, 1, 2 * n - 1, L[i], R[i], x[i]);
	}
} 