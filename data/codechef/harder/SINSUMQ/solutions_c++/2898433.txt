#include<iostream>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<utility>
#include<sstream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<string>
#include<cctype>
#include<queue>
#include<deque>
#include<stack>
#include<cmath>
#include<ctime>
#include<list>
#include<map>
#include<set>
#define pi (acos(-1.0))
#define Abs(a) (((a)<0) ? (-(a)) :(a) )
#define rep(i,n) for((i)=0;(i)<(n);(i)++)
#define Rep(i,n) for(int i=0;i<(n);i++)
#define Rrep(i,n) for(int i=n-1;i>=0;i--)
#define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--)
#define Pii pair<int,int>
#define PB push_back
#define Size(x) ((int)(x.size()))
#define Sinesum(a,b,n)  (sin(((b)/2.0)*((n)+1))*sin((a)+((n)*(b))/2.0))/sin((b)/2.0)
#define Cossum(a,b,n) (sin(((b)/2.0)*((n)+1))*cos((a)+((n)*(b))/2.0))/sin((b)/2.0)
#define SZ 200005
using namespace std;
typedef long long mint;
typedef unsigned long long umint;
int l[SZ],r[SZ],d[SZ],lazy[4*SZ+5];
double ssum[4*SZ+5],cssum[4*SZ+5],si[4*SZ+5],cs[4*SZ+5];
set<Pii > s;
inline double fSinesum(int st,int add,int n)
{
    if(add==0||n<0)
        return (n+1)*sin(st);
    return Sinesum(st,add,n);
}
inline double fCossum(int st,int add,int n)
{
    if(add==0||n<0)
        return (n+1)*cos(st);
    return Cossum(st,add,n);
}
void build(int l,int r,int node)
{
    if(l==r)
    {
        ssum[node]=si[l];
        cssum[node]=cs[l];
        return ;
    }
    int mid=(l+r)/2;
    build(l,mid,2*node);
    build(mid+1,r,2*node+1);
    ssum[node]=ssum[2*node]+ssum[2*node+1];
    cssum[node]=cssum[2*node]+cssum[2*node+1];
}
inline double Smodi(double sn,double cs,int ext)
{
    return sn*cos(ext)+cs*sin(ext);
}
inline double Cmodi(double sn,double cs,int ext)
{
    return cs*cos(ext)-sn*sin(ext);
}
double query(int l,int r,int lft,int rght,int node,int sm)
{
    //cout<<l<<" "<<r<<" "<<lft<<" "<<rght<<" "<<ssum[node]<<" "<<lazy[node]<<endl;
    if(l>rght||r<lft)
        return 0.0;
    if(lft>=l&&rght<=r)
        return Smodi(ssum[node],cssum[node],sm+lazy[node]);
    int mid=(lft+rght)/2;
    return query(l,r,lft,mid,2*node,sm+lazy[node])+query(l,r,mid+1,rght,2*node+1,sm+lazy[node]);
}
void update(int l,int r,int lft,int rght,int val,int node)
{
    //cout<<l<<" "<<r<<" "<<lft<<" "<<rght<<" "<<ssum[node]<<" "<<cssum[node]<<" "<<lazy[node]<<endl;
    if(l>rght||r<lft)
        return;
    if(lft>=l&&rght<=r)
    {
        lazy[node]+=val;
        return ;
    }
    int mid=(lft+rght)/2;
    update(l,r,lft,mid,val,2*node);
    update(l,r,mid+1,rght,val,2*node+1);
    ssum[node]=Smodi(ssum[2*node],cssum[2*node],lazy[2*node])+Smodi(ssum[2*node+1],cssum[2*node+1],lazy[2*node+1]);
    cssum[node]=Cmodi(ssum[2*node],cssum[2*node],lazy[2*node])+Cmodi(ssum[2*node+1],cssum[2*node+1],lazy[2*node+1]);
    //cout<<lft<<" "<<rght<<" "<<ssum[node]<<" "<<cssum[node]<<" "<<lazy[2*node]<<" "<<lazy[2*node+1]<<endl;
}
int main()
{
    //freopen("in.txt","r",stdin);
    int n,q,i,a,b;
    scanf("%d%d",&n,&q);
    rep(i,q)
    {
        scanf("%d%d%d",&l[i],&r[i],&d[i]);
        if(l[i]>r[i])
            swap(l[i],r[i]);
        s.insert(Pii(l[i],0));
        s.insert(Pii(r[i]+1,0));
    }
    i=1;
    set<Pii >::iterator it=s.begin();
    int prev=it->first;
    it++;
    for(;it!=s.end();)
    {
        si[i]=fSinesum(prev,1,it->first-prev-1);
        cs[i]=fCossum(prev,1,it->first-prev-1);
        prev=it->first;
        s.insert(Pii(it->first,i));
        s.erase((s.find(Pii(prev,0))));
        it=s.upper_bound(Pii(prev,i));
        i++;
    }
    build(1,s.size()-1,1);
    rep(i,q)
    {
        a=s.lower_bound(Pii(l[i]+1,0))->second;
        b=s.lower_bound(Pii(r[i]+1,0))->second;
        if(d[i]==0)
            printf("%.12lf\n",query(a,b,1,s.size()-1,1,0));
        else
            update(a,b,1,s.size()-1,d[i],1);
    }
    return 0;
}


