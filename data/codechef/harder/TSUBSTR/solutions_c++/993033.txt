#include <stdio.h>
#include <string.h>
const int nmax = 250000, cmax = 26, S = sizeof(int)*cmax;

struct san {
    san *f, *ch[cmax];
    int l;
    long long sze;
}pl[nmax*2 + 18], *init = pl + 1;

int n, q, tot = 1;
long long K, total;
int fst[nmax + 18], nxt[nmax*2 + 18], pnt[nmax*2 + 18], eot;
char str[nmax + 18], alp[cmax + 18];
bool ed[nmax*2 + 18];

void add(int s, int t) 
{
    pnt[++eot] = t, nxt[eot] = fst[s], fst[s] = eot;
}

san *addsa(san *p, int c)
{
    san *q = pl + (++tot);
    q->l = p->l;
    for (; p && !p->ch[c]; p = p->f) p->ch[c] = q;
    if (!p) q->f = init;
    else
	if (p->ch[c]->l == p->l + 1) q->f = p->ch[c];
	else {
	    san *r = pl + (++tot), *u = p->ch[c];
	    memcpy(r->ch, u->ch, S);
	    r->f = u->f;
	    u->f = q->f = r;
	    for (; p && p->ch[c] == u; p = p->f) p->ch[c] = r;
	}
    return q;
}

void dfs(int k, san *A, int f)
{
    san *B = addsa(A, str[k] - 'a');
    for (int i = fst[k]; i; i = nxt[i])
	if (pnt[i] != f)
	    dfs(pnt[i], B, k);
}

inline long long gettal(san *a) 
{
    int k = a - pl;
    if (ed[k]) return a->sze;
    a->sze = ed[k] = 1;
    for (int i = 0; i < cmax; ++i) 
	if (a->ch[i]) a->sze += gettal(a->ch[i]);
    return a->sze;
}

void solve(san *a, long long k)
{
    int qt = 0;
    for (san *b; k; ) 
	for (int i = 0; i < cmax; ++i)
	    if (b = a->ch[alp[i] - 'a'])
		if (b->sze >= k) {
		    str[++qt] = alp[i], --k, a = b;
		    break;
		}
		else
		    k -= b->sze;
    str[qt + 1] = '\0';
    printf("%s\n", str + 1);
}

int main()
{
    scanf("%d%d", &n, &q);
    scanf("%s", str + 1);
    for (int i = 1, ss, tt; i < n; ++i)
	scanf("%d%d", &ss, &tt), add(ss, tt), add(tt, ss);
    dfs(1, init, -1);
    printf("%lld\n", total = gettal(init));
    while (q--) 
	if (scanf("%s %lld", alp, &K), K > total)
	    printf("-1\n");
	else 
	    solve(init, K - 1);
    return 0;
}
