#include <queue>
#include <vector>
#include <cassert>
#include <iostream>
#include <algorithm>
#include <string.h>
#include <stdio.h>

#define TR(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define REP(i, n) for (int i = 0; i < n; ++i)
#define PB push_back
#define MP make_pair
#define CLEAR(x) memset(x,0,sizeof(x))
#define FILL(x,c) memset(x,c,sizeof(x))

using namespace std;

const int MAXN = 600007;

struct SAM
{
    struct Node
    {
        int suf, ch[26];
        int maxi, dan;
        Node() : suf(-1), maxi(0), dan(0)
        {
            memset(ch, -1, sizeof(ch));
        }
    };

    SAM()
    {
        init();
    }

    void init()
    {
        total = 1;
        tree[0] = Node();
        root = last = 0;
        memset(sz, 0, sizeof(sz));
    }

    int extend(int w, int rear = -1)
    {
     //   cout << "extend("<<w<<","<<rear<<");\n";
        int p = (rear == -1 ? last : rear);
        int np = total++;
        tree[np].maxi = tree[p].maxi + 1;
        tree[np].dan = 1;
        while (-1 != p && -1 == tree[p].ch[w])
            tree[p].ch[w] = np, p = tree[p].suf;
        if (-1 == p)
            tree[np].suf = root;
        else
        {
            int q = tree[p].ch[w];
            if (tree[p].maxi+1 == tree[q].maxi)
                tree[np].suf = q;
            else
            {
                int nq = total++;
                memcpy(tree[nq].ch, tree[q].ch, sizeof(tree[q].ch));
                tree[nq].maxi = tree[p].maxi + 1;
                tree[nq].suf = tree[q].suf;
                tree[q].suf = nq;
                tree[np].suf = nq;
                while (p != -1 && tree[p].ch[w] == q)
                    tree[p].ch[w] = nq, p = tree[p].suf;
            }
        }
        last = np;
        return last;
    }
    int root, last;
    Node tree[MAXN];
    int total;

    //extend
    long long sz[MAXN];
    int in[MAXN];
    queue<int> Q;
    vector<int> from[MAXN];

    void dp()
    {
        REP(i, total) in[i] = 0;
        while (Q.size()) Q.pop();
        REP(i, total) REP(j, 26) if (tree[i].ch[j] != -1)
        {
            ++in[i];
            from[tree[i].ch[j]].PB(i);
        }
        REP(i, total) if (!in[i])
            Q.push(i);
        while (Q.size())
        {
            int now = Q.front();
            Q.pop();
            sz[now] = 1;
            REP(i, 26) if (tree[now].ch[i] != -1)
                sz[now] += sz[tree[now].ch[i]];
            TR(it, from[now])
            {
                --in[*it];
                if (!in[*it]) Q.push(*it);
            }
        }
    }
};

int where[250007];
int ch[250007][26];
vector<int> e[250007];
char c[250007];
bool vis[250007];
int id[250007];
SAM* sam;
int n, m;

void go()
{
    //cout << "u = " << u << " ch = " << c[u] << " have = " << have << endl;
    queue<int> Q;
    CLEAR(vis);
    FILL(where, -1);
    FILL(ch, -1);
    Q.push(0);

    int last = 1;

    id[0] = 0;
    where[0] = sam->extend(c[0]-'a');
    while (Q.size())
    {
        int u = Q.front();
  //      cout << "u = " << u << endl;
  //      cout << "ch[u] = " << c[u] << endl;
        vis[u] = true;
        Q.pop();
        assert(-1 != where[id[u]]);

        TR(it, e[u])
            if (!vis[*it])
            {
                if (ch[id[u]][c[*it]-'a'] == -1)
                {
                    ch[id[u]][c[*it]-'a'] = last++;
                    where[last-1] = sam->extend(c[*it]-'a', where[id[u]]);
                    id[*it] = last-1;
                }
                else
                {
                    id[*it] = ch[id[u]][c[*it]-'a'];
                }
                Q.push(*it);
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s", c);
    REP(i, n-1)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        --u, --v;
        e[u].PB(v);
        e[v].PB(u);
    }
    sam = new SAM();
    go();
    sam->dp();

 //   REP(i, sam->total)
 //       cout << "sam->sz["<<i<<"]="<<sam->sz[i]<<endl;

    cout << sam->sz[0] << endl;

    long long rank;
    while (m--)
    {
        scanf("%s%lld", c, &rank);
        int now = sam->root;
        if (rank > sam->sz[0])
        {
            printf("-1\n");
            continue;
        }
        while (true)
        {
            if (rank == 1) break;
            rank -= 1;
            for (int i = 0; i < 26; ++i)
                if (sam->tree[now].ch[c[i]-'a'] != -1)
                {
                    if (rank <= sam->sz[sam->tree[now].ch[c[i]-'a']])
                    {
                        printf("%c", c[i]);
                        now = sam->tree[now].ch[c[i]-'a'];
                        break;
                    }
                    else rank -= sam->sz[sam->tree[now].ch[c[i]-'a']];
                }
        }
        printf("\n");
    }
    return 0;
}
