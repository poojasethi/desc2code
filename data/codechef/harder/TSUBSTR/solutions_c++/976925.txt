#include <string>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <list>
#include <map>
#include <set>
#include <bitset>
#include <functional>
#include <utility>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string.h>
 
using namespace std;
 
typedef long long int64;

const int bufsize=128*1024;

char buf1[bufsize],buf2[bufsize];
int currentL1=0,bufL1=0,bufL2=0;

char lbuffer[1<<20];

char next_char()
{
	if (currentL1==bufL1)
	{
		bufL1=fread(buf1,sizeof(char),bufsize,stdin);
		if (bufL1==0) return 0;
		currentL1=0;
	}
	return buf1[currentL1++];
}
int next_int()
{
	char c=next_char();
	while (c<'0' || c>'9') c=next_char();
	int n=0;
	for (;c>='0' && c<='9';c=next_char()) n=n*10+(c-'0');
	return n;
}
int64 next_int64()
{
	char c=next_char();
	while (c<'0' || c>'9') c=next_char();
	int64 n=0;
	for (;c>='0' && c<='9';c=next_char()) n=n*10+(c-'0');
	return n;
}
void next_str(int *a)
{
	char c=next_char();
	while (c<'a' || c>'z') c=next_char();
	int L=0;
	for (;c>='a' && c<='z';c=next_char()) a[L++]=c-'a';
}
void flush_write()
{
	if (bufL2==0) return;
	fwrite(buf2,sizeof(char),bufL2,stdout);
	bufL2=0;
}
void write_char(char c)
{
	buf2[bufL2++]=c;
	if (bufL2==bufsize) flush_write();
}
void write_int(int n)
{
	if (n>=10) write_int(n/10);
	write_char((char)('0'+n%10));
}
void write_int64(int64 n)
{
	if (n>=10) write_int64(n/10);
	write_char((char)('0'+n%10));
}
void write_str(char *s)
{
	for (;*s!=0;s++) write_char(*s);
}

const int maxn=250000+5;
const int maxsize=1<<20;

int n,nQ;
int edge[maxn+maxn];
int key[maxn],deg[maxn],*graph[maxn],*ptr_graph[maxn],graph_buffer[maxn*4];
int father[maxn],treesize[maxn],q[maxn];
int root,nodes,dq[20][maxn];
int next[maxsize][26],one_next[maxsize];
int64 cnt[maxsize];
int leaf[maxsize];
int order[26];

int build(int depth,int size,int *q)
{
	int idx=nodes++;
	if (depth>0 && size==1)
	{
		cnt[idx]=treesize[q[0]];
		leaf[idx]=q[0];
		return idx;
	}
	for (int i=0;i<26;i++) next[idx][i]=-1;
	leaf[idx]=-1;
	int c[26],*g[26],*h[26];
	for (int i=0;i<26;i++) c[i]=0;
	if (depth==0)
		for (int i=0;i<size;i++) c[key[q[i]]]++;
	else
		for (int l=0;l<size;l++) 
		{ 
			int k=q[l]; 
			if (deg[k]==0) continue;
			if (one_next[k]>=0) c[one_next[k]]++;
			else for (int *p=next[k],i=0;i<26;i++) if (p[i]>=0) c[i]++;
		}
	for (int *p=dq[depth],i=0;i<26;i++) { g[i]=p; h[i]=p; p+=c[i]; }
	if (depth==0)
		for (int i=0;i<size;i++) { int w=key[q[i]]; *h[w]=q[i]; h[w]++; }
	else
		for (int l=0;l<size;l++)
		{
			int k=q[l];
			if (deg[k]==0) continue;
			if (one_next[k]>=0) { int i=one_next[k]; *h[i]=next[k][i]; h[i]++; }
			else for (int *p=next[k],i=0;i<26;i++) if (p[i]>=0) { *h[i]=p[i]; h[i]++; }
		}
	cnt[idx]=1;
	for (int i=0;i<26;i++) if (c[i]) 
	{
		int t=build(depth+1,c[i],g[i]);
		next[idx][i]=t;
		cnt[idx]+=cnt[t];
	}
	return idx;
}

int main()
{
#ifdef _MSC_VER
	freopen("input.txt","r",stdin);
#endif
	n=next_int();
	nQ=next_int();
	next_str(key);
	for (int i=0;i<n;i++) deg[i]=0;
	for (int i=0;i<n+n-2;i++) { edge[i]=next_int()-1; deg[edge[i]]++; }
	for (int *ptr_graph_buffer=graph_buffer,i=0;i<n;i++)
	{
		graph[i]=ptr_graph_buffer;
		ptr_graph_buffer+=deg[i]; 
	}
	for (int i=0;i<n;i++) ptr_graph[i]=graph[i];
	for (int i=0;i<n+n-2;i+=2) 
	{ 
		int a=edge[i];
		int b=edge[i+1];
		*ptr_graph[a]=b; ptr_graph[a]++; 
		*ptr_graph[b]=a; ptr_graph[b]++; 
	}
	for (int i=0;i<n;i++) father[i]=-1;
	father[0]=0;
	int sizeq=0;
	q[sizeq++]=0;
	for (int cl=0;cl<sizeq;cl++) for (int k=q[cl],f=father[k],i=deg[k]-1,*pos=graph[k];i>=0;i--) 
		if (pos[i]==f)
			swap(pos[i],pos[--deg[k]]);
		else
		{
			father[pos[i]]=k; 
			q[sizeq++]=pos[i]; 
		}
	memset(next,255,n*sizeof(next[0]));
	int new_sizeq=0;
	for (int *ptr_graph_buffer=graph_buffer+n+n,cl=0;cl<sizeq;cl++)
	{
		int k=q[cl];
		if (deg[k]<0) continue;
		q[new_sizeq++]=k;
		one_next[k]=-1;
		if (deg[k]<3)
		{
			if (deg[k]==0) continue;
			if (deg[k]==1) { int other=graph[k][0]; int c=key[other]; next[k][c]=other; one_next[k]=c; continue; }
			int o1=graph[k][0],c1=key[o1];
			int o2=graph[k][1],c2=key[o2];
			if (c1!=c2) { next[k][c1]=o1; next[k][c2]=o2; continue; }
		}
		int first[26],sdeg[26];
		bool conflict=false;
		for (int i=0;i<26;i++) first[i]=-1;
		for (int i=deg[k]-1;i>=0;i--)		
		{
			int other=graph[k][i];
			int c=key[other];
			if (first[c]<0) first[c]=other,sdeg[c]=deg[other];
			else { conflict=true; sdeg[c]+=deg[other]; }
		}
		if (!conflict)
			for (int i=0;i<26;i++) next[k][i]=first[i];
		else
		{
			for (int i=0;i<26;i++) if (first[i]>=0) 
			{
				int other=first[i];
				next[k][i]=other;
				if (sdeg[i]==deg[other]) continue;
				int *old=graph[other];
				graph[other]=ptr_graph_buffer;
				ptr_graph_buffer+=sdeg[i];
				memcpy(graph[other],old,deg[other]*sizeof(int));
				//for (int j=0;j<deg[other];j++) graph[other][j]=old[j];
			}
			for (int i=deg[k]-1;i>=0;i--)
			{
				int other=graph[k][i];
				int c=key[other];
				if (other==first[c]) continue;
				int sp=first[c];
				memcpy(graph[sp]+deg[sp],graph[other],deg[other]*sizeof(int));
				//for (int *ptr1=graph[sp]+deg[sp],*ptr2=graph[other],j=deg[other];j>0;j--) ptr1[j]=ptr2[j];
				deg[sp]+=deg[other];
				deg[other]=-1;
			}
		}
	}
	sizeq=new_sizeq;
	for (int cl=sizeq-1;cl>=0;cl--)
	{
		int k=q[cl],s=1;
		for (int i=0;i<26;i++) if (next[k][i]>=0) s+=treesize[next[k][i]];
		treesize[k]=s;
		cnt[k]=s;
	}
	nodes=n;
	root=build(0,sizeq,q);
	write_int64(cnt[root]);
	write_char('\n');
	for (;nQ>0;nQ--)
	{
		next_str(order);
		int64 idx=next_int64();
		if (idx>cnt[root])
		{
			write_char('-');
			write_char('1');
			write_char('\n');
			continue;
		}
		int p=root;
		bool done=false;
		while (leaf[p]<0)
		{
			if ((--idx)==0) { done=true; break; }
			if (idx<=(cnt[p]>>1))
				for (int i=0;i<26;i++) 
				{
					int s=next[p][order[i]]; if (s<0) continue;
					if (cnt[s]<idx) idx-=cnt[s]; else { write_char('a'+order[i]); p=s; break; }
				}
			else
			{
				int64 left=cnt[p]-1;
				for (int i=25;i>=0;i--) 
				{
					int s=next[p][order[i]]; if (s<0) continue;
					left-=cnt[s]; if (left<idx) { idx-=left; write_char('a'+order[i]); p=s; break; }
				}
			}
		}
		if (!done)
		{
			int ridx=(int)idx;
			p=leaf[p];
			while (1)
			{
				if ((--ridx)==0) break;
				if (one_next[p]>=0)
				{
					int i=one_next[p]; write_char('a'+i); p=next[p][i];
				}
				else if (ridx<=(treesize[p]>>1))
					for (int i=0;i<26;i++) 
					{
						int s=next[p][order[i]]; if (s<0) continue;
						if (treesize[s]<ridx) ridx-=treesize[s]; else { write_char('a'+order[i]); p=s; break; }
					}
				else
				{
					int left=treesize[p]-1;
					for (int i=25;i>=0;i--) 
					{
						int s=next[p][order[i]]; if (s<0) continue; 
						left-=treesize[s]; if (left<ridx) { ridx-=left; write_char('a'+order[i]); p=s; break; }
					}
				}
			}
		}
		write_char('\n');
	}
	flush_write();
	return 0;
}