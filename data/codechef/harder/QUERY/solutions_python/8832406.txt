#include <cstdio>
#include <cstring>

#ifdef _WIN32
#define LLFORMAT "I64"
#else
#define LLFORMAT "ll"
#endif

const int MAXN = 100005;
const int MAXQ = 100005;
const int MAXL = 35;

struct Node {
    static const int MAXNDN = 30000005;
    static Node nds[MAXNDN];
    static Node *newnode;

    Node *lc, *rc;
    long long s;
    long long v1;
    long long v2;
};

Node Node::nds[MAXNDN];
Node *Node::newnode = Node::nds;

struct Graph {
    struct Edge {
        int y;
        int next;
    };

    int n;
    Edge e[2 * MAXN];
    int eh[MAXN];
    int en;
    int fa[MAXN];
    int dep[MAXN];
    int size[MAXN];
    int dfn[MAXN];
    int top[MAXN];

    void init(int n_)
    {
        n = n_;
        memset(eh, -1, (size_t)n * sizeof(*eh));
        en = 0;
    }

    void addedge_one(int x, int y)
    {
        e[en].y = y;
        e[en].next = eh[x];
        eh[x] = en++;
    }

    void addedge(int x, int y)
    {
        addedge_one(x, y);
        addedge_one(y, x);
    }

    void BFSsize(int s);
    void DFSHLD(int s);
    int LCA(int x, int y) const;
    int splitpath(int x, int y, int (*res)[4]) const;
};

void Graph::BFSsize(int s)
{
    static int que[MAXN];
    int qb = 0, qe = 1;
    que[0] = s;
    fa[s] = -1;
    dep[s] = 0;
    while (qb < qe) {
        int x = que[qb++];
        for (int i = eh[x]; i != -1; i = e[i].next) {
            if (e[i].y != fa[x]) {
                fa[e[i].y] = x;
                dep[e[i].y] = dep[x] + 1;
                que[qe++] = e[i].y;
            }
        }
    }
    for (int i = 0; i < n; i++) {
        size[i] = 1;
    }
    for (int i = n - 1; i >= 1; i--) {
        size[fa[que[i]]] += size[que[i]];
    }
}

void Graph::DFSHLD(int s)
{
    static int heavyedge[MAXN];
    memset(heavyedge, -1, (size_t)n * sizeof(*heavyedge));
    for (int i = 0; i < n; i++) {
        for (int j = eh[i]; j != -1; j = e[j].next) {
            if (e[j].y != fa[i] && (heavyedge[i] == -1 || size[e[j].y] > size[e[heavyedge[i]].y])) {
                heavyedge[i] = j;
            }
        }
    }
    static int stk[MAXN][2];
    int stkn = 1;
    int dfnnow = 1;
    stk[0][0] = s;
    stk[0][1] = -2;
    dfn[s] = 0;
    top[s] = s;
    while (stkn) {
        int x = stk[stkn - 1][0];
        int y = stk[stkn - 1][1];
        if (y == -1) {
            stkn--;
        } else if (y == -2) {
            stk[stkn - 1][1] = eh[x];
            if (heavyedge[x] != -1) {
                dfn[e[heavyedge[x]].y] = dfnnow++;
                top[e[heavyedge[x]].y] = top[x];
                stk[stkn][0] = e[heavyedge[x]].y;
                stk[stkn][1] = -2;
                stkn++;
            }
        } else {
            stk[stkn - 1][1] = e[y].next;
            if (y != heavyedge[x] && e[y].y != fa[x]) {
                dfn[e[y].y] = dfnnow++;
                top[e[y].y] = e[y].y;
                stk[stkn][0] = e[y].y;
                stk[stkn][1] = -2;
                stkn++;
            }
        }
    }
}

int Graph::LCA(int x, int y) const
{
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]]) {
            x = fa[top[x]];
        } else {
            y = fa[top[y]];
        }
    }
    if (dep[x] < dep[y]) {
        return x;
    } else {
        return y;
    }
}

int Graph::splitpath(int x, int y, int (*res)[4]) const
{
    int x0 = x;
    int resn = 0;
    int z = LCA(x, y);
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]]) {
            res[resn][0] = dfn[top[x]];
            res[resn][1] = dfn[x] + 1;
            res[resn][2] = dep[x0] - dep[top[x]];
            res[resn][3] = -1;
            resn++;
            x = fa[top[x]];
        } else {
            res[resn][0] = dfn[top[y]];
            res[resn][1] = dfn[y] + 1;
            res[resn][2] = dep[x0] + dep[top[y]] - 2 * dep[z];
            res[resn][3] = 1;
            resn++;
            y = fa[top[y]];
        }
    }
    if (dep[x] < dep[y]) {
        res[resn][0] = dfn[x];
        res[resn][1] = dfn[y] + 1;
        res[resn][2] = dep[x0] - dep[x];
        res[resn][3] = 1;
        resn++;
    } else {
        res[resn][0] = dfn[y];
        res[resn][1] = dfn[x] + 1;
        res[resn][2] = dep[x0] - dep[y];
        res[resn][3] = -1;
        resn++;
    }
    return resn;
}

struct InState {
    int n, m;
    int e[MAXN][2];
    char qtype[MAXQ];
    int qr[MAXQ][4];
};

struct OutState {
    int ansn;
    long long ans[MAXQ];
};

InState in;
OutState out;

void input()
{
    scanf("%d%d", &in.n, &in.m);
    for (int i = 0; i < in.n - 1; i++) {
        scanf("%d%d", &in.e[i][0], &in.e[i][1]);
        in.e[i][0]--;
        in.e[i][1]--;
    }
    for (int i = 0; i < in.m; i++) {
        scanf(" %c", &in.qtype[i]);
        if (in.qtype[i] == 'c') {
            scanf("%d%d%d%d", &in.qr[i][0], &in.qr[i][1], &in.qr[i][2], &in.qr[i][3]);
        } else if (in.qtype[i] == 'q') {
            scanf("%d%d", &in.qr[i][0], &in.qr[i][1]);
        } else if (in.qtype[i] == 'l') {
            scanf("%d", &in.qr[i][0]);
        }
    }
}

Node *addval(const Node *now, int l, int r, int ql, int qr, int wa, int wb)
{
    Node *p = Node::newnode++;
    if (now) {
        *p = *now;
    }
    if (ql == l && qr == r) {
        p->v1 += wa;
        p->v2 += wb;
        return p;
    }
    int mid = (l + r) >> 1;
    if (qr <= mid) {
        p->lc = addval(p->lc, l, mid, ql, qr, wa, wb);
    } else if (ql >= mid) {
        p->rc = addval(p->rc, mid, r, ql, qr, wa, wb);
    } else {
        p->lc = addval(p->lc, l, mid, ql, mid, wa, wb);
        p->rc = addval(p->rc, mid, r, mid, qr, wa, wb);
    }
    p->s += (long long)wa * (ql + qr - 1) * (qr - ql) / 2 + (long long)wb * (qr - ql);
    return p;
}

long long getsum(const Node *now, int l, int r, int ql, int qr)
{
    if (!now) return 0;
    long long sum = (long long)now->v1 * (ql + qr - 1) * (qr - ql) / 2 + (long long)now->v2 * (qr - ql);
    if (ql == l && qr == r) {
        return sum + now->s;
    }
    int mid = (l + r) >> 1;
    if (qr <= mid) {
        sum += getsum(now->lc, l, mid, ql, qr);
    } else if (ql >= mid) {
        sum += getsum(now->rc, mid, r, ql, qr);
    } else {
        sum += getsum(now->lc, l, mid, ql, mid);
        sum += getsum(now->rc, mid, r, mid, qr);
    }
    return sum;
}

void solve()
{
    static Graph g;
    g.init(in.n);
    for (int i = 0; i < in.n - 1; i++) {
        g.addedge(in.e[i][0], in.e[i][1]);
    }
    g.BFSsize(0);
    g.DFSHLD(0);
    static Node *root[MAXQ];
    Node *nowroot = NULL;
    long long lastans = 0;
    int ccnt = 0;
    root[0] = NULL;
    out.ansn = 0;
    for (int i = 0; i < in.m; i++) {
        if (in.qtype[i] == 'c') {
            int x = (int)((in.qr[i][0] + lastans) % in.n);
            int y = (int)((in.qr[i][1] + lastans) % in.n);
            int wa = in.qr[i][2];
            int wb = in.qr[i][3];
            static int ts[MAXL][4];
            int tn = g.splitpath(x, y, ts);
            for (int j = 0; j < tn; j++) {
                int u = wb * ts[j][3];
                int v = wa + wb * (ts[j][2] - ts[j][3] * ts[j][0]);
                nowroot = addval(nowroot, 0, in.n, ts[j][0], ts[j][1], u, v);
            }
            root[++ccnt] = nowroot;
        } else if (in.qtype[i] == 'q') {
            int x = (int)((in.qr[i][0] + lastans) % in.n);
            int y = (int)((in.qr[i][1] + lastans) % in.n);
            static int ts[MAXL][4];
            int tn = g.splitpath(x, y, ts);
            long long ans = 0;
            for (int j = 0; j < tn; j++) {
                ans += getsum(nowroot, 0, in.n, ts[j][0], ts[j][1]);
            }
            out.ans[out.ansn++] = ans;
            lastans = ans;
        } else {
            int x = (int)((in.qr[i][0] + lastans) % (ccnt + 1));
            nowroot = root[x];
        }
    }
}

void output()
{
    for (int i = 0; i < out.ansn; i++) {
        printf("%"LLFORMAT"d\n", out.ans[i]);
    }
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("QUERY.in", "r", stdin);
    freopen("QUERY.out", "w", stdout);
#endif

    input();
    solve();
    output();

#ifndef ONLINE_JUDGE
    fclose(stdin); fclose(stdout);
#endif
    return 0;
}
