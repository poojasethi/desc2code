#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;

const int maxN=100005,maxM=maxN,logN=18,treepoolsize=maxM*logN*logN*1.1;

int N,len,tim;

struct node;
struct edge{
	node *ed;
	edge *next;
} E[maxN<<1],*newE=E;
struct node{
	edge *son;
	node *fa,*prefer,*top;
	int depth,size;
	int st,en;
	void dfssize(){
		size=1;
		for(edge *e=son;e;e=e->next) if(e->ed!=fa){
			e->ed->fa=this;
			e->ed->depth=depth+1;
			e->ed->dfssize();
			size+=e->ed->size;
			if(!prefer||e->ed->size>prefer->size) prefer=e->ed;
		}
	}
	void dfs(){
		if(fa&&fa->prefer==this) top=fa->top; else top=this;
		st=len++;
		if(prefer) prefer->dfs();
		for(edge *e=son;e;e=e->next) if(e->ed!=fa&&e->ed!=prefer)
			e->ed->dfs();
		en=len;
	}
} V[maxN];

struct tree{
	tree *l,*r;
	ll b,k,sum;
} treepool[treepoolsize],*newtree=treepool,*T[maxM];

ll K,B;

tree* cover(tree *las,int beg,int end,int L,int R){
	if(end<=L||beg>=R) return las;
	tree *cur=newtree++;
	if(newtree-treepool>treepoolsize) for(;;);
	if(las) *cur=*las;
	if(beg>=L&&end<=R){
		cur->b+=B;
		cur->k+=K;
		cur->sum+=((B*2+K*(end-beg-1))*(end-beg))>>1;
		B+=K*(end-beg);
		return cur;
	}
	int mid=(beg+end)>>1;
	cur->l=cover(cur->l,beg,mid,L,R);
	cur->r=cover(cur->r,mid,end,L,R);
	cur->sum=(cur->l?cur->l->sum:0)+(cur->r?cur->r->sum:0)+(((cur->b*2+cur->k*(end-beg-1))*(end-beg))>>1);
	return cur;
}

ll querysum(tree *cur,int beg,int end,int L,int R){
	if(end<=L||beg>=R||!cur) return 0;
	if(beg>=L&&end<=R) return cur->sum;
	int mid=(beg+end)>>1;
	int st=max(beg,L)-beg,en=min(end,R)-beg;
	return querysum(cur->l,beg,mid,L,R)+querysum(cur->r,mid,end,L,R)+(((cur->b*2+cur->k*(st+en-1))*(en-st))>>1);
}

void addchain(node *u,node *v,ll b,ll k){
	static pii seq1[logN+5],seq2[logN+5];
	pii *top1=seq1,*top2=seq2;
	while(u->top!=v->top){
		if(u->top->depth>=v->top->depth){
			*top1++=pii(u->top->st,u->st);
			u=u->top->fa;
		}
		else{
			*top2++=pii(v->top->st,v->st);
			v=v->top->fa;
		}
	}
	if(u->depth>=v->depth)
		*top1++=pii(v->st,u->st);
	else
		*top2++=pii(u->st,v->st);
	int cnt=0;
	for(pii *cur=seq1;cur<top1;cur++){
		cnt+=cur->second-cur->first+1;
		B=b+k*(cnt-1);
		K=-k;
		T[tim]=cover(T[tim],0,N,cur->first,cur->second+1);
	}
	for(pii *cur=top2;cur-->seq2;){
		B=b+k*cnt;
		K=k;
		T[tim]=cover(T[tim],0,N,cur->first,cur->second+1);
		cnt+=cur->second-cur->first+1;
	}
}

ll querysumchain(node *u,node *v){
	ll ans=0;
	while(u->top!=v->top){
		if(u->top->depth>=v->top->depth){
			ans+=querysum(T[tim],0,N,u->top->st,u->st+1);
			u=u->top->fa;
		}
		else{
			ans+=querysum(T[tim],0,N,v->top->st,v->st+1);
			v=v->top->fa;
		}
	}
	if(u->depth>=v->depth)
		ans+=querysum(T[tim],0,N,v->st,u->st+1);
	else
		ans+=querysum(T[tim],0,N,u->st,v->st+1);
	return ans;
}

int ctims,ctim[maxM];

int main(){
	int M; scanf("%d%d",&N,&M);
	for(int i=1;i<N;i++){
		int x,y; scanf("%d%d",&x,&y);
		*newE=(edge){V+y,V[x].son},V[x].son=newE++;
		*newE=(edge){V+x,V[y].son},V[y].son=newE++;
	}
	V[1].dfssize();
	V[1].dfs();
	ll ans=0;
	for(tim=1;tim<=M;tim++){
		static char type[2];
		static int x,y;
		scanf("%s",type);
		T[tim]=T[tim-1];
		if(type[0]=='c'){
			int a,b;
			scanf("%d%d%d%d",&x,&y,&a,&b);
			x=(x+ans)%N+1;
			y=(y+ans)%N+1;
			addchain(V+x,V+y,a,b);
			ctim[++ctims]=tim;
		}
		else
		if(type[0]=='q'){
			scanf("%d%d",&x,&y);
			x=(x+ans)%N+1;
			y=(y+ans)%N+1;
			ans=querysumchain(V+x,V+y);
			printf("%lld\n",ans);
		}
		else{
			scanf("%d",&x);
			x=(x+ans)%(ctims+1);
			T[tim]=T[ctim[x]];
		}
	}
}