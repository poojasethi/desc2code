#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAXN = 100005,MAXM = 30000005;

typedef long long LL;

struct Node
{
	int l,r;
	LL sum,k,b;
}T[MAXM];

int To[MAXN * 2],Next[MAXN * 2],Final[MAXN],Build[MAXM];
int Son[MAXN],Hfa[MAXN],Fa[MAXN],Dfn[MAXN],Deep[MAXN];
int Ord[MAXN],Refer[MAXN],N,M,cnt,Root,tot,total,TIME;

void read(int &x)
{
	char c;
	bool f = 0;
	while (c = getchar(),(c < '0' || c > '9') && c != '-');
	x = 0;
	if (c == '-') f = 1; else x = c - 48;
	while (c = getchar(),c >= '0' && c <= '9') x = x * 10 + c - 48;
	if (f) x = -x;
}

void Link(int u,int v)
{
	To[++ tot] = v,Next[tot] = Final[u],Final[u] = tot;
}

void Dfs(int Now,int Pre)
{
	Deep[Now] = Deep[Pre] + 1;
	Fa[Now] = Pre;
	Son[Now] = 1;
	for(int i = Final[Now];i;i = Next[i])
		if (To[i] != Pre) Dfs(To[i],Now),Son[Now] += Son[To[i]];
}

void Dfs_H(int Now,int Pre,int Hf)
{
	Hfa[Now] = Hf;
	Dfn[Now] = ++ total;
	Refer[total] = Now;
	int c = 0;
	for(int i = Final[Now];i;i = Next[i])
		if (To[i] != Pre && Son[To[i]] > Son[c]) c = To[i];
	if (c)
		Dfs_H(c,Now,Hf);
	for(int i = Final[Now];i;i = Next[i])
		if (To[i] != Pre && To[i] != c) Dfs_H(To[i],Now,To[i]);
}

LL Query(int l,int r,int i,int j,int jd)
{
	if (!jd || j < l || i > r) return 0;
	if (i <= l && r <= j) return T[jd].sum; else
	{
		int mid = l + r >> 1;
		LL tmp = Query(l,mid,i,j,T[jd].l) + Query(mid + 1,r,i,j,T[jd].r);
		i = max(l,i),j = min(r,j);
		if (i <= j) tmp = tmp + T[jd].b * (j - i + 1) + T[jd].k * ((i + j) * 1ll * (j - i + 1)) / 2;
		return tmp;
	}
}

int Change(int l,int r,int i,int j,LL k,LL b,int jd)
{
	if (j < l || i > r) return jd;
	int nt = jd;
	if (Build[jd] != TIME) nt = ++ cnt,Build[nt] = TIME;
	T[nt] = T[jd];
	if (i <= l && r <= j)
	{
		T[nt].k += k,T[nt].b += b;
		T[nt].sum += b * (r - l + 1) + k * ((l + r) * 1ll * (r - l + 1) / 2);
		return nt;
	}
	int mid = l + r >> 1;
	T[nt].l = Change(l,mid,i,j,k,b,T[jd].l),T[nt].r = Change(mid + 1,r,i,j,k,b,T[jd].r);
	T[nt].sum = T[T[nt].l].sum + T[T[nt].r].sum + T[nt].b * (r - l + 1) + T[nt].k * ((l + r) * 1ll * (r - l + 1) / 2);
	return nt;
}

LL Query(int u,int v)
{
	LL tmp = 0;
	for(;u != v;)
	{
		if (Deep[Hfa[u]] < Deep[Hfa[v]] || Hfa[u] == Hfa[v] && Deep[u] < Deep[v]) swap(u,v);
		if (Hfa[u] != Hfa[v])
			tmp += Query(1,N,Dfn[Hfa[u]],Dfn[u],Root),u = Fa[Hfa[u]]; else
				tmp += Query(1,N,Dfn[v] + 1,Dfn[u],Root),u = v;
	}
	tmp += Query(1,N,Dfn[u],Dfn[u],Root);
	return tmp;
}

void Change(int u,int v,LL k,LL b)
{
	static int Order[2][MAXN],C[2];
	++ TIME;
	memset(C,0,sizeof C);
	int l = 0;
	for(;u != v;)
	{
		if (Deep[Hfa[u]] < Deep[Hfa[v]] || Hfa[u] == Hfa[v] && Deep[u] < Deep[v]) swap(u,v),l ^= 1;
		if (Hfa[u] != Hfa[v])
			Order[l][++ C[l]] = u,Order[l][++ C[l]] = Hfa[u],u = Fa[Hfa[u]]; else
				Order[l][++ C[l]] = u,Order[l][++ C[l]] = Refer[Dfn[v] + 1],u = v;
	}
	reverse(Order[1] + 1,Order[1] + C[1] + 1);
	int c = 0;
	for(int i = 1;i <= C[0];i += 2)
	{
		int l = Order[0][i],r = Order[0][i + 1];
		LL b1 = b + k * c + k * Dfn[l];
		Root = Change(1,N,Dfn[r],Dfn[l],-k,b1,Root);
		c += Dfn[l] - Dfn[r] + 1;
	}
	Root = Change(1,N,Dfn[u],Dfn[u],0,k * c + b,Root);
	c ++;
	for(int i = 1;i <= C[1];i += 2)
	{
		int l = Order[1][i],r = Order[1][i + 1];
		swap(l,r);
		LL b1 = b + k * c - k * Dfn[r];
		Root = Change(1,N,Dfn[r],Dfn[l],k,b1,Root);
		c += Dfn[l] - Dfn[r] + 1;
	}
}

int main()
{
	read(N),read(M);
	for(int i = 1;i < N;i ++)
	{
		int u,v;
		read(u),read(v);
		Link(u,v),Link(v,u);
	}
	Dfs(1,0);
	Dfs_H(1,0,1);
	int cur = 0;
	LL lstans = 0;
	for(int i = 1;i <= M;i ++)
	{
		static char s[3];int l,r,k,b;
		scanf("%s", s);
		read(l);
		if (s[0] == 'l') l = (l + lstans) % (cur + 1),Root = Ord[l]; else
		{
			read(r);
			l = (l + lstans) % N + 1,r = (r + lstans) % N + 1;
			if (s[0] == 'q')	printf("%lld\n", lstans = Query(l,r)); else
			{
				read(b),read(k);
				Change(l,r,k,b);
				Ord[++ cur] = Root;
			}
		}
	}
	return 0;
}
