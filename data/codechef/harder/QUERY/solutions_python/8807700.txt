#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
using namespace std;
typedef unsigned long long UL;
const int N = 100500;
const int MN = 200500;
const int M = 35005000;
int point[N],to[MN],next[MN];
int fa[N],top[N],num[N],numx[N],tot[N],depth[N];
struct Node
{
	Node *lson,*rson;
	UL vx,vy,vz;
}tree[M],*root[N];
int zhan[N],zhancc;
int cc;
UL ans;
int n,m;
char getopt()
{
	char ch=getchar();
	while(ch<'a' || ch>'z')
		ch=getchar();
	return ch;
}
int getint()
{
	int res=0;
	char ch=getchar();
	while((ch<'0' || ch>'9') && ch!='-')
		ch=getchar();
	bool fan=0;
	if(ch=='-')
	{
		fan=1;
		ch=getchar();
	}
	while('0'<=ch && ch<='9')
	{
		res=res*10+ch-'0';
		ch=getchar();
	}
	if(fan)
		res=-res;
	return res;
}
void AddEdge(int x,int y)
{
	cc++;
	next[cc]=point[x];
	point[x]=cc;
	to[cc]=y;
}
void GetData()
{
	int i;
	n=getint();
	m=getint();
	for(i=1;i<n;i++)
	{
		int a=getint();
		int b=getint();
		AddEdge(a,b);
		AddEdge(b,a);
	}
}
void GetFa(int x)
{
	tot[x]=1;
	depth[x]=depth[fa[x]]+1;
	int now=point[x];
	while(now)
	{
		int tox=to[now];
		if(tox!=fa[x])
		{
			fa[tox]=x;
			GetFa(tox);
			tot[x]+=tot[tox];
		}
		now=next[now];
	}
}
void GetLine(int x,int y,int z)
{
	num[x]=y;
	numx[y]=x;
	top[x]=z;
	y++;
	int now,prefer=0;
	now=point[x];
	while(now)
	{
		int tox=to[now];
		if(tox!=fa[x] && tot[tox]>tot[prefer])
			prefer=tox;
		now=next[now];
	}
	if(!prefer)
		return;
	GetLine(prefer,y,z);
	y+=tot[prefer];
	now=point[x];
	while(now)
	{
		int tox=to[now];
		if(tox!=fa[x] && tox!=prefer)
		{
			GetLine(tox,y,tox);
			y+=tot[tox];
		}
		now=next[now];
	}
}
void Init()
{
	GetFa(1);
	GetLine(1,1,1);
	cc=0;
	tree[0].lson=tree[0].rson=tree;
	root[0]=tree;
}
void Change(Node *now,Node *last,int x,UL vx)
{
	UL vy=vx*x;
	UL vz=vy*x;
	int l=1,r=n;
	now->vx+=vx;
	now->vy+=vy;
	now->vz+=vz;
	while(l<r)
	{
		int mid=(l+r)/2;
		if(x<=mid)
		{
			if(now->lson==last->lson)
			{
				cc++;
				now->lson=tree+cc;
				now=now->lson;
				last=last->lson;
				now->vx=last->vx+vx;
				now->vy=last->vy+vy;
				now->vz=last->vz+vz;
				r=mid;
				break;
			}
			now=now->lson;
			last=last->lson;
			now->vx+=vx;
			now->vy+=vy;
			now->vz+=vz;
			r=mid;
		}
		else
		{
			if(now->rson==last->rson)
			{
				cc++;
				now->rson=tree+cc;
				now=now->rson;
				last=last->rson;
				now->vx=last->vx+vx;
				now->vy=last->vy+vy;
				now->vz=last->vz+vz;
				l=mid+1;
				break;
			}
			now=now->rson;
			last=last->rson;
			now->vx+=vx;
			now->vy+=vy;
			now->vz+=vz;
			l=mid+1;
		}
	}
	while(l<r)
	{
		int mid=(l+r)/2;
		if(x<=mid)
		{
			now->rson=last->rson;
			cc++;
			now->lson=tree+cc;
			now=now->lson;
			last=last->lson;
			now->vx=last->vx+vx;
			now->vy=last->vy+vy;
			now->vz=last->vz+vz;
			r=mid;
		}
		else
		{
			now->lson=last->lson;
			cc++;
			now->rson=tree+cc;
			now=now->rson;
			last=last->rson;
			now->vx=last->vx+vx;
			now->vy=last->vy+vy;
			now->vz=last->vz+vz;
			l=mid+1;
		}
	}
}
void ChangeSec(Node *now,Node *t,int l,int r,UL a,UL b)
{
	UL s=r-l;
	Change(now,t,l,a);
	if(l+1<=n)
		Change(now,t,l+1,b-a);
	if(r+1<=n)
		Change(now,t,r+1,-a-(s+1)*b);
	if(r+2<=n)
		Change(now,t,r+2,a+s*b);
}
Node *ChangeLine(Node *t,int x,int y,UL a,UL b)
{
	int xx=x,yy=y;
	UL tot=0;
	while(top[x]!=top[y])
	{
		if(depth[top[x]]>depth[top[y]])
		{
			tot+=num[x]-num[top[x]]+1;
			x=fa[top[x]];
		}
		else
		{
			tot+=num[y]-num[top[y]]+1;
			y=fa[top[y]];
		}
	}
	if(depth[x]<depth[y])
		tot+=num[y]-num[x]+1;
	else
		tot+=num[x]-num[y]+1;
	x=xx;y=yy;
	UL c=a+(tot-1)*b,d=-b;
	cc++;
	Node *res=tree+cc;
	*res=*t;
	while(top[x]!=top[y])
	{
		if(depth[top[x]]>depth[top[y]])
		{
			tot=num[x]-num[top[x]]+1;
			a+=tot*b;
			ChangeSec(res,t,num[top[x]],num[x],a-b,-b);
			x=fa[top[x]];
		}
		else
		{
			tot=num[y]-num[top[y]]+1;
			c+=tot*d;
			ChangeSec(res,t,num[top[y]],num[y],c-d,-d);
			y=fa[top[y]];
		}
	}
	if(depth[x]<depth[y])
	{
		tot=num[y]-num[x]+1;
		c+=tot*d;
		ChangeSec(res,t,num[x],num[y],c-d,-d);
	}
	else
	{
		tot=num[x]-num[y]+1;
		a+=tot*b;
		ChangeSec(res,t,num[y],num[x],a-b,-b);
	}
	return res;
}
Node Find(Node *x,int zl,int zr,int l,int r)
{
	if(zl==l && zr==r)
		return (*x);
	int mid=(l+r)/2;
	if(zr<=mid)
		return Find(x->lson,zl,zr,l,mid);
	if(zl>mid)
		return Find(x->rson,zl,zr,mid+1,r);
	Node a=Find(x->lson,zl,mid,l,mid);
	Node b=Find(x->rson,mid+1,zr,mid+1,r);
	a.vx+=b.vx;
	a.vy+=b.vy;
	a.vz+=b.vz; 
	return a;
}
UL FindSum(Node *t,int l,int r)
{
	UL s=r+1;
	Node val=Find(t,1,r,1,n);
	UL res=val.vz-val.vy*(2*s+1)+val.vx*(s*s+s);
	if(l>1)
	{
		s=l;
		val=Find(t,1,l-1,1,n);
		res-=val.vz-val.vy*(2*s+1)+val.vx*(s*s+s);
	}
	res/=2;
	return res;
}
UL FindAns(Node *t,int x,int y)
{
	UL res=0;
	while(top[x]!=top[y])
	{
		if(depth[top[x]]>depth[top[y]])
		{
			res+=FindSum(t,num[top[x]],num[x]);
			x=fa[top[x]];
		}
		else
		{
			res+=FindSum(t,num[top[y]],num[y]);
			y=fa[top[y]];
		}
	}
	if(depth[x]<depth[y])
		res+=FindSum(t,num[x],num[y]);
	else
		res+=FindSum(t,num[y],num[x]);
	return res;
}
void DoIt()
{
	int i;
	for(i=1;i<=m;i++)
	{
		char opt=getopt();
		if(opt=='c')
		{
			int a=(ans+getint())%n+1;
			int b=(ans+getint())%n+1;
			UL c=getint();
			UL d=getint();
			root[i]=ChangeLine(root[i-1],a,b,c,d);
			zhan[++zhancc]=i;
		}
		else if(opt=='q')
		{
			int a=(ans+getint())%n+1;
			int b=(ans+getint())%n+1;
			root[i]=root[i-1];
			ans=FindAns(root[i],a,b);
			cout<<ans<<endl;
		}
		else
		{
			int a=((ans+getint())%(zhancc+1));
			root[i]=root[zhan[a]];
		}
	}
}
int main()
{
	GetData();
	Init();
	DoIt();
	return 0;
}