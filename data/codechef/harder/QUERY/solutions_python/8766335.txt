#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long LL;
const int MAXN=100010;
int n,Q;
int head[MAXN],to[MAXN<<1],next[MAXN<<1],cnt=1;
inline void adde(int f,int t)
{
	cnt++,to[cnt]=t,next[cnt]=head[f],head[f]=cnt;
	cnt++,to[cnt]=f,next[cnt]=head[t],head[t]=cnt;
}
int fa[MAXN],dep[MAXN],size[MAXN],son[MAXN];
int anc[MAXN][20],Log[MAXN];
void DFS(int x)
{
	size[x]=1;
	for(int i=head[x];i;i=next[i])
		if(to[i]!=fa[x])
		{
			fa[to[i]]=x;
			anc[to[i]][0]=x;
			dep[to[i]]=dep[x]+1;
			DFS(to[i]);
			size[x]+=size[to[i]];
			if(size[to[i]]>size[son[x]]) son[x]=to[i];
		}
}
int top[MAXN],dfn[MAXN],dfs_clock;
void BuildTree(int x,int tp)
{
	dfn[x]=++dfs_clock,top[x]=tp;
	if(son[x]) BuildTree(son[x],tp);
	for(int i=head[x];i;i=next[i])
		if(to[i]!=fa[x]&&to[i]!=son[x])
			BuildTree(to[i],to[i]);
}
void initLCA()
{
	Log[0]=-1;
	for(int i=1;i<=n;i++) Log[i]=Log[i>>1]+1;
	for(int i=1;i<=Log[n];i++)
		for(int j=1;j<=n;j++)
			anc[j][i]=anc[anc[j][i-1]][i-1];
}
int LCA(int p,int q)
{
	if(dep[p]<dep[q]) swap(p,q);
	int d=dep[p]-dep[q];
	for(int i=Log[d];i>=0;i--)
		if(d&(1<<i)) p=anc[p][i];
	for(int i=Log[n];i>=0;i--)
		if(anc[p][i]!=anc[q][i]) p=anc[p][i],q=anc[q][i];
	if(p!=q) return anc[p][0];
	else return p;
}
LL getsum(LL a,LL d,LL n)
{
	return n*a+n*(n-1)/2*d;
}
struct Seg
{
	int l,r;
	int lch,rch;
	LL a,d,s;
}T[MAXN*300];
int root[MAXN],tot;
int MakeTree(int l,int r)
{
	int o=++tot;
	T[o].l=l,T[o].r=r;
	if(l==r) return o;
	int mid=(l+r)>>1;
	T[o].lch=MakeTree(l,mid);
	T[o].rch=MakeTree(mid+1,r);
	return o;
}
int Change(int x,int l,int r,LL a,LL d)
{
	int o=++tot;
	T[o]=T[x];
	if(T[o].l==l&&T[o].r==r)
	{
		T[o].a+=a;
		T[o].d+=d;
		T[o].s+=getsum(a,d,r-l+1);
		return o;
	}
	T[o].s+=getsum(a,d,r-l+1);
	int mid=(T[o].l+T[o].r)>>1;
	if(r<=mid) T[o].lch=Change(T[x].lch,l,r,a,d);
	else if(l>mid) T[o].rch=Change(T[x].rch,l,r,a,d);
	else
	{
		T[o].lch=Change(T[o].lch,l,mid,a,d);
		T[o].rch=Change(T[o].rch,mid+1,r,a+d*(mid-l+1),d);
	}
	return o;
}
LL Query(int x,int l,int r)
{
	if(T[x].l==l&&T[x].r==r) return T[x].s;
	int mid=(T[x].l+T[x].r)>>1;
	if(r<=mid) return getsum(T[x].a+(l-T[x].l)*T[x].d,T[x].d,r-l+1)+Query(T[x].lch,l,r);
	else if(l>mid) return getsum(T[x].a+(l-T[x].l)*T[x].d,T[x].d,r-l+1)+Query(T[x].rch,l,r);
	else return getsum(T[x].a+(l-T[x].l)*T[x].d,T[x].d,r-l+1)+Query(T[x].lch,l,mid)+Query(T[x].rch,mid+1,r);
}
int totVer,nowVer;
void Change(int x,int y,LL a,LL d)
{
	root[totVer]=root[nowVer];
	int lca=LCA(x,y);
	int D=dep[x]+dep[y]-dep[lca]-dep[lca]+1;
	LL ax=a,ay=a+(D-1)*d,dx=d,dy=-d;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y),swap(ax,ay),swap(dx,dy);
		LL Len=dep[x]-dep[top[x]]+1,Ax=ax+dx*(Len-1),Dx=-dx;
		root[totVer]=Change(root[totVer],dfn[top[x]],dfn[x],Ax,Dx);
		ax+=dx*(dep[x]-dep[top[x]]+1);
		x=fa[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y),swap(ax,ay),swap(dx,dy);
	root[totVer]=Change(root[totVer],dfn[x],dfn[y],ax,dx);
}
LL Query(int x,int y)
{
	LL res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=Query(root[nowVer],dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	res+=Query(root[nowVer],dfn[x],dfn[y]);
	return res;
}
char op[10];
LL lastans;
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i=1,x,y;i<n;i++) scanf("%d%d",&x,&y),adde(x,y);
	DFS(1);
	BuildTree(1,1);
	initLCA();
	root[0]=MakeTree(1,n);
	while(Q--)
	{
		int x,y;
		LL a,d;
		scanf("%s",op);
		if(op[0]=='c')
		{
			scanf("%d%d%lld%lld",&x,&y,&a,&d);
			x=(x+lastans)%n+1;
			y=(y+lastans)%n+1;
			++totVer;
			Change(x,y,a,d);
			nowVer=totVer;
		}
		else if(op[0]=='q')
		{
			scanf("%d%d",&x,&y);
			x=(x+lastans)%n+1;
			y=(y+lastans)%n+1;
			lastans=Query(x,y);
			printf("%lld\n",lastans);
		}
		else
		{
			scanf("%d",&x);
			x=(x+lastans)%(totVer+1);
			nowVer=x;
		}
	}
	return 0;
}
