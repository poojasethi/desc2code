//pb_ds 20160123_4
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cmath>
using namespace std;
#define RG register
#define set_file(File) freopen(File ".in", "r", stdin), freopen(File ".out", "w", stdout)
#define close_file() fclose(stdin), fclose(stdout)
#define For(i, a, b) for(RG int i = a, ___u = b; i <= ___u; ++i)
#define ForDown(i, a, b) for(RG int i = b, ___d = a; i >= ___d; --i)
#define cmax(i, j) ((i) < (j) ? (i) = (j) : (i))
#define cmin(i, j) ((i) > (j) ? (i) = (j) : (i))
#define dmax(i, j) ((j) < (i) ? (i) : (j))
#define dmin(i, j) ((i) < (j) ? (i) : (j))
#define ddel(i, j) ((i) > (j) ? (i) - (j) : (j) - (i))
#define dabs(i) ((i) > 0 ? (i) : -(i))
#define dsqr(x) ((x) * (x))
#define lowbit(i) ((i) & -(i))
typedef long long ll;
typedef double db;
typedef long double ld;
 
namespace io
{
	const int MAXBUF = 1 << 15;
	const int OUTPUT = 1 << 23;
	char B[MAXBUF], *S = B, *T = B;
	#define getc() (S == T && (T = (S = B) + fread(B, 1, MAXBUF, stdin), S == T) ? 0 : *S++)
	#define fastcall __attribute__((optimize("-O3")))
	#define IL __inline__ __attribute__((always_inline))
	template<class Type> IL Type read()
	{
		RG Type aa = 0; RG bool bb = 0; RG char ch, *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? bb = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		io::S = S, io::T = T; return bb ? -aa : aa;
	}
	int (*F)() = read<int>;
	template<> IL double read()
	{
		RG double aa = 0, bb;
		RG bool cc = 0;
		RG char ch;
		RG char *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? cc = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		if(ch == '.')
		{
			bb = 1;
			while(ch = getc(), ch >= '0' && ch <= '9')
				aa += (bb *= 0.1) * (ch - '0');
		}
		io::S = S, io::T = T;
		return cc ? -aa : aa;
	}

	IL int gets(RG char *s)
	{
		RG char *iter = s, *S = io::S, *T = io::T;
		while(*iter = getc(), *iter == ' ' || *iter == '\n' || *iter == '\r')
			;
		while(*++iter = getc(), *iter != ' ' && *iter != '\n' && *iter != '\r')
			;
		*iter = 0;		
		io::S = S, io::T = T;
		return iter - s;
	}
	IL char get()
	{
		RG char ch;
		while(ch = getc(), ch == ' ' || ch == '\n' || ch == '\r')
			;
		return ch;
	}
	
	char buff[OUTPUT], *iter = buff;
	template<class T>IL void P(RG T x, RG char ch = '\n')
	{
///*lgg*/cout << x << ch; return;
		static int stack[110]; RG int O = 0; RG char *iter = io::iter;
		if(!x)*iter++ = '0';
		else
		{
			(x < 0) ? x = -x, *iter++ = '-' : 1;
			for(; x; x /= 10) stack[++O] = x % 10;
			for(; O; *iter++ = '0' + stack[O--])
				;
		}
		*iter++ = ch, io::iter = iter;
	}

	IL void puts(RG const char *s) {while(*s) *iter++ = *s++;}
	IL void output() {fwrite(buff, 1, iter - buff, stdout), iter = buff;}
}

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

namespace pb_ds
{
	const int MAXN = 100010;
	struct Pointer {int to; Pointer *next;} *fir[MAXN];
	IL void link(RG int a, RG int b)
	{
		static Pointer mem[MAXN << 1], *tot = mem;
		*++tot = (Pointer) {b, fir[a]}, fir[a] = tot;
		*++tot = (Pointer) {a, fir[b]}, fir[b] = tot;
	}
	bool vis[MAXN];
	int dep[MAXN], fa[MAXN], size[MAXN], cho[MAXN];
	inline void dfs_init(RG int i)
	{
		size[i] = vis[i] = 1;
		for(RG Pointer *iter = fir[i]; iter; iter = iter->next)
			if(!vis[iter->to])
			{
				fa[iter->to] = i;
				dep[iter->to] = dep[i] + 1;
				dfs_init(iter->to);
				size[i] += size[iter->to];
				if(size[iter->to] > size[cho[i]])
					cho[i] = iter->to;
			}
///*lgg*/printf("dfs_init i = %d dep = %d fa = %d size = %d cho = %d\n",i,dep[i],fa[i],size[i],cho[i]);
	}
	int top[MAXN], pos[MAXN], timer;
	inline void dfs_make(RG int i)
	{
		vis[i] = 0;
		pos[i] = ++timer;
		top[i] = (i == cho[fa[i]]) ? top[fa[i]] : i;
///*lgg*/printf("i = %d top = %d pos = %d\n",i,top[i],pos[i]);
		if(cho[i])
		{
			dfs_make(cho[i]);
			for(RG Pointer *iter = fir[i]; iter; iter = iter->next)
				if(vis[iter->to]) dfs_make(iter->to);
		}		
	}	
	struct Node *null;
	struct Node
	{
		int A, B;		//对应的区间，A = (l + r)，B = (r - l + 1)
		int k; ll b;	//上面加的等差数列
		ll sum;			//区间和
		Node *lef, *rig;
		IL void do_add(RG int qk, RG ll qb)
		{
			k += qk;
			b += qb;
			sum += qb * B + (((ll) qk * A * B) >> 1);
		}
	} mem[MAXN * 18 * 18], *tot = mem, *ver[MAXN], *T;
	inline Node *build(RG int l, RG int r)
	{
		RG Node *o = ++tot;
		o->A = l + r;
		o->B = r - l + 1;
		o->sum = o->b = o->k = 0;
		if(l < r)
		{
			RG int m = (l + r) >> 1;
			o->lef = build(l, m);
			o->rig = build(m + 1, r);
			//o->push_up();
		}
		else o->lef = o->rig = null;
///*lgg*/printf("[%d, %d] A = %d B = %d\n", l, r, o->A,o->B);
		return o;
	}
	int ql, qr, qk;
	ll qb;
	IL int dist(RG int x, RG int y)
	{
		RG int ans = dep[x] + dep[y];
		while(top[x] != top[y])
			dep[top[x]] > dep[top[y]]
				? x = fa[top[x]]
				: y = fa[top[y]];
		return ans - (dmin(dep[x], dep[y]) << 1);
	}
	struct Data
	{
		int i;			//点
		int k;			//实际上加的等差数列
		ll b;
	};
	ll ans;
	inline void modify(RG Node* &o, RG int l, RG int r)
	{
		*++tot = *o;
		o = tot;
		if(ql <= l && r <= qr)
			o->do_add(qk, qb);
		else
		{
			//o->push_down();
			RG int m = (l + r) >> 1;
			if(ql <= m) modify(o->lef, l, m);
			if(m < qr) modify(o->rig, m + 1, r);
			cmax(l, ql);
			cmin(r, qr);
			o->sum += ((((ll) qk * (l + r) + (qb << 1))* (r - l + 1)) >> 1);
		}
///*lgg*/printf("modify [%d, %d] o->k = %d o->b = %lld o->sum = %lld\n",l,r,o->k,o->b,o->sum);
	}
	inline void query(RG Node *o, RG int l, RG int r)
	{
///*lgg*/assert(!null->sum && o != null);
		if(!o->sum) return;
		if(ql <= l && r <= qr)
		{
			(ans += o->sum);
///*lgg*/printf("query [%d, %d] o->k = %d o->b = %lld o->sum = %lld ans = %lld\n",l,r,o->k,o->b,o->sum, ans);
			return;
		}
		//o->push_down();
		RG int m = (l + r) >> 1;
		if(ql <= m) query(o->lef, l, m);
		if(m < qr) query(o->rig, m + 1, r);
		cmax(l, ql);
		cmin(r, qr);
		ans += ((((ll) o->k * (l + r) + (o->b << 1))* (r - l + 1)) >> 1);
///*lgg*/o->check();
	}
	
	IL void main()
	{
		RG int (*F)() = io::read<int>;
		RG char (*G)() = io::get;
		null = new Node;
		null->sum = 0;
		null->lef = null->rig = null;
		
		RG int n = F(), m = F(), t = 0;
		ver[0] = T = build(1, n);
		For(i, 2, n) link(F(), F());
		dfs_init(1);
		dfs_make(1);
		
		RG char cmd;
		RG int x, y, k;	
		RG int b;
		RG Data X, Y;
		while(m--)
		{
			cmd = G();
///*lgg*/fprintf(stderr, "m = %d cmd = %c (%d)\n", m,cmd,cmd);
			if(cmd == 'l')
				T = ver[(F() + ans) % (t + 1)];
			else if(cmd == 'c')
			{
				X.i = (F() + ans) % n + 1;
				Y.i = (F() + ans) % n + 1;
				b = F();
				k = F();
				if(!k && !b) goto save;
				X.k = -k;
				Y.k = k;
				X.b = b;
				Y.b = b + (ll) dist(X.i, Y.i) * k;	
///*lgg*/printf("modify x = %d y = %d\n",X.i,Y.i);	
				while(top[X.i] != top[Y.i])
				{
					#define modify_0(X) (X.b -= (ll) X.k * (dep[X.i] - dep[top[X.i]]), ql = pos[top[X.i]], qr = pos[X.i], qk = X.k, qb = X.b - (ll) X.k * pos[top[X.i]], modify(T, 1, n), X.i = fa[top[X.i]], X.b -= X.k)
					dep[top[X.i]] > dep[top[Y.i]]
						? modify_0(X) : modify_0(Y);
				}
				#define modify_1(X, Y) (X.b -= (ll) X.k * (dep[X.i] - dep[Y.i]), ql = pos[Y.i], qr = pos[X.i], qk = X.k, qb = X.b - (ll) X.k * pos[Y.i], modify(T, 1, n))
				dep[X.i] > dep[Y.i]
					? modify_1(X, Y) : modify_1(Y, X);
				save: ver[++t] = T;
			}
			else
			{
				x = (F() + ans) % n + 1;
				y = (F() + ans) % n + 1;
///*lgg*/printf("query x = %d y = %d\n", x, y);
				ans = 0;
				while(top[x] != top[y])
				{
					#define query_0(x) (ql = pos[top[x]], qr = pos[x], query(T, 1, n), x = fa[top[x]])
					dep[top[x]] > dep[top[y]]
						? query_0(x) : query_0(y);
				}
				#define query_1(x, y) (ql = pos[y], qr = pos[x], query(T, 1, n))
				dep[x] > dep[y]
					? query_1(x, y) : query_1(y, x);
				io::P(ans);
			}
				
		}
	}
}

int main()
{
	//set_file("god");
	pb_ds::main();
	io::output();
	close_file();
}
/*
10 100
1 2
2 3
2 4
2 5
2 6
5 7
1 8
8 9
1 10
^/\*lgg\*/
