#include <cstdio>
#include <vector>

#define fst first
#define snd second

typedef long long i64;
typedef std::pair<i64, i64> Info;

const int N = 100000 + 10;

int n, m;
std::vector<int> adj[N];

int fa[N], dep[N], size[N], son[N], top[N], map[N];

void bfs(int s) {
  static int q[N];
  int r = 1;
  q[r] = s;
  for (int f = 1; f <= r; ++f) {
    int a = q[f];
    for (auto b : adj[a]) {
      if (b != fa[a]) {
        fa[b] = a;
        dep[b] = dep[a] + 1;
        q[++r] = b;
      }
    }
  }
  for (int i = 1; i <= n; ++i) size[i] = 1;
  for (int i = r; i > 1; --i) {
    int a = q[i];
    size[fa[a]] += size[a];
    if (size[son[fa[a]]] < size[a]) son[fa[a]] = a;
  }
  for (int i = 1, cnt = 0; i <= r; ++i) {
    int a = q[i];
    if (!top[a]) {
      for (int j = a; j; j = son[j]) {
        map[j] = ++cnt;
        top[j] = a;
      }
    }
  }
}

inline Info& operator+= (Info &lhs, const Info &rhs) {
  lhs.fst += rhs.fst;
  lhs.snd += rhs.snd;
  return lhs;
}

Info shift(const Info &orig, int x) {
  return Info(orig.fst + x * orig.snd, orig.snd);
}

i64 calc(const Info &info, int p, int q, int l, int r) {
  int a = std::max(l, p), b = std::min(r, q);
  Info cur = shift(info, a - p);
  return cur.fst * (b - a + 1) + cur.snd * (b - a) * (b - a + 1) / 2;
}

namespace pst {

const int S = 300 * N;

int lch[S], rch[S];
i64 sum[S];
Info tag[S];

int tot = 0;

int p, q;
Info info;

int modify(int orig, int l, int r) {
  int res = ++tot;
  sum[res] = sum[orig];
  sum[res] += calc(info, p, q, l, r);
  tag[res] = tag[orig];
  lch[res] = lch[orig];
  rch[res] = rch[orig];
  if (p <= l && r <= q) {
    tag[res] += shift(info, l - p);
    return res;
  }
  int mid = (l + r) / 2;
  if (p <= mid) lch[res] = modify(lch[orig], l, mid);
  if (q > mid) rch[res] = modify(rch[orig], mid + 1, r);
  return res;
}

i64 query(int id, int l, int r) {
  if (p <= l && r <= q) return sum[id];
  i64 res = calc(tag[id], l, r, p, q);
  int mid = (l + r) / 2;
  if (p <= mid) res += query(lch[id], l, mid);
  if (q > mid) res += query(rch[id], mid + 1, r);
  return res;
}

}

std::vector<Info> path;

void select(int a, int b) {
  static std::vector<Info> p, q;
  p.clear(), q.clear();
  while (top[a] != top[b]) {
    int x = top[a], y = top[b];
    if (dep[x] > dep[y]) {
      p.push_back(Info(map[a], map[x]));
      a = fa[x];
    } else {
      q.push_back(Info(map[y], map[b]));
      b = fa[y];
    }
  }
  (dep[a] > dep[b] ? p : q).push_back(Info(map[a], map[b]));
  path = p;
  for (int i = q.size() - 1; i >= 0; --i) path.push_back(q[i]);
}

int modify(int orig, int x, int y, int a, int b) {
  Info cur(a, b);
  select(x, y);
  int t = 0, res = orig;
  for (int i = 0; i < path.size(); ++i) {
    int l = path[i].fst, r = path[i].snd;
    Info cur = shift(Info(a, b), t);
    if (l > r) {
      std::swap(l, r);
      int temp = r - l + 1;
      cur.fst += cur.snd * (temp - 1);
      cur.snd = -cur.snd;
    }
    pst::p = l, pst::q = r;
    pst::info = cur;
    res = pst::modify(res, 1, n);
    t += r - l + 1;
  }
  return res;
}

i64 query(int t, int x, int y) {
  select(x, y);
  i64 res = 0;
  for (int i = 0; i < path.size(); ++i) {
    int l = path[i].fst, r = path[i].snd;
    if (l > r) std::swap(l, r);
    pst::p = l;
    pst::q = r;
    res += pst::query(t, 1, n);
  }
  return res;
}

int main() {
#ifndef ONLINE_JUDGE
  freopen("in.txt", "r", stdin);
#endif
  scanf("%d%d", &n, &m);
  for (int i = n - 1; i--;) {
    int x, y;
    scanf("%d%d", &x, &y);
    adj[x].push_back(y);
    adj[y].push_back(x);
  }
  bfs(1);
  std::vector<int> root;
  root.push_back(0);
  i64 ans = 0;
  for (int cur = 0; m--;) {
    char op;
    int x, y, a, b;
    scanf(" %c%d", &op, &x);
    switch (op) {
      case 'c':
        scanf("%d%d%d", &y, &a, &b);
        x = (x + ans) % n + 1;
        y = (y + ans) % n + 1;
        root.push_back(modify(root[cur], x, y, a, b));
        cur = root.size() - 1;
        break;
      case 'q':
        scanf("%d", &y);
        x = (x + ans) % n + 1;
        y = (y + ans) % n + 1;
        printf("%lld\n", ans = query(root[cur], x, y));
        break;
      case 'l':
        x = (x + ans) % root.size();
        cur = x;
        break;
    }
  }
  return 0;
}
