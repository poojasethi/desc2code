#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cassert>
#define rep(i,a,b) for (int i=a;i<=b;i++)
#define drep(i,a,b) for (int i=a;i>=b;i--)
#define INF int(1e8)
#define LL long long
#define pb push_back
#define mp make_pair
#define clr(a) memset(a,0,sizeof(a));
using namespace std;
const int N=30000000;
const int NN=320000;
vector<int> E[NN];
int fa[NN],f[NN][20],size[NN],An[NN],cnt,dep[NN],Root[NN],dfn[NN],pos[NN],ti,n;
struct Node
{
	int L,R;
	LL sum,A,B;
}t[N];
LL lastans;
void dfs(int x,int Fa)
{
	dep[x]=dep[Fa]+1;f[x][0]=Fa;size[x]=1;
	for (int i=0;i<E[x].size();i++)
		if (E[x][i]!=Fa) dfs(E[x][i],x),size[x]+=size[E[x][i]];
}
void Dfs(int x,int Fa,int c)
{
	dfn[x]=++ti;An[x]=c;
	int Max=0,il=0;
	for(int i=0;i<E[x].size();i++)
		if (E[x][i]!=Fa) if (size[E[x][i]]>Max) Max=size[E[x][i]],il=E[x][i];
	if (il) Dfs(il,x,c);
	for (int i=0;i<E[x].size();i++)
		if (E[x][i]!=Fa && E[x][i]!=il) Dfs(E[x][i],x,E[x][i]);
}
void dp() {rep(j,1,18) rep(i,1,n) f[i][j]=f[f[i][j-1]][j-1];}
int lca(int x,int y)
{
	if (dep[x]<dep[y]) swap(x,y);
	drep(i,18,0)
		if (dep[f[x][i]]>=dep[y]) x=f[x][i];
	if (x==y) return x;
	drep(i,18,0)
		if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
int build(int l,int r)
{
	int c=++cnt;
	if (l==r) return cnt;
	int mid=(l+r)>>1;
	t[c].L=build(l,mid);t[c].R=build(mid+1,r);
	return c;
}
void addflag(int w,LL A,LL B,int l,int r)
{
	if (w==0) return;
	t[w].sum+=A*(r-l+1)+B*(l+r)*(r-l+1)/2ll;
	t[w].A+=A;t[w].B+=B;
}
int add(int w,int l,int r,int A,int B,int u=1,int v=n)
{
	int p=++cnt;t[p]=t[w];
	if (u==l && v==r)
	{
		addflag(p,A,B,u,v);
		return p;
	}
	int mid=(u+v)>>1;
	if (r<=mid) t[p].L=add(t[w].L,l,r,A,B,u,mid);
	else if (l>mid) t[p].R=add(t[w].R,l,r,A,B,mid+1,v);
	else
	{
		t[p].L=add(t[w].L,l,mid,A,B,u,mid);
		t[p].R=add(t[w].R,mid+1,r,A,B,mid+1,v);
	}
	t[p].sum=t[t[p].L].sum+t[t[p].R].sum+t[p].A*(v-u+1)+t[p].B*(u+v)*(v-u+1)/2ll;
	return p;
}
LL ask(int w,int l,int r,int u=1,int v=n)
{
	if (l==u && r==v) return t[w].sum;
	int mid=(u+v)>>1;
	LL oth=t[w].A*(r-l+1)+t[w].B*(l+r)*(r-l+1)/2LL;
	if (r<=mid) return ask(t[w].L,l,r,u,mid)+oth;
	else if (l>mid) return ask(t[w].R,l,r,mid+1,v)+oth;
	else return ask(t[w].L,l,mid,u,mid)+ask(t[w].R,mid+1,r,mid+1,v)+oth;
}
void solve(int rt,int x,int y)
{
	LL ans=0;
	while (An[x]!=An[y])
	{
		int xx=An[x],yy=An[y];
		if (dep[xx]<dep[yy]) swap(x,y),swap(xx,yy);
		ans+=ask(rt,dfn[xx],dfn[x]);
		x=fa[xx];
	}
	if (dep[x]>dep[y]) swap(x,y);
	ans+=ask(rt,dfn[x],dfn[y]);
	printf("%lld\n",lastans=ans);
}
void change(int rtid,int x,int y,int A,int B)
{
	int L=0,R=0,len=dep[x]+dep[y]-dep[lca(x,y)]*2+1;
	while (An[x]!=An[y])
	{
		int xx=An[x],yy=An[y];
		if (dep[xx]<dep[yy])
		{
			R+=dep[y]-dep[yy]+1;
			Root[rtid]=add(Root[rtid],dfn[yy],dfn[y],A+B*(len-R-dfn[yy]),B);
			y=fa[yy];
		}
		else
		{
			Root[rtid]=add(Root[rtid],dfn[xx],dfn[x],A+B*(L+dfn[x]),-B);
			L+=dep[x]-dep[xx]+1;
			x=fa[xx];
		}
	}
	if (dep[x]<dep[y])
	{
		R+=dep[y]-dep[x]+1;
		Root[rtid]=add(Root[rtid],dfn[x],dfn[y],A+B*(len-R-dfn[x]),B);
	}
	else
	{
		Root[rtid]=add(Root[rtid],dfn[y],dfn[x],A+B*(L+dfn[x]),-B);
		L+=dep[x]-dep[y]+1;
	}
}
char s[10];
int m,x,y,A,B;
int main()
{
//	freopen("QUERY.in","r",stdin);
	scanf("%d%d",&n,&m);
	rep(i,1,n-1) scanf("%d%d",&x,&y),E[x].pb(y),E[y].pb(x);
	dfs(1,0);Dfs(1,0,1);dp();
	rep(i,1,n) fa[i]=f[i][0];
	Root[0]=build(1,n);
	int tot=0;
	rep(i,1,m)
	{
		scanf("%s",s);
		if (s[0]=='l')
		{
			scanf("%d",&x);
			x=(x+lastans)%(tot+1);
			Root[i]=Root[pos[x]];
		}
		else if (s[0]=='c')
		{
			Root[i]=Root[i-1];
			++tot;pos[tot]=i;
			scanf("%d%d%d%d",&x,&y,&A,&B);
			x=(x+lastans)%n+1;y=(y+lastans)%n+1;
			change(i,x,y,A,B);
		}
		else if (s[0]=='q')
		{
			Root[i]=Root[i-1];
			scanf("%d%d",&x,&y);
			x=(x+lastans)%n+1;y=(y+lastans)%n+1;
			solve(Root[i],x,y);
		}
	}
}
