#include<algorithm>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include  <stdio.h>
#include   <math.h>
#include   <time.h>
#include   <vector>
#include    <queue>
#include      <map>
#include      <set>
using namespace std;

namespace INPUT
{
	const int L=1<<15;
	char buffer[L],*S,*T,ch;
	
	char Get_Char()
	{
		if(S==T)
		{
			T=(S=buffer)+fread(buffer,1,L,stdin);
			if(S==T)
				return EOF;
		}
		return *S++;
	}
	
	void get(int& x)
	{
		for(ch=Get_Char();ch<'0'||ch>'9';ch=Get_Char());
		x=ch^'0';
		for(ch=Get_Char();ch>='0'&&ch<='9';ch=Get_Char())
			x=x*10+(ch^'0');
	}
	
	char get_char()
	{
		for(ch=Get_Char();ch<'a'||ch>'z';ch=Get_Char());
		return ch;
	}
}

#define get INPUT::get

const int N=200005,M=35000005;

typedef long long LL;

int e[N],next[N],G[N],tot,n,m,son[N],pre[N],sz[N],dep[N],top[N],pos[N],fp[N];

void adde(int u,int v)
{
	e[++tot]=v;next[tot]=G[u];G[u]=tot;
	e[++tot]=u;next[tot]=G[v];G[v]=tot;
}

void dfs1(int u,int p)
{
	sz[u]=1;pre[u]=p;dep[u]=dep[p]+1;
	for(int i=G[u],v;i;i=next[i])
		if((v=e[i])!=p)
		{
			dfs1(v,u);sz[u]+=sz[v];
			if(sz[v]>sz[son[u]])
				son[u]=v;
		}
}

void dfs2(int u,int tp)
{
	top[u]=tp;pos[u]=++tot;fp[tot]=u;
	if(son[u])
		dfs2(son[u],tp);
	for(int i=G[u],v;i;i=next[i])
		if((v=e[i])!=pre[u]&&v!=son[u])
			dfs2(v,v);
}

int LCA(int u,int v)
{
	while(top[u]!=top[v])
		if(dep[top[u]]>dep[top[v]])
			u=pre[top[u]];
		else
			v=pre[top[v]];
	return dep[u]>dep[v]?v:u;
}

int Lc[M],Rc[M],rt[N],Now,TOT;

LL S[M],K[M],B[M],Sd[N];

void Make_Sd()
{
	for(int i=1;i<=n;i++)
		Sd[i]=Sd[i-1]+dep[fp[i]];
}

#define Mid (l+r>>1)

void update(int &x,int y,int l,int r,int L,int R,LL k,LL b)
{
	x=++tot;
	S[x]=S[y];K[x]=K[y];B[x]=B[y];Lc[x]=Lc[y];Rc[x]=Rc[y];
	if(L<=l&&r<=R)
	{
		K[x]+=k;B[x]+=b;S[x]+=k*(Sd[r]-Sd[l-1])+b*(r-l+1);
		return;
	}
	if(L<=Mid)
		update(Lc[x],Lc[y],l,Mid,L,R,k,b);
	if(R>Mid)
		update(Rc[x],Rc[y],Mid+1,r,L,R,k,b);
	S[x]=S[Lc[x]]+S[Rc[x]]+K[x]*(Sd[r]-Sd[l-1])+B[x]*(r-l+1);
}

LL Ask(int x,int l,int r,int L,int R)
{
	if(!x)
		return 0;
	if(L<=l&&r<=R)
		return S[x];
	int ll=max(l,L),rr=min(r,R);
	LL s=(rr-ll+1)*B[x]+K[x]*(Sd[rr]-Sd[ll-1]);
	if(L<=Mid)
		s+=Ask(Lc[x],l,Mid,L,R);
	if(R>Mid)
		s+=Ask(Rc[x],Mid+1,r,L,R);
	return s;
}

void update(int u,int v,LL k,LL b,int f,int& rt)
{
	while(dep[top[u]]>dep[v])
		update(rt,rt,1,n,pos[top[u]],pos[u],k,b),u=pre[top[u]];
	if(f&&u==v)
		return;
	update(rt,rt,1,n,pos[v]+f,pos[u],k,b);
}

LL Ask(int u,int v,int f,int& rt)
{
	LL s=0;
	while(dep[top[u]]>dep[v])
		s+=Ask(rt,1,n,pos[top[u]],pos[u]),u=pre[top[u]];
	if(f&&u==v)
		return s;
	return s+Ask(rt,1,n,pos[v]+f,pos[u]);
}

int main()
{
	get(n);get(m);
	for(int i=1,u,v;i<n;i++)
		get(u),get(v),adde(u,v);
	tot=0;dfs1(1,0);dfs2(1,1);tot=0;Make_Sd();
	LL Ans=0;
	while(m--)
	{
		static char c;
		c=INPUT::get_char();
		if(c=='c')
		{
			static int x,y,a,b,lca;
			get(x);get(y);get(a);get(b);
			x=(x+Ans)%n+1;y=(y+Ans)%n+1;
			TOT++;rt[TOT]=rt[Now];Now=TOT;
			lca=LCA(x,y);
			update(x,lca,-b,a+dep[x]*(LL)b,0,rt[Now]);
			update(y,lca,b,a+(dep[x]-2*dep[lca])*(LL)b,1,rt[Now]);
		}
		else if(c=='q')
		{
			static int x,y,lca;
			get(x);get(y);
			x=(x+Ans)%n+1;y=(y+Ans)%n+1;
			lca=LCA(x,y);
			printf("%lld\n",Ans=Ask(x,lca,0,rt[Now])+Ask(y,lca,1,rt[Now]));
		}
		else
		{
			static int w;
			get(w);
			Now=(w+Ans)%(TOT+1);
		}
	}
	return 0;
}
