#include <iostream>
#include <fstream>
#include <cstring>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <ctime>
#include <map>
#include <queue>
#include <set>
using namespace std;

const int maxn=100000+15;
struct Edge
{
	int x,y,next;
	Edge(int x=0,int y=0,int next=0):x(x),y(y),next(next) {}
}edge[maxn*2];
int sumedge,head[maxn];
int n,m;
int ins(int x,int y)
{
	edge[++sumedge]=Edge(x,y,head[x]);
	return head[x]=sumedge;
}
int hh,tt,line[maxn];
int dep[maxn],fa[maxn],son[maxn];
int w[maxn],top[maxn],siz[maxn];
struct Node
{
	long long sum,a,b;
	int l,r;
}pp[maxn*18*18];
int tot,root[maxn],cur,cnt;
int bfs()
{
	line[hh=tt=1]=1;
	dep[1]=1;
	for (;hh<=tt;hh++)
	 for (int u=head[line[hh]];u;u=edge[u].next)
	 	if (edge[u].y!=fa[line[hh]])
	 	{
	 		fa[edge[u].y]=line[hh];
	 		dep[edge[u].y]=dep[line[hh]]+1;
	 		line[++tt]=edge[u].y;
	 	}
	for (int i=1;i<=n;i++) siz[i]=1;
	for (hh=tt;hh>1;hh--) siz[fa[line[hh]]]+=siz[line[hh]];
	for (int i=1;i<=n;i++)
		for (int u=head[i];u;u=edge[u].next)
			if (edge[u].y!=fa[i])
				if (son[i]==0 || siz[son[i]]<siz[edge[u].y])
					son[i]=edge[u].y;
	int num=0;
	for (hh=tt;hh>=1;hh--)
		if (top[line[hh]]==0)
		{
			int x=line[hh],y;
			for (y=x;y!=1 && son[fa[y]]==y;y=fa[y]);
			for (;x!=y;w[x]=++num,top[x]=y,x=fa[x]);
			w[y]=++num;
			top[y]=y;
		}
	return 0;
}
int foundlca(int x,int y)
{
	int fx=top[x],fy=top[y];
	while (fx!=fy)
	{
		if (dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);
		x=fa[fx];
		fx=top[x];
	}
	if (dep[x]<dep[y]) swap(x,y);
	return y;
}
int ins(int root,int l,int r,int x,int y,int a,int b)
{
	if (l>y || r<x) return root;
	int w=++tot;
	pp[w]=pp[root];
	long long xl=max(l,x),xr=min(r,y);
	long long tl=a+(xl-x)*b,tr=a+(xr-x)*b;
	pp[w].sum+=(tl+tr)*(xr-xl+1)/2;
	if (x<=l && r<=y)
	{
		pp[w].a+=a+(l-x)*b;
		pp[w].b+=b;
		return w;
	}
	int mid=(l+r)>>1;
	pp[w].l=ins(pp[w].l,l,mid,x,y,a,b);
	pp[w].r=ins(pp[w].r,mid+1,r,x,y,a,b);
	return w;
}
long long found(int root,int l,int r,int x,int y)
{
	if (root==0 || l>y || r<x) return 0;
	if (x<=l && r<=y) return pp[root].sum;
	long long xl=max(l,x),xr=min(r,y);
	long long tl=pp[root].a+(xl-l)*pp[root].b,tr=pp[root].a+(xr-l)*pp[root].b;
	long long ans=0;
	if ((tl+tr)%2==0) ans=(tl+tr)/2*(xr-xl+1);
	 else ans=(xr-xl+1)/2*(tl+tr);
	int mid=(l+r)>>1;
	return ans+found(pp[root].l,l,mid,x,y)+found(pp[root].r,mid+1,r,x,y);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		ins(x,y);
		ins(y,x);
	}
	bfs();
	long long lastans=0;
	while (m--)
	{
		char od[2];
		scanf("%s",od);
		if (od[0]=='c')
		{
			int x,y,a,b;
			scanf("%d%d%d%d",&x,&y,&a,&b);
			x=(x+lastans)%n+1,y=(y+lastans)%n+1;
			int ix=x,iy=y;
			int lcaa=foundlca(x,y);
			int fx=top[x],fy=top[y];
			root[++cnt]=root[cur];
			cur=cnt;
			while (fx!=top[lcaa])
			{
				root[cur]=ins(root[cur],1,n,w[x],w[fx],a+(dep[ix]-dep[x])*b,b);
				x=fa[fx];
				fx=top[x];
			}
			int mb=a+(dep[ix]+dep[iy]-2*dep[lcaa])*b;
			while (fy!=top[lcaa])
			{
				root[cur]=ins(root[cur],1,n,w[y],w[fy],mb-(dep[iy]-dep[y])*b,-b);
				y=fa[fy];
				fy=top[y];
			}
			if (dep[x]<dep[y])
			 root[cur]=ins(root[cur],1,n,w[y],w[x],mb-(dep[iy]-dep[y])*b,-b);
			else
			 root[cur]=ins(root[cur],1,n,w[x],w[y],a+(dep[ix]-dep[x])*b,b);
		}
		else
		if (od[0]=='q')
		{
			int x,y;
			scanf("%d%d",&x,&y);
			x=(x+lastans)%n+1;y=(y+lastans)%n+1;
			lastans=0;
			int fx=top[x],fy=top[y];
			while (fx!=fy)
			{
				if (dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);
				lastans+=found(root[cur],1,n,w[x],w[fx]);
				x=fa[fx];
				fx=top[x];
			}
			if (dep[x]<dep[y]) swap(x,y);
			lastans+=found(root[cur],1,n,w[x],w[y]);
			printf("%lld\n",lastans);
		}
		else
		if (od[0]=='l')
		{
			int x;
			scanf("%d",&x);
			x=(x+lastans)%(cnt+1);
			cur=x;
		}
	}
	return 0;
}
