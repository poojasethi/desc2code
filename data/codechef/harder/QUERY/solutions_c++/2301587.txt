#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<vector>
#include<map>
#include<queue>
#include<set>
#define X first
#define Y second
#define fr(i,n) for(int i=1;i<=n;i++)
#define pb push_back
 
using namespace std;
 
typedef long long ll;
 
const int N=101000;
int n,Q;
int head[N],key[N<<1],nxt[N<<1],cnt;
int dep[N],fa[N],sz[N],son[N],top[N],loc[N],q[N*10],length;
ll ans;
int last[N],cur,all;

inline ll getint()
{
	ll r = 0;
	char c;
	while(!isdigit(c = getchar()) && c != '-');
	r = c - '0';
	while(isdigit(c = getchar())) r = r * 10 + c - '0';
	return r;
}

struct Node
{
	Node *l,*r;
	ll fa,fb,g;
}*root[N],node[30010000],*now=node;
 
inline Node *newNode(Node *L=NULL,Node *R=NULL,ll _fa=0,ll _fb=0,ll _g=0)
{
	now++;
	now->l=L;
	now->r=R;
	now->fa=_fa;
	now->fb=_fb;
	now->g=_g;
	return now;
}
 
inline void add(int x,int y)
{
	nxt[++cnt]=head[x];
	key[cnt]=y;
	head[x]=cnt;
}
 
Node *build(int l,int r)
{
	if(l==r) return newNode();
	int mid=l+r>>1;
	return newNode(build(l,mid),build(mid+1,r));
}
 
void BFS()
{
	int h=1,t=1;
	q[t++]=1;
	dep[1]=1;
	while(h<t)
	{
		int sta=q[h++];
		for(int i=head[sta];~i;i=nxt[i])
			if(!dep[key[i]])
			{
				dep[key[i]]=dep[sta]+1;
				fa[key[i]]=sta;
				q[t++]=key[i];
			}
	}
	for(int i=t-1;i>=1;i--)
	{
		sz[q[i]]++;
		sz[fa[q[i]]]+=sz[q[i]];
		if(sz[q[i]]>sz[son[fa[q[i]]]])
			son[fa[q[i]]]=q[i];
	}
	for(int i=1;i<t;i++)
	{
		if(son[fa[q[i]]]!=q[i]) top[q[i]]=q[i];
		else top[q[i]]=top[fa[q[i]]];
	}
	for(int i=1;i<t;i++)
		if(top[q[i]]==q[i])
			for(int j=q[i];j;j=son[j])
				loc[j]=++length;
	root[0]=build(1,n);
}
 
Node *update(Node *rt,int l,int r,int L,int R,ll a,ll b)
{
	if(L<=l&&r<=R)
		return newNode(rt->l,rt->r,rt->fa+a,rt->fb+b,rt->g+(a+a+b*(r-l))*(r-l+1)/2);
	int mid=l+r>>1;
	ll len=min(R,r)-max(L,l)+1;
	return newNode(L<=mid?update(rt->l,l,mid,L,R,a,b):rt->l,mid<R?update(rt->r,mid+1,r,L,R,a+b*max(mid-max(l,L)+1,0),b):rt->r,rt->fa,rt->fb,rt->g+(a+a+b*(len-1))*len/2);
}
 
ll query(Node *rt,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)
	{
		return rt->g;
	}
	int mid=l+r>>1;
	ll len=min(R,r)-max(L,l)+1,a=rt->fa,b=rt->fb;
	a=a+max((L-l),0)*b;
	return (L<=mid?query(rt->l,l,mid,L,R):0)+(mid<R?query(rt->r,mid+1,r,L,R):0)+(a+a+b*(len-1))*len/2;
}
 
inline void update(int x,int y,ll a,ll b)
{
	int lca,len,nx=x,ny=y;
	Node *last=root[cur];
	cur=all;
	root[cur]=last;
	while(top[nx]!=top[ny])
	{
		if(dep[top[nx]]>dep[top[ny]]) nx=fa[top[nx]];
		else ny=fa[top[ny]];
	}
	if(dep[nx]>dep[ny]) lca=ny;
	else lca=nx;
	len=dep[x]+dep[y]-dep[lca]-dep[fa[lca]];
	ll st=a,ed=a+b*(len-1),xd=b,yd=-b;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
		{
			st+=(dep[x]-dep[top[x]])*xd;
			root[cur]=update(root[cur],1,n,loc[top[x]],loc[x],st,-xd);
			st+=xd;
			x=fa[top[x]];
		}
		else
		{
			ed+=(dep[y]-dep[top[y]])*yd;
			root[cur]=update(root[cur],1,n,loc[top[y]],loc[y],ed,-yd);
			ed+=yd;
			y=fa[top[y]];
		}
	}
	if(dep[x]>dep[y]) root[cur]=update(root[cur],1,n,loc[y],loc[x],ed,yd);
	else root[cur]=update(root[cur],1,n,loc[x],loc[y],st,xd);
}
 
inline ll query(int x,int y)
{
	ll sum=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
		{
			sum+=query(root[cur],1,n,loc[top[x]],loc[x]);
			x=fa[top[x]];
		}
		else
		{
			sum+=query(root[cur],1,n,loc[top[y]],loc[y]);
			y=fa[top[y]];
		}
	}
	if(dep[x]>dep[y]) sum+=query(root[cur],1,n,loc[y],loc[x]);
	else sum+=query(root[cur],1,n,loc[x],loc[y]);
	return sum;
}
 
inline void change()
{
	ll x,y,a,b;
	all++;
	x=getint(),y=getint(),a=getint(),b=getint();
	x=(x+ans)%n+1,y=(y+ans)%n+1;
	update(x,y,a,b);
}
 
inline void query()
{
	ll x,y;
	x=getint(),y=getint();
	x=(x+ans)%n+1,y=(y+ans)%n+1;
	ans=query(x,y);
	printf("%lld\n",ans);
}
 
inline void back()
{
	ll x;
	x=getint();
	x=(x+ans)%(all+1);
	cur=x;
}
 
int main()
{
	memset(head,-1,sizeof head);
	n=getint(),Q=getint();
	for(int i=1,x,y;i<n;i++)
		x=getint(),y=getint(),add(x,y),add(y,x);
	BFS();
	for(int i=1;i<=Q;i++)
	{
		char str[4];
		scanf("%s",str);
		if(str[0]=='c') change();
		if(str[0]=='q') query();
		if(str[0]=='l') back();
	}
	return 0;
} 