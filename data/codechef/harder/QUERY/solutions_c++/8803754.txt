#include <stdio.h>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	100005
#define m	50000005
#define I64	long long
#define min(a,b)	((a)<(b)?(a):(b))
#define max(a,b)	((a)>(b)?(a):(b))
#define For(i,a,b)	for(int i=a;i<=b;i++)
#define Rep(i,a,b)	for(int i=a;i>=b;i--)

int		N,Q,D,Rt[n],ls[m],rs[m],Opt[n];
int		F[n],Top[n],Dfn[n],Dep[n];
char	s[5];

struct	Nod{int k;I64 b,sum;}T[m];

#define CH	(ch=getchar())
int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}

namespace	Tree{
		int		C,D,st[n],siz[n],son[n];
		struct	Lin{int v,next;}E[n<<1];

		void	Link(int u,int v){
			E[++D]=(Lin){v,st[u]};	st[u]=D;
			E[++D]=(Lin){u,st[v]};	st[v]=D;
		}
		void	DFS1(int u,int f){
			Dep[u]=Dep[f]+1;	F[u]=f;
			for (int i=st[u],v;i;i=E[i].next)
			if	((v=E[i].v)^f)	{
				DFS1(v,u);	siz[u]+=siz[v];
				if	(siz[v]>siz[son[u]])	son[u]=v;
			}	siz[u]++;
		}
		void	DFS2(int u,int f,int c){
			Top[u]=c;	Dfn[u]=++C;
			if	(son[u])DFS2(son[u],u,c);
			for (int i=st[u],v;i;i=E[i].next)
				if	((v=E[i].v)!=f&&v!=son[u])	DFS2(v,u,v);
		}
		void	Main(){
			N=IN();	Q=IN();
			For(i,2,N)	Link(IN(),IN());
			DFS1(1,0);	DFS2(1,0,1);
		}
};

int		LCA(int u,int v){
		for	(;Top[u]!=Top[v];v=F[Top[v]])
			if	(Dep[Top[u]]>Dep[Top[v]])	swap(u,v);
		return	Dep[u]<Dep[v]?u:v;
}

I64		SUM(int u,int k){
		I64	s=T[u].b,t=1ll*T[u].k*(k-1)+s;
		return	(s+t)*k/2;
}
void	Modify(int&u,int l,int r,int x,int y,I64 b,int k){
		int v=u;u=++D;	T[u]=T[v],ls[u]=ls[v],rs[u]=rs[v];
		if	(x<=l&&r<=y){
			T[u].k+=k;	T[u].b+=b;	return;
		}

		int Mid=l+r>>1;
		if	(x<=Mid)	Modify(ls[u],l,Mid,x,min(y,Mid),b,k);
		if	(y>Mid)		Modify(rs[u],Mid+1,r,max(Mid+1,x),y,x>Mid?b:b+1ll*(Mid+1-x)*k,k);
		T[u].sum=T[ls[u]].sum+T[rs[u]].sum+SUM(ls[u],Mid-l+1)+SUM(rs[u],r-Mid);
}
I64		Query(int u,int l,int r,int x,int y){
		if	(!u||x<=l&&r<=y)	return	T[u].sum+SUM(u,r-l+1);	int Mid=l+r>>1;	I64 ret=0;
		if	(x<=Mid)	ret+=Query(ls[u],l,Mid,x,min(Mid,y));
		if	(y>Mid)		ret+=Query(rs[u],Mid+1,r,max(Mid+1,x),y);
		return	ret+SUM(u,y-l+1)-SUM(u,x-l);
}

void	Work1(int&Rt,int u,int v,int a,int b){
		int l=0,r=Dep[u]+Dep[v]-2*Dep[LCA(u,v)]+2;

		for (int fx=Top[u],fy=Top[v];fx!=fy;)
		if	(Dep[fx]>Dep[fy])	{
			l+=Dep[u]-Dep[fx]+1;
			Modify(Rt,1,N,Dfn[fx],Dfn[u],1ll*(l-1)*b+a,-b);	u=F[fx];fx=Top[u];
		}	else	{
			r-=Dep[v]-Dep[fy]+1;
			Modify(Rt,1,N,Dfn[fy],Dfn[v],1ll*(r-1)*b+a,b);	v=F[fy];fy=Top[v];
		}

		if	(Dfn[u]<Dfn[v])	Modify(Rt,1,N,Dfn[u],Dfn[v],1ll*l*b+a,b);
			else	Modify(Rt,1,N,Dfn[v],Dfn[u],1ll*(r-2)*b+a,-b);
}
I64		Work2(int Rt,int u,int v){
		I64	ret=0;
		for (;Top[u]!=Top[v];v=F[Top[v]]){
			if	(Dep[Top[u]]>Dep[Top[v]])	swap(u,v);
			ret+=Query(Rt,1,N,Dfn[Top[v]],Dfn[v]);
		}
		if	(Dfn[u]>Dfn[v])	swap(u,v);
		return	ret+Query(Rt,1,N,Dfn[u],Dfn[v]);
}

int		main()	{
		Tree::Main();	I64 Ans=0;
		For(i,1,Q)	{
			scanf("%s",s);	Rt[i]=Rt[i-1];	int x,y,a,b;

			if	(s[0]=='l')	x=(IN()+Ans)%(Opt[0]+1),Rt[i]=Rt[x?Opt[x]:0];
			else	{
				x=(IN()+Ans)%N+1,y=(IN()+Ans)%N+1;
				if	(s[0]=='q')	printf("%lld\n",Ans=Work2(Rt[i],x,y));
					else	a=IN(),b=IN(),Opt[++*Opt]=i,Work1(Rt[i],x,y,a,b);
			}
		}
}