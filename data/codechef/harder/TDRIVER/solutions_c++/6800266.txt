#include<bits/stdc++.h>
using namespace std;

#define sc( x ) scanf( "%d" , &x )
#define REP( i , n ) for( int i = 0 ; i < n ; ++i )
#define clr( t , val ) memset( t , val , sizeof( t ) )

#define SZ( v ) ((int)(v).size())
#define all( v ) v.begin() , v.end()

#define pb push_back

typedef vector< int > vi;
typedef long long ll;
typedef vector< ll > vll;
typedef vector< vi > vvi;

struct data{
	ll x , y , xp , yp;
	data(){}
	data( ll x , ll y , ll xp , ll yp ) : x( x ) , y( y ) , xp( xp ) , yp( yp ) {}
};
bool operator < ( const data &d1 , const data &d2 ){
	if( d1.xp != d2.xp ) return d1.xp < d2.xp;
	if( d1.yp != d2.yp ) return d1.yp < d2.yp;
	return 0;
}
void trans( ll x , ll y , ll &X , ll &Y ){
	X = x - y;
	Y = x + y;
}
void RESIZE( vll &v ){
	sort( all( v ) );
	v.resize( unique( all( v ) ) - v.begin() );
}
struct FT{
	int MAXVAL;
	vll T;
 	FT( int n ){
	 	T = vll( n + 5 );
	 	MAXVAL = n + 2;
	}
	
	void upd( int pos , ll val ){
	    while( pos <= MAXVAL ){
	        T[ pos ] += val;
	        pos += (pos & -pos); 
	    }
	}
	void update( int pos , ll val ){
		upd( pos + 1 , val );
	}
	
	ll qry( int pos ){
	    ll sum = 0;
	    while( pos ){
	        sum += T[ pos ];
	        pos -= ( pos & -pos );
	    }
	    return sum;
	}
	ll query( int pos ){ return qry( pos + 1 );}
 	ll up( int pos ){ return query( MAXVAL - 1 ) - query( pos - 1 ); }
 	ll down( int pos ){ return query( pos );}
};
int getId( vll &v , ll x ){
	return lower_bound( all( v ) , x ) - v.begin();
}

int main(){
	int cases;
	sc( cases );
	REP( tc , cases ){
		int n , a , b;
		sc( n );
		sc( a ) , sc( b );
		vector< data > V;
		vll vx , vy;
		REP( i , n ){
			int x , y;
			sc( x ) , sc( y );
			ll X , Y;
			trans( a * x , b * y , X , Y );
			V.pb( data( a * x , b * y , X , Y ) );
			vx.pb( X );
			vy.pb( Y );
		}
		RESIZE( vx );
		RESIZE( vy );
		sort( all( V ) );
		ll ans = 0;
		vector< FT > VAL( 2 , SZ( vy ) ) , CNT( 2 , SZ( vy ) );
		
		for( int i = n - 1 ; i >= 0 ; --i ){
			int ind;
			for( int j = i ; j >= 0 ; --j )
				if( V[ j ].yp == V[ i ].yp ) ind = j;
				else break;
			ll val = V[ i ].yp;
			int pos = getId( vy , val );
			for( int j = i ; j >= ind ; --j ){
				VAL[ 0 ].update( pos , V[ i ].y );
				VAL[ 1 ].update( pos , V[ i ].x );
				CNT[ 0 ].update( pos , +1 );
				CNT[ 1 ].update( pos , +1 );
				ll L = CNT[ 0 ].down( pos - 1 ) , R = CNT[ 1 ].up( pos );
				ll SL = VAL[ 0 ].down( pos - 1 ) , SR = VAL[ 1 ].up( pos );
				ans += L * V[ i ].y - SL;
				ans += SR - R * V[ i ].x;
			}
			i = ind;
		}
		printf( "%lld\n" , ans );
	}
}

