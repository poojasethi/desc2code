#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	100005
#define For(i,a,b)	for(int i=a;i<=b;i++)

#define CH	(ch=getchar())
int		IN(){
		int x=0,ch;
		for	(;CH<'0'||ch>'9';);
		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0';
		return	x;
}

int		N,Q,F[n],Col[n],Top[n],End[n],Dfn[n],Seq[n],A[2][n],H[2][n];

namespace	Tree{
		int		C,D,st[n],siz[n],son[n];
		struct	Lin{int v,next;}E[n<<1];

		void	Link(int u,int v){
			E[++D]=(Lin){v,st[u]};	st[u]=D;
			E[++D]=(Lin){u,st[v]};	st[v]=D;
		}

		void	DFS1(int u,int f){
			for	(int i=st[u],v;i;i=E[i].next)
			if	((v=E[i].v)!=f)	{
				DFS1(v,u),siz[u]+=siz[v];	F[v]=u;
				if	(siz[v]>siz[son[u]])	son[u]=v;
			}	siz[u]++;
		}
		void	DFS2(int u,int f,int c){
			Dfn[u]=++C;	Seq[C]=u;	Top[u]=c;	End[c]=u;
			if	(son[u])	DFS2(son[u],u,c);
			for	(int i=st[u],v;i;i=E[i].next)
				if	((v=E[i].v)!=f&&v!=son[u])	DFS2(v,u,v);
		}

		void	Main(){
			N=IN();
			For(i,2,N)	Link(IN(),IN());
			DFS1(1,0);	DFS2(1,0,1);
		}
};

struct	Seg{
		struct	Nod{
			int cnt,siz,las,sum;
			Nod	operator +	(const Nod&a){
				return	(Nod){cnt+a.cnt,siz+a.siz,(a.cnt==a.siz&&las)?las:a.las,sum+(cnt==siz)*a.sum};
			}
		}T[n<<2];

		void	Build(int u,int l,int r){
			T[u]=(Nod){0,r-l+1,0,0};	int Mid=l+r>>1;
			if	(l^r)	Build(u<<1,l,Mid),Build(u<<1|1,Mid+1,r);
		}
		void	Modify(int u,int l,int r,int x,int k){
			if	(l==r)	{
				if	(k)		T[u]=(Nod){1,1,l,k};
					else	T[u]=(Nod){0,1,0,0};
				return;
			}	int Mid=l+r>>1;
			if	(x<=Mid)	Modify(u<<1,l,Mid,x,k);
				else		Modify(u<<1|1,Mid+1,r,x,k);
			T[u]=T[u<<1]+T[u<<1|1];
		}
		Nod		Query(int u,int l,int r,int x,int y){
			if	(x<=l&&r<=y)	return	T[u];	int Mid=l+r>>1;
			if	(y<=Mid)	return	Query(u<<1,l,Mid,x,y);
			if	(x>Mid)		return	Query(u<<1|1,Mid+1,r,x,y);
			return	Query(u<<1,l,Mid,x,y)+Query(u<<1|1,Mid+1,r,x,y);
		}
}T[2];

void	INS(int x,int c){
		Col[x]=c;	A[c][x]=1;
		for	(int f;x;x=f)	{
			int t=Top[x],l=Dfn[t],r=Dfn[End[t]];	f=F[t];
			if	(f)	H[c][f]-=T[c].Query(1,1,N,l,r).sum;
			T[c].Modify(1,1,N,Dfn[x],A[c][x]?A[c][x]+H[c][x]:0);
			if	(f)	H[c][f]+=T[c].Query(1,1,N,l,r).sum;
		}
}
void	DEL(int x)	{
		int c=Col[x];A[c][x]=0;
		for	(int f;x;x=f)	{
			int t=Top[x],l=Dfn[t],r=Dfn[End[t]];	f=F[t];
			if	(f)	H[c][f]-=T[c].Query(1,1,N,l,r).sum;
			T[c].Modify(1,1,N,Dfn[x],A[c][x]?A[c][x]+H[c][x]:0);
			if	(f)	H[c][f]+=T[c].Query(1,1,N,l,r).sum;
		}
}

void	Ask(int x){
		int c=Col[x];
		for	(;x;)	{
			int t=Top[x],f=F[t];
			int r=Seq[T[c].Query(1,1,N,Dfn[t],Dfn[x]).las];
			if	(!f||Col[f]!=c||r!=t)	{x=r;break;}	x=f;
		}
		printf("%d\n",T[c].Query(1,1,N,Dfn[x],Dfn[End[Top[x]]]).sum);
}

int		main(){
		Tree::Main();
		For(c,0,1)	T[c].Build(1,1,N);
		For(i,1,N)	INS(i,0);

		for	(Q=IN();Q--;){
			int t=IN(),x=IN();
			if	(t)		DEL(x),INS(x,Col[x]^1);
				else	Ask(x);
		}
}