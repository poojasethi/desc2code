//code qui segfault et bug pour l'instant

#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int NB_NOEUDS = 100005;
int N,M;

struct Noeud
{
	int id;
	int w;
	int sz;
	Noeud* fa;
	Noeud* gauche;
	Noeud* droite;
	Noeud* pere;
	Noeud* pathparent;
	
	Noeud() : id(0), w(0), sz(0), fa(NULL), gauche(NULL), droite(NULL), pere(NULL), pathparent(NULL)
	{
	}
};

Noeud arbre[NB_NOEUDS][2];
vector<int> arcs[NB_NOEUDS];

void update(Noeud *noeud)
{
	int d=0,g=0;
	if(noeud->droite)
		d=noeud->droite->sz;
	if(noeud->gauche)
		g=noeud->gauche->sz;
	noeud->sz = g + d + noeud->w + 1;
}

int col[NB_NOEUDS];

Noeud* findRoot(Noeud* noeud)
{
	//splay(noeud);
	while(noeud->gauche)
		noeud=noeud->gauche;
	return noeud;
}

void setPere(Noeud *noeud, Noeud* pere)
{
	if(noeud)
		noeud->pere=pere;
}

/*WIKI*/

void left_rotate( Noeud *x ) {
    Noeud *y = x->droite;
    if(y) {
      x->droite = y->gauche;
      if( y->gauche ) y->gauche->pere = x;
      y->pere = x->pere;
      
      y->pathparent=x->pathparent;
    x->pathparent=NULL;
    }
 
    if( !x->pere ) ;//root = y;
    else if( x == x->pere->gauche ) x->pere->gauche = y;
    else x->pere->droite = y;
    if(y) y->gauche = x;
    x->pere = y;
    update(x);
  }
 
  void right_rotate( Noeud *x ) {
    Noeud *y = x->gauche;
    if(y) {
      x->gauche = y->droite;
      if( y->droite ) y->droite->pere = x;
      y->pere = x->pere;
      
      y->pathparent=x->pathparent;
   	 x->pathparent=NULL;
    }
    if( !x->pere ) ;//root = y;
    else if( x == x->pere->gauche ) x->pere->gauche = y;
    else x->pere->droite = y;
    if(y) y->droite = x;
    x->pere = y;
    update(x);
  }
 
  void splay( Noeud *x ) {
    while( x->pere ) {
      if( !x->pere->pere ) {
        if( x->pere->gauche == x ) right_rotate( x->pere );
        else left_rotate( x->pere );
      } else if( x->pere->gauche == x && x->pere->pere->gauche == x->pere ) {
        right_rotate( x->pere->pere );
        right_rotate( x->pere );
      } else if( x->pere->droite == x && x->pere->pere->droite == x->pere ) {
        left_rotate( x->pere->pere );
        left_rotate( x->pere );
      } else if( x->pere->gauche == x && x->pere->pere->droite == x->pere ) {
        right_rotate( x->pere );
        left_rotate( x->pere );
      } else {
        left_rotate( x->pere );
        right_rotate( x->pere );
      }
    }
    update(x);
  }
/* WIKI */

/*void rotate(Noeud *noeud)
{
	Noeud *pere = noeud->pere;
	
	//màj pp
	noeud->pathparent = pere->pathparent;
	pere->pathparent  = NULL;
	////////
	
	if(pere->gauche==noeud)
	{
		if(pere->droite)pere->droite->pere=noeud;
		pere->gauche=noeud->droite;
		noeud->droite=pere;
	}
	else
	{
		if(pere->gauche)pere->gauche->pere=noeud;
		pere->droite=noeud->gauche;
		noeud->gauche=pere;
	}
	setPere(pere->gauche, pere);
	setPere(pere->droite, pere);
	setPere(noeud, pere->pere);
	setPere(pere, noeud);

	update(noeud);
}

void splay(Noeud *noeud)
{
	while(noeud->pere)
	{
		Noeud *p = noeud->pere;
		Noeud *gp= p->pere;

		if(!gp)
			rotate(noeud); //zig
		else if((p->gauche==noeud) ^ (gp->droite==noeud))
			rotate(p), rotate(noeud); //zig-zig
		else
			rotate(noeud), rotate(noeud); //zig-zag
	}
	update(noeud);
}*/

void access(Noeud *noeud)
{
	splay(noeud);
	if(noeud->droite)
	{
		noeud->w += noeud->droite->sz;
		
		//lct
		noeud->droite->pathparent=noeud;
		noeud->droite->pere=NULL;
		noeud->droite=NULL;
		update(noeud);
	}
	while(noeud->pathparent)
	{
		//printf("ici\n");
		Noeud *pp = noeud->pathparent;
		splay(pp);
		if(pp->droite)
		{
			pp->w += pp->droite->sz; //on ajoute celui là qui maintenant est un pp

			//lct
			pp->droite->pathparent=pp;
			pp->droite->pere=NULL;
		}
		
		pp->w -= noeud->sz; //celui là n'est plus un pp mais bien un fils direct
		
		pp->droite=noeud;
		noeud->pere=pp;
		noeud->pathparent=NULL;
		update(pp); // ça ou pas ?
		splay(noeud);
		//update(noeud);
		//le pathparent est màj dans le splay
	}
}

void link(Noeud* noeud, Noeud* pere=0)
{
	//printf("infini\n");
	if(!pere) pere = noeud->fa;
	//if(!pere)return;
	access(pere);
	access(noeud);
	pere->droite=noeud;
	noeud->pere=pere;
	update(pere);
}

void cut(Noeud *noeud)
{
	access(noeud);
	//noeud->
	if(noeud->gauche){
	noeud->gauche->pere=NULL;
	noeud->gauche=NULL;
	update(noeud);}
}

void dfs(int noeud, int pere=0)
{
	for(int i = 0; i < arcs[noeud].size(); i++)
	{
		if(arcs[noeud][i]!=pere)
		{
			arbre[arcs[noeud][i]][0].fa=&arbre[noeud][0];
			arbre[arcs[noeud][i]][1].fa=&arbre[noeud][1];
			arbre[arcs[noeud][i]][0].pathparent=&arbre[noeud][0];
			//link(&arbre[arcs[noeud][i]][0], &arbre[noeud][0]);
			dfs(arcs[noeud][i], noeud);
			arbre[noeud][0].w += arbre[arcs[noeud][i]][0].sz;
		}
	}
	update(&arbre[noeud][0]);
	update(&arbre[noeud][1]);
}

int nbb = 0;

int requete(Noeud* noeud)
{
	nbb++;
	access(noeud);
	Noeud *rac = findRoot(noeud);
	splay(rac);
	//update(rac);
	//printf("debug : %d\n", nbb);
	//printf("debug : %d et sz2 = %d et w2 = %d\n", rac->id, noeud->sz, noeud->w); //BUG ICI, rac=1 au lieu de 4
	//if(rac->fa)
	//printf("ma couleur : %d et mon pere %d\n", col[rac->id], col[rac->fa->id]);
	
	return rac->droite->sz; //on est obligé d'avoir un fils droit car le noeud est à exclure
}

int main()
{
	scanf("%d", &N);
	
	for(int i = 1; i < N; i++)
	{
		arbre[i][0].id=arbre[i][1].id=i;
		int a,b;
		scanf("%d%d",&a,&b);
		arcs[a].push_back(b);
		arcs[b].push_back(a);
	}
	arbre[N][0].id=arbre[N][1].id=N;
	
	arbre[1][0].fa = &arbre[N+1][0];
	arbre[1][1].fa = &arbre[N+1][1];
	arbre[1][0].pathparent = &arbre[N+1][0];
	//arbre[N+1][0].sz = N+1;

	//printf("hugfdm\n");
	dfs(1);
	scanf("%d", &M);
	//printf("hum\n");

	for(int i = 0; i < M; i++)
	{
		int type, noeud;
		scanf("%d%d", &type, &noeud);

		if(type==1)
		{
			cut(&arbre[noeud][col[noeud]]);
			col[noeud] ^= 1;
			link(&arbre[noeud][col[noeud]]);
		}
		else
			printf("%d\n", requete(&arbre[noeud][col[noeud]]));
	}
	return 0;
}
