#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define INF 0x7f7f7f7f
#define MAXN 100010
using namespace std;
int v[MAXN*2],next[MAXN*2],first[MAXN];
int size[MAXN],sum[MAXN],col[MAXN],id[MAXN];
int tot,n;
 
char buf[10000000],*pt = buf,*o = buf;
int getint(){
    int f = 1,x = 0;
    while((*pt != '-') && (*pt < '0' || *pt > '9'))   pt ++;
    if(*pt == '-')  f = -1,pt ++;   else    x = *pt++ - 48;
    while(*pt >= '0' && *pt <= '9')   x = x * 10 + *pt ++ - 48;
    return x * f;
}
 
void addedge(int x,int y){
    v[++tot]=y;next[tot]=first[x];first[x]=tot;
    v[++tot]=x;next[tot]=first[y];first[y]=tot;
}
 
struct Path{
    int dep,top,size;
    int Treap_rt[2],Segment_rt[2];
}path[MAXN];
int path_cnt=0;
 
struct Point{
    int belong,rank,father;
}po[MAXN];
 
struct Treap{
    int key[MAXN],w[MAXN],fa[MAXN],ch[MAXN][2],pool[MAXN];
    int top,cnt;
    Treap(){
        srand(1234567);
        top=cnt=0;
    }
    int newnode(int v,int f){
        int x=top?pool[top--]:(++cnt);
        key[x]=v;w[x]=rand();
        fa[x]=f;ch[x][0]=ch[x][1]=0;
        return x;
    }
    void rotate(int x,int t){
        if(!x) return;
        int y=fa[x];
        ch[y][t]=ch[x][!t];if(ch[x][!t]) fa[ch[x][!t]]=y;
        fa[x]=fa[y];if(fa[y]) ch[fa[y]][ch[fa[y]][1]==y]=x;
        fa[ch[x][!t]=y]=x;
    }
    void insert(int&root,int v){
        if(!root){
            root=newnode(v,0);
            return;
        }
        int x=root;
        for(;ch[x][key[x]<v];x=ch[x][key[x]<v]);
        ch[x][key[x]<v]=newnode(v,x); x=ch[x][key[x]<v]; 
        while(fa[x]&&w[x]<w[fa[x]]) rotate(x,ch[fa[x]][1]==x);
        if(fa[x]==0) root=x;
    }
    void _delete(int&root,int v){
        int x=root;
        for(;key[x]!=v;x=ch[x][key[x]<v]);
        int p=x;
        if(ch[p][0]&&ch[p][1]){
            for(p=ch[p][0];ch[p][1];p=ch[p][1]);
            key[x]=key[p];
        }
        int s=ch[p][0]?ch[p][0]:ch[p][1];
        fa[s]=fa[p];if(fa[p]) ch[fa[p]][ch[fa[p]][1]==p]=s;
        if(root==p) root=s; pool[++top]=p;
    }
    int getsuc(int root,int v){
        int x=root,ret=INF;
        while(x){
            if(key[x]>v) ret=min(key[x],ret);
            x=ch[x][key[x]<=v];
        }
        return ret;
    }
}T;
 
struct SegmentTree{
    int s[MAXN*12],l[MAXN*12],r[MAXN*12],lc[MAXN*12],rc[MAXN*12];
    int cnt;
    SegmentTree(){
        cnt=0;
    }
    void build(int&p,int L,int R,int no,int c){
        p=++cnt;s[p]=0,l[p]=L,r[p]=R;
        if(L<R){
            int mid=(L+R)>>1;
            build(lc[p],L,mid,no,c);
            build(rc[p],mid+1,R,no,c);
        }else
            s[p]=c?1:size[id[sum[no-1]+L]];
    }
    void update(int p,int x,int y,int d){
        if(x<=l[p]&&r[p]<=y){
            s[p]+=d;
            return;
        }
        if(x<=r[lc[p]]) update(lc[p],x,y,d);
        if(y>=l[rc[p]]) update(rc[p],x,y,d);
    }
    int query(int p,int x){
        if(l[p]==r[p]) return s[p];
        if(s[p]){
            s[lc[p]]+=s[p];
            s[rc[p]]+=s[p];
            s[p]=0;
        }
        if(x<=r[lc[p]]) return query(lc[p],x);
                   else return query(rc[p],x); 
    }
}S;
     
void dfs(int dep,int u){
    size[u]=1;int ma=0,j=0;
    for(int i=first[u];i;i=next[i])
        if(v[i]!=po[u].father){
            po[v[i]].father=u;
            dfs(dep+1,v[i]);
            size[u]+=size[v[i]];
            if(size[v[i]]>ma) ma=size[v[i]],j=v[i];
        }
    for(int i=first[u];i;i=next[i])
        if(v[i]!=po[u].father)
            if(v[i]==j){
                po[u].belong=po[v[i]].belong;
                po[u].rank=po[v[i]].rank+1;
            }else{
                int k=po[v[i]].belong;
                path[k].dep=dep+1;
                path[k].top=v[i];
                path[k].size=po[v[i]].rank;
            }
    if(!po[u].belong){
        po[u].belong=++path_cnt;
        po[u].rank=1;
    }
    T.insert(path[po[u].belong].Treap_rt[0],po[u].rank);
}
 
int get_anc(int v){
    int suc=T.getsuc(path[po[v].belong].Treap_rt[col[v]^1],po[v].rank);
    int u;
    while(suc==INF){
        u=path[po[v].belong].top;
        v=po[u].father;
        if(col[v]!=col[u]) return u;
        suc=T.getsuc(path[po[v].belong].Treap_rt[col[v]^1],po[v].rank);
    }
    return id[sum[po[v].belong-1]+suc-1]; 
}
 
void modify_anc(int v,int d){
    int suc=T.getsuc(path[po[v].belong].Treap_rt[col[v]^1],po[v].rank);
    int u;S.update(path[po[v].belong].Segment_rt[col[v]],po[v].rank,po[v].rank,-d);
    while(suc==INF){
        u=path[po[v].belong].top;
        S.update(path[po[v].belong].Segment_rt[col[v]],po[v].rank,po[u].rank,d);
        v=po[u].father;
        if(col[v]!=col[u]){
            if(v) S.update(path[po[v].belong].Segment_rt[col[u]],po[v].rank,po[v].rank,d);
            return;
        }
        suc=T.getsuc(path[po[v].belong].Treap_rt[col[v]^1],po[v].rank);
    }
    S.update(path[po[v].belong].Segment_rt[col[v]],po[v].rank,suc,d);
}
 
void init(){
    n=getint();
    for(int i=1;i<n;i++){
        int x=getint(),y=getint();
        addedge(x,y);
    }
    memset(col,0,sizeof(col)); col[0]=-1;
    dfs(1,1);
    int k=po[1].belong;
    path[k].dep=1;path[k].top=1;path[k].size=po[1].rank;
    for(int i=1;i<=path_cnt;i++) sum[i]=sum[i-1]+path[i].size;
    for(int i=1;i<=n;i++) id[sum[po[i].belong-1]+po[i].rank]=i;
    for(int i=1;i<=path_cnt;i++){
        S.build(path[i].Segment_rt[0],1,path[i].size,i,0);
        S.build(path[i].Segment_rt[1],1,path[i].size,i,1);
    }
}
 
int ask(int v){
    int x=get_anc(v); 
    return S.query(path[po[x].belong].Segment_rt[col[x]],po[x].rank);
}
 
int change(int v){
    int d=S.query(path[po[v].belong].Segment_rt[col[v]],po[v].rank);
    modify_anc(v,-d);
    T._delete(path[po[v].belong].Treap_rt[col[v]],po[v].rank);
    col[v]^=1;
    T.insert(path[po[v].belong].Treap_rt[col[v]],po[v].rank);
    d=S.query(path[po[v].belong].Segment_rt[col[v]],po[v].rank);
    modify_anc(v,d);
}
 
void solve(){
    int q=getint(); int op,v;
    while(q--){
        op=getint(),v=getint();
        if(op==0) printf("%d\n",ask(v));
        else change(v);
    }
}
 
int main(){
    //freopen("input.txt","r",stdin);freopen("output.txt","w",stdout); 
    fread(buf,1,10000000,stdin);
    init();
    solve();
    return 0;
}
