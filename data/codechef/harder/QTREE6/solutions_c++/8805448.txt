#include <bits/stdc++.h>
#define filein(t) freopen(t, "r", stdin)
#define fileout(t) freopen(t, "w", stdout)
#define mp make_pair
#define f first
#define s second
#define N 100005
#define ln 1000000001
#define BIT(i, j) ((j >> i) & 1)
#define ll long long
#define oo 1000000007
#define pii pair < pair <int, int>, int >
#define pi pair < int, pair <int, int> >
#define Pa pair < int , int >

using namespace std;

typedef int arr[N];
arr cnt, P[20], H, pos, d, Pre, color;
int Ma[4*N], Mi[4*N];

vector <int> a[N];
int num, n;

struct BIT
{
    int Tree[N];
    void Up(int x, int Val)
    {
        while(x < N)
        {
            Tree[x] += Val;
            x += x & (-x);
        }
    }
    int Get_Val(int x)
    {
        int r = 0;
        while(x)
        {
            r += Tree[x];
            x -= x & (-x);
        }
        return r;
    }
};

BIT T[2];

void DFS1(int u, int pre)
{
    cnt[u] = 1;
    for(int i=0; i<a[u].size(); i++)
    {
        int v = a[u][i];
        if(v == pre)    continue;
        P[0][v] = u;
        H[v] = H[u] + 1;
        DFS1(v, u);
        cnt[u] += cnt[v];
    }
}

void DFS2(int u, int pre)
{
    int Ma = 0;
    pos[u] = ++num;
    d[num] = u;
    if(Pre[u] == 0)
        Pre[u] = pos[u];
    for(int i=0; i<a[u].size(); i++)
    {
        int v = a[u][i];
        if(v == pre)    continue;
        if(cnt[Ma] < cnt[v])    Ma = v;
    }
    if(Ma == 0) return;
    Pre[Ma] = Pre[u];
    DFS2(Ma, u);
    for(int i=0; i<a[u].size(); i++)
    {
        int v = a[u][i];
        if(v == Ma || v == pre) continue;
        DFS2(v, u);
    }
}

int Next(int u, int h)
{
    int hi = H[u] - h;
    for(int i=0; i<=17; i++)
        if(BIT(i, hi))
            u = P[i][u];
    return u;
}

int LCA(int u, int v)
{
    if(H[u] < H[v]) swap(u, v);
    u = Next(u, H[v]);
    if(u == v)  return u;
    for(int i=17; i>=0; i--)
        if(P[i][u] != P[i][v])
        {
            u = P[i][u];
            v = P[i][v];
        }
    return P[0][u];
}

int Max(int p, int q)
{
    if(color[p] < color[q]) return q;
    if(color[p] > color[q]) return p;
    if(H[p] > H[q]) return p;
    return q;
}

int Max_Val(int node, int l, int r, int d, int c)
{
    if(d <= l && r <= c)    return Ma[node];
    if(d > r || c < l)  return n+1;
    int g = (l + r) / 2;
    int u = Max_Val(node*2, l, g, d, c);
    int v = Max_Val(node*2+1, g+1, r, d, c);
    return Max(u, v);
}

int Get_max(int u)
{
    while(u)
    {
        int v = Max_Val(1, 1, n, Pre[u], pos[u]);
        if(color[v] == 1)   return v;
        u = P[0][d[Pre[u]]];
    }
    return 0;
}

int Min(int p, int q)
{
    if(color[p] > color[q]) return q;
    if(color[p] < color[q]) return p;
    if(H[p] > H[q]) return p;
    return q;
}

int Min_Val(int node, int l, int r, int d, int c)
{
    if(d <= l && r <= c)    return Mi[node];
    if(d > r || c < l)  return n+2;
    int g = (l + r) / 2;
    int u = Min_Val(node*2, l, g, d, c);
    int v = Min_Val(node*2+1, g+1, r, d, c);
    return Min(u, v);
}

int Get_min(int u)
{
    while(u)
    {
        int v = Min_Val(1, 1, n, Pre[u], pos[u]);
        if(color[v] == 0)   return v;
        u = P[0][d[Pre[u]]];
    }
    return 0;
}

void Add(int u, int par, int type, int Val)
{
    if(u == 0)  return;
    if(H[u] < H[par])   return;
    if(par == 0)    par = 1;
    while(H[d[Pre[u]]] > H[par])
    {
        T[type].Up(Pre[u]+1, Val);
        T[type].Up(pos[u]+2, -Val);
        u = P[0][d[Pre[u]]];
    }
    T[type].Up(pos[par]+1, Val);
    T[type].Up(pos[u]+2, -Val);
}

void Update(int node, int l, int r, int pos)
{
    if(l > pos || pos > r)  return;
    if(l == r)
        return;
    int g = (l + r) / 2;
    Update(node*2, l, g, pos);
    Update(node*2+1, g+1, r, pos);
    Ma[node] = Max(Ma[2*node], Ma[2*node+1]);
    Mi[node] = Min(Mi[2*node], Mi[2*node+1]);
}

void Build(int node, int l, int r)
{
    if(l == r)
    {
        Ma[node] = Mi[node] = d[l];
        return;
    }
    int g = (l + r) / 2;
    Build(node*2, l, g);
    Build(node*2+1, g+1, r);
    Ma[node] = Max(Ma[2*node], Ma[2*node+1]);
    Mi[node] = Min(Mi[2*node], Mi[2*node+1]);
}

int main()
{
  //  filein("inp.txt");  fileout("out.txt");
    int u, v, q, type, w;
    cin >> n;
    for(int i=1; i<n; i++)
    {
        scanf("%d%d", &u, &v);
        a[u].push_back(v);
        a[v].push_back(u);
    }
    H[1] = 1;
    DFS1(1, 0);
    color[n+1] = 0;
    color[n+2] = 1;
    for(int j=1; j<=17; j++)
        for(int i=1; i<=n; i++)
            P[j][i] = P[j-1][P[j-1][i]];
    DFS2(1, 0);
    for(int i=1; i<=n; i++)
    {
        color[i] = 1;
        T[0].Up(pos[i]+1, 1); T[0].Up(pos[i]+2, -1);
        T[1].Up(pos[i]+1, cnt[i]); T[1].Up(pos[i]+2, -cnt[i]);
    }
    Build(1, 1, n);
    cin >> q;
    while(q--)
    {
        scanf("%d%d", &type, &u);
        if(type == 0)
        {
            if(color[u] == 0)
                v = Get_max(u);
            else
                v = Get_min(u);
            v = Next(u, H[v]+1);
            printf("%d\n", T[color[u]].Get_Val(pos[v]+1));
        }
        else
        {
            if(color[u] == 0)
                v = Get_min(P[0][u]), w = Get_max(P[0][u]);
            else
                v = Get_max(P[0][u]), w = Get_min(P[0][u]);
            Add(P[0][u], v, 1 - color[u], T[1-color[u]].Get_Val(pos[u]+1));
            Add(P[0][u], w, color[u], -T[color[u]].Get_Val(pos[u]+1));
            color[u] = 1 - color[u];
            Update(1, 1, n, pos[u]);
        }
    }
}
