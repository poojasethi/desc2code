#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>
#define getcx getchar_unlocked

using namespace std;

int N;
int M;

const int MAXN = 100001;

//color=0 for black, 1 for white
//3 arbres, 0 = black[], 1 = white[], 2=pour trouver upper
int color[MAXN];
vector<int> arcs[MAXN];
int pere[MAXN];
int heavy[MAXN];
int parent[MAXN];
vector<int> tree[3][MAXN];
int id[MAXN][2];
vector<int> wesh[MAXN];
int nbFeuilles[MAXN];

int dfs(int noeud, int ppere=1)
{
	//fprintf(stderr, "i am 3 i swear God \n");
	int pb=0;
	int maxi=0;
	int tt = 1;
	int maxj=0;
	pere[noeud]=ppere;
	for(int i = 0; i < arcs[noeud].size(); i++)
	{
		if(arcs[noeud][i]==ppere){pb=i;continue;}
		int nb = dfs(arcs[noeud][i], noeud);
		//pere[arcs[noeud][i]]=noeud;
		tt+=nb;
		if(nb>maxi)
			maxi=nb,maxj=i;
	}
	heavy[noeud]=arcs[noeud][maxj];
	if(arcs[noeud].size()>0 && arcs[noeud][pb]==ppere)
	{
		swap(arcs[noeud][pb], arcs[noeud].back());
		arcs[noeud].pop_back();
	}

	/*for(int i = 0; i < arcs[noeud].size(); i++)
	{
		int nb = dfs(arcs[noeud][i], noeud);
		tt+=nb;
		if(nb>maxi)
			maxi=nb, maxj=i;
	}
	heavy[noeud]=arcs[noeud][maxj];*/

	return tt;
}

int oc=1;

void dfs2(int noeud, int pos=0)
{
	int curr=0;
	if(noeud!=1)
		curr=id[pere[noeud]][0];
	if(noeud!=1&&heavy[pere[noeud]]!=noeud)
	{
		curr=oc++;
		parent[curr]=pere[noeud];
		pos=0;
	}

	//if(noeud==2)printf("dEbUg : %d\n", curr);
	//if(noeud==3) fprintf(stderr, "hey guy my name is 3 and my pos is %d\n", pos);
	id[noeud][0]=curr;
	id[noeud][1]=pos;
	tree[0][curr].push_back(0);
	tree[1][curr].push_back(0);
	tree[2][curr].push_back(0);
	wesh[curr].push_back(noeud);

	for(int i = 0; i < arcs[noeud].size(); i++)
	{
		dfs2(arcs[noeud][i], pos+1);
	}
}

void updateTree(int col, int arbre, int gauche, int droite, int val)
{	
	if(gauche>droite)
	{
		return;
	}
	if(gauche==droite)
		tree[col][arbre][gauche]+=val;
	else
	{
		if(gauche&1)
		{
			tree[col][arbre][gauche]+=val;
			gauche++;
		}
		if(!(droite&1))
		{
			tree[col][arbre][droite]+=val;
			droite--;
		}
		updateTree(col, arbre, gauche/2, droite/2, val);
	}
}

int somme(int arbre, int gauche, int droite)
{
	if(gauche>droite)return 0;
	if(gauche==droite)
		return tree[2][arbre][gauche];
	if(gauche&1)
		return tree[2][arbre][gauche]+somme(arbre, (gauche+1), droite);
	if(!(droite&1))
		return tree[2][arbre][droite]+somme(arbre, gauche, (droite-1));
	return somme(arbre, gauche/2, droite/2);
}

void afficheQuiArbre()
{
	for(int i = 1; i <= N; i++)
	{
		printf("noeud %d : arbre=%d\n", i, id[i][0]);
	}
}

int findUpper(int u, int col) //trouve le plus haut noeud avec tout de même couleur sur le chemin
{
	int nbF = nbFeuilles[id[u][0]];
	int gauche = nbF;
	int droite = id[u][1];
	//if(gauche>droite)fprintf(stderr, "mamamia : gauche = %d et droite = %d, en effet, u=%d et donc idu = %d\n", gauche, droite,u, id[u][0]);
	int s = somme(id[u][0], gauche, droite);
	//if(u==8)printf("wesh : %d et droite-gauche+1=%d et col=%d\n", s,droite-gauche+1, col);
	if((col==0 && s==droite-gauche+1) || (col==1 && s==0)) // tous les noeuds à gauche de u sont de la couleur col
	{
		//if(u==8)printf("donc voila\n");
		//if(u==2)
		//printf("je suis 2222\n");
		if(id[u][0]==0)
			return wesh[id[u][0]][gauche-nbF];
		//if(u==8)
		//printf("more information : parent=%d\n", parent[id[u][0]]);
		int res = findUpper(parent[id[u][0]],col);
		if(color[res]==col) //fix, au lieu de dire color[res]... je ne sais pourquoi BUG
			return res;
		return wesh[id[u][0]][gauche-nbF];
	}
	else // la réponse se situe ici
	{
		//if(u==3)
		//	printf("and now begin the hostilities\n");
		//if(u==2)printf("je suis 2");
		//NB : on peut se permettre un log^2 car il est final.
		//return trouveLeTruc();
		
		gauche = nbFeuilles[id[u][0]]-1; //gauche exclu droite inclus
		droite = id[u][1];
		
		//printf("on a droite qui vaut %d, en effet, heavy[1]=%d donc id[u][0]=%d\n", droite-nbF, heavy[1], id[u][0]);
		
		//if(u==3)
		//printf("droite-nbF = %d et donc wesh[id[u][0]]=%d\n", droite-nbF,wesh[id[u][0]][droite-nbF]);
		
		while(gauche < droite-1)
		{
			int mid=(gauche+droite)/2;
			
			int ok = col==1?0:id[u][1]-mid+1;
			//if(mid>id[u][1])fprintf(stderr, "mamamia2 : gauche = %d et droite = %d, en effet, u=%d et donc idu = %d\n", mid, id[u][1],u, id[u][0]);
			if(somme(id[u][0], mid, id[u][1]) == ok)
			{
				//if(u==2) printf("WHAT ok=%d\n", ok);
		//		if(u==3)printf("pourquoi ? %d avec mid=%d, id[u][1]=%d\n", ok, mid, id[u][1]);
				droite=mid;
			}
			else
				gauche=mid;
		}
		//if(u==3)
		//printf("droite-nbF = %d et donc wesh[id[u][0]]=%d\n", droite-nbF,wesh[id[u][0]][droite-nbF]);
		
		//printf("END\n");
		return wesh[id[u][0]][droite-nbF];
	}
}

//bug potentiel si lim=0... Attention ! fix : pere[1]=1, ça devrait régler le pb
void update(int node, int lim, int val, int col)
{
	int gauche = nbFeuilles[id[node][0]];
	if(id[node][0] == id[lim][0])
		gauche=id[lim][1];
	
	//if(gauche>id[node][1])fprintf(stderr, "mamamia3 : gauche = %d et droite = %d\n", gauche, id[node][1]);//,u, id[u][0]);
	updateTree(col, id[node][0], gauche, id[node][1], val);
	//updateTreeW(id[node][0], gauche, droite, -val);//peut être pas ça
	
	//printf("je crash ici car parent = %d avec node=%d et pere=%d\n", parent[id[node][0]], node, pere[node]);
	if(id[node][0] != id[lim][0])
		update(parent[id[node][0]], lim, val, col);
	//printf("houla\n");
}

void maj(int arbre, int noeud)
{
	if(noeud==0)return;
	
	tree[2][arbre][noeud]=tree[2][arbre][noeud*2] + tree[2][arbre][noeud*2+1];
	
	maj(arbre, noeud/2);
}

int sumToRoot(int col, int arbre, int noeud)
{
	if(noeud==0)return 0;
	
	return tree[col][arbre][noeud] + sumToRoot(col, arbre, noeud/2);
}

int main()
{
	//inp(N);
	scanf("%d", &N);
	//freopen("test42.out", "w", stdout);
	
	for(int i = 1; i < N; i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		
		//if(a==3&&b==2) printf("OH OUI\n");
		arcs[a].push_back(b);
		arcs[b].push_back(a);
	}
	
	//enracine l'arbre et crée la structure heavy-light
	dfs(1);
	dfs2(1);
	
	for(int i = 0; i < N; i++)
	{
		int p2=1;
		while(p2<tree[0][i].size())p2<<=1;
		nbFeuilles[i]=p2;
		p2<<=1;
		tree[0][i].resize(p2);
		tree[1][i].resize(p2);
		tree[2][i].resize(p2);
	}
	//pas init mais on suppose=0 ?
	
	//fprintf(stderr, "pourquoi moi ? %d\n", N);
	
	for(int i = 1; i <= N; i++)
	{
		id[i][1]+=nbFeuilles[id[i][0]];
		//if(i==3)fprintf(stderr, "wesh yo mdr\n");
		tree[2][id[i][0]][id[i][1]] = 1;
	}
	for(int i = 1; i <= N; i++)
	{
		maj(id[i][0], id[i][1]/2);
		//printf("i survived till i=%d\n", i);
		update(i, 1, 1, 0);
		tree[1][id[i][0]][id[i][1]]=1;
	}
	
	//afficheQuiArbre();
	//inp(M);
	scanf("%d", &M);
	
	for(int i = 0; i < M; i++)
	{
		int t,u;
		//inp(t);
		//inp(u);
		scanf("%d%d", &t,&u);
		
		//printf("c'est find upper qui bug\n");
		int upperSB = findUpper(u, color[u]);
		if(t==0)
		{
			//printf("je suis la\n");
			//printf("debug : %d\n", upperSB);
			printf("%d\n", sumToRoot(color[u], id[upperSB][0], id[upperSB][1]));
		}
		else
		{
			//if(u==8)printf("debug upper=%d\n", upperSB);
			//tree[color[u]][id[u][0]][id[u][1]]-=1; //pe?
			int maValeur=sumToRoot(color[u], id[u][0], id[u][1]); //val[u]
			if(u!=1)
				update(pere[u], pere[upperSB], -maValeur, color[u]); //on soustrait à tous les noeuds sur le chemin sauf u
			//toggle(u);
			//tree[color[u]][id[u][0]][id[u][1]]-=1;
			color[u]=1-color[u];
			//tree[color[u]][id[u][0]][id[u][1]]+=1; //pepe??
			tree[2][id[u][0]][id[u][1]]^=1;
			maj(id[u][0], id[u][1]/2);
			//arbre[id[u][0]][id[u][1]]^=1;
			upperSB = findUpper(u,color[u]);
			//printf("i=%d et debug : %d\n", i, upperSB);
			maValeur=sumToRoot(color[u], id[u][0], id[u][1]);
			//printf("la boheme : %d\n", maValeur);
			if(u!=1)
				update(pere[u], pere[upperSB], +maValeur, color[u]);
		}
	}
	
	return 0;
}
