#include <cstdio>
#include <algorithm>
#define Sub(x, col) ((x<<1)|col)
#define stype(x) (x->f->son[1]==x)
#define isroot(x) ((!x->f)||(x->f->son[0]!=x&&x->f->son[1]!=x))
#define NE(x, y) ++ne, e[ne]=y, h[ne]=s[x], s[x]=ne
using namespace std;

const int N = 100005;
namespace LCT {
	struct node{
		node *f, *son[2];
		int tadd, val;
		node () {val = 1;}
		inline void SA(int x) {
			tadd += x, val += x;
		}
		inline void D() {
			if (tadd) {
				if (son[0]) son[0]->SA(tadd);
				if (son[1]) son[1]->SA(tadd);
				tadd = 0;
			}
		}
	} pool[N*2], *l[N*2];
	inline void rot(node *x) {
		node *fa = x->f; int st = stype(x);
		x->f=fa->f; if (!isroot(fa)) fa->f->son[stype(fa)]=x;
		fa->son[st]=x->son[!st]; if (x->son[!st]) x->son[!st]->f=fa;
		x->son[!st]=fa, fa->f=x;
	}
	inline node *Dpath(node *x) {
		int ln = 0;
		for (; !isroot(x); x=x->f) l[++ln] = x;
		for (x->D(); ln; --ln) l[ln]->D();
		return x;
	}
	void splay(node *x, node *y = 0) {
		if (!y) y = Dpath(x)->f; else Dpath(x);
		while (x->f!=y) {
			if (x->f->f!=y) rot(stype(x->f)==stype(x)?x->f:x);
			rot(x);
		}
	}
	void access(node *x) {
		splay(x); x->son[1]=0;
		while (x->f) {
			splay(x->f), x->f->son[1]=x;
			x = x->f;
		}
	}
	inline node *succ(node *x) {
		splay(x); x=x->son[1];
		for (x->D(); x->son[0]; x=x->son[0], x->D());
		return x;
	}
	inline int Q(node *x) {
		access(x); splay(x);
		for (x->D(); x->son[0]; x=x->son[0], x->D());
		x = succ(x);
		splay(x);
		return x->val;
	}
	inline int Q(int x) {
		return Q(pool + x);
	}
	inline void cut(node *x) {
		access(x); splay(x);
		x->son[0]->SA(-x->val);
		x->son[0]->f = 0, x->son[0] = 0;
	}
	inline void cut(int x) {
		cut(pool+x);
	}
	inline void link(node *x, node *y) {
		splay(x); x->f = y;
		access(y); splay(y); y->SA(x->val);
	}
	inline void link(int x, int y) {
		link(pool+x, pool+y);
	}
}
inline void R(int &x) {
	char ch = getchar(); x = 0;
	for (; ch<'0'; ch = getchar());
	for (; ch>='0'; ch = getchar()) x = x*10+ch-'0';
}
int n, m, ne = 0, s[N], e[N*2], h[N*2], col[N], fa[N];
void dfs(int x, int f) {
	fa[x] = f;
	for (int w=s[x]; w; w=h[w]) if (e[w]!=f)
		dfs(e[w], x);
}
int main() {
	int x, y, t;
	R(n);
	for (int i=1; i<n; ++i) {
		R(x); R(y);
		NE(x, y); NE(y, x);
	}
	dfs(1, 0);
	for (int i=1; i<=n; ++i)
		LCT::link(Sub(i, 0), Sub(fa[i], 0));
	R(m);
	for (int i=1; i<=m; ++i) {
		R(t); R(x);
		if (t == 1) {
			LCT::cut(Sub(x, col[x]));
			col[x] ^= 1;
			LCT::link(Sub(x, col[x]), Sub(fa[x], col[x]));
		} else
			printf("%d\n", LCT::Q(Sub(x, col[x])));
	}
	return 0;
}