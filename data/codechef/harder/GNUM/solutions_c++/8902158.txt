#include<bits/stdc++.h>
using namespace std;
#define getcx getchar
inline void in(int &n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
int arr[100005];
vector<int> primes;
void primeGeneration()
{
    primes.push_back(2);
    primes.push_back(3);
    int t = 2;
    for(int i=5; i*i<=100000; )
    {
        if(arr[i]==0)
        {
            for(int j=i*i; j<=100000; j=j+i+i)
            {
                arr[j] = 1;
            }
        }
        i = i+t;
        t = 6-t;
    }
    t = 2;
    for(int i=5; i<=100000; )
    {
        if(arr[i]==0)
        {
            primes.push_back(i);
        }
        i = i+t;
        t = 6-t;
    }
    return;
}
#define pii pair< int , int >
#define INF ((int)(1e9))
#define temp 0
#define perm 1
#define V 1505
int capacity[V][V];
int state[V] , from[V];
int cntLeft,cntRight;
int findPath(int source,int sink,int N)
{
    for(int i=0; i<N; i++)
    {
        state[i] = temp;
        from[i] = -1;
    }
    queue<int> Q;
    Q.push(source);
    state[source] = perm;
    while(!(Q.empty()))
    {
        int ver = Q.front();
        Q.pop();
        if(ver == 0)
        {
            for(int i=1; i<=cntLeft; i++)
            {
                if(capacity[ver][i]>0 && state[i] == temp)
                {
                    Q.push(i);
                    state[i] = perm;
                    from[i] = ver;
                }
            }
        }
        else if(ver>=1 && ver<=cntLeft)
        {
            for(int i=cntLeft+1; i<=cntLeft+cntRight; i++)
            {
                if(capacity[ver][i]>0 && state[i] == temp)
                {
                    Q.push(i);
                    state[i] = perm;
                    from[i] = ver;
                }
            }
        }
        else
        {
            for(int i=1; i<=cntLeft; i++)
            {
                if(capacity[ver][i]>0 && state[i] == temp)
                {
                    Q.push(i);
                    state[i] = perm;
                    from[i] = ver;
                }
            }
            if(capacity[ver][N-1]>0 && state[N-1] == temp)
            {
                Q.push(N-1);
                state[N-1] = perm;
                from[N-1] = ver;
            }
        }
        if(state[N-1] == perm)
        {
            break;
        }
    }
    int pathCapacity = INF;
    int curr = sink;
    int prev;
    while(from[curr]>-1)
    {
        prev = from[curr];
        pathCapacity = min(pathCapacity,capacity[prev][curr]);
        curr = prev;
    }
    if(pathCapacity==INF)
    {
        return 0;
    }
    //MaxFlow can be increased , so adjust the given network
    curr = sink;
    while(from[curr]>-1)
    {
        prev = from[curr];
        capacity[prev][curr]-=pathCapacity;
        capacity[curr][prev]+=pathCapacity;
        curr = prev;
    }
    return pathCapacity;
}
int maxFlow(int source,int sink,int N)
{
    int ans = 0;
    while(1)
    {
        int pathCapacity = findPath(source,sink,N);
        if(pathCapacity == 0)
        {
            break;
        }
        else
        {
            ans+=pathCapacity;
        }
    }
    return ans;
}
int func(int num)
{
    int ans = 1;
    for(int i=0; i<primes.size(); i++)
    {
        if(num%primes[i]==0)
        {
            ans*=primes[i];
            while(num%primes[i]==0)
            {
                num/=primes[i];
            }
        }
    }
    ans*=num;
    return ans;
}
int gcd(int x,int y)
{
    if(y==0)
        return x;
    return gcd(y,x%y);
}
int a[405],b[405];
int H[200005];
pair< int , int > Left[V] , Right[V];
int main()
{
    primeGeneration();
    int t;
    in(t);
    while(t--)
    {
        int n;
        in(n);
        for(int i=1; i<=n; i++)
        {
            in(a[i]);
        }
        for(int i=1; i<=n; i++)
        {
            in(b[i]);
        }
        vector<int> v,A,B;
        map< int , int > S;
        for(int i=1; i<=n; i++)
        {
            for(int j=1; j<=n; j++)
            {
                if(a[i]<b[j])
                {
                    int x = gcd(a[i],b[j]);
                    if(x!=1)
                    {
                        v.push_back(x);
                        A.push_back(x);
                        S.insert(pii(x,x));
                    }
                }
                else if(a[i]>b[j])
                {
                    int x = gcd(a[i],b[j]);
                    if(x!=1)
                    {
                        v.push_back(x);
                        B.push_back(x);
                        S.insert(pii(x,x));
                    }
                }
            }
        }
        for(map<int,int>::iterator it=S.begin(); it!=S.end(); it++)
        {
            int x = it->second;
            it->second = func(x);
        }
        assert(S.size()<=800);
        for(int i=0; i<v.size(); i++)
        {
            v[i] = S[v[i]];
        }
        for(int i=0; i<A.size(); i++)
        {
            A[i] = S[A[i]];
        }
        for(int i=0; i<B.size(); i++)
        {
            B[i] = S[B[i]];
        }
        sort(v.begin(),v.end());
        int cnt = 0;
        map< int , int > M;
        map< int , int >::iterator it;
        for(int i=0; i<v.size(); i++)
        {
            it = M.find(v[i]);
            if(it==M.end())
            {
                cnt++;
                M.insert(pii(v[i],cnt));
                H[cnt] = v[i];
            }
        }


        //Prepare the graph for maxFlow
        sort(A.begin(),A.end());
        cntLeft = 0;
        int prevLeft = -1;
        for(int i=0; i<A.size(); i++)
        {
            if(A[i]!=prevLeft)
            {
                cntLeft++;
                Left[cntLeft].first = M[A[i]];
                Left[cntLeft].second = 1;
            }
            else
            {
                Left[cntLeft].second++;
            }
            prevLeft = A[i];
        }
        sort(B.begin(),B.end());
        cntRight = 0;
        int prevRight = -1;
        for(int i=0; i<B.size(); i++)
        {
            if(B[i]!=prevRight)
            {
                cntRight++;
                Right[cntRight].first = M[B[i]];
                Right[cntRight].second = 1;
            }
            else
            {
                Right[cntRight].second++;
            }
            prevRight = B[i];
        }
        /*
        printf("\ncntLeft is %d\n",cntLeft);
        for(int i=1; i<=cntLeft; i++)
        {
            printf("%d %d %d\n",Left[i].first,H[Left[i].first],Left[i].second);
        }
        printf("\ncntRight is %d\n",cntRight);
        for(int i=1; i<=cntRight; i++)
        {
            printf("%d %d %d\n",Right[i].first,H[Right[i].first],Right[i].second);
        }
        */
        for(int i=0; i<=cntLeft+cntRight+1; i++)
        {
            for(int j=0; j<=cntLeft+cntRight+1; j++)
            {
                capacity[i][j] = 0;
            }
        }
        for(int i=1; i<=cntLeft; i++)
        {
            capacity[0][i] = Left[i].second;
        }
        for(int i=cntLeft+1; i<=cntLeft+cntRight; i++)
        {
            capacity[i][cntLeft+cntRight+1] = Right[i-cntLeft].second;
        }
        for(int i=1; i<=cntLeft; i++)
        {
            for(int j=cntLeft+1; j<=cntLeft+cntRight; j++)
            {
                int x = gcd( H[Left[i].first] , H[Right[j-cntLeft].first] );
                //printf("i is %d j is %d gcd is %d\n",i,j,x);
                if(x>1)
                {
                    capacity[i][j] = INF;
                }
            }
        }
        //Done

        /*
        printf("\ngraph is \n");
        for(int i=0; i<=cntLeft+cntRight+1; i++)
        {
            for(int j=0; j<=cntLeft+cntRight+1; j++)
            {
                printf("%d ",capacity[i][j]);
            }
            printf("\n");
        }
        */

        int ans = maxFlow(0,cntLeft+cntRight+1,cntLeft+cntRight+2);
        printf("%d\n",ans);
    }
    return 0;
}
