#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>
#include <bitset>
#include <list>

using namespace std;

#define pb push_back
#define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++)
#define INF 1011111111
#define rep(i, n) FOR(i, 0, n)
#define CL(a, v) memset((a), (v), sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int, int> pii;

/*** TEMPLATE CODE ENDS HERE */

#define MAX_PR 10001

using namespace std;

namespace PushRelabel {

typedef long long LL;

struct Edge {
  int from, to, cap, flow, index;
  Edge(int from, int to, int cap, int flow, int index)
      : from(from), to(to), cap(cap), flow(flow), index(index) {}
};

const int MAXN = 2002;
int N;
vector<vector<Edge> > G;
vector<LL> excess;
vector<int> dist, active, count;
queue<int> Q;

void Init(int n) {
  Q = queue<int>();
  N = n;
  G = vector<vector<Edge> >(n);
  excess = vector<LL>(n);
  dist = VI(n);
  active = VI(n);
  count = VI(2 * n);
}

void AddEdge(int from, int to, int cap) {
  G[from].push_back(Edge(from, to, cap, 0, (int)G[to].size()));
  if (from == to) G[from].back().index++;
  G[to].push_back(Edge(to, from, 0, 0, (int)G[from].size() - 1));
}

void Enqueue(int v) {
  if (!active[v] && excess[v] > 0) {
    active[v] = true;
    Q.push(v);
  }
}

void Push(Edge &e) {
  int amt = int(min(excess[e.from], LL(e.cap - e.flow)));
  if (dist[e.from] <= dist[e.to] || amt == 0) return;
  e.flow += amt;
  G[e.to][e.index].flow -= amt;
  excess[e.to] += amt;
  excess[e.from] -= amt;
  Enqueue(e.to);
}

void Gap(int k) {
  for (int v = 0; v < N; v++) {
    if (dist[v] < k) continue;
    count[dist[v]]--;
    dist[v] = max(dist[v], N + 1);
    count[dist[v]]++;
    Enqueue(v);
  }
}

void Relabel(int v) {
  count[dist[v]]--;
  dist[v] = 2 * N;
  for (int i = 0; i < G[v].size(); i++)
    if (G[v][i].cap - G[v][i].flow > 0)
      dist[v] = min(dist[v], dist[G[v][i].to] + 1);
  count[dist[v]]++;
  Enqueue(v);
}

void Discharge(int v) {
  for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);
  if (excess[v] > 0) {
    if (count[dist[v]] == 1)
      Gap(dist[v]);
    else
      Relabel(v);
  }
}

LL GetMaxFlow(int s, int t) {
  count[0] = N - 1;
  count[N] = 1;
  dist[s] = N;
  active[s] = active[t] = true;
  for (int i = 0; i < G[s].size(); i++) {
    excess[s] += G[s][i].cap;
    Push(G[s][i]);
  }

  while (!Q.empty()) {
    int v = Q.front();
    Q.pop();
    active[v] = false;
    Discharge(v);
  }

  LL totflow = 0;
  for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;
  return totflow;
}
}  // namespace PushRelabel

namespace Dinic {

const int MAXN = 2002;

struct Edge {
  int u, v, cap, flow;
};

int N, d[MAXN], ptr[MAXN], q[MAXN];
vector<Edge> edge;
vector<int> g[MAXN];

void Init(int n) {
  N = n;
  edge = vector<Edge>();
  rep(i, n) g[i] = VI();
  memset(d, 0, n * sizeof(int));
  memset(ptr, 0, n * sizeof(int));
  memset(q, 0, n * sizeof(int));
}

void AddEdge(int u, int v, int cap) {
  Edge e1 = {u, v, cap, 0};
  Edge e2 = {v, u, 0, 0};
  g[u].push_back((int)edge.size());
  edge.push_back(e1);
  g[v].push_back((int)edge.size());
  edge.push_back(e2);
}

bool bfs(const int source, const int sink) {
  memset(d, -1, N * sizeof(d[0]));
  d[source] = 0;

  int qh = 0, qt = 0;
  q[qt++] = source;

  while (qh < qt && d[sink] == -1) {
    int u = q[qh++];
    for (size_t i = 0; i < g[u].size(); ++i) {
      int id = g[u][i];
      int v = edge[id].v;
      if (d[v] == -1 && edge[id].flow < edge[id].cap) {
        d[v] = d[u] + 1;
        q[qt++] = v;
      }
    }
  }

  return d[sink] != -1;
}

int dfs(const int u, const int t, const int flow) {
  if (flow == 0) return 0;
  if (u == t) return flow;
  for (int &i = ptr[u]; i < g[u].size(); ++i) {
    int id = g[u][i];
    int v = edge[id].v;
    if (d[v] != d[u] + 1) continue;
    int pushed = dfs(v, t, min(flow, edge[id].cap - edge[id].flow));
    if (pushed) {
      edge[id].flow += pushed;
      edge[id ^ 1].flow -= pushed;
      return pushed;
    }
  }
  return 0;
}

int GetMaxFlow(int source, int sink) {
  int flow = 0;
  while (bfs(source, sink)) {
    CL(ptr, 0);
    while (int push = dfs(source, sink, INF)) flow += push;
  }
  return flow;
}
}

namespace EdmonsKarp {
const int maxn = 2002;

struct Edge {
  int u, v, cap;
};

vector<Edge> E;
VI g[maxn];

void Init(int n) {
  rep(i, n) g[i] = VI();
  E = vector<Edge>();
}

void AddEdge(int from, int to, int cap) {
  Edge e1 = {from, to, cap};
  g[from].push_back((int)E.size());
  E.push_back(e1);
  Edge e2 = {to, from, 0};
  g[to].push_back((int)E.size());
  E.push_back(e2);
}

int q[maxn];
int from[maxn];

int GetMaxFlow(int S, int T) {
  int flow = 0;
  while (true) {
    rep(i, maxn) from[i] = -1;
    int qh = 0, qt = 0;
    q[qt++] = S;
    from[S] = S;

    while (qh < qt && from[T] == -1) {
      int at = q[qh++];
      rep(i, (int)g[at].size()) {
        const Edge &e = E[g[at][i]];
        if (from[e.v] == -1 && e.cap > 0) {
          q[qt++] = e.v;
          from[e.v] = g[at][i];
        }
      }
    }

    if (from[T] == -1) break;
    int push = INF;
    for (int v = T; from[v] != v;) {
      int id = from[v];
      push = min(push, E[id].cap);
      v = E[id].u;
    }
    assert(push != 0);
    for (int v = T; from[v] != v;) {
      int id = from[v];
      E[id].cap -= push;
      E[id ^ 1].cap += push;
      v = E[id].u;
    }
    flow += push;
  }
  return flow;
}
}

//#define FLOW PushRelabel
#define FLOW Dinic
//#define FLOW EdmonsKarp

typedef vector<int> vi;

int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }

vi vA;
map<int, int> gL, gR;
int t, n;

vi primes;
bitset<MAX_PR> isP;

inline int Normalize(int x) {
  int ret = 1;
  for (int i = 0; i < primes.size() && x > 1; i++) {
    if (x % primes[i] == 0) {
      ret *= primes[i];
      while (x % primes[i] == 0) x /= primes[i];
    }
  }
  return ret;
}

inline void markP(int x) {
  primes.push_back(x);
  for (int i = x + x; i < MAX_PR; i += x) isP.reset(i);
}

void sieve() {
  isP.set();
  markP(2);
  for (int i = 3; i < MAX_PR; i += 2) {
    if (isP[i]) markP(i);
  }
}

int main() {
#ifdef LOCAL_HOST
  freopen("input.txt", "r", stdin);
// freopen("output.txt","w",stdout);
#endif
  ios_base::sync_with_stdio(false);
  sieve();
  cin >> t;
  while (t--) {
    cin >> n;
    gL.clear();
    gR.clear();
    vA.clear();
    int x;
    for (int i = 0; i < n; i++) {
      cin >> x;
      vA.push_back(x);
    }
    int g;
    for (int j = 0; j < n; j++) {
      cin >> x;

      for (int i = 0; i < n; i++) {
        if (vA[i] < x) {  // Left
          g = Normalize(gcd(vA[i], x));
          if (g > 1) {
            if (!gL.count(g)) {
              gL[g] = 0;
            }
            gL[g]++;
          }
        } else if (vA[i] > x) {  // Right
          g = Normalize(gcd(vA[i], x));
          if (g > 1) {
            if (!gR.count(g)) {
              gR[g] = 0;
            }
            gR[g]++;
          }
        }
      }
    }

    int source = 0, target = (int)gL.size() + (int)gR.size() + 1;

    FLOW::Init((int)gL.size() + (int)gR.size() + 2);
    map<int, int>::const_iterator it, it2;
    int id, id2;
    for (it = gL.begin(), id = 1; it != gL.end(); ++it, id++) {
      FLOW::AddEdge(source, id, it->second);
    }
    for (it = gR.begin(), id = (int)gL.size() + 1; it != gR.end(); ++it, id++) {
      FLOW::AddEdge(id, target, it->second);
    }

    for (it = gL.begin(), id = 1; it != gL.end(); ++it, id++) {
      for (it2 = gR.begin(), id2 = (int)gL.size() + 1; it2 != gR.end();
           ++it2, id2++) {
        if (gcd(it->first, it2->first) > 1) {
          FLOW::AddEdge(id, id2, it->second);
        }
      }
    }

    cout << FLOW::GetMaxFlow(source, target) << '\n';
  }
}
