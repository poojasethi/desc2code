#include "bits/stdc++.h"
#define min(a,b) (a)<(b)?(a):(b)
#define max(a,b) (a)>(b)?(a):(b)
#define abso(a) (a)>(0)?(a):(-a)
#define gcd(a,b) __gcd(a,b)
#define lcm(a,b) (a*(b/gcd(a,b)))
#define VI vector<int>
#define pb push_back
#define all(c) c.begin(), c.end()
#define pii pair<int, int>
#define pip pair<int, pii>
#define F first
#define S second
#define mp make_pair
#define CLR(p) memset(p, 0, sizeof(p))
#define SET(p) memset(p, -1, sizeof(p))
#define INF 0x3f3f3f3f
using namespace std;


inline void inp(int *n)
{
    *n = 0;
    int ch = getchar_unlocked();
    int sign = 1;
    while(ch < '0' || ch > '9') 
    {
        if (ch == '-') 
            sign = -1;
        ch = getchar_unlocked();
    }
    while(ch >= '0' && ch <= '9')
        (*n) = ((*n)<<3) + ((*n)<<1) + ch - '0', ch = getchar_unlocked();
    *n = (*n)*sign;
}

typedef long long LL;
 
struct Edge 
{
    int from, to, cap, flow, index;
    Edge(int from, int to, int cap, int flow, int index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};
 
struct PushRelabel 
{
    int N;
    vector<vector<Edge> > G;
    vector<LL> excess;
    vector<int> dist, active, count;
    queue<int> Q;
     
    PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}
     
    void AddEdge(int from, int to, int cap) 
    {
        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
        if (from == to) 
            G[from].back().index++;
        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
    }
     
    void Enqueue(int v) 
    {
        if (!active[v] && excess[v] > 0) 
        { 
            active[v] = true; 
            Q.push(v); 
        }
    }
     
    void Push(Edge &e) 
    {
        int amt = int(min(excess[e.from], LL(e.cap - e.flow)));
        if (dist[e.from] <= dist[e.to] || amt == 0) 
            return;
        e.flow += amt;
        G[e.to][e.index].flow -= amt;
        excess[e.to] += amt;
        excess[e.from] -= amt;
        Enqueue(e.to);
    }
    void Gap(int k) 
    {
        for (int v = 0; v < N; v++) 
        {
            if (dist[v] < k) 
                continue;
            count[dist[v]]--;
            dist[v] = max(dist[v], N+1);
            count[dist[v]]++;
            Enqueue(v);
        }
    }
     
    void Relabel(int v) 
    {
        count[dist[v]]--;
        dist[v] = 2*N;
        for (int i = 0; i < G[v].size(); i++)
            if (G[v][i].cap - G[v][i].flow > 0)
                dist[v] = min(dist[v], dist[G[v][i].to] + 1);
        count[dist[v]]++;
        Enqueue(v);
    }
     
    void Discharge(int v) 
    {
        for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) 
            Push(G[v][i]);
        if (excess[v] > 0) 
        {
            if (count[dist[v]] == 1)
                Gap(dist[v]);
            else
                Relabel(v);
        }
    }
     
    LL GetMaxFlow(int s, int t) 
    {
        count[0] = N-1;
        count[N] = 1;
        dist[s] = N;
        active[s] = active[t] = true;
        for (int i = 0; i < G[s].size(); i++) 
        {
            excess[s] += G[s][i].cap;
            Push(G[s][i]);
        }
        while (!Q.empty()) 
        {
            int v = Q.front();
            Q.pop();
            active[v] = false;
            Discharge(v);
        }
        LL totflow = 0;
        for (int i = 0; i < G[s].size(); i++) 
            totflow += G[s][i].flow;
        return totflow;
    }
};

int a[512], b[512], n;
map< int, int > U, V;


int main()
{
    int t;
    inp(&t);
    while(t--)
    {
        inp(&n);
        for (int i = 0; i < n; ++i)
        {
            inp(&a[i]);
        }
        for (int i = 0; i < n; ++i)
        {
            inp(&b[i]);
        }
        U.clear();
        V.clear();
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int g = __gcd(a[i], b[j]);
                if(g > 1)
                {
                    if(a[i] < b[j])
                    {
                        if(!U.count(g))
                            U[g] = 1;
                        else
                            U[g]++;
                        
                    }
                    else if(a[i] > b[j])
                    {
                        if(!V.count(g))
                            V[g] = 1;
                        else
                            V[g]++;
                    }

                }
            }
        }
        int source = 0, target = U.size() + V.size() + 1;
        PushRelabel PR(target + 1);
        map< int, int >::iterator it1, it2;


        int id1 = 1;
        for (it1 = U.begin(); it1 != U.end(); ++it1, id1++)
        {
//            printf("adding edge from %d to %d with capacity %d\n", source, id1, it1->second);
            PR.AddEdge(source, id1, it1->second);
        }

        int id2 = U.size() + 1;
        for (it2 = V.begin(); it2 != V.end(); ++it2, id2++)
        {
  //          printf("adding edge from %d to %d with capacity %d\n", id2, target, it2->second);
            PR.AddEdge(id2, target,  it2->second);
        }

        for (it1 = U.begin(), id1 = 1; it1 != U.end(); ++it1, id1++)
        {
            for (it2 = V.begin(), id2 = U.size() + 1; it2 != V.end(); ++it2, id2++)   
            {
                if(__gcd(it1->first, it2->first) > 1) 
                {
    //                printf("adding edge from %d to %d with capacity %d\n", id1, id2, it1->second);
                    PR.AddEdge(id1, id2, it1->second);
                }
            }
        }

        printf("%lld\n",PR.GetMaxFlow(source, target) );





    }
    return 0;
}    