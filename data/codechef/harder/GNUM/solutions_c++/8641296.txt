#include <map>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n	500005
#define m	5000005
#define INF	(1<<30)
#define For(i,a,b)	for(int i=a;i<=b;i++)

int		N,C,D,S,T,Test,A[n],B[n],P[n],Q[n],st[n],Dis[n];
struct	Lin{int v,f,next;}E[m];
map<int,int>G,L,R;

void	Work(int d){
		for (int i=2;i*i<=d;i++)
			if	(d%i==0)	for (P[++*P]=i;d%i==0;d/=i);
		if	(d^1)	P[++*P]=d;
}
void	Link(int u,int v,int f){
		E[++D]=(Lin){v,f,st[u]};	st[u]=D;
		E[++D]=(Lin){u,0,st[v]};	st[v]=D;
}

bool	BFS(){
		For(i,1,C)	Dis[i]=-1;	Dis[Q[1]=S]=0;
		for (int l=0,r=1;l<r;)	{
			int u=Q[++l];
			for (int i=st[u],v;i;i=E[i].next)
			if	(E[i].f&&Dis[v=E[i].v]==-1){
				Dis[Q[++r]=v]=Dis[u]+1;
				if	(v==T)	return	1;
			}
		}	return	0;
}
int		DFS(int u,int Lim){
		if	(u==T)	return	Lim;	int ret=0;
		for (int i=st[u],v;i;i=E[i].next)
		if	(E[i].f&&Dis[u]+1==Dis[v=E[i].v]){
			int t=DFS(v,min(E[i].f,Lim-ret));
			if	(t)	{
				E[i].f-=t;	E[i^1].f+=t;ret+=t;
				if	(ret==Lim)	break;
			}	else	Dis[v]=-1;
		}	return	ret;
}

int		main(){
	//	freopen("1.in","r",stdin);
	//	freopen("1.out","w",stdout);

		scanf("%d",&Test);
		for (;Test--;)	{
			scanf("%d",&N);	*P=0;
			For(i,1,N)	scanf("%d",&A[i]),Work(A[i]);
			For(i,1,N)	scanf("%d",&B[i]),Work(B[i]);
			sort(P+1,P+*P+1);	*P=unique(P+1,P+*P+1)-P-1;

			C=*P,D=1;	S=++C;	T=++C;	G.clear();
			For(i,1,C)	st[i]=0;
			For(i,1,*P)	G[P[i]]=i;
			L.clear();	R.clear();

			For(i,1,N)	For(j,1,N)	{
				int d=__gcd(A[i],B[j]);
				if	(d==1||A[i]==B[j])	continue;
				A[i]<B[j]?L[d]++:R[d]++;
			}

	//		printf("%d %d\n",L.size(),R.size());

			For(i,1,N)	For(j,1,N)	{
				int d=__gcd(A[i],B[j]);
				if	(d==1||A[i]==B[j])	continue;
				
				if	(A[i]<B[j])	{
//					if(TL[d]) fprintf(stderr,"fuck\n"); 
					if	(!L.count(d))	continue;
					st[++C]=0;	Link(S,C,L[d]); 
					L.erase(d);
			//		printf("%d\n",L.count(d));
					for (int i=2;i*i<=d;i++)
						if	(d%i==0)	for (Link(C,G[i],INF);d%i==0;d/=i);
					if	(d^1)	Link(C,G[d],INF);
					
				}	else	{
//					if(TR[d]) fprintf(stderr,"fuck\n");
					if	(!R.count(d))	continue;
					st[++C]=0;	Link(C,T,R[d]);
					R.erase(d);
					for (int i=2;i*i<=d;i++)
						if	(d%i==0)	for (Link(G[i],C,INF);d%i==0;d/=i);
					if	(d^1)	Link(G[d],C,INF);
				
				}
				
			}

			int Ans=0;
			for (;BFS();)	Ans+=DFS(S,INF);
			printf("%d\n",Ans);
		}
}