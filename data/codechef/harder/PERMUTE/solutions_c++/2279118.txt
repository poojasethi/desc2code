#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <cctype>
#include <cfloat>
#include <climits>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <string>
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <deque>
#include <map>
#include <set>
#include <utility>
#include <sys/time.h>

#define INF 1000000007
#define EPS (1e-8)
#define pb(a) push_back(a)
#define pf(a) push_front(a)
#define mp make_pair
#define FOR(i,k) for(i=0;i<k;i++)
#define RFOR(i,k) for(i=k-1;i>=0;i--)
const long double PI = 3.1415926535897932384626433832795;
typedef long long LL;


using namespace std;

// computes a^b % mod
LL modular_exponentiation_recursive( LL a , LL b , LL n )
{
  if( b == 0 )
    {
      return 1;
    }
  
  if( b == 1 )
    {
      return ( a % n );
    }

  LL ans;

  ans = modular_exponentiation_recursive( a , b/2 , n );
  ans = ( ans*ans )%n;

  if( (b%2) != 0 )
    {
      ans = ( ans * a )%n;
    }
  return ans;
}


int main()
{
  int tests;
  scanf("%d",&tests);
  
  LL modnum = 1000000007;
  int factarr[1000009];
  
  factarr[0] = 1;
  factarr[1] = 1;
  for( LL i = 2 ; i < 1000000 ; i++ )
    {
      factarr[i] = ( i * factarr[i-1] ) % modnum;
    }
  
  LL n,m,k;
  while( tests-- > 0 )
    {
      scanf("%lld%lld",&n,&m);
      
      k = 2*n - m;
      
      LL ans = factarr[n-k];
      ans = ( ans * modular_exponentiation_recursive( n-k+1 , (k+1)/2 , modnum ) ) % modnum ;
      ans = ( ans * modular_exponentiation_recursive( n-k , k/2 , modnum ) ) % modnum;
      
      printf("%lld\n",ans);
    }
  
  return 0;
}


