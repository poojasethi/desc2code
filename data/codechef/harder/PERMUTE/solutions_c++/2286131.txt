/*
Placing the number in decreasing order (start with N).
When placing n (n may not equal N), we should now currently how many safe "segment" are there.
For example: N = 10, M = 17, so when placing 10, there must be 7 safe segment which is 1, 2, ..., 7.

There are two way of placing n like you said, but when we continuing to placing n - 1, the number of safe segment will not be change.
Use the example above, after placed 10, the safe segment for 10 will be 6 but when we placing 9, besides these 6 safe segments, we have new safe segment: 8. So the k will not change.

Our nice formula will be f[n, k] = (2 * k + k * (k - 1)) * f[n - 1][k] for n large enough.

When n is small, we will calculate f in O(1) since n and all the current safe segments can be placing in any order.
The formula will be different for odd M and even M.
*/
#include <assert.h>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <algorithm>

#define FOR(i,a,b) for (int i = int(a); i <= b; i++)
#define DOWN(i,a,b) for (int i = int(a); i >= b; i--)

#define mod 1000000007

using namespace std;
long long fact[1222222];

long long power(int n, int k) {
    if (k == 0) return 1;
    long long res = power(n, k / 2);
    res = (res * res) % mod;

    if (k % 2) res = (res * n) % mod;
    return res;
}

int main() {
    int ntest;
    cin >> ntest;

    fact[0] = 1;
    FOR (i, 1, 1000000) fact[i] = ((long long)i * fact[i - 1]) % mod;
    while (ntest--) {
        int n, m;
        scanf("%d%d", &n, &m);

        long long k = m - n;

        long long num = (2LL * k + k * (k - 1)) % mod;
        long long base = n - (m + 1) / 2;

        long long res = fact[k + (m % 2)];

        res = (res * power(num, base)) % mod;
        res = (res + mod) % mod;
        printf("%d\n", res);
    }

    return 0;
}
