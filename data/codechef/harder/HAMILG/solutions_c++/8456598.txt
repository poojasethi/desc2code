#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)
#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)
using namespace std;
typedef long long LL;
typedef double db;
const int N=2100;
int f[N];
int get(int x){
	if(x==f[x])return x;
	return f[x]=get(f[x]);
}
vector<int>p[N];
int link[N];
int match[N],kind[N],have[N],vis[N],tt;
int q[N];
int n,m,T;
int lca(int x,int y){
	++tt;
	while(true){
		if(x){
			x=get(x);
			if(vis[x]==tt)return x;
			vis[x]=tt;
			if(match[x])x=link[match[x]];else x=0;
		}
		swap(x,y);
	}
}
void mg(int a,int b){
	f[get(a)]=get(b);
}
void Union(int a,int p){
	while(a^p){
		int b=match[a];int c=link[b];
		if(get(c)^p)link[c]=b;
		if(kind[b]==2)kind[q[++q[0]]=b]=1;
		if(kind[c]==2)kind[q[++q[0]]=c]=1;
		mg(a,b);mg(b,c);
		a=c;
	}
}
void work(int st){
	rep(i,1,n)kind[i]=link[i]=0;
	rep(i,1,n)f[i]=i;
	kind[st]=1;q[q[0]=1]=st;
	rep(i,1,q[0]){
		int x=q[i];
		have[x]=1;
		rep(j,0,p[x].size()-1){
			int y=p[x][j];
			if(kind[y]==2)continue;
			if(match[x]==y)continue;
			if(get(x)==get(y))continue;
			
			if(kind[y]==1){
				int r=lca(x,y);
				if(get(x)!=r)link[x]=y;
				if(get(y)!=r)link[y]=x;
				Union(x,r);
				Union(y,r);
			}
			else
			if(!match[y]){
				link[y]=x;
				while(x){
					int z=match[x];
					match[x]=y;
					match[y]=x;
					y=z;
					x=link[y];
				}
				return;
			}
			else{
				q[++q[0]]=match[y];
				kind[match[y]]=1;
				kind[y]=2;
				link[y]=x;
			}
		}
	}
}
void deep_dark_fantasy(){
	scanf("%d%d",&n,&m);tt=0;
	rep(i,1,n){
		match[i]=kind[i]=have[i]=link[i]=0;
		p[i].clear();vis[i]=0;
		f[i]=i;
	}
	q[0]=0;
	rep(i,1,m){
		int u,v;scanf("%d%d",&u,&v);
		p[u].push_back(v);
		p[v].push_back(u);
	}
	rep(i,1,n)if(!match[i])work(i);
	memset(have,0,sizeof have);
	rep(i,1,n)if(!match[i])work(i);
	int ans=0;
	rep(i,1,n)if(have[i])ans++;
	printf("%d\n",ans);
}
int main(){
	scanf("%d",&T);
	while(T--){
		deep_dark_fantasy();
	}
	return 0;
}


