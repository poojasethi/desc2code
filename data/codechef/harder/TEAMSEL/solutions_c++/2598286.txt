// Approach - Pseudo polynomial time dynamic programming approach similar to knapsack problem.
// URL - http://en.wikipedia.org/wiki/Knapsack_problem
//   and http://en.wikipedia.org/wiki/Partition_problem
//
// If the kth bit in dp[j] is set it means that there exists a subset with k elements whose sum
// is equal to j. 
// 
// For example -  let there be 5 players with skills 1,2,3,4,5. We start with only 
// 1 element equal to 1. Thus dp[1] will become 1. Then 2 is added to the set. dp[2] will become
// 1. Also dp[3] will become 2. This is 2 in binary is 10 and it indicates that there is a subset
// of 2 elements whose sum equals 3. Such a subset is {1,2}. On adding 3 to the set dp[6] will become
// 4 because 4 when written in binary is 100. Since the third bit is set it means that there is a subset
// of 3 elements whose sum is 6 and we know that the subset is {1,2,3}.
//
// Following this approach we fill all the values and in the end we find the value that is 
// closest to half of the sum and has the bit set for half of the numbers. That value is one of our results.

// Uncomment the lines with the marker '//#' to see how dptable changes and try with example player skills as 1,2,3,4,5 


#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <algorithm>
#include <iostream>
#include <complex>

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define all(c) (c).begin(), (c).end()
#define sz(a) int((a).size())
#define pb push_back
#define mp make_pair
#define traverse(c,it, cond) for(it = c.begin(); it != c.end() && cond; it++)
#define ll long long
#define INF 0x7FFFFFFF

int arr[101];
unsigned ll dptable[22501],res1,res2,x1,x2;

int main()
{
	int t,n,sum,halfsum,i,j,n1,n2;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		sum=0;
		for(i=0;i<n;i++)
		{
			scanf("%d",&arr[i]);
			sum += arr[i];
		}
		
		if(n == 1)
		{
			printf("0 %d\n",arr[0]);
			continue;
		}
		
		halfsum = (sum+1)>>1;
		
		memset(dptable,0,sizeof(dptable));
		
		for(i=0;i<n;i++)
		{
			for(j=halfsum;j>arr[i];j--)
			{
				dptable[j] |= (dptable[j-arr[i]]<<1);
//#				printf("dptable[%d] = %llu\n",j,dptable[j]);
			}
			dptable[arr[i]] |= 1;
//#			printf("dptable[%d] = %llu\n",arr[i],dptable[arr[i]]);
//#			printf("\n");
		}
		
		n1 = n>>1;
		n2 = n - n1;
		
		x1 = 1ULL << (n1 - 1);
		x2 = 1ULL << (n2 - 1);
		
		for(i=halfsum;i>=0;i--)
		{
			if((dptable[i] & x1) || (dptable[i] & x2))
				break;
		}
		
		if(i<0)
			i=0;
		
		if(i < sum-i)
		{
			res1 = i;
			res2 = sum-i;
		}
		else
		{
			res1 = sum-i;
			res2 = i;
		}
		
		printf("%llu %llu\n",res1,res2);
	}
	return 0;
}
