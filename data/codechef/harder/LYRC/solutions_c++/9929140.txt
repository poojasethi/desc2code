#include <bits/stdc++.h>
#define sz(n) n.size()
#define SD(n) scanf("%d", &n)
#define SS(n) scanf("%s", n)
#define SDD(n,m) scanf("%d%d", &n,&m)
#define FOR(i, n) for(int i = 0; i < n; i++)
#define FAB(i, a,b) for(int i = a; i < b; i++)
#define mp make_pair
#define pb push_back
#define zero(n) memset(n, 0, sizeof(n))
#define mone(n) memset(n, -1, sizeof(n))
using namespace std;
#define endl '\n'
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;

#define N 505
#define MN 5000*505
#define ALF 100
int term[MN], ac[MN][ALF], fail[MN], fr[MN], node[MN], siz,termina[MN],cant[MN],cant2[MN];
int father[MN];
vector<int> order;
const int INF = 1e9;
map<char, int> mapa;
int num = 1;
int conv(char c) {
    if(!mapa[c])
    {
        mapa[c] = num++;
    }
    return mapa[c];
}
void init() {
        for (int i = 0; i <= siz; i++) {
                memset(ac[i], 0, sizeof(ac[i]));
                term[i] = 0;
        }
        siz = 1;
}
void build() {
        order.clear();
        fail[1] = 1;
        queue<int> Q;
        for (int i = 0; i < ALF; i++)
                if (ac[1][i]) {
                        fail[ac[1][i]] = 1;
                        Q.push(ac[1][i]);
                } else
                        ac[1][i] = 1;
        while (!Q.empty()) {
                int u = Q.front();
                Q.pop();
                order.push_back(u);
                term[u] |= term[fail[u]];
                for (int i = 0; i < ALF; i++) {
                        int v = ac[u][i];
                        if (v) {
                                fail[v] = ac[fail[u]][i];
                                Q.push(v);
                        } else {
                                ac[u][i] = ac[fail[u]][i];
                        }
                }
                cant[fail[u]]++;
        }
}
void insert(char *S, int id) {
        int nod = 1;
        int len = strlen(S);
        for (int i = 0; i < len; i++) {
                int c = conv(S[i]);
                if (!ac[nod][c])
                        ac[nod][c] = ++siz;
                nod = ac[nod][c];
        }
        if(!termina[nod])
        {
            termina[nod] = id;
        }
        father[id] = nod;
        term[nod] = 1;
}

void match(char *s)
{
    int now = 1, len = strlen(s), i;
	for(i = 0; i < len; i++)
	{
	    now = ac[now][conv(s[i])];
        cant2[now]++;
	}
}

queue<int> Q;
void DP()
{
    while(!Q.empty())Q.pop();
    int i, z, j, u;

	for(i = 1; i <= siz; i++)
	{
		if(cant[i] == 0)
			Q.push( i );
	}

	while(!Q.empty())
	{
		u = Q.front();
		Q.pop();
		cant[fail[u]]--;
		if(cant[fail[u]] == 0)
		{
			Q.push(fail[u]);
		}
		cant2[fail[u]]+=cant2[u];
	}
}
char cad[505][5005];
char text[105][50005];

int main()
{
    int t,n;
    SD(n);
    init();
    FOR(i, n)
    {
        SS(cad[i]);
        insert(cad[i], i+1);
    }
    build();
    SD(t);
    FOR(i, t)
    {
        SS(text[i]);
    }
    FOR(i, t)
    {
        match(text[i]);
    }
    DP();
    FOR(i, n)
    {
        printf("%d\n", cant2[father[i+1]]);
    }
    return 0;
}


