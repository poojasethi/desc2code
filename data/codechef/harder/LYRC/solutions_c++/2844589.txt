/** author : ayush sharma **/
#include<iostream>
#include<functional>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<string>
#include<sstream>
#include<vector>
#include<queue>
#include<set>
#include<map>
#include<stack>
#define FOR(i,a,b) for(int i=a; i<b; i++)
#define FORr(i,a,b) for(int i=a ; i>=b; i--)
#define pb push_back
#define mp make_pair
#define ub upper_bound
#define lb lower_bound
#define si1(n) scanf("%d",&n)
#define si2(n1, n2) scanf("%d%d",&n1,&n2)
#define si3(n1,n2,n3) scanf("%d%d%d",&n1, &n2, &n3)
#define si4(n1,n2,n3,n4) scanf("%d%d%d%d",&n1, &n2, &n3, &n4)
#define FF first
#define SS second
#define READ(x) freopen(x,"r",stdin)
#define WRITE(x) freopen(x,"w",stdout)
#define show1(a) cout<<a<<"\n"
#define show2(a, b) cout<<a<<"   "<<b<<"\n"
#define show3(a, b, c) cout<<a<<"   "<<b<<"    "<<c<<"\n"
#define show4(a, b, c,d) cout<<a<<"   "<<b<<"    "<<c<<"   "<<d<<"\n"

using namespace std;
typedef long long LL;
typedef pair <int,int> pii;
typedef pair<string,int> psi;
typedef vector<int> vi;



#define sz 500
#define ROOT 0
#define NIL -1
#define ALPHA 63
int t_size;
struct linked_list{
    int val; // id of current word;
    int next;
    linked_list(){
        val=next=-1;
    }
}list[sz+1];
int freq[sz+1]; //counts frequency of visit of each node
struct state_body{
    int fail, head, tail;
    int edge[ALPHA];
    state_body(){
        fail=head=tail=NIL;
        memset(edge,NIL,sizeof edge);
    }
}state[sz*5000+1];
int node_sz=0;
void addWord(int id, char *w, int *num){
    int pos=ROOT;
    for(int i=0;w[i];i++){
        int p=num[w[i]];
        if(state[pos].edge[p]==NIL) state[pos].edge[p]=t_size++;
        pos=state[pos].edge[p];
    }
    if(state[pos].head==NIL) state[pos].head=++node_sz, state[pos].tail=node_sz, list[node_sz].val=id;
    else list[state[pos].tail].next=++node_sz, list[node_sz].val=id, state[pos].tail=node_sz;
}

void makeFailureFunction(){
    state[ROOT].fail= t_size;
    FOR(i,0,ALPHA) state[t_size].edge[i]=ROOT;
    queue<int> Q;
    FOR(i,0,ALPHA){
        if(state[ROOT].edge[i]!=NIL){
            int u=state[ROOT].edge[i];
            state[u].fail=ROOT;
            Q.push(u);
        }
    }
    while(!Q.empty()){
        int cur=Q.front(); Q.pop();
        FOR(i,0,ALPHA){
            if(state[cur].edge[i]!=NIL){
                int u=state[cur].edge[i];
                Q.push(u);
                int F=state[cur].fail;
                while(state[F].edge[i]==NIL) F=state[F].fail;
                state[u].fail=state[F].edge[i];
                F=state[F].edge[i];
                if(!~state[F].head) continue;
                else if(!~state[u].head) state[u].head=state[F].head, state[u].tail=state[F].tail;
                else if(state[u].head!=NIL) list[state[u].tail].next=state[F].head, state[u].tail=state[F].tail;
            }
        }
    }
}

void doMatching(char *P, int *num){
    int pos=ROOT;
    for(int i=0;P[i];i++){
        int p=num[P[i]];
        while(state[pos].edge[p]==NIL) pos=state[pos].fail;
        pos=state[pos].edge[p];
        freq[state[pos].head]++;
//        show2(pos, state[pos].head);
    }
}

void doMapping(int *N){
    int i=0;
    for(char c='a';c<='z';c++) N[c]=i, i++;
    for(char c='A';c<='Z';c++) N[c]=i, i++;
    for(char c='0';c<='9';c++) N[c]=i, i++;
    N['-']=i++;
}
int res[501];
int main(){
    t_size=1;    // it already contains root
    int num[200];
    memset(num,-1,sizeof num);
    doMapping(num);
    int W; si1(W);
    FOR(i,1,W+1){
        char str[5001];
        scanf("%s",str);
        addWord(i,str,num);
    }
//    show1("input taken");
    makeFailureFunction();
//    show1("failure function made");
    int N;
    si1(N);
    FOR(i,0,N){
        char lyric[50001];
        scanf("%s",lyric);
        doMatching(lyric,num);
    }
    FOR(i,1,node_sz+1){
        if(freq[i]){
//            show4(freq[i], list[i].val, list[i].next, list[list[i].next].val);
            for(int ptr=i; ptr!=NIL; ptr=list[ptr].next){
                res[list[ptr].val]+=freq[i];
            }
        }
    }
    FOR(i,1,W+1){
        printf("%d\n",res[i]);
    }
    return 0;
}
