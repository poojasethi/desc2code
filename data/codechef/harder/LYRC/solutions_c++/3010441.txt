#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

#define maxW 501
#define maxP 5001
#define maxS 50001
#define maxN 101
#define maxNodes maxW*maxP

int AC[maxNodes][66];
int tail[maxW], pos = 1;
int fail[maxNodes];
int cnt[maxNodes];

char text[maxS];
int inDeg[maxNodes];

int w, n;

// assigning a unique number to each of the alphabet
inline int Id(char c)
{
    if (c>='a' && c<='z')         return c - 'a';
    else if (c>='A' && c<='Z')    return c - 'A' + 26; 
    else if (c>='0' && c<='9')    return c - '0' + 52;
    else                          return 62;     
}

// insert a new pattern into the AC trie, which we should
// convert into an automata in the future
int insert(char *s)
{
    // acp is the current node which we are at in the AC tree
    int acp = 0, cid;
    int slen = strlen(s);
    
    for (int i=0 ; i<slen ; i++)
    {
        cid = Id(s[i]);
        if (AC[acp][cid] == -1)
        {
            AC[acp][cid] = pos++;
            for (int j=0 ; j<66 ; j++)
                AC[pos][j] = -1;             
        }     
        acp = AC[acp][cid];
    }    
    return acp;
}

void init()
{
    fail[0] = 0;
    inDeg[0] = 1;
    
    for (int i=0 ; i<66 ; i++)
    {
        if (AC[0][i] != -1)
        {
            fail[AC[0][i]] = 0;
            ++inDeg[0];             
        }   
        else
        {
            AC[0][i] = 0;    
        } 
    }     
}

void makeTransitions()
{
    queue<int> Q;
    
    init();
    for (int i=0 ; i<66 ; i++)
    {
        if (AC[0][i]>0)
            Q.push(AC[0][i]);    
    }     
    
    while (!Q.empty())
    {
        int cur = Q.front();
        Q.pop();
        
        for (int i=0 ; i<66 ; i++)
        {
            if (AC[cur][i] > 0)
            {
                fail[AC[cur][i]] = AC[fail[cur]][i];
                ++inDeg[AC[fail[cur]][i]];
                
                Q.push(AC[cur][i]);               
            }   
            else
            {
                AC[cur][i] = AC[fail[cur]][i];    
            }    
        }      
    }
}

char s[maxP];

int main()
{
    memset(AC, -1, sizeof AC);
    scanf("%d", &w);
    for (int i=0 ; i<66 ; i++)
    {
        AC[0][i] = -1;   
    }    
    
    for (int i=0 ; i<w ; i++)
    {
        scanf("%s", s);
        tail[i] = insert(s);    
    }
    
    makeTransitions();
    
    scanf("%d", &n);
    for (int i=0 ; i<n ; i++)
    {
        scanf("%s", text);
        int tlen = strlen(text);
        int cur = 0;
        
        for (int j=0 ; j<tlen ; j++)
        {
            cur = AC[cur][Id(text[j])];
            ++cnt[cur];
        }    
    }
    
    queue<int> Q;
    for (int i=0 ; i<pos+1 ; i++)
        if (inDeg[i] == 0)
            Q.push(i);    

    while (!Q.empty())
    {
        int tmp = Q.front();
        Q.pop();
        
        if (tmp == 0)  break;
        
        --inDeg[fail[tmp]];
        
        cnt[fail[tmp]] += cnt[tmp];
        
        if (inDeg[fail[tmp]] == 0)
        {
            Q.push(fail[tmp]);                     
        }     
    }
    
    for (int i=0 ; i<w ; i++)
    {
        printf("%d\n", cnt[tail[i]]);    
    }
    
    //int k;
    //scanf("%d", &k);
    return 0;
}
