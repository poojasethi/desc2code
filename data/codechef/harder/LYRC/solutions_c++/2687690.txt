#define NDEBUG
#include <bits/stdc++.h>
#define rep(x,n) for(int x=0;x<int(n);++x)
#define print(x) cout<<x<<endl
#define dbg(x) cerr<<#x<<" = "<<x<<endl
#define pv(x,y) {for(typeof(y) z=(x);z!=(y);z++)cerr<<*z<<" ";cerr<<endl;}
#define _ <<" , "<<
#define mp make_pair
#define x first
#define y second
using namespace std;
typedef pair<int,int> pt;

// be lucky pretty please!
const int maxn=50000*100+47;

namespace ANUNCIE_AQUI {
  bool k_cmp(int a1, int b1, int a2, int b2, int a3 = 0, int b3 = 0) {
    return a1 != b1 ? a1 < b1 : (a2 != b2 ? a2 < b2 : a3 < b3);
  }
  int bucket[maxn+1], tmp[maxn];
  template<class T> void k_radix(T keys, int *in, int *out, int off, int n, int k) {
    memset(bucket, 0, sizeof(int) * (k+1));
    for(int j = 0; j < n; j++)
      bucket[keys[in[j]+off]]++;
    for(int j = 0, sum = 0; j <= k; j++)
      sum += bucket[j], bucket[j] = sum - bucket[j];
    for(int j = 0; j < n; j++)
      out[bucket[keys[in[j]+off]]++] = in[j];
  }
  int mod0[maxn/3+1];
  vector<int> k_rec(const vector<int>& v, int k) {
    int n = v.size()-3, sz = (n+2)/3, sz2 = sz + n/3;
    if(n < 2) return vector<int>(n);
    vector<int> sub(sz2+3);
    for(int i = 1, j = 0; j < sz2; i += i%3, j++)
      sub[j] = i;
    k_radix(v.begin(), &sub[0], tmp, 2, sz2, k);
    k_radix(v.begin(), tmp, &sub[0], 1, sz2, k);
    k_radix(v.begin(), &sub[0], tmp, 0, sz2, k);
    int last[3] = {-1, -1, -1}, unique = 0;
    for(int i = 0; i < sz2; i++) {
      bool diff = false;
      for(int j = 0; j < 3; last[j] = v[tmp[i]+j], j++)
        diff |= last[j] != v[tmp[i]+j];
      unique += diff;
      if(tmp[i]%3 == 1) sub[tmp[i]/3] = unique;
      else sub[tmp[i]/3 + sz] = unique;
    }
    vector<int> rec;
    if(unique < sz2) {
      rec = k_rec(sub, unique);
      rec.resize(sz2+sz);
      for(int i = 0; i < sz2; i++) sub[rec[i]] = i+1;
    } else {
      rec.resize(sz2+sz);
      for(int i = 0; i < sz2; i++) rec[sub[i]-1] = i;
    }
    for(int i = 0, j = 0; j < sz; i++)
      if(rec[i] < sz) tmp[j++] = 3*rec[i];
    k_radix(v.begin(), tmp, mod0, 0, sz, k);
    for(int i = 0; i < sz2; i++)
      rec[i] = rec[i] < sz ? 3*rec[i] + 1 : 3*(rec[i] - sz) + 2;
    int prec = sz2-1, pmod0 = sz-1, pret = sz2+sz-1;
    while(prec >= 0 && pmod0 >= 0)
      if(rec[prec]%3 == 1 && k_cmp(v[mod0[pmod0]], v[rec[prec]],sub[mod0[pmod0]/3], sub[rec[prec]/3+sz]) || rec[prec]%3 == 2 && k_cmp(v[mod0[pmod0]], v[rec[prec]], v[mod0[pmod0]+1], v[rec[prec]+1], sub[mod0[pmod0]/3+sz], sub[rec[prec]/3+1])) rec[pret--] = rec[prec--];
      else
        rec[pret--] = mod0[pmod0--];
    if(pmod0 >= 0) memcpy(&rec[0], mod0, sizeof(int) * (pmod0+1));
    if(n%3==1) rec.erase(rec.begin());
    return rec;
  }
  vector<int> karkkainen(string s) {
    int n = s.size(), cnt = 1;
    vector<int> v(n + 3);
    for(int i = 0; i < n; i++) v[i] = i;
    k_radix(s.begin(), &v[0], tmp, 0, n, 256);
    for(int i = 0; i < n; cnt += (i+1 < n && s[tmp[i+1]] != s[tmp[i]]), i++)
      v[tmp[i]] = cnt;
    return k_rec(v, cnt);
  }
  vector<int> lcp(const string& s, const vector<int>& sa) {
    int n = sa.size();
    vector<int> prm(n), ans(n-1);
    for(int i = 0; i < n; i++) prm[sa[i]] = i;
    for(int h = 0, i = 0; i < n; i++)
      if(prm[i]) {
        int j = sa[prm[i]-1], ij = max(i, j);
        while(ij + h < n && s[i+h] == s[j+h]) h++;
        ans[prm[i]-1] = h;
        if(h) h--;
      }
    return ans;
  }
}

unsigned int n;
string s;
vector<int> suffix, lcp;

void doit() {
  n = s.size();
  suffix = ANUNCIE_AQUI::karkkainen(s);
  lcp = ANUNCIE_AQUI::lcp(s,suffix);
}

int pos;

// restart by setting pos=0
int findl(string p) {
  while(pos < suffix.size() and s[suffix[pos]] < p[0]) {
    ++pos;
  }
  if(pos >= suffix.size() or s[suffix[pos]] > p[0]) {
    return -1; // not found
  }
  int have = 1;
  while(have < p.size()) {
    int nxt = suffix[pos]+have >= n ? 0 : s[suffix[pos]+have];
    if(nxt < p[have]) {
      // check if we are keeping the prefix for pos+1
      if(pos+1 < suffix.size() and lcp[pos] >= have) {
        ++pos;
      } else {
        return -1; // not found
      }
    } else if(nxt == p[have]) {
      ++have; // letter was found
    } else {
      assert(nxt > p[have]);
      return -1; // not found
    }
  }
  return pos;
}

// restart by second pos=suffix.size()-1
int findr(string p) {
  while(pos >= 0 and s[suffix[pos]] > p[0]) {
    --pos;
  }
  if(pos < 0 or s[suffix[pos]] < p[0]) {
    return -2; // not found
  }
  int have = 1;
  while(have < p.size()) {
    int nxt = suffix[pos]+have >= n ? 0 : s[suffix[pos]+have];
    if(nxt > p[have]) {
      // check if we are keeping the prefix for pos-1
      if(pos-1 >= 0 and lcp[pos-1] >= have) {
        --pos;
      } else {
        return -2; // not found
      }
    } else if(nxt == p[have]) {
      ++have; // letter was found
    } else {
      assert(nxt < p[have]);
      return -2; // not found
    }
  }
  return pos;
}

vector< pair<string,int> > pattern, v1, v2;
int l[555], r[555], ans[555];

bool is(string a, string b) {
  return a.size() > b.size() and a.substr(0,b.size()) == b;
}

bool comp1(pair<string,int> a, pair<string,int> b) {
  if(is(a.first,b.first)) return false;
  if(is(b.first,a.first)) return true;
  return a<b;
}

bool comp2(pair<string,int> a, pair<string,int> b) {
  if(is(a.first,b.first)) return false;
  if(is(b.first,a.first)) return true;
  return a>b;
}

void go(int np,string buf) {
  s=buf;
  doit();
  // findl
  pos=0;
  for(int i=0;i<np;++i) {
    string p=v1[i].first;
    l[v1[i].second]=findl(p);
  }
  // findr
  pos=suffix.size()-1;
  for(int i=0;i<np;++i) {
    string p=v2[i].first;
    r[v2[i].second]=findr(p);
  }
  rep(i,np) if(l[i]<=r[i]) ans[i] += r[i]-l[i]+1;
}

int main() {
  cin.sync_with_stdio(false);
  int np;
  cin>>np;
  pattern.resize(np);
  rep(i,np) cin>>pattern[i].first, pattern[i].second=i;
  v1=v2=pattern;
  sort(v1.begin(),v1.end(),comp1);
  sort(v2.begin(),v2.end(),comp2);
  int ns;
  cin>>ns;
  string buf;
  const int Z=50000*4;
  rep(i,ns) {
    string tmp;
    cin>>tmp;
    buf = buf + char('a'-1) + tmp;
    
    if(buf.size() >= Z) {
      go(np,buf);
      buf="";
    }
  }
  
  if(buf.size()) go(np,buf);
  
  rep(i,np) printf("%d\n",ans[i]);
  return 0;
}