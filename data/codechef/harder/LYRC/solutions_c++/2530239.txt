#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef long long ll;
#define sz(a) int((a).size())
#define pb push_back
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define mp make_pair
#define go(i,n) for(int i=0;i<n;i++)
#define go3(i,j,n) for(int i=j;i<n;i++)
 
const int K = 64;
const int NMAX = 2500010;
int finder[505];
 
struct vertex {
  int next[K];
  int p;
  char pch;
  int link;
  int go[K];
  int leafs;
  ll seen;
  int len;
};
 
vertex t[NMAX+1];
int sz;
 
int code(char c){
 
	if(c>='a') return c-'a';
	if(c>='A') return c-'A' + 26;
	if(c>='0') return c-'0'+52;
	if(c == '-') return 62;
	if(c == '+') return 63;
}
void init() {
	t[0].p = t[0].link = -1;
	memset (t[0].next, 255, sizeof t[0].next);
	memset (t[0].go, 255, sizeof t[0].go);
	t[0].len = 0;
	sz = 1;
}
 
void add_string (const string & s,int id) {
	int v = 0;
	for (size_t i=0; i<s.length(); ++i) {
	char c = code(s[i]);
	if (t[v].next[c] == -1) {
	memset (t[sz].next, 255, sizeof t[sz].next);
	memset (t[sz].go, 255, sizeof t[sz].go);
	t[sz].link = -1;
	t[sz].p = v;
	t[sz].pch = c;
	 
	t[sz].len = t[v].len+1;
	t[v].next[c] = sz++;
	}
	v = t[v].next[c];
	}
	t[v].leafs++;
	finder[id] = v;
}
int proceed (int v, char c);
	int get_link (int v) {
	if (t[v].link == -1)
	if (v == 0 || t[v].p == 0)
	t[v].link = 0;
	else
	t[v].link = proceed (get_link (t[v].p), t[v].pch);
	return t[v].link;
	}
	int proceed (int v, char c) {
	if (t[v].go[c] == -1)
	if (t[v].next[c] != -1)
	t[v].go[c] = t[v].next[c];
	else
	t[v].go[c] = v==0 ? 0 : proceed (get_link (v), c);
	return t[v].go[c];
}
 
/*int used[5000000] ;
 
void dfs(int v=0){
	used[v] = 1;
	printf("v=%d len=%d\n",v,t[v].len);
	go(i,K)
	if(t[v].next[i]!=-1 && !used[t[v].next[i]])
	{
	printf("next by %d\n",i);
	dfs(t[v].next[i]);
	}
} */
 
void work(int v = 0){
	//used[v] = 1;
	go(i,K)
	if(t[v].next[i]!=-1)
	work(t[v].next[i]);
	 
	t[get_link(v)].seen += t[v].seen;
 
}
 
pair<int,int> sr[5000005];
 
void oku(){

	init();
	int n,m;
	string s;
	 
	cin>>n;
	 
	go(i,n){
	cin>>s;
	add_string(s,i);
	}
 
	cin>>m;
	 
	string w="";
	 
	go(i,m){
	cin>>s;
	w+=s+"+";
	}
	 
	int v = 0;
	go(i,sz(w)){
	v = proceed(v,code(w[i]));
	//cout<<v<<endl;
	//printf("(%d)t[%d].seen++\n",t[v].seen,v);
	t[v].seen++;
	}

	/*go(i,sz) 
	 cout<<i<<" "<<t[i].link<<endl;
	 cout<<"-----"<<endl;
	*/
	//go(i,sz)
	 //cout<<i<<" "<<t[i].seen<<endl;
	//dfs();
	//work();
	go(i,sz) sr[i] = mp(t[i].len,i);
	sort(sr,sr+sz);
	reverse(sr,sr+sz);
	 
	go(i,sz)
	{
	//cout<<sr[i].second<<" "<<t[sr[i].second].len<<endl;
	v = sr[i].second;
	//printf("t[%d].seen(%I64d) += t[%d].seen(%I64d)\n",get_link(v),t[get_link(v)].seen,v,t[v].seen);
	t[get_link(v)].seen += t[v].seen;
	}
	 
	 
	go(i,n){
	cout<<t[finder[i]].seen<<endl;
	}
 
}
 
int main(){
#ifndef ONLINE_JUDGE
  //freopen("in","r",stdin);
#endif
 
oku();
 
return 0;} 