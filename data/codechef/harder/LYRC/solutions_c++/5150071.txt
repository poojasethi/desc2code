// Task-ID: 1548
#include <algorithm>
#include <iostream>
#include <cstring>
#include <complex>
#include <cassert>
#include <cstdlib>
#include <cstdio>
#include <bitset>
#include <vector>
#include <string>
#include <cmath>
#include <ctime>
#include <queue>
#include <list>
#include <map>
#include <set>

#define all(x) (x).begin(), (x).end()
#define type(x) __typeof((x).begin())
#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); it++)

#ifdef KAZAR
    #define eprintf(...) fprintf(stderr,__VA_ARGS__)
#else
    #define eprintf(...) 0
#endif

using namespace std;

template<class T> inline void umax(T &a,T b){if(a<b) a = b ; }
template<class T> inline void umin(T &a,T b){if(a>b) a = b ; }
template<class T> inline T abs(T a){return a>0 ? a : -a;}
template<class T> inline T gcd(T a,T b){return __gcd(a, b);}
template<class T> inline T lcm(T a,T b){return a/gcd(a,b)*b;}

const int inf = 1e9 + 143;
const long long longinf = 1e18 + 143;

inline int read(){int x;scanf(" %d",&x);return x;}

const int N = 510 * 5100;

int sz = 0;
int next[N][63];
int fail[N];
int par[N];
int parc[N];
int cnt[N];

int loc[N];

char foo[N];
int what[1024];

int get_val(char x){
    return what[x];
}

int main(){

#ifdef KAZAR
    freopen("f.input","r",stdin);
    freopen("f.output","w",stdout);
    freopen("error","w",stderr);
#endif

    int alp = 0;
    for(int i = 'a'; i <= 'z'; i++) what[i] = alp++;
    for(int i = 'A'; i <= 'Z'; i++) what[i] = alp++;
    for(int i = '0'; i <= '9'; i++) what[i] = alp++;
    what['-'] = alp++;

    int n = read();

    for(int i = 1; i <= n; i++){
        scanf(" %s", foo);
        int len = strlen(foo);
        int u = 0;
        for(int j = 0; j < len; j++){
            int need = get_val(foo[j]);
            int &nx = next[u][need];
            if(!nx){
                nx = ++sz;
                par[nx] = u;
                parc[nx] = need;
            }
            u = nx;
        }
        loc[i] = u;
    }

    queue<int> q;
    q.push(0);
    vector<int> bfs_order;
    while(!q.empty()){
        int u = q.front();q.pop();
        bfs_order.push_back(u);
        for(int c = 0; c < alp; c++){
            if(next[u][c])
                q.push(next[u][c]);
        }
        if(u == 0 || par[u] == 0) continue;
        int ch = parc[u];
        fail[u] = fail[par[u]];
        while(fail[u] > 0 && !next[fail[u]][ch])
            fail[u] = fail[fail[u]];
        fail[u] = next[fail[u]][ch];
    }

    int m = read();

    for(int i = 1; i <= m; i++){
        scanf(" %s", foo);
        int len = strlen(foo);
        int u = 0;
        for(int j = 0; j < len; j++){
            int need = get_val(foo[j]);
            while(u > 0 && !next[u][need])
                u = fail[u];
            if(next[u][need])
                u = next[u][need];
            cnt[u]++;
        }
    }

    assert(bfs_order.size() == sz + 1);
    for(int i = sz; i >= 0; i--){
        int u = bfs_order[i];
        cnt[fail[u]] += cnt[u];
    }

    for(int i = 1; i <= n; i++)
        printf("%d\n",cnt[loc[i]]);

    return 0;
}
