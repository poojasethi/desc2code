/* Pranet Verma */
/* Yeh mera template hai. Apna khud banao =_= */
#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
#define mp make_pair
#define s(n) scanf("%d",&n)
#define s2(n,m) scanf("%d%d",&n,&m)
#define s3(n,m,l) scanf("%d%d%d",&n,&m,&l)
#define s4(n,m,l,x) scanf("%d%d%d%d",&n,&m,&l,&x)
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); }
const int mod=1000000007;

const int MAXN=5000*500+500;
char words[500][5001];
vector<int> wordEnd[MAXN];
int cnt[MAXN];
int links[MAXN];
int inDegree[MAXN];
map<char,int> trie[MAXN];
int sz=1;
void add(char s[],int n,int id)
{
    int r=0;
    for(int i=0;i<n;++i)
    {
        char c=s[i];
        if(trie[r][c]==0)
            trie[r][c]=sz++;
        r=trie[r][c];
    }
    wordEnd[r].push_back(id);
}

void makeLinks()
{
    queue<int> Q;
    Q.push(0);
    while(!Q.empty())
    {
        int u=Q.front();
        Q.pop();
        if(u==0)
        {
            for(map<char,int>::iterator i=trie[u].begin();i!=trie[u].end();++i)
                {
                    links[i->second]=0;
                    ++inDegree[0];
                    Q.push(i->second);
                }
            continue;
        }

        for(map<char,int>::iterator i=trie[u].begin();i!=trie[u].end();++i)
        {
            char c=i->first;
            int r=links[u];
            while(r>0 && trie[r].find(c)==trie[r].end())
                r=links[r];
            if(trie[r].find(c)==trie[r].end())
                r=0;
            else
                r=trie[r][c];
            ++inDegree[r];
            links[i->second]=r;
            Q.push(i->second);
        }
    }
}
char s[50001];
int ans[501];
int main()
{
    std::ios::sync_with_stdio(false);
    int n;
    s(n);
    for(int i=0;i<n;++i)
        {
            scanf("%s",words[i]);
            add(words[i],strlen(words[i]),i);
        }
    makeLinks();

    int m;
    s(m);

    for(int c=0;c<m;++c)
    {
        int r=0;        
        scanf("%s",s);
        int n=strlen(s);
        for(int i=0;i<n;++i)
        {
            char c=s[i];
            while(r>0 && trie[r].find(c)==trie[r].end())
                r=links[r];
            if(trie[r].find(c)==trie[r].end())
                r=0;
            else
                r=trie[r][c];
            ++cnt[r];
        }
    }
    
        
    queue<int> Q;
    for(int i=0;i<sz;++i)
    {
        if(inDegree[i]==0)
            Q.push(i);
    }
    while(!Q.empty())
    {
        int u=Q.front();
        Q.pop();
        if(u==0)
            break;
        int v=links[u];
        cnt[v]+=cnt[u];
        --inDegree[v];
        assert(inDegree[v]>=0);
        if(inDegree[v]==0)
            Q.push(v);
    }

    for(int i=0;i<sz;++i)
    {
        for(int j=0;j<wordEnd[i].size();++j)
        {
            int u=wordEnd[i][j];
            ans[u]=cnt[i];
        }
    }

    for(int i=0;i<n;++i)
        printf("%d\n",ans[i]);
}