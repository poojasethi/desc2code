#include <algorithm>
#include <iostream>
#include <sstream>
#include <memory>
#include <vector>
#include <string>
#include <bitset>
#include <queue>
#include <stack>
#include <list>
#include <set>
#include <map>
#include <climits>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <ctime>
#define sz(a) ((int)(a).size())
#define foreach(i, Type, v) for(Type::iterator i=v.begin(); i!=v.end(); i++)
using namespace std;
typedef long long llong;
typedef pair<int, int> Item;

const int Maxn = 50000+10;
const int INF = 0x7f7f7f7f;
const int MOD = 1000000007;
const double eps = 1e-10;
const double pi = acos(-1.0);
inline int compareTo(double a, double b) { return (a>b+eps) ? 1 : ((a+eps<b)?-1:0); }

int ans[510];
char str[Maxn];

int num;
const int Tot = 63;
class Trie
{
public:
    int id;   // 字符串标号
    int cnt;  // 字符串数量
    Trie *fail, *next[Tot];
    int idx(char ch)
    {
    	if( isdigit(ch) )
    		return ch-'0';
    	else if( islower(ch) )
    		return ch-'a'+10;
    	else if( isupper(ch) )
    		return ch-'A'+36;
    	else
    		return 62;
    }
    Trie()
	{
        id = cnt = 0;
        fail = NULL;
        for(int i=0; i<Tot; i++)
        	next[i] = NULL;
    }
	void Insert(char *s);
	void acAuto();
	void query(char *s);
} *root;

map<Trie*, int> mp;
map<Trie*, int>::iterator ptr;

void Trie::Insert(char *s)
{
    Trie *p = root;
    while( *s )
    {
        int t = idx(*s);
        if( p->next[t] == NULL )
            p->next[t] = new Trie();
        p = p->next[t];
        s++;
    }
    p->cnt++;
    if( p->id == 0 )
		p->id = num++;
}
void Trie::acAuto()
{
    queue<Trie*> que;
    for(int i=0; i<Tot; i++)
        if( root->next[i] )
        {
            root->next[i]->fail = root;
            que.push(root->next[i]);
        }
    while( !que.empty() )
    {
        Trie* p = que.front();
        que.pop();
        for(int i=0; i<Tot; i++)
            if( p->next[i] )
            {
                Trie* tmp = p->fail;
                que.push(p->next[i]);
                while( tmp && tmp!=root && tmp->next[i]==NULL )
                    tmp = tmp->fail;
                if( tmp->next[i] )
                    p->next[i]->fail = tmp->next[i];
                else
                    p->next[i]->fail = root;
            }
    }
}
void Trie::query(char *s)
{
	Trie *p = root;
    while( *s )
    {
		int t = idx(*s);
		while( p && p!=root && p->next[t]==NULL )
			p = p->fail;
		if( p->next[t] )
			p = p->next[t];
		else
			p = root;
		Trie* tmp = p;
		if( tmp && tmp!=root )
			mp[tmp]++;
		s++;
	}
}

int main()
{
	int W, N;
	map<string, int> mp1;
	map<int, int> mp2;
    ios::sync_with_stdio(0);

    root = new Trie();

    scanf("%d", &W);
    for(int i=0; i<W; i++)
    {
    	scanf("%s", str);
    	if( mp1.find((string)str) == mp1.end() )
    	{
    		mp1[(string)str] = num;
    		root->Insert(str);
    	}
    	mp2[i] = mp1[(string)str];
    }
    root->acAuto();
    scanf("%d", &N);
    for(int i=0; i<N; i++)
    {
    	scanf("%s", str);
    	root->query(str);
    }

    for(ptr=mp.begin(); ptr!=mp.end(); ptr++)
    {
    	Trie* tmp = ptr->first;
    	while( tmp && tmp!=root )
    	{
    		if( tmp->cnt > 0 )
    			ans[tmp->id] += ptr->second;
    		tmp = tmp->fail;
    	}
    }
    for(int i=0; i<W; i++)
    	printf("%d\n", ans[mp2[i]]);

    return 0;
}
