#include <bits/stdc++.h>

using namespace std;

#define N 200005
#define FOR(i, a, b) for(int i = a; i < b; i++)
#define REP(i, n) FOR(i, 0, n)
#define ll long long

int n;
char s[N];

int rank[20][N], order[N], neworder[N], it;
int cnt[N], val[N];
int pw[20];

int cmp(int i, int j)
{
    return s[i] < s[j];
}
inline void sa()
{
    REP(i, n) rank[0][i] = s[i]-'a';
    for(it = 0; pw[it] <= n; it++)
    {
        REP(i, n) val[i] = i+pw[it] >= n ? 0 : rank[it][i+pw[it]] + 1;
        REP(i, n+1) cnt[i] = 0;
        REP(i, n) cnt[val[i]+1]++;
        REP(i, n+1) cnt[i] += cnt[i-1];
        REP(i, n) neworder[cnt[val[i]]++] = i;
        REP(i, n) cnt[i] = 0;
        REP(i, n) cnt[rank[it][i]+1]++;
        REP(i, n) cnt[i] += cnt[i-1];
        REP(i, n) order[cnt[rank[it][neworder[i]]]++] = neworder[i];
        int r = -1;
        REP(i, n)
        {
            if(i == 0 or rank[it][order[i]] != rank[it][order[i-1]] or val[order[i]] != val[order[i-1]]) r++;
            rank[it+1][order[i]] = r;
        }
    }
}

inline int lcp(int x, int y)
{
    int ret = 0;
    for(int i = it; i >= 0; i--) if(x + pw[i] - 1 < n and y + pw[i] - 1 < n and rank[i][x] == rank[i][y])
    {
        x += pw[i];
        y += pw[i];
        ret += pw[i];
    }
    return ret;
}

int par[N], sz[N];
int temp[N], tempn;
inline int root(int x)
{
    tempn = 0;
    while(x != par[x]) temp[tempn++] = x, x = par[x];
    REP(i, tempn) par[temp[i]] = x;
    return x;
}
ll ans[N], curh;
inline void merge(int u, int v)
{
    u = root(u);
    v = root(v);
    if(sz[v] > sz[u]) swap(u, v);
    ans[sz[u]+1] -= (sz[u]+1)*curh;
    ans[sz[v]+1] -= (sz[v]+1)*curh;
    par[v] = u;
    sz[u] += sz[v];
    ans[sz[u]+1] += (sz[u]+1)*curh;
}

int l[N], z[N];
bool done[N];

int cmp2(int i, int j)
{
    return l[i] > l[j];
}
inline void ko()
{
    REP(i, n-1) l[i] = lcp(order[i], order[i+1]);
    l[n-1] = 0;
    REP(i, n) done[i] = 0, ans[i+1] = 0;
    REP(i, n) z[i] = i;
    sort(z, z+n, cmp2);
    REP(i, n) par[i] = i, sz[i] = 1;
    REP(i, n)
    {
        curh = l[z[i]];
        ans[2] += 2*curh;
        if(z[i] > 0 and done[z[i]-1]) merge(z[i], z[i]-1);
        if(z[i] < n-1 and done[z[i]+1]) merge(z[i], z[i]+1);
        done[z[i]] = 1;
    }
    REP(i, n)
    {
        int sub = l[i];
        if(i > 0) sub = max(sub, l[i-1]);
        ans[1] += max(0, n-order[i] - sub);
    }
    for(int i = n-1; i >= 1; i--) ans[i] += ans[i+1];
}

int main()
{
    REP(i, 20) pw[i] = 1<<i;
    int t; scanf("%d\n", &t);
    while(t--)
    {
        gets(s);
        n = strlen(s);
        sa();
        ko();
        int q; scanf("%d\n", &q);
        while(q--)
        {
            int x; scanf("%d\n", &x);
            printf("%lld\n", ans[x]);
        }
    }
    return 0;
}