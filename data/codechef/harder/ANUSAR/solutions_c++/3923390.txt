#pragma comment(linker, "/STACK:67108864")

#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<ctype.h>
#include<assert.h>
#include<iostream>
#include<vector>
#include<stack>
#include<queue>
#include<set>
#include<map>
#include<string>
#include<utility>
#include<algorithm>
#include<list>
using namespace std;

#define CLR(a) memset(a,0,sizeof(a))
#define SET(a) memset(a,-1,sizeof(a))
#define pb push_back
#define SZ(a) ((Long)a.size())
#define ALL(a) a.begin(),a.end()
#define FOREACH(i, c) for( __typeof( (c).begin() ) i = (c).begin(); i != (c).end(); ++i )
#define AREA2(x1,y1,x2,y2,x3,y3) ( x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2) )
#define SQR(x) ((x)*(x))
#define STR string
#define IT iterator
#define ff first
#define ss second
#define MP make_pair
#define EPS 1e-9
#define INF 1000000007

#define chk(a,k) ((bool)(a&(1<<(k))))
#define set0(a,k) (a&(~(1<<(k))))
#define set1(a,k) (a|(1<<(k)))

typedef long long Long;
typedef vector<long> Vl;
typedef vector<Long> VL;
typedef pair<long,long> Pll;
typedef pair<Long,Long> PLL;

inline Long FastMax(Long x, Long y) { return (((y-x)>>(32-1))&(x^y))^y; }
inline Long FastMin(Long x, Long y) { return (((y-x)>>(32-1))&(x^y))^x; }

#define MAX 100007
#define MAXN 200007
#define MAXLG 22

char S[2*MAXN];
Long Q,N,lj,ljj;
Long Ord[MAXLG][2*MAXN],t[2*MAXN][2];
Long A[2*MAXN], B[2*MAXN], C[2*MAXN], D[2*MAXN],Id[MAXN];

void tmp_CLR( Long *v, Long lim )
{
    Long i;
    lim = max( lim,301LL );
    for( i=0;i<=lim;i++ ) v[i] = 0;
}

void Build( void ){
    Long i,j,k,jj;
    //CLR( t );CLR( A );CLR( B );//CLR( C );//CLR( D );
    tmp_CLR( A, N );tmp_CLR( B, N );
    tmp_CLR( C, N );tmp_CLR( D, N );
    for (i = 0; i < N; ++i) A[(Long)S[i]] = 1;
    for (i = 1; i < max( N,301LL ); ++i) A[i] += A[i-1];
    for (i = 0; i < N; ++i) Ord[0][i] = A[(Long)S[i]];
    for (j = 0, jj = 1, k = 0; jj < N ; ++j, jj <<= 1){
        //memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B));
        tmp_CLR( A, 2*N+7 );tmp_CLR( B, 2*N+7 );
        for (i = 0; i < N; ++i){
            ++A[ t[i][0] = Ord[j][i] ], ++B[ t[i][1] = (i+jj<N) ? Ord[j][i+jj] : 0 ];
        }
        for (i = 1; i <= N; ++i) A[i] += A[i-1], B[i] += B[i-1];
        for (i = N-1; i >= 0; --i) C[--B[t[i][1]]] = i;
        for (i = N-1; i >= 0; --i) D[--A[t[C[i]][0]]] = C[i];
        Ord[j+1][D[0]] = k = 1;
        for (i = 1; i < N; ++i){
            Ord[j+1][D[i]] = (k += (t[D[i]][0] != t[D[i-1]][0] || t[D[i]][1] != t[D[i-1]][1]));
        }
    }
    lj = j; ljj = jj;
    for( i=0;i<N;i++ ) Id[Ord[lj][i]] = i;
}
Long Lcp( Long x, Long y ){
    Long k,j,jj, prf = 0;
    for (j = lj, jj = ljj; j >= 0; --j, jj >>= 1)
        if (x<N && y<N && Ord[j][x] == Ord[j][y]){
            x   += jj; y   += jj; prf += jj;
        }
    return prf;
}

Long par[MAXN+7];
Long child[MAXN+7];
vector<Long> adj[MAXN+7];
Long freq[MAXN+7];
Long last[MAXN+7];

Long Find( Long u )
{
    if( par[u]==u ) return u;
    else return par[u] = Find( par[u] );
}

void Union( Long u,Long v, Long i )
{
    u = Find( u );
    v = Find( v );
    if( u==v ) return;
    freq[child[u]] -= i*last[u];
    freq[child[v]] -= i*last[v];
    last[u] = last[v] = 0;
    par[u] = v;
    child[v] += child[u];
}

int main( void )
{
    Long i,j,v,Icase,k = 0;

    //freopen("text1.txt","r",stdin );

    scanf("%lld",&Icase );
    while( Icase-- ){
        scanf("%s",S );
        N = strlen( S );
        Build();
        for( i=2;i<=N;i++ ){
            adj[Lcp( Id[i-1],Id[i] )].pb( i );
        }
        for( i=0;i<=N;i++ ){
            par[i] = i;
            child[i] = 1;
            last[i] = 0;
        }
        for( i=N;i>=1;i-- ){
            vector<Long> st;
            for( j=0;j<adj[i].size();j++ ){
                k = adj[i][j];
                Union( Id[k-1], Id[k], i );
                st.pb( Find( Id[k] ) );
            }
            for( j=0;j<st.size();j++ ){
                st[j] = Find( st[j] );
            }
            sort( ALL( st ) );
            st.resize( unique( ALL( st ) ) - st.begin() );
            for( j=0;j<st.size();j++ ){
                last[st[j]] = child[st[j]];
                freq[child[st[j]]] += child[st[j]]*i;
            }
        }
        freq[1] = (N*(N+1))/2;
        for( i=N;i>=2;i-- ){
            freq[i] += freq[i+1];
        }
        scanf("%lld",&Q );
        while( Q-- ){
            scanf("%lld",&v );
            printf("%lld\n",freq[v] );
        }
        for( i=0;i<=2*N+1;i++ ){
            adj[i].clear();
            freq[i] = 0;
        }
    }

    return 0;
}



