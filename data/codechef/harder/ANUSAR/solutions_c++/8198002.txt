#include <bits/stdc++.h>
using namespace std;
template <class T> int size(const T &x) { return x.size(); }
#define rep(i,a,b) for (__typeof(a) i=(a); i<(b); ++i)
#define iter(it,c) for (__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)
typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<ii> vii;
typedef long long ll;
const int INF = 2147483647;

const double EPS = 1e-9;
typedef unsigned long long ull;
typedef vector<vi> vvi;
typedef vector<vii> vvii;
template <class T> T mod(T a, T b) { return (a % b + b) % b; }

const int MAXLEN = 201000;

struct suffix_automaton {
    int *len,
        *link,
        *occur;
    ll *occuratleast;
    bool *isclone;
    map<char,int> *next;
    ll *cnt;
    int sz, last;

    suffix_automaton(){
        len = new int[MAXLEN*2];
        link = new int[MAXLEN*2];
        cnt = new ll[MAXLEN*2];
        isclone = new bool[MAXLEN*2];
        next = new map<char,int>[MAXLEN*2];
        occur = new int[MAXLEN*2];
        occuratleast = new ll[MAXLEN*2];
        sz = 0;
        clear();
    }

    void clear(){
        for(int i = 0; i < sz; ++i){
            next[i].clear();
        }
        sz = 0;
        last = 0;
        len[0] = 0;
        link[0] = -1;
        ++sz;
    }

    void extend(char c){
        int cur = sz++;
        len[cur] = len[last] + 1;
        isclone[cur] = false;
        int p = last;
        for(; p != -1 && !next[p].count(c); p = link[p]){
            next[p][c] = cur;
        }
        if(p == -1){
            link[cur] = 0;
        } else {
            int q = next[p][c];
            if(len[p] + 1 == len[q]){
                link[cur] = q;
            } else {
                int clone = sz++;
                len[clone] = len[p] + 1;
                next[clone] = next[q];
                link[clone] = link[q];
                isclone[clone] = true;
                for(; p != -1 && next[p].count(c) && next[p][c] == q; p = link[p]){
                    next[p][c] = clone;
                }
                link[q] = link[cur] = clone;
            }
        }
        last = cur;
    }
    ll count(){
        memset(cnt, -1, sizeof(ll)*sz);
        count(0);
        return --cnt[0];
    }

    ll count(int st){
        if(cnt[st] != -1) return cnt[st];
        cnt[st] = 1;
        for(map<char,int>::iterator i = next[st].begin(); i != next[st].end(); ++i){
            cnt[st] += count((*i).second);
        }
        return cnt[st];
    }

    string lexicok(ll k){
        int st = 0;
        string s;
        assert(k <= cnt[0]);
        while(k){
            for(map<char,int>::iterator i = next[st].begin(); i != next[st].end(); ++i){
                if(k <= cnt[(*i).second]){
                    st = (*i).second;
                    s.push_back((*i).first);
                    k--;
                    break;
                } else {
                    k -= cnt[(*i).second];
                }
            }
        }
        return s;
    }
    //struct lencmp{
        //bool operator()(int a, int b){
            //return len[a] < len[b];
        //}
    //};
    bool operator()(const int &a, const int &b){
        return len[a] < len[b];
    }

    void countoccur(){
        memset(occuratleast, 0, sizeof(ll)*sz);
        int *paths = new int[MAXLEN*2];
        memset(paths, 0, sizeof(int)*sz);
        for(int i = 0; i < sz; ++i){
            if(!isclone[i]){
                occur[i] = 1;
                //printf("%d is not clone\n", i);
            } else {
                occur[i] = 0;
            }
        }
        vi states(sz);
        for(int i = 0; i < sz; ++i){
            states[i] = i;
        }
        sort(states.rbegin(), states.rend(), *this);
        for(int i = 0; i < size(states); ++i){
            int v = states[i];
            //printf("v: %d\n", v);
            if(link[v] != -1) {
                //printf("blaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n");
                occur[link[v]] += occur[v];
                //printf("%d occurs %d\n", v, occur[v]);
            }
        }
        sort(states.begin(), states.end(), *this);
        paths[0] = 1;
        for(int i = 0; i < size(states); ++i){
            int v = states[i];
            for(map<char,int>::iterator j = next[v].begin(); j != next[v].end(); ++j){
                paths[(*j).second] += paths[v];
            }
        }
        for(int i = 1; i < sz; ++i){
            occuratleast[occur[i]] += (ll)occur[i]*paths[i];
            //printf("%d occurs %d with %d different\n", i, occur[i], paths[i]);
        }
        for(int i = sz - 1; i > 0; --i){
            occuratleast[i-1] += occuratleast[i];
        }
        delete[] paths;
    }
};

int main(){
    int T, K;
    cin >> T;
    scanf("%d\n", &T);
    char c;// = getchar_unlocked();
    suffix_automaton sa;
    for(int t = 0; t < T; ++t){
        //cin >> s;
        c = getchar_unlocked();
        while(c != '\n'){
            sa.extend(c);
            c = getchar_unlocked();
        }
        //for(int i = 0; i < size(s); ++i){
            //sa.extend(s[i]);
        //}
        sa.countoccur();
        cin >> K;
        for(int i = 0; i < K; ++i){
            int a;
            //cin >> a;
            scanf("%d\n", &a);
            printf("%lld\n", sa.occuratleast[a]);
            //cout << sa.occuratleast[a] << endl;
        }
        sa.clear();
    }
}
