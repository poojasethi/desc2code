#include <bits/stdc++.h>
using namespace std;

//Uzumaki Naruto :)
//#define TRACE

#ifdef TRACE
#define trace(a,n)    for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << endl;
#define dbg(args...) {debug,args; cerr<<endl;}
#define pause()      cin.get();cin.get();

#else
#define trace(a,n)
#define dbg(args...)
#define pause()

#endif

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int NN = 212345;

/* suffix array construction start */
int rnk[NN],pos[NN];
int nxt[NN],cnt[NN];
bool bh[NN],b2h[NN];
int height[NN];

string msg;
bool cmp(int i,int j){
    return (msg[i] < msg[j]);
}

void build_sa(int n){
    for(int i = 0; i < n; ++i)
        pos[i] = i;
    sort(pos,pos+n,cmp);
    for(int i = 0; i < n; ++i)
        bh[i] = (i == 0 or msg[pos[i]] != msg[pos[i-1]]), b2h[i] = false;

    for(int h = 1; h < n; h <<= 1){
        int buckets = 0;
        for(int i = 0, j; i < n; i = j){
            rnk[pos[i]] = i;
            cnt[i] = 0;
            for(j = i+1; j < n and !bh[j]; ++j)
                rnk[pos[j]] = i;
            nxt[i] = j;
            ++buckets;
        }

        if (buckets == n) break;

        ++cnt[rnk[n-h]];
        b2h[rnk[n-h]] = true;
        for(int i = 0; i < n; i = nxt[i]){
            for(int j = i; j < nxt[i]; ++j){
                int s = pos[j]-h;
                if (s < 0) continue;
                int head = rnk[s];
                rnk[s] = head + cnt[head]++;
                b2h[rnk[s]] = true;
            }

            for(int j = i; j < nxt[i]; ++j){
                int s = pos[j]-h;
                if (s < 0 or !b2h[rnk[s]]) continue;
                for(int k = rnk[s]+1; k < n and b2h[k] and !bh[k]; ++k)
                    b2h[k] = false;
            }
        }

        for(int i = 0; i < n; ++i)
            pos[rnk[i]] = i, bh[i] |= b2h[i];
    }

    for(int i = 0; i < n; ++i)
        rnk[pos[i]] = i;
}

void getHeight(int n){
    height[0] = 0;
    for(int i = 0, h = 0; i < n; ++i){
        if (rnk[i] <= 0) continue;
        int j = pos[rnk[i]-1];
        while(i+h < n and j+h < n and msg[i+h] == msg[j+h])
            ++h;
        height[rnk[i]] = h;
        h -= (h > 0);
    }
}
/* suffix array construction end */

int tree[NN];
void update(int i,int v,int n){
    for(i = i+1; i < n+5; i+= i&-i)
        tree[i] += v;
}

int query(int i){
    int sum = 0;
    for(i = i+1; i > 0; i-= i&-i)
        sum += tree[i];
    return sum;
}

vector<pii> rng[NN];
LL dp[NN];

void solve(){
    cin >> msg;
    int n = (int)msg.size();
    build_sa(n);
    getHeight(n);

    trace(pos,n);
    trace(height,n);
    for(int i = 0; i < n+5; ++i){
        dp[i] = tree[i] = 0;
        rng[i].clear();
    }

    stack<pii> ss;
    for(int i = 1; i < n; ++i){
        while(!ss.empty() and ss.top().first >= height[i]){
            int v = ss.top().first;
            ss.pop();
            if (v > height[i]){
                int p = (ss.empty() ? 1 : ss.top().second + 1);
                if (v) rng[v].push_back(make_pair(i-1,p));
            }
        }
        ss.push(make_pair(height[i],i));
    }

    while(!ss.empty()){
        int v = ss.top().first;
        ss.pop();
        int p = (ss.empty() ? 1 : ss.top().second + 1);
        if (v) rng[v].push_back(make_pair(n-1,p));
    }

    for(int i = 1; i < n; ++i){
        for(int j = 0; j < (int)rng[i].size(); ++j){
            int st = rng[i][j].second , en = rng[i][j].first;
            int q = query(st);
            int add = i-q;
            dp[en-st+2] += (LL)add*(LL)(en-st+2);
            update(st,add,n);
            update(en+1,-add,n);
            dbg("updating ",st," -> ",en," with value ",add," at ",i);
        }
    }

    for(int i = n; i >= 0; --i)
        dp[i] += dp[i+1];
    LL all = ((LL)n*(LL)(n+1))/2LL;

    dbg("all done");
    int m;
    cin >> m;
    for(int i = 0; i < m; ++i){
        int f; cin >> f;
        if (f <= 1) cout << all << "\n";
        else cout << dp[f] << "\n";
        dbg("input is ",f);
    }
}

int main()
{
    ios_base::sync_with_stdio(0);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}
