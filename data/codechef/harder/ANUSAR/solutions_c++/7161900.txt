#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

#define gc getchar_unlocked
int getint() { unsigned int c; int x = 0; while (((c = gc()) - '0') >= 10) { if (c == '-') return -getint(); if (!~c) exit(0); } do { x = (x << 3) + (x << 1) + (c - '0'); } while (((c = gc()) - '0') < 10); return x; }
int getstr(char *s) { int c, n = 0; while ((c = gc()) <= ' ') { if (!~c) exit(0); } do { s[n++] = c; } while ((c = gc()) > ' ' ); s[n] = 0; return n; }
template<class T> inline bool chmin(T &a, T b) { return a > b ? a = b, 1 : 0; }
template<class T> inline bool chmax(T &a, T b) { return a < b ? a = b, 1 : 0; }
#define pch putchar_unlocked
void putint(int n) { int i = 16, a[i]; if (n < 0) pch('-'); do { a[--i] = 48 + abs(n % 10); n /= 10; } while (n); while (i < 16) pch(a[i++]); }
void putll(ll n) { int i = 32, a[i]; if (n < 0) pch('-'); do { a[--i] = 48 + abs(n % 10); n /= 10; } while (n); while (i < 32) pch(a[i++]); }

typedef char C;
struct Node;
typedef Node *Nptr;
const int range_out = 1 << 28;

struct Node {
    int s, e;           // [s, e)
    Nptr lnk, lst, nxt; // failure link, last child, next sibling
    Node() { lnk = lst = nxt = 0; }

    Nptr getCh(int pos, const C *in) {
        for (Nptr p = lst; p; p = p->nxt) if (in[pos] == in[p->s]) return p;
        return 0;
    }
    void addCh(Nptr p) { p->nxt = lst, lst = p; }
    void changeCh(Nptr p, int pos, const C *in) {
        if (in[lst->s] == in[pos]) { p->nxt = lst->nxt, lst = p; return; }
        for (Nptr r = 0, q = lst; q; r = q, q = q->nxt) if (in[q->s] == in[pos]) {
            r->nxt = p, p->nxt = q->nxt;
            return;
        }
    }
};

const int MNODE =  400100;
int n_node = 0;
Node nodes[MNODE];

inline Nptr gen_node(int srt, int end) {
    Nptr p = nodes + n_node;
    p->s = srt, p->e = end, p->lnk = p->lst = p->nxt = 0;
    return nodes + n_node++;
}

inline int get_id(Nptr p) { return p - nodes; }

Nptr gen(const C in[], int n) {
    Nptr root = gen_node(-1, -1);
    int pos = -1, rem = 0, currE = 0, currL = 0;
    Nptr p = root, needSL = 0;
    for (int i = 0; i < n; i++) {
        pos++, needSL = 0, rem++;
        for (; rem; ) {
            if (currL == 0) currE = pos;
            Nptr q = p->getCh(currE, in);
            if (q == 0) {
                Nptr q1 = nodes + n_node++;
                q1->s = pos, q1->e = range_out;
                q1->lnk = q1->lst = 0;
                q1->nxt = p->lst;
                p->lst = q1;
                if (needSL) needSL->lnk = p;
                needSL = p;
            } else {
                if (q->s + currL >= q->e) {
                    int len = q->e - q->s;
                    p = q, currL -= len, currE += len;
                    continue;
                }
                if (in[i] == in[q->s + currL]) { currL++; if (needSL) needSL->lnk = p; needSL = p; break; }
                Nptr sp = gen_node(q->s, q->s + currL);
                p->changeCh(sp, currE, in);
                sp->addCh(q), sp->addCh(gen_node(pos, range_out));
                q->s = q->s + currL;
                if (needSL) needSL->lnk = sp; needSL = sp;
            }
            rem--;
            if (p == root and currL) {
                currL--, currE = pos - rem + 1;
            } else {
                p = p->lnk; if (!p) p = root;
            }
        }
    }
    for (int i = 0; i < n_node; i++) if (nodes[i].e >= range_out) nodes[i].e = n;
    return root;
}

int n; char in[200000 + 111];
int Q;

ll node_cnt[MNODE];
int vis[MNODE];
Nptr stk[MNODE], *sp;

void tree_sort(Nptr p) {
    int now = 0, id;
    for (int i = 0; i < n_node; i++) vis[i] = 0;
    sp = stk; *sp++ = p;
    while (sp != stk) {
        Nptr q = *--sp;
        if (vis[q - nodes]) {
            id = q - nodes;
            if (q->lst == 0) node_cnt[id] = 1;
            else node_cnt[id] = 0;
            for (Nptr r = q->lst; r; r = r->nxt) {
                node_cnt[id] += node_cnt[r - nodes];
            }
        } else {
            *sp++ = q, vis[q - nodes] = 1;
            for (p = q->lst; p; p = p->nxt) *sp++ = p;
        }
    }
}

ll freqE[200111];

void calc() {
    for (int i = 0; i < n_node; i++) {
        const Nptr & p = nodes + i;
        freqE[node_cnt[p - nodes]] += (ll)(p->e - p->s) * node_cnt[p - nodes];
    }
}

int main () {
    int i, j, tcc, tc = getint();
    for (tcc = 0; tcc < tc; tcc++) {
        n = getstr(in);
        in[n] = '$', n++;
        in[n] = 0;
        n_node = 0;
        Nptr root = gen(in, n);
        tree_sort(root);
        Q = getint();
        for (i = 0; i < n_node; i++) vis[i] = 0;
        // node_count();
        for (i = 0; i <= n + 2; i++) freqE[i] = 0;
        calc();

        for (i = n + 1; ~i; --i) {
            freqE[i] += freqE[i + 1];
        }

        for (i = 0; i < Q; i++) {
            int a = getint();
            if (a > n) a = n + 1;
            ll res = freqE[a];
            if (a == 1) {
                res -= n;
            }
            putll(res), pch('\n');
        }
    }
    return 0;
}
