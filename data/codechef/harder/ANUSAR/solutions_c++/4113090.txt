#include<cstdio>
#include<bits/stdc++.h>
#include<algorithm>

#ifndef ONLINE_JUDGE
#define getchar_unlocked getchar
#define putchar_unlocked putchar
#endif

inline int read_int(){register char c=getchar_unlocked();while(c<'0' || c>'9')c=getchar_unlocked();int ret=0;while(c>='0'&&c<='9'){ret=(ret<<3)+(ret<<1)+c-48;c=getchar_unlocked();}return ret;}

inline void fastwrite(long long int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)putchar_unlocked(snum[i--]);putchar_unlocked('\n');}



using namespace std;

#define maxn 200010
#define rep(i,n) for(int i=0;i<n;i++)
#define fu(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)

char S[maxn];
int pos[maxn],sa[maxn],tmp[maxn],lcp[maxn];
int N,gap;

inline bool sufcmp(int i,int j)
{
    if(pos[i]!=pos[j])
        return pos[i]<pos[j];
    i+=gap;
    j+=gap;
    if(i<N&&j<N)
        return pos[i]<pos[j];
    return i>j;
}

void build_sa()
{
    N=strlen(S);
    rep(i,N) pos[i]=S[i],sa[i]=i;
    for(gap=1;;gap*=2)
    {
        sort(sa,sa+N,sufcmp);
        fu(i,1,N-1) tmp[i]=tmp[i-1]+sufcmp(sa[i-1],sa[i]);
        rep(i,N) pos[sa[i]]=tmp[i];
        if(tmp[N-1]==N-1)
            break;
    }
}

void build_lcp()
{
    for(int i=0,k=0;i<N;i++)
        if(pos[i]!=N-1)
        {
            for(int j=sa[pos[i]+1];S[i+k]==S[j+k];)
                k++;
            lcp[pos[i]]=k;
            if(k)
                --k;
        }
    lcp[N-1]=0;
}

int L[maxn],R[maxn],stk[maxn];

void build_LR()
{
    int top=0;
    stk[++top]=0;
    L[0]=-1;
    fu(i,1,N-1)
    {
        while(top && lcp[stk[top]]>=lcp[i])top--;
        if(top)
            L[i]=stk[top];
        else
            L[i]=-1;
        stk[++top]=i;
    }

    top=0;
    stk[++top]=N-1;
    R[N-1]=N;
    fd(i,N-2,0)
    {
        while(top && lcp[stk[top]]>=lcp[i])top--;
        if(top)
            R[i]=stk[top];
        else
            R[i]=N;
        stk[++top]=i;
    }
}

long long tree[maxn];

inline void update(int idx,int n,long long val)
{
    while(idx<=n)
    {
        tree[idx]+=val;
        idx+=idx&-idx;
    }
}

inline long long query(int idx)
{
    long long sum=0;
    while(idx>0)
    {
        sum+=tree[idx];
        idx-=idx&-idx;
    }
    return sum;
}

long long D[maxn];
int lef[maxn];

void build_D()
{
    fu(i,0,N) tree[i]=0;
    fu(i,1,N) D[i]=0;
    fu(i,0,N) lef[i]=-2;
    rep(i,N)
    {
        if(lcp[i]==0)
            continue;
        if(lef[lcp[i]]==L[i])
            continue;
        lef[lcp[i]]=L[i];
        int len=lcp[i];
        if(L[i]!=-1)
            len=min(len,lcp[i]-lcp[L[i]]);
        if(R[i]!=N)
            len=min(len,lcp[i]-lcp[R[i]]);
        D[R[i]-L[i]]+=(long long)len*(R[i]-L[i]);
    }
    fu(i,1,N)if(D[i]!=0)update(i,N,D[i]);
}

int main()
{
    int t,Q,fi;
    long long qn;
    t=read_int();
    while(t--)
    {
        scanf("%s",S);
        Q=read_int();

        build_sa();
        build_lcp();
        build_LR();
        build_D();
        qn=query(N);
        while(Q--)
        {
            fi=read_int();
            if(fi>N)
                fastwrite(0);
            else if(fi==1)
                fastwrite((long long)N*(N+1)/2);
            else
                fastwrite(qn-query(fi-1));
        }
    }
}
