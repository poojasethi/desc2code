#include<bits/stdc++.h>

using namespace std;

// Shortcuts for "common" data types in contests
typedef long long int ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef set<int> si;
typedef map<string, int> msi;
// To simplify repetitions/loops, Note: define your loop style and stick with it!
#define s(i) scanf("%d",&i)
#define sl(i) scanf("%ld",&i)
#define sll(i) scanf("%lld",&i)
#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define NREP(i,a,b) \
for (int i = int(a); i >= int(b); i--)
#define TRvi(c, it) \
for (vi::iterator it = (c).begin(); it != (c).end(); it++)
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
#define TRmsi(c, it) \
for (msi::iterator it = (c).begin(); it != (c).end(); it++)
#define INF 2000000000 // 2 billion
#define MAX_N 200010                         // second approach: O(n log n)

#define gc getchar_unlocked
int getint() { unsigned int c; int x = 0; while (((c = gc()) - '0') >= 10) { if (c == '-') return -getint(); if (!~c) exit(0); } do { x = (x << 3) + (x << 1) + (c - '0'); } while (((c = gc()) - '0') < 10); return x; }
#define pch putchar_unlocked
void putint(int n) { int i = 16, a[i]; if (n < 0) pch('-'); do { a[--i] = 48 + abs(n % 10); n /= 10; } while (n); while (i < 16) pch(a[i++]); }

char T[MAX_N];                   // the input string, up to 100K characters
int n;                                        // the length of input string
int RA[MAX_N], tempRA[MAX_N];        // rank array and temporary rank array
int SA[MAX_N], tempSA[MAX_N];    // suffix array and temporary suffix array
int c[MAX_N];                                    // for counting/radix sort

//char P[MAX_N];                  // the pattern string (for string matching)
int m;                                      // the length of pattern string

int Phi[MAX_N];                      // for computing longest common prefix
int PLCP[MAX_N];
int LCP[MAX_N];  // LCP[i] stores the LCP between previous suffix T+SA[i-1]
ll ans[MAX_N];
                                              // and current suffix T+SA[i]
void countingSort(int k) {                                          // O(n)
  int i, sum, maxi = max(300, n);   // up to 255 ASCII chars or length of n
  REP( i , 0 , maxi + 10 )
    c[i] = 0;// clear frequency table
  for (i = 0; i < n; i++)       // count the frequency of each integer rank
    c[i + k < n ? RA[i + k] : 0]++;
  for (i = sum = 0; i < maxi; i++) {
    int t = c[i]; c[i] = sum; sum += t;
  }
  for (i = 0; i < n; i++)          // shuffle the suffix array if necessary
    tempSA[c[SA[i]+k < n ? RA[SA[i]+k] : 0]++] = SA[i];
  for (i = 0; i < n; i++)                     // update the suffix array SA
    SA[i] = tempSA[i];
}

void constructSA() {         // this version can go up to 100000 characters
  int i, k, r;
  for (i = 0; i < n; i++) RA[i] = T[i];                 // initial rankings
  for (i = 0; i < n; i++) SA[i] = i;     // initial SA: {0, 1, 2, ..., n-1}
  for (k = 1; k < n; k <<= 1) {       // repeat sorting process log n times
    countingSort(k);  // actually radix sort: sort based on the second item
    countingSort(0);          // then (stable) sort based on the first item
    tempRA[SA[0]] = r = 0;             // re-ranking; start from rank r = 0
    for (i = 1; i < n; i++)                    // compare adjacent suffixes
      tempRA[SA[i]] = // if same pair => same rank r; otherwise, increase r
      (RA[SA[i]] == RA[SA[i-1]] && RA[SA[i]+k] == RA[SA[i-1]+k]) ? r : ++r;
    for (i = 0; i < n; i++)                     // update the rank array RA
      RA[i] = tempRA[i];
    if (RA[SA[n-1]] == n-1) break;               // nice optimization trick
} }

void computeLCP() {
  int i, L;
  Phi[SA[0]] = -1;                                         // default value
  for (i = 1; i < n; i++)                            // compute Phi in O(n)
    Phi[SA[i]] = SA[i-1];    // remember which suffix is behind this suffix
  for (i = L = 0; i < n; i++) {             // compute Permuted LCP in O(n)
    if (Phi[i] == -1) { PLCP[i] = 0; continue; }            // special case
    while (T[i + L] == T[Phi[i] + L]) L++;       // L increased max n times
    PLCP[i] = L;
    L = max(L-1, 0);                             // L decreased max n times
  }
  for (i = 0; i < n; i++)                            // compute LCP in O(n)
    LCP[i] = PLCP[SA[i]];   // put the permuted LCP to the correct position
}

int **M, N, LOGN, *A;
void SparseTable(int N_) {
		N = N_, LOGN = ceil(log2(N));
		M = new int*[N];
		REP(i, 0, N-1) {
			M[i] = new int[LOGN];
			memset(M[i], 0, LOGN * sizeof(int));
		}
		REP(i, 0, N-1) { M[i][0] = i; }
		for (int j = 1; 1 << j <= N; j++) {
		    for (int i = 0; i + (1 << j) - 1 < N; i++) {
		        if (LCP[M[i][j - 1]] <= LCP[M[i + (1 << (j - 1))][j - 1]]) {
		            M[i][j] = M[i][j - 1];
		        } else {
		            M[i][j] = M[i + (1 << (j - 1))][j - 1];
		        }
		    }
		}
	}
    int query(int i, int j) {
        int k = log2(j - i + 1);
        if(LCP[ M[i][k] ] <= LCP[ M[j - (1<<k) + 1][k] ]) { return M[i][k]; }
        else { return M[j - (1<<k) + 1][k]; }
    }


void recurse( int left , int right , int prev )
{
    if( left == right )
        return;
    int idx = query( left + 1 , right );
    ans[right - left + 1] += ( LCP[idx] - prev );
    recurse( left , idx - 1 , LCP[idx] );
    recurse( idx , right , LCP[idx] );
}

int main()
{
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","r",stdout);
    int t;s(t);
    while( t-- )
    {
        scanf("%s",T);
        strcat( T , "#" );
        n = strlen(T);
        REP(i , 0 , n + 3 )
        {
            Phi[i] = 0;
            PLCP[i] = 0;
            LCP[i] = 0;
            SA[i] = 0;
            tempSA[i] = 0;
            RA[i] = 0;
            tempRA[i] = 0;
        }
        constructSA();
        computeLCP();
        SparseTable( n ) ;
        recurse( 0 , n - 1 ,  0 );
        ans[1] = ( n ) * 1ll * ( n - 1 );
        ans[1] /= 2;
        REP( i , 2 , n - 1 )
            ans[i] *= i;
        for( int i = n - 1 ; i >= 2 ;  i-- )
            ans[i] += ans[i + 1];
        int q;q = getint();
        REP( i , 0  , q - 1 )
        {
            int p; p = getint();
            printf("%lld\n",ans[p]);
        }
        REP( i , 0 ,  n + 4 )
            ans[i] = 0;
    }
    return 0;
}

