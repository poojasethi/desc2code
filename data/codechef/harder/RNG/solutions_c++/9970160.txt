#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])
using namespace std;
typedef long long i64;
typedef unsigned long long u64;
typedef unsigned u32;
typedef pair<int,int> pin;
#define mk(a,b) make_pair(a,b)
#define lowbit(x) ((x)&(-(x)))
#define sqr(a) ((a)*(a))
#define clr(a) (memset((a),0,sizeof(a)))
#define ls ((x)<<1)
#define rs (((x)<<1)|1)
#define mid (((l)+(r))>>1)
#define pb push_back
#define w1 first
#define w2 second
inline void read(int &x){
	x=0;int f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
inline void judge(){
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
}
/*******************************head*******************************/
const int maxn=400005;
namespace Poly{
	inline int powmod(int a,int b,int mod){
		int res=1;for(;b;b>>=1){
			if(b&1)res=1ll*res*a%mod;a=1ll*a*a%mod;
		}return res;
	}
	const int mod=104857601,G=3;
	int len,lim,w[maxn],rev[maxn],tmp[maxn],a[maxn],b[maxn];
	inline void init(int n,int m){
		len=1;lim=0;
		while(len<=n+m)len<<=1,lim++;
		int g=powmod(G,(mod-1)/len,mod);w[0]=1;
		rep(i,1,len)w[i]=1ll*w[i-1]*g%mod;
		rep(i,0,len-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<(lim-1));
	}
	inline void NTT(int a[],int on){
		rep(i,0,len-1)if(i<rev[i])swap(a[i],a[rev[i]]);
		for(int h=2;h<=len;h<<=1){
			int wm=w[len/h];
			for(int j=0;j<len;j+=h){
				int w=1;
				rep(k,0,h/2-1){
					int u=a[j+k],t=1ll*a[j+k+h/2]*w%mod;
					a[j+k]=(u+t)%mod;
					a[j+k+h/2]=(u-t+mod)%mod;w=1ll*w*wm%mod;
				}
			}
		}
		if(on==-1){
			int inv=powmod(len,mod-2,mod);
			rep(i,0,len-1)a[i]=1ll*a[i]*inv%mod;
		}
	}
	inline void inv(int a[],int b[],int k){
		if(k==1){
			b[0]=powmod(a[0],mod-2,mod);return;
		}
		inv(a,b,(k+1)>>1);
		init(k,k);
		rep(i,0,k-1)tmp[i]=a[i];
		rep(i,k,len)tmp[i]=0;
		NTT(tmp,1);NTT(b,1);
		reverse(w+1,w+len);
		rep(i,0,len-1)b[i]=((2ll*b[i]-1ll*b[i]*b[i]%mod*tmp[i])%mod+mod)%mod;
		NTT(b,-1);
		rep(i,k,len-1)b[i]=0;
	}
	inline void GetMod(int A[],int B[],int invb[],int n,int m,int R[]){
		while(n&&!A[n])n--;
		if(n<m){
			rep(i,0,n)R[i]=A[i];rep(i,n+1,m)R[i]=0;
			return;
		}
		rep(i,0,n-m)a[i]=A[n-i],b[i]=invb[i];
		init(n-m,n-m);
		rep(i,n-m+1,len-1)a[i]=b[i]=0;
		NTT(a,1);NTT(b,1);
		reverse(w+1,w+len);
		rep(i,0,len-1)a[i]=1ll*a[i]*b[i]%mod;
		NTT(a,-1);
		rep(i,n-m+1,len-1)a[i]=0;
		rep(i,0,(n-m)/2)swap(a[i],a[n-m-i]);
		init(n-m,m);
		rep(i,0,m)b[i]=B[i];rep(i,m+1,len-1)b[i]=0;rep(i,n-m+1,len-1)a[i]=0;
		NTT(a,1);NTT(b,1);
		rep(i,0,len-1)a[i]=1ll*a[i]*b[i]%mod;
		reverse(w+1,w+len);
		NTT(a,-1);
		rep(i,0,m-1)R[i]=((A[i]-a[i]+mod))%mod;
		rep(i,m,n)R[i]=0;
	}
	inline void Mul(int X[],int Y[],int n){
		init(n,n);
		rep(i,0,n)a[i]=X[i],b[i]=Y[i];
		rep(i,n+1,len)a[i]=b[i]=0;
		NTT(a,1);NTT(b,1);
		reverse(w+1,w+len);
		rep(i,0,len-1)a[i]=1ll*a[i]*b[i]%mod;
		NTT(a,-1);
		rep(i,0,len-1)X[i]=a[i];
	}/*
	inline bool check(){
		int n=50000;
		static int v[maxn],invb[maxn];
		rep(i,0,n)v[i]=rand()%mod;
		inv(v,invb,n+1);
		init(n,n);
		NTT(v,1);NTT(invb,1);rep(i,0,len-1)v[i]=1ll*v[i]*invb[i]%mod;
		reverse(w+1,w+len);
		NTT(v,-1);
		rep(i,n+1,len-1)v[i]=0;
		rep(i,0,n)if(v[i]!=(i==0))return 0;
		return 1;
	}*/	inline void GetMod(int A[],int B[],int invb[],int n,int m,int D[],int R[]){
		while(n&&!A[n])n--;
		if(n<m){
			rep(i,0,n)R[i]=A[i];rep(i,n+1,m)R[i]=0;
			return;
		}
		rep(i,0,n-m)a[i]=A[n-i],b[i]=invb[i];
		init(n-m,n-m);
		rep(i,n-m+1,len-1)a[i]=b[i]=0;
		NTT(a,1);NTT(b,1);
		reverse(w+1,w+len);
		rep(i,0,len-1)a[i]=1ll*a[i]*b[i]%mod;
		NTT(a,-1);
		rep(i,n-m+1,len-1)a[i]=0;
		rep(i,0,(n-m)/2)swap(a[i],a[n-m-i]);
		rep(i,0,(n-m))D[i]=a[i];
		init(n-m,m);
		rep(i,0,m)b[i]=B[i];rep(i,m+1,len-1)b[i]=0;rep(i,n-m+1,len-1)a[i]=0;
		NTT(a,1);NTT(b,1);
		rep(i,0,len-1)a[i]=1ll*a[i]*b[i]%mod;
		reverse(w+1,w+len);
		NTT(a,-1);
		rep(i,0,m-1)R[i]=((A[i]-a[i]+mod))%mod;
		rep(i,m,n)R[i]=0;
	}

	inline bool check(){
		int n=30000,m=10000;
		static int A[maxn],B[maxn],tmp[maxn],D[maxn],R[maxn],invb[maxn];
		rep(i,0,n)A[i]=rand()%mod;
		rep(i,0,m)B[i]=rand()%mod;
		rep(i,0,n-m)tmp[i]=B[m-i];
		inv(tmp,invb,n-m+1);
		GetMod(A,B,invb,n,m,D,R);
		init(m,n-m);
		NTT(B,1);NTT(D,1);
		rep(i,0,len-1)B[i]=1ll*B[i]*D[i]%mod;
		reverse(w+1,w+len);
		NTT(B,-1);
		rep(i,0,n+m)B[i]=(B[i]+R[i])%mod;
		rep(i,0,n+m)if(B[i]!=A[i])return 0;
		return 1;
	}
}
i64 n;
int k;
int xs[maxn],c[maxn];
int invb[maxn],a[maxn],b[maxn],tmp[maxn];
int main(){
	//judge();srand(time(NULL));
	read(k);cin>>n;
	rep(i,0,k-1)read(c[i]);
	xs[k]=Poly::mod-1;
	rep(i,1,k)read(xs[k-i]);n--;
	if(k==1){
		cout<<c[0]*(i64)Poly::powmod(xs[0],n%(Poly::mod-1),Poly::mod)%Poly::mod;return 0;
	}
	if(n<k){
		cout<<c[n];return 0;
	}
	rep(i,0,k-2)tmp[i]=xs[k-i];
	Poly::inv(tmp,invb,k-1);
	a[1]=1;b[0]=1;
	for(;n;n>>=1){
		if(n&1){
			Poly::Mul(b,a,k-1);
			rep(i,0,(k<<1))tmp[i]=0;
			Poly::GetMod(b,xs,invb,((k-1)<<1),k,tmp);
			rep(i,0,k-1)b[i]=tmp[i];
			rep(i,k,k<<1)b[i]=0;
		}
		Poly::Mul(a,a,k-1);
		rep(i,0,(k<<1))tmp[i]=0;
		Poly::GetMod(a,xs,invb,((k-1)<<1),k,tmp);
		rep(i,0,k-1)a[i]=tmp[i];
		rep(i,k,k<<1)a[i]=0;
	}
	int ans=0;
	rep(i,0,k-1)ans=(ans+1ll*c[i]*b[i])%Poly::mod;
	cout<<ans<<endl;
	//if(Poly::check())cerr<<"ok"<<endl;else cerr<<"WA"<<endl;
	//cerr<<(double)clock()/CLOCKS_PER_SEC;
	return 0;
}
