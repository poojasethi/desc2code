#include<cstdio>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<algorithm>
#include<string>
#include<utility>
#include<cassert>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long
#define INF 10000000000000000LL

pair<ll,ll> myplus(pair<ll,ll> a, pair<ll,ll> b){ return make_pair(a.first+b.first, a.second+b.second); }
pair<ll,ll> myminus(pair<ll,ll> a, pair<ll,ll> b){ return make_pair(a.first-b.first, a.second-b.second); }
pair<ll,ll> mymulti(pair<ll,ll> a, ll b){ return make_pair(a.first*b, a.second*b); }

pair<ll,ll> mat[120][120];
int toright[120], toleft[120];
pair<ll,ll> ofsleft[120], ofsright[120];
int left[120], right[120], trace[120], ptr[120];;

void MinCostMatchInit(int n, int m){
  int i;
  rep(i,n) toright[i] = -1, ofsleft[i] = make_pair(0LL, 0LL);
  rep(i,m) toleft[i] = -1, ofsright[i] = make_pair(0LL, 0LL);
}

/* n <= m */
/* recalculate about the r-th row */
pair<ll,ll> MinCostMatchModify(int n, int m, int r){
  int i, a, b, c, z;
  pair<ll,ll> d, t, res = make_pair(0LL, 0LL);

  if(toright[r]>=0){
    toleft[toright[r]] = -1;
    toright[r] = -1;
  }

  rep(i,n) left[i] = 0;
  rep(i,m) right[i] = 0;
  rep(i,m) trace[i] = -1, ptr[i] = r;
  left[r] = 1;

  for(;;){
    d = make_pair(INF*120, INF*120);
    rep(i,m) if(!right[i]){
      t = myplus(mat[ptr[i]][i], myplus(ofsleft[ptr[i]], ofsright[i]));
      if(d > t) d = t, b = i;
    }
    
    res = myplus(res, d);
    rep(i,n) if(left[i]) ofsleft[i] = myminus(ofsleft[i], d);
    rep(i,m) if(right[i]) ofsright[i] = myplus(ofsright[i], d);
    
    trace[b] = ptr[b];
    c = toleft[b];
    if(c < 0){
      while(b>=0){
        a = trace[b];
        z = toright[a];
        toleft[b] = a;
        toright[a] = b;
        b = z;
      }
      break;
    }
    right[b] = left[c] = 1;
    rep(i,m) if(myplus(mat[c][i], myplus(ofsleft[c], ofsright[i])) < myplus(mat[ptr[i]][i], myplus(ofsleft[ptr[i]], ofsright[i]))) ptr[i] = c;
  }

  return res;
}


int main(){
  int N;
  ll A[101][101], B[101][101], x, y;
  pair<pair<ll,ll>,int> arr[10010];
  pair<ll,ll> res, tmp, cost, now;

  int i, j, k, go;
  int a, b;
  pair<ll,ll> add;

  assert( scanf("%d",&N)==1 );
  rep(i,N) rep(j,N) assert( scanf(" %lld:%lld",A[i]+j,B[i]+j)==2 );
  rep(i,N) rep(j,N) assert( 0LL<=A[i][j] && A[i][j]<=1000000000000LL );
  rep(i,N) rep(j,N) assert( 0LL<=B[i][j] && B[i][j]<=1000000000000LL );

  rep(i,N) rep(j,N){
    x = A[i][j] - B[i][j];
    y = A[i][j] + B[i][j];
    A[i][j] = x;
    B[i][j] = y;
  }
  /* A[i][j] = H-G, B[i][j] = H+G */
  /* So chef maximize A, then maximize B */
  /* And guest maximize -A, then maximize B */

  rep(i,N) rep(j,N) arr[i*N+j] = make_pair(make_pair(A[i][j],-B[i][j]),i*N+j);
  sort(arr, arr+N*N); /* sort the edge, if arr[k] are unused for k<i, and arr[i] is used, then the fight i will be cancelled (or all fights are not cancelled) */

  MinCostMatchInit(N, N);
  rep(i,N) rep(j,N) mat[i][j] = make_pair(-A[i][j], -B[i][j]);
  res = make_pair(-INF, -INF);
  
  tmp = make_pair(-INF, -INF);
  rep(i,N){
    cost = MinCostMatchModify(N, N, i);
    tmp = myminus(tmp, cost);
  }

  /* brute-force for cancelled fight arr[go] */
  /* arr[go] must be chosen, and arr[k] (k<go) must not be chosen */
  for(go=N*N-1;go>=0;go--){
    k = arr[go].second;
    a = k/N; b = k%N;

    if(myplus(tmp,make_pair(INF,INF)) <= res) break; /* pruning :) */

    if(A[a][b] <= 0){ /* all fights will not be calcelled */
      tmp = myplus(tmp,make_pair(INF,INF));
      if(res < tmp) res = tmp;
      break;
    }

    /* match(a,b) should be used, so we set a really good cost for this */
    mat[a][b] = myplus(mat[a][b], make_pair(-INF, -INF));
    cost = MinCostMatchModify(N, N, a); /* recalculate min-cost matching */
    tmp = myminus(tmp, cost);

    now = tmp;
    now = myminus(now, make_pair(A[a][b], B[a][b])); /* match(a,b) is cancelled */
    if(res < now) res = now;

    /* match(a,b) must not be used after this, so we set very bad cost for this */
    mat[a][b] = myplus(mat[a][b], make_pair(2*INF, 2*INF));
    cost = MinCostMatchModify(N, N, a);
    tmp = myminus(tmp, cost);
  }

  printf("%lld %lld\n",(res.first+res.second)/2, (res.second-res.first)/2);

  return 0;
}