#include <cstdio>
#include <cstring>
#include <cassert>
#include <ctime>
#include <cstdlib>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long int64;
typedef pair<int64,int64> PLL;

PLL operator+(const PLL &p1, const PLL &p2) {
	return PLL(p1.first + p2.first, p1.second + p2.second);
}

PLL operator-(const PLL &p1, const PLL &p2) {
	return PLL(p1.first - p2.first, p1.second - p2.second);
}

#define N 100
#define V 1000000000000LL

PLL INFW = make_pair(N*V, N*V);
PLL INF = make_pair(1LL<<62, 1LL<<62);

int n;
PLL w[N][N];
PLL lx[N], ly[N], slack[N];
int slackx[N];
int s[N],t[N];
int mx[N], my[N];
int q[N],qh,qt,p[N];

void init() {
	// initial labeling
	for (int i=0;i<n;i++) {
		mx[i]=-1;
		my[i]=-1;
	}
	for (int i=0;i<n;i++) {
		lx[i]=w[i][0];
		for (int j=0;j<n;j++) lx[i]=max(lx[i],w[i][j]);
		ly[i]=make_pair(0,0);
	}
}

void update_slack(int x) {
	for (int y=0;y<n;y++) {
		PLL sl=lx[x]+ly[y]-w[x][y];
		if (sl<slack[y]) {
			slack[y]=sl;
			slackx[y]=x;
		}
	}
}

int find_root() {
	qh=0; qt=0;
	memset(s,0,sizeof(s));
	memset(t,0,sizeof(t));
	memset(p,-1,sizeof(p));
	for (int y=0;y<n;y++) slack[y]=INF;
	for (int x=0;x<n;x++) {
		if (mx[x]==-1) {
			q[qt++]=x;
			s[x]=1;
			update_slack(x);
			return 1;
		}
	}
	return 0;
}

void improve() {
	// increase matching
	while (1) {
		// exposed vertex = root
		if (!find_root()) break;
		// grow tree
		int id=-1;
		while (1) {
			// extend equality graph
			while (qh<qt) {
				int x=q[qh++];
				for (int y=0;y<n;y++) {
					if (w[x][y]==lx[x]+ly[y] && !t[y]) {
						p[y]=x;
						int z=my[y];
						if (z==-1) {
							id=y;
							goto augment;
						} else {
							q[qt++]=z;
							s[z]=1; t[y]=1;
							update_slack(z);
						}
					}
				}
			}
			// improve labeling
			PLL delta = INF;
			for (int y=0;y<n;y++) if (!t[y]) delta=min(delta,slack[y]);
			for (int x=0;x<n;x++) if (s[x]) lx[x]=lx[x]-delta;
			for (int y=0;y<n;y++) if (t[y]) ly[y]=ly[y]+delta;
			for (int y=0;y<n;y++) if (!t[y]) slack[y]=slack[y]-delta;
			// handle new edges
			for (int y=0;y<n;y++) {
				if (!t[y] && slack[y].first==0 && slack[y].second==0) {
					p[y]=slackx[y];
					int z=my[y];
					if (z==-1) {
						id=y;
						goto augment;
					} else {
						q[qt++]=z;
						s[z]=1; t[y]=1;
						update_slack(z);
					}
				}
			}
		}
		assert(0);
		// augment path
		augment:;
		for (int y=id,x,z;y!=-1;y=z) {
			x=p[y]; z=mx[x];
			mx[x]=y; my[y]=x;
		}
	}
}

PLL get_cost(int cheat=0, int debug=0) {
	PLL c=make_pair(0,0);
	PLL m=c-INF;
	for (int x=0;x<n;x++) {
		int y=mx[x];
		c=c+w[x][y];
		if (w[x][y].first>m.first) m=w[x][y];
		else if (w[x][y].first==m.first && w[x][y].second<m.second) m=w[x][y];
	}
	if (cheat && m.first>0) c=c-m;
	return c;
}

vector<pair<PLL,PLL> > edges;

int main() {
	scanf("%d",&n);
	for (int i=0;i<n;i++) {
		for (int j=0;j<n;j++) {
			int64 p1,p2;
			scanf("%lld:%lld",&p1,&p2);
			w[i][j]=make_pair(p1-p2,p1);
			edges.push_back(make_pair(make_pair(-w[i][j].first,w[i][j].second),make_pair(i,j)));
		}
	}

	init();
	improve();

	PLL best = make_pair(0,0)-INFW;
	sort(edges.begin(),edges.end());
	for (int i=0;i<(int)edges.size();i++) {
		int x=edges[i].second.first, y=edges[i].second.second;
		int yy=mx[x];
		if (yy!=y) {
			w[x][y]=INFW;
			mx[x]=-1; my[yy]=-1;
			lx[x]=max(lx[x],w[x][y]-ly[y]);
			improve();
		}

		PLL cost = get_cost(1);
		if (cost>best) best=cost;

		w[x][y]=make_pair(0,0)-INFW;
		if (mx[x]==y) {
			mx[x]=-1; my[y]=-1;
			improve();
		}
		if (get_cost()<=best) break;
	}

	cout << best.second << " " << best.second-best.first << endl;
	return 0;
}