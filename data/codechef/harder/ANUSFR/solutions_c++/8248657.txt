#include <algorithm>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
 
typedef pair<int, int> pii;
 
template<class T>
inline void chkmax(T& x, T y) {
	if (x < y) x = y;
}
 
template<class T>
inline void chkmin(T& x, T y) {
	if (y < x) x = y;
}
 
struct Data {
	int a, b, id;
	
	bool operator<(const Data& d) const {
		return a < d.a;
	}
};
 
struct Query {
	int st, en, c1, c2, id;
	
	bool operator<(const Query& q) const {
		return c2 < q.c2;
	}
};
 
#define sz(x) int((x).size())
#define MX 200005
#define MC 30
int n;
char s[MX];
int st[MC][MX], en[MC][MX];
Data dat[MC][MX];
Query q[MC][MX];
int Q, qn[MC];
int x[MX * 20], N;
pii ans[MX];
 
void preprocess() {
	int i, x;
	vector<int> pos;
	
	n = strlen(s);
	pos.push_back(n);
	for (i = n - 1; i >= 0; i--) {
		pos.insert(pos.begin(), i);
		for (x = 1; x < sz(pos); x++) {
			if (s[i] == s[pos[x]]) break;
		}
		if (x < sz(pos)) pos.erase(pos.begin() + x);
		for (x = 1; x < sz(pos); x++) {
			st[x][i] = pos[x - 1];
			en[x][i] = pos[x] - 1;
		}
		for (; x < MC; x++) {
			st[x][i] = MX;
			en[x][i] = MX;
		}
	}
	
	for (x = 1; x < MC; x++) {
		for (i = 0; i < n; i++) {
			dat[x][i].a = (st[x][i] == MX) ? -1 : st[x][i] - i + 1;
			dat[x][i].b = (en[x][i] == MX) ? -1 : en[x][i] - i + 1;
			dat[x][i].id = i;
		}
		sort(dat[x], dat[x] + n);
	}
}
 
void build() {
	int i;
	
	for (N = 1; N < n; N *= 2);
	for (i = 0; i < N; i++) x[N + i] = -1;
	for (i = N - 1; i; i--) x[i] = max(x[i * 2], x[i * 2 + 1]);
	x[0] = max(x[1], x[2]);
}
 
void update(int i, int a) {
	i += N;
	x[i] = a;
	for (i /= 2; i; i /= 2) x[i] = max(x[i * 2], x[i * 2 + 1]);
	x[0] = max(x[1], x[2]);
}
 
int max_val(int st, int en) {
	int rlt;
	
	if (en == st + 1) return x[st];
	if (en == st + 2) return max(x[st], x[st + 1]);
	
	rlt = max_val((st + 1) / 2, en / 2);
	if (st & 1) chkmax(rlt, x[st]);
	if (en & 1) chkmax(rlt, x[en - 1]);
	return rlt;
}
 
int range_max(int st, int en) {
	return max_val(N + st, N + en);
}
 
int main() {
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	int i, x, len1, len2, L, R, M, k, id, prv;
	
	scanf("%s", s);
	preprocess();
	scanf("%d", &Q);
	for (i = 0; i < Q; i++) {
		scanf("%d%d%d%d%d", &x, &len1, &len2, &L, &R);
		k = qn[x];
		q[x][k].st = L, q[x][k].en = R - len1 + 1;
		chkmin(q[x][k].en, upper_bound(st[x], st[x] + n, R) - st[x] - 1);
		q[x][k].c1 = len1, q[x][k].c2 = len2;
		q[x][k].id = i;
		qn[x]++;
	}
	for (x = 1; x < MC; x++) {
		sort(q[x], q[x] + qn[x]);
		prv = 0;
		build();
		for (k = 0; k < qn[x]; k++) {
			id = q[x][k].id;
			len1 = q[x][k].c1, len2 = q[x][k].c2;
			for (i = prv; i < n; i++) {
				if (dat[x][i].a > len2) break;
				update(dat[x][i].id, dat[x][i].b);
			}
			prv = i;
			L = q[x][k].st, R = q[x][k].en + 1;
			if (L >= R || range_max(L, R) < len1) {
				ans[id] = pii(-1, -1);
				continue;
			}
			while (R - L > 1) {
				M = (L + R) / 2;
				if (range_max(L, M) >= len1) R = M;
				else L = M;
			}
			R = max(st[x][L], L + len1 - 1);
			ans[id] = pii(L, R);
		}
	}
	for (i = 0; i < Q; i++) printf("%d %d\n", ans[i].first, ans[i].second);
	return 0;
} 