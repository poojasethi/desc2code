#include <cstdio>
#include <vector>
#include <algorithm>
#include <queue>
#include <bitset>
#include <cstring>
using namespace std;
 
int n, edges;
vector<int> edge[200], eNum[200]; // number of customers
int A[500], B[500];
 
int cycleCount;
vector<int> cycles[200]; // variable for  possibility-3 explained later
int inf = 1000000;
 
int D[200], E[500];
int dist[200][200];
 
typedef struct state {
  int u;
  int parentEdge;
  bitset<200> visitedvertices;
  
  state(bitset<200> mask, int v, int pedge) {
    u = v;
    visitedvertices = mask;
    visitedvertices[u] = 1;
    parentEdge = pedge;
  }
 
  bool isMovePossible(int v) {
    return !visitedvertices[v];
  }
 
  state moveTo(int v, int pedge) {
    return state(visitedvertices, v, pedge);
  }
 
  void print() const {
    printf("At %d, visited: ", u+1);
    for(int i=0; i < n; i++) if(visitedvertices[i]) printf("%d ",i+1);
    printf("\n");
  }
} state;
 
void printPaths(const vector<state>& V) {
  for(int i=0;i<V.size();i++)
    V[i].print();
}
 
queue<state> q;
 
// Possibility-1:  two vertices connected by three paths
 
vector<int> costs[200];
int cheapestCycle[200];
bitset<200> cheapestCycleMask[200];
 
int findThreePaths(int start) {
  for(int i=0;i<n;i++) {
    costs[i].clear();
  }
 
  queue<state> q;
  bitset<200> empty;
  q.push(state(empty, start, -1));
  while(!q.empty()) {
    state& S = q.front(); q.pop();
    int u = S.u;
    for(int i=0;i<edge[u].size();i++) {
      int v = edge[u][i];
      if(costs[v].size() < 3 && S.isMovePossible(v)) {
        state next = S.moveTo(v, eNum[u][i]);
        costs[v].push_back(next.visitedvertices.count() - 1);
        q.push(next);
      }
      if(v == start && costs[v].size() < 3 && S.parentEdge != eNum[u][i]) {
        if(costs[v].empty()) {
          cheapestCycleMask[v] = S.visitedvertices;
        }
        costs[v].push_back(S.visitedvertices.count());
      }
    }
  }
  int ret = inf;
 
  for(int i=0;i<n;i++) {
    dist[i][start] = dist[start][i] = inf * (i != start);
    if(!costs[i].empty()) {
      dist[i][start] = dist[start][i] = costs[i][0];
    }
    if(i != start && costs[i].size() == 3) {
      int cur = costs[i][0] + costs[i][1] + costs[i][2];
      ret = min(ret, cur);
    }
  }
 
  // possibility-2: two cycles sharing a vertex
 
  if(costs[start].size() == 3) {
    // remove costs[start][1] since same cycle will be repeated in opposite direction as well
    int cur = costs[start][0] + costs[start][2];
    ret = min(ret, cur);
  }
  cheapestCycle[start] = inf;
  if(!costs[start].empty()) {
    cheapestCycle[start] = costs[start][0];
  }
  return ret - 1;
}
 
int findThreePaths() {
  int ret = inf;
  for(int i=0;i<n;i++) {
    int cur = findThreePaths(i);
    ret = min(ret, cur);
  }
  //  Possibility-3: two cycles joined by a path
 
  for(int i=0;i<n;i++) if(cheapestCycle[i] != inf)
    for(int j=i+1;j<n;j++) if(cheapestCycle[j] != inf && !cheapestCycleMask[i][j])
      ret = min(ret, dist[i][j] + cheapestCycle[i] + cheapestCycle[j] - 1);
  return ret;
}
 
void clear() {
  for(int i=0;i<n;i++) {
    edge[i].clear();
    eNum[i].clear();
    D[i] = -1;
  }
  for(int i=0;i<edges;i++) E[i] = 0;
}
 
void solveCase() {
  scanf(" %d %d",&n,&edges);
  clear();  
  for(int i=0;i<edges;i++) {
    int u, v;
    scanf(" %d %d",&u,&v);
    u--; v--;
    A[i] = u; B[i] = v;
    edge[u].push_back(v); eNum[u].push_back(i);
    edge[v].push_back(u); eNum[v].push_back(i);
  }
 
  bool edgeDuplicated = false;
  
  int ret = edges;
  ret = min(ret, findThreePaths());
  printf("%d\n",ret);
}
 
main() {
  int cases; scanf(" %d",&cases);
  while(cases--) {
    solveCase();
  }
}