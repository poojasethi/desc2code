// #include <bits/stdc++.h>
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <climits>
#include <vector>
#include <cstring>
using namespace std;
typedef long long ll;

#define rd(x) scanf("%d",&x)
#define rd2(x,y) scanf("%d %d",&x,&y)
#define wd(x) printf("%d",x)
#define wd2(x,y) scanf("%d %d",&x,&y)
#define PC(x) putchar(x)
#define GC(x) getchar(x)

#define F first
#define S second
#define MP make_pair
#define PB push_back
#define D double

#define VI vector<int>
#define VL vector<long>
#define PII pair<int,int>
#define PLL pair<ll,ll>



#define E1(a) cerr<<#a<<":"<<a<<endl;
#define E2(a,b) cerr<<#a<<":"<<a<<" "<<#b<<":"<<b<<endl;
#define E3(a,b,c) cerr<<#a<<":"<<a<<" "<<#b<<":"<<b<<" "<<#c<<":"<<c<<endl;
#define E4(a,b,c,d) cerr<<#a<<":"<<a<<" "<<#b<<":"<<b<<" "<<#c<<":"<<c<<" "<<#d<<":"<<d<<endl;



#define mod 1000000007
#define maxn 200009
#define maxr 1009

//struct to store the information about link/cut tree
//contains the right,left,parent,path parent indices  -- no pointers are used
struct LCI{
    int p,pp,l,r;//parent,path parent,left,right
    int f;//flip flag f = 1  => tree is reverse binary search tree greater  elements are to the left

    int val;//add other variables if necessary and change the updatenode method

    LCI(int vv=0,int _p=-1,int _pp=-1,int _l=-1,int _r=-1,int ff = 0){
        p=_p;pp=_pp;l=_l;r=_r;
        f = ff;
        val = vv;
    }
};


int n,m,q;
PII edg[maxn];
vector<pair<PII,int> > qu;
int ans[maxn];



//initialize this for every test case for every vertex
LCI lci[2*maxn];





//update the value of node based on its children
void updatenode(int v){
    if(v==-1)return;
    lci[v].val = v-n >0 ? v-n : INT_MAX;
    if(lci[v].l!=-1)lci[v].val = min(lci[v].val,lci[lci[v].l].val);
    if(lci[v].r!=-1)lci[v].val = min(lci[v].val,lci[lci[v].r].val);
}


//propogates lazyness to children including the flip flag
void propogatenode(int v){
    if(v==-1)return;
//	E1(v);
    int l = lci[v].l;
    int r = lci[v].r;
    if(lci[v].f){
        lci[v].f = 0;
        swap(lci[v].l,lci[v].r);
        if(l!=-1)lci[l].f = 1-lci[l].f;
        if(r!=-1)lci[r].f = 1-lci[r].f;
    }
}

//internal
void setchild(int p,int x,int n){
    if(p==-1)return;
    if(lci[p].l==x)lci[p].l = n;
    else lci[p].r = n;
}

//splays the node in its preferred path tree
void splay(int n){
    int p,gp;
    p = gp = -1;
    p = lci[n].p;
    if(p!=-1)gp = lci[p].p;
    propogatenode(gp);propogatenode(p);propogatenode(n);
    if(p==-1){return;}

    int l1 = (lci[p].l==n);

    if(gp==-1){
        if(l1){
            setchild(lci[p].p,p,n);
            lci[n].p = lci[p].p;
            lci[p].l = lci[n].r;
            if(lci[n].r!=-1)lci[lci[n].r].p = p;
            lci[n].p = lci[p].p;
            lci[n].r = p;
            lci[p].p = n;
            lci[n].r = p;
        }
        else{
            setchild(lci[p].p,p,n);
            lci[n].p = lci[p].p;
            lci[p].r = lci[n].l;
            if(lci[n].l!=-1)lci[lci[n].l].p = p;
            lci[n].p = lci[p].p;
            lci[n].l = p;
            lci[p].p = n;
            lci[n].l = p;
        }
        updatenode(p);
        updatenode(n);
        swap(lci[p].pp,lci[n].pp);
        return;
    }
    int l2 = (lci[gp].l==p);

    if(l1&&l2){
        int b = lci[n].r;
        lci[n].r = p;
        lci[p].p = n;
        lci[n].p = lci[gp].p;
        setchild(lci[gp].p,gp,n);
        lci[gp].l = lci[p].r;
        if(lci[p].r!=-1)lci[lci[p].r].p = gp;
        lci[p].l = b;
        if(b!=-1)lci[b].p = p;
        lci[p].r = gp;
        lci[gp].p = p;

    }
    else if(!(l1||l2)){
        int b = lci[n].l;
        lci[n].l = p;
        lci[p].p = n;
        lci[n].p = lci[gp].p;
        setchild(lci[gp].p,gp,n);
        lci[gp].r = lci[p].l;
        if(lci[p].l!=-1)lci[lci[p].l].p = gp;
        lci[p].r = b;
        if(b!=-1)lci[b].p = p;
        lci[p].l = gp;
        lci[gp].p = p;
    }
    else if(!l1&&l2){
        lci[n].p = lci[gp].p;
        setchild(lci[gp].p,gp,n);
        lci[p].r = lci[n].l;
        if(lci[n].l!=-1)lci[lci[n].l].p = p;
        lci[gp].l = lci[n].r;
        if(lci[n].r!=-1)lci[lci[n].r].p = gp;
        lci[n].l = p;
        lci[n].r = gp;
        lci[p].p = n;
        lci[gp].p = n;
    }
    else{
        lci[n].p = lci[gp].p;
        setchild(lci[gp].p,gp,n);
        lci[p].l = lci[n].r;
        if(lci[n].r!=-1)lci[lci[n].r].p = p;
        lci[gp].r = lci[n].l;
        if(lci[n].l!=-1)lci[lci[n].l].p = gp;
        lci[n].r = p;
        lci[n].l = gp;
        lci[p].p = n;
        lci[gp].p = n;
    }
    updatenode(gp);
    updatenode(p);
    updatenode(n);
    swap(lci[gp].pp,lci[n].pp);
    splay(n);
}


//makes the path from root to v preferred
//and makes v the root of its splay tree
void access(int v){
    splay(v);
    int x = lci[v].r;
    if(x!=-1){
        lci[v].r = -1;
        lci[x].pp = v;
        lci[x].p = -1;
        updatenode(v);
    }
    while(lci[v].pp!=-1){
        int y = lci[v].pp;
        splay(y);
        int z = lci[y].r;
        lci[z].p = -1;
        lci[z].pp = y;
        lci[v].p = y;
        lci[v].pp = -1;
        lci[y].r = v;
        updatenode(y);
        splay(v);
    }
}

//links subtree of v as child of w
//v should be the root, w can be anything
//if v is not the root, use makeroot function to make it root, in this way you can select the root of newly created tree
void link(int v,int w){
    access(v);
    access(w);
    lci[w].r = v;
    lci[v].p = w;
    updatenode(w);
}

//cut v from its parent, if parent exists
void cut(int v){
    access(v);
    int x = lci[v].l;
    if(x!=-1)lci[x].p = -1;
    lci[v].l = -1;
    updatenode(v);
}

//returns the root of the vertex v
int findroot(int v){
    access(v);
    int ret = v;
    while(lci[ret].l!=-1)ret = lci[ret].l;
    access(ret);
    return ret;
}

//returns the path aggregate value like min,max,sum of all the vertices from root to v
//change updatenode and propogatenode methods accordingly.
int pathaggregate(int v){
    access(v);
    return lci[v].val;
}

//makes the vertex v as root in its tree
void make_root(int v){
    access(v);
    lci[v].f = 1 - lci[v].f;
}



bool cmp(pair<PII,int> a,pair<PII,int> b){return a.F.S<b.F.S;}




int bit[maxn];
void update(int in,int v){
    while(in<=m){
        bit[in] += v;
        in += in&(-in);
    }
}

int query(int in){
    int ret = 0;
    while(in>0){
        ret += bit[in];
        in -= in&(-in);
    }
    return ret;
}


void print(){
    for(int i=1;i<=n+m;i++){
        cerr<<i<<" "<<lci[i].l<<" "<<lci[i].r<<" "<<lci[i].p<<" "<<lci[i].pp<<" "<<lci[i].val<<" "<<lci[i].f<<endl;
    }
}

/*void printLCI() {
    cerr << "p";
    for(int j = 1; j <= n+m; ++j) cerr << "\t|" << lci[j].p;
    cerr << endl;
    cerr << "pp";
    for(int j = 1; j <= n+m; ++j) cerr << "\t|" << lci[j].pp;
    cerr << endl;
    cerr << "l";
    for(int j = 1; j <= n+m; ++j) cerr << "\t|" << lci[j].l;
    cerr << endl;
    cerr << "r";
    for(int j = 1; j <= n+m; ++j) cerr << "\t|" << lci[j].r;
    cerr << endl;
    cerr << "f";
    for(int j = 1; j <= n+m; ++j) cerr << "\t|" << lci[j].f;
    cerr << endl;
    cerr << "val";
    for(int j = 1; j <= n+m; ++j) cerr << "\t|" << ((lci[j].val == INT_MAX) ? "MAX" : to_string(lci[j].val));
    cerr << endl;
    cerr << "--------------------" << endl;

    return;
}*/





int main(){
    int t;
    rd(t);
    while(t--){

        rd(n);rd2(m,q);

        for(int i=1;i<=m;i++){rd2(edg[i].F,edg[i].S);}

        qu.clear();
        for(int i=0;i<q;i++){
            int x,y;
            rd2(x,y);
            qu.PB(MP(MP(x,y),i));
        }
        sort(qu.begin(),qu.end(),cmp);

        for(int i=1;i<=n;i++)lci[i] = LCI(INT_MAX);
        for(int i=1;i<=m;i++)lci[i+n] = LCI(i);
        fill(bit,bit+m+5,0);
        int rr = 1;
        //printLCI();
        for(int i=0;i<q;i++){
            int l = qu[i].F.F;
            int r = qu[i].F.S;

            for(;rr<=r;rr++){
                //add edge rr to the link/cut tree
                int u = edg[rr].F;
                int v = edg[rr].S;
                E1(rr);
                if(v==u)continue;
                int ins = 0;
                if(findroot(u)==findroot(v)){
                    make_root(v);
                    int x = pathaggregate(u);
                    E2(x, rr);
                    make_root(n+x);
                    cut(edg[x].F);
                    cut(edg[x].S);
                    update(x,-1);
                    ins = 1;
                }
                else{ins = 1;}
                if(ins){
                    link(rr+n,u);
                    make_root(v);
                    link(v,rr+n);
                    update(rr,1);
                }
                //printLCI();
            }

            ans[qu[i].S] = query(r)-query(l-1);
        }
        for(int i=0;i<q;i++){wd(n-ans[i]);putchar('\n');}

    }
}