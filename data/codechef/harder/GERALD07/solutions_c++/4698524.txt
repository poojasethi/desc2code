
#include <cstdio>
#include <cstring>
#include <cassert>
#include <algorithm>
#include <bitset>
#include <vector>
#include <iostream>
#define REP(i, n) for(int i = 0; i < (int)(n); ++i)
using namespace std;
typedef long long ll;


template<typename T>
struct BIT {
  vector<T> data;
  BIT(int n) : data(n+1, 0) {}
  T sum(int ed) const {
    for(T res(0); ; ed &= ed-1) if(ed) res += data[ed]; else return res;
  }
  T sum(int bg, int ed) const {
    return sum(ed) - sum(bg);
  }
  void add(int i, const T& x) {
    for(++i; i < (int)data.size(); i += i & -i) data[i] += x;
  }
};

struct query_t {
  int bg, ed;
  int idx;
};
bool operator<(const query_t& q1, const query_t& q2) {
  return q1.bg < q2.bg;
}


class Node {
public:
  Node *lp, *rp, *pp;
  int id;
  Node *minChild;
  Node() {}
  void init(int val) {
    toReverse = false;
    id = val;
    minChild = this;
    lp = rp = pp = NULL;
  }
  bool isRoot() const {
    return !pp || (pp->rp != this && pp->lp != this);
  }
  void splay() {
    while(!isRoot()){
      Node *p1 = pp;
      if(p1->isRoot()){
        p1->doReverse(); doReverse();
        if(p1->lp == this) rotr();
        else rotl();
      }else{
        Node *p2 = p1->pp;
        p2->doReverse(); p1->doReverse(); doReverse();
        if(p2->lp == p1){
          if(p1->lp == this){ p1->rotr(), rotr(); }
          else{ rotl(), rotr(); }
        }else{
          if(p1->lp == this){ rotr(), rotl(); }
          else{ p1->rotl(), rotl(); }
        }
      }
    }
    doReverse();
    aggregate();
  }
  void reverse() {
    toReverse ^= true;
  }
  
private:
  bool toReverse;
  void rotr() {
    Node *y = pp, *x = y->pp;
    if((y->lp=rp)) rp->pp = y;
    (rp=y)->pp = this;
    if((pp=x)){
      if(x->lp == y) x->lp = this;
      else if(x->rp == y) x->rp = this;
    }
    y->aggregate(); aggregate();
  }
  void rotl() {
    Node *y = pp, *x = y->pp;
    if((y->rp=lp)) lp->pp = y;
    (lp=y)->pp = this;
    if((pp=x)){
      if(x->lp == y) x->lp = this;
      else if(x->rp == y) x->rp = this;
    }
    y->aggregate(); aggregate();
  }
  void doReverse() {
    if(toReverse){
      toReverse = false;
      if(lp) lp->toReverse ^= true;
      if(rp) rp->toReverse ^= true;
      std::swap(lp, rp);
    }
  }
  void aggregate() {
    minChild = this;
    if(lp && lp->minChild->id < minChild->id) minChild = lp->minChild;
    if(rp && rp->minChild->id < minChild->id) minChild = rp->minChild;
  }
};
void expose(Node *v) {
  Node *prev = NULL;
  for(Node *p = v; p; p = p->pp){
    p->splay();
    p->rp = prev;
    prev = p;
  }
  v->splay();
}
Node* getRoot(Node *v) {
  if(!v) return NULL;
  expose(v);
  while(v->lp)
    v = v->lp;
  return v;
}
inline void link(Node *child, Node *parent) {
  expose(child);
  assert(child->lp == NULL); // child must be actual root before link()
  child->pp = parent;
}
inline void cut(Node *v) {
  expose(v);
  if(v->lp)
    v->lp->pp = NULL;
  v->lp = NULL;
}
inline void evert(Node *v) {
  expose(v);
  v->reverse();
}
inline Node* getMinChild(Node *u, Node *v) {
  evert(u);
  expose(v);
  assert(v->rp == NULL);
  return v->minChild;
}



Node* nodes[200000+10];
Node* edges[200000+10];
Node _nodes[200000+10];
Node _edges[200000+10];

int as[200000+10];
int bs[200000+10];

query_t qs[200000+10];
pair<int,int> ps[200000+10];
int ans[200000+10];

int main(void) {
  int nCase;
  scanf("%d", &nCase);
  REP(iCase, nCase){
    int nNode;
    int nEdge;
    int nQuery;
    scanf("%d%d%d", &nNode, &nEdge, &nQuery);
    REP(iEdge, nEdge){
      scanf("%d%d", as+iEdge, bs+iEdge);
      --as[iEdge];
      --bs[iEdge];
    }
    
    REP(i, nNode){
      _nodes[i].init(1000000);
      nodes[i] = &_nodes[i];
    }
    REP(i, nEdge){
      _edges[i].init(i);
      edges[i] = &_edges[i];
    }
    REP(i, nEdge){
      ps[i].second = i;
      int a = as[i];
      int b = bs[i];
      if(a == b){
        ps[i].first = i;
        continue;
      }
      Node *ra = getRoot(nodes[a]);
      Node *rb = getRoot(nodes[b]);
      if(ra == rb){
        Node *e = getMinChild(nodes[a], nodes[b]);
        ps[i].first = e->id;
        evert(nodes[a]);
        cut(e);
        evert(nodes[b]);
        cut(e);
      }else{
        ps[i].first = -1;
      }
      evert(nodes[a]);
      link(nodes[a], edges[i]);
      link(edges[i], nodes[b]);
    }
    
//     REP(i, nEdge){
//       cerr << ps[i].first << " " << ps[i].second << endl;
//     }
    sort(ps, ps + nEdge);
    
    REP(iQuery, nQuery){
      query_t& q = qs[iQuery];
      scanf("%d%d", &q.bg, &q.ed);
      q.bg--;
      q.idx = iQuery;
    }
    sort(qs, qs + nQuery);
    
    BIT<int> bit(nEdge+1);
    int pi = 0;
    REP(qi, nQuery){
      int bg = qs[qi].bg;
      int ed = qs[qi].ed;
      while(pi < nEdge && ps[pi].first < bg){
//         cerr << " pi = " << pi << ", bg = " << bg << ", ps[pi].first = " << ps[pi].first << ", ps[pi].second = " << ps[pi].second << endl;
        bit.add(ps[pi].second, 1);
        pi++;
      }
      ans[qs[qi].idx] = nNode - bit.sum(bg, ed);
    }
    
    REP(iQuery, nQuery){
      printf("%d\n", ans[iQuery]);
    }
  }

  return 0;
}
