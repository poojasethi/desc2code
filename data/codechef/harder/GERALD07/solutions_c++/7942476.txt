#include <cstdio>
#include <algorithm>
inline void I(int &a)
{
 register int c;
 a=0;
 do c=getchar_unlocked(); while(c<'0');
 do
 {
  a=(a<<1)+(a<<3)+c-'0';
  c=getchar_unlocked();
 }while(c >= '0');
}
inline void O(int a)
{
 register char s[11];
 register int t = -1;
 do s[++t]=a%10+'0',a/=10; while(a>0);
 while(t>=0) putchar_unlocked(s[t--]);
 putchar_unlocked('\n');
}
const int N = 400010;
const int inf = ~0u >> 2;
struct Node* null;
struct Node
{
        Node* ch[2];
        Node* fa;
        int mi, val, rev;
        inline bool isroot(){return fa==null||fa->ch[0]!=this&&fa->ch[1]!=this;}
        inline bool d(){return fa->ch[1]==this;}
        inline void setc(int s, Node* who){who->fa=this;ch[s]=who;}
        inline void rotate() {
                bool f=d();
                Node* y=fa; y->setc(f,ch[!f]),fa=y->fa;
                if(!y->isroot()) fa->ch[y->d()]=this;
                this->setc(!f,y),y->up();
        }
        void splay() {
                for(go();!isroot();rotate()) 
                        if(!fa->isroot())
                                (fa->d()^d())?rotate():fa->rotate();
                up();
        }
        inline void up() {
                mi = std::min(ch[0]->mi, ch[1]->mi);
                mi = std::min(mi, val);
        }
        void init(int v, Node* f) {
                fa = f;
                val = mi = v;
                ch[0] = ch[1] = null;
                rev = 0;
        }
        void flip() {
                std::swap(ch[0], ch[1]);
                rev ^= 1;
        }
        void push() {
                if(rev) {
                        ch[0]->flip(), ch[1]->flip(), rev = 0;
                }
        }
        void print() {
                if(this != null) {
                        if(ch[0] != null) ch[0]->print();
                        O(val);
                        if(ch[1] != null) ch[1]->print();
                }
        }
        void go() {
                if(!isroot()) fa->go();
                push();
        }
};
struct Bit 
{
        int c[N];
        int n;
        void init(int n) {
                std::fill(c, c + n + 1, 0);
                this->n = n;
        }
        void insert(int x, int v) {
                for(x++; x <= n; x += x & -x) c[x] += v;
        }
        int sum(int x) {
                int ret = 0;
                for(x++; x; x -= x & -x) ret += c[x];
                return ret;
        }
}ta;
struct Edge
{
        int a, b;
        void in() {  I(a); I(b);    }
}edge[N];
int n;
struct Link_Cut_Tree 
{
        Node node[N]; int tot;
        Node* access(Node* u) {
                Node* v = null;
                for(; u != null; v = u, u = u->fa) u->splay(),u->ch[1] = v,u->up();
                return v;
        }
        int ask(Node* x, Node* y) {
                access(x);
                for(x = null; y != null; y = y->fa) {
                        y->splay();
                        if(y->fa == null)  {
                                return std::min(y->ch[1]->mi, x->mi);
                        }
                        y->ch[1] = x, y->up(), x = y;
                }
        }
        int ask(int a, int b) {
                return ask(node + a, node + b);
        }
        void cut(Node* u) {
                u->splay();
                u->ch[0]->fa = u->fa;
                u->fa = u->ch[0] = null;
                u->up();
        }
        void cut(Node* u, Node* v) {
                access(u), v->splay();
                if(v->fa == u) {
                        v->fa = null;
                } else {
                        access(v), u->splay(), u->fa = null;
                }
        }
        void link(Node* u, Node* v) {
                make_root(u);
                u->fa = v;
        }
        void make_root(Node* u) {
                Node* tmp = access(u);
                tmp->flip();
                u->splay();
        }
        bool judge(Node* u, Node* v) {
                while(u->fa != null) u = u->fa;
                while(v->fa != null) v = v->fa;
                return u == v;
        }
        void insert(int a, int b, int c) {
                Node* u = node + a;
                Node* v = node + b;
                Node* edge_node = &node[n + c + 1];
                edge_node->init(c, null);
                if(judge(u, v)) {
                        int id = ask(u, v);
                        ta.insert(id, -1);
                        cut(node + n + id + 1, node + edge[id].a);
                        cut(node + n + id + 1, node + edge[id].b);
                }
                link(edge_node, node + a), link(edge_node, node + b);
                ta.insert(c, 1);
        }
}lct;
struct Query
{
        int l, r, id;
        void in(int id) {
                I(l); I(r); l--; r--;
                this->id = id;
        }
        bool operator < (const Query& cmp) const {
                return r < cmp.r;
        }
}query[N];
int ans[N];
int main()
{
        null = new Node();
        null->ch[0] = null->ch[1] = null->fa  = null;
        null->mi = null->val = inf; 
        int t, a, b, c, m, q;
        I(t);
        while(t--) {
                I(n); I(m); I(q);
                ta.init(m);
                for(int i = 1; i <= n; i++) {
                        lct.node[i].init(inf, null);
                }
                lct.tot = n;
                for(int i = 0; i < m; i++) {
                        edge[i].in();
                }
                for(int i = 0; i < q; i++) {
                        query[i].in(i);
                }
                std::sort(query, query + q);
                int pt = 0;
                for(int i = 0; i < q; i++) {
                        while(pt < m && pt <= query[i].r) {
                                int a = edge[pt].a,b = edge[pt].b,c = pt;
                                if(a != b)  lct.insert(a, b, c);
                                pt++;
                        }
                        ans[query[i].id] = n - (ta.sum(query[i].r) - ta.sum(query[i].l - 1));
                }
                for(int i = 0; i < q; i++) O(ans[i]);
        }
} 
