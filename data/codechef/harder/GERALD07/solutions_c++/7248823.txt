#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;

#define all(o) (o).begin(), (o).end()
#define allr(o) (o).rbegin(), (o).rend()
const int INF = 2147483647;
typedef long long ll;
typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<ii> vii;
typedef vector<vi> vvi;
typedef vector<vii> vvii;
template <class T> int size(const T &x) { return x.size(); }

// assert or gtfo

struct union_find {
    vi p;
    stack<ii> old;
    stack<int> saves;
    int version, comps;
    union_find() {

    }
    union_find(int n) : p(n, -1) {
        version = 0;
        comps = n;
    }
    void save() {
        saves.push(version);
    }
    void rollback() {
        while (version != saves.top()) {
            if (old.top().first == -1) {
                comps = old.top().second;
            } else {
                p[old.top().first] = old.top().second;
            }
            old.pop();
            version--;
        }
        saves.pop();
    }
    int find(int x) {
        if (p[x] < 0) {
            return x;
        } else {
            int res = find(p[x]);
            old.push(ii(x, p[x]));
            version++;
            p[x] = res;
            return p[x];
        }
    }
    bool unite(int x, int y) {
        int xp = find(x), yp = find(y);
        if (xp == yp) return false;
        old.push(ii(-1, comps));
        version++;
        comps--;
        if (p[xp] < p[yp]) {
            old.push(ii(xp,p[xp]));
            version++;
            p[xp] += p[yp];
            old.push(ii(yp,p[yp]));
            version++;
            p[yp] = xp;
        }
        else {
            old.push(ii(yp,p[yp]));
            version++;
            p[yp] += p[xp];
            old.push(ii(xp,p[xp]));
            version++;
            p[xp] = yp;
        }
        return true;
    }
    int size(int x) {
        return -p[find(x)];
    }
};

union_find uf;
int st;
bool cmp(const pair<ii,int> &a, const pair<ii,int> &b) {
    return ii(a.first.first/st, a.first.second) < ii(b.first.first/st, b.first.second);
}

ii edges[200100];
int res[200100];

int main()
{
    int ts;
    scanf("%d\n", &ts);
    for (int t = 0; t < ts; t++) {
        int n, m, qs;
        scanf("%d %d %d\n", &n, &m, &qs);
        st = static_cast<int>(sqrt(n) + 1e-9);
        for (int i = 0; i < m; i++) {
            scanf("%d %d\n", &edges[i].first, &edges[i].second);
            edges[i].first--;
            edges[i].second--;
        }
        vector<pair<ii,int> > queries;
        for (int i = 0; i < qs; i++) {
            int l, r;
            scanf("%d %d\n", &l, &r);
            l--, r--;
            queries.push_back(make_pair(ii(l,r), i));
        }
        sort(all(queries), cmp);
        uf = union_find(n);
        for (int q = 0; q < qs; q++) {
            if (queries[q].first.second - queries[q].first.first + 1 <= st + 1) {
                uf.save();
                for (int i = queries[q].first.first; i <= queries[q].first.second; i++) {
                    uf.unite(edges[i].first, edges[i].second);
                }
                res[queries[q].second] = uf.comps;
                uf.rollback();
            }
        }
        uf.save();
        int l = 0, r = -1;
        int last = -1;
        for (int q = 0; q < qs; q++) {
            if (queries[q].first.second - queries[q].first.first + 1 <= st + 1)
                continue;
            // res[queries[q].second] = -1;
            // continue;
            if (last != queries[q].first.first / st) {
                uf.rollback();
                uf.save();
// cout << "init" << endl;
                assert(uf.version == 0);
                l = (queries[q].first.first/st + 1) * st;
                r = l-1;
                last = queries[q].first.first / st;
            }
            while (r < queries[q].first.second) {
                r++;
                uf.unite(edges[r].first, edges[r].second);
// cout << "unite " << edges[r].first+1 << " " << edges[r].second + 1 << endl;
            }
            uf.save();
// cout << "save" << endl;
            while (queries[q].first.first < l) {
                l--;
                uf.unite(edges[l].first, edges[l].second);
// cout << "unite " << edges[l].first+1 << " " << edges[l].second + 1 << endl;
            }
            res[queries[q].second] = uf.comps;
// cout << "ans for " << queries[q].second << " = " << uf.comps << endl;
            l = (queries[q].first.first/st + 1) * st;
            uf.rollback();
// cout << "rollback" << endl;
        }
        for (int q = 0; q < qs; q++) {
            printf("%d\n", res[q]);
        }
    }
    return 0;
}
