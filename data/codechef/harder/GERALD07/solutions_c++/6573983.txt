// adijimmy
#include <bits/stdc++.h>
typedef long long int ll;
using namespace std;
#define N 200005
int n,m,q,magic;
int x[N], y[N], l[N], r[N], p[N], answer[N];
int f[N], g[N];
int res, ans;
int upd[N],cnt;
bool comp(const int &i, const int &j){
	return make_pair(l[i] / magic, r[i]) < make_pair(l[j] / magic, r[j]);
}
int find(int x, int *next){
	if (next == g && upd[x] != cnt){
		upd[x] = cnt;
		g[x] = f[x];
	}
	if (next[x] != x) next[x] = find(next[x], next);
	return next[x];
}
void unionfind(int x, int y, int *next, int &result){
	x = find(x, next);
	y = find(y, next);
	if(x == y) return;
	result -= 1;
	if(rand() & 1) next[x] = y;
	else next[y] = x;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d %d %d", &n, &m, &q);
		magic = sqrt(m);
		for (int i = 0; i < m; i++) scanf("%d %d", &x[i], &y[i]);
		for (int i = 0; i < q; i++){
		   scanf("%d %d", &l[i], &r[i]);
		   l[i] -= 1;
		   r[i] -= 1;
		   p[i] = i;
		}
		sort(p,p+q,comp);
		for(int I = 0, J = 0; I < q; I = J){
		   for(int i = 1; i <= n; i++) f[i] = i;
		   res = n;
		   cnt += 1;
		   int last = l[p[I]] / magic * magic + magic;
		   while(J < q && l[p[I]] / magic == l[p[J]] / magic){
			while(last <= r[p[J]]){
			  unionfind(x[last],y[last],f,res);
			  last++;
			}
			cnt++;
			ans = res;
			int to = min(r[p[J]]+1, l[p[I]] / magic * magic + magic);
			for (int i = l[p[J]]; i<to; i++) unionfind(x[i], y[i], g, ans);
			answer[p[J]] = ans;
			J++;
		   }
		}
		for(int i=0;i<q;i++) printf("%d\n",answer[i]);
     }
    return 0;
}
