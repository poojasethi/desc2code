using namespace std;
#include <bits/stdc++.h>
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define wl(n) while(n--)
#define ll long long
#define P(x) printf("%d\n",x)
#define PB push_back
#define MP make_pair
#define fl(i,n) for(i=0;i<n;i++)
#define fil(i,a,n) for(i=a;i<n;i++)
#define rev(i,a,n) for(i=n-1;i>=a;i--)
#define mem(a,i) memset(a,i,sizeof(a))
#define F first
#define S1 second
typedef pair<int,int> P;
vector<pair<int,int> > v;
std::vector<int> v1;
pair<int,int> p1;
#define MOD 1000000007
#define debug(x)  printf("####%d####\n",x);
#define nl printf("\n");
#define str string
string s;
int dp[1001];
ll pow1(ll x,ll y)
{
    if(y==0)
    return 1;
    ll temp= pow1(x,y/2)%MOD;
    if(y%2==0)
    return (temp*temp)%MOD;
    else
    return (((temp*temp)%MOD)*x)%MOD;
}
struct ab
{
    int l,r,i;
}a[200001];
#define blocks 450
bool cmp(ab a1,ab a2)
{
    if(a1.l/blocks!=a2.l/blocks)
        return a1.l/blocks<a2.l/blocks;
    return a1.r<a2.r;
}
int parent[200001],sol[200001],parent1[200009];
int ans;
int find(int i)
{
    if(parent[i]==i)
        return i;
    return parent[i]=find(parent[i]);
}
int find1(int i)
{
    if(parent1[i]==i)
        return i;
    return parent1[i]=find1(parent1[i]);
}
int main()
{
    //std::ios_base::sync_with_stdio(false);
    int t;
    int n,i,j,k,m,l;
    S(t);
    wl(t)
    {
        v.clear();
        int q;
        S2(n,m);
        S(q);
        fl(i,m)
        {
            S2(j,k);
            v.push_back(make_pair(j,k));
        }
        fl(i,q)
        {
            S2(j,k);
            j--;
            k--;
            a[i].l=j;
            a[i].r=k;
            a[i].i=i;
        }
        sort(a,a+q,cmp);
        i=0;
        for(int b=0;b*blocks<=m;b++)
        {
            fil(k,0,n+2)
            {
                parent1[k]=k;
                parent[k]=k;
            }
            ans=0;
            int curr_start=b*blocks;
            int curr_end=(b+1)*blocks-1;
            int pos=curr_end+1;
            while(i<q&&a[i].l<=curr_end)
            {
                v1.clear();
                int tempans=0;
                int l=a[i].l;
                int r=a[i].r;
                //cout<<l<<" "<<r<<" ";
                for(;pos<=r;pos++)
                {
                    int p=v[pos].first;
                    int q=v[pos].second;
                    p=find(p);
                    q=find(q);
                    if(p!=q)
                    {
                        parent[p]=q;
                        ans++;
                    }
                }
                //cout<<ans<<" ";
                //cout<<"hete\n";
                for(j=min(curr_end,r);j>=l;j--)
                {
                    int p=v[j].first;
                    int q=v[j].second;
                    int p1=find(p);
                    int q1=find(q);
                    if(p1!=q1)
                    {
                        // set[p]=p1;
                        // set[q]=q1;
                        // v1.push_back(p);
                        // v1.push_back(q);
                        p1=find1(p1);
                        q1=find1(q1);
                        if(p1!=q1)
                        {
                            tempans++;
                            parent1[p1]=q1;
                            v1.push_back(p1);
                        }
                    }
                }
                //scout<<"hee\n";
                //cout<<tempans<<"\n";
                sol[a[i].i]=n-(tempans+ans);
                for(int op=0;op<v1.size();op++)
                    parent1[v1[op]]=v1[op];
                i++;
            }
        }
        fl(i,q)
        P(sol[i]);
    }
    
    return 0;
}