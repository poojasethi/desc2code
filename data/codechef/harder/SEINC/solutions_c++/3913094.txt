// by xcwgf666

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cassert>
using namespace std;

int n, tn, ret, a[100000 + 5], b[100000 + 5], i, carry, kol[4], cur, k1, k2;

int main (int argc, char * const argv[]) {
	assert(scanf("%d", &tn) != EOF);
	assert(1 <= tn && tn <= 10);
	while (tn--) {
		scanf("%d", &n);
		assert(1 <= n && n <= 100000);
		for(i = 1; i <= n; i++) {
			assert(scanf("%d", &a[i]) != EOF);
			assert(0 <= a[i] && a[i] <= 3);
		}
		for(i = 1; i <= n; i++) {
			assert(scanf("%d", &b[i]) != EOF);
			assert(0 <= a[i] && a[i] <= 3);
		}
		for(i = 1; i <= n; i++) a[i] = (b[i] + 4 - a[i]) % 4; // getting one array instead of two
		for(i = 1; i <= n; i++) b[i] = a[i] - a[i - 1]; // getting pairwise adjacent differences
		ret = k1 = k2 = 0;
		for(i = 1; i <= n; i++) if (b[i] < 2) { // if the value of b[i] is *small*, we can use it as it is
			ret += max(0, b[i]); 
			// we can use this cell later as the end of some segment
			// if it's value is an appropriate for this, let's remember it
			if (b[i] == -3) ++k1; 
			if (b[i] == -2) ++k2;
		} else { // else we will try to make the segment
			// finding the beginning point of the segment
			if (k1) { 
				--k1; 
				b[i] -= 4;
				++ret;
			} else if (b[i] == 3 && k2) {
				--k2;
				b[i] -= 4;
				ret += 2;
			}
			// after making the segment the value of b[i] might become small 
			// and therefore, the current cell can be a beginning of some further segment
			if (b[i] == -3) ++k1; 
			if (b[i] == -2) ++k2;
			ret += max(b[i], 0);
		}
		printf("%d\n", ret);
	}
    return 0;
}
