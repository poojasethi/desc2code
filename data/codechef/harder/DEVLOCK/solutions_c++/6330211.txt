// #includes {{{
#include <algorithm>
#include <complex>
#include <numeric>
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <list>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>
#include <cmath>
using namespace std;
// }}}
// pre-written code {{{
#define REP(i,n) for(int i=0;i<(int)(n);++i)
#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)
#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)
#define LET(x,a) __typeof(a) x(a)
//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)
#define ALL(c) (c).begin(), (c).end()
#define MP make_pair

#define EXIST(e,s) ((s).find(e)!=(s).end())

#define RESET(a) memset((a),0,sizeof(a))
#define SET(a) memset((a),-1,sizeof(a))
#define PB push_back
#define DEC(it,command) __typeof(command) it=command

const int INF=0x3f3f3f3f;

typedef long long Int;
typedef unsigned long long uInt;
#ifdef __MINGW32__
typedef double rn;
#else
typedef long double rn;
#endif

typedef pair<int,int> pii;

/*
#ifdef MYDEBUG
#include"debug.h"
#include"print.h"
#endif
*/
// }}}

//{{{ Print functions
// Input/Output
template<class T>
void matrix_out(const vector<vector<T> > &x){
	REP(i,x.size()){
		REP(j,x[0].size()){
			cout<<x[i][j]<<"\t";
		}
		cout<<endl;
	}
}

template<class U,class S,class T>
U &operator<<(U &os, const pair<S,T> &p){
	os<<"("<<p.first<<","<<p.second<<")";
	return os;
}

template<class U,class T>
U &operator<<(U &os, const vector<T> &x) {
	os<<"vector[";
	REP(i,x.size()){
		os<<x[i];
		if(i!=x.size()-1)os<<",";
	}
	os<<"]";
	return os;
}

template<class U,class T>
U &operator<<(U &os, const deque<T> &x) {
	os<<"deque[";
	REP(i,x.size()){
		os<<x[i];
		if(i!=x.size()-1)os<<",";
	}
	os<<"]";
	return os;
}

template<class U,class T>
U &operator<<(U &os, const set<T> &x) {
	os<<"set[";
	FOR(it,x){
		os<<*it;
		if(++it!=x.end())os<<",";
		it--;
	}
	os<<"]";
	return os;
}

template<class U,class T>
U &operator<<(U &os, const list<T> &x) {
	os<<"list[";
	FOR(it,x){
		os<<*it;
		if(++it!=x.end())os<<",";
		it--;
	}
	os<<"]";
	return os;
}

template<class U,class T>
U &operator<<(U &os, const multiset<T> &x) {
	os<<"multiset[";
	FOR(it,x){
		os<<*it;
		if(++it!=x.end())os<<",";
		it--;
	}
	os<<"]";
	return os;
}



template<class U,class S,class T>
U &operator<<(U &os, const map<S,T> &x) {
	os<<"map[";
	FOR(it,x){
		os<<*it;
		if(++it!=x.end())os<<",";
		it--;
	}
	os<<"]";
	return os;
}

void printBit(int b,int k=-1){
	if(k==-1){
		int bb=1,i=0;
		while(bb){
			if(b&bb)k=i;
			bb<<=1;i++;
		}
	}
	REP(ct,k){
		cout<<b%2;
		b>>=1;
	}
	cout<<endl;
}

//}}}
//{{{ debug
#define dump(x) cerr << #x << " = " << (x) << endl;
#define debug(x) cerr << #x << " = " << (x) << " (L" << __LINE__ << ")" << " " << __FILE__ << endl;
#define debug2(x) cerr << #x << " = [";REP(__ind,(x).size()){cerr << (x)[__ind] << ", ";}cerr << "] (L" << __LINE__ << ")" << endl;
//}}}

//{{{ gcd and inverse
Int gcd(Int a, Int b) {
	return b != 0 ? gcd(b, a % b) : a;
}
Int lcm(Int a, Int b) {
	return a / gcd(a, b) *b;
}
// a x + b y = gcd(a, b)
Int extgcd(Int a, Int b, Int &x, Int &y) {
	Int g = a; x = 1; y = 0;
	if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;
	return g;
}
Int invMod(Int a, Int m) {
	Int x, y;
	if (extgcd(a, m, x, y) == 1) return (x + m) % m;
	else                         return 0; // unsolvable
}
//}}}


typedef int Num;

const int mod = 998244353;

//{{{ operation
inline Num mul(const Num &a, const Num &b, const Num m = mod){
	Num c = (a*(long long)b)%m;
//	assert(0<=c and c<m);
	return c;
}
inline void mul_asgn(Num &a, const Num &b, const Num m = mod){
	a = mul(a,b,m);
}
inline Num add(const Num &a, const Num &b, const Num m = mod){
	Num c=a+b;
	if(c>=m)c-=m;
//	assert(0<=c and c<m);
	return c;
}
inline Num add_asgn(Num &a, const Num &b, const Num m = mod){
	a = add(a,b,m);
}
inline Num neg(const Num &a, const Num m = mod){
	if(a==0)return 0;
	else return m-a;
}
inline Num subt(const Num &a, const Num &b, const Num m = mod){
	Num c=a-b;
	if(c<0)c+=m;
	return c;
}
inline Num subt_asgn(Num &a, const Num &b, const Num m = mod){
	a -= b;
	if(a<0)a+=m;
}
/*
inline Num inv(const Num &a, const Num m = mod){
	return invMod(a,m);
}
*/
//}}}

//{{{ pow
/* (x^k)%m */
inline Num powMod(Num x, Num k){
	Num res;
	if(k==0) return 1;
	res = powMod(x,k/2);
	res = mul(res,res,mod);
	if(k%2) res = mul(res,x,mod);
	return res;
}
//}}}

int N,P;
int MM;

int dp[2][15010][55];//id, sum, rem
int dp2[2][15010];//id, sum
int result[15010][55];//sum, rem
int N0;
vector<int> loop, rest;

const int M = 15000;
//Int fact[M+1],invfact[M+1];
int inv_a[M+1];
int M_SIZE, P_SIZE;
int FFT_SIZE,inv_FFT_SIZE;

#define FAST
Num omega, inv_omega;

//{{{ primitive root
int primitive_root(int p){
	vector<int> v;
	int t = p-1;
	for(int i=2;i*i<=t;i++){
		if(t%i==0){
			v.push_back(i);
			while(t%i==0)t/=i;
		}
	}
	if(t>1)v.push_back(t);
	for(Int r=2;;r++){
		bool valid = true;
		REP(i,v.size()){
			if(powMod(r,(p-1)/v[i])==1){
				valid=false;
			}
		}
		if(valid)return r;
	}
}
//}}}
void init(){
	M_SIZE = 1;
	while(M_SIZE<=MM+10)M_SIZE<<=1;
	M_SIZE<<=1;

	P_SIZE = 1;
	while(P_SIZE<P)P_SIZE<<=1;
	P_SIZE<<=1;

	assert(MM*2+1<M_SIZE);
	
#ifdef FAST
	FFT_SIZE = M_SIZE*P_SIZE;
#else
	FFT_SIZE = M_SIZE;
#endif
	inv_FFT_SIZE = invMod(FFT_SIZE,mod);
//	cout<<FFT_SIZE<<" "<<inv_FFT_SIZE<<endl;
//	cout<<mul(FFT_SIZE,inv_FFT_SIZE)<<endl;
	Num r = primitive_root(mod);
	omega = powMod(r,(mod-1)/FFT_SIZE);
	inv_omega = invMod(omega,mod);

	int f = 1;
	for(int i=0;i<=M;i++,mul_asgn(f,i)){
		inv_a[i] = invMod(i,mod);
	}
}

//{{{ fft
void fft(int n, const Num &omega, Num a[]) {
	Num base = omega;
	for (int m = n; m >= 2; m >>= 1) {
		int mh = m >> 1;
		Num w(1);
		for (int i = 0; i < mh; i++) {
			for (int j = i; j < n; j += m) {
				int k = j + mh;
				Num x = subt(a[j], a[k]);
				add_asgn(a[j],a[k]);
				a[k] = mul(w,x);
			}
			w = mul(w,base);
		}
		base = mul(base,base);
	}
	int i = 0;
	for (int j = 1; j < n - 1; j++) {
		for (int k = n >> 1; k > (i ^= k); k >>= 1);
		if (j < i) swap(a[i], a[j]);
	}
}
//}}}

void calc2(){
	int from = 0;
	memset(dp2[from],0,sizeof(dp2[from]));
	memset(result,0,sizeof(result));
	dp2[from][0]=1;
	int cmb = 1;
	REP(i,MM+1){
		//cmb = comb(N0,i)
		int t = 0;
		for(int s=0;s<=MM;s++){
//			ref+=dp2[from][s]*comb(N0,i);
			add_asgn(result[s][t],mul(dp2[from][s],cmb));
			t++;
			t = (t==P)?0:t;
		}
		if(i==MM)break;
		int to = (from+1)%2;
		memset(dp2[to],0,sizeof(dp2[to]));
		int sum = 0, head = -1, tail = -9;
		for(int s=0;s<=MM;s++){
			dp2[to][s]=sum;
			head++;
			if(0<=head and head<=MM){
				add_asgn(sum,dp2[from][head]);
//				sum+=dp2[from][head];//head
//				if(sum>=mod)sum-=mod;
			}
			if(0<=tail and head<=MM){
				subt_asgn(sum,dp2[from][tail]);
//				sum-=dp2[from][tail];//tail
//				if(sum<0)sum+=mod;
			}
			tail++;
		}
		from=to;
		mul_asgn(cmb,N0-i);
		mul_asgn(cmb,inv_a[i+1]);
	}
}

#ifdef FAST
const int FFT_BASE = (1<<15)*(1<<7);
#else
const int FFT_BASE = (1<<15);
#endif
Num a[FFT_BASE], b[FFT_BASE], c[FFT_BASE];

// using fft
void calc(int r0, int from, int to){
	memset(dp[to],0,sizeof(dp[to]));
//	dump(r0);

#ifdef FAST
	memset(b,0,sizeof(b));
	REP(r,P){
		int r2 = r*r0%P;
		for(int s=0;s<=MM;s++)add_asgn(b[s + r2*M_SIZE], result[s][r]);
	}

	fft(FFT_SIZE,omega,b);

	memset(a,0,sizeof(a));
	REP(r,P)for(int s=0;s<=MM;s++)a[s + r*M_SIZE] = dp[from][s][r];

	fft(FFT_SIZE,omega,a);

	REP(i,FFT_SIZE)c[i] = mul(a[i],b[i]);

	fft(FFT_SIZE,inv_omega,c);
	REP(i,FFT_SIZE)mul_asgn(c[i],inv_FFT_SIZE);

	for(int r=0;r<P*2;r++){
//	REP(r,P_SIZE){
		int r2 = r%P;
		for(int s=0;s<=MM;s++){
			add_asgn(dp[to][s][r2],c[s+r*M_SIZE]);
		}
	}
#else
	REP(r,P)REP(r2,P){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		for(int s=0;s<=MM;s++){
			a[s] = Num(dp[from][s][r]);
			b[s] = Num(result[s][r2]);
		}
		fft(FFT_SIZE,omega,a);
		fft(FFT_SIZE,omega,b);
		for(int i=0;i<FFT_SIZE;i++)c[i] = mul(a[i],b[i]);
		fft(FFT_SIZE,inv_omega,c);
		int ri = (r+r2*r0)%P;
		for(int s=0;s<=MM;s++)add_asgn(dp[to][s][ri], mul(c[s],inv_FFT_SIZE));
	}
#endif
}

//{{{ function calc_pattern
void calc_pattern(){
	rest.clear();loop.clear();
	vector<int> v;
	int r = 1;
	int start;// end = v.size()
	for(int i=0;;){
		int j;
		bool found = false;
		for(j=0;j<v.size();j++){
			if(v[j]==r){
				found=true;
				break;
			}
		}
		if(found){
			start = j;
			break;
		}
		v.push_back(r);
		i++;
		mul_asgn(r,10,P);
	}
	for(int i=start;i<v.size();i++){
		loop.push_back(v[i]);
	}
	int n = N;
	// [0,n)
	// [0, start): rest
	for(int i=0;i<min(n,start);i++){
		rest.push_back(v[i]);
	}
	if(n<=start){
		return;
	}
	n-=start;
	N0 = n/loop.size();
	int rem = n%loop.size();
	REP(i,rem){
		rest.push_back(loop[i]);
	}
}

void test_calc_pattern(){
	for(P=7;P<=7;P++){
		for(N=1;N<=10;N++){
			dump(N);
			dump(P);
			calc_pattern();
			dump(N0);
			dump(loop);
			dump(rest);
		}
	}
}
//}}}

int main(){
	scanf("%d%d%d",&N,&P,&MM);
//	cout<<N<<" "<<P<<" "<<MM<<endl;
	init();
	calc_pattern();
//	cout<<loop<<endl;
	calc2();
	int from = 0;
	memset(dp[from],0,sizeof(dp[from]));
	dp[from][0][0]=1;

	REP(i,loop.size()){
		int r0 = loop[i], to = (from+1)%2;
		calc(r0,from,to);
		from = to;
	}
	REP(i,rest.size()){
		int r0 = rest[i], to = (from+1)%2;
		memset(dp[to],0,sizeof(dp[to]));
		for(int s=0;s<=MM;s++){
			for(int d=0;d<10;d++){
				int sd = s+d;
				if(sd>MM)continue;
				int r1 = (r0*d)%P;
				for(int r=0;r<P;r++,add_asgn(r1,1,P)){
					add_asgn(dp[to][sd][r1],dp[from][s][r]);
				}
			}
		}
		from = to;
	}
	int total = 0;
	for(int i=0;i<=MM;i++){
		add_asgn(total,dp[from][i][0]);
		printf("%d",total);
		if(i<MM){
			printf(" ");
		}
	}
	printf("\n");
	return 0;
}