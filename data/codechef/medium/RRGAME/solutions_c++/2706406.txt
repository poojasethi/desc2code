#include <iostream>
#include <list>
#include <fstream>
#include <cmath>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <deque>
#include <map>
#include <complex>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <sstream>

using namespace std;

#define FORALL(i,a,b) for(int i=(a);i<=(b);++i)
#define FOR(i,n) for(int i=0;i<(n);++i)
#define FORB(i,a,b) for(int i=(a);i>=(b);--i)

typedef long long ll;
typedef long double ld;
typedef complex<ld> vec;

typedef pair<int,int> pii;
typedef map<int,int> mii;

#define pb push_back
#define mp make_pair

/*#warning assumes D is sorted in decreasing order
bool graphic(ll* D, int n, ll sum) {
	//ll sum = 0;
	//FOR(i,n) sum += D[i];
	if (sum%2) return false;
	return (D[i] <= sum-D[i]);
}*/

#define MAXN 100010
ll A[MAXN];
ll D[MAXN];

#warning N=1 ans = 0

ll odds(ll a, ll b) {
	if (a==0) return (b+1)/2;
	else return odds(0,b) - odds(0,a-1);
}

ll evens(ll a, ll b) {
	if (a==0) return (b+2)/2;
	else return evens(0,b) - evens(0,a-1);
}

int main() {
	int N;
	ll M,K;
	cin >> N >> M >> K;
	ll y;
	FOR(i,N) scanf("%Ld",&y), A[i] =y;
	FOR(i,N) D[i] = (M-A[i])/K + 1;
	sort(D,D+N);
	reverse(D,D+N);
	
	ll s = 0;
	FOR(i,N) s += D[i];
	
	//FOR(i,N) cout << D[i] << " "; cout << endl;
	
	#warning when N=1?
	
	ll ans = 0;
	// decrease d1
	if (D[0] <= (s-D[0])){
		ll x = min((s-D[0])-D[0],D[1]);
		if (s%2) ans = max(ans,odds(0,x));
		else ans = max(ans,evens(0,x));
	}
	
	{
		ll low = max(0ll,D[0] -(s-D[0]));
		if (low <= D[0]-D[1]) {
			ll sumd1 = s-(D[0]-D[1]);
			ll x = min(D[1],sumd1-D[1]);
			assert(x >= 0);
			x += (D[0]-D[1]);
			
			ll high = x;
			if (s%2) ans = max(ans,odds(low,high));
			else ans = max(ans,evens(low,high));
			
			//cout << low << " " << high << endl;
		}
	}
	
	cout << ans%(1000000007) << endl;
	return 0;
	
	//decrease d0 to d1, all the while being happy
	if (D[0] <= (s-D[0])) {
		ll diff = D[0]-D[1];
		assert(diff>=0);
		
		// now try to decrease d1
		{
			ll s2 = s - diff;
			ll d0 = D[0]-diff;
			if (d0 <= (s2-d0)) {
				ll x = min((s2-d0)-d0,D[1]);
				ans = max(ans,(x+diff+1+1-(s%2))/2);
			}
		}
		//ll x = min((s-D[0])-diff
	}
	
	if (D[0] > (s-D[0])) {
		ll bad = D[0] - (s-D[0]);
		if (bad <= D[0]-D[1]) {
			D[0] -= bad;
			s -= bad;
			if (D[0] <= (s-D[0])) {
				ll diff = D[0]-D[1];
				assert(diff>=0);
				// now try to decrease d1
				{
					ll s2 = s - diff;
					ll d0 = D[0]-diff;
					if (d0 <= (s2-d0)) {
						ll x = min((s2-d0)-d0,D[1]);
						//cout << x << " " << diff << " " << bad << endl;
						ans = max(ans,(x+diff+bad+1+1-((s+bad)%2))/2 - ((bad-1)+1+1-((s+bad)%2))/2);
					}
				}
			}
		}
	}
	
	cout << ans << endl;
	return 0;
	
	if (D[0] > (s-D[0])) {	//largest guy is too big
		ll diff = D[0]-(s-D[0]);
		diff = min(diff,D[0]-D[1]);
		D[0] -= diff;
		s -= diff;
	}
	
	assert(D[0] <= (s-D[0]) || D[0] == D[1]);
	
	
	
	
	if (N>1)
	{
		ll diff = D[0]-D[1];
		assert(diff >= 0);
		D[0]-=diff;
		s -= diff;
		
		//cout << diff << endl;
		
		//if (D[0] <= (s-D[0])) 
		s -= D[0];
		ll x = min(s-D[0],D[1]) + diff;
		s += D[0];
		if (s%2) {
			ans = max(ans,(x+1)/2);
		}else {
			ans = max(ans,(x+2)/2);
		}
		//cout << "bro: " << x << " " << diff << endl;
		//x += diff;
		//ans = max(ans,x+diff);
		
	}
	
	cout << ans << endl;
	/*
	ll ans = 0;
	
	ll low = 0;
	ll high = sum;
	
	bool odd = (sum%2)?true:false;
	while(low<high) {
		ll k = (low+high)/2;
		ll t = 2*k + odd;
		if (works(t)) {
		
		}
	}
	if (graphic(DD,N,sum)) ans++;	//they all make it
	
	// now pick one guy not to make it, and binary search to find
	FOR(*/
}











