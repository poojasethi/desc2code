#include <cstring>
#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <algorithm>
 
using namespace std;
 
typedef long long int64;
 
#define MAXN 1000007
typedef long long int64;
 
static int sm[MAXN][4];
static int64 dp[MAXN][4][4];
 
char input[MAXN];
int arr[MAXN];
 
int q, n; 
char sc[2], ec[2];
int si, ei;
int sci, eci;
 
 
// static int count_a[5*MAXN][4];
// static int64 count_b[5*MAXN][4][4];
 
 
class parser {
  private:
   char buf[1<<17]; int ptr;
    void fillbuffer() {
      fread(buf,1,1<<17,stdin); ptr=0; 
    }
 
    char getcharx() {
       if(ptr==1<<17) fillbuffer();
       return buf[ptr++];
    }
   
    public :
    
    parser() {
      ptr = 1<<17; 
    }
 
    int readInt(){ 
        char c; while((c=getcharx())<'0') ; 
        int n = 0; while(n=n*10+c-'0',(c=getcharx())>='0');
        return n;
    }
   
   void readString(char str []){
     int p = 0;
     char c; while((c=getcharx())<'a') ; 
     while(str[p++]=c,(c=getcharx())>='a' && c <= 'z');
     str[p] = '\0'; 
   }
};
  
// struct btree {
  
//   void init(int idx, int s, int e){
//     if(s == e) {
//       count_a[idx][arr[s]] += 1;
//       return ;
//     }
//     else {
//        init(2*idx, s, (s+e)/2);
//        init(2*idx+1, (s+e)/2+1, e);
//        for(int i=0; i<4; ++i) 
// 	 count_a[idx][i] = count_a[2*idx][i] + count_a[2*idx+1][i];
//        for(int i=0; i<4; ++i)
//          for(int j=0; j<4; ++j) {
//             count_b[idx][i][j] = count_b[2*idx][i][j] + 
//                                  count_b[2*idx+1][i][j] + 
//                          (int64) count_a[2*idx][i] * count_a[2*idx+1][j];
// 	 }
//        return;
//     }
//   }
 
//   void calculate(int idx, int rs, int re, int s, int e, int sc, int ec, int64  r []){
//     if( e < rs  || re < s ) {
//        r[0] = r[1] = r[2] = 0;
//        return;
//     } 
//     if( rs <= s && e <= re ) {
//       r[0] = count_a[idx][sc];
//       r[1] = count_a[idx][ec];
//       r[2] = count_b[idx][sc][ec];
//       return;
//     }
//     else {
//       int64 ll[3], rr[3];
//       calculate(2*idx, rs, re, s, (s+e)/2, sc, ec, ll);
//       calculate(2*idx+1, rs, re, (s+e)/2+1, e, sc, ec,rr);
//       r[0] = ll[0] + rr[0];
//       r[1] = ll[1] + rr[1];
//       r[2] = ll[2] + rr[2] + ll[0] * rr[1];
//     }
//   }
// };
 
 
 
inline int calculate_index(char c){
  if(c == 'c') return 0;
  else if(c == 'h') return 1;
  else if(c == 'e') return 2;
  else return 3;
}
 
int main(){
  parser p;
  p.readString(input);
  n = strlen(input);
 
  for(int i=0; i<n; ++i) {
    int idx = calculate_index(input[i]);
    sm[i+1][0] = sm[i][0]; sm[i+1][1] = sm[i][1]; sm[i+1][2] = sm[i][2]; sm[i+1][3] = sm[i][3];
    sm[i+1][idx] += 1;  
    for(int j=0; j<4; ++j) {    
      dp[i+1][j][0] = dp[i][j][0]; dp[i+1][j][1] = dp[i][j][1];
      dp[i+1][j][2] = dp[i][j][2]; dp[i+1][j][3] = dp[i][j][3];
    }
    //printf("%d %d %d %d\n", sm[i+1][0], sm[i+1][1], sm[i+1][2], sm[i+1][3]);
    dp[i+1][0][idx] += sm[i][0]; dp[i+1][1][idx] += sm[i][1]; 
    dp[i+1][2][idx] += sm[i][2]; dp[i+1][3][idx] += sm[i][3];
  }
  // struct btree rt;
  // rt.init(1, 0, n-1);
  q = p.readInt();
  while(q--) {
    p.readString(sc); p.readString(ec);
    si = p.readInt(); ei = p.readInt();
    sci = calculate_index(sc[0]);
    eci = calculate_index(ec[0]);
    int64 r = dp[ei][sci][eci] - dp[si-1][sci][eci];
    r -= (int64)(sm[ei][eci] - sm[si-1][eci]) * ( sm[si-1][sci] );
    printf("%lld\n", r);
  }
  return 0;
}
 