#include<iostream>
#include<cstdlib>
#include<vector>
#include<cmath>
using namespace std;
 /*
int possible(int num , vector<int> b, vector<int> pos1 , int num_pos, int desire)
{	int totalpos= 999999;
	int ch = 0;
	for(int i = 0 ; i < b.size(); i++)
	{	if(num+b[i]==desire)
		{		if(totalpos > max(num_pos, pos1[i]))
				{	totalpos = max(num_pos, pos1[i]);
				}
				ch = 1;
		}
		else if(num+b[i]>desire)
		{	break;
		}
	}
	if(ch==0)
	{	return -1;
	}
	else
	{	return totalpos;
	}
 
}	*/
int min1(int i, int n)
{	int y= i+1;
	if(y>n/2)
	{	return n - y + 1;
	}
	else
	{	return y;
	}
 
}
/*
int sor(vector<int> & p , vector<int>& q)
{	for( int i = 0 ; i <  p.size(); i++)
	{	int min = p[i];
		int pos =  i;
		for( int j = i;  j< p.size(); j++)
		{	if(min> p[j])
			{	min = p[j];
				pos = j;
				
			}
		} 
		int temp = p[i];
		p[i]=min;
		p[pos]=temp;
		int temp2 = q[i];
		q[i]=q[pos];
		q[pos]=temp2;
	}
}
 */
int main()
{	

 
		int n;
		long desire;
		cin>>n;
		cin>>desire;
		int a[n];
		int b[desire];
		for(int i =0 ;i < n  ;i ++)
		{	cin>>a[i];
		}
		vector<int> second(desire);
		for(int i =0 ; i < desire  ;i ++)
			{	b[i]=-1;
				second[i]=-1;
			}
		vector<int> great;
		vector<int> lesser;
		vector<int> gr_pos;
		
/*		for( int i = 0 ; i < n ; i++)
		{	if(a[i]>desire/2)
			{	great.push_back(a[i]);
				gr_pos.push_back(min(i,n));
			}
			else if(a[i]<=desire/2)
			{	lesser.push_back(a[i]);
				les_pos.push_back(min(i,n));
			}
			
*/		
		for(int  i = 0 ; i < n ; i++)
		{	if(a[i]<desire&&a[i]!=0)
			{	if(b[a[i]]!=-1)
				{	if(b[a[i]]>min1(i,n))
					{	second[a[i]]=b[a[i]];
						b[a[i]]=min1(i,n);
					}	
					else
					{	if(second[a[i]]>min1(i,n))
						{	second[a[i]]=min1(i,n);
						}
						else if(second[a[i]]==-1)
						{	second[a[i]]=min1(i,n);
						}
					}
				}
     			else if(b[a[i]]==-1)
				{	b[a[i]] = min1(i,n);
				
				}
			}
		}
 
		long long h = 999999999;
		int chec =  0;
		for(int i = 0 ; i < n  ; i++)
		{	if(a[i]<desire&&a[i]!=0)
			{	if(b[a[i]]!=-1&&b[desire-a[i]]!=-1)
				{	if(a[i]!=desire-a[i])
					{
					
	/*				{	if(second[a[i]]!=-1)
						{	if(h>max(b[a[i]],second[a[i]]))
							{ h = max(b[a[i]],second[a[i]]);
							}
						}
					}
		*/				 if(h>max(b[a[i]],b[desire-a[i]]))
						{	h = max(b[a[i]],b[desire-a[i]]);
					
					
						}
						chec  = 1;
					}
				}
			}
		}
//		sor(lesser,les_pos);
	
//		vector<long long> diff;
//		for( int i = 0 ; i < great.size(); i++)
//		{	int ele = great[i];
//			long long post = possible(ele,lesser,les_pos,gr_pos[i],desire);
//		
//			if(post!=-1)
//			{	diff.push_back(post);
//			}
//		}
//		long long min1 = -1;
//		long long min = 9999999;
//	if(diff.size()!=0)
//	{	long long min =  diff[0];
//			min1 = min;
//	}
//		for( int i = 0 ; i < diff.size(); i++)
///		{	
//			if(min>diff[i])
//			{	min = diff[i];
//				min1 = min;
				
//			}
//		}
		if(h==999999999)
		{	cout<<-1<<endl;
		}
		else
		{	cout<<h<<endl ;
		}
	
		
}
