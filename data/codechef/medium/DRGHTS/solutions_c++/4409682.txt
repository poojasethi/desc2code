#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<vector>
#include<list>
#include<queue>
#include<map>
#include<algorithm>
#include<utility>
using namespace std;
#define id(x) scanf("%d",&x)	// int                : range             -2,147,483,648 to 2,147,483,647
#define iu(x) scanf("%u",&x)    // unsigned int       : range                          0 to 4,294,967,295
#define illd(x) scanf("%lld",&x)   // long long          : range â€“9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
#define illu(x) scanf("%llu",&x)// unsigned long long : range                          0 to 18,446,744,073,709,551,615
#define fl(i,x,y) for(ll i=x;i<y;i++)
typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
int nv,ne,x,y;
vector<int> connected_component[50001];//contains all components information and maximum number can be no_of_vertices
vector<int> graph[50001];//contains graph data
vector<int> children[50001];
int root[50001];
int label[50001];// 0 means closed and 1 means opened,maximum size is no_of_vertices
int I[50001];      // I[i] - no of opened windows in subtree rooting at i
int visited[50001];
int parent[50001];
int present_component=0;
int dfs(int v)
{
	connected_component[present_component].push_back(v);
	I[v]+=label[v];
	visited[v]=1;
	for(int i=0;i<graph[v].size();i++)
	{
		if(visited[graph[v][i]]==0)
		{
			parent[graph[v][i]]=v;
			dfs(graph[v][i]);
			I[v]+=I[graph[v][i]];

		}
	}


}
int divide_component()
{
	for(int i=0;i<nv;i++)
	{
		if(visited[i]==0)
		{
			dfs(i);
			present_component++;
		}
		
	}

}
void print_connected_components()
{
	for(int i=0;i<present_component;i++)
	{
		for(int j=0;j<connected_component[i].size();j++)
		{
			cout<<connected_component[i][j]<<" ";
		}
		cout<<endl;
	}
}
void print_graph()
{
	for(int i=0;i<nv;i++)
	{
		for(int j=0;j<graph[i].size();j++)
		{
			cout<<graph[i][j]<<" ";
		}
		cout<<endl;
	}
}
void print_parent()
{
	cout<<"parent"<<endl;
	for(int i=0;i<nv;i++)
	{
		cout<<parent[i]<<" ";
	}
	cout<<endl;

}
void print_I()
{
	cout<<"I"<<endl;
	for(int i=0;i<nv;i++)
	{
		cout<<I[i]<<" ";
	}
	cout<<endl;


}
void find_roots()
{
	for(int i=0;i<present_component;i++)
	{
		for(int j=0;j<connected_component[i].size();j++)
		{
			if(parent[connected_component[i][j]]==-1)
				{root[i]=connected_component[i][j];break;}
		}
	}
}
void find_all_children()
{
	for(int i=0;i<nv;i++)
	{
		if(parent[i]!=-1)
		{
			children[parent[i]].push_back(i);
		}
	}
}
ll calculate_ans1()
{
	ll q=0;
	for(int i=0;i<present_component;i++)
	{
		ll p=0;
		for(int j=0;j<connected_component[i].size();j++)
		{
			if(label[connected_component[i][j]])
				p++;

		}
		q+=((p)*(p-1))/2;
	}
	return q;
}

ll calculate_ans2()
{
	ll ans=0;
	for(int i=0;i<present_component;i++)
	{
		for(int j=0;j<connected_component[i].size();j++)
		{
			if(I[connected_component[i][j]]>0 && I[connected_component[i][j]] < I[root[i]])
				{ans++;continue;}
			if(label[connected_component[i][j]]==1 && I[connected_component[i][j]]>1)
				{ans++;continue;}
			ll count=0;
			for(int k=0;k<children[connected_component[i][j]].size();k++)
			{
				if(I[children[connected_component[i][j]][k]]>0)
					count++;
				if(count>=2)
					{ans++;break;}

			}


		}
	}
	return ans;

}

int main()
{
	id(nv),id(ne);
	memset(I,0,sizeof(I));
	memset(visited,0,sizeof(visited));
	memset(parent,-1,sizeof(parent));
	for(int i=0;i<nv;i++) id(label[i]);
	for(int i=0;i<ne;i++)
	{
		id(x);
		id(y);
		graph[x-1].push_back(y-1);
		graph[y-1].push_back(x-1);
	}
	divide_component();
	//print_parent();
	//print_I();
	//print_connected_components();
	find_roots();
	find_all_children();
	printf("%lld %lld\n",calculate_ans1(),calculate_ans2());	
	getchar();
	return 0;
}
