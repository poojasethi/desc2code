//create an un-directed graph
//count then number of open wiindows in different connected components
//count the number of non

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#define LL long long int
#include <string.h>
#include <list>
using namespace std;

int * visited;
int * window;
LL tree_window_count;
int node  = 0;

class Graph
{
    int V;    // No. of vertices
    list<int> *adj;    // Pointer to an array containing adjacency lists


public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w);   // function to add an edge to graph
    void furik();
    void rubik();
    void DFSvertex(int v, int visited[]);
    int DFSvertexr(int v, int visited[]);  // A function used by DFS
};

Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // undirected
    adj[w].push_back(v);
}

void Graph::DFSvertex(int v, int visited[])
{
    // Mark the current node as visited and print it
    visited[v] = 1;
    if (window[v])
        tree_window_count++;


    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for(i = adj[v].begin(); i != adj[v].end(); ++i)
        if(!visited[*i])
            DFSvertex(*i, visited);
}

int Graph::DFSvertexr(int v, int visited[])
{
    // Mark the current node as visited
    visited[v] = 1;
    int flag1 = 0,flag2 = 0;

    if (window[v])
        flag1 = 1;

         // cout << v<< " -> ";


    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;


    for(i = adj[v].begin(); i != adj[v].end(); i++){
        if(!visited[*i]){
           int temp = DFSvertexr(*i, visited);
           flag2 = flag2 || temp;  // if any 1 of adjacent is open window - flag2 = 1
        }
    }


            if(flag1||flag2){
            //  cout << endl << "vert = " << v << " -> " << flag1 << " , " << flag2 <<endl;
               node++;
                return 1 ;
            }
            else return 0;
}



// The function to do DFS traversal. It uses recursive DFSUtil()
void Graph::furik()
{
    LL furik=0;
    // Mark all the vertices as not visited

    for(int i = 0; i < V; i++)
        visited[i] = 0;


    // Call the recursive helper function to print DFS traversal
    // starting from all vertices one by one
    for(int i = 1; i < V; i++)
        if(!visited[i]&&window[i]){
            tree_window_count=0;
            DFSvertex(i, visited);
            furik+=(LL)((tree_window_count)*(tree_window_count-1)*0.5);

        }

        cout << furik << " ";

}


void Graph::rubik()
{

    for(int i = 0; i < V; i++)
        visited[i] = 0;

      node=0;
      int temp;

    for(int i = 1; i < V; i++){
       // all connected components

        temp = node;
         if(!visited[i]&&window[i]){
            //cout <<endl<< "here for "<<i<<endl;
            DFSvertexr(i, visited);

            if(temp+1==node) // cant add single open window cases
            node--;

    }
    }
   cout << node;
}






int main()
{
    int t;
   // cin >> t;
    //while(t--){
    int V,E;
    cin >> V >> E;
    Graph g(V+1);
    visited = (int*)malloc((V+1)*sizeof(int)); //global arrays
    window =  (int*)malloc((V+1)*sizeof(int));
    int oc;

    window[0]=0;
    for(int i=1;i<=V;i++){
        scanf("%d",&oc);
        visited[i]=0;
        window[i]=oc;
    }


    int e1,e2;

    for(int i=0;i<E;i++){
        scanf("%d%d",&e1,&e2);

        if(e1-e2)
        g.addEdge(e1, e2);
    }



    g.furik();
    g.rubik();

    //cout<<endl;

    //}

    return 0;
}
