//solving recurrence relation with matrix exponentiation

#include<stdio.h>
#include<iostream>
#include<math.h>                      
#include<stdlib.h>
#include<cstdio>
#include<utility>
#include<cstring>
#include<algorithm>
#include<vector>
#define MOD 1000000007
#define prnt(a) printf("%lld\n",a)
typedef long long ll;
#define FOR(k,a,b) for(typeof(a) k=(a); k < (b); ++k)
const int k=2;

struct matrix {
    long long a[3][3];
};

using namespace std;


matrix mul(matrix A,matrix B) // multiply 2 matrices
{  int i,j,m;
	matrix C;
	for(i=0;i<k;i++) for(j=0;j<k;j++)  C.a[i][j]=0;
	
	for(i=0;i<k;i++)
		for(j=0;j<k;j++)
			for(m=0;m<k;m++)  {
	//			C.a[i][j]+=(A.a[i][m]*B.a[m][j])%mod;
		//	C.a[i][j]%=mod;  }
			C.a[i][m] += (A.a[i][j] * ll(B.a[j][m])) % MOD;
			C.a[i][m] %= MOD; }

  	return C;
}

matrix pow(matrix A,int p)   // computes A ^ p
{
	if(p==1)  return A;
	if(p%2==1)  return  mul(A,pow(A,p-1));
	 matrix X = pow(A,p/2);
	 return mul(X,X);
}

int main()
{   
    int g; long  x,s,t; 
	matrix M,C,tem,re;
	M.a[0][0]=1;    M.a[0][1]=1;
	M.a[1][0]=1;    M.a[1][1]=0;
	
	C.a[0][0]=1;    C.a[0][1]=0;
	
	cin>>t;
    while(t--)
    {
		scanf("%ld%d",&x,&g);
	
			//ans=sum(y)-sum(x-1);   &&  sum(x)=fib(x+2)-1;
		
			
		    tem=pow(M,x);
			re=mul(C,tem);
									
			s=re.a[0][0];  
			//cout<<s<<"  ";
			long cnt=0;
			
			while(s)
			{
				cnt+=s&1;
				s>>=1;
			}
			//cout<<cnt<<endl;
			if(cnt==g)  printf("CORRECT\n");
			else        printf("INCORRECT\n");
	}
	return 0;
}