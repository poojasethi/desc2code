#include<iostream>
#include<stdio.h>
#include<string>
#define infi 1000000
using namespace std;
char board[1001][1001];
int points[1001][1001];
int n;
int maximum( int a, int b, int c, int d)
{
	int e,f;
	e=max(a,b);	f=max(c,d);
	return max(e,f);
}
int calc( int x, int y )
{
	if ( y==n-1 )
	{
		if (board[x][y]=='P')
			return 1;
		else
			return 0;
	}
	if ( y>n-1 || x>n-1 || x<0)
		return -infi;
	if ( points[x][y]!=-1)
		return points[x][y];
	else
	{
		int value = maximum( calc( x+1,y+2), calc( x-1,y+2), calc( x+2,y+1), calc( x-2,y+1));
		if ( board[x][y]=='P' )
			points[x][y]=1+value;
		else 
			points[x][y]= value;
		return points[x][y];
	}
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	int cases,i,j,pawns,posx,posy;
	///string str;
	char str[1001];
	//cin>>cases;
	scanf( "%d",&cases);
	while(cases--)
	{
		//cin>>n;
		scanf( "%d",&n);
		for (i=0;i<n;++i)
		{
			//cin>>str;
			scanf( "%s",str);
			for(j=0;j<n; ++j)
			{
				board[i][j]=str[j];
				if (board[i][j]=='K')
				{
					posx=i;
					posy=j;
				}
				points[i][j]=-1;
			}
			
		}
		pawns=calc( posx, posy);
		printf( "%d\n",pawns);
//		cout<<pawns<<endl;
/*		for(i=0;i<n; ++i){
			for(j=0;j<n;++j)
				cout<<points[i][j]<<" ";
			cout<<endl;	}
*/		
	}
}

/*
1
4
PPPP
PPPK
PPPP
PPPP

1
6
K...PP
P.P..P
.P...P
P..P.P
PP..PP
PPPPPP

*/

/*
2
5
K....
..P..
.P...
...P.
.....
6
K.....
..P..P
.P..P.
...P..
.P...P
...P..
*/

/*
//maximum waiters 
#include<iostream>
#include<algorithm>
#include<cstdio>
#define scan(a) scanf("%d",&a)
using namespace std;

struct cust
{
	int st;
	int dep;
	int comp;
};

bool sort1(cust const &a,cust const &b){
	if(a.comp!=b.comp){
		return(b.comp>a.comp);
	}
	else{
		return (b.dep>a.dep);
	}
}


int main()
{
	int t,i,j,n,k,count,c;
	scan(t);
	while(t--)
	{
		scan(n); scan(k);
		cust arr[n];
		for ( i=0;i<n;++i){
			scan(arr[i].st);
			scan(arr[i].dep);
			scan(arr[i].comp);
		}
		
		if(n==0|| n==1)
		{
			printf("%d\n",n);
			continue;
		}	
		
		sort( arr, arr+n, sort1);
		count=1;c=0;
		for (i=1; i<n;++i)
		{
			if ( (arr[i].comp != arr[i-1].comp) || ( arr[i].comp == arr[i-1].comp && arr[i].st >= arr[c].dep  )  )
			{
				c=i;
				count+=1;
			}
		}
		printf("%d\n",count);
	}
	
}

/*
2
3 3
1 3 1
4 6 2
7 10 3
4 2
10 100 1
100 200 2
150 500 2
200 300 2
*/


/*
#include <stdio.h>
#include <stdbool.h>
#define scan(a) scanf( "%d",&a)
int s[100001];
int klimit[5][100001];
 
void sieve()
{
	long i,j;
	for(i=2;i<=100000;i++)
	{
		if(s[i]==0)
		{
			for(j=i;j<=100000;j+=i)
			{
				s[j]++;
			}
		}
	}
	
}
void func()
{
	int i;
	for(i=2;i<=100000;i++)
	{
		int j;
		for(j=1;j<=5;j++)
		{
		klimit[j-1][i]=s[i]==j?klimit[j-1][i-1]+1:klimit[j-1][i-1];
		}
	}
}
int main()
{
	sieve();
	func();
	int a,b,k,t,i,j,ans;
	scan(t);
	while(t--)
	{
/*	a=scan();
	b=scan();
	k=scan();
	scan(a); scan(b); scan(k);
	//printf("%d %d\n",klimit[k-1][b],klimit[k-1][a-1]);
	ans=klimit[k-1][b]-klimit[k-1][a-1];
	printf("%d\n",ans);
	}
	return 0;
}
 */




/*
1
4
1 2 3 4
1 4 5 3


#include <stdio.h>
 
#define MAX 500
inline int min(int a,int b)
{
	return a>b?b:a;
}
int main()
{
	int H[MAX],K[MAX],DP[2*MAX+1],t,i,j,n,max,result;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		//printf("n = %d\n",n);
		max = 0;
		for(i=0;i<n;i++)
		{
			scanf("%d",&H[i]);
			if(H[i] > max)
				max = H[i];
		}
		for(i=0;i<n;i++)
			scanf("%d",&K[i]);
		// Initialization
		DP[0] = 0;
		for(i=1;i<=(2*max);i++)
			DP[i] = 1000000000;
		//DP
		for(i=0;i<n;i++){
			for(j=K[i];j<=(2*max);j++){
				DP[j] = min(DP[j],1+DP[j-K[i]]);
				printf(" %d: %d \n",j,DP[j]);
			}
			//printf("%d\n",DP[i]);
		}
				
		result = 0;
		for(i=0;i<n;i++)
			result+=DP[2*H[i]];
		printf("%d\n",result);
	}
	return 0;
}

/*
#include<stdio.h>
#include<stdlib.h>
//#define scan(a) scanf("%d",&a)
//#define SIZE 65535
//char buffer[SIZE];
#define gc getchar_unlocked 
int dynamic ( int pump[], int start, int end , int result);
inline int getn(){
	int n = 0, c = gc();
	while(c < '0' || c > '9') c = gc();
	while(c >= '0' && c <= '9')
		n = (n<<3) + (n<<1) + c - '0', c = gc();
	return n;
}
int compare (const void* p1, const void* p2)
{ 
   int i1 = *(int*) p1;
   int i2 = *(int*) p2;

   return i2-i1; 
 }
 int main()
{
	int num,n,i,j,l,var,count,min,calc;
	int *order,*pump;
	//char buffer[SIZE];
	num=getn();
	//scan(num);
	for (l=0;l<num;++l)
	{
	//	n=scan(buffer);
		//scan(n);
		n=getn();
		printf("%d",n);
		order=(int*)malloc(n*sizeof(int));
		pump=(int*)malloc(n*sizeof(int));
		
		for ( i=0;i<n;++i)
		{
			////var=scan(buffer);
			//scan(var);
			var=getn();
			order[i]=2*var;
		}
		for ( i=0;i<n;++i)
		{
			//var=scan(buffer);
			//scan(var);
			var=getn();
			pump[i]=var;
		}
		qsort(pump,n,sizeof(int), compare);
		count =0;
		
		for ( i=0 ; i<n; ++i)
		{
			min = dynamic ( pump, 0, n-1, order[i] );
			//printf( "%d ",min);
			count +=min;
		}
		printf("\n%d\n",count);
	}
}
int dynamic ( int pump[], int start, int end , int result)
{
	int i, value, min=9999,j;
	if(result ==0)
		return 0;
	if ( result == pump[start])
		return 1;
	else
	{
		for ( i=start; pump[i]>result; ++i);
		for ( j=i; j<=end; ++j)
		{
			value =dynamic( pump, j, end, result - pump[j]);
			if (value< min)
				min=value;
			
		}
		return min+1;
		
	}
}

/*
1
5
9 7 4 8 2 
9 4 3 5 1  
*/


/*int scan(char buffer[])
 {

	long unsigned i;
	int input, c;
	input=0;
	while ( (c=fread(buffer, sizeof(char), SIZE, stdin))>0)
	{
		for (i=0;i<c;++i){
		if ( buffer[i]=='\n'||buffer[i]==' ')
			return input;
		else
			input=input*10 + (buffer[i]-'0');}
	}
	return input;
 }
 */
