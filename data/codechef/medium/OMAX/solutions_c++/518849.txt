#include <vector>
#include <numeric>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include <limits>

using namespace std;

#define FOR(i,a,b)		for(int i=(a),_b=(b);i<(_b);++i)
#define FORD(i,a,b)		for(int i=(a),_b=(b);i>(_b);--i)
#define pb			push_back
#define mp			make_pair
#define	sz(a)			int((a).size())
#define	all(c)			(c).begin(),(c).end()
#define	tr(c,i)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define	present(c,x)		((c).find(x) != (c).end())
#define	cpresent(c,x)		(find(all(c),x) != (c).end()) 

typedef long long		ll;
typedef unsigned long long	ull;
typedef vector<int>		vi;
typedef vector<vi>		vvi;
typedef vector<string>		vs;
typedef pair<int, int>		pii;
typedef vector<pii>		vpii;
typedef unsigned char	byte;

const int N = 78;
int a[N][N];
const int MAXX = (N*N*100000);
const int MINX = -(N*N*100000);

int dp[N][N][N][N];

int sum(byte r1, byte c1, byte r2, byte c2)
{
	int s = 0;
	if (r1 > 0)
		s += a[r1-1][c2];
	if (c1 > 0)
		s += a[r2][c1-1];
	if (r1 > 0 && c1 > 0)
		s -= a[r1-1][c1-1];
	return a[r2][c2]-s;
}

int main()
{
#if 0
	ifstream cin("in");
#endif
#if 0
	ofstream cout("out");
#endif
	int R,C;
	while (true) {
		//cin >> R >> C;
		scanf("%d %d",&R,&C);
		if (R == 0 && C == 0)
			break;
		FOR(i,0,R) FOR(j,0,C)
			//cin >> a[i][j];
			scanf("%d",&a[i][j]);
		FOR(c,0,C) FOR(r,1,R)
			a[r][c] += a[r-1][c];
		FOR(r,0,R) FOR(c,1,C)
			a[r][c] += a[r][c-1];

		int best = MINX;
		FORD(r1,R-1,-1) {
			FORD(c1,C-1,-1) {
				FOR(r2,r1+2,R) {
					FOR(c2,c1+2,C) {
						int bottom = r1+1;
						int left = c1+1;
						int top = r2-1;
						int right = c2-1;
						int &ans = dp[bottom][left][top][right];
						ans = sum(bottom,left,top,right);
						if (bottom+1 <= top)
							ans = min(ans,dp[bottom+1][left][top][right]);
						if (left+1 <= right)
							ans = min(ans,dp[bottom][left+1][top][right]);
						if (top-1 >= bottom)
							ans = min(ans,dp[bottom][left][top-1][right]);
						if (right-1 >= left)
							ans = min(ans,dp[bottom][left][top][right-1]);
						best = max(best,sum(r1,c1,r2,c2)-ans);
					}
				}
			}
		}
		//cout << best << endl;
		printf("%d\n",best);
	}
	return 0;
}
