//#undef _GLIBCXX_DEBUG

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <valarray>
#include <vector>

using namespace std;

#define foreach(iter,cont) for(typeof((cont).begin()) iter = (cont).begin(); iter != (cont).end(); ++iter)
#define min3(a, b, c) min(a, min(b, c))
#define max3(a, b, c) max(a, max(b, c))
#define inf 1000000008
#define eps 1.0e-10L
#define divisible(a, b) (((a) / (b)) * (b) == (a))
//static const long long p = 1000000007;
__attribute__((unused)) static bool eq(long double a, long double b)  { return (a == b ? true : (a * b == 0 ? abs(a - b) < eps : abs(a - b) / (abs(a) + abs(b)) < eps));  }
__attribute__((unused)) static long long modp(long long n, long long m) { long long r = n % m; return r >= 0 ? r : r + m; }
__attribute__((unused)) static long long gcd(long long a, long long b) { return (a < 0 ? gcd(-a, b) : (b < 0 ? gcd(a, -b) : (!a && !b ? 1 : (b ? gcd(b, a % b) : a)))); }
template<class T> static int len(const T& cont) { return (int) cont.size(); }

// BEGIN CUT HERE
template<class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << "(" << p.first << ", " << p.second << ")"; }
template<class T> ostream &operator<<(ostream& os, const vector<T> &vec) { os << "[ "; for(size_t i = 0; i < vec.size(); i++) { os << vec[i]; if(i != vec.size() - 1) { os << ", "; } } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const list<T> &l) { os << "[ "; bool first = true; for(typename list<T>::const_iterator lstIt = l.begin(); lstIt != l.end(); ++lstIt) { if(!first) { os << ", "; } first = false; os << *lstIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const deque<T> &d) { os << "[ "; bool first = true; for(typename deque<T>::const_iterator dIt = d.begin(); dIt != d.end(); ++dIt) { if(!first) { os << ", "; } first = false; os << *dIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const vector<vector<T> > &mat) { for(size_t i = 0; i < mat.size(); i++) { if(i) os << endl; os << mat[i]; } return os; }
template<class T> ostream &operator<<(ostream &os, const set<T> &s) { os << "{ "; bool first = true; for(typename set<T>::const_iterator setIt = s.begin(); setIt != s.end(); ++setIt) { if(!first) { os << ", "; } first = false; os << *setIt; } return os << " }"; }
template<class T, class U> ostream &operator<<(ostream &os, const map<T, U> &m) { os << "{ "; bool first = true; for(typename map<T, U>::const_iterator mapIt = m.begin(); mapIt != m.end(); ++mapIt) { if(!first) { os << ", "; } first = false; os << mapIt->first << " = " << mapIt->second; } return os << " }"; }
enum CONSOLE_FG { FG_BLACK, FG_RED, FG_GREEN, FG_YELLOW, FG_BLUE, FG_MAGENTA, FG_CYAN, FG_WHITE };
enum CONSOLE_STYLE { STYLE_NONE, STYLE_BOLD };
ostream& operator<<(ostream &os, CONSOLE_FG color) { return os << "\x1b[" << ((int) color + 30) << "m"; }
ostream& operator<<(ostream &os, CONSOLE_STYLE style) { return os << "\x1b[" << (style == STYLE_NONE ? 0 : 1) << "m"; }
// END CUT HERE

/*
  KmpTable table = kmpInitTable(needle.begin(), needle.end());
  string::iterator it = kmpSearch(haystack.begin(), haystack.end(),
  needle.begin(), needle.end(),
  table);
  cout << (it - haystack.begin()) << endl;
*/

typedef vector<int> KmpTable;

template<class RandomAccessIterator>
KmpTable kmpInitTable(RandomAccessIterator needleStart, RandomAccessIterator needleEnd) {
	vector<int> t(needleEnd - needleStart, 0);
	t[0] = -1;
	if(t.size() > 1) {
		t[1] = 0;
	}
	
	int pos = 2;
	int cnd = 0;
	
	while(needleStart + pos < needleEnd) {
		if(*(needleStart + pos - 1) == *(needleStart + cnd)) {
			t[pos++] = ++cnd;
		} else if(cnd > 0) {
			cnd = t[cnd];
		} else {
			t[pos++] = 0;
		}
	}
	
	return t;
}

template<class RandomAccessIterator1, class RandomAccessIterator2>
RandomAccessIterator1 kmpSearch(RandomAccessIterator1 haystackStart, RandomAccessIterator1 haystackEnd,
                                RandomAccessIterator2 needleStart, RandomAccessIterator2 needleEnd,
                                const KmpTable &t) {
	
	int haystackSize = haystackEnd - haystackStart;
	int needleSize = needleEnd - needleStart;
	
	int m = 0;
	int i = 0;
	
	while(m + i < haystackSize) {
		if(*(needleStart + i) == *(haystackStart + m + i)) {
			if(i == needleSize - 1) {
				return haystackStart + m;
			}
			i++;
		} else {
			m = m + i - t[i];
			if(t[i] > -1) {
				i = t[i];
			} else {
				i = 0;
			}
		}
	}
	
	return haystackEnd;
}

int n, age[100000], l[100000], r[100000], p[100000], q, m, agem[1000], lm[1000], rm[1000], pm[1000];
vector<int> preOrder, preOrderm;

void dfs(int u) {
	preOrder.push_back(u == -1 ? u : age[u]);

	if(u != -1) {
		dfs(l[u]);
		dfs(r[u]);
	}
}

void dfsm(int u) {
	preOrderm.push_back(u == -1 ? u : agem[u]);

	if(u != -1) {
		dfsm(lm[u]);
		dfsm(rm[u]);
	}
}

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		scanf("%d", &age[i]);
	}

	fill_n(l, n, -1);
	fill_n(r, n, -1);
	fill_n(p, n, -1);

	for(int i = 0; i < n - 1; i++) {
		int a, b;
		char c;
		scanf("%d %d %c", &a, &b, &c);

		if(c == 'M') {
			l[a - 1] = b - 1;
		} else {
			r[a - 1] = b - 1;
		}

		p[b - 1] = a - 1;
	}

	for(int i = 0; i < n; i++) {
		if(p[i] == -1) {
			dfs(i);
		}
	}

	scanf("%d", &q);
	while(q--) {
		scanf("%d", &m);
		for(int i = 0; i < m; i++) {
			scanf("%d", &agem[i]);
		}

		fill_n(lm, m, -1);
		fill_n(rm, m, -1);
		fill_n(pm, m, -1);
		preOrderm.clear();
		
		for(int i = 0; i < m - 1; i++) {
			int a, b;
			char c;
			scanf("%d %d %c", &a, &b, &c);

			if(c == 'M') {
				lm[a - 1] = b - 1;
			} else {
				rm[a - 1] = b - 1;
			}

			pm[b - 1] = a - 1;
		}

		for(int i = 0; i < m; i++) {
			if(pm[i] == -1) {
				dfsm(i);
			}
		}

		KmpTable table = kmpInitTable(preOrderm.begin(), preOrderm.end());
		vector<int>::iterator it = kmpSearch(preOrder.begin(), preOrder.end(),
		                                     preOrderm.begin(), preOrderm.end(),
		                                     table);

		printf("%s\n", it == preOrder.end() ? "NO" : "YES");
	}

	return 0;
}
