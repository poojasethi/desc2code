#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<ctime>
#include<assert.h>

#include<cmath>
#include<iostream>
#include<fstream>

#include<string>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
#include<set>
#include<sstream>
#include<stack>
#include<limits.h>

using namespace std;


#define asdf exit(0);


#define NODE 1000100

char temp[11];
int ad[NODE][2];
int visited[NODE];
int in[NODE];
int mapp[450];
int age[NODE];
char s[NODE];
int n;//used only in creatign the string



stack<int> st_dfs_vertex, st_dfs_edge;
void st_dfs(int u)
{
	sprintf(temp,"%d",age[u]);
    int i;


    n=0;
    s[n++]='(';

	int lln=strlen(temp);
    for(i=0;i<lln;i++) s[n++]=temp[i];
    s[n++]=')';




    visited[u]=1;//vis[u]=1;
    st_dfs_vertex.push(u);
    st_dfs_edge.push(0);

    int v;
    while (!st_dfs_vertex.empty())
    {
        u = st_dfs_vertex.top(); st_dfs_vertex.pop();
        i = st_dfs_edge.top(); st_dfs_edge.pop();
        if (i == 2 )
        {
            s[n++]='U';
            //..pos1
        }
        else
        {
            st_dfs_vertex.push(u);
            st_dfs_edge.push(i+1);
            v = ad[u][i];
            if ( v && !visited[v] )//..line 1
            {

                //..inside loop
                if(i==0) s[n++]='L';
                else s[n++]='R';

                visited[v]=1;//visited[v]=1;
                st_dfs_vertex.push(v);
                st_dfs_edge.push(0);



                sprintf(temp,"%d",age[v]);

                s[n++]='(';
                int lln=strlen(temp);
                for(i=0;i<lln;i++) s[n++]=temp[i];
                s[n++]=')';
            }
        }
    }



	//s[n-1]=0;
	//n--;
}



void make_string()
{
    int N,i,x,y;
    scanf("%d",&N);


    for(i=0;i<N;i++)
    {
        in[i+1]=0;

        ad[i+1][0]=0;
        ad[i+1][1]=0;



        visited[i+1]=0;

        scanf("%d",&age[i+1]);
		age[i+1]--;
    }

    char ch[10];
    for(i=0;i<(N-1);i++)
    {
        scanf("%d %d %s",&x,&y,ch);

        if(ch[0]=='E') ch[0]='L';

        if(ch[0]=='L') ad[x][0]=y;
        else ad[x][1]=y;

        in[y]=1;
    }


    for(i=1;i<=N;i++)
    {
        if(in[i]==0)
		{
			st_dfs(i);
			break;
		}
	}




    for(i=0;i<n;i++)
    {
        s[i]=mapp[s[i]];
    }

}






const int K_AHO(100010);//number of words in dic
const int L_AHO(1000010);//sum of chars in all words in dictionary
const int different_chars(16); //number of difference characters


int si_AHO;
int m_Aho;



int po[K_AHO];//ith word tar end kon node e ase
int fail[L_AHO];




int q[L_AHO];
int child[L_AHO][different_chars];//trie er DS (ith node theke k peiL_AHOe jaite hobe child[i][k] node e)






int Querys;





int vis[1000010];




//take input: 'WORDS' ta dictionary word
int WORDS;
void dic()
{

    scanf("%d", &WORDS);


    int i,h,j,t;
    si_AHO = 1;
    t=0;

    for(i=0;i<WORDS;i++)
    {
        //scanf("%s", s);
        make_string();
		//s[n-1]=0;
		//n--;


		int len = n, p(1);


		for(j=0;j<len;j++)
        {
            if (child[p][s[j]] == 0) child[p][s[j]] = ++si_AHO;
            p = child[p][s[j]];
        }
        po[i] = p;
    }


	for(i=0;i<different_chars;i++)
    if (child[1][i])
    {
        q[t++] = child[1][i];
        fail[q[t - 1]] = 1;
    }
    else child[1][i] = 1;


    for(h=0;h<t;h++)
    for(i=0;i<different_chars;i++)
    if (child[q[h]][i])
    {
        q[t++] = child[q[h]][i];
        fail[q[t - 1]] = child[fail[q[h]]][i];
    }
    else child[q[h]][i] = child[fail[q[h]]][i];





}





char temp_s[1000010];
int temp_n;
void ini()
{
    int i;
    for(i='0';i<='9';i++) mapp[i]=i-'0';
    mapp['L']=10;
    mapp['R']=11;
    mapp['(']=12;
    mapp[')']=13;
    mapp['U']=14;
}


int main()
{
    //freopen("in.txt","r",stdin);
	//freopen("out1.txt","w",stdout);


    int i,j,h,p;


    ini();


    make_string();
    for(i=0;i<n;i++) temp_s[i]=s[i];
	temp_n=n;
	dic();

	for(i=0;i<temp_n;i++) s[i]=temp_s[i];





    int len = temp_n;
    for (i = 0, p = 1; i <len; i++)
    {
        p = child[p][s[i]];


		int q=p;
        vis[q]=1;
        while(q!=1)
        {
            vis[q]=1;
            q=fail[q];
		}
    }


    for(i=0;i<WORDS;i++)
    {
        if(vis[po[i]])
        {
            printf("YES\n");
        }
        else printf("NO\n");
    }




    return 0;
}
