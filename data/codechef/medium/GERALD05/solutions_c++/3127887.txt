/* Divanshu Garg */

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cctype>
#include <cassert>

using namespace std;

#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(int i=(a);i<(n);++i)
#define FD(i,a,n) for(int i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define Sl(x) scanf("%llu",&x)
#define M(x,i) memset(x,i,sizeof(x))
#define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl
int ABS(int a) { if ( a < 0 ) return (-a); return a; }
#define fr first
#define se second

/* Relevant code begins here */

/* Input from file or online */

void input() {
#ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
    // freopen("out.txt","w",stdout);
#endif
}

/* Input opener ends */

#define MOD 1000000007

/* This function calculates (a^b)%MOD */
ill poW(ill a, ill b) {
    ill x = 1, y = a;
    while ( b > 0 ) {
        if ( b&1 ) {
            x = (x*y);
            if ( x >= MOD ) x %= MOD;
        }
        y = (y*y);
        if ( y >= MOD ) y %= MOD;
        b = (b>>1);
    }
    return x;
}
 
ill modInverse(ill a, ill m) {
    return poW(a,m-2);
}

ill cnt[105], S;
ill dp[105][105];
ill invModFact[105];

void pre() {
    invModFact[0] = 1;
    F(i,1,105) {
        invModFact[i] = (invModFact[i-1]*modInverse(i,MOD)) % MOD;
    }
}

ill select_now(ill n,ill k) {
    if ( n == 0 ) return 0;
    if ( k == 0 ) return 1;
    n += (k-1);
    ill x = 1;
    for ( int i = 0; i < k; ++i ) {
        x = (x*((n-i)%MOD)) % MOD;
    }
    return ((x*invModFact[k])%MOD);
}

ill f(int sum, int idx) {
    if ( sum == 0 ) return 1;
    if ( idx > sum ) return 0;
    ill &res = dp[sum][idx];
    if ( res != -1 ) return res;
    res = 0;
    ill choice = sum/idx; choice++;
    F(i,0,choice) {
        ill x = select_now(cnt[idx],i);
        ill temp = (x*f(sum-i*idx,idx+1))%MOD;
        res = (res+temp)%MOD;
    }
    return res;
}

int main() {
    input();
    pre();
    int t; cin >> t;
    while ( t-- ) {
        ill a0, a1, a2, a3;
        cin >> a0 >> a1 >> a2 >> a3 >> S;
        F(i,1,105) {
            cnt[i] = a0 + a1*i + a2*i*i + a3*i*i*i;
        }
        M(dp,-1);
        cout << f(S,1) << endl;
    }
    return 0;
}