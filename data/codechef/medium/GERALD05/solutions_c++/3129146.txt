#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<functional>
#include<string>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<utility>
#include<fstream>
#include<sstream>
#include<cmath>
#include<cstdio>
#include <ctime>
#include<cassert>

using namespace std;

#define MEM(a,b) memset(a,(b),sizeof(a))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MP make_pair
#define pb push_back

#define M 1000000007

#define maxs 100
#define maxt 500

typedef long long  LL;

typedef pair<int,int> pi;
typedef vector<int> vi;
typedef vector<string> vs;
typedef vector<double> vd;
typedef vector<pi> vpi;


LL a[4];

int F(int n)
{
   int ret=0,pw=1;
   for(int i=0;i<4;i++)
   {
      ret=(ret+pw*a[i])%M;
      pw=(pw*n)%M;
   }
   return ret;
}

LL modexp(LL a,LL b)
{
	if(b==1) return a%M;
	if(b%2) return ((a%M)*modexp(a,b-1))%M;
	LL q=modexp(a,b/2);
	return (q*q)%M;
}


LL inv[maxs+5]; // modular inverse
LL h[maxs+5];  // h(j) = number of ways to choose total j objects from fn objects
LL f[maxs+5][maxs+5]; // f(j,k) = number of ways where currently considering rang=j and total sum of rangs=k
LL g[maxs+5][maxs+5]; //g(j,k)=number of ways to make multiset of size k with exactly j distinct objects

int main()
{
   int i,j,k,T,sumS=0;

   for(i=1;i<=maxs;i++) inv[i]=modexp(i,M-2);

   g[0][0]=1;
   for(i=1;i<=maxs;i++)
      for(j=i;j<=maxs;j++)
         g[i][j]=(g[i][j-1] + g[i-1][j-1])%M;

   scanf("%d",&T);
   assert(T>=1 && T<=maxt);

   while(T--)
   {
      int S;

      for(i=0;i<4;i++)
      {
         scanf("%d",&a[i]);
         assert(a[i]>=0 && a[i]<=1000);
      }
      assert((a[0]+a[1]+a[2]+a[3]));

      scanf("%d",&S);
      assert(S>=1 && S<=maxs);
      sumS+=S;

      MEM(f,0);
      f[0][0]=1;

      for(i=1;i<=S;i++)
      {
         LL fn=F(i),ncr=1;
         MEM(h,0);h[0]=1;

         for(j=1;j<=MIN(S,fn);j++)
         {
            ncr=(ncr*(fn-j+1))%M;
            ncr=(ncr*inv[j])%M;
            for(k=j;k<=S;k++) h[k]=(h[k]+ncr*g[j][k])%M;
         }

         for(k=0;k<=S;k++)
            for(j=0;j*i<=k;j++)
               f[i][k]=(f[i][k]+h[j]*f[i-1][k-j*i])%M;

      }
      cout<<f[S][S]<<endl;
   }

   assert(sumS>=1 && sumS<=500);

	return 0;
}


