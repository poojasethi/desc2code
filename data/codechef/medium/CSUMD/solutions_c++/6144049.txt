//solving recurrence relation with matrix exponentiation

#include<stdio.h>
#include<iostream>
#include<math.h>                      
#include<stdlib.h>
#include<cstdio>
#include<utility>
#include<cstring>
#include<algorithm>
#include<vector>
#define MOD 1000000007
typedef long long ll;
#define FOR(k,a,b) for(typeof(a) k=(a); k < (b); ++k)
const int k=2;

struct matrix {
    int a[3][3];
};

using namespace std;


matrix mul(matrix A,matrix B) // multiply 2 matrices
{  int i,j,m;
	matrix C;
	for(i=0;i<k;i++) for(j=0;j<k;j++)  C.a[i][j]=0;
	
	for(i=0;i<k;i++)
		for(j=0;j<k;j++)
			for(m=0;m<k;m++)  {
	//			C.a[i][j]+=(A.a[i][m]*B.a[m][j])%mod;
		//	C.a[i][j]%=mod;  }
			C.a[i][m] += (A.a[i][j] * ll(B.a[j][m])) % MOD;
			C.a[i][m] %= MOD; }

	return C;
}

matrix pow(matrix A,int p)   // computes A ^ p
{
	if(p==1)  return A;
	if(p%2==1)  return  mul(A,pow(A,p-1));
	 matrix X = pow(A,p/2);
	 return mul(X,X);
}

int main()
{   
    int t,n; 
	matrix M,C,tem,re;
	M.a[0][0]=2;    M.a[0][1]=1;
	M.a[1][0]=2;    M.a[1][1]=0;
	
	C.a[0][0]=3;    C.a[0][1]=1;
	
	scanf("%d",&t);
    while(t--)
    {
		scanf("%d",&n);
		if(n==1)   printf("1\n");
	    else if(n==2) printf("3\n");
	    else {
			    int sec=n-2;
			  tem=pow(M,n-2);
			  re=mul(C,tem);
			  printf("%d\n",re.a[0][0]);
		}	
	}
	return 0;
}