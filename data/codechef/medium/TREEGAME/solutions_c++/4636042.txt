#include <iostream>
#include <vector>
#include <string>
#include <list>
#include<cstdio>
#include <limits> // for numeric_limits
 
#include <set>
#include <utility> // for pair
#include <algorithm>
#include <iterator>
 
 
typedef int vertex_t;
typedef double weight_t;
 
const weight_t max_weight = std::numeric_limits<double>::infinity();
 
struct neighbor {
    vertex_t target;
    weight_t weight;
    neighbor(vertex_t arg_target, weight_t arg_weight)
        : target(arg_target), weight(arg_weight) { }
};
 
typedef std::vector<std::vector<neighbor> > adjacency_list_t;
 
 
void DijkstraComputePaths(vertex_t source,
                          const adjacency_list_t &adjacency_list,
                          std::vector<weight_t> &min_distance,
                          std::vector<vertex_t> &previous)
{
    int n = adjacency_list.size();
    min_distance.clear();
    min_distance.resize(n, max_weight);
    min_distance[source] = 0;
    previous.clear();
    previous.resize(n, -1);
    std::set<std::pair<weight_t, vertex_t> > vertex_queue;
    vertex_queue.insert(std::make_pair(min_distance[source], source));
 
    while (!vertex_queue.empty()) 
    {
        weight_t dist = vertex_queue.begin()->first;
        vertex_t u = vertex_queue.begin()->second;
        vertex_queue.erase(vertex_queue.begin());
 
        // Visit each edge exiting u
	const std::vector<neighbor> &neighbors = adjacency_list[u];
        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();
             neighbor_iter != neighbors.end();
             neighbor_iter++)
        {
            vertex_t v = neighbor_iter->target;
            weight_t weight = neighbor_iter->weight;
            weight_t distance_through_u = dist + weight;
	    if (distance_through_u < min_distance[v]) {
	        vertex_queue.erase(std::make_pair(min_distance[v], v));
 
	        min_distance[v] = distance_through_u;
	        previous[v] = u;
	        vertex_queue.insert(std::make_pair(min_distance[v], v));
 
	    }
 
        }
    }
}
 
 
std::list<vertex_t> DijkstraGetShortestPathTo(
    vertex_t vertex, const std::vector<vertex_t> &previous)
{
    std::list<vertex_t> path;
    for ( ; vertex != -1; vertex = previous[vertex])
        path.push_front(vertex);
    return path;
}
 
int ans[10005],count[10005];

 int partition( int A[], int l, int r)
{
int j,i=l+1,p,t,x,y,z,median;

p=A[l];


for(j=l+1;j<=r;j++)
{
if(A[j]<p)
	{
	t=A[i];
	A[i]=A[j];
	A[j]=t;
	i=i+1;
	}
}
t=A[i-1];
A[i-1]=A[l];
A[l]=t;

return i-1;
}


void quicksort( int A[], int l, int r)
{
 int q;
if(l<r)
{
q=partition(A,l,r);
quicksort(A,l,q-1);
quicksort(A,q+1,r);
}
}


 
int main()
{
    // remember to insert edges both ways for an undirected graph
    int N,M,x,y,i,T;
    
    scanf("%d",&T);
    
    while(T--)
        {
    
    scanf("%d",&N);
    
    for(i=0;i<N;i++)
	count[i]=0;
    
    
    adjacency_list_t adjacency_list(N);
    // 0 = a
    
for(i=0;i<N-1;i++)
    {
        scanf("%d%d",&x,&y);
        x--;
        y--;

            adjacency_list[x].push_back(neighbor(y, 1));
	    adjacency_list[y].push_back(neighbor(x, 1));

    }

 int djikstraroot=0;

    std::vector<weight_t> min_distance;
    std::vector<vertex_t> previous;
    DijkstraComputePaths(djikstraroot, adjacency_list, min_distance, previous);
    for(i=0;i<N;i++)
        {
        ans[i]=min_distance[i];
    //std::cout << min_distance[i] << std::endl;   
   // printf("%d\n",ans[i]);
    }
    
    quicksort(ans,0,N-1);

for(i=0;i<N;i++)
count[ans[i]]++;

        
i=0;
int j=N-1,alicemove=0,bobmove=0;

        while(i<=j)
            {
            while(count[i]==0&&i<N)     //valid index for alice
                i++;
            
            if(i!=N)    
                alicemove++;
            
            while(count[j]==0&&j>i)
                j--;
            
            if(j>i)    //valid index of bob;
                {
                count[j]--; //bob removes a leaf
                bobmove++;
                if(count[j]==0)
                    j--;    //bob moves onto a next leaf;
            }
            
            i++;
                            
        }
       
        
        
        
        
        
        printf("%d\n",alicemove+bobmove);
    }
 
    return 0;
}
