#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>

using namespace std;

const int MAX = 10001;

int main()
{
    bool has_cycle;
    int t; // number of test cases
    int n, m; // |vertex|, |edge|
    int u, v; // src, dst
    int max;
    int indgr[MAX];
    int depth[MAX];
    queue<int> Q;
    vector<vector<int> > adjtbl(MAX);

    // start
    scanf("%d", &t);
    for(int i = 0; i < t; i++)
    {
        // init
        has_cycle = false;
        max = 0;
        memset(indgr, 0, sizeof(int) * MAX);
        memset(depth, 0, sizeof(int) * MAX);
        for (int j = 1; j < MAX; j++)
            adjtbl[j].clear();
        
        // receive input
        scanf("%d%d", &n, &m);
        if (n > 0)
            max = 1;
        for (int j = 0; j < m; j++)
        {
            scanf("%d%d", &u, &v);
            if (u == v)
                has_cycle = true;
            adjtbl[u].push_back(v);
            indgr[v] += 1;
        }

        if (has_cycle)
            goto IMPOSSIBLE;

        // init Q
        for (int j = 1; j <= n; j++)
            if (indgr[j] == 0)
            {
                Q.push(j);
                depth[j] = 1;
            }

        while(!Q.empty())
        {
            u = Q.front(); Q.pop();
            for(vector<int>::iterator itr = adjtbl[u].begin(); 
                    itr !=adjtbl[u].end(); itr++)
            {
                v = *itr;
                if (--indgr[v] == 0)
                {
                    Q.push(v);
                    depth[v] = depth[u] + 1;
                    if (depth[v] > max)
                        max = depth[v];
                }
            }
        }

        for (int j = 1; j <= n; j++)
            if (indgr[j])
                goto IMPOSSIBLE;
        printf("%d\n", max);
        continue;
IMPOSSIBLE:
        printf("IMPOSSIBLE\n");
    }
    return 0;
}

