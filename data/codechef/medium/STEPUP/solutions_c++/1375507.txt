#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <cstdio>
#include <string>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <string.h>
#include <cassert>
#include <limits.h>

using namespace std;

#define GI ({int t; scanf("%d", &t); t;})
#define GL ({long long int t; scanf("%lld", &t); t;})
#define GD ({double t; scanf("%lf", &t); t;})
#define FOR(i, a, b) for(int i = a; i < b; i++)
#define RFOR(i, a, b) for(i = a - 1; i >= b; i--)
#define REP(i, n) FOR(i, 0, n)
#define CLEAR(a, b) memset(a, b, sizeof(a))
#define ALL(v) (v).begin(),(v).end()
#define mp make_pair
#define SE second
#define FI first
#define pb push_back
#define sz size()
#define INF (int)INT_MAX
#define EPS LD(1e-9)
#define DINF LD(1e50)
#define MOD 100000007
#define MAXN 10000

typedef long long LL;
typedef vector <int> VI;
typedef vector <string> VS;
typedef vector <vector <int> > VVI;
typedef pair <int,int> PII;
typedef double LD;

int indegree[MAXN + 1];
bool visited[MAXN + 1];
int dp[MAXN + 1];
set <int> S;
vector <int> V;

void Reset(){
     memset(indegree, 0, sizeof(indegree));
     memset(dp, 0, sizeof(dp));
     memset(visited, 0, sizeof(visited));
     S.clear();
     V.clear();
}

int main(){
    int T, N, M, u, v, maxx;
    
    T = GI;
    
    while(T--){
        maxx = 0;   
        Reset();
            
        N = GI, M = GI;
        
        vector <int> G[N + 1];
        
        for(int i = 1; i <= M; i++){
            u = GI, v = GI;    
            
            G[u].pb(v);
            indegree[v]++;     
        }    
        
        for(int i = 1; i <= N; i++){
            if(indegree[i] == 0) 
               S.insert(i);
        }    
        
        
        while(!S.empty()){
            u = *(S.begin());
            
            visited[u] = true;
            S.erase(S.begin());
            V.pb(u);
            
            for(int i = 0; i < G[u].size(); i++){
                v = G[u][i];    
                indegree[v]--;    
            
                if(!visited[v] && !indegree[v])
                       S.insert(v);  
            }
        } 
        
        if(V.size() != N)    
                    printf("IMPOSSIBLE\n");
        else{
             for(int i = 0; i < V.size(); i++) {
                     u = V[i];
                     for(int j = 0; j < G[u].size(); j++){
                             v = G[u][j];
                             dp[v] = max(dp[v], dp[u] + 1);
                             maxx = max(maxx, dp[v]);
                     }
             }
             printf("%d\n", maxx + 1);
        }
    }
    return 0;
}
