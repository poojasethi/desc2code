#include <algorithm>
#include <iostream>
#include <ctime>
#include <memory.h>
#include <vector>
#include <map>
#include <fstream>
#include <string>
 
using namespace std;
 
int n, k;
 
/*
Main idea: From first k + 2 elementh we can choose two numbers that will not change. Use brute force for first K + 2 numbers. Final solution is O(K ^ 2 * N).
* You can think about O(N * K) solution - it is quite easy :)
*/ 
 
void solve() {
	scanf("%d%d",&n,&k);
	vector<int> a(n);
	map < pair <long long, long long>, bool> f;
	for (int i = 0; i < n; ++i)
		scanf("%d",&a[i]);
	int ans = 0;
	long long E, Q, Fir;
	long long aF = 1000000000000000LL, sF = -1;
	for (int i = 0; i < k + 2; ++i)
		for (int j = i + 1; j < k + 2; ++j){
			// choose first and second number that will not change
			E = a[j] - a[i];
			Q = E / (j - i);
			// calculate d - (Ai = A0 + i * d)
			if (Q * (j - i) == E) {
				Fir = a[i] - Q * i;
				// check is it new pair --- Fir = A0, Q = d
				if (f[make_pair(Fir, Q)] == false) {
					f[make_pair(Fir, Q)] = true;
					// chK - number of error that can do
					int chK = k;
					for (int qt = 0; qt < n; ++qt) {
						if (Fir != a[qt]) chK--;
						if (chK < 0) break;
						Fir += Q;
					}
					if (chK >= 0) {
						// checking this sequence for beauty
						Fir = a[i] - Q * i;
						if (Fir < aF || (Fir == aF && sF > Q)) {
							aF = Fir;
							sF = Q;
						}
					}
				}
			}
		}
	if (aF > 1000000000000LL) printf("-1\n");
	else {
		// printing this sequence
		for (int i = 0; i < n; ++i) {
			printf("%lld ", aF);
			aF += sF;
		}
		printf("\n");
	}
}
 
int main(){
	solve();
	return 0;
}
 
