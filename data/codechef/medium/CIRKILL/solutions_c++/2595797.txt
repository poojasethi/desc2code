/***********Template Starts Here***********/
#pragma comment (linker,"/STACK:16777216")
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <vector>
#include <deque>
#include <functional>
#include <string>
#include <iostream>
#include <cctype>

#define pb push_back
#define nl puts ("")
#define sp printf ( " " )
#define phl printf ( "hello\n" )
#define all(c) (c).begin(),(c).end()
#define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define sz(a) int((a).size())

using namespace std;

typedef long long vlong;
typedef unsigned long long uvlong;
typedef vector < int > vi;
typedef pair < int, int > ii;
typedef vector < ii > vii;


const vlong inf = 2147383647;
const double pi = 2 * acos ( 0.0 );
const double eps = 1e-9;
const vlong maxint = 2147483647;
const vlong minint = -2147483648;

/***********Template Ends Here***********/

struct vec {
    double i, j;

    vec operator * ( const double b ) {
        vec res;
        res.i = i * b;
        res.j = j * b;
        return res;
    }
    double operator * ( const vec b ) {
        return i * b.i + j * b.j;
    }
    double operator ^ ( const vec b ) {
        return ( i * b.j - b.i * j );
    }
    vec operator + ( const vec b ) {
        vec res;
        res.i = i + b.i;
        res.j = j + b.j;
        return res;
    }
    vec operator - ( const vec b ) {
        vec res;
        res.i = i - b.i;
        res.j = j - b.j;
        return res;
    }
    vec perp() {
        vec res;
        res.i = -j;
        res.j = i;
        return res;
    }
} tv;
vector < vec > vp;

struct line {
    vec a, v;

    line make_line ( vec a, vec b ) {
        line r;
        r.a = a;
        r.v = b - a;
        return r;
    }
}A, B;


bool check ( int a, int b, int c ) {
    //Create a triangle with 3 points
    //Create 2 lines, a-b, a-c
    A = A.make_line( vp[a], vp[b] );
    B = B.make_line( vp[a], vp[c] );

    if ( ( A.v ^ B.v ) == 0 ) //Area 0
        return false;

    return true;
}

struct circle {
    vec cen;
    double rad;
}center, c2;


void intersection ( line a, line b, double &s, double &t ) {
    vec w = a.a - b.a;

    vec vp = b.v.perp();
    vec up = a.v.perp();

    s = -( w * vp ) / ( vp * a.v );
    t = ( w * up ) / ( up * b.v );
}

void create_circle () { //Using A, B find center and radius
    //Create perpendicular of A
    line PA, PB;
    PA.a = A.a + ( A.v * 0.5 );
    PA.v = A.v.perp();
    PB.a = B.a + ( B.v * 0.5 );
    PB.v = B.v.perp();

    //Now intersect the two lines
    double s, t;
    intersection ( PA, PB, s, t );


    center.cen = PA.a + ( PA.v * s );

    vec AC;
    AC = center.cen - A.a;
    center.rad = AC * AC;
}

//struct compare {
//    bool operator () ( const circle &a, const circle &b ) {
//        if ( a.cen.i + eps < b.cen.i ) return true;
//        else if ( fabs ( a.cen.i - b.cen.i ) <= eps && a.cen.j + eps < b.cen.j ) return true;
//        else if ( fabs ( a.cen.i - b.cen.i ) <= eps && fabs ( a.cen.j - b.cen.j ) <= eps && a.rad + eps < b.rad ) return true;
//        else return false;
//    }
//};

circle all[35][35][35];
bool possible[35][35][35];

int main () {
    //freopen ( "input.txt", "r", stdin );
    //freopen ( "output.txt", "w", stdout );
    int kase;
    scanf ( "%d", &kase );
    while ( kase-- ) {
        vp.clear();
        memset ( possible, 0, sizeof possible );

        int n;
        scanf ( "%d", &n );

        int i, j, k;
        for ( i = 0; i < n; i++ ) {
            scanf ( "%lf %lf", &tv.i, &tv.j );
            vp.pb ( tv );
        }

        for ( i = 0; i < n; i++ ) {
            for ( j = i + 1; j < n; j++ ) {
                for ( k = j + 1; k < n; k++ ) {
                    //Check if proper triangle
                    possible[i][j][k] = check( i, j, k );
                    if ( possible[i][j][k] == false ) continue;
                    create_circle();
                    all[i][j][k] = center;

                }
            }
        }

        int ash;
        int total = 0;
        int death = 0;
        for ( i = 0; i < n; i++ ) {
            for ( j = i + 1; j < n; j++ ) {
                for ( k = j + 1; k < n; k++ ) {
                    if ( possible[i][j][k] == false ) {
                        total += n - 3;
                        continue; //No circle possible
                    }

                    center = all[i][j][k];
                    //printf ( "%d %d %d %lf %lf %lf\n", i, j, k, center.cen.i, center.cen.j, center.rad );

                    //If possible, try all possible ways to put ash
                    for ( ash = 0; ash < n; ash++ ) {
                        if ( ash == i || ash == j || ash == k ) continue;
                        total++;
                        vec dish = all[i][j][k].cen - vp[ash];
                        double dist = dish * dish;
                        //printf ( "%lf %lf\n", dist, all[i][j][k].rad );
                        if ( dist < all[i][j][k].rad + eps ) death++;
                    }
                }
            }
        }

        printf ( "%.10lf\n", death / ( total * 1.0 ) );
    }

    return 0;
}
