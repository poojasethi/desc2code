#include<iostream>
#include<vector>
#include<math.h>
#include<iomanip>
using namespace std;
long double circum_x,circum_y;
vector<long double> x(51,0.00000000),y(51,0.00000000);
int colinear(int i, int j, int k)
{
    long double Ax,Ay,Bx,By,Cx,Cy,s,a,b,c;
    Ax=x[i]; Ay=y[i];   
    Bx=x[j]; By=y[j];   
    Cx=x[k]; Cy=y[k];   
    
    a=sqrt((Ax-Bx)*(Ax-Bx)*1.0000000000 + (Ay-By)*(Ay-By)*1.0000000000);    //AB
    b=sqrt((Bx-Cx)*(Bx-Cx)*1.0000000000 + (By-Cy)*(By-Cy)*1.0000000000);    //BC
    c=sqrt((Cx-Ax)*(Cx-Ax)*1.0000000000 + (Cy-Ay)*(Cy-Ay)*1.0000000000);    //CA
    
    s=(a+b+c)/(2.0000000000000000);
    
    if(s*(s-a)*(s-b)*(s-c)<0.0000001)
     return 1;
return 0;    
}    
void findcircum(int i, int j, int k)
{
     long double Ax,Ay,Bx,By,Cx,Cy,D;
     Ax=x[i]; Ay=y[i];   //P=(a,b)
     Bx=x[j]; By=y[j];   //Q=(c,d)
     Cx=x[k]; Cy=y[k];   //R=(e,f)
     
     D=(2.00000000000000000)*( Ax*(By-Cy) + Bx*(Cy-Ay) + Cx*(Ay-By) );
      
     circum_x = ((Ax*Ax + Ay*Ay)*(By-Cy)*1.0000000000 + (Bx*Bx + By*By)*(Cy-Ay)*1.0000000000 + (Cx*Cx + Cy*Cy)*(Ay-By)*1.000000000)/(D*1.0000000000);
     circum_y = ((Ax*Ax + Ay*Ay)*(Cx-Bx)*1.0000000000 + (Bx*Bx + By*By)*(Ax-Cx)*1.0000000000 + (Cx*Cx + Cy*Cy)*(Bx-Ax)*1.0000000000)/(D*1.0000000000);
     
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
       x.clear(); y.clear();
       int i,j,k,l,n,count=0,tot=0;
       long double dist,rad,ans;
       cin>>n;
       for(i=0;i<n;i++)
        cin>>x[i]>>y[i];
        
       for(i=0;i<n;i++)
       {
          for(j=i+1;j<n;j++)
          {
             for(k=j+1;k<n;k++)
             {                              
                for(l=0;l<n;l++)
                {
                   if(l==i || l==j || l==k)
                     continue;
                   if(!colinear(i,j,k))
                   {
                                                             
                      findcircum(i,j,k);
                      rad = ((x[i]-circum_x)*(x[i]-circum_x)*1.0000000000+(y[i]-circum_y)*(y[i]-circum_y)*1.0000000000);
                      dist = ((x[l]-circum_x)*(x[l]-circum_x)*1.0000000000+(y[l]-circum_y)*(y[l]-circum_y)*1.0000000000);
                      if(dist<=rad+0.0000001)
                       {
                           count++;
                       }
                      else
                      {                        
                           tot++; 
                      }
                   }                
                  else
                  {
                     tot++;  
                  }
                }           
             }
          }
       }
       ans=(count*1.000000000000000)/(count+tot);
       cout<<setprecision(10)<<ans<<endl;
    }
return 0;
}
