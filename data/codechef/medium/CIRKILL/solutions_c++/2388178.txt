//dinesh verma ,mca III yr, iit roorkee

#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
#include<iomanip>
#include <complex>
#include <cstdlib>
#include <limits>
#define MAX 4
#include<cstdio>
using namespace std;

const double len_before_point_digits = 1E10;
const double epsLen = numeric_limits<double>::epsilon() * len_before_point_digits;


struct cordinate
{
   int x;
    int y;
};


int det(int a[][3])
{
return (a[0][0]*((a[1][1]*a[2][2]) - (a[2][1]*a[1][2])) -a[0][1]*(a[1][0]*a[2][2] - a[2][0]*a[1][2]) + a[0][2]*(a[1][0]*a[2][1] - a[2][0]*a[1][1]));
}
int aa,da,ea,fa;

int chk(int x,int y)
{
if(aa>0){
if((aa*(x*x+y*y)+da*x+ea*y+fa)<=0)
return 1;
return 0;}
else{
if((aa*(x*x+y*y)+da*x+ea*y+fa)>=0)
return 1;
return 0;
}
}



template <typename Iterator>
inline bool next_combination(const Iterator first, Iterator k, const Iterator last)
{
   if ((first == last) || (first == k) || (last == k))
      return false;
   Iterator itr1 = first;
   Iterator itr2 = last;
   ++itr1;
   if (last == itr1)
      return false;
   itr1 = last;
   --itr1;
   itr1 = k;
   --itr2;
   while (first != itr1)
   {
      if (*--itr1 < *itr2)
      {
         Iterator j = k;
         while (!(*itr1 < *j)) ++j;
         std::iter_swap(itr1,j);
         ++itr1;
         ++j;
         itr2 = k;
         std::rotate(itr1,j,last);
         while (last != j)
         {
            ++j;
            ++itr2;
         }
         std::rotate(k,itr2,last);
         return true;
      }
   }
   std::rotate(first,k,last);
   return false;
}


int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        struct cordinate tile[n];
        int i;
        for(i=0;i<n;i++)
        {cin>>tile[i].x>>tile[i].y;}


    std::size_t p=n;
    std::size_t k=3;
    std::vector<int> ints;

    for (int i = 0; i < n; ints.push_back(i++));


   int ax,bx,cx,ay,by,cy;
   int ycount=0,total=(n*(n-1)*(n-2)*(n-3))/6,ncount=0;
   double area,prob;
do
{
   ax=tile[ints[0]].x;
   bx=tile[ints[1]].x;
   cx=tile[ints[2]].x;

   ay=tile[ints[0]].y;
   by=tile[ints[1]].y;
   cy=tile[ints[2]].y;
 // cout<<"\n "<<ax<<":"<<ay<<", "<<bx<<":"<<by<<","<<cx<<":"<<cy<<endl;
  area=0.5*(ax*(by-cy)+bx*(cy-ay)+cx*(ay-by));
  //cout<<"\n area"<<area<<endl;
  if(area==0.0)
      {  ncount=ncount+(n-3);
         //cout<<"\n nc- :"<<ncount<<endl;   // collinear case
      }
  else
   {
      int a1[3][3]={{ax,ay,1},{bx,by,1},{cx,cy,1}};
      aa=det(a1);

      int a[3][3]={ax*ax+ay*ay,ay,1,bx*bx+by*by,by,1,cx*cx+cy*cy,cy,1};
      da=-1*det(a);
      a[0][1]=ax;
      a[1][1]=bx;
      a[2][1]=cx;
      ea=det(a);
      a[0][2]=ay;
      a[1][2]=by;
      a[2][2]=cy;
      fa=-1*det(a);

       for(int i=0;i<n;i++)
           {
              long double e,f;
              e=tile[i].x;
              f=tile[i].y;
              if(!( ((e==ax)&&(f==ay)) || ((e==bx)&&(f==by)) || ((e==cx)&&(f==cy))))
                {
                    if(chk(e,f))
                    {ycount++;
                    // cout<<"point"<<e<<" , "<<f<<" and"<<"yc : "<<ycount;
                    }
                }
                }
      }

}while(next_combination(ints.begin(),ints.begin() + k,ints.end()));
prob=(ycount)/(long double)total;
//cout<<"\n ncount "<<ncount<<" ycount"<<ycount<<" \n prob "<<fixed<<setprecision(16)<<prob<<endl;
printf("\n %.20g \n",prob);
}
return 0;
}


