#include<cstdio>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include  "vector"
#include  "stack"
#include "queue"
#define max 10001
#define swap(x,y,t) {	t = x; x = y; y = t;	}

using namespace std;

vector<int> input[max];
int parent[max];
bool save[max],exists[max],visited[max];
int n,s,t;

void makeTree(){
	int i,k,top,temp;
	for(i=1;i<=n;i++)	visited[i]=false;
	queue<int> q;
	q.push(s);
	visited[s] = true;
	while(!q.empty()){
		top = q.front();
		i=1;k = input[top][0];
		while(i <= k){
			if(visited[input[top][i]]){
				swap(input[top][i],input[top][k],temp);
				k--;
				input[top][0]--;
			}
			else{
				q.push(input[top][i]);
				visited[input[top][i]] = true;
				i++;
			}
		}
		q.pop();
	}
}

void runDFS(){
	stack<int> st;int i,top,temp;
	st.push(s);
	for(i=1;i<=n;i++)	visited[i]=false;
	while(!st.empty()){
		top = st.top();
		if(!visited[top]){
			if(save[top]){
				exists[top] = false;
				visited[top]=true;
				st.pop();
			}
			else if(input[top][0] == 0){
				exists[top]=true;
				visited[top]=true;
				st.pop();
			}
			else if(input[top][0] == 1){
				exists[top] = true;
				st.pop();
				visited[top]=true;
			}
			else{
				if(!visited[input[top][1]])	st.push(input[top][1]);
				else{
					st.push(input[top][2]);
					visited[top]=true;
				}
			}
		}
		else{
			exists[top] = exists[input[top][1]] || exists[input[top][2]];
			st.pop(); 
		}
	}
}

//

class FastInput {
	public:
		FastInput() {
			m_dataOffset = 0;
			m_dataSize = 0;
			m_v = 0x80000000;
		}
		uint32_t ReadNext() {
			if (m_dataOffset == m_dataSize) {
				int r = read(0, m_buffer, sizeof(m_buffer));
				if (r <= 0) return m_v;
				m_dataOffset = 0;
				m_dataSize = 0;
				int i = 0;
				if (m_buffer[0] < '0') {
					if (m_v != 0x80000000) {
						m_data[m_dataSize++] = m_v;
						m_v = 0x80000000;
					}
					for (; (i < r) && (m_buffer[i] < '0'); ++i);
				}
				for (; i < r;) {
					if (m_buffer[i] >= '0') {
						m_v = m_v * 10 + m_buffer[i] - 48;
						++i;
					} else {
						m_data[m_dataSize++] = m_v;
						m_v = 0x80000000;
						for (i = i + 1; (i < r) && (m_buffer[i] < '0'); ++i);
					}
				}
			}
			return m_data[m_dataOffset++];
		}
	public:
		uint8_t m_buffer[32768];
		uint32_t m_data[16384];
		size_t m_dataOffset, m_dataSize;
		uint32_t m_v;
};
class FastOutput {
	public:
		FastOutput() {
			m_dataOffset = 0;
		}
		~FastOutput() {
		}
		void Flush() {
			if (m_dataOffset) {
				if (write(1, m_data, m_dataOffset));
				m_dataOffset = 0;
			}
		}
		void PrintChar(char d) {
			if (m_dataOffset + 1 > sizeof(m_data)) Flush();
			m_data[m_dataOffset++] = d;
		}
		void ReplaceChar(int offset, char d) {
			m_data[m_dataOffset + offset] = d;
		}
	public:
		uint8_t m_data[32768];
		size_t m_dataOffset;
};
 
FastInput in;
FastOutput out;

//

int main(){
	int T,temp;
	T = in.ReadNext();
	while(T--){
		n = in.ReadNext();
		s = in.ReadNext();
		t = in.ReadNext();
		for(int i=1;i<=n;i++){
			temp = in.ReadNext();
			input[i].resize(0);
			input[i].push_back(0);
			while(temp--){
				input[i][0]++;
				input[i].push_back(in.ReadNext());
			}
		}
		for(int i=1;i<=n;i++) 	save[i]=false;
		for(int i=0;i<t;i++){	save[in.ReadNext()]=true;	}
		makeTree();
		runDFS();
		/*for(int i=1;i<=n;i++){
			for(int j=0;j<=input[i][0];j++)	printf("%d  ",input[i][j]);
			printf("\n");
		}*/
		
		if(exists[s]){
			out.PrintChar('y');
			out.PrintChar('e');
			out.PrintChar('s');
			out.PrintChar('\n');
		}
		else{
			out.PrintChar('n');
			out.PrintChar('o');
			out.PrintChar('\n');
		}
		//for(int i=1;i<=n;i++) 		if(exists[i])		printf("yes ");  else printf("no ");
		//printf("\n");
	}
	out.Flush();
	return 0;
}