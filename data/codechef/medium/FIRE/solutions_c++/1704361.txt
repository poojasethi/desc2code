#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

const int maxN = 10005;//maximum number of brushes

int n;//number of bushes indexed 1 to n
int s;//index of bush initially on fire
int t;//number of bushes to save

int savebush[maxN];//list of bushes to be saved
bool visited[maxN];//to help build tree
int connect[maxN][3];//captures close enough relation

struct node;
node *addnode(int x);
void addleftch(node* n, int x);
void addrightch(node* n, int x);
void init();
void buildtree(node* r);
bool bsearch(int p[], int s, int x);
bool protect(node *v);


int main()
{
    int T;
    scanf("%d", &T);
    while(T--)
    {

    int c;//number of bushes close (0<=c<=3)
    int bush;//a bush
    scanf("%d%d%d", &n, &s, &t);
    init();
    //get in closeness relations
    for(int i=1; i<=n; i++)
    {
        scanf("%d", &c);
        for(int j=0; j<c; j++)
        {
            scanf("%d", &bush);
            connect[i][j] = bush;
        }
    }
    //take in list of bushes to be saved
    for(int i=0; i<t; i++)
    scanf("%d", savebush+i);

    //build the tree
    node *root;
    root = addnode(s);
    visited[s] = 1;
    buildtree(root);

    //sort to allow binary search to easily find if a bush is special or not
    sort(savebush, savebush + t);

    //final answer
    printf("%s\n", !protect(root)?"no":"yes");

    }
}
//For a Tree
struct node
{
    int bushindex;
    node* left;
    node* right;
};

node* addnode(int x)
{
    node* tmp;
    tmp = new node;
    tmp->bushindex = x;
    tmp->left = NULL;
    tmp->right = NULL;
    return tmp;
}
void addleftch(node* n, int x)
{
    if(n == NULL)return;
    else
    n->left = addnode(x);
}
void addrightch(node* n, int x)
{
    if(n == NULL)return;
    else
    n->right = addnode(x);
}

void buildtree(node* root)
{
int i= root->bushindex, j=0;
while ((connect[i][j]==0 || visited[connect[i][j]] == 1) && j<3)j++;

//Add left child
if(j<3)
{
  addleftch(root, connect[i][j]);
  visited[connect[i][j]] = 1;
  buildtree(root->left);
}
 while ((connect[i][j]==0 || visited[connect[i][j]] == 1) && j<3)j++;

//Add right child
if(j<3)
{
  addrightch(root, connect[i][j]);
  visited[connect[i][j]] = 1;
  buildtree(root->right);
 }
 return;
}

//for initialization
void init()
{
    for(int i=1; i<=n; i++)
    visited[i] = 0;

    for(int i=1; i<=n; i++)
    for(int j=0; j<3; j++)
    connect[i][j] = 0;

}
//to find if a bush is special
bool bsearch(int p[], int size, int x)
{
    int low = 0;
    int high = size-1;
    while(low<=high)
    {
        int mid = (low+high)/2;
        if(p[mid] == x)return 1;
        if(p[mid]>x) high = mid-1;
        else
        low = mid+1;

    }
    return 0;
}
//can we protect special bushes which are connected to bush v and bush v is on fire?
bool protect(node *v)
{
    if(bsearch(savebush, t, v->bushindex)== 1) //bush v is itself special so cant
    return 0;
    if(v->right == NULL)return 1; //at most one bush connected so can easily protect that bush and stop spread :D
    return (protect(v->left)|protect(v->right));//at most one connected bush should be in need of protection. Cannot protect both!
}

