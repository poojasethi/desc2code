#include<iostream>
#include<queue>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<string>
#include<cstring>
#include<bitset>
#include<map>
#include<numeric>
#include<sstream>
#include<cmath>
using namespace std;
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define pb push_back
#define f(i,x,y) for(int i = x; i<y; i++)
#define FOR(it,A) for(typeof A.begin() it = A.begin(); it!= A.end(); it++)
#define quad(x) (x) * (x)
#define mp make_pair
#define clr(x, y) memset(x, y, sizeof x)
#define fst first
#define snd second
typedef pair<int, int> pii;
typedef long long ll;
typedef long double ld;
#define inf (1 << 28)
int t, n;
char s[2001];
ll G[1002][1002][2][2];
int C[1002][1002][2][2], caso;
char L[1002], R[1002];
ll mod = 1000000007;
 
ll G2[1002][1002];
int LL[1002];
bool islucky(int n){
     int &res = LL[n];
     if(res >= 0) return res;
     res = true;
     do{
         int d = n % 10;
         n /= 10;
         res &= d == 4 || d == 7;
     }while(n);     
     return res;
}
ll g2(int pos, int van){
    if(pos == -1) return islucky(van);
    ll &res = G2[pos][van];
    if(res >= 0) return res;
    res = 2 * g2(pos - 1, van + 1) + 8 * g2(pos - 1, van);
    return res %= mod;
}   
 
ll g(int pos, int van, int pre, int suf){
       if(!pre && !suf) return g2(pos, van);
       if(pos == -1) return islucky(van);
       ll &res = G[pos][van][pre][suf];
       int &c = C[pos][van][pre][suf];
       if(c == caso) return res;
       res = 0; c = caso;
       int l = pre ? L[pos] : 0;
       int r = suf ? R[pos] : 9;
       f(i, l, r + 1){
            int nvan = van + (i == 4 || i == 7);
            res += g(pos - 1, nvan, pre && l == i, suf && r == i);
       }
       return res %= mod;
}
int main(){
    scanf("%d", &t);
    clr(C, -1); caso = 0; clr(G2, -1); clr(LL, -1);
    while(t--){
               caso++;
               clr(L, 0); clr(R, 0);
               scanf("%s", L);
               scanf("%s", R);
               int na = strlen(L);
               f(i, 0, na) L[i] -= '0';
               reverse(L, L + na);
               int nb = strlen(R);
               f(i, 0, nb) R[i] -= '0';
               reverse(R, R + nb);
               n = max(na, nb);
               cout << g(n - 1, 0, true, true) << endl;
    }
}