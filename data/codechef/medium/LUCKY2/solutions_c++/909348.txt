#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <sstream>
#include <set>
#include <map>
#include <queue>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <ctime>
 
#define MOD 1000000007
 
using namespace std;

int dp[1005][1005][2];
char L[1005], R[1005];

bool isLucky(int n)
{
	if(n == 0) return 0;
	
	while(n > 0)
	{
		int k = n % 10;
		if(k != 4 && k != 7) return 0;
		else n = n / 10;
	}
	return 1;
}

int getCnt(char *s)
{
	int T = strlen(s), cnt = 0;
	for(int i=0; i<T; i++)
		if(s[i] == '4' || s[i] == '7')
			cnt++;
	return cnt;
}
 
int f(char *s)
{
	int T = strlen(s);
	
	for(int i=T; i>=0; i--)
	{
		for(int k=0; k<=777; k++)
		{
			if(i == T) dp[i][k][0] = dp[i][k][1] = (k ? 0 : 1);
			else if (k > T-i) dp[i][k][0] = dp[i][k][1] = 0;
			else
			{
				dp[i][k][0] = (8LL*dp[i+1][k][0] + (k ? 2LL*dp[i+1][k-1][0]: 0LL)) % MOD;
				
				long long n1 = s[i] - '0';
				long long n2 = (int)(4 < n1) + (int)(7 < n1);
				
				dp[i][k][1] = ((n1-n2)*dp[i+1][k][0] + (k ? n2*dp[i+1][k-1][0] : 0)) % MOD;
				
				if(n1 == 4 || n1 == 7) dp[i][k][1] = (dp[i][k][1] + (k ? dp[i+1][k-1][1] : 0))%MOD;
				else dp[i][k][1] = (dp[i][k][1] + dp[i+1][k][1]) % MOD;
				/*
				for(int d=0; d<=9; d++)
				{
					if(d != 4 && d != 7)
					{
						if(d < s[i] - '0') dp[i][k][1] += dp[i+1][k][0];
						else if(d == s[i] - '0') dp[i][k][1] += dp[i+1][k][1];
					}
					else if(k)
					{
						if(d < s[i] - '0') dp[i][k][1] += dp[i+1][k-1][0];
						else if(d == s[i] - '0') dp[i][k][1] += dp[i+1][k-1][1];
					}
					
					if(dp[i][k][1] >= MOD) dp[i][k][1] -= MOD;
				}
				*/
			}
		}
	}
	
	int ans = 0;
	for(int i=1; i<=1001; i++)
		if(isLucky(i))
			ans = (ans + dp[0][i][1]) % MOD;
	return ans;
}
 
int main()
{
	int T;
	scanf("%d", &T);
	
	for(int caso=0; caso<T; caso++)
	{
		scanf("%s %s", L, R);
		
		printf("%d\n", (MOD + f(R) - f(L) + isLucky(getCnt(L))) % MOD);
	}
	
	return 0;
}