// arr[i] = max(arr[i-1],arr[j] + val[i]); // boundary values inclusive.
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

struct node {
    int startTime;
    int endTime;
    int profitValue;
};

bool comp(node a, node b)   {
    return (a.endTime < b.endTime);
}

int indexOfJustSmaller(node arr[], int n)   {

    int value = arr[n].startTime;
    if(arr[0].endTime > value)return -1;

    int index = 0;
    int lo = 0;
    int hi = n-1;
    while(lo <= hi) {
        int mid = lo + (hi-lo)/2;
        if(arr[mid].endTime > value)hi = mid - 1;
        else if(arr[mid].endTime <= value){index = mid;lo = mid + 1;}
    }

    return index;
}

int main()  {

    int t,n;
    scanf("%d",&t);
    while(t--)  {
        scanf("%d",&n);
        node arr[n];
        int answer[n];

        for(int i = 0 ; i < n ; ++i)scanf("%d %d %d",&arr[i].startTime,&arr[i].endTime,&arr[i].profitValue);

        sort(arr,arr+n,comp);

        answer[0] = arr[0].profitValue;
        for(int i = 1; i < n ; ++i) {
            int j = indexOfJustSmaller(arr,i);

            if(j == -1) {
                answer[i] = max(answer[i-1],arr[i].profitValue);
            }
            else    {
                answer[i] = max(answer[i-1],answer[j] + arr[i].profitValue);
            }
        }

        printf("%d\n",answer[n-1]);
    }
    return 0;
}
