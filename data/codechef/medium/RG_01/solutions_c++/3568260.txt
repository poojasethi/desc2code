#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>

#define MAXN 1100
#define INF 1234567890

#define X first
#define Y second
#define mp make_pair
#define pb push_back

using namespace std;

typedef pair< int, int > pii;
typedef pair< int, pii > edge;

vector< pii > T[ MAXN + 1 ];
vector< edge > E;

int par[ MAXN + 1 ], rank[ MAXN + 1 ];
int cost[ MAXN + 1 ][ MAXN + 1 ];

int find( int u )
{
	if( par[ u ] == u ) return par[ u ];
	return par[ u ] = find( par[ u ] );
}

void Union( int u, int v )
{
	u = find( u );
	v = find( v );
	if( rank[ u ] > rank[ v ] ) par[ v ] = u;
	else {
		par[ u ] = v;
		if( rank[ u ] == rank[ v ] ) rank[ v ]++;
	}
}

void dfs( int s, int u, int minw, int p )
{
	if( s != u ) cost[ s ][ u ] = minw;
	for( int i = 0; i < T[ u ].size(); i++ ) {
		int v = T[ u ][ i ].X, w = T[ u ][ i ].Y;
		if( v == p ) continue;
		dfs( s, v, min( minw, w ), u );
	}
}

int main( void )
{
	int N, M, u, v, w;
	scanf("%d%d", &N, &M );
	for( int i = 0; i < N; i++ ) {
		rank[ i ] = 1;
		par[ i ] = i;
	}
	for( int i = 0; i < M; i++ ) {
		scanf("%d%d%d", &u, &v, &w );
		E.pb( mp( w, mp( u, v ) ) );
	}
	sort( E.begin(), E.end() );
	for( int i = M - 1; i >= 0; i-- ) {
		int u = E[ i ].Y.X, v = E[ i ].Y.Y, w = E[ i ].X;
		if( find( u ) != find( v ) ) {
			T[ u ].pb( mp( v, w ) );
			T[ v ].pb( mp( u, w ) );
			Union( u, v );
		}
	}
	for( int i = 0; i < N; i++ ) dfs( i, i, INF, -1 );
	for( int i = 0; i < N; i++ ) {
		for( int j = 0; j < N; j++ ) {
			printf("%d", cost[ i ][ j ] );
			if( j < N - 1 ) printf(" ");
		}
		printf("\n");
	}
	return 0;
}
