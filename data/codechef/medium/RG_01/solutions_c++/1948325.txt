#pragma warning ( disable : 4786)
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdio>
using namespace std;
 
#define All(X) X.begin(),X.end()
#define For(i, s, n) for(int i=s; i<=n; i++)
#define Rep(i, n) for(int i=0; i<n; i++)
#define Clr(arr) memset(arr, 0, sizeof(arr))
#define Slr(arr) memset(arr, -1, sizeof(arr))
#define Co continue
#define Re return
#define Sf scanf
#define Pf printf
#define Ss stringstream
#define Ox 2147483647
#define Pi (2.0*acos(0.0))
#define Eps (1e-9)
 
int outland[1001][1001];
int land[1001][1001];
 
vector< pair < int, pair< int, int > > > Edges;
 
int KST_findForest(int *_pForest, int u) {
    while(_pForest[u] != u) {
        u = _pForest[u];
    }
    Re u;
}
void KST_union(int *_pForest, int pu, int pv) {
    _pForest[pu] = min(pu, pv);
    _pForest[pv] = _pForest[pu];
}
vector< vector< int > > KSpaningTree(int V, vector< pair < int, pair <int, int> > > &edges){
    int * _pForest = new int[V];
    vector< vector<int> > adjList(V);
    
    Rep(i, V) {
        _pForest[i] = i;
    }
    int u, v, pU, pV;
    Rep(i, edges.size()) {
        u = edges[i].second.first;
        v = edges[i].second.second;
        pU = KST_findForest(_pForest, u);
        pV = KST_findForest(_pForest, v);
        if (pU != pV) {
            KST_union(_pForest, pU, pV);
            adjList[u].push_back(v);
            adjList[v].push_back(u);
        }
    }
    delete _pForest;
    Re adjList;
}
 
bool comp(pair<int, pair<int, int> > a, pair<int, pair<int, int> > b) {
    Re a.first > b.first;
}
 
struct node{
    int u, p, w;
};
 
void bfs(int u, vector<vector<int> >&adjList) {
    queue<node> que;
    node a, b;
    a.u = u;
    a.p = -1;
    a.w = Ox;
    que.push(a);
    
    int d;
    while(!que.empty()) {
        b = que.front();
        outland[u][b.u] = outland[b.u][u] = b.w;
        que.pop();
        Rep(i, adjList[b.u].size()) {
            d = adjList[b.u][i];
            if (d != b.p) {
                a.u = d;
                a.p = b.u;
                a.w = min(b.w, land[b.u][d]);
                que.push(a);
            }
        }
    }
}
int main() {
    int V, E, u, v, w;
    Sf("%d %d", &V, &E);
    //Slr(outland);
    Rep(i, E) {
        Sf("%d %d %d", &u, &v, &w);
        land[u][v] = land[v][u] = w;
        pair<int, int> p1(u,v);
        pair<int, pair<int, int> > p(w, p1);
        Edges.push_back(p);
    }
    sort(All(Edges), comp);
    vector<vector<int> > adjList = KSpaningTree(V, Edges);
    Rep(i, V) {
        bfs(i, adjList);
    }
    Rep(i, V) {
        Rep(j, V) {
            if (j>0) Pf(" ");
            if (i==j) Pf("0");
            else Pf("%d", outland[i][j]);
        }
        Pf("\n");
    }
    //Pf("%d\n",I);
    
    Re 0;
}