#include <cstdio>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

struct QEntry {
	QEntry(int from, int to, int weight)
		: from(from), to(to), weight(weight) {}
	int from;
	int to;
	int weight;
	bool operator<(const QEntry & other) const {
		return weight < other.weight;
	}
};

void bfs(const vector<vector<int> > &g, const vector<vector<int> > &ws, int n, int start, vector<vector<int> > &r) {
	queue<int> q;
	vector<char> vis(n);
	vector<int> mins(n);
	mins[start] = (1 << 30);
	q.push(start);
	vis[start] = 1;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		int s = (int)g[u].size();
		for (int i = 0; i < s; ++i) {
			int v = g[u][i];
			if (u == v) continue;
			if (!vis[v]) {
				mins[v] = min(mins[u], ws[u][i]);
				vis[v] = 1;
				q.push(v);
			}
		}
	}
	mins[start] = 0;
	for (int i = 0; i < n; ++i) {
		r[start][i] = mins[i];
	}
}

void maxst(const vector<vector<int> > &g, const vector<vector<int> > &ws, int n) {
	priority_queue<QEntry> pq;
	vector<char> vis(n);
	pq.push(QEntry(0, 0, 0));
	vector<vector<int> > t(n);
	vector<vector<int> > tw(n);
	int stop = 0;
	while (!pq.empty()) {
		QEntry u = pq.top();
		pq.pop();
		if (!vis[u.to]) {
			vis[u.to] = 1;
			if (u.from != u.to) {
				t[u.from].push_back(u.to);
				tw[u.from].push_back(u.weight);
				t[u.to].push_back(u.from);
				tw[u.to].push_back(u.weight);
			}
			++stop;
			if (stop == n) break;
			int s = (int)g[u.to].size();
			for (int i = 0; i < s; ++i) {
				int v = g[u.to][i];
				int w = ws[u.to][i];
				if (!vis[v]) {
					pq.push(QEntry(u.to, v, w));
				}
			}
		}
	}
//	for (int i = 0; i < n; ++i) {
//		int s = (int)t[i].size();
//		for (int j = 0; j < s; ++j) {
//			printf("%d --(%d)--> %d\n", i, tw[i][j], t[i][j]);
//		}
//	}
	vector<vector<int> > results(n);
	for (int i = 0; i < n; ++i)
		results[i].assign(n, 0);
	for (int i = 0; i < n; ++i) {
		bfs(t, tw, n, i, results);
	}
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (j == 0) printf("%d", results[i][j]);
			else printf(" %d", results[i][j]);
		}
		printf("\n");
	}

}

int main() {
	int v, e;
	scanf("%d %d", &v, &e);
	vector<vector<int> > graph(v);
	vector<vector<int> > weights(v);
	int from, to, weight;
	for (int i = 0; i < e; ++i) {
		scanf("%d %d %d", &from, &to, &weight);
		graph[from].push_back(to);
		weights[from].push_back(weight);
		graph[to].push_back(from);
		weights[to].push_back(weight);
	}
	maxst(graph, weights, v);
}
