#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
#include<utility>


using namespace std;

pair < int,pair <int,int> > edge[500001];
int cid[1000];
int size[1000];
vector <int> adj[1000];
int MSP[1000][1000]={0};
queue <int> q;

int find(int v){
	while(cid[v]!=v){
		v=cid[v];
	}
	return v;
}

void merge(int u,int v){
	int cid_u = find(u);
	int cid_v = find(v);
	if(size[cid_u]>=size[cid_v]){
		cid[cid_v]=cid[cid_u];
		size[cid_u]=size[cid_u]+size[cid_v];
	}
	else {
		cid[cid_u]=cid[cid_v];
		size[cid_v]=size[cid_v]+size[cid_u];
	}
}

void max_score_path(int V,int E){
	for(int i = 0; i < V; i++){//initializing cid[i] and size[i]
		cid[i] = i;
		size[i] = 1;
	}
	
	//int flag=0;
	
	for (int i = E-1;i >= 0;i--){//creating MST and storing it into adj list
		int u,v,wt;
		u = edge[i].second.first;
		v = edge[i].second.second;
		wt = edge[i].first;
		if( find(u)!= find(v)){
			merge(u,v);
			adj[u].push_back(v);
			adj[u].push_back(wt);
			adj[v].push_back(u);
			adj[v].push_back(wt);
		}
		//if(flag == (V-1)) break;
	}
	//bfs
	for(int i=0;i<V;i++){
		int max_score[V];
		for(int j = 0;j<V;j++){//initializing max_score
			max_score[j]=100000001;
		}
		bool visited[V];
		for(int j=0;j<V;j++){//initializing visited
			visited[j] = false;
		}
		
		q.push(i);
		visited[i]=true;
		while(!q.empty()){
			int u = q.front();
			q.pop();
			for(int j=0;j< adj[u].size();j++){
				if(!visited[adj[u][j]]){
					q.push(adj[u][j]);
					visited[adj[u][j]]=true;
					max_score[adj[u][j]]=adj[u][j+1];
					if(max_score[adj[u][j]]>max_score[u]){
						max_score[adj[u][j]]=max_score[u];
					}
				}
				j++;
			}
		}
		for(int j=0;j<V;j++){
			MSP[i][j] = (max_score[j]%100000001);
		}
	}
}

int main(){
	int V,E;
	scanf("%d%d",&V,&E);
	for(int i =0; i < E; i++){
		scanf("%d%d%d",&edge[i].second.first,&edge[i].second.second,&edge[i].first);
	}
	sort(edge,edge+E);
	max_score_path(V,E);
	for (int i =0; i < V; i++){
		printf("\n");
		for(int j =0; j< V; j++){
			printf("%d ",MSP[i][j]);
		}
		
	}
	return 0;
}
