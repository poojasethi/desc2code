#include <cstdio>
#include <algorithm>
#include <vector>
#define MIN(a,b) (((a)<(b))?(a):(b))

using namespace std;

vector <int> adjlist[1000];
int n;
vector<int> treeadj[1000];

int adm[1000][1000];

typedef struct edge {
	int i;
	int j;
	int w;
} edge;

bool operator<(const edge& l, const edge& r){
	if (l.w == r.w){
		return (l.i==r.i)? l.j < r.j : l.i < r.i;
	} else
		return l.w < r.w;
}

vector <edge> edges;

typedef struct node {
	int parent;
	int height;
} node;

node ds[1000];

void make_set(int size){
	for (int i=0; i<size; i++){
		ds[i].parent = i;
		ds[i].height = 1;
	}
}

int find_set(int i){
	if (ds[i].parent==i) return i;
	return ds[i].parent = find_set(ds[i].parent);
}

void join(int i, int j){
	i=find_set(i);
	j=find_set(j);
	if (ds[i].height > ds[j].height){
		int t=i;
		i=j;
		j=t;
	}
	if (ds[i].height == ds[j].height)
		ds[j].height++;
	ds[i].parent = j;
}

int visited[1000];

int ans[1000][1000];

void dfs_visit (int v, int min, int from){
	visited[v]=1;
	if (v!=from){
		ans[v][from] = ans[from][v] = min;
	}
	for( vector<int>::iterator x = treeadj[v].begin(); x != treeadj[v].end(); x++){
		if (!visited[*x]){
			dfs_visit(*x, MIN(min, adm[v][*x]), from);
		}
	}
}

void MaxST(){
	make_set(n);
	sort(edges.begin(), edges.end());
	int cc=n;
	vector<edge>::reverse_iterator x = edges.rbegin();
	while (cc>1){
		if (find_set((*x).i) != find_set((*x).j)){
			join((*x).i, (*x).j);
			treeadj[(*x).i].push_back((*x).j);
			treeadj[(*x).j].push_back((*x).i);
			cc--;
		}
		x++;
	}

	for (int i=0; i<n; i++){
		for (int j=0; j<n; j++){
			visited[j]=0;
		}
		dfs_visit(i, 99999999, i);
	}
}





int main(){
	int e;

	scanf("%d %d", &n, &e);

	for (int i=0; i<e; i++){
		edge c;
		scanf("%d %d %d", &c.i, &c.j, &c.w);
		edges.push_back(c);
		adm[c.i][c.j] = adm[c.j][c.i] = c.w;
	}

	MaxST();

	for (int i=0; i<n; i++){
		for (int j=0; j<n; j++){
			printf("%d ", (i!=j)? ans[i][j]: 0);
		}
		printf("\n");
	}

	return 0;
}