#include<iostream>
#include<stdio.h>
#include<vector>
#include<algorithm>
#include<vector>

using namespace std;

#define MAXE 500009
#define MAXN 1009
#define pii pair<int,int>
#define f first
#define s second
#define mp make_pair
#define INF 2000000009

int N,M,par[MAXN],r[MAXN],d[MAXN];
vector<pii>con[MAXN];

struct st {
	int a,b,c;
}edge[MAXE];

bool cmp (st a,st b) {
	return a.c>b.c;
}

int FindSet(int a) {
	if (par[a]!=a)
		par[a]=FindSet(par[a]);
	return par[a];
}

void Link(int a,int b) {
	a=FindSet(a);
	b=FindSet(b);
	
	if (r[a]>r[b])
		par[b]=a;
	else {
		if (r[a]==r[b])
			++r[b];
		par[a]=b;
	}
}

void Read() {
	scanf("%d%d",&N,&M);
	
	for (int i=1;i<=M;i++) {
		scanf("%d %d %d",&edge[i].a,&edge[i].b,&edge[i].c);
	}
	
}

// calculate the maximum-spanning-tree
void MST() {
	
	for (int i=0;i<=N-1;i++) {
		r[i]=1;
		par[i]=i;
	}
	
	sort(edge+1,edge+M+1,cmp);
	
	for (int i=1;i<=M;i++) {
		
		if (FindSet(edge[i].a)!=FindSet(edge[i].b)) {
			
			
			con[edge[i].a].push_back(mp(edge[i].b,edge[i].c));
			con[edge[i].b].push_back(mp(edge[i].a,edge[i].c));
			
			Link(edge[i].a,edge[i].b);
		}
	}
}

void Dfs(int root,int dist,int father) {
	
	d[root]=dist;
	
	for (int i=0;i<con[root].size();i++) {
		if (con[root][i].f!=father) {
			if (dist)
				dist=min(dist,con[root][i].s);
			else
				dist=con[root][i].s;
			Dfs(con[root][i].f,dist,root);
		}
	}
}

void Solve() {
	for (int i=0;i<=N-1;i++) 
		d[i]=INF;
	
	for (int i=0;i<=N-1;i++) {
		Dfs(i,0,-1);
		
		for (int j=0;j<=N-1;j++) {
			printf("%d ",d[j]);
			d[j]=INF;
		}
		printf("\n");
	}
}

int main () {
	//freopen("score.in","r",stdin);
	//freopen("score.out","w",stdout);
	
	Read();
	MST();
	Solve();
	
	return 0;
}
