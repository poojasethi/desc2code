//kruskals algorithm for maximum spanning tree
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<vector>
#define MIN(a,b) ((a<=b)?a:b)
using namespace std;
int result[1000][1000];
struct edge
{
    int start;
	int dest;
	int wt;
};
struct edge1
{
	int dest;
	int wt;
};
typedef vector<struct edge1>vec;
struct subset
{
	int parent;
	int rank;
};
int fastread()
{
int input;
char c=0;
while (c<33) c=getchar_unlocked();
input=0;
while (c>33)
{
input=input*10+c-'0';
c=getchar_unlocked();
}
return input;
}
/*int compare(const void *p,const void *q)
{
	const struct edge*a=(struct edge*)p;
	const struct edge*b=(struct edge*)q;
	if(a->wt>=b->wt)
	return -1;
	else
	return 1;
}*/
int findset(int i,struct subset set[])
{
	if(set[i].parent==i)
	return i;
	else
	{
		set[i].parent=findset(set[i].parent,set);
		return set[i].parent;
	}
}
bool mcmp(const edge a, const edge b) {
    return  a.wt> b.wt;
}
void unionfind(int x,int y,struct subset set[])
{
	int i,j,k,l,m;
	i=findset(x,set);
	j=findset(y,set);
	l=set[i].rank;
	m=set[j].rank;
	if(l>m)
	{
		set[j].parent=i;	
	}
	else if(m>l)
	{
		set[i].parent=j;
	}
	else
	{
		set[i].rank++;
		set[j].parent=i;
	}
	return ;
}
void kruskal(struct subset set[],struct edge arr[],int v,int e,vector<vec>&v1)
{
	int i,j,k,l,m;
	for(i=0;i<=e-1;i++)
	{
		j=arr[i].start;
		k=arr[i].dest;
		l=findset(j,set);
		m=findset(k,set);
		if(l!=m)
		{
			unionfind(l,m,set);
            //printf("%d -> %d -> %d\n",j,k,arr[i].wt);
            struct edge1*r=new struct edge1;
            struct edge1*q=new struct edge1;
		    q->dest=k;
		    q->wt=arr[i].wt;
		    v1[j].push_back(*q);
            r->dest=j;
            r->wt=arr[i].wt;
            v1[k].push_back(*r);
		}
	}
	return ;
}
void dfs(int visited[],int current,vector<vec>&v1,int start)
{
	vector<struct edge1>::iterator p;
	for(p=v1[current].begin();p!=v1[current].end();p++)
	{
		if(visited[p->dest]==-1)
		{
            if(current==start)
            visited[p->dest]=p->wt;
            else if(current!=start)
			visited[p->dest]=MIN(visited[current],p->wt);
			dfs(visited,p->dest,v1,start);
		}
	}
	return ;
}
int main(void)
{
	int v,e,i,j,k,l;
	v=fastread();
    e=fastread();
	struct edge arr[e];
	vector<vec>v1;
	int visited[v];
	for(i=0;i<=v-1;i++)
	{
		vec *p=new vec;
		v1.push_back(*p);
	}
	for(i=0;i<=e-1;i++)
	{
		arr[i].start=fastread();
        arr[i].dest=fastread();
        arr[i].wt=fastread();
	}
    sort(arr, arr+e, mcmp);
	struct subset set[v];
	for(i=0;i<=v-1;i++)
	{
		set[i].parent=i;
		set[i].rank=0;
	}
	kruskal(set,arr,v,e,v1);
    /*vec::iterator p;
    for(i=0;i<=v-1;i++)
    {
       for(p=v1[i].begin();p!=v1[i].end();p++)
       {
           printf("%d ",p->dest);
       }
       printf("\n");
    }*/
	for(i=0;i<=v-1;i++)
	{
		for(j=0;j<=v-1;j++)
		visited[j]=-1;
		visited[i]=0;
		dfs(visited,i,v1,i);
		for(j=0;j<=v-1;j++)
		result[i][j]=visited[j];
	}
	for(i=0;i<=v-1;i++)
	{
		for(j=0;j<=v-1;j++)
        printf("%d ",result[i][j]);
		printf("\n");
	}
    v1.clear();
	return 0;
}