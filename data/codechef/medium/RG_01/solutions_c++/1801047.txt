#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;

// Begin fast read
#define MAX_BUF 1024
 
char buf_in[MAX_BUF],*next_in,buf_out[MAX_BUF],*next_out;
 
void read_buf() {
  buf_in[fread(buf_in,1,MAX_BUF-1,stdin)]=0;
  next_in=buf_in;
}
 
void read_char() {
  next_in++;
  if (!*next_in)
    read_buf();
}
 
bool read_eof() {
  return !*next_in;
}
 
int read_int() {
  int x=0;
 
  while (*next_in<'0' || *next_in>'9')
    read_char();
  while (*next_in>='0' && *next_in<='9') {
    x=10*x+*next_in-'0';
    read_char();
  }
 
  return x;
}
 
double read_double() {
  double x=0.0,p=1.0;
 
  while ((*next_in<'0' || *next_in>'9') && *next_in!='-')
    read_char();
  if (*next_in=='-')
    return -read_double();
  while (*next_in>='0' && *next_in<='9') {
    x=10*x+*next_in-'0';
    read_char();
  }
  if (*next_in=='.') {
    read_char();
    while (*next_in>='0' && *next_in<='9') {
      x=10*x+*next_in-'0';
      p*=10.0;
      read_char();
    }
  }
 
  return x/p;
}
 
void write_buf() {
  fwrite(buf_out,1,next_out-buf_out,stdout);
  next_out=buf_out;
}
 
void write_char(char c) {
  *next_out++=c;
  if (next_out-buf_out==MAX_BUF)
    write_buf();
}
 
void _write_int(int x) {
  if (x) {
    _write_int(x/10);
    write_char('0'+x%10);
  }
}
 
void write_int(int x) {
  if (x<0) {
    write_char('-');
    x=-x;
  }
  if (!x)
    write_char('0');
  else
    _write_int(x);
}
 
void write_string(const char *c) {
  while (*c)
    write_char(*c++);
}
 
void init() {
  read_buf();
  next_out=buf_out;
}
 
void deinit() {
  write_buf();
}
// End fast read

//Begin graph
const int MAXE = 1000000;
const int INF  = 1000000000;
struct edge {
	int s, d, w;
	bool operator<(const struct edge &rhs) const {
		return w>rhs.w;
	}
} a[MAXE];

int n, e;
vector<int> g[1005];
int cost[1005][1005];
int visited[1005];

void dfs(int start, int cur, int c) {
	if (start!=cur) {
		cost[start][cur] = max(cost[start][cur], c);
	}
	visited[cur] = 1;
	for (int i=0; i<g[cur].size(); i++) {
		int next = g[cur][i];
		if (!visited[next]) {
			dfs(start, next, min(c,cost[cur][next]));
		}
	}
}
//End graph

//Begin union find
int uf[1005];
int cf[1005];

int find(int x) {
	return (uf[x]==x) ? x : uf[x]=find(uf[x]);
}

void merge(int x, int y) {
	int i = find(x);
	int j = find(y);
	if (i==j) return;
	if (cf[i]<cf[j]) {	
		cf[j] += cf[i];
		uf[i] = j;
	} else {
		cf[i] += cf[j];
		uf[j] = i;
	}
}

bool connected(int i, int j) {
	return find(i)==find(j);
}
// End union find

int main() {
	//freopen("in.txt", "r", stdin);
	init();
	n = read_int();
	e = read_int();
	for (int i=0; i<=n; i++) {
		g[i].clear();
	}
	for(int i=0; i<e; i++) {
		a[i].s = read_int();
		a[i].d = read_int();
		a[i].w = read_int();
	}
	sort(a, a+e);
	for (int i=0; i<=n; i++) {
		uf[i] = i;
		cf[i] = 1;
	}
	memset(cost, 0, sizeof cost);
	for (int i=0; i<e; i++) {
		if (!connected(a[i].s, a[i].d)) {
			g[a[i].s].push_back(a[i].d);
			g[a[i].d].push_back(a[i].s);
			cost[a[i].s][a[i].d] = cost[a[i].d][a[i].s] = a[i].w;
			merge(a[i].s, a[i].d);
		}
	}
	for (int i=0; i<n; i++) {
		memset(visited, 0, sizeof visited);
		dfs(i, i, INF);
	}
	for (int i=0; i<n; i++) {
		for (int j=0; j<n; j++) {
			write_int(cost[i][j]);
			write_char(' ');
		}
		write_string("\n");
	}
	deinit();
	return 0;
}