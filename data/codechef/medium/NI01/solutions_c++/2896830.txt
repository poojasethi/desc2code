/*
  with the help of god
*/
#include <algorithm>
#include <numeric>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <iostream>
#include <iterator>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <sstream>
#include <stack>

using namespace std;

//typedef 

typedef long long ll;
typedef long double ld;
typedef unsigned int ui;
typedef unsigned long long ull;
typedef pair<int,int> pii;

//define

#define gi ({int t; scanf("%d",&t); t;})
#define gl ({ll t; scanf("%lld",&t); t;})
#define gd ({double t;scanf("%lf",&t); t;})
#define rep(i,n) for(int i=0,_n=n;i<_n;i++)
#define fr(i,a,b) for(int i=a;i<b;i++)
#define frd(i,a,b)  for(int i=b;i>=a;i--)
#define repd(i,n) for(int _n=ni=_n-1;i>=0;--i)
#define fit(i,v) for(__typeof((v).begin()) i =(v).begin(); i != (v).end(); ++i)
#define fitd(i,v) for(__typeof((v).rbegin()) i=(v).rbegin(); i!=(v).rend();++i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define ms(a,x) memset(a, x, sizeof(a))
#define sz(c) (int)(c).size()
#define dbg(x) cerr<<#x<<" = "<<(x)<<endl 
#define sqr(x) ((x)*(x))
#define mod (ll) (1e4 + 7 + eps)

//template
template <class T> T gcd(T a,T b){
  T r;
  while(b!=0){
    r=a%b;
    a=b;
    b=r;
  }
  return a;
}

int max(int a,int b){ return a>b?a:b;}
int min(int a,int b){ return a<b?a:b;}
ll modulo(ll a,ll b){ return a<b?a:a%b;}

//constants
const int inf = (int) 1e9 + 5;
const ll linf = (ll) 1e16 + 5;
const double eps = 1e-6;

//geomentry
typedef struct{
  //vector is ax,by
  double x,y;
}point,geovector;
typedef struct{
  //ax+by+c=0
  double a,b,c;
}line;
typedef struct{
  double r;
  point c;
}circle;
bool issame(double x,double y){
  return fabs(x-y) < eps-eps/100.0;
}
double dist(point p,point q){
  return sqrt(sqr(p.x-q.x) + sqr(p.y-q.y));
}

//exponentiation
ll power(ll a,ll b){
  if(b==0) return 1;
  if(b==1) return a;
  ll ret = power(a,b>>1);
  (ret *= ret)%=mod;
  if(b&1) (ret*=a)%=mod;
  return ret;
}

//inversemodulo

ll im(ll a,ll n){
  ll i=n,v=0,d=1;
  ll x;
  while(a>0){
    ll t=i/a;
    x=a;
    a=i%x;
    i=x;	
    x=d;
    d=v-t%x;
    v=x;
  }
  v%=n;
  if(v<0) v=(v+n)%n;
  return v;
}
int main(){
  int t;
  t=gi;
  while(t--){
    int n,m,q,p,r,k;
    n=gi;m=gi;q=gi;p=gi;r=gi;k=gi;
    /*
      n-no of safari cars
      m-no of passengers in museum at time zero
      q-no of passengers at park gate
      p-time of safari park ride
      r-every r second one passenger from museum waits in gate
    */
    int tym=0;
    vector <int> cur_saf;
    rep(i,min(n,q)) cur_saf.pb(0);
    int temp=n;
    n-=min(n,q);
    q-=min(temp,q);
    tym=1;
    while(tym<=k){
      int j=lower_bound(cur_saf.begin(),cur_saf.end(),tym-p)-cur_saf.begin();
      fr(i,j,sz(cur_saf)){
	if(cur_saf[i]+p==tym){
	  n++;
	}
	else{
	  break;
	}
      }
      rep(i,min(n,q)) cur_saf.pb(tym);
      temp=n;
      n-=min(n,q);
      q-=min(temp,q);
      if(tym%r==0 && m!=0){
	if(n==0){
	  q++;
	}
	else{
	  n--;
	  cur_saf.pb(tym);
	}
	m--;
      }
      tym++;
    }
    int res=0;
    rep(i,sz(cur_saf)){
      if(cur_saf[i]+p<=k) res++;
    }
    printf("%d %d %d %d\n",n,res,m,q);
  }
  return 0;
}

