import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.util.Comparator;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.RandomAccess;
import java.util.AbstractList;
import java.io.Writer;
import java.util.List;
import java.io.IOException;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.Random;
import java.math.BigInteger;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.util.Stack;

public class Main 
{
	public static void main(String[] args) throws Exception
	{
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;

		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		SaveTheTrees solver = new SaveTheTrees();
		int T = in.readInt();
		for(int count = 0; count < T; count++)
		{
			solver.solve(count+1, in, out);			
		}
		out.close();

	}//end of main()
}
 
class SaveTheTrees 
{
	int N;
	int[] A;
	Point2D[] points;

	public void solve(int testNumber, InputReader in, OutputWriter out) throws Exception
	{
		N = in.readInt();
		A = new int[N];

		for(int count = 0; count < N; count++)
		{
			A[count] = in.readInt();
		}

		int numOfPoints = (N*2 - 3);
		points = new Point2D[numOfPoints];
		
		long[] yMin = new long[N];
		long[] yMax = new long[N];
		yMin[N-1] = A[N-1];
		yMax[N-1] = A[N-1];
		for(int count = N-2; count >= 0; count--) {
			yMin[count] = Math.min(yMin[count+1], A[count+1]);
			yMax[count] = Math.max(yMax[count+1], A[count+1]);
		}

		int pointCount = 0;
		for(int xCount = 0; xCount < N-2; xCount++) {
			points[pointCount] = new Point2D(A[xCount], yMin[xCount]);
			//System.out.println(points[pointCount]);
			points[pointCount+1] = new Point2D(A[xCount], yMax[xCount]);
			//System.out.println(points[pointCount+1]);
			pointCount+=2;
		}
		points[pointCount] = new Point2D(A[N-2], A[N-1]);
		//System.out.println(points[pointCount]);
		//System.out.println(pointCount+1);
		out.print(getArea(points, out) + "\n");		
		//long ans = getSchedule(X, Y, N);
		//out.print(ans + "\n");

	}//end of solve()

	public long getArea(Point2D[] points, OutputWriter out)
	{
		GrahamScan gs = new GrahamScan();
		gs.grahamScan(points);
		Point2D[] hull = gs.getCCWHull();
		long area = 0;
		for(int count = 1; count < hull.length; count++) {
			area += ((hull[count-1].x * hull[count].y) - (hull[count-1].y * hull[count].x));
		}
		
		return Math.abs(area);
	}

}//end of class SaveTheTrees

class InputReader 
{
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
 
	public InputReader(InputStream stream) 
	{
		this.stream = stream;
	}
	 
	public int read() 
	{
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) 
		{
			curChar = 0;
			try 
			{
				numChars = stream.read(buf);
			} 
			catch (IOException e) 
			{
				throw new InputMismatchException();
			}

			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
 
	public int readInt() 
	{
		int c = read();

		while (isSpaceChar(c))
			c = read();

		int sgn = 1;
		if (c == '-') 
		{
			sgn = -1;
			c = read();
		}

		int res = 0;
		do 
		{
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} 
		while (!isSpaceChar(c));

		return res * sgn;
	}

	public String readString() 
	{
		StringBuilder sb = new StringBuilder();
		int c = read();
		while (isWhiteSpace(c)) 
		{
		    c = read();
		}

		while (!isWhiteSpace(c)) 
		{
		    sb.appendCodePoint(c);
		    c = read();
		}

		return sb.toString();
	}

	public static boolean isWhiteSpace(int c) 
	{
		return c >= -1 && c <= 32;
	}
 
	public static boolean isSpaceChar(int c) 
	{
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
}
 
class OutputWriter 
{
	private final PrintWriter writer;
	 
	public OutputWriter(OutputStream outputStream) 
	{
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}
	 
	public OutputWriter(Writer writer) 
	{
		this.writer = new PrintWriter(writer);
	}
	 
	public void print(Object...objects) 
	{
		for (int i = 0; i < objects.length; i++) 
		{
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}
	 
	public void printLine(Object...objects) 
	{
		print(objects);
		writer.println();
	}
	 
	public void close() 
	{
		writer.close();
	}
 
}


class GrahamScan {
	Stack<Point2D> hull = new Stack<Point2D>();
	
	public void grahamScan(Point2D[] points) {
		int pointsCount = points.length;
	
		// sort by y-coordinate
		Arrays.sort(points);
		
		// sort by points[0].polarOrder
		Arrays.sort(points, 1, pointsCount, points[0].polarOrder());
		
		hull.push(points[0]);
		
		// find index k1 such that points[0] != points[k1]
		int k1;
		for(k1 = 1; k1 < pointsCount; k1++) {
			if(!points[k1].equals(points[0])) {
				break;
			}
		}
		
		// if all points co-incide
		if (k1 == pointsCount) {
			return;
		}
		
		// find index k2 such that points[0], points[k1], points[k2] are non-collinear
		int k2;
		for(k2 = k1+1; k2 < pointsCount; k2++) {
			if(Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
				break;
			}
		}
		
		// points[k2-1] is the second extreme point
		hull.push(points[k2-1]);
		
		for(; k2 < pointsCount; k2++) {
			Point2D top = hull.pop();
			while(Point2D.ccw(hull.peek(), top, points[k2]) <= 0) {
				top = hull.pop();
			}
			hull.push(top);
			hull.push(points[k2]);
		}

	}
	
	public Point2D[] getCCWHull() {
		Point2D[] ccwHull = new Point2D[hull.size() + 1];
		int count = hull.size();
		while(count > 0) {
			ccwHull[count-1] = hull.pop();
			count--;
		}
		ccwHull[ccwHull.length - 1] = ccwHull[0];
		
		return ccwHull;
	}

}// end of Graham Scan

class Point2D implements Comparable<Point2D> {
	long x, y;
	
	public Point2D(long x, long y) {
		this.x = x;
		this.y = y;
	}
	
	public int compareTo(Point2D that) {
		if (this.y < that.y) return -1;
		if (this.y > that.y) return 1;
		if (this.x < that.x) return -1;
		if (this.x > that.x) return 1;
		return 0;
	}
	
	public boolean equals(Object other) {
		if (this == other) return true;
		if (other == null) return false;
		if (this.getClass() != other.getClass()) return false;
		Point2D that = (Point2D) other;
		return this.x == that.x && this.y == that.y;
	}
	
	public int hashCode() {
		int hashX = ((Long)x).hashCode();
		int hashY = ((Long)x).hashCode();
		return 31*hashX + hashY;
	}
	
	public static int ccw(Point2D a, Point2D b, Point2D c) {
		long area1 = (c.y - a.y) * (b.x - a.x);
		long area2 = (b.y - a.y) * (c.x - a.x);
		
		if (area1 > area2) {
			return 1;
		}
		if (area2 > area1) {
			return -1;
		}
		
		return 0;
	}
	
	private class PolarOrder implements Comparator<Point2D> {
	
		public int compare(Point2D p1, Point2D p2) {
			long dy1 = p1.y - y;
			long dy2 = p2.y - y;
			long dx1 = p1.x - x;
			long dx2 = p2.x - x;
			if (dy1 >= 0 && dy2 < 0) return -1;
			if (dy1 < 0 && dy2 >= 0) return 1;
			// 3 collinear and horizontal points
			if (dy1 == 0 && dy2 == 0) {
				if (dx1 < 0 && dx2 >= 0) return 1;
				if (dx1 >= 0 && dx2 < 0) return -1;
			}
			
			return -ccw(Point2D.this, p1, p2);
		}
		
	}
	
	public Comparator<Point2D> polarOrder() {
		return new PolarOrder();
	}
	
	public String toString() {
		return "(" + x + "," + y + ")";
	}
}