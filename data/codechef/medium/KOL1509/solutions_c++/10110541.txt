#include<iostream>
#include<math.h>
 
using namespace std;
 
long int N;
long int Narr[100000];
typedef struct
{
	long long int x;
	long long int y;
}points;
 
points N_points[200000];
long int Nk = 0;
 
points N_convexhull[200000];
long int Nc = 0; 
 
 
int compare(points& P, points& n1, points& n2)
{
	points vec1,vec2;
	vec1.x = n1.x - P.x;
	vec1.y = n1.y - P.y;
	vec2.x = n2.x - P.x;
	vec2.y = n2.y - P.y;
 
	if(( vec1.x == 0) && (vec1.y == 0))
	{
		return -1;
	}
	if((vec2.x == 0) && (vec2.y == 0))
	{
		return 0;
	}
 
	long long int angc = vec1.x*vec2.y - vec1.y*vec2.x;
 
	if( angc > 0)
		return -1;
	else
	if( angc < 0)
		return 0;
	else
	{
		if( n2.x < n1.x)
			return 0;
		else
		if( n2.x > n1.x)
			return -1;
 
		if( n2.y < n1.y)
			return 0;
		else
			return -1;
	}
}
 
void swap(long int i, long int j)
{
	points temp;
	temp.x = N_points[i].x;
	temp.y = N_points[i].y;
 
	N_points[i].x = N_points[j].x;
	N_points[i].y = N_points[j].y;
 
	N_points[j].x = temp.x;
	N_points[j].y = temp.y;
}
 
void qsort(points& P, long int id1, long int id2)
{
	if( id1 >= id2)
		return;
 
	points pivot;
	pivot.x = N_points[id1].x;
	pivot.y = N_points[id1].y;
 
	// push pivot to end
	N_points[id1].x = N_points[id2].x;
	N_points[id1].y = N_points[id2].y;
 
	N_points[id2].x = pivot.x;
	N_points[id2].y = pivot.y;
 
	long int i,j=id1;
	for(long int i=id1;i<id2;i++)
	{
		if(compare(P,N_points[i],pivot)<0)
		{
			swap(i,j);
			j++;
		}
	}
	swap(j,id2);
	qsort(P,id1,j-1);
	qsort(P,j+1,id2);
}
 
int finddirection(long int ic, long int ik)
{
	points vec1,vec2;
	vec1.x = N_points[ik].x - N_convexhull[ic-1].x;
	vec1.y = N_points[ik].y - N_convexhull[ic-1].y;
 
	vec2.x = N_points[ik].x - N_convexhull[ic].x;
	vec2.y = N_points[ik].y - N_convexhull[ic].y;
 
	if((vec1.x == 0)&&(vec1.y == 0))
		return 0;
 
	if((vec2.x == 0)&&(vec2.y == 0))
		return 0;
 
	long long int angc = vec1.x*vec2.y - vec2.x*vec1.y;
	if( angc > 0)
		return 1;
	else
		return -1;
} 
 
void findconvexhull()
{
	points P;
	P.y = N_points[0].y;
	P.x = N_points[0].x;
	for(long int i=1;i<Nk;i++)
	{
		if((N_points[i].y < P.y)||((N_points[i].y == P.y)&&(N_points[i].x < P.x)))
		{
			P.y = N_points[i].y;
			P.x = N_points[i].x;
		}
	}
	qsort(P,0,Nk-1);

	Nc = 0;
	N_convexhull[Nc].x = P.x;
	N_convexhull[Nc].y = P.y;
	Nc++;
	for(long int i=0;i<Nk;)
	{
		long int j = (i+1)%Nk;
		if( Nc == 1)
		{
			N_convexhull[Nc].x = N_points[j].x;
			N_convexhull[Nc].y = N_points[j].y;
			Nc++;
			i++;
			continue;
		}
		int dir = finddirection(Nc-1,j);
		if(dir == 1)
		{
			N_convexhull[Nc].x = N_points[j].x;
			N_convexhull[Nc].y = N_points[j].y;
			Nc++;
			i++;
		}
		else
			Nc--;
	}
}
 
int main()
{
	long int T;
	cin >> T;
	for(long int i=0;i<T;i++)
	{
		cin >> N;
		cin >> Narr[0];
		long int min = Narr[0];
		long int max = Narr[0];
		Nk = 0;
		for(long int j=1;j<N;j++)
		{
			cin >> Narr[i];
			N_points[Nk].x = min;
			N_points[Nk++].y = Narr[i];
			N_points[Nk].x = max;
			N_points[Nk++].y = Narr[i];
			if( min > Narr[i])
			{
				min = Narr[i];
			}
			if( max < Narr[i])
			{
				max = Narr[i];
			}
		}
	
		Nc = 0;
		findconvexhull();
	
		long long int area = 0;
		for(long int j = 1; j < Nc ; j++)
		{
			long long int v1 = N_convexhull[j-1].x;
			long long int v2 = N_convexhull[j-1].y;
			long long int w1 = N_convexhull[j].x;
			long long int w2 = N_convexhull[j].y;
			area += (v1*w2 -v2*w1);
		}
 
		area = (area < 0) ? -area:area;
		cout << area << endl;
	}
	return 0;
}