#include <map>
#include <limits>
#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cassert>
#include <experimental/optional>

using namespace std;

struct point{
    int64_t x, y;
    point(pair<int64_t, int64_t> p): x(p.second), y(p.first){}

    point(int64_t y, int64_t x): x(x), y(y){}
    point(){}

    bool is_left(const point &p0, const point &p1){
        return ((p0.x - x)*(p1.y - y) - (p1.x - x)*(p0.y - y) > 0);
    }

    static int64_t angle(const point &p0, const point &p1, const point &p3){
        return (p0.x - p3.x)*(p1.y - p3.y) - (p1.x - p3.x)*(p0.y - p3.y);
    }
    
    bool coolinear(const point &p0, const point &p1){
        return ((p0.x - x)*(p1.y - y) - (p1.x - x)*(p0.y - y) == 0);
    }

    double value(const point &o) const{
        if (*this == o) return -numeric_limits<double>::infinity();
        return -((double) (x - o.x)) / (y - o.y);
    }

    bool operator==(const point &a) const{
        return x == a.x && y == a.y;
    }

    point& operator=(const pair<int64_t, int64_t> &o){
        this->x = o.second;
        this->y = o.first;
        return *this;
    }

    int64_t distSq(const point &a) const{
        return (a.x - x)*(a.x - x) + (a.y - y)*(a.y - y);
    }

    int64_t normSq() const{
        return x * x + y * y;
    }
};

point pnts[0x40000];
point hull[0x40000];

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    size_t T;
    cin >> T;

    do {
        size_t N;
        cin >> N;

        int64_t t;
        cin >> t;

        int64_t mincoord = t;
        int64_t maxcoord = t;

        --N;

        experimental::optional<point *> lss;
        experimental::optional<point *> rss;

        auto lcs = pnts+N;
        auto rcs = pnts+N-1;

        auto uit = pnts+N;
        auto dit = pnts+N-1;


        size_t M = 2*N;
        while (dit >= pnts){
            int64_t t;
            cin >> t;

            *(dit  ) = point(t, maxcoord);
            *(uit++) = point(t, mincoord);

            if (t < mincoord){
                mincoord = t;
                if (lss) sort(lcs, uit, [](const point &a, const point &b) {
                                                return a.y > b.y;
                                            });
                else lss = uit;
                lcs = uit;
            }

            if (t > maxcoord){
                maxcoord = t;
                if (rss) sort(dit, rcs, [](const point &a, const point &b) {
                                            return a.y > b.y;
                                        });
                else rss = dit;
                rcs = dit;
            }

            --dit;
        }

        if (lss || rss) sort(rss.value_or(pnts), lss.value_or(pnts+M), [](const point &a, const point &b) {
                                    return a.y > b.y;
                                });

        sort(lcs, pnts+M, [](const point &a, const point &b) {
                                    return a.y > b.y;
                                });
        sort(pnts, rcs, [](const point &a, const point &b) {
                                    return a.y > b.y;
                                });

        auto p    = pnts; 
        auto pend = pnts+M;

        size_t D = 0;
        for (auto t=pend-1; t >= p ; --t){
            while (D >= 2 && point::angle(hull[D-2], hull[D-1], *t) >= 0) --D;
            hull[D++] = *t;
        }

        M = 0;
        for (auto t=p; t != pend ; ++t){
            while (M >= 2 && point::angle(hull[D-2], hull[D-1], *t) >= 0){
                --M;
                --D;
            }
            ++M;
            hull[D++]=*t;
        }

        int64_t area = 0;

        point curr = hull[D-1];
        point prev;

        for (size_t i = 0; i < D; ++i){
            prev = curr;
            curr = hull[i];
            area += prev.x * curr.y - prev.y * curr.x;
        }

        int64_t a = abs(area);

        cout << a << '\n';
    } while (--T);
}