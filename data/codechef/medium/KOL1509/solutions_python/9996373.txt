#include <map>
#include <limits>
#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cassert>
#include <experimental/optional>

using namespace std;

struct point{
    int64_t x, y;
    point(pair<int64_t, int64_t> p): x(p.second), y(p.first){}

    point(int64_t y, int64_t x): x(x), y(y){}
    point(){}

    bool is_left(const point &p0, const point &p1){
        return ((p0.x - x)*(p1.y - y) - (p1.x - x)*(p0.y - y) > 0);
    }

    constexpr static int64_t angle(const point &p0, const point &p1, const point &p3){
        return (p0.x - p3.x)*(p1.y - p3.y) - (p1.x - p3.x)*(p0.y - p3.y);
    }
    
    bool coolinear(const point &p0, const point &p1){
        return ((p0.x - x)*(p1.y - y) - (p1.x - x)*(p0.y - y) == 0);
    }

    double value(const point &o) const{
        if (*this == o) return -numeric_limits<double>::infinity();
        return -((double) (x - o.x)) / (y - o.y);
    }

    bool operator==(const point &a) const{
        return x == a.x && y == a.y;
    }

    point& operator=(const pair<int64_t, int64_t> &o){
        this->x = o.second;
        this->y = o.first;
        return *this;
    }

    int64_t distSq(const point &a) const{
        return (a.x - x)*(a.x - x) + (a.y - y)*(a.y - y);
    }

    int64_t normSq() const{
        return x * x + y * y;
    }
};

point pnts[0x40000];
point hull[0x40000];

experimental::optional<point *> lss;
experimental::optional<point *> rss;

bool compare_same(const point &a, const point &b){
    return a.y > b.y;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    size_t T=10000;
    cin >> T;

    do {
        // size_t N = rand()%1000+2;

        // int64_t t = rand()%1000;

        size_t N;
        cin >> N;

        int64_t t;
        cin >> t;

        int64_t mincoord = t;
        int64_t maxcoord = t;
        
        lss = experimental::nullopt;
        rss = experimental::nullopt;

        --N;

        auto lcs = pnts+N;
        auto rcs = pnts+N-1;

        auto uit = pnts+N;
        auto dit = pnts+N-1;


        size_t M = 2*N;
        while (dit >= pnts){
            // int64_t t = rand()%1000;
            int64_t t;
            cin >> t;

            *(dit  ) = point(t, maxcoord);
            *(uit++) = point(t, mincoord);

            if (t < mincoord){
                mincoord = t;
                if (lss) sort(lcs, uit, compare_same);
                else lss = uit;
                lcs = uit;
            }

            if (t > maxcoord){
                maxcoord = t;
                if (rss) sort(dit, rcs, compare_same);
                else rss = dit;
                rcs = dit;
            }

            --dit;
        }
        auto pend = pnts+M;

        if (lss || rss) sort(rss.value_or(pnts), lss.value_or(pend), compare_same);

        sort(lcs , pend, compare_same);
        sort(pnts,  rcs, compare_same);


        size_t D = 0;
        for (auto t=pend-1; t >= pnts ; --t){
            while (D >= 2 && point::angle(hull[D-2], hull[D-1], *t) >= 0) --D;
            hull[D++] = *t;
        }

        M = D + 2;
        for (auto t=pnts; t != pend ; ++t){
            while (D >= M && point::angle(hull[D-2], hull[D-1], *t) >= 0) --D;
            hull[D++] = *t;
        }

        int64_t area = 0;

        point curr = hull[D-1];
        point prev;

        for (size_t i = 0; i < D; ++i){
            prev = curr;
            curr = hull[i];
            area += prev.x * curr.y - prev.y * curr.x;
        }

        int64_t a = abs(area);

        cout << a << '\n';
    } while (--T);
}