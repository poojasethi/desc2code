#include<cstdio>
#include<queue>

using namespace std;

//Processing variables
char maze[13 * 13];
short treasures[13]; //store treasure's coordinates
int n;
short bestconfig, current_best;
bool free[13]; //can we choose treasure i for the next in our path?

short total_treasure;
short treasures_cost[13 * 13]; //cost between treasures
short from_start_cost[13]; //cost from start point to each treasure
short to_end_cost[13]; //cost from each treasure to the end

//Maintain a queue
short my_queue[100];
short head = -1, tail = -1;
short size = 0;

//functions's prototype
void process();
int bfs_cost(short from_i, short from_j, short to_i, short to_j);
void try_next(short i, short treasure_obtained);

//Entry's point
int main() {

	int testcase;
	scanf("%i", &testcase);
	for (int test = 0; test < testcase; test++) {
		scanf("%i", &n);
		for (int i = 0; i < n; i++)
			scanf("%s", (maze + i * n));
		process();

		printf("%d\n", bestconfig == 10000 ? -1 : bestconfig);
	}
	return 0;
}

void process() {
	//Calculate number of treasures and index to them
	total_treasure = 0;
	for (int i = 0; i < n * n; i++)
		if (maze[i] == '*')
			treasures[total_treasure++] = i;
	//Calculate the cost between each treasure
	for (int treasure1 = 0; treasure1 < total_treasure; treasure1++)
		for (int treasure2 = 0; treasure2 < total_treasure; treasure2++) {
			treasures_cost[treasure1 * total_treasure + treasure2] =
					treasures_cost[treasure2 * total_treasure + treasure1] =
							bfs_cost(treasures[treasure1] / n,
									treasures[treasure1] % n,
									treasures[treasure2] / n,
									treasures[treasure2] % n);
		}
	//calculate cost from start and to end
	for (int treasure = 0; treasure < total_treasure; treasure++) {
		from_start_cost[treasure] = bfs_cost(0, 0, treasures[treasure] / n,
				treasures[treasure] % n);
		to_end_cost[treasure] = bfs_cost(n - 1, n - 1, treasures[treasure] / n,
				treasures[treasure] % n);
	}
	//Initialize branch and bound process
	for (int i = 0; i < total_treasure; i++)
		free[i] = true;
	bestconfig = 10000;
	current_best = 0;

	if (total_treasure != 0)
		for (int treasure = 0; treasure < total_treasure; treasure++) {
			current_best = current_best + from_start_cost[treasure];
			try_next(treasure, 1);
			current_best = current_best - from_start_cost[treasure];
		}
	else
		bestconfig = bfs_cost(0, 0, n - 1, n - 1);
}

void try_next(short i, short treasure_obtained) {
	//if i is the last treasure in our bag:
	if (treasure_obtained == total_treasure
			&& current_best + to_end_cost[i] < bestconfig) {
		bestconfig = current_best + to_end_cost[i];
		return;
	}

	free[i] = false;

	for (int next = 0; next < total_treasure; next++)
		if (free[next]
				&& current_best + treasures_cost[i * total_treasure + next]
						+ to_end_cost[next] < bestconfig) {
			current_best = current_best
					+ treasures_cost[i * total_treasure + next];
			try_next(next, treasure_obtained + 1);
			current_best = current_best
					- treasures_cost[i * total_treasure + next];
		}

	free[i] = true;
}

int bfs_cost(short from_i, short from_j, short to_i, short to_j) {
	head = tail = 0;
	size = 1;
	my_queue[head] = from_i * n + from_j;

	bool free[13 * 13];
	for (int i = 0; i < n * n; i++)
		free[i] = true;
	free[from_i * n + from_j] = false;

	int d[13 * 13];
	for (int i = 0; i < n * n; i++)
		d[i] = 0;
	bool found = false;

	while (size > 0) {
		int next = my_queue[head];
		size--;
		if (head == tail) {
			head = tail = -1;
			size = 0;
		} else
			head = (head + 1) % 100;

		if (next == to_i * n + to_j) {
			found = true;
			break;
		}
		int i = next / n, j = next % n;
		if (i > 0 && maze[(i - 1) * n + j] != '#' && free[(i - 1) * n + j]) {
			if (size == 0) {
				head = tail = 0;
				my_queue[tail] = (i - 1) * n + j;
			} else
				my_queue[tail = (tail + 1) % 100] = (i - 1) * n + j;
			size++;
			free[(i - 1) * n + j] = false;
			d[(i - 1) * n + j] = d[next] + 1;
		}
		if (i + 1 < n && maze[(i + 1) * n + j] != '#'
				&& free[(i + 1) * n + j]) {
			if (size == 0) {
				head = tail = 0;
				my_queue[tail] = (i + 1) * n + j;
			} else
				my_queue[tail = (tail + 1) % 100] = (i + 1) * n + j;
			size++;
			free[(i + 1) * n + j] = false;
			d[(i + 1) * n + j] = d[next] + 1;
		}
		if (j > 0 && maze[(i) * n + j - 1] != '#' && free[(i) * n + j - 1]) {
			if (size == 0) {
				head = tail = 0;
				my_queue[tail] = i * n + j - 1;
			} else
				my_queue[tail = (tail + 1) % 100] = i * n + j - 1;
			size++;
			free[i * n + j - 1] = false;
			d[i * n + j - 1] = d[next] + 1;
		}
		if (j + 1 < n && maze[(i) * n + j + 1] != '#'
				&& free[(i) * n + j + 1]) {
			if (size == 0) {
				head = tail = 0;
				my_queue[tail] = i * n + j + 1;
			} else
				my_queue[tail = (tail + 1) % 100] = i * n + j + 1;
			size++;
			free[i * n + j + 1] = false;
			d[i * n + j + 1] = d[next] + 1;
		}
	}
	if (found)
		return d[to_i * n + to_j];
	else
		return 10000;
}
