#include<cstdio>
#include<queue>

using namespace std;

//Processing variables
char maze[13 * 13];
int treasures[13]; //store treasure's coordinates
int n;
int bestconfig, current_best;
bool free[13]; //can we choose treasure i for the next in our path?

int total_treasure;
int treasures_cost[13 * 13]; //cost between treasures
int from_start_cost[13]; //cost from start point to each treasure
int to_end_cost[13]; //cost from each treasure to the end

//functions's prototype
void process();
int bfs_cost(int from_i, int from_j, int to_i, int to_j);
void try_next(int i, int treasure_obtained);

//Entry's point
int main() {

	int testcase;
	scanf("%d", &testcase);
	for (int test = 0; test < testcase; test++) {
		scanf("%d", &n);
		for (int i = 0; i < n; i++)
			scanf("%s", (maze + i * n));
		process();

		printf("%d\n", bestconfig == 10000 ? -1 : bestconfig);
	}
	return 0;
}

void process() {
	//Calculate number of treasures and index to them
	total_treasure = 0;
	for (int i = 0; i < n * n; i++)
		if (maze[i] == '*')
			treasures[total_treasure++] = i;
	//Calculate the cost between each treasure
	for (int treasure1 = 0; treasure1 < total_treasure; treasure1++)
		for (int treasure2 = 0; treasure2 < total_treasure; treasure2++) {
			treasures_cost[treasure1 * total_treasure + treasure2] =
					treasures_cost[treasure2 * total_treasure + treasure1] =
							bfs_cost(treasures[treasure1] / n,
									treasures[treasure1] % n,
									treasures[treasure2] / n,
									treasures[treasure2] % n);
		}
	//calculate cost from start and to end
	for (int treasure = 0; treasure < total_treasure; treasure++) {
		from_start_cost[treasure] = bfs_cost(0, 0, treasures[treasure] / n,
				treasures[treasure] % n);
		to_end_cost[treasure] = bfs_cost(n - 1, n - 1, treasures[treasure] / n,
				treasures[treasure] % n);
	}
	//Initialize branch and bound process
	for (int i = 0; i < total_treasure; i++)
		free[i] = true;
	bestconfig = 10000;
	current_best = 0;

	if (total_treasure != 0)
		for (int treasure = 0; treasure < total_treasure; treasure++) {
			current_best = current_best + from_start_cost[treasure];
			try_next(treasure, 1);
			current_best = current_best - from_start_cost[treasure];
		}
	else
		bestconfig = bfs_cost(0, 0, n - 1, n - 1);
}

void try_next(int i, int treasure_obtained) {
	//if i is the last treasure in our bag:
	if (treasure_obtained == total_treasure
			&& current_best + to_end_cost[i] < bestconfig) {
		bestconfig = current_best + to_end_cost[i];
		return;
	}

	free[i] = false;

	for (int next = 0; next < total_treasure; next++)
		if (free[next]
				&& current_best + treasures_cost[i * total_treasure + next] + to_end_cost[next]
						< bestconfig) {
			current_best = current_best
					+ treasures_cost[i * total_treasure + next];
			try_next(next, treasure_obtained + 1);
			current_best = current_best
					- treasures_cost[i * total_treasure + next];
		}

	free[i] = true;
}

int bfs_cost(int from_i, int from_j, int to_i, int to_j) {
	queue<int> q;
	q.push(from_i * n + from_j);

	bool free[13 * 13];
	for (int i = 0; i < n * n; i++)
		free[i] = true;
	free[from_i * n + from_j] = false;

	int d[13 * 13];
	for (int i = 0; i < n * n; i++)
		d[i] = 0;
	bool found = false;

	while (!q.empty()) {
		int next = q.front();
		q.pop();

		if (next == to_i * n + to_j) {
			found = true;
			break;
		}
		int i = next / n, j = next % n;
		if (i > 0 && maze[(i - 1) * n + j] != '#' && free[(i - 1) * n + j]) {
			q.push((i - 1) * n + j);
			free[(i - 1) * n + j] = false;
			d[(i - 1) * n + j] = d[next] + 1;
		}
		if (i + 1 < n && maze[(i + 1) * n + j] != '#'
				&& free[(i + 1) * n + j]) {
			q.push((i + 1) * n + j);
			free[(i + 1) * n + j] = false;
			d[(i + 1) * n + j] = d[next] + 1;
		}
		if (j > 0 && maze[(i) * n + j - 1] != '#' && free[(i) * n + j - 1]) {
			q.push((i) * n + j - 1);
			free[i * n + j - 1] = false;
			d[i * n + j - 1] = d[next] + 1;
		}
		if (j + 1 < n && maze[(i) * n + j + 1] != '#'
				&& free[(i) * n + j + 1]) {
			q.push((i) * n + j + 1);
			free[i * n + j + 1] = false;
			d[i * n + j + 1] = d[next] + 1;
		}
	}
	if (found)
		return d[to_i * n + to_j];
	else
		return 10000;
}
