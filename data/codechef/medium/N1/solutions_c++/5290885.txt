#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;

void Orienteering() {
typedef pair<int,int> pair_inner;
int x_steps[]={1,-1,0,0};
int y_steps[]={0,0,1,-1};
queue<pair<pair_inner,pair_inner> > Q;
int checkpoint_num[102][102];
int startx,starty,endx,endy;
int W,H,check_points=1,check_points_found=0;
cin>>W;
H=W;
//cout<<W<<" "<<H;
char input[W+2][H+2];

    for(int i=0;i<H;i++)
    scanf("%s",input[i]);

    for(int i=0;i<H;i++){
            for(int j=0;j<W;j++){
                if(input[i][j]=='*'){
                 checkpoint_num[i][j]=check_points;
                 check_points++;
                }


            }
    }
    //cout<<check_points<<"-";
    //cout<<input[0]<<"-";
     //queue<pair<pair_inner,pair_inner> > empty;
     //swap( Q, empty );

startx=0;starty=0;
endx=W-1;endy=H-1;
bool ***visited = new bool **[W];	//x part of array
		for(int i = 0; i < W; i++)
		{
			visited[i] = new bool *[W];	//y part of array
			for(int j = 0; j < W; j++)
			{
				visited[i][j] = new bool [1<<check_points];	//attempt part of array
				for(int k = 0; k < 1<<check_points; k++)
					visited[i][j][k] = 0;
			}
		}
int try_x,try_y,steps_upto,solution=0;
pair<pair_inner,pair_inner> attempt;
Q.push(make_pair(pair_inner(0,0),pair_inner(startx,starty)));

visited[startx][starty][check_points_found]=1;
    while(!Q.empty()){
        attempt=Q.front();
        Q.pop();
        startx=attempt.second.first;
        starty=attempt.second.second;
        check_points_found=attempt.first.first;
        steps_upto=attempt.first.second;

         if(endx==startx&&endy==starty&&check_points_found==((1<<(check_points-1))-1)){
            solution=1;
            break;
         }
         for(int i=0;i<4;i++){
            try_x=startx+x_steps[i];
            try_y=starty+y_steps[i];
             if(try_x<H&&try_x>=0&&try_y<W&&try_y>=0&&visited[try_x][try_y][check_points_found]==0&&input[try_x][try_y]!='#'){
                visited[try_x][try_y][check_points_found]=1;
                if(input[try_x][try_y]=='*')
                Q.push(make_pair(pair_inner(check_points_found|(1<<(checkpoint_num[try_x][try_y]-1)),steps_upto+1),pair_inner(try_x,try_y)));

                else
                Q.push(make_pair(pair_inner(check_points_found,steps_upto+1),pair_inner(try_x,try_y)));

             }
            }
         }
    if(solution)
    cout<<steps_upto<<"\n";
    else
    cout<<"-1\n";
    return;
    }

int main() {
    #ifndef ONLINE_JUDGE
   freopen("input.txt","r",stdin);
    #endif
    int t;
    cin>>t;
    while(t--){

    Orienteering();

    }
return 0;
}
