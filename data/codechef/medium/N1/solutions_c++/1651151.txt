#include<iostream>
#include<vector>
#include<string>
#include<queue>

#define ITERATE(c,it) for(typeof((c).begin()) it = (c).begin();it!=(c).end();it++) 
#define PN(i,j) my_pair(i,j,N)
#define PS(i,j) my_pair(i,j,max_subsets)

#define UN(val,k,l) get_pair(k,l,val,N)
#define US(val,k,l) get_pair(k,l,val,max_subsets)
 
const int max_treasure = 13;
const int max_n = 13;
const int max_subsets = 1 << max_treasure;
const int max_vertices = max_n*max_n; 

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vii;

inline int mark(int i,int val)
{
	return (1<<i) | val;
}
inline int my_pair(int i,int j,int Base)
{
	//Map from NxN->N. Note 0<=j<base
	return i*Base+j;
} 

void get_pair(int & i,int & j,int Val,int Base)
{
	j = Val% Base;
	i = (Val - j) / Base;
}

int dist[(max_vertices+1)*max_subsets];
int tr_index[max_vertices];
string maze[max_n];
vii adj_list(max_vertices,vector<int>());

 
int main(){
	int T,N;
	cin >> T;
	for(int i=0;i<T;i++){
		cin >> N;
		int tr_count = 0; //Treasure count
		for(int j=0;j<N;j++){
			cin>>maze[j];
			for(int k=0;k<N;k++){
				adj_list[PN(j,k)].clear();
				
				if(maze[j][k] == '*') 
					tr_index[PN(j,k)] = (tr_count++); 
				else 
					tr_index[PN(j,k)] = -1;
				
				if(maze[j][k] == '#')
					continue;
					
				if(j>0 && maze[j-1][k] != '#'){
					adj_list[PN(j-1,k)].push_back(PN(j,k));
					adj_list[PN(j,k)].push_back(PN(j-1,k));
				}
				if(k > 0 && maze[j][k-1] != '#'){
					adj_list[PN(j,k-1)].push_back(PN(j,k));
					adj_list[PN(j,k)].push_back(PN(j,k-1));
				}

			}
		
			
		
		}
		
		for(int j=0;j<N;j++){
			for(int k=0;k<N;k++){
				for(int l=0;l<(1<<tr_count);l++)
					dist[PS(PN(j,k),l)] = -1;
				}
			}
		queue<int> q;
		q.push(PS(PN(0,0),0));
		dist[PS(PN(0,0),0)] = 0;
		while (q.size()){
			int val=q.front();
			int vertex,treasure_collected; 
			q.pop();
			US(val,vertex,treasure_collected);
			ITERATE(adj_list[vertex],it){
					int next = PS(*it,treasure_collected);
					if(tr_index[*it] != -1)
						next=PS(*it,mark(tr_index[*it],treasure_collected));
					if(dist[next] == -1){
						dist[next] = dist[val] + 1;
						q.push(next);
						}
				}
			
			}
		cout<<dist[PS(PN(N-1,N-1),(1<<tr_count)-1)]<<endl;
	}
}
