// Prepend this entire file to main when ready to submit.
 
#ifndef PROGRAMMING_CONTESTS_H
#define PROGRAMMING_CONTESTS_H
 
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <typeinfo>
#include <utility>
using namespace std;
 
typedef long long LL;
 
#define RI(x) int x; scanf("%i", &x)
#define RLL(x) long long x; scanf("%lli", &x)
#define RS(x) char _buf[2000]; scanf("%s", _buf); string x(_buf)
#define RL(x) string x; getline(cin, x) //Does not include line break at end.
#define FIN(path) freopen(path, "r", stdin)
#define FOUT(path) freopen(path, "w", stdout)
 
#define IT(c) typeof(c.begin())
#define FOR(i, a, b) for(int i=(a), _b=(b); i<_b; ++i)
#define FORR(i, a, b) for(int i=(b-1), _a=(a); i>=_a; --i)
#define FORE(it, c) for(IT(c) it=c.begin(); it!=c.end(); ++it)
#define ALL(x) x.begin(), x.end()
 
#define PB push_back
#define MP make_pair
#define SZ(c) ((int)c.size())
#define LEN(a) (sizeof(a)/sizeof(a[0]))
#define END(a) (a+LEN(a))
 
#define TWO(e) (1<<e)
#define TWOL(e) (1LL<<e)
 
 
static const double PI = acos(-1.0);
static const double GOLD = (1+sqrt(5.0))/2;
 
 
 
 
// Requires that type of v is the type that a contains.
template <typename A, typename V>
static void fillArray(A &a, const V &v) {
  fill((V*)a, (V*)a+sizeof(a)/sizeof(V), v);
}
 
 
// Pieces which are the empty string are dropped.
static void split(const string &s, vector<string> &pieces, const string &delim = " ") {
  unsigned int nextI = 0;
    for(unsigned int cutAt = s.find(delim,nextI); cutAt != s.npos; cutAt = s.find(delim,nextI)) {
         if(cutAt > nextI) pieces.push_back(s.substr(nextI,cutAt-nextI));
         nextI = cutAt+delim.length();
    }
    if(nextI < s.length()) {
         pieces.push_back(s.substr(nextI));
  }
}
 
static string toLower(const string& s) {
  string t = s;
  transform(s.begin(), s.end(), t.begin(), (int (*)(int))tolower);
  return t;
}
static string toUpper(const string& s) {
  string t = s;
  transform(s.begin(), s.end(), t.begin(), (int (*)(int))toupper);  
  return t;
}
 
 
 
static bool isLetter(const char& c) {
  char d = tolower(c);
  return d >= 'a' && d <= 'z';
}
static bool isVowel(const char& c) {
  char d = tolower(c);
  return d=='a'||d=='e'||d=='i'||d=='o'||d=='u'||d=='y';
}
static bool isConsonant(const char& c) {
  return isLetter(c) && !isVowel(c);
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
// Stuff for debugging.
 
static void sleep(const int ms) {
    clock_t goal = ms + clock();
    while (goal > clock());
}
 
template<typename T>
static void print(T x) {
  cout << x << endl;
}
 
template<typename T>
static void print(T first, const T &last) {
  while(first != last) cout << *(first++) << " ";
  cout << endl;
}
 
template<typename T, size_t LENGTH>
static void print(const T (&a)[LENGTH]) {
  print(a,a+LENGTH);
}
 
template<typename T, size_t LENGTH0, size_t LENGTH1>
static void print(const T (&a)[LENGTH0][LENGTH1]) {
  for(int i = 0; i < LENGTH0; ++i) {
    print(a[i]);
  }
}
 
static double timer() {
  return 1.0*clock()/CLOCKS_PER_SEC;
}
 
#endif // PROGRAMMING_CONTESTS_H
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
string mapp[15];
int trea[15][15];
int ntrea;
int N;
 
 
// Efficient representation of an array in which index i
// can be assigned values 0,...,2^baB[i]-1. Thus baB[i]
// is the number of bits to represent index i.
//MODIFY///////////////////////////////////////////////////////
typedef int baT; const int baLen = 8*sizeof(baT);
const static int baB[baLen] = {4,4,1,1,1,1,1,1,1,1,1,1,1,1,1}; // Values must be >= 0 and sum to <= 64.
///////////////////////////////////////////////////////////////
static int baBS[baLen] = {0}; // index i is sum from baB[0] to baB[i-1] 
 
inline static void baInit() {
  static bool done = false;
  if(!done){for(int i = 1; i < baLen; ++i) baBS[i] = baBS[i-1]+baB[i-1]; done=true;}
}
 
// Sets value of index i to v.
inline static void baSet(baT& s, const int& i, const baT& v) {
  baInit();
  // Set bits for index i to 0.
  baT mask = ~(((1 << baB[i])-1) << baBS[i]);
  s &= mask;
  // Set bits for index i to v.
  mask = v << baBS[i];
  s |= mask;
}
 
// RETURNS: Value of index i.
inline static baT baGet(const baT& s, const int& i) {
    baInit();
    baT mask = ((1 << baB[i])-1) << baBS[i];
    return (s & mask) >> baBS[i];
}
 
inline static baT baMax() {
  baT res = 0;
  for(int i = 0; i < baLen; ++i) baSet(res,i,(1 << baB[i])-1);
  return res;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
static int dr[] = {0,1,0,-1};
static int dc[] = {-1,0,1,0};
 
 
typedef baT State;
typedef int Cost;
const Cost INF = 1000000000;
 
 
State goal;
inline bool isGoal(const State &s) {
  return s == goal;
}
 
struct StateComparator {
  public:
    bool operator()(const State &s, const State &t) const {
      return s < t;
    }
};
 
 
 
 
 
//RETURNS: Cost of path from start to a goal state or INF if no such path exists.
//map<State,Cost,StateComparator> costsFromStart;
int* costsFromStart = new int[baMax()+1];
//map<State,State,StateComparator> prev;
//vector<State> path;
//Cost maxCost = -1;
 
Cost bfs(State start) {
  fill(costsFromStart,costsFromStart+baMax()+1,INF);
  queue<State> q;
  q.push(start);
  costsFromStart[start] = 0;
  while(!q.empty()) {
    const State& curr = q.front();
    if(isGoal(curr)) {
      //path = makePath(curr,prev,path);
      return costsFromStart[curr];
    }
 
 
    
    
    const Cost& currCost = costsFromStart[curr];
 
    int r = baGet(curr,0);
    int c = baGet(curr,1);
    FOR(i,0,4) {
      int rr = r+dr[i];
      int cc = c+dc[i];
      if(rr>=0&&rr<N&&cc>=0&&cc<N&&mapp[rr][cc]!='#') {
        State ss = curr;
        baSet(ss,0,rr);
        baSet(ss,1,cc);
        if(mapp[rr][cc]=='*') baSet(ss,2+trea[rr][cc],1);
        
        if(costsFromStart[ss] == INF) {
                q.push(ss);
                //prev[succ] = curr;
                costsFromStart[ss] = currCost+1;
              }
 
      }
    }
    
    
    
    
    q.pop();
    //if(q.empty()) maxCost = currCost;
  }
  return INF;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
int main(int argc, char** argv) {
  //double start = timer();
  //FIN("input.txt");
  RI(t);
  FOR(test,0,t) {
    int next=0;
    ntrea=0;
    fillArray(trea,0);
    RI(N_); N=N_;
    FOR(i,0,N) {
      RS(s);
      mapp[i] = s;
      FOR(j,0,N) {
        if(mapp[i][j]=='*') {
          trea[i][j]=next++;
          ++ntrea;
        }
      }
    }
    
    goal=0;
    baSet(goal,0,N-1);
    baSet(goal,1,N-1);
    FOR(i,2,2+ntrea) baSet(goal,i,1);
    
    int res = bfs(0);
    printf("%i\n",res==INF?-1:res);
  }
  
  //cout << timer()-start;
  return 0;
}