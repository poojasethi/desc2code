#include<iostream>
#include<string.h>
#include<stdio.h>
using namespace std;

 
const int MAXNODE = 13;
char map[MAXNODE+2][MAXNODE+3];
int dist[MAXNODE+2][MAXNODE+2];
int pi[MAXNODE+2];
int pj[MAXNODE+2];
int qi[(MAXNODE+2) * (MAXNODE+2)];
int qj[(MAXNODE+2) * (MAXNODE+2)];
int ql[(MAXNODE+2) * (MAXNODE+2)];
int dp[1<<MAXNODE][MAXNODE+1];
bool done[MAXNODE+2][MAXNODE+2];
int T, N;

int xMove[4]={0,0,1,-1};
int yMove[4]={1,-1,0,0};


class Orienteering {
int N;
public:
	Orienteering(){
		}

	
	void main();
	void read();
	void makeGraph();
	//int bfs(int,int);
//	void compute();
	
	bool isSafe(int,int);
 
	
	 
	int cal_dist(int s, int d)
	{
	
			
	int Q[50000][3];
	int top,rear;
	top = rear = 0;
	
	int t1 = pi[s];
	int t2 = pj[s];
	Q[rear][0] = t1;
	Q[rear][1] = t2;
	Q[rear++][2] = 0;
	
	
	int visited[101][101];
	
	for(int i=0;i<N;i++)
	for(int j=0;j<N;j++)
	visited[i][j] = 0;
	
	
	visited[t1][t2] = 1;
	while(top<rear){
		int i = Q[top][0];
		int j = Q[top][1];
		int depth = Q[top][2];
		
		if(pi[d]==i && pj[d]==j){
			return Q[top][2];
		}
		top++;
		for(int k=0;k<4;k++){
			int x = i+xMove[k];
			int y = j+yMove[k];
			
			if(isSafe(x,y) && visited[x][y]==0){
				Q[rear][0] = x;
				Q[rear][1] = y;
				Q[rear++][2] = depth+1;
				visited[x][y] = 1;
			}
		}
	}
	return -1;
	
	
	}
	
};


void Orienteering::main() {
	read();
	makeGraph();
}


void Orienteering::read() {
	cin>>N;
	for(int i=0;i<N;i++){
			cin>>map[i];
	}
}


	bool Orienteering::isSafe(int i,int j) {

		if(i>=0 && j>=0 && i<N && j<N && map[i][j]!='#')
			return true;
		return false;
	}

void Orienteering::makeGraph() {
	
			
		int tr = 0;
		int d;
		pi[tr] = 0;
		pj[tr++] = 0;
		for(int i=0; i<N; i++)
		for(int j=0; j<N; j++)
		{
		if (map[i][j] == '*')
		{
		pi[tr] = i;
		pj[tr++] = j;
		}
		}
		pi[tr] = pj[tr] = N - 1;
		for(int i=0; i<=tr; i++)
		{
		dist[i][i] = 10000;
		for(int j=i+1; j<=tr; j++)
		{
		if ((d=cal_dist(i, j)) < 0)
		{
		printf("-1\n");
		return;
		}
		dist[i][j] = dist[j][i] = d;
		}
		}
		tr -= 1;
		memset(dp, 0x01, sizeof(dp));
		for(int i=0; i<tr; i++)
		dp[1<<i][i+1] = dist[0][i+1];
		 
		for(int i=1; i<(1<<tr); i++)
		for(int j=0; j<tr; j++)
		if ((1<<j)&i)
		for(int k=0; k<tr; k++)
		if(((1<<k)&i)==0)
		dp[(1<<k)|i][k+1] = min(dp[(1<<k)|i][k+1],
		dp[i][j+1] + dist[j+1][k+1]);
		int opt = 10000;
		for(int i=1; i<=tr; i++)
		opt = min(opt, dp[(1<<tr)-1][i] + dist[i][tr+1]);
		printf("%d\n", opt);
	
}



int main(int argc, char* argv[]) {
	int T;
	scanf("%d",&T);
	while(T--)
	{
	Orienteering o;	
	o.main();
}	return 0;
}
