#include <cstdio>
#include <cstring>
#include <algorithm>
#define MAX 1e9
#define LEFT 0
#define UP 1
using namespace std;

int rows, cols, zoo[104][104], dp[104][104][2];

void init()
{	memset(zoo, 0, sizeof zoo);
	for (int i = 0; i < 104; ++i)
	{	for (int j = 0; j < 104; ++j)
			dp[i][j][0] = dp[i][j][1] = MAX;
	}
}

void read_input()
{	char str[102];
	scanf("%d %d", &rows, &cols);
	for (int i = 1; i <= rows; i++ )
	{	scanf("%s", str);
		for (int j = 0; j < cols; j++ )
			zoo[i][j+1] = (str[j] == '1');
	}
}

void solve()
{	for (int i = 1; i <= rows; ++i)
	{	for (int j = 1; j <= cols; ++j)
		{	dp[i][j][LEFT] = zoo[i + 1][j] + zoo[i][j + 1];
			dp[i][j][UP] = zoo[i + 1][j] + zoo[i][j + 1];
			// this will be considered for every element (overflows are assigned 0 so no problems of any extra addition )
			if(i == 1 && j == 1)
			{	dp[i][j][LEFT] += zoo[i][j];		// for first element(top left element )
				dp[i][j][UP] += zoo[i][j];
			}
			else
			{	dp[i][j][LEFT] += min(dp[i][j - 1][LEFT] + zoo[i - 1][j], dp[i][j - 1][UP]);
				dp[i][j][UP] += min(dp[i - 1][j][LEFT], dp[i - 1][j][UP] + zoo[i][j - 1]);
			}
		}
	}
	printf("%d\n", min( dp[rows][cols][LEFT], dp[rows][cols][UP] ));
}

int main()
{	int t;
	scanf("%d",&t);
	while (t-- > 0)
	{	init();
		read_input();
		solve();
	}
	return 0;
}

/* Codechef editorial:
Main concept- Think of correct recurrence statement first!! Number of parameters -> no. of dimensions

keep N x M x 2 states, where the extra "2" tells you whether you have come from "up" or from "left". Given this, you will be able to tell where you have come from, and where to look for a double-count mouse.
#define LEFT 0
#define UP 1

Let DP[i][j][LEFT] = Minimum number of mice that scared elephant till (i,j) assuming you came from the left i.e. (i, j-1) side,
and DP[i][j][UP] = Minimum number of mice that scared elephant till (i,j) assuming you came from the left i.e. (i-1, j) side,
effect of UP/LEFT explained below

just using the fair assumption that if we go from left then 
		i-1,j
i,j-1	-> 	i,j		i,j+1
		i+1,j
just consider (i+1,j), (i,j+1) and (i-1,j)

and for if we go from up then 
		i-1,j
		 |
i,j-1		i,j		i,j+1
		i+1,j
just consider (i+1,j), (i,j+1) and (i-1,j)
IS WRONG ( consider the third column of third line element. Here we count occurence of mice at 3rd col of 2nd row twice in this way!
	
Now lets take the example to guide you the idea first

0	0	1	0	0	0	0	0	1	0
1	1	1	1	1	1	0	1	0	0
1	0	0	1	0	0	1	0	0	0


1st row
1	3	4	5	6	7	7	9	9

for second row:
3	4	5	7	7	7	9	9	9

for 3rd row
3	3	5	6	7	8	8	9	9

now what we did for 3rd row?

for 
any elemnt (i,j)


i-2, j-2		i-2, j-1		i-2, j		i-2, j+1
i-1, j-2		i-1, j-1		i-1, j		i-1, j+1
i, j-2			i, j-1			i, j		i, j+1
i+1, j-2		i+1, j-1		i+1, j		i+1, j+1

Now if we go to i,j from i, j-1 then we have to consider i,j = i,j+1 and i+1,j. 
Now if we came to i, j-1 from its left then we did not consider mice at position i-1,j but if we would have come to i, j-1 from i-1,j-1 (up) then i-1,j-1 would have already included the mice at position at i-1,j
hence the dp->
for (int j = 1; j <= cols; ++j)
{	dp[i][j][LEFT] = zoo[i + 1][j] + zoo[i][j + 1];
	dp[i][j][UP] = zoo[i + 1][j] + zoo[i][j + 1];
	if(i == 1 && j == 1)
	{	dp[i][j][LEFT] += zoo[i][j];
		dp[i][j][UP] += zoo[i][j];			i,j+1 and i+1,j will always be considered
	}
	else
	{	dp[i][j][LEFT] += min(dp[i][j - 1][LEFT] + zoo[i - 1][j], dp[i][j - 1][UP]);
		dp[i][j][UP] += min(dp[i - 1][j][LEFT], dp[i - 1][j][UP] + zoo[i][j - 1]);
		// avoid any repetiotion using 3rd dimension
	}
}
*/