//3d dp which required knowing the path in the previous state
// nice question for dp practice
#include <cstdio>
#include <algorithm>

#define INF 100000000
char str[101];
int dp[101][101][2], shadows[101][101], a[101][101];

int main() {
    int t, n, m;
    scanf("%d",&t);
    while(t--) {
        scanf("%d%d",&n,&m);
        for(int i=0;i<n;++i) {
            for(int j=0;j<m;++j) {
                shadows[i][j] = 0;
            }
        }
        for(int i=0;i<n;++i) {
            scanf("%s",str);
            for(int j=0;j<m;++j) a[i][j] = str[j]-'0';
        }
        if(a[0][0]) {
            shadows[0][1]++;
            shadows[1][0]++;
        }
        if(a[0][m-1]) {
            shadows[0][m-2]++;
            shadows[1][m-1]++;
        }
        if(a[n-1][0]) {
            shadows[n-2][0]++;
            shadows[n-1][1]++;
        }
        if(a[n-1][m-1]) {
            shadows[n-2][m-1]++;
            shadows[n-1][m-2]++;
        }
        for(int j=1;j<m-1;++j) {
            if(a[0][j]) {
                shadows[0][j-1]++;
                shadows[0][j+1]++;
                shadows[1][j]++;
            }
        }
        for(int j=1;j<m-1;++j) {
            if(a[n-1][j]) {
                shadows[n-1][j-1]++;
                shadows[n-1][j+1]++;
                shadows[n-2][j]++;
            }
        }
        for(int i=1;i<n-1;++i) {
            if(a[i][0]) {
                shadows[i-1][0]++;
                shadows[i][1]++;
                shadows[i+1][0]++;
            }
        }
        for(int i=1;i<n-1;++i) {
            if(a[i][m-1]) {
                shadows[i-1][m-1]++;
                shadows[i][m-2]++;
                shadows[i+1][m-1]++;
            }
        }
        for(int i=1;i<n-1;++i) {
            for(int j=1;j<m-1;++j) {
                if(a[i][j]) {
                    shadows[i-1][j]++;
                    shadows[i][j-1]++;
                    shadows[i][j+1]++;
                    shadows[i+1][j]++;
                }
            }
        }

        dp[0][0][0] = dp[0][0][1] = shadows[0][0]+a[0][0]; //mouse is added because every-time a mouse is found it is subtracted later
        for(int j=1;j<m;++j) {
            dp[0][j][0] = dp[0][j-1][0]+shadows[0][j]-a[0][j-1];
            dp[0][j][1] = INF;
        }
        for(int i=1;i<n;++i) {
            dp[i][0][0] = INF;
            dp[i][0][1] = dp[i-1][0][1]+shadows[i][0]-a[i-1][0];
        }
        int t1, t2;
        for(int i=1;i<n;++i) {
            for(int j=1;j<m;++j) {
                dp[i][j][0] = shadows[i][j]-a[i][j-1]+std::min(dp[i][j-1][0],dp[i][j-1][1]-a[i-1][j]);
                dp[i][j][1] = shadows[i][j]-a[i-1][j]+std::min(dp[i-1][j][1],dp[i-1][j][0]-a[i][j-1]);
            }
        }
        printf("%d\n",std::min(dp[n-1][m-1][0],dp[n-1][m-1][1]));
    }
    return 0;
}
