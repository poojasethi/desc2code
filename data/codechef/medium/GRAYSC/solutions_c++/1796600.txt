#include <iostream>
#include <string>
#include <algorithm>
#include <cstdio>
#include <map>
#include <vector>
#include <iomanip>
#include <cstring>
#include <bitset>
#include <set>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <list>
#include <queue>
#include <cassert>
#include <deque>
#include <stack>
#include <ctime>
#include <cmath>

using namespace std;

#define FOR(i, a, b) for(int i = a; i < b; i++)
#define FORN(i, a, b) for (int i = a; i >= b; i--)
#define REP(i, a) FOR(i, 0, a)
#define REPN(i, a) FORN(i, a, 0)
#define FOREACH(it, c) for (typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define CLEAR(b) memset((b), 0, sizeof(b))
#define SET(a, b) memset((a), (b), sizeof(a))
#define setmax(a, b) if (a < b) {a = b;}
#define setmin(a, b) if (a > b) {a = b;}
#define ub(V, x) upper_bound((V).begin(), (V).end(), x)
#define lb(V, x) lower_bound((V).begin(), (V).end(), x)
#define pb push_back
#define mp make_pair

const int INF = 0x3f3f3f3f;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int u32;
#define DEBUG 0
const int N = 100001;

ull a[N], b[N];

int GetBit(ull n) {
    ull tmp = 1ULL;
    if (n & tmp) return 0;
    FOR(i, 1, 64) {
        if ((tmp << i) & n) return i;
    }
    return -1;
}

int main() {
#if DEBUG
    freopen("ques.txt", "r", stdin);
    freopen("ans.txt", "w", stdout);
#endif
    int n;
    scanf("%d", &n);
    REP(i, n)
        scanf("%llu", a + i);
    map<ull, int> cmap;
    cmap[a[n - 1]] = 1;
    set<ull> dset; // for duplicates
    int bitStart[64] = {-1};
    int bits[64] = {0};
    REP(i, n - 1) {
        if (cmap.find(a[i]) == cmap.end())
            cmap[a[i]] = 1;
        else {
            int cnt = cmap[a[i]];
            // There are four repeated numbers
            if (cnt == 3) {
                printf("Yes\n");
                return 0;
            }
            cmap[a[i]] = cnt + 1;
            dset.insert(a[i]);
            if (dset.size() > 1) {
                printf("Yes\n");
                return 0;
            }
        }
        b[i] = a[i] ^ a[i + 1];
        int bit = GetBit(b[i]);
        assert(bit != -1);
        ++bits[bit];
        // if found this bit index for the first time, then update bitStart for this position
        if (bits[bit] == 1) bitStart[bit] = i;
        if (bits[bit] > 1 && bitStart[bit] + 2 <= i) {
            printf("Yes\n");
            return 0;
        }
    }
    printf("No\n");
    return 0;
}
