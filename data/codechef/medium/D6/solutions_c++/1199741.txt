#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <utility>
#include <stack>
#include <deque>
#include <queue>
#include <fstream>
 
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cassert>
 
using namespace std;
 
const int MAX_POINTS = 100;
bool plane[MAX_POINTS + 1][MAX_POINTS + 1] = { false };
 
struct point {
	int x;
	int y;
 
	point(int x = 0, int y = 0) 
		: x(x), y(y) {
	}
 
	bool operator <(const point& rhs) const {
		if (x < rhs.x) {
			return true;
		}
		else if (x > rhs.x) {
			return false;
		}
		else {
			return (y < rhs.y);
		}
	}
 
	bool operator >(const point& rhs) const {
		if (x > rhs.x) {
			return true;
		}
		else if (x < rhs.x) {
			return false;
		}
		else {
			return (y > rhs.y);
		}
	}

	friend 
	ostream& operator <<(ostream& out, const point& rhs) {
		return out << "(" << rhs.x - 50 << "," << rhs.y - 50 << ")";
	}
};
 
bool is_in_range(const point& pt) {
	return (pt.x >= 0 && pt.y >= 0 && pt.x <= MAX_POINTS && pt.y <= MAX_POINTS);
}

bool is_in_plane(const point& pt) {
	return plane[pt.x][pt.y];
}
 
/*
	For every pair, we look for another two
	and note that these coordinates are already sorted
	which means the second point is always greater than
	equal to the first point 
*/
int how_many_squares(const vector<point>& coordinates) {
 
	int size = coordinates.size();
	int dx = 0;
	int dy = 0;
	int count = 0;
 
	point p3(0, 0);
	point p4(0, 0);
 
	for (int i = 0; i < size; ++i) {
		for (int j = i + 1; j < size; ++j) {
			// to avoid duplicate we only check all pairs
			// that are far to the right (in y-axis)
			if (coordinates[j].y > coordinates[i].y) {
				// calculate dx, dy
				dx = abs(coordinates[j].x - coordinates[i].x);	
				dy = abs(coordinates[j].y - coordinates[i].y);

				// greater is j
				p3.x = coordinates[i].x + dy;
				p3.y = coordinates[i].y - dx;

				p4.x = coordinates[j].x + dy;
				p4.y = coordinates[j].y - dx;

				if (is_in_range(p3) && is_in_range(p4) && is_in_plane(p3) && is_in_plane(p4)) {
					count++;
				}
			}	 
		}
	}
 
	return count;
}
 
void inout_count_the_squares() {
	int test_cases;
	cin >> test_cases;
 
	int n;
	int x;
	int y;
	vector<point> coordinates;
 
	while (test_cases--) {
		cin >> n;
 
		memset(plane, 0, sizeof(plane));
		for (int i = 0; i < n; ++i) {
			cin >> x >> y;
			// we shift (x, y) 50 to right and up so we can 
			// ignore the negative value when constructing
			// matrix 
			coordinates.push_back(point(x + 50, y + 50));
			
			// there is a pair (x, y)
			plane[x + 50][y + 50] = true;
		}
 
		// sort these coordinates
		sort(coordinates.begin(), coordinates.end());
		cout << how_many_squares(coordinates) << endl;
		coordinates.clear();
	}
}
 
int main() {
	inout_count_the_squares();
	return 0;
}  