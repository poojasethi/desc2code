#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <limits>
#include <cctype>

using namespace std;
/*
///dah esbat el function grundy
int dp[109][109];
int grundy(int a,int b)
{
   int &ret=dp[a][b];
    if(ret!=-1)
        return ret;
        
    if(a==0) return ret=b;
    if(b==0) return ret=a;
    
    
    
    vector<int> childs;

    
    for(int i=1;i<=b;i++)
        childs.push_back(grundy(a,b-i));
    
    int st=0;
    ret=0;
    
    sort(childs.begin(),childs.end());
    for(int i=0;i<childs.size();i++)
    {
        //cout<<childs[i]<<" ";
        if(childs[i]!=st)
        {
            return ret=st;
            break;
        }
        else
            st++;
    }
    ret=childs.back()+1;
    
    return ret;
    
}
int main()
{
    cout<<0.000<<endl;
    #ifndef ONLINE_JUDGE
  freopen("2.txt","r",stdin);
  #endif
  
  for(int i=1;i<=9;i++)
  {
      memset(dp,-1,sizeof dp);
         cout<<i<<" "<<grundy(5,i)<<endl;;
         
         }
  
  
}
*/


/*
An Easy way to understand
 
vector<int> ans;
void  Grundy(int a,int b)
{
    //cout<<a<<" "<<b<<endl;
    if(a<b)
        swap(a,b);
 
    if(a%b==0)
         {
             ans.push_back((a/b)-1);
             return ;
         }
 
 
    int ret=a/b;
    ans.push_back(ret);
    Grundy(a-(ret*b),b);
 
 
    return ;
}
int main()
{
    #ifndef ONLINE_JUDGE
  freopen("2.txt","r",stdin);
  #endif
 
  int tc;
  cin>>tc;
  while(tc--)
  {
      int n;
      cin>>n;
       int x=0;
       while(n--)
       {
           int a,b;
           cin>>a>>b;
           ans.clear();
           Grundy(a,b);
 
           int ret=0;
           ///now every entry in ans in order define  length of piles  but from 0 -to - n i cant draw from pile i untill i finsh all piles from 0-to i-1
           ///so if I have only the last pile mex[one last pile]=last pile
           //// then in order go back then i have mex and a new pile ,, and from the code above shown the relation of grundy :)   
           /// i can calculate the new mex from the old mex and new size
        
           for(int i=ans.size()-1;i>=0;i--)
           {
               a=ans[i];
               //cout<<a<<" ";
               if(a==0)
                  continue;
               if(a<=ret)
                  ret=a-1;
               else
                ret=a;
           }
           //cout<<ret<<endl;
           x^=ret;
       }
 
       if(x)
        cout<<"YES"<<endl;
       else
        cout<<"NO"<<endl;
  }
}
 */
int  Grundy(int a,int b)
{
    if(a<b)
        swap(a,b);
    
    if(a%b==0)
             return (a/b)-1;
    
    
    int ret=a/b;
    int mex=Grundy(a-(ret*b),b);
    
    if(ret<=mex)
        ret--;
    return ret;
}
int main()
{
    #ifndef ONLINE_JUDGE
  freopen("2.txt","r",stdin);
  #endif
  
  int tc;
  cin>>tc;
  while(tc--)
  {
      int n;
      cin>>n;
       int x=0;
       while(n--)
       {
           int a,b;
           cin>>a>>b;

           x^=Grundy(a,b);
       }
       
       if(x)
        cout<<"YES"<<endl;
       else
        cout<<"NO"<<endl;
  }
}
