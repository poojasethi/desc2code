#include<bits/stdc++.h>
#define pb push_back
#define inf 99999999
#define mp make_pair
#define Vector vector<int>
#define Vov vector<vector<int> >
#define ll long long
#define FILL(a,val) memset(a,val,sizeof(val))
#define Min(a,b) (a < b) ? a:b
#define Max(a,b) (a > b) ? a:b
#define sn(n) scanf("%d",&n)
#define p(n) printf("%d\n",n)
#define ss(s) scanf("%s",s)
#define Swap(a,b) (a = b+a-(b=a))
#define FOR(i,a,b) for(i=a;i<b;i++)
#define FORE(i,a,b) for(i=a;i <= b;i++)
#define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)
#define p_limit 10000001
#define gc() getchar_unlocked()
using namespace std;
int gcd(int a,int b){
	return (!b) ? a:gcd(b,a%b);
}
vector<vector<int> >graph(10000);
void inp_graph(){
	int n,m,src,des,i;
	sn(n);sn(m);
	FOR(i,0,m){
		sn(src);sn(des);
		graph[src].pb(des);
	}
}
int n;
bool prime[p_limit];
ll cost[p_limit];
//vector<vector<int> >grid(n,vector<int>(n));
//vector<vector<bool> >visit(n,vector<bool>(n));
int grid[1000][1000];
bool visit[1000][1000];
int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};
inline int inp() {
  int n = 0;
  int ch = gc();
  int sign = 1;
  while(ch < '0' || ch > '9') {
    if (ch == '-') sign = -1;
    ch = gc();
  }
  while(ch >= '0' && ch <= '9')
    n = (n<<3) + (n<<1) + ch - '0', ch = gc();
  return n = n*sign;
};
void sieve(){
	int i,j;
	int cnt;
	prime[0]=false;
	prime[1]=false;
	FOR(i,2,p_limit){
		prime[i] = true;
	}
	for(i=2;i<sqrt(p_limit);i++){
		if(prime[i]==1){
			for(j=i*i; j < p_limit;j+=i){
				prime[j] = 0;
			}
		}
	}
	cnt = 0;
	FORE(i,0,p_limit){
		if(prime[i] == 1){
			cost[i] = cnt++;
		}
		else{
			cost[i] = (i%2 == 0) ? (i/2) : (i+3)/2;//(i/2) + (i%2) * 2;
		}
	}
}

void dfs(int src,int des){
	visit[src][des] = true;
	int type = (grid[src][des] % 2 == 0) ? 2 : 1;
	for(int i=0;i<4;i++){
		int x = src + dx[i];
		int y = des + dy[i];
		if(x < 0 || x >= n || y < 0 || y >= n)
			continue;
		if(visit[x][y])
			continue;
		if(!prime[grid[x][y]] && grid[src][des] % 2 == grid[x][y] % 2)
			dfs(x,y);	
	}		
}
int main(){
	sieve();
	int t;
	t = inp();
	while(t--){
		int i,j;
		n = inp();
		FOR(i,0,n){
			FOR(j,0,n){
				cin >> grid[i][j];
				visit[i][j] = false;
			}
		}
		ll ans = 0;
		FOR(i,0,n){
			FOR(j,0,n){
				if(visit[i][j]){
					continue;
				}
				ans += cost[grid[i][j]];
				if(!prime[grid[i][j]]){
					dfs(i,j);
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
}

