#include<stdio.h>
    #include<math.h>
    #include<iostream>
    #define FOR(i,a,b) for((i)=(a);(i)<(b);(i)++)
    #define FOR_(i,a,b) for((i)=(a);(i)<=(b);(i)++)
    #define FOR_2(i,a,b) for((i)=(a);(i)<=(b);(i)+=2)
    #define gc getchar_unlocked
    using namespace std;
    int prime[10000000]={0};
    bool *flag=new bool[10000000];
    int a[351][351];
    int c=1;
    int n;


void fcin(int &x){register int c = gc();x = 0;for(;(c<48 || c>57);c = gc());for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}}
   int sqrtI( int sqrtArg )
{
int answer, x;
int  temp;


if ( sqrtArg == 0 ) return 0; // undefined result
if ( sqrtArg == 1 ) return 1; // identity
answer = 0;                     // integer square root
for( x=0x8000; x>0; x=x>>1 )
{                                 // 16 bit shift
answer |= x;             // possible bit in root
temp = answer* answer; // fast unsigned multiply
if (temp == sqrtArg) break; // exact, found it
if (temp > sqrtArg) answer ^= x; // too large, reverse bit
}
return answer; // approximate root
}
   void sieve()
    {
    int i,j,d,U,L;
    L=2;
    U=10000000;
    d=U-L+1;
    FOR(i,0,d)
    flag[i]=true;
    FOR_2(i,(L%2!=0),d)
    flag[i]=false;
    FOR_2(i,3,sqrtI(U))
    {
    if (i>L && !flag[i-L])
    continue;
    j=L/i*i;
    if (j<L)
    j+=i;
    if (j==i)
    j+=i;
    j-=L;
    for (;j<d;j+=i)
    flag[j]=false;
    }
    if (L<=1)
    flag[1-L]=false;
    if (L<=2)
    flag[2-L]=true;
    FOR(i,0,d)
    if (flag[i])
    {
    prime[L+i]=prime[L+i]+(c++);
    }
    }
    void floodFill( int fpaRow, int fpaCol,int mod)
    {
    if (a[fpaRow][fpaCol]==-1)
    {
    return;
    }
    else
    {
    if(a[fpaRow][fpaCol]%2==mod || prime[a[fpaRow][fpaCol]]!=0)
    return;
    else
    {
    a[fpaRow][fpaCol]=-1;
    if(fpaRow<n-1)
    {
    floodFill( fpaRow+1, fpaCol,mod);
    }
    if(fpaRow >0)
    {
    floodFill( fpaRow-1, fpaCol,mod);
    }
    if(fpaCol<n-1)
    {
    floodFill( fpaRow, fpaCol+1,mod);
    }
    if(fpaCol>0)
    {
    floodFill( fpaRow, fpaCol-1,mod);
    }
    }
    }
    }
    int main()
    {
    int t,i,j;
    long long int s;
    sieve();
    fcin(t);
    ++t;
    while(--t)
    {
    fcin(n);
    s=0;
    FOR(i,0,n)
    FOR(j,0,n)
    fcin(a[i][j]);
    FOR(i,0,n)
    {
    FOR(j,0,n)
    {
    if(a[i][j]!=-1)
    {
    if(prime[a[i][j]]!=0)
    {
    s=s+ (prime[a[i][j]]-1);
    a[i][j]=-1;
    }
    else if(a[i][j]%2==0)
    {
    s=s+(a[i][j]/2);
    floodFill(i,j,1);
    }
    else
    {
    s=s+ (a[i][j]/2+2);
    floodFill(i,j,0);
    }
    }
    }
    }
    std::cout << s << "\n";
    }
    return 0;
    }