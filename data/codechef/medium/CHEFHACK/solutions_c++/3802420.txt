#include<iostream>
#include<list>
using namespace std;
struct co_ord
{
	int x ;
	int y ;
};
list<struct co_ord>m_list;
#define MAX_PASSWD 10000001
int isPrime[MAX_PASSWD];
unsigned long Prev_PrimeCount[MAX_PASSWD];
#define NO 0
#define YES 1
void PreCalc_Prime()
{
	isPrime[0] = isPrime[1] = NO;
	Prev_PrimeCount[0] = Prev_PrimeCount[1] = Prev_PrimeCount[2]= 0;
	 Prev_PrimeCount[3]= 1;
	 Prev_PrimeCount[4] = 2;
	 unsigned long prime_count = 0;
	for ( unsigned long i = 2; i <MAX_PASSWD;i++)
	{
		isPrime[i] =  YES;
	}
	for ( unsigned long i = 2; i <MAX_PASSWD;i++)
	{
		unsigned long j = 2;
		while(i*j < MAX_PASSWD)
		{
			isPrime[i*j] = NO;
			j++;
		}
	}

	for ( unsigned long i = 2; i <MAX_PASSWD;i++)
	{
		Prev_PrimeCount[i] = prime_count; 
		if (isPrime[i] == YES)
			prime_count++;
	}

}
#define MAX_TABLE_SIZE 351
typedef unsigned long long ll;
typedef unsigned long lu;
ll data_Table[MAX_TABLE_SIZE][MAX_TABLE_SIZE];
long data_unsuccessfulAttempts[MAX_TABLE_SIZE][MAX_TABLE_SIZE];
//int serverType[MAX_TABLE_SIZE][MAX_TABLE_SIZE];
unsigned int table_size = 0;
void ChecKForEvenGrid(int x , int y)
{ 
	unsigned long long tmp = 0;
    m_list.clear();
	struct co_ord os_loc;
	os_loc.x = x;
	os_loc.y = y;
	m_list.push_back(os_loc);
	while(m_list.size() > 0) {
	os_loc = m_list.front();
	m_list.pop_front();
	x = os_loc.x;
	y = os_loc.y;
  	if ( x > 0)
	{
		if (data_unsuccessfulAttempts[x-1][y] == -1) {
		tmp = data_Table[x-1][y];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 == 0)
			{
				data_unsuccessfulAttempts[x-1][y] = 0;
				os_loc.x = x -1;
				os_loc.y = y ;
				m_list.push_back(os_loc);
				// it is a part of Grid Network
			}
		}
		}
	}
	if ( y > 0)
	{
		if (data_unsuccessfulAttempts[x][y-1] == -1) {
		tmp = data_Table[x][y-1];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 == 0)
			{
				// it is a part of Grid Network
				data_unsuccessfulAttempts[x][y-1] = 0;
				os_loc.x = x ;
				os_loc.y = y - 1 ;
				m_list.push_back(os_loc);
			}
		}
		}
	}
	if ( x < table_size-1)
	{
		if (data_unsuccessfulAttempts[x+1][y] == -1) {
		tmp = data_Table[x+1][y];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 == 0)
			{
				// it is a part of Grid Network
				data_unsuccessfulAttempts[x+1][y] = 0;
				os_loc.x = x+1 ;
				os_loc.y = y ;
				m_list.push_back(os_loc);
			}
		}
		}
	}
	if (y <table_size-1)
	{
		if (data_unsuccessfulAttempts[x][y+1] == -1) {
		tmp = data_Table[x][y+1];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 == 0)
			{
				// it is a part of Grid Network
				data_unsuccessfulAttempts[x][y+1] = 0;
				os_loc.x = x ;
				os_loc.y = y+1 ;
				m_list.push_back(os_loc);
			}
		}
		}
	}
	} // list while loop 
}


// As this is already discovered using Grid 
void ChecKForOddGrid(int x , int y)
{   unsigned long long tmp = 0;
    m_list.clear();
	struct co_ord os_loc;
	os_loc.x = x;
	os_loc.y = y;
	m_list.push_back(os_loc);
	while(m_list.size() > 0) {
	os_loc = m_list.front();
	m_list.pop_front();
	x = os_loc.x;
	y = os_loc.y;
  	if ( x > 0)
	{
		if (data_unsuccessfulAttempts[x-1][y] == -1) {
		tmp = data_Table[x-1][y];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 != 0)
			{
				data_unsuccessfulAttempts[x-1][y] = 0;
				os_loc.x = x -1;
				os_loc.y = y ;
				m_list.push_back(os_loc);
				// it is a part of Grid Network
			}
		}
	}
	}
	if ( y > 0)
	{
		if (data_unsuccessfulAttempts[x][y-1] == -1) {
		tmp = data_Table[x][y-1];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 != 0)
			{
				// it is a part of Grid Network
				data_unsuccessfulAttempts[x][y-1] = 0;
				os_loc.x = x ;
				os_loc.y = y - 1 ;
				m_list.push_back(os_loc);
			}
		}
		}
	}
	if ( x < table_size-1)
	{
		if (data_unsuccessfulAttempts[x+1][y] == -1) {
		tmp = data_Table[x+1][y];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 != 0)
			{
				// it is a part of Grid Network
				data_unsuccessfulAttempts[x+1][y] = 0;
				os_loc.x = x+1 ;
				os_loc.y = y ;
				m_list.push_back(os_loc);
			}
		}
		}
	}
	if (y <table_size-1)
	{
		if (data_unsuccessfulAttempts[x][y+1] == -1) {
		tmp = data_Table[x][y+1];
		if (isPrime[tmp] == NO)
		{
			if ( tmp %2 != 0)
			{
				// it is a part of Grid Network
				data_unsuccessfulAttempts[x][y+1] = 0;
				os_loc.x = x ;
				os_loc.y = y+1 ;
				m_list.push_back(os_loc);
			}
		}
		}
	}
	} // list while loop 
}

int main()
{
	PreCalc_Prime();
	//freopen("input.txt","r",stdin);
	unsigned int test_case = 0;
	scanf("%d\n",&test_case);
	while(test_case-- > 0)
	{
		table_size = 0;
		scanf("%d\n",&table_size);
		for ( int i = 0 ; i < table_size ; i++)
		{
			for ( int j = 0 ; j < table_size ; j++)
			{
				if ( j == table_size-1)
				{
                 scanf("%llu\n",&data_Table[i][j]);
				}
				else
				{
					scanf("%llu",&data_Table[i][j]);
				}
				data_unsuccessfulAttempts[i][j] = -1;
			}
		}

		// Grid Hacking Mechanish 
		unsigned long long tmp = 0;
		unsigned long long sum = 0;
		for ( unsigned int i = 0 ; i < table_size ; i++)
		{
			for ( unsigned int j = 0 ; j < table_size ; j++)
			{
				// As this is already discovered using Grid 
				if ( data_unsuccessfulAttempts[i][j] == 0) 
					continue;

				 tmp = data_Table[i][j];
				if (isPrime[tmp] == YES)
				{
                  data_unsuccessfulAttempts[i][j] = Prev_PrimeCount[tmp];
				  sum += data_unsuccessfulAttempts[i][j];
				}
				else if ( tmp %2 == 0) // Even Non Prime
				{
					data_unsuccessfulAttempts[i][j] = tmp / 2;
					sum += data_unsuccessfulAttempts[i][j];
					ChecKForEvenGrid(i,j);
				}
				else if ( tmp %2 != 0) // Odd Non Prime
				{
                    data_unsuccessfulAttempts[i][j] = ((tmp +1) / 2) + 1;
					sum += data_unsuccessfulAttempts[i][j];
					ChecKForOddGrid(i,j);
				}

			}
		}
		printf("%llu\n",sum);
	}

	return 0;
}
