// LUCIFER

#include <bits/stdc++.h>

using namespace std;

#define MAX 10000000
#define LMT 3200
#define pb push_back

long long int flag[MAX/64];
long long int prime[MAX], total;

void sieve()
{
    //cout << "sdcs";
    long long int i, j, k;
    for (i = 3; i < LMT; i += 2)
        if((flag[i>>6] & (1<<((i>>1)&31))) == 0)
            for(j = i*i, k = i<<1; j < MAX; j += k)
                (flag[j>>6]|=(1<<((j>>1)&31)));
    prime[2] = 1;
    //cout << "s"
    for(i = 3, j = 2; i < MAX; i += 2) {
        if((flag[i>>6]&(1<<((i>>1)&31))) == 0) {
            prime[i] = j++;
         //   cout << i << " ";
        }
    }
    total = j;
}

#define mp make_pair

int main()
{
    //cout << "sd";
    sieve();
    long long int i, j, n, k, x, y;
    long long int t;
    scanf("%lld", &t);
    long long int a[400][400];
    long long int mrk[400][400];
    long long int cnt, top, g, h;
    while (t--) {
        scanf("%lld", &n);
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++)
                scanf("%lld", &a[i][j]), mrk[i][j] = 0;
        }
        cnt = 0;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (!mrk[i][j]) {
                    mrk[i][j] = 1;
                    if (prime[a[i][j]])
                        cnt += (prime[a[i][j]] - 1);
                    else if (a[i][j]%2) {
                        vector < pair <long long int, long long int> > q;
                        cnt += (a[i][j]+3)/2;
                        top = 0;
                        q.pb(mp(i, j));
                        k = 0;
                        //cout << endl;
                        while (k < q.size()) {
                            g = q[k].first;
                            h = q[k].second;
                            //cout << g << " " << h << endl;
                            if (h > 0 && mrk[g][h-1] == 0 && a[g][h-1]%2 && !prime[a[g][h-1]])
                                q.pb(mp(g,h-1)), mrk[g][h-1] = 1;
                            if (h < (n-1) && mrk[g][h+1] == 0 && a[g][h+1]%2 && !prime[a[g][h+1]])
                                q.pb(mp(g,h+1)), mrk[g][h+1] = 1;
                            if (g > 0 && mrk[g-1][h] == 0 && a[g-1][h]%2 && !prime[a[g-1][h]])
                                q.pb(mp(g-1,h)), mrk[g-1][h] = 1;
                            if (g < (n-1) && mrk[g+1][h] == 0 && a[g+1][h]%2 && !prime[a[g+1][h]])
                                q.pb(mp(g+1,h)), mrk[g+1][h] = 1;
                            k++;
                        }
                    }
                    else {
                        vector < pair <long long int, long long int> > q;
                        cnt += (a[i][j]/2);
                        top = 0;
                        q.pb(mp(i, j));
                        k = 0;
                        //cout << endl;
                        while (k < q.size()) {
                            g = q[k].first;
                            h = q[k].second;
                           // cout << g << " " << h << endl;
                            if (h > 0 && mrk[g][h-1] == 0 && !(a[g][h-1]%2) && !prime[a[g][h-1]])
                                q.pb(mp(g,h-1)), mrk[g][h-1] = 1;
                            if (h < (n-1) && mrk[g][h+1] == 0 && !(a[g][h+1]%2) && !prime[a[g][h+1]])
                                q.pb(mp(g,h+1)), mrk[g][h+1] = 1;
                            if (g > 0 && mrk[g-1][h] == 0 && !(a[g-1][h]%2) && !prime[a[g-1][h]])
                                q.pb(mp(g-1,h)), mrk[g-1][h] = 1;
                            if (g < (n-1) && mrk[g+1][h] == 0 && !(a[g+1][h]%2) && !prime[a[g+1][h]])
                                q.pb(mp(g+1,h)), mrk[g+1][h] = 1;
                            k++;
                        }
                    }
                }
                //cout << endl << cnt << endl;
            }
        }
        printf("%lld\n", cnt);
    }
    return 0;
}
