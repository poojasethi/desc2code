#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
 #define MAX 10000007
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <fstream>
#include <iomanip>
 #include<cstdlib>
#include <stdio.h>
 
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cassert>
using namespace std;
int prime_arr[10000002];
char ar[(MAX)>>4];
// fast input
inline void Scan_f(int& a)
{
char c = 0;
while(c<33)
c = getc(stdin);
a = 0;
while(c>33)
{
a = a*10 + c - '0';
c = getc(stdin);
}
}
//
inline void sieve()
{
    register int i,j,p,q,k;
    int m=MAX/2;
 
    for(i=1,k=3;k*k<=MAX;++i,k+=2)
    {
        p=i>>3;
        if(!( ar[p] & (1 << (i & 7) ) ) )
        {
            for(j=(k*k)>>1;(j<<1)+1<=MAX;j+=k)
            {
                q=j>>3;
                ar[q]|=1<<(j&7);
            }
        }
    }
 
    prime_arr[2]=1;
    k=1;
 
 
    for(i=1;i<=m ;++i)
    {
        p=i>>3;
        if(!(ar[p]& ( 1 << (i&7) ) ) )
        {
            prime_arr[(i<<1)+1]=++k;
        }
    }
}
/*bool isprime(int num)
{
	int i=2;
	if(num==1 || num==0)
		return false;
	for(i=2;i<=sqrt(num);i++)
	{
		if(!sieve[i])
			if(!(num%i))
				return false;
	}
	return true;
	
}*/
/*long long int nop(int num)
{
	int i=2;
	long long int count=0;
	for(;i<=sqrt(num);i++)
	{
		if(!sieve[i])
		{
			count++;
				if(!(sieve[num/i]))
					count++;
		}
	}
	return count+eulerTot(num);
}*/
void dfs(int k,int l,bool visited[][400],int isodd,int n,int a[][400])
{
	if(isodd)
	{
		stack<int>dfs1;
		dfs1.push((k*n)+l);
		int temp;
		while(!dfs1.empty())
		{
			temp=dfs1.top();
			dfs1.pop();
			int i=temp/n;
			int j=temp%n;
			if(((i-1)>=0) && ((a[i-1][j])%2) && (!visited[i-1][j]) &&(!prime_arr[a[i-1][j]]))
			{
				visited[i-1][j]=true;
				dfs1.push((i-1)*n+j);
			}
			if(((j-1)>=0) && (a[i][j-1]%2) && (!visited[i][j-1]) &&(!prime_arr[a[i][j-1]]))
			{
				visited[i][j-1]=true;
				dfs1.push(i*n+(j-1));
			}
			if(((i+1)<n) && ((a[i+1][j])%2) && (!visited[i+1][j]) &&(!prime_arr[a[i+1][j]]))
			{
				visited[i+1][j]=true;
				dfs1.push((i+1)*n+j);
			}
			if(((j+1)<n) && (a[i][j+1]%2) && (!visited[i][j+1]) &&(!prime_arr[a[i][j+1]]))
			{
				visited[i][j+1]=true;
				dfs1.push(i*n+(j+1));
			}
		}
	}
	else
	{
		stack<int>dfs1;
		dfs1.push(k*n+l);
		int temp;
		while(!dfs1.empty())
		{
			temp=dfs1.top();
			dfs1.pop();
			int i=temp/n;
			int j=temp%n;
			if(((i-1)>=0) && (a[i-1][j]!=2) && (!((a[i-1][j])%2)) && (!visited[i-1][j]) )
			{
				visited[i-1][j]=true;
				dfs1.push((i-1)*n+j);
			}
			if(((j-1)>=0) && (a[i][j-1]!=2) && (!(a[i][j-1]%2)) && (!visited[i][j-1]))
			{
				visited[i][j-1]=true;
				dfs1.push((i*n+(j-1)));
			}
			if(((i+1)<n) && (a[i+1][j]!=2) && (!((a[i+1][j])%2)) && (!visited[i+1][j]))
			{
				visited[i+1][j]=true;
				dfs1.push((i+1)*n+j);
			}
			if(((j+1)<n) && (a[i][j+1]!=2) && (!(a[i][j+1]%2)) && (!visited[i][j+1]))
			{
				visited[i][j+1]=true;
				dfs1.push((i*n)+(j+1));
			}
		}
	}
}


void solve(int a[][400],int n,bool visited[][400])
{
	int i,j,k,l;
	long long int ans=0;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(!visited[i][j])
			{
				if(prime_arr[a[i][j]])
				{
					ans+=prime_arr[a[i][j]]-1;
					//printf("%d %d %lld\n",i,j,ans);
					visited[i][j]=true;
				}
				else if(a[i][j]%2)   //odd number
				{
					ans+=((a[i][j]+1)/2)+1;
					//printf("%d %d %lld\n",i,j,ans);
					dfs(i,j,visited,1,n,a);  // '1' denotes odd number...
				}
				else    //even number
				{
					ans+=(a[i][j]/2);
					//printf("%d %d %lld\n",i,j,ans);
					dfs(i,j,visited,0,n,a);
				}
			}
		}
	}
	printf("%lld\n",ans);
}
int main()
{
	int test;
	Scan_f(test);
	while(test--)
	{
		int n,i,j,k;
		Scan_f(n);
		int a[400][400]={0};
		bool visited[400][400]={0};
		for(i=0;i<n;i++)
		{
			for(j=0;j<n;j++)
			{
				Scan_f(a[i][j]);
			}
		}
		sieve();
		solve(a,n,visited);
	}
	return 0;
}