// START BOILERPLATE HEADER
// Useful Includes
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>

#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>

#include <stdio.h>

#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;

// Useful Constants
#define INF    (int)        2147483646                        //one less than the max
#define LINF   (long long)  9223372036854775806               //one less than the max
#define EPS                 1e-9                              //Arbitrary
#define PI                  3.1428571428571428571428571428571
#define E                   2.7182818284590452353602874713526

//Useful Macros
#define MAX(i,j)            ((i)>(j)?(i):(j))
#define MIN(i,j)            ((i)<(j)?(i):(j))
#define ABS(i)              ((i)<0?-(i):(i))
#define REP(i,a)            for((i)=0;(i)<(a);(i)++)
#define FOR(i,a,b)          for((i)=a;(i)<(b);(i)++)
#define FORE(i,a,b)         for((i)=a;(i)<=(b);(i)++)
#define EACH(it,b)          for(__typeof((b).begin())it=(b).begin();it!=(b).end();it++)
#define CLRI(ptr,n)         memset((ptr),0,(n)*sizeof(int))

//Useful Typedefs
typedef long long ll;
typedef long double ld;
typedef vector <int> vi;
typedef vector <string> vs;
typedef map<char,int> mci;
typedef map<int,int>  mii;

//Fast stdin class (my windows g++ doesn't have getchar_unlocked, so this will have to do)
class FastInput {
    public:
        FastInput();
        inline void getint(int &n);
        inline void getstr(char k[]);
        inline void getlcstr(char k[]);
        inline void getnumstr(char k[]);
    private:
        inline void nextchar(char &c);
        inline void getmore();
        static const int BUFSIZE = 1<<16;
        static char buffer[];
        char *bufpos;
        char *bufend;
};

char FastInput::buffer[FastInput::BUFSIZE];

FastInput::FastInput() { getmore(); }

inline void FastInput::getmore() {
    bufpos = buffer;
#ifdef ONLINE_JUDGE
    bufend = buffer + read(0, buffer, BUFSIZE);
#else
    cin.read(buffer,BUFSIZE);
    bufend = buffer + cin.gcount();
#endif
}

inline void FastInput::nextchar(char &c) {
    c = *bufpos++;
    if (bufpos==bufend) getmore();
}

inline void FastInput::getint(int &n) {
    n = 0;
    register char ch;
    register char lch = ' ';
    nextchar(ch);
    while (ch < '0' || ch > '9') {
        lch = ch;
        nextchar(ch);
    }
    while (ch >= '0' && ch <= '9') {
        n=(n<<3)+(n<<1)+ch-'0';
        nextchar(ch);
    }
    if (lch=='-') n = -n;
}

inline void FastInput::getlcstr (char k[]) {
    register int cnt = 0;
    register char ch;
    nextchar(ch);
    while ( ch < 'a' || ch > 'z' ) nextchar(ch);
    while (ch >= 'a' && ch <= 'z') {
        k[cnt++] = ch;
        nextchar(ch);
    }
    k[cnt] = '\0';
}

inline void FastInput::getstr (char k[]) {
    register int cnt = 0;
    register char ch;
    nextchar(ch);
    while (( ch < 'a' || ch > 'z' ) &&
           ( ch < 'A' || ch > 'Z' )) nextchar(ch);
    while ((ch >= 'a' && ch <= 'z') ||
           (ch >= 'A' && ch <= 'Z')) {
        k[cnt++] = ch;
        nextchar(ch);
    }
    k[cnt] = '\0';
}

inline void FastInput::getnumstr (char k[]) {
    register int cnt = 0;
    register char ch;
    nextchar(ch);
    while ( ch < '0' || ch > '9' ) nextchar(ch);
    while (ch >= '0' && ch <= '9') {
        k[cnt++] = ch;
        nextchar(ch);
    }
    k[cnt] = '\0';
}

// Observations
// 1. Definitions
//      Let C(k) be the value we are trying to calculate -- i.e. the number of pairs (L,R) with 1 <= L <= R <= N with the F4(L) + ... + F4(R) = F7(L) + ... + F7(R)
//      Let S4(k) = F4(1) + F4(2) + ... + F4(k)
//      Let S7(k) = F7(1) + F7(2) + ... + F7(k)
//      Let D(k)  = S4(k) - S7(k)
//      Then note S4(R) - S4(L-1) = F4(L) + F4(L+1) + ... + F4(R)
//      Then note S7(R) - S7(L-1) = F7(L) + F7(L+1) + ... + F7(R)
//      So F4(L) + F4(L+1) + ... + F4(R) == F7(L) + F7(L+1) + ... + F7(R) if and only if
//         S4(R) - S4(L-1) == S7(R) - S7(L-1), which happens if and only i
//         S4(R) - S7(R) == S4(L-1) - S7(L-1), which is the same as D(R) == D(L-1)
// 2. Furthermore, for a given k, we note C(k) = C(k-1) + {number of non-negative integers r <= k with D(r) = D(k)} 
// 2. D(k) can be calculated inductively as D(k-1) + F4(k) - F7(k)
// 3. Finally, we don't need to keep all the D(k) around, but merely the size of the equivalence classes under D(k).
//    That is, we just need to keep a record of how many numbers have a given value of D(k)
// 4. The max value that D(k) should take over 0 <= k <= 100000 is at 55555 (and others).  Here we have seen
//    1 more 4 in the 1s place
//    10 more 4s in the 10s place
//    100 more 4s in the 100s place,
//    1000 more 4s in the 1000s place,
//    10000 more 4s in the 10000s place.
//    Meaning the max value of D(k) we need to keep track of is 11111

int main() {
    FastInput fi;
    int i;
    int t;
    int c[100001], dcount[11113];
    int d = 0;
    int n;
    int done_so_far = 1;

    CLRI(dcount,11113);
    dcount[0] = 2; c[1] = 1;
    fi.getint(t);
    while (t--) {
        fi.getint(n);
        if (done_so_far < n) {
            FORE(i,done_so_far+1,n) {
            
                // Digit counting code here
                int junki = i;
                while (junki > 0) {
                    int z = junki % 10;
                    switch(z) {
                        case 4 :
                            d++;
                            break;
                        case 7 :
                            d--;
                            break;
                    }
                    junki /= 10;
                }
                
                c[i] = c[i-1] + dcount[d]++;
            }
            done_so_far = n;
        }
        printf("%d\n",c[n]);
    }
}

//def main() :
//    t = int(f.next())
//
//    ## Ok, so we precalculate this
//    c = [0] * 100001
//    dcount = [0] * 11113
//    dcount[0] = 2
//    c[1] = 1
//    d = 0
//    for i in xrange (2,100001) :
//        numstr = str(i)
//        for cc in numstr :
//            if cc == '4' : d += 1
//            if cc == '7' : d -= 1
//        c[i] = c[i-1] + dcount[d]
//        dcount[d] += 1
//        
//    ## Now we just read and print
//    for tt in xrange(t) :
//        n = int(f.next())
//        outbuf.append(str(c[n]))
//    print "\n".join(outbuf)
//main()