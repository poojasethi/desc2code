// To find the answer, take the minimum value of all the valid values in a connected component.
// Now to make the graph connected, Take the minimum value of all the values we got from the above step and make edge from that node
// To all the remaining nodes, i.e add all other values and multiply that with the minimum value.
// If graph is already connected than answer is 0.
// if there exists a connected component where all nodes are not valid to be chosen, than answer is not possible (-1).
 
/* Author :  Jay Pandya */

// Standard includes
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<limits.h>
#include<string.h>

//Data Structures
#include<algorithm>
#include<vector>
#include<string>
#include<set>
#include<map>
#include<utility>
#include<stack>
#include<queue>

//Macros
#define all(c) c.begin(),c.end() //all element in container c

#define tr(container, it) \
   for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) //to iterate in container

#define stringswap(swstingA, swstringB) swstringA.swap(swstringB) //to swap string

#define present(container, element) (container.find(element) != container.end()) //to check whether a element is in a set or a map
#define cpresent(container, element) (find(all(container),element) != container.end()) //to check whether  a element is in container like vector

#define CLR(x,v) memset(x,v,sizeof(x)) //memset

#define print(x) cout<<#x<<" is "<<x<<endl;//for printing
#define sz(a) int((a).size()) 
#define pb push_back 
#define vi vector<int>; 
#define vvi  vector<vi>; //2D string 
#define ii pair<int,int>; 
#define mp(typeA,typeB)  make_pair<typeA,typeB> //maing pair

//macros for limits

#define MAX 100010
#define LLI long long int
#define ULLI unsigned long long int

using namespace std;
int vert[MAX];
int used[MAX];

int getpar(int u){ 
   if(vert[u]==u) vert[u]=u;
   else vert[u]=getpar(vert[u]);
   return vert[u];
}

void same(int u, int v){ 
   vert[getpar(u)]=vert[getpar(v)];
}
int main()
{
   int test,n,m,k,c;
   scanf("%d %d",&n,&m);
   for(int i=0;i<=n;i++)
   {
      vert[i]=i;
      used[i]=0;
   }

   int x,y;
   for(int i=0;i<m;i++)
   {
      scanf("%d %d",&x,&y);
      int k=getpar(x);
      int l=getpar(y);
      if(k==l)
	 continue;
      same(k,l);//merge forests
   }
   set<int> Num_Component;
   map<int,int> MaxV_Component;
   for(int i=1;i<=n;i++)
      Num_Component.insert(getpar(i));

   for(int i=1;i<=n;i++)
      MaxV_Component[getpar(i)]=INT_MAX;

   if(Num_Component.size()==1)//Graph is connected
   {
      printf("0\n");
   }
   else
   {
      int in;
      vector<int> V;
      for(int i=1;i<=n;i++)
      {
	 scanf("%d",&in);
	 if(in<0)
	    in=INT_MAX;
	 MaxV_Component[getpar(i)] = min(MaxV_Component[getpar(i)],in);
      }
      tr(MaxV_Component,it)
      {
	 if(it->second==INT_MAX)//There is one component where we can not make an edge connecting to it, Answer not possible
	 {
	    printf("-1\n");
	    return 0;
	 }
	 V.pb(it->second);
      }
      sort(all(V));
      int sum=0;
      for(int i=1;i<V.size();i++)
      {
	 sum+=V[0];
	 sum+=V[i];
      }
      printf("%d\n",sum);
   }
   return 0;
}
