#include <bits/stdc++.h>
using namespace std;
//fast input
#define get getchar_unlocked
template<class T>
inline void scan_int(T *ret) {register char ip=get(),flag=1;*ret=0;for(;ip<'0'||ip>'9';ip=get())if(ip=='-'){flag=-1;ip=get();break;}for(;ip>='0'&&ip<='9';ip=get())(*ret)=((*ret)<<3)+((*ret)<<1)+ip-'0';(*ret) = flag*(*ret);}
#define scan_d scan_int<int>
#define scan_ld scan_int<long int>
#define scan_lld scan_int<long long int>
template <class T>
inline T scan_decimal(){register char c;c = get();T flag=1.0;long long int t = 0;for(;c<'0'||c>'9';c=get())if(c=='-'){flag=-1.0;c=get();break;}while(c<='9' && c>='0'){t=(t<<3)+(t<<1)+c-'0';c = get();}long long int d=0,i=1;if(c=='.'){c = get();while(c<='9' && c>='0'){i=(i<<3)+(i<<1);d=(d<<3)+(d<<1)+c-'0';c = get();}}return ((T)t + ((T)d)/i)*flag;}
#define scan_f scan_decimal<float>
#define scan_lf scan_decimal<double>
inline void scan_str(char *str){register char c = 0;register int i = 0;while (c < 33)c = get();while (c != '\n' && c != EOF){str[i] = c;c = get();i = i + 1;}str[i] = '\0';}
//end of fast input
//fast output
#define put putchar_unlocked
char output_buffer[21];
template <class T>
inline void print_int(T n) {if(n<0){n=-n;put('-');}int i=21;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{put(output_buffer[i]);}while(++i<21);}
#define print_d print_int<int>
#define print_ld print_int<long int>
#define print_lld print_int<long long int>
template <class T>
inline void println_int(T n) {print_int(n);put('\n');}
#define println_d println_int<int>
#define println_ld println_int<long int>
#define println_lld println_int<long long int>
template <class T>
inline void printsp_int(T n,char ch) {print_int(n);put(ch);}
#define printsp_d printsp_int<int>
#define printsp_ld printsp_int<long int>
#define printsp_lld printsp_int<long long int>
inline void print_str(char *str){char* temp=str;while((*temp)!='\0'){put(*temp);temp++;}}
//end of fast output


/*
Using quick union find algorithm
*/
#define MAXN 100001
#define INF 32767
int sizex,sizey;
int id[MAXN];
short mins[MAXN];
map<int,int> planet_min;
int root (int i,int &size)
{
	size = 0;
	while(i != id[i])
	{
		id[i] = id[id[i]];
		i = id[i];
		size++;
	}
	return i;
}
void qunion(int x,int y)
{
	x = root(x,sizex);
	y = root(y,sizey);
	if(sizex>sizey)
		id[y] = x;
	else
		id[x] = y;
}
inline bool qfind(int &x,int &y)
{
	return (root(x,sizex) == root(y,sizey));
}
int main()
{
	int n,m,i,j;
	int cur_root;
	short Min = INF;
	int count = 0;
	int cost;
	int size;
	scan_d(&n);
	for(i=1;i<=n;i++)
	{
		id[i] = i;
		mins[i] = -1;
	}
	scan_d(&m);
	while(m--)
	{
		scan_d(&i);
		scan_d(&j);
		qunion(i,j);
	}
	for(i=1;i<=n;i++)
	{
		scan_d(&cost);
		cur_root = root(i,sizex);
		if(cost >=0)
		{
			if(mins[cur_root] == -1)
			{
				count++;
				mins[cur_root] = (short)cost;
			}
			else
				mins[cur_root] = min(mins[cur_root],(short)cost);
		}
		else
		{
			if(mins[cur_root] == -1)
			{
				count++;
				mins[cur_root] = INF;
			}
		}
	}
	if(count == 1)
	{
		println_d(0);
		return 0;
	}
	cost = 0;
	for(i=1;i<=n;i++)
	{
		if(mins[i] == -1)
			continue;
		else if(mins[i] == INF)
		{
			println_d(-1);
			return 0;
		}
		else
		{
			cost += mins[i];
			Min = min(Min,mins[i]);
		}
	}
	println_d((Min*(count-1) + cost-Min));
	return 0;
}