#include <iostream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <vector>
#include <string>
#include <deque>
#include <bitset>
#include <algorithm>
#include <utility>
#include <functional>
#include <limits>
#include <numeric>
#include <complex>
#include <cassert>
#include <cmath>
#include <memory.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <climits>

using namespace std;

template<typename X> inline X abs(const X& a) { return (a < 0 ? -a : a); }
template<typename X> inline X sqr(const X& a) { return (a * a); }
template<typename X> inline void print(const X& a,int N) {cout<<endl;for(int i=0;i<N;i++)cout<<a[i]<<" ";cout<<endl;}
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pp;
typedef pair<ld, ld> ppld;
typedef unsigned long long ull;

#define swap(a,b) a^=b^=a^=b;
#define FOR(i, n) for(int i = 0; i < int(n); i++)
#define FORD(i, n) for(int i = int(n-1); i >= 0; i--)
#define FORAB(i, a, b) for(int i = int(a); i < int(b); i++)
#define foreach(it, a) for(__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)
#define pb push_back
#define mp make_pair
#define mset(a, val) memset(a, val, sizeof (a))
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define getcx getchar_unlocked
#define getmid(a,b) (a+(b-a)/2)
#define tr(container, it) \
   for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) //to iterate in container

const int INF = int(1e9);
const ll INF64 = ll(INF) * ll(INF);
const ld EPS = 1e-9;
const ld PI = ld(3.1415926535897932384626433832795);

template<typename X> inline void inp(X &n ) {
     int ch=getcx();int sign=1;n=0;
     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}
     while(  ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
     n=n*sign;
}
template<typename X> inline void out(X a) {
    char snum[20]; int i=0;
    do {snum[i++]=a%10+48; a=a/10; }while(a!=0);
    i=i-1;
    while(i>=0) putchar(snum[i--]);
    putchar('\n');
}
#define MAX 100005

int planetParentArr[MAX];
int planetCostArr[MAX];
int rankPlanet[MAX];

int findParent(int node)
{
	if(planetParentArr[node] == node)
		return node;
	else
	{
		planetParentArr[node] = findParent(planetParentArr[node]);
		return planetParentArr[node];
	}
}

void mergeForest(int a, int b)
{
	if(rankPlanet[a] == rankPlanet[b])
	{
		++rankPlanet[a];
		planetParentArr[b] = a;
	}
	else
	{
		if(rankPlanet[a]>rankPlanet[b])
			planetParentArr[b] = a;
		else
			planetParentArr[a] = b;
	}
}

int main()
{
	int j = 1;
	int i;
	int planets, pathsPresent = 0, totalHeadPlanets = 0;
	int min_cost = MAX;
	int sum = 0;
	inp(planets);
	inp(pathsPresent);

	for(i = 1; i<= planets; ++i)
	{
		planetParentArr[i] = i;
		planetCostArr[i] = -1;
		rankPlanet[i] = 0;
	}

	for(i=0; i<pathsPresent; ++i)
	{
		int x, y;
		inp(x);
		inp(y);
		x = findParent(x);
		y = findParent(y);

		if(x!=y)
			mergeForest(x, y);
	}

	for(i = 1; i<=planets; ++i)
	{
		int cost;
		inp(cost);

		if(cost<0)
			cost = MAX;
		int x = findParent(i);
		
		if(planetCostArr[x] == -1)			//first time we are processing this root node
		{
			totalHeadPlanets++;
			planetCostArr[x] = cost;
		}

		else
		{
			planetCostArr[x] = min(planetCostArr[x], cost);
		}
	}

	if(totalHeadPlanets == 1)
	{
		printf("0\n");
		return 0;
	}

	for(i = 1; i<=planets; ++i)
	{
		if(planetCostArr[i] == -1)
			continue;
		
		if(planetCostArr[i] == MAX)
		{
			printf("-1\n");
			return 0;
		}

		min_cost = min(min_cost, planetCostArr[i]);
		sum += planetCostArr[i]; 
	}

	sum+= (totalHeadPlanets-2)*min_cost;
	printf( "%d\n", sum );

	return 0;
}