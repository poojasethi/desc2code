#include <stdio.h>
#include <vector>
#include <queue>

#define REP(i,N) for(int i=0; i<N; i++)
#define VVI vector<vector<int> >
#define VI vector<int>
#define DEBUG false

using namespace std;
void printGraph(VVI graph)
{
  REP(i, graph.size())
    {
      REP(j, graph.size())
	{
	  printf("%d ", graph[i][j]);
	}
      printf("\n");
    }
}

void printArray(VI arr)
{
  REP(i, arr.size())
    {
      printf("%d ", arr[i]);
    }

  printf("\n");
}



// source at index 0
// sink at index n-1
// assume cap is symmetric
int solveMaxFlowUsingPushRelabel(vector<vector<int> > cap)
{
	int N = cap.size();
	int s = 0, t = N-1;

	vector<int> excess(N), h(N), active(N), count(N+2);
	vector<vector<int> > res(cap); // residual capacities
	vector<vector<int> > flow(N, vector<int>(N));
	queue<int> q;

	REP(i,N)
	{
		if(cap[s][i] > 0)
		{
			excess[i] += cap[s][i];
			res[i][s] += cap[s][i];
			res[s][i] = 0;
			flow[s][i] = cap[s][i];
			flow[i][s] = -cap[s][i];
			active[i] = 1;
			q.push(i);
		}
	}

	
	h[s] = N;
	count[N] = 1;
	active[s] = 1;
	//q.push(s);
	active[t] = 1;


	if(DEBUG) printf("excess\n");
	if(DEBUG) printArray(excess);
	if(DEBUG) printf("h\n");
	if(DEBUG) printArray(h); 
	if(DEBUG) printf("active\n");
	if(DEBUG) printArray(active);
	if(DEBUG) printf("res\n");
	if(DEBUG) printGraph(res);
	if(DEBUG) printf("flow\n");		
	if(DEBUG) printGraph(flow);
			
	while(!q.empty())
	{
	  
		int node = q.front();
		q.pop();
		active[node] = 0;

		if(DEBUG) printf("### current node: %d\n", node);
		if(DEBUG) printf("excess\n");
		if(DEBUG) printArray(excess);
		if(DEBUG) printf("h\n");
		if(DEBUG) printArray(h);
		if(DEBUG) printf("active\n");
		if(DEBUG) printArray(active);
		if(DEBUG) printf("res\n");
		if(DEBUG) printGraph(res);
		if(DEBUG) printf("flow\n");		
		if(DEBUG) printGraph(flow);
		
		for(int i=0; i<N && excess[node]; i++)
		{
			if(res[node][i] && h[node] >= h[i] + 1)
			{
				int delta = min(excess[node], res[node][i]);
				excess[node] -= delta;
				res[node][i] -= delta;
				res[i][node] += delta;
				flow[node][i] += delta;
				flow[i][node] -= delta;
				excess[i] += delta; 
				if(!active[i]) q.push(i);
				active[i] = 1;
				if(DEBUG) printf("dischargin %d flow from %d to %d\n", delta, node, i);
			}
		}

		if(excess[node])
		{
			if(count[h[node]] == 1)
			  {
			    REP(i,N)
			      {
				if(h[i] >= h[node] && h[i] <= N)
				  {
				    count[h[i]]--;
				    h[i] = N+1;
				    count[N+1]++;
				  }
			      }
			  }
			else
			  {
			    h[node]++;
			  }
			
			q.push(node); active[node]=1;		
		}
	}

	int maxflow = 0;
	REP(i,N) maxflow += flow[s][i];
	return maxflow;
}

int main()
{
  int T, M, N, A, B;
  vector<vector<int> > graph;
  
  scanf("%d", &T);
  while(T--)
  {
    scanf("%d %d", &N, &M);
    graph.clear();

    graph.resize(2*N + 2, vector<int>(2*N+2));

    REP(i, N)
    {
      graph[0][1+i] = 1;
      graph[1+N+i][2*N+1] = 1;
    }

    REP(i,M)
    {
      scanf("%d %d", &A, &B);
      graph[1+A - 1][1+N+B - 1] = 1;
    }

    int res = N - solveMaxFlowUsingPushRelabel(graph);
    printf("%d\n", res);
  }
  
  return 0;    
}
