#include<cstdio>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<vector>
#include<algorithm>

#define SIZE 1000000
typedef long int  li;
typedef long long int ll;

int segtree[SIZE];
li count;
ll input[100005];
ll cost[100005];
ll K[100005][501];

li N, M;
int money;

void build_tree(li root, li l, li r) {

  if ( r < l ) return;
  if ( r == l ) {
    segtree[root] = 0;
    return;
  }
  li mid = (l + r)/2;
  segtree[root] = 0;
  build_tree(2*root, l, mid);
  build_tree(2*root+1, mid+1, r);

}

void update_tree(li root, li l, li r, li i, li j, li val) {


  if (j < l || r < i) return;
  if (i <= l && r <= j) {
    if (segtree[root] == 0) segtree[root] = val;
    else if (val < segtree[root]) segtree[root] = val;
    return;
  }
  
  li mid = (l + r)/2;
  li left_c = 2*root;
  li right_c = 2*root + 1;
  // SPLIT OPERATION
  if (segtree[root] != 0) {

    // root has some value/cost
    // check if the child nodes should be updated with that cost
    if (segtree[left_c] == 0) {
      segtree[left_c] = segtree[root];
    }
    else if (segtree[left_c] > segtree[root]) {
      segtree[left_c] = segtree[root];
    }

    if (segtree[right_c] == 0) {
      segtree[right_c] = segtree[root];
    }
    else if (segtree[right_c] > segtree[root]) {
      segtree[right_c] = segtree[root];
    }

  }
  
  update_tree(left_c, l, mid, i, j, val);
  update_tree(right_c, mid + 1, r, i, j, val);

  // NO MERGE OPERATION
}

int query_tree(li root, li l, li r, li i, li j) {

  if (j < l || r < i) return 0;
  if (i <= l && r <= j) return segtree[root];

  li mid = (l + r)/2;
  li left_c = 2*root;
  li right_c = 2*root + 1;

  // SPLIT OPERATION
  if (segtree[root] != 0) {
    
    // root has some value/cost
    // check if the child nodes should be updated with that cost
    if (segtree[left_c] == 0) {
      segtree[left_c] = segtree[root];
    }
    else if (segtree[left_c] > segtree[root]) {
      segtree[left_c] = segtree[root];
    }

    if (segtree[right_c] == 0) {
      segtree[right_c] = segtree[root];
    }
    else if (segtree[right_c] > segtree[root]) {
      segtree[right_c] = segtree[root];
    }
  
  }

  int from_l, from_r;
  from_l = query_tree(left_c, l, mid, i, j);
  from_r = query_tree(right_c, mid + 1, r, i, j);

  // Why? CAW
  if (from_l != 0) return from_l;
  else return from_r;
}

ll max(ll a, ll b) {
  if (a > b) return a;
  else return b;
}

ll findKnapsack(li count, int money) {
  li i, j;
  for(i=0; i<=count; i++) {
    K[i][0] = 0;
    K[0][i] = 0;
  }
  for(i=1; i<=count; i++) {
    for(j=1; j<=money; j++) {
      if (cost[i] > j) {
        K[i][j] = K[i-1][j];
      }
      else {
        K[i][j] = max(input[i] + K[i-1][j-cost[i]], K[i-1][j]);
      }
    }
  }
  return K[count][money];
}

int main() {
  li T, i, temp, l, r;
  int c;
  ll check_;
  ll no;
  scanf("%ld", &T);
  ll total;
  ll max;
  while(T--) {
    count = 1;
    total = 0;
    scanf("%ld %d %ld", &N, &money, &M);
    build_tree(1, 1, N);
    for(i=1; i<=N ; i++) {
      scanf("%lld", &no);
      total += no;
      input[i] = no;
    }
    temp = M;
    while(temp--) {
      scanf("%ld %ld %d", &l, &r, &c);
      // update segtree
      update_tree(1, 1, N, l, r, c);
    }
    
    for(i=1; i<=N; i++) {
      if (input[i] < 0) {
        check_ = query_tree(1, 1, N, i, i);
        if (check_ != 0) {
          // there must be a way or no use
          input[count] = 0 - input[i];
          cost[count++] = query_tree(1, 1, N, i, i);
        }
      }
    }
    count--;

    // we only need to consider negative numbers;
    // once we have cost and value; solve knapsack
    max = findKnapsack(count, money);
    printf("%lld\n", max + total);
  }  
  return 0;
}
