#include <cstdlib>
#include <cstring>
#include <cassert>
#include <climits>
#include <cstdio>
#include <cctype>
#include <cfloat>
#include <ctime>
 
#include <algorithm>
#include <iostream>
#include <utility>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <numeric>
#include <complex>
#include <vector>
#include <string>
#include <queue>
#include <stack>
#include <list>
#include <map>
#include <set>
#include <map>
 
 
#define forab(i,a,b) for( __typeof (a) i = a ; i <= b ; i++ )
#define forba(i,a,b) for( __typeof (a) i = a ; i >= b ; i-- )
#define rep(i,n) forab(i,0,n-1)
#define repr(i,n) forba(i,n-1,0)
#define forstl(i, s) for ( __typeof ((s).end ()) i = (s).begin (); i != (s).end (); i++ )
 
#define memo(a,b)       memset (a,b,sizeof(a))
#define all(a)          a.begin () , a. end ()
#define clr(a)          a.clear ()
#define sz(a)           a.size()
#define sf              scanf
#define pf              printf
#define si(a)           scanf("%d",&a)
#define pb              push_back
#define MP              make_pair
#define nl              puts("")
#define ll             long long
#define vi              vector < int >
#define vii		vector < int , int >
#define vll             vector < ll >
#define pii             pair < int , int >
 
#define rd              freopen ( "input.txt" , "r" , stdin )
#define wr              freopen ( "output.txt" , "w" , stdout )
 
using namespace std ;
#define MAX 1000001
 
class FastInput {
	public:
		FastInput() {
			m_dataOffset = 0;
			m_dataSize = 0;
			m_v = 0x80000000;
		}
		uint32_t ReadNext() {
			if (m_dataOffset == m_dataSize) {
				int r = read(0, m_buffer, sizeof(m_buffer));
				if (r <= 0) return m_v;
				m_dataOffset = 0;
				m_dataSize = 0;
				int i = 0;
				if (m_buffer[0] < '0') {
					if (m_v != 0x80000000) {
						m_data[m_dataSize++] = m_v;
						m_v = 0x80000000;
					}
					for (; (i < r) && (m_buffer[i] < '0'); ++i);
				}
				for (; i < r;) {
					if (m_buffer[i] >= '0') {
						m_v = m_v * 10 + m_buffer[i] - 48;
						++i;
					} else {
						m_data[m_dataSize++] = m_v;
						m_v = 0x80000000;
						for (i = i + 1; (i < r) && (m_buffer[i] < '0'); ++i);
					}
				}
			}
			return m_data[m_dataOffset++];
		}
	public:
		uint8_t m_buffer[32768];
		uint32_t m_data[16384];
		size_t m_dataOffset, m_dataSize;
		uint32_t m_v;
};
class FastOutput {
	public:
		FastOutput() {
			m_dataOffset = 0;
		}
		~FastOutput() {
		}
		void Flush() {
			if (m_dataOffset) {
				if (write(1, m_data, m_dataOffset));
				m_dataOffset = 0;
			}
		}
		void PrintUint(uint32_t v, char d) {
			if (m_dataOffset + 11 > sizeof(m_data)) Flush();
			if (v < 100000) {
				if (v < 1000) {
					if (v < 10) {
						m_data[m_dataOffset + 0] = v + 48;
						m_dataOffset += 1;
					} else if (v < 100) {
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						m_data[m_dataOffset + 0] = v + 48;
						m_dataOffset += 2;
					} else {
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						m_data[m_dataOffset + 0] = v + 48;
						m_dataOffset += 3;
					}
				} else {
					if (v < 10000) {
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 4;
 
					} else {
 
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 5;
 
					}
 
				}
 
			} else {
 
				if (v < 100000000) {
 
					if (v < 1000000) {
 
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 6;
 
					} else if (v < 10000000) {
 
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 7;
 
					} else {
 
						m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 8;
 
					}
 
				} else {
 
					if (v < 1000000000) {
 
						m_data[m_dataOffset + 8] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 9;
 
					} else {
 
						m_data[m_dataOffset + 9] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 8] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
 
						m_data[m_dataOffset + 0] = v + 48;
 
						m_dataOffset += 10;
 
					}
 
				}
 
			}
 
			m_data[m_dataOffset++] = d;
 
		}
 
		void PrintChar(char d) {
 
			if (m_dataOffset + 1 > sizeof(m_data)) Flush();
 
			m_data[m_dataOffset++] = d;
 
		}
 
		void ReplaceChar(int offset, char d) {
 
			m_data[m_dataOffset + offset] = d;
 
		}
 
 
 
	public:
 
		uint8_t m_data[32768];
 
		size_t m_dataOffset;
 
};
 
 
 
FastInput g_fi;
 
FastOutput g_fo;
 
 
struct hotel
{
	int start;
	int finish;
	int table;
 
}s[100019];
 
 
 
bool comp(const hotel a, const hotel b)
{
	if(b.table!=a.table) return a.table<b.table;
	else if(b.finish!=a.finish) return a.finish<b.finish;
	else return a.start<b.start;
}
 
int main(int argc, char const *argv[])
{
	//input;
	int t;
	t=g_fi.ReadNext();
	while(t--)
	{
		int n,k;
		n=g_fi.ReadNext();k=g_fi.ReadNext();
 
 
 
 
		for (int i = 0; i < n; ++i)
		{
			int start,finish,table;
			start=g_fi.ReadNext();finish=g_fi.ReadNext();table=g_fi.ReadNext();
			s[i].start=start;
			s[i].finish=finish;
			s[i].table=table;
 
		}
 
		sort(s,s+n,comp);
 
 
		// for (int i = 0; i < n; ++i)
		// {
		// 	printf("%d %d %d \n",s[i].start,s[i].finish,s[i].table );
		// }
 
		// printf("\n\n");
 
		int i=0,customer=0;
 
		while( i < n)
		{
				customer++;
				int tab=s[i].table,pend=s[i].finish,cstart=0;
				i++;
 
				//printf("1-> tab %d i= %d pend %d customer %d\n",tab,i,pend,customer );
 
				while( tab==s[i].table && (i<n)  )
				{
					cstart =s[i].start;
				//	printf("i=%d pend %d  cstart %d  cust %d \n",i,pend,cstart, customer );
 
					if (cstart>=pend)
					{
						pend=s[i].finish ;
						customer++;
						//printf("new pend %d  cust %d \n",pend,customer );
 
					}
 
					i++;
 
				}
 
 
		}
 
 
 
 
 
		g_fo.PrintUint(customer, '\n');
 
 
 
	}
	g_fo.Flush();
	return 0;
}