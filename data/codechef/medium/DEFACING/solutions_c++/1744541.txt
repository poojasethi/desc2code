#include <cstdlib>
#include <iostream>
#include <cstring>
//#include <stdio.h>
//#include <stdlib.h>

using namespace std;

#define byte char

        // Bits - segments correspondense
        //   --5--
        //  4|   |0
        //   --6--
        //  3|   |1
        //   --2--
char segments[] = { 0x3F, 0x03, 0x6D, 0x67, 0x53, 0x76, 0x7E, 0x23, 0x7F, 0x77 };
char minTrans[] = { 0, 0, 2, 3, 4, 5, 6, 0, 8, 8, 0 };
char minNZTrans[] = { 8, 1, 2, 3, 4, 5, 6, 3, 8, 8, 1 };
char maxTrans[] = { 8, 9, 8, 9, 9, 9, 8, 9, 8, 9, 9 };

    class NumInChars
    {
        public:
               char Digits[10];
               int Length;
               int Value;

        void Set(NumInChars source, int shift, int length)
        {
            Length = source.Length + shift;

            for (int i = 0; i < shift; i++)
            {
                Digits[i] = 10;
            }
            for (int i = 0; i < source.Length; i++)
            {
                Digits[i + shift] = source.Digits[i];
            }
            for (int i = Length; i < length; i++)
            {
                Digits[i] = 10;
            }
            if (length > Length)
            {
                Length = length;
            }
        }

        void Set(int value)
        {
            //itoa(value, Digits, 10);
            sprintf(Digits, "%d", value);
//            string s = value.ToString();
            Length = strlen(Digits);
            for (int i = 0; i < Length; i++)
            {
                Digits[i] = Digits[i] - '0';
            }
            Value = value;
        }

        int UpdateValue()
        {
            int res = 0;
            for (int i = 0; i < Length; i++)
            {
                res = res * 10 + Digits[i];
            }
            Value = res;
            return Value;
        }
    };

        bool IsDigitConvertionPossible(char from, char to)
        {
            byte fb = segments[from];
            byte tb = segments[to];

            return (fb | tb) == tb;
        }

        int CalcMinValue(NumInChars num, int fixedPos)
        {
            int res = 0;
            for (int i = 0; i < num.Length; i++)
            {
                byte d = num.Digits[i];
                res = res * 10 + (i < fixedPos ? d : minTrans[d]);
            }
            return res;
        }

        byte TryIncreaseDigit(byte d, byte mask)
        {
            if (d == 9) return 100;
            for (d++; d < 10; d++)
            {
                if (mask == 10 || IsDigitConvertionPossible(mask, d))
                    return d;
            }
            return 100;
        }

        byte TryDecreaseDigit(byte d, byte mask, bool allowZero)
        {
            if (d == 0) return 100;
            byte min = allowZero ? (byte)0 : (byte)1;
            for (d--; d >= min; d--)
            {
                if (mask == 10 || IsDigitConvertionPossible(mask, d))
                    return d;
            }
            return 100;
        }

int main(int argc, char *argv[])
{
            NumInChars curNum;
            NumInChars maxNum;
            NumInChars tryNum;

            int t;
            scanf("%d", &t);
            for (int it = 0; it < t; it++)
            {
                int score, max;
                //Read2Nums(out score, out max, curNum, maxNum);
                scanf("%d %d", &score, &max);

                curNum.Set(score);
                maxNum.Set(max);

                int maxScore = score;

                for (int len = maxNum.Length; len > 0 && len >= maxNum.Length - 1; len--)
                {
                    int maxShift = len - curNum.Length;
                    for (int shift = 0; shift <= maxShift; shift++)
                    {
                        tryNum.Set(curNum, shift, len);
                        bool isValid = true;

                        for (int i = 0; i < tryNum.Length; i++)
                        {
                            char prevDigit = tryNum.Digits[i];
                            //tryNum.Digits[i] = (i == 0 ? Transitions.minNZTrans : Transitions.minTrans)[tryNum.Digits[i]];
                            tryNum.Digits[i] = maxTrans[tryNum.Digits[i]];
                            char lastGoodDigit = 100;

                            while (true)
                            {
                                int minValue = CalcMinValue(tryNum, i + 1);
                                if (minValue <= max)
                                {
                                    lastGoodDigit = tryNum.Digits[i];
                                    break;
                                }
                                byte newDigit = TryDecreaseDigit(tryNum.Digits[i], prevDigit, i > 0);
                                if (newDigit == 100) break;
                                tryNum.Digits[i] = newDigit;
                            }

                            if (lastGoodDigit == 100)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                        {
                            tryNum.UpdateValue();
                            maxScore = maxScore >= tryNum.Value ? maxScore : tryNum.Value;
                            if (maxScore == max) break;
                        }
                    }
                    if (maxScore == max) break;
                }
                printf("%d\n", maxScore);
            }
    return EXIT_SUCCESS;
}
