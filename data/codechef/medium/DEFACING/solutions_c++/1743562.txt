#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <stack>
#include <list>
#include <cstdlib>
#include <cctype>
#include <bitset>
#include <string>
#include <map>
#include <cassert>
#include <set>

#ifdef PEYEK 
	#define debugln {printf("----OK----\n");}
	#define debug(...) {printf(__VA_ARGS__);}
	#define debugs(...) {printf(":::::--->> ");printf(__VA_ARGS__);}
	#define TIME() printf("%.3lf\n",clock()/(double)CLOCKS_PER_SEC)
#else
	#define debugln {}
	#define debug(...) {}
	#define debugs(...) {}
	#define TIME() {}
#endif

#define FOR(_i,_n,_m) for(int (_i)=(_n),_t=(_m);_i<(_t);++(_i))
#define FORN(_i,_n,_m) for(int (_i)=(_n),_t=(_m);_i<=(_t);++(_i))
#define FORD(_i,_n,_m) for(int (_i)=(_n),_t=(_m);_i>=(_t);--(_i))
#define FORLL(_i,_n,_m) for(long long (_i)=(_n),_t=(_m);_i<(_t);++(_i))
#define FORNLL(_i,_n,_m) for(long long (_i)=(_n),_t=(_m);(_i)<=(_t);++(_i))
#define FORDLL(_i,_n,_m) for(long long (_i)=(_n),_t=(_m);(_i)>=(_t);--(_i))
#define FOREACH(_i,_a) for (__typeof(_a.begin()) _i=_a.begin();_i!=_a.end();++_i)
#define RESET(_a,_value) memset(_a,_value,sizeof(_a))
#define pb push_back
#define ppb pop_back
#define pf push_front
#define ppf pop_front
#define ff first
#define ss second
#define mp make_pair
#define SIZE(_a) (int)_a.size()
#define VSORT(_a) sort(_a.begin(),_a.end())
#define SSORT(_a,_val) sort(_a,_a+(_val))
#define ALL(_a) _a.begin(),_a.end()
#define MAX(_a,_b) (((_a)>(_b))?(_a):(_b))
#define MIN(_a,_b) (((_a)<(_b))?(_a):(_b))
 
using namespace std;
 
const int dr[]={ 1, 0,-1, 0, 1, 1,-1,-1};
const int dc[]={ 0, 1, 0,-1, 1,-1,-1, 1};
const double eps=1e-9;
typedef vector<int> vi;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> pll;
typedef vector<pll> vpll;
typedef vector<ll> vll;
typedef pair<double,double> pdd;
typedef vector<pdd> vpdd;
const int INF=0x7FFFFFFF;
const ll INFLL=0x7FFFFFFFFFFFFFFFLL;
const double pi=acos(-1);

template <class T> T take(queue<T> &O) {T tmp=O.front();O.pop();return tmp;}
template <class T> T take(stack<T> &O) {T tmp=O.top();O.pop();return tmp;}
template <class T> T take(priority_queue<T> &O) {T tmp=O.top();O.pop();return tmp;}
template <class T> inline void getint(T &num)
{
	bool neg=0;
	num=0;
	char c;
	while ((c=getchar_unlocked()) && (!isdigit(c) && c!='-'));
	if (c=='-')
	{
		neg=1;
		c=getchar_unlocked();
	}
	do num=num*10+c-'0';
	while ((c=getchar_unlocked()) && isdigit(c));
	num*=(neg)?-1:1;
}

void OPEN(string in="input.txt",string out="output.txt")
{
	freopen(in.c_str(),"r",stdin);
	freopen(out.c_str(),"w",stdout);
	return ;
}

//using sokokaleb's template v2.7

int dp[10][10][2][2],ans,sz,p10[9];
char x[11],z[11];
bool isa[256][256];

int f(int posbig,int poslit,int under,int guna)
{
	int &ret=dp[posbig][poslit][under][guna],nu=under;
	if (ret!=-1) return ret;
	if (posbig==0) return ret=(poslit?-INF:0);
	debugs("%2d %2d %2d %2d\n",posbig,poslit,under,guna);
	debugs("POSLIT - %c\n",z[poslit]);
	ret=-INF;

	if (guna)
	{
		if (poslit)
		{
			FORD (i,'9','0')
			if (isa[z[poslit]][i])
			{
				if (i>x[posbig] && !under) continue;
				under|=(i<x[posbig]);
				ret=MAX(ret,f(posbig-1,poslit-1,under,1)+(i-'0')*p10[posbig-1]);
			}
		}
		else
		{
			FORD (i,'9','0')
			{
				if (i>x[posbig] && !under) continue;
				under|=(i<x[posbig]);
				ret=MAX(ret,f(posbig-1,poslit,under,1)+(i-'0')*p10[posbig-1]);
			}
		}
	}
	else
	{
		// make
		if (poslit)
		{
			FORD (i,'9','0')
			if (isa[z[poslit]][i])
			{
				if (i>x[posbig] && !nu) continue;
				nu|=(i<x[posbig]);
				ret=MAX(ret,f(posbig-1,poslit-1,nu,1)+(i-'0')*p10[posbig-1]);
			}
		}

		nu=under;
		FORD (i,'9','0')
		{
			if (i>x[posbig] && !nu) continue;
			nu|=(i<x[posbig]);
			ret=MAX(ret,f(posbig-1,poslit,nu,guna)+(i-'0')*p10[posbig-1]);
		}
	}
	return ret;
}

int main()
{
	p10[0]=1;
	FOR (i,1,9) p10[i]=10*p10[i-1];
	FOR (i,0,10)
		isa[0][i+'0']=1;
	isa['0']['0']=isa['0']['8']=1;
	isa['1']['0']=isa['1']['1']=isa['1']['3']=isa['1']['4']=isa['1']['7']=isa['1']['8']=isa['1']['9']=1;
	isa['2']['2']=isa['2']['8']=1;
	isa['3']['3']=isa['3']['8']=isa['3']['9']=1;
	isa['4']['4']=isa['4']['8']=isa['4']['9']=1;
	isa['5']['5']=isa['5']['6']=isa['5']['8']=isa['5']['9']=1;
	isa['6']['6']=isa['6']['8']=1;
	isa['7']['0']=isa['7']['3']=isa['7']['7']=isa['7']['8']=isa['7']['9']=1;
	isa['8']['8']=1;
	isa['9']['8']=isa['9']['9']=1;
	getint(ans);
	FOR (tc,0,ans)
	{
		RESET(z,0);RESET(x,0);
		scanf("%s%s",z+1,x+1);
		sscanf(z+1,"%d",&ans);
		reverse(x+1,x+1+strlen(x+1));
		reverse(z+1,z+1+strlen(z+1));
		sz=strlen(x+1);
		RESET(dp,-1);
		printf("%d\n",MAX(ans,f(sz,strlen(z+1),0,0)));
	}
	return 0;
}