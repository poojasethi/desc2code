#include <cassert>
#include <cstdio>

using namespace std;

#define SBIT(v, p) (((v) ? 1U : 0U) << (p))

#define DBITS(top, tol, tor, mid, bol, bor, bot) \
	        ( SBIT((top), 0)                     \
	| SBIT((tol), 1) | SBIT((tor), 2)            \
	        | SBIT((mid), 3)                     \
	| SBIT((bol), 4) | SBIT((bor), 5)            \
	        | SBIT((bot), 6) )

struct digit_info_t { unsigned int bits; int minDeface; int maxDeface; };

const digit_info_t digitInfo[] =
	{ /*0*/ { DBITS(1, 1, 1, 0, 1, 1, 1), 0, 8 }
	, /*1*/ { DBITS(0, 0, 1, 0, 0, 1, 0), 0, 9 }
	, /*2*/ { DBITS(1, 0, 1, 1, 1, 0, 1), 2, 8 }
	, /*3*/ { DBITS(1, 0, 1, 1, 0, 1, 1), 3, 9 }
	, /*4*/ { DBITS(0, 1, 1, 1, 0, 1, 0), 4, 9 }
	, /*5*/ { DBITS(1, 1, 0, 1, 0, 1, 1), 5, 9 }
	, /*6*/ { DBITS(1, 1, 0, 1, 1, 1, 1), 6, 8 }
	, /*7*/ { DBITS(1, 0, 1, 0, 0, 1, 0), 0, 9 }
	, /*8*/ { DBITS(1, 1, 1, 1, 1, 1, 1), 8, 8 }
	, /*9*/ { DBITS(1, 1, 1, 1, 0, 1, 1), 8, 9 }
	};

inline
bool canDeface(int digit, int tryDigit)
{
	const unsigned int bits = digitInfo[digit].bits;
	const unsigned int tryBits = digitInfo[tryDigit].bits;
	bool result = ((bits & tryBits) == bits);
	assert(!result || ((digitInfo[digit].minDeface <= tryDigit) && (tryDigit <= digitInfo[digit].maxDeface)));
	return result;
}

////
// Maximize all remaining digits.
int maximizeScore(int score, int hiAnyMin, int loAnyMax, int digitValue)
{
	// High "any" digits are replaced by 9s.
	while (hiAnyMin <= digitValue)
	{
		int digit = score / digitValue % 10;
		score += (9 - digit) * digitValue;
		digitValue /= 10;
	}

	// Middle digits are replaced by maximum defacing digits.
	while (loAnyMax <= digitValue)
	{
		int digit = score / digitValue % 10;
		score += (digitInfo[digit].maxDeface - digit) * digitValue;
		digitValue /= 10;
	}

	// Low "any" digits are replaed by 9s.
	while (digitValue)
	{
		int digit = score / digitValue % 10;
		score += (9 - digit) * digitValue;
		digitValue /= 10;
	}

	return score;
}

int solveCore(int score, int max, int hiAnyMin, int loAnyMax, int digitValue)
{
	// Select the digits from the score and the max values.
	const int digit = score / digitValue % 10;
	const int maxDigit = max / digitValue % 10;

	// If true, any replacement digit is considered valid (because it's padding).
	const bool anyDigitValid = (hiAnyMin <= digitValue) || (digitValue < loAnyMax);
	const int minReplace = anyDigitValid ? 0 : digitInfo[digit].minDeface;
	const int maxReplace = anyDigitValid ? 9 : digitInfo[digit].maxDeface;

	// The max clamp is a way to quickly avoid depth searches. For instance, given a max value of
	//  135, the max clamp would be 200, 140, and 136 for successive calls.
	const int maxClamp = (max / digitValue + 1) * digitValue;

	// Count down, allowing early return if a valid score is found.
	for (int i = maxReplace; minReplace <= i; --i)
	{
		// Skip invalid defacing digits.
		if (!anyDigitValid && !canDeface(digit, i))
			continue;
		// Replace the digit.
		int tryScore = score + (i - digit) * digitValue;
		// If score is at or beyond the max clamp, skip it, no other changes can help.
		if (maxClamp <= tryScore)
			continue;
		// Search the remaining digits, if any.
		if ((1 < digitValue) && (i < maxDigit))
			tryScore = maximizeScore(tryScore, hiAnyMin, loAnyMax, digitValue / 10);
		else if (1 < digitValue)
			tryScore = solveCore(tryScore, max, hiAnyMin, loAnyMax, digitValue / 10);
		// If score is in range, return it.
		if (tryScore <= max)
			return tryScore;
	}

	return score;
}

////
// Given an integer, return the number of digits.
inline
int countDigits(int n)
{
	int count = 1;
	for (int r = n; r /= 10; )
		++count;
	return count;
}

////
// Given a integer n, return pow(10, n).
inline
int pow10(int n)
{
	int result = 1;
	for (int i = 0; i < n; ++i)
		result *= 10;
	return result;
}

////
// Given score=123, max=23456:
//  * start=123, hiAnyMin=1000, loAnyMax=1,
//  * start=1230, hiAnyMin=10000, loAnyMax=10
//  * start=12300, hiAnyMin=100000, loAnyMax=100
int solve(int score, int max)
{
	assert(0 <= score);
	assert(score <= max);
	assert(max <= 20130120);

	int bestScore = score;
	
	const int scoreDigitCount = countDigits(score);
	const int maxDigitCount = countDigits(max);
	const int highestDigitValue = pow10(maxDigitCount - 1);
	for (int i = scoreDigitCount; i <= maxDigitCount; ++i)
	{
		const int loAnyMax = pow10(i - scoreDigitCount);
		const int hiAnyMin = loAnyMax * pow10(scoreDigitCount);
		int result = solveCore(score * loAnyMax, max, hiAnyMin, loAnyMax, highestDigitValue);
		if ((bestScore < result) && (result <= max))
			bestScore = result;
	}

	assert(score <= bestScore);
	assert(bestScore <= max);
	return bestScore;
}

void processStream(FILE * in, FILE * out)
{
	int testCount = 0;
	fscanf(in, "%d\n", &testCount);
	assert(1 <= testCount);
	assert(testCount <= 201301);
	for (int i = 0; i < testCount; ++i)
	{
		int score, max;
		fscanf(in, "%d %d\n", &score, &max);
		int defaced = solve(score, max);
		fprintf(out, "%d\n", defaced);
	}
}

int main(int argc, char * argv[])
{
#if !ONLINE_JUDGE
	if (_isatty(_fileno(stdin)))
		return doUnitTests();
#endif // !ONLINE_JUDGE

	processStream(stdin, stdout);
	return 0;
}
