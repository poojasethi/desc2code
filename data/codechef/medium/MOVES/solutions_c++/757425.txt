/* mymacro.h ver 1.1 */
#include <iostream>
#include <cstdio>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <stack>
#include <functional>
#include <algorithm>
#include <cmath>
#include <string>
#include <sstream>
#include <complex>
using namespace std;

#define REP(i, m, n) for(int i=(m); i<(n); ++i)
#define rep(i, n) for(int i=0; i<(n); ++i)
#define each(it, a) for(__typeof((a).begin()) it = (a).begin(); it != (a).end(); ++it)
#define FILL(a, c) std::fill((__typeof(c)*)(a), (__typeof(c)*)(a) + sizeof(a) / sizeof(__typeof(c)), (c))
#define pb push_back                                                                          
#define sz(v) ((int)(v).size())                                                                   
#define all(v) (v).begin(),(v).end()    
#define def(a, x) __typeof(x) a = x

const int dx[] = {1, 0, -1, 0, 1, 1, -1, -1}, dy[] = {0, 1, 0, -1, 1, -1, 1, 0};
const double EPS = 1e-10;

typedef pair<int, int> PI;
typedef long long ll;
#define mp make_pair
#define fi first
#define se second

template<class T> inline bool isin(T k, T begin, T end) { return !(k < begin) && k < end; }

#define dump(x) (cout << #x << " = " << x << " at line" << __LINE__ << endl)

/*********************/

template<class T>
T powmod(T b, T e, T mod) {
	T a = 1;
	for(; e != 0; e >>= 1, b=(b*b)%mod)
		if (e&1) a = (a*b) % mod;
	return a;
}

#define MAXN 5000
#define MOD 1000000007ll
ll frac[MAXN+1];
ll invfrac[MAXN+1];
ll nCk(ll n, ll k) {
	return (frac[n] * invfrac[k]) % MOD * invfrac[n-k] % MOD;
}
int main() {
	frac[0] = 1;
	rep(i, MAXN) frac[i+1] = frac[i] * (i+1) % MOD;
	invfrac[MAXN] = powmod(frac[MAXN], MOD-2, MOD);
	for(int i=MAXN-1; i>=0; i--) invfrac[i] = invfrac[i+1] * (i+1) % MOD;

	int N, K;
	while(cin >> N >> K, N) {
		cout << 2 * nCk(N-2, K/2) * nCk(N-2, (K-1)/2) % MOD << endl;
	}
	return 0;
}
