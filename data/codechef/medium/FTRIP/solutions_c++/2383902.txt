#include<stdio.h>
#include<algorithm>
#include<cassert>
using namespace std;
#define eps 1e-7				// round off correctly for 1e-6

double nCr[1000][1000];  			// till S-1 needed only. iCj

inline int FAST_IO()
{	int x=0;
	char ch;
	ch=getchar_unlocked();
	x=ch-48;
	while ((ch=getchar_unlocked()) >= 48 && ch <= 57)
		x=x*10+ch-48;
	return x;	
}

void PascalTriangle()
{	for(int i=0; i<1000; i++)					// O(n^2)
	{	nCr[i][0] = nCr[i][i] = 1.0;				// iC0 = 1 and iCi = 1
		for(int j=1; j<i; j++)
			nCr[i][j] = nCr[i-1][j] + nCr[i-1][j-1];	// nCr + nCr-1 = n+1Cr
	}
}
 
int main()
{	double ans,tmp;
	int i,t,s,n,m,k,l,u;
	PascalTriangle();
	t= FAST_IO();
	assert( t>=1 && t <=100 );
	while(t-- > 0)
	{	ans = 0.0;
		s= FAST_IO();
		assert( s>=1 && s<=1000);
		n= FAST_IO();
		assert( n>=1 && n<=s);
		m= FAST_IO();
		assert( m>=1 && m<=s);
		k= FAST_IO();
		assert( k>=0 && k < m);
		l = max(k, n-1 + m-s);
		u = min(m-1,n-1);
		for(i=l; i<= u; i++)
			ans += nCr[m-1][i] * nCr[s-m][n-1-i];
		tmp = nCr[s-1][n-1];
		printf("%f\n", ((double)ans/tmp)+eps);			// max error 1e-6
	}
	return 0;
}