#include <iostream>
#include <vector>
#include <queue>
#include <limits.h>

//for INT_MAX which I used as infinity

using namespace std;


#define endl '\n'

#define pii pair<int,int>

#define f first

#define s second

#define mp make_pair

#define pb push_back


int s;//source vertex

bool visited[100001];//visited array

int dist[100001]; //storing shortest distance from source to every vertex

vector <pii> G[100001]; // Adjacency List  source, destination, weight ( ie dist[source,destination] )


void init(int n)//Initializes (resets) data
{

	for(int i=1;i<=n;i++)
	{

		visited[i]=false;

		G[i].clear();

		dist[i]=INT_MAX;

	}

}


void Dijkstra();


//Comparator to sort edges. The shortest edge is removed first from the priority queue

class prioritize
{
    public:

	bool operator ()(pii&p1 ,pii&p2)

	{
		return p1.s>p2.s;
	}

};


int main()
{

	int v1,v2,w,n,m;

	cin>>n>>m;//number of vertics,edges

	init(n);//resetting data

	for(int i=0;i<m;i++)

	{
		cin>>v1>>v2;   //inputting data

		G[v1].pb( mp(v2,0) );
		
		G[v2].pb( mp(v1,1) );
	}

	s=1;

	Dijkstra();
	
	if( dist[n]!=INT_MAX )
	 {
	 	cout<<dist[n];
	 }
	else
	 {
	 	cout<<"-1";
	 } 

}


void Dijkstra()
{
	priority_queue<pii, vector<pii> , prioritize> Q ;
	           //Datatype, Container, Comparator

	dist[s]=0;

	Q.push(mp(s,0));//pushing source,0 as dist from source to itself is 0. Duh

	
	while( !Q.empty() )
	{
		
		pii cur=Q.top();

		Q.pop();

		int cv=cur.f,cw=cur.s;

		visited[cv]=true;
		
		for( typeof((G[cv]).begin()) x = G[cv].begin() ; x != (G[cv]).end(); x++)     //Iterating through vertices of current vertex
		{
			if( !visited[x->f] )//Node not visited before.
			{
				int nv=x->f,nw=x->s;//current vertex and its weight

				if(cw+nw<dist[nv])///New dist is shorter
				{
					dist[nv]=cw+nw;

					Q.push( mp(nv,dist[nv]) ) ;//Adding to priority queue
				}
			}

		}

	}
}