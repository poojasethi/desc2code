    #include <cstring>
    #include <cstdio>
    #include <vector>
    #include <queue>
    #include<bits/stdc++.h>
    using namespace std;

    typedef pair< int, int > pii;

    int get_int(){
int x=0;char c;int t=0;
for (c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());
if (c=='-'){t=1;c=getchar();}
for (;c>='0'&&c<='9';c=getchar()){x*=10;x+=c-48;}
if (t) x=-x;return x;
}


    const int MAX = 100001;
    const int INF = 0x3f3f3f3f;


    vector< pii > G[MAX];
    int d[MAX];


    void dijkstra(int start) {
    int u, v, i, c, w;


    priority_queue< pii, vector< pii >, greater< pii > > Q;


    memset(d, 0x3f, sizeof d);
    Q.push(pii(0, start));
    d[start] = 0;

    while(!Q.empty()) {
    u = Q.top().second; // node
    c = Q.top().first; // node cost so far
    Q.pop(); // remove the top item.


    if(d[u] < c) continue;

    //->>>>>>>>>>>>>>>>>>>>>>>


    for(i = 0; i < G[u].size(); i++) {
    v = G[u][i].first; // node
    w = G[u][i].second; // edge weight

    if(d[v] > d[u] + w) {
    d[v] = d[u] + w;
    Q.push(pii(d[v], v));
    }
    }
    }
    }

    int main() {
    int n, e, i, u, v, w, start;
    /*
    Read a graph with n nodes and e edges.
    */
    //while(scanf("%d %d", &n, &e) == 2) {
//scanf("%d %d",&n,&e);
n=get_int(); e=get_int();
    /*
    Reset the graph
    */
    for(i = 1; i <= n; i++) G[i].clear();

    /*
    Read all the edges. u to v with cost w
    */
    for(i = 0; i <e; i++) {
  u=get_int(); v=get_int();  //  scanf("%d %d", &u, &v);
    G[u].push_back(pii(v, 0));
    G[v].push_back(pii(u, 1)); // only if bi-directional
    }

    /*
    For a start node call dijkstra.
    */
   // scanf("%d", &start);

dijkstra(1);



if(d[n]>=INF) printf("-1\n");
else printf("%d\n",d[n]);



    return 0;
    }
