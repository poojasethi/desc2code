#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include <stdarg.h>
 
using namespace std;
 
typedef unsigned int uint;
typedef long long int64;
typedef unsigned long long uint64;
typedef unsigned long long double64;
 
#ifdef DEBUG
#define ASSERT(_Expression) (void)((!!(_Expression)||(__assert((#_Expression),__LINE__),0)));
void __assert(const char *_Message,const unsigned _Line) {printf("ASSERTION FAILED\n");printf("Message = %ls\n",_Message);printf("Line = %u\n",_Line); exit(0);}
#endif

const int MODULO = 1000000007;
const int N = 1001;
bool is_palindrome[N][N];

void init_palindrome(const string &s) {
	int length = s.length();
	for (int i = length - 1; i >= 0; --i) {
		// a single character is a palindrome
		is_palindrome[i][i] = true;			
		// two consecutive same characters
		if ((i + 1) < length && s[i] == s[i + 1]) {
			is_palindrome[i][i + 1] = true; 
		} 
		for (int j = i + 2; j < length; ++j) {
			// check the middle
			if (s[i] == s[j] && is_palindrome[i + 1][j - 1]) {
				is_palindrome[i][j] = true; 
			}
		}
	}
}

int count_palindrome(int length) {
	vector<int> dp(length + 1);
	dp[0] = dp[1] = 1;
	int n;
	for (int i = 1; i < length; ++i) {
		dp[i + 1] = dp[i];
		for (int j = i - 1; j >= 0; --j) {
			if (is_palindrome[j][i]) {
				dp[i + 1] = (dp[i + 1] + dp[j]) % MODULO;
			}
		}
	}
	return dp[length];
}

void inout_count_palindromes() {
	string s;
	cin >> s;
	int length = s.length();
	init_palindrome(s);
	cout << count_palindrome(length) << endl;
}
 
int main() {
	inout_count_palindromes();
	return 0;
}     