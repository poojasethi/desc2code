//shivi..coding is adictive!!
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
const int INF = 1000000001;
const LL INFLL = LL(INF) * LL(INF);
template<class T> inline int size(const T&c)
{
    return c.size();
}
inline bool myisspace(char c)
{
    return c>=0 && c<=' ';
}

class INPUT
{
    static const int BUFSIZE = 1<<16;
    static char buffer[];
    char *bufpos;
    char *bufend;
    void grabBuffer();
public:
    INPUT()
    {
        grabBuffer();
    }
    bool eof()
    {
        return bufend==buffer;
    }
    char nextChar()
    {
        return *bufpos;
    }
    inline char readChar();
    inline void skipWS();
    inline unsigned readUnsigned();
    inline int readInt();
    inline ULL readULL();
    inline LL readLL();
    inline void readString(char *p);
    inline string readString(int maxlen=100);
};

char INPUT::buffer[INPUT::BUFSIZE];

void INPUT::grabBuffer()
{
    bufpos = buffer;
    bufend = buffer + read(0, buffer, BUFSIZE);
}

char INPUT::readChar()
{
    char res = *bufpos++;
    if(bufpos==bufend) grabBuffer();
    return res;
}

void INPUT::skipWS()
{
    while(!eof() && myisspace(nextChar())) readChar();
}

unsigned INPUT::readUnsigned()
{
    skipWS();
    unsigned res = 0;
    while(!eof() && isdigit(nextChar()))
    {
        res = 10u * res + (readChar()-'0');
    }
    return res;
}

int INPUT::readInt()
{
    skipWS();
    bool neg = false;
    if(!eof() && nextChar()=='-')
    {
        neg=true;
        readChar();
    }
    int res = static_cast<int>(readUnsigned());
    if(neg) res = -res;
    return res;
}

ULL INPUT::readULL()
{
    skipWS();
    ULL res = 0;
    while(!eof() && isdigit(nextChar()))
    {
        res = 10u * res + (readChar()-'0');
    }
    return res;
}

LL INPUT::readLL()
{
    skipWS();
    bool neg = false;
    if(!eof() && nextChar()=='-')
    {
        neg=true;
        readChar();
    }
    LL res = static_cast<LL>(readUnsigned());
    if(neg) res = -res;
    return res;
}

void INPUT::readString(char *p)
{
    skipWS();
    while(!eof() && !myisspace(nextChar())) *p++ = readChar();
    *p = 0;
}

string INPUT::readString(int maxlen)
{
    char buf[maxlen+1];
    readString(buf);
    return string(buf);
}

class OUTPUT
{
    static const int BUFSIZE = 1<<16;
    static char buffer[];
    char *bufpos;
    char *BUFLIMIT;
    void flushBuffer();
public:
    OUTPUT():bufpos(buffer),BUFLIMIT(buffer+BUFSIZE-100) {}
    ~OUTPUT()
    {
        flushBuffer();
    }
    inline void operator()(char c);
    inline void operator()(unsigned x);
    inline void operator()(int x);
    inline void operator()(ULL x);
    inline void operator()(LL x);
    inline void operator()(const char*s);
    void operator()(const string&s)
    {
        operator()(s.c_str());
    }
    inline void print(double d, int prec);
    template<class A,class B>
    void operator()(const A& a,const B& b)
    {
        operator()(a);
        operator()(b);
    }
    template<class A,class B,class C>
    void operator()(const A& a,const B& b,const C&c)
    {
        operator()(a);
        operator()(b);
        operator()(c);
    }
    template<class A,class B,class C,class D>
    void operator()(const A& a,const B& b,const C&c,const D&d)
    {
        operator()(a);
        operator()(b);
        operator()(c);
        operator()(d);
    }
    template<class A,class B,class C,class D,class E>
    void operator()(const A& a,const B& b,const C&c,const D&d,const E&e)
    {
        operator()(a);
        operator()(b);
        operator()(c);
        operator()(d);
        operator()(e);
    }
    template<class A,class B,class C,class D,class E,class F>
    void operator()(const A& a,const B& b,const C&c,const D&d,const E&e,const F&f)
    {
        operator()(a);
        operator()(b);
        operator()(c);
        operator()(d);
        operator()(e);
        operator()(f);
    }
};

char OUTPUT::buffer[OUTPUT::BUFSIZE];

void OUTPUT::flushBuffer()
{
    char *p = buffer;
    while(p < bufpos)
    {
        p += write(1, p, bufpos-p);
    }
    bufpos = buffer;
}

void OUTPUT::operator()(char c)
{
    *bufpos = c;
    ++bufpos;
    if(bufpos >= BUFLIMIT) flushBuffer();
}

void OUTPUT::operator()(unsigned x)
{
    char *old = bufpos;
    do
    {
        *bufpos = char('0' + x % 10u);
        x /= 10u;
        ++bufpos;
    }
    while(x);
    reverse(old, bufpos);
    if(bufpos >= BUFLIMIT) flushBuffer();
}

void OUTPUT::operator()(int x)
{
    if(x<0)
    {
        operator()('-');
        x = -x;
    }
    operator()(static_cast<unsigned>(x));
}

void OUTPUT::operator()(ULL x)
{
    char *old = bufpos;
    do
    {
        *bufpos = char('0' + x % 10u);
        x /= 10u;
        ++bufpos;
    }
    while(x);
    reverse(old, bufpos);
    if(bufpos >= BUFLIMIT) flushBuffer();
}

void OUTPUT::operator()(LL x)
{
    if(x<0)
    {
        operator()('-');
        x = -x;
    }
    operator()(static_cast<ULL>(x));
}

void OUTPUT::operator()(const char*s)
{
    while(*s) operator()(*s++);
}

void OUTPUT::print(double d, int prec)
{
    char buf[100];
    sprintf(buf, "%.*f", prec, d);
    operator()(buf);
}

INPUT input;
OUTPUT output;

int abs(int x)
{
    if(x>0)
    {
        return x;
    }
    else
    {
        return -x;
    }
}


struct Node
{
	int age;
	int rating;
};

class criteria
{
	public:
	bool operator()(Node a,Node b)
	{
		return a.age>b.age;
	}
};

class criteria2
{
	public:
	bool operator()(Node a,Node b)
	{
		return a.age<b.age;
	}
};

int main()
{
	priority_queue<Node,vector<Node>,criteria2> young;//MAXpq
	priority_queue<Node,vector<Node>, criteria > old;//MINpq
	Node temp;	
	int N,sy,so;
	N=input.readInt();
	temp.age=input.readInt();
	temp.rating=input.readInt();
	young.push(temp);
	sy=temp.rating;
	so=0;
	cout<<max(so,sy)-min(so,sy)<<endl;
	--N;
	
	while(N)
	{
		temp.age=input.readInt();
		temp.rating=input.readInt();
		if(young.size()==old.size())
		{
			int p=(old.top()).age;
			if(temp.age<=p)
				{young.push(temp);sy+=(temp).rating;}
			else
			{
				so-=(old.top()).rating;
				sy+=(old.top()).rating;
				so+=temp.rating;
				young.push(old.top());
				old.pop();
				old.push(temp);
			}	
		}
		else
		{
			int q=(young.top()).age;
			if(temp.age>=q)
				{old.push(temp);so+=(temp).rating;}
			else
			{
				sy-=(young.top()).rating;
				so+=(young.top()).rating;
				sy+=temp.rating;
				old.push(young.top());
				young.pop();
				young.push(temp);
			}	
		}
		
		cout<<max(so,sy)-min(so,sy)<<endl;
		--N;
	}
	
}
