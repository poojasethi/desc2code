#include<iostream>
#include<vector>
#include<queue>
#include<limits.h>


#define  pii  pair<int,int>
#define  mp   make_pair     
#define  pb   push_back     

#define  inf  INT_MAX

using namespace std;


int main()
{
	 int source , vertices , edges , from , to , distance , i , j , ver , dist , u , v , w ;
	 
	 int s , g , d , q;
	 
	 pair<int,int> top;
     

	 scanf("%d",&vertices);
     
     
	 vector< pii > G[ vertices+5 ]; // Adjacency List
     
     
     
     for( from=0 ; from<vertices ; from++ )
      {
      	 for( to=0 ; to<vertices ; to++ )
      	  {
      	  	  scanf("%d",&distance);
      	  	  
      	  	  if( from!=to )
      	  	   {
      	  	   	   G[from].pb( mp(to,distance) );
      	  	   }
      	  }
      }

	 	 
	 vector< vector<int> >   D( vertices+5 , vector<int> (vertices+5,inf) );     	       
     
     for( source=0 ; source<vertices ; source++ )
      {
      	 D[source][source]=0;
      	 
      	 priority_queue< pii , vector<pii> , greater<pii> > Q;
	 
		 Q.push( mp(0 , source ) );
		 
		 
		 while( !Q.empty() )
		  {
		  	  top=Q.top();
		  	  
		  	  Q.pop();
		  	  
		  	  ver  =top.second;
		  	  dist =top.first;
		  	  
		  	  if( dist<= D[source][ver] ) // 'ver' has yet not been visited
		  	   {
		  	   	  //for( typeof( (G[ver]).begin() ) x = G[ver].begin() ; x != (G[ver]).end(); x++ ) 
		  	   	  for( vector<pair<int,int> >::iterator   x = G[ver].begin() ; x != (G[ver]).end(); x++ )
		  	   	   {
		  	   	   	     u=ver ;
		  	   	   	    
		  	   	   	     v=x->first;
		  	   	   	    
		  	   	   	     w=x->second;
		  	   	   	    
		  	   	          if( D[source][ v ]  > D[source][ u ] + w )
						    {
						 	    D[source][ v ] = D[source][ u ] + w;
						 	
						 	     Q.push( mp( D[source][v], v ) );
						    }
		  	   	   }
		  	   }	 
		  }
      	 
      }
      
    scanf("%lld",&q);
 
    while(q--)
	 {
	 	scanf("%d %d %d",&s,&g,&d);

        printf("%d %d\n", D[s][g] + D[g][d] , D[s][g] + D[g][d] - D[s][d] );
	 }
	  
     return 0;
}