#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cstdlib>
#include <cstdio>
#include <vector>
#include <string>
#include <cmath>
#include <set>
#include <map>

using namespace std;

typedef long long LL;
typedef long double LD;

#define pb push_back
#define mp make_pair
#define sz(A) (int)(A).size()

const int N = 103;

int dp[N][N][10][2][2], a[N][N];

int main() {
	int t;
	scanf("%d", &t);	

	for (int i = 0; i < t; i++) {
		int n, m;
		scanf("%d%d\n", &n, &m);

		for (int j = 0; j < n; j++, scanf("\n"))
			for (int k = 0; k < m; k++) {
				char sym;
				scanf("%c", &sym);
				a[j][k] = int(sym - '0');
			}

		int res = 0;
		for (int p = 0; p < 10; p++) {
			memset(dp, 0, sizeof(dp));
						
			for (int j = 0; j <= n; j++)
				for (int k = 0; k <= m; k++) {
					for (int last = 0; last < 10; last++) {						
						for (int dr = 0; dr < 2; dr++)
							for (int dc = 0; dc < 2; dc++) {
								if (j != n || k != m) 
									res = max(res, dp[j][k][last][dr][dc]);								
				
								if (j < n && k < m) {
    								int val = (a[j][k] + p * dr + p * dc) % 10;
    								if (val <= last) {
    									dp[j + 1][k][val][dr][0] = max(dp[j + 1][k][val][dr][0], dp[j][k][last][dr][dc] + 1);
    									dp[j + 1][k][val][dr][1] = max(dp[j + 1][k][val][dr][1], dp[j][k][last][dr][dc] + 1);
    									dp[j][k + 1][val][0][dc] = max(dp[j][k + 1][val][0][dc], dp[j][k][last][dr][dc] + 1);
    									dp[j][k + 1][val][1][dc] = max(dp[j][k + 1][val][1][dc], dp[j][k][last][dr][dc] + 1);
    								}								
    								dp[j + 1][k][last][dr][0] = max(dp[j + 1][k][last][dr][0], dp[j][k][last][dr][dc]);
    								dp[j][k + 1][last][0][dc] = max(dp[j][k + 1][last][0][dc], dp[j][k][last][dr][dc]);
    								dp[j + 1][k][last][dr][1] = max(dp[j + 1][k][last][dr][1], dp[j][k][last][dr][dc]);
    								dp[j][k + 1][last][1][dc] = max(dp[j][k + 1][last][1][dc], dp[j][k][last][dr][dc]);
								}
							}
					}					
				}
		}
		printf("%d\n", res);
	}

	return 0;
}