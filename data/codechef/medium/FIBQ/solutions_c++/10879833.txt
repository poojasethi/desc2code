#include<bits/stdc++.h>
#define ll long long int
#define mp make_pair
#define pb push_back
#define si(x) scanf("%d",&x)
#define pi(x) printf("%d\n",x)
#define s(x) scanf("%lld",&x)
#define p(x) printf("%lld\n",x)

using namespace std;
const ll M = 1000000007;
/*map<ll, ll> F;

ll f(ll n) {
	if (F.count(n)) return F[n];
	long k=n/2;
	if (n%2==0) {
		return F[n] = (f(k)*f(k) + f(k-1)*f(k-1)) % M;
	} else {
		return F[n] = (f(k)*f(k+1) + f(k-1)*f(k)) % M;
	}
}*/
void fib(ll n,ll &x,ll &y){
  ll temp = 0;
  if(n==0){
      x=0;y=1;
      return;
  }
  if(n==1){
      x=1;y=1;
      return;
  }
  fib(n/2,x,y);
  if(!(n&1)){
      temp = x;
      x = (((2*y-x+M)%M)*x)%M;
      y = (temp*temp+y*y)%M;
  }
  else{
      temp = x;
      x = (x*x + y*y)%M;
      y = (x + (((2*y-temp+M)%M)*temp)%M)%M;
  }
}


ll f(ll n){
    ll x,y;
    fib(n,x,y);
    return x;
}

int a[100002];
ll tree[400002][3];
struct entry{
    ll a1,a2,a3;
};

void build(int l,int r,int i){
    if(l == r){

        tree[i][0] = f(a[l]);
        tree[i][1] = f(a[l]-1);
        tree[i][2] = f(a[l]+1);
        return;
    }

    int m = l+(r-l)/2;
    build(l,m,2*i);
    build(m+1,r,2*i+1);

    tree[i][0] = ((tree[2*i][0] + tree[2*i+1][0])%M + ((tree[2*i][0]*tree[2*i+1][1])%M + (tree[2*i][2]*tree[2*i+1][0])%M)%M)%M;
    tree[i][1] = ((tree[2*i][1] + tree[2*i+1][1])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][1]*tree[2*i+1][1])%M)%M)%M;
    tree[i][2] = ((tree[2*i][2] + tree[2*i+1][2])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][2]*tree[2*i+1][2])%M)%M)%M;

}

void update(int s,int e,int l,int val,int i){
    if(s>l || e<l) return;
    if(s==e && l==e){
        a[l] = val;
        tree[i][0] = f(val);
        tree[i][1] = f(val-1);
        tree[i][2] = f(val+1);
        return;
    }

    int m = s+(e-s)/2;
    update(s,m,l,val,2*i);
    update(m+1,e,l,val,2*i+ 1);


    tree[i][0] = ((tree[2*i][0] + tree[2*i+1][0])%M + ((tree[2*i][0]*tree[2*i+1][1])%M + (tree[2*i][2]*tree[2*i+1][0])%M)%M)%M;
    tree[i][1] = ((tree[2*i][1] + tree[2*i+1][1])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][1]*tree[2*i+1][1])%M)%M)%M;
    tree[i][2] = ((tree[2*i][2] + tree[2*i+1][2])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][2]*tree[2*i+1][2])%M)%M)%M;
}

entry query(int s,int e,int l,int r,int i){
    entry ans;
    if(e<l || r<s){
        ans.a1 = ans.a2 = ans.a3 = 0;
        return ans;
    }
    if(l <= s && e <= r){
        ans.a1 = tree[i][0];
        ans.a2 = tree[i][1];
        ans.a3 = tree[i][2];
        return ans;
    }

    int m = s+(e-s)/2;

    entry q1 = query(s,m,l,r,2*i);
    entry q2 = query(m+1,e,l,r,2*i+1);

    ans.a1 = ans.a2 = ans.a3 = 0;
    ans.a1 = (ans.a1 + q1.a1)%M;
    ans.a1 = (ans.a1 + q2.a1)%M;
    ans.a1 = (ans.a1 + q1.a1*q2.a2)%M;
    ans.a1 = (ans.a1 + q1.a3*q2.a1)%M;

    ans.a2 = (ans.a2 + q1.a1*q2.a1)%M;
    ans.a2 = (ans.a2 + q1.a2*q2.a2)%M;
    ans.a2 = (ans.a2 + q1.a2 + q2.a2)%M;

    ans.a3 = (ans.a3 + q1.a1*q2.a1)%M;
    ans.a3 = (ans.a3 + q1.a3*q2.a3)%M;
    ans.a3 = (ans.a3 + q1.a3 + q2.a3)%M;

    return ans;
}

int main(){
    int n,q,x,y;
    char c;
    si(n);si(q);
    for(int i=1;i<=n;i++){
        si(a[i]);
    }
    build(1,n,1);
    while(q--){
        scanf(" %c",&c);
        if(c == 'C'){
            si(x);si(y);
            update(1,n,x,y,1);
        }
        else{
            si(x);si(y);
            p(query(1,n,x,y,1).a1);
        }
    }
    return 0;
}
