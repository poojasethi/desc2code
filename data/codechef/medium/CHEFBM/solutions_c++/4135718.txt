#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int ai[100001];
vector<pair<int,int> > cache[100001];

int main() {
    int n, m, p, x, y;
    cin >> n >> m >> p;
    for(int i=0;i<p;++i) {
        cin >> x >> y;
        cache[x].push_back(make_pair(y,1));
        // It is necessary and sufficient to consider
        // only j and j+1 elements when j element is changed
        // because the condition may fail only between j and j+1 elements
        // as the j-1 element is initially sorted
        // and the condition between j-1 and j elements
        //  is checked when j-1 element is increased
        // Hence, considering j and j+1 elements is sufficient
        if ( y<m ) cache[x].push_back(make_pair(y+1,0));
    }
    for(int i=1;i<=n;++i) {
        if ( cache[i].size() ) {
            // ai[1] and ai[m] are to be initialized
            // because if the both the indices are not included from the previous loop,
            // the values will be garbage values (may be from previous iterations of the same loop)
            // and the final result consisting only them will be erroneous.
            ai[1] = 1;
            ai[m] = m;
            for(int j=0;j<cache[i].size();++j) ai[cache[i][j].first] = cache[i][j].first;
            vector<int> buf;
            for(int j=0;j<cache[i].size();++j) {
                ai[cache[i][j].first] += cache[i][j].second;
                buf.push_back(cache[i][j].first);
            }
            sort(buf.begin(),buf.end());
            //buf.resize(unique(buf.begin(),buf.end())-buf.begin());
            int res = 0;
            for(int j=1;j<buf.size();++j) {
                if(ai[buf[j]] < ai[buf[j-1]]) {
                    res = -1;
                    break;
                }
            }
            if ( res==-1 ) cout << -1 << endl;
            else cout << (ai[m]-ai[1]) << endl;
        } else cout << (m-1) << endl;
    }
    return 0;
}
