#include <fstream>
#include <cstring>
#include <climits>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

#pragma warning (disable:4996)
#define NMAX 100010

typedef long long ll;
using namespace std;

map<int, int> r[NMAX];

int main() {
	int n, m, p;
	scanf("%d %d %d", &n, &m, &p);

	for (int i = 1; i <= p; i++) {
		int x, y;
		scanf("%d %d", &x, &y);
		
		if (r[x].find(y) == r[x].end()) r[x][y] = y + 1;
		else							r[x][y]++;
	}

	for (int i = 1; i <= n; ++i) {
		/*for (int j = m - 1; j >= 1; j--) {
			int prev = r[i].find(j + 1) == r[i].end() ? j+1: r[i][j+1];
			int cur  = r[i].find(j) == r[i].end() ? j : r[i][j];
			if (cur > prev) {
				cost = -1;
				break;
			}
			else {
				cost += prev - cur;
			}
		}*/
		ll cost=0, last=m;
		bool invalid = false;
		for (map<int, int>::reverse_iterator it = r[i].rbegin(); it != r[i].rend(); ++it) {
			ll key = (*it).first;
			ll value = (*it).second;
			ll value_k_1 = r[i].find(key+1) == r[i].end() ? key+1 : r[i][key+1];
			ll extracost = 0;

			if (key == last) continue;	// this will accounted in next turn
			else if (key + 1 == last) extracost = 0;
			else {
				ll value_last = r[i].find(last) == r[i].end() ? last : r[i][last];
				extracost = value_last - (key + 1);	// cost from last till key+1 
			}

			last = key;	// update the last element
			if (value > value_k_1) {
				invalid = true;
				break;
			}
			else {
				cost += value_k_1 - value + extracost;
			}
		}

		// if last != 1, then take cost till 1
		if (invalid) {
			printf("-1\n");
		}
		else {
			if (last != 1) { 
				ll value_last = r[i].find(last) == r[i].end() ? last : r[i][last];
				cost += value_last - 1; 
			}
			printf("%lld\n", cost);
		}
	}

	return 0;
}