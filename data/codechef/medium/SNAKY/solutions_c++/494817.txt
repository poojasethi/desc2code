#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <queue>

#define S(i)    scanf("%d", &i)
#define SF(i)   scanf("%f", &i)
#define SD(i)   scanf("%lf", &i)
#define SLU(i)  scanf("%llu", &i)
#define SL(i)   scanf("%lli", &i)
#define SS(i)   scanf("%s", i)
#define P(i)    printf("%d", i)
#define PLU(i)  printf("%llu", i)
#define PL(i)   printf("%lli", i)
#define PF(i)   printf("%f", i)
#define PD(i)   printf("%lf", i)
#define SP      printf(" ")
#define NL      printf("\n")
#define PS(s)   printf("%s",s)
#define PT(s)   printf(s)

#define FOR(i,n)    for(int i = 0; i < n; i++)
#define REP(i,a,b)  for(int i = a; i < b; i++)
#define FORR(i,n)   for(int i = n-1; i >= 0; i--)
#define fill(a,val) memset(a,val,sizeof(a))
#define llu         long long unsigned int
#define lli         long long int
using namespace std;

int m,n,x,y,l;
char str[1000001];
int grid[1000][1000];
bool isInCollision;
int ns;
struct point{
    int x,y;
};

bool isValid(int x, int y){
    if(x < 0 || y < 0 || x == n || y == m)
    return false;

    return true;
}

void solve(){
    queue<point> q;
    point temp = {x,y};
    q.push(temp);
    fill(grid,0);
    grid[x][y] = 1;

    FOR(i,l-1){
        if(str[i] == 'U')   y++;
        if(str[i] == 'D')   y--;
        if(str[i] == 'R')   x++;
        if(str[i] == 'L')   x--;
        temp.x = x;
        temp.y = y;
        q.push(temp);
        //P(x);SP;P(y);NL;
        grid[x][y] = 1;
    }

    char dir = str[l-2];
    isInCollision = false;
    ns = 0;
    while(!isInCollision){
        if(dir == 'U')   y++;
        if(dir == 'D')   y--;
        if(dir == 'R')   x++;
        if(dir == 'L')   x--;
        //P(x);SP;P(y);NL;
        if(isValid(x,y)){
            temp = q.front();
            grid[temp.x][temp.y] = 0;
            q.pop();

            if(grid[x][y] == 1){
                PT("BODY ");
                isInCollision = true;
            }
            else{
                temp.x = x;
                temp.y = y;
                q.push(temp);
                grid[x][y] = 1;
                ns++;
            }
        }
        else{
            isInCollision = true;
            PT("WALL ");
        }
    }
    P(ns);NL;
}

int main()
{
    //freopen("input.txt", "r", stdin);
    int t;
    S(t);
    FOR(prob,t){
        S(n);S(m);S(x);S(y);S(l);
        x--;y--;
        SS(str);
        solve();
    }
    return 0;
}
