#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <map>
#include <queue>
#include <sstream>
#include <numeric>
#include <functional>
#include <set>
#include <cmath>
#include <stack>
#include <cassert>
#include <fstream>
#ifdef HOME_PC
#include <ctime>
#endif
using namespace std;

#pragma comment(linker,"/stack:16000000")
#pragma warning (disable : 4996)

#define ALL(v) v.begin(),v.end()
#define SZ(v) (int)v.size()
#define mset(A,x) memset((A),(x),sizeof(A))
#define FOR(i,start,N) for(int i=(start);i<(N);++i)
#define FORSZ(i,start,v) FOR(i,start,SZ(v))
#define REPSZ(i,v) FORSZ(i,0,v)
#define FORE(i,start,N) FOR(i,start,N+1)
#define make_unique(v) v.resize(unique(ALL(v))-v.begin())
#define debug(x) cout<<#x<<" = "<<x<<endl;
#define adebug(A,N) FOR(i,0,N) cout<<#A<<"["<<i<<"] = "<<A[i]<<endl;
#define adebug2d(a,n,m) FOR(i,0,n) { FOR(j,0,m) { cout<<a[i][j]<<" ";} cout<<endl;}
#define vdebug(v) REPSZ(i,v) cout<<#v<<"["<<i<<"] = "<<v[i]<<endl;
#define selfx(x,f,a) x = f(x,a)
#define sqr(x) ((x)*(x))


typedef pair<int,int> pii;
typedef long long i64;
typedef vector<int> VI; typedef vector< vector<int> > VVI;
typedef vector<string> VS;

const int inf = 1<<25;
const double eps = 1e-9;


const int MAXN = 1<<10;
int board[MAXN][MAXN];
int cellDir[MAXN][MAXN];



int di[] = {-1,1,0,0};
int dj[] = {0,0,-1,1};

char sdir[] = {"LRDU"};

int getDir(char c)
{
	switch(c)
	{
		case 'L':
			return 0;
		case 'R':
			return 1;
		case 'D':
			return 2;
		case 'U':
			return 3;
	}
	return -1;
}


char s[1<<20];

int main()
{
#ifdef HOME_PC
	//freopen ("input.txt","r",stdin);
	freopen ("in.txt","r",stdin);
	//freopen ("output.txt","w",stdout);
#endif

	mset(board,-1);
	int tt;
	scanf("%d",&tt);
	for(int cas = 1;cas<=tt;++cas)
	{
		int N,M,si,sj,L;

		scanf("%d %d %d %d %d",&N,&M,&si,&sj,&L);

		--si,--sj;
		int ti = si, tj = sj;

		board[si][sj] = cas;
		

		scanf("%s",s);

		int dir = -1;
		for(int i = 0; i < L-1; ++i)
		{
			dir = getDir(s[i]);
			cellDir[si][sj] = dir;
			si+=di[dir];
			sj+=dj[dir];
			assert(si>=0 && si <= N && sj>=0 && sj <= M);
			board[si][sj] = cas;
		}
		
		cellDir[si][sj] = dir;

		int steps = 0;
		bool wall = false;
		bool body = false;

		for(;;)
		{
			assert(steps < 2000);
				
			++steps;
			board[ti][tj] = 0;
			int d = cellDir[ti][tj];
			assert(d>=0 && d<=3);
			ti+=di[d];
			tj+=dj[d];
			
			si+=di[dir],sj+=dj[dir];
			
			if(si < 0 || sj < 0 || si >= N|| sj >= M)
			{
				wall = true;
				break;
			}
			if(board[si][sj] == cas)
			{
				body = true;
				break;
			}
			board[si][sj] = cas;
			cellDir[si][sj] = dir;
		}


		printf("%s %d\n",wall?"WALL":"BODY",steps-1);
	}
#ifdef HOME_PC
	cerr<<endl<<"Execution time = "<<clock()<<" ms"<<endl;
#endif
	return 0;
}

