#include<iostream>
#include<sstream>
#include<fstream>
#include<iomanip>
#include<string>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<algorithm>
#include<utility>
#include<stdexcept>
#include<limits>
#include<numeric>
#include<iterator>
#define pb push_back
#define iter(container,it) typeof(container.begin()) it
#define all(x) x.begin(),x.end()
#define fastin cin.sync_with_stdio(false);cout.sync_with_stdio(false)
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<cassert>
#include<ctime>
#include<cctype>
#define SET(p) memset(p,-1,sizeof(p))
#define CLR(p) memset(p,0,sizeof(p))
using  namespace std;
#ifndef ONLINE_JUDGE
#include<debug.h>
#include<mystack.h>
#endif
template<typename T> void rin(T& n)
{
    n=0;
    int chint,sign=1;
    bool taken=false;
    while (1)
    {
        chint=cin.get();
        if(isspace(chint)&&!taken)
            continue;
        else if(!taken&&chint=='-')
        {
            sign=-1;
            continue;
        }
        else if(chint<'0'||chint>'9')
            break;
        n = (n << 3) + ( n << 1 ) + (chint - '0');
        taken=true;
    }
    n*=sign;
}
void rin(string& n)
{
    n.clear();
    int chint;
    while (1)
    {
        chint=cin.get();
        if(chint=='\n')
            break;
        n+=static_cast<char>(chint);
    }
}
string n;
int p2,hashcount,calcmax;
vector<int> hashp,shashp,maxesbw,maxesfront,maxesend,temp(26,0),temp2(26,0),temp3(26,0);
bool firsttime;
int mybsearch(int p)
{
    int start=0,end=hashp.size()-1,mid;
    while(start<=end)
    {
        mid=(start+end)/2;
        if(hashp[mid]==p)
            return mid;
        else if(hashp[mid]>p)
            end=mid-1;
        else
            start=mid+1;
    }
    return -2;
}
void normalize_hashes()
{
    int i=0,j;
    while(n[i]=='#')
    {
        i++;
    }
    n.erase(0,i);
    i=(int)n.length()-1;
    while(n[i]=='#')
    {
        i--;
    }
    n.erase(i+1);
    for(i=0; i<(int)n.length()-1; i++)
    {
        if(n[i]=='#'&&n[i+1]=='#')
        {
            hashp.pb(i);
            for(j=i+2; n[j]=='#'; j++)
                ;
            n.erase(i+2,j-i-2);
            i+=2;
        }
        if(n[i]=='#'&&n[i+1]!='#')
        {
            hashp.pb(i);
            shashp.pb(i);
        }
    }
}
void compute()
{
    register int i,j;
    fill(all(temp),0);
    fill(all(temp2),0);
    fill(all(temp3),0);
    maxesfront.resize((int)hashp.size()+1);
    maxesbw.resize((int)hashp.size()+1);
    maxesend.resize((int)hashp.size()+1);
    int a=0,b=0,c=0;
    string n1=n;
    reverse(all(n1));
    for(i=0,j=0; i<(int)n.length(); i++,j++)
    {
        if(n[i]!='#')
        {
            temp[n[i]-'a']++;
            temp2[n[i]-'a']++;
        }
        else
        {
            if(n[i+1]=='#')
                i++;
            maxesfront[a++]=*max_element(all(temp));
            maxesbw[b++]=*max_element(all(temp2));
            fill(all(temp2),0);
        }
        if(n1[j]!='#')
            temp3[n1[j]-'a']++;
        else
        {
            if(n1[j+1]=='#')
                j++;
            maxesend[c++]=*max_element(all(temp3));
        }
    }
    maxesfront[a]=*max_element(all(temp));
    maxesbw[b]=*max_element(all(temp2));
    maxesend[c]=*max_element(all(temp3));
    reverse(all(maxesend));
    if(((int)shashp.size()>0)&&mybsearch(shashp[0])==0)
        shashp.erase(shashp.begin());
    if((((int)shashp.size()-1)>=0)&&(mybsearch(shashp[(int)shashp.size()-1])==(int)hashp.size()-1))
        shashp.erase(shashp.end()-1);
}
void reset()
{
    maxesbw.clear();
    maxesend.clear();
    maxesfront.clear();
    hashp.clear();
    shashp.clear();
    n.clear();
    hashcount=0;
}
int main()
{
    int t;
    fastin;
    cin>>t;
    cin.ignore();
    while(t--)
    {
        int ans=0;
        reset();
        rin(n);
        firsttime=true;
        normalize_hashes();
        compute();
        int k=0;
        while(k<(int)shashp.size())
        {
            calcmax=0;
            hashcount=mybsearch(shashp[k])+1;
            calcmax=maxesbw[hashcount]+maxesbw[hashcount-1]+maxesfront[hashcount-2]+maxesend[hashcount+1];
            ans=max(ans,calcmax);
            k++;
        }
        if(ans==0)
            ans=-3;
        cout<<ans+3<<"\n";
    }
}
