/***********Template Starts Here***********/
#pragma comment (linker,"/STACK:16777216")
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <vector>
#include <deque>
#include <functional>
#include <string>
#include <iostream>
#include <cctype>

#define pb push_back
#define nl puts ("")
#define sp printf ( " " )
#define phl printf ( "hello\n" )
#define all(c) (c).begin(),(c).end()
#define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define sz(a) int((a).size())

using namespace std;

typedef long long vlong;
typedef unsigned long long uvlong;
typedef vector < int > vi;
typedef pair < int, int > ii;
typedef vector < ii > vii;


const vlong inf = 2147383647;
const double pi = 2 * acos ( 0.0 );
const double eps = 1e-9;
const vlong maxint = 2147483647;
const vlong minint = -2147483648;

/***********Template Ends Here***********/

char buf[10010];
int total[26][10010*5];
int n, h;

void build_seg ( int ch, int t, int a, int b ) {
    if ( a == b ) {
        if ( buf[a] == ch ) total[ch][t] = 1;
        else total[ch][t] = 0;
        return;
    }
    int mid = ( a + b ) / 2;
    build_seg( ch, t * 2, a, mid );
    build_seg( ch, t * 2 + 1, mid + 1, b );

    total[ch][t] = total[ch][t*2] + total[ch][t*2+1];
}

void build() {

    int i;
    for ( i = 0; i < 26; i++ ) {
        build_seg ( i, 1, 0, n - 1 );
    }
}

int find_total ( int ch, int t, int a, int b, int i, int j ) {
    if ( a == i && b == j ) {
        return total[ch][t];
    }
    int mid = ( a + b ) / 2;
    if ( j <= mid ) {
        return find_total( ch, t * 2, a, mid, i, j );
    }
    else if ( i >= mid + 1 ) {
        return find_total( ch, t * 2 + 1, mid + 1, b, i, j );
    }
    else {
        return find_total( ch, t * 2, a, mid, i, mid ) + find_total( ch, t * 2 + 1, mid + 1, b, mid + 1, j );
    }
}

vector < int > hash;

int calc ( int a, int b, int c ) {

    //printf ( "%d %d %d\n", a, b, c );

    int p, q, r, s;
    p = q = r = s = 0;

    if ( a - 1 - 0 + 1 == 0 ) return 0;
    if ( ( b - 1 ) - ( a + 1) + 1 == 0 ) return 0;
    if ( ( c - 1 ) - ( b + 1) + 1 == 0 ) return 0;
    if ( ( n - 1 ) - ( c + 1 ) + 1 == 0 ) return 0;

    int i;
    for ( i = 0; i < 26; i++ ) {
        int temp = find_total ( i, 1, 0, n - 1, 0, a - 1 );
        if ( temp > p ) p = temp;
    }
    if ( p == 0 ) return 0;

    for ( i = 0; i < 26; i++ ) {
        int temp = find_total ( i, 1, 0, n - 1, a + 1, b - 1 );
        if ( temp > q ) q = temp;
    }
    if ( q == 0 ) return 0;

    for ( i = 0; i < 26; i++ ) {
        int temp = find_total ( i, 1, 0, n - 1, b + 1, c - 1 );
        if ( temp > r ) r = temp;
    }
    if ( r == 0 ) return 0;

    for ( i = 0; i < 26; i++ ) {
        int temp = find_total ( i, 1, 0, n - 1, c + 1, n - 1 );
        if ( temp > s ) s = temp;
    }
    if ( s == 0 ) return 0;

    return p + q + r + s + 3;

}
int main () {
    //freopen ( "input.txt", "r", stdin );
    //freopen ( "output.txt", "w", stdout );
    int kase;
    scanf ( "%d", &kase );

    while ( kase-- ) {
        scanf ( "%s", buf );

        int i;
        n = strlen ( buf );
        h = '#' - 'a';

        for ( i = 0; i < n; i++ ) {
            buf[i] -= 'a';
        }

        build();

        hash.clear();
        for ( i = 0; i < n; i++ ) if ( buf[i] == h ) hash.pb ( i );

        if ( hash.size() < 3 ) {
            printf ( "0\n" );
            continue;
        }
        int res = 0;
        for ( i = 0; i < hash.size() - 2; i++ ) {
            int temp = calc ( hash[i], hash[i+1], hash[i+2] );
            if ( temp > res ) res = temp;
        }

        printf ( "%d\n", res );
    }

    return 0;
}
