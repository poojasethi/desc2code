#!/usr/bin/env python

try:
    import psyco
    psyco.full()
except ImportError: pass
import sys

#from itertools import permutations, product
#
#def prod(values, n):
#    for c in product(*[values[::] for _ in xrange(n)]):
#        yield c

RANK=0
SUIT=1

A=14
K=13
Q=12
J=11
T=10
A1=1

R={'T':T, 'J':J, 'Q':Q, 'K':K, 'A':A}

def _get_hand(hand):
    return sorted([(int(R.get(r, r)), s) for r, s in map(tuple, hand.split())])

def get_rank(hand):
    return [r for (r, _) in hand]

def get_suit(hand):
    return [s for (_, s) in hand]

def is_same_suit(hand):
    return len(set(get_suit(hand))) == 1

def is_same_rank(hand):
    return len(set(get_rank(hand))) == 1

def _is_in_sequence(l):
    return sum([a - b for (a, b) in zip(l[1:], l[:-1])]) == len(l) - 1

def is_in_sequence(hand):
    l = get_rank(hand)
    r = _is_in_sequence(l)
    if A not in l or r:
        return r
    else:
        l.remove(A)
        l.append(A1)
        l.sort()
        return _is_in_sequence(l)

def is_royal_flush(hand):
    return 'royal flush' if set([A, K, Q, J, T]) == set(get_rank(hand)) and is_same_suit(hand) else ''

#TODO: Remove
#for r in permutations(list('AKQTJ')):
#    for s in 'SHDC':
#        hand = ' '.join(map(lambda x: x[0] + x[1], zip(r, tuple(5*s))))
#        for p in permutations(hand.split()):
#            h = ' '.join(p)
#            assert is_royal_flush(_get_hand(h))

def is_straight_flush(hand):
    return 'straight flush' if is_in_sequence(hand) and is_same_suit(hand) else ''

#TODO: Remove
#l=list('A23456789TJQKA')
#for i in xrange(len(l) - 4):
#    for s in 'SHDC':
#        v = l[i:i+5]
#        hand = ' '.join(map(lambda x: x[0] + x[1], zip(v, tuple(5*s))))
#        for p in permutations(hand.split()):
#            h = ' '.join(p)
#            assert is_straight_flush(_get_hand(h)), h

def is_four_of_a_kind(hand):
    r = get_rank(hand)
    return 'four of a kind' if r[0] == r[1] == r[2] == r[3] or r[1] == r[2] == r[3] == r[4] else '' 

#TODO: Remove
#l=list('A23456789TJQKA')
#for r1 in l:
#    for r2 in l:
#        if r1 == r2: continue
#        for s in 'SHDC':
#            v = list(4 * r1) + [r2]
#            hand = ' '.join(map(lambda x: x[0] + x[1], zip(v, tuple(5*s))))
#            for p in permutations(hand.split()):
#                h = ' '.join(p)
#                assert is_four_of_a_kind(_get_hand(h))

def is_full_house(hand):
    r = get_rank(hand)
    return 'full house' if (r[0] == r[1] == r[2] and r[3] == r[4]) or (r[0] == r[1] and r[2] == r[3] == r[4]) else ''

#TODO: Remove
#l=list('A23456789TJQKA')
#for r1 in l:
#    for r2 in l:
#        if r1 == r2: continue
#        v = list(3 * r1) + list(2 * r2)
#        for ss in prod('SHDC', 5):
#            hand = ' '.join(map(lambda x: x[0] + x[1], zip(v, ss)))
#            assert is_full_house(_get_hand(hand)), hand
##            for p in permutations(hand.split()):
##                h = ' '.join(p)
##                assert is_full_house(_get_hand(h)), h

def is_flush(hand):
    return 'flush' if is_same_suit(hand) else ''

def is_straight(hand):
    return 'straight' if is_in_sequence(hand) else ''

def is_three_of_a_kind(hand):
    r = get_rank(hand)
    return 'three of a kind' if r[0] == r[1] == r[2] or r[1] == r[2] == r[3] or r[2] == r[3] == r[4] else ''

def is_two_pairs(hand):
    r = get_rank(hand)
    return 'two pairs' if (r[0] == r[1] and r[2] == r[3]) or (r[0] == r[1] and r[3] == r[4]) or (r[1] == r[2] and r[3] == r[4]) else ''

def is_pair(hand):
    r = get_rank(hand)
    return 'pair' if (r[0] == r[1]) or (r[1] == r[2]) or (r[2] == r[3]) or (r[3] == r[4])  else ''

def is_high_card(hand):
    return 'high card'

def get_hand(hand):
    hand = _get_hand(hand)
    return is_royal_flush(hand) or is_straight_flush(hand) or is_four_of_a_kind(hand) or is_full_house(hand) or is_flush(hand) or is_straight(hand) or is_three_of_a_kind(hand) or is_two_pairs(hand) or is_pair(hand) or is_high_card(hand)

def main():
    T = int(sys.stdin.readline())
    for _ in xrange(T):
        hand = sys.stdin.readline()
        print get_hand(hand)

main()