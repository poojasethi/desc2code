#include <cstdio>
#include <iostream>
#include <cassert>
#include <vector>
#include <sstream>

using namespace std;

#define MODULO (1000000007ULL)
#define MAXN (1000000007U)
#define TWELVE (12U)
typedef unsigned long long ULL;

struct sqmat22 {
    int a; //00
    int b; //01
    int c; //10
    int d; //11
    sqmat22(int A, int B, int C, int D) : a(A), b(B), c(C), d(D) {}
    ~sqmat22() {}

    sqmat22 operator+(sqmat22 const &r) const {
        int rsa = (a + r.a)%MODULO;
        int rsb = (b + r.b)%MODULO;
        int rsc = (c + r.c)%MODULO;
        int rsd = (d + r.d)%MODULO;
        return sqmat22(rsa, rsb, rsc, rsd);
    }
    sqmat22 operator-(sqmat22 const &r) const {
        int ta = (a - r.a)%MODULO;
        int tb = (b - r.b)%MODULO;
        int tc = (c - r.c)%MODULO;
        int td = (d - r.d)%MODULO;
        int rsa = (ta<0)?(MODULO+ta):ta;
        int rsb = (tb<0)?(MODULO+tb):tb;
        int rsc = (tc<0)?(MODULO+tc):tc;
        int rsd = (td<0)?(MODULO+td):td;
        return sqmat22(rsa, rsb, rsc, rsd);
    }
    sqmat22 operator*(sqmat22 const &r) const {
        int rsa = ((ULL(a)*ULL(r.a))%MODULO + (ULL(b)*ULL(r.c))%MODULO)%MODULO;
        int rsb = ((ULL(a)*ULL(r.b))%MODULO + (ULL(b)*ULL(r.d))%MODULO)%MODULO;
        int rsc = ((ULL(c)*ULL(r.a))%MODULO + (ULL(d)*ULL(r.c))%MODULO)%MODULO;
        int rsd = ((ULL(c)*ULL(r.b))%MODULO + (ULL(d)*ULL(r.d))%MODULO)%MODULO;
        return sqmat22(rsa, rsb, rsc, rsd);
    }

    string toStr() {
        ostringstream mat;
        mat << " { {" << a << ", " << b << "} {" << c << ", " << d << "} }";
        return mat.str();
    }
};

sqmat22 IDEN(1, 0, 0, 1);
sqmat22 BASE(2, 3, 1, 0);
vector<sqmat22> POWERS;

void prepocessPowers(sqmat22 const &base, unsigned MAXPOW, vector<sqmat22> &powers) {
    unsigned cpow=1, idx=0; // cpow = 2^idx
    powers.push_back(base); // base^(2^0) = base^1 = base
    while (cpow < MAXPOW) {
        sqmat22 const &curr = powers[idx];
        powers.push_back(curr*curr);
        ++idx;
        cpow = 2*cpow; // cpow = 2^idx
    }
}

sqmat22 raiseTo(vector<sqmat22> const &powers, unsigned exponent) {
    assert(powers.size() > 1);
    assert(1<<(powers.size()-1) > exponent);
    sqmat22 res(1, 0, 0, 1);
    unsigned cpow=2, idx=0;
    //cerr << "raiseTo " << exponent << " -> ";
    while (exponent) {
        //cerr << (exponent%2);
        if (exponent%2) {
            res = (res*powers[idx]);
        }
        ++idx;
        cpow = 2*cpow;
        exponent = (exponent/2);
    }
    //cerr << endl;
    return res;
}

void doTest() {
    unsigned N;
    cin >> N;
    //cerr << "N = " << N << endl;
    --N; // n = N-1;
    sqmat22 baseNm1 = raiseTo(POWERS, N-1);
    //cerr << "base^(N-1) = base^" << N-1 << " = " << baseNm1.toStr() << endl;
    ULL res = baseNm1.a;
    res *= TWELVE;
    res %= MODULO;
    cout << res << endl;
}

int main() {
    int T;
    cin >> T;
    prepocessPowers(BASE, MAXN, POWERS);
    for (int tt=0; tt<T; ++tt) {
        doTest();
    }
    return 0;
}
