//R1 = ( 3^n - 2 x 2^n + 1 ) / 2
//R2 = ( 4^n - 3 x 3^n + 3 x 2^n - 1  ) / 2
//using princilpe of inclusion exclusion
/*
R1
For a possible solution (A,B), each of the numbers {1,2,3,...,n} is either in A, or in B or in-neither-of-them (lets call them C). This is same as dividing the balls 1,2,3,..,N in to 3 boxes A, B, C such that neither A nor B is empty.
R1 = Number of ways of dividing N balls in to 3 boxes A, B and C such that A and B are non-empty
R1 = ( Total ways of dividing N balls in to 3 boxes = 3n ) -  ( Either A of B is empty = ( 2n + 2n - 1 ) < inclusion-exclusion > )
This counts ordered pairs (A,B). We need unordered pairs, so divide by 2. Finally, R1 = ( 3n - 2 x 2n + 1 ) / 2
R2
Similarly we can find R2. For a possible solution (A,B), each of the numbers {1,2,3,...,n} is either only-in-A, or only-in-B or in-both-A-and-B (C) or in-neither-of-them (D). This is same as dividing the balls 1,2,3,..,N in to 4 boxes A, B, C, D such that neither A nor B nor C is empty.
Derive it similary using inclusion-exclusion, you should get this : R2 = ( 4n - 3 x 3n + 3 x 2n - 1  ) / 2
*/

//NOTE: (8/2)%3 == (8%6)/2  since we are dividing both num and dem by 1/2 so reminder has to multiplied by 1/2

#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<malloc.h>
#include<vector>
#include<algorithm>
#include<stack>
#include<queue>
#include<list>
#include<string>
#include<map>


#define min(a,b) (a>b?b:a)
#define max(a,b) (a>b?a:b)
#define PB(x) push_back(x)
#define MP(x,y) make_pair(x,y)
#define F first
#define S second
#define MODU 100000007
#define MAX 1e+18
typedef long long LL;
using namespace std;

LL pow(LL a,LL b,LL MOD)
{
    LL p=a,ans=1;
    while(b){
        if(b%2==1)
            ans=(ans*p)%MOD;
        b/=2;
        p=(p*p)%MOD;
    }
    return ans;
}

int main()
{
    //freopen("input.txt","r",stdin);
    int t;
    cin>>t;
    while(t--){
        LL n;
        cin>>n;
        LL po2,po3,po4,po22,po33;
        po2=pow(2,n,MODU);
        po22=pow(2,n-1,MODU);
        po3=pow(3,n,MODU*2);
        po33=pow(3,n+1,MODU*2);
        po3/=2;
        po33/=2;
        po4=pow(4,n-1,MODU);
        LL r1,r2;
        r1=(po3+1-po2+MODU)%MODU;
        r2=((2*po4)%MODU-(po33)%MODU+(3*po22)%MODU-1+MODU)%MODU;
        cout<<r1<<" "<<r2<<endl;
    }
}
