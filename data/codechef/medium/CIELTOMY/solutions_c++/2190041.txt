#include<iostream>
#include<queue>
#include<vector>
using namespace std;

typedef pair<int , int> node;
typedef vector<node> list;

int paths[100];

int findPaths(list graph[] ,int dist[] , int source , int dest)
{

    if(dest == source)
        return 1;
    int count = 0;
    for(list::iterator it=graph[dest].begin() ; it!= graph[dest].end() ; it++)
    {
        if(dist[it->first] + it->second == dist[dest])
        {
            count += findPaths(graph , dist , source , it->first );
        }
    }
    return count;
}

int Dijakstra( list graph[] , int start , int dest , int size)
{
    priority_queue<node , vector<node> , greater<node> > Q;
    int dist[size];
    fill_n(dist ,size , 1000);
    dist[start] = 0 ;
    Q.push(make_pair(0,start));

    while(!Q.empty())
    {
        node curr = Q.top();
        Q.pop();
        if(curr.second == dest)
        break;

        for(list::iterator it  = graph[curr.second].begin() ; it != graph[curr.second].end() ; it++)
        {
            if(dist[curr.second] + it->second < dist[it->first])
            {
                dist[it->first] = dist[curr.second] + it->second;
                Q.push(make_pair(dist[it->first] , it->first));
            }
        }
    }
    fill_n(paths,100 , -1);
    return findPaths(graph ,dist , start,dest);
}



int main()
{
    int t , n , m;
    cin >>t;
    while(t--)
    {
        cin >>n >> m;
        list graph[n];
        int a,b,c;
        for(int x= 0 ; x< m;x++)
        {
            cin >> a>>b>>c;
            node dummy ;
            a--;
            b--;
            dummy.second = c ;
            dummy.first = b;
            graph[a].push_back(dummy);

            dummy.first = a;
            graph[b].push_back(dummy);
        }

        int paths = Dijakstra(graph , 0  , n-1, n);
        cout<< paths << "\n";

    }
    return 0;
}
