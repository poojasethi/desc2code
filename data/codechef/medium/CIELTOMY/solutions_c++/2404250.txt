#include <iostream>
#include <vector>
#include <string>
#include <cstdio>
#include <algorithm>
#include <climits>
#include <utility>
#include <fstream>
#include <map>
#include <cmath>
#include <functional>
#include <exception>
#include <stdexcept>
#include <sstream>
#include <cassert>
#include <memory>
#include <limits>

class graph {
private:
	std::vector<std::vector<int> > cost;
	std::vector<std::vector<int> > ways;

public:
	graph(int n) :
			cost(n, std::vector<int>(n, 999999)),
			ways(n, std::vector<int>(n, 0)) {
		for (int i = 0; i < n; ++i) {
			ways[i][i] = 1;
			cost[i][i] = 0;
		}
	}

	void add_edge(int u, int v, int c) {
		cost[u][v] = c;
		cost[v][u] = c;
		ways[u][v] = 1;
		ways[v][u] = 1;
	}

	int count_shortest_path(int from, int to) {
		return ways[from][to];
	}

	void floyd_warshall() {
		int n = cost.size();
		for (int k = 0; k < n; ++k) {
			for (int u = 0; u < n; ++u) {
				for (int v = 0; v < n; ++v) {
					if (u == k || v == k) {
						continue;
					}
					if (cost[u][k] + cost[k][v] < cost[u][v]) {
						cost[u][v] = cost[u][k] + cost[k][v];
						ways[u][v] = ways[u][k] * ways[k][v];
					}
					else if (cost[u][k] + cost[k][v] == cost[u][v]) {
						ways[u][v] += ways[u][k] * ways[k][v];
					}
				}
			}
		}
	}

};

void inout_ciel_and_tomya() {
	int test_cases;
	int city;
	int road;
	int u;
	int v;
	int cost;
	std::cin >> test_cases;
	while (test_cases--) {
		std::cin >> city >> road;
		graph g(city);
		for (int r = 0; r < road; ++r) {
			std::cin >> u >> v >> cost;
			g.add_edge(u - 1, v - 1, cost);
		}
		g.floyd_warshall();
		std::cout << g.count_shortest_path(0, city - 1) << '\n';
	}
}

int main() {
	inout_ciel_and_tomya();
	return 0;
}
