#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<map>
#include<set>
#include<string>
#include<iostream>
using namespace std;

#define SI ({int x;scanf("%d",&x);x;})
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
#define PRINT(x) { printf("%d\n", (x) ) ; }
#define MIN(a,b) if(a>(b)) a=(b)
#define MAX(a,b) if(a<(b)) a=(b)
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)	
#define fill(a,v) memset(a, v, sizeof a)


map< string, int > cities;
int adjMat[ 50 ][ 50 ];
string names[ 50 ];
int n;
int visited[ 50 ];
char* error;
string ecity;


void input()
{
	error = ( char* ) malloc( 50 * sizeof( char ) );
	n = SI;
	fill( adjMat, -1 );

	REP( i, n )
	{
		cin >> names[ i ];
		cities[ names[ i ] ] = i;
	}

	int m = SI;

	REP( i, m )
	{
		string c1, c2;
		int len;

		cin>>c1>>c2>>len;

		int i1 = cities[ c1 ];
		int i2 = cities[ c2 ];

		adjMat[ i1 ][ i2 ] = len;
						
	}
}

int main()
{
	input();

	int t  = SI;

	REP( j, t )
	{
		int k = SI;
		int flag = 0;
		fill( visited, 0 );
		int result = 0;

		int i1, i2;
		string s;

		cin >>s ;

		if( cities.find( s ) != cities.end() ) 
		{
			i1 = cities[ s ];
			visited[ i1 ] = 1;
		}

		else
		flag = 1;
		sprintf( error, " is not a city\n" );
		ecity = s;

		REP( i, k-1 )
		{
			cin >> s;

			if( flag>0 )
			continue;

			if( cities.find(s) == cities.end() ) // city does not exist
			{
				flag = 1;
				sprintf( error, " is not a city\n" );
				ecity = s;
				
				continue;
			}

			i2 = cities[ s ];
		
			if( visited[ i2 ] >0 ) // city already visited
			{
				flag = 1;
				sprintf( error, " already visited\n" );
				ecity = s;
				continue;
			}
		
			visited[ i2 ] = 1;

			if( adjMat[ i1 ][ i2 ] <0 ) // road does not exist
			{
				flag = 1;
				sprintf( error, " has no road to it\n"  );
				ecity = s;
				continue;	
			}

			int d = adjMat[ i1 ][ i2 ];
			result +=d;
			i1 = i2;
			
		}
	
		if( flag == 1 )
		{
			cout<<"ERROR"<<endl;
			// cout<< ecity << error;
		}

		else
			cout<<result<<endl; 
		
	}

	

	
	return 0;
	
	
	
	
}
