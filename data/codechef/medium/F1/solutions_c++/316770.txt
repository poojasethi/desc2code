#include<iostream>
#include<cstdio>
#include<fstream>
#include<sstream>
#include<algorithm>
#include<functional>
#include<complex>
#include<iomanip>
#include<numeric>
#include<cassert>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<utility>
#include<vector>
#include<string>
#include<queue>
#include<stack>
#include<set>
#include<list>
#include<bitset>
#include<map>
 
#define SIZE(X) ((int)(X.size()))
#define LENGTH(X) ((int)(X.length()))
#define MP(X,Y) make_pair((X),(Y))
#define two(X) (1<<(X))
#define twoL(X) (1LL<<(X))
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define Clear(A,n) memset(A,n,sizeof(A))
#define FOR(i,n) for(int i=0;i<(n);i++)
#define REP(i,a,b) for(int i=(a);i<=(b);i++)


using namespace std;
typedef pair<int,int> PII;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<PII> VII;
typedef map<int,int> MII;
typedef map<string ,int > MSI;

template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}
template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}
template<class T> inline int countbit(T n){return (n==0)?0:(1+countbit(n&(n-1)));}
template<class T> inline T sqr(T x){return x*x;}
template<class T> inline T lowbit(T n){return n&(-n);}
template<class T> inline T gcd(T a,T b)
{if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);}

const double pi=acos(-1.0);
const double eps=1e-10;
const int Dx[8]={-1,0,1,0,-1,1,1,-1};
const int Dy[8]={0,1,0,-1,1,1,-1,-1};

const double INF = 1000000000 ;
const int mod = 123657 ;

const int MAXN = 500+10;
const int MAXM = 700+10 ;


int A[ MAXN ][ MAXN ] ;
int B[ MAXN ][ MAXN ] ;
int BN[ MAXN ][ MAXN ] ;

int Que[ MAXN ] ;
int tail , head , num , size ;


int main(){
	// freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);

	int cases; scanf("%d",&cases);

	FOR( tc , cases ){

		int N , M , K ;
		printf("Case %d:\n" , tc + 1 );

		scanf("%d%d%d",&N,&M,&K);
		
		FOR( i , N ) FOR( j , M ) scanf("%d",&A[i][j]);
		
		FOR( i , K )FOR( j , K ) B[i][j] = 0 , BN[i][j] = 0 ;


		FOR( i , N ){
			tail = 0 , head = 0 ;
			FOR( j , M ){
				while( tail != head && A[ i ][ Que[ tail - 1 ] ] < A[ i ][ j ] ){
					tail -- ;
				}
				if( tail == head ) size = 0 ;
				Que[ tail ++ ] = j ;
				if( A[ i ] [ Que[ tail-1 ] ] == A[ i ][ Que[ head ] ] ){
					size ++ ;
				}
				if( j >= K - 1 ){
					B[ i ][ j - K + 1 ] = A[ i ] [ Que[head] ] ;
					BN[ i ][ j - K + 1 ] = size ;
				}
				if( j >= Que[ head  ] + K - 1  ){
					head ++; size -- ;
					if( size == 0 ){
						int tmp = head; 
						while( tmp < tail && A[ i ][ Que[tmp] ] == A[ i ][ Que[head] ] ) tmp ++ ,size++ ;
					}
				}
			}
		}
		/*
		FOR( i , N ){
			FOR( j , M - K + 1  ) {
				if( j ) putchar(' ');
				printf("%d",B[ i ] [ j ] );
				if( BN[ i ][ j ] != 1 ) printf("(%d)",BN[i][j]);
			}
			putchar('\n');
		}
		*/
		FOR( i , M - K + 1 ){
			tail = 0 , head = 0 ;
			 FOR( j , N ){
				while( tail != head && B[ Que[ tail - 1 ] ][ i ] < B[ j ][ i ] ){
					tail -- ;
				}
				if( tail == head ) size = 0 ;
				Que[ tail ++ ] = j ;

				if( B[ Que[ tail-1 ] ] [ i ] == B[ Que[ head ] ][ i ] ){
					size += BN[ j ][ i ] ;
				}
				if( j >= K - 1 ){
					//cout << size << endl;
					B[ j - K + 1 ][ i ] = B[ Que[ head ] ] [ i ] ;
					A[ j - K + 1 ][ i ] = size ;
				}

				if( j >= Que[ head  ] + K - 1  ){
					size -= BN[ Que[ head  ] ][ i ] ; head ++;
					if( size == 0 ){
						int tmp = head; 
						while( tmp < tail && B[ Que[tmp] ][ i ] == B[ Que[head] ][ i ] ) size+=BN [ Que[ tmp ] ] [ i ] ,tmp ++ ;
					}
				}
			 }
		}
		
		FOR( i , N-K+1 ){
			FOR( j , M-K+1 ) {
				if( j ) putchar(' ');
				printf("%d",B[ i ] [ j ] );
				if( A[ i ][ j ] != 1 ) printf("(%d)",A[i][j]);
				//putchar(' ');
			}
			putchar('\n');
		}

		puts("");
	}
}

/*
23
2 3 1
1 2 3
4 5 6

2 3 2
1 2 3
4 5 6

*/
