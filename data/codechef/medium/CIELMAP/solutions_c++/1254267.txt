#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <algorithm>
#include <map>
#include <set>
#include <list>
#include <vector>
#include <stack>
#include <queue>
#include <iterator>
#include <functional>
#include <cstring>
#include <climits>
#include <cassert>
#include <cmath>

using namespace std;

#define ALL(x) x.begin(),x.end()
#define REP(i,n) for (int i=0; i<(n); ++i)
#define FOR(var,start,end) for (int var=(start); var<=(end); ++var)
#define FORD(var,start,end) for (int var=(start); var>=(end); --var)
#define FOREACH(it, X) for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define PB push_back
#define PF push_front
#define MP(a,b) make_pair(a,b)
#define ST first
#define ND second
#define SIZE(x) (int)x.size()

// typedef long long LL;
typedef pair<int, int> PII;
typedef vector<int> VI;
typedef vector<bool> VB;
typedef vector< vector<int> > VVI;
typedef vector< vector<bool> > VVB;

static double calcDist(const PII &p1, const PII &p2) {
    double x1 = static_cast<double>(p1.ST);
    double y1 = static_cast<double>(p1.ND);
    double x2 = static_cast<double>(p2.ST);
    double y2 = static_cast<double>(p2.ND);

    return sqrt((y1-y2) * (y1-y2) + (x1-x2)*(x1-x2));
}


static double determinant(const PII &a, const PII &b) {
    return (a.ST * b.ND - a.ND * b.ST);
}

static bool good(const PII &p1, const PII &p2, const vector<PII> &points) {
    int cntLeft = 0;
    int cntRight = 0;
    FOREACH (p, points) if (*p != p1 && *p != p2) {
        int d = determinant(MP(p2.ST - p1.ST, p2.ND - p1.ND),
                            MP(p->ST - p1.ST, p->ND - p1.ND));
        if (d < 0) ++cntLeft;
        else ++cntRight;

        if (cntLeft >= 2 || cntRight >= 2) return true;
    }
    return false;
}

/*
 * idea:
 * consider the line through every possible pair of points:
 * if more than 2 points lie left (or right) of the line it
 * is possible to construct a tetragon
 */
int main() {

    int nTests = 0;
    scanf("%d", &nTests);

    REP (test, nTests) {
        int nPoints = 0;
        scanf("%d", &nPoints);

        vector<PII> points;
        REP (i, nPoints) {
            int x, y;
            scanf("%d%d", &x, &y);

            points.PB(MP(x, y));
        }

        double best = 0.0;
        REP (i, nPoints) {
            FOR (j, i+1, nPoints-1) {
                if (good(points[i], points[j], points)) {
                    best = max(best, calcDist(points[i], points[j]));
                }
            }
        }

        printf("%.10f\n", best);
     }

    return 0;
}
