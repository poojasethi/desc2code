using namespace std;
#include <cmath>
#include <cstdio>
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
typedef long long ll; 
typedef pair<int,int> pii; 
#define FOR(i,n) for (int i = 0; i < n; i++)
#define SZ(x) ((int)x.size())
#define PB push_back
#define MP make_pair
#define sf(x) scanf("%d",&x)
#define split(str) {vs.clear();istringstream ss(str);while(ss>>(str))vs.push_back(str);}
long DIRECTION(pair<int,int> p1,pair<int,int> p2,pair<int,int> p3)
{
	return (p2.first-p1.first)*(p3.second-p1.second)-(p3.first-p1.first)*(p2.second-p1.second);
}
bool intersect1(pair<int,int> p1,pair<int,int> p2,pair<int,int> p3,pair<int,int> p4)
{
  if(max(p1.first,p2.first)>=min(p3.first,p4.first))
    if(max(p3.first,p4.first)>=min(p1.first,p2.first))
      if(max(p1.second,p2.second)>=min(p3.second,p4.second))
	if(max(p3.second,p4.second)>=min(p1.second,p2.second))
	  return true;
  return false;
}
bool intersect(pair<int,int> p1,pair<int,int> p2,pair<int,int> p3,pair<int,int> p4)
{
	ll d1 = DIRECTION(p1,p3,p4);
	ll d2 = DIRECTION(p2,p3,p4);
	ll d3 = DIRECTION(p3,p1,p2);
	ll d4 = DIRECTION(p4,p1,p2);
	if(d1*d2<0&&d3*d4<0)return true;
	return false;
}
double dist(pair<int,int> p1,pair<int,int> p2)
{
	ll x1=p1.first;
	  ll x2=p2.first;
	  ll y1=p1.second;
	  ll y2=p2.second;
	  return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}
int main()
{
  //cout<<intersect(MP(0,0),MP(0,2),MP(1,1),MP(2,1));
  int t;
  sf(t);
  while(t--)
  {
    int n;
    sf(n);
    vector<pair<int,int> > v;
    FOR(i,n)
    {
      int a,b;
      sf(a);sf(b);
      v.PB(make_pair(a,b));
    }
    if(n==4)
    {
      double max=0;
	FOR(i,4)FOR(j,4)FOR(k,4)FOR(l,4)
	{
		if(i==j||j==k||k==l||i==l||i==k||j==l)continue;
		if(intersect(v[i],v[j],v[k],v[l])||intersect(v[j],v[k],v[i],v[l]))continue;
		if(max<dist(v[i],v[j]))max=dist(v[i],v[j]);
		if(max<dist(v[j],v[k]))max=dist(v[j],v[k]);
		if(max<dist(v[k],v[l]))max=dist(v[k],v[l]);
		if(max<dist(v[l],v[i]))max=dist(v[l],v[i]);
	}
/*
      if(!(intersect(v[0],v[1],v[2],v[3])))
      {
	ll x1=v[0].first;
	  ll x2=v[1].first;
	  ll y1=v[0].second;
	  ll y2=v[1].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
	 x1=v[2].first;
	   x2=v[3].first;
	   y1=v[2].second;
	   y2=v[3].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
      }
      if(!(intersect(v[0],v[2],v[1],v[3])))
      {
	ll x1=v[0].first;
	  ll x2=v[2].first;
	  ll y1=v[0].second;
	  ll y2=v[2].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
	 x1=v[1].first;
	   x2=v[3].first;
	   y1=v[1].second;
	   y2=v[3].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
      }
      if(!(intersect(v[0],v[3],v[2],v[1])))
      {
	ll x1=v[0].first;
	  ll x2=v[3].first;
	  ll y1=v[0].second;
	  ll y2=v[3].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
	 x1=v[2].first;
	   x2=v[1].first;
	   y1=v[2].second;
	   y2=v[1].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
      }
*/
      printf("%.8f\n",sqrt(max));
    }
    else
    {
      double max=0;
      FOR(i,v.size()-1)
	for(int j=i+1;j<v.size();j++)
	{
	  ll x1=v[i].first;
	  ll x2=v[j].first;
	  ll y1=v[i].second;
	  ll y2=v[j].second;
	  if(max<(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))max=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
	}
      printf("%.8f\n",sqrt(max));
    }
  }
}
