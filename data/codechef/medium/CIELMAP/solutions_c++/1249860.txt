// File Name   : cielmap.cpp
// Development : Saturday 11 August 2012 10:24:25 PM IST
// Author      : Xeronix

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <cstring>
#include <string.h>
#include <cstdlib>
#include <bitset>
#include <sstream>
#include <stack>
#include <queue>
#include <numeric>
#include <utility>
#include <cctype>
#include <list>
#include <limits.h>
#include <signal.h>
#include <time.h>
#include <map>
#include <set>
#include <float.h>
#include <new>
#include <sstream>
#include <complex>
#include <deque>

#define TR(c,i) for ( typeof((c).begin()) i = (c).begin(); i != (c).end(); i++ ) 
#define SWAP(a,b) {typeof(a) T; T=a; a=b; b=T;}
#define FOR(i,a,b) for ( i = a; i <= b; i++ )
#define ROF(i,a,b) for ( i = a; i >= b; i-- )
#define MEM(t,n) ( t * )malloc( (n)*sizeof( t ) )
#define ALL(v) (v).begin(), (v).end()
#define SORT(v) sort( ALL(v) )
#define MAX(a,b) ((a) >= (b) ? (a) : (b))
#define MIN(a,b) ((a) <= (b) ? (a) : (b))
#define ABS(a) ((a) < (0) ? (a)*(-1) : (a))
#define SET(x,a) memset(x,a,sizeof(x))
#define IN(x,a) x.find(a) != x.end()  
#define SQ(x) (x)*(x)
#define DIST(x1,y1,x2,y2) SQ(x1-x2)+SQ(y1-y2)
#define PB push_back
#define MP make_pair
#define F first
#define S second

#define DEB(x) cout << #x << " = " << x << endl;
#define DEBA(x,n) { int i; cout << "{\n"; FOR(i,0,n-1)cout << i << " " << x[i] << endl; cout << "}\n"; }
#define DEBT(x) { cout << "{\n"; TR( x,it ) cout << *it << "\n" ; cout << "}\n"; }
#define DEBM(x) { cout << "{\n"; TR( x,it ) cout << it->F << " : " << it->S << "\n"; cout << "}\n"; }

#define SYNC ios_base::sync_with_stdio(false);
#define C(format,n) scanf( "%"#format, &n )

//#define LIM
#ifdef LIM
	int S, D, Y, O;
	char *inp, *out, *ipos, *opos, DIG[30];
	#define FRMI inp=( char * )malloc( LIM*sizeof( char ) );fread_unlocked( inp,1,LIM,stdin );ipos=inp;
	#define FWM out=( char * )malloc( LIM*sizeof( char ) );opos=out;
	#define FWO fwrite_unlocked( out,opos-out,1,stdout );
	#define GETI(n) n=0;while(*ipos<33){ipos++;}if(*ipos=='-'){S=-1;ipos++;}else{S=1;}while(*ipos>='0'){n=10*n+(*ipos-'0');ipos++;}n*=S;
	#define PUTI(n) O=n;D=0;if(O<0){*opos++='-';O*=-1;}if(!O)*opos++='0';else{while(O){Y=O/10;DIG[D++]=O-Y*10+'0';O=Y;}\
	while(D--)*opos++=DIG[D];}
	#define PUTC(c) *opos++=c;
#endif

using namespace std;

template<class T> inline string tostring( T n ){ stringstream ss; ss << n; ss.flush(); return ss.str(); }
template<class T> inline string tobinary( T n ){ string s = n ? "" : "0"; while( n ) { s += ( ( n & 1 ) + '0' ); n >>= 1; } return s; }
template<class T> inline int digits( T n ){ int cnt = n ? 0 : 1; while( n ){ n /= 10; cnt++; } return cnt; }
template<class T1, class T2> inline T2 gcd( T1 a, T2 b ){ return !b ? a : gcd( b, a%b ); }

#define VAL(x,y,x1,y1,x2,y2) ( (y-y1)*(x2-x1) + (x1-x)*(y2-y1) )
struct point {
	int x, y;
};

int main()
{
	int t, n, i, j;
	point pt[1010];

	C(d,t);

	while ( t-- ) { 
		C(d,n);

		FOR( i,0,n-1 ) {
			C(d,pt[i].x);
			C(d,pt[i].y);
		}

		int maxd = INT_MIN;

		if( n > 4 ) {
			FOR( i,0,n-1 ) {
				FOR( j,i+1,n-1 ) {
					maxd = MAX( maxd, DIST( pt[i].x, pt[i].y, pt[j].x, pt[j].y ) );
				}
			}
		} else {
			 if( VAL( pt[2].x,pt[2].y,pt[0].x,pt[0].y,pt[1].x,pt[1].y )*1LL*
					 VAL( pt[3].x,pt[3].y,pt[0].x,pt[0].y,pt[1].x,pt[1].y ) >= 0 ) {
				 maxd = MAX( maxd, DIST( pt[0].x, pt[0].y, pt[1].x, pt[1].y ) );
			 }
			 
			 if( VAL( pt[0].x,pt[0].y,pt[1].x,pt[1].y,pt[2].x,pt[2].y )*1LL*
					 VAL( pt[3].x,pt[3].y,pt[1].x,pt[1].y,pt[2].x,pt[2].y ) >= 0 ) {
				 maxd = MAX( maxd, DIST( pt[1].x, pt[1].y, pt[2].x, pt[2].y ) );
			 }

			 if( VAL( pt[0].x,pt[0].y,pt[2].x,pt[2].y,pt[3].x,pt[3].y )*1LL*
					 VAL( pt[1].x,pt[1].y,pt[2].x,pt[2].y,pt[3].x,pt[3].y ) >= 0 ) {
				 maxd = MAX( maxd, DIST( pt[2].x, pt[2].y, pt[3].x, pt[3].y ) );
			 }

			 if( VAL( pt[2].x,pt[2].y,pt[3].x,pt[3].y,pt[0].x,pt[0].y )*1LL*
					 VAL( pt[1].x,pt[1].y,pt[3].x,pt[3].y,pt[0].x,pt[0].y ) >= 0 ) {
				 maxd = MAX( maxd, DIST( pt[3].x, pt[3].y, pt[0].x, pt[0].y ) );
			 }
			 
			 if( VAL( pt[0].x,pt[0].y,pt[1].x,pt[1].y,pt[3].x,pt[3].y )*1LL*
					 VAL( pt[2].x,pt[2].y,pt[1].x,pt[1].y,pt[3].x,pt[3].y ) >= 0 ) {
				 maxd = MAX( maxd, DIST( pt[1].x, pt[1].y, pt[3].x, pt[3].y ) );
			 }
			 
			 if( VAL( pt[1].x,pt[1].y,pt[0].x,pt[0].y,pt[2].x,pt[2].y )*1LL*
					 VAL( pt[3].x,pt[3].y,pt[0].x,pt[0].y,pt[2].x,pt[2].y ) >= 0 ) {
				 maxd = MAX( maxd, DIST( pt[0].x, pt[0].y, pt[2].x, pt[2].y ) );
			 }
		}

		printf( "%.10lf\n", sqrt( maxd ) );
	}

	return 0;
}
