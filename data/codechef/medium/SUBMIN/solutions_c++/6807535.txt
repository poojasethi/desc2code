//i've implemented brute force method...
//check for each element to last element.. that min element is there and upto what index subarray is there...
// we break the loop if min>a[i] because a[i] would be minimum in that subarray but that we dont want to include in our subarray...
#include<bits/stdc++.h>
#define MAX 52
using namespace std;

int main()
{
    int n,a[MAX],q;
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    cin>>q;
    while(q--)
    {
        int i,j,min,ans=0,flag,beforemin=0;
        cin>>min;
        for(i=0;i<n;i++)
        {
            flag=0;
            beforemin=0;
            for(j=i;j<n;j++)
            {
                // checking flag is necessary because flag will not allow yes to update it again
                if(min==a[j]&&flag==0)
                {
                    flag=1;
                    beforemin=j-i;// because ex:-a[]={3,4,1,4,6} for query=1 from starting we're going to exclude those elements which are before min element...
                }
                if(min>a[j])
                   break;
            }
            if(flag)
            {
                ans +=(j-i)-beforemin;
            }
            //cout<<ans<<"   ";
        }
        cout<<ans<<endl;

    }
    return 0;
}
