#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#define stream istringstream
#define rep(i,n) for(__typeof(n) i=0; i<(n); i++)
#define repl(i,n) for(__typeof(n) i=1; i<=(n); i++)
#define INF (1<<28)
#define PI 3.14159265358979323846264338327950
#define pb(x) push_back(x)
#define ppb pop_back
#define all(x) x.begin(),x.end()
#define mem(x,y) memset(x,y,sizeof(x));
#define eps 1e-9
#define pii pair<int,int>
#define pll pair<long long,long long>
#define pmp make_pair
#define sz(s) ((int)(s.size()))


using namespace std;
template<class T> inline T gcd(T a,T b) {if(a<0)return 
gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);}
template<class T> inline T lcm(T a,T b) {if(a<0)return 
lcm(-a,b);if(b<0)return lcm(a,-b);return a*(b/gcd(a,b));}
template<class T> inline T sqr(T x){return x*x;}
template<class T> T power(T N,T P){ return (P==0)?  1: N*power(N,P-1); }
template<class T> bool inside(T a,T b,T c){ return (b>=a && b<=c);}
typedef long long i64;
typedef unsigned long long ui64;

#define READ(f) freopen(f, "r", stdin)
#define WRITE(f) freopen(f, "w", stdout)

#define mx 105


i64 MOD=100000007 ;
i64 modf(i64 n,i64 p,i64 m)
{	
	if(p==0) return 1;
	if(p%2==0) 	{		i64 ret=modf(n,p>>1,m);		return ((ret%m)*(ret%m))%m;	}
	else return ((n)*(modf(n,p-1,m)))%m;
}
i64 arr[20000];






namespace matrix {
#define size 105
#define wint int
    wint mat[size][size], tmp[size][size], res[size][size];
    wint MOD;
    int n;
    void init(int _n, wint _MOD) {
	n = _n;
	MOD = _MOD;
	mem(mat, 0);
	mem(tmp, 0);
	mem(res, 0);
    } void mul(wint r[][size], wint a[][size], wint b[][size]) {
	rep(i, n) rep(j, n) {
	    i64 val = 0;
	    rep(t, n) val += 1LL * a[i][t] * b[t][j];
	    tmp[i][j] = val % MOD;
	}
	memcpy(r, tmp, n * size * sizeof(tmp[0][0]));
    }
    void mPow(wint r[][size], wint a[][size], wint p) {
	if (p < 0)
	    return;
	mem(r, 0);
	rep(i, n) r[i][i] = 1;
	while (p > 0) {
	    if (p & 1)
		mul(r, r, a);
	    mul(a, a, a);
	    p >>= 1;
	}
    }
    void pow(wint p) {
	mPow(res, mat, p);
	memcpy(mat, res, n * size * sizeof(tmp[0][0]));
    }
    void fill() {
	rep(i, n - 1) {
	    mat[0][i] = 1;
	    if (i)
		mat[i][i - 1] = 1;
	}
    }
    void print(wint pp[][size]) {
	rep(i, 1) {
	    rep(j, n) printf(" %09d", pp[i][j]);
	    cout << endl;
	}
    }
#undef MOD
#undef size
#undef wint
};

int r[mx][mx];

int main()
{
	//READ("in");
	
	int t;
	cin>>t;
	while(t--)
	{
		i64 init,s1,s2,k,n;
		cin>>init>>s1>>s2>>k>>n;
		
		arr[0]=init;
		
		
		
		for(int i=1;i<=s1;i++)
		{
			arr[i]=arr[i-1]+1;
			arr[i]%=MOD;
		}
		for(int i=s1+1;i<=s1+s2;i++)
		{
			arr[i]=arr[i-1]*2;
			arr[i]%=MOD;
			
		}
		
		
		int p=n-(s1+s2+1);
		if(p<=0)
		{
			printf("%lld\n",arr[n-1]);
			
			continue;
		}
		
		matrix::init(k+1,MOD-1);
		matrix::fill();
		matrix::pow(p);
		mem(r,0);
		
		
		for(int i=0;i<k;i++) r[i][i]=1;
		matrix::mul(r,matrix::mat,r);

		
		i64 ans=1;
		for(int i=s1+s2,j=0;j<k;i--,j++)
		{
			ans*=modf(arr[i],r[0][j],MOD);
			ans%=MOD;
		//	cout<<arr[i]<<" "<<my[0][j]<<endl;
		}
		cout<<ans%MOD<<endl;
		
		
	}

	
	
}


