#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
#include<map>
#include<cctype>
#include<sstream>
#define L long long int
#define U unsigned long long int
#define R 1000000007
using namespace std;

void multiply(U F[3][3],U M[3][3]);
void power(U F[3][3],U n);

U crowd(U n)
{
	U F[3][3]={{1,1,0},{1,0,1},{1,0,0}};
	if(n==0)return 0;
	power(F,n+1);
	return F[0][0];
}

void power(U F[3][3],U n)
{
	if(n==0 || n==1)return;
	U M[3][3]={{1,1,0},{1,0,1},{1,0,0}};
	power(F,n/2);
	multiply(F,F);
	if(n%2!=0)
	{
		multiply(F,M);
	}
}

void multiply(U F[3][3],U M[3][3])
{
	U a=((F[0][0]*M[0][0])%R + (F[0][1]*M[1][0])%R + (F[0][2]*M[2][0])%R)%R;
	U b=((F[0][0]*M[0][1])%R + (F[0][1]*M[1][1])%R + (F[0][2]*M[2][1])%R)%R;
	U c=((F[0][0]*M[0][2])%R + (F[0][1]*M[1][2])%R + (F[0][2]*M[2][2])%R)%R;
	U d=((F[1][0]*M[0][0])%R + (F[1][1]*M[1][0])%R + (F[1][2]*M[2][0])%R)%R;
	U e=((F[1][0]*M[0][1])%R + (F[1][1]*M[1][1])%R + (F[1][2]*M[2][1])%R)%R;
	U f=((F[1][0]*M[0][2])%R + (F[1][1]*M[1][2])%R + (F[1][2]*M[2][2])%R)%R;
	U g=((F[2][0]*M[0][0])%R + (F[2][1]*M[1][0])%R + (F[2][2]*M[2][0])%R)%R;
	U h=((F[2][0]*M[0][1])%R + (F[2][1]*M[1][1])%R + (F[2][2]*M[2][1])%R)%R;
	U i=((F[2][0]*M[0][2])%R + (F[2][1]*M[1][2])%R + (F[2][2]*M[2][2])%R)%R;
	F[0][0]=a;
	F[0][1]=b;
	F[0][2]=c;
	F[1][0]=d;
	F[1][1]=e;
	F[1][2]=f;
	F[2][0]=g;
	F[2][1]=h;
	F[2][2]=i;
}

U pow2(U n)
{
	if(n==0)return 1;
	if(n==1)return 2;
	 U x = pow2(n/2);
    if(n&1)
          return (x*((x*2)%R))%R;
    return (x*x)%R;
}

int main()
{
	int t;
	scanf("%d",&t);
	U n;
	while(t--)
	{
		scanf("%llu",&n);
		U x=pow2(n),y=crowd(n);
		if(x>=y)cout<<x-y<<endl;
		else cout<<R+x-y<<endl;
	}
}
