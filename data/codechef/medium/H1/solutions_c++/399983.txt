#include <vector>
#include <map>
#include <set>
#include <string>
#include <queue>
#include <utility>
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

#define swap(x,y) { int _t = (x); (x) = (y); (y) = _t; }
#define min(x,y) ((x) < (y) ? (x) : (y))
#define max(x,y) ((x) > (y) ? (x) : (y))
#define PRINT(x) cout << #x << " = " << x << endl
#define FORab(i,a,b) for(int i = (a); i < (int)b; i++)
#define FORn(i,n) FORab(i,0,n)

typedef pair<int,int> pi;

//               0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17
int isPrime[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1};
/*
	0	1	2
	3	4	5
	6	7	8
 */
int adj[] = {0,1, 1,2, 3,4, 4,5, 6,7, 7,8, 0,3, 1,4, 2,5, 3,6, 4,7, 5,8};
int visited[362880];

/*
   Calculates the unique id based on Inversions and Factorial Number System
 */
int id(int a[9]) {
	int val = 0;
	FORn(i,9) {
		int inversions = 0;
		FORab(j,i+1,9) if(a[i] < a[j]) inversions++;
		val = val * (9-i) + inversions;
	}
	return val;
}

int value(int a[9]) {
	int v = 0;
	FORn(i,9) v = v * 10 + a[i];
	return v;
}

map<int, int> distances;

void bfs() {
	int root[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

	memset(visited, 0, sizeof(visited));

	queue<pi> moves;
	moves.push(make_pair(value(root),0));

	while(!moves.empty()) {
		pi move = moves.front(); moves.pop();
		int v = move.first;
		int a[9];
		FORn(i,9) a[8-i] = v % 10, v /= 10;
		int ID = id(a);
		if(visited[ID])
			continue;
		visited[ID] = 1;

		distances[move.first] = move.second;
		int move_count = move.second+1;

		for(int k = 0; k < 24; k+=2) {
			int i = adj[k], j = adj[k+1];
			if(isPrime[a[i]+a[j]]) {
				swap(a[i], a[j]);
				moves.push(make_pair(value(a),move_count));
				swap(a[i], a[j]);
			}
		}
	}

	return;
}

void main2() {
	int a[9];
	FORn(i,9) scanf("%d", &a[i]);

	if(!visited[id(a)])
		printf("-1\n");
	else {
		map<int,int>::iterator it = distances.find(value(a));
		printf("%d\n", it->second);
	}
}

int main() {
	int T;
	scanf("%d", &T);
	bfs();
	FORn(i,T) main2();
	return 0;
}
