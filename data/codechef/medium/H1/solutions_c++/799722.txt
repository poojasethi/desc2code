#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#define MAX 362880
#define REP(i,n) for(int i = 0; i < n; i++)
using namespace std;

int perm[MAX];
int cnt = 0;
int steps[MAX];
int dig[9] = {1,2,3,4,5,6,7,8,9};
int pp[] = {3,5,7,11,13,17};
int sp[12][2] = {{8,7},{7,6},{5,4},{4,3},{2,1},{1,0},{8,5},{5,2},{7,4},{4,1},{6,3},{3,0}};

int ni(){
    int v;
    scanf("%d", &v);
    return v;
}

int Bsearch(int val){
    int low = 0;
    int high = MAX-1;
    int mid;
    while(low <= high){
        mid = (low+high)/2;
        if(perm[mid] == val){
            return mid;
        }
        else if(perm[mid] > val){
            high = mid-1;
        }
        else{
            low = mid+1;
        }
    }
    return -1;
}

void swap(int *a, int i, int j){
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}

void init(int val, int i){
    if(i == 9){
        //printf("%d\n", val);
        perm[cnt] = val;
        cnt++;
        return;
    }
    int temp[9];
    REP(k,9){
        temp[k] = dig[k];
    }
    sort(dig+i, dig+9);
    for(int j = i; j < 9; j++){
        swap(dig,i,j);
        init(val*10 + dig[i],i+1);
        swap(dig,i,j);
    }
    REP(k,9){
        dig[k] = temp[k];
    }

}

bool isPrime(int v){
    REP(i,6){
        if(v == pp[i]) return true;
    }
    return false;
}

int getNextState(int curr, int i){
    int a = sp[i][0];
    int b = sp[i][1];

    int x[9];
    REP(i,9){
        x[8-i] = curr % 10;
        curr = curr/10;
    }
    int total = x[a] + x[b];
    if(isPrime(total)){
        int temp = x[a];
        x[a] = x[b];
        x[b] = temp;

        curr = 0;
        REP(i,9){
            curr = 10*curr + x[i];
        }
        return curr;
    }
    else{
        return -1;
    }
}

void BFS(){
    queue<int> q;
    q.push(0);
    steps[0] = 0;

    while(!q.empty()){
        int idx = q.front();
        int curr = perm[idx];
        q.pop();

        REP(i,12){
            int next = getNextState(curr, i);
            if(next != -1){
                int nidx = Bsearch(next);
                if(steps[nidx] == -1){
                    q.push(nidx);
                    steps[nidx] = steps[idx] + 1;
                }
            }
        }
    }
}

int main(){
    //freopen("output.txt", "w", stdout);
    init(0,0);
    REP(i,cnt){
        steps[i] = -1;
    }
    BFS();

    int t = ni();
    while(t--){
        int num = 0;
        REP(i,9){
            num = 10*num + ni();
        }
        int state = Bsearch(num);
        printf("%d\n", steps[state]);
    }
}
