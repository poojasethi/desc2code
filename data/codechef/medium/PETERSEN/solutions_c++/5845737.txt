#include<bits/stdc++.h>
#define pp pair<int,string>
using namespace std;
char num[10];
int PETERSON[10][10];
queue<int> Q;//saves the path
void addEdge(int u, int v)
{
    PETERSON[u][v]=1;
    PETERSON[v][u]=1;
}
bool DFS(int begin, string str)
{
    int i = 0;
    int L = str.length();
    Q.push(begin);
    for(int i = 0;i<L-1;i++)
    {
        //the next vertex cannot be the same by any chance
        int next = str[i+1]-65;
        if(next==begin)next+=5;
        next%=10;
        if(PETERSON[begin][next]==1)//they are connected
        {
            Q.push(next);
            begin = next;
        }
        else if(PETERSON[begin][(next+5)%10]==1 && begin!=(next+5)%10)
        {
            next = next+5;
            next%=10;
            Q.push(next);
            begin = next;
        }
        else //if not connected, there is no way
            {
                while(!Q.empty())Q.pop();
                return false;
            }
    }
    return true;
}
int main()
{
    char c = 'A';
    for(int i = 0;i<10;i++)
    {
        num[i] = c+(i%5);
    }
    addEdge(0,1);addEdge(0,5); addEdge(1,2);addEdge(1,6);
    addEdge(2,7);addEdge(2,3); addEdge(3,4);addEdge(3,8);
    addEdge(4,0);addEdge(4,9); addEdge(5,7);addEdge(5,8);
    addEdge(6,8);addEdge(6,9); addEdge(7,9);
    int T;
    cin>>T;
    string TEST;
    for(int i = 0;i<T;i++)
    {
        cin>>TEST;
        //say AAB
        //determine the starting point
        int begin1 = TEST[0]-65;
        int begin2 = (begin1+5)%10;
        if(DFS(begin1,TEST)==true)
        {
            while(!Q.empty())
            {
                cout<<Q.front();Q.pop();
            }
        }
        else if(DFS(begin2,TEST)==true)
        {
            while(!Q.empty())
            {
                cout<<Q.front();Q.pop();
            }
        }
        else cout<<"-1";
        cout<<"\n";
    }
    return 0;
}
