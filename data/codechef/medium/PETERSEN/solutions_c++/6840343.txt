#include<bits/stdc++.h>
using namespace std;
int main()
{
	//map 'A' -> 0, B to 1 , C to  2, D to 3, E to 4
	// store the peterson graph in vector of vectors format
	// now take the string input given to you say AAB 
	// We have to choose the first Mapping of A i.e 0 find out posssible path
	//if not found or found find another path with 0+5=5 
	//finding possible path with chosen starting vertex. take the next letter 
	//in the given string and find out its two mappings and see if walk can be 
	// continued and if it can be than with which number
	//store the the two strings you get and outupt in lexicographical order
	map <char,int> mymap;
	mymap['A'] = 0;
	mymap['B'] = 1;
	mymap['C'] = 2;
	mymap['D'] = 3;
	mymap['E'] = 4;
	vector < vector<int> > matrix;
	int i;
	for(i=0;i<10;i++)
	{
		vector <int> row;
		matrix.push_back(row);
	}
	matrix[0].push_back(1);
	matrix[0].push_back(5);
	matrix[0].push_back(4);
	matrix[1].push_back(0);
	matrix[1].push_back(6);
	matrix[1].push_back(2);
	matrix[2].push_back(1);
	matrix[2].push_back(7);
	matrix[2].push_back(3);
	matrix[3].push_back(2);
	matrix[3].push_back(8);
	matrix[3].push_back(4);
	matrix[4].push_back(3);
	matrix[4].push_back(0);
	matrix[4].push_back(9);
	matrix[5].push_back(0);
	matrix[5].push_back(7);
	matrix[5].push_back(8);
	matrix[6].push_back(1);
	matrix[6].push_back(9);
	matrix[6].push_back(8);
	matrix[7].push_back(5);
	matrix[7].push_back(9);
	matrix[7].push_back(2);
	matrix[8].push_back(5);
	matrix[8].push_back(6);
	matrix[8].push_back(3);
	matrix[9].push_back(4);
	matrix[9].push_back(6);
	matrix[9].push_back(7);
	int t;
	vector <int> answer1;
	vector <int> answer2;
	int flag1=0; int flag2=0;
	int flag,flagh,size,size1,size2,winner,prev,corr1,corr2,j;
	char input[100004],var;
	scanf("%d",&t);
	while(t--)
	{
		flag1=0;
		flag2=0;
		for(i=0;i<=100003;i++)
		{
			input[i] = 'Z';
		}
		answer1.clear();
		answer2.clear();
		scanf("%s",input);
		answer1.push_back(mymap[input[0]]);
		prev = answer1[0];
		//printf("prev=%d\n",prev);
		i=1;
		flag=1;
		while(flag!=0)
		{
			var = input[i];
			//printf("var=%c\n",var);
		
			if(var=='\0')
			{
				flag1=1;
				break;
			} 
			corr1 = mymap[input[i]];
			//printf("corr1=%d\n",corr1);
			corr2 = corr1+5;
			//printf("corr2=%d\n",corr2);
			i++;
			for(j=0;j<=2;j++)
			{
				if(matrix[prev][j]==corr1)
				{
					answer1.push_back(corr1);
					prev=corr1;
					break;
				}
				if(matrix[prev][j]==corr2)
				{
					answer1.push_back(corr2);
					prev=corr2;
					break;
				}
				if(j==2)
				{
					flag=0;
				}
			}
		}
		//printf("flag1=%d\n",flag1);
		answer2.push_back(mymap[input[0]]+5);
		prev = answer2[0];
		//printf("prev=%d\n",prev);
		i=1;
		flag=1;
		while(flag!=0)
		{
			var = input[i];
			if(var=='\0')
			{
				flag2=1;
				break;
			} 
			corr1 = mymap[input[i]];
			corr2 = corr1+5;
			i++;
			for(j=0;j<=2;j++)
			{
				if(matrix[prev][j]==corr1)
				{
					answer2.push_back(corr1);
					prev=corr1;
					break;
				}
				if(matrix[prev][j]==corr2)
				{
					answer2.push_back(corr2);
					prev=corr2;
					break;
				}
				if(j==2)
				{
					flag=0;
				}
			}
		}
		if(flag1==0 && flag2==0)
		{
			printf("-1\n");
		}
		if(flag1==1 && flag2==0)
		{
			for(i=0;i<answer1.size();i++)
			{
				printf("%d",answer1[i]);
			}
			printf("\n");
		}
		if(flag1==0 && flag2==1)
		{
			for(i=0;i<answer2.size();i++)
			{
				printf("%d",answer2[i]);
			}
			printf("\n");
		}
		if(flag1==1 && flag2==1)
		{
			flagh=0;
			size = answer1.size();
			for(i=0;i<size;i++)
			{
				if(answer1[i]==answer2[i])
				{
					continue;
				}
				else if(answer1[i]<answer2[i])
				{
					flagh=1;
					break;
				}
				else
				{
					flagh=2;
					break;
				}
			}
			if(flagh==0)
			{
				flagh=1;
			}
			if(flagh==1)
			{
				for(i=0;i<answer1.size();i++)
				{
					printf("%d",answer1[i]);
				}
				printf("\n");
			}
			else
			{
				for(i=0;i<answer2.size();i++)
				{
					printf("%d",answer2[i]);
				}
				printf("\n");
			}
		}
	}
	
}
