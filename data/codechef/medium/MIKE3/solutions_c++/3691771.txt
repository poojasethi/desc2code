#include<bits/stdc++.h>
using namespace std;
int n,m,res;
//vector<int>stamp[20002];
//offer[22];
 int conflict[22][22]={0},visit[22]={0};
// vector<int>ass;


void combinationUtil(int arr[], int data[], int start, int end, int index, int r);

// The main function that prints all combinations of size r
// in arr[] of size n. This function mainly uses combinationUtil()
void printCombination(int arr[], int n, int r)
{
    // A temporary array to store all combination one by one
    int data[r];

    // Print all combination using temprary array 'data[]'
    combinationUtil(arr, data, 0, n-1, 0, r);
}

/* arr[]  ---> Input Array
   data[] ---> Temporary array to store current combination
   start & end ---> Staring and Ending indexes in arr[]
   index  ---> Current index in data[]
   r ---> Size of a combination to be printed */
void combinationUtil(int arr[], int data[], int start, int end, int index, int r)
{  int i,k,l,fl=0,j;
    // Current combination is ready to be printed, print it
    if (index == r)
    {
/*        for ( j=0; j<r; j++)
            printf("%d ", data[j]);
        printf("\n");*/

        for(i=0;i<r-1;i++)
        {
            for(j=i+1;j<r;j++)

            if(conflict[data[i]][data[j]]==0)
              fl=1;
        }
        if(!fl)
            res=r;

        return;
    }

    // replace index with all possible elements. The condition
    // "end-i+1 >= r-index" makes sure that including one element
    // at index     will make a combination with remaining elements
    // at remaining positions
    for (int i=start; i<=end && end-i+1 >= r-index; i++)
    {
        data[index] = arr[i];
        combinationUtil(arr, data, i+1, end, index+1, r);
    }
}






int main()
{  int i,j,k,l,fl,max,count,index,ans;
  scanf("%d%d",&n,&m);
  vector<int>a[20002];
//  int conflict[22][22]={0};

  for(i=1;i<=m;i++)
  {
   scanf("%d",&j);
        while(j--)
        {    scanf("%d",&k);
              a[i].push_back(k);
        }

  }
//  int fl;
  // calcilating conflicts
  for(i=1;i<m;i++)
  {
      for(j=i+1;j<=m;j++)
      {       fl=0;
          for(k=0;k<a[i].size();k++)
          {
              for(l=0;l<a[j].size() && a[j][l]<=a[i][k] ;l++)
              {
                  if(a[j][l]==a[i][k])
                    {
                        fl=1;
                        conflict[i][j]=1;
                        conflict[j][i]=1;
                        break;
                    }
              }
              if(fl)
                break;
          }

      }
  }
   max=-1;ans=m;

for(i=1;i<=m;i++)
    for(j=1;j<=m;j++)
      if(i!=j)conflict[i][j]=!conflict[i][j];


/*

for(i=1;i<=m;i++)
 {

 for(j=1;j<=m;j++)
printf("%d ",conflict[i][j]);
 printf("\n");
 }


/*
while(1)
{   max=0;
    fl=1;
    for(i=1;i<=m;i++)
        {for(j=1;j<=m;j++)
           {if(conflict[i][j]==1)
            fl=0;
           }
        }

    if(fl)
    break;


      for(i=1;i<=m;i++)
    {   count=0;
        for(j=1;j<=m;j++)
        {
            if(conflict[i][j]==1)
                count++;

        }
        if(count>max)
        {
            max=count;
            index=i;
        }

    }
//printf("\n\n%d",index);
    for(i=1;i<=m;i++)
    {
       // if(conflict[index][i]==1)
            conflict[index][i]=0;
            conflict[i][index]=0;
    }




  ans--;
}*/
int arr[m+4];

for(i=0;i<m;i++)
    arr[i]=i+1;
ans=1;
for(i=2;i<=m;i++)
{
    // printCombination(arr, m, i);

     //visit[22]={0};
   // ass.push_back(i);
      for(j=0;j<22;j++)
        visit[j]=0;
         res=0;
   // res=dfs(2);

printCombination(arr, m, i);

    if(res>ans)
        ans=res;
    //ass.pop_back();
}


printf("%d\n",ans);
    return 0;
}
