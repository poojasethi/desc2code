#include <cstdio>
#include<vector>
#define pb push_back
#define pop pop_back
#define gc getchar_unlocked
#define pc putchar_unlocked
int scan(){register int n=0,c=gc();while(c<'0'||c>'9')c=gc();while(c<='9'&&c>='0')n=n*10+c-'0',c=gc();return n;}
void print(int a){char s[20];int i=0;do{s[i++]=a%10+'0',a/=10;}while(a);i--;while(i>=0)pc(s[i--]);pc('\n');}
using namespace std;
int a[21][20001],overlap[21][21],m,n,ans=0;
vector<int> V;
void dfs(int v)
{
	if(v==m+1)
		{ans=ans>V.size()?ans:V.size();
		return;}
	dfs(v+1);
	int i,flag=1;
	for(i=0;i<V.size();i++)
		if(overlap[v][V[i]]){flag=0;break;}
	if(flag)
	{
		V.pb(v);
		dfs(v+1);
		V.pop();
	}
}
int main(void) {
	int i,j,x,k;
	n=scan();m=scan();
	for(i=1;i<=m;i++)
		for(j=0,x=scan();j<x;j++)
			a[i][scan()]=1;
	//find overlap matrix
	for(i=1;i<=m;i++)
		for(j=i+1;j<=m;j++)
			for(k=1;k<=n;k++)
				if(a[i][k]&&a[j][k])
					{overlap[i][j]=overlap[j][i]=1;
					break;}
	//use dfs to find maximum number of non-overlapping sets
	dfs(1);
	print(ans);
	return 0;
}
