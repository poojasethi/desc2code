#include<stdio.h>
#include<algorithm>
#include<vector>
#include<math.h>
#include<string.h>
#include<stdlib.h>
#include<set>
#include<iostream>
using namespace std;

#define S(x) scanf("%d",&x)
#define S1(x) scanf("%lld",&x)
#define P(x) printf("%d\n",x)
#define P1(x) printf("%lld\n",x)
#define Y printf("YES\n")
#define N printf("NO\n")
#define mod 1000000007
#define ll long long
#define MAX 101
#define undef -2
#define empty -1
#define noEdge 0
#define unmatched 1
#define matched 2

struct Label {
       ll even;
       ll odd[2];
};
struct elem {
       ll vertex,type;
};

ll g[MAX][MAX];
ll bsm[MAX];
ll path[2][MAX],endPath[2];
bool match[MAX];
Label label[MAX];
elem queue[2*MAX];
ll qF,qB;
void initGraph(ll n)
{
     for (ll i=0; i<n; i++)
         for (ll j=0; j<n; j++) g[i][j]=noEdge;
}
ll readGraph(){
     ll n,e,a,b;
     S1(n);
     S1(e);
     initGraph(n);
     for (ll i=0; i<e; i++){
     S1(a);
     S1(b);
         if (a!=b)
            g[a-1][b-1]=g[b-1][a-1]=unmatched;
     }
     return n;
}
void initAlg(ll n)
{
     qF=qB=0;
     for (ll i=0; i<n; i++)
     {
         bsm[i]=i;
         label[i].even=label[i].odd[0]=label[i].odd[1]=undef;
     }
}

void btrc (ll vert, ll pathNum, ll stop, ll parity, ll direction)
{
     if (vert==stop) return;
     else if (parity==0)
     {
        if (direction==0)
        {
           btrc(label[vert].even,pathNum,stop,(parity+1)%2,0);
           path[pathNum][endPath[pathNum]++]=vert;
        }
     }
     else if (parity==1 && label[vert].odd[1]==undef)
     {
        if (direction==0)
        {
           btrc(label[vert].odd[0],pathNum,stop,(parity+1)%2,0);
           path[pathNum][endPath[pathNum]++]=vert;
        }
     }
     else if (parity==1 && label[vert].odd[1]!=undef)
     {
          if (direction==0)
          {
             btrc(label[vert].odd[0],pathNum,empty,(parity+1)%2,0);
             btrc(label[vert].odd[1],pathNum,vert,(parity+1)%2,0);
             path[pathNum][endPath[pathNum]++]=vert;
          }
     }
}

void enqueue (ll vert, ll t)
{
     elem tmp;
     tmp.vertex=vert;
     tmp.type=t;
     queue[qB++]=tmp;
}

void newBlossom (ll a, ll b)
{
     ll i,base,iB,innerBase,j,p;
     for (i=0; path[0][i]==path[1][i]; i++);
     i--;
     base=bsm[path[0][i]];

     for (j=i; j<endPath[0]; j++) bsm[path[0][j]]=base;
     for (j=i+1; j<endPath[1]; j++) bsm[path[1][j]]=base;
     for (p=0; p<2; p++)
     {
        for (j=i+1; j<endPath[p]-1; j++)
        {
            if (label[path[p][j]].even==undef)
            {

               label[path[p][j]].even=path[p][j+1];
               enqueue(path[p][j],0);
            }
            else if (label[path[p][j]].odd[0]==undef && label[path[p][j+1]].even==undef)
            {
                 label[path[p][j]].odd[0]=path[p][j+1];
                 enqueue(path[p][j],1);
            }

            else if (label[path[p][j]].odd[0]==undef && label[path[p][j+1]].even!=undef)
            {
                 iB=bsm[path[p][j]];
                 innerBase=j;
                 for (; bsm[j]==iB && j<endPath[p]-1; j++);
                 j--;
                 label[path[p][innerBase]].odd[0]=path[p][j+1];
                 label[path[p][innerBase]].odd[1]=path[p][j];
                 enqueue(path[p][innerBase],1);
            }
        }
     }
     if (g[a][b]==unmatched)
     {
        if (label[a].odd[0]==undef)
        {
           label[a].odd[0]=b;
           enqueue(a,1);
        }
        if (label[b].odd[0]==undef)
        {
           label[b].odd[0]=a;
           enqueue(b,1);
        }
     }
     else if (g[a][b]==matched)
     {
          if (label[a].even==undef)
          {
             label[a].even=b;
             enqueue(a,0);
          }
          if (label[b].even==undef)
          {
             label[b].even=a;
             enqueue(b,0);
          }
     }
}

void augmentPath ()
{
     ll a,b;
     for (ll p=0; p<2; p++)
     {
         for (ll i=0; i<endPath[p]-1; i++)
         {
             a=path[p][i];
             b=path[p][i+1];
             if (g[a][b]==unmatched)
                g[a][b]=g[b][a]=matched;
             else if (g[a][b]==matched)
                  g[a][b]=g[b][a]=unmatched;
         }
     }
     a=path[0][endPath[0]-1];
     b=path[1][endPath[1]-1];
     if (g[a][b]==unmatched) g[a][b]=g[b][a]=matched;
     else if (g[a][b]==matched) g[a][b]=g[b][a]=unmatched;
     match[path[0][0]]=match[path[1][0]]=true;
}

bool augmentMatching (ll n)
{
    ll node,nodeLabel;
    initAlg(n);
    for (ll i=0; i<n; i++) if (!match[i])
    {
         label[i].even=empty;
         enqueue(i,0);
    }
    while (qF<qB)
    {
         node=queue[qF].vertex;
         nodeLabel=queue[qF].type;
         if (nodeLabel==0)
         {
            for (ll i=0; i<n; i++) if (g[node][i]==unmatched)
            {
                if (bsm[node]==bsm[i]);

                else if (label[i].even!=undef)
                {
                     endPath[0]=endPath[1]=0;
                     btrc(node,0,empty,0,0);
                     btrc(i,1,empty,0,0);
                     if (path[0][0]==path[1][0]) newBlossom(node,i);
                     else
                     {
                          augmentPath();
                          return true;
                     }
                }
                else if (label[i].even==undef && label[i].odd[0]==undef)
                {
                     label[i].odd[0]=node;
                     enqueue(i,1);
                }
            }
        }
        else if (nodeLabel==1)
        {
            for (ll i=0; i<n; i++) if (g[node][i]==matched)
            {
                if (bsm[node]==bsm[i]);
                else if (label[i].odd[0]!=undef)
                {
                     endPath[0]=endPath[1]=0;
                     btrc(node,0,empty,1,0);
                     btrc(i,1,empty,1,0);
                     if (path[0][0]==path[1][0]) newBlossom(node,i);
                     else {
                          augmentPath();
                          return true;
                     }
                }
                else if (label[i].even==undef && label[i].odd[0]==undef)
                {
                     label[i].even=node;
                     enqueue(i,0);
                }
            }
         }
         qF++;
     }
     return false;
}

void findMaximumMatching (ll n)
{
     for (ll i=0; i<n; i++)
        match[i]=false;
     while (augmentMatching(n));
}

int main()
{
    ll n,i,t,j,m,a,b,c;
	for(S1(t);t--;)
	{
		n=readGraph();
        c=0;
        findMaximumMatching(n);
        for(i=0; i<n; i++)
            for(j=i+1; j<n; j++)
                if (g[i][j]==matched)
                    c++;
        if(c*2==n)
            Y;
        else
            N;
	}
    return 0;
}
