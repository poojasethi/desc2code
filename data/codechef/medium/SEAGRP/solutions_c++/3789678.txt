#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,Line-- Assertion failed: %sn,__LINE__,#f);exit(1);}}
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define pnl      printf(n)
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FOREACH(it,s) 	for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second
#define EPS 1e-5
#define MAXK 505
#define MOD 1000000007
typedef long long LL;
typedef unsigned long long ULL;
double start;				//time
template<typename T>inline T mod(T N,T M)
{	return (N%M+M)%M;	}

//#define tukku26
#ifdef tukku26
	#define SD(x) scanf(%d,&x);
#else
	#define SD(x) inp(x)
	#define getcx getchar_unlocked
	template<typename T>
	// generic i/p for int / long long int / unsigned long long / etc.
	inline void inp( T &n )
	{	n=0;
		int ch=getcx();
		int sign=1;
		while(ch<'0'||ch>'9')
		{	if(ch=='-')
				sign=-1;
			ch=getcx();
		}
		while(ch>='0'&&ch<='9')
		{	n=(n<<3)+(n<<1)+ch-'0';
			ch=getcx();		// n= n*10 = n*(8+2) - n<<3 + n<<2 => optimization
		}
		n *= sign;			// n = -n => bitwise
	}
#endif

namespace Num
{	
}

using namespace Num;

void pre()
{	
}


//	cin.sync_with_stdio(0);
void solve ( int &T )
{	for(int t =0; t < T; t++)
	{	int N,M;
		cin >> N >> M;
		srand(N);
		vector< vector<int> > G(N);
		for(int i =0; i < M; i++)
		{	int a,b;
			cin >> a >> b;
			srand(rand()+a);
			srand(rand()+b);
			G[--a].push_back(--b);
			G[b].push_back(a);
		}
		vector<bool> V(N,false);
		queue<int> q;
		bool ok =true;
		if ( N % 2 != 0 )			// if odd vertices means no perfect matching possible
		{	cout << "NO\n";
			continue;
		}
		// Tutte. Anything below EPS is considered as 0!! Why this occured. 34*12/17=24 but here (12/17)*34, this sort of precision losses
		for(int r =0; r < 10; r++)
			if(ok) 
			{	vector< vector<double> > T(N, vector<double>(N,0));
				for(int i =0; i < N; i++)
					for ( vector<int>::iterator it= G[i].begin(); it != G[i].end(); it++ )
						if(*it > i)
						{	int a =rand()%1000000000;
							T[i][*it] =1.0*a;
							T[*it][i] =-1.0*a;
						}
					// Gauss
				for(int i =0; i < N; i++)
				{	int x =i-1;
					for(int j =i; j < N; j++) 	// in case if a[i][i] is 0 then on divide by 0 error may occur later when changing the row. Hence, find first non-zero ele row j in the col i and swap the two
						if(abs(T[j][i]) > EPS)	// non-zero element
						{	x =j;
							break;
						}
					if(x == i-1)		// all a[i][i] -> a[j][i] are 0 and hence one of the diagonal elemnet is for sure 0 and hence the determinant is 0
					{	ok =false;	// determinant is 0
						break;
					}
					swap(T[x],T[i]);	// swap 2 rows so that T[i][i] != 0. if a[i][i] != 0 originally no effect of swapping
					// Row wise reduction with a[i][i] for each below rows
					for(int j =i+1; j < N; j++)
						if( abs(T[j][i]) > EPS )
						{	double d =T[j][i]/T[i][i];	// what we want a[j][i] - k*a[i][i]=0, so k = a[j][i]/a[i][i] and hence the operation on entire row. Now since a[i][i] is in denominator and hence a[i][i] should != 0
							for(int k =i; k < N; k++)
								T[j][k] -=d*T[i][k];			// change all row elements
						}
				}
			}
			if( ok )
				cout << "YES\n";
			else
				cout << "NO\n";
	}
}

int gaussian()
{
	int m=4,n=4;
	double l;
	double v[4][4];
	for ( int i=0; i<4; i++ )
		for ( int j=0; j<4; j++ )
			cin>>v[i][j];
	for(int i=0;i<n;i++)
	{	m=i;
		for(int j=i+1;j<n;j++)
		{
			if(fabs(v[i][j])>fabs(v[i][m]))
				m=j;
		}
		for(int k=i;k<n+1;k++)
		{
			l=v[k][i];
			v[k][i]=v[k][m];
			v[k][m]=l;
		}
		if(fabs(v[i][i]) < 0.00001f )
			return 0;	
		for(int j=i+1;j<n;j++)
		{
			for(int k=n;k>=i;k--)
			{
				v[k][j]-=v[k][i]*v[i][j]/v[i][i];
			}
		}
	}
	return 1;
}

int main()
{	pre();
	int t;
	inp(t);
	solve(t);
	return 0;
}
