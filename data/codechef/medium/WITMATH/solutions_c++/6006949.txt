#include <stdio.h>
#include <stdlib.h>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <set>
#include <vector>
#include <queue>
#include <map>
#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;
typedef long long int LLD;
LLD overflow(LLD a,LLD b,LLD c)
{
	a%=c;
	b%=c;
	long double res=a;
	res*=b;
	LLD div=LLD(res/c);
	a*=b;
	a-=div*c;
	a%=c;
	if(a<0)
	a+=c;
	return a;
	
	
}
LLD mypow(LLD a,LLD b,LLD c)
{
	LLD res=1;
	while(b>0)
	{
		if(b&1)
		{
			res=overflow(res,a,c);
		}
		b=b/2;
		if(b>0)
		{
			a=overflow(a,a,c);
		}
		
	}
	return res;
}
bool Miller_Rabin(LLD n,int iter)
{
	LLD temp,s,a,mod;
	if(n<2)
	return false;
	else if(n!=2 && !(n&1))
	return false;
	 
	s=n-1;
	int cnt=0,flag,i,j;
	 while(!(s&1)) {
        s/=2;
        cnt++;
    }
	for(i=1;i<=iter;i++)
	{
		a=rand()%(n-1)+1;//producing from 1 to n-1
		mod=mypow(a,s,n);
		if(mod==1 || mod==n-1)
		continue;
	    flag=0;	
		for(j=1;j<cnt;j++)
		{
			mod=mypow(mod,2LL,n);
			if(mod==1)
			{
				return false;
			}
		    if(mod==n-1)
			{
				flag=1;
				break;
			}
			
		}
		if(flag)
		continue;
		return false;
		
		
		
		
		
	}
	return true;
	
	
	
	
	
}
int main()
{
	int T,c;
	LLD n;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%lld",&n);
		if(n==2 || n==3)
		{
		printf("%lld\n",n);
		continue;
	    }
	    if(!(n&1))
	    n--;//getting nearest odd number that can be probably prime
	    c=0;//counter
	    while(1)
		{
			if(Miller_Rabin(n,4))
			{
				printf("%lld\n",n);
				break;
			}
			n-=2;
			c+=2;
			if(c>=1300)
			{
				c=1/0;//for detecting SIGFPE
			}
			
			
		}   
	    
	    
	    
	}
	return 0;
}