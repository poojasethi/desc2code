
#include<cstdio>
#include<set>
#include<cmath>

//#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define ll long long
#define ld long double
#define pii pair< int,int >
#define pdd pair< double,double >
#define eps 1e-9

const int inf = 0x3f3f3f3f;

int mini( int a, int b )
{
    return ( ((a) > (b)) ? (b) : (a) );
}

int maxi( int a, int b )
{
    return ( ((a) > (b)) ? (a) : (b) );
}

int readint()
{
    int n=0;
    int sign=1;
    char c=getchar_unlocked();
    //char c=getchar();
    if(c=='-')
    {
        sign=-1;
        c=getchar_unlocked();
        //c=getchar();
    }
    while(c<'0' || c>'9')
        c=getchar_unlocked();
        //c=getchar();
    while(c>='0' && c<='9')
    {
        n=(n<<3) + (n<<1) + c-'0';
        c=getchar_unlocked();
        //c=getchar();
    }
    return (sign*n);
}

using namespace std;

class comp
{
    public:
    bool operator()(const pdd &p1,const pdd &p2)
    {
        if(abs(p1.first-p2.first)<eps)
            return (p1.second<p2.second);
        return (p1.first<p2.first);
    }
};

int n,ans=4;
int x[2002],y[2002];
set< pdd,comp > st;
set< pdd,comp >::iterator it1;
set< pdd,comp >::iterator it2;

//if considered points (x1y1x2y2) form AB then after rotating AB by 90 around A and B, we find 2 new points
//let AB = (x2-x1)+i(y2-y2) .. AD = AB(cos90 + i sin90)
// D = Ax + newx,Ay + newy

int main()
{
    n=readint();

    for(int i=1;i<=n;i++)
    {
        x[i]=readint();
        y[i]=readint();
        st.insert( mp ( (double)x[i],(double)y[i] ));
    }

    if(n==0)
    {
        printf("4\n");
        return 0;
    }
    if(n==1)
    {
        printf("3\n");
        return 0;
    }
    if(n==2)
    {
        printf("2\n");
        return 0;
    }

    //for(it1=st.begin();it1!=st.end();it1++)
      //  printf("%lf %lf\n",it1->first,it1->second);

    for(int i=1;i<=n;i++)
    {
        //for(it2=it1+1;it2!=st.end();it2++)
        for(int j=i+1;j<=n;j++)
        {
            double x1,y1,x2,y2,newx,newy;

            x1=(double)x[i];
            y1=(double)y[i];
            x2=(double)x[j];
            y2=(double)y[j];

            //st.erase(mp(x1,y1));
            //st.erase(mp(x2,y2));

            int score=2;                    //anticlockwise rotation.. multiply by (cos90 + i sin90) ie by iota

            newx=x1-(y2-y1);
            newy=y1+(x2-x1);
            if(st.find(mp(newx,newy))!=st.end())
                score--;
            newx=x2-(y2-y1);
            newy=y2+(x2-x1);
            if(st.find(mp(newx,newy))!=st.end())
                score--;
            ans=mini(ans,score);

            score=2;                        //clockwise rotation.. multiply by (cos90 + i sin90) ie by -iota

            newx=x1+(y2-y1);
            newy=y1-(x2-x1);
            if(st.find(mp(newx,newy))!=st.end())
                score--;
            newx=x2+(y2-y1);
            newy=y2-(x2-x1);
            if(st.find(mp(newx,newy))!=st.end())
                score--;
            ans=mini(ans,score);


            //st.insert(mp(x1,y1));
            //st.insert(mp(x2,y2));

        }
    }

    printf("%d\n",ans);

    return 0;
}
