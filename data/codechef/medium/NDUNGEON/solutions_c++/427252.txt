#include<vector>
#include<algorithm>
#include<iostream>
#include<stdio.h>
#include<queue>
#define MAXN 10010
#define INF 987654321
using namespace std;
int A[110][110];
vector< pair<int,int> > G[MAXN];
typedef pair<int,int> ii;

int main()
{
	int r;
	int c;
	scanf("%d%d",&r,&c);
	priority_queue< pair<int,int> , vector< pair<int,int> > , greater< pair<int,int> > > q;
	ii P;
	for(int i=0;i<r;i++)
	{
		for(int j=0;j<c;j++)
			scanf("%d",&A[i][j]);
	}
	//Construct Graph
	int soux;
	int souy;
	int t;
	scanf("%d%d%d",&soux,&souy,&t);
	for(int i=0;i<r;i++)
	{
		for(int j=0;j<c;j++)
		{
			if(i-1>=0)
				G[i*c+j].push_back(ii((i-1)*c+j,A[i][j]));
			if(i+1<r)
				G[i*c+j].push_back(ii((i+1)*c+j,A[i][j]));
			if(j+1<c)
				G[i*c+j].push_back(ii((i*c+j+1),A[i][j]));
			if(j-1>=0)
				G[i*c+j].push_back(ii((i*c+j-1),A[i][j]));
		}
	}
	vector<int> D(r*c+4,INF);
	D[0]=0;
	q.push(ii(0,0));
	while(!q.empty())
	{
		ii top = q.top();
		q.pop();
		int v;
		int d;
		v=top.second;
		d=top.first;
		if(d<=D[v])
		{
			vector< pair<int,int> >::iterator it;
			for(it=G[v].begin();it!=G[v].end();it++)
			{
				int v2;
				v2=it->first;
				int cost;
				cost=it->second;
				if(D[v2] > D[v]+cost)
				{
					D[v2]=D[v]+cost;
					q.push(ii(D[v2],v2));
				}
			}
		}
	}
	if(D[(soux-1)*c+souy-1]+A[soux-1][souy-1] <=t)
		printf("YES\n%d\n",t-(D[(soux-1)*c+souy-1]+A[soux-1][souy-1]));
	else
		printf("NO\n");
	return 0;
}


