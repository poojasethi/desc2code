// draco.cpp : main project file.

//#include "stdafx.h"
#include<iostream>
#include<stdio.h>
#include<queue>
struct node
{
	int x;
	int y;
};
using namespace std;
//using namespace System;

int Min(int a,int b)
{
	if(a>b)
		return b;
	else
		return a;
}
int main()
{
	//int tests;
	//scanf("%d",&tests);
	//while(tests--)
	{
    
		int rows,cols;
		scanf("%d%d",&rows,&cols);
		int **arr=new int*[rows];
		int **adj=new int*[rows];
		int i,j,k;
		int px,py,time;
		for(i=0;i<rows;i++)
		{
			arr[i]=new int[cols];
			adj[i]=new int[cols];
			for(j=0;j<cols;j++)
				{
					scanf("%d",&arr[i][j]);
					adj[i][j]=1000000000;
			}
		}
		scanf("%d%d%d",&px,&py,&time);
		adj[0][0]=arr[0][0];
		int dimx[]={1,-1,0,0};
		int dimy[]={0,0,1,-1};
		queue<node> Q;
		node temp;
		temp.x=0;
		temp.y=0;
		Q.push(temp);

		while(!Q.empty())
		{
			node n=Q.front();
			Q.pop();
			for(i=0;i<4;i++)
			{
				int X=n.x+dimx[i];
				int Y=n.y+dimy[i];
				if(X>=0 && X<rows && Y>=0 && Y<cols && adj[X][Y]>(adj[n.x][n.y]+arr[X][Y]))
				{
					node t;
					t.x=X;
					t.y=Y;
					Q.push(t);
					adj[X][Y]=(adj[n.x][n.y]+arr[X][Y]);
				}
			}
		}
		if(adj[px-1][py-1]>time)
		{
			printf("NO\n");
		}
		else
			printf("YES\n%d\n",time-adj[px-1][py-1]);
	}
    return 0;
}
