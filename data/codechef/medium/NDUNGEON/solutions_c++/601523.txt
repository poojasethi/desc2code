#include <vector>
#include <cstdio>
#include <climits>

using namespace std;

const int MAX=70;

typedef unsigned int uint;

class ContainerIsEmpty
{
};


template <class Object>
class Heap
{
public:
    Heap() : array(MAX*MAX+1), cnt(0) {}
    void enqueue(const Object &x)
    {
        array[0] = &x;
        size_t hole = ++cnt;
        while( x < *array[hole/2])
        {
            array[hole] = array[hole/2];
            hole /= 2;
        }
        array[hole] = &x;
    }

    const Object * dequeue()
    {
        if(isEmpty())
            throw ContainerIsEmpty();

        const Object *tmp = array[1];
        array[1] = array[cnt--];
        heapDown(1);
        return tmp;
    }

    bool isEmpty()
    {
        return cnt == 0;
    }

private:
    void heapDown(uint hole)
    {
        uint child;
        const Object *tmp = array[hole];
        while ( 2 * hole <= cnt )
        {
            child = 2 * hole;
            if (child + 1 <= cnt && *array[child+1] < *array[child])
                child += 1;
            if (*array[child] < *tmp)
                array[hole] = array[child];
            else
                break;
            hole = child;
        }
        array[hole] = tmp;
    }

private:
    vector<const Object*> array;
    size_t cnt;
};

struct Edge
{
    Edge(uint _i=0, uint _j=0, uint c=0) : i(_i), j(_j), cost(c) {}
    uint i;
    uint j;
    uint cost;
};

struct Node
{
    Node(uint r=0, uint c=0, uint d=UINT_MAX) :
        row(r), col(c), distance(d), known(false) {}
    uint row;
    uint col;
    uint distance;
    bool known;
    vector <Edge> adjs;
};

bool operator < (const Node &lhs, const Node &rhs)
{
    return lhs.distance < rhs.distance;
}

int main()
{
    Node Nodes[MAX][MAX];
    uint rows, cols;
    scanf("%u%u", &rows, &cols);

    uint c;
    for(int i=0; i<rows; i++)
        for(int j=0; j<cols; j++)
        {
            scanf("%ud", &c);
            Nodes[i][j] = Node(i, j);
            if (i-1>=0)
                Nodes[i][j].adjs.push_back(Edge(i-1, j, c));
            if (i+1<rows)
                Nodes[i][j].adjs.push_back(Edge(i+1, j, c));
            if (j-1>=0)
                Nodes[i][j].adjs.push_back(Edge(i, j-1, c));
            if (j+1<cols)
                Nodes[i][j].adjs.push_back(Edge(i, j+1, c));
        }

    uint dst_row, dst_col, limit;
    scanf("%u%u%u", &dst_row, &dst_col, &limit);

    Heap<Node> pq = Heap<Node>();
    Nodes[0][0].distance = 0;
    pq.enqueue(Nodes[0][0]);
    uint nodesSeen = 0;
    uint nodesNo = rows * cols;

    while (!pq.isEmpty() && nodesSeen < nodesNo)
    {
        Node *u = (Node *)pq.dequeue();
        if (u->known)
            continue;
        u->known = true;

        vector<Edge>::iterator itr;
        for(itr = u->adjs.begin(); itr != u->adjs.end(); itr++)
        {
            Node &v = Nodes[(*itr).i][(*itr).j];
            if( u->distance + (*itr).cost < v.distance)
            {
                v.distance = u->distance + (*itr).cost;
                pq.enqueue(v);
            }
        }
        nodesSeen+=1;
    }

    Node &d = Nodes[dst_row-1][dst_col-1];
    int diff;
    if ((diff = (limit - d.distance - d.adjs[0].cost)) >= 0)
    {
        printf("YES\n");
        printf("%d\n", diff);
    }
    else
        printf("NO\n");
    return 0;
}