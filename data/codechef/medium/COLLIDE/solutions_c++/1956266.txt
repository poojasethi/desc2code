#include <cfloat>
#include <cmath>
#include <cstdio>

using namespace std;

#define maxn 2012
#define NOT_COLLIDE 300.0f
#define UP 0
#define DOWN 1
#define LEFT 2
#define RIGHT 4

int ax[maxn];
int ay[maxn];
int ad[maxn];
int x, y, d;


int get_direction(char ch) {
	int code;
	switch (ch) {
		case 'U':
			code = UP;
			break;
		case 'D':
			code = DOWN;
			break;	
		case 'L':
			code = LEFT;
			break;
		case 'R':
			code = RIGHT;
			break;	
	}
	return code;
}

float get_next_x(int x, int d, float step) {
	if (d == LEFT) return x - step;
	if (d == RIGHT) return x + step;
	return x;
}

float get_next_y(int y, int d, float step) {
	if (d == UP) return y + step;
	if (d == DOWN) return y - step;
	return y;
}

bool is_meeting_step(int k, float step) {
	if (get_next_x(x, d, step) != get_next_x(ax[k], ad[k], step))
		return false;
	if (get_next_y(y, d, step) != get_next_y(ay[k], ad[k], step))
		return false;
	return true;
}

float meeting_time(int k) {
	float dx = abs((float)(x - ax[k]));
	float dy = abs((float)(y - ay[k]));

	if (dx == 0 && dy == 0)
		return 0.0f;

	if (dx == 0) {
		float step = dy / 2.0f;
		if (is_meeting_step(k, step))
			return step;
		return NOT_COLLIDE;
	}

	if (dy == 0) {
		float step = dx / 2.0f;
		if (is_meeting_step(k, step))
			return step;
		return NOT_COLLIDE;
	}

	if (dx == dy) {
		float step = dx;
		if (is_meeting_step(k, step))
			return step;
		return NOT_COLLIDE;
	}

	return NOT_COLLIDE;
}

int main() {
	int t, n;
	char dir[2];
	scanf("%d", &t);
	for (int k = 0; k < t; k++) {
		scanf("%d %d %s", &x, &y, dir);
		d = get_direction(dir[0]);
		scanf("%d", &n);
		for (int i = 0; i < n; i++) {
			scanf("%d %d %s", ax + i, ay + i, dir);
			ad[i] = get_direction(dir[0]);
		}
		float min_time = NOT_COLLIDE;
		for (int i = 0; i < n; i++) {
			float tmp = meeting_time(i);
			if (tmp < min_time)
				min_time =  tmp;
		}
		if (min_time != NOT_COLLIDE)
			printf("%.1f\n", min_time);
		else
			printf("SAFE\n");
	}
	return 0;
}
