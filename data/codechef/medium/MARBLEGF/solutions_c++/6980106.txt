#include <iostream>
using namespace std;


#define ll long long int
ll getSum(ll BITree[], int n, int index)
{
    ll sum = 0; // Iniialize result

    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse ancestors of BITree[index]
    while (index>0)
    {
        // Add current element of BITree to sum
        sum += BITree[index];

        // Move index to parent node
        index -= index & (-index);
    }
    return sum;
}

// Updates a node in Binary Index Tree (BITree) at given index
// in BITree.  The given value 'val' is added to BITree[i] and
// all of its ancestors in tree.
void updateBIT(ll *BITree, int n, int index, int val)
{
    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse all ancestors and add 'val'
    while (index <= n)
    {
       // Add 'val' to current node of BI Tree
       BITree[index] += val;

       // Update index to that of parent
       index += index & (-index);
    }
}

// Constructs and returns a Binary Indexed Tree for given
// array of size n.
ll *constructBITree(int arr[], int n)
{
    // Create and initialize BITree[] as 0
    ll *BITree = new ll[n+1];
    for (int i=1; i<=n; i++)
        BITree[i] = 0;

    // Store the actual values in BITree[] using update()
    for (int i=0; i<n; i++)
        updateBIT(BITree, n, i, arr[i]);

    // Uncomment below lines to see contents of BITree[]
    //for (int i=1; i<=n; i++)
    //      cout << BITree[i] << " ";

    return BITree;
}

int a[1000001] ;
// Driver program to test above functions
int main()
{
    int i,j,k,n,t,p,q ;
    cin >> n >> q ;

    char c ;
    int index ;
    int number ;

    for(i=0;i<n;i++) cin >> a[i] ;

    ll *BITree = constructBITree(a, n);
    for(i=0;i<q;i++) {
        cin >> c ;
        cin >> index ;
        cin >> number ;
        if(c == 'S') {
           // cout << getSum(BITree, n, number) << " "  << getSum(BITree, n, index) << " " << a[index] << endl ;
            cout << getSum(BITree, n, number) - getSum(BITree, n, index) + a[index] << endl ;
        }
        else if(c == 'G') {
            a[index] += number ;
            updateBIT(BITree, n, index, number);
        }
        else {
            a[index] -= number ;
            updateBIT(BITree, n, index, -number);
        }
    }

    return 0;
}
