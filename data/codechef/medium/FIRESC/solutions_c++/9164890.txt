#include <bits/stdc++.h>
#define MAX 100000
#define M 1000000007
using namespace std;

struct subset
{
    int parent;
    int rank;
};

int find(subset s[], int i)
{
    // find root and make root as parent of i (path compression)
    //if(s[i].parent != i)
    //    s[i].parent = find(s, s[i].parent);
    while(s[i].parent != i)
        i = s[i].parent;
    return s[i].parent;
}

int union_xy(subset s[], int x, int y)
{
    int root_x = find(s, x);
    int root_y = find(s, y);

    if(root_x == root_y) return 0;

    // Attach smaller rank tree under root of high rank tree
    // (Union by Rank)
    // rank is used as the degree of subset(no. of elements in the subset)
    if(s[root_x].rank < s[root_y].rank) {
        s[root_x].parent = root_y;
        s[root_y].rank += s[root_x].rank;
    }
    else if(s[root_x].rank >= s[root_y].rank) {
        s[root_y].parent = root_x;
        s[root_x].rank += s[root_y].rank;
    }
    return 1;
}

void init(subset s[], int n)
{
    for(int i = 1; i<=n; ++i) {
        s[i].parent = i;
        s[i].rank = 1;
    }
}

int main()
{
    std :: ios :: sync_with_stdio(false);
    //freopen("in.txt", "r", stdin);
    int t;
    cin >> t;
    while(t--) {
        long long n, m, c, x, y, p = 1;
        cin >> n >> m;
        subset s[n + 1];
        init(s, n);
        c = n;
        while(m--) {
            cin >> x >> y;
            if(union_xy(s, x, y))
                c--;
        }
        for(int i = 1; i<=n; ++i) {
            if(s[i].parent == i)
                p = (p%M * (s[i].rank)%M)%M;
        }
        cout << c << " " << p << endl;
    }
    return 0;
}
