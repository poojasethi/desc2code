//program RECTCNT

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>

using namespace std;

struct Point
{
  int X,Y;
};

bool operator <(Point A,Point B)
{
  return (A.X==B.X)?(A.Y<B.Y):(A.X<B.X);
}

struct HashType
{
  long long X;
  int Count;
  HashType *Next;
};

int Get()
{
  char c;
  while(c=getchar(),(c!='-')&&(c<'0'||c>'9'));
  bool Flag=(c=='-');
  if(Flag)
    c=getchar();
  int X=0;
  while(c>='0'&&c<='9')
    {
      X=X*10+c-48;
      c=getchar();
    }
  return Flag?-X:X;
}

const int BigNumber=999991;

HashType *Hash[BigNumber];
int Time[BigNumber];

void Add(int Current,long long X)
{
  int V=X%BigNumber;
  if(Time[V]!=Current)
    {
      Hash[V]=NULL;
      Time[V]=Current;
    }
  HashType *P=Hash[V];
  while(P!=NULL)
    {
      if(P->X==X)
        {
          P->Count++;
          return;
        }
      P=P->Next;
    }
  P=new HashType;
  P->X=X;
  P->Count=1;
  P->Next=Hash[V];
  Hash[V]=P;
}

int Find(int Current,long long X)
{
  int V=X%BigNumber;
  if(Time[V]!=Current)
    {
      Hash[V]=NULL;
      Time[V]=Current;
      return 0;
    }
  HashType *P=Hash[V];
  while(P!=NULL)
    {
      if(P->X==X)
        return P->Count;
      P=P->Next;
    }
  return 0;
}

int main()
{
  int N,Current=0;
  memset(Time,0,sizeof(Time));
  while(N=Get())
    {
      static Point P[100000];
      for(int i=0;i<N;i++)
        {
          P[i].X=Get();
          P[i].Y=Get()+1000000000;
        }
      sort(P,P+N);
      static int Data[100000];
      int M=0;
      for(int i=0;i<N;i++)
        if(!i||P[i].X!=P[i-1].X)
          Data[M++]=P[i].X;
      static vector<int> A[100000];
      for(int i=0;i<M;i++)
        A[i].clear();
      for(int i=0,j=0;i<N;i++)
        {
         if(P[i].X!=Data[j])
           j++;
         A[j].push_back(P[i].Y);
        }
      int Mid=(int)sqrt(N);
      long long Ans=0;
      for(int i=0;i<M;i++)
        if(A[i].size()>=Mid)
          {
            Current++;
            for(int j=0;j<A[i].size();j++)
              Add(Current,A[i][j]);
            for(int j=0;j<M;j++)
              {
                if(A[j].size()>=Mid&&j<=i)
                  continue;
                int Count=0;
                for(int k=0;k<A[j].size();k++)
                  Count+=Find(Current,A[j][k]);
                Ans+=(long long)Count*(Count-1)/2;
              }
          }
      Current++;
      for(int i=0;i<M;i++)
        if(A[i].size()<Mid)
          for(int j=0;j<A[i].size();j++)
            for(int k=j+1;k<A[i].size();k++)
              {
                long long Mask=A[i][j]*2000000001LL+A[i][k];
                Ans+=Find(Current,Mask);
                Add(Current,Mask);
              }
      cout<<Ans<<endl;
    }
  return 0;
}
