//Final Solution (Does not fail even when test cases include vertical line or when optimum location lies outside of maximum range of abcissa or ordinate. Current test cases do not check these cases. :()
//Plan First of all note that optimum always exists and hence we never need to print "NO". Also sum of distances is a unimodal function hence can apply ternary search
//Divide into two cases
//Case A: Line ax+by+c =0 and b =0 ie line is vertical, x=constant; Here apply ternary search on only y direction to find optimum y
//Case B: Line ax+by+c = 0 and b not equal to 0. Here can apply ternary search along the line while dealing with moving x cordinate and finding corresponding y coordinate at each
//step

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

const int maxN = 5000;
const double oo = 1e9;//will act as our infinty
const double e = 1e-8;//max accuracy acheived(note that it should be less than 1e-7 to be accurate upto 6 decimal places)

//some global variables

int N;//number of warehouses
double xmax, xmin, ymax, ymin;//store extremes of foots of perpendiculars(will be our search range)
int a, b, c;//equation of line is ax+by+c =0

int xcor[maxN];//stores x coordinates of warehouses
int ycor[maxN];//stores y coordinates of warehouses


//some helper functions
int sqr(int x){return x*x;}
double min(double a, double b){return a<b?a:b;}
double max(double a, double b){return a>b?a:b;}
double gety(double x)
{
   double y = -c - a*x;
    y/= b;
    return y;
}
double dist(int x1, int y1, double x2, double y2)//distance between two points
{
 double tmp1 = x1 - x2;
 double tmp2 = y1- y2;
 return sqrt(tmp1*tmp1 + tmp2*tmp2);
}
double total_distance(double x, double y)//sum of distances to all warehouses
{
    double sum = 0;
    for(int i=0; i<N; i++)
    sum+= dist(xcor[i], ycor[i], x, y);
    return sum;
}


//when we have a vertical line i.e. b = 0
double yternary()
{
    double res = oo;
    double low = ymin;
    double hi = ymax;
    double m1, m2, d1, d2;


    if(hi - low < e)
    return total_distance(xmin, low);

    while(hi- low >= e )
    {
        m1 = (hi - low)/3;
        m2 = hi- m1;
        m1+= low;
        d1 = total_distance(xmin, m1);
        d2 = total_distance(xmin, m2);
        if(d1<= d2 + e)
        {
            hi = m2;
            if(d1<res - e)res = d1;
        }
        else
        {
            low = m1;
            if(d2<res - e)res = d2;
        }
    }
    return res;

}

//when b is not zero ie line not vertical
double ternary()
{
    double res = oo;
    double m1, m2, d1, d2;
    double low = xmin;
    double hi = xmax;
    if(hi- low < e)
    return total_distance(xmin, gety(xmin));

    while(hi - low>=e)
    {
        m1 = (hi - low)/3;
        m2 = hi - m1;
        m1+= low;
        d1 = total_distance(m1, gety(m1));
        d2 = total_distance(m2, gety(m2));
        if(d1<= d2 + e)
        {
            hi = m2;
            if(d1<res - e)res = d1;
        }
        else
        {
            low = m1;
            if(d2<res -e)res = d2;
        }
    }
    return res;

}
//Main program
int main()
{
    int t;//number of test cases
    int x, y;//for coordinates of warehouses
    double xp, yp;//for foot of perpendiculars
    scanf("%d", &t);
    while(t--)
    {
        xmax = -oo;
        xmin = oo;
        ymax = -oo;
        ymin = oo;

        scanf("%d", &N);
        scanf("%d%d%d", &a, &b, &c);
        for(int i=0; i<N; i++)
        {
            scanf("%d%d", &x, &y);
            xp = x-(double)a*(a*x + b*y + c)/(sqr(a) + sqr(b));//using well known formula to find foot of perpendiculars
            yp = y-(double)b*(a*x + b*y + c)/(sqr(a) + sqr(b));
            
            xmin = min(xp, xmin);
            xmax = max(xp, xmax);
            ymin = min(yp, ymin);
            ymax = max(yp, ymax);
            
            xcor[i] = x;
            ycor[i] = y;
           }

         if(b == 0)printf("%.6lf\n", yternary());//vertical line
         else printf("%.6lf\n", ternary());//not vertical line
         
         //All Done :D

    }

}
