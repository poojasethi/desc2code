#include <cstdio>
#include <vector>
#include <algorithm>
#include <cctype>

using namespace std;

const int MAX_CITY = 10001;
struct Data
{
    Data() : dtime(-1), city(-1), atime(-1), used(false) {}
    Data(int d, int c, int a) : 
        dtime(d), city(c), atime(a), used(false) {}
    int dtime;
    int city;
    int atime;
    bool used;
};

bool operator < (const Data &left, const Data &right)
{
    return left.dtime < right.dtime;
}

bool lessthan (Data *left, Data *right)
{
    return left->dtime < right->dtime;
}

vector<Data *> city[MAX_CITY];
Data flight[MAX_CITY];

const int BUFSIZE = 8192;
char r_buffer[BUFSIZE];
int r_bufpos = BUFSIZE;
 
int read_int()
{
    int n;
    bool sign=true;

    sign = 1;
    for (; r_bufpos < BUFSIZE && !isdigit(r_buffer[r_bufpos]) &&
            r_buffer[r_bufpos]!='-'; r_bufpos++);
    if (r_buffer[r_bufpos] == '-')
    {
        sign = false;
        r_bufpos += 1;
    }

    if (r_bufpos == BUFSIZE)
    {
        r_bufpos = 0;
        fread(r_buffer, 1, BUFSIZE, stdin);
        for (; r_bufpos < BUFSIZE && !isdigit(r_buffer[r_bufpos]) &&
                r_buffer[r_bufpos]!='-'; r_bufpos++);
        if (r_buffer[r_bufpos] == '-')
        {
            sign = false;
            r_bufpos += 1;
        }
    }

    n = 0;
    for (; r_bufpos < BUFSIZE && isdigit(r_buffer[r_bufpos]); r_bufpos++)
        n = 10 * n + r_buffer[r_bufpos] - '0';

    if (r_bufpos == BUFSIZE)
    {
        r_bufpos = 0;
        fread(r_buffer, 1, BUFSIZE, stdin);
        for (; r_bufpos < BUFSIZE && isdigit(r_buffer[r_bufpos]); r_bufpos++)
            n = 10 * n + r_buffer[r_bufpos] - '0';
    }
    return sign? n: -n;
}

Data *get_next_data(int scity, int t)
{
    if (t > city[scity].back()->dtime)
        return NULL;
    else if (t <= city[scity].front()->dtime)
        return city[scity][0];
    else
    {
        int left = 0;
        int right = city[scity].size()-1;
        while (left < right)
        {
            int m = (left + right) / 2;
            if (t <= city[scity][m]->dtime)
                right = m;
            else
                left = m + 1;
        }
        return city[scity][left];
    }
}

int main()
{
    int T, C1, T1, C2, T2, N;
    int src_city, src_time, dst_city, dst_time; 

    
    T = read_int();
    for(; T>0; T--)
    {
        for(int i=0; i<MAX_CITY; i++)
            city[i].clear();

        N = read_int();
        for(int i = 0; i < N; i++)
        {
            C1 = read_int();
            T1 = read_int();
            C2 = read_int();
            T2 = read_int();
            flight[i].dtime = T1;
            flight[i].city = C2;
            flight[i].atime = T2;
            flight[i].used = false;
            city[C1].push_back(&flight[i]);
        }
      
        for(int i = 0; i < MAX_CITY; i++)
            sort(city[i].begin(), city[i].end(), lessthan);

        src_city = read_int();
        src_time = read_int();
        dst_city = read_int();
        dst_time = read_int();

        if (src_city == dst_city && src_time <= dst_time)
            printf("Yes 0\n");
        else
        {
            Data *n;
            int cnt=1;
            while(true)
            {
                if( city[src_city].size() == 0 
                    || !(n = get_next_data(src_city, src_time)) 
                    || n->used )
                {
                    printf("No\n");
                    break;
                }
           
                if (n->city == dst_city && n->atime <= dst_time)
                {
                    printf("Yes %d\n", cnt);
                    break;
                }
                n->used = true;    
                src_city = n->city;
                src_time = n->atime;
                cnt += 1;
            }
        }
    }
    return 0;
}
