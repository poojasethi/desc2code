#
// Palindromic Bases
#
// Source: CodeChef December 2009 Algorithm Challenge
#
// CodeChef ID: K2
#
 
#
#include <algorithm>
#
#include <bitset>
#
#include <cassert>
#
#include <cctype>
#
#include <cmath>
#
#include <cstdio>
#
#include <cstdlib>
#
#include <cstring>
#
#include <ctime>
#
#include <deque>
#
#include <functional>
#
#include <iomanip>
#
#include <iostream>
#
#include <list>
#
#include <map>
#
#include <numeric>
#
#include <queue>
#
#include <set>
#
#include <sstream>
#
#include <stack>
#
#include <string>
#
#include <utility>
#
#include <vector>
#
using namespace std;
#
 
#
typedef long long LL;
#
 
#
bool ispalin(LL n, LL b) {
#
if (b==1) return 0;
#
vector<LL> x;
#
//printf("N: %lld, B: %lld\n", n,b);
#
do { x.push_back(n%b); n/=b; } while (n);
#
for (int i=0;i<x.size()-1-i;++i) {
#
if (x[i]!=x[x.size()-1-i])
#
return 0;
#
}
#
return 1;
#
}
#
 
#
LL naive(LL n) {
#
for (int i=2;i<=n+1;++i) {
#
if (ispalin(n,i)) return i;
#
}
#
cerr << "N " << n << endl;
#
assert(0);
#
}
#
 
#
const int MAX=100001;
#
LL pw[MAX];
#
vector<LL> primes;
#
//bool isprime[MAX];
#
 
#
LL solve(LL n) {
#
if (n==1) return 2;
#
if (n==2) return 3;
#
 
#
for (LL i=2;i*i<=n;++i) {
#
while (n >= pw[i]*i)
#
pw[i] *= i;
#
if ((n / pw[i]) != (n % i)) // fail on first digit
#
continue;
#
bool ok = 1;
#
LL hi = pw[i]/i,lo=i;
#
while (lo < hi) {
#
if (( n/hi)%i != (n/lo)%i) {
#
ok = 0;
#
break;
#
}
#
hi /= i;
#
lo *= i;
#
}
#
if (ok) return i;
#
}
#
 
#
/*
#
for (int i=0;i<primes.size() && primes[i]*primes[i] <= n;++i) {
#
while (x % primes[i] == 0) {
#
x /= primes[i];
#
}
#
}
#
if (x >= 3) {
#
printf("X-1: %lld\n", x-1);
#  
#
if (ispalin(n, x-1))
#
return x-1;
#
#
}
#
*/
#
 
#
LL minb = n-1;
#
for (LL i=2;i*i<=n;++i) if (n%i==0) {
#
if (ispalin(n,(n/i)-1)) {
#
minb = min(minb, (n/i)-1);
#
}
#
}
#
return minb;
#
}
#
 
#
void test() {
#
for (int i=1;i<=1000000;++i) {
#
//printf("%d\n", i);
#
//printf("NAIVE %lld\n", naive(i));
#
//printf("SOLVE %lld\n", solve(i));
#
if (i%1000 == 0) printf("%d\n", i);
#
if (naive(i) != solve(i)) {
#
cerr << " FAIL ON I " << i << endl;
#
assert(0);
#
break;
#
}
#
}
#
}
#
 
#
int main() {
#
/*
#
for (int i=0;i<MAX;++i) isprime[i] = 1;
#
isprime[0] = isprime[1] = 0;
#
for (int i=2;i<MAX;++i) if (isprime[i]) {
#
primes.push_back(i);
#
for (int j=2;i*j<MAX;++j) isprime[i*j] = 0;
#
}
#
*/
#
for (int i=0;i<MAX;++i) pw[i]=1;
#
 
#
//test();
#
 
#
int ncases;
#
scanf("%d", &ncases);
#
vector<pair<LL,int> > input(ncases);
#
for (int z=0;z<ncases;++z) {
#
scanf("%lld", &input[z].first);
#
input[z].second = z;
#
}
#
sort(input.begin(),input.end());
#
vector<LL> sols(ncases);
#
for (int i=0;i<input.size();++i) {
#
LL ret = solve(input[i].first);
#
sols[input[i].second] = ret;
#
//printf("SOLVE %lld to %lld, NAIVE: %lld\n", input[i].first, sols[input[i].second], naive(input[i].first));
#
//assert(naive(input[i].first)==ret);
#
}
#
 
#
for (int i=0;i<sols.size();++i) printf("%lld\n", sols[i]);
#
}