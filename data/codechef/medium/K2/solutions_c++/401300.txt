#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <sys/time.h>
#include <stdio.h>
#include <string.h>

using namespace std;

typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long LL;
typedef unsigned long long ULL;
typedef unsigned char BYTE;

#define FOR(i, n) for (int i = 0; i < (n); ++i)
#define FORU(i, s, e) for (int i = (s); i <= (e); ++i)
#define FORD(i, s, e) for (int i = (s); i >= (e); --i)
#define ALL(x) (x).begin(),(x).end()
#define FOREACH(i, v) for(__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++i)
#define SIZE(x) ((int)(x).size())
#define MP make_pair
#define BIT(x, b) (((x) >> (b)) & 1)
#define DEBUG(x) cerr << #x << " = " << x << " at line " << __LINE__ << endl;
#define INF 1000000000
#define MAX_TIME 5
#define TIME_LEFT_UNTIL(end) ((curTime=getTime()-startTime) < (end))
#define TIME_LEFT() TIME_LEFT_UNTIL(MAX_TIME)
#define INIT_TIME() startTime = getTime();
//#define cerr while (0) cerr

double startTime, curTime;

inline double getTime () {
  timeval tv;
  gettimeofday(&tv, 0);
  return tv.tv_sec + tv.tv_usec * 1e-6;
}

int main () {
  int cases;
  scanf("%d", &cases);
  while (cases--) {
    LL x;
    scanf("%lld", &x);
    if (x <= 2) {
      printf("%d\n", x+1);
      continue;
    }
    LL out = x-1;
    LL i;
    for (i = 2; i*i < x; ++i) {
      LL r = 0, t = x;
	  /**
		Just another way of checking a number to be pallindromic in base i.
	  */
      while (t) {
        r = r * i + t % i;
        t /= i;
      }
	  if (r == x) {
        out = i;
        break;
      }
    }
	/** Multiples of strictly non-pallindromic numbers n.
		11, 22, 33 ... all represent multiples of the number n in base n-1.
		
		If i(i+1) == x then x in base i = 110 which is non-pallindromic.
		If i(i+1) > x then x/i <= i or
			1)	x/i == i then x in base i = 100 (NP)
			2)	x/i <= i-1 then x in base i = (i-a)b (NP) a>0 and b = x%i
				a and b are not equal to i/2 simultaneously since then we have a contradiction (i/2 i/2) in base i is x/2.
	 */
    if (out == x-1)		
      for (i = 2; i*(i+1) < x; ++i)
        if (x % i == 0) {
          out = x / i - 1;
        }
    printf("%lld\n", out);
  }
  return 0;
}
