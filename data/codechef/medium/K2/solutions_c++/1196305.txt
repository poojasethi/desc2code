#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <utility>
#include <stack>
#include <deque>
#include <queue>
#include <fstream>
#include <sstream>

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cassert>

using namespace std;

typedef long long int ill;

bool is_palindrome(const string& s) {
	int half = s.length() / 2;
	for (int i = 0, j = s.length() - 1; i < half; ++i, --j) {
		if (s[i] != s[j]) {
			return 0;
		}
	}

	return 1;
}

template <typename T>
string to_string(T data) {
	ostringstream oss;
	oss << data;
	return oss.str();
}

string convert_to_base(unsigned long long n, int b) {
	string result;
	while (n) {
		result.append(to_string(n % b));
		n /= b;
	}

	return result;
}

vector<int> extract_digits(ill b, ill n) {
	vector<int> digits;
	// extract digits
	while (n) {
		digits.push_back(n % b);
		n /= b;
	}

	return digits;
}

bool is_palindromic_base(ill b, ill n) {
	vector<int> digits = extract_digits(b, n);
	int end = digits.size();
	// check for palindromic of base b
	for (int i = 0, j = end - 1; i < j; ++i, --j) {
		if (digits[i] != digits[j]) {
			return false;
		}
	}

	return true;
}
/*
	For any N, we have 
		N = a_{n-1}*b^{n-1} + a_{n-2}*b^{n-2} + a_{n-3}*b^{n-3} + ..................a_1b^1 + a_0
	Note that the base of a number must be at most n - 1
	because if b >= n then b^1 is also >= n which doesn't make sense in this case because
	we have more than 3 digits.
*/
ill get_smallest_base_with_more_than_3_digits(ill n) {
	for (ill b = 2; b*b*b < n; ++b) {
		if (is_palindromic_base(b, n)) {
			return b;
		}
	}

	return n - 1;
}

ill get_smallest_base_with_exactly_3_digits(ill n) {
	ill b = 2;
	while (b*b*b <= n) {
		b++;
	}

	ill temp;
	ill left;
	ill right;
	ill middle;

	for (; b*b < n; ++b) {
		temp = n;

		left = temp % b; 
		temp /= b;

		middle = temp % b;
		temp /= b;

		right = temp;
		if (left == right) {
			return b;
		}
	}

	return n - 1;
}

ill get_smallest_base_last(ill n) {
	ill b = n - 1;
	for (ill i = 2; i*i < n; ++i) {
		if (n % i == 0 && i + 1 < n/i) {
			b = min(b, (n/i) - 1);
		}
	}

	return b;
}

ill get_smallest_palandromic_base(ill n) {
	if (n <= 3) {
		return 2;
	}

	ill b;
	b = get_smallest_base_with_more_than_3_digits(n);
	if (b == n - 1) {
		b = get_smallest_base_with_exactly_3_digits(n);
		if (b == n - 1) {
			return get_smallest_base_last(n);	
		}
		else {
			return b;
		}
	}
	else {
		return b;
	}
}

void inout_palindromic_number() {
	int test_cases;
	scanf("%d", &test_cases);
	
	ill n;
	int base;
	while (test_cases--) {
		scanf("%lld", &n);
		printf("%lld\n", get_smallest_palandromic_base(n));
	}
}

int main() {
	inout_palindromic_number();
	return 0;
}
