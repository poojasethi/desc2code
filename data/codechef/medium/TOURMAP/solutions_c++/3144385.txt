#include<iostream>
#include<sstream>
#include<fstream>
#include<iomanip>
#include<string>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<algorithm>
#include<utility>
#include<limits>
#include<stdexcept>
#include<numeric>
#include<iterator>
#define pb push_back
#define mp make_pair
#define iter(container,it) typeof(container.begin()) it
#define all(x) x.begin(),x.end()
#define fastin std::ios::sync_with_stdio(false)
#define cout_precision(x) cout<<std::fixed<<setprecision(x)
using namespace std;
#ifndef ONLINE_JUDGE
#include <debug.h>
#include <binary_tree.h>
#include <bignum.h>
#endif
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<cassert>
#include<cctype>
#define SET(p) memset(p,-1,sizeof(p))
#define CLR(p) memset(p,0,sizeof(p))
#define S(n) scanf("%d",&n)
#define P(n) printf("%d\n",n)
template<typename T>
class hash_table
{
    typedef pair<string,T> node;
    static const int ht_size=1000000;
    typedef typename list<node>::iterator nodeiter;
    nodeiter it;
    vector<list<node> > ht;
    vector<int> filled;
    unsigned int generate_hash(const string& key)
    {
        unsigned long long ans=0,j=1;
        for(int i=0; i<(int)key.length(); i++)
        {
            ans+=((key[i]-'a')*j)%ht_size;
            j<<=1;
        }
        return ans%ht_size;
    }
public:
    hash_table()
    {
        ht.resize(ht_size);
    }
    void clearall()
    {
        for(int i=0; i<(int)filled.size(); i++)
        {
            ht[filled[i]].clear();
        }
        filled.clear();
    }
    node* find(const string& key)
    {
        int h=generate_hash(key);
        for(it=ht[h].begin(); it!=ht[h].end(); ++it)
        {
            if((*it).first==key)
                return &(*it);
        }
        return NULL;
    }
    void insert(const node& key)
    {
        //if(find(key.first)!=NULL)
        //return ;
        int h=generate_hash(key.first);
        ht[h].pb(key);
        filled.pb(h);
    }
    void show()
    {
        vector<nodeiter> iterlist(ht_size);
        int i;
        for(i=0; i<ht_size; i++)
        {
            iterlist[i]=ht[i].begin();
        }
        for(i=0; i<(int)filled.size(); i++)
        {
            if(iterlist[filled[i]]!=ht[filled[i]].end())
            {
                cout<<"ht["<<filled[i]<<"] = "<<*(iterlist[filled[i]]);
                iterlist[filled[i]]++;
            }
        }
    }
};
typedef pair<string,pair<string,int> > node;
inline node filter(string s)
{
    string first,second;
    int money;
    stringstream ss(s);
    ss>>first>>second>>money;
    return mp(first,mp(second,money));
}
int main()
{
    fastin;
    int t,i,size,money,tot;
    cin>>t;
    string first,second;
    vector<pair<string,pair<string,int> > > n(6000);
    hash_table<pair<string,int> > h1,h2;
    while(t--)
    {
        cin>>size;
        cin.ignore();
        tot=0;
        for(i=0; i<size-1; i++)
        {
            getline(cin,first);
            n[i]=filter(first);
            first=n[i].first;
            second=n[i].second.first;
            money=n[i].second.second;
            tot+=money;
            h1.insert(mp(first,mp(second,money)));
            h2.insert(mp(second,mp(first,money)));
        }
        //h1.show();
        //h2.show();
        for(i=0; i<size-1; i++)
        {
            if(h2.find(n[i].first)==NULL)
            {
                node *p=&n[i];
                i=0;
                while(p!=NULL)
                {
                    n[i++]=*p;
                    p=h1.find((*p).second.first);
                }
                break;
            }
        }
        for(i=0; i<size-1; i++)
        {
            //cout<<n[i];
            cout<<n[i].first<<" "<<n[i].second.first<<" "<<n[i].second.second<<"$\n";
        }
        cout<<tot<<"$\n";
        h1.clearall();
        h2.clearall();
    }
}
