#include <iostream>
#include <vector>
#include <string>
#include <cstdio>
#include <algorithm>
#include <climits>
#include <utility>
#include <fstream>
#include <map>
#include <cmath>
#include <functional>
#include <exception>
#include <stdexcept>
#include <sstream>
#include <cassert>
#include <memory>
#include <limits>
#include <deque>
#include <queue>
#include <limits>
#include <climits>
#include <string>
#include <cstring>
#include <iomanip>
#include <stack>

#include <tr1/unordered_map>
using namespace std::tr1;

static const int oo = 99999999;

class graph {
	static const int MAX_NO_VERTEX = 5001;

private:
	int no_vertex;
	std::vector<std::vector<int> > adj;
	std::vector<std::vector<int> > cost;

	int count;
	unordered_map<std::string, int> name_map;
	unordered_map<int, std::string> vertex_map;
	bool in_deg[MAX_NO_VERTEX];

public:
	graph(int no_vertex) :
			no_vertex(no_vertex),
			adj(no_vertex),
			cost(no_vertex, std::vector<int>(no_vertex, oo)),
			count(0) {
		memset(in_deg, 0, sizeof(bool) * MAX_NO_VERTEX);
	}

	void dfs(int u) {
		int v;
		int total = 0;
		while (1) {
			if (adj[u].size() == 0) {
				break;
			}
			v = u;
			std::cout << vertex_map[u] << " ";
			u = adj[u][0];
			std::cout << vertex_map[u] << " ";
			total += cost[v][u];
			std::cout << cost[v][u] << "$\n";
		}
		std::cout << total << "$\n";
	}

	/**
	 * The only vertex that does not have
	 * any edge going in is the start
	 * Eg:
	 * 		A->B->C->D
	 */
	int get_start() const {
		for (int v = 0; v < no_vertex; ++v) {
			if (in_deg[v] == false) {
				return v;
			}
		}
		return -1;
	}

	void add_edge(const std::string &from, const std::string &to, int cost) {
		int u = try_get_city(from);
		int v = try_get_city(to);
		add_edge(u, v, cost);
	}

private:
	int try_get_city(const std::string &city) {
		unordered_map<std::string, int>::iterator iter = name_map.find(city);
		if (iter != name_map.end()) {
			return iter->second;
		} else {
			int temp = count;
			name_map.insert(std::make_pair(city, count));
			vertex_map.insert(std::make_pair(count, city));
			count++;
			return temp;
		}
	}

	void add_edge(int u, int v, int w) {
		adj[u].push_back(v);
		// add edge u->v, so v has some edge going in
		in_deg[v] = true;
		cost[u][v] = w;
	}
};

void test_graph() {
	graph g(5);
	g.add_edge("Warsaw", "Kiev", 120);
	g.add_edge("Madrid", "Paris", 100);
	g.add_edge("Munich", "Warsaw", 150);
	g.add_edge("Paris", "Munich", 200);
	int u = g.get_start();
	g.dfs(u);
}

int dollar_to_int(const std::string &n) {
	int num(0);
	// ignore $ sign
	int len = n.size() - 2;
	for (int i = 0; i <= len; ++i) {
		num = (num << 3) + (num << 1) + (n[i] - '0');
	}
	return num;
}

void solve() {
	int no_vertex;
	std::cin >> no_vertex;
	graph g(no_vertex);
	std::string u;
	std::string v;
	std::string cost;
	for (int i = 0; i < no_vertex - 1; ++i) {
		std::cin >> u >> v >> cost;
		g.add_edge(u, v, dollar_to_int(cost));
	}
	g.dfs(g.get_start());
}

void test_to_int() {
	std::string s = "1500$";
	std::cout << dollar_to_int(s) << '\n';
}


void inout_sridhar_likes_travelling() {
	int tc;
	std::cin >> tc;
	while (tc--) {
		solve();
	}
}

int main() {
	inout_sridhar_likes_travelling();
	return 0;
}
