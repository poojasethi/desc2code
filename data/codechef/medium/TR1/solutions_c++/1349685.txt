#include <iostream>
#include <list>
#include <cstdio>
#include <cstring>
using namespace std;

#define P 1000000007
typedef long long int int64;

void push_all (int r, list<int>* edges,list<int>& pile, bool* in_pile) {
  pile.push_front (r);
  in_pile[r] = true;
  list<int>::iterator it;
  for (it = edges[r].begin (); it != edges[r].end ();++it){
    if (!in_pile[*it]){
	push_all (*it, edges, pile, in_pile);
      }
  }
}


int64 solve () {
  int n; scanf("%d",&n);
  list<int>* edges = new list<int> [n];
  //lecture des données  
  int u,v;
  for (int j=1;j<n;j++){
    scanf("%d%d",&u,&v);
    edges[u-1].push_front (v-1);
    edges[v-1].push_front (u-1);
  }
  //on met tous les sommets dans une LIFO en commençant par la racine
  bool in_pile [n];
  memset(in_pile,0,sizeof(bool)*n);
  //for (int i = 0; i<n; i++){in_pile[i] = false;}
  list<int> pile;
  push_all (0,edges,pile,in_pile);
  //on ressort tous les sommets un par un (on commence donc par les feuilles 
  int64 res = 0;
  int64 size [n];
  int64 size_square [n];
  int64 s1,s2;
  for (int i=0; i < n; i++){
    u = pile.front ();
    pile.pop_front ();
    list<int>::iterator it;
    in_pile[u] = false;
    s1 = 0; s2 = 0;
    for (it = edges[u].begin (); it != edges[u].end ();it++){
      if (!in_pile[*it]){
	s1 = (s1 + size[*it]) % P;
	s2 = (s2 + size_square[*it]) % P;
      }
    }
    size[u] = (s1 + 1) % P;
    size_square[u] = (size[u] * size[u]) % P;
    int64 w = u;
    v = (P + size_square[u] - s2) % P;
    v = ((w+1) * v) % P;
    res = (res + v) % P;
    //    cout << "sommet " << (u+1) << endl;//" res =" << res << endl;*/
  }
  delete [] edges;  
  return res;
}

int main () {
  int nbcases;
  cin >> nbcases;
  for (int i=1; i<=nbcases; i++){
    cout << solve () << endl;
  }
    return 0;
}
