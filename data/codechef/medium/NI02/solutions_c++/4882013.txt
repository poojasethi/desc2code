// dijkstra standard implementation without heaps.
// order |V|^2

#include <bits/stdc++.h>
using namespace std;
int dist[2510][2510];
bool visited[2510];
pair<int,int> a[2510];
int cost[2510];
int inf=1000000000;

int main()
{
	int test;
	cin >>test;
	for(int z =1;z  <= test;z++)
	{
		int n;
		cin >> n;
		for(int i =2; i <= (n+1);i++)
			scanf("%d%d",&a[i].first,&a[i].second);
		cin>>a[1].first>>a[1].second;
		cin>>a[n+2].first>>a[n+2].second;
		n+=2;
		for(int i =1; i<= n;i++)
		{
			for(int j =1; j <= n;j++)
			{
				dist[i][j]=(a[i].first-a[j].first)*(a[i].first-a[j].first)+(a[i].second-a[j].second)*(a[i].second-a[j].second);
			}
		}
		cost[1]=0;
		for(int j=2;j <= n;j++)
			cost[j]=inf;
		// main algo.
		while(1)
		{
			int mini,minicost=inf+1; // vertex with minimum distance.
			
			for(int i =1;i <= n;i++)
				{
					if(cost[i]<minicost && !visited[i]){mini=i;minicost=cost[i];}
				}
			if(mini==n)break;
			//cout<<mini<<" "<<n<<endl;
			//for(int i =1; i <=n;i++)cout<<cost[i]<<" "<<visited[i]<<" ";
			//cout<<endl;
			visited[mini]=1;
			for(int j=1;j <= n;j++)
			{
				if(!visited[j])
				cost[j]=min(cost[j],cost[mini]+dist[mini][j]);
			}
		}
		cout<<cost[n]<<endl;
		for(int i =1;i <=n;i++)visited[i]=0;
	}
}
