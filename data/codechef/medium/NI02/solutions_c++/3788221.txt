/*Author: Rishul Aggarwal*/

#include<bits/stdc++.h>

#define mod 1000000007
#define ll long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define in(type,x) scanf("%" #type,&x)
#define debug(args...) {dbg,args; cerr<<endl;}
#define test int t;\
			 in(d,t);\
			 while(t--)

using namespace std;

struct debugger
{template<typename T> debugger& operator,(const T& v)
 {cerr<< v <<" ";
  return *this;
 }
}dbg;

ll gcd(ll a,ll b) {if(b==0) return a; return gcd(b,a%b);}

ll power(ll b,ll exp,ll m) {ll ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; }

ll dist[100002];
bool visited[100002];

ll dijkstra(int source, vector< vector< pair<int,ll> > >graph,int n)
{
	rep(i,0,n) dist[i]=1e18,visited[i]=0;
	
	set <pair<ll,int> > heap;   //heap[i].second is min dijkstra score for vertex number = heap[i].first
	vector< pair<int,ll> >::iterator vvi;
	set <pair<ll,int> >::iterator si;
	
	//start with source
	dist[source]=0;
	heap.insert(make_pair(0,source));
	//cout<<"here1";
	while(!heap.empty())
	{
		si = heap.begin();
		pair<ll,int> temp = *si;
		// this is the new entry into the set of processed vertices, vertex with the min dijkstra score
		int new_entry = temp.second;
		heap.erase(heap.begin());
		visited[new_entry]=1;
		
		for(vvi = graph[new_entry].begin(); vvi != graph[new_entry].end(); vvi++)
		{
			
			int vadj = vvi->first;
			ll vadj_weight = vvi->second;
			ll old_dist = dist[vadj], new_dist = dist[new_entry] + vadj_weight;
			//cout<<new_dist<<" "<<old_dist<<endl;
			if( (new_dist < old_dist) && (!visited[vadj]) )
			{
				pair<ll,int>to_find = make_pair(old_dist,vadj);
				set <pair<ll,int> >::iterator si;
			 // remove (vadj,old_dist) from heap and insert (vadj,new_dist) into heap 
			    si=heap.find(to_find);
				if(si!=heap.end())
				 heap.erase(si);						
				heap.insert(make_pair(new_dist,vadj)); 
				dist[vadj]=new_dist;					
			}
		}
	}
	//cout<<"here2";
	return dist[n];
	
}
			

int main()
{
 test
  {
  	int n;
  	in(d,n);
  	vector< vector<pair<int,ll> > >graph;
  	int coord[2505][2];
  	rep(i,1,n)
  	{
  		in(d,coord[i][0]),in(d,coord[i][1]);
  	}
  	in(d,coord[n+1][0]),in(d,coord[n+1][1]);
    in(d,coord[n+2][0]),in(d,coord[n+2][1]); 
    graph.resize(n+5);
    rep(i,1,n+2)
     rep(j,i+1,n+2)
      {
      	ll dist=((ll)coord[i][0]-coord[j][0])*((ll)coord[i][0]-coord[j][0]) + ((ll)coord[i][1]-coord[j][1])*((ll)coord[i][1]-coord[j][1]);
      	graph[i].push_back(make_pair(j,dist));
      	graph[j].push_back(make_pair(i,dist));
      }
    ll ans = dijkstra(n+1,graph,n+2);
	printf("%lld\n",ans);

  }


return 0;
}

