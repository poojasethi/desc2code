#include <cstdio>
#include <iostream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
#include <set>
#include <map>
#include <queue>
#include <deque>
#include <stack>
#include <list>
#include <bitset>
#include <utility>
#include <ctime>
#include <cassert>
#include <climits>
 
using namespace std;
 
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
typedef pair<int,int> pii;
typedef vector<pii > vii;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
 
#define pb push_back
#define mp make_pair
#define X first
#define Y second
#define MEM(a,b) memset(a,(b),sizeof(a))
#define pr(a) cout<<#a<<" = "<<(a)<<endl
#define cin(n) int (n); scanf("%d", &(n))
#define cin2(n,m) int (n),(m); scanf("%d%d",&(n),&(m))
#define sz(a) int((a).size())
#define all(a) a.begin(),a.end()
#define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++)
#define rep(x,n)   for(int (x)=0;(x)<(n);(x)++)
#define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define prc(a) tr(a, it) cout<<*(it)<<" "; cout<<endl
#define pra(a,n) for(int i=0; i<(n); i++) printf("%d ",((a)[i])); printf("\n") 
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) scanf("%d",&((a)[i])) 
#define vin(a,n) vector<int> (a); (a).resize((n)); for(int i=0; i<(n); i++) scanf("%d",&((a)[i])) 
#define MOD 1000000007

struct node{
	int x;
	int y;
};

int main(){
	cin(t);
	while(t--){
		cin(n);
		int cost[n+2];
		rep(i,n+2)
			cost[i]= INT_MAX;
		node info[n+2];
		rep(i,n){
			scanf("%d%d",&info[i+1].x,&info[i+1].y);
		}
		scanf("%d%d%d%d",&info[0].x,&info[0].y,&info[n+1].x,&info[n+1].y);
		int visited[n+2];
		rep(i,n+2)
			visited[i]=0;
		cost[0]=0;
		int min;
		int idx;
		int cidx = 0;
		visited[0]=1;
		int temp=0;
		while(cidx != n+1){
			min = INT_MAX;
			rep(i,n+2){
				if(visited[i]==0){
					temp = (info[i].x - info[cidx].x)*(info[i].x - info[cidx].x) + (info[i].y - info[cidx].y)*(info[i].y - info[cidx].y);
					if(cost[i]>temp+cost[cidx]){
						cost[i]=temp+cost[cidx];
					}
					if(min >= cost[i] ){
						min = cost[i];
						idx = i;
					}
				}
			}
			 cidx = idx;
			 visited[idx]=1;
		}
		printf("%d\n",cost[n+1]);
	}
	return 0;
}