/*God is greater than any problem that
u have and u have to not worry because
when u pray and then worry,
the worry nullify your prayer
He is right here, right now !!
*/

#include <bits/stdc++.h>
using namespace std;
#define bitcnt __builtin_popcount
#define ln length()
#define rep(i, n) for(int i = 0; i < n; i++)
#define rrep(i, n) for(int i = n - 1; i >= 0; i--)
#define all(a)  a.begin(),a.end()
#define LL long long
#define limit 1000006
#define sl(n) scanf("%lld", &n)
#define s(n)  scanf("%d", &n)
#define pl(n) printf("%lld", n)
#define pi(n)  printf("%d", n)
#define pb push_back
#define pn printf("\n")
#define mod 1000000007
typedef vector<LL> row;
typedef vector<row> matrix;
#define NIL -1
void print(LL *arr, LL n)
{
	rep(i, n) cout << arr[i] << " ";
	cout << endl;
}
int n, m, k;
vector<int>graph[3005];
int visited[3005];
int low[3005];
int disc[3005];
int ap[3005];
int ttime;

void dfs(int u, int parent)
{
    int children = 0;
    visited[u] = true;
    disc[u] = low[u] = ttime++;
    int size = graph[u].size();
    rep(i, size)
    {
        int v = graph[u][i];
        if (!visited[v])
        {
            children++;
            dfs(v, u);
            low[u]  = min(low[u], low[v]);
            if (parent == NIL && children > 1)
               ap[u] = true;
            if (parent != NIL && low[v] >= disc[u])
               ap[u] = true;
        }
        else if (v != parent)
            low[u]  = min(low[u], disc[v]);
    }
}

void solve()
{
	rep(i, 3005) graph[i].clear();
	memset(visited, 0, sizeof(visited));
	memset(low, 0, sizeof(low));
	memset(disc, 0, sizeof(disc));
	memset(ap, 0, sizeof(ap));
	s(n); s(m); s(k);
	rep(i, m) {
		int u, v;
		s(u); s(v);
		graph[u].pb(v);
		graph[v].pb(u);
	}
	ttime = 0;
	dfs(0, -1);
	int count = 0;
	for(int i = 0; i < n; i++) {
		if(ap[i]) count++;
	}
	pi(k * count); pn;
}

int main()
{
	int t;
	scanf("%d", &t);
	while(t--) {
		solve();
	}
	return 0;
}
