#include<cstdio>
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<cstring>

//parent array - size m + n  
//mark array - size m + n
//child array - size n
//visit array  - size n 
//alias array ( ) = size n

int g=0;
int inc=0;
int countal=0;

using namespace std;

int parent[10000000];
bool mark[10000000];
int child[3000];
int visit[3000];
int alias[3000];


int doit(int node,int parent[],bool mark[],int child[],int visit[],int alias[],vector < vector < int >  > & graph)
{
	alias[node]=node;
	visit[node]=inc++;
	child[g++]=node;
	//cout<<"visited node="<<node<<" "<<endl;
	//cout<<"special visit="<<visit[7]<<endl;
	int i;
	int no=0;
	for(i=0;i<graph[node].size();i++)
	{
		//not visited
		//cout<<node<<" "<<graph[node][i]<<" "<<visit[graph[node][i]]<<endl;
		//cout<<"special 1 visit="<<visit[7]<<endl;
		if(visit[graph[node][i]]==-1) {  
			parent[graph[node][i]]=node; 
			//cout<<parent[graph[node][i]]<<" "<<"child top "<<child[g-1]<<endl;
			if(child[g-1]!=node) child[g++]=node;
			doit(graph[node][i],parent,mark,child,visit,alias,graph);
			//cout<<"g is "<<g<<endl;
			no++;
			alias[node]=node;
		}
		//back edge
		else if(parent[node]!=graph[node][i] && visit[node]>visit[graph[node][i]])
		{

			//	cout<<"node="<<" "<<node<<" "<<graph[node][i]<<endl;
			//shouldnot mark alias as 1 if starting node for back edge
			if(child[g-1]==node)
			{
				//cout<<"what"<<endl;
				mark[child[g-1]]=1;
				g--;
			}
			//cout<<"special visit="<<visit[7]<<endl;

			//eliminate those edges just less than the visiting time
			while(g>0 && visit[child[g-1]]>visit[graph[node][i]])
			{
				//cout<<"daw child is "<<child[g-1]<<endl;
				mark[child[g-1]]=1;
				mark[alias[child[g-1]]]=1;
				g--;
			}
			//cout<<"g= " <<g<<endl;
			//cout<<"special visit="<<visit[7]<<endl;
			//make new alias if node is present && alias is not already been made
			if(g>0 && visit[child[g-1]]==visit[graph[node][i]] && alias[graph[node][i]]==graph[node][i])
			{
				//cout<<"parents"<<" "<<countal<<" "<<graph[node][i]<<endl;
				parent[countal++]=graph[node][i];
				alias[graph[node][i]]=countal-1;
			}
		}
	}
	if(child[g-1]==node) g--;
	return no ;
}

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,m,k;
		scanf("%d%d%d",&n,&m,&k);
		//cin>>n>>m>>k;
		int i,j;
		int u,v;
		vector < vector < int > > graph(n);
		countal=n;
		for(i=0;i<m;i++)
		{
			scanf("%d%d",&u,&v);
			//cin>>u>>v;
			graph[u].push_back(v);
			graph[v].push_back(u);
		}
		memset(parent,-100,sizeof(parent));
		memset(mark,0,sizeof(mark));
		memset(visit,-1,sizeof(visit));
		memset(alias,-1,sizeof(alias));
		parent[0]=-1;
		int val=doit(0,parent,mark,child,visit,alias,graph);
		//reusing alias for storing articulation points
		for(i=1;i<countal;i++)
		{
			//articulation point
			if(!mark[i])
			{
				//cout<<i<<" "<<parent[i]<<endl;
				alias[parent[i]]=-2;
			}
		}
		int ans=0;
		if(val<=1) alias[0]=12; else alias[0]=-2; 
		for(i=0;i<n;i++)
			if(alias[i]==-2) ans++;
		cout<<ans*k<<endl;
	}
	return 0;
}


