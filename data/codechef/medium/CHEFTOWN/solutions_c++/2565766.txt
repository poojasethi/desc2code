#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include<string>
 
 
#define s(a) scanf("%d",&a)
#define lls(a) scanf("%lld",&a)
#define fs(a) scanf("%f",&a)
#define ds(a) scanf("%lf",&a)
#define p(a) printf("%d",a)
#define llp(a) printf("%lld",a)

using namespace std;
typedef long long int LLD;

LLD arr[400005],counts = 0,minimum,maximum;
 
void printKMax(LLD arr[], LLD n, LLD k)
{
    // Create a Double Ended Queue, Qi that will store indexes of array elements
    // The queue will store indexes of useful elements in every window and it will
    // maintain decreasing order of values from front to rear in Qi, i.e., 
    // arr[Qi.front[]] to arr[Qi.rear()] are sorted in decreasing order
    deque<LLD>  min(k),max(k);
 
    /* Process first k (or first window) elements of array */
    LLD i;
    for (i = 0; i < k; ++i)
    {
        // For very element, the previous smaller elements are useless so
        // remove them from Qi
        while ( (!min.empty()) && arr[i] <= arr[min.back()])
            min.pop_back();  // Remove from rear
             while ( (!max.empty()) && arr[i] >= arr[max.back()])
            max.pop_back(); 
 
        // Add new element at rear of queue
        min.push_back(i);
        max.push_back(i);
    }
 
    // Process rest of the elements, i.e., from arr[k] to arr[n-1]
    for ( ; i < n; ++i)
    {
        // The element at the front of the queue is the largest element of
        // previous window, so print it
        minimum =  arr[min.front()];
        maximum = arr[max.front()];
        
        if(maximum - minimum == k-1)
        counts++;
 
 
        // Remove the elements which are out of this window
        while ( (!min.empty()) && min.front() <= i - k)
            min.pop_front();  // Remove from front of queue
            
            while ( (!max.empty()) && max.front() <= i - k)
            max.pop_front();  // Remove from front of queue
 
 
        // Remove all elements smaller than the currently
        // being added element (remove useless elements)
        while ( (!min.empty()) && arr[i] <= arr[min.back()])
            min.pop_back();
            
            while ( (!max.empty()) && arr[i] >= arr[max.back()])
            max.pop_back();
 
 
         // Add current element at the rear of Qi
         min.push_back(i);
        max.push_back(i);
    }
 
    // Print the maximum element of last window
    minimum =  arr[min.front()];
        maximum = arr[max.front()];
        
        if(maximum - minimum == k-1)
        counts++;
} 
 
int main() {
    
    LLD n,w,i;
    
    lls(n);
    lls(w);
    
    for(i=0;i<n;i++)
    lls(arr[i]);
    
    printKMax(arr,n,w);
    
    
    cout<<counts<<endl;
    return 0;
}  