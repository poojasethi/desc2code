//Copied solution..just for testing

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define ll long long
#define LIM 1001111
#define INF (1<<30)
#define gc getchar_unlocked
#define pc(x) putchar_unlocked(x);
inline void out(int n)
{
    int N = n, rev, count = 0;rev = N;if (N == 0) { pc('0'); pc('\n'); return ;}while ((rev % 10) == 0) { count++; rev /= 10;}rev = 0;while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}while (count--) pc('0');
    pc('\n');
}
inline void sc(int &x)
{
    register int c = gc();x = 0;int neg = 0;for(; ((c<48 || c>57) && c != '-');c=gc());if(c=='-'){neg = 1;c = gc();}for(; c>47 && c<58 ; c = gc()) {x = (x<<1) + (x<<3) + c - 48;}if(neg)x = -x;
}


int A[LIM];
int L[LIM];
int R[LIM];
int s[LIM]; // stack

typedef pair<int,int> ct;
#define value first
#define count second

ct cts[LIM];
char typ[11];
char ans[LIM]; // will contain the answer string
int n, m;
int find(int k) {
    // binary search
    int L = 0, R = n + 1;
    while (R - L > 1) {
        int M = L + R >> 1;
        (cts[M].value <= k ? L : R) = M;
    }
    return cts[L].count;
}

int main() {
    //scanf("%d%d", &n, &m);
    sc(n);sc(m);
    A[0] = A[n+1] = INF;
    for (int i = 1; i <= n; i++) sc(A[i]);//scanf("%d", A + i);

    // compute L from left to right
    s[0] = 0;
    for (int q = 0, i = 1; i <= n; i++) {
        while (A[s[q]] <  A[i]) q--;
        L[i] = s[q];
        s[++q] = i;
    }

    // compute R from right to left
    s[0] = n+1;
    for (int q = 0, i = n; i; i--) {
        while (A[s[q]] <= A[i]) q--;
        R[i] = s[q];
        s[++q] = i;
    }

    // compute the frequencies of maximums of subarrays in sorted order.
    cts[0].value = -INF;
    cts[0].count = 0;
    for (int i = 1; i <= n; i++) {
        cts[i].value = A[i];
        cts[i].count = (R[i] - i) * (i - L[i]);
    }
    sort(cts, cts + n + 1);
    // compute cumulative sums. Since we only need the parity, we can use '^' instead of '+'
    for (int i = 1; i <= n; i++) {
        cts[i].count ^= cts[i-1].count;
    }

    // answer queries
    for (int i = 0; i < m; i++) {
        int k;
        scanf("%s%d%s", typ, &k, ans + i);
        if (!((*typ == '>' ? n*(n+1LL)/2 - find(k) : *typ == '<' ? find(k-1) : find(k) - find(k-1)) & 1)) ans[i] ^= 7;
    }
    ans[m] = 0;
    printf("%s\n", ans);
}