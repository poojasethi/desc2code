// START BOILERPLATE HEADER
// Useful Includes
// <vector> <list> <map> <set> <deque> <queue> <stack> <bitset>
// <algorithm> <functional> <numeric> <utility> <sstream> <iomanip>
// <ctime> <cassert>

#include <iostream>
#include <fstream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>

using namespace std;

// Useful Constants
#define PI  3.141592653589793238462643383279502884197169399375105820974944592307816406286
#define E   2.718281828459045235360287471352662497757247093699959574966967627724076630353               

//Useful Macros
#define MAX(i,j)            ((i)>(j)?(i):(j))
#define MIN(i,j)            ((i)<(j)?(i):(j))
#define ABS(i)              ((i)<0?-(i):(i))
#define REP(i,a)            for((i)=0;(i)<(a);(i)++)
#define FOR(i,a,b)          for((i)=a;(i)<(b);(i)++)
#define FORE(i,a,b)         for((i)=a;(i)<=(b);(i)++)
#define EACH(it,b)          for(__typeof((b).begin())it=(b).begin();it!=(b).end();it++)
#define CLRI(ptr,n)         memset((ptr),0,(n)*sizeof(int))
#define CLRC(ptr,n)         memset((ptr),0,(n)*sizeof(char))

//Useful Typedefs
typedef long long ll;
typedef unsigned long long ull;

//Fast stdin class (my windows g++ doesn't have getchar_unlocked, so this will have to do)
class FastInput {
	private:
        static const int BUFSIZE = 1<<16;
        static char buffer[];
        char *bufpos;
        char *bufend;
        bool debug_mode;
        ifstream mystream;
    public:
        inline void getmore();
		inline void getint(int &n);
		inline void getull(ull &n);
		inline void getstr(char k[]);
		FastInput()                     { debug_mode = false; getmore(); }
		FastInput(const char *filename) { debug_mode = true; mystream.open(filename); getmore(); }
		inline void nextchar(char &c)   { c = *bufpos++; if (bufpos==bufend) getmore(); }
};

char FastInput::buffer[FastInput::BUFSIZE];

inline void FastInput::getmore() {
    bufpos = buffer;
#ifdef ONLINE_JUDGE
    bufend = buffer + read(0, buffer, BUFSIZE);
#else
	if (debug_mode) { mystream.read(buffer,BUFSIZE); bufend = buffer + mystream.gcount(); }
	else            {      cin.read(buffer,BUFSIZE); bufend = buffer +      cin.gcount(); }
#endif
}

inline void FastInput::getint(int &n) {
    n = 0; register char ch; bool neg = false; nextchar(ch);
    while (ch < '0' || ch > '9')   { if (ch=='-') neg = true; nextchar(ch); }
	while (ch >= '0' && ch <= '9') { n=(n<<3)+(n<<1)+ch-'0'; nextchar(ch); }
    if (neg) n = -n;
}

inline void FastInput::getull(unsigned long long &n) {
    n = 0; register char ch; nextchar(ch);
    while (ch < '0' || ch > '9')   { nextchar(ch); }
	while (ch >= '0' && ch <= '9') { n=(n<<3)+(n<<1)+ch-'0'; nextchar(ch); }
}

inline void FastInput::getstr (char k[]) {
    register int cnt = 0; register char ch; nextchar(ch);
    while (( ch < 'a' || ch > 'z' ) && ( ch < 'A' || ch > 'Z' )) nextchar(ch);
    while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) { k[cnt++] = ch; nextchar(ch); }
    k[cnt] = '\0';
}


class FastOutput {
	private:
        static const int BUFSIZE = 1<<16;
        static char buffer[];
        char *bufpos;
        char *bufend;

    public:
		inline void flush();
		inline void putint(int n,char c);
		FastOutput()  { bufpos = buffer; bufend = bufpos + BUFSIZE; }
		~FastOutput() { flush(); }
		inline void wrchar(char c) { *bufpos++ = c;	if (bufpos == bufend) flush(); }
        inline void putstr(char *k) { while (*k != 0) wrchar(*k++); }
};

char FastOutput::buffer[FastOutput::BUFSIZE];

inline void FastOutput::flush() {
	if (bufpos == buffer) { return; }
#ifdef ONLINE_JUDGE
    write(1, buffer, bufpos-buffer);
#else
	cout.write(buffer,bufpos-buffer);
#endif
	bufpos = buffer;
}

inline void FastOutput::putint(int n, char c) {
	char buf[32]; bool neg = false; char *bufptr; bufptr = buf + 31; *bufptr-- = 0; if (c > 0) *bufptr-- = c;
	if (n == 0) *bufptr-- = '0';
	if (n < 0) { neg = true; n = -n; }
	while (n>0) { int r = n % 10; *bufptr-- = '0'+r; n /=10; }
	if (neg) { *bufptr-- = '-'; }
	putstr(++bufptr);
}
	



/////////////////////////////////////////////////////////////////////////////////////
// SOLUTION STARTS HERE
/////////////////////////////////////////////////////////////////////////////////////

char nextchar(FastInput &fi) {
	char c = 0;
	while ((c < 33) || (c > 126)) fi.nextchar(c);
	return c;
}

int getpassstr(FastInput &fi, char *pass) {
	char c = 0; int i = 0;
	while ((c < 33) || (c > 126)) fi.nextchar(c);
	while ((c >= 33) && (c <= 126)) { pass[i++] = c; fi.nextchar(c); }
	return i;
}

int main() {
    //FastInput fi;
	FastInput fi("FORGETPW.in");
	FastOutput fo;
	char a[128], pass[1000001];
	int i,j,k;
    int t; fi.getint(t);
	while (t--) {
		char s,t,ci;
		FOR(ci,0,127) { a[ci] = ci; }
		int n; fi.getint(n);
		while (n--) { s = nextchar(fi); t = nextchar(fi); a[s] = t; }
		int passlen = getpassstr(fi, pass);
		FOR(i,0,passlen) pass[i] = a[pass[i]];
		bool foundLeading = false, foundTrailing = false;
		// Do the stuff before the decimal
		FOR(i,0,passlen) { 
			if (pass[i] == '.') break;
			if (!foundLeading && (pass[i] >= '1') && (pass[i] <= '9')) foundLeading = true;
			if (foundLeading) fo.wrchar(pass[i]);
		}
		// Check if we have a nonzero trailing decimal
		if (i < passlen-1) { for (j=passlen-1; j >= i; j--) { if ((pass[j] >= '1') && (pass[j] <= '9')) { foundTrailing = true; break; } } }
		if (foundTrailing) {
			fo.wrchar('.');
			FORE(k,i+1,j) fo.wrchar(pass[k]);
		}
		if (!foundLeading && !foundTrailing) { fo.wrchar('0'); }
		fo.wrchar('\n');
		fo.flush();
	}
	fo.flush();
	return(0);
}
