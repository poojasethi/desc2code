/*
 * =====================================================================================
 *
 *       Filename:  elephants.cpp
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  Sunday 10 February 2013 11:50:11  IST
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:   (), 
 *        Company:  
 *
 * =====================================================================================
 */

#include<iostream>
#include<vector>
using namespace std;


typedef long long ll;


class Fact {
		public:
		ll MOD;
		vector<ll> fact, ifact;
		Fact(int mod, int N){
			MOD = mod; //1e9 + 7;
			vector<ll> f(N+1), iff(N+1);
			f[0] = iff[0] = 1;
			for(int i=1;i<=N;i++){
				f[i] = (i * f[i-1]) % MOD;
				iff[i] = (inverse(i) * iff[i-1]) % MOD;
			}
			fact = f;
			ifact = iff;
			//printv(fact);
			//printv(ifact);
		}
		template<typename T>
		void printv(T &v){
			int N = v.size();
			for(int i=0;i<N;i++) cout << v[i] << ",";
			cout << endl;
		}

		ll pow(ll a, ll p){
			if(p == 1) return a;
			if(p == 0) { cout << "Fail" << endl; return -1;}
			if(p & 1){
				ll res = pow(a, (p-1)/2);
				res = (res * res) % MOD;
				res = (res * a) % MOD;
				return res;
			} else {
				ll res = pow(a, p/2);
				res = (res * res) % MOD;
				return res;
			}
		}

		//use fermats little theorem
		ll inverse(int r){
			ll res = pow(r, MOD - 2) % MOD;
			//cout << "inverse " << r << " " << res << endl;
			return res;
		}

		ll comb(int n, int r){
			//cout << "comb" << n << "," << r << endl;
			ll res = 1;
			res = (fact[n] * ifact[r])  % MOD;
			res = (res * ifact[n-r]) % MOD;
			return res;
		}

		ll C(int n, int r){
			//lucas theorem
			vector<int> nk, rk;
			while(n) {
				int rem = n % MOD;
				nk.push_back(rem);
				n /= MOD;
			}
			while(r){
				int rem = r % MOD;
				rk.push_back(rem);
				r/=MOD;
			}
			while( rk.size() > nk.size()) nk.pop_back();
			//printv(rk);
			//printv(nk);
			ll res = 1;
			int N = nk.size();
			for(int i=0;i<N;i++){
				res = (res * comb(nk[i], rk[i]) ) % MOD;
			}
			return res;
		}
};


ll modulo = 1000000007;
void process(Fact &f, int N, vector<int> C){
	ll res = 0;
	int start;
	if(N%2 == 1) start = (N+1)/2;
	else start = N/2 + 1;
	for(int i=start;i<=N;i++){
		res =  (res + f.C(N, i)) % modulo;
	}
	cout << res << endl;
}
int main(){
	int T;
	cin >> T;
	Fact f(modulo, 1000);
	for(int t=0;t<T;t++){
		int N, v;
		cin >> N;
		vector<int> C(N, 0);
		for(int i=0;i<N;i++){
			cin >> v;
			C.push_back(v);
		}
		process(f, N, C);
	}
	return 0;
}
