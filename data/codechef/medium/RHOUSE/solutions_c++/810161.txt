#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cassert>

using namespace std;

char b[100100],l;
int n,m,t;

typedef struct edge{
	int c;
	int n1,n2;
}e;

bool cmp(e _1, e _2){
	return _1.c < _2.c;
}

typedef struct node{
	struct node * parent;
	char type;
	int value;
	int rank;
}node;

node * makeset(int value){
	node * n = new node();
	n->value = value;
	n->parent = NULL;
	n->rank = 0;
	return n;
}

void union_set(node* n1, node* n2){
	if(n1 == n2) return;
	if(n1->type == 'R' || n2->type == 'R'){
		n1->type = n2->type = 'R';
	}
	if(n1->rank > n2->rank){
		n2->parent = n1;
	}else if(n1->rank < n2->rank){
		n1->parent = n2;
	}else{
		n2->parent = n1;
		n1->rank+=1;
	}
}

node* find(node* n){
	node* temp;
	node* root = n;
	while(root!=NULL && root->parent!=NULL){
		root = root->parent;
	}
	while(n!=NULL && n->parent!=NULL){
		temp = n->parent;
		n->parent = root;
		n = temp;
	}
	return root;
}

e edges[400100];
node *nodes[100100];

int main(){
	scanf("%d", &t);
	while(t--){
		scanf("%d %d\n", &n, &m);
		scanf("%s", b);
		for(int i=1; i<=n; i++){
			nodes[i] = makeset(i);
			nodes[i]->type = b[i-1];
		}	
		for(int i=1; i<=m; i++){
			scanf("%d %d %d", &edges[i].n1,&edges[i].n2,&edges[i].c);
		}	
		
		sort(edges+1, edges+m+1, cmp);
		
		long long int cost = 0;
		for(int i=1; i<=m; i++){
			if(edges[i].c < 0){
				union_set(find(nodes[edges[i].n1]), find(nodes[edges[i].n2]));
				cost+=edges[i].c;
			}else{
				node *t1 = find(nodes[edges[i].n1]);
				node *t2 = find(nodes[edges[i].n2]);
				if(t1!=t2 && (t1->type != 'R' || t2->type != 'R')){
					union_set(t1, t2);
					cost+=edges[i].c;
				}
			}
		}
		printf("%lld\n", cost);
		
	}
	return 0;
}