#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

void make_set(int, int*, int*);
void union_set(int, int, int*, int*);
void link(int, int, int*, int*);
int find_set(int, int*);

struct edge {
	int x, y, wt;
};

bool edgeComp (const edge& e1, const edge& e2) 
{
	return e1.wt < e2.wt;
}

int main()
{
	int T;
	scanf("%d", &T);

	while (T--) {
		long long cost = 0;

		int N, M;
		scanf("%d %d", &N, &M);

		char *bldgs = new char[N+2];
		scanf("%s", bldgs+1);

		int r = 0;
		for (int i = 1; i <= N; ++i) {
			if (bldgs[i] == 'R') {
				r = i;
				break;
			}
		}

		int p[N+1], rank[N+1];
		for (int i = 1; i <= N; ++i) {
			make_set(i, p, rank);
			if (bldgs[i] == 'R' && i != r) {
				union_set(i, r, p, rank);
			}
		}

		vector<edge> edges(M);
		int x, y, wt;
		for (int i = 0; i < M; ++i) {
			scanf("%d %d %d", &x, &y, &wt);
			edges[i].x = x;
			edges[i].y = y;
			edges[i].wt = wt;
		}

		sort (edges.begin(), edges.end(), edgeComp);

		for (int i = 0; i < M; ++i) {
			edge e = edges[i];
			if (e.wt < 0) {
				cost += e.wt;
				union_set(e.x, e.y, p, rank);
			} else if (find_set(e.x, p) != find_set(e.y, p)) {
				cost += e.wt;
				union_set(e.x, e.y, p, rank);
			}
		}

		printf ("%lld\n", cost);

	}
}

void make_set(int x, int* p, int *rank)
{
	p[x] = x;
	rank[x] = 0;
}

void union_set(int x, int y, int *p, int *rank)
{
	link(find_set(x, p), find_set(y, p), p, rank);
}

void link (int x, int y, int *p, int *rank)
{
	if (rank[x] > rank[y]) {
		p[y] = x;
	} else {
		p[x] = y;
		if (rank[x] == rank[y]) {
			++rank[y];
		}
	}
}

int find_set(int x, int *p)
{
	if (x != p[x]) {
		p[x] = find_set(p[x], p);
	}
	return p[x];
}
