#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <deque>
#include <list>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <utility>
#include <algorithm>

#define INF 0x3f3f3f3f
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define MAXN 100005
#define MAXM 400005

using namespace std;

typedef long long llint;
typedef pair<int,int> pii;

int par[MAXN], N, M, nedge;
llint ans;
char type[MAXN];
pair< int, pii > edge[MAXM];

int Find_Set ( int a ) {
    if ( a != par[a] ) {
        par[a] = Find_Set ( par[a] );
    }
    return par[a];
}

bool Link ( int a, int b ) {
    a = Find_Set ( a );
    b = Find_Set ( b );
    if ( ( type[a] == 'R' && type[b] == 'R' ) || a==b ) {
        return false;
    }
    if ( type[a] == 'R' ) {
        par[b] = a;
        return true;
    }
    else {
        par[a] = b;
        return true;
    }
}

void Read() {
    int i, a, b, cost;

    ans = 0;
    nedge = 0;

    scanf ("%d %d ", &N, &M);

    for ( i=1; i<=N; ++i ) {
        type[i] = (char) getchar_unlocked();
        par[i] = i;
    }


    for ( i=1; i<=M; ++i ) {
        scanf ("%d %d %d", &a, &b, &cost );
        if ( cost <= 0 ) {
            ans += (llint)cost;
            Link ( a, b );
            continue;
        }
        edge[ ++nedge ] = mp ( cost, mp ( a,b ) );
    }
    sort ( edge+1, edge+nedge+1 );
}

void Solve() {
    int i, a, b;

    for ( i=1; i<=nedge; ++i ) {
        if ( Link( edge[i].Y.X , edge[i].Y.Y ) ) {
            ans += (llint)edge[i].X;
        }
    }

    printf ("%lld\n", ans);
}

int main ( void ) {
#ifdef D
    freopen ("input","r",stdin);
#endif

    int t, T;

    scanf ("%d", &T);
    for ( t=1; t<=T; ++t ) {
        Read();
        Solve();
    }

    return 0;
}
