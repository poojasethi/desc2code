#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

/*
  Need to calculate the numbers between L-R (~10^6) which have prime number of 
  factors.
  
  -- We can iterate over the numbers from L to R, prime factorise them and
  calculate the number of factors for each number.
  
  -- First, we calculate all the prime numbers till 10^3 as L and R 
  can be 10^12 max. So, till the fourth root.
  
  -- Then we prime factorize each number and try and find the answer.

//This solution gets TLEd, need to comeup with a faster solution.

//We need a segmented sieve approach here! Should have thought of 
that already.. isn't it.

*/

const int N = 1000000;

class PrimeList
{
      vector<int> primes;         //The list of primes
      vector<bool> primeHash;     //index (prime)? true : false
      int n;                      //Too which primes have been calculated
public:
      PrimeList(int numPrimes); 
      inline const int GetN() {return n;}
      inline vector<int> GetPrimes() {return primes;}
      inline vector<bool> GetPrimeHash() {return primeHash;}
      void Display(int numPrimes);
};

PrimeList::PrimeList(int numPrimes)
  :n(numPrimes), primeHash(vector<bool> (numPrimes, true))
{
  //compute the primeHash
  for (int i=4; i<numPrimes; i+=2) primeHash[i] = false;
  int rootNumPrimes = static_cast<int>(sqrt(numPrimes));
  for (int i=3; i<=rootNumPrimes; i+=2)
  {
      if (primeHash[i])
      {
         for (int j = i*i; j<numPrimes; j += (2*i))
             primeHash [j] = false;
      }    
  }
  //make the primeList
  primes.push_back(2);
  for (int i=3; i<numPrimes; i+=2)
      if (primeHash[i])
         primes.push_back(i);
}

void PrimeList::Display(int numPrimes)
{
    // Print the first numPrimes primes
    if (numPrimes > primes.size()) return;
    for (int i=0; i<numPrimes; ++i)
        cout<<primes[i]<<", ";
    cout<< ".."<<endl;                       
}

int divisors[N+1];
long long num[N+1];

int main()
{
    PrimeList p(N);
    vector<int> primes = p.GetPrimes();
    vector<bool> primeHash = p.GetPrimeHash();
    
    int testcases;
    scanf("%d", &testcases);
    while (testcases--)
    {
          long long L, R;
          int ans = 0;
          scanf("%lld%lld", &L, &R);
          if (L>R) swap(L,R);
       
          if (L<=1) L=2; 
         
          for (long long i=L; i<=R; ++i)
          {
               divisors[i-L] = 1;    
               num[i-L] = i;
          }
          for (int i=0; i<primes.size(); ++i)
          {
              if (primes[i] > R) break;
              for (long long j = ((L-1)/primes[i] + 1) * primes[i]; j <= R; j += primes[i])
              {
                  int cnt = 2;
                  num[j-L] /= primes[i];
                  while ( num[j-L] % primes[i] == 0)
                  {
                        num[j-L] /= primes[i];
                        ++cnt;
                  }
                  divisors[j-L] *= cnt;
              } 
          }
          
          for (long long i=L; i<=R; ++i)
          {
              if (num[i-L] > 1) divisors[i-L] *= 2;
              if (primeHash[divisors[i-L]]) ++ans;    
          }
          printf("%d\n", ans);
    }    
    return 0;
}
