#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define MAXN 100000
int L[MAXN+10]; //L[i] stores largest index < i such that substring S[L[i],i] contains more than K 1s/0s
LL pre[MAXN+10];//prefix sum of array i-L[i] to calculate subarray sums.
char s[MAXN+10];
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        memset(L,0,sizeof(L));
        int n,q,l,r,k;
        scanf("%d %d %d %s",&n,&k,&q,s+1);
        int cnt[2]={};              //cnt[i] stores current count of j
        map <int, int> mymap[2];    //mymap[i][j] stores the largest index till where i j's were present
        for(int i=1; i<=n; i++){
            cnt[s[i]-'0']++;
            for(int j=0; j<2; j++)
                L[i]=max(L[i],mymap[j][cnt[j]-k]);
            mymap[s[i]-'0'][cnt[s[i]-'0']]=i;
            pre[i]=pre[i-1]+(LL)(i-L[i]);
        }
        while(q--){
            scanf("%d %d",&l,&r);
            int p=min((LL)(lower_bound(L+1,L+n+1,l)-L),(LL)r+1ll);  //count how many L[i] are less than l
            LL ans=pre[r]-pre[p-1];                                 //all substrings of S[l,p-1] are valid
            if(p>l) ans += ((LL)(p-l)*(LL)(p-l+1))/2;               //add to answer: i-L[i] from i=p to r.
            printf("%lld\n",ans);
        }
    }
    return 0;
}