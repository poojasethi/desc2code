/*
@author Anirudh Villayannur Raja
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>
#define pb push_back 
#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)
#define max(i,j) (i>j?i:j)
#define MOD 1000000007
using namespace std;

/*
 Let dp[x][y] denote the number of ways of preparing y dishes by the first x cooks. Clearly, our answer will be dp[m][n]. The recurrence is as follows:
dp[i][j]=Î£dp[i-1][j-k] where x[i]<=k<=y[i] 

*/

int main(){  
int t;
scanf("%d",&t);
while(t--){
int n,m;
scanf("%d %d",&n,&m);
int x[m],y[m];
FOR(i,0,m){
scanf("%d %d",&x[i],&y[i]);
}
int dp[101][101]={0};
dp[0][0] = 1;
    		for(int i=0;i<m;i++)
				for(int j=0;j<=n;j++)
					for(int k=x[i];k<=y[i] && j+k<=n;k++)
					{
						dp[i+1][j+k] += dp[i][j];
						if(dp[i+1][j+k] >= MOD)
							dp[i+1][j+k] -= MOD;
					}

printf("%d\n",dp[m][n]);
}
return 0;
}
