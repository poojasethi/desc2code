/*
	Author : Dawnavd
	Tags   : Offline Processing | Prime Factor
	Friday 04 Apr 2014 
	05:14:30 AM IST
*/
#include <bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
int cnt[100001];
vector<pii> query;
vector<int> ar;
void inc(int x)
{
	int i;
	for (i = 1; i*i < x; i++) {
		if (x%i == 0) {
			cnt[i]++;
			cnt[x/i]++;
		}
	}
	if (i*i == x){
		cnt[i]++;
	}
}
struct node
{
	int a,b,k;
	node() {}
	node(int a,int b,int k)
	{
		this->a = a;
		this->b = b;
		this->k = k;
	}
};
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	vector<node> qquery;
	map<pii,int> mp;
	ar.push_back(0);
	for (int i = 1; i <= n; i++) {
		int awe;
		scanf("%d",&awe);
		ar.push_back(awe);
	}
	for (int i = 0; i < q; i++) {
		int k,a,b;
		scanf("%d%d%d",&a,&b,&k);
		qquery.push_back(node(a,b,k));
		query.push_back(pii(a-1,k));
		query.push_back(pii(b,k));
	}
	sort(query.begin(),query.end());
	int j = 0;
	int i;
	for (i = 1; i <= n; i++) {
		while (j < query.size() && query[j].first < i) {
			int a = query[j].first;
			int k = query[j++].second;
			mp[pii(a,k)] = cnt[k];
		}
		inc(ar[i]);
	}
	while (j < query.size() && query[j].first < i) {
		int a = query[j].first;
		int k = query[j++].second;
		mp[pii(a,k)] = cnt[k];
	}
	for (int i = 0; i < q; i++) {
		int a = qquery[i].a;
		int b = qquery[i].b;
		int k = qquery[i].k;
		printf("%d\n",mp[pii(b,k)]-mp[pii(a-1,k)]);
	}
	return 0;
}
