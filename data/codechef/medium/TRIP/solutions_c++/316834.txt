#include<iostream>
#include<cstdio>
#include<fstream>
#include<sstream>
#include<algorithm>
#include<functional>
#include<complex>
#include<iomanip>
#include<numeric>
#include<cassert>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<utility>
#include<vector>
#include<string>
#include<queue>
#include<stack>
#include<set>
#include<list>
#include<bitset>
#include<map>
 
#define SIZE(X) ((int)(X.size()))
#define LENGTH(X) ((int)(X.length()))
#define MP(X,Y) make_pair((X),(Y))
#define two(X) (1<<(X))
#define twoL(X) (1LL<<(X))
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define Clear(A,n) memset(A,n,sizeof(A))
#define FOR(i,n) for(int i=0;i<(n);i++)
#define REP(i,a,b) for(int i=(a);i<=(b);i++)


using namespace std;
typedef pair<int,int> PII;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<PII> VII;
typedef map<int,int> MII;
typedef map<string ,int > MSI;

template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}
template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}
template<class T> inline int countbit(T n){return (n==0)?0:(1+countbit(n&(n-1)));}
template<class T> inline T sqr(T x){return x*x;}
template<class T> inline T lowbit(T n){return n&(-n);}
template<class T> inline T gcd(T a,T b)
{if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);}

const double pi=acos(-1.0);
const double eps=1e-10;
const int Dx[8]={-1,0,1,0,-1,1,1,-1};
const int Dy[8]={0,1,0,-1,1,1,-1,-1};

const double INF = 1000000000 ;
const int mod = 1000000007 ;

const int MAXN = 1000000+10;
const int MAXM = 700+10 ;


int A[ MAXN ] ;
int dp[ MAXN ] ;
int num [ MAXN ] ;
int Que[ MAXN ] ;

int getInt(){
	char c;
	while( (c=getchar()) && !isdigit(c) ) ;
	int ret = c - '0' ; while( c=getchar() ) if( !isdigit(c) )break;else ret=ret*10+c-'0' ;
	return ret;
}
int main(){
	int N , M ;
	while( scanf("%d%d",&N,&M) != EOF ){
		FOR( i , N ) {
			A[i] = getInt() ;//scanf("%d",&A[i]);
		//	cout << A[i] << endl;
		}
		
		FOR( i , N ) dp[i] = 0 , num[ i ] = 0 ; 
		int head = 0 , tail = 0  , forhead = 1 , sz = 1 ;  Que[ tail ++ ] = 0 ;  num[0] = 1 ;
		REP( i , 1 , N - 1 ){
			while( head < tail && A[ i ] - A[ Que [ head ] ] > M  ) {
				sz -= num[ Que[head++] ] ;
				if( sz < 0 ) sz += mod;
			}
			if( head >= forhead ){
				sz = 0 ;forhead = head ;
				while( forhead < tail && dp[ Que[forhead] ] == dp[ Que[ head ] ] ){
					sz += num[ Que[ forhead++ ] ] ;
					if( sz >= mod ) sz -= mod;
				}
			}
			//cout << head << " " << forhead << " " <<  sz << endl;
			dp[ i ] = dp[ Que[ head ] ] + 1 ; 
			num[ i ] = sz ;

			while( tail > head && dp[ i ] < dp[ Que[tail-1] ] ) tail -- ;
			Que[ tail ++ ] = i ; 
			if( tail == head+1 ){
				forhead = head;
				sz = num[ Que[ head ] ] ;
			}else{
				if( dp[ Que[tail-1] ] == dp[ Que[head] ] ){
					sz += num[ Que[ forhead ++ ] ];
					if( sz >= mod ) sz -= mod;
				}
			}
		}
		printf("%d %d\n",dp[ N-1 ] - 1 , num[ N-1 ]);
	}
}
