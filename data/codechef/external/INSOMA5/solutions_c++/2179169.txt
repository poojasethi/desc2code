//Same as Optimal Bst problem :)

#include <iostream>
#include <cstring>

using namespace std;

int dp[20][20];
unsigned long long C[36];

void pre()
{
    C[0] = C[1] = 1;

    for(int i = 2;i <= 35;++i){
        C[i] = 0;
        for(int j = 0;j < i;++j)
            C[i] += C[j] * C[i - 1 - j];
    }
}

bool check(char c, bool b, bool a)
{
        if(c == '.') return b&&a;
        if(c == '+') return b||a;
        else return b!=a;
}

int main()
{
    string s;

    cin >> s;

    int n = 0;
    pre();

    for(int i = 0; i < s.size(); i++) {
        if(s[i] == 'T' || s[i] == 'F') n++;
    }
    memset(dp, 0, sizeof(dp));
    int j = 0;
    for(int i = 0; i < n; i++) {
        dp[i][i] = (s[j]=='T'? 1:0);
        j+=2;
    }
    for(int i = 1; i < n; ++i) {
        for(int j = 0; j < n-i; ++j) {
            for(int k = j; k < i+j; ++k) {
                char temp = s[2*k+1];
                if(check(temp, true, true)) dp[j][j+i] += (dp[j][k]*dp[k+1][j+i]);
                if(check(temp, true, false)) dp[j][j+i] += (dp[j][k]*(C[j+i-k-1]-dp[k+1][j+i]));
                if(check(temp, false, true)) dp[j][j+i] += ((C[k-j]-dp[j][k])*dp[k+1][j+i]);
                if(check(temp, false, false)) dp[j][j+i] += ((C[k-j]-dp[j][k])*(C[j+i-k-1]-dp[k+1][j+i]));
            }

        }
    }

    cout << dp[0][n-1] << endl;
}
