#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <memory>
#include <cctype>
#include <string>
#include <vector>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <set>
#include <algorithm>
using namespace std;
#define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i))
#define RFOR(i,a,b) for(int (i) = (a); (i) >= (b); --(i))
#define INITIALIZE(a,b) memset((a),b,sizeof(a))
#define INF 1000000000
#define pi 2*acos(0.0)
#define SQR(a) (a)*(a)
#define MP make_pair
#define MAX 100001
#define MODV 1000000007
#define mod(a,mb) if(a >= mb) a = a - mb;
#define modx(a) mod(a,MODV)

typedef unsigned long long UInt;
typedef long long Int;

void compPrime(int *primeArr,int n){}
void compPhi(int *phiArr, int n){}
void compFact(int *factArr, int n){}
void compPow(int *powArr, int x, int n)
{   int i;
    powArr[0] = 1;
    FOR(i,1,n){powArr[i] = powArr[i-1]*x;mod(powArr[i],MODV);}
}

class Literal
{
public :
    int count1 ;
    int count0 ;
    Literal(){count1 = count0 = 0;}

};
int main()
{
  int test,N,i,j, sum;
  char Str[30];
  scanf("%s", Str);
  vector<char>OP;
  vector<int>Val;

  for(i=0; Str[i]!='\0'; i++)
  {
      if(Str[i]=='T')Val.push_back(1);
      else if(Str[i]=='F')Val.push_back(0);
      else OP.push_back(Str[i]);
  }

  N = Val.size();
  Literal m[N+1][N+1];
  FOR(i,1,N)
    if(Val[i-1]==0)m[i][i].count0 =  1;
    else m[i][i].count1 = 1;

   int l,k;
   int q1, q0;
   int count00, count01, count10, count11;
   FOR(l,2,N)
   {
       FOR(i, 1, N-l+1)
       {
           j = i + l - 1;
           q1 = 0;
           q0 = 0;
           FOR(k,i,j-1)
           {
               count00 = m[i][k].count0 * m[k+1][j].count0;
               count01 = m[i][k].count0 * m[k+1][j].count1;
               count10 = m[i][k].count1 * m[k+1][j].count0;
               count11 = m[i][k].count1 * m[k+1][j].count1;
               if(OP[k-1]=='+'){q1 += count11+count10+count01; q0+=count00;}
               else if(OP[k-1]=='.'){q1+=count11; q0+= count00+count10+count01;}
               else {q1+= count01 + count10; q0+= count11 + count00;}

           }
           m[i][j].count1 = q1;
           m[i][j].count0 = q0;
       }
   }

   printf("%d\n", m[1][N].count1);


}
