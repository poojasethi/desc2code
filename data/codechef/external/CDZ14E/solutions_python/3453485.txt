#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define MOD 1000000007

struct node
{
    int n,l,r;
    long long sum;
} buf[400000];    

int N,i,j,T,Q,pos[20000+10],roots[20000+10],num;
vector<pair<int,int> > a;
int insert(int id,int l,int r,int v);
long long query(int lr,int rr,int l,int r,int k);

int main()
{
    scanf("%d",&N);
    for(i = 0; i < N; i++)
    {
        scanf("%d",&j);
        a.pb(mp(j,i+1));
    }
    sort(all(a));
    for(i = 0; i < N; i++)
        pos[a[i].second] = i+1;
    roots[0] = 0;
    for(i = 1; i <= N; i++)
        roots[i] = insert(roots[i-1],1,N,pos[i]);
    scanf("%d",&Q);
    while(Q--)
    {
        int l,r,k;
        scanf("%d %d %d",&l,&r,&k);
        printf("%lld\n",query(roots[l-1],roots[r],1,N,k));
    }
    
    return 0;
}

int insert(int id,int l,int r,int v)
{
    int idx = ++num;
    buf[idx] = buf[id];
    if(l == r)
    {
        buf[idx].sum = a[l-1].first;
        buf[idx].n = 1;
        return idx;
    }
    int mid = (l + r) / 2;
    if(v <= mid) buf[idx].l = insert(buf[idx].l,l,mid,v);
    else         buf[idx].r = insert(buf[idx].r,mid+1,r,v);
    buf[idx].sum = (buf[buf[idx].l].sum + buf[buf[idx].r].sum) % MOD;
    buf[idx].n = buf[buf[idx].l].n + buf[buf[idx].r].n;
    return idx;
}

long long query(int lr,int rr,int l,int r,int k)
{
    if(l == r)
        return buf[rr].sum - buf[lr].sum;
    int mid = (l + r) / 2;
    int left = buf[buf[rr].l].n - buf[buf[lr].l].n;
    if(left >= k)
        return query(buf[lr].l,buf[rr].l,l,mid,k);
    else
        return (buf[buf[rr].l].sum - buf[buf[lr].l].sum + MOD + query(buf[lr].r,buf[rr].r,mid+1,r,k-left)) % MOD;
}