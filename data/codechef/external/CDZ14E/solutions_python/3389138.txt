import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Main {
	static InputStream is;
	static PrintWriter out;
//	static String INPUT = "5 9 3 5 3 1 2 1 3 2 2 5 3";
	static String INPUT = "";
	
	static void solve()
	{
		int n = ni();
		int[] a = na(n);
		int Q = ni();
		Node[] entry = new Node[n+1];
		entry[0] = buildPBST(a);
		for(int i = 0;i < n;i++){
			entry[i+1] = entry[i].clone().insert(a[i]);
		}
		
		for(int i = 0;i < Q;i++){
			int l = ni()-1, r = ni()-1, K = ni();
			
			Node X = entry[l], Y = entry[r+1];
			long alsum = 0;
			while(K > 0){
//				tr(K, X.des, Y.des, X.num, Y.num, X.count, Y.count, X.sum, Y.sum);
				Node XL = X.left, YL = Y.left;
				if(XL != null && K < YL.des - XL.des){
					X = XL; Y = YL;
				}else{
					if(XL != null){
						K -= YL.des - XL.des;
						alsum += YL.sum - XL.sum;
					}
					if(K < Y.count - X.count){
						alsum += (long)Y.num * K;
						break;
					}else{
						alsum += (long)Y.num * (Y.count - X.count);
						K -= Y.count - X.count;
						X = X.right; Y = Y.right;
					}
				}
			}
			out.println(alsum % 1000000007);
		}
	}
	
		public static class Node
		{
			public int num;
			public int count;
			public int des;
			public long sum;
			public Node left, right;
			
			public Node(int num, int count, long sum) {
				this.num = num;
				this.count = count;
				this.sum = sum;
				des = count;
			}
			
			public Node clone()
			{
				Node ret = new Node(num, count, sum);
				ret.left = this.left;
				ret.right = this.right;
				return ret;
			}
			
			public void update()
			{
				des = count;
				sum = (long)num * count;
				if(left != null){
					des += left.des;
					sum += left.sum;
				}
				if(right != null){
					des += right.des;
					sum += right.sum;
				}
			}
			
			public Node insert(int x)
			{
				if(x < num){
					left = left.clone();
					left.insert(x);
				}else if(x > num){
					right = right.clone();
					right.insert(x);
				}else{
					count++; // e is always cloned.
				}
				update();
				return this;
			}
			
			public Node erase(int x)
			{
				if(x < num){
					left = left.clone();
					left.erase(x);
				}else if(x > num){
					right = right.clone();
					right.erase(x);
				}else{
					count--; // e is always cloned.
				}
				update();
				return this;
			}
			
			public Node search(int x)
			{
				if(x < num){
					return left != null ? left.search(x) : null;
				}else if(x > num){
					return right != null ? right.search(x) : null;
				}else{
					return this;
				}
			}
			
			// floor, ceilで制限はできない。初期値null, null
			// NOT VERIFIED
			public Node[] fc(int x, Node floor, Node ceil)
			{
				if(x < num){
					if(left == null)return new Node[]{floor, this};
					return left.fc(x, floor, this);
				}else if(x > num){
					if(right == null)return new Node[]{this, ceil};
					return right.fc(x, this, ceil);
				}else{
					return new Node[]{this, this};
				}
			}
			
			public List<int[]> list()
			{
				List<int[]> ret = new ArrayList<int[]>();
				if(left != null){
					ret.addAll(left.list());
				}
				ret.add(new int[]{num, count, des});
				if(right != null){
					ret.addAll(right.list());
				}
				return ret;
			}

			@Override
			public String toString() {
				StringBuilder builder = new StringBuilder();
				builder.append("Node [num=");
				builder.append(num);
				builder.append(", count=");
				builder.append(count);
				builder.append(", des=");
				builder.append(des);
				builder.append(", left=\n");
				builder.append(left);
				builder.append("\n, right=\n");
				builder.append(right);
				builder.append("\n]");
				return builder.toString();
			}
			
			public String toString(String indent) {
				StringBuilder builder = new StringBuilder();
				builder.append("[num=");
				builder.append(num);
				builder.append(", count=");
				builder.append(count);
				builder.append(", des=");
				builder.append(des);
				builder.append(", sum=");
				builder.append(sum);
				builder.append("]\n");
				if(left != null){
					builder.append(left.toString(indent + "  "));
				}
				if(right != null){
					builder.append(right.toString(indent + "  "));
				}
				return builder.toString();
			}
		}
		
		public static Node buildPBST(int[] oa){
			int n = oa.length;
			int[] a = Arrays.copyOf(oa, n);
			Arrays.sort(a);
			int[] b = new int[n];
			int p = 0;
			for(int i = 0;i < n;i++){
				if(i == 0 || a[i] != a[i-1]){
					b[p++] = a[i];
				}
			}
			b = Arrays.copyOf(b, p);
			return dfs(0, p, b);
		}
		
		private static Node dfs(int l, int r, int[] b)
		{
			if(l == r)return null;
			int m = l+r>>>1;
			Node ret = new Node(b[m], 0, 0L);
			ret.left = dfs(l, m, b);
			ret.right = dfs(m+1, r, b);
			return ret;
		}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}
