#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
ll pwr(ll a,ll b,ll mod)
{
  ll ans=1;
  while(b)
  {
    if(b&1)
      ans=(ans*a)%mod;
    a=(a*a)%mod;
    b/=2;
  }
  return ans;
}
ll pwr(ll a,ll b)
{
  ll ans=1;
  while(b)
  {
    if(b&1)
      ans*=a;
    a*=a;
    b/=2;
  }
  return ans;
}
ll gcd(ll a,ll b)
{
  while(b)
    {
      ll temp=a;
      a=b;
      b=temp%b;
    }
  return a;
}
ll lcm(ll a,ll b)
{  
  return (a/gcd(a,b))*b;
}
ll modularInverse(ll a,ll m)
{     
      /*reminder: make sure m is prime*/
      assert(false);
      return pwr(a,m-2,m);
}
const int mod=1000000007;
map<int,int> M;
int a[24234];
int RM[22423];
struct Node
{
  int count;
  ll sum;
  Node *left,*right;
  Node()
  {
 
  }
  Node(int count,ll sum,Node *left,Node *right)
  {
    this->count=count;
    this->sum=sum;
    this->left=left;
    this->right=right;
  }
  Node* insert(int l,int r,int val);
};
Node *root[20001];
Node* Node::insert(int l,int r,int val)
{
 
  if(l<=val && val<=r)
  {
    if(l==r)
    {
      return new Node(this->count+1,(this->sum+RM[val])%mod,root[0],root[0]);
    }
 
    int m=(l+r)/2;
 
    Node *left=this->left->insert(l,m,val);
    Node *right=this->right->insert(m+1,r,val);
 
 
    return new Node(this->count+1,(this->sum+RM[val])%mod,left,right );
  }
 
  return this;
}
 
int query(Node *low,Node *high,int l,int r,int k)
{
  if(l==r)
  {
    // ll ans=high->sum-low->sum;
    // ans%=mod;
    // if(ans<0)
    //   ans+=mod;
    return ((ll)RM[l]*k)%mod;
  }
  
 
  int m=(l+r)/2;
  int inLeft=high->left->count-low->left->count;
  if(inLeft>=k)
    return query(low->left,high->left,l,m,k);
  
  ll sumInLeft=(high->left->sum-low->left->sum)%mod;
 
  if(sumInLeft<0)
    sumInLeft+=mod;
  return (sumInLeft+query(low->right,high->right,m+1,r,k-inLeft))%mod;
}
int main()
{
  root[0]=new Node();
  root[0]->sum=0;
  root[0]->count=0;
  root[0]->left=root[0];
  root[0]->right=root[0];
 
  std::ios::sync_with_stdio(false);
  
  int n;
  cin>>n;
  for(int i=1;i<=n;++i)
    {
      cin>>a[i];
      M[a[i]];
    }
  int lim=0;
  for(map<int,int>::iterator i=M.begin();i!=M.end();++i)
  {
    i->second=lim;
    RM[lim]=i->first;
    ++lim;
  }
 
  for(int i=1;i<=n;++i)
  {
    root[i]=root[i-1]->insert(0,lim-1,M[a[i]]);
  }
  int m;
  cin>>m;
  while(m--)
  {
    int l,r,k;
    cin>>l>>r>>k;
    cout<<query(root[l-1],root[r],0,lim-1,k)<<"\n";
  }
 
 
   
 
 
}  