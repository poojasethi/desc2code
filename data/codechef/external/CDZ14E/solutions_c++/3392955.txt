/*
Ashutosh Singla <ashu1461@gmail.com>
Algorithm:
#tags:
date: Mon Oct 14 14:48:36 IST 2013
*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<algorithm>

using namespace std;
typedef vector<int> vi; 
typedef pair<int,int> ii;
typedef long long LL;
#define FL(a) memset(a, 0, sizeof a);
#define fill(a,v,N) memset(a, v, sizeof(a[0])*N)
#define sz(a) int((a).size()) 
#define pb push_back 
#define si(n) scanf("%d",&n)
#define sin(n) scanf("%d\n",&n) // for scanning strings ..
#define sill(n) scanf("%lld",&n)
#define pi(n) printf("%d\n",n);
#define pill(n) printf("%lld\n",n);
#define pis(n) printf("%d ",n);

#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())  // map and set find .. 
#define cpresent(c,x) (find(all(c),x) != (c).end())  // stl find ..
#define FREP(b) for(int i=0;i<b;i++)
#define FREPr(b) for(int i=b-1;i>=0;i--)
#define REP(a,b,c) for(int a=b;a<c;a++)
#define REPr(a,b,c) for(int a=b;a>b;a--)
#define mp(a,b) make_pair(a,b);
typedef pair<int, int> ii;
#define MAX_S 100007
/*
struct data{
};
bool operator < (const data &a1, const data &a2){
}
*/
LL h[16][20008], n, A[20008];
LL csum[16][20008];
struct node{
    // provide some information about the node.
    int level,lef,ri;
    void merge(node &n1, node& n2, int flag = 0){
        // do the merging
        lef = n1.lef, ri = n2.ri;
        level = n1.level - 1;
        if(flag != 1) return ;
        sort(h[level] + lef, h[level] + ri + 1);
    }
    void split(node &n1, node &n2){
        
    }
    void update(){
        // do stuff ..
    }
    node (int s, int L, int R) : level(s), lef(L), ri(R){}
    node(){}
};
node tree[1<<16];
void Print(){
    for(int i = 0; i < 16; i++){
        for(int j = 1; j <= n; j++){
            cout << h[i][j] << " ";
        }
        cout << endl;
    }
}
void init(int root, int l, int r, int level){
    if(l == r){
        tree[root] = node(level,l,r);
        return;
    }
    int mid = (l + r)/2;
    init(root*2, l, mid, level+1);
    init(root*2 + 1, mid+1, r, level+1);
    tree[root].merge(tree[root*2], tree[root*2 +1], 1);
}
struct info{
    int h,l,r;
    info(int h_, int l_, int r_) : l(l_), r(r_), h(h_) {}
    info() {}
};
vector<info> store;
inline node range_query(int root, int l, int r, int &u, int &v){
    if(u<=l && v >=r){
        store.push_back(info(tree[root].level, tree[root].lef, tree[root].ri));
        return tree[root];
    }
    int mid = (l+r)/2;
    tree[root].split(tree[2*root], tree[2*root+1]);
    if(v <= mid) return range_query(root*2, l, mid, u, v);
    if(u > mid) return range_query(root*2+1, mid+1, r, u, v);
    node n1 = range_query(root*2, l, mid, u, v);
    node n2 = range_query(root*2+1, mid+1, r, u, v);
    tree[root].merge(tree[root*2], tree[root*2 +1]);
    node n;
    n.merge(n1, n2);
//    printf("made of tree ... %d (%d, %d)\n", n.level, n.lef, n.ri);
    return n;
}
const int MOD = 1000000007;
LL solve(int K){
    int sp[store.size() + 1];
    LL ret = 0;
    while(K>0){
        int id = -1, maxd = -1; // id of the maximum element;
        for(int i = 0; i < store.size(); i++){
            if(store[i].r - store[i].l + 1 > maxd){
                maxd = store[i].r - store[i].l + 1;
                id = i;
            }
        }
        if(maxd == 1){
            vector<int> ans;
            for(int i = 0; i < store.size(); i++){
                if(store[i].l <= store[i].r)
                ans.push_back(h[store[i].h][store[i].r]);
            }
            sort(ans.begin(), ans.end());
            for(int i = 0; i < K; i++){
                ret += ans[i];
                ret %= MOD;
            }
            return ret;
        }

        int mid = (store[id].r + store[id].l)/2;
        int md = mid;
        mid = h[store[id].h][mid];
        int M = 0;
        for(int i = 0; i < store.size(); i++){
            sp[i] = upper_bound(h[store[i].h] + store[i].l, h[store[i].h] + store[i].r+1, mid) - h[store[i].h];
            int x = sp[i] - store[i].l;
            sp[i]--;
            M += x;
        }
//        M -= (sp[id] - mid - 1);
  //      sp[id] = mid + 1;
        int prev = store[id].r;
        if(K < M){
            for(int i = 0; i < store.size(); i++){
                store[i].r = sp[i];
            }
            if(store[id].r == prev) store[id].r--;
        }
        if(K >= M){
            for(int i = 0; i < store.size(); i++){
                ret += (csum[store[i].h][sp[i]] - csum[store[i].h][store[i].l-1]);
                ret = (ret + MOD)%MOD;
                store[i].l = sp[i]+1;
            }
            K = K-M;
        }
  //      return 0;
    }
    return ret;
}
int main()
{ 
    sill(n);
    REP(i,1,n+1){
        cin >> A[i];
        REP(j,0,16){
            h[j][i] = A[i];
        }
    } // ok let us copy ... !
    init(1,1,n,0);
  //  Print();
    REP(j,0,16){
        REP(i,1,n+1){
            csum[j][i] = ((csum[j][i-1] + h[j][i]) + MOD)%MOD;
        }
    }
    int q,l,r,k;
    si(q);
    while(q--){
        si(l);si(r);si(k);
        store.clear();
        range_query(1,1,n,l,r);
//        solve(k);
        LL d = solve(k);
        d = (d  + MOD)%MOD;
        printf("%lld\n",d);
    }
    return 0;
}
