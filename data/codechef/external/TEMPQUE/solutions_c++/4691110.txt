#include <bits/stdc++.h>
using namespace std;

/* Uzumaki Naruto */
#define TRACE

#ifdef TRACE
#define trace(a,n)   for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << endl;
#define dbg(args...) {debug,args; cerr<<endl;}
#define pause()      cin.get();cin.get();

#else
#define trace(a,n)
#define dbg(args...)
#define pause()

#endif

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

#define fr first
#define se second
typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int NN = 112345;

int seg[NN],val[NN];
int rnk[NN],pos[NN];

void update(int i,int v){
    for(i += 5; i < NN; i += i&-i)
        seg[i] += v;
}

int query(int i){
    int ans = 0;
    for(i += 5; i > 0; i -= i&-i)
        ans += seg[i];
    return ans;
}

void solve(){
    int n,m,num,type;
    scanf("%d%d",&n,&m);

    vector<pii> temp;
    for(int i = 0; i < n; ++i){
        scanf("%d",&num);
        temp.push_back(make_pair(num,i));
    }

    sort(temp.begin(),temp.end());
    for(int i = 0; i < n; ++i){
        int x = temp[i].fr, v = temp[i].se;
        rnk[v] = i, pos[i] = v, val[i] = x;
    }

    for(int i = 0; i < m; ++i){
        scanf("%d%d",&type,&num);
        if (type == 2){
            int st = 0, en = n-1;
            while(st < en){
                int mid = (st+en)/2;
                int v = val[mid] - query(mid);
                if (v >= num) en = mid;
                else st = mid+1;
            }

            en += ((val[en]-query(en)) < num);
            printf("%d\n",n-en);
            //dbg("query",en,pos[en],val[en],query(en));

        } else if (type == 1){
            int st = 0, en = n-1;
            int ind = rnk[--num], v = val[ind];
            v -= query(ind);

            while(st < en){
                int mid = (st+en)/2 + 1;
                int tv = val[mid] - query(mid);
                if (tv <= v) st = mid;
                else en = mid-1;
            }

            int ti = pos[st];
            // swap positions and increment value
            rnk[ti] = ind, rnk[num] = st;
            pos[ind] = ti, pos[st] = num;
            ++val[st];
            //dbg(val[st]-query(st),st,ti);

        } else {
            int st = 0, en = n-1;
            while(st < en){
                int mid = (st+en)/2;
                int v = val[mid]-query(mid);
                if (v >= num) en = mid;
                else st = mid+1;
            }

            en += ((val[en]-query(en)) < num);
            update(en,1);
            //dbg("rng",en,pos[en],val[en],query(en));
        }
    }
}

int main()
{
    solve();
    return 0;
}
