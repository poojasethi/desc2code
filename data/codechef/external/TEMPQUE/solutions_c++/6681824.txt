#include<bits/stdc++.h>
using namespace std;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar_unlocked();
    }
    return x;
}
#define mp make_pair
#define pb push_back
#define author rajat1603
#define mod 1000000007
#define N 100011
int segtree[N<<2]={0};
int posintree[N]={0};
int n;
int q;
pair<int,int> p[N];
int ind[N];
int pos[N];
void build(int l,int r,int node){
    if(l==r){
        posintree[l]=node;
        segtree[node]=p[l].first-p[l-1].first;
        return ;
    }
    int mid = (l+r)>>1;
    int lc = node<<1;
    int rc = lc|1;
    build(l,mid,lc);
    build(mid+1,r,rc);
    segtree[node]=segtree[lc]+segtree[rc];
}
void update(int idx,int val){
    if(idx>n||idx<1){
        return;
    }
    int x=posintree[idx];
    while(x){
        segtree[x]+=val;
        x>>=1;
    }
}
int sum(int l,int r,int node,int ql,int qr){
    if(l>qr||r<ql){
        return 0;
    }
    if(l>=ql&&r<=qr){
        return segtree[node];
    }
    int mid = (l+r)>>1;
    int lc = node<<1;
    int rc = lc|1;
    return sum(l,mid,lc,ql,qr)+sum(mid+1,r,rc,ql,qr);
}
int query(int idx){
    return sum(1,n,1,1,idx);
}
int lowerbound(int val){
    int l=1,r=n,node=1;
    if(segtree[1]<val){
        return n+1;
    }
    while(l<r){
        int lc = node<<1;
        int rc = lc|1;
        int mid =(l+r)>>1;
        if(segtree[lc]>=val){
            node=lc;
            r=mid;
        }
        else{
            val-=segtree[lc];
            node = rc;
            l = mid+1;
        }
    }
    return l;
}
int main(){
	n=scan(),q=scan();
    for(int i=1;i<=n;++i){
        p[i].first=scan();
        p[i].second=i;
    }
    sort(p+1,p+1+n);
    for(int i=1;i<=n;++i){
        ind[p[i].second]=i;
        pos[i]=p[i].second;
    }
    p[0].first=0;
    build(1,n,1);
    while(q--){
        int type=scan(),x=scan();
        if(type==1){
            int y = query(ind[x]);
            int z = pos[lowerbound(y+1)-1];
            swap(ind[x],ind[z]);
            pos[ind[x]]=x;
            pos[ind[z]]=z;
            update(ind[x],1);
            update(ind[x]+1,-1);
        }
        else if(type==2){
            printf("%d\n",n+1-lowerbound(x));
        }
        else{
            update(lowerbound(x),-1);
        }
    }
}