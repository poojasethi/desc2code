#include <cstdio>

#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> II;

typedef vector<int> VI;
typedef vector<VI> VVI;

#define HIGHESTSETBIT(mask) ( sizeof(int)*8-1-__builtin_clz((mask)) )

// Linear
class BinaryIndexedTree {
   VI tree;
   int N;
public:
   BinaryIndexedTree(int _N) : N(_N), tree(VI(_N+1)) {}
   int get_cumfreq(int idx) {
      int sum = 0;
      for (; idx > 0; idx -= (idx & -idx))
         sum += tree[idx];
      return sum;
   }

   void update(int idx, int val = 1) {
      for (; idx <= N; idx += (idx & -idx))
         tree[idx] += val;
   }

/*
   int get_freq(int idx) {
      if (idx <= 0) return 0;

      int sum = tree[idx];
      int z = idx - (idx & -idx);
      for (--idx; idx != z; idx -= (idx & -idx))
         sum -= tree[idx];
      return sum;
   }
*/

   // find (lowest) index with cumulative frequency >= cumfreq
   int lower_bound(int cumfreq) {
      int idx = 0;
      for (int mask = 1<<HIGHESTSETBIT(N); mask != 0 && idx < N; mask >>= 1) {
         int tidx = idx | mask;
         if (tidx > N) continue;
         if (cumfreq > tree[tidx]) { 
            idx = tidx; 
            cumfreq -= tree[tidx];
         }
      }
      return idx+1;
   }

};

#define MAXN 100004

II Qs[MAXN];
int pos[MAXN]; // pos[q] = index in the sorted array where queue 'q' is

int main(int argc, char* argv[]) {
   int N, Q;
   scanf("%d %d", &N, &Q);
   for (int i = 1; i <= N; ++i) {
      scanf("%d", &Qs[i].first);
      Qs[i].second = i;
   }
   Qs[0] = II(0, 0);

   sort(Qs, Qs+N+1);
   for (int i = 0; i <= N; ++i)
      pos[ Qs[i].second ] = i;

   BinaryIndexedTree bit(N);
   for (int i = 1; i <= N; ++i)
      bit.update(i, Qs[i].first - Qs[i-1].first);

   while (Q-- > 0) {
      int cmd, param;
      scanf("%d %d", &cmd, &param);
      switch (cmd) {
         case 1: {
            int i = pos[param];
            int sz = bit.get_cumfreq(i);
            int j = bit.lower_bound(sz+1)-1;
            int q = Qs[j].second;
            pos[param] = j;
            pos[q] = i;
            swap(Qs[i], Qs[j]);
            bit.update(j, 1);
            bit.update(j+1, -1);
            break;
         }
         case 2:
            printf("%d\n", N + 1 - bit.lower_bound(param));
            break;
         case 3: {
            int y = bit.lower_bound(param);
            bit.update(y, -1);
            break;
         }
      }
   }
   return 0;
}
