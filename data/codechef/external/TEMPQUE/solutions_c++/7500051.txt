/* Author : RISHAV GOYAL */

#include <bits/stdc++.h> // sherlock holmes
using namespace std;

#define LL long long int
#define UL unsigned long long int

#define imax INT_MAX
#define imin INT_MIN
#define LLmax LLONG_MAX
#define LLmin LLONG_MIN

#define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++)
#define rep(i,n) for(int i= int(1); i<= (int)n; i++)
#define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)

#define pr() printf("Reached here 1...\n");
#define pr1() printf("Reached here 2...\n");

#define CLR(a) memset(a,0,sizeof(a));
#define SET(a) memset(a,-1,sizeof(a));

#define str strlen
#define sz size()
#define pb(x) push_back(x)
#define mp make_pair
#define ii pair<int,int>
#define ll pair<LL,LL>

#define F first
#define S second
#define gcd(a,b) __gcd(a,b)

#define mod int(1e9 + 7)
#define MAX int(1e5 + 10)

#define si(a) scanf("%d",&a);

#define VI vector<int>
#define VL vector<LL>
#define VS vector<string>
#define VC vector<char>

LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}

#define gc getchar_unlocked
void sint(int &x)
{
	register int c = gc();
	x = 0;
	for(;(c<48 || c>57);c = gc());
	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}


int a[MAX],ind[MAX],seg[2*MAX]={0};
vector<ii> v;

int MaxVal;

void update(int idx ){
	while (idx <= MaxVal){
		seg[idx] ++;
		idx += (idx & -idx);
	}
}

int read(int idx){
	int sum = 0;
	while (idx > 0){
		sum += seg[idx];
		idx -= (idx & -idx);
	}
	return sum;
}

int over = 0;

int main()
{
	int n,Q;
	sint(n); sint(Q);
	MaxVal = n;
	v.pb(mp(0,0));
	rep(i,n) {
		sint(a[i]);
		v.pb(mp(a[i],i));
	}
	sort(v.begin()+1, v.end());
	for(int i=1;i<=n;++i){
		ind[v[i].S] = i;
	}
	int mxQ = v[n].F, med, mxid,id,c,it,f,m,A,X,Y,mxmed,qtype;

	while( Q--){
		sint(qtype);
		if(qtype == 1){ // add +1 to A queue.
			sint(A);
			id = ind[A];
			med = read(n) - read(id-1);		// query(1,1,n,id,0);
			c = med + v[id].F + over;

			it = 1, f = n;
			while( it !=f){
				m = (it+f)/2;
				if( read(n)-read(m) + v[m+1].F + over <= c) it = m+1;
				else f = m;
			}
			mxid = f;
			if( mxid == id){
				if(id == n) mxQ++;
				v[id].F++;
				continue;
			}

			mxmed = read(f);		//query(1,1,n,f,0);
			swap( ind[v[mxid].S] , ind[v[id].S]);
			swap( v[id].S, v[mxid].S);
			v[mxid].F++;
			mxQ = read(n) - read(n-1) + over + v[n].F;
		}
		else if(qtype == 2){ // print number of Q has >= X.
			sint(X);
			if( mxQ < X){
				printf("0\n");
				continue;
			}
			it = 1, f = n;
			while( it != f){
				m = (it+f)/2;
				if( read(n)-read(m-1) + v[m].F + over>= X) f = m;
				else it = m +1;
			}
			printf("%d\n", n - f + 1);
		}
		else{ // Open the door.
			sint(Y);
			if( mxQ < Y)continue;
			it = 1, f = n;
			while( it != f){
				m = (it+f)/2;
				if( read(n)-read(m-1) + v[m].F + over >= Y) f = m;
				else it = m+1;
			}
			if(f>1) {
				update(f-1);
			}
			mxQ--;
			over--;
		}
	}

	return 0;
}
