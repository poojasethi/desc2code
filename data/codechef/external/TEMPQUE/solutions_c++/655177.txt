#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<algorithm>
#include<string.h>
#include<utility>
#include<vector>
#include<map>
#include<queue>
#include<set>
#define MAX 1000100

using namespace std;

typedef long long ll;



int getint()
{
    int i;
    scanf("%d",&i);
    return i;
}

long long getll()
{
    long long a;
    scanf("%lld",&a);
    return a;
}

typedef pair<int,int> my_pair;

bool comp(const my_pair& left, const my_pair& right)
{
    return left.first < right.first;
}


int n,q;
int qu[MAX];
vector<pair<int,int> > qup;
int bit[MAX];
int mymap[MAX];
int who[MAX];
int op,x;


int query(int i)
{
    int sum=0;

    while(i>0)
    {
        sum+=bit[i];
        i-=(i&(-i));
    }
    return sum;
}

int lower_bound(int val)
{
    int l,h,mid;
    int temp;
    l=0;h=n;

    if(query(n)<val) return n+1;

    while(l+1<h)
    {
        mid=(l+h)/2;
        //printf("mid- %d\n",mid);
        temp = query(mid);
        if( temp >= val)
        {
            h=mid;
        }
        else if(temp < val)
        {
            l=mid;
        }
    }
    return h;

}


void update(int i,int val)
{
    while(i<=n)
    {
        bit[i]+=val;
        i+=i&(-i);
    }
}

int main()
{
    n = getint();
    q = getint();

    for(int i=0;i<n;i++)
    {
        qu[i]=getint();
        qup.push_back(pair<int,int>(qu[i],i));
    }

    sort(qup.begin(),qup.end(),comp);

    int prev=0;

    for(int i=0;i<n;i++)
    {
        int temp = qup[i].second;
        qu[i]=qup[i].first;
        mymap[temp]=i+1;
        who[i+1]=temp;
        update(i+1,qu[i]-prev);
        prev=qu[i];
    }

    //for(int i=0;i<n;i++)
      //  printf("bit-%d\n",bit[i+1]);

    int temp,temp1;

    for(int i=0;i<q;i++)
    {
        op=getint();
        x=getint();

        if(op==1)
        {
            temp = x;

            x=mymap[x-1];

            temp1 = lower_bound(query(x)+1)-1;
            update(temp1,1);

            int t=who[temp1];

            if(temp1+1 <= n)
            {
                update(temp1+1,-1);
            }
            mymap[temp-1]=temp1;
            who[temp1]=temp-1;
            mymap[t]=x;
            who[x]=t;
        }
        else if(op==2)
        {
            temp = lower_bound(x);
            printf("%d\n",n-temp+1);
        }
        else if(op==3)
        {
            temp = lower_bound(x);
            //printf("op3 - %d\n",temp);
            update(temp,-1);

        }
        else if(op==4)
        {
            temp = query(x);
            printf("%d\n",temp);
        }
    }

    return 0;
}
