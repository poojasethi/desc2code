#include <cstdio>
#include <algorithm>
#include <utility>
 
#define MAXN 100100
#define INF 100000000
 
using namespace std;
 
struct node {
	int maxim, flag;
};
 
typedef pair< int, int > pii;
 
node segtree[ 4*MAXN + 1 ];

inline int readint() {
    int n = 0;
    char c = getchar_unlocked();
    while ( !( '0' <= c && c <= '9' ) ) {
        c = getchar_unlocked();
    }
    while ( '0' <= c && c <= '9' ) {
        n = n * 10 + c - '0';
        c = getchar_unlocked();
    }
    return n;
}

void unflag( int, int ,int );

void init( int n, int l, int r, int* A )
{
	if( l == r ) {
		segtree[ n ].maxim = A[ l ];
		segtree[ n ].flag = 0;
	} else {
		init( 2*n, l, ( l + r ) / 2, A );
		init( 2*n + 1, ( l + r ) / 2 + 1, r, A );
		segtree[ n ].maxim = max( segtree[ 2*n ].maxim, segtree[ 2*n + 1 ].maxim );
		segtree[ n ].flag = 0;
	}
}

void update( int n, int l, int r, int i, int j, int v )
{
	if( l == i && j == r ) {
		segtree[ n ].flag += v;
		segtree[ n ].maxim += v;
		return;
	}
	unflag( n, l, r );
	if( j <= ( l + r ) / 2 ) {
		update( 2*n, l, ( l + r ) / 2, i, j , v );
	}
	else if( i > ( l + r ) / 2 ) {
		update( 2*n + 1, ( l + r ) / 2 + 1, r, i, j, v );
	} else {
		update( 2*n, l, ( l + r ) / 2, i , ( l + r ) / 2, v );
		update( 2*n + 1, ( l + r ) / 2 + 1, r, ( l + r ) / 2 + 1, j, v );
	}
	segtree[ n ].maxim = max( segtree[ 2*n ].maxim, segtree[ 2*n + 1 ].maxim );
}

void unflag( int n, int l, int r )
{
	if( segtree[ n ].flag != 0 ) {
		int v = segtree[ n ].flag;
		segtree[ 2*n ].maxim += v;
		segtree[ 2*n + 1 ].maxim += v;
		segtree[ 2*n ].flag += v;
		segtree[ 2*n + 1 ].flag += v;
		segtree[ n ].flag = 0;
	}
}
 
int query( int n, int l, int r, int node )
{
	if( l == r ) {
		return segtree[ n ].maxim;
	}
	unflag( n, l, r );
	if( node <= ( l + r ) / 2 ) {
		return query( 2*n, l, ( l + r ) / 2, node );
	} else {
		return query( 2*n + 1, ( l + r ) / 2 + 1, r, node );
	}
}
 
int leftmost( int n, int l, int r, int X, int N )
{
	if( l == r ) {
		if( segtree[ n ].maxim >= X ) {
			return l;
		}
		return N + 1;
	}
	unflag( n, l, r );
	if( segtree[ 2*n ].maxim >= X ) {
		return leftmost( 2*n, l, ( l + r ) / 2, X, N );
	} else {
		return leftmost( 2*n + 1, ( l + r ) / 2 + 1, r, X, N );
	}
}

int rightmost( int n, int l, int r, int X )
{
	if( l == r ) {
		if( segtree[ n ].maxim == X ) {
			return l;
		}
		return l - 1;
	}
	unflag( n, l, r );
	if( segtree[ 2*n ].maxim > X ) {
		return rightmost( 2*n, l, ( l + r ) / 2, X );
	} else {
		return rightmost( 2*n + 1, ( l + r ) / 2 + 1, r , X );
	}
}

int main( void )
{
	int N,Q;
	N = readint();
	Q = readint();
	pii AA[ N + 1 ];
	for( int i = 1; i <= N; i++ ) {
		int k;
		k = readint();
		AA[ i ] = make_pair( k, i );
	}
	int A[ N + 1 ], idxi[ N + 1 ], idxii[ N + 1 ];
	sort( AA + 1, AA + N + 1 );
	for( int i = 1; i <= N; i++ ) {
		A[ i ] = AA[ i ].first;
		idxi[ AA[ i ].second ] = i;
		idxii[ i ] = AA[ i ].second;
	}	
	// idxii[ u ] gives the index of the element in pos u in the original array
	// idxi[ u ] gives the position of the element with index u in the sorted array
	init( 1, 1, N, A );
	while( Q-- ) {
		int q, u;
		q = readint();
		u = readint();
		if( q == 1 ) {
			int q1, pos;
			q1 = query( 1, 1, N, idxi[ u ] );
			pos = rightmost( 1, 1, N, q1 );
			int prev = idxi[ u ];
			if( pos != idxi[ u ] ) {
				swap( idxii[ pos ], idxii[ idxi[ u ] ] );
				idxi[ idxii[ idxi[ u ] ] ] = prev;
				idxi[ u ] = pos;
			}
			update( 1, 1, N, idxi[ u ], idxi[ u ], 1 );
		}
		else if( q == 2 ) {
			int pos = leftmost( 1, 1, N, u, N );
			printf("%d\n", N - pos + 1 );
		}
		else if( q == 3 ) {
			int pos = leftmost( 1, 1, N, u, N );
			if( pos <= N ) {
				update( 1, 1, N, pos, N, -1 );
			}
		}
	} 
	return 0;
}
