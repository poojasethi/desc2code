#include<iostream>
#include<cstdio>
#include<list>
#define inf 1000000000
#define MIN(a,b) ((a<=b)?a:b)
using namespace std;
int dist[1001][1001];
bool visited[1001][1001];
char arr[1001][1001];
struct node
{
    int x;
    int y;
};
void bfs(int dist[][1001],bool visited[][1001],char arr[][1001],int n,int m,list<struct node>&adj)
{
    struct node *temp;
    struct node z;
    char ch;
    int i,j,k,p,q,r;
    temp=new node;
    temp->x=0;
    temp->y=0;
    adj.push_back(*temp);
    while(!adj.empty())
    {
        z=adj.front();
        adj.pop_front();
        p=z.x;
        q=z.y;
        ch=arr[p][q];
        r=dist[p][q];
        if(p-1>=0&&ch=='0')
        {
            if(!visited[p-1][q]&&arr[p-1][q]=='1')
            {
                visited[p-1][q]=true;
                temp=new struct node;
                temp->x=p-1;
                temp->y=q;
                adj.push_back(*temp);
                dist[p-1][q]=MIN(dist[p-1][q],r+1);
            }
            else if(visited[p-1][q]&&arr[p-1][q]=='1')
            {
                dist[p-1][q]=MIN(r+1,dist[p-1][q]);
            }
        }
        if(p-1>=0&&ch=='1')
        {
            if(!visited[p-1][q]&&arr[p-1][q]=='0')
            {
                visited[p-1][q]=true;
                temp=new struct node;
                temp->x=p-1;
                temp->y=q;
                adj.push_back(*temp);
                dist[p-1][q]=MIN(dist[p-1][q],r+1);
            }
            else if(visited[p-1][q]&&arr[p-1][q]=='0')
            {
                dist[p-1][q]=MIN(r+1,dist[p-1][q]);
            }
        }
        if(p+1<=n-1&&ch=='0')
        {
            if(!visited[p+1][q]&&arr[p+1][q]=='1')
            {
                visited[p+1][q]=true;
                temp=new struct node;
                temp->x=p+1;
                temp->y=q;
                adj.push_back(*temp);
                dist[p+1][q]=MIN(dist[p+1][q],r+1);
            }
            else if(visited[p+1][q]&&arr[p+1][q]=='1')
            {
                dist[p+1][q]=MIN(r+1,dist[p+1][q]);
            }
        }
        if(p+1<=n-1&&ch=='1')
        {
            if(!visited[p+1][q]&&arr[p+1][q]=='0')
            {
                visited[p+1][q]=true;
                temp=new struct node;
                temp->x=p+1;
                temp->y=q;
                adj.push_back(*temp);
                dist[p+1][q]=MIN(dist[p+1][q],r+1);
            }
            else if(visited[p+1][q]&&arr[p+1][q]=='0')
            {
                dist[p+1][q]=MIN(r+1,dist[p+1][q]);
            }
        }
        if(q-1>=0&&ch=='0')
        {
            if(!visited[p][q-1]&&arr[p][q-1]=='1')
            {
                visited[p][q-1]=true;
                temp=new struct node;
                temp->x=p;
                temp->y=q-1;
                adj.push_back(*temp);
                dist[p][q-1]=MIN(dist[p][q-1],r+1);
            }
            else if(visited[p][q-1]&&arr[p][q-1]=='1')
            {
                dist[p][q-1]=MIN(r+1,dist[p][q-1]);
            }
        }
        if(q-1>=0&&ch=='1')
        {
            if(!visited[p][q-1]&&arr[p][q-1]=='0')
            {
                visited[p][q-1]=true;
                temp=new struct node;
                temp->x=p;
                temp->y=q-1;
                adj.push_back(*temp);
                dist[p][q-1]=MIN(dist[p][q-1],r+1);
            }
            else if(visited[p][q-1]&&arr[p][q-1]=='0')
            {
                dist[p][q-1]=MIN(r+1,dist[p][q-1]);
            }
        }
        if(q+1<=m-1&&ch=='0')
        {
            if(!visited[p][q+1]&&arr[p][q+1]=='1')
            {
                visited[p][q+1]=true;
                temp=new struct node;
                temp->x=p;
                temp->y=q+1;
                adj.push_back(*temp);
                dist[p][q+1]=MIN(dist[p][q+1],r+1);
            }
            else if(visited[p][q+1]&&arr[p][q+1]=='1')
            {
                dist[p][q+1]=MIN(r+1,dist[p][q+1]);
            }
        }
        if(q+1<=m-1&&ch=='1')
        {
            if(!visited[p][q+1]&&arr[p][q+1]=='0')
            {
                visited[p][q+1]=true;
                temp=new struct node;
                temp->x=p;
                temp->y=q+1;
                adj.push_back(*temp);
                dist[p][q+1]=MIN(dist[p][q+1],r+1);
            }
            else if(visited[p][q+1]&&arr[p][q+1]=='0')
            {
                dist[p][q+1]=MIN(r+1,dist[p][q+1]);
            }
        }
    }
}
int main(void)
{
    int i,j,k,n,m,t;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        for(i=0;i<=n-1;i++)
            scanf("%s",arr[i]);
        for(i=0;i<=n-1;i++)
        {
            for(j=0;j<=m-1;j++)
            {
                dist[i][j]=inf;
                visited[i][j]=false;
            }
        }
        list<struct node>adj;
        dist[0][0]=1;
        bfs(dist,visited,arr,n,m,adj);
        if(dist[n-1][m-1]>=inf)
            printf("-1\n");
        else
            printf("%d\n",dist[n-1][m-1]);
    }
    return 0;
}
