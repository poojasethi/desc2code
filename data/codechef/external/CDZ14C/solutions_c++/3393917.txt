#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
long op[1005][1005];
vector <string> maze;

int dy[]={0,1,-1,0};
int dx[]={1,0,0,-1};
void bfs(int n,int m)
{
   int i;
   queue < pair <int,int> > q;
   q.push(make_pair(0,0));
   while(!q.empty())
   {
      int x = q.front().first;
		int y = q.front().second;
		q.pop();              
     for(i=0;i<4;i++)                 
      {
          int x1=x+dx[i];                            
          int y1=y+dy[i];
          if(x1 >=0 && x1 <n && y1 >=0 && y1 <m)
          {
          if(maze[x][y]!=maze[x1][y1])  
          {
          if(op[x][y]+1<op[x1][y1])  
          {                            
            op[x1][y1]=op[x][y]+1;    
            q.push(make_pair(x1,y1));  
          }                        
          }                                 
          }                                     
      }                                            
   
   }              
     
}     
int main()
{
 int t,n,m,i,j;
 string str;
 scanf("%d",&t);   
    while(t--)
    {
    scanf("%d%d",&n,&m);          
     for(i=0;i<n;i++) 
     {
       cin>>str;
       maze.push_back(str);
     }
     
     for(i=0;i<n;i++)
      for(j=0;j<m;j++)   
        op[i][j]=10000000;
        
        op[0][0]=1;
        
        bfs(n,m);
      /*  for(i=0;i<n;i++)
         for(j=0;j<m;j++)
           {
           if(j+1<m && maze[i][j]!=maze[i][j+1])   
           {
           if(op[i][j]+1<op[i][j+1])      
           op[i][j+1]=op[i][j]+1;                         
           }  
            if(i+1<n && maze[i][j]!=maze[i+1][j])   
           {
           if(op[i][j]+1<op[i+1][j])      
           op[i+1][j]=op[i][j]+1;                         
           }                                     
                         
           } */
           
           if(op[n-1][m-1]!=10000000)
           cout<<op[n-1][m-1]<<endl;  
           else
           cout<<"-1"<<endl;
           maze.clear();
    }      
    return 0;
}   
