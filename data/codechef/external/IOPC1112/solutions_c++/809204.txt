
#ifndef PROGRAMMING_CONTESTS_H
#define PROGRAMMING_CONTESTS_H
#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>
#ifdef LOCALHOST
static FILE* _freopen=freopen("input.txt","r",stdin);
#else
#define NDEBUG
#endif
#include <cassert>
using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int,int> PII;

#define IT(c) typeof(c.begin())
#define PB push_back
#define MP make_pair
#define LEN(a) (sizeof(a)/sizeof(a[0]))
#define ALL(c) c.begin(),c.end()
#define FOR(i,a,b) for(int i=(a), _b=(b); i<_b; ++i)
#define FORD(i,a,b) for(int i=(b-1), _a=(a); i>=_a; --i)
#define FORE(i,c) for(IT(c) i=(c).begin(); i!=(c).end(); ++i)

static int RI(){int res;int r=scanf("%d ",&res);assert(r==1);return res;}
static LL RLL(){LL res;int r=scanf("%lld ",&res);assert(r==1);return res;}
static ULL RULL(){ULL res;int r=scanf("%llu ",&res);assert(r==1);return res;}
static double RD(){double res;int r=scanf("%lf ",&res);assert(r==1);return res;}
static string RS(){char buf[2000];int r=scanf("%s ",buf);assert(r==1);return string(buf);}
static string RL(){string res;getline(cin,res);assert(cin.good());return res;} //Requires and discards line break at end of line.
static const double PI=acos(-1.0), EPS=1e-10;
template<typename T> static string str(T x){stringstream ss;ss<<x;return ss.str();}
template<typename A,typename V> static void fill(A& a,V v){fill_n((V*)a,sizeof(a)/sizeof(v),v);} // Requires A is a V array.
static double timer(){return 1.0*clock()/CLOCKS_PER_SEC;}

#endif //PROGRAMMING_CONTESTS_H


int n,r,k,m=100000007;
vector<int> a[405];

int mem[405][405][2];

//direct is true iff can use the edge (parent,v)
int f(int parent, int parentI, int k, int direct){
  int v=(parent==-1?1:a[parent][parentI]);
  int& res=mem[v][k][direct];
  if(res!=-1) return res;
  res=0;

  bool hasChild=a[v].size()>0, hasRSib=parent!=-1&&parentI+1<a[parent].size();
  if(!hasChild&&hasRSib){
    res=(res+f(parent,parentI+1,k,direct))%m; //dont use edge
    if(direct&&k>0)res=(res+f(parent,parentI+1,k-1,0))%m; //use edge
  } else if(hasChild&&!hasRSib){
    res=(res+f(v,0,k,1))%m; //dont use edge
    if(direct&&k>0)res=(res+f(v,0,k-1,0))%m; //use edge
  } else if(hasChild&&hasRSib){
    FOR(give,0,k+1){ //how many to give to next sibling?
      int left=k-give;
      res=(res+(LL)f(v,0,left,1)*(LL)f(parent,parentI+1,give,direct))%m; //dont use edge
      if(direct&&left>0)res=(res+(LL)f(v,0,left-1,0)*(LL)f(parent,parentI+1,give,0))%m; //use edge
    }
  } else {
    res=(k==0||k==1&&direct);
  }
    
  return res;
}


int main(int argc, char** argv) {
  FOR(test,0,RI()){
    n=RI(),r=RI(),k=RI();
    FOR(i,1,n+1)a[i].clear();
    fill(mem,-1);
    
    vector<int> t[405];
    FOR(i,0,r){
      int v=RI(),w=RI();
      t[v].PB(w);
      t[w].PB(v);
    }
    
    queue<int> q;
    q.push(1);
    bool seen[405]={0};
    seen[1]=true;
    while(!q.empty()){
      int v=q.front();
      q.pop();
      FOR(i,0,t[v].size()) {
        int c=t[v][i];
        if(!seen[c]){
          seen[c]=true;
          q.push(c);
          a[v].PB(c);
        }
      }
    }
    
    cout<<f(-1,0,k,0)<<endl;
  }
  return 0;
}
