#include <bits/stdc++.h>
#include <fstream>
#define INF 800000000000
#define MOD 1000000007
#define MAXN 100005
#define ins insert
#define pb push_back
#define mp make_pair
#define sz size
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for(int i = a; i < b; ++i)
#define sd(n) scanf("%d",&n)
#define sll(n) scanf("%I64d",&n)
#define pdn(n) printf("%d\n",n)
#define plln(n) printf("%I64d\n",n)
#define pd(n) printf("%d ",n)
#define nl() printf("\n")
using namespace std;
 
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vi> vvi;
typedef vector<vl> vvl;
typedef pair<int, int> pii;
 
namespace patch
{
    template < typename T > std::string to_string( const T& n )
    { 
        std::ostringstream stm ;
        stm << n ;
        stm.str() ;
    }
}
 
ll modpow(ll base, ll exponent, ll modulus)
{
    ll result = 1;
    while (exponent > 0)
    {
        if (exponent % 2 == 1)
            result = (result * base) % modulus;
        exponent = exponent >> 1;
        base = (base * base) % modulus;
    }
    return result;
}
 
ll gcd(ll u, ll v)
{
    return (v != 0) ? gcd(v, u % v) : u;
}
 
ll mulmod(ll a, ll b, ll c){
    ll x = 0, y = a%c;
    while(b > 0){
        if(b%2 == 1){
            x = (x+y) % c;
        }
        y = (y*2) % c;
        b /= 2;
    }
    return x%c;
}
 
const long long MOD2 = static_cast<long long>(MOD) * MOD;
 
struct Matrix
{
    vector< vector<int> > mat;
    int n_rows, n_cols;
 
    Matrix() {}
 
    Matrix(vector< vector<int> > values): mat(values), n_rows(values.size()),
        n_cols(values[0].size()) {}
 
    static Matrix identity_matrix(int n)
    {
        vector< vector<int> > values(n, vector<int>(n, 0));
        for(int i = 0; i < n; i++)
            values[i][i] = 1;
        return values;
    }
 
    Matrix operator*(const Matrix &other) const 
    {
        int n = n_rows, m = other.n_cols;
        vector< vector<int> > result(n_rows, vector<int>(n_cols, 0));
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++) {
                long long tmp = 0;
                for(int k = 0; k < n_cols; k++) {
                    tmp += mat[i][k] * 1ll * other.mat[k][j];
                    while(tmp >= MOD2)
                        tmp -= MOD2;
                }
                result[i][j] = tmp % MOD;
            }
 
        return Matrix(result);
    }
 
    inline bool is_square() const
    {
        return n_rows == n_cols;
    }
};
 
// M_powers[i] is M, raised to 2^i-th power
Matrix M_powers[55];
 
void precalc_powers(Matrix M)
{
    assert(M.is_square());
    M_powers[0] = M;
 
    for(int i = 1; i < 55; i++)
        M_powers[i] = M_powers[i - 1] * M_powers[i - 1];
}
 
Matrix fast_exponentiation_with_precalc(int power)
{
    Matrix result = Matrix::identity_matrix(M_powers[0].mat.size());
    int pointer = 0;
    while(power) {
        if(power & 1)
            result = result * M_powers[pointer];
        pointer++;
        power >>= 1;
    }
    return result;
}
 
int t, n;
map<string, vector<string> > a;
 
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> t;
    rep(test, 0, t) {
        cin >> n;
        a.clear();
        rep(i, 0, n) {
            string x;
            cin >> x;
            string temp = x.substr(x.sz()-3, 3);
            a[temp].pb(x);
            sort(a[temp].begin(), a[temp].end());
        }
        map<string, vector<string> >::iterator it;
        cout << "Case : " << test+1 << '\n';
        for(it = a.begin(); it != a.end(); ++it) {
            vector<string> temp = it->second;
            for(int j = 0; j < temp.sz(); ++j) {
                if(j != temp.sz()-1)
                    cout << temp[j] << " ";
                else
                    cout << temp[j];
            }
            cout << '\n';
        }
    }
    return 0;
}
 
/*f(n) = f(n-1) - f(n-2)
 
[f(n-2) f(n-1)] * M = [f(n-1) f(n)]
 
[f(n-2) f(n-1)] * [x y] = [f(n-1) f(n)]
                  [p q]
 
a*x + b*p = b
x = 0, p = 1 
a*y + b*q = b-a
y = -1, q = 1
[0 -1]
[1  1]
*/
 
/*10 17 7 -10 -17 -7 10
 
23 17 -6 -23 -17*/ 