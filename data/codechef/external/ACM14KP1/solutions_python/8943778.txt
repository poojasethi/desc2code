#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <algorithm>
#include <queue>
#include <stdio.h>
#include <math.h>
using namespace std;

struct po{
	long double x;
	long double y;
};
struct pp{
	long double x;
	long double y;
	int ind;
};
bool operator<(pp a,pp b){
	if(a.y==b.y){
		return a.ind<b.ind;
	}
	return a.y<b.y;
}
bool operator<(po a, po b){
	return a.x<b.x;
}
int T;
int n;
set<pp> pnt;
set<pp>::iterator ii,jj;
po p[100100];

long double dist(int i,int j){
	return sqrt( (p[i].x-p[j].x)*(p[i].x-p[j].x)  + (p[i].y-p[j].y)*(p[i].y-p[j].y));
}
int main(){
	cin>>T;
	cout<<fixed;
	cout.precision(14);
	for(int yy=1;yy<=T;yy++){
		cin>>n;
		pnt.clear();
		for(int i=0;i<n;i++){
			cin>>p[i].x>>p[i].y;
		}
		sort(p,p+n);
		int cur=0;
		long double sol=1000000000;
		for(int i=0;i<n;i++){
			while(p[i].x-p[cur].x>sol/2){
				pp h;
				h.x=p[cur].x;
				h.y=p[cur].y;
				h.ind=cur;
				pnt.erase(h);
				cur++;
			}
			pp h;
			h.y=p[i].y-sol/2;
			h.ind=-1;
			h.x=-1;
			ii=pnt.lower_bound(h);
			for(;ii!=pnt.end();ii++){
				for(jj=ii;jj!=pnt.end();jj++){
					if(ii->ind==jj->ind)continue;
					sol=min(sol,dist(i,ii->ind) + dist(ii->ind,jj->ind) + dist(i,jj->ind) );
				}
			}
			h.y=p[i].y;
			h.x=p[i].x;
			h.ind=i;
			pnt.insert(h);
		}
		cout<<"Case "<<yy<<": "<<sol<<endl;
	}
}