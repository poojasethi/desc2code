#include <stdio.h>
#include <vector>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <cstdio>
#include <map>
#include <string>
#include <iostream>
#include <algorithm>
#include <math.h>
#include <limits.h>
#define llu long long unsigned
#define ld long
#define F first
#define S second
#define ll long long
using namespace std;
#define si(x) scanf("%d",&x)
#define sdb(x) scanf("%lf",&x)
#define sll(x) scanf("%lld",&x)
#define sc(x) scanf("%c",&x)
#define pi(x) printf("%d", x);
#define res 1000000007
const int maxx=101000;
struct node {
	int next[26];
	int len;
	int sufflink;
	int num,counter;
};
std::vector<int> edge[110000];
int len;
char palstr[110000];
node paltree[110000]; 
ll sum[110000];
ll
int num; // Total suffixes added till now		
int suff; //Index of palindrome suffix for the current alphabet to be added
long long ans;
int addletter(int pos)
{
	int cur=suff,curlen=0;
	int let=palstr[pos]-97;
	//cur is the link of current suffix palindome, 
	//so if x if the letter added we need to search of A(which is suffix-palin of cur) such that xA holds
	
	while(1) // In this loop we find A...A can be empty too
	{
		curlen=paltree[cur].len;
		if((pos-curlen-1)>=0&&(palstr[pos-1-curlen]==palstr[pos])) break;
		cur=paltree[cur].sufflink;
	}
	if(paltree[cur].next[let]) // If there is already a link to the next palindrome i.e. if from A link to x is present 
	{
		// Then we just update our current suffix to be xAx
		suff=paltree[cur].next[let];
		paltree[suff].counter++;
		return 0;
	}
	// If no link is present then we need to create a new node
	num++; // Add new node
	suff=num; //Update curr largest pal-suffix
	paltree[num].len=paltree[cur].len+2;
	paltree[cur].next[let]=num;
	paltree[num].counter=1;

	if(paltree[num].len==1)
	{
		paltree[num].sufflink=2;
		edge[2].push_back(num);
		return 1;
	}
	// For creating the suffix link for xAx
	// We need to search for B such that B is largest suffix palin of A and xB holds

	while(1)
	{
		cur=paltree[cur].sufflink;	
		curlen=paltree[cur].len;
		if(((pos-curlen-1)>=0)&&(palstr[pos]==palstr[pos-curlen-1])) 
		{
			paltree[num].sufflink=paltree[cur].next[let];
			break;
		}
	} 
	paltree[num].num=paltree[paltree[num].sufflink].num+1; // Total number of palin suffixes increases by one.
	edge[paltree[num].sufflink].push_back(num);
	return 1;
}
void initpal()
{
	paltree[1].len=-1; //Root node in which next node will be having a single character
	paltree[2].len=0;	//Root node in which next node will be having two characters
	paltree[1].sufflink=1;paltree[2].sufflink=1; //Index of suffix in 	
	num=2;//No of nodes already added in paltree
	suff=2; //Index of latest max suffix palindrome.......here paltree[2]
}
void clear()
{
	for(int i=0;i<maxx;i++)
	{
		paltree[i].len=paltree[i].sufflink=paltree[i].num=paltree[i].counter=0;
		for(int j=0;j<26;j++) paltree[i].next[j]=0;
		edge[i].clear();
		num=suff=ans=len=0;
	}
}
int dfs(int curr,int level)
{
	sum[curr]=0;
	for(int i=0;i<edge[curr].size();i++)
		sum[curr]+=dfs(edge[curr][i],level+1);
	sum[curr]+=paltree[curr].counter;
	sum[curr]%=res;
	return sum[curr];

}
void dfs2(int curr,int summation)
{
	ans+=(summation*sum[curr])%res;
	ans%=res;
	// printf("%lld\n", ans);
	for(int i=0;i<edge[curr].size();i++)
		dfs2(edge[curr][i],(summation+sum[curr])%res);
}
int solve()
{
	scanf("%s",palstr);
	initpal();
	int len=strlen(palstr);
	for(int i=0;i<len;i++)
		addletter(i);
	dfs(2,0);
	sum[2]=0;
	dfs2(2,0);
	printf("%lld\n", ans);
}
int main()
{
	int t;
	solve();
}
