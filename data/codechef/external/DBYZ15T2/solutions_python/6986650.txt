//Dbyz15t2.c
/*

*****************************   Author : Hrishikesh Vaidya  ***************************************

*/		
#include <stdio.h>
#include <vector>
#include <iostream>
#include <queue>
#include <set>
#include <algorithm>
#include <math.h>
#include <string>
#include <cstring>
#include <map>
#include <stack>
using namespace std;
//Input macros
#define si(n) scanf("%d",&n)
#define sc(n) scanf("%c",&n);
#define sl(n) scanf("%lld",&n)
#define sf(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define mem(a,b) memset(a,b,sizeof(a))
#define f(i,a,b) for(ll i=a;i<=b;i++)
#define frev(i,a,b) for(ll i=a;i>=b;i--)
#define maX(a,b) ((a)>(b)?a:b)
#define miN(a,b) ((a)<(b)?a:b)
#define ll long long
#define ld long
#define llu unsigned long long
#define pb push_back
#define gc getchar_unlocked
#define fs first
#define sn second
#define ls (node<<1)
#define rs (node<<1)|1
#define mod 1000000007
//Palindromictree
#define maxn 100005
typedef vector<int> vi;
struct node 
{
    int next[26];
    int len;
    int sufflink;
    int cnt;
};
int A[maxn];
ll ans;
vi edge[maxn];
int len;
string s;
node tree[maxn]; 
int num; 		
int suff;
ll sum[maxn]; 			
bool addLetter(int pos) 
{
    int cur = suff, curlen = 0;
    int let = s[pos] - 'a';
 
    while (true) 
    {
        curlen = tree[cur].len;
        if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos])    	
            break;	
        cur = tree[cur].sufflink;
    }		
    if (tree[cur].next[let]) 
    {	
        suff = tree[cur].next[let];
        tree[suff].cnt++;
        return false;
    }
 
    num++;
    suff = num;
    tree[num].len = tree[cur].len + 2;
    tree[cur].next[let] = num;
    tree[num].cnt=1;
 
    if (tree[num].len == 1) 
    {
        tree[num].sufflink = 2;
        edge[2].push_back(num);
        return true;
    }
 
    while (true) 
    {
        cur = tree[cur].sufflink;
        curlen = tree[cur].len;
        if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos]) 
        {
            tree[num].sufflink = tree[cur].next[let];
            break;
        }    	
    }           
 	//tree[num].cnt = 1 + tree[tree[num].sufflink].cnt;
 	edge[tree[num].sufflink].push_back(num);
    return true;
}
int dfs(int curr)
{
	sum[curr]=0;
	for(int i=0;i<edge[curr].size();i++)
		sum[curr]+=dfs(edge[curr][i]);
	sum[curr]+=tree[curr].cnt;
	sum[curr]%=mod;
	return sum[curr];
}
void dfs2(int curr,int summation)
{
	ans+=(summation*sum[curr])%mod;
	ans%=mod;
	for(int i=0;i<edge[curr].size();i++)
		dfs2(edge[curr][i],(summation+sum[curr])%mod);
} 
void initTree() 
{
 
    num = 2; suff = 2;
    tree[1].len = -1; tree[1].sufflink = 1; tree[1].cnt = 0;
    tree[2].len = 0; tree[2].sufflink = 1; tree[2].cnt = 0;
    for(int i=1; i<=s.size()+2; i++)
        for(int j=0; j<26; j++)
            tree[i].next[j] = 0;
}
void Readinput()
{
	cin>>s;
}
void solve()
{
	int i,j;
	ans=0;
	initTree();
	mem(sum,0);
	for(i=0;i<s.size();i++) addLetter(i);
	dfs(2);
	sum[2]=0;
	dfs2(2,0);
	printf("%lld\n",ans);
}
int main()
{
	Readinput();
	solve();
	return 0;
}