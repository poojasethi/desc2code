//satyaki3794
#include <bits/stdc++.h>
#include <iomanip>
#define ff first
#define ss second
#define pb push_back
#define MOD (1000000007LL)
#define LEFT(n) (2*(n))
#define RIGHT(n) (2*(n)+1)

using namespace std;
typedef long long ll;
typedef pair<int, int> ii;
typedef pair<int, ii> iii;

ll pwr(ll base, ll p, ll mod = MOD){
ll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;
}



char hash_ch(char ch){
	if(ch == 'A')	return 'A';
	if(ch == 'C')	return 'B';
	if(ch == 'T')	return 'C';
	return 'D';
}


struct palin_node{
    int next[26], len, sufflink, halflink;
};


int ticks, suff;
char str[100005];
palin_node tree[400050];
ll cnt[100005];


void init_palindrome_tree(){
    ticks = suff = 2;
    tree[1].len = -1;    tree[1].sufflink = 1;	tree[1].halflink = 1;
    tree[2].len = 0;    tree[2].sufflink = 1;	tree[2].halflink = 1;
}

int get_link(int curr, int pos){
    while(1){
        curr = tree[curr].sufflink;
        int currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos])  break;
    }
    return curr;
}

void add_letter(int pos){

    int currlen, curr = suff, curr2 = suff;
    int ch = str[pos]-'a';

    while(1){
        currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos])  break;
        curr = tree[curr].sufflink;
    }

    if(tree[curr].next[ch] != 0){
        //node already exists
        suff = tree[curr].next[ch];
        return;
    }

    //create new node, by appending ch to both ends of max suffix palindrome
    ticks++;
    suff = ticks;
    tree[ticks].len = tree[curr].len + 2;
    tree[curr].next[ch] = ticks;

    if(tree[ticks].len == 1){
        tree[ticks].sufflink = tree[ticks].halflink = 2;
        return;
    }

    //now find suffix link of the newly created node
    while(1){
        curr = tree[curr].sufflink;
        currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]){
            tree[ticks].sufflink = tree[curr].next[ch];
            break;
        }
    }

    curr = tree[curr2].halflink;
    while(1){
    	currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos] && (tree[tree[curr].next[ch]].len)*2<=tree[ticks].len){
            tree[ticks].halflink = tree[curr].next[ch];
            break;
        }
        curr = tree[curr].sufflink;
    }
}


void print_tree(){
	for(int i=1;i<=ticks;i++){
		cout<<i<<": len = "<<tree[i].len<<" link = "<<tree[i].sufflink<<" halflink = "<<tree[i].halflink;
		cout<<" and next =";
		for(int j=0;j<4;j++)	cout<<" "<<tree[i].next[j];cout<<endl;
	}
	cout<<endl;
}



int main()
{
    // ios_base::sync_with_stdio(0);

    scanf("%s", str);
// cout<<str<<endl;

	init_palindrome_tree();
	for(int i=0;str[i]!='\0';i++){
		add_letter(i);
		cnt[suff]++;
// cout<<"after inserting "<<i<<" suff = "<<suff<<endl;
	}

	// print_tree();

// for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl;


	for(int i=ticks;i>=3;i--)
		cnt[tree[i].sufflink] = (cnt[tree[i].sufflink] + cnt[i]) % MOD;
	cnt[1] = cnt[2] = 0;

// for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl;

	ll ans = 0;
	for(int i=3;i<=ticks;i++){
		ans += cnt[i] * cnt[tree[i].sufflink];
		ans %= MOD;
		cnt[i] += cnt[tree[i].sufflink];
		cnt[i] %= MOD;
	}

	printf("%lld", ans);
    return 0;
}






