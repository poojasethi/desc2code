#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <iostream>

enum type { NOTHING, BASE, PIPUL };

struct cell {
	short x, y;
	int altitude;
	type T;
	bool visited;
};

cell Cells[50][50] = {{{0,0,0,NOTHING,false}}};
std::vector<int> altitudes;

class compareCells {
	bool reverse;
public:
	compareCells(const bool& revparam = true)
	{ reverse = revparam; }
	bool operator() (const cell *A, const cell *B) const {
		if (reverse) return A->altitude > B->altitude;
		else return A->altitude < B->altitude;
	}
};

std::priority_queue<cell*, std::vector<cell*>, compareCells> toVisit;

int K_count = 0;
int K_visited = 0;

void resetVisited(int m, int base_x, int base_y) {
	for (int i = 0; i < m; i++)
		for (int j = 0; j < m; j++)
			Cells[i][j].visited = false;
	K_visited = 0;
	//	if (!toVisit.empty())
		//printf("Warning! toVisit heap should be empty a the end of min run.\n");
	toVisit.push(&Cells[base_x][base_y]);
}

unsigned SAFE(int x, int max, int min) {
	return ((x > max) ? max : ((x < min ) ? min : x));
}

bool DFS(cell *C, int max, int min, int K, int m) {
	//	if (C != &Cells[C->x][C->y])
		//printf("All HELL!\n");
	//printf("DFS reached [%d, %d] with alt %d, visited %d\n", C->x, C->y, C->altitude, C->visited);
	C->visited = true;
	if (C->T == PIPUL) {
		//printf("K visited! %d\n", K_visited + 1);
		K_visited += 1;
	}
	if (K_visited == K) {
		//printf("All K found!\n");
		return true;
	}
	if (C->altitude < min) {
		//printf("This cell is not viable\n");
		return false;
	}
	else if (C->altitude >= min && C->altitude > max) {
		//printf("This cell may be visited in the future.\n");
		toVisit.push(C);
		return false;
	}		
	for (int i = -1; i < 2; i++)
		for (int j = -1; j < 2; j++) {
			int s_x = SAFE(C->x + i, m-1, 0);
			int s_y = SAFE(C->y + j, m-1, 0);
			if (s_x == C->x && s_y == C->y)
				continue;
			//printf("Considering neighbour [%d, %d] with alt %d\n", s_x, s_y, Cells[s_x][s_y].altitude);
			if (Cells[s_x][s_y].visited) {
				//printf("Already visited, continuing...\n");
				continue;
			}
			else if (Cells[s_x][s_y].altitude >= min) {
				if (Cells[s_x][s_y].altitude <= max) {
					//printf("Exploring possible DFS\n");
					if (DFS(&Cells[s_x][s_y], max, min, K, m))
						return true;
				}
				else {
					//printf("Pushing [%d, %d] onto stack\n", s_x, s_y);
					Cells[s_x][s_y].visited = true;
					toVisit.push(&Cells[s_x][s_y]);
				}
			}
			else {
				Cells[s_x][s_y].visited = true;
				//printf("Cell is not min viable, continuing!\n");
			}
		}
	return false;
}

int main() {
	int m;
	scanf("%d", &m);
	char row[50];
	for (int i = 0; i < m; i++) {
		scanf("%s", row);
		for (int j = 0; j < m; j++) {
			Cells[j][i].x = j;
			Cells[j][i].y = i;			
			if (row[j] == 'P')
				Cells[j][i].T = BASE;
			else if (row[j] == 'K') {
				Cells[j][i].T = PIPUL;
				K_count++;
			}
		}
	}
	//	printf("m is %d, and K_count is %d\n", m, K_count);
	int base_alt = 0;
	int min_alt = 999999;
	int max_alt = 0;
	int base_x, base_y;
	for (int i = 0; i < m; i++)
		for (int j = 0; j < m; j++) {
			scanf("%d", &(Cells[j][i].altitude));
			if (Cells[j][i].T == BASE) {
				base_alt = Cells[j][i].altitude;
				base_x = j;
				base_y = i;
			}
			if (Cells[j][i].altitude < min_alt && Cells[j][i].T == PIPUL)
				min_alt = Cells[j][i].altitude;
			if (Cells[j][i].altitude > max_alt && Cells[j][i].T == PIPUL)
				max_alt = Cells[j][i].altitude;
			altitudes.push_back(Cells[j][i].altitude);
		}
	//printf("Before normalization, max alt %d min alt %d base alt %d\n", max_alt, min_alt, base_alt);
	max_alt -= base_alt;
	min_alt -= base_alt;
	for (int i = 0; i < m; i++)
		for (int j = 0; j < m; j++) {
			Cells[i][j].altitude -= base_alt;
			altitudes[j + m * i] -= base_alt;
		}
	base_alt = 0;
	//printf("Max alt is %d, min alt is %d \n", max_alt, min_alt);
	std::sort(altitudes.begin(), altitudes.end());
	altitudes.erase(std::unique(altitudes.begin(), altitudes.end()), altitudes.end());
	// printf("Alts are: \n");
	// for (int i = 0; i < altitudes.size(); i++)
	// 	printf("%d ", altitudes[i]);
	//printf("\n");
	std::vector<int>::iterator min = std::find(altitudes.begin(), altitudes.end(), min_alt);

	toVisit.push(&Cells[base_x][base_y]);
	int ans = 999999;
	for (; min >= altitudes.begin(); min--) {
		for ( std::vector<int>::iterator max =
			      std::find(altitudes.begin(), altitudes.end(), max_alt);
		      max != altitudes.end(); max++) {
			if (*max - *min >= ans)
				continue;
			//printf("Considering max as %d and min as %d\n", *max, *min);
			while (!toVisit.empty() && toVisit.top()->altitude <= *max) {
				//printf("Visiting top of stack\n");
				if (DFS(toVisit.top(), *max, *min, K_count, m))
					if (*max - *min < ans) {
						//printf("New answer found from max %d and min %d\n", *max, *min);
						ans = *max - *min;
						while (!toVisit.empty()) toVisit.pop();
						break;
					}
				toVisit.pop();
			}
		}
		resetVisited(m, base_x, base_y);
	}
	printf("%d\n", ans);
	return 0;
}
