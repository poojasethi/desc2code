#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<ll>primes;
bool isprime=false;
bool check[100005];
/*void sieve()
{
    primes.push_back(2);
    for(ll i=3;i*i<=1000000009;i+=2)
    {
        isprime=true;
        ll temp=sqrt(i)+1;
        for(int j=0;j<primes.size();j++)
        {
            if(primes[j]>temp)
                break;
            if(i%primes[j]==0)
            {
                isprime=false;
                break;
            }
        }
        if(isprime)
            primes.push_back(i);
    }
}*/
void sieve()
{
    check[0]=true;check[1]=true;
    for(ll i=2;i<=100000;i++)
    {
        if(!check[i])
        {
            for(ll j=i*i;j<=100000;j+=i)
                check[j]=true;
        }
        if(!check[i])
            primes.push_back((ll)i);
    }
}
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    memset(check,false,sizeof check);
    sieve();
    //cout<<primes.size()<<"\n";
    for(int i=0;i<primes.size();i++)
        primes[i]=primes[i]*primes[i];
    int q;cin>>q;
    while(q--)
    {
        ll l,r;cin>>l>>r;
        int v1=lower_bound(primes.begin(),primes.end(),l)-primes.begin();
        if(primes[v1]>r)
        {
            cout<<"0\n";continue;
        }
        int v2=lower_bound(primes.begin(),primes.end(),r)-primes.begin();
        if(primes[v2]!=r)
        v2--;
        cout<<v2-v1+1<<"\n";
    }
    return 0;
}
// if lower_bound find the number then it return s its position otherwise the next greater position
// upper_bound always returns the position of the next greater element whether the element is present or not
/*
1
1 1000000000
*/
