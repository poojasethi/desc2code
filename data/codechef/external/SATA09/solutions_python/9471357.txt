#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pi;

const int maxlog = 20;
const int maxn = 100010;
const int sqrtn = 450;
const ll mod = 1e9+7;

void summod(int& a, int b) {
    a += b;
    if (a >= mod) a -= mod;
}

void restmod(int& a, int b) {
    a -= b;
    if (a < 0) a += mod;
}

int multmod(ll a, ll b) {
    ll r = (a*b)%mod;
    return r;
}

struct queri {
    int ini;
    int fin;
    int extra;
    int index;
    int part;
};

typedef vector<queri> vq;

int D[maxn];
int P[maxn][maxlog + 2];
vi val[maxn];
vi G[maxn];
vq Q;
pi T[maxn];
int U[maxn];
int F[maxn];
int A[2*maxn];
int cont = 0;
int res = 0;
int R[maxn];
int m;

bool comp(queri a, queri b) {
    if (a.part != b.part) return a.part < b.part;
    if (a.fin != b.fin) return a.fin < b.fin;
    return a.ini < b.ini;
}

void add(int x) {
   if(val[x].size()) restmod(res, val[x].back());
   if(val[x].size()) val[x].push_back(multmod(val[x].back(), x));
   else val[x].push_back(x);
   summod(res, val[x].back());
}

void rest(int x) {
   restmod(res, val[x].back());
   val[x].pop_back();
   if(val[x].size()) summod(res, val[x].back());
}

void actu(int k) {
    if (U[k]) {
        rest(F[k]);
        U[k] = 0;
    }
    else {
        add(F[k]);
        U[k] = 1;
    }
}

void dfs(int x, int p, int d) {
    T[x].first = cont;
    A[cont++] = x;
    D[x] = d;
    int j = 0;
    while (p) {
        P[x][j] = p;
        p = P[p][j];
        ++j;
    }
    for (int i = 0; i < G[x].size(); ++i) if (!D[G[x][i]]) dfs(G[x][i], x, d + 1);
    T[x].second = cont;
    A[cont++] = x;
}

int lca(int x, int y) {
    if (D[x] < D[y]) swap(x, y);
    for (int i = maxlog; i >= 0; --i) if (D[P[x][i]] >= D[y]) x = P[x][i];
    for (int i = maxlog; i >= 0; --i) {
        if (P[x][i] != P[y][i]) {
            x = P[x][i];
            y = P[y][i];
        }
    }
    if (x == y) return x;
    return P[x][0];
}

void readqueries() {
    scanf("%d", &m);
    Q = vq(m);
    for (int i = 0; i < m; ++i) {
        int x, y;
        scanf("%d %d", &x, &y);
        int l = lca(x, y);
        queri q;
        if (T[x].first > T[y].first) swap(x, y);
        if (x == l) {
            q.ini = T[x].first;
            q.fin = T[y].first;
            q.extra = -1;
        }
        else {
            q.ini = T[x].second;
            q.fin = T[y].first;
            q.extra = T[l].first;
        }
        q.index = i;
        q.part = q.ini/sqrtn;
        Q[i] = q;
    }
    sort(Q.begin(), Q.end(), comp);
}

void readgraf() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &F[i]);
    for (int i = 1; i < n; ++i) {
        int x, y;
        scanf("%d %d", &x, &y);
        G[x].push_back(y);
        G[y].push_back(x);
    }
    dfs(1, 0, 1);
}

void solve() {
    int in = 0;
    int fi = -1;
    
    for (int i = 0; i < m; ++i) {
        int kin = Q[i].ini;
        int kfi = Q[i].fin;
        
        while (fi < kfi) {
            ++fi;
            actu(A[fi]);
        }
        
        while (fi > kfi) {
            actu(A[fi]);
            --fi;
        }
        
        while (in < kin) {
            actu(A[in]);
            ++in;
        }
        
        while (in > kin) {
            --in;
            actu(A[in]); 
        }
        
        if (Q[i].extra != -1) {
            actu(A[Q[i].extra]);
            R[Q[i].index] = res;
            actu(A[Q[i].extra]);
        }
        else R[Q[i].index] = res;
    }
    
    for (int i = 0; i < m; ++i) printf("%d\n", R[i]);
}

int main() {
    readgraf();
    readqueries();
    solve();
}