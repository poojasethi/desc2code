#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back
#define sz(a) int((a).size())
#define all(a)  a.begin(), a.end()
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;
#define present(c,x) ((c).find(x) != (c).end())
const double eps = 1e-8;
#define EQ(a,b) (fabs((a)-(b))<eps)
inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 4e5+10;
const ll inf = 1e18;

ll power(ll a,ll n){
	if(n==0){
		return 1;
	}
	ll b = power(a,n/2);
	b = b*b%mod;
	if(n%2) b= b*a%mod;
	return b;
}

int add(int a,int b){ return (a+b)%mod;}
int mul(int a,int b){ return (ll)a*b%mod;}

int Fare[N] , tin[N] , tout[N] , timer , par[N][20] , depth[N];
vector <int> G[N];
vector <  int > order;

void dfs(int i, int p ,int d=0){
	order.pb(i);
	depth[i] = d;
	tin[i] = timer++;
	par[i][0]= p;
	REP(j,G[i].size()){
		if(G[i][j]!=p)	dfs(G[i][j],i,d+1);
	}
	order.pb(i);
	tout[i]= timer++;
}

int LCA(int u,int v){
	if(depth[u]<depth[v])	swap(u,v);
	int dif = depth[u]-depth[v] , c=0;
	while(dif>0){
		if(dif&1)	u = par[u][c];
		dif/=2;c++;
	}
	if(u==v)	return u;
	for(int i=19;i>=0;i--){
		if(par[u][i]!=par[v][i]){
			u = par[u][i] , v = par[v][i];
		}
	}
	return par[u][0];
}

vector < pair < pii , pii > > Q;
int BLOCK = 400 , A[N] , cnt[N] , B[N] , C[N] ,inv[N];

int cmp( pair < pii , pii > a , pair < pii , pii > b){
	if(a.X.X/BLOCK !=  b.X.X/BLOCK) return a.X.X/BLOCK <  b.X.X/BLOCK;
	return a.X.Y < b.X.Y;
}

void g(int node , int &ans){
	if(cnt[node]==1){
		C[Fare[node]]--;
		ans = add(ans , mod-B[Fare[node]]);
		if(C[Fare[node]]==0)	B[Fare[node]]=0;
		B[Fare[node]] = mul(B[Fare[node]],inv[Fare[node]]);
		ans = add(ans,B[Fare[node]]);
	}else {
		//printf("%d\n",ans);
		C[Fare[node]]++;
		ans = add(ans , mod-B[Fare[node]]);
	//	printf("%d\n",ans);
		if(C[Fare[node]]==1)	B[Fare[node]] = 1;
		B[Fare[node]] = mul(B[Fare[node]],Fare[node]);
		ans = add(ans,B[Fare[node]]);
	//	printf("%d\n",ans);
	}
	cnt[node]--;
}

void f(int node , int &ans){
	cnt[node]++;
	if(cnt[node]==1){
		if(B[Fare[node]]==0)	B[Fare[node]]=1;
		else ans = add(ans , mod-B[Fare[node]]);
		B[Fare[node]] = mul(B[Fare[node]],Fare[node]);
		ans = add(ans,B[Fare[node]]);
		C[Fare[node]]++;
	}else {
		C[Fare[node]]--;
		ans = add(ans , mod-B[Fare[node]]);
		if(C[Fare[node]]==0)	B[Fare[node]] = 0;
		else B[Fare[node]] = mul(B[Fare[node]],inv[Fare[node]]);
		ans = add(ans,B[Fare[node]]);
	}
}

int main(){
 // 	freopen("nice.in","r",stdin);
 // freopen("nice.out","w",stdout);
	int n;scanf("%d",&n);
	REP(i,n)	scanf("%d",&Fare[i]);
	REP(i,n-1){
		int u,v;scanf("%d %d",&u,&v);u--;v--;G[u].pb(v);G[v].pb(u);
	}
	inv[0]=1;
	REPP(i,1,N)	inv[i] = power(i,mod-2);	
	dfs(0,0);
	REPP(i,1,20)	REP(j,n)	par[j][i] = par[par[j][i-1]][i-1];
	int q;scanf("%d",&q);
	REP(i,q){
		int u,v;scanf("%d %d",&u,&v);u--;v--;
		int lca = LCA(u,v);
	//	printf("ss%d\n",lca);
		if(lca==u){
			Q.pb(mp(mp(tin[u],tin[v]),mp(-1,i) ));
		}else if(lca==v){
			Q.pb(mp(mp(tin[v],tin[u]),mp(-1,i)));
		}else{
			if(tout[u]<tin[v])
				Q.pb(mp(mp(tout[u],tin[v]),mp(lca,i) ));
			else Q.pb(mp(mp(tout[v],tin[u]),mp(lca,i) ));
		}
	}
//	REP(i,order.size())	printf("%d ",order[i]);printf("\n");
	sort(all(Q),cmp);
	int l=0,r=-1 , ans = 0;
	REP(i,Q.size()){
//		printf("%d %d %d %d\n",Q[i].X.X,Q[i].X.Y,Q[i].Y.X,Q[i].Y.Y);
		while(r<Q[i].X.Y){
			r++;
			int node = order[r];
			f(node,ans);
		//	printf("aa%d\n",ans);
		}
		while(l>Q[i].X.X){
			l--;
			int node = order[l];
			f(node,ans);
		//	printf("bb%d\n",ans);
		}
		while(r> Q[i].X.Y){
			int node = order[r];
			g(node,ans);
			r--;
		//	printf("cc%d\n",ans);
		}
		while(l<Q[i].X.X){
			int node = order[l];
			g(node,ans);
			l++;	
		//	printf("dd%d %d\n",ans,cnt[node]);
		}
		if(Q[i].Y.X!=-1){
			int a = B[Fare[Q[i].Y.X]] , pans = ans;
			pans = add(pans, mod - B[Fare[Q[i].Y.X]]);
			if(a==0)	a=1;
			a = mul(a,Fare[Q[i].Y.X]);
			pans = add(pans,a);
			A[Q[i].Y.Y ] = pans;
		}else A[Q[i].Y.Y ] = ans;
	}
	REP(i,Q.size())	printf("%d\n",A[i]);
	return 0;
}
