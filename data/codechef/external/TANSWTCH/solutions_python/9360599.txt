//#define prantoran
//To Infinity And Beyond


#include<bits/stdc++.h>

#define sf scanf
#define pf printf
#define ll long long
#define inf (ll)1<<60
#define sz 2111111
#define pii pair<int,int>
#define mp(x,y) make_pair(x,y)
#define ff first
#define ss second
#define vi vector<int>

#define vl vector<ll>
#define pb push_back
#define pdd pair<double,double>
#define pll pair<ll,ll>
#define lazy second

#define uu first
#define vv second
#define vii vector< pair<int,int> >
#define vi vector<int>
#define vll vector<ll>


using namespace std;



struct debugger{
    template<typename T> debugger& operator, (const T& v){
        cerr<<v<<" ";
        return *this;
    }
}dbg;


#ifdef prantoran
    #include<ctime>
    clock_t tStart = clock();
   // freopen("input.txt","r",stdin);

    #define debug(args...){dbg,args; cerr<<endl;}
    #define timeStamp printf("Execution Time: %.2fs\n",(double)(clock()-tStart)/CLOCKS_PER_SEC);

#else
    #define debug(args...)
    #define timeStamp
#endif // prantoran


ll mod =1000000007;

ll mod_v(ll nn){return nn%mod;}

template<class T>
T fast_pow(T n , T p){
    if(p==0) return 1;
    if(p%2){
        T g=mod_v ( mod_v(n) * mod_v(fast_pow(n,p-1)) );
        return g;
    }
    else{
        T g=fast_pow(n,p/2);
        g=mod_v( mod_v(g) * mod_v(g) ) ;
        return g;
    }
}

template<class T>
inline T modInverse(T n){
    return fast_pow(n,mod-2);
}

//#####################^^prantoran^^##########################

const int mxn = 111;

int t , len ;
char s[mxn];
int cum[111];

int main(){
    #ifdef prantoran

        freopen("input.txt","r",stdin);
       // freopen("output.txt","w",stdout);
    #endif // prantoran
   //ios_base::sync_with_stdio(false);

    sf("%d ",&t);

    while(t--){
        sf("%s",&s);
        len = strlen(s);

        cum[0]=0;

        for(int i = 1 ; i<=len;i++){
            if(s[i-1]=='N'){
                cum[i]=1;
            }
            else{
                cum[i]=0;
            }
            cum[i]+=cum[i-1];

          //  cout<<"cum["<<i<<"]:"<<cum[i]<<endl;

        }

        int sum = cum[len];

        for(int i = 1;i<=len;i++){
            int tmp = (cum[i-1]-cum[0]);
           // cout<<"tmp:"<<tmp<<endl;
            tmp+= ((len-i+1)-(cum[len]-cum[i-1]));



            sum=min(sum,tmp);
           // cout<<"i:"<<i<<"\tsum:"<<sum<<"\ttmp:"<<tmp<<endl;

        }
        pf("%d\n",sum);

    }


    return 0;
}
