//bfs
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
#define INF 1000000000
#define MP make_pair
int dx[]={0,0,-1,1};
int dy[]={-1,1,0,0};
string st[103];
int mark[102][102][4];
int r,c;
queue<pair<pair<int,int>,pair<int,int> > > q;
bool valid(int x, int y)
{
	if(x<0 || x>=r || y<0 || y>=c)
		return false;
	if(st[x][y]!='*')
		return true;
	return false;
}
int main()
{
  std:ios_base::sync_with_stdio(false);
  cin>>r>>c;
  for(int i=0;i<r;i++)	cin>>st[i];
  
  int fi,fj;
  for(int i=0;i<r;i++)
  {
  	for(int j=0;j<c;j++)
  	{ 
	  	for(int k=0;k<4;k++)
		  mark[i][j][k]=INF;
		    
  		if(st[i][j]=='H')
  		{
  			for(int k=0;k<4;k++)
  				q.push(MP(MP(i,j),MP(0,k)));
  		}
  		if(st[i][j]=='L')
  		{
  			fi=i;
  		    fj=j;
  		}
  	}
  }
  int ans=INF;
  while(!q.empty())
  {
  	int curx=q.front().first.first;
  	int cury=q.front().first.second;
  	int turns=q.front().second.first;
  	int dir=q.front().second.second;
  	q.pop();
  	for(int d=0;d<4;d++)
  	{
  		int nx=curx+dx[d];
  		int ny=cury+dy[d];
  		int off=0;
  		if(d!=dir) off++;
  		
  		if(valid(nx,ny) && mark[nx][ny][d] > turns+off)
  		{
  			mark[nx][ny][d]=turns+off;
  			q.push(MP(MP(nx,ny),MP(turns+off,d)));
  		}
  	}
  }
  for(int k=0;k<4;k++)
  ans=min(ans,mark[fi][fj][k]);
  printf("%d\n",ans);
  return 0;
}