#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <cstring>
#include <queue>
#include <map>
#include <set>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <bitset>


#define vi vector < int >
#define mod 1000000007
#define inf 987654321
#define dinf -inf
#define lo long long int
#define S(n) scanf("%d",&n);
#define SL(n) scanf("%lld",&n);
#define P(n) printf("%d",n);
#define PL(n) printf("%lld",n);
#define spa printf(" ");
#define st(a,v) memset(a, v, sizeof (a))
#define nwl puts("");

using namespace std;


/**
 *   //////////////////
 *   // MAXIMUM FLOW //
 *   //////////////////
 *
 * This file is part of my library of algorithms found here:
 *      http://www.palmcommander.com:8081/tools/
 * LICENSE:
 *      http://www.palmcommander.com:8081/tools/LICENSE.html
 * Copyright (c) 2004
 * Contact author:
 *      igor at cs.ubc.ca
 **/

/****************
 * Maximum flow * (Ford-Fulkerson on an adjacency matrix)
 ****************
 * Takes a weighted directed graph of edge capacities as an adjacency
 * matrix 'cap' and returns the maximum flow from s to t.
 *
 * PARAMETERS:
 *      - cap (global): adjacency matrix where cap[u][v] is the capacity
 *          of the edge u->v. cap[u][v] is 0 for non-existent edges.
 *      - n: the number of vertices ([0, n-1] are considered as vertices).
 *      - s: source vertex.
 *      - t: sink.
 * RETURNS:
 *      - the flow
 *      - fnet contains the flow network. Careful: both fnet[u][v] and
 *          fnet[v][u] could be positive. Take the difference.
 *      - prev contains the minimum cut. If prev[v] == -1, then v is not
 *          reachable from s; otherwise, it is reachable.
 * DETAILS:
 * FIELD TESTING:
 *      - Valladolid 10330: Power Transmission
 *      - Valladolid 653:   Crimewave
 *      - Valladolid 753:   A Plug for UNIX
 *      - Valladolid 10511: Councilling
 *      - Valladolid 820:   Internet Bandwidth
 *      - Valladolid 10779: Collector's Problem
 * #include <string.h>
 * #include <queue>
 **/
// the maximum number of vertices
#define NN 505

int x1;
int x2;
int z000;
int y2;
// adjacency matrix (fill this up)
int cap[NN][NN];

// flow network
int fnet[NN][NN];
// BFS predecessor
int prev[NN];
int fordFulkerson( int n, int s, int t )
{
    // init the flow network
    //cout << "Inside\n";
    memset( fnet, 0, sizeof( fnet ) );

    int flow = 0;

    while( true )
    {
        // find an augmenting path
        memset( prev, -1, sizeof( prev ) );
        queue< int > q;
        prev[s] = -2;
        q.push( s );
        while( !q.empty() && prev[t] == -1 )
        {
            int u = q.front();
            q.pop();

            for( int v = 0; v < n; v++ )
                if( prev[v] == -1 && fnet[u][v] - fnet[v][u] < cap[u][v] )
                    { prev[v] = u; q.push( v ); }
        }

        // see if we're done
        if( prev[t] == -1 ) break;

        // get the bottleneck capacity
        int bot = 0x7FFFFFFF;
        for( int v = t, u = prev[v]; u >= 0; v = u, u = prev[v] )
            bot = min(bot, cap[u][v] - fnet[u][v] + fnet[v][u]);

        // update the flow network
        for( int v = t, u = prev[v]; u >= 0; v = u, u = prev[v] )
            fnet[u][v] += bot;

        flow += bot;
    }

    return flow;
}
int n, m, c;
int x[500];
int y[500];
int cost[500][500];
int solve ( int curr ) {
    st(cap,0);
    int tot = n + 2*m + 2;
    for (int i = 1; i <= n; i++)
        cap[0][i] = 1;
    for (int j = 1; j <= 2*m; j++)
        cap[j + n][tot-1] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (cost[i-1][j-1] <= curr)
                cap[i][j+n] = 1;
            if (cost[i-1][j-1] + c <= curr)
                cap[i][j+n+m]  = 1;
        }
    }
    return fordFulkerson(tot, 0 , tot - 1);
}
int main ( )  {
    int tc;
    S ( tc );
    while ( tc-- ) {
        int k;
        S ( n );S ( m ); S ( k ); S ( c );
        for(int i = 0; i < n; i++ )
            for ( int j = 0; j < m; j++ )
                S ( cost[i][j] );
        int low = 0, high = 987654321, mid,ans;
        while ( low <= high ) {
            mid = ( low + high ) / 2;
         //   cout << mid << endl;
            if ( solve ( mid ) >= k )
                high = mid - 1,ans=mid;
            else
                low = mid + 1;
        }
        printf ( "%d\n", ans );
    }
}






























