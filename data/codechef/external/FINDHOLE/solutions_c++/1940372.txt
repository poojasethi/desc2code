#include<iostream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<list>
#include<cstdlib>
#include<queue>
#include<limits>

using namespace std;

const int lim = 305;
const int max_t = 10000000;
const int inf = numeric_limits<int>::max();
int c[lim][lim] = {0};
int f[lim][lim] = {0};
int d[105][105] = {0};
vector<int> adjl[lim];
bool visited[lim]={false};
int par[lim];
int aug[lim];
int augval,maxflow;
int N,M,K,C;
queue<int> Q;
int s=0,t;

bool augmentingpath()
{
    for(int x=0;x<lim;x++)
        visited[x] = false;
    while(!Q.empty())
        Q.pop();    
    
    visited[s]=true;
    par[s] = s;
    Q.push(s);
    aug[s] = inf;
    
    int vt,vtnbr;
    while(!Q.empty())
    {
        vt = Q.front();
        Q.pop();
        //cout << "Vertex :" << vt <<"\t";
        for(int i=0; i<adjl[vt].size(); ++i)
        {
            vtnbr=adjl[vt][i];
            if((!visited[vtnbr]) && (c[vt][vtnbr]-f[vt][vtnbr]>0))
            {
                //cout << "Residual Flow" <<c[vt][vtnbr]-f[vt][vtnbr] <<endl;
                visited[vtnbr]=true;
                Q.push(vtnbr);
                par[vtnbr]=vt;
        		aug[vtnbr]=min(aug[vt],c[vt][vtnbr]-f[vt][vtnbr]);
            }
        }    
    }
    //cout << endl;
    augval=aug[t];
    return visited[t];
}

void augmentflow(int vt)
{
        if(par[vt]!=vt)
        {
                f[par[vt]][vt] += augval;
                f[vt][par[vt]] -= augval;
                augmentflow(par[vt]);
        }
}

int findmaxflow()
{
    //cout << "start" <<endl;
    //int i=0;
    while(augmentingpath())// && i<10)
    {
        //cerr<<"augval:"<<augval<<endl;
        maxflow += augval;
        augmentflow(N+2*M+1);
      // i++;
    }
    return maxflow;
}

bool possible(int ti)
{
    maxflow = 0;
    for(int x=0;x<lim;x++)
        for(int y=0;y<lim;y++)
        {
            c[x][y] = 0;
            f[x][y] = 0;
        }
    for(int i=0; i<N+2*M+2; ++i)
        adjl[i].resize(0);
    for(int x=0;x<N;x++)
    {
        for(int y=0;y<M;y++)
        {
            if(d[x][y] <= ti)
            {
                c[x + 1][y + N + 1] = 1;
                adjl[x+1].push_back(y+N+1);
                adjl[y+N+1].push_back(x+1);
                if(d[x][y] + C <= ti)
                {
                    c[x+1][y + N + M + 1] = 1;
                    adjl[x+1].push_back(y+N+M+1);
                    adjl[y+N+M+1].push_back(x+1);
                }
            }
        }    
    }
    for(int x=N+1;x<=N+2*M;x++)
    {
        c[x][N+2*M+1] = 1;
        adjl[x].push_back(N+2*M+1);
        adjl[N+2*M+1].push_back(x);    
    }
    for(int y=1;y<=N;y++)
    { 
        c[0][y] = 1;
        adjl[0].push_back(y);
        adjl[y].push_back(0);
    }
     if(findmaxflow() < K)
        return false;
     else
        return true;   
        
}

int binarysrch(int l,int r)
{
    if(l+1==r)
        return r;
    else
    {
        int mid = (l+r)/2;
        if(possible(mid))
            return binarysrch(l,mid);
        else
            return binarysrch(mid,r);
    }        
}

int main()
{
    int T;
    cin >> T;
    for(int iter=0;iter<T;iter++)
    {
            scanf("%d %d %d %d",&N,&M,&K,&C);
            t = N+2*M+1;
            for(int x=0;x<N;x++)
                for(int y=0;y<M;y++)
                    scanf("%d",&d[x][y]);
            if(possible(0))
                cout << 0 <<endl;
            else if(!possible(2*max_t))
                cout << "Not Possible";
            else
                cout << binarysrch(0,2*max_t) << endl;
            
            //cout << possible(10)<<endl;
    }
    //cin >> N;
    return 0;    
}
