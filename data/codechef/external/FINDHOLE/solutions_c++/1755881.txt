#include <cstdio>
#include <cassert>

#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int N, M, K, C;
int D[104][104];

class BipartiteMatching2 {
   vector<bool> seen;
   bool bpm(int u) {
      if (seen[u]) return false;
      seen[u] = true;
      for (int j = 0; j < adj[u].size(); ++j) {
         int v = adj[u][j];
         if (matchR[v] < 0 || bpm(matchR[v])) {
            matchL[u] = v;
            matchR[v] = u;
            return true;
         }
      }
      return false;
   }
public:
   size_t nL, nR;
   vector< vector<int> > adj; // adjacency lists

   vector<int> matchL, matchR;
   BipartiteMatching2(size_t _nL, size_t _nR) : nL(_nL), nR(_nR), adj(_nL) {}

   int process() {
      matchL.assign( nL, -1 ),
      matchR.assign( nR, -1 );
      int cnt = 0;
      while (true) {
         int nchanges = 0;
         seen = vector<bool>(nL, false);
         for (int u = 0; u < nL; ++u) {
            if (matchL[u] < 0 && !seen[u])
               if (bpm(u))
                  nchanges++;
         }
         if (nchanges == 0) break;
         cnt += nchanges;
      }
      return cnt;
   }
};

bool check(int t) {
   BipartiteMatching2 bpm(N, M*2);
   for (int i = 0; i < N; ++i) {
      for (int j = 0; j < M; ++j) {
         if (D[i][j] + C <= t)
            bpm.adj[i].push_back(j);
         if (D[i][j] <= t)
            bpm.adj[i].push_back(j + M);
      }
   }
   return bpm.process() >= K;
}

int binary_search() {
   int lo = 0, hi = 20000000;
   while (lo < hi) {
      int mid = lo + (hi-lo)/2;
      if (check(mid))
         hi = mid;
      else
         lo = mid+1;
   }
// assert(check(lo));
   return lo;
}

int main(int argc, char* argv[]) {
   int TC;
   scanf("%d", &TC);
   while (TC-- > 0) {
      scanf("%d %d %d %d", &N, &M, &K, &C);
      for (int i = 0; i < N; ++i)
         for (int j = 0; j < M; ++j)
            scanf("%d", &D[i][j]);
      int res = binary_search();
      printf("%d\n", res);
   }

   return 0;
}
