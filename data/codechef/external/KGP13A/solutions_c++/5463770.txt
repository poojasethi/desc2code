#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<algorithm>
#include<set>
#include<vector>
#include<limits.h>
using namespace std;
#define pb push_back
#define mk make_pair
#define scani(n) scanf("%d",&n);
#define ll long long
long int a[1000][1000],dp[1000][1000];
int visited[1000],parent[1000],n;
void trace(int s,int d)
{
	if(d==s || parent[d]==-1)
	{
		visited[s]=1;
		return;
	}
	visited[d]=1;
	trace(s,parent[d]);
}
bool dijik(int s,int d)
{
	int i,j,dist[n+5];
	for(i=0;i<n;i++)
	{
		dist[i]=INT_MAX;parent[i]=-1;
	}
	dist[s]=0;
	queue<int>q;
	q.push(s);
	while(!q.empty())
	{
		i=q.front();
		q.pop();
	//	cout<<i<<" : "<<endl;
		for(j=0;j<n;j++)
		{
			if(i==j)continue;
//			cout<<j<<" :  "<<a[i][j]<<" "<<dist[j]<<" "<<a[i][j]<<" "<<dist[i]<<endl;

			if(a[i][j]!=INT_MAX && dist[j]>a[i][j]+dist[i])
			{
				parent[j]=i;
//				cout<<"parent["<<j<<"] = "<<i<<endl;
				dist[j]=dist[i]+a[i][j];
				q.push(j);
			}
		}	
		
	}
//	cout<<"dijik over\n";
	int pp;
//	cin>>pp;
	if(dist[d]==INT_MAX)
	{
	//	cout<<"returning false\n";
		return false;
	}
	memset(visited,0,sizeof(visited));
//	cout<<s<<" "<<d<<" trace : \n";
	trace(s,d);
//	cout<<"returning true\n";
	return true;
}
int find(int i)
{
	long int j,fin=INT_MAX;
	for(j=0;j<n;j++)
	{
		if(i==j || visited[j]==0)continue;
		fin=min(fin,dp[i][j]);
	}
	return fin;
}
int main()
{
	int t,tt,i,j,k,d,q,no,source,dest,pos,ans,ans2,s,ss;
	vector<int>head;
	cin>>t;
	for(tt=1;tt<=t;tt++)
	{
		cin>>n;
		head.clear();
		for(i=0;i<n;i++)
		{
			for(j=0;j<n;j++)
			{
				dp[i][j]=INT_MAX;
				a[i][j]=INT_MAX;
			}
			a[i][i]=0;
			dp[i][i]=0;
		}
		
		for(i=0;i<n;i++)
		{
			cin>>q>>no;
			if(q==1)
				head.pb(i);
			for(j=0;j<no;j++)
			{
				cin>>k>>d;
				dp[i][k-1]=a[i][k-1]=d;
				dp[k-1][i]=a[k-1][i]=d;
				
			}
		}
	/*	cout<<n<<endl;
		for(int kk=0;kk<n;kk++)
		{
			for(int ii=0;ii<n;ii++)
			{
				for(int jj=0;jj<n;jj++)
				{
					if((dp[ii][kk]+dp[kk][jj])<dp[ii][jj]);
						dp[ii][jj]=dp[ii][kk]+dp[kk][jj];
				}
			}
		}
	*/
		int V=n;
		for (k = 0; k < V; k++)
    {
        // Pick all vertices as source one by one
        for (i = 0; i < V; i++)
        {
            // Pick all vertices as destination for the
            // above picked source
            for (j = 0; j < V; j++)
            {
                // If vertex k is on the shortest path from
                // i to j, then update the value of dist[i][j]
                if (dp[i][k]!=INT_MAX && dp[k][j]!=INT_MAX && dp[i][k] + dp[k][j] < dp[i][j])
                {//	cout<<i<<" "<<k<<" "<<j<<" "<<dp[i][k]<<" "<<dp[k][j]<<" "<<dp[i][j]<<"--->"<<dp[i][k]+dp[k][j]<<endl;
                    dp[i][j] = dp[i][k] + dp[k][j];
            	}
            }
        }
    }
	
	/*
		for(i=0;i<n;i++)
		{
			for(j=0;j<n;j++)
			{
				cout<<dp[i][j]<<" ";
			//	cout<<"("<<a[i][j]<<","<<dp[i][j]<<") ";
			}
			cout<<endl;
		}
	*/	if(head.size()==1)
		{
			pos=head[0];
			ans=0;
			for(i=0;i<n;i++)
			{
				if(i==pos)continue;
				ans+=dp[i][pos];
			}
			cout<<"Case "<<tt<<": "<<ans<<endl;
			continue;
		}
		ans=INT_MAX;
		for(s=0;s<head.size();s++)
		{
			for(ss=s+1;ss<head.size();ss++)
			{
				ans2=0;
				source=head[s];
				dest=head[ss];
//					cout<<source<<" "<<dest<<" calling\n";
			
				if(!dijik(source,dest))continue;
				for(i=0;i<n;i++)
				{ //   cout<<i<<" "<<visited[i]<<endl;
					if(visited[i]==0)
					{
						ans2+=find(i);
					}
				}
			//	cout<<source<<" "<<dest<<"  "<<ans2<<"conmp\n";
				
				ans=min(ans2,ans);
		//		cout<<"loop1:";
			}
		//	cout<<"loop2:";
			
		}
		cout<<"Case "<<tt<<": "<<ans<<endl;
		
	}

	return 0;
}
