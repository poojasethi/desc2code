#include <iostream>
#include <iosfwd>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cctype>
#include <vector>
#include <bitset>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <deque>
#include <string>
#include <list>
#include <iterator>
#include <sstream>
#include <complex>
#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>

using namespace std;

#define BUG(x) if (DEBUG) cout << __LINE__ << ": " << #x << " = " << x << endl
#define LET(x, a) __typeof(a) x = a
#define FOREACH(it, v) for(LET(it, (v).begin()); it != (v).end(); ++it)

typedef long long LL;

template <class T> inline int size(const T& c) {return (int) c.size();}
int rInt() {int nT = -1; scanf("%d", &nT); return nT;}
string rStr() {char nStr[1 << 20] = ""; scanf("%s", nStr); return nStr;}
LL rLL() {LL nT = -1; scanf("%lld", &nT); return nT;}
inline LL two(int x) {return (1LL << (x));}
template <class T> ostream& operator << (ostream& o, const vector <T>& v)
{o << "{"; FOREACH(it, v) o << *it << ","; return o << "}";}
template <class A, class B> ostream& operator << (ostream& o, const pair <A, B>& p)
{o << "("; o << p.first << "," << p.second << ")"; return o;}

const bool DEBUG = true;
const double EPS = 1e-8;
const int INF  = 1000000000;
const LL INFLL = 1000000000000000000LL;
const LL MODULO = 1000000000 + 7;

struct Solver
{
	vector <LL> fact;
	vector < vector <LL> > c;
	vector < vector <LL> > answer;
	Solver(int nsize) {
		fact.resize(nsize, 0);
		fact[0] = 1;
		for (int i = 1; i < size(fact); ++i)
			fact[i] = (fact[i - 1] * i) % MODULO;
		c.resize(nsize, vector <LL> (nsize, 0));
		c[0][0] = 1;
		for (int n = 1; n < size(c); ++n) {
			c[n][0] = 1;
			for (int k = 1; k <= n; ++k)
				c[n][k] = (c[n - 1][k - 1] + c[n - 1][k]) % MODULO;
		}
		answer.resize(nsize, vector <LL> (nsize, 0));
		for (int i = 0; i < nsize; ++i)
			answer[0][i] = 1;
		for (int n = 1; n < nsize; ++n) {
			for (int k = 1; k < nsize; ++k) {
				for (int curr = 2; curr <= n && curr <= k; ++curr) {
					LL ways = (c[n - 1][curr - 1] * fact[curr - 1]) % MODULO;
					answer[n][k] = (answer[n][k] + ways * answer[n - curr][k]) % MODULO;
				}
			}
		}
	}
	inline int solve(int n, int k) {
		return (int) answer[n][k];
	}
};

int main()
{
	const bool contest = false;
	if (contest == true) {
		freopen("input.txt", "r", stdin);
		freopen("output.txt", "w", stdout);
	}
	int nTest = rInt();
	Solver solver(101);
	for (int test = 1; test <= nTest; ++test) {
		int n = rInt(), k = rInt();
		printf("%d\n", solver.solve(n, k));
	}
	return 0;
}

// Powered by PhoenixAI
