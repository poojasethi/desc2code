// C program to show segment tree operations like construction, query
// and update
#include <stdio.h>
#include <math.h>
 #include<stdlib.h>
// A utility function to get the middle index from corner indexes.
int getMid(int s, int e) {  return s + (e -s)/2;  }
 
/*  A recursive function to get the sum of values in given range
    of the array. The following are parameters for this function.
 
    st    --> Pointer to segment tree
    si    --> Index of current node in the segment tree. Initially
              0 is passed as root is always at index 0
    ss & se  --> Starting and ending indexes of the segment represented
                 by current node, i.e., st[si]
    qs & qe  --> Starting and ending indexes of query range */
 
int getSumUtil(int *st, int ss, int se, int qs, int qe, int si)
{
    // If segment of this node is completely inside the range query, then return
    // the sum of the segment.....i.e- the value of segment tree at the index=si
    if (qs <= ss && qe >= se)
        return st[si];
 
    // If segment of this node is outside the given range
    if (se < qs || ss > qe)
        return 0;
 
    // If a part of this segment overlaps with the given range
    int mid = getMid(ss, se);
    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +
           getSumUtil(st, mid+1, se, qs, qe, 2*si+2);
}
 
/* A recursive function to update the nodes which have the given 
   index in their range. The following are parameters
    st, si, ss and se are same as getSumUtil()
    i    --> index of the element to be updated. This index is 
             in input array.
   diff --> Value to be added to all nodes which have i in range */
 
/* 
It is very similar to the constructSTUtil() procedure, the only difference being that it follows only one path down the tree
(the one that leads to the leaf node being updated) and comes back up, recursively updating parent nodes along this same path.
*/
 
void updateValueUtil(int *st,int ss,int se,int i,int val,int si)
{
 
	if(i < ss || i > se)//If the given index(i) to be updated(arr[i]) is outside the range of the current segment,i.e-[ss,se]
		return;
 
	if(ss==se){
 
		st[si]=val;
 
		return ;
 
	}
 
	int mid=(ss+se)/2;
	//We want to update the node-st[si](i.e-the current node in which we are)....for that we have to update its children-st[2*si+1] and st[2*si+2]...
	//So we recur to its left and right child to uppdate them...
	updateValueUtil(st,ss,mid,i,val,si*2+1);
 
	updateValueUtil(st,mid+1,se,i,val,si*2+2);
 
 //Now after the two above recursive calls,the child of st[si] have been updated and so we can update st[si] also... 
	st[si]=st[2*si+1]+st[2*si+2];
 
}
 
 
// The function to update a value in input array and segment tree.
// It uses updateValueUtil() to update the value in segment tree
void updateValue(int arr[], int *st, int n, int i, int new_val)
{
    // Check for erroneous input index
    if (i < 0 || i > n-1)
    {
        printf("Invalid Input");
        return;
    }
 
    // Update the value in array
    arr[i] = new_val;
 
    // Update the values of nodes in segment tree
    updateValueUtil(st, 0, n-1, i, new_val, 0);
}
 
// Return sum of elements in range from index qs (quey start)
// to qe (query end).  It mainly uses getSumUtil()
int getSum(int *st, int n, int qs, int qe)
{
    // Check for erroneous input values
    if (qs < 0 || qe > n-1 || qs > qe)
    {
      //  printf("Invalid Input");
        return(0);
    }
 
    return getSumUtil(st, 0, n-1, qs, qe, 0);
}
 
// A recursive function that constructs Segment Tree for array[ss..se].
// si is index of current node in segment tree st
int constructSTUtil(int arr[], int ss, int se, int *st, int si)
{
    // If there is one element in array, store it in current node of
    // segment tree and return
    if (ss == se)
    {
        st[si] = arr[ss];
        return arr[ss];
    }
 
    // If there are more than one elements, then recur for left and
    // right subtrees and store the sum of values in this node
    int mid = getMid(ss, se);
    st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) +
              constructSTUtil(arr, mid+1, se, st, si*2+2);
    return st[si];
}
 
/* Function to construct segment tree from given array. This function
   allocates memory for segment tree and calls constructSTUtil() to
   fill the allocated memory */
int *constructST(int arr[], int n)
{
    // Allocate memory for segment tree
 
    //Height of segment tree
    int x = (int)(ceil(log2(n))); 
 
    //Maximum size of segment tree
    int max_size = 2*(int)pow(2, x) - 1; 
 
    // Allocate memory
    int *st = new int[max_size];
 
    // Fill the allocated memory st
    constructSTUtil(arr, 0, n-1, st, 0);
 
    // Return the constructed segment tree
    return st;
}
 
 int fakearr[1000009];
 int ans[1000009];
 int arr[1000009];
// Driver program to test above functions
int main()
{
	int T,N,i,curr;
	scanf("%d",&T);
	
	while(T--)
	{
		for(i=0;i<=1000007;i++)
			arr[i]=0;
		
		int n = sizeof(arr)/sizeof(arr[0]);
		int *st = constructST(arr, n);
		
		scanf("%d",&N);
		
		for(i=0;i<=N-1;i++)
			{
				scanf("%d",&fakearr[i]);
			}
			
		for(i=0;i<=N-1;i++)
			{
				curr=getSum(st,n,fakearr[i],fakearr[i]);
				ans[i]=getSum(st,n,1,fakearr[i]-1);		
				updateValue(arr, st, n, fakearr[i], curr+1);
			//	scanf("%d",&fakearr[i]);
			}
			
			
			for(i=0;i<=N-1;i++)
				printf("%d ",ans[i]);
				
				printf("\n");
		//		free(st);
	}
    
    
 
    // Build segment tree from given array
    
 /*
    // Print sum of values in array from index 1 to 3
    printf("Sum of values in given range = %d\n", 
            getSum(st, n, 1, 3));
 
    // Update: set arr[1] = 10 and update corresponding 
    // segment tree nodes
    
    //Note that if we want to increment arr[1] by 10 then we have to call -
    //updateValue(arr,st,n,1,arr[1]+10);
	
 
    // Find sum after the value is updated
    printf("Updated sum of values in given range = %d\n",
            getSum(st, n, 1, 3));
  */
  
    return 0;
}
 