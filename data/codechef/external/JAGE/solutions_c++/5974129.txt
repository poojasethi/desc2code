#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<set>
#include<vector>
#include<map>
#include<algorithm>

using namespace std;

#define maxn 300009
#define maxn1 100009
#define mod  1000000007
#define inf 10000009
#define gc getchar_unlocked

typedef long long ll;
typedef pair<int,int> ii;

int n,c;
int arr[maxn];

vector<int> v1[maxn1];
vector<int> :: iterator it1,it2;


struct segment
{
	int total,color,length,st1,ed1;
};

int read() {
  int ret = 0;
  char c = gc();
  while(c<'0' || c>'9') c = gc();
  while(c>='0' && c<='9') {
    ret = 10 * ret + c - 48;
    c = gc();
  }
  return ret;
}

segment tree[4*maxn];

int func(int color , int start , int end)
{
	it1 = lower_bound(v1[color].begin() , v1[color].end() , start);
	it2 = upper_bound(v1[color].begin() , v1[color].end() , end);
	
	if(it1!=v1[color].end() && it2!=v1[color].end())
	{
		int index1 = it1 - v1[color].begin() ;
		int index2 = it2 - v1[color].begin() ;

		index2--;

		if(v1[color][index2]<=end && v1[color][index2]>=start && v1[color][index1]>=start && v1[color][index1]<=end)
		return index2-index1 +1;

		else
		return 0;
	}
	
	else if(it1 != v1[color].end() && it2 == v1[color].end())
	return (v1[color].size() - ( it1-v1[color].begin() ) );

	else if(it1 == v1[color].end() && it2 == v1[color].end())
	return 0;
}


segment merge(segment node1 , segment node2,int start1,int end1 , int start2 , int end2)
{
	segment result;

	result.total = 0;
	result.color=-1;
	result.length=node1.length + node2.length;
	if(start1 != inf &&start2!=inf && end1!=inf && end2!=inf)
	{  
		result.st1 = start1;
		result.ed1 = end2;
	}
	else if(start1 == inf && start2 !=inf && end1==inf && end2!=inf)
	{
		result.st1 = start2;
		result.ed1 = end2;
	}
	else if(start1 != inf &&start2==inf && end1!=inf && end2==inf)
	{
		result.st1 = start1;
		result.ed1 = end1;
	}
	else 
	{
		result.st1 = inf;
		result.ed1 =inf;
		return result;
	}
	if(node1.color == -1 && node2.color == -1)
	{
		result.total = 0;
		result.color = -1;
	}
	else if(node1.color==-1 && node2.color!=-1)
	{
		int t1 = func(node2.color , start1 , end1);
		if(t1 + node2.total > (result.length/2))
		{
			result.total = node2.total+t1;
			result.color = node2.color;
		}
	}
	else if(node1.color != -1 && node2.color == -1)
	{
		int t1 = func(node1.color , start2 , end2);
		if(t1 + node1.total > (result.length/2))
		{
			result.total = node1.total + t1;
			result.color = node1.color;
		}
	}
	else if(node1.color != -1 && node2.color != -1)
	{
		int color1 = node1.color;
		int color2 = node2.color;
		if(color1==color2)
		{
			result.total = node1.total + node2.total;
			result.color = color1;
		}
		else
		{
			int t1=0,t2=0;
			t1 = func(color1,start2,end2);
			t2 = func(color2,start1,end1);

			int len1 = node1.length;
			int len2 = node2.length;
			
			if(((len1+len2)/2) < t1+ node1.total)
			{
				result.color = color1;
				result.total = t1+ node1.total;
			}
		  else if(((len1+len2)/2) < t2+ node2.total)
			{
				result.color = color2;
				result.total = t2 + node2.total;
			}
		}
	}

	return result;
}

void build_tree(int node, int a, int b) 
{
    if(a > b) return;

  	if(a == b) 
		{ 
    		tree[node].color = arr[a];
				tree[node].total = 1; 
				tree[node].length = 1;
				tree[node].st1 =a;
				tree[node].ed1 = b;
				return;
		}
		
		int mid = (a+b)/2;	
		int start1 = a;
		int end1 = mid;
		int start2 = mid+1;
		int end2 = b;

		build_tree(node*2, a, (a+b)/2); 
		build_tree(node*2+1, 1+(a+b)/2, b);
	
	  tree[node] = merge(tree[node*2], tree[node*2+1],tree[node*2].st1,tree[node*2].ed1,tree[node*2+1].st1,tree[node*2+1].ed1);
}

segment query_tree(int node, int a, int b, int i, int j) 
{
	segment res1,dummy,res2,res3,res4;

	dummy.total=0;
	dummy.color=-1;
	dummy.length=0;
	dummy.st1 = inf;
	dummy.ed1 = inf;
	if((a > b) || (a > j) || (b < i)) return dummy;

	
	if(a >= i && b <= j) 
	{
		res1.color = tree[node].color;
		res1.total = tree[node].total;
		res1.length = tree[node].length;
		res1.st1 = a;
		res1.ed1 = b;
		return res1;
	}
	
	int mid = (a+b)/2;
	int start1 = a;
	int end1 = mid;
	int start2 = mid+1;
	int end2 = b;
	
 	res1 = query_tree(node*2, a, (a+b)/2, i, j); 
	res2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); 

 	segment res = merge(res1,res2,res1.st1,res1.ed1,res2.st1,res2.ed1);

	return res;
}

int main() 
{
	//scanf("%d%d",&n,&c);
	n=read();
	c=read();
	for(int i=0;i<n;i++)
	{
		//scanf("%d",&arr[i]);
		arr[i] = read();
		v1[arr[i]].push_back(i);
	}

	build_tree(1,0,n-1);
	
	int m,l,r;
	scanf("%d",&m);
		
	for(int i=0;i<m;i++)
	{
		l=read();
		r = read();
		//scanf("%d%d",&l,&r);
		l--;
		r--;

		segment result = query_tree(1,0,n-1,l,r);

		if(result.color==-1)
		printf("no\n");
		else
		printf("yes %d\n",result.color);

	}
	return 0;
}
