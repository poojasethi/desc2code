#include <cstdio>
#include <cstring>
#include <vector>
#include <map>
#include <cmath>

using namespace std;

#define FOR(a,b,c) for(int a=(int)(b);a<=(int)(c);a++)
#define ll long long
#define pii pair<long long,long long>

int n;
vector<int> adj[10010];
int visit[10010];
ll ha[10010],fact[10010];
ll mod=1000000007;
int prime[10010];

int input()
{
	scanf("%d",&n);
	FOR(i,0,n-1) adj[i].clear();
	memset(ha,0,sizeof(ha));
	int a,b;
	FOR(i,0,n-2) 
	{
		scanf("%d%d",&a,&b);
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	return 0;
}

ll mypow(ll a, int n)
{
	ll rv = 1, p = a;
	
	while(n)
	{
		if(n&1) rv = (rv * p) % mod;
		p = (p * p) % mod;
		n>>=1;
	}
	
	return rv;
}

// expecting no collision b/w siblings 
ll findha(int u, int depth)
{
	ll rv=mypow(prime[adj[u].size()],depth);
	visit[u]=1;
	if(ha[u]) return ha[u];
	FOR(i,0,(int)adj[u].size()-1) if(!visit[adj[u][i]]) rv = (rv * findha(adj[u][i],depth+1))% mod;
	ha[u]=rv;
	return rv;
}

ll f(int u)
{
	ll rv=1;
	map< pii,int> h;
	int v;
	
	visit[u]=1;
	
	FOR(i,0,(int)adj[u].size()-1) 
	{
		v = adj[u][i];
		if(visit[v]) continue;
		ll tmp = f(v);
		h[pii(tmp,ha[v])]++;
	}
	
	map< pii,int>::iterator it;
	
	for(it=h.begin(); it!=h.end(); it++) 
	{
		rv = ( ((rv * mypow(it->first.first,it->second) )%mod) * fact[it->second])%mod;
	}
	
	return rv;
}

int solve()
{
	memset(visit,0,sizeof(visit));
	findha(0,0);
	memset(visit,0,sizeof(visit));
	return (int)f(0);
}

int sieve(int n)
{
	char arr[n+1];
	int limit=sqrt(n);
	memset(arr,0,sizeof(arr));
	arr[1]=1;
	FOR(i,2,limit)
	{
		if(arr[i]) continue;
		for(int j=i<<1;j<=n;j+=i) arr[j]=1;
	}
	int i=2,c=0;
	while(c<10010 && i<n)
	{
		if(!arr[i]) prime[c++]=i;
		i++;
	}	
	return 0;
}

int pre()
{
	fact[0]=1;
	FOR(i,1,10009) fact[i]=(fact[i-1]*i)%mod;
	sieve(110000);
	return 0;
}

int main()
{
	int test;
	//freopen("ip.txt","r",stdin);
	scanf("%d",&test);
	pre();
	while(test--)
	{
		input();
		printf("%d\n",solve());
	}
	return 0;
}

