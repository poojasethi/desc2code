#include<stdio.h>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<ctype.h>
#include<vector>
#include<algorithm>
#include<map>
#include<string>
#include<queue>
#include<stack>
using namespace std;

#define maxm 1000
#define inf (1<<29)
#define ii long long int

#define pii pair<int,ii>
#define mp  make_pair
#define uu first
#define vv second


ii mini(ii a,ii b){
    if(a<b) return a;
    return b;
}
ii maxi(ii a,ii b){
    if(a>b) return a;
    return b;
}

int B,P;
ii ans;
ii C[maxm],T[maxm],trip[maxm],rem[maxm];
queue<pii>q[maxm];


void cal(int ind,ii t,int now);

int main(){

    int i,j,k,l,test,t=1;

    //freopen("in.txt","r",stdin);
    //freopen("out1.txt","w",stdout);

    while(scanf("%d %d",&B,&P)==2){

        if(!B && !P) break;

        B=-B;

        memset(trip,0,sizeof(trip));
        memset(rem,0,sizeof(rem));

        ans=0;
        for(i=1;i<=B;i++){
            scanf("%d %d",&C[i],&T[i]);
            while(!q[i].empty()) q[i].pop();
        }

        if(!P){
            puts("0");
            continue;
        }

        cal(1,0,P);

        //printf("%d %d %d\n",rem[1],ans,trip[1]);
        for(i=1;i<=B;i++){
            while(rem[i]){
                cal(i,trip[i],0);
                //printf("ind= %d %d %d %d\n",i,rem[i],ans,trip[i]);
            }
        }

        printf("%lld\n",ans);

    }

    return 0;
}


void cal(int ind,ii t,int now){

    //printf("id = %d t= %d now= %d trip[id]=%d rem[id]=%d\n",ind,t,now,trip[ind],rem[ind]);

    if(ind>B){
        ans=maxi(ans,t);
        return ;
    }

    if(!rem[ind]){
        trip[ind]=maxi(trip[ind],t);
    }

    int i;

    for(i=1;i<=now;i++) q[ind].push(mp(1,t));
    rem[ind]=q[ind].size();

    int val=0;


    if(t<trip[ind]) return ;

    while(!q[ind].empty()){
        pii v=q[ind].front();
        if(v.vv<=trip[ind]){ val++; q[ind].pop(); }
        else break;
        if(val>=C[ind]) break;
    }
    rem[ind]=q[ind].size();
    if(val){
        cal(ind+1,trip[ind]+T[ind],val);
        trip[ind]+=T[ind];
    }
	else{
		if(q[ind].empty()) return ;
		pii v=q[ind].front();
		trip[ind]=v.vv;
		val=0;
		while(!q[ind].empty()){
			pii v=q[ind].front();
			if(v.vv<=trip[ind]){ val++; q[ind].pop(); }
			else break;
			if(val>=C[ind]) break;
		}
		rem[ind]=q[ind].size();
		cal(ind+1,trip[ind]+T[ind],val);
		trip[ind]+=T[ind];
	}

}
