#include<bits/stdc++.h>
using namespace std;
#define MAX 100001
#define ll long long int 
ll a[MAX];
ll tree[4*MAX];
ll lazy[4*MAX];
ll mid(ll x,ll y)
{   return (x+(y-x)/2);
}
void build(ll node,ll i,ll j)
{   if(i==j)
   {  tree[node]=a[i];
   }
   else
   {   build(2*node,i,mid(i,j));
       build(2*node+1,mid(i,j)+1,j);
       tree[node]=tree[2*node]+tree[2*node+1];
   }
}
void lazy_update(ll node,ll i,ll j,ll l,ll r,ll val)
{   if(lazy[node]!=0)
   {  tree[node]+=(j-i+1)*lazy[node];
     if(i!=j)
	 {  lazy[2*node]+=lazy[node];
	    lazy[2*node+1]+=lazy[node];
	 }
	 lazy[node]=0;
   }
   if(i>j||i>r||j<l)
   {  return;
   }
   if(i>=l&&j<=r)
   {    tree[node]+=(j-i+1)*val;
       if(i!=j)
       {   lazy[2*node]+=val;
          lazy[2*node+1]+=val;
	   }
	   return;
   }
   lazy_update(2*node,i,mid(i,j),l,r,val);
   lazy_update(2*node+1,mid(i,j)+1,j,l,r,val);
   tree[node]=tree[2*node]+tree[2*node+1];
}
ll lazy_query(ll node,ll i,ll j,ll l,ll r)
{    if(i>j||i>r||j<l)
     return 0;
    if(lazy[node]!=0)
   {    tree[node]+=(j-i+1)*lazy[node];
       if(i!=j)
       {    lazy[2*node]+=lazy[node];
            lazy[2*node+1]+=lazy[node];
	   }
	   lazy[node]=0;
   }
   if(i>=l&&j<=r)
   {   return tree[node];
   }
  ll p1=lazy_query(2*node,i,mid(i,j),l,r);
   ll p2=lazy_query(2*node+1,mid(i,j)+1,j,l,r);
   return (p1+p2);
   
}
int main()
{  
   int t;
  scanf("%d",&t);
  while(t--)
  {   memset(a,0,sizeof(a));
      memset(tree,0,sizeof(tree));
      memset(lazy,0,sizeof(lazy));
      ll n,c,p,q,v;
      scanf("%lld %lld",&n,&c);
      build((long long)1,(long long)1,n);
      while(c--)
      {    int ch;
          scanf("%d",&ch);
           if(ch==1)
           { 
              scanf("%lld %lld %lld",&p,&q,&v);
               lazy_update((long long)1,(long long)1,n,p,q,v);
		   }
		   else if(ch==2)
		   {   scanf("%lld %lld",&p,&q);
		      ll x=lazy_query((long long)1,(long long)1,n,p,q);
		      printf("%lld\n",x);
		   }
	  }
  }
  return 0;
}