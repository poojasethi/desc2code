#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define si(n) scanf("%d", &n);
#define s(n) scanf("%lld", &n);
#define MOD 1000000007
#define mp make_pair
#define pb push_back
 
ll segtree[500069], lazy[500069];
 
void buildTree(ll input[], ll low, ll high, ll pos)
{
	if(low == high)
	{
		segtree[pos] = input[low];
		return;
	}
	ll mid = (low+high)/2;
	buildTree(input, low, mid, 2*pos+1);
	buildTree(input, mid+1, high, 2*pos+2);
	segtree[pos] = min(segtree[2*pos+1], segtree[2*pos+2]);
}
 
void updateRange(ll qlow, ll qhigh, ll v, ll low, ll high, ll pos)
{
	
	if(low>high)
		return;
	if(lazy[pos] != 0)			//check if any updates from previous query are left to be done
	{
		segtree[pos] += (high-low+1)*lazy[pos];
		if(low!=high)
		{
			lazy[2*pos+1] += lazy[pos];
			lazy[2*pos+2] += lazy[pos];
		}
		lazy[pos]=0;
	}
	
	if(qlow>high || qhigh<low)			//no overlap
		return;
	if(qlow<=low && qhigh>=high)		//total overlap
	{
		segtree[pos] += (high-low+1)*v;
		if(low!=high)
		{
			lazy[2*pos+1] += v;
			lazy[2*pos+2] += v;
		}
		return;
	}
	ll mid= (low+high)/2;
	updateRange(qlow,qhigh,v,low,mid,2*pos+1);
	updateRange(qlow,qhigh,v,mid+1,high,2*pos+2);
	
	segtree[pos] = segtree[2*pos+1] + segtree[2*pos+2];
}
ll RangeSumQuery(ll qlow, ll qhigh, ll low, ll high, ll pos)
{
	if(low > high)
		return 0;
	if(lazy[pos] != 0)
	{
		segtree[pos] += (high-low+1)*lazy[pos];
		if(low != high)
		{
			lazy[2*pos+1] += lazy[pos];
			lazy[2*pos+2] += lazy[pos];
		}
		lazy[pos]=0;
	}
	if(qhigh<low || qlow>high)
		return 0;					//no overleap
	if(qlow<=low && qhigh>=high)
		return segtree[pos];			//total overlap
	ll mid = (low+high)/2;
	return (RangeSumQuery(qlow,qhigh,low,mid,2*pos+1) + RangeSumQuery(qlow,qhigh,mid+1,high,2*pos+2));
}
int main()
{
	ll te;
	s(te);
	while(te--)
	{
		memset(segtree,0,sizeof(segtree));
		memset(lazy,0,sizeof(lazy));
	ll v,q,x,y,n,t,tq,i,j,a[100005]={};
	s(n)s(q);
	ll size = log2(n);
	size = 2*(size+1)-1;
	
//	for(i=0;i<n;i++)
//		s(a[i]);	
	buildTree(a,0,n-1,0);
//	s(q);
	while(q--)
	{
		s(tq);
		if(tq==1)
		{
			s(x)s(y)s(v);
			updateRange(x-1,y-1,v,0,n-1,0);
		}
		else
		{
			s(x)s(y);
			printf("%lld\n", RangeSumQuery(x-1,y-1,0,n-1,0));
		}
	}
	}
	return 0;
} 