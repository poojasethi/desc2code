#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define mp make_pair
#define pb push_back

#define MOD 1000000007
const int N = 1e6;

struct Node{
	ll x, lazy, w;
	Node(): x(0), lazy(0), w(0) {}
	Node(ll x, ll lazy, ll w): x(x), lazy(lazy), w(w) {}
	void merge(Node &a, Node &b){
		x = a.x + b.x;
		w = a.w + b.w;
		lazy = 0;
	}
	void split(Node &a, Node &b){
		a.x += a.w * lazy;
		b.x += b.w * lazy;
		a.lazy += lazy;
		b.lazy += lazy;
		lazy = 0;
	}
	void update(ll val){
		lazy += val;
		x += val * w;
	}
};
Node tree[N];

void makeTree(int root, int sz){
	if (root < sz){
		makeTree(root * 2, sz);
		makeTree(root * 2 + 1, sz);
		tree[root].merge(tree[root * 2], tree[root * 2 + 1]);
	}
}

void range_update(int root, int L, int R, int l, int r, ll val){
	if (l <= L && R <= r){
		tree[root].update(val);
		return ;
	}
	int lc = root << 1, rc = lc | 1, mid = (L + R) >> 1;
	tree[root].split(tree[lc], tree[rc]);
	if (l <= mid) range_update(lc, L, mid, l, r, val);
	if (r > mid) range_update(rc, mid + 1, R, l, r, val);
	tree[root].merge(tree[lc], tree[rc]);
}

Node range_query(int root, int L, int R, int l, int r){
	if (l <= L && R <= r) return tree[root];
	int lc = root << 1, rc = lc | 1, mid = (L + R) >> 1;
	tree[root].split(tree[lc], tree[rc]);
	Node lq = Node(), rq = Node();
	if (l <= mid) lq = range_query(lc, L, mid, l, r);
	if (r > mid) rq = range_query(rc, mid + 1, R, l, r);
	tree[root].merge(tree[lc], tree[rc]);
	lq.merge(lq, rq);
	return lq;
}
int main()
{	
	int t;
	cin >> t;
	while (t--){
		for (int i = 0; i < N; i++)
			tree[i] = Node();
		int n, q;
		cin >> n >> q;
		int ht = (int)ceil(log(n) / log(2.0));
		int sz = 1 << ht;
		for (int i = 0; i < n; i++)
			tree[i + sz].w = 1LL;
		makeTree(1, sz);
		while (q--){
			int type, u, v;
			cin >> type >> u >> v;
			if (type == 1){
				ll x;
				cin >> x;
				range_update(1, 1, sz, u, v, x);
			}
			else{
				cout << range_query(1, 1, sz, u, v).x << endl;
			}
		}
	}
	return 0;
}