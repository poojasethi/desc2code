#include <iostream>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <vector>
#include<stack>
#include<set>
#include<limits.h>
#include <queue>
#include <map>
#include <cstdlib>
#include <algorithm>
//psyduck
#define ll long long
#define S(x) scanf("%d",&x)
#define Sf(x) scanf("%f",&x)
#define Slf(x) scanf("%lf",&x)
#define Sl(x) scanf("%lld",&x)
#define P(x)  printf("%d\n", x)
#define Pf(x)  printf("%f\n", x)
#define Plf(x)  printf("%lf\n", x)
#define Pl(x)  printf("%lld\n", x)
#define mem(x,i) memset(x,i,sizeof(x))
#define mod 1000000007
using namespace std;

void dba(ll int debug_array[],int n){
    for (int i = 1; i <= n; i++)cout << debug_array[i]<<" ";
    cout << endl;
}
void db2a(int debug2d[100][100],int n, int m)
{
    for (int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cout << debug2d[i][j];
        cout << endl;
}
ll int lazy[400005];
ll int seg[400005];
ll int l,r;
void construction(ll int node, ll int b, ll int e);
void update_lazy(ll int node, ll int b, ll int e, ll int diff);
ll int query_lazy(ll int node, ll int b, ll int e);
int main()
{
    ll int t,i,n,q,type,diff;
    Sl(t);
    while(t--){
        mem(lazy,0);
        mem(seg,0);
        Sl(n);Sl(q);
        while(q--){
            Sl(type);
            if(type == 1){
                Sl(l);Sl(r);Sl(diff);
                update_lazy(1,1,n,diff);
               // dba(seg,10);
                //dba(lazy,10);
            }
            else{
                Sl(l);Sl(r);
                ll int ans = query_lazy(1,1,n);
                Pl(ans);
            }
        }
    }
}
void update_lazy(ll int node, ll int b, ll int e, ll int diff)
{
    if(lazy[node] != 0){
        seg[node] = seg[node]+(e-b+1)*lazy[node];
        if(b != e){
            lazy[2*node] = lazy[2*node]+lazy[node];
            lazy[2*node+1] = lazy[2*node+1]+lazy[node];
        }
        lazy[node] = 0;
    }
    if(e < l ||b > r){
        return ;
    }
    if(b >= l && e <= r){
        seg[node] = seg[node] + (e-b+1)*diff;
        if(b != e){
            lazy[2*node] = lazy[2*node]+diff;
            lazy[2*node+1] = lazy[2*node+1]+diff;
        }
        return ;
    }
    ll int mid = (b+e)/2;
    update_lazy(2*node,b,mid,diff);
    update_lazy(2*node+1,mid+1,e,diff);
    seg[node] = seg[2*node] + seg[2*node+1];
}
ll int query_lazy(ll int node, ll int b, ll int e)
{
    if(lazy[node] != 0){
        seg[node] = seg[node]+(e-b+1)*lazy[node];
        if(b != e){
            lazy[2*node] = lazy[2*node]+lazy[node];
            lazy[2*node+1] = lazy[2*node+1]+lazy[node];
        }
        lazy[node] = 0;
    }
    if(b > r || e < l){
        return 0;
    }
    if(b >= l && e <= r){
        return seg[node];
    }
    ll int mid = (b+e)/2;
    ll int x = query_lazy(2*node,b,mid);
    ll int y = query_lazy(2*node+1,mid+1,e);
    return x+y;
}
