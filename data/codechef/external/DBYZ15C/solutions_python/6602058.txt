#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <string>
#include <stack>
#include <cmath>
#include <list>
#include <iomanip>
#include <set>
#include <map>
#include <sstream>
#include <fstream>
#include <string.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

typedef tree<int, null_type, less<int>, rb_tree_tag,
		tree_order_statistics_node_update> ordered_tree;
typedef long long LL;
typedef pair<int, int> PII;
typedef pair<LL, LL> PLL;
typedef vector<int> VI;

#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))
#define RFOR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))
#define For(i,a,b) for(int (i)=(a);i<(b);++(i))
#define FoR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))
#define INF 1000000001
#define LINF 1000000000000000001ll
#define PB push_back
#define EPS 1e-7
#define X first
#define Y second
#define MP make_pair
#define ITER(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)
#define FILL(A,value) memset(A,value,sizeof(A))
#define ALL(V) V.begin(), V.end()

LL n, m, k;

int mod = 1000000007;
int a, b;
struct matrix {
	LL a[47][47];
	matrix() {
		FILL(a, 0);
	}
	matrix(int x) {
		FILL(a, 0);
		FOR(i,0,n)
			a[i][i] = x;
	}
	matrix operator *(matrix b) {
		matrix res;
		FOR(i,0,n)
			FOR(j,0,n)
				FOR(k,0,n)
				{
					res.a[i][j] += (a[i][k] * b.a[k][j]) % mod;
					res.a[i][j] %= mod;
				}
		return res;
	}

	matrix operator+(matrix b) {
		matrix res;
		FOR(i,0,n)
			FOR(j,0,n)
				res.a[i][j] = (a[i][j] + b.a[i][j]) % mod;
		return res;
	}
};

matrix po(matrix a, LL p) {
	if (p == 0)
		return matrix(1);
	if (p % 2)
		return po(a, p - 1) * a;
	matrix t = po(a, p / 2);
	return t * t;
}
matrix sum(matrix a, LL p) {
	if (p == 1)
		return a;
	if (p % 2)
		return sum(a, p - 1) + po(a, p);
	matrix z = sum(a, p / 2);
	return z + (z * po(a, p / 2));
}
matrix g;
int main() {
//freopen("collect.in","r",stdin);
//freopen("collect.out","w",stdout);
	ios::sync_with_stdio(0);
	cin >> n >> m >> k;
	FOR(i,0,m)
	{
		cin >> a >> b;
		--a;
		--b;
		g.a[a][b]++;
	}
	g = sum(g, k);
	int q;
	cin >> q;
	FOR(i,0,q)
	{
		cin >> a >> b;
		--a;
		--b;
		cout << g.a[a][b] << endl;
	}
	return 0;
}
