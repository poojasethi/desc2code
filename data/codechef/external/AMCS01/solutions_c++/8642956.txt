#include <bits/stdc++.h>
#define ll long long int
#define s(a) scanf("%lld",&a)
#define f first
#define sc second
#define mp make_pair
#define pb push_back
#define inf 10e16

using namespace std;

vector<ll>v[200001];
ll length[200001]={0};
ll deep[200001]={0};
ll extra[200001]={0};
ll extra2[200001]={0};
vector<ll>path,temp;
ll mx,node;
ll prev[100001]={0};

void dfs(ll ind)
{
    bitset<100001>visit;
    ll nod,depth;
    queue<pair<ll,ll> >q;
    q.push(mp(ind,0));
    while(!q.empty()) {
        nod=q.front().f;
        depth=q.front().sc;
        if(depth>mx) {
            mx=depth;
            node=nod;
        }
        visit[nod]=1;
        q.pop();

        for(ll i=0;i<v[nod].size();i++) {
            if(visit[v[nod][i]]==1) continue;
            q.push(mp(v[nod][i],depth+1));
            prev[v[nod][i]]=nod;
        }
    }
}

void dfs2(ll ind,ll depth,ll last)
{
    deep[ind]=depth;
    ll flag=0;
    for(ll i=0;i<v[ind].size();i++) {
        if(v[ind][i]==last) continue;
        flag=1;
        dfs2(v[ind][i],depth+1,ind);
        extra[ind]+=extra[v[ind][i]];
        extra2[ind]+=extra2[v[ind][i]];
    }
    if(flag==0) {
        length[depth]++;
        if(depth==mx) {
            extra[ind]=1;
        }
        else if(depth == mx-1) {
            extra2[ind]=1;
        }
    }
}

void dfs3(ll ind,ll last)
{
    if(last!=-1) {
        extra[ind]=max(extra[ind],extra[last]);
        extra2[ind]=max(extra2[ind],extra2[last]);
    }
    for(ll i=0;i<v[ind].size();i++) {
        if(v[ind][i]==last) continue;
        dfs3(v[ind][i],ind);
    }
}

int main()
{
    //freopen("inp.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    ll n,i,j,k,l,w,ww,x,y,z,diameter;
    s(n);
    for(i=1;i<n;i++) {
        s(x);s(y);
        v[x].pb(y);
        v[y].pb(x);
    }
    if(n==1) while(1);
    if(n==2) {
        cout<<"1 1\n";
        return 0;
    }
    mx=0;
    node=0;
    dfs(0);
    w=node;
    mx=0;
    dfs(w);
    ww=node;
    diameter=mx;

    ll ha=ww;

    while(ha != w) {
        path.pb(ha);
        ha=prev[ha];
    }
    path.pb(ha);

    ll centre=path[diameter/2];
    diameter++;
    mx=diameter/2;
    dfs2(centre,0,-1);

    extra[centre]=0;
    extra2[centre]=0;
    dfs3(centre,-1);

    for(i=0;i<n;i++) {
        if(extra[i]==length[mx]) {
            cout<<length[mx-1]-extra2[i]<<" ";
        }
        else cout<<length[mx]-extra[i]<<" ";
    }
    cout<<endl;
    return 0;
}