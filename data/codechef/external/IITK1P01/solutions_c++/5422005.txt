#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define ll long long
 
const int mod=1000000007;
long long pwr(long long a,long long b,long long mod)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2,mod);
  temp=(temp*temp)%mod;
  if(b&1)
    temp=(temp*a)%mod;
  return temp;
}
long long pwr(long long a,long long b)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2);
  temp=(temp*temp);
  if(b&1)
    temp=(temp*a);
  return temp;
}
long long gcd(long long a,long long b)
{
  return b==0?a:gcd(b,a%b);
}
long long lcm(long long a,long long b)
{  
  return (a/gcd(a,b))*b;
}
long long modularInverse(long long a,long long m)
{
      return pwr(a,m-2,m);
}
bool* isPrime;
void generatePrimeSieve(const int lim)
{
  isPrime=(bool *)malloc(lim+1);
  memset(isPrime,true,lim+1);
  isPrime[0]=false;
  isPrime[1]=false;
  for(int i=2;i<=lim;++i)
    if(isPrime[i])
      for(int j=i+i;j<=lim;j+=i)
        isPrime[j]=false;
}
#define matrix vector<vector<int> >
matrix identityMatrix;
matrix mul(const matrix &a,const matrix &b)
{
  int n=a.size();
  matrix ans(n,vector<int> (n) );
  for (int i = 0; i < n; ++i)
  {
    for (int j = 0; j < n; ++j)
    {
      for (int k = 0; k < n; ++k)
      {
        ans[i][j]+= ((long long)a[i][k]*b[k][j])%mod;
        ans[i][j]%=mod;
      }
    }
  }
  return ans;
} 
matrix pwr(const matrix &a,long long n)
{
    if(n==0)
    {
      /*define identity */
      assert(false);
      return identityMatrix;
    }
    if(n==1)
     return a;
    matrix tmp=pwr(a,n/2);
    tmp=mul(tmp,tmp);
    if(n&1)
      tmp=mul(a,tmp);
    return tmp;
}
int dist[202][202];
int v,e,k;
int goodCity[20];
 
int evaluate(int mask)
{
  vector<int> a;
  vector<int> b;
  for(int i=k;i<k+k;++i)
  {
 
    if(mask&(1<<i))
      a.push_back(i-k);
    else
      b.push_back(i-k);
  }
 
  int ans=0;
  for(int i=0;i<a.size();++i)
  {
    int u=a[i];
    u=goodCity[u];
    for(int j=0;j<b.size();++j)
    {
      int v=b[j];
      v=goodCity[v];
      ans+=dist[u][v];
    }
 
  }
 
  return ans;
}
 
int dpMax(int,int);
int dpMin(int,int);
 
int DPMAX[1<<24];
int DPMIN[1<<24];
bool DONEMAX[1<<24];
bool DONEMIN[1<<24];
 
/* first half of mask represents occupied or not. second half decides which king */
int dpMax(int mask,int freeCities)
{
  if(DONEMAX[mask])
    return DPMAX[mask];
  DONEMAX[mask]=true;
  if(freeCities==0)
  {
    return DPMAX[mask]=evaluate(mask);
  }
 
  int ans=-1e9;
  for(int i=0;i<k;i++)
  {
    /* city is occupied */
    if(mask&(1<<i))
      continue;
    /* assign city to king 1 : make bit  */
    int newMask=mask|(1<<(k+i));
    newMask|=(1<<i);
    ans=max(ans,dpMin(newMask,freeCities-1));
  }
  return DPMAX[mask]=ans;
}
 
int dpMin(int mask,int freeCities)
{
  if(DONEMIN[mask])
    return DPMIN[mask];
  DONEMIN[mask]=true;
  
  if(freeCities==0)
  {
    return DPMIN[mask]=evaluate(mask);
  }
 
  int ans=1e9;
  for(int i=0;i<k;i++)
  {
    /* city is occupied */
    if(mask&(1<<i))
      continue;
    /* assign city to king 2 : make bit 0  */
    int newMask=mask&(~(1<<(k+i))) ;
    newMask|=(1<<i);
 
    ans=min(ans,dpMax(newMask,freeCities-1));
  }
  return DPMIN[mask]=ans;
}
int main()
{
  std::ios::sync_with_stdio(false);
  
  cin>>v>>e>>k;
 
  for (int i = 0; i < 200; ++i)
  {
    for (int j = 0; j < 200; ++j)
    {
      dist[i][j]=1e9;
    }
  }
  
  
 
  
  for(int i=0;i<e;++i)
  {
    int x,y,w;
    
    cin>>x>>y>>w;
    --x;
    --y;
    dist[x][y]=w;
    dist[y][x]=w;
  }
 
  for (int kk = 0; kk < 200; ++kk)
  {
    for (int j = 0; j < 200; ++j)
    {
      for (int i = 0; i < 200; ++i)
      {
        dist[i][j]=min(dist[i][j],dist[i][kk]+dist[kk][j]);
      }
    }
  }
  
  for(int i=0;i<k;++i)
  {
    cin>>goodCity[i];
    --goodCity[i];
  }
  cout<<dpMax(0,k);
 
 
  
} 