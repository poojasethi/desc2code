/*Author: Rishul Aggarwal*/

#include<bits/stdc++.h>

#define mod 1000000007
#define ll long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define in(type,x) scanf("%" #type,&x)
#define debug(args...) {dbg,args; cerr<<endl;}
#define test int t;\
in(d,t);\
while(t--)

using namespace std;

struct debugger
{template<typename T> debugger& operator,(const T& v)
{cerr<< v <<" ";
return *this;
}
}dbg;

ll gcd(ll a,ll b) {if(b==0) return a; return gcd(b,a%b);}

ll power(ll b,ll exp,ll m) {ll ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; }

int v,e,k;
int a[205][205];
int good[205];

map <pair<pair<int,int>,int>,int >store;

void floydWarshall()
{
	rep(k,1,v)
	 rep(i,1,v)
	  rep(j,1,v)
	   a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	   
}


int solve(int x,int y,int turn)
{
	pair<pair<int,int>,int> p=make_pair(make_pair(x,y),turn);
	if(store[p]) return store[p];
	
	int ans=0;
	if(turn==k)
	{
		
		rep(i,0,k-1)
		 if((x>>i)&1)
		  rep(j,0,k-1)
		   if((y>>j)&1)
		  	ans+=a[good[i]][good[j]];
	}
		
	else if(turn%2==0)
	{
	
		ans=1e-9;
		rep(i,0,k-1)
		 {
		 	if(((x>>i)&1) || ((y>>i)&1)) continue;
		 	else
		 	{
		 		ans=max(ans,solve(x|(1<<i),y,turn+1));
		 	}
		 }
				 	 
	}
	else
	{
		ans=1e9;
		rep(i,0,k-1)
		 {
		 	if(((x>>i)&1) || ((y>>i)&1)) continue;
		 	else
		 	{
		 		ans=min(ans,solve(x,y|(1<<i),turn+1));
		 	}
		 }
		
	}
	
	return store[p]=ans;
		
}


int main()
{
  in(d,v),in(d,e),in(d,k);
  
  rep(i,1,v) rep(j,1,v) a[i][j]=1e9,a[i][i]=0;
  
  rep(i,1,e)
   {
   	 int x,y,w;
   	 in(d,x),in(d,y),in(d,w);
   	 a[x][y]=a[y][x]=w;
   }
   
  floydWarshall();
   
   /*rep(i,1,v)
    {rep(j,1,v) cout<<a[i][j]<<" ";
     cout<<endl;}*/
  
  rep(i,0,k-1)
   in(d,good[i]);
   
  printf("%d\n",solve(0,0,0));  	
  

  return 0;
}
