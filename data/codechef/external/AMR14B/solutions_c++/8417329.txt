#include <bits/stdc++.h>

using namespace std;

#define ll long long

const int maxn = 1000010;

struct node{
	int dest;
	ll wt;
};

struct edge{
	int strt, dest;
	ll wt;
	bool operator<(const edge&n) const{
		return wt<n.wt;
	}
};

struct subset{
	int parent, rank;
};

vector<node> adj[maxn];
vector<edge> vec;
int vis[maxn];
ll dist[maxn], prev_wt[maxn];
subset dsu[maxn];

void dfs(int src)
{
	vis[src] = 1;
	int i;
	for(i=0; i<adj[src].size(); i++){
		if(!vis[adj[src][i].dest])
			dfs(adj[src][i].dest);
	}
}

int find_parent(int cur)
{
	if(dsu[cur].parent==cur)
		return cur;
	return find_parent(dsu[cur].parent);
}

int main()
{
	//freopen("i.txt", "r", stdin);
	int t, n, i, j, m, u, v, f, edges_taken, p1, p2, cur;
	ll mst_wt, d_wt, w, cdist;
	scanf("%d", &t);
	while(t--){
		scanf("%d%d", &n, &m);
		for(i=0; i<=n; i++)
			adj[i].clear(), vis[i] = 0, dist[i] = 1ll<<50, prev_wt[i] = 0;
		vec.clear();
		for(i=0; i<m; i++){
			scanf("%d%d%lld", &u, &v, &w);
			adj[u].push_back((node){v, w});
			adj[v].push_back((node){u, w});
			vec.push_back((edge){u, v, w});
		}
		dfs(0);
		f = 1;
		for(i=0; i<n; i++){
			if(!vis[i]){
				f = 0;
				break;
			}
		}
		if(!f){
			printf("NO\n");
			continue;
		}
		for(i=0; i<n; i++){
			dsu[i].parent = i;
			dsu[i].rank = 0;
		}
		sort(vec.begin(), vec.end());
		mst_wt = edges_taken = i = 0;
		while(edges_taken<n-1 && i<m){
			u = vec[i].strt, v = vec[i].dest, w = vec[i].wt;
			i++;
			p1 = find_parent(u), p2 = find_parent(v);
			if(p1==p2)
				continue;
			if(dsu[p1].rank<dsu[p2].rank)
				dsu[p1].parent = p2;
			else if(dsu[p2].rank<dsu[p1].rank)
				dsu[p2].parent = p1;
			else{
				dsu[p1].parent = p2;
				dsu[p2].rank++;
			}
			edges_taken++;
			mst_wt+=w;
		}
		priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > q;
		dist[0] = 0;
		q.push(make_pair(0, 0));
		while(!q.empty()){
			cdist = q.top().first;
			cur = q.top().second;
			q.pop();
			if(cdist>dist[cur])
				continue;
			for(i=0; i<adj[cur].size(); i++){
				if(cdist+adj[cur][i].wt<dist[adj[cur][i].dest]){
					dist[adj[cur][i].dest] = cdist+adj[cur][i].wt;
					prev_wt[adj[cur][i].dest] = adj[cur][i].wt;
					q.push(make_pair(dist[adj[cur][i].dest], adj[cur][i].dest));
				}
				else if(cdist+adj[cur][i].wt==dist[adj[cur][i].dest]){
					if(prev_wt[adj[cur][i].dest] > adj[cur][i].wt)
						prev_wt[adj[cur][i].dest] = adj[cur][i].wt;	
				}
			}
		}
		d_wt = 0;
		for(i=0; i<n; i++)
			d_wt+=prev_wt[i];
		if(mst_wt==d_wt)
			printf("YES\n");
		else
			printf("NO\n");
	}
	return 0;
}