#include <bits/stdc++.h>

using namespace std;

#define ff first
#define ss second
#define mpa make_pair

int N;
int M;

vector<pair<int, long long> > Gra[100002];
int Par[100002];
int Path[100002];
long long Dis[100002];
long long Lst[100002];
bool Vis[100002];
bool vis[100002];
vector<pair<int, pair<int, long long> > > Vec;

void init()
{
    Vec.clear();
    for(int i = 0; i <= N; ++i) {
        Gra[i].clear();
        Par[i] = -1;
        Dis[i] = 1e11;
        Vis[i] = false;
        vis[i] = false;
        Path[i] = 0;
        Lst[i] = 0;
    }
}

inline bool cmp(pair<int, pair<int, long long> > P1, pair<int, pair<int, long long> > P2)
{
    return P1.ss.ss < P2.ss.ss;
}

int Find(int Node)
{
    if(Par[Node] == -1)
            return Node;
    return Par[Node] = Find(Par[Node]);
}

void Uni(int x, int y)
{
    if(x > y)
            swap(x, y);
    Par[y] = x;
}

long long Dij(int So)
{
    priority_queue<pair<long long, pair<long long, int> > , vector<pair<long long, pair<long long, int> > >, greater<pair<long long, pair<long long, int> > > > Que;
    Que.push(mpa(0, mpa(0, 0)));
    Dis[0] = 0;

    while(!Que.empty()) {
        pair<long long, pair<long long, int> > P = Que.top();
        Que.pop();
        
        if(Vis[P.ss.ss])
                continue;

        int u = P.ss.ss;
        int sz = Gra[u].size();
        for(int i = 0; i < sz; ++i) {
            int v = Gra[u][i].ff;
            if(Dis[v] > Dis[u] + Gra[u][i].ss || (Dis[v] == Dis[u] + Gra[u][i].ss && Gra[u][i].ss < Lst[v])) {
                Dis[v] = Dis[u] + Gra[u][i].ss;
                Lst[v] = Gra[u][i].ss;
                Path[v] = u;
                Que.push(mpa(Dis[v], mpa(Lst[v], v)));
            }
        }

        Vis[u] = true;
    }

    long long Cst = 0;
    for(int i = 0; i < N; ++i) {
        Cst += Lst[i];
    }

    return Cst;

}

void Dfs(int v)
{
    Vis[v] = true;
    int sz = Gra[v].size();
    for(int i = 0; i < sz; ++i) {
        int u = Gra[v][i].ff;
        if(!Vis[u])
                Dfs(u);
    }
}

bool All_V()
{
    Dfs(0);
    bool flg = true;
    for(int i = 0; i < N; ++i) {
        if(!Vis[i]) {
            flg = false;
        }
    }

    for(int i = 0; i < N; ++i)
            Vis[i] = false;
    return flg;
}

int main()
{
    int T;
    scanf("%d", &T);

    while(T--) {
        scanf("%d%d", &N, &M);
        init();
        for(int i = 0; i < M; ++i) {
            int u;
            int v;
            long long w;
            scanf("%d%d%lld", &u, &v, &w);
            Gra[u].push_back(mpa(v, w));
            Gra[v].push_back(mpa(u, w));
            Vec.push_back(mpa(u, mpa(v, w)));
        }

        bool is = All_V();
        if(!is) {
            puts("NO");
            continue;
        }
        
        long long MSPC = 0;
        sort(Vec.begin(), Vec.end(), cmp);
        for(int i = 0; i < M; ++i) {
            int u = Vec[i].ff;
            int v = Vec[i].ss.ff;
            long long w = Vec[i].ss.ss;
            
            int pu = Find(u);
            int pv = Find(v);
            if(pu != pv) {
                Uni(pu, pv);
                MSPC += w;
            }
        }

        long long DC = Dij(0);
        if(MSPC == DC) {
            puts("YES");
        } else {
            puts("NO");
        }
    }

    return 0;
}
