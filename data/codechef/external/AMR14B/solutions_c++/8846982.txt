#include <bits/stdc++.h>
 
using namespace std;
 
#define N 20005
#define INF 1e18
#define F first
#define S second
#define MP make_pair
typedef long long ll;
typedef pair<ll, pair<ll,ll> > pi;
 
ll parent[N];
bool vis[N];
ll d[N];
ll pre[N];
ll m, n;
vector< vector< pair<ll, ll> > > graph;
 
void dijkstra()
{
	memset(vis, 0, sizeof vis);
	fill(d, d + N, INF);
	fill(pre, pre + N, INF);
	d[0] = 0;
	pre[0] = 0;
	priority_queue< pi, vector<pi>, greater<pi> > q;
	q.push( MP(0, MP(0, 0)) );
	while(!q.empty())
	{
		pi temp = q.top();
		q.pop();
		ll u = temp.S.S;
		if(vis[u]) continue;
		vis[u] = true;
		for(ll i = 0; i < graph[u].size(); i++)	
		{
			ll v = graph[u][i].F;
			ll wt = graph[u][i].S;
			if(!vis[v] && ((d[v] > d[u] + wt) || (d[v] == d[u] + wt && pre[v] > wt)))
			{
				d[v] = d[u] + wt;
				pre[v] = wt;
				q.push( MP(d[v], MP(pre[v], v)) );
			}
		}	
	}
}
 
struct edge
{
	ll x, y, cost;
};
 
vector<edge> graph1;
 
bool cmp(edge a, edge b)
{
	return a.cost < b.cost;
}
 
ll findset(ll i)
{
	if(i != parent[i])
		parent[i] = findset(parent[i]);
	return parent[i];
}
 
ll kruskal()
{
	sort(graph1.begin(), graph1.end(), cmp);
	ll weight = 0;
	ll used = 0;
	for(ll i = 0; i < m && used != n - 1; i++)
	{
		ll u = graph1[i].x;
		ll v = graph1[i].y;
		ll pu = findset(u);
		ll pv = findset(v);
		if(pu == pv)
			continue;
		used++;
		parent[pv] = pu;
		weight += graph1[i].cost;
	}
	return weight;
}
 
int main()
{
	ios :: sync_with_stdio(false);
	ll t;
	ll i, flag;
	ll a, b, w;
	cin >> t;
	while(t--)
	{
		cin >> n >> m;
		graph.clear();
		graph.resize(n);
		graph1.clear();
		edge ob;
		for(i = 0; i < m; i++)		
		{
			cin >> a >> b >> w;
			graph[a].push_back( MP(b, w) );
			graph[b].push_back( MP(a, w) );
			ob.x = a;
			ob.y = b;
			ob.cost = w;
			graph1.push_back(ob);
		}
		dijkstra();
		ll dijkstra_weight = 0;
		flag = 0;
		for(i = 0; i < n; i++)
		{
			if(pre[i] == INF) // Graph is disconnected
			{
				flag = 1;
				break;
			}
			dijkstra_weight += pre[i];
		}
		if(flag)
		{
			cout << "NO" << endl;
			continue;	
		}
		for(i = 0; i < n; i++)
			parent[i] = i;
		ll mst_weight = kruskal();
		// cout << mst_weight << " " << dijkstra_weight << endl;
		if(mst_weight == dijkstra_weight)
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
	}	
	return 0;
}