#include<bits/stdc++.h>
#define intMAX 1123456789LL
#define MAX intMAX * intMAX
#define F first
#define S second
#define mp make_pair
#define ll long long
#define pb push_back
#define pv(v,b,a) v.insert(v.begin()+b,a)
#define all(c) c.begin(),c.end()
#define sf(a) scanf("%d",&a);
#define sl(a) scanf("%lld",&a);
#define MAXCR 1000000000
#define mem(arr,a) memset(arr, a, sizeof arr)
#define er(vec,a,b) vec.erase(vec.begin() + a, vec.begin() + b+1)
#define traverse(a) for()
#define pii pair<int ,int>
#define mod 1000000007
#define LIM 100
using namespace std;
/*
list as pop_front();push_front(ELEMENT);
list as pop_front();push_back(ELEMENT);
to see first element stack=q.front()
to see last element queue=q.back()
*/
//str.insert(6,str3,3,4); to insert 4 words from str3 starting from 3rd position(0 based indexing) to str from 6th position (0 based indexing)
//str.find("live");//finds first occurance of string and returns its 0 based indes
//string str1=str.substr (a,n);//a=0 based start index,n=length of words//if length not given substring till end is formed
//auto bound_=upper_bound (v.begin(), v.end(), 20); //Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.
//auto bound_=lower_bound (v.begin(), v.end(), 20);//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
//bool ans=binary_search();//Returns true if any element in the range [first,last) is equivalent to val, and false otherwise.
/*
//for(???<???>:iterator itr;itr!=???.end();itr++) or for(auto &tt : t.edges)
map<double,LL>my;
map<double,LL>:: iterator it;
for(it=my.begin();it!=my.end();it++)
*/
//getline(cin,s,'\n');  to get input terminating at'\n';excluding '\n'
//(a/b)%m = ((a%m)(b^(m-2)%m))%m.
//(a^b)%m=
//vector<ll>v(size,default val);
//reverse(all(s))//to reverse some vector or string;
//cin.eof() //checks for end of file return true when cin takes input as end of file
vector<pair<ll,ll> >gp[20001];
vector<pair<ll,pair<ll,ll> > >v;
set<pair<ll,ll> >q1;
ll d[20001],D[20001],flag,rank_[20001],node[20001];
void pre()
{
	ll i;
	v.clear();
	flag=0;
	for(i=0;i<20001;i++)
	{
		d[i]=MAX;
		D[i]=0;
		rank_[i]=0;
		node[i]=i;
		gp[i].clear();
	}
}
bool comp(pair<ll,pair<ll,ll> > a,pair<ll,pair<ll,ll> > b)
{
	if(a.F<b.F)
	{
		return true;
	}
	return false;
}
ll find_(ll x)
{
	if(x==node[x])
		return x;
	return node[x]=find_(node[x]);
}
void union_(ll a,ll b)
{
	if(rank_[a]>rank_[b])
		node[b]=a;
	else if(rank_[b]>rank_[a])
		node[a]=b;
	else
	{
		node[a]=b;
		rank_[b]++;
	}
}
ll krus()
{
	ll cnt=0,a,b,c,leader1,leader2,i;
	sort(all(v),comp);
	for(i=0;i<v.size();i++)
	{
		a=v[i].S.F;
		b=v[i].S.S;
		c=v[i].F;
		leader1=find_(a);
		leader2=find_(b);
		if(leader1==leader2)
			continue;
		cnt+=c;
		union_(leader1,leader2);
	}
	return cnt;
}
ll dik(ll n)
{
	d[0]=0;
	ll cnt=0,v,i,u,cost;
	q1.insert(mp(0,0));
	while(!q1.empty())
	{
		pair<ll,ll>top=*q1.begin();
		q1.erase(q1.begin());
		v=top.S;
		for(i=0;i<gp[v].size();i++)
		{
			u=gp[v][i].F;
			cost=gp[v][i].S;
			if(cost+d[v]<d[u])
			{
				if(d[u]!=MAX)
				{
					q1.erase(q1.find(mp(d[u],u)));
				}
				d[u]=d[v]+cost;
				q1.insert(mp(d[u],u));
				D[u]=cost;
			}
			else if(cost+d[v]==d[u]&&D[u]>cost)
			{
				D[u]=cost;
			}
		}
	}
	for(i=0;i<n;i++)
	{
		cnt+=D[i];
		if(d[i]==MAX)
		{
			flag=1;
			return cnt;
		}
	}
	return cnt;
}

int main()
{
	ll t,n,m,a,b,c,i;
	sl(t)
	while(t--)
	{
		pre();
		sl(n)
		sl(m)
		for(i=0;i<m;i++)
		{
			sl(a)
			sl(b)
			sl(c)
			v.pb(mp(c,mp(a,b)));
			gp[a].pb(mp(b,c));
			gp[b].pb(mp(a,c));
		}
		if(krus()!=dik(n)||flag==1)
		{
			printf("NO\n");
		}
		else
		{
			printf("YES\n");
		}
	}
	return 0;
}
