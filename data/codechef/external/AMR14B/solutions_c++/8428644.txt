#include<bits/stdc++.h>
#define rep(i,x,y) for(i=x;i<y;i++)
#define rrep(i,x,y) for(i=x;i>=y;i--)
#define trv(y,x) for(typeof(x.begin())y=x.begin();y!=x.end();y++)
#define trvr(y,x) for(typeof(x.rbegin())y=x.rbegin();y!=x.rend();y++)
#define pb(f) push_back(f)
#define pi(a) printf("%d\n",a)
#define pil(a) printf("%lld\n",a)
#define pi_ printf("\n")
#define pil(a) printf("%lld\n",a)
#define sc(a) scanf("%d",&a)
#define ll long long
#define scl(a) scanf("%lld",&a)
#define scs(a) scanf("%s",a)
#define mp make_pair
#define fi first
#define se second
#define maxn 20005
#define inf 1e9
using namespace std;
//#include<windows.h>
//FILE *fin = freopen("nice.in","r",stdin);
//FILE *fout = freopen("nice.out","w",stdout);
typedef pair<ll,ll> pii;
typedef vector<ll> vi;
typedef vector< pii > vpii;
using namespace std;
vector<pii > adj[maxn];
long long  dis[maxn],lastedge[maxn];
vector< pair<ll, pair <ll , ll > > > edges;
                                                 //0-indexing
ll findbaapu(pair<ll,ll> P[],ll jwaak)
{
	if(P[jwaak].first!=jwaak)
	P[jwaak].first=findbaapu(P,P[jwaak].first);
	return P[jwaak].first;
}
void Union(pair<ll,ll> P[],ll x,ll y)
{
	ll xroot=findbaapu(P,x);
	ll yroot=findbaapu(P,y);
	if(P[xroot].second<P[yroot].second)
		P[xroot].first=yroot;
	else if(P[xroot].second>P[yroot].second)
		P[yroot].first=xroot;
	else
	{
		P[xroot].first=yroot;
		P[yroot].second++;
	}
}
long long  Kruskal(ll n)
{
	ll total_edges=edges.size();
	ll i,e=0;
	long long  ans=0;
	sort(edges.begin(),edges.end());
	pair<ll,ll> P[n];
	for(i=0;i<n;i++)
	{
		P[i].first=i; //parent
		P[i].second=0; //rank
	}
	i=0;
	while(i<total_edges)
	{
		ll wt=edges[i].first;
		ll src=edges[i].second.first,des=edges[i].second.second;
		ll x=findbaapu(P,src);
		ll y=findbaapu(P,des);
		if(x!=y)
		{
			ans+=wt;
			Union(P,x,y);
			e++;
		}
		i++;
	}
	return (e==n-1)?ans:-1;
}
void dijkstra(ll root)
{
	dis[root]=0;
	priority_queue<pii, vector<pii>, greater<pii> > Q;
	Q.push(make_pair(0,root));
	while(!Q.empty())
	{
		pii p=Q.top();Q.pop();
		ll u=p.second;
		ll thiscost=p.first;
		if(dis[u]<thiscost)
		continue;
		trv(it,adj[u])
		{
			ll v=it->first,wt=it->second;
			if(dis[v]>dis[u]+wt)
			{
				dis[v]=dis[u]+wt;
				lastedge[v]=wt;
				Q.push(make_pair(dis[v],v));
			}
			else if(dis[v]==dis[u]+wt)
			{
				lastedge[v]=min((ll)wt,lastedge[v]);
			}
		}
	}
}
int main()
{
	ll i,v,e,c,f,t;
	scanf("%lld",&t);
	while(t--)
	{
	//	adj.clear();
		edges.clear();
		for(i=0;i<maxn;i++)
		{
			adj[i].clear();}
		scanf("%lld%lld",&v,&e);
		ll n=v;
	//	for(i=0;i<n;i++)
	//	adj.pb(vector<pii>() );
		for(i=0;i<e;i++)
		{
			ll x,y,z;
			scanf("%lld%lld%lld",&x,&y,&z);
			adj[x].push_back(make_pair(y,z));
			adj[y].push_back(make_pair(x,z));
			edges.push_back(make_pair(z,make_pair(x,y)));
		}
		ll x,y;
		for(i=0;i<=n;i++)  // index it whatever u want
		dis[i]=lastedge[i]=LONG_LONG_MAX;
		dijkstra(0);
		long long ans=0;
		for(i=0;i<n;i++)
		{
			adj[i].clear();
			if(i!=0)
			ans=(lastedge[i]==LONG_LONG_MAX)?-1:ans+lastedge[i];
			if(ans==-1)
			break;
		}
		if(ans==-1)
		{
			edges.clear();
			printf("NO\n");
			continue;
		}
	//	cout<<ans<<endl;
		long long int ans1=Kruskal(v);
		edges.clear();
		if(ans1==-1)
		{
			printf("NO\n");
			continue;
		}
		if(ans1==ans)
		printf("YES\n");
		else printf("NO\n");
	}
}