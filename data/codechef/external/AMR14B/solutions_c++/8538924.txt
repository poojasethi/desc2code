#include <bits/stdc++.h>
using namespace std;
 
#define ll long long
#define rep(i,n) for(int i=0; i<(n); i++)
#define forn(i,a,b) for(int i=(a); i<=(b); i++)
#define forb(i,a,b) for(int i=(a); i>=(b); i--)
 
#define DBG 1
#define debug(x) if (DBG) {cerr << #x << " : " << x << endl; }
#define debug2(x, y) if (DBG) {cerr << #x << " : " << x << " :: " << #y << " : " << y << endl; }
#define debug3(x, y, z) if (DBG) {cerr << #x << " : " << x << " :: " << #y << " : " << y << " :: " << #z << " : " << z << endl; }
 
#define pb push_back
#define mp make_pair
#define pi pair<int, int>
#define pl pair<ll, ll>
#define VI vector<int>
#define VII vector<VI >
#define VL vector<ll>

#define all(x) x.begin(), x.end()
#define max(a,b) ((a) > (b)) ? (a) : (b)
#define min(a,b) ((a) < (b)) ? (a) : (b)

#define si(x) scanf("%i", &x)
#define sd(x) scanf("%lf", &x)


#define N 20010
ll INF = 1e15;

bool visited[N];
ll pathWeight[N], parentWeight[N];
int parent[N];


struct edge
{
	int u, v, weight;
	edge(int u, int v, int w) : u(u), v(v), weight(w){}
	bool operator < (const edge e) const
	{
		return weight < e.weight;
	}
};

// Disjoint set with path compression

int P[N], RANK[N];

void makeSet(int i)
{
	P[i] = i;
	RANK[i] = 0;
}

int findRepresentative(int x)
{
	if (P[x] == x) return x;
	P[x] = findRepresentative(P[x]);
	return P[x];
}

void mergeParents(int x, int y)	// merge parents
{
	if (RANK[x] < RANK[y])
	{
		P[x] = y;
	}
	else if (RANK[x] > RANK[y])
	{
		P[y] = x;
	}
	else
	{
		P[y] = x;
		RANK[x]++;
	}
}

void mergeElements(int x, int y)
{
	mergeParents(findRepresentative(x), findRepresentative(y));
}

bool solve()
{
	int n, m, start;
	si(n);
	si(m);

	vector<pi> edges[n+1];
	int u, v, w;

	vector<edge> E;

	rep(i, m)
	{
		si(u);
		si(v);
		si(w);

		// change this in case edges are directed

		edges[u].pb(mp(v,w));
		edges[v].pb(mp(u,w));
		E.pb(edge(u,v,w));
	}

	start = 0;


	sort(all(E));
	// rep(i, m) debug3(i, edges[i].u, edges[i].weight);

	ll gWeight = 0;
	int netEdges = 0;

	rep(i, n) makeSet(i);

	rep(i, m)
	{
		if (findRepresentative(E[i].u) != findRepresentative(E[i].v))
		{
			mergeElements(E[i].u, E[i].v);
			gWeight += E[i].weight;
			netEdges++;
		}
	}

	if (netEdges != n-1) return false;
	// debug2("Minspan done", gWeight);
	// dijkstra

	memset(visited, false, sizeof(visited));
	memset(parent, -1, sizeof(parent));	// optional
	rep(i, N) pathWeight[i] = INF;
	pathWeight[start] = 0;


	priority_queue<pl> weights;	
	weights.push(mp(0, start));

	

	while(!weights.empty())
	{
		pl current = weights.top();
		weights.pop();
		// debug3(current.second, current.first, visited[current.second]);
		if (visited[current.second]) continue;
		visited[current.second] = true;

		/**
			Break here if path to the vertex current.second has to be found
		**/

		rep(j, edges[current.second].size())
		{
			int newNode = edges[current.second][j].first;
			if(pathWeight[newNode] > pathWeight[current.second] + edges[current.second][j].second)
			{
				pathWeight[newNode] = pathWeight[current.second] + edges[current.second][j].second;
				parent[newNode] = current.second;
				parentWeight[newNode] = edges[current.second][j].second;
				weights.push(mp(-pathWeight[newNode], newNode));
			}
			else if (pathWeight[newNode] == pathWeight[current.second] + edges[current.second][j].second)
			{
				if (parentWeight[newNode] > edges[current.second][j].second)
				{
					parent[newNode] = current.second;
					parentWeight[newNode] = edges[current.second][j].second;
				}
			}
		}
	}

	// vector<pi> dtree;
	ll dWeight = 0;

	rep(i, n)
	{
		if (i != start)
		{
			// if (pathWeight[i] >= INF) return false;
			// debug3(i, pathWeight[i], parent[i]);
			// debug2(i, parentWeight[i]);
			dWeight += parentWeight[i];
		}
	}

	// debug2("dijkstra done", dWeight);
	return gWeight == dWeight;
}


int main()
{
	int t;
	si(t);

	while(t--)
	{
		printf("%s\n", solve() ? "YES" : "NO");
	}
}
