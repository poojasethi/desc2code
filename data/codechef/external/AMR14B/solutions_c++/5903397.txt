#include<bits/stdc++.h>

#define ll long long int
#define ull unsigned long long int
#define maxN 1000006
#define MOD 1000000007
#define pb push_back
#define mp make_pair

#define INF (((ll)1000000000) * ((ll)1000000000))

using namespace std;

//priority queue is ordered by <dist[v] , edge_weight (u,v) , v >
set< pair< ll , pair<ll,ll> > > P;
vector<pair<ll,ll> >V[maxN];
vector< pair<ll ,pair<ll,ll> > >E;
ll parent[maxN],rank[maxN],vis[maxN];
ll dist[maxN],last_edge[maxN];

ll kruskal(int );

int main() {

cin.sync_with_stdio(0);
cin.tie(0);

int T;
cin>>T;

while(T--) {

int N,M,i;
cin>>N>>M;

for(i=0;i<N;i++) {
 vis[i]=0;
 last_edge[i]=INF;
 dist[i]=INF;
}

//always clear vector
for(i=0;i<N;i++) {
 V[i].clear();
}
E.clear();

for(i=0;i<M;i++) {
 int x,y,z;
 cin>>x>>y>>z;
 V[x].pb ( mp(y,z) );	//edge from x to y of weight z
 V[y].pb ( mp(x,z) );
 E.pb( mp(z , mp(x,y) ) );
 E.pb( mp(z , mp(y,x) ) );
 }

set< pair< ll , pair<ll,ll> > >::iterator it;

//dist[0]=0 , W(0,0)=0 , u=0
P.insert(mp(0 , mp(0,0) ) );
dist[0]=0;
last_edge[0]=0;


while(P.empty()==false) {	//visit all vertices

it=P.begin();
 int u=it->second.second;

/*
 for(i=0;i<N;i++)
 cout<<dist[i]<<" ";
 cout<<"\n";
*/

 P.erase(it);
 if(vis[u]==0) 	//vertice is unvisited
 for(i=0;i<V[u].size();i++) { 	//adjacency list of u
  int v=V[u][i].first;
  int w=V[u][i].second;
  if(!vis[v] && (dist[u] + w < dist[v] || (dist[u] + w == dist[v] && w < last_edge[v]))) {
   dist[v]=dist[u]+w;
   last_edge[v]=w;
   P.insert( mp(dist[v] , mp(last_edge[v] , v) ) );
  }
 }
  
 vis[u]=1;
}

bool possible=true;

ll dw=0;
for(i=0;i<N;i++)
if(dist[i]==INF) {
 possible=false;
 break;
}
else
 dw+=last_edge[i];

ll kw=-1;
if(possible)
kw= kruskal(N);


if(possible && kw==dw)
cout<<"YES\n";
else
cout<<"NO\n";

}

return 0;
}



int find(int a) {
if(parent[a]!=a)
parent[a]=find(parent[a]);
return parent[a];
}

void Union(int a,int b) {

if(rank[a]<rank[b])	//a has a tree of lesser depth
parent[a]=b;
else if(rank[a]>rank[b])	//a has a tree of greater depth
parent[b]=a;
else if(rank[a]==rank[b]) {
 parent[a]=b;
 rank[b]++;
}

}

ll kruskal(int N) {

int i;
for(i=0;i<N;i++) {
 parent[i]=i;
 rank[i]=0;
 }

ll mst_weight=0;
sort(E.begin() , E.end() );

for(i=0;i<E.size();i++) {
 int u=E[i].second.first;
 int v=E[i].second.second;
 int w=E[i].first;

 if(find(u) != find(v) ) {
  mst_weight+=w;
  Union(find(u),find(v));
 }
}

return mst_weight;
}
