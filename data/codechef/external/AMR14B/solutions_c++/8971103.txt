#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mp make_pair
#define F first
#define S second
#define sl(a) scanf("%lld",&a);
#define intMAX 1123456789LL
#define MAX intMAX*intMAX

using namespace std;

vector<pair<ll,ll> >gp[20005];
ll sumprim,sumdik,visited[20005],d[20005],d_[20005];
set<pair<ll,ll> >q;

void set_1()
{
	ll i;
	for(i=0;i<20005;i++)
	{
		gp[i].clear();
		visited[i]=0;
		d[i]=MAX;
	}
}
void set_2()
{
	ll i;
	for(i=0;i<20005;i++)
	{
		d[i]=MAX;
		d_[i]=MAX;
	}
}
void prim()
{
	q.insert(mp(0,0));
	d[0]=0;
	ll v,u,i,cost;
	while(!q.empty())
	{
		pair<ll,ll>top=*q.begin();
		q.erase(q.begin());
		v=top.S;
		visited[v]=1;
		sumprim+=top.F;
		for(i=0;i<gp[v].size();i++)
		{
			u=gp[v][i].F;
			cost=gp[v][i].S;
			if(visited[u]==0)
			{
				if(cost<d[u])
				{
					if(d[u]!=MAX)
					{
						q.erase(q.find(mp(d[u],u)));
					}
					d[u]=cost;
					q.insert(mp(d[u],u));
				}
			}
		}
	}
}
void dik()
{
	d[0]=0;
	d_[0]=0;
	q.insert(mp(0,0));
	ll u,v,cost,i;
	while(!q.empty())
	{
		pair<ll,ll>top=*q.begin();
		q.erase(q.begin());
		v=top.S;
		sumdik+=d_[v];
		for(i=0;i<gp[v].size();i++)
		{
			u=gp[v][i].F;
			cost=gp[v][i].S;
			if(d[u]>cost+d[v]||(d[u]==cost+d[v]&&cost<d_[u]))
			{
				if(d[u]!=MAX)
				{
					q.erase(q.find(mp(d[u],u)));
				}
				d[u]=cost+d[v];
				d_[u]=cost;
				q.insert(mp(d[u],u));
			}
		}
	}
}
int main()
{
	ll i,t,flag,n,m,u,v,w;
	sl(t)
	while(t--)
	{
		set_1();
		sumdik=0;
		sumprim=0;
		flag=0;
		sl(n)
		sl(m)
		for(i=1;i<=m;i++)
		{
			sl(u)
			sl(v)
			sl(w)
			gp[u].pb(mp(v,w));
			gp[v].pb(mp(u,w));
		}
		prim();
		for(i=0;i<n;i++)
		{
			if(visited[i]==0)
			{
				flag=1;
				break;
			}
		}
		if(flag==1)
		{
			printf("NO\n");
			continue;
		}
		set_2();
		dik();
		if(sumprim==sumdik)
		{
			printf("YES\n");
		}
		else
		{
			printf("NO\n");
		}
	}
	return 0;
}
