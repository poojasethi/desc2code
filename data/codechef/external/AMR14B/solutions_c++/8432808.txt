#include<bits/stdc++.h>
#define ll long long
#define fi first
#define se second
ll mpow(ll a, ll n,ll mod)
{ll ret=1;ll b=a;while(n) {if(n&1)
    ret=(ret*b)%mod;b=(b*b)%mod;n>>=1;}
return (ll)ret;
}
using namespace std;
#define irr acos(-1.0)
#define mem(x,a) memset(x,a,sizeof(x))
#define pii pair<int,int>
#define mp make_pair
#define pb push_back
#define N 40000+5
#define INF (((ll)1000000000)*((ll)1000000000))
int par[N];
set<pair<int,pii> > s;
set<pair<int,pii> >::iterator it;
ll DIS[N];
ll len[N];
vector<pii> g[N];
int n,m;
int parent(int x)
{
    while(par[x]!=x)
        x=par[x];
    return x;
}
ll dij()
{
    DIS[0]=0;
    len[0]=0;
    priority_queue<pair<ll,pair<ll,ll> >, vector<pair<ll,pair<ll,ll> > >, greater<pair<ll,pair<ll,ll> > > > q;
	q.push(mp(0,mp(0,0)));
    while(!q.empty())
    {
        pair<ll,pair<ll,ll> > temp=q.top();
        q.pop();
        int u=temp.se.se;
        for(int j=0;j<g[u].size();j++)
        {
            int to=g[u][j].fi;
            int w=g[u][j].se;
            if(DIS[to]>w+DIS[u]||(DIS[u]+w==DIS[to]&&w<len[to]))
            {
                DIS[to]=w+DIS[u];
                len[to]=w;
                q.push(mp(DIS[to],mp(len[to],to)));
            }
        }
    }
    ll sum=0;
    for(int j=0;j<n;j++)
    {
        if(DIS[j]==INF)
        {
            return -1;
        }
        sum+=len[j];
    }
    return sum;
}
void allclear()
{
    s.clear();
    for(int j=0;j<n;j++)
    {
        g[j].clear();
        DIS[j]=INF;
        len[j]=INF;
    }
}
int main()
{
    int i,j;
    int t;
    cin>>t;
    while(t--)
    {
    scanf("%d%d",&n,&m);
    allclear();
    for(j=0;j<n;j++)
        par[j]=j;
    for(j=0;j<m;j++)
    {
        int x,y,w;
        scanf("%d%d%d",&x,&y,&w);
        g[x].pb(mp(y,w));
        g[y].pb(mp(x,w));
        s.insert(mp(w,mp(x,y)));
    }
    ll sum1=0,sum2=0;
    for(it=s.begin();it!=s.end();it++)
    {
        int u=(it->se).fi;
        int v=(it->se).se;
        int w=it->fi;
        int x=parent(u);
        int y=parent(v);
        if(x!=y)
        {
            par[x]=y;
            sum1+=w;
        }
    }
    sum2=dij();
    if(sum2==-1)
    {
        printf("NO\n");
        continue;
    }
    if(sum1==sum2)
        printf("YES\n");
    else
        printf("NO\n");
    }
    return 0;
}
