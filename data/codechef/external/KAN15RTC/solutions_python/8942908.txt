#include <bits/stdc++.h>
using namespace std ;

#define ft first
#define sd second
#define pb push_back
#define all(x) x.begin(),x.end()

#define ull unsigned long long int
#define ui unsigned int
#define ll long long int
#define vi vector<int>
#define vii vector<pair<int,int> >
#define pii pair<int,int>
#define vl vector<ll>
#define vll vector<pair<ll,ll> >
#define pll pair<ll,ll>
#define mp make_pair

#define sc(x) scanf("%d",&x)
#define sc2(x,y) scanf("%d%d",&x,&y)
#define sc3(x,y,z) scanf("%d%d%d",&x,&y,&z)

#define scll1(x) scanf("%lld",&x)
#define scll2(x,y) scanf("%lld%lld",&x,&y)
#define scll3(x,y,z) scanf("%lld%lld%lld",&x,&y,&z)

#define pr1(x) printf("%d\n",x)
#define pr2(x,y) printf("%d %d\n",x,y)
#define pr3(x,y,z) printf("%d %d %d\n",x,y,z)

#define prll1(x) printf("%lld\n",x)
#define prll2(x,y) printf("%lld %lld\n",x,y)
#define prll3(x,y,z) printf("%lld %lld %lld\n",x,y,z)

#define pr_vec(v) for(int i=0;i<v.size();i++) cout << v[i] << " " ;

#define f_in(st) freopen(st,"r",stdin)
#define f_out(st) freopen(st,"w",stdout)

#define fr(i, a, b) for(i=a; i<=b; i++)
#define fb(i, a, b) for(i=a; i>=b; i--)

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define debug( s ) cout << s << "\n"

const int maxn = 1e5 + 10;
const int maxp = 1e5 + 10;
const int mod = 1e9 + 7;



vector<pair<pii, pii > > A; 
map<int, int> M;

int st[2][4 * maxn], F[2][4 * maxn];

class SegmentTree {

	public:
		// void buildst(int bit,int idx,int ss,int se){
 	// 		if( ss == se ){
  // 				st[bit][idx] = A[ss];
  // 				F[bit][idx] = 0;
  // 				return;
 	// 		}
 	// 		int mid=(ss+se) >> 1;
 	// 		buildst(bit, 2*idx, ss, mid);
 	// 		buildst(bit, 2*idx+1, mid+1, se);
 	// 		F[bit][idx] = 0;
 	// 		st[bit][idx] = min(st[bit][idx*2], st[bit][idx*2+1]);
		// }

		void reset(int bit,int idx,int ss,int se){
 			if( ss == se ){
  				st[bit][idx] = 0;
  				F[bit][idx] = 0;
  				return;
 			}
 			int mid=(ss+se) >> 1;
 			reset(bit, 2*idx, ss, mid);
 			reset(bit, 2*idx+1, mid+1, se);
 			F[bit][idx] = 0;
 			st[bit][idx] = 0;
		}

		void update(int bit,int idx,int ss,int se,int l,int r, int v){
   			if( F[bit][idx] ) {
     			st[bit][idx] += F[bit][idx];
     			if( ss != se ){
       				F[bit][2*idx] += F[bit][idx];
       				F[bit][2*idx+1] += F[bit][idx];
     			}
     			F[bit][idx] = 0;
   			}

   			if( l > se || r < ss ) return;

   			if(l <= ss && se <= r ){
     			st[bit][idx] += v;
     			if( ss != se ){
      				F[bit][2*idx] += v;
      				F[bit][2*idx+1] += v;
     			}
     			return;
   			}

   			int mid= ( ss + se ) >> 1;
   			update(bit, 2*idx, ss, mid, l, r, v);
   			update(bit, 2*idx+1, mid+1, se, l, r, v);
   			st[bit][idx]= max(st[bit][idx*2], st[bit][idx*2+1]);
		}

		int query(int bit,int idx,int ss,int se,int l,int r){
 		  	if( F[bit][idx] ){
      			st[bit][idx] += F[bit][idx];
      			if( ss != se ){
        			F[bit][2*idx] += F[bit][idx];
        			F[bit][2*idx+1] += F[bit][idx];
      			}
      			F[bit][idx] = 0;
    		}
   			if( l > se || r < ss ) return INT_MAX;
   			if( l <= ss && se <= r ) return st[bit][idx];
   			int mid = ( ss + se ) >> 1;
   			int L = query(bit, 2*idx, ss, mid, l, r);
   			int R = query(bit, 2*idx+1, mid+1, se, l, r);
   			return max(L, R);
		}
};


void solve() {

	int n; cin >> n;
	int i;
	fr(i, 1, n) {
		int x1, x2, y1, y2;
		cin >> x1 >> y1;
		cin >> x2 >> y2;
		M[x1] = 1;
		M[x2] = 1;
		M[y1] = 1;
		M[y2] = 1;
		A.pb(mp(mp(x1, 0), mp(y1, y2)));
		A.pb(mp(mp(x2, 1), mp(y1, y2)));
	}

	int c = 0;
	for( map<int, int> :: iterator it = M.begin(); it != M.end(); ++it ) {
		it->sd = ++c;
	}

	for( vector<pair<pii, pii > > :: iterator it = A.begin(); it != A.end(); ++it ) {
		it->ft.ft = M[it->ft.ft];
		it->sd.ft = M[it->sd.ft];
		it->sd.sd = M[it->sd.sd];
	}

	// cout << A[0].ft.ft << " " << A[0].ft.sd << " " << A[0].sd.ft << " " << A[0].sd.sd << "\n";
	sort(all(A));
	SegmentTree SegTree;
	SegTree.reset(0, 1, 1, c);
	int ans = 0;
	for( vector<pair<pii, pii > > :: iterator it = A.begin(); it != A.end(); ++it ) {
		if( !it->ft.sd ) {
			SegTree.update(0, 1, 1, c, it->sd.ft, it->sd.sd, 1);
		} else {
			SegTree.update(0, 1, 1, c, it->sd.ft, it->sd.sd, -1);
		}
		ans = max(ans, SegTree.query(0, 1, 1, c, 1, c));
	}
	cout << ans << "\n";
	A.clear();
	M.clear();
}
int main() {

	int t; cin >> t;
	while( t-- ) solve();
	return 0;
}