import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) throws IOException {
        InputReader reader = new InputReader(System.in);
        int T = reader.readInt();
        for (int t=0; t<T; t++) {
            int N = reader.readInt();
            int[] x1 = new int[N];
            int[] y1 = new int[N];
            int[] x2 = new int[N];
            int[] y2 = new int[N];
            for (int n=0; n<N; n++) {
                x1[n] = reader.readInt();
                y1[n] = reader.readInt();
                x2[n] = reader.readInt();
                y2[n] = reader.readInt();
            }
            Map<Integer,Integer> map = map(y1,y2);
            Event[] events = new Event[2*N];
            for (int n=0; n<N; n++) {
                Event event = new Event();
                event.add = true;
                event.x = x1[n];
                event.y1 = y1[n];
                event.y2 = y2[n];
                events[2*n] = event;
                event = new Event();
                event.add = false;
                event.x = x2[n];
                event.y1 = y1[n];
                event.y2 = y2[n];
                events[2*n+1] = event;
            }
            Arrays.sort(events, new Comparator<Event>() {
                @Override
                public int compare(Event o1, Event o2) {
                    int diff = o1.x - o2.x;
                    if (diff == 0) {
                        diff = (o1.add ? 0 : 1) - (o2.add ? 0 : 1);
                    }
                    return diff;
                }
            });
            int answer = 0;
            Node root = new Node(0,2*N-1);
            for (Event event : events) {
                int L = map.get(event.y1);
                int R = map.get(event.y2);
                root.update(L, R, event.add ? 1 : -1);
                answer = Math.max(answer, root.value);
            }
            System.out.println(answer);
        }
    }

    static class Node {
        int from;
        int to;
        int value;
        Node left;
        Node right;
        int addBelow;

        Node(int from, int to) {
            this.from = from;
            this.to = to;
            if (from != to) {
                int mid = (from+to) >>> 1;
                left = new Node(from, mid);
                right = new Node(mid+1, to);
            }
        }

        void update(int L, int R, int delta) {
            if (R < from || to < L) {
                // no-op
            } else if (L <= from && to <= R) {
                addBelow += delta;
                value += delta;
            } else {
                pushBelow();
                left.update(L, R, delta);
                right.update(L, R, delta);
                value = Math.max(left.value, right.value);
            }
        }

        void pushBelow() {
            if (addBelow != 0) {
                left.update(from, to, addBelow);
                right.update(from, to, addBelow);
                addBelow = 0;
            }
        }
    }

    static class Event {
        int x;
        boolean add;
        int y1;
        int y2;
    }

    static Map<Integer,Integer> map(int[] x1, int[] x2) {
        int[] x = new int[x1.length+x2.length];
        System.arraycopy(x1, 0, x, 0, x1.length);
        System.arraycopy(x2, 0, x, x1.length, x2.length);
        Arrays.sort(x);
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        for (int i=0; i<x.length; i++) {
            map.put(x[i], i);
        }
        return map;
    }

    static final class InputReader {
        private final InputStream stream;
        private final byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int read() throws IOException {
            if (curChar >= numChars) {
                curChar = 0;
                numChars = stream.read(buf);
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public final int readInt() throws IOException {
            return (int)readLong();
        }

        public final long readLong() throws IOException {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
                if (c == -1) throw new IOException();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return negative ? -res : res;
        }

        public final int[] readIntArray(int size) throws IOException {
            int[] array = new int[size];
            for (int i=0; i<size; i++) {
                array[i] = readInt();
            }
            return array;
        }

        public final long[] readLongArray(int size) throws IOException {
            long[] array = new long[size];
            for (int i=0; i<size; i++) {
                array[i] = readLong();
            }
            return array;
        }

        public final String readString() throws IOException {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.append((char)c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
    }

}
