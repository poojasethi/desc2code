#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MAX 80000
int tree[MAX],lazy[MAX];
map<int,int> mpx,mpy;
struct rect
{
    int x1,y1,x2,y2;
};
struct query
{
    int x,y1,y2,val;
};
rect A[10005];
vector<query> v;
bool comp(query a,query b)
{
    if(a.x==b.x)
        return a.val>b.val;
    return a.x<b.x;
}
void update_tree(int node, int a, int b, int i, int j, int value)
{
  	if(lazy[node] != 0)
    {
   		tree[node] += lazy[node];
		if(a != b)
		{
			lazy[node*2] += lazy[node];
            lazy[node*2+1] += lazy[node];
		}
   		lazy[node] = 0;
  	}
	if(a > b || a > j || b < i)
		return;
  	if(a >= i && b <= j)
  	{
        tree[node] += value;
		if(a != b)
		{
			lazy[node*2] += value;
			lazy[node*2+1] += value;
		}
        return;
	}
	update_tree(node*2, a, (a+b)/2, i, j, value);
	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value);
	tree[node] = max(tree[node*2],tree[node*2+1]);
}
int query_tree(int node, int a, int b, int i, int j)
{
	if(a > b || a > j || b < i)
        return 0;
	if(lazy[node] != 0)
	{
		tree[node] += lazy[node];
		if(a != b)
		{
			lazy[node*2] += lazy[node];
			lazy[node*2+1] += lazy[node];
		}
		lazy[node] = 0;
	}
	if(a >= i && b <= j)
		return tree[node];
	int q1 = query_tree(node*2, a, (a+b)/2, i, j);
	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j);
	int res = max(q1,q2);
	return res;
}
int main()
{
	int t,n,i,szx,szy,res;
	map<int,int>::iterator it;
	query q;
	cin>>t;
	while(t--)
	{
	    memset(lazy, 0, sizeof lazy);
	    memset(tree,0,sizeof tree);
	    mpx.clear();
	    mpy.clear();
	    v.clear();
	    cin>>n;
	    for(i=0;i<n;i++)
        {
            cin>>A[i].x1>>A[i].y1>>A[i].x2>>A[i].y2;
            mpx[A[i].x1]++;
            mpy[A[i].y1]++;
            mpx[A[i].x2]++;
            mpy[A[i].y2]++;
        }
        szx=szy=0;
        for(it=mpx.begin();it!=mpx.end();it++)
            it->second=szx++;
        for(it=mpy.begin();it!=mpy.end();it++)
            it->second=szy++;
        for(i=0;i<n;i++)
        {
            q.x=mpx[A[i].x1];
            q.y1=mpy[A[i].y1];
            q.y2=mpy[A[i].y2];
            q.val=1;
            v.push_back(q);
            q.x=mpx[A[i].x2];
            q.val=-1;
            v.push_back(q);
        }
        sort(v.begin(),v.end(),comp);
        for(i=res=0;i<v.size();i++)
        {
            update_tree(1,0,szy-1,v[i].y1,v[i].y2,v[i].val);
            res=max(res,query_tree(1,0,szy-1,0,szy-1));
        }
        cout<<res<<endl;
	}
}
