#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <limits.h>
#include <vector>
#include <stdlib.h>
#include <algorithm>
#include <memory.h>
#include <string.h>
#include <math.h>
#include <string>
#include <algorithm>
#include <functional>
#include <cassert>
#include <set>
#include <map>
 
using namespace std;
typedef long long lli;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<lli, lli> pll;
 
#define _LOCAL_DEBUG_
#ifdef _LOCAL_DEBUG_
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#else
#define eprintf(...) 
#endif
int t;
const int MAX = 2e5 + 10;
lli n;
int q;
int np = 0;
 
struct Segment {
    lli length, from;
    Segment() {}
    Segment(lli _length, lli _from) : length(_length), from(_from) {}
    lli end() {
        return from + length - 1;
    }
};
 
bool operator <(const Segment &s1, const Segment &s2) {
    lli d1 = (s1.length - 1) / 2;
    lli d2 = (s2.length - 1) / 2;
    if (d1 == d2)
        return s1.from < s2.from;
    return d1 > d2;
}
 
set<Segment> s;
map<int, lli> numToPos;
map<lli, int> posToNum;
 
void clear() {
}
 
lli getPos() {
    lli d = LLONG_MIN;
    lli pos;
    if (posToNum.find(1) == posToNum.end()) {
        d = next(posToNum.find(0))->first - 2;
        pos = 1;
    }
    Segment tSeg = *s.begin();
    lli tLength = (tSeg.length - 1) / 2;
    lli tPos = tSeg.from + tLength;
    if (tLength > d)
        pos = tPos, d = tLength;
 
    if (posToNum.find(n) == posToNum.end()) {
        lli td = n - prev(posToNum.find(n + 1))->first - 1;
        if (td > d)
            d = td, pos = n;
    }
    return pos;
}
 
void insert(lli pos) {
    if (pos == 1) {
        lli nextPos = next(posToNum.find(0))->first;
        s.erase(s.find(Segment(nextPos - 1, 1)));
        if (nextPos - 2 > 0)
            s.insert(Segment(nextPos - 2, 2));
    }
    else if (pos == n) {
        lli prevPos = prev(posToNum.find(n + 1))->first;
        s.erase(s.find(Segment(n - prevPos, prevPos + 1)));
        if (n - prevPos - 1 > 0)
            s.insert(Segment(n - prevPos - 1, prevPos + 1));
    }
    else {
        Segment tSeg = *s.begin();
        s.erase(s.begin());
        if (pos > tSeg.from) s.insert(Segment(pos - tSeg.from, tSeg.from));
        if (pos < tSeg.end()) s.insert(Segment(tSeg.end() - pos, pos + 1));
    }
 
    np++;
    numToPos[np] = pos;
    posToNum[pos] = np;
}
 
void remove(int lp) {
    lli pos = numToPos[lp];
    map<lli, int>::iterator it = posToNum.find(pos);
    lli lPos = prev(it)->first + 1;
    lli lLength = pos - lPos;
    if (lLength > 0) s.erase(s.find(Segment(lLength, lPos)));
    lli rPos = next(it)->first - 1;
    lli rLength = rPos - pos;
    if (rLength > 0) s.erase(s.find(Segment(rLength, pos + 1)));
    s.insert(Segment(rPos - lPos + 1, lPos));
    numToPos.erase(numToPos.find(lp));
    posToNum.erase(posToNum.find(pos));
}
 
void solve() {
    scanf("%lld%d\n", &n, &q);
    s.insert(Segment(n, 1));
    posToNum[0] = -1;
    posToNum[n + 1] = -1;
    while (q--) {
        if (q == 2)
            q = q;
        int type;
        scanf("%d", &type);
        if (type == 1) {
            lli pos = getPos();
            insert(pos);
            printf("%lld\n", pos);
        }
        else {
            int lp;
            scanf("%d", &lp);
            remove(lp);
        }
        continue;
        eprintf("Pos:\n");
        for (int i = 1; i <= n; i++) {
            auto it = posToNum.find(i);
            if (it == posToNum.end())
                eprintf("%3s", "X");
            else
                eprintf("%3d", it->second);
        }
 
        eprintf("\nSegments:\n");
        set<Segment>::iterator it = s.begin();
        for (; it != s.end(); it++) {
            eprintf("%lld %lld\n", it->from, it->length);
        }
    }
}
 
int main() {
#ifdef _LOCAL_VAN
    freopen("in.txt", "r", stdin);
#endif
    clear();
    solve();
    return 0;
}