#include <bits/stdc++.h>
using namespace std;
 
vector<int> primesVec;
/*
bool prime(int n){
	if(n == 2)return true;
	for(int i=2; i*i<=n; i++){
		if(n%i == 0) return false;
	}
	return true;
}
*/
bool primenew(int n){
	if(n == 2)return true;
	for(int i=0; primesVec[i]*primesVec[i]<=n; i++){
		if(n%primesVec[i] == 0) return false;
	}
	return true;
}
 
 
 
int main(){
	ios_base::sync_with_stdio(false);
	int t,a,b,count,root,factor,power;
 
	for(int i = 2; i<32000; i++){
		if(primenew(i))primesVec.push_back(i);
	}
	cin >> t;
	vector<int> kiwi;
	long long int num = 1;
	for(int i=0; i<primesVec.size(); i++){
		for(int j=0; primesVec[j]<30; j++){
			num = 1;
			power = 0;
			while(num < 1000000000 && power < primesVec[j] - 1){
				num *= primesVec[i]; 
				power++;
			}
			if(num > 1000000000){
				break;
			}
			if(power == primesVec[j] - 1){
                //cout << num << " ";
				kiwi.push_back(num);
			}
 
		}
        //cout << "\n";
	}
 
	//cout << kiwi.size() << "\n";
	//sort(kiwi.begin(), kiwi.end());
 
	for(int i=0; i<t; i++){
		cin >> a >> b;
		count = 0;
		for(int j=0; j<kiwi.size(); j++){
			if(kiwi[j] >= a && kiwi[j] <= b)count++;
			
				/*
					num = j;
					power = 0;
					for(int k=0; primesVec[k]*primesVec[k]<=j; k++){
						if(j%primesVec[k] == 0){
							while(num%primesVec[k] == 0){
								num = num/primesVec[k];
								power++;
							}
							if(num == 1){
								if(primenew(power+1))count++;
							}
							else{
								break;
							}
						}
					}*/
					
				
 
		}
		if(b >= 32000){
			bool isPrime[200001];
			int lower = max(a,32001);
            int ceiling;
			for(int j = lower; j<=b; j++){
				isPrime[j-lower] = true;
			}
			for(int j=0; j<primesVec.size(); j++){
                ceiling = ceil(lower*1.0/primesVec[j]);
				for(int k=max(ceiling,2); k<= b/primesVec[j]; k++){
					isPrime[primesVec[j]*k - lower] = false;
				}
			}

			for(int j = lower; j<=b; j++){
				if(isPrime[j-lower]) count++;
			}
		}
    cout << count << "\n"; 
	}
} 