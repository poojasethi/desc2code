#include<stdio.h>
#include<stdlib.h>//HEADER FILES
#define gc() getchar()//_unlocked()
#define pc(x) putchar(x)//_unlocked(x)
#define lli long long int
 
int ctr[100005];
int input[200001],size;//INPUT ARRAY AND ITS SIZE
int temporary[200001];//TEMPORARY ARRAY TO STORE MERGED ARRAY
 
int inline inp()
{
int n=0;
char c=gc();
while(c < '0' || c >'9')
{
c=gc();
}
while(c>='0' && c<='9')
{
n=(n<<3)+(n<<1)+c-'0';
c=gc();
}
return n;
}
inline void oup(lli n)
{
lli N = n, rev;
int count = 0;
rev = N;
if (N == 0) { pc('0'); return ;}
while ((rev % 10) == 0) { count++; rev /= 10;} //obtain the count of the number of 0s
rev = 0;
while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;} //store reverse of N in rev
while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
while (count--) pc('0');
}
 
lli merge_and_count_split_inversions(int a[],int p,int q,int r)//FUNCTION TO MERGE TWO SORTED ARRAYS a[p----q] AND a[q+1----r]
{
int i,j,k;
lli counter=0;
for(i=p,j=q+1,k=0;(i<=q)&&(j<=r);)
{ if(a[i]<=a[j])
{
temporary[k++]=a[i++];//COPYING SMALLER ELEMENT OUT OF a[i] AND a[j]
}
else
{
temporary[k++]=a[j++];
counter=counter+(q-i+1);
}
}
if(i<=q)while(i<=q)temporary[k++]=a[i++];//APPENDING UNUSED ARRAY AS ITS ALREADY SORTED
else while(j<=r)temporary[k++]=a[j++];
 
for(i=p,k=0;i<=r;)a[i++]=temporary[k++];//COPYING TEMPORARY ARRAY TO MAIN ARRAY ,SO THAT IT NOW STORES MERGED ARRAYS a[p--q] AND a[q+1--r]
return counter;
}
 
lli sort_and_count_inversions(int a[],int p,int r)//FUNCTION TO SUBDIVIDE ARRAY AND CALL MERGE FUNCTION FOR TWO SORTED ARRAYS a[p----q] AND a[q+1----r]
{ if(p<r)
{ int q=(p+r)/2;//SUBDIVIDE ARRAY
lli x=sort_and_count_inversions(a,p,q);
lli y=sort_and_count_inversions(a,q+1,r);//CALL FUNCTION TO DIVIDE AGAIN IF SIZE STILL>1
lli z=merge_and_count_split_inversions(a,p,q,r);//CALLING MERGE
return (x+y+z);
}
else
{
return 0;
}
}
 
int main()//MAIN FUNCTION
{
int t,i=0,z=1;//NUMBER OF ITEMS IN LIST
lli result,k;
t=inp();//INPUT SIZE
while(t--)//INPUT ALL ITEMS
{
size=inp();
int flag=-1;
scanf("%lld",&k);
for(i=1;i<=size;i++)ctr[i]=0;
for(i=0;i<size;i++)
{
input[i]=inp();
ctr[input[i]]++;
if(ctr[input[i]]>=2)flag=2;
}
result=sort_and_count_inversions(input,0,size-1);
if(result>=k)
{
result=result-k;
}
else
{
k=k-result;
k=k%2;
 
if((k==0)||(flag==2))result=0;
else
{
result=1;
}
}
printf("Case %d: %lld",z++,result);
pc('\n');
}
return 0;
}