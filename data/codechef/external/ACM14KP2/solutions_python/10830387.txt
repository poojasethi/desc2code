// codechef_codes.cpp : Defines the entry point for the console application.
 
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <time.h>
#include <cstdlib>
#include <deque>
 
using namespace std;
 
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vector<int> > vvi;
typedef pair<int, int> ii;
typedef vector<pair<int, int> > vii;
typedef vector<vector<pair<int, int> > > vvii;
 
#define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define max(a,b) ((a)>(b)?a:b)
#define min(a,b) ((a)<(b)?a:b)
#define min_3(a,b,c) (min((a),min((b),(c))))
#define INF 1000000007
#define pb push_back 
#define PB pop_back
#define pf push_front
#define PF pop_front
#define MP make_pair
#define all(x) (x).begin(), (x).end()
#define nall(x) (x).rbegin(), (x).rend()
#define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it)
#define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it)
#define mset(a,b) memset(a,b,sizeof(a))
#define ia(a,n) FOR(i,0,n-1)cin>>a[i]
#define ia1(a,n) FOR(i,1,n)cin>>a[i]
#define fpresent(c,x) ((c).find(x) != (c).end())  // set,map
#define present(c,x) (find(all(c),x) != (c).end())  //vector
#define F first
#define S second
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define NFOR(i,a,b) for(int i=a;i>=b;--i)
#define rep(i,n) FOR(i,0,n-1)
#define TCASE int __T;cin>>__T;FOR(Tc,1,__T)
inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; }
inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); }
inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; }
inline int neg(int x, int m = INF) { x = -x;return norm(x); }
 
 
/// debug //////
#define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;}
#define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;}
#define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;
 
ll temp[100001],arr[100001];
 
ll  _mergeSort(ll arr[], ll temp[], ll left, ll right);
ll merge(ll arr[], ll temp[], ll left, ll mid, ll right);
 
/* This function sorts the input array and returns the
number of inversions in the array */
ll mergeSort(ll arr[], ll array_size)
{
	return _mergeSort(arr, temp, 0, array_size - 1);
}
 
/* An auxiliary recursive function that sorts the input array and
returns the number of inversions in the array. */
ll _mergeSort(ll arr[], ll temp[], ll left, ll right)
{
	ll mid, inv_count = 0;
	if (right > left)
	{
		/* Divide the array into two parts and call _mergeSortAndCountInv()
		for each of the parts */
		mid = (right + left) / 2;
 
		/* Inversion count will be sum of inversions in left-part, right-part
		and number of inversions in merging */
		inv_count = _mergeSort(arr, temp, left, mid);
		inv_count += _mergeSort(arr, temp, mid + 1, right);
 
		/*Merge the two parts*/
		inv_count += merge(arr, temp, left, mid + 1, right);
	}
	return inv_count;
}
 
/* This funt merges two sorted arrays and returns inversion count in
the arrays.*/
ll merge(ll arr[], ll temp[], ll left, ll mid, ll right)
{
	ll i, j, k;
	ll inv_count = 0;
 
	i = left; /* i is index for left subarray*/
	j = mid;  /* i is index for right subarray*/
	k = left; /* i is index for resultant merged subarray*/
	while ((i <= mid - 1) && (j <= right))
	{
		if (arr[i] <= arr[j])
		{
			temp[k++] = arr[i++];
		}
		else
		{
			temp[k++] = arr[j++];
 
			/*this is tricky -- see above explanation/diagram for merge()*/
			inv_count = inv_count + (mid - i);
		}
	}
 
	/* Copy the remaining elements of left subarray
	(if there are any) to temp*/
	while (i <= mid - 1)
		temp[k++] = arr[i++];
 
	/* Copy the remaining elements of right subarray
	(if there are any) to temp*/
	while (j <= right)
		temp[k++] = arr[j++];
 
	/*Copy back the merged elements to original array*/
	for (i = left; i <= right; i++)
		arr[i] = temp[i];
 
	return inv_count;
}
 
 
int main() {
	boost;
	ll tc,N,K,i,num,count = 0;
	cin >> tc;
	while (tc--) {
		int status = 0;
		count++;
		cin >> N >> K;
		for(i = 0 ; i < N ; i++)
			cin >> arr[i];
		ll I = mergeSort(arr,N);
		for (i = 0; i < N; i++) {
			if(arr[i] == arr[i+1]){
				status = 1 ;
				break;
				}
		}
		if (K <= I) {
			cout << "Case "<< count <<": "<<(I-K)<<endl;
		}
		else {
			if ((I - K) % 2 == 0) {
				cout <<"Case "<<count <<": "<<"0"<< endl;
			}
			else {
				if(status == 1)
					cout << "Case " << count << ": " << "0" << endl;
				else
					cout << "Case " << count << ": " << "1" << endl;
			}
		}
 
	}
} 