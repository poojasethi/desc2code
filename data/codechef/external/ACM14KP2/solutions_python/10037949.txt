#include<bits/stdc++.h>
#define ll long long
#define SIZE 100009

using namespace std;

inline int LSOne(int n){         // Returns least Significant 1's place
	return n&(-n);
}

class FenwickTree{
	vector<ll> ft;                                                      // Fenwick tree usable from 1 to n
	public:
	FenwickTree(int n){              
		ft.assign(n+1,0);
	}
	ll rsq(int b){                                                      //Returns the cumulative freq from index 1 to n
		ll sum =0; 
		for(; b >0; b = b-LSOne(b)){                                      //O(logn)
			sum += ft[b];
		}
		return sum;
	}
	ll rsq(int a, int b){                                              // Returns The cumulative freq from index a to b
		return rsq(b) - (a == 1? 0 : rsq(a-1));
	}
	void adjust(int idx,int a){                                        // Adjusts the Array's idxth element, increments by a
		for(; idx < (int)ft.size();idx += LSOne(idx))                   // O(logn)
			ft[idx] +=a;
	}
	void rupd(int idx1,int idx2, int b){                              // Range updates Fenwick tree
		adjust(idx1, b);
//		cout<<"in"<<endl;
		adjust(idx2+1, -1*b);
	}
	ll pointq(int idx1){                                              // Point Query fenwick tree
		return rsq(idx1);
	}
};


int main(){
	ios::sync_with_stdio(false);
	int T,H;
	cin>>T;                                                                    // Test cases and hold
	H = T;

	while(T--){
		ll ans =0;                                                            // ans holds no of inversions
		int A[SIZE], n,k;
		set<int> A1;                                                          // set to check if there r any repeated Ai's
		cin>>n>>k;
		for(int i=0; i< n; i++){
			cin>>A[i];
			A1.insert(A[i]);
		}
		FenwickTree t(n+3);

		for(int i =0; i< n; i++){                                        // Function to find no of invs
			ans+= t.pointq(A[i]);
			t.rupd(1,A[i]-1,1);
		}

		cout<<"Case "<<H-T<<": ";
		if(ans>k){                                                       // If invs are more then ans is ans-k
			cout<<ans-k<<endl;
		}
		else{                                                           // If k is more-> more swaps even aftr sortd
			if(A1.size() != n)cout<<0<<endl;                             // 2 identical elements can b swappd again nd again
			else
			if((k-ans)%2)cout<<1<<endl;                                  // check parity
			else cout<<0<<endl;
		}
	}
	return 0;
}

