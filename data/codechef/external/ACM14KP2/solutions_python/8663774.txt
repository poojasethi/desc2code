import java.io.*;
import java.util.*;

class acmc
{
public static long _mergeSort(long arr[], long temp[], int left, int right)
{
  int mid;
  long inv_count = 0;
  long m;
  if (right > left)
  {
    /* Divide the array into two parts and call _mergeSortAndCountInv()
       for each of the parts */
    m = (right + left)/2;
    mid=(int)m;
  
    /* Inversion count will be sum of inversions in left-part, right-part
      and number of inversions in merging */
    inv_count  = _mergeSort(arr, temp, left, mid);
    inv_count += _mergeSort(arr, temp, mid+1, right);
  
    /*Merge the two parts*/
    inv_count += merge(arr, temp, left, mid+1, right);
  }
  return inv_count;
}
  
/* This funt merges two sorted arrays and returns inversion count in
   the arrays.*/
public static long merge(long arr[], long temp[], int left, int mid, int right)
{
  int i, j, k;
  long inv_count = 0;
  
  i = left; /* i is index for left subarray*/
  j = mid;  /* j is index for right subarray*/
  k = left; /* i is index for resultant merged subarray*/
  while ((i <= mid - 1) && (j <= right))
  {
    if (arr[i] <= arr[j])
    {
      temp[k++] = arr[i++];
    }
    else
    {
      temp[k++] = arr[j++];
  
     /*this is tricky -- see above explanation/diagram for merge()*/
      inv_count = inv_count + (mid - i);
    }
  }
  
  /* Copy the remaining elements of left subarray
   (if there are any) to temp*/
  while (i <= mid - 1)
    temp[k++] = arr[i++];
  
  /* Copy the remaining elements of right subarray
   (if there are any) to temp*/
  while (j <= right)
    temp[k++] = arr[j++];
  
  /*Copy back the merged elements to original array*/
  for (i=left; i <= right; i++)
    arr[i] = temp[i];
  
  return inv_count;
}
	
	public static void main(String[] args) throws Exception
	{
		//new FileInputStream("input.txt");
		//new FileOutputStream("output.txt")
		InputReader in = new InputReader(System.in);
		OutputWriter out = new OutputWriter(System.out);
		int t=in.ri();
		for(int z=0;z<t;z++)
		{
			int n=in.ri();
			long k=in.rl();
			long ar[]=new long[100005];
			int flag=0;
			Arrays.fill(ar,0);
			long arr[]=new long[n];
			long temp[]=new long[n];
			for(int i=0;i<n;i++){arr[i]=in.rl();ar[(int)arr[i]]+=1;
				if(ar[(int)arr[i]]>1)flag=1;}
			long ans=(_mergeSort(arr,temp,0,n-1));
			//out.pl(ans);
			out.print("Case "+(z+1)+": ");
			if(k<=ans)
			{
				out.pl(ans-k);
			}
			else
			{
				//out.pl("else");
				if((k-ans)%2==0)out.pl("0");
				else{
					//out.pl("else 1");
					if(flag==1)out.pl("0");
					else out.pl("1");
					}
			}
		}
		out.close();
	}
		
		//out.printLine(max);
		
	


	private static class InputReader
	{
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;
		 
		public InputReader(InputStream stream)
		{
			this.stream = stream;
		}
 
		public int read()
		{
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars)
			{
				curChar = 0;
				try
				{
					numChars = stream.read(buf);
				} catch (IOException e)
				{
					throw new InputMismatchException();
				}
				if (numChars <= 0)
				return -1;
			}
			return buf[curChar++];
		}
		 public double rd() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, ri());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, ri());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }
		public int ri()
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-')
			{
				sgn = -1;
				c = read();
			}
			int res = 0;
			do
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}
		
		
		public long rl() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
		public String rs()
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do
			{
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}
		
		public boolean isSpaceChar(int c)
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
 
		
 
		public interface SpaceCharFilter
		{
			public boolean isSpaceChar(int ch);
		}
	}
 
	private static class OutputWriter
	{
		private final PrintWriter writer;
 
		public OutputWriter(OutputStream outputStream)
		{
			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
		}
 
		public OutputWriter(Writer writer)
		{
			this.writer = new PrintWriter(writer);
		}
 		public void print(Object... objects)
		{
			for (int i = 0; i < objects.length; i++)
			{
				if (i != 0)
				writer.print(' ');
				writer.print(objects[i]);
			}
		}
		
		public void pf(double n)
		{
			writer.printf("%.2f%n", n);
		}
		public void pl(Object... objects)
		{
			print(objects);
			writer.println();
		}
 
		public void close()
		{
			writer.close();
		}
 
		public void flush()
		{
			writer.flush();
		}
 
	}
}
