// C++ code to demonstrate operations of Binary Index Tree
#include<iostream>
using namespace std;
typedef long long int l;
#include<cstdio>
#include<algorithm>
#include<map>
template<typename X> inline void inp(X &n ) {
     int ch=getchar();int sign=1;n=0;
     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();}
     while(  ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=getchar();
     n=n*sign;
}l bt[100001]={0};
l arr[100001]={0};int n;


l getSum(int index)
{
    l sum = 0; // Iniialize result
index--;

    while (index>0)
    {
        // Add current element of BITree to sum
        sum +=bt[index];

        // Move index to parent node
        index -= index & (-index);
    }
    return sum;
}

// Updates a node in Binary Index Tree (BITree) at given index
// in BITree.  The given value 'val' is added to BITree[i] and
// all of its ancestors in tree.
void updateBIT(int index, int val)
{
    // index in BITree[] is 1 more than the index in arr[]
   // index = index + 1;

    // Traverse all ancestors and add 'val'
    while (index <= n)
    {
       // Add 'val' to current node of BI Tree
       bt[index] += val;

       // Update index to that of parent
       index += index & (-index);
    }
}

map<int,int> m;int ca=1;
int main()
{
int t;
inp(t);
while(t--)
{
    int k;
    inp(n);int flag=0;
    inp(k);int val;
    for(int i=1;i<=n;i++)
    {
        inp(val);
        arr[i]=val;
        if(m[val]>0)
            flag=1;
        m[val]++;
       // cout<<arr[i]<<endl;

    }

    l ans=0;
    for(int i=0;i<=n;i++)
        bt[i]=0;

 for(int i=n;i>=1;i--)
 {
     ans+=getSum(arr[i]);
     updateBIT(arr[i],1);
     //cout<<


 }
// cout<<"ans= "<<ans<<endl;
 printf("Case %d: ",ca);
 ca++;
 if((k)<=ans)
    cout<<ans-k<<endl;
 else
 {
     if(flag)
        cout<<0<<endl;
     else if(!((k-ans)&1))
             {
                 cout<<0<<endl;
             }
    else
        cout<<1<<endl;
 }
 m.clear();
}
}

