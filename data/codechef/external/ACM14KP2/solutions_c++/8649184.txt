/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 *
 * @author Sourav Kumar Paul
 */
class ByeInversion {
    static boolean flag = false;
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        int test = Integer.parseInt(reader.readLine());
        long start = System.currentTimeMillis();
        StringTokenizer st;
        for (int t = 0; t < test; t++) {
            flag = false;
            st = new StringTokenizer(reader.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int a[] = new int[n];
            st = new StringTokenizer(reader.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Integer.parseInt(st.nextToken());
            }
            int temp[] = new int[n];
            long cc = findCountInversion(a, temp, 0, n - 1);
            if (cc >= k) {
                out.println("Case " + (t + 1) + ": " + (cc - k));
            } else {
                if ((k - cc) % 2 == 1) {
                    if(flag)
                        out.println("Case " + (t + 1) + ": 0");
                    else
                    out.println("Case " + (t + 1) + ": 1");
                } else {
                    out.println("Case " + (t + 1) + ": 0");
                }
            }
        }
        out.flush();
        out.close();

        //  System.out.println("\n\ntime: "+(System.currentTimeMillis() - start)/100F + "s");
    }

    private static long findCountInversion(int[] a, int temp[], int beg, int end) {
        if (beg >= end) {
            return 0;
        }
        int mid = (end + beg) / 2 ;
        long sum = findCountInversion(a, temp, beg, mid);
        sum += findCountInversion(a, temp, mid + 1, end);
        sum += merge( a,temp, beg, mid + 1, end);
        return sum;

    }

    private static long merge(int[] arr, int temp[], int left, int mid, int right) {

        int i, j, k;
        long inv_count = 0;

        i = left; /* i is index for left subarray*/

        j = mid;  /* i is index for right subarray*/

        k = left; /* i is index for resultant merged subarray*/

        while ((i <= mid - 1) && (j <= right)) {
            if (arr[i] <= arr[j]) {
                if(arr[i] == arr[j])
                    flag = true;
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];

                /*this is tricky -- see above explanation/diagram for merge()*/
                inv_count = inv_count + (mid - i);
            }
        }

        /* Copy the remaining elements of left subarray
         (if there are any) to temp*/
        while (i <= mid - 1) {
            temp[k++] = arr[i++];
        }

        /* Copy the remaining elements of right subarray
         (if there are any) to temp*/
        while (j <= right) {
            temp[k++] = arr[j++];
        }

        /*Copy back the merged elements to original array*/
        for (i = left; i <= right; i++) {
            arr[i] = temp[i];
        }

        return inv_count;

    }
}
