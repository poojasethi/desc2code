#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 10000007
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){ return N=N | (1<<pos);}
int RESET(int N,int pos){   return N= N & ~(1<<pos);}
int check(int N,int pos){   return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){   printf("("); for(int i=6;i>=1;i--)  {bool x=check(N,i);cout<<x;}    puts(")");}
int mod(int a, int b) { return a - a/b * b;}

ll N;
int K;

int ID;
map<pair<int, pair<int, int> >, int> Mp;

typedef vector<ll> row;
typedef vector<row> matrix;

ll rec(ll pos, int a, bool b, bool c)
{
	if(pos == N) {
		return a == 0 && c;
	}
	
	ll ans = 0;
	
	//cout<<"pos => " << pos << " a => " << a <<" b => " << b <<" c => " << c <<"\n";
	
	// a ko do
	ans += rec(pos + 1, (a + 1)%K, 0, c);
	
	if(!b) {
		ans += rec(pos + 1, a, !b, c);
	}
	
	ans += rec(pos + 1, a, 0, true);
	
	return ans;
}

int Get(int i, int j, int k)
{
	if(Mp.count(mpa(i, mpa(j, k))))
		return Mp[mpa(i, mpa(j, k))];
	Mp[mpa(i, mpa(j, k))] = ID;
	return ID++;
}

matrix pre()
{
	
	if(K == 0) {
		
		matrix mat = matrix(4, row(4, 0));
		for(int i = 0; i <= 0; ++i) {
			for(int j = 0; j <= 1; ++j) {
				for(int k = 0; k <= 1; ++k) {
					for(int l = 0; l <= 2; ++l) {
						int nwi = i;
						int nwj = j;
						int nwk = k;
					
						if(l == 0) {
							continue;
						} else if(l == 1) {
							if(nwj == 1)
								continue;
							nwj = 1;
						} else {
							nwk = 1;
							nwj = 0;
						}
						
						int prestate = Get(i, j, k);
						int newstate = Get(nwi, nwj, nwk);
						
						mat[prestate][newstate]++;
					}
				}
			}
		}
		
		return mat;
	}
	
	matrix mat = matrix(4 * K, row(4 * K, 0));
	
	for(int i = 0; i < K; ++i) {
		for(int j = 0; j <= 1; ++j) {
			for(int k = 0; k <= 1; ++k) {
				for(int l = 0; l <= 2; ++l) {
					int nwi = i;
					int nwj = j;
					int nwk = k;
				
					if(l == 0) {
						nwi = (nwi + 1)%K;
						nwj = 0;
					} else if(l == 1) {
						if(nwj == 1)
							continue;
						nwj = 1;
					} else {
						nwk = 1;
						nwj = 0;
					}
					
					int prestate = Get(i, j, k);
					int newstate = Get(nwi, nwj, nwk);
					
					mat[prestate][newstate]++;
				}
			}
		}
	}
	
	return mat;
}

matrix mul(matrix a, matrix b)
{
	int size = a.size();
	matrix c = matrix(size, row(size, 0));
	for(int i = 0; i < size; ++i) {
		for(int j = 0; j < size; ++j) {
			for(int k = 0; k < size; ++k) {
				c[i][j] += (a[i][k] * b[k][j]);
				if(c[i][j] >= MOD)
					c[i][j] %= MOD;
			}
		}
	}
	
	return c;
}

matrix Pow_(matrix mat, ll Pp)
{
	if(Pp == 1)
		return mat;
	matrix c = Pow_(mat, Pp >> 1);
	c = mul(c, c);
	
	if(Pp & 1)
		c = mul(c, mat);
	return c;
}

int main()
{
	int T;
	scanf("%d", &T);
	ID = 0;
	
	while(T--) {
		scanf("%lld%d", &N, &K);
		Mp.clear();
		ID = 0;
		matrix mat = pre();
		
		mat = Pow_(mat, N);
		
		ll ans = mat[Get(0, 0, 0)][Get(0, 0, 1)];
		ans += mat[Get(0, 0, 0)][Get(0, 1, 1)];
		if(ans >= MOD)
			ans %= MOD;
		printf("%lld\n", ans);	
	}
	
	return 0;
}