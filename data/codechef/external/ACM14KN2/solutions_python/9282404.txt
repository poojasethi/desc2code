#include<bits/stdc++.h>
#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)
#define mp make_pair
using namespace std;
typedef long long int ll;
typedef unsigned long long int ull;
ll P=10000007;
int id;
map<pair<int,pair<int,int> >,int>state;
struct llModMatrix{
  int r, c, mod; ll limit; ll **data;
  void malloc(int r, int c, int mod){int i;this->r=r;this->c=c;this->mod=mod;limit=((1ULL<<63)-1)-(ull)(mod-1)*(mod-1);data=(ll**)std::malloc(sizeof(ll*)*r);data[0]=(ll*)std::malloc(sizeof(ll)*r*c);REP(i,1,r)data[i]=data[i-1]+c;}
  void* malloc(int r, int c, int mod, void *workMemory){int i;this->r=r;this->c=c;this->mod=mod;limit=((1ULL<<63)-1)-(ull)(mod-1)*(mod-1);data=(ll**)workMemory;data[0]=(ll*)(data+r);REP(i,1,r)data[i]=data[i-1]+c;return (void*)(data[0]+r*c);}
  void free(void){std::free(data[0]);std::free(data);}
  void setIdentity(){int i,j;rep(i,r)rep(j,c){data[i][j]=0;if(i==j)data[i][j]=1;}}
  void setZero(){int i,j;rep(i,r)rep(j,c)data[i][j]=0;}
  void operator=(llModMatrix &a){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c)data[i][j]=a.data[i][j];}
  void operator+=(llModMatrix &a){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]+=a.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  void operator-=(llModMatrix &a){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]-=a.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  void mixed(void){int i,j;rep(i,r)rep(j,c){if(data[i][j]<0)data[i][j]+=mod;if(data[i][j]&&rand()%2)data[i][j]-=mod;}}
  void add(llModMatrix &a, llModMatrix &b){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]=a.data[i][j]+b.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  void sub(llModMatrix &a, llModMatrix &b){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]=a.data[i][j]-b.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  void mul(llModMatrix &a, llModMatrix &b){int i,j,k;r=a.r;c=b.c;setZero();rep(i,r)rep(k,a.c)if(a.data[i][k])rep(j,c){data[i][j]+=a.data[i][k]*b.data[k][j];if(data[i][j]>=limit||data[i][j]<=-limit)data[i][j]%=mod;}rep(i,r)rep(j,c)if(data[i][j]>=mod||data[i][j]<=-mod)data[i][j]%=mod;}
  void pow(llModMatrix &a, ull b, void *workMemory){llModMatrix t1,t2;r=c=a.r;workMemory=t1.malloc(r,c,mod,workMemory);workMemory=t2.malloc(r,c,mod,workMemory);setIdentity();t1=a;while(b){if(b%2){t2=*this;this->mul(t2,t1);}t2.mul(t1,t1);t1=t2;b/=2;}}
  bool print(){for(int i=0;i<r;i++,cout<<"\n")for(int j=0;j<c;j++)cout<<data[i][j]<<" ";cout<<'\n';return true;}
};
int getState(int k,int j,int v)
{
	//cout<<k<<" # "<<j<<" # "<<v<<"\n";
	if(state.count(mp(k,mp(j,v)))==1)
		return state[mp(k,mp(j,v))];
	state[mp(k,mp(j,v))]=id;
	return id++;
}
void setT(llModMatrix& T,int K)
{
	for(int k=0;k<max(K,1);k++)
	{
		for(int j=0;j<2;j++)
		{
			for(int v=0;v<2;v++)
				{	if(K)//k solves it
						T.data[getState(k,j,v)][getState((k+1)%K,0,v)]++;
					if(j==0)
						T.data[getState(k,j,v)][getState(k,1,v)]++;
					T.data[getState(k,j,v)][getState(k,0,1)]++;
			}
		}
	}
}
void *mem=malloc(50*50*sizeof(ll));
int main()
{
	cin.sync_with_stdio(0);
	int t,K;			cin>>t;
	ll N,ans;
	llModMatrix T,pw;	T.malloc(50,50,P);	pw.malloc(50,50,P);
	while(t--)
	{
		ans=0;	id=0;	state.clear();
		cin>>N>>K;	T.setZero();pw.setZero();
		T.r=T.c=max(4*K,4);
		//cout<<"Starting \n";
		setT(T,K);//cout<<"DONE setting Transition matrix\n";
		//T.print();
		pw.pow(T,N,mem);
		//pw.print();cout<<"\n";
		//cout<<getState(0,0,0)<<" "<<getState(0,0,1)<<" "<<getState(0,1,1)<<"\n";
		ans=pw.data[getState(0,0,0)][getState(0,0,1)];
		ans=(ans+pw.data[getState(0,0,0)][getState(0,1,1)])%P;
		cout<<ans<<"\n";
	}
	return 0;
}
