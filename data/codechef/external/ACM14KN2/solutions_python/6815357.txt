#include<bits/stdc++.h>
#define ll long long
#define ff first
#define ss second
#define m_p make_pair
#define pb push_back
#define pf push_front
#define ppf pop_front
#define ppb pop_back
#define NINF 0x80
#define INF 0x3f
#define eps 1e-9
#define l_b lower_bound
#define u_b upper_bound
#define MOD1 1000000007
#define MOD2 1000000009
#define check(n,pos) (bool)(n & (1<<pos))
#define biton(n,pos) (n | (1<<pos))
#define bitoff(n,pos) (n & ~(1<<pos))
#define mod(a,b) ((a%b+(ll)b)%b)
using namespace std;
/****************************matrix******************************/
const int _M=10000007;
const int maxN=100;
struct mat
{
    ll _[maxN][maxN];//long long <<
    int r,c;
    mat()
    {
        memset(_,0,sizeof _);
    }
    mat (int a,int b)
    {
        r=a,c=b;
        memset(_,0,sizeof _);
    }
    void set()
    {
        memset(_,0,sizeof _);
    }
    void set (int a,int b) // integer ,integer <<
    {
        r=a,c=b;
        memset(_,0,sizeof _);
    }
    void print()
    {
        printf("** Printing matrix **\n");
        for(int i=1; i<=r; i++)
        {
            for(int j=1; j<=c; j++)
            {
                if(j!=1) printf(" ");
                printf("%lld",_[i][j]); //lld, long long
            }
            printf("\n");
        }
        printf("___ End printing ___\n");
    }
} tmp,I;
mat operator * (mat &a,mat &b)
{
    tmp.set(a.r,b.c);
    for(int i=1; i<=a.r; i++)
        for(int j=1; j<=b.c; j++)
            for(int k=1; k<=a.c; k++)//1 to n
            {
                tmp._[i][j]+=a._[i][k]*b._[k][j];
                if(tmp._[i][j]>=_M) tmp._[i][j]%=_M;
            }//mod defined
    return tmp;
}
mat operator ^ (mat a,ll p) // ll p <<
{
    I.set(a.r,a.c);
    for(int i=0; i<=a.r; i++) I._[i][i]=1;
    while(p)
    {
        if(p&1) I=I*a;
        a=a*a;
        p>>=1;
    }
    return I;
}
/****************************matrix******************************/
mat M;
ll n;
int k,cnt;
int node[12][2][2];
int getid(int i,bool j,bool l)
{
    if(!node[i][j][l]) return node[i][j][l]=++cnt;
    else return node[i][j][l];
}
void build_M()
{
    for(int i=0; i<k || i==0; i++)
    {
        for(int j=0; j<=1; j++)
        {
            for(int l=0; l<=1; l++)
            {
                if(k) M._[getid(i,j,l)][getid((i+1)%k,0,l)]++;
                if(!j) M._[getid(i,j,l)][getid(i,1,l)]++;
                M._[getid(i,j,l)][getid(i,0,1)]++;
            }
        }
    }
    M=M^(n);
}
ll getres()
{
    ll res=0;
    res+=M._[getid(0,0,0)][getid(0,0,1)];
    if(res>=_M) res%=_M;
    res+=M._[getid(0,0,0)][getid(0,1,1)];
    return res%_M;
}

int main()
{
    int ks,kase;
    scanf("%d",&kase);
    for(ks=1; ks<=kase; ks++)
    {
        scanf("%lld %d",&n,&k);
        int mm=max(k,1);
        M.set(mm*2*2,mm*2*2);
        memset(node,0,sizeof node);
        cnt=0;
        build_M();
        printf("%lld\n",getres());
    }
}
/*
10000
1000000000000000000 10
60794
100000 5
864655
1000 2
6441917
32123131231  5
2350311
31231312312313123 2
2763134
231313131232313 0
5422596
31231231313123 1
5925559
31312313133123 6
4925909
675675757575 2
9361986
2231 10
7166207


*/
