#include<iostream>
#include<bits/stdc++.h>
using namespace std;
#include<vector>

#define ll long long
/* This function calculates power of p in n! */
#define gc getchar_unlocked
#define pc putchar_unlocked

int fastread()
{
char sign='\0',c=gc();
int ret=0;
while((c<'0'||c>'9')&&c!='-'){c=gc();}
if(c=='-'){
sign='1';
c=gc();
}
while(c>='0'&&c<='9'){
ret=10*ret+c-48;
c=gc();
}
if(sign)ret=-ret;
return ret;
}

int countFact(int n,ll int p)
{
int k=0;
while (n>=p)
{
k+=n/p;
n/=p;
}
return k;
}

/* This function calculates (a^b)%MOD */
long long pow(int a, int b,ll int MOD)
{
long long x=1,y=a;
while(b > 0)
{
if(b%2 == 1)
{
x=(x*y);
if(x>MOD) x%=MOD;
}
y = (y*y);
if(y>MOD) y%=MOD;
b /= 2;
}
return x;
}

/* Modular Multiplicative Inverse
Using Euler's Theorem
a^(phi(m)) = 1 (mod m)
a^(-1) = a^(m-2) (mod m) */
long long InverseEuler(int n, ll int MOD)
{
return pow(n,MOD-2,MOD);
}

long long factMOD(int n,ll int MOD)
{
long long res = 1;
while (n > 0)
{
for (int i=2, m=n%MOD; i<=m; i++)
res = (res * i) % MOD;
if ((n/=MOD)%2 > 0)
res = MOD - res;
}
return res;
}

long long C(int n, int r, ll int MOD)
{
if (countFact(n, MOD) > countFact(r, MOD) + countFact(n-r, MOD))
return 0;

return (factMOD(n, MOD) *
((InverseEuler(factMOD(r, MOD), MOD) *
InverseEuler(factMOD(n-r, MOD), MOD)) % MOD)) % MOD;
}

int main()
{ int t;
t=fastread();
while(t-- )
{

int n,r;
long long int p=1000000007;
n=fastread(); r=fastread();
{ if(r>n)
printf("0\n");
else
printf("%lld\n",C(n,r,p));
}

}
}
