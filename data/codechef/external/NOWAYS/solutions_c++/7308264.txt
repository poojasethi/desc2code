#include<bits/stdc++.h>
using namespace std;

#define sd(x) scanf("%d",&x)
#define ss(x) scanf("%s",x)
#define lld long long int
#define slld(x) scanf("%lld",&x)



long long int countFact(long long int n,long long int p)
{
long long int k=0;
while (n>=p)
{
k+=n/p;
n/=p;
}
return k;
}

/* This function calculates (a^b)%MOD */
long long pow(long long int a, long long int b, long long int MOD)
{
long long x=1,y=a;
while(b > 0)
{
if(b%2 == 1)
{
x=(x*y);
if(x>MOD) x%=MOD;
}
y = (y*y);
if(y>MOD) y%=MOD;
b /= 2;
}
return x;
}

/* Modular Multiplicative Inverse
Using Euler's Theorem
a^(phi(m)) = 1 (mod m)
a^(-1) = a^(m-2) (mod m) */
long long int InverseEuler(long long int n,long long int MOD)
{
return pow(n,MOD-2,MOD);
}

long long factMOD(long long int n,long long int MOD)
{
long long res = 1;
while (n > 0)
{
for (int i=2, m=n%MOD; i<=m; i++)
res = (res * i) % MOD;
if ((n/=MOD)%2 > 0)
res = MOD - res;
}
return res;
}

long long int C(long long int n, long long int r,long long int MOD)
{
if (countFact(n, MOD) > countFact(r, MOD) + countFact(n-r, MOD))
return 0;

return (factMOD(n, MOD) *
((InverseEuler(factMOD(r, MOD), MOD) *
InverseEuler(factMOD(n-r, MOD), MOD)) % MOD)) % MOD;
}

int main()
{
    int t;
    lld n,k;
	sd(t);
	while(t--)
	{
        slld(n);slld(k);
        if(n>=k)
        printf("%lld\n",C(n,k,1000000007));
        else
        cout<<0<<endl;
	}

	return 0;
}
