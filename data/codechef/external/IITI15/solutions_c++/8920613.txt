// created  : Prashant Kumar Singh :) 
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<math.h>
#include<cstring>
#include<utility>
#include<cstring>
#include<set>
#include<map>
#include<vector>
#include<functional>
#define ll long long
#define gr greater<ll>()
#define pi acos(-1.0)
#define mp make_pair
#define sz(a) int((a).size())
#define pb push_back
#define f(i,l,r) for(int i=l;i<=r;i++)
#define in_T int t;for(scanf("%d",&t);t--;)
#define in_I(a) scanf("%d",&a)
#define in_F(a) scanf("%lf",&a)
#define in_L(a) scanf("%I64d",&a)
#define in_S(a) scanf("%s",a)
#define newline printf("\n")
#define MAX1(a,b) a>b?a:b
#define MIN(a,b) a<b?a:b
#define SWAP(a,b) {int tmp=a;a=b;b=tmp;}
#define P_I(a) printf("%d\n",a)
#define P_L(a) printf("%I64d\n",a);
const ll  MAX = 200005;
using namespace std;
struct query
{
    int l, r, n;
} q[MAX];
 ll bt[MAX],x[MAX],ans[MAX],inv=0,block,n,m;
void update(ll indx,ll val)
{
    while(indx<=MAX)
    {
        bt[indx]+=val;
        indx+=(indx)&(-indx);
    }
}
ll query_bit(ll indx)
{
    ll ans=0;
    while(indx>0)
    {
        ans+=bt[indx];
        indx-=(indx)&(-indx);
    }
    //cout<<ans<<"\n";
    return ans;
}
bool comp(query x, query y)
{
    if (x.l / block != y.l / block)
        return x.l / block < y.l / block;
    return x.r < y.r;
}
 
//for updates in queries
void addrgt(int  pos)
{
    inv+=query_bit(20001ll)-query_bit(x[pos]);
    update(x[pos],1);
     return ;
}
void removergt(int pos)
{
    inv-=query_bit(20001ll)-query_bit(x[pos]);
    update(x[pos],-1);
}
void addlft(int pos)
{
    inv+=query_bit(x[pos]-1);
    update(x[pos],1);
}
//for update of queries
void removelft(int  pos)
{
    inv-=query_bit(x[pos]-1);
    update(x[pos],-1);
     return;
}
 
int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    #ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
#endif
    cin>>n;
    block = sqrt(n);
    map<ll,ll>mp;
    for(int i=1;i<=n;i++){
        cin>>x[i];
        mp[x[i]]++;
    }
    map<ll,ll>::iterator it;
    ll rank=1;
    for( it=mp.begin();it!=mp.end();it++)
    it->second=rank++;
    
    for(int i=1;i<=n;i++)
    x[i]=mp[x[i]];
    cin>>m;
    for (int i = 0; i < m; i++)
    {
        cin>>q[i].l>>q[i].r; 
        q[i].n = i;
    }
    sort(q, q + m, comp);
 
    int curL = 1, curR = 1, L, R;
    for (int i = 0; i < m; i++)
    {
        L = q[i].l;
        R = q[i].r;
 
        while (curL < L)
        {
            removelft(curL);
            curL++;
        }
        while (curL > L)
        {
            addlft(curL - 1);
            curL--;
        }
        while (curR <= R)
        {
            addrgt(curR);
            curR++;
        }
        while (curR > R + 1)
        {
            removergt(curR - 1);
            curR--;
        }
 
        ans[q[i].n] = inv;
    }
 
    for (int i = 0; i < m; i++)
    {
        P_L(ans[i]);
    }
 
    return 0;
} 