  #include <bits/stdc++.h>
  using namespace std;
  #define infinity (1000000007)
  #define pii pair<int,int>
  #define ppi pair<pii,int>
  #define ppp pair<pii,pii>
  #define pip pair<int,pii>
  #define ll long long

  const int mod=1000000007;
  long long pwr(long long a,long long b,long long mod)
  {
    if(b==0)
      return 1;
    long long temp=pwr(a,b/2,mod);
    temp=(temp*temp)%mod;
    if(b&1)
      temp=(temp*a)%mod;
    return temp;
  }
  long long pwr(long long a,long long b)
  {
    if(b==0)
      return 1;
    long long temp=pwr(a,b/2);
    temp=(temp*temp);
    if(b&1)
      temp=(temp*a);
    return temp;
  }
  long long gcd(long long a,long long b)
  {
    return b==0?a:gcd(b,a%b);
  }
  long long lcm(long long a,long long b)
  {  
    return (a/gcd(a,b))*b;
  }
  long long modularInverse(long long a,long long m)
  {
        return pwr(a,m-2,m);
  }
  bool* isPrime;
  void generatePrimeSieve(const int lim)
  {
    isPrime=(bool *)malloc(lim+1);
    memset(isPrime,true,lim+1);
    isPrime[0]=false;
    isPrime[1]=false;
    for(int i=2;i<=lim;++i)
      if(isPrime[i])
        for(int j=i+i;j<=lim;j+=i)
          isPrime[j]=false;
  }
  #define matrix vector<vector<int> >
  matrix identityMatrix;
  matrix mul(const matrix &a,const matrix &b)
  {
    int n=a.size();
    matrix ans(n,vector<int> (n) );
    for (int i = 0; i < n; ++i)
    {
      for (int j = 0; j < n; ++j)
      {
        for (int k = 0; k < n; ++k)
        {
          ans[i][j]+= ((long long)a[i][k]*b[k][j])%mod;
          ans[i][j]%=mod;
        }
      }
    }
    return ans;
  } 
  matrix pwr(const matrix &a,long long n)
  {
      if(n==0)
      {
        /*define identity */
        assert(false);
        return identityMatrix;
      }
      if(n==1)
       return a;
      matrix tmp=pwr(a,n/2);
      tmp=mul(tmp,tmp);
      if(n&1)
        tmp=mul(a,tmp);
      return tmp;
  }

  int base;
  struct Qry
  {
    int l,r,i;
    Qry(){}
    Qry(int u,int v,int i)
    {
      this->l=u;
      this->r=v;
      this->i=i;
    }

    bool operator < (const Qry o) const
    {
      if( l/base == o.l/base)
        return r<o.r;

      return l/base<o.l/base;
    }
  };


  int tree[100001];
  void mu(int i)
  {   
    int p;
    while(i)
    {
      p=(i-1)/2;
      if(i&1)
        tree[p]=tree[i]+tree[i+1];
      else
        tree[p]=tree[i]+tree[i-1];
      i=p;
    }

  }

  int qst(int i,int l,int r,int x,int y)
  {
    // cout<<i<<" "<<l<<" "<<r<<" "<<x<<" "<<y<<endl;
    if(x>r || y<l)
      return 0;
    if(x<=l && r<=y)
      return tree[i];

    int m=(l+r)/2;

    return qst(2*i+1,l,m,x,y)+qst(2*i+2,m+1,r,x,y);

  }
  #define pb push_back
  vector<Qry> q;
  int a[42342];
  int b[43432];
  int ans[43222];
  int currL=-1,currR=-1;
  int total=0;
  int n,N,BASE;
  int mp(int x)
  {
    return lower_bound(b,b+n,x)-b;
  }
  void addPointToLeft(int u)
  {
    // cout<<"addPointToLeft( "<<u<<endl;
    if(u==-1)
      return;
    int val=mp(a[u]);
    total+=qst(0,0,BASE,0,val-1);
    tree[BASE+val]+=1;
    mu(BASE+val);
  }
  void addPointToRight(int u)
  {
    // cout<<"addPointToRight "<<u<<endl;
    if(u==-1)
      return;

    int val=mp(a[u]);
    // cout<<u<<" "<<a[u]<<" "<<val<<"x\n"<<endl;
    // cout<<val+1<<" "<<n-1<<endl;
    total+=qst(0,0,BASE,val+1,n-1);
    tree[BASE+val]+=1;
    mu(BASE+val);

    // cout<<total<<endl;
  }
  void removePointFromLeft(int u)
  {
    // cout<<"removePointFrom "<<u<<endl;
    if(u==-1)
      return;
    int val=mp(a[u]);
    total-=qst(0,0,BASE,0,val-1);
    tree[BASE+val]-=1;
    mu(BASE+val);
  }
  void removePointFromRight(int u)
  {
    // cout<<"removePointFrom "<<u<<endl;
    if(u==-1)
      return;
    int val=mp(a[u]);
    total-=qst(0,0,BASE,val+1,n-1);
    tree[BASE+val]-=1;
    mu(BASE+val);
  }
  int process(const Qry &q)
  { 
      while(currL<q.l)
      {
        removePointFromLeft(currL);
        ++currL;
      }
      while(currL>q.l)
      {
        --currL;
        addPointToLeft(currL);
      }
      while(currR>q.r)
      {
        removePointFromRight(currR);
        --currR;
      }
      while(currR<q.r)
      {
        ++currR;
        addPointToRight(currR);
      }
      ans[q.i]=total;
  }
  int main()
  {

    scanf("%d",&n);
    base=ceil(sqrt(n));
    N=ceil(log2(n));
    BASE=(1<<N)-1;
    for(int i=0;i<n;++i)
    {
      scanf("%d",&a[i]);
      b[i]=a[i];
    }

    sort(b,b+n);

    int m;
    scanf("%d",&m);
    for(int i=0;i<m;++i)
    {
      int u,v;
      scanf("%d%d",&u,&v);
      q.pb(Qry(u-1,v-1,i));
    }

    sort(q.begin(),q.end());



    for(int i=0;i<m;++i)
      process(q[i]);
    
      
    for(int i=0;i<m;++i)
      printf("%d\n",ans[i]);
      // cout<<ans[i]<<"\n";
  }
