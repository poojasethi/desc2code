/*-----MO : SQRT Decomposition + BIT ((N+Q)*N^0.5*logN)-----*/
#include<bits/stdc++.h>
//#define DEBUG
//#ifdef DEBUG
//code to debug
//#endif
//#undef DEBUG
using namespace std;

const int mod=(int)1e9+7,maxn=20005,ln=17;
#define F(i,p,n) for(int i=p;i<n;i++)
#define I(i,p,q) for(int i=p;i>=q;i--)
#define Ss(x) scanf("%s",x)
#define S(x) scanf("%d",&x)
#define Sl(x) scanf("%lld",&x)
//#define getcx getchar_unlocked
#define getcx getchar
/*inline void S(int& n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}*/
#define Ps(x) printf("%d  ",x)
#define P(x) printf("%d\n",x)
typedef long long int LL;
#define modulo(x,y,z) (x+y)<0?x+y+z:((x+y>=z)?x+y-z:x+y)
#define Debug(x) cout << #x << "=" << x << endl
#define Debugarr(x,n) cout<<"array "<<#x<<":"<<endl; F(ij,0,n) cout<<ij<<". "<<x[ij]<<endl; cout<<endl
#define Debugarr2(x,m,n) cout<<"array "<<#x<<":"<<endl; F(ij,0,m) {F(jk,0,n) cout<<x[ij][jk]<<" "; cout<<endl;} cout<<endl
#define pii pair<int,int>
#define Fi first
#define Se second
#define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int
#define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit
const int shift=30,etf=mod-1;

const LL inf=(LL)1e18+1;

const double PI=(double)3.141592653589793238,EPSILON=1e-10;

int a[maxn],buck_sz,ans,res[maxn],lptr=1,rptr=0,BIT[maxn];

int q,n;

map<int,int> mym;
map<int,int>::iterator itm;

vector<pii> vec;

struct query
{
    int l,r,idx;
}info[maxn];

bool cmp(query a,query b)
{
    if((a.l-1)/buck_sz==(b.l-1)/buck_sz)
        return a.r<b.r;
    return (a.l-1)/buck_sz<(b.l-1)/buck_sz;
}

int Sqrt(int n)
{
    int p=1,q=1005;
    while(p!=q)
    {
        int m=(p+q)>>1;
        if(m*m<n)
            p=m+1;
        else
            q=m;
    }
    return p;
}

void bitupdate(int idx,int val,int maxval)
{
    //assert(idx>0);
    int p=idx;
    while(p<=maxval)
    {
        BIT[p]+=val;
        p+=(p & -p);
    }
}

int bitquery(int idx,int maxval)
{
    //assert(idx>0);

    int s=0;
    while(idx)
    {
        s+=BIT[idx];
        idx-=(idx & -idx);
    }
    return s;
}

void _add1(int position)
{
    int temp=bitquery(a[position]-1,n);
    ans+=temp;
    bitupdate(a[position],1,n);
}

void _add2(int position)
{
    int temp=bitquery(n,n)-bitquery(a[position],n);
    ans+=temp;
    bitupdate(a[position],1,n);
}

void _remove1(int position)
{
    int temp=bitquery(a[position]-1,n);
    ans-=temp;
    bitupdate(a[position],-1,n);
}

void _remove2(int position)
{
    int temp=bitquery(n,n)-bitquery(a[position],n);
    ans-=temp;
    bitupdate(a[position],-1,n);
}

void calculate(int idx)
{
    while(lptr<info[idx].l)
    {
        _remove1(lptr);
        lptr++;
    }

    while(lptr>info[idx].l)
    {
        lptr--;
        _add1(lptr);
    }

    while(rptr<info[idx].r)
    {
        rptr++;
        _add2(rptr);
    }

    while(rptr>info[idx].r)
    {
        _remove2(rptr);
        rptr--;
    }
    res[info[idx].idx]=ans;
}

int main()
{
    S(n);
    int cnt=0;
    buck_sz=Sqrt(n);
    F(i,1,n+1)
    {
        S(a[i]);
        vec.push_back(pii (a[i],i));
    }
    sort(vec.begin(),vec.end());
    F(i,0,vec.size())
    {
        itm=mym.find(vec[i].Fi);
        if(itm==mym.end())
        {
            mym[vec[i].Fi]=++cnt;
        }
        a[vec[i].Se]=mym[vec[i].Fi];
    }
    S(q);
    F(i,1,q+1)
    {
        int l,r;
        S(l);
        S(r);
        info[i].l=l;
        info[i].r=r;
        info[i].idx=i;
    }

    sort(info+1,info+q+1,cmp);

    F(i,1,q+1)
    {
        calculate(i);
    }

    F(i,1,q+1)
    {
        P(res[i]);
    }

    return 0;
}
