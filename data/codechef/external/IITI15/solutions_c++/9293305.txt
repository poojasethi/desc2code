#include<bits/stdc++.h>

#define MOD 1000000007
#define MAX 20002
#define ll long long
#define slld(t) scanf("%lld",&t)
#define sd(t) scanf("%d",&t)
#define pd(t) printf("%d\n",t)
#define plld(t) printf("%lld\n",t)
#define pcc pair<char,char>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define mp(a,b) make_pair(a,b)
#define F first
#define S second
#define pb(x) push_back(x)

using namespace std;

// segment tree for incrementing part :p

int segtree[MAX<<2];

void build(){
	int lim=MAX<<2;
	for(int i=0;i<lim;i++) segtree[i]=0;
}

int query(int t,int i,int j,const int &ri,const int &rj){
	if(ri<=i && j<=rj)
		return segtree[t];
	
	int l=0,r=0;
	int left = t<<1,right=left|1,mid=(i+j)>>1;
	
	if(ri<=mid) l=query(left,i,mid,ri,rj);
	if(rj>mid) r=query(right,mid+1,j,ri,rj);
	
	return l+r;
}

void update(int t,int i,int j,const int &update_index,const int &inc)
{
	if(i==j) {segtree[t]+=inc; return;	}
	
	int left = t<<1,right=left|1,mid=(i+j)>>1;
	
	if(update_index<=mid)update(left,i,mid,update_index,inc);
	else update(right,mid+1,j,update_index,inc);
	
	segtree[t]=segtree[left]+segtree[right];
}

// end of seg tree 

// MO's stuffs

#define MOQ pair<pii ,int>

pii A[MAX];
int newA[MAX];

MOQ queries[MAX]; //	( (l,r) , idx ) 

int BLOCK_SIZE;		// you will need that for comparison function
bool mo_cmp(const MOQ &x,const MOQ &y){
	int Bx=x.F.F/BLOCK_SIZE,By=y.F.F/BLOCK_SIZE;
	if(Bx!=By) return Bx<By;	// comparing block no
	return x.F.S<y.F.S;
}

ll current_answer=0;		// store answer for current segment we are processing

// extending the current segment 

// computes F[L,R+1] from F[L,R]
inline void addR(int x){
	current_answer+=query(1,1,MAX-1,x+1,MAX-1);	// count of elements greater than x
	update(1,1,MAX-1,x,1);	// increase the count of x by 1
}

// computes F[L,R-1] from F[L,R]
inline void removeR(int x){
	current_answer-=query(1,1,MAX-1,x+1,MAX-1);	// count of elements greater than x
	update(1,1,MAX-1,x,-1);	// decrease the count of x by 1
}

// computes F[L-1,R] from F[L,R]
inline void addL(int x){
	if(x!=1)current_answer+=query(1,1,MAX-1,1,x-1);	// count of elements smaller than x
	update(1,1,MAX-1,x,1);	// increase the count of x by 1
}

// computes F[L+1,R] from F[L,R]
inline void removeL(int x){
	if(x!=1)current_answer-=query(1,1,MAX-1,1,x-1);	// count of elements smaller than x
	update(1,1,MAX-1,x,-1);	// decrease the count of x by 1
}

// end of extension functions

ll answers[MAX];

int main(){
	int n,x;
	sd(n);
	
	for(int i=1;i<=n;i++) sd(x),A[i]=mp(x,i);
	build();
	
	// doing co-ordinate compression
	sort(A+1,A+n+1);
	
	A[0]=mp(-1,0);
	
	int curr=0;
	
	for(int i=1;i<=n;i++){
		if(A[i].F!=A[i-1].F)curr++;
		newA[A[i].S]=curr;
	}
	
	// end of co-ordinate compression, elements can be now in range [1,n]
	
	// Use mos comparator to sort queries in offline
	
	int q;
	sd(q);
	for(int i=1;i<=q;i++){
		int l,r;
		sd(l);sd(r);
		queries[i]=mp(mp(l,r),i);
	}
	
	BLOCK_SIZE=sqrt(n);
	sort(queries+1,queries+q+1,mo_cmp);
	
	// end of query sorting
	
	// set up current segment [mo_left, mo_right];
    int mo_left = 1, mo_right = 0;					// take care about this part .. Its 1,0 because we are using 1 indexing
    
    for(int i = 1; i <= q; i++) {
        // [left, right] is what query we must answer now.
        int left = queries[i].F.F;
        int right = queries[i].F.S;

        // Usual part of applying Mo's algorithm: moving mo_left
        // and mo_right.
        while(mo_right < right) {
            mo_right++;
            addR(newA[mo_right]);
        }
        while(mo_right > right) {
            removeR(newA[mo_right]);
            mo_right--;
        }

        while(mo_left < left) {
            removeL(newA[mo_left]);
            mo_left++;
        }
        while(mo_left > left) {
            mo_left--;
            addL(newA[mo_left]);
        }

        // Store the answer into required position.
        answers[queries[i].S] = current_answer;
    }

    // We output answers *after* we process all queries.
    for(int i = 1; i <=q; i++){
    	plld(answers[i]);
    }
}