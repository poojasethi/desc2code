/* Implementation of printing the shortest path
    using BFS where graph is a n*m grid.
    used map of pairs.   */

#include<bits/stdc++.h>
using namespace std;

map< pair<int,int>, pair<int,int> >path;
int x;
char output[1001][1001],adj[1001][1001];
        int visited[1001][1001];
int bfs(pair<int,int>start, int n, int m)
{
     pair<int,int>p;
    queue< pair<int,int> >q;
    q.push(start);
    visited[start.first][start.second] = 1;
    while(!q.empty()){
        p = q.front();
        q.pop();
        if((visited[p.first+1][p.second] == 0) && (p.first + 1 < n) && ( adj[p.first + 1][p.second] != 'w')){      // bottom
         //   printf("Bottom\n");
            visited[p.first+1][p.second] = 1;
            pair<int,int>temp;
            temp.first = p.first+1;
            temp.second = p.second;
            q.push(temp);
            path[temp] = p;
            //dist[p.first+1][p.second] = dist[p.first][p.second] + 1 ;
          //  path.push_back(temp);
          //  x++;
            if(adj[p.first+1][p.second] == 'f')
                //return dist[p.first+1][p.second] ;
               {
                   output[p.first+1][p.second] = 'f';
            //       path.pop_back();
                   return 1;
               }
        }
        if((visited[p.first-1][p.second] == 0) && (p.first - 1 >= 0) && (adj[p.first - 1][p.second] != 'w')){      // top
       //     printf("Top\n");
            visited[p.first-1][p.second] = 1;
            pair<int,int>temp;
            temp.first = p.first-1;
            temp.second = p.second;
            q.push(temp);
            path[temp] = p;
            //dist[p.first-1][p.second] = dist[p.first][p.second] + 1 ;
          //  path.push_back(temp);
          //  x++;
            if(adj[p.first-1][p.second] == 'f')
                //return dist[p.first-1][p.second] ;
                {
                    output[p.first-1][p.second] = 'f';
            //        path.pop_back();
                    return 1;
                }
        }
        if((visited[p.first][p.second-1] == 0) && (p.second - 1 >= 0) && (adj[p.first][p.second-1] != 'w')){      // left
        //    printf("Left\n");
            visited[p.first][p.second-1] = 1;
            pair<int,int>temp;
            temp.first = p.first;
            temp.second = p.second-1;
            q.push(temp);
            path[temp] = p;
           // dist[p.first][p.second-1] = dist[p.first][p.second] + 1 ;
          //  path.push_back(temp);
          //  x++;
            if(adj[p.first][p.second-1] == 'f')
                {
                    output[p.first][p.second-1] = 'f';
            //        path.pop_back();
                    return 1;
                }
                //return dist[p.first][p.second-1] ;
        }
        if((visited[p.first][p.second+1] == 0) && (p.second + 1 < m) && (adj[p.first][p.second+1] != 'w')){      // right
       //     printf("Right\n");
            visited[p.first][p.second+1] = 1;
            pair<int,int>temp;
            temp.first = p.first;
            temp.second = p.second+1;
            q.push(temp);
            path[temp] = p;
            //dist[p.first][p.second+1] = dist[p.first][p.second] + 1 ;
          //  path.push_back(temp);
          //  x++;
            if(adj[p.first][p.second+1] == 'f')
               {
                   output[p.first][p.second+1] = 'f';
                   return 1;
               }
               // return dist[p.first][p.second+1] ;
        }
    }
    return -1 ;
}


int main()
{
    int t,n,m,a,b,i,j;
    char s[1001];
    pair<int,int>start;
    pair<int,int>last;
    scanf("%d",&t);
    while(t--){
        x=0;

        scanf("%d %d",&n,&m);

        for(i=0;i<n;i++){
            scanf("%s",s);
            for(j=0;j<m;j++){
                output[i][j]=45;
                visited[i][j] = 0;
                adj[i][j] = s[j];
                if(s[j] == 's'){
                    start.first = i;
                    start.second = j;
                }
                if(s[j] == 'f'){
                    last.first = i;
                    last.second = j;
                }
            }
        }
        path[start].first = -1;
        path[start].second = -1;
     //   printf("\n%d %d\n",last.first,last.second);
     //   for(i=0;i<x;i++)
        //    printf("(%d,%d)  ",path[i].first,path[i].second);
        if(bfs(start,n,m) == -1)
            printf("The path doesn't exist.\n");
        else{
                while(path[last].first!=-1 && path[last].second!=-1){
            //        printf("1.  %d,%d  --->   %d,%d\n",last.first,last.second,path[last].first,path[last].second);
                    output[path[last].first][path[last].second] = 'b';
                    last=path[last];
          //          printf("2.  %d,%d  --->   %d,%d\n",last.first,last.second,path[last].first,path[last].second);
                }
            output[start.first][start.second]= 's';
            for(i=0;i<n;i++){
                for(j=0;j<m;j++){
                    printf("%c",output[i][j]);
                }
            printf("\n");
            }
        }
    }
    return 0;
}
