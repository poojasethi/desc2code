#include<iostream>
#include<stdio.h> 
#include<algorithm>
#include<math.h>
#include<vector>
#include<set>
#include<string.h>
#include<map>
#include<queue>
#include<limits.h>
#define tr(i) for(typeof(i.begin()) it=i.begin(); it!=i.end();it++)
#define pb push_back
#define mp make_pair
#define REP(i,n) for(int i=0;i<n;i++)
#define rep(i,s,n) for(int i=s;i<n;i++)
#define s(n) scanf("%d",&n)
#define XX first
#define X first
#define Y second
#define all(a) a.begin(),a.end()
#define YY second.first
#define ZZ second.second
#define fill(a,b) memset(a,b,sizeof(a))

using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
typedef pair<int,pii> piii;
typedef pair<LL,int> pli;

#define MN 1000

int N,M,Q;
int a,b,c;
int D[MN][2],par[MN][2],root[MN],L[MN];
vector<vector<pii> > ad;
vector<pii> ed;
map<pii,int> MAP;
priority_queue<pii,vector<pii>, greater<pii> > path;

void input()
{
	s(N); s(M); s(Q);
	ad.clear();
	ad.resize(N);
	//path=new priority_queue<pii,vector<pii>, greater<pii> >();
	while(!path.empty()) path.pop();
	MAP.clear();
	ed.clear();
	REP(i,M)
	{
		s(a); s(b); s(c);
		ad[a].pb(mp(b,c));
		ad[b].pb(mp(a,c));
		ed.pb(mp(a,b));
	}
	fill(par,-1);
	REP(i,N) REP(j,2) D[i][j]=INT_MAX;
}

void djik(int s, int in)
{
	D[s][in]=0; par[s][in]=-1;
	set<pii> Djik;
	Djik.insert(mp(0,s));
	while(!Djik.empty())
	{
		a=Djik.begin()->X, b=Djik.begin()->Y;
		Djik.erase(Djik.begin());
		if(a!=D[b][in]) continue;
		tr(ad[b])
		{
			if(a+it->second<D[it->first][in])
			{
				D[it->first][in]=a+it->second;
				par[it->first][in]=b;
				Djik.insert(mp(D[it->first][in],it->first));
			}
		}
	}
}

void cdfs(int i,bool cur)
{
	tr(ad[i])
	{
		if(par[i][1]==it->first&&cur) continue;
		if(par[i][0]==it->first) continue;
		path.push(mp(D[i][0]+D[it->first][1]+it->second,L[root[it->first]]));
		//cout<<i<<" "<<it->first<<" ";
		//cout<<D[i][0]+D[it->first][1]+it->second<<" "<<L[root[it->first]]<<endl;
		if(par[it->first][0]==i) cdfs(it->first,false);
	}
}

int main()
{	
	int T; s(T);
	REP(ij,T)
	{
		input();
		djik(0,0);
		int x=N-1,y;
		set<pii> Djik;
		par[N-1][1]=-1;
		while(x!=-1) 
		{
			if(par[x][0]!=-1) par[par[x][0]][1]=x; 
			D[x][1]=D[N-1][0]-D[x][0];
			root[x]=x;
			Djik.insert(mp(D[x][1],x));
			x=par[x][0];
		}
		L[0]=0;
		x=0;
		while(x!=-1)
		{
			if(par[x][1]!=-1) L[par[x][1]]=L[x]+1;
			x=par[x][1];
		}
		while(!Djik.empty())
		{
			a=Djik.begin()->X, b=Djik.begin()->Y;
			Djik.erase(Djik.begin());
			if(a!=D[b][1]) continue;
			tr(ad[b])
			{
				if(a+it->second<D[it->first][1])
				{
					D[it->first][1]=a+it->second;
					par[it->first][1]=b;
					root[it->first]=root[b];
					Djik.insert(mp(D[it->first][1],it->first));
				}
			}
		}
		x=0;
		while(true)
		{
			y=par[x][1];
			if(y==-1) break;
			cdfs(x,true);
			while(!path.empty()&&path.top().second<=L[x]) path.pop();
			if(!path.empty()) MAP[mp(x,y)]=path.top().first;
			else  MAP[mp(x,y)]=-1;
			x=y;
		}
		REP(c,Q)
		{
			s(a);
			x=ed[a].X,y=ed[a].Y;
			if(MAP.find(mp(x,y))!=MAP.end())
			{
				if(MAP[mp(x,y)]==-1)
					printf("no route for corrupt ministers!!!\n");
				else 
					printf("%d\n",MAP[mp(x,y)]);
			}
			else if(MAP.find(mp(y,x))!=MAP.end())
			{
				if(MAP[mp(y,x)]==-1)
					printf("no route for corrupt ministers!!!\n");
				else 
					printf("%d\n",MAP[mp(y,x)]);
			}
			else
			{
				printf("%d\n",D[N-1][0]);
			}
		}
	}
	return 0;
}
