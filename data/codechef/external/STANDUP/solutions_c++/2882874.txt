#include <iostream>
#include <iomanip>
#include <cassert>

using namespace std;

/* optimal strategy

   Since the position does not matter at all, we may assume that we are simply flipping the cards
   from left to right in a linear arrangement.

   Now, the steps are

   - open a card
   - if it matches one of the known cards, open that card as "other card"
   - otherwise, open a new card again
   - if the new card matches an open card, then we should make another move and eliminate this pair!
 */

double A[2560][2560];
double fun(int total, int opened, int off) {
	// cout << string(off*4, ' ') << total << " " << opened << endl;
	assert(total % 2 == 0);
	assert(opened + opened <= total);
	assert(total >= 0);
	assert(opened >= 0);

	if (A[total][opened] > -1e-9) {
		return A[total][opened];
	}
	if (total == 0) {
		return A[total][opened] = 0;
	}

	double &res = A[total][opened];
	res = 0;
	// opening a new card.
	// probability that card opened matches an existing card.
	double p = (double)opened / (total - opened);
	if (p > 1e-9) {
		res = p * (fun(total - 2, opened - 1, off+1) + 1.0);
	}
	// probabiliy that the card opened does not match an existing card.
	p = 1.0 - p;
	if (p > 1e-9) {
		opened++;
		// probability that the new card opened matches the last card we opened! dumb luck!
		double t = 1.0 / (total - opened);
		res += p * t * (fun(total - 2, opened - 1, off+1) + 1.0);
		if (p > 1e-9) {
			// probability that the new card opened matches an existing card.
			double q = (double)(opened - 1) / (total - opened);
			res += p * q * (fun(total - 2, opened - 1, off+1) + 2.0);
			// probablity that nothing got picked up
			p = p * (1.0 - q - t);
			if (p > 1e-9) {
				res += p * (fun(total, opened + 1, off+1) + 1.0);
			}
		}
	}
	return res;
}

int main() {
	for(int i=0;i<=2500;i++) for(int j=0;j<2500;j++) A[i][j] = -1.0;
	int te = 0;
	int m, n;
	while(cin >> m >> n) {
		assert(m > 0 && m <= 50);
		assert(n > 0 && n <= 50);
		int t = m * n;
		assert(t % 2 == 0);
		cout << fixed << setprecision(4) << fun(t,0,0) << endl;
		te++;
	}
	assert(te <= 100);
	return 0;
}