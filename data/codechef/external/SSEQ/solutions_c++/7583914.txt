#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define pb push_back
#define pob pop_back
#define pf push_front
#define pof pop_front
#define mp make_pair
#define all(a) a.begin(),a.end()
#define bitcnt(x) __builtin_popcountll(x)
#define MOD 1000000009
#define MAXN 100005
#define pi 3.14159
#define D 1009
typedef unsigned long long int uint64;
typedef long long int int64;
 

struct node{
	int lval,rval,c_diff;
	bool is_AP;
	node(){
		is_AP=true;
		lval=-MOD;
		rval=-MOD;
		c_diff=-MOD;
	}
	void merge(node &a,node &b){
		
		if((a.c_diff==-MOD)&&(b.c_diff==-MOD)){
			is_AP=true;
			if((a.lval!=-MOD)&&(b.rval!=-MOD)){
			lval=a.lval;
			rval=b.rval;
			c_diff=b.lval-a.rval;
			return;
			}
		
			if(a.lval==-MOD){
				lval=b.lval;
				rval=b.rval;
				c_diff=b.c_diff;
				return;
			}	
		
			if(b.lval==-MOD){
				lval=a.lval;
				rval=a.rval;
				c_diff=a.c_diff;
			}
		
			return;
		}
		
		if(a.c_diff==-MOD){
			
			if(a.lval!=-MOD){
			is_AP=(b.is_AP&a.is_AP)&&(b.lval-a.rval==b.c_diff);;
			lval=a.lval;
			rval=b.rval;
			c_diff=b.lval-a.rval;
			}
			else{
				is_AP=b.is_AP;
				lval=b.lval;
				rval=b.rval;
				c_diff=b.c_diff;
			}
			return;
		}
		
		if(b.c_diff==-MOD){
			
			if(b.lval!=-MOD){
			is_AP=(a.is_AP&b.is_AP)&&(b.lval-a.rval==a.c_diff);
			lval=a.lval;
			rval=b.rval;
			c_diff=b.lval-a.rval;
			}
			
			else{
				is_AP=a.is_AP;
				lval=a.lval;
				rval=a.rval;
				c_diff=a.c_diff;
			}
			
			return;
		}
		
		is_AP=((a.is_AP&b.is_AP)&&(a.c_diff==b.c_diff)&&(b.lval-a.rval==a.c_diff));
		lval=a.lval;
		rval=b.rval;
		c_diff=b.lval-a.rval;
	}
};
node tree[4*MAXN];

void mergeup(int pos){
	pos/=2;
	while(pos){
		tree[pos].merge(tree[2*pos],tree[2*pos+1]);
		pos/=2;
	}
}

node query(int root,int lft,int rht,int u,int v){
	if((u<=lft)&&(v>=rht))
	return tree[root];
	int mid=(lft+rht)/2;
	node l,r,n;
	if(u<mid)
	l=query(2*root,lft,mid,u,v);
	if(v>mid)
	r=query(2*root+1,mid,rht,u,v);
	n.merge(l,r);
	return n;
}

int main(){
	int n,i;
	cin>>n;
	int h=ceil(log2(n));
	h=(1<<h);
	
	for(i=0;i<n;i++){
		cin>>tree[i+h].lval;
		tree[i+h].rval=tree[i+h].lval;
	}
	for(i=h-1;i>0;i--)
	tree[i].merge(tree[2*i],tree[2*i+1]);
	int q,l,r,ch;
	cin>>q;
	while(q--){
		
	//	for(i=1;i<n+h;i++){
	//		cout<<" index "<<i<<" lft val "<<tree[i].lval<<" rht val "<<tree[i].rval<<" c_diff "<<tree[i].c_diff<<" is_ap "<<tree[i].is_AP<<endl;
	//	}
		
		cin>>ch;
		if(ch==1){
			cin>>l>>r;
			l--;
			node x=query(1,h,2*h,l+h,r+h);
			cout<<x.is_AP<<endl;
		}
		else{
			cin>>l>>r;
			l--;
			tree[l+h].lval=tree[l+h].rval=r;
			mergeup((l+h));
		}
	}
	return 0;
}