#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000000007
void build(ll node,ll a,ll b,vector<ll>& v,vector<ll>& tree)
{
	if(a>b)
		return;
	if(a==b)
	{
		tree[node]=v[a];
		return;
	}
	build(node*2,a,(a+b)/2,v,tree);
	build(node*2+1,(a+b)/2+1,b,v,tree);
	tree[node]=((ll)tree[node*2]+(ll)tree[node*2+1]);
}
void update(ll node,ll a,ll b,ll i,ll j,ll val,vector<ll>& mul,vector<ll>& add,ll type,vector<ll>& tree)
{
	if((mul[node]!=1)||(add[node]!=0))
	{
		tree[node]=((ll)tree[node]*mul[node]);
		tree[node]=((ll)tree[node]+((ll)(b-a+1)*(add[node])));
		if(a!=b)
		{
			mul[2*node]=((ll)mul[2*node]*mul[node]);
			mul[2*node+1]=((ll)mul[2*node+1]*mul[node]);
			add[node*2]=((ll)mul[node]*add[node*2]);
			add[node*2+1]=((ll)mul[node]*add[node*2+1]);
			add[node*2]=((ll)add[node*2]+add[node]);
			add[node*2+1]=((ll)add[node*2+1]+add[node]);
		}
		mul[node]=1;
		add[node]=0;
	}
	if((a>b)||(i>b)||(a>j))
		return;
	if((a>=i)&&(b<=j))
	{
		if(type==1)
		{
			tree[node]=((ll)tree[node]+((ll)(b-a+1)*val));
		}
		else
			tree[node]=((ll)tree[node]*val);
		if(a!=b)
		{
			if(type==1)
			{
				add[node*2]=((ll)add[node*2]+val);
					add[node*2+1]=((ll)add[node*2+1]+val);
			}
			else
			{
				add[node*2]=((ll)add[node*2]*val);
				add[node*2+1]=((ll)add[node*2+1]*val);
				mul[node*2]=((ll)mul[node*2]*val);
					mul[node*2+1]=((ll)mul[node*2+1]*val);
			}
		}
		return;
		
	}
	update(node*2,a,(a+b)/2,i,j,val,mul,add,type,tree);
	update(node*2+1,(a+b)/2+1,b,i,j,val,mul,add,type,tree);	
	tree[node]=((ll)tree[node*2]+tree[node*2+1]);
}
ll query(ll node,ll a,ll b,ll i,ll j,vector<ll>& mul,vector<ll>& add,vector<ll>& tree)
{
	if((mul[node]!=1)||(add[node]!=0))
	{
		tree[node]=((ll)tree[node]*mul[node]);
		tree[node]=((ll)tree[node]+((ll)(b-a+1)*(add[node])));
		if(a!=b)
		{
			mul[2*node]=((ll)mul[2*node]*mul[node]);
			mul[2*node+1]=((ll)mul[2*node+1]*mul[node]);
			add[node*2]=((ll)mul[node]*add[node*2]);
			add[node*2+1]=((ll)mul[node]*add[node*2+1]);
			add[node*2]=((ll)add[node*2]+add[node]);
			add[node*2+1]=((ll)add[node*2+1]+add[node]);
		}
		mul[node]=1;
		add[node]=0;
	}
	if((a>b)||(i>b)||(a>j))
		return 0;
	if((a>=i)&&(b<=j))
		return tree[node];
	ll q1=query(node*2,a,(a+b)/2,i,j,mul,add,tree);
	ll q2=query(node*2+1,(a+b)/2+1,b,i,j,mul,add,tree);
	ll res=((ll)q1+q2);
	return res;
}
int main()
{
	ll i,n,q,x,y,val,op,ft,lt;
	double d,cal,ans;
	scanf("%lld",&n);
	vector<ll> v(n),tree(4*n),mul(4*n,1),add(4*n);
	for(i=0;i<n;i++)
		scanf("%lld",&(v[i]));
		scanf("%lld",&q);
	build(1,0,n-1,v,tree);
	while(q--)
	{
		scanf("%lld",&op);
		if(op==1)
		{
			scanf("%lld%lld",&x,&y);
			x--;
			y--;
			ft=query(1,0,n-1,x,x,mul,add,tree);
			lt=query(1,0,n-1,y,y,mul,add,tree);
			if(x!=y)
			{
				d=((double)(lt)-(double)(ft))/(y-x);
				cal=2*ft+(y-x)*d;
				cal=((y-x+1)*cal)/2;
				ans=(double)query(1,0,n-1,x,y,mul,add,tree);
				if(ans==cal)
					printf("1\n");
				else
					printf("0\n");
			}
			else
				printf("1\n");
		}
		
		else
		{
			scanf("%lld%lld",&x,&y);
			x--;
			update(1,0,n-1,x,x,0,mul,add,2,tree);
			update(1,0,n-1,x,x,y,mul,add,1,tree);
		}
		
	}
	return 0;
}