/*
-----------------------------------------------------------------------------
Author :            ---------------------------------------------------------
    UTKAR$H $AXENA  ---------------------------------------------------------
    IIT INDORE      ---------------------------------------------------------
-----------------------------------------------------------------------------
*/
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
#define fre 	freopen("0.in","r",stdin),freopen("0.out","w",stdout)
#define abs(x) ((x)>0?(x):-(x))
#define MOD 1000000007
#define lld signed long long int
#define pp pop_back()
#define ps(x) push_back(x)
#define mpa make_pair
#define pii pair<int,int>
#define fi first
#define se second
#define scan(x) scanf("%d",&x)
#define print(x) printf("%d\n",x)
#define scanll(x) scanf("%lld",&x)
#define printll(x) printf("%lld\n",x)
#define boost ios_base::sync_with_stdio(0)
vector<int> g[2*100000+5];
vector<int> w[2*100000+5];
int par[100000+5],P[100000+5][18],jump[100000+5][18],L[100000+5];
int N;
pair<int,pii >E[100000+5];
void dfs(int v,int lev)
{
	L[v]=lev;
	for(int i=0;i<g[v].size();++i)
	{
		int u=g[v][i];
		if(par[v]==u)continue;
		par[u]=v;
		jump[u][0] = w[v][i];
		dfs(u,lev+1);
	}
}
void create()
  {
	int i, j;

	for (i = 1; i<=N; i++)
		for (j = 1; (1<<j) <=N; j++)
		  P[i][j] = -1,
		  jump[i][j] = MOD;

	for (i=1; i<=N; i++)
		P[i][0] = par[i];

	for (j = 1; (1<<j) <=N; j++)
	{
		for (i = 1; i <=N; i++)
		{
			if (P[i][j - 1] != -1)
				P[i][j] = P[P[i][j - 1]][j - 1],
				jump[i][j] = min(jump[i][j-1] ,jump[P[i][j-1]][j-1]);
			//cout<<i<<' '<<j<<' '<<jump[i][j]<<endl;
		}
	}
}
int lca(int p, int q)
{
	int tmp, log, i;

	if (L[p] < L[q])
	  tmp = p, p = q, q = tmp;

	for (log = 1; 1 << log <= L[p]; log++);
	log--;

	for (i = log; i >= 0; i--)
		if ( L[p] - (1<<i) >= L[q] )
			p = P[p][i];
	if (p == q)
		return p;

	for (i = log; i >= 0; i--)
		if (P[p][i] != -1 && P[p][i] != P[q][i])
			p = P[p][i], q = P[q][i];

	return par[p];
}
int tell(int A,int v)
{
	int up = -L[A] + L[v];

	int J = 262144;
	int p = 18;
	int ans =MOD;
	//cout<<A<<' '<<v<<endl;
	while(J>0)
	{
		//cout<<v<<' '<<p<<' '<<J<<endl;
		if(up>=J)
		{
			ans = min(ans,jump[v][p]);
			v = P[v][p];
			up -= J;
		}
		--p;
		J /= 2;
	}
	//cout<<ans<<endl;
	return ans;
}
int path(int u,int v)
{
	int l = lca(u,v);
	return min(tell(l,u),tell(l,v));
}
struct dsu
{
	int n,dad[100000+5],rnk[100000+5];
	void init(int nn)
	{
		n = nn;
		for (int i = 1; i <=n; i++)
		{
			rnk[i] = 0;
			dad[i] = i;
		}
	}
	int root(int v)
	{
		if (v == dad[v]) return v;
		return dad[v] = root(dad[v]);
	}
	void join(int v1, int v2)
	{
		v1 = root(v1), v2 = root(v2);
		if (v1 == v2) return;
		if (rnk[v1] < rnk[v2]) swap(v1, v2);
		dad[v2] = v1;
		if (rnk[v1] == rnk[v2]) rnk[v1]++;
	}
}DSU;
vector<pair<int,pii > >V;
int main()
{
	//fre;
	int M,a,b;
	cin>>N>>M;
	DSU.init(N);
	for(int i=1;i<=M;++i)
	{
		scan(a);scan(b);
		E[i].se.fi=a+1;
		E[i].se.se=b+1;
		scan(E[i].fi);
	}
	sort(E+1,E+M+1);
	for(int i=1;i<=M;++i)
	{
		if(DSU.root(E[i].se.fi) == DSU.root(E[i].se.se))
		{
			V.ps(E[i]);
		}
		else
		{
			g[E[i].se.fi].ps(E[i].se.se);
			g[E[i].se.se].ps(E[i].se.fi);

			w[E[i].se.fi].ps(E[i].fi);
			w[E[i].se.se].ps(E[i].fi);
			DSU.join(E[i].se.fi,E[i].se.se);
			//cout<<E[i].se.fi<<' '<<E[i].se.se<<'\t'<<E[i].first<<endl;
		}
	}
	dfs(1,0);
	create();
	//cout<<path(2,4)<<endl;
	for(int i=0;i<V.size();++i)
	{
		if(path(V[i].se.se,V[i].se.fi)==V[i].fi)
		{
			cout<<"NO";
			return 0;
		}
	}
	cout<<"YES";
}
