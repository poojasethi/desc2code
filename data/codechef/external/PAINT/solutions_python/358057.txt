#include <iostream>
#include <iosfwd>
#include <iomanip>

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cctype>

#include <vector>
#include <bitset>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <deque>
#include <string>
#include <list>
#include <iterator>
#include <sstream>
#include <complex>

#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>

using namespace std;

#define BUG(x) if (DEBUG) cout << __LINE__ << ": " << #x << " = " << x << endl
#define LET(x, a) __typeof(a) x = a
#define FOR(i, a, b) for (LET(i, (a)); i < (b); ++i)
#define RFOR(i, a, b) for (LET(i, (a)); i >= (b); --i)
#define REP(i, N) FOR (i, 0, N)
#define RREP(i, N) RFOR (i, N, 0)
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define CLEAR(x) memset( (x), 0, sizeof((x)))
#define FILL(x, v) memset((x), (v), sizeof((x)))
#define SORT(x) sort((x).begin(), (x).end())
#define UNIQUE(x) SORT(x), (x).resize(unique((x).begin(), (x).end()) - (x).begin())
#define REVERSE(x) reverse((x).begin(), (x).end())
#define FOREACH(it, v) for(LET(it, (v).begin()); it != (v).end(); ++it)
#define PRESENT(x, v) (find(ALL((x)), (v)) != (x).end())
#define CPRESENT(x, v) ((x).find((v)) != (x).end())
#define PB(x) push_back((x))
#define SIZE(x) ((int) (x).size())
#define MP(x, y) make_pair((x), (y))

typedef vector <int> VI; typedef vector <string> VS; typedef vector <double> VD;
typedef vector <VI> VVI; typedef vector <VS> VVS; typedef stringstream SS;
typedef pair <int, int> PII; typedef long long LL; typedef unsigned long long ULL;
typedef vector <PII> VPII; typedef vector <LL> VLL; typedef vector <bool> VB;
typedef vector <VLL> VVLL; typedef vector <VD> VVD; typedef vector <VB> VVB;

template <class T> inline int size(const T& c) { return (int) c.size(); }
VI tokenInt(string& s) {stringstream sin(s); VI v; int x; while (sin >> x) v.PB(x); return v;}
VS tokenStr(string& s) {stringstream sin(s); VS v; string x; while (sin >> x) v.PB(x); return v;}
int rInt() {int nT = -1; scanf("%d", &nT); return nT;}
string rStr() {char nStr[1 << 10] = ""; scanf("%s", nStr); return nStr;}
LL rLL() {LL nT = -1; scanf("%lld", &nT); return nT;}
char rChar() {char c = -1; scanf("%c", &c); return c;}
VI stov(string& s) {VI v; REP(i, size(s)) v.PB(s[i] - '0'); REVERSE(v); return v;}
LL stol(string& s) {LL r = 0; REP(i, size(s)) r = r * 10LL + (s[i] - '0'); return r;}
int stoi(string& s) {int r = 0; REP(i, size(s)) r = r * 10 + (s[i] - '0'); return r;}
string ltos(LL x) {string s; do {s.PB(x % 10 + '0'); x /= 10;} while (x); REVERSE(s); return s;}
VI ltov(LL x) {VI v; do {v.PB(x % 10); x /= 10;} while (x); return v;}
string itos(int x) {string s; do {s.PB(x % 10 + '0');x /= 10;} while (x); REVERSE(s); return s;}
VI itov(int x) {VI v; do {v.PB(x % 10);x /= 10;} while (x); return v;}
string vtos(VI& v) {string s; int l = size(v); REP(i, l) s.PB(v[l-i-1] + '0'); return s;}
LL vtol(VI& v) {LL r = 0; int l = size(v); REP(i, l) r = r * 10LL + v[l-i-1]; return r;}
int vtoi(VI& v) {int r = 0, l = size(v); REP(i, l) r = r * 10 + v[l-i-1]; return r;}
inline LL two(int x) {return (1LL << (x));}
template <class T> ostream& operator <<(ostream &O, vector <T> &v) {O << '{';
int x = size(v)-1; REP(i,x) O << v[i] << ", "; if (x >= 0) O << v[x]; return O << '}';}
VS split(string s,string del) {s += del[0]; string temp; VS ret; REP(i,size(s))
if(del.find(s[i]) == string::npos) temp.PB(s[i]); else{ret.PB(temp);temp = "";} return ret;}

const bool DEBUG = true;
const double EPS = 1e-8;
const int INF  = 100000000;
const LL INFLL = 1000000000000000000LL;

class Solver
{
	int maxArea;
	vector <int> parent;
	vector <int> area;
	int m, n;
	void preProcess()
	{
		parent.resize(m * n, 0);
		for (int i = 0; i < m; ++i)
			for (int j = 0; j < n; ++j)
				parent[c(i, j)] = c(i, j);
		area.resize(m * n, 0);
		for (int i = 0; i < m; ++i)
			for (int j = 0; j < n; ++j)
				area[c(i, j)] = 0;
	}
	int c(int x, int y)
	{
		return x * n + y;
	}
	bool isValid(int x, int y)
	{
		return x >= 0 && y >= 0 && x < m && y < n;
	}
	int find(int rank)
	{
		if (parent[rank] == rank)
			return rank;
		else
			return parent[rank] = find(parent[rank]);
	}
	void merge(int u, int v)
	{
		parent[u] = v;
		area[v] += area[u];
		maxArea = max(area[v], maxArea);
	}
	void display(vector <int>& area)
	{
		for (int i = 0; i < m; ++i, cout << endl)
			for (int j = 0; j < n; ++j)
				cout << area[c(i, j)];
		cout << endl;
	}
	public: void solve(vector <bool>& plane, int queries, int _m, int _n)
	{
		m = _m; n = _n;
		maxArea = 0;
		preProcess();
		int dx[] = {0, 1, 0, -1};
		int dy[] = {1, 0, -1, 0};
		for (int i = 0; i < queries; ++i) {
			int query = rInt();
			if (query == 1) {
				int x = rInt() - 1, y = rInt() - 1;
				if (area[c(x, y)] == 0) {
					plane[c(x, y)] = true;
					area[c(x, y)] = 1;
					for (int j = 0; j < 4; ++j) {
						int u = x + dx[j], v = y + dy[j];
						if (isValid(u, v)) {
							int px = find(c(u, v));
							int py = find(c(x, y));
							if (px != py && area[px] != 0) {
								merge(px, py);
							}
						}
				}
				maxArea = max(maxArea, area[find(c(x, y))]);
				}
			}
			else {
				printf("%d\n", maxArea);
			}
		}
	}
};

int main()
{
	const bool contest = false;
	if (contest == true) {
		freopen("input.txt", "r", stdin);
		freopen("output.txt", "w", stdout);
	}
	int nTest = 1;
	for (int test = 1; test <= nTest; ++test) {
		int m = rInt(), n = rInt();
		vector <bool> plane(m * n, false);
		int queries = rInt();
		Solver solver;
		solver.solve(plane, queries, m, n);
	}
	return 0;
}

// Powered by PhoenixAI
