#include <bits/stdc++.h>
using namespace std; 
#define rep(i,n)        for(int i = 0;  i < n ; ++i)
#define REP(i,a,b)      for(int i = a ; i <= b; ++i)
#define pii             pair<int,int> 
#define pb(a)           push_back(a)
#define ll              long long
#define MOD             1000000007
#define pil             pair<int,long long>
#define mp              make_pair
#define CLR(x,a)        memset(x,a,sizeof(x))
#define pll             pair<ll,ll>
using namespace std;
const int MAXN = 203; 
const int INF = 1000000; 
 
struct Edge
{
int u,v,flow,capacity;
Edge()
{
 
}
Edge(int u,int v,int flow,int capacity)
{
this->u=u;
this->v=v;
this->flow=flow;
this->capacity=capacity;
 
}
};
 
vector<Edge> e;
vector<vector<int> > G;
int n,m;
int source=0,sink=202;
int dist[5001];
int ptr[5001];
 
 
bool findPath()
{
 
memset(dist,-1,sizeof(dist));
dist[source]=0;
queue<int> Q;
Q.push(source);
while(!Q.empty())
{
int u=Q.front();
assert(dist[u]>=0);
// cout<<u<<endl;
Q.pop();
 
for (int i = 0; i < G[u].size(); ++i)
{
int ID=G[u][i];
// assert(u==e[ID].u);
int v=e[ID].v;
 
if( (dist[v]==-1) && e[ID].flow<e[ID].capacity)
{
// cout<<v<<endl;
dist[v]=dist[u]+1;
// cout<<dist[v]<<endl;
Q.push(v);
// if(v==sink)
// return true;
}
}
}
 
return dist[sink]!=-1;
}
 
 
int dfs(int u,int flow)
{
if(flow==0)
return 0;
if(u==sink)
return flow;
for(;ptr[u]<G[u].size();++ptr[u])
{
int ID=G[u][ptr[u]];
int v=e[ID].v;
if(dist[v]!=dist[u]+1)
continue;
int pushed=dfs(v,min(flow,e[ID].capacity-e[ID].flow));
if(pushed)
{
e[ID].flow +=pushed;
e[ID^1].flow -=pushed;
return pushed;
}
}
return 0;
}
ll dinics()
{
ll flow=0;
while(findPath())
{
memset(ptr,0,sizeof ptr);
while(int pushed=dfs(source,1e9))
flow+=pushed;
}
return flow;
}
void add_edge(int u,int v,int capacity)
{
G[u].push_back(e.size());
e.push_back(Edge(u,v,0,capacity));
G[v].push_back(e.size());
e.push_back(Edge(v,u,0,0));
}
bool done[MAXN] ; 
int main(){
  ios::sync_with_stdio(0);
    int N , T ; 
    cin >> N ;  
    cin >> T ; 
    vector<int> R(T) , C(T) ; 
    source = 0 , sink = N + N + 1 ; 
    G.resize(2*N + 2) ; 


    // for(int i=1;i<=N;++i)
    // {
    //   add_edge(source,i,1);
    //   add_edge(i+N,sink,1);

    // }
    for(int i = 0 ; i < T ; ++i)
    {
        cin >> R[i] >> C[i] ;
    }
    
    for(int i = 0 ; i < T ; ++i)
    {
        
        // if(!done[R[i]])
        // {
        //     add_edge(source,R[i],1) ;
        //     done[R[i]] = true ; 
        // } 
        
        add_edge(R[i],C[i]+N,INF) ;


        // if(!done[C[i]+N])
        // {
        //     add_edge(C[i]+N,sink,1) ; 
        //     done[C[i]+N] = true ; 
        // }
    }

    for(int i=1;i<=N;++i)
    {
      if(!done[i])
        add_edge(source,i,1);
      if(!done[i+N])
        add_edge(i+N,sink,1);
    }
    cout << dinics() << "\n" ; 
    return 0 ;
}  