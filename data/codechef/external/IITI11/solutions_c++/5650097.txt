/* kho kho approach :) of bipartite max matching*/

#include<iostream>
#include<cstdio>
#include<cstring>

#define sd(x) scanf("%d",&x)

using namespace std;



bool graph[101][101];

bool visited[101];

int match[101];          //to know the element of set v is matched with element of set u i.e what it stores



int n;
bool bpt_path(int u)                //return true if there exist a path from U to V where source is u
{

    for(int v=1;v<=n;v++)
    {

        if(graph[u][v]==true&&visited[v]==0)
        {

           visited[v]=1;

           if(match[v]<0||bpt_path(match[v]))           //seen visted[v] is already marked 1 it is sure that u=match[v] will not try
           {
               match[v]=u;                                 //to find  v again in path form U TO V in biparted graph
                return true;
           }

        }


    }
    return false;
}




int main()
{

    int i,j,res,t;
    sd(n);
    sd(t);

    memset(match,-1,sizeof(match));
    while(t--)
    {
        sd(i);
        sd(j);
        graph[i][j]=1;
    }

        res=0;
        for(i=1;i<=n;i++)
        {

            memset(visited,0,sizeof(visited));
            if(bpt_path(i))
            {

                res++;
            }
        }

    cout<<res;
    return 0;
}
