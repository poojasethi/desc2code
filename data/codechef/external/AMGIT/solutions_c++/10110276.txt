#include <bits/stdc++.h>
using namespace std;

#define inf (1<<30)-1
#define INF (1LL<<62)-1
#define MOD 1000000007LL
#define MP make_pair
#define PB push_back
#define ALL(x) x.begin(),x.end()
#define PI acos(-1)
#define MEM(x,y) memset(x,y,sizeof (x))
#define debug cout<<"A"<<'\n'
#define REP(i,a,b) for (int i=(a); i<=(b); i++)
#define PER(i,a,b) for (int i=(a); i>=(b); i--)
#define REPL(i,a,b) for (LL i=(a); i<=(b); i++)
#define PERL(i,a,b) for (LL i=(a); i>=(b); i--)
#define print(x) cout<<x<<'\n'
#define dprint(a,x) cout<<setprecision(x)<<fixed<<a<<'\n'
#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)
typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef pair<int,int>PII;
typedef pair<LL,LL>PLL;
typedef set<int> SI;
typedef set<LL> SL;
typedef set<string> SS;
typedef vector<int> VI;
typedef vector<LL> VL;
typedef vector<string> VS;
typedef map<int,int> MII;
typedef map<LL,LL> MLL;
typedef queue<int> QI;

/* Direction Array */

// int fx[]={1,-1,0,0};
// int fy[]={0,0,1,-1};
// int fx[]={0,0,1,-1,-1,1,-1,1};
// int fy[]={-1,1,0,0,1,1,-1,-1};

template <class T> inline T bigmod(T p,T e,T M)
{
    T ret = 1;
    for(; e > 0; e >>= 1)
    {
        if(e & 1) ret = (ret * p) % M;
        p = (p * p) % M;
    } return (T)ret;
}

template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}
template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}
template <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}
template <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}
template <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }
template <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}

inline LL power(LL a, LL b)
{
	LL multiply=1;
	REP(i,1,b)
	{
		multiply*=a;
	}
	return multiply;
}
inline LL ABS(LL a){return (a>=0)?a:-a;}

/*end of header*/
string dir,s,com;
vector<string> vs;
map<LL,vector<string> >childword;
VL graph[10001];
map<LL,LL>color;
LL isblack[10001],iswhite[10001],visited[10001];
LL dp[10001][2];
void dfs(LL u)
{
    visited[u]=1;
    if(color.find(u)==color.end() && graph[u].empty())
        return;
    if(graph[u].empty())
    {
        if(color[u]==0)iswhite[u]=1;
        else isblack[u]=1;
        return;
    }
    LL b=1,w=1;
    REP(i,0,graph[u].size()-1)
    {
        if(!visited[graph[u][i]])dfs(graph[u][i]);
        if(isblack[graph[u][i]]==0)b=0;
        if(iswhite[graph[u][i]]==0)w=0;
    }
    isblack[u]=b;
    iswhite[u]=w;
    return;
}
LL call(LL node,LL col)
{
    if(dp[node][col]!=-1)return dp[node][col];
    /*if(iswhite[node]==1)
    {
        if(col==0)return dp[node][col]=1;
        else return dp[node][col]=0;
    }
    if(isblack[node]==1)
    {
        if(col==1)return dp[node][col]=1;
        else return dp[node][col]=0;
    }*/
    if(graph[node].empty())
    {
        if(col==0)return dp[node][col]=color[node]^1;
        else return dp[node][col]=color[node];
    }
    LL ret1=0,ret2=1;
    REP(i,0,graph[node].size()-1)
    {
        ret1+=call(graph[node][i],col);
        ret2+=call(graph[node][i],col^1);
    }
    return dp[node][col]=min(ret1,ret2);
}
int main()
{
    //freopen("input_file_name.in","r",stdin);
    //freopen("output_file_name.out","w",stdout);
    LL t,n,cur,flag,num;
    cin>>t;
    while(t--)
    {
        cin>>n;
        color.clear();
        num=1;
        REP(i,1,10000){childword[i].clear();graph[i].clear();}
        while(n--)
        {
            cin>>com;
            getline(cin,dir);
            vs.clear();
            s.clear();
            LL pos=0;
            while(dir[pos]<'a'||dir[pos]>'z')pos++;
            REP(i,pos,dir.size()-1)
            {
                if(dir[i]=='/')
                {
                    vs.PB(s);
                    s.clear();
                }
                else s.PB(dir[i]);
            }
            vs.PB(s);
            s.clear();
            cur=1;

            REP(i,0,vs.size()-1)
            {
                flag=0;
                if(!childword[cur].empty())
                {
                    REP(j,0,childword[cur].size()-1)
                    {
                        if(childword[cur][j]==vs[i])
                        {
                            cur=graph[cur][j];
                            flag=1;
                            break;
                        }
                    }
                }
                if(flag==1)continue;
                childword[cur].PB(vs[i]);
                graph[cur].PB(++num);
                cur=num;
            }
            if(com=="stage")color[cur]=0;
            else color[cur]=1;

        }
        MEM(isblack,0);
        MEM(iswhite,0);
        MEM(visited,0);
        dfs(1);
        MEM(dp,-1);
        print(call(1,0));
    }
    return 0;
}


