import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;


class ShortestPath {

	static int MB = 1 << 20;
	static BufferedReader br = new BufferedReader( new InputStreamReader(System.in, StandardCharsets.US_ASCII), 50*MB );
	static StringTokenizer st;
	
	static void NL() throws Exception {
		st = new StringTokenizer(br.readLine());
	}
	
	static String NT() {
		return st.nextToken();
	}
	
	public static void main(String[] args) throws Exception {
		NL();
		int T = Integer.parseInt(NT());
		while ( T--> 0 ) {
			NL();
			int n = Integer.parseInt(NT());
			int m = Integer.parseInt(NT());
			int q = Integer.parseInt(NT());
			
			int[] f = new int[m];
			int[] t = new int[m];
			int[] w = new int[m];
			for (int i = 0; i < m; i++) {
				NL();
				f[i] = Integer.parseInt(NT());
				t[i] = Integer.parseInt(NT());
				w[i] = Integer.parseInt(NT());
			}

			int[] x = new int[q];
			for (int i = 0; i < q; i++) {
				NL();
				x[i] = Integer.parseInt(NT());
			}
			print(solve(n, m, q, f, t, w, x));
		}
	}

	private static void print(long[] res) {
		StringBuilder sb = new StringBuilder();
		for (long r : res) {
			sb.append(r).append('\n');
		}
		System.out.print(sb);
	}

	static ArrayList<Edge>[] g;
	
	private static long[] solve(int n, int m, int q, int[] f, int[] t, int[] w, int[] x) {
		// create graph
		g = new ArrayList[n + 1]; // 1-based
		for (int i = 0; i < g.length; i++) {
			g[i] = new ArrayList<>();
		}
		// add edges
		for (int i = 0; i < m; i++) {
			g[f[i]].add( new Edge(t[i], w[i]) ); // f -> t
			g[t[i]].add( new Edge(f[i], w[i]) ); // t -> f
		}
		
		long[] st = new long[n+1]; // shortest paths for whole graph
		Arrays.fill(st, -1);
		
		PriorityQueue<Item> pq = new PriorityQueue<>();
		pq.add(new Item(1, 0));
		while (pq.isEmpty() == false) {
			Item act = pq.poll();
			if (st[act.w] == -1) { // not processed yet
				st[act.w] = act.cost;
				
				for (Edge edge : g[act.w]) {
					pq.add(new Item(edge.t, act.cost + edge.w));
				}
			}
		}
		// 
		long[] res = new long[q];
		for (int i = 0; i < q; i++) {
			res[i] = st[x[i]];
		}
		return res;
	}

	static class Edge {
		
		int t, w; // to and weight

		public Edge(int t, int w) {
			this.t = t;
			this.w = w;
		}
		
		@Override
		public String toString() {
			return String.format("[->%d, %d]", t, w);
		}
	}

	static class Item implements Comparable<Item> {
		
		int w; // where we are currently
		long cost;
		
		public Item(int w, long cost) {
			this.w = w;
			this.cost = cost;
		}
		
		@Override
		public int compareTo(Item it) {
			// compare by cost, if same process vertexes by index 
			if ( cost == it.cost ) {
				return Integer.compare(w, it.w);
			}
			return Long.compare(cost, it.cost);
		}
		
		@Override
		public String toString() {
			return String.format("[%d, %d]", w, cost);
		}
	}

}
