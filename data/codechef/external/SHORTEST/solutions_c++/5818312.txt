import java.util.*;
import java.io.*;
class DijkstraAF
{
    static Map<Integer,ArrayList<Edge>> map = new HashMap<Integer,ArrayList<Edge>>();
    public static void main(String[]args)
    {
        InputReader1 sc = new InputReader1(System.in);
        int T=sc.nextInt();
        while(T-->0)
        {
            map.clear();
            int n=sc.nextInt(),m=sc.nextInt(),q=sc.nextInt();
            while(m-->0)
            {
                int a=sc.nextInt(),b=sc.nextInt(),weight=sc.nextInt();
                if(map.containsKey(a))
                {
                    map.get(a).add(new Edge(b,weight));
                }
                else
                {
                    map.put(a,new ArrayList<Edge>());
                    map.get(a).add(new Edge(b,weight));
                }
                if(map.containsKey(b))
                {
                    map.get(b).add(new Edge(a,weight));
                }
                else
                {
                    map.put(b,new ArrayList<Edge>());
                    map.get(b).add(new Edge(a,weight));
                }
            }
           

            long path[]=new long[n+1];
            Arrays.fill(path,-1);
            PriorityQueue<Item> pq = new PriorityQueue<Item>();
            pq.add(new Item(1,0));

            while(!pq.isEmpty())
            {
                Item act= pq.poll();
                int node=act.node;
                if(path[node]==-1)
                {
                    path[node]=act.cost;
                    int t=map.get(node).size();
                    for(int i=0;i<t;i++)
                    {
                        Edge e=map.get(node).get(i);
                        pq.add(new Item(e.node,act.cost+e.weight));
                    }
                }
            }
            for(int i=0;i<q;i++)
            {
                int x=sc.nextInt();
                System.out.println(path[x]);
            }
        }
    }
}
class Edge
{
    int node,weight;
    public  Edge(int node , int weight)
    {
        this.node=node;
        this.weight=weight;
    }
}
class Item implements Comparable<Item> // For Priority Queue
{
    int node; // where we are currently
    long cost;
    public Item(int node, long cost)
    {
        this.node = node;
        this.cost = cost;
    }

    public int compareTo(Item it) 
    {
        // compare by cost, if same process vertexes by index 
        if ( cost == it.cost ) 
            return node-it.node;
        return Long.compare(cost,it.cost);
    }
}
class InputReader1 
{

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader1(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int nextInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c & 15;
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long nextLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c & 15;
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String next() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public String nextLine() {
        int c = read();
        //while (c != '\n' && c != '\r' && c != '\t' && c != -1)
        //c = read();
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (c != '\n' && c != '\r' && c != '\t' && c != -1);
        return res.toString();
    }

    public static boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

}  
