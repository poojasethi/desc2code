
#include<bits/stdc++.h>

using namespace std;

#define si(x) scanf("%d",&x)
#define pri(x) printf("%d",x)
#define sll(x) scanf("%lld",&x)
#define pll(x) printf("%lld",x)
#define sstr(s) scanf("%s",s)
#define pstr(s) printf("%s",s)
#define nl printf("\n")
#define ll long long int
#define pb push_back
#define mp make_pair
#define vi vector<int>

const int mx = 1e5+10;
int n,M[100005][20];
int k[100005];

inline void sparseTable(int a[], int n) {
    //value based
    int LN = log2(n)+1;
    for(int i=0;i<n;i++) {
	M[i][0]=a[i];
    }
    for(int j=1;j<LN;j++) {
	int pos = 1<<j;
	for(int i=0;i+pos-1 <n;i++) {
	    M[i][j] = min(M[i][j-1],M[i+(1<<(j-1))][j-1]);
	}
    }
    //storing floor of log(x) for fast query
    k[2]=1;
    for(int i=3;i<=n;i++) {
	k[i]=k[i-1]+((i&(i-1))==0);
	//   cout<<k[i]<<" ";
    }
}

int rmqa(int x,int y) {
    int len = y-x+1;
    return min(M[x][k[len]],M[y-(1<<k[len])+1][k[len]]);
}

struct suffixArray {
    char *s;
    int n, sa[mx],as[mx],lcp[mx];
    int o[mx],tmp[mx],c[mx];

    suffixArray(char* s):s(s){
	n = strlen(s);
	s[n++] = '$';
    }
    void srt(int k){
	memset(c,0,sizeof c);
	for(int i=0;i<n;i++){
	    c[i+k<n?o[i+k]:0]++;
	}
	int sm = 0;
	int maxi = max(300,n);
	for(int i=0;i<maxi;i++){
	    int v = c[i];
	    c[i] = sm;
	    sm+=v;
	}

	for(int i=0;i<n;i++){
	    int idx = sa[i]+k<n?o[sa[i]+k]:0;
	    tmp[c[idx]++] = sa[i];
	}
	for(int i=0;i<n;i++) 
	    sa[i] = tmp[i];
    }
    void csa(){ 
	for(int i=0;i<n;i++){
	    o[i] = s[i];
	    sa[i] = i;
	}
	for(int k=1;k<n;k<<=1){
	    srt(k);
	    srt(0);
	    tmp[sa[0]] = 0;
	    int idx = 0;
	    for(int i=1;i<n;i++){
		int o1 = 0, o2 = 0; 
		if(sa[i]+k<n) o1 = o[sa[i]+k];
		if(sa[i-1]+k<n) o2 = o[sa[i-1]+k];

		if(o[sa[i]]!=o[sa[i-1]] || o1!=o2){
		    idx++;
		}
		tmp[sa[i]] = idx;
	    }
	    for(int i=0;i<n;i++){
		o[i] = tmp[i];
	    }
	}
    }
    void clcp(){
	for(int i=0;i<n;i++)
	    as[sa[i]] = i;
	int l = 0;
	for(int i=0;i<n;i++){
	    l = max(0,l-1);
	    if(as[i]==0) l = 0;
	    else while(s[i+l]==s[sa[as[i]-1]+l]){
		l++;
	    }
	    tmp[i] = l;
	}
	for(int i=0;i<n;i++)
	    lcp[i] = tmp[sa[i]];
    }
};

ll A_A[50005], B_B[50005], AB[100005];

char a[50005],b[50005],x[100005];

int main()
{
 //   int ad[] = {0,1,3,-1,5,0,11,1123,-99};
   // sparseTable(ad,10);
   // cout<<rmqa(1,3);
    sstr(a); sstr(b);
    int A=strlen(a),B=strlen(b),X;
    strcpy(x,a);
    x[A]='z'+2;
    int i,j;
    for(i=0,j=A+1;i<B;++i,++j) {
	x[j]=b[i];
    }
    X=strlen(x);
    suffixArray aa(a);
    aa.csa();
    aa.clcp();
    suffixArray bb(b);
    bb.csa();
    bb.clcp();
    suffixArray xx(x);
    xx.csa();
    xx.clcp();
    sparseTable(xx.lcp,X);/*
			     for(int i=1;i<=X;++i) {
			     cout<<xx.sa[i]<<" "<<xx.lcp[i]<<" ";
			     for(int j=xx.sa[i];j<X;++j) {
			     cout<<x[j];
			     }
			     nl;
			    // int w;
			  //   si(w);
			     }
			     nl;*/
    ll disA=0,disB=0,disA_B=0;
    for(i=1;i<=A;++i) {
	//	cout<<aa.sa[i]<<endl;
	if(i==1) {
	    disA += A-aa.sa[i];
	    A_A[A-aa.sa[i]]++;
	}
	else {
	    int com = aa.lcp[i];//cout<<"LCP[i] "<<aa.lcp[i]<<endl;
	    disA += (ll)(max(0,A-aa.sa[i]-com));
	    if(A-aa.sa[i]-com >= 0) {
		A_A[A-aa.sa[i]]++;
		if(com>=0) {
		    A_A[com]--;
		}
	    }
	}/*
	    for(int j=1;j<=A;++j) {
	    cout<<A_A[j]<<" ";
	    }
	    nl;*/
    }
    for(i=1;i<=B;++i) {
	if(i==1) {
	    disB += bb.sa[i];
	    B_B[B-bb.sa[i]]++;
	}
	else {
	    int com = bb.lcp[i];
	    disB += (ll)(max(0,B-bb.sa[i]-com));
	    if(B-bb.sa[i]-com>=0) {
		B_B[B-bb.sa[i]]++;
		if(com>=0)
		    B_B[com]--;
	    }
	}
    }
    AB[A]=0;
    int st;
    bool flg = false;
    for(i=2;i<=X;++i) {
	if(xx.sa[i]==A) continue;
	int com = xx.lcp[i];
	if((xx.sa[i-1]>A && xx.sa[i]<A) || (xx.sa[i-1]<A && xx.sa[i]>A)) {
	    disA_B = disA_B + xx.lcp[i];
	    if(xx.lcp[i]>=0) {
		AB[xx.lcp[i]]++;
		if(flg == false) {
		    flg = true;
		    st = i;
		}
		else {
		    int temp = rmqa(st,i);
		    //if(temp==0) {
			st = i;
		    //}
//		    cout<<xx.sa[i]<<" "<<temp<<endl;
	//	    return 0;
		    AB[temp]--;
		}
		//		if(SA3[i]>0)
		//		AB[SA3[i]-1]--;
	    }
	}/*
	cout<<xx.sa[i]<<endl;
	for(int j=1;j<=X;++j) {
	    cout<<AB[i]<<" ";
	}
	cout<<disA_B<<endl;
	int w;
	si(w);*/
    }
    for(i=A-1;i>=0;--i) {
	A_A[i] += A_A[i+1];
    }
    for(i=B-1;i>=0;--i) {
	B_B[i] += B_B[i+1];
    }
    for(i=X-1;i>=0;--i) {
	AB[i] += AB[i+1];
    }/*
	cout<<disA<<endl;
	for(int i=1;i<=A;++i) {
	cout<<i<<" "<<A_A[i]<<endl;
	}*//*
	      cout<<disB<<endl;
	      for(int i=1;i<=B;++i) {
	      cout<<i<<" "<<B_B[i]<<endl;
	      }*//*
		    cout<<disA_B<<endl;
		    for(int i=1;i<=X;++i) {
		    cout<<i<<" "<<AB[i]<<"\n";
		    }*/
    int q;
    si(q);
    while(q--) {
	ll x,k,ans;
	sll(x); sll(k);
	if(x==1) {
	    ans = AB[k];
	}
	else if(x==2) {
	    ans = A_A[k] - AB[k];
	}
	else if(x==3) {
	    ans = B_B[k] - AB[k];
	}
	else {
	    ans = A_A[k] - AB[k] + B_B[k] - AB[k];
	}
	pll(ans); nl;
    }
    return 0;
}
