
#include<bits/stdc++.h>

using namespace std;

#define si(x) scanf("%d",&x)
#define pri(x) printf("%d",x)
#define sll(x) scanf("%lld",&x)
#define pll(x) printf("%lld",x)
#define sstr(s) scanf("%s",s)
#define pstr(s) printf("%s",s)
#define nl printf("\n")
#define ll long long int
#define pb push_back
#define mp make_pair
#define vi vector<int>

const int mx = 1e5+10;
int n,M[100005][20];
int k[100005];

inline void sparseTable(int a[], int n) {
    int LN = log2(n)+1;
    for(int i=0;i<n;i++) {
	M[i][0]=a[i];
    }
    for(int j=1;j<LN;j++) {
	int pos = 1<<j;
	for(int i=0;i+pos-1 <n;i++) {
	    M[i][j] = min(M[i][j-1],M[i+(1<<(j-1))][j-1]);
	}
    }
    k[2]=1;
    for(int i=3;i<=n;i++) {
	k[i]=k[i-1]+((i&(i-1))==0);
    }
}

int rmqa(int x,int y) {
    int len = y-x+1;
    return min(M[x][k[len]],M[y-(1<<k[len])+1][k[len]]);
}

// Ref : Alei Reyes
struct suffixArray {
    char *s;
    int n, sa[mx],as[mx],lcp[mx];
    int o[mx],tmp[mx],c[mx];

    suffixArray(char* s):s(s){
	n = strlen(s);
	s[n++] = '$';
    }
    void srt(int k){
	memset(c,0,sizeof c);
	for(int i=0;i<n;i++){
	    c[i+k<n?o[i+k]:0]++;
	}
	int sm = 0;
	int maxi = max(300,n);
	for(int i=0;i<maxi;i++){
	    int v = c[i];
	    c[i] = sm;
	    sm+=v;
	}

	for(int i=0;i<n;i++){
	    int idx = sa[i]+k<n?o[sa[i]+k]:0;
	    tmp[c[idx]++] = sa[i];
	}
	for(int i=0;i<n;i++) 
	    sa[i] = tmp[i];
    }
    void csa(){ 
	for(int i=0;i<n;i++){
	    o[i] = s[i];
	    sa[i] = i;
	}
	for(int k=1;k<n;k<<=1){
	    srt(k);
	    srt(0);
	    tmp[sa[0]] = 0;
	    int idx = 0;
	    for(int i=1;i<n;i++){
		int o1 = 0, o2 = 0; 
		if(sa[i]+k<n) o1 = o[sa[i]+k];
		if(sa[i-1]+k<n) o2 = o[sa[i-1]+k];

		if(o[sa[i]]!=o[sa[i-1]] || o1!=o2){
		    idx++;
		}
		tmp[sa[i]] = idx;
	    }
	    for(int i=0;i<n;i++){
		o[i] = tmp[i];
	    }
	}
    }
    void clcp(){
	for(int i=0;i<n;i++)
	    as[sa[i]] = i;
	int l = 0;
	for(int i=0;i<n;i++){
	    l = max(0,l-1);
	    if(as[i]==0) l = 0;
	    else while(s[i+l]==s[sa[as[i]-1]+l]){
		l++;
	    }
	    tmp[i] = l;
	}
	for(int i=0;i<n;i++)
	    lcp[i] = tmp[sa[i]];
    }
};

ll A_A[50005], B_B[50005], AB[100005];

char a[50005],b[50005],x[100005];

int main()
{
    sstr(a); sstr(b);
    int A=strlen(a),B=strlen(b),X;
    strcpy(x,a);
    x[A]='z'+2;
    int i,j;
    for(i=0,j=A+1;i<B;++i,++j) {
	x[j]=b[i];
    }
    X=strlen(x);
    suffixArray aa(a);
    aa.csa();
    aa.clcp();
    suffixArray bb(b);
    bb.csa();
    bb.clcp();
    suffixArray xx(x);
    xx.csa();
    xx.clcp();
    sparseTable(xx.lcp,X);
    for(i=1;i<=A;++i) {
	if(i==1) {
	    A_A[A-aa.sa[i]]++;
	}
	else {
	    int com = aa.lcp[i];
	    if(A-aa.sa[i]-com >= 0) {
		A_A[A-aa.sa[i]]++;
		if(com>=0) {
		    A_A[com]--;
		}
	    }
	}
    }
    for(i=1;i<=B;++i) {
	if(i==1) {
	    B_B[B-bb.sa[i]]++;
	}
	else {
	    int com = bb.lcp[i];
	    if(B-bb.sa[i]-com>=0) {
		B_B[B-bb.sa[i]]++;
		if(com>=0)
		    B_B[com]--;
	    }
	}
    }
    AB[A]=0;
    int st=0;
    bool flg = false;
    for(i=2;i<=X;++i) {
	if(xx.sa[i]==A) continue;
	int com = xx.lcp[i];
	if((xx.sa[i-1]>A && xx.sa[i]<A) || (xx.sa[i-1]<A && xx.sa[i]>A)) {
	    if(xx.lcp[i]>=0) {
		AB[xx.lcp[i]]++;
		if(flg == false) {
		    flg = true;
		}
		else {
		    int temp = rmqa(st,i);
		    AB[temp]--;
		}
		st = i;
	    }
	}
    }
    for(i=A-1;i>=0;--i) {
	A_A[i] += A_A[i+1];
    }
    for(i=B-1;i>=0;--i) {
	B_B[i] += B_B[i+1];
    }
    for(i=X-1;i>=0;--i) {
	AB[i] += AB[i+1];
    }
    int q;
    si(q);
    while(q--) {
	ll x,k,ans;
	sll(x); sll(k);
	if(x==1) {
	    ans = AB[k];
	}
	else if(x==2) {
	    ans = A_A[k] - AB[k];
	}
	else if(x==3) {
	    ans = B_B[k] - AB[k];
	}
	else {
	    ans = A_A[k] - AB[k] + B_B[k] - AB[k];
	}
	pll(ans); nl;
    }
    return 0;
}
