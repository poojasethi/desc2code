//#include<bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <queue>
#include <stack>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <set>
using namespace std;
#define w(t) while(t--)
#define S(x) scanf("%d",&x)
#define SLL(x) scanf("%lld",&x)
#define P(x) printf("%d\n",x)
#define fl(i , a, b) for(i = (int)a; i<(int)b; i++)
#define mem(a , value) memset(a , value , sizeof(a))
#define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++)
#define MOD 1000000007
#define MAX 1000000010
#define ll long long
#define all(v) v.begin(),v.end()
#define mp make_pair
#define pb push_back
#define f first
#define s second
typedef pair<int,int> pp;
string s,s1,s2; 
#define SZ 200002
int P[30][SZ] , sa[SZ] ,stp , n , cnt;
struct s
{
    int nr[2],p ;
}L[SZ];
int power(ll x,ll y)
{
    if(y==0) return 1;
   	int tmp = power(x,y/2); 
    if(y%2==0) return (tmp*tmp);
    return ((tmp*tmp))*x;
}
bool mycmp(struct s a , struct s b)
{
    return a.nr[0]==b.nr[0] ? (a.nr[1]<b.nr[1]?1:0) : (a.nr[0]<b.nr[0]?1:0);
}
void constructsa()
{
	stp =0 ; 
    for (int i = 0; i < n; ++i)
        P[0][i] = s[i] -'a';
    for (stp = 1, cnt=1; cnt<n ;cnt*=2,  ++stp)
    {
        for (int k = 0; k <n; ++k)
        {
            L[k].nr[0] = P[stp-1][k];
            L[k].nr[1] = k+cnt<n ? P[stp-1][k+cnt]:-1;
            L[k].p = k;
        }
        sort(L , L+n , mycmp);
        for (int i = 0; i < n; ++i)
        {
            P[stp][L[i].p] = i>0 && L[i].nr[0]==L[i-1].nr[0] && L[i].nr[1]==L[i-1].nr[1]? P[stp][L[i-1].p] : i;
        }
    }    
    for(int suffix = 0 ; suffix < n ; suffix++)
    {
        sa[P[stp-1][suffix]] = suffix; 
        /* P[stp-1][suffix] = rank of suffix starting at suffix position*/
    }
    return ;
}
ll constlcp(ll x , ll y)
{
    ll ans=0 ; 
    for (ll k = stp-1; k>=0 && x<n && y<n; k--)
    {
        if(P[k][x]==P[k][y])
        {
            ll t = power(2, k );
            x += t, y +=t;
            ans+=t; 
        }
    }
    return ans; 
}
const int N = 100002;
int A[N] , B[N] , U[N]; 
int main()
{
	string tmp ;
	int i ; 
	cin >> s; 
	n = s.size();
	int f1 = n ; 
	tmp = s ;
	constructsa(); 	
	// this gives me numbers of k length distinct substrings
	A[1]++; A[n-sa[0]+1]--;
	fl(i,1,n){
		int lcp = constlcp(sa[i], sa[i-1]); 
		A[lcp+1]++;
		A[n - sa[i] + 1]--; 
	}
	fl(i,1,n+1) A[i] += A[i-1];

	tmp += "#"; 
	cin >> s1;
	tmp+= s1;

	n = s1.size();
	s = s1 ; 
	constructsa();

	B[1]++; B[n-sa[0]+1]--;
	fl(i,1,n){
		int lcp = constlcp(sa[i], sa[i-1]); 
		B[lcp+1]++;
		B[n - sa[i] + 1]--; 
	}
	fl(i,1,n+1) B[i]+= B[i-1] ;
	s = tmp ; 
	n = tmp.size(); 
	constructsa();

	// pos = 0 par # start hoga 
	fl(i,1,n){
		if(sa[i] < f1 )
		{
			int lcp = constlcp(sa[i] , sa[i-1]) ;
			U[lcp+1]++;
			U[f1-sa[i]+1]--;
		}
		else{
			int lcp = constlcp(sa[i] ,sa[i-1]);
			U[lcp+1]++;
			U[n-sa[i]+1]--;
		}
	}
	fl(i,1,n+1) U[i]+=U[i-1];
	int t;
	S(t);
	w(t){
		int a,b;
		S(a);S(b);
		if(a==1){
			printf("%d\n", A[b] + B[b] - U[b]);
		}
		else if(a==2){
			printf("%d\n" , U[b] - B[b]);
		}
		else if(a==3){
			printf("%d\n", U[b] - A[b]);
		}
		else{
			printf("%d\n", 2*U[b] - (A[b] + B[b]));
		}
	}
	return 0;
}