/*******************karan*****************************/
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<assert.h>
#include<math.h>
#include<ctype.h>
#include<algorithm>
#include<vector>
#include<queue>
#include<deque>
#include<stack>
#include<map>
#include<set>
#define all(v) (v).begin() , (v).end()
#include<utility> //for pair
#define S(a,x) scanf("%"#a,&x)  //#a expands to "a" we use this bcoz, arguments are not replaced within quoted strings
#define PS(a,x) printf("%"#a" ",x)  //print with space
#define PN(a,x) printf("%"#a"\n",x)  //print with newline
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define FORD(i,a,b) for(int i=a;i>=b;i--)
#define REP(i,n) FOR(i,0,n)
#define Max(a, b) ((a>b)?a:b)
#define Min(a, b) ((a>b)?b:a)
#define MAXN 0
#define MOD 1000000007
#define TC int t; S(d,t); while(t--)
#define fill(a,v) memset(a,v,sizeof a)     //Works properly only for v = 0 or -1
#define LL long long
#define LD long double
using namespace std;
LL N;
int t, r;
LD p;
LD eps = 1e-13;
map<LL, LD> mymap;
long double func(LL n)
{
    if (n > N)
    {
        return 0.0;
    }
    if(mymap.count(n))
    {
        return mymap[n];
    }
    LD prec = pow (1.0 / n, p);
    if (prec < eps)
    {
        return 0.0;
    }
    mymap[n] = prec * (1.0 + func (n + t + r)) + (1.0 - prec) * (func (n + t));
    return mymap[n];
}
int main()
{
    S(ld, N);
    S(Lf, p);
    S(d,t);
    S(d, r);
    printf("%.7Lf\n", func(1));
    return 0;
}
