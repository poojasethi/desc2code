#include<iostream>
#include<stdlib.h>
#include<stdio.h>
#include<string>
#include<math.h>
#include<vector>
#include<iterator>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include<algorithm>
#define display(a,len) for(int i=0;i<len;i++)cout<<a[i]<<" ";cout<<endl;
#define displaymatrix(a,row,col)for(long long int i=0;i<row;++i){for(long long int j=0;j<col;++j)cout<<a[i][j]<<" ";cout<<endl;}
#define loop1(low,high) for(int i=low;i<high;i++)
#define loop2(low,high) for(int j=low;j<high;j++)
#include<string.h>
#define left(p) p<<1
#define right(p) ((p<<1)+1)
#define mid(l,r) (l+r)/2

using namespace std;
typedef long long int ll;
typedef unsigned long long int ull;
typedef vector< ll > vi;
struct node
{
    ll S,M;
    bool I,D;
}st[400040]={0};
ll A[100010]={0};
void build(ll p, ll L, ll R)
{
    if (L == R)
    {
        st[p].M = A[L];
        st[p].S = A[L];
        st[p].I = 1;
        st[p].D = 1;

    }
    else
    {
        build(left(p) , L , mid(L,R));
        build(right(p), mid(L,R) + 1, R);
        st[p].M = max(st[left(p)].M , st[right(p)].M);
        st[p].S = st[left(p)].S + st[right(p)].S;
        ll mid=mid(L,R);
        st[p].I = (st[left(p)].I && st[right(p)].I && A[mid] <= A[mid + 1]);
        st[p].D = (st[left(p)].D && st[right(p)].D && A[mid] >= A[mid + 1]);
    }
}


void update(ll p, ll L, ll R, ll ind)
{
    if (ind > R || ind < L)
        return;
    if (L == R)
	{
		st[p].M = A[L];
		st[p].S = A[L];
		return;
	}
	ll mid = mid(L, R);
	update(left(p), L, mid, ind);
	update(right(p), mid + 1, R, ind);

	st[p].M = max(st[left(p)].M , st[right(p)].M);
    st[p].S = st[left(p)].S + st[right(p)].S;
    st[p].I = (st[left(p)].I && st[right(p)].I && A[mid] <= A[mid + 1]);
    st[p].D = (st[left(p)].D && st[right(p)].D && A[mid] >= A[mid + 1]);

}

ll rmqM(ll p, ll L, ll R, ll i, ll j)
{
    if (i >  R || j <  L) return 0;
    if (L >= i && R <= j) return st[p].M;

    ll p1 = rmqM(left(p) , L , (L+R) / 2, i, j);
    ll p2 = rmqM(right(p), (L+R) / 2 + 1, R , i, j);
    return max(p1,p2);
}

ll rmqS(ll p, ll L, ll R, ll i, ll j)
{
    if (i >  R || j <  L) return 0;
    if (L >= i && R <= j) return st[p].S;
    return (rmqS(left(p) , L , (L+R) / 2, i, j)+rmqS(right(p), ((L+R) / 2) + 1, R , i, j));
}

bool rmqI(ll p, ll L, ll R, ll i, ll j)
{
        if (i >  R || j <  L) return 1;
        if (L >= i && R <= j) return st[p].I;
        ll mid=mid(L,R);
        ll tmp1=rmqI(left(p), L, mid, i, j);
        ll tmp2=rmqI(right(p), mid + 1, R, i, j);
        return (tmp1 && tmp2 && (A[mid] <= A[mid + 1] || mid < i || mid > j || mid + 1 < i || mid + 1 > j));
}

bool rmqD(ll p, ll L, ll R, ll i, ll j)
{
        if (i >  R || j <  L) return 1;
        if (L >= i && R <= j) return st[p].D;
        ll mid=mid(L,R);
        ll tmp1=rmqD(left(p), L, mid, i, j);
        ll tmp2=rmqD(right(p), mid + 1, R, i, j);
        return (tmp1 && tmp2 && (A[mid] >= A[mid + 1] || mid < i || mid > j || mid + 1 < i || mid + 1 > j));
}

int main()
{
	ios_base::sync_with_stdio(false);
	//freopen("a.txt", "r", stdin);// for testing the test case here 10911 is input file
	//freopen("b.txt", "w", stdout);
	ll n,m;
	cin>>n>>m;
	for(ll i=0;i<n;i++)
        cin>>A[i];
    build(1, 0, n-1 );
    while(m--)
    {
        char ch;
        ll x,y;
        cin>>ch>>x>>y;
        x--;
        y--;
        switch(ch)
        {
            case 'M':
                cout<<rmqM(1, 0, n-1 , x, y)<<endl;
                break;
            case 'U':
                A[x]=y+1;// y is new value here
                update(1,0,n-1,x);
                break;
            case 'S':
                cout<<rmqS(1, 0, n-1 , x, y)<<endl;
                break;
            case  'I':
                cout<<rmqI(1, 0, n-1, x, y)<<endl;
                break;
            case 'D':
                cout<<rmqD(1, 0, n-1 , x, y)<<endl;
                break;

        }
    }


	return 0;
}
