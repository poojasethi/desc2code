#include <bits/stdc++.h>
using namespace std;
#define all(c) c.begin(), c.end()
#define tr(container, it) for(auto it = container.begin(); it != container.end(); it++)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define mp make_pair
#define Foreach(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define For(i,a,b) for(long long   (i)=(a);(i) < (b); ++(i))
#define rof(i,a,b) for(long long   (i)=(a);(i) > (b); --(i))
#define rep(i, c) for(auto &(i) : (c))
#define x first
#define y second
#define pb push_back
#define PB pop_back()
#define fastscan ios_base::sync_with_stdio(0);cin.tie(NULL);
#define MAXN 1000000
#define MAXIND 1000000

long long   arr[MAXN];
struct node{
	long long   max,sum,i,d;
	node(){
		max=0;
		sum=0;
		i=1;
		d=1;
	}
	long long   query(char type){
		if(type=='M'){
			return max;
		}else if(type=='S'){
			return sum;
		}else if(type=='I'){
			return i;
		}else if(type=='D'){
			return d;
		}
	}
}vals[MAXIND];
void initialize(long long   node, long long   b, long long   e,long long   N){
	if (b == e){
		vals[node].max = arr[b];
		vals[node].sum = arr[b];
	}else{
		//compute the values in the left and right subtrees
          initialize(2 * node, b, (b + e) / 2, N);
          initialize(2 * node + 1, (b + e) / 2 + 1, e, N);
  //search for the minimum value in the first and
  //second half of the longerval
          // if (A[M[2 * node].max] >= A[M[2 * node + 1].max]){
          //     M[node].max = M[2 * node].max;
          // }
          // else{
          //     M[node].max = M[2 * node + 1].max;
          // }
          vals[node].max=max(vals[2 * node].max,vals[2*node+1].max);
          // compute sum
          vals[node].sum=vals[2 * node].sum+vals[2*node+1].sum;
          if(vals[2 * node].d==1 && vals[2 * node+1].d==1 && arr[(b + e) / 2]>=arr[(b + e) / 2 + 1]){
          	vals[node].d=1;
          }else{
          	vals[node].d=0;
          }
          if(vals[2 * node].i==1 && vals[2 * node+1].i==1 && arr[(b + e) / 2]<=arr[(b + e) / 2 + 1]){
          	vals[node].i=1;
          }else{
          	vals[node].i=0;
          }
      }
}
void update(long long   node, long long   a, long long   b, long long   i, long long   j, long long   val){
	if(a>b||a>j||b<i){
		return;
	}
	//cout<<a<<" "<<b<<"\n";
	if(a==b){
		arr[a]=val;
		vals[node].sum=val;
		vals[node].max=val;
		return;
	}
	update(node*2, a, (a+b)/2, i, j, val); // Updating left child
	update(1+node*2, 1+(a+b)/2, b, i, j, val); // Updating right

	// if (vals[2 * node].max >= vals[2 * node + 1].max){
	// 	vals[node].max = vals[2 * node].max;
	// }
	// else{
	// 	vals[node].max = vals[2 * node + 1].max;
	// }
	vals[node].max=max(vals[2*node].max,vals[2*node+1].max);
	vals[node].sum=vals[2 * node].sum+vals[2*node+1].sum;
	if(vals[2 * node].d==1 && vals[2 * node+1].d==1 && arr[(a + b) / 2]>=arr[(a + b) / 2 + 1]){
		vals[node].d=1;
	}else{
		vals[node].d=0;
	}
	if(vals[2 * node].i==1 && vals[2 * node+1].i==1 && arr[(a + b) / 2]<=arr[(a + b) / 2 + 1]){
		vals[node].i=1;
	}else{
		vals[node].i=0;
	}
}
long long   query(long long   node, long long   a, long long   b, long long   i ,long long   j,char type){
	if(a > b || a > j || b < i) return -1;
	// completely within range
	if(a >= i && b <= j){
		return vals[node].query(type);
	}
	if(type=='M'){
		long long   p1=query(2*node,a,(a+b)/2,i,j,type);
		long long   p2=query(2*node+1,(a+b)/2+1,b,i,j,type);
		long long   res=max(p1,p2);
		return res;
	}else if(type=='S'){
		long long   sum1=query(2*node,a,(a+b)/2,i,j,type);
		long long   sum2=query(2*node+1,(a+b)/2+1,b,i,j,type);
		if(sum1==-1 && sum2!=-1)return sum2;
		if(sum2==-1 && sum1!=-1)return sum1;
		if(sum1!=-1 && sum2!=-1)return sum1+sum2;
		return -1;
	}else{
		long long   l1=query(2*node,a,(a+b)/2,i,j,type);
		long long   l2=query(2*node+1,(a+b)/2+1,b,i,j,type);
		if(l1==1&&l2==1){
			if(type=='I' && arr[(a+b)/2]<=arr[(a+b)/2+1]){
				return 1;
			}
			if(type=='D' && arr[(a+b)/2]>=arr[(a+b)/2+1]){
				return 1;
			}
			// cout<<a<<" "<<b<<" "<<arr[a]<<" "<<arr[b]<<"0-\n";
			return 0;
		}
		if(l1==0 || l2==0)return 0;
		else return max(l1,l2);
	}
}
int  main(){
	long long   n,m;
	cin>>n>>m;
	For(i,0,n){
		long long   d;
		cin>>d;
		arr[i]=d;
	}
	// cout<<n<<"\n";
	initialize(1,0,n-1,n);
	while(m--){
		char T;
		long long   a,b;
		cin>>T>>a>>b;
		if(T=='U'){
			update(1,0,n-1,a-1,a-1,b);
		}else{
			long long   res=query(1,0,n-1,a-1,b-1,T);
			cout<<res<<"\n";
		}
		// cout<<"0\n";
	}
	return 0;
}