#include <bits/stdc++.h>
 
using namespace::std;
 
#define ll long long int
#define mp make_pair
#define ff first
#define ss second
const int MOD=1000000007,INF = 1e9,MAX = 2e6;
 
 
ll a[MAX],b[MAX],C[MAX];
vector < ll >  v;
 
ll tree1[MAX];
ll tree4[MAX];
bool tree2[MAX];
bool tree3[MAX];
ll arr[MAX];
 
struct trie{
 
	ll st,end;
	bool b;
 
	trie()
	{
		st=-1;
		end=-1;
	}
	trie(ll start,ll en,bool b1)
	{
		st=start;
		end=en;
		b=b1;
	}
};
 
void build1(ll node,ll start,ll end)
{
	if(start==end)
	{
		tree1[node]=arr[start];
		return;
	}	
	ll mid = (start+end)/2;
	build1(2*node,start,mid);
	build1(2*node+1,mid+1,end);
	tree1[node]=tree1[2*node]+tree1[2*node+1];	
}
 
void build2(ll node,ll start,ll end)
{
	if(start==end)
	{
		tree2[node]=true;
		return;
	}	
	ll mid = (start+end)/2;
	build2(2*node,start,mid);
	build2(2*node+1,mid+1,end);
	
	if(tree2[node*2] && tree2[node*2+1])
	{
		if(arr[mid]<=arr[mid+1])
		tree2[node]=true;
		else
		tree2[node]=false;	
	}	
	else
	{
		tree2[node]=false;
	}
}
 
void build3(ll node,ll start,ll end)
{
	if(start==end)
	{
		tree3[node]=true;
		return;
	}	
	ll mid = (start+end)/2;
	build3(2*node,start,mid);
	build3(2*node+1,mid+1,end);
	
	if(tree3[node*2] && tree3[node*2+1])
	{
		if(arr[mid]>=arr[mid+1])
		tree3[node]=true;
		else
		tree3[node]=false;	
	}	
	else
	{
		tree3[node]=false;
	}
}
 
void build4(ll node,ll start,ll end)
{
	if(start==end)
	{
		tree4[node]=arr[start];
		return;
	}	
	ll mid = (start+end)/2;
	build4(2*node,start,mid);
	build4(2*node+1,mid+1,end);
	tree4[node]=max(tree4[2*node],tree4[2*node+1]);	
}
 
 
void update1(ll node,ll start,ll end,ll idx,ll val)
{
	if(start==end)
	{
		tree1[node]=val;
		arr[start]=val;
	}	
	else
	{
		ll mid = (start+end)/2;
		if(idx>mid)
		update1(2*node+1,mid+1,end,idx,val);
		else
		update1(2*node,start,mid,idx,val);
 
		tree1[node]=tree1[2*node]+tree1[2*node+1];	
	}
}
void update2(ll node,ll start,ll end,ll idx,ll val)
{
	if(start==end)
	{
		tree2[node]=true;
		arr[start]=val;
	}	
	else
	{
		ll mid = (start+end)/2;
		if(idx>mid)
		update2(2*node+1,mid+1,end,idx,val);
		else
		update2(2*node,start,mid,idx,val);
 
		if(tree2[node*2] && tree2[node*2+1])
		{
			if(arr[mid]<=arr[mid+1])
			tree2[node]=true;
			else
			tree2[node]=false;	
		}	
		else
		{
			tree2[node]=false;
		}
 
	}
}
void update3(ll node,ll start,ll end,ll idx,ll val)
{
	if(start==end)
	{
		tree3[node]=true;
		arr[start]=val;
	}	
	else
	{
		ll mid = (start+end)/2;
		if(idx>mid)
		update3(2*node+1,mid+1,end,idx,val);
		else
		update3(2*node,start,mid,idx,val);
 
		if(tree3[node*2] && tree3[node*2+1])
		{
			if(arr[mid]>=arr[mid+1])
			tree3[node]=true;
			else
			tree3[node]=false;	
		}	
		else
		{
			tree3[node]=false;
		}
	}
}
 
void update4(ll node,ll start,ll end,ll idx,ll val)
{
	if(start==end)
	{
		tree4[node]=val;
		arr[start]=val;
	}	
	else
	{
		ll mid = (start+end)/2;
		if(idx>mid)
		update4(2*node+1,mid+1,end,idx,val);
		else
		update4(2*node,start,mid,idx,val);
 
		tree4[node]=max(tree4[2*node],tree4[2*node+1]);	
	}
}
 
ll query1(ll node,ll start,ll end,ll l,ll r)
{
	if(end<l || start>r)
	return 0;
	if(start>=l && end<=r)
	return tree1[node];
 
	ll mid = (start+end)/2;
	return query1(2*node,start,mid,l,r) + query1(2*node+1,mid+1,end,l,r); 	
}
 
trie query2(ll node,ll start,ll end,ll l,ll r)
{
	if(end<l || start>r)
	return trie();
	if(start>=l && end<=r)
	return trie(arr[start],arr[end],tree2[node]);
 
	ll mid = (start+end)/2;
	trie t1,t2,t3;
	t1=query2(2*node,start,mid,l,r) ;
	t2=query2(2*node+1,mid+1,end,l,r); 	
 
	if(t1.st!=-1 && t2.st==-1)
	{
		return t1;
	}
	else if(t1.st==-1 && t2.st!=-1)
	{
		return t2;
	}
	else
	{
		t3.st = t1.st;
		t3.end=t2.end;
		
		if(t2.b && t1.b)
		{
			if(t1.end<=t2.st)
			t3.b=true;
			else
			t3.b=false;
		}
		else
		t3.b=false;
 
		return t3;
	}
}
 
trie query3(ll node,ll start,ll end,ll l,ll r)
{
	if(end<l || start>r)
	return trie();
	if(start>=l && end<=r)
	return trie(arr[start],arr[end],tree3[node]);
 
	ll mid = (start+end)/2;
	trie t1,t2,t3;
	t1=query3(2*node,start,mid,l,r) ;
	t2=query3(2*node+1,mid+1,end,l,r); 	
 
	if(t1.st!=-1 && t2.st==-1)
	{
		return t1;
	}
	else if(t1.st==-1 && t2.st!=-1)
	{
		return t2;
	}
	else
	{
		t3.st = t1.st;
		t3.end=t2.end;
		
		if(t2.b && t1.b)
		{
			if(t1.end>=t2.st)
			t3.b=true;
			else
			t3.b=false;
		}
		else
		t3.b=false;
	
		return t3;
	}
}
 
ll query4(ll node,ll start,ll end,ll l,ll r)
{
	if(end<l || start>r)
	return 0;
	if(start>=l && end<=r)
	return tree4[node];
 
	ll mid = (start+end)/2;
	return max(query4(2*node,start,mid,l,r),query4(2*node+1,mid+1,end,l,r)); 	
}
 
int main()
{
	std::ios_base::sync_with_stdio(false);
	
	ll i,j,k,n,q;
 
	cin>>n>>q;
 
	for(i=1;i<=n;i++)
	cin>>arr[i];	
	
	build1(1,1,n);
	build2(1,1,n);
	build3(1,1,n);
	build4(1,1,n);
 
	while(q--)
	{
		char c;
 
		cin>>c;
		cin>>j>>k;
 
		if(c=='S')
		{
			printf("%lld\n",query1(1,1,n,j,k));
		}
		else if(c=='I')
		{
			printf("%d\n",query2(1,1,n,j,k).b);
		}
		else if(c=='D')
		{
			printf("%d\n",query3(1,1,n,j,k).b);
		}
		else if(c=='M')
		{
			printf("%lld\n",query4(1,1,n,j,k));
		}
		else
		{
			update1(1,1,n,j,k);
			update2(1,1,n,j,k);
			update3(1,1,n,j,k);
			update4(1,1,n,j,k);
		}
	}
} 