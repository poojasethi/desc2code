#include <iostream>
#include <cmath>
#include <climits>
#define t tree[i]
#define t1 tree[i+1]
#define t2 tree[i/2]

using namespace std;
long lm, bm;

struct node
{
    long mn;
    long mx;
    bool inc, dec;
    long long sum;
    long l, r;
    bool flag;
};
long size_max = (long)(pow(2, ceil(log2(10000))) +1);
//node * tree = new node[size_max];
node tree[262150];
void construct_tree(long n)
{
    long i,j;
    long level = ceil(log2(n));
    i = j = pow(2,level);
    while(j>1)
    {
    for(i=j; i<2*j; i += 2)
    {
        t2.flag = true;
        t2.sum = t.sum + t1.sum;
        t2.mx = max(t.mx, t1.mx);

        t2.inc = t2.dec = false;
        if(t.flag && t1.flag)
        {
            t2.mn = min(t.mn, t1.mn);
            if(t.inc && t1.inc)
            {
            if(t.mx<=t1.mn)
                t2.inc = true;
            else
                t2.inc = false;
            }
            if(t.dec && t1.dec)
            {
            if(t.mn>=t1.mx)
                t2.dec = true;
            else
                t2.dec = false;
            }
        }
        else if(t.flag)
        {
            t2.inc = t.inc;
            t2.dec = t.dec;
            t2.mn = t.mn;
        }
        else
            {
                t2.flag = false;
                t2.inc = t2.dec = true;
            }
        t2.l = t.l;
        t2.r = t1.r;

    }
    j/=2;
    }
}

long long sum(long qsi, long qei, long i)
{
    if(qsi<=t.l && qei>=t.r)
        return t.sum;
    if(qsi>t.r || qei<t.l)
        return 0;
    return sum(qsi, qei, 2*i) + sum(qsi, qei, 2*i+1);
}

long max_f(long qsi, long qei, long i)
{
    if(qsi<=t.l && qei>=t.r)
        return t.mx;
    if(qsi>t.r || qei<t.l)
        return LONG_MIN;
    return max(max_f(qsi, qei, 2*i),max_f(qsi, qei, 2*i+1));
}

bool inr(long qsi, long qei, long i)
{
    if(qsi<=t.l && qei>=t.r)
    {
        if(t.mn < lm)
            return false;
        lm = t.mx;

        return t.inc;
    }
    if(qsi>t.r || qei<t.l)
        return true;

    return (inr(qsi, qei,2*i) && inr(qsi, qei,2*i+1));
    //return (a&&b);
}

bool dcr(long qsi, long qei, long i)
{
    if(qsi<=t.l && qei>=t.r)
    {
        if(t.mx > bm)
            return false;
        bm = t.mn;

        return t.dec;
    }
    if(qsi>t.r || qei<t.l)
        return true;

    return (dcr(qsi, qei,2*i) && dcr(qsi, qei,2*i+1));
    //return (a&&b);
}

void update(long i, long d)
{
    t.sum=d;
    t.mx=d;
    t.mn=d;
    for(;i>1;i/=2)
    {
        if(i%2)
        {
            t2.sum=t.sum+tree[i-1].sum;
            t2.mx = max(tree[i-1].mx, t.mx);
            t2.mn = min(tree[i-1].mn, t.mn);
            if(tree[i-1].mx <= t.mn)
                t2.inc = t.inc && tree[i-1].inc;
            else
                t2.inc=0;
            if(tree[i-1].mn >= t.mx)
                t2.dec = t.dec && tree[i-1].dec;
            else
                t2.dec=0;
        }
        else
        {
            if(t1.flag)
            {
                t2.sum=t.sum+t1.sum;
                t2.mx = max(t1.mx, t.mx);
                t2.mn = min(t1.mn, t.mn);
                if(t.mx <= t1.mn)
                    t2.inc = t.inc && t1.inc;
                else
                    t2.inc=0;
                if(t.mn >= t1.mx)
                    t2.dec = t.dec && t1.dec;
                else
                    t2.dec=0;
            }
            else
            {
                t2.sum=t.sum;
                t2.mx=t.mx;
                t2.mn=t.mn;
                t2.inc=t.inc;
                t2.dec=t.dec;
            }
        }
    }

}

int main()
{
    long n, m, k=1, x, y, range, i;
    char ch;
    cin>>n>>m;
    long level = ceil(log2(n));
    range = pow(2, level) + n;
    for(i=pow(2,level); i<range; ++i)
    {
        cin>>tree[i].sum;
        tree[i].mn = tree[i].mx = tree[i].sum;
        tree[i].inc = tree[i].dec = true;
        tree[i].l = tree[i].r = k++;
        tree[i].flag = true;
    }
    for(;i<pow(2,level+1); ++i)
    {
        t.mn = t.mx = t.sum = 0;
        tree[i].inc = tree[i].dec = true;
        tree[i].l = tree[i].r = k++;
        t.flag = false;
    }
    //cout<<tree[(long)pow(2,level)+4].sum<<endl;

    construct_tree(n);
    //cout<<tree[1].inc<<endl;

    while(m--)
    {
        lm = LONG_MIN;
        bm = LONG_MAX;
        cin>>ch;
        cin>>x>>y;
        switch(ch)
        {
        case 'U':
            update(pow(2,level)+x-1,y);
            //cout<<tree[1].inc<<endl;
            break;
        case 'S':
            cout<<sum(x,y,1)<<"\n";
            break;
        case 'M':
            cout<<max_f(x,y,1)<<"\n";
            break;
        case 'I':
            cout<<inr(x,y,1)<<"\n";
            break;
        case 'D':
            cout<<dcr(x,y,1)<<"\n";
            break;
        }
    }

}
