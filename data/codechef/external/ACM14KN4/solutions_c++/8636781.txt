/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

public class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		
		BufferedReader br = new BufferedReader (new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter (new BufferedWriter (new OutputStreamWriter (System.out) ) );
		
		String[] pts = br.readLine().split(" ");
		int n = Integer.parseInt(pts[0]);
		int m = Integer.parseInt(pts[1]);
		pts = br.readLine().split(" ");
		Long[] arr = new Long[n];
		for (int i = 0; i < n; i ++)
			arr[i] = new Long(pts[i]);
		
		SegmentTree<Node, Long> st = new SegmentTree<Node, Long>(arr) {
			
			public Node merge(Node left, Node right) {
				
				Node ans = new Node();
				ans.val = left.sum + right.sum;
				ans.max = Math.max(left.max, right.max);
				ans.sum = ans.val;
				if (left.r <= right.l && left.inc && right.inc)
					ans.inc = true;
				if (left.r >= right.l && left.dec && right.dec)
					ans.dec = true;
				ans.l = left.l;
				ans.r = right.r;
				return ans;
			}	
			public Node initLeaf(Long data) {
				Node x = new Node();
				x.val = data;
				x.max = data;
				x.sum = data;
				x.inc = true;
				x.dec = true;
				x.l = data;
				x.r = data;
				return x;
			}
		};
		
		
		for (int i = 0; i < m; i ++) {
			pts = br.readLine().split(" ");
			char ch = pts[0].charAt(0);
			int ind = Integer.parseInt(pts[1]) - 1;
			long x = Long.parseLong(pts[2]);
			if (ch == 'U') {
				st.update(ind, x);
			}
			else {
				int rgt = Integer.parseInt(pts[2]) - 1;
				Node ans = st.query(ind, rgt);
				
				if (ch == 'M')
					out.println(ans.max);
				else if (ch == 'S')
					out.println(ans.sum);
				else if (ch == 'I')
					out.println(ans.inc?1:0);
				else if (ch == 'D')
					out.println(ans.dec?1:0);
			}
		}
		out.flush();
		out.close();
	}
	
	static class Node {
		long val, max, sum;
		long l, r;
		boolean inc, dec;
		public Node() {
			inc = false;
			dec = false;
		}
	}
}

abstract class SegmentTree<T, V> {
	
	private int[] leafInd;
	private int N;
	private T[] tree;
	
	public SegmentTree(V[] arr) {
		this.N = arr.length;
		leafInd = new int[N];
		tree = (T[])new Object[(N<<2) + 1];
		build(1, 0, N - 1, arr);
	}
	
	private void build(int index, int start, int end, V[] arr) {
		if(start > end)
			return;
		if(start == end) {
			tree[index] = initLeaf(arr[start]);
			leafInd[start] = index;
		}
		else if(start < end) {
			int mid = (start + end) / 2;
			build(2 * index, start, mid, arr);
			build(2 * index + 1, mid + 1, end, arr);
			tree[index] = merge(tree[2 * index], tree[2 * index + 1]);
		}
	}
	
	public void update(int ind, V data) {
		if(ind <0 || ind >= N)
			throw new IllegalArgumentException("Index not present in array");
		int index = leafInd[ind];
		
		tree[index] = initLeaf(data);
		index /= 2;
		
		while(index >= 1) {
			tree[index] = merge(tree[2 * index], tree[2 * index + 1]);
			index /= 2;
		}
	}
	
	public T query(int i, int j) {
		return query(1, 0, N - 1, i, j);
	}
	
	public T queryAll() {
		return tree[1];
	}
	
	private T query(int index, int start, int end, int i, int j) {
		if(start > end)
			return null;
		else if(start >= i && end <= j)
			return tree[index];
		int mid = (start + end) / 2;
		if(j <= mid)
			return query(2 * index, start, mid, i, j);
		else if(i > mid)
			return query(2 * index + 1, mid + 1, end, i, j);
		else {
			T left = query(2 * index, start, mid, i, j);
			T right = query(2 * index + 1, mid + 1, end, i, j);
			return merge(left, right);
		}
		
	}
	
	public abstract T initLeaf(V data);
	
	public abstract T merge(T left, T right);
}
