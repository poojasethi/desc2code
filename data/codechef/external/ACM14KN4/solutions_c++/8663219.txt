/*
    AUTHOR:         BHUVNESH JAIN
    INSTITUITION:   BITS PILANI, PILANI
*/
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <iterator>
#include <cmath>
#include <cassert>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <climits>
 
using namespace std;
 
#define fastio          std::ios_base::sync_with_stdio(false)
#define PAUSE_EXE       assert(false)
#define LL              long long
#define MAX             100005
#define LIMIT           262950
#define MOD             1000000007
#define REP(i,n)        for(__typeof(n) i=0; i<n; ++i)
#define REP1(i,n)       for(__typeof(n) i=1; i<=n; ++i)
#define REP2(i,n)       for(__typeof(n) i=1; i<n; ++i)
#define CREP(i,n)       for(__typeof(n) i=n-1; i>=0; --i)
#define CREP1(i,n)      for(__typeof(n) i=n; i>=1; --i)
#define CREP2(i,n)      for(__typeof(n) i=n-1; i>=1; --i)
#define MYREP(i,a,b)    for(__typeof(a) i=a; i<=b; ++i)
#define MYCREP(i,a,b)   for(__typeof(a) i=b; i>=a; --i)
#define SET(a, b)       memset(a, b, sizeof(a))
#define sz(a)           int((a).size())
#define pb              push_back
#define mp              make_pair
#define fi              first
#define sec             second
#define all(c)          (c).begin(),(c).end()
#define allr(c)         (c).rbegin(),(c).rend()
#define reset(c)        (c).clear()
#define loop(c,i)       for(typeof(c.begin()) i = c.begin(); i != c.end(); i++)
#define present(c,x)    ((c).find(x) != (c).end())
#define cpresent(c,x)   (find(all(c),x) != (c).end())
 
const double EPS = 1e-10;
 
template <typename T> T max(T &a, T &b) {return (!(a < b) ? a : b);}
template <typename T> T min(T &a, T &b) {return (a < b ? a : b);}
template <typename T> T mod(T a, T b) {return (a < b ? a : a % b);}
LL mulmod(LL a,LL b, LL m){LL q=(LL)(((long double)a*(long double)b)/(long double)m);LL r=a*b-q*m;if(r>m)r%=m;if(r<0)r+=m;return r;}
template <typename T>T power(T e, T n, T m){T x=1,p=e;while(n){if(n&1)x=mod(x*p, m);p=mod(p*p, m);n>>=1;}return x;}
template <typename T> T InverseEuler(T a, T m){return (a==1? 1 : power(a, m-2, m));}
template <typename T> T gcd(T a, T b){return (!b)? a:gcd(b,a%b);}
template <typename T> T lcm(T a, T b){return (a*(b/gcd(a,b)));}

LL a[MAX];

int qs, qe;

struct node
{
    LL sum, maxi;
    bool in, de;
    
    void merge(node &A, node &B, int t)
    {
        sum = A.sum + B.sum;
        maxi = max(A.maxi, B.maxi);
        if(A.in && B.in && (a[t] <= a[t+1]))
            in = true;
        else
            in = false;
        if(A.de && B.de && (a[t] >= a[t+1]))
            de = true;
        else
            de = false;
    }

}tree[LIMIT];

void build(int i, int j, int ind)
{
    if(i == j)
    {
        tree[ind].sum = a[i];
        tree[ind].maxi = a[i];
        tree[ind].in = true;
        tree[ind].de = true;
        return;
    }
    int mid, l, r;
    mid = (i + j)>>1;
    l = ind <<1;
    r = l|1;
    build(i,mid,l);
    build(mid+1,j,r);
    tree[ind].merge(tree[l], tree[r], mid);
}

void update(int i, int j, int ind)
{
    if(i > qs || j < qs)
        return;
    if(i == j && i == qs)
    {
        tree[ind].sum = a[i];
        tree[ind].maxi = a[i];
        tree[ind].in = true;
        tree[ind].de = true;
        return;
    }
    int mid, l, r;
    mid = (i + j)>>1;
    l = ind <<1;
    r = l|1;
    update(i,mid,l);
    update(mid+1,j,r);
    tree[ind].merge(tree[l], tree[r], mid);
}

LL sum(int i, int j, int ind)
{
    if(i>qe || j<qs)
        return 0;
    if(i>=qs && j<=qe) 
        return tree[ind].sum;
    int mid, l, r;
    mid = (i + j)>>1;
    l = ind <<1;
    r = l|1;
    return sum(i, mid, l) + sum(mid+1, j, r);
}

LL maximum(int i, int j, int ind)
{
    if(i>qe || j<qs)
        return 0;
    if(i>=qs && j<=qe)  
        return tree[ind].maxi;
    int mid, l, r;
    mid = (i + j)>>1;
    l = ind <<1;
    r = l|1;
    return max(maximum(i, mid, l),maximum(mid+1, j, r));
}

bool inc(int i, int j, int ind)
{
    if(i > qe || j < qs)
        return true;
    if(i >= qs && j <= qe) 
    	return tree[ind].in;
    int mid,l,r;
    mid = (i + j)>>1;
    l = ind <<1;
    r =l|1;
    bool check = true;
    if(mid >=qs && (mid+1)<=qe && (a[mid]>a[mid+1]))
        check = false;
    return (check && (inc(i, mid, l) && inc(mid+1, j, r)));
}

bool dec(int i, int j, int ind)
{
    if(i > qe || j < qs)
        return true;
    if(i >= qs && j <= qe) 
    	return tree[ind].de;
    int mid,l,r;
    mid = (i + j)>>1;
    l = ind <<1;
    r =l|1;
    bool check = true;
    if(mid >=qs && (mid+1)<=qe && (a[mid]<a[mid+1]))
        check = false;
    return (check && (dec(i, mid, l) && dec(mid+1, j, r)));
}

int main()
{
    int n, m, i;
    LL ans;
    char type;
    bool X;
    scanf("%d%d", &n,&m);
    REP1(i, n)
        scanf("%lld", &a[i]);
    build(1,n,1);
    while(m--)
    {
        scanf("\n%c%d%d", &type,&qs,&qe);
        if(type == 'U')
        {
            a[qs] = qe;
            update(1,n,1);
        }
        else if(type == 'S')
        {
            ans = sum(1,n,1);
            printf("%lld\n", ans);
        }
        else if(type == 'M')
        {
            ans = maximum(1,n,1);
            printf("%lld\n", ans);
        }
        else if(type == 'I')
        {
            X = inc(1,n,1);
            if(X)
                printf("1\n");
            else 
                printf("0\n");
        }
        else if(type == 'D')
        {
            X = dec(1,n,1);
            if(X)
                printf("1\n");
            else 
                printf("0\n");
        }
    }
    return 0;
}