//THE ALGO FREAKS
//inclusions
#include <stdio.h>
#include<math.h>
#include<ctype.h>
#include<cstring>
#include<bitset>
#include<string>
#include<stdlib.h>
#include<iostream>
#include<list>
#include<sstream>
#include<vector>
#include<stack>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
//input statements
#define sf(n) scanf("%d",&n)
 
#define gc() getchar()
#define fsf(n) scanf("%f",&n)
#define sf2(n,m) scanf("%d %d",&n,&m)
//#define lsf(n) scanf("%lld",&n)
//#define lsf2(n,m) scanf("%lld %lld",&n,&m)
/*#define usf(n) scanf("%u",&n)
#define ulsf(n) scanf("%llu",&n)
#define usf2(n,m) scanf("%u %u",&n,&m)
#define ulsf2(n) scanf("%llu %llu",&n,&m)*/
 
//output statements
#define pf(n) printf("%d",n)
#define pf2(n,m) printf("%d %d",n,m)
#define pfn(n){ pf(n); nl;}
#define pf2n(n,m) {pf2(n,m); nl;}
//#define lpf(n) printf("%lld",n)
//#define lpf2(n,m) printf("%lld %lld",n,m)
//#define lpf2n(n,m) {lpf2(n,m); nl;}
//#define lpfn(n){ lpf(n); nl;}
//for unsigned int/long int
/*#define upf(n) printf("%u",n)
#define ulpf(n) printf("%llu",n)
#define upf2(n,m) printf("%u %u",n,m)
#define ulpf2(n,m) printf("%llu %llu",n,m)
#define upfn(n) {upf(n); nl;}
#define upf2n(n,m) {upf2(n,m); nl;}
#define ulpf2n(n,m) {ulpf2(n,m); nl;}
#define ulpfn(n) {ulpf(n); nl;}*/
#define pc(c) putchar(c)
//#define fpfn(n) {fpf(n); nl;}
//#define fpf(n) printf("%f",n)
#define nl printf("\n")
#define sp printf(" ")
#define yes printf("Yes\n")
#define no printf("No\n")
//statements
#define fr(i,n)  for(i=0;i<n;i++)
#define frw(i,p,e) for(i=p;i<e;i++)
#define rev(i,p,e) for(i=p;i>=e;i--)
#define ini(arr,i,n,p) for(i=0;i<n;i++) arr[i]=p
#define ittr(v,it) for(typeof(v.begin()) it=v.begin(); it!=v.end();it++)
//binary search bsearch(key,base,num,size,compare function)
//sorting qsort(base,num,size, compare function)
#define cont continue
#define wl while
#define ev(x) x%2==0
#define od(x) x%2!=0
#define max3(max,a,b,c) if(a>b) {if(a>c)max=a; else max=c;} else {if(b>c)max=b; else max=c;}
#define mod(a,b) (a>=0)?(a)%(b):(a)%(b)+(b)
 
//types
typedef long long int lint;
typedef unsigned long long int ulint;
typedef unsigned int uint;
typedef short int sint;
typedef double dbl;
typedef float flt;
#define vi vector<int>
#define vvi vector<vi >
#define ii pair<int,int>
#define iii pair<int, ii >
#define F first 
#define S second 
#define prq priority_queue
#define sz(a) int((a).size())
#define vecsiz(c) (c.end()-c.begin())
//dfs bfs
#define ddx dx[]={-1,0,+1,0}
#define ddy dy[]={0,+1,0,-1}
#define range(i,j,n,m) (i<0 || j<0 || i>=n || j>=m) 
//STL and containers
#define all(c) c.begin(),c.end()
#define maxe max_element 
#define  mine min_element
#define pb push_back
#define pfr push_front
#define mp make_pair
 #define present(container, element) (container.find(element) != container.end())//for set, map
 #define cpresent(container, element) (find(all(container),element) != container.end()) //for others
#define accum accumulate
//constants
#define CONS 1000000007
#define SIZE 100002
#define TYPE int
#define TYPE2 double
 
using namespace std;
//--------------------------------------------------
//                code from here
//--------------------------------------------------

struct segment
{
	//structure 
int lid;
int rid;
int largest;//largest of all
lint sum;//sum
char order;//ascending or descending 0=no order 1=ascending 2=descending 3=both
};
int arr[SIZE];//array of elements
vector<segment> tree(4*SIZE);
int n;//no. of nodal segments

char deduceorder(char od1,char od2,int mid)
{
// to deduce order based upon mid
char temp;
	if(od1==0 || od2==0)temp=0;
	else if(od1==3 && od2==3)
	 {
	 if(arr[tree[mid].rid]==arr[tree[mid+1].lid]) temp=3;
	 else if(arr[tree[mid].rid]<arr[tree[mid+1].lid])temp=1;
	 else temp=2;
		}	
	else if(od1==3 || od2==3)
	{
	if((od1==2 || od2==2) && arr[tree[mid].rid]>=arr[tree[mid+1].lid]) temp=2;
	else if((od1==1 || od2==1) && arr[tree[mid].rid]<=arr[tree[mid+1].lid]) temp=1;
	else temp=0;
	}
	else if(od1==od2)
	{
	if(od1==2 && arr[tree[mid].rid]>=arr[tree[mid+1].lid])temp=2;
	else if(od1==1 && arr[tree[mid].rid]<=arr[tree[mid+1].lid])temp=1;
	else temp=0;
	}
	else temp=0;
	return temp;
}
void formsegtree(int si,int l,int r)
{//to build seg tree
tree[si].lid=l;
tree[si].rid=r;
if(l==r)
{
	tree[si].sum=arr[l];
	tree[si].order=3;
	tree[si].largest=arr[l];
	return;
}
int mid=(l+r)/2;
formsegtree(2*si+1,l,mid);
formsegtree(2*(si+1),mid+1,r);
mid=2*(si+1)-1;
	tree[si].sum=tree[mid].sum+tree[mid+1].sum;
	tree[si].largest=max(tree[mid].largest,tree[mid+1].largest);
	char od1=tree[mid].order,od2=tree[mid+1].order;
	tree[si].order=deduceorder(od1,od2,mid);
}
void update(int idx,int* fields)
{
//update the index and the tree, fields contain the index and value fields, idx is tree pointer
	int l=tree[idx].lid, r=tree[idx].rid;
	if(l==r)
	{
		tree[idx].sum=tree[idx].largest=fields[1];
		return;
	}
	int mid=2*(idx+1)-1;
	if(fields[0]<=tree[mid].rid) update(mid,fields);
	else  update(mid+1,fields);
	//update the intermediate segments
	tree[idx].sum=tree[mid].sum+tree[mid+1].sum;
	tree[idx].largest=max(tree[mid].largest,tree[mid+1].largest);
	char od1=tree[mid].order,od2=tree[mid+1].order;
	tree[idx].order=deduceorder(od1,od2,mid);
}

int largest(int idx,int l,int r)
{
//find the largest, l left and r right
	if(l==tree[idx].lid && r==tree[idx].rid )
	{
		return tree[idx].largest;
	}
	if(r<tree[idx].lid   || l>tree[idx].rid ) return -1;
	int mid=(tree[idx].lid+tree[idx].rid)/2;
	if(r<=mid) return largest(2*idx+1,l,r);
	if(l>mid) return largest(2*(idx+1),l,r); 
	return max(largest(2*idx+1,l,mid),largest(2*(idx+1),mid+1,r)); 
	
}
lint sum(int idx,int l,int r)
{
//find the sum, l left and r right
	if(l==tree[idx].lid && r==tree[idx].rid )
	{
		return tree[idx].sum;
	}
	if(r<tree[idx].lid   || l>tree[idx].rid ) return -1;
	int mid=(tree[idx].lid+tree[idx].rid)/2;
	if(r<=mid) return sum(2*idx+1,l,r);
	if(l>mid) return sum(2*(idx+1),l,r); 
	return sum(2*idx+1,l,mid)+sum(2*(idx+1),mid+1,r); 
	
}
char order(int idx,int l,int r)
{
//find the order, l left and r right
	if(l==tree[idx].lid && r==tree[idx].rid )
	{
		return tree[idx].order;
	}
	if(r<tree[idx].lid   || l>tree[idx].rid ) return -1;
	int mid=(tree[idx].lid+tree[idx].rid)/2;
	if(r<=mid) return order(2*idx+1,l,r);
	if(l>mid) return order(2*(idx+1),l,r); 
	return deduceorder(order(2*idx+1,l,mid),order(2*(idx+1),mid+1,r),2*idx+1); 

}

int main()
{
int m,i,j,k;
sf2(n,m);
fr(i,n)
sf(arr[i]);
formsegtree(0,0,n-1);
 char c;
fr(i,m)
{
	getchar();
	c=getchar();
	//putchar(c);
	sf2(j,k);
	switch(c)
	{
		case 'U':arr[j-1]=k;
				int fields[2];
				fields[0]=j-1;
				fields[1]=k;
				update(0,fields);
/*				fr(i,4*n)
 {
 	pf(tree[i].order);
 }nl;*/
				break;
		case 'M': pfn(largest(0,j-1,k-1));
				break;
		case 'S':printf("%lld\n",sum(0,j-1,k-1));
				break;
		case 'I':char c;
				c=order(0,j-1,k-1);
				if(c==1 || c==3)pfn(1)
				else pfn(0)
				break;
		case 'D':c=order(0,j-1,k-1);
				if(c==2 || c==3)pfn(1)
				else pfn(0)
				break;
	}
	
}
	return 0;
}
