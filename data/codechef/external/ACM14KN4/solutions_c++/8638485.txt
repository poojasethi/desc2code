#include <cstdio>
#include<iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

struct SegmentTreeNode {
	ll sum,mx,incr,decr,mn;
	
	void assignLeaf(ll value) {
		sum=mx= mn=value;
		incr=1;decr=1;
	}
	
	void merge(SegmentTreeNode& left, SegmentTreeNode& right) {
		sum = left.sum + right.sum;
		mx=max(left.mx,right.mx);
		mn=min(left.mn,right.mn);
		if(left.incr&&right.incr&&left.mx<=right.mn){
			incr=1;
			
		}else{
			incr=0;
			
		}
		if(left.decr&&right.decr&&left.mn>=right.mx){
			decr=1;
		}
		else{
			decr=0;
		}
		//prefixMaxSum = max(left.prefixMaxSum, left.sum + right.prefixMaxSum);
		//suffixMaxSum = max(right.suffixMaxSum, right.sum + left.suffixMaxSum);
		//maxSum = max(prefixMaxSum, max(suffixMaxSum, max(left.maxSum, max(right.maxSum, left.suffixMaxSum + right.prefixMaxSum))));
	}
	
	ll getDecr(){
		return decr;
	}
	
	ll getIncr(){
		return incr;
	}
	
	ll getMax(){
		return mx;
	}
	
	ll getSum() {
		return sum;
	}
};

template<class T, class V>
class SegmentTree {
	SegmentTreeNode* nodes;
	ll N;
	
public:
	SegmentTree(T arr[], ll N) {
		this->N = N;
		nodes = new SegmentTreeNode[getSegmentTreeSize(N)];
		buildTree(arr, 1, 0, N-1);
	}
	
	~SegmentTree() {
		delete[] nodes;
	}
	
	V getMax(ll lo, ll hi) {
		SegmentTreeNode result = getValue(1, 0, N-1, lo, hi);
		return result.getMax();
	}
	
	V getSum(ll lo, ll hi) {
		SegmentTreeNode result = getValue(1, 0, N-1, lo, hi);
		return result.getSum();
	}
	
	V getIncr(ll lo, ll hi) {
		SegmentTreeNode result = getValue(1, 0, N-1, lo, hi);
		return result.getIncr();
	}
	
	V getDecr(ll lo, ll hi) {
		SegmentTreeNode result = getValue(1, 0, N-1, lo, hi);
		return result.getDecr();
	}
	
	void update(ll index, T value) {
		update(1, 0, N-1, index, value);
	}
	
private:	
	void buildTree(T arr[], ll stIndex, ll lo, ll hi) {
		if (lo == hi) {
			nodes[stIndex].assignLeaf(arr[lo]);
			return;
		}
		
		ll left = 2 * stIndex, right = left + 1, mid = (lo + hi) / 2;
		buildTree(arr, left, lo, mid);
		buildTree(arr, right, mid + 1, hi);
		nodes[stIndex].merge(nodes[left], nodes[right]);
	}
	
	SegmentTreeNode getValue(ll stIndex, ll left, ll right, ll lo, ll hi) {
		if (left == lo && right == hi)
			return nodes[stIndex];
			
		ll mid = (left + right) / 2;
		if (lo > mid)
			return getValue(2*stIndex+1, mid+1, right, lo, hi);
		if (hi <= mid)
			return getValue(2*stIndex, left, mid, lo, hi);
			
		SegmentTreeNode leftResult = getValue(2*stIndex, left, mid, lo, mid);
		SegmentTreeNode rightResult = getValue(2*stIndex+1, mid+1, right, mid+1, hi);
		SegmentTreeNode result;
		result.merge(leftResult, rightResult);
		return result;
	}
	
	ll getSegmentTreeSize(ll N) {
		ll size = 1;
		for (; size < N; size <<= 1);
		return size << 1;
	}
	
	void update(ll stIndex, ll lo, ll hi, ll index, T value) {
		if (lo == hi) {
			nodes[stIndex].assignLeaf(value);
			return;
		}
		
		ll left = 2 * stIndex, right = left + 1, mid = (lo + hi) / 2;
		if (index <= mid)
			update(left, lo, mid, index, value);
		else
			update(right, mid+1, hi, index, value);
		
		nodes[stIndex].merge(nodes[left], nodes[right]);
	}
};

int main() {
	ll N, i, A[800005], M, x, y;
	char ch;
	scanf("%lld%lld", &N,&M);
	for (i = 0; i < N; ++i)
		scanf("%lld", &A[i]);
	SegmentTree<ll,ll> st(A, N);
	//scanf("%d", &M);
	for (i = 0; i < M; ++i) {
		//scanf("%c%lld%lld",&ch, &x, &y);
		cin>>ch>>x>>y;
		switch(ch){
			case 'S':
				printf("%lld\n", st.getSum(x-1, y-1));
				break;
			case 'M':
				printf("%lld\n", st.getMax(x-1, y-1));
				break;
			case 'I':
				printf("%lld\n", st.getIncr(x-1, y-1));
				break;
			case 'D':
				printf("%lld\n", st.getDecr(x-1, y-1));
				break;
			case 'U':
				st.update(x-1,y);
				break;	
		}
		//cout<<i<<endl;
		//cout<<M<<endl;
	}	
	return 0;
}