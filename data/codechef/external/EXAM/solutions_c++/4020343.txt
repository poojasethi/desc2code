#include<iostream>
#include<cstdio>
#include<vector>
#include<map>
#include<climits>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

#define F(i, n) for(i = 0;i < n; ++i)
#define FI(i, st, ft) for(i = st;i <= ft; ++i)
#define FD(i,n) for(i=n-1; i>=0; i--)
#define pb(a, b) a.push_back(b)
#define M 1000000
#define inf -1000000000
int K[1002][10002],S[1002][10002];
int v[1005],w[1005];
typedef long int li;
int max(int a,int b) { return (a > b)? a : b; }
int knapSack(int W, int wt[], int val[], int n)
{
   int j,i, w;
  
 
   // Build table K[][] in bottom up manner
   for (i = 0; i <= n; i++)
   {
       for (w = 0; w <= W; w++)
       {
           if (i==0 || w==0)
              { K[i][w] = 0;
               S[i][w]=0;}
           else if (wt[i-1] <= w)
           {  K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);
				if(2*val[i-1]+K[i-1][w-wt[i-1]]>=S[i-1][w])
				S[i][w]=2*val[i-1]+K[i-1][w-wt[i-1]];
				else
				S[i][w]=S[i-1][w];}
               
           else
                 {K[i][w] = K[i-1][w];
				S[i][w]=S[i-1][w];}
       }
   }
 
   return S[n][W];
}
 
 bool sort_pred(const pair< int, int>& left, const pair< int, int>& right)
    {
    return left.first < right.first;
    }
#define F(i, n) for(i = 0;i < n; ++i)
#define FI(i, st, ft) for(i = st;i <= ft; ++i)
#define FD(i,n) for(i=n-1; i>=0; i--)
#define pb(a, b) a.push_back(b)
#define M 1000000
#define inf -1000000000
int main()
{int n,t;
cin>>n>>t;
int j,i;
vector<pair< int, int> >p;
F(i,n)
{pair< int, int>q;
cin>>q.first;
 
p.push_back(q);
}
F(i,n)
{
	cin>>p[i].second;
}
sort(p.begin(),p.end(),sort_pred);
F(i,p.size())
{v[i]=p[i].first;
w[i]=p[i].second;
	
}
for( i=0;i<=n;i++)
    for(j=0;j<=t;j++)
      K[i][j]=S[i][j]=0;
cout<<knapSack(t, w, v, n);
 
	return 0;
} 