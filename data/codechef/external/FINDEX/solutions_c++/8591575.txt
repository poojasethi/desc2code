#include<bits/stdc++.h>
#include<string.h>
using namespace std;
typedef long long int ll;
const int SIZE =  1e5+5;
int arr[SIZE],brr[SIZE],crr[SIZE];
int n;
int A,B,C;
ll maxi;
int dp[SIZE];
 int cnt = 0;
bool composite[SIZE];
vector<int> BB;
vector<int> CC;
void computeLPSArray(int*,int,int*);
inline int scan(){
    int x = 0;
    char c = getchar_unlocked();
    while(c<'0'||c>'9') c = getchar_unlocked();
    while(c>='0'&&c<='9'){
            x = (x<<1)+(x<<3)+c-'0';
    c = getchar_unlocked();
    }
    return x;
}


inline ll scanL(){
    ll x = 0LL;
    char c = getchar_unlocked();
    while(c<'0'||c>'9') c = getchar_unlocked();
    while(c>='0'&&c<='9'){
            x = (x<<1)+(x<<3)+c-'0';
    c = getchar_unlocked();
    }
    return x;
} 
void KMPSearch(int *pat, int *txt,int type)
{
    int M;
    int N = A;
    if(type)
    M = B;
    else
        M = C;
    // create lps[] that will hold the longest prefix suffix values for pattern
    int *lps = (int *)malloc(sizeof(int)*M);
    int j  = 0;  // index for pat[]

    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

    int i = 0;  // index for txt[]
    while (i < N)
    {
      if (pat[j] == txt[i])
      {
        j++;
        i++;
      }

      if (j == M)
      {
          if(type) BB.push_back(i-j);
        else
            CC.push_back(i-j);
        j = lps[j-1];
      }

      // mismatch after j matches
      else if (i < N && pat[j] != txt[i])
      {
        // Do not match lps[0..lps[j-1]] characters,
        // they will match anyway
        if (j != 0)
         j = lps[j-1];
        else
         i = i+1;
      }
    }
    free(lps); // to avoid memory leak
}

void computeLPSArray(int *pat, int M, int *lps)
{
    int len = 0;  // lenght of the previous longest prefix suffix
    int i;

    lps[0] = 0; // lps[0] is always 0
    i = 1;

    // the loop calculates lps[i] for i = 1 to M-1
    while (i < M)
    {
       if (pat[i] == pat[len])
       {
         len++;
         lps[i] = len;
         i++;
       }
       else // (pat[i] != pat[len])
       {
         if (len != 0)
         {
           // This is tricky. Consider the example AAACAAAA and i = 7.
           len = lps[len-1];

           // Also, note that we do not increment i here
         }
         else // if (len == 0)
         {
           lps[i] = 0;
           i++;
         }
       }
    }
}





int main(){
    int tt;
   A = scan(),B = scan(),C = scan();
   for(int i = 0;i<A;i++) arr[i]=scanL();
   for(int i = 0;i<B;i++) brr[i]=scanL();
   for(int i = 0;i<C;i++) crr[i]=scanL();
   KMPSearch(crr, arr,0);
   KMPSearch(brr,arr,1);
   map<int,int> mtpB;
   for(int i = 0;i<BB.size();i++) mtpB[BB[i]]=1;
   memset(dp,0,sizeof dp);
   for(int i = A-1;i>=0;i--) dp[i]=dp[i+1]+mtpB[i];
   ll cnt = 0;
   for(int i = 0;i<CC.size();i++) cnt+=dp[CC[i]];
   printf("%lld\n",cnt);
   return 0;
}
