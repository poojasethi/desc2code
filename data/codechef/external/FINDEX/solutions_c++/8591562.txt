#include<bits/stdc++.h>
#include<string>
using namespace std;
void reverse(char *str, int length)
{
    int start = 0;
    int end = length -1;
    while (start < end)
    {
        swap(*(str+start), *(str+end));
        start++;
        end--;
    }
}
 
// Implementation of itoa()
char* itoa2(int num, char* str, int base)
{
    int i = 0;
    bool isNegative = false;
 
    /* Handle 0 explicitely, otherwise empty string is printed for 0 */
    if (num == 0)
    {
        str[i++] = '0';
        str[i] = '\0';
        return str;
    }
 
    // In standard itoa(), negative numbers are handled only with 
    // base 10. Otherwise numbers are considered unsigned.
    if (num < 0 && base == 10)
    {
        isNegative = true;
        num = -num;
    }
 
    // Process individual digits
    while (num != 0)
    {
        int rem = num % base;
        str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0';
        num = num/base;
    }
 
    // If number is negative, append '-'
    if (isNegative)
        str[i++] = '-';
 
    str[i] = '\0'; // Append string terminator
 
    // Reverse the string
    reverse(str, i);
 
    return str;
}
void LPSarray(string *s,int m,int *arr)
{
	int i=0;
	arr[0]=0;//here array stores LPS value
	i++;
	int len=0;
	while(i<m)
	{
		if(s[i]==s[len])
		{
			len++;
			arr[i]=len;
			i++;
		}
		else
		{
			if(len!=0)
			{
				len=arr[len-1];//we go to previous largest prefix which is also a suffix and then check
			}
			else
			{
				arr[i]=0;
				i++;
			}
		}
	}
}
int st1[100005],st2[100005];
int y=0;
void matchStr(string *text,string *pat,int n,int m)
{
	int arr[m];
	LPSarray(pat,m,arr);
	int i=0,j=0;
	while(i<n)
	{
		if(text[i]==pat[j])
		{
			j++;
			i++;
		}
		if(j==m)
		{
			//cout<<"match found at "<<i-j<<endl;
				st1[y++]=i-j;
			j=arr[j-1];
		}
		else if(i<n&&text[i]!=pat[j])
		{
			if(j!=0)
			j=arr[j-1];
			else
			i++;
		}
	}
	//delete(arr);
}
int x=0;
void matchStr2(string *text,string *pat,int n,int m)
{
	int arr[m];
	LPSarray(pat,m,arr);
	int i=0,j=0;
	while(i<n)
	{
		if(text[i]==pat[j])
		{
			j++;
			i++;
		}
		if(j==m)
		{
			//cout<<"match found at "<<i-j<<endl;
				st2[x++]=i-j;
			j=arr[j-1];
		}
		else if(i<n&&text[i]!=pat[j])
		{
			if(j!=0)
			j=arr[j-1];
			else
			i++;
		}
	}
	//delete(arr);
}
string take[100005],cat1[100005],cat2[100005];
int main()
{
	int n,k,l,p;
	char *f;
	scanf("%d%d%d",&n,&k,&l);
	for(int i=0;i<n;i++)
	{
	  scanf("%d",&p);
	 stringstream out;
	 out<<p;
	  take[i]=out.str();	
	}
	for(int i=0;i<k;i++)
	{
	  scanf("%d",&p);
	 stringstream out;
	 out<<p;
	  cat1[i]=out.str();	
	}
	for(int i=0;i<l;i++)
	{
		scanf("%d",&p);		
	  stringstream out;
	 out<<p;
		cat2[i]=out.str();
	}
	matchStr(take,cat1,n,k);
	matchStr2(take,cat2,n,l);
	long long ans=0;
	for(int i=0;i<y;i++)
	{
		int z=lower_bound(st2,st2+x,st1[i])-st2;
		if(st2[z]==st1[i])
		ans+=z+1;
		else
		ans+=z;
	}
	printf("%lld\n",ans);
}