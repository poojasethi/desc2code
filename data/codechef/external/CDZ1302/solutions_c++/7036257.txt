#ifdef DEBUG
#include<debug.h>
#else
#define db(...) {}
#define dbt(...) {}
#define pprintf(...) {}
#endif

#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
using namespace std;

#define ASSERT(f)       if(!(f)){fprintf(stdout,"Line-->%d  Assertion failed: %s\n",__LINE__,#f);exit(1);}
#define MOD             1000000007LL
#define ABS(x)          ((x)<0?-(x):(x))
#define SQR(x)          ((x)*(x))
#define CUBE(x)         ((x)*(x)*(x))
#define pnl             printf("\n");
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define FOREACH(i,s)    for(__typeof((s).begin()) i=(s).begin();i!=(s).end();i++)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second
typedef long long LL;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef pair<int, int> PII;
typedef vector<PII> VPII;
#define SIZE 100005
struct Edge {
        int from, to, weight;
        Edge(int from, int to, int weight) :
                from(from), to(to), weight(weight) {
        }
        Edge(const Edge&e) {
            from = e.from;
            to = e.to;
            weight = e.weight;
        }
        void display() {
            printf("%d--%d-->%d\n", from, weight, to);
        }
};

class minHeap {
    public:
        bool operator()(const Edge &a, const Edge &b) const {
            return a.weight > b.weight;
        }
};

class Set {
        vector<int> pSet;
        vector<int> pRank;
    public:
        Set(int n) {
            pSet.resize(n);
            pRank.resize(n, 1);
            for (int i = 0; i < n; i++) {
                pSet[i] = i;
            }
        }

        ~Set() {
            pSet.clear();
            pRank.clear();
        }

        int findSet(int i) {
            if (pSet[i] == i) {
                return i;
            }

            pSet[i] = findSet(pSet[i]);
            return pSet[i];
        }

        bool isSameSet(int a, int b) {
            return findSet(a) == findSet(b);
        }

        int getRank(int i) {
            return pRank[i];
        }

        void unionSet(int a, int b) {
            int x = findSet(a);
            int y = findSet(b);
            if (x != y) {
                int xS = pRank[x];
                int yS = pRank[y];
                if (xS < yS) {
                    pSet[x] = y;
                    pRank[y] += xS;
                } else {
                    pSet[y] = x;
                    pRank[x] += yS;
                }
            }
        }
};

class Graph {
        int N;
        priority_queue<Edge, vector<Edge>, minHeap> Edges;
        // 0 based indexing
    public:
        Graph(int n) {
            N = n;
        }

        void addEdge(int from, int to, int weight) {
            Edges.push(Edge(from, to, weight));
        }

        ~Graph() {
            while (!Edges.empty()) {
                Edges.pop();
            }
        }

        LL MinimumSpanningTreeKruskal() {
            LL sum = 0;
            Set set(N);
            while (!Edges.empty()) {
                Edge e = Edges.top();
                Edges.pop();
                int v = e.to;
                int u = e.from;
                int w = e.weight;
                //prevent loop
                if (set.isSameSet(u, v) == false) {
                    sum += (LL) w;
                    set.unionSet(u, v);
                }
            }
            return sum;
        }

};
int N, M, x, y, w;
void solve(int cx) {
    scanf("%d %d", &N, &M);
    db(N, M);
    Graph g(N + 1);
    REP(i, M)
    {
        scanf("%d %d %d", &x, &y, &w);
        db(x, y, w);
        g.addEdge(x, y, w);

    }
    printf("%lld\n", g.MinimumSpanningTreeKruskal());
}
int main() {
#ifdef LOCAL
    IO; TE tt("main");
#endif
    int T = 1;
    scanf("%d", &T);
    FORE(i, 1, T)
    {
        solve(i);
    }
    return 0;
}
