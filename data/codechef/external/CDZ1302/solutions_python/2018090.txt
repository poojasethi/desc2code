/*	Jayesh Lahori	    */
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<stack>
#include<queue>
#include<map>
#include<set>

using namespace std;

/* General Declarations */

#define INF		1000000007
#define LL		long long int
#define SI(n)		scanf("%lld",&n);
#define SC(c)		scanf("%c",&c);
#define SS(s)		scanf("%s",s);
#define FOR(x,a,b)	for(LL x=a;x<b;x++)
#define REP(i,n)	for(LL i=0;i<n;i++)
#define MP		make_pair
#define PB		push_back


/* Container's */

#define	VI		vector<LL>
#define PLL             pair<LL,LL>  /* A Single Pair  */
#define VP		vector<PLL> /* Vector of Pairs */
#define VS		vector<string>
#define VVI		vector<VI>
#define VVS		vector<VS>

LL parent[1000010];
LL children[1000010];

LL find(LL x)
{
	if(parent[x]==x)
		return x;
	return parent[x]=find(parent[x]);
}

int main()
{
	LL tc;
	SI(tc);	
	while(tc--)
	{

		LL n,m;
		SI(n);
		SI(m);

		REP(i,n+1)
		{
			parent[i]=i;
			children[i]=1;
		}

		priority_queue<pair<LL,PLL > > q; 

		while(m--)
		{
			LL x,y,w;
			SI(x);
			SI(y);
			SI(w);
		
			x--;
			y--; /* O based indexing of Vertices */

			q.push(MP(-w,MP(x,y))); /* q take pair of LL and PLL , So First do a MP for PLL then MP for overall pair */
		}

		LL ans=0;
		LL cnt=0;

		while(!q.empty())
		{
			if(cnt==n-1)
				 break;   /* All Vertices are included in MST */

			pair<LL,PLL> dummy=q.top();
			q.pop();

			LL x=dummy.second.first;  /* 1st of Inner Pair */
			LL y=dummy.second.second; /* 2nd of Inner Pair */ 
			LL w=-dummy.first;        /* First of Outer Pair */

			LL c1 = find(x);
			LL c2 = find(y);
			if(c1 != c2)
			{
				if(children[c1] < children[c2]) 
					swap(c1, c2);
				children[c1] += children[c2];
				children[c2]=1;
				parent[c2] = c1;
				ans+=w;
				cnt+=1;
			}

		}
		printf("%lld\n",ans); /* Cost of Spanning Tree */
	}

	return 0;
}
