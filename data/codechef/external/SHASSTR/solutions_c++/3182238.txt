#include<iostream>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<utility>
#include<sstream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<string>
#include<cctype>
#include<queue>
#include<deque>
#include<stack>
#include<cmath>
#include<ctime>
#include<list>
#include<map>
#include<set>
#define pi (acos(-1.0))
#define Abs(a) (((a)<0) ? (-(a)) :(a) )
#define rep(i,n) for((i)=0;(i)<(n);(i)++)
#define Rep(i,n) for(int i=0;i<(n);i++)
#define Rrep(i,n) for(int i=n-1;i>=0;i--)
#define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--)
#define Pii pair<int,int>
#define PB push_back
#define Size(x) ((int)(x.size()))
#define MIN(a,b) ((a)<(b) ? (a):(b))
#define MAX(a,b) ((a)>(b) ? (a):(b))
using namespace std;
typedef long long mint;
typedef unsigned long long umint;
char a[5001],b[5001];
int d[2][2][5005][5005];
int main()
{
    //freopen("in.txt","r",stdin);
    int t,T,sa,sb,k,mx,ka,kb;
    int i,j;
    scanf("%d",&T);
    for(t=1; t<=T; t++)
    {
        scanf("%d%d%d",&sa,&sb,&k);
        scanf("%s%s",a,b);
        if(k>min(sa,sb))
        {
            puts("-1");
            continue;
        }
        rep(ka,2)
        rep(kb,2)
        for(i=0; i<=sa; i++)
            for(j=0; j<=sb; j++)
            {
                if(ka*k>i||kb*k>j)
                {
                    d[ka][kb][i][j]=-1;
                    continue;
                }
                else
                    d[ka][kb][i][j]=0;
                if(i==0||j==0)
                    continue;
                if(a[i-1]==b[j-1])
                {
                    //cout<<"oria "<<d[ka][kb][i-1][j-1]<<endl;
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],(d[ka][kb][i-1][j-1]+1));
                }
                d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i][j-1]);
                d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i-1][j]);
                if(ka)
                {
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][kb][i-k][j]);
                }
                if(kb)
                {
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][0][i][j-k]);
                }
                if(ka&&kb)
                {
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][0][i-k][j-k]);
                }
                //cout<<ka<<" "<<kb<<" "<<i<<" "<<j<<" "<<d[ka][kb][i][j]<<endl;
            }
        //cout<<d[1][1][sa][sb]<<endl;
        printf("%d\n",MAX(0,d[1][1][sa][sb]));
    }
    return 0;
}


