/* .................................................................................................................................. */

/** Header **/

#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <bitset>
#include <list>
#include <set>
#include <map>

using namespace std;

/** Repeat **/

#define REP(I, N) for (int I=0;I<int(N);++I)
#define FOR(I, A, B) for (int I=int(A);I<int(B);++I)
#define DWN(I, B, A) for (int I=int(B-1);I>=int(A);--I)
#define REP_1(I, N) for (int I=1;I<=int(N);++I)
#define FOR_1(I, A, B) for (int I=int(A);I<=int(B);++I)
#define DWN_1(I, B, A) for (int I=int(B);I>=int(A);--I)
#define REP_C(I, N) for (int N____=int(N),I=0;I<N____;++I)
#define FOR_C(I, A, B) for (int B____=int(B),I=A;I<B____;++I)
#define DWN_C(I, B, A) for (int A____=int(A),I=B-1;I>=A____;--I)
#define REP_1_C(I, N) for (int N____=int(N),I=1;I<=N____;++I)
#define FOR_1_C(I, A, B) for (int B____=int(B),I=A;I<=B____;++I)
#define DWN_1_C(I, B, A) for (int A____=int(A),I=B;I>=A____;--I)
#define DO(N) while(N--)
#define DO_C(N) int N____ = N; while(N____--)
#define TO(i, a, b) int s_=a<b?1:-1,b_=b+s_;for(int i=a;i!=b_;i+=s_)
#define TO_1(i, a, b) int s_=a<b?1:-1,b_=b;for(int i=a;i!=b_;i+=s_)
#define SQZ(I, J, A, B) for (int I=int(A),J=int(B)-1;I<J;++I,--J)
#define SQZ_1(I, J, A, B) for (int I=int(A),J=int(B);I<=J;++I,--J)

/** Macro **/

#define ALL(A) A.begin(), A.end()
#define CLR(A) A.clear()
#define CPY(A, B) memcpy(A, B, sizeof(A))
#define INS(A, P, B) A.insert(A.begin() + P, B)
#define ERS(A, P) A.erase(A.begin() + P) 
#define SRT(A) sort(ALL(A))
#define SZ(A) int(A.size())
#define PB push_back
#define MP(A, B) make_pair(A, B)

/** Typedef **/

typedef long long LL;
typedef double DB;

typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<LL> VL;
typedef vector<DB> VD;
typedef set<int> SI;
typedef set<string> SS;
typedef set<LL> SL;
typedef set<DB> SD;
typedef map<int, int> MII;
typedef map<string, int> MSI;
typedef map<LL, int> MLI;
typedef map<DB, int> MDI;
typedef pair<int, int> PII;
typedef pair<int, bool> PIB;

/** Bitwise Operation **/

inline int count_bits(int x){
    x = (x & 0x55555555) + ((x & 0xaaaaaaaa) >> 1);
    x = (x & 0x33333333) + ((x & 0xcccccccc) >> 2);
    x = (x & 0x0f0f0f0f) + ((x & 0xf0f0f0f0) >> 4);
    x = (x & 0x00ff00ff) + ((x & 0xff00ff00) >> 8);
    x = (x & 0x0000ffff) + ((x & 0xffff0000) >> 16);
    return x;
}

inline int count_bits_32(int x){
    x = (x & 0x55555555) + ((x & 0xaaaaaaaa) >> 1);
    x = (x & 0x33333333) + ((x & 0xcccccccc) >> 2);
    x = (x & 0x0f0f0f0f) + ((x & 0xf0f0f0f0) >> 4);
    x = (x & 0x00ff00ff) + ((x & 0xff00ff00) >> 8);
    x = (x & 0x0000ffff) + ((x & 0xffff0000) >> 16);
    return x;
}

inline int count_bits_16(int x){
    x = (x & 0x00005555) + ((x & 0x0000aaaa) >> 1);
    x = (x & 0x00003333) + ((x & 0x0000cccc) >> 2);
    x = (x & 0x00000f0f) + ((x & 0x0000f0f0) >> 4);
    x = (x & 0x000000ff) + ((x & 0x0000ff00) >> 8);
    return x;
}

inline int count_bits_8(int x){
    x = (x & 0x00000055) + ((x & 0x000000aa) >> 1);
    x = (x & 0x00000033) + ((x & 0x000000cc) >> 2);
    x = (x & 0x0000000f) + ((x & 0x0000f0f0) >> 4);
    return x;
}

int reverse_bits(int x){
    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);
    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);
    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);
    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);
    x = ((x >> 16) & 0x0000ffff) | ((x << 16) & 0xffff0000);
    return x;
}
template<class T> inline T low_bit(T x) {return x & -x;}

template<class T> inline T high_bit(T x) {
    T p = low_bit(x);
    while (p != x) x -= p, p = low_bit(x);
    return p;
}

/** Function **/

template<class T> inline void RD(T &x){ // I/O Accelerator  
    // scanf("%d", &x);
    cin >> x;
    //char c; for (c = getchar(); c < '0'; c = getchar()); x = c - '0';
    //for (c = getchar(); c >= '0'; c = getchar()) x = x * 10 + c - '0';
}

template<class T> inline void RD(T &x0, T &x1){RD(x0), RD(x1);}
template<class T> inline void RD(T &x0, T &x1, T &x2){RD(x0), RD(x1), RD(x2);}
template<class T> inline void RD(T &x0, T &x1, T &x2, T &x3){RD(x0), RD(x1), RD(x2), RD(x3);}
template<class T> inline void RD(T &x0, T &x1, T &x2, T &x3, T &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);}
template<class T> inline void RD(T &x0, T &x1, T &x2, T &x3, T &x4, T &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);}
template<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}
template<class T> inline void RST(T &A0, T &A1){RST(A0), RST(A1);}
template<class T> inline void RST(T &A0, T &A1, T &A2){RST(A0), RST(A1), RST(A2);}
template<class T> inline void RST(T &A0, T &A1, T &A2, T &A3){RST(A0), RST(A1), RST(A2), RST(A3);}
template<class T> inline void RST(T &A0, T &A1, T &A2, T &A3, T &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}
template<class T> inline void RST(T &A0, T &A1, T &A2, T &A3, T &A4, T &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}
template<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}
template<class T> inline void FLC(T &A0, T &A1, int x){FLC(A0, x), FLC(A1, x);}
template<class T> inline void FLC(T &A0, T &A1, T &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}
template<class T> inline void FLC(T &A0, T &A1, T &A2, T &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}
template<class T> inline void FLC(T &A0, T &A1, T &A2, T &A3, T &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}
template<class T> inline void FLC(T &A0, T &A1, T &A2, T &A3, T &A4, T &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}

template<class T> inline void checkMin(T &a, T b){if (b<a) a=b;}
template<class T> inline void checkMax(T &a, T b){if (b>a) a=b;}
template<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}
template<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}
template<class T> inline T sqr(T a){return a*a;}
template<class T> inline T cub(T a){return a*a*a;}
template<class T> inline DB dist(T x0, T x1, T y0, T y1){return sqrt(sqr(x0 - x1) + sqr(y0 - y1));}
template<class T> inline T gcd(T a, T b){return b?gcd(b,a%b):a;}
template<class T> inline T lcm(T a, T b){return a*b/gcd(a, b);}

/* .................................................................................................................................. */

const int MOD = 1000000007;
const int INF = 0x7fffffff;
const int N = 50010;



struct Po{
    int x, y;
    friend bool operator <(Po a, Po b){
        return a.x < b.x; //|| a.x == b.x && a.y < b.y;
    }
} P[N];

int S0[N], S1[N], S2[N], S3[N];
int ky[N], ct[N], sz[N], lc[N], rc[N];
int root, total, _val;
/* BST */


int n;

LL ans;




inline void Updata(int now){
    sz[now] = sz[lc[now]] + sz[rc[now]] + 1;
}

inline void Clear(){
    root = total = 0;
    RST(lc, rc, ky, ct, sz);
}

inline void Insert_(int& now = root){
    if (!now){
        now = ++total, ky[now] = _val;
        ct[now] = sz[now] = 1;
    }
    else {
        ++sz[now];
        if (_val == ky[now]) {
            ++ct[now];
            return;
        }
        if (_val < ky[now]) Insert_(lc[now]);
        else Insert_(rc[now]);
    }
}

void Insert(int y){
    _val = y, Insert_();
}

int Select(int x){
    int now = root;
    
    while (true){
        if (x < sz[lc[now]]) now = lc[now];
        else if (x >= sz[lc[now]] + ct[now]) x -= sz[lc[now]] + ct[now], now = rc[now];
        else break;
    }
    return ky[now];
}

// Count How many element <= x 

int _Count(int x){
    
    int now = root, res = 0;
    
    while (now && x != ky[now]){
        if (x < ky[now]) now = lc[now];
        else res += sz[lc[now]] + ct[now], now = rc[now];
    }
    
    res += sz[lc[now]] + ct[now];
    return res;
}

// Count How many element >= x

int Count_(int x){
    
    int now = root, res = 0;
    
    while (now && x != ky[now]){
        if (x < ky[now]) res += sz[rc[now]] + ct[now], now = lc[now];
        else now = rc[now];
    }
    
    res += sz[rc[now]] + ct[now];
    return res;
}


void Inorder(int now = root){
    if (now){
        Inorder(lc[now]);
        cout << ky[now] << " ";
        Inorder(rc[now]);
    }
}


void init(){
    
    RD(n); REP(i, n) RD(P[i].x, P[i].y);

    sort(P, P+n);
        
    Clear();
    
    int i, i_;
    for(i=0;i<n;i=i_){
        Insert(P[i].y); for(i_=i+1;i_<n && P[i].x==P[i_].x; i_++) Insert(P[i_].y);
        for(int j=i;j<i_;j++) S0[j] = _Count(P[j].y) - 1, S1[j] = Count_(P[j].y) - 1;
    }
    
    Clear();

    
    for(i=n-1;i>=0;i=i_){
        Insert(P[i].y);
        for(i_=i-1;i>=0 && P[i].x==P[i_].x; i_--) Insert(P[i_].y);
        for(int j=i;j>i_;j--) S2[j] = _Count(P[j].y) - 1, S3[j] = Count_(P[j].y) - 1;
    }
    
    ans = 0;
}



LL c3(int n){
    if (n < 3) return 0;
    return LL(n) * (n-1) * (n-2) / 6;
}

void solve(){
    REP(i, n){
        ans += LL(S0[i]) * S3[i] + LL(S1[i]) * S2[i];
    }
    
    
    int i, i_;
    for (i=0;i<n;i=i_){
        for(i_=i+1;i_<n && P[i_].x==P[i].x;++i_);
        ans -= c3(i_ - i);
    }

    REP(i, n) swap(P[i].x, P[i].y);
    sort(P, P+n);
    
    for (i=0;i<n;i=i_){
        for(i_=i+1;i_<n && P[i_].x==P[i].x;++i_);
        ans -= c3(i_ - i);
    }
}


int main(){
    //freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
    //ios::sync_with_stdio(false);
    
    int T; RD(T);
    DO(T){
        init(); solve();
        printf("%lld\n", ans * 2);
    }
}


