#include<bits/stdc++.h>
#define assn(n,a,b) assert(n<=b && n>=a)
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define sz(x) ((int)(x	).size())
#define F first
#define S second
#define REP(i,a,b) for(int i=a;i<b;i++)
#define rep(i,b) for(i=0;i<b;i++)
#define rep1(i,b) for(i=1;i<=b;i++)
#define pdn(n) printf("%d\n",n)
#define sl(n) scanf("%lld",&n)
#define sd(n) scanf("%d",&n)
#define pn printf("\n")
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long LL;



#define MOD 1000000007LL

int m;
LL dp1[1002][1002];
LL update(LL left,LL last, LL y){
    LL &result = dp1[left][last];
    if(result!=-1) return result;
    if(last>=y) return 0;
    if(left==0) return 1;
    return result = (update(left-1,last+1,y)+update(left-1,1,y))%MOD;
}
LL get1(LL y,LL m,LL n){
    memset(dp1,-1,sizeof(dp1));
    LL a=update(m,0,y);
    LL ans=1;
    for(int i=1; i<=n; i++)
        ans=(ans*a)%MOD;
    return ans;
}


LL dp3[33][33][10];
bool valid[33][33][33];
bool getvalid(int mask1,int mask2,int next,int y,int m){
    int ct = 0;
    REP(i,1,m){
        bool flag[2];
        flag[0]=flag[1]=false;
        flag[(mask1&(1<<i))>0]=true;
        flag[(mask1&(1<<(i-1)))>0]=true;
        flag[(mask2&(1<<i))>0]=true;
        flag[(mask2&(1<<(i-1)))>0]=true;
        flag[(next&(1<<i))>0]=true;
        flag[(next&(1<<(i-1)))>0]=true;
        //cout << flag[0] << " asdf "  << flag[1] << endl;
        //cout << (next&(1<<(i))) <<  " :: " << next << endl;
        if(flag[0] && flag[1]) ct=0;
        else{
            if(ct==0) ct =2;
            else ct++;
        }
        if(ct>=y) return false;
    }
    return true;
}
void gen(int y,int m){
    //cout << " get valid" << getvalid(0,0,2,2,2) << endl;
    REP(i,0,(1<<m)) REP(j,0,(1<<m)) REP(k,0,(1<<m)){
        valid[i][j][k] = getvalid(i,j,k,y,m);
    }
}
LL update(LL mask1,LL mask2,LL left,LL y){
    LL &result = dp3[mask1][mask2][left];
    if(result!=-1) return result;
    if(left==0) return result = 1;
    result=0;
    REP(next,0,(1<<m)){
        if(valid[mask1][mask2][next]){
            result = (result + update(mask2,next,left-1,y))%MOD;
        }
    }
//    if(result>0)printf("%d %d %d\n",mask1,mask2,result);
    return result;
}
LL get3(LL y,LL m,LL n){
    gen(y,m);
//    for(int i=0; i<4; i++)
        //cout << valid[0][0][i] << " : " ;
//    cout << endl;
    memset(dp3,-1,sizeof(dp3));
    LL result = 0;
    REP(i,0,(1<<m)) REP(j,0,(1<<m)){
        result = (result + update(i,j,n-2,y))%MOD;
//        cout << update(i,j,n-2,y) << " " << result << endl;
    }
    return result;
}



LL p=1000000007ll;
LL matrix[200][200];
LL powo[200][200];
void multiply(int flag)
{
    LL temp[200][200]={};
    for(int i=0; i<(1<<m); i++)
        for(int j=0; j<(1<<m); j++)
            for(int k=0; k<(1<<m); k++)
            {
                if(flag==0)
                    temp[i][j]+= (matrix[i][k]*matrix[k][j])%p;
                else
                    temp[i][j]+= (matrix[i][k]*powo[k][j])%p;
                if(temp[i][j]>=p)temp[i][j]-=p;
            }
    for(int i=0; i<(1<<m); i++)
        for(int j=0; j<(1<<m); j++)
            matrix[i][j]=temp[i][j];
}
void power(int N)
{
    if(N==0 || N==1)return;
    power(N/2);
    multiply(0);
    if(N%2)multiply(1);
}

int check(int mask1, int next, int y)
{
/*    int cnt=0;
    if((a&(1<<0))==(b&(1<<0)))cnt=1;
    for(int i=1; i<m; i++)
    {
        if((a&(1<<i))==(b&(1<<i)) &&
                (a&(1<<(i-1)))==(b&(1<<(i-1)))
                &&
                (a&(1<<i))==(a&(1<<(i-1)))
          )cnt++;
        else if((a&(1<<i))==(b&(1<<i)))cnt=1;
        else cnt=0;
        if(cnt>=y)return 0;
    }
    if(cnt>=y)return 0;
    return 1;*/
    int ct = 0;
    REP(i,1,m){
        bool flag[2];
        flag[0]=flag[1]=false;
        flag[(mask1&(1<<i))>0]=true;
        flag[(mask1&(1<<(i-1)))>0]=true;
        flag[(next&(1<<i))>0]=true;
        flag[(next&(1<<(i-1)))>0]=true;
        //cout << flag[0] << " asdf "  << flag[1] << endl;
        //cout << (next&(1<<(i))) <<  " :: " << next << endl;
        if(flag[0] && flag[1]) ct=0;
        else{
            if(ct==0) ct =2;
            else ct++;
        }
        if(ct>=y) return false;
    }
    return true;

}
int main()
{
    int n,x,y;
    sd(n),sd(m),sd(x),sd(y);
    if(x==1)
    {
        cout << get1(y,m,n) << endl;
    }
    else if(x==2)
    {
        for(int i=0; i<(1<<m); i++)
            for(int j=0; j<(1<<m); j++)
                matrix[i][j]=powo[i][j]=(LL)check(i,j,y);
        power(n-1);
        LL ans=0;
        for(int i=0; i<(1<<m); i++)
            for(int j=0; j<(1<<m); j++)
            {
                ans += matrix[i][j];
                if(ans>=p)ans-=p;
            }
        cout << ans << endl;
    }
    else
    {
        cout<<get3(y,m,n) << endl;
    }
    return 0;
}
