/*
 *Kartik Singal @ ka4tik
 */
#include<bits/stdc++.h>
using namespace std;
struct debugger{template<typename T> debugger& operator,(const T& v){cerr<<v<<" ";return *this;}}dbg;
#define db(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0)
#define s(n) scanf("%d",&n);
#define ll long long
void gentests()
{
    ofstream file;
    file.open("in");
    ll test=1;
    while(test--)
    {
        ll n,m,x,y;
        x=rand()%3;x++;
        x=1;
        if(x==1)
        {
            n=rand()%1000000;
            n++;
            m=rand()%1000;
            m++;
        }
        else if(x==2)
        {
            n=rand()%1000000;
            n++;
            m=rand()%7;
            m++;
        }
        else
        {
            n=rand()%8;
            n++;
            m=rand()%5;
            m++;
        }
        y=rand()%m;y++;
        file<<n<<" "<<m<<" "<<x<<" "<<y<<endl;
    }
    file.close();
}
ll n,m,x,y;
ll dp1[1001][1001][2];
bool done1[1001][1001][2];
#define mod 1000000007
#define MAXN 1000111
ll modpow(ll n,ll p)
{
    ll ret=1;
    while(p)
    {
        if(p&1){
            ret=ret*n;
            if(ret>=mod) ret%=mod;
        }
        p=p/2;
        n*=n;
        if(n>=mod)
            n%=mod;
    }
    return ret;
}
ll rec1(ll index,ll consi,ll type)
{
    if(consi>=y)
        return 0;
    if(index==m)
        return 1;
    if(done1[index][consi][type])
        return dp1[index][consi][type];
    ll ans=0;
    if(type==0)
        ans=rec1(index+1,1,1)+rec1(index+1,consi+1,0);
    if(type==1)
        ans=rec1(index+1,consi+1,1)+rec1(index+1,1,0);
    done1[index][consi][type]=1;
    ans%=mod;
    return dp1[index][consi][type]=ans;
}
ll solve1(ll n,ll m,ll x,ll y)
{
    assert(x==1);
    ll single_row=rec1(1,1,0)+rec1(1,1,1);
    single_row%=mod;
    return modpow(single_row,n);
}
bool check(ll mask_last,ll mask)
{
    ll prev=-1;
    ll cnt=0;
    ll mx=0;
    for(ll i=0;i<m;i++)
    {
        mx=max(cnt,mx);
        ll flag=0;
        if(mask_last&(1<<i))
            if(mask&(1<<i))
            {
                if(prev==-1||prev==0)
                {
                    cnt=1;
                    prev=1;
                }
                else if(prev==1)
                    cnt++;
                flag=1;
            }
        if(!(mask_last&(1<<i)))
            if(!(mask&(1<<i)))
            {
                if(prev==-1||prev==1)
                {
                    cnt=1;
                    prev=0;
                }
                else if(prev==0)
                    cnt++;
                flag=1;
            }
        if(!flag)
        {
            prev=-1;
            cnt=0;
        }
    }
    mx=max(cnt,mx);
    return mx<y;
}
typedef vector<ll> vi;
typedef vector< vector<ll> > vvi;
vvi matrixUnit(ll n)
{
    vvi res(n,vi(n,0));
    for(ll i=0;i<n;i++)
        res[i][i]=1;
    return res;
}
vvi matrixAdd(vvi &a,vvi &b)
{
    ll n=a.size();
    ll m=a[0].size();
    vvi res(n,vi(m));
    for(ll i=0;i<n;i++)
    {
        for(ll j=0;j<m;j++)
        {
            res[i][j]=a[i][j]+b[i][j];
            if(res[i][j]>=mod)
                res[i][j]%=mod;
        }
    }
    return res;
}
vvi matrixMul(const vvi &a, const vvi &b) 
{
    ll n =a.size();
    ll m =a[0].size();
    ll k =b[0].size();
    vvi res(n,vi(k));
    for (ll i=0;i<n;i++)
        for (ll j=0;j<k;j++)
            for (ll p=0;p<m;p++)
                res[i][j]=(res[i][j]+(long long)a[i][p]*b[p][j])%mod;

    return res;
}
vvi matrixPow(vvi a,ll p)
{
    ll n=a.size();
    if(p==0)
        return matrixUnit(a.size());
    if((p&1))
        return matrixMul(a,matrixPow(a,p-1));
    else
        return matrixPow(matrixMul(a,a),p/2);
}
ll solve2(ll n,ll m,ll x,ll y)
{
    assert(x==2);
    if(n<=1)
        return modpow(2,n*m);
    ll ans=0;
    vvi T=matrixUnit((1<<m));
    for(ll i=0;i<(1<<m);i++)
        for(ll j=0;j<(1<<m);j++)
            if(check(i,j))
                T[i][j]=1;
            else
                T[i][j]=0;

    T=matrixPow(T,n-1);
    for(ll i=0;i<T.size();i++)
        for(ll j=0;j<T[i].size();j++)
        {
            ans+=T[i][j];
            if(ans>=mod) ans%=mod;
        }
    return ans;
}
bool check(ll mask_second_last,ll mask_last,ll mask)
{
    ll prev=-1;
    ll cnt=0;
    ll mx=0;
    for(ll i=0;i<m;i++)
    {
        mx=max(cnt,mx);
        ll flag=0;
        if(mask_second_last&(1<<i))
            if(mask_last&(1<<i))
                if(mask&(1<<i))
                {
                    if(prev==-1||prev==0)
                    {
                        cnt=1;
                        prev=1;
                    }
                    else if(prev==1)
                        cnt++;
                    flag=1;
                }
        if(!(mask_second_last&(1<<i)))
            if(!(mask_last&(1<<i)))
                if(!(mask&(1<<i)))
                {
                    if(prev==-1||prev==1)
                    {
                        cnt=1;
                        prev=0;
                    }
                    else if(prev==0)
                        cnt++;
                    flag=1;
                }
        if(!flag)
        {
            prev=-1;
            cnt=0;
        }
        if(mx>=y) return false;
    }
    mx=max(cnt,mx);
    return mx<y;
}
bool done3[10][1<<5][1<<5];
bool ok[1<<5][1<<5][1<<5];
ll dp3[10][1<<5][1<<5];
ll rec3(ll row_index,ll mask_last,ll mask_second_last)
{
    if(row_index==n)
        return 1;
    if(done3[row_index][mask_last][mask_second_last])
        return dp3[row_index][mask_last][mask_second_last];
    ll ans=0;
    for(ll i=0;i<(1<<m);i++)
    {
        if(ok[mask_second_last][mask_last][i])
        {
            ans+=rec3(row_index+1,i,mask_last);
            if(ans>=mod)
                ans%=mod;
        }
    }
    done3[row_index][mask_last][mask_second_last]=1;
    return dp3[row_index][mask_last][mask_second_last]=ans;
}
ll solve3(ll n,ll m,ll x,ll y)
{
    assert(x==3);
    if(n<=2) return modpow(2,n*m);
    ll ans=0;
    for(ll i=0;i<(1<<m);i++)
        for(ll j=0;j<(1<<m);j++)
            for(ll k=0;k<(1<<m);k++)
                if(check(i,j,k))
                    ok[i][j][k]=1;
    for(ll i=0;i<(1<<m);i++)
        for(ll j=0;j<(1<<m);j++)
        {
            ans+=rec3(2,i,j);
            if(ans>=mod)
                ans%=mod;
        }
    return ans;
}
int main()
{
    //gentests();
    //freopen("in","r",stdin);

    cin>>n>>m>>x>>y;

    if(x==1)
    {
        cout<<solve1(n,m,x,y)<<endl;
    }
    else if(x==2)
    {
        cout<<solve2(n,m,x,y)<<endl;
    }
    else 
    {
        cout<<solve3(n,m,x,y)<<endl;
    }

    return 0;
}

