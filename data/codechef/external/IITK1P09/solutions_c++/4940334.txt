#include <bits/stdc++.h>
using namespace std;

// uzumaki naruto
#define TRACE

#ifdef TRACE
#define dbgarr(a,n)   cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n";
#define dbg(args...)  {debug,args; cerr<<endl;}
#define pause()       cin.get();cin.get();

#else
#define dbgarr(a,n)
#define dbg(args...)
#define pause()
#endif

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

#define fr first
#define se second
#define pb push_back

typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const LL mod = 1000000007LL;
int n,m,x,y;

LL dp1[1005][1005][2];
bool vis1[1005][1005][2];

LL f1(int x,int cnt,int f){
    if (cnt == y) return 0;
    if (x == m) return 1;
    if (vis1[x][cnt][f]) return dp1[x][cnt][f];
    vis1[x][cnt][f] = true;

    LL ans = 0;
    for(int k = 0; k < 2; ++k){
        int add = (k == f ? cnt : 0) + 1;
        ans = (ans + f1(x+1,add,k))%mod;
    }
    dp1[x][cnt][f] = ans;
    return ans;
}

LL fast_pow(LL a,LL b){
    LL ans = 1LL;
    while(b > 0){
        if (b & 1) ans = (ans * a)%mod;
        a = (a * a)%mod;
        b >>= 1;
    }
    return ans;
}

const int mm2 = (1 << 7);
LL dp2[mm2][mm2],tmp[mm2][mm2];
LL con[mm2][mm2];

LL valid(int mask1,int mask2){
    for(int i = 0,k; i+y-1 < m; ++i){
        for(int co = 0; co < 2; ++co){
            for(k = i; k < m; ++k){
                int tx = (mask1 >> k) & 1;
                int ty = (mask2 >> k) & 1;
                if (tx != co or ty != co) break;
            }
            if (k-i >= y)
                return 0LL;
        }
    }
    return 1LL;
}

void mul(LL A[][mm2],LL B[][mm2]){
    int sz = (1 << m);
    for(int i = 0; i < sz; ++i){
        for(int j = 0; j < sz; ++j){
            tmp[i][j] = 0;
            for(int k = 0; k < sz; ++k)
                tmp[i][j] = (tmp[i][j] + A[i][k]*B[k][j])%mod;
        }
    }

    for(int i = 0; i < sz; ++i){
        for(int j = 0; j < sz; ++j)
            A[i][j] = tmp[i][j];
    }
}

void ident(LL A[][mm2]){
    int sz = (1 << m);
    for(int i = 0; i < sz; ++i){
        for(int j = 0; j < sz; ++j)
            A[i][j] = (i == j);
    }
}

void mat_power(int nn){
    if (nn == 0){
        ident(dp2);
        return;
    }

    mat_power(nn/2);
    mul(dp2,dp2);
    if (nn&1) mul(dp2,con);
}

bool pp[12][64][64];
long long cal[12][64][64];

bool check(int mask1,int mask2,int mask3){
    int k;
    for(int i = 0; i < m; ++i){
        for(int co = 0; co < 2; ++co){
            for(k = i; k < m; ++k){
                int t1 = (mask1 >> k) & 1;
                int t2 = (mask2 >> k) & 1;
                int t3 = (mask3 >> k) & 1;
                if (t1 != co) break;
                if (t2 != co) break;
                if (t3 != co) break;
            }
            if (k-i >= y) return false;
        }
    }
    return true;
}

long long f(int idx, int mask1, int mask2)
{
     if ( idx == n ) return 1;
     if ( pp[idx][mask1][mask2] ) return cal[idx][mask1][mask2];
     pp[idx][mask1][mask2] = true;
     long long ans = 0;
     for ( int i = 0; i < (1<<m); i++ ) {
         if ( check(mask1,mask2,i) ) {
            ans = (ans + f(idx+1, mask2, i))%mod;
         }
     }
     cal[idx][mask1][mask2] = ans;
     return ans;
}

void get()
{
    long long ans;
    if ( n == 1 ) {
         ans = 1<<m;
         ans %= mod;
    }
    else {
        ans = 0;
        for ( int i = 0; i < (1<<m); i++ ) {
          for ( int j = 0; j < (1<<m); j++ ) {
              ans = (ans + f(2,i,j))%mod;
            }
        }
    }
    cout << ans << endl;
}

void solve(){
    cin >> n >> m >> x >> y;
    if (x == 1){
        LL ans = f1(0,0,0);
        ans = fast_pow(ans,n);
        cout << ans << endl;
    }

    if (x == 2){
        for(int i = 0; i < (1 << m); ++i){
            for(int j = 0; j < (1 << m); ++j){
                con[i][j] = valid(i,j);
            }
        }

        mat_power(n-1);
        LL ans = 0;
        for(int i = 0; i < (1 << m); ++i){
            for(int j = 0; j < (1 << m); ++j)
                ans = (ans + dp2[i][j])%mod;
        }
        cout << ans << endl;
    }
    if ( x == 3 ) {
    	get();
    }
}

int main()
{
    ios_base::sync_with_stdio(0);
    solve();
    return 0;
}
