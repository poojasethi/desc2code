#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
#define S(x) scanf("%d",&x)
#define P(x) printf("%d\n",x)

typedef long long LL;
typedef vector<int> VI;

const int MAXN = 1000005;
int a[MAXN];


// RMQ - Sparse Table //
//<O(N logN), O(1)>//
// Method minPos(i,j) returns the minimum element in the range [i..j] in O(1) time after preprocessing time of O(N log N).
// i and j are 0-based index. Memory used is O(NlogN) as well.
class RMQ {
    VI logTable;
    vector<VI> rmq;
    VI A;
public:
    RMQ(int a[], int n) {
        A.resize(n);
        rep(i,0,n) A[i] = a[i];

        logTable.resize(n+1);
        for (int i = 2; i <= n; i++)
            logTable[i] = logTable[i >> 1] + 1;

        rmq.resize(logTable[n]+1);
        rep(i,0,logTable[n]+1)
            rmq[i].resize(n);

        for (int i = 0; i < n; ++i)
            rmq[0][i] = i;

        for (int k = 1; (1 << k) < n; ++k) {
            for (int i = 0; i + (1 << k) <= n; i++) {
                int x = rmq[k - 1][i];
                int y = rmq[k - 1][i + (1 << k - 1)];
                rmq[k][i] = a[x] <= a[y] ? x : y;
            }
        }
    }

    int minPos(int i, int j) {
        int k = logTable[j - i];
        int x = rmq[k][i];
        int y = rmq[k][j - (1 << k) + 1];
        return A[x] <= A[y] ? x : y;
    }

    int minEle(int i, int j) {
        int k = logTable[j - i];
        int x = rmq[k][i];
        int y = rmq[k][j - (1 << k) + 1];
        return A[x] <= A[y] ? A[x] : A[y];
    }
};

int main()
{
    #ifndef ONLINE_JUDGE
        //freopen("in.txt","r",stdin);
    #endif
    int n,q;
    S(n);
    S(q);
    rep(i,0,n) S(a[i]);
    RMQ ob(a, n);
    while(q--) {
        int i,j;
        S(i);
        S(j);
        i--;
        j--;
        printf("%d\n", ob.minEle(i,j));
    }
    return 0;
}
