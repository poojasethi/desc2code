#include<bits/stdc++.h>
using namespace std;
int st[100005],stt[100005];
int getMid(int s, int e)
{
return (s + (e -s)/2); 
}
int tree(int arr[], int ss, int se, int *st, int si)
{
    // If there is one element in array, store it in current node of
    // segment tree and return
    if (ss == se)
    {
        st[si] = arr[ss];
        return arr[ss];
    }
 
    // If there are more than one elements, then recur for left and
    // right subtrees and store the sum of values in this node
    int mid = getMid(ss, se);
   
    st[si] =  min(tree(arr, ss, mid, st, si*2+1), tree(arr, mid+1, se, st, si*2+2));
    return st[si];
    return *st;
}
int getmin(int *st, int ss, int se, int qs, int qe, int index)
{
	
    // If segment of this node is a part of given range, then return the
    // sum of the segment
    if (qs <= ss && qe >= se)
        return st[index];
 
    // If segment of this node is outside the given range
    if (se < qs || ss > qe)
        return INT_MAX;
 
    // If a part of this segment overlaps with the given range
    int mid = getMid(ss, se);
    return min(getmin(st, ss, mid, qs, qe, 2*index+1),getmin(st, mid+1, se, qs, qe, 2*index+2));
}
 int tree1(int arr[], int ss, int se, int *stt, int si)
{
    // If there is one element in array, store it in current node of
    // segment tree and return
    if (ss == se)
    {
        stt[si] = arr[ss];
        return arr[ss];
    }
 
    // If there are more than one elements, then recur for left and
    // right subtrees and store the sum of values in this node
    int mid = getMid(ss, se);
   
    stt[si] =  max(tree1(arr, ss, mid, stt, si*2+1), tree1(arr, mid+1, se, stt, si*2+2));
    return stt[si];
    return *stt;
}
int getmax(int *stt, int ss, int se, int qs, int qe, int index)
{
	
    // If segment of this node is a part of given range, then return the
    // sum of the segment
    if (qs <= ss && qe >= se)
        return stt[index];
 
    // If segment of this node is outside the given range
    if (se < qs || ss > qe)
        return -1;
 
    // If a part of this segment overlaps with the given range
    int mid = getMid(ss, se);
    return max(getmax(stt, ss, mid, qs, qe, 2*index+1),getmax(stt, mid+1, se, qs, qe, 2*index+2));
}
int main()
{
	int n,i,q,l,r,arr[100005];
	cin>>n>>q;
	
	for(i=0;i<n;i++)
	cin>>arr[i];
    *st = tree(arr,0,n-1,st,0);
    *stt = tree1(arr,0,n-1,stt,0);
    while(q--)
    {
	cin>>l>>r;
	if(l==r)
	cout<<0<<endl;
	else
   cout<<getmax(stt, 0, n-1, l, r, 0)-getmin(st, 0, n-1, l, r, 0)<<endl;
}
	return 0;
	
}