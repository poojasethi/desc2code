#include<iostream>
#include<cmath>
#include<algorithm>
#define ll long long int
using namespace std;


void buildMinSegmentTree(ll*,ll*,ll,ll,ll);
void buildMaxSegmentTree(ll*,ll*,ll,ll,ll);

ll getMin(ll*, ll low, ll high, ll node, ll start, ll end);
ll getMax(ll*, ll low, ll high, ll node, ll start, ll end);

int main(){

    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n,q;
    ll i;
    cin>>n>>q;
    ll input[n];
    for(i=0;i<n;i++)
        cin>>input[i];
    int sizeOfTree = 2*pow(2,ceil(log2(n)))-1;
    //cout<<sizeOfTree<<endl;

    ll *minSegmentTreePtr = new ll[sizeOfTree];
    ll *maxSegmentTreePtr = new ll[sizeOfTree];

    for(i=0;i<sizeOfTree;i++){
        minSegmentTreePtr[i]=-1;
        maxSegmentTreePtr[i]=-1;
    }

    buildMinSegmentTree(input,minSegmentTreePtr,0,n-1,0);
    buildMaxSegmentTree(input,maxSegmentTreePtr,0,n-1,0);

    //for(i=0;i<sizeOfTree;i++)
      //  cout<<minSegmentTreePtr[i]<<' ';
    //cout<<endl;

    //for(i=0;i<sizeOfTree;i++)
      //  cout<<maxSegmentTreePtr[i]<<' ';
    //cout<<endl;

    for(i=0;i<q;i++){
        ll left,right;
        cin>>left>>right;
        ll maximum=getMax(maxSegmentTreePtr,0,n-1,0,left,right);
        ll minimum=getMin(minSegmentTreePtr,0,n-1,0,left,right);
        //cout<<max<<' '<<min<<' '<<
        cout<<abs(maximum-minimum)<<endl;

    }
    return 0;
}


void buildMinSegmentTree(ll *input, ll *minSegmentTreePtr, ll low, ll high, ll node){

    if(low==high){
        minSegmentTreePtr[node]=input[low];
        //cout<<"min minSegmentTree[node] = "<<minSegmentTreePtr[node]<<" node "<<node<<endl;
        return ;
    }

    buildMinSegmentTree(input,minSegmentTreePtr,low,(low+high)/2,2*node+1);
    buildMinSegmentTree(input,minSegmentTreePtr,1+(low+high)/2,high,2*node+2);

    minSegmentTreePtr[node]=min(minSegmentTreePtr[2*node+1],minSegmentTreePtr[2*node+2]);
    //cout<<"min minSegmentTree[node] = "<<minSegmentTreePtr[node]<<" node "<<  node<<endl;

}



void buildMaxSegmentTree(ll *input, ll *maxSegmentTreePtr, ll low, ll high, ll node){

    if(low==high){
        maxSegmentTreePtr[node]=input[low];
      //  cout<<"max maxSegmentTree[node] = "<<maxSegmentTreePtr[node]<<" node "<<node<<endl;
        return ;
    }

    buildMaxSegmentTree(input,maxSegmentTreePtr,low,(low+high)/2,2*node+1);
    buildMaxSegmentTree(input,maxSegmentTreePtr,1+(low+high)/2,high,2*node+2);

    maxSegmentTreePtr[node]=max(maxSegmentTreePtr[2*node+1],maxSegmentTreePtr[2*node+2]);
    //cout<<"max maxSegmentTree[node] = "<<maxSegmentTreePtr[node]<<" node "<<node<<endl;

}



ll getMax(ll *maxSegmentTreePtr, ll low, ll high, ll node, ll start, ll end){

    if(low>=start&&high<=end)
        return maxSegmentTreePtr[node];

    if(low>end||high<start||low>high)
        return -1;

    return max(getMax(maxSegmentTreePtr,low,(low+high)/2,2*node+1,start,end),getMax(maxSegmentTreePtr,1+(low+high)/2,high,2*node+2,start,end));

}



ll getMin(ll *minSegmentTreePtr, ll low, ll high, ll node, ll start, ll end){

    if(low>=start&&high<=end)
        return minSegmentTreePtr[node];

    if(low>end||high<start||low>high)
        return 1000000000;

    return min(getMin(minSegmentTreePtr,low,(low+high)/2,2*node+1,start,end),getMin(minSegmentTreePtr,1+(low+high)/2,high,2*node+2,start,end));
}
