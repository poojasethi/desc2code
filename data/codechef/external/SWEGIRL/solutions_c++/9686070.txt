#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000000007
void build(int node,int a,int b,vector<int>& v,vector<int>& tree)
{
	if(a>b)
		return;
	if(a==b)
	{
		tree[node]=v[a];
		return;
	}
	build(node*2,a,(a+b)/2,v,tree);
	build(node*2+1,(a+b)/2+1,b,v,tree);
	tree[node]=((ll)tree[node*2]+(ll)tree[node*2+1])%mod;
}
void update(int node,int a,int b,int i,int j,int val,vector<int>& mul,vector<int>& add,int type,vector<int>& tree)
{
	if((mul[node]!=1)||(add[node]!=0))
	{
		tree[node]=((ll)tree[node]*mul[node])%mod;
		tree[node]=((ll)tree[node]+((ll)(b-a+1)*(add[node]))%mod)%mod;
		if(a!=b)
		{
			mul[2*node]=((ll)mul[2*node]*mul[node])%mod;
			mul[2*node+1]=((ll)mul[2*node+1]*mul[node])%mod;
			add[node*2]=((ll)mul[node]*add[node*2])%mod;
			add[node*2+1]=((ll)mul[node]*add[node*2+1])%mod;
			add[node*2]=((ll)add[node*2]+add[node])%mod;
			add[node*2+1]=((ll)add[node*2+1]+add[node])%mod;
		}
		mul[node]=1;
		add[node]=0;
	}
	if((a>b)||(i>b)||(a>j))
		return;
	if((a>=i)&&(b<=j))
	{
		if(type==1)
		{
			tree[node]=((ll)tree[node]+((ll)(b-a+1)*val)%mod)%mod;
		}
		else
			tree[node]=((ll)tree[node]*val)%mod;
		if(a!=b)
		{
			if(type==1)
			{
				add[node*2]=((ll)add[node*2]+val)%mod;
					add[node*2+1]=((ll)add[node*2+1]+val)%mod;
			}
			else
			{
				add[node*2]=((ll)add[node*2]*val)%mod;
				add[node*2+1]=((ll)add[node*2+1]*val)%mod;
				mul[node*2]=((ll)mul[node*2]*val)%mod;
					mul[node*2+1]=((ll)mul[node*2+1]*val)%mod;
			}
		}
		return;
		
	}
	update(node*2,a,(a+b)/2,i,j,val,mul,add,type,tree);
	update(node*2+1,(a+b)/2+1,b,i,j,val,mul,add,type,tree);	
	tree[node]=((ll)tree[node*2]+tree[node*2+1])%mod;
}
int query(int node,int a,int b,int i,int j,vector<int>& mul,vector<int>& add,vector<int>& tree)
{
	if((mul[node]!=1)||(add[node]!=0))
	{
		tree[node]=((ll)tree[node]*mul[node])%mod;
		tree[node]=((ll)tree[node]+((ll)(b-a+1)*(add[node]))%mod)%mod;
		if(a!=b)
		{
			mul[2*node]=((ll)mul[2*node]*mul[node])%mod;
			mul[2*node+1]=((ll)mul[2*node+1]*mul[node])%mod;
			add[node*2]=((ll)mul[node]*add[node*2])%mod;
			add[node*2+1]=((ll)mul[node]*add[node*2+1])%mod;
			add[node*2]=((ll)add[node*2]+add[node])%mod;
			add[node*2+1]=((ll)add[node*2+1]+add[node])%mod;
		}
		mul[node]=1;
		add[node]=0;
	}
	if((a>b)||(i>b)||(a>j))
		return 0;
	if((a>=i)&&(b<=j))
		return tree[node];
	int q1=query(node*2,a,(a+b)/2,i,j,mul,add,tree);
	int q2=query(node*2+1,(a+b)/2+1,b,i,j,mul,add,tree);
	int res=((ll)q1+q2)%mod;
	return res;
}
int main()
{
	int i,n,q,x,y,val,op,ans,t,c;
	string s;
	scanf("%d",&t);
	while(t--)
	{
	    cin>>s;
	    n=s.length();
	    vector<int> v(n),tree(4*n),mul(4*n,1),add(4*n);
	    for(i=0;i<n;i++)
		{
		    if(s[i]=='X')
		    {
		        v[i]=1;
		    }
		}
	        build(1,0,n-1,v,tree);
	        scanf("%d",&q);
	        while(q--)
	        {
			    scanf("%d%d%d",&op,&x,&y);
			    x--;
			    y--;
			update(1,0,n-1,x,y,0,mul,add,2,tree);
			if(op==1)
			update(1,0,n-1,x,y,1,mul,add,1,tree);
	        }
	        c=0;
	       for(i=0;i<n;i++)
	       {
	           val=query(1,0,n-1,i,i,mul,add,tree);
	           if(val)
	           {
	               s[i]='X';
	               c++;
	           }
	           else
	            s[i]='O';
	       }
		ans=c;
		for(i=0;i<n;i++){
			if(s[i]=='X')
				c--;
			else
				c++;
			ans=min(ans, c);
		}
		printf("%d\n", ans);
	}
	return 0;
}