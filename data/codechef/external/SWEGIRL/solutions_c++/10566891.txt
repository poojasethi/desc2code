#include<bits/stdc++.h>
using namespace std;
int st[400005];
int lazy[400005];
int a[100005];
 
void construct(int node, int i, int j)
{
	if(i == j)
	{
		st[node] = a[i];
		return;
	}
	int mid = (i+j)/2;
	construct(node*2, i, mid);
	construct(node*2+1,mid+1,j);
	st[node] = st[node*2]+st[node*2+1];
	return;
}
 

 
void update(int node, int i, int j, int x, int y, int v)
{
	if(i>j || i>y || j<x)
	return;
	if(lazy[node]!=-1)
	{
		st[node]=(j-i+1)*lazy[node];
		if(i!=j)
		{
			lazy[node*2]=lazy[node];
			lazy[node*2+1]=lazy[node];
		}
		lazy[node]=-1;
	}
	if(i>=x && j<=y)
	{
		st[node]=(j-i+1)*v;
		lazy[node]=-1;
		if(i!=j)
		{
			lazy[node*2]=v;
			lazy[node*2+1]=v;
		}
		return;
	}
	update(node*2,i,(i+j)/2,x,y,v);
	update(node*2+1,(i+j)/2+1,j,x,y,v);
	st[node]=st[node*2]+st[node*2+1];

}
 
int query(int node, int i, int j, int x, int y)
{
	if(i>j || i>y || j<x)
	return INT_MIN;
	if(lazy[node]!=-1)
	{
		st[node]=(j-i+1)*lazy[node];
		if(i!=j)
		{
			lazy[node*2]=lazy[node];
			lazy[node*2+1]=lazy[node];
		}
		lazy[node]=-1;
	}
	if(i>=x && j<=y)
	return st[node];
	int l=query(node*2,i,(i+j)/2,x,y);
	int r=query(node*2+1,(i+j)/2+1,j,x,y);
	return l+r;
}
 
int main()
{
	
 
	int t;
	cin >> t;
	while(t--)
	{
		string s;
		cin >> s;
		memset(lazy,-1,sizeof(lazy));
		for(int i = 0;i < s.size();i++)
		{
			if(s[i] == 'X')
				a[i+1] = 1;
			else a[i+1] = 0;
		}
		int n = s.size();
		construct(1, 1, n);
		int k;
		cin >> k;
		int aq,l,r;
		while(k--)
		{
			cin >> aq >> l >> r;
			if(aq == 1)
			{
				update(1, 1, n, l, r, 1);
			}
			else
			{
				update(1, 1, n, l, r, 0);
			}
		}
		for(int i = 1;i <= n;i++)
			a[i] = query(1, 1, n, i, i);
		int pre[n+1], suf[n+1];
		pre[0] = 0;
		pre[1] = a[1];
		suf[n] = a[n];
		for(int i = 2;i <= n;i++)
		{
			pre[i] = pre[i-1] + a[i];
			suf[n-i+1] = suf[n-i+2] + a[n-i+1];
		}
		int ans = min(pre[n], n-pre[n]);
		for(int i = 1;i < n;i++)
		{
			ans = min(ans, i-pre[i]+suf[i+1]);
		}
		cout << ans << endl;
	}
 
	return 0;
}