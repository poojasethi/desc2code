#include <cstdio>
#include <algorithm>
#include <utility>
#include <cstring>
#include <stack>
#include <vector>

using namespace std;

typedef pair<int,int> pii;
const long long MOD = 100000007;

pii keys[26];
vector< long long >no_wrap3(4);
vector< long long >no_wrap4(5);
vector< long long > wrap3(100010,0);
vector< long long > wrap4(100010,0);
stack<long long> res_comps;

int T;
char seq[100010];

long long get_key_pattern_count(int key,long order){
	int key_type;
	long long pat_count = 0;
	if(key > 1 && key < 7  || key == 8 ){
		key_type = 3;
	}
	else{
		key_type = 4;
	}

	if( key_type == 3 ){
		for(long i=no_wrap3.size();i<=order;++i){
			no_wrap3.push_back(no_wrap3[i-1]+no_wrap3[i-2]+no_wrap3[i-3]+1);
			no_wrap3[i] = no_wrap3[i] % MOD;
		}
		pat_count = no_wrap3[order];
	}

	else{
		for(long i=no_wrap4.size();i<=order;++i){
			no_wrap4.push_back(no_wrap4[i-1]+no_wrap4[i-2]+no_wrap4[i-3]+no_wrap4[i-4]+1);
			no_wrap4[i] = no_wrap4[i] % MOD;
		}

		pat_count = no_wrap4[order];
	}

	return pat_count;
}

int main(){
	no_wrap3[0] = 1;
	no_wrap3[1] = 1;
	no_wrap3[2] = 2;
	no_wrap3[3] = 4;
	wrap3[0] = 0;

	no_wrap4[0] = 1;
	no_wrap4[1] = 1;
	no_wrap4[2] = 2;
	no_wrap4[3] = 4;
	no_wrap4[4] = 8;
	wrap4[0] = 0;

	// Key Mappings A-Z 0-25
	for(int i=2;i<7;++i){
		for(int j=0;j<3;++j){
			keys[(i-2)*3 + j].first = j + 1;
			keys[(i-2)*3 + j].second = i;
		}
	}

	for(int i=7;i<8;++i){
		for(int j=0;j<4;++j){
			keys[15 + (i-7)*4 + j].first = j + 1;
			keys[15 + (i-7)*4 + j].second = i;
		}
	}

	for(int i=8;i<9;++i){
		for(int j=0;j<3;++j){
			keys[19+(i-8)*3 + j].first = j + 1;
			keys[19+(i-8)*3 + j].second = i;
		}
	}

	for(int i=9;i<10;++i){
		for(int j=0;j<4;++j){
			keys[22 + (i-9)*4 + j].first = j + 1;
			keys[22 + (i-9)*4 + j].second = i;
		}
	}

	scanf("%d",&T);
	long len;
	while(T--){
		//Reset Space
		scanf("%s",seq);
		len = strlen(seq);
		long long result = 1;
		int idx = 0;
		int prev_key = keys[seq[idx] - 'a'].second;
		long order = 0;
		int curr_key,curr_order;
		while( idx < len ){
			curr_key 	= keys[seq[idx] - 'a'].second;
			curr_order  = keys[seq[idx] - 'a'].first;;
			if( curr_key == prev_key ){
				order += curr_order;
			}
			else{
				res_comps.push( get_key_pattern_count(prev_key,order) );
				prev_key = curr_key;
				order = curr_order;
			}
			++idx;
		}
		
		// For the last key
		res_comps.push( get_key_pattern_count(prev_key,order) );

		while(!res_comps.empty()){
			result = ( res_comps.top() * result ) % MOD;
			res_comps.pop();
		}

		printf("%lld\n", result);

	}
	return 0;
}
