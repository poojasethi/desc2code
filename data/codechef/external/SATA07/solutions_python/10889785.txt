#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> 
using namespace __gnu_pbds;
using namespace std;
#define SF(x)	scanf("%d", &x)
#define PF(x)	printf("%d", x)
#define psp     printf(" ")
#define pnl     printf("\n")
#define pie     cout<<" # "<<endl
#define charint(c) ((c)-'0')
#define pii pair< int, int >
#define pb(x) push_back(x)
#define test int t; scanf("%d",&t);while(t--)
#define forall(i,a,b) for(int i=(a);i<=(b);++i)
#define NFOR(i,a,b) for(int i=(a);i>=(b);--i)
#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define gcd(a,b)   __gcd(a,b)
#define bss binary_search
#define ersort(x)       (sort((x).rbegin(), (x).rend()))
#define rev(v)      (reverse(v.begin(),v.end()))
#define vmax(v)     (*max_element(v.begin(),v.end()))
#define vmin(v)     (*min_element(v.begin(),v.end()))
#define MAX		100050
#define INF		1e9
#define mod     1000000007
#define fi first
#define se second
inline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }
typedef long long 		ll;
typedef unsigned long long	ull;
typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set;
inline int add(int a,int b, int m=mod){a+=b;if(a>=m)a-=m;return a;}
inline int mul(int a,int b, int m=mod){return (int)(((ll)a*(ll)b)%m);}
ll expo(ll base,ll pow){
    ll ans = 1;
    while(pow!=0){
        if(pow&1==1){
            ans = ans*base;
            ans = ans%mod;
        }
        base *= base;
        base%=mod;
        pow/=2;
    }
    return ans;
}
ll inv(ll x){
    return expo(x,mod-2);
}
int expFactor(int n, int p)
{
    int x = p;
    int exponent = 0;
    while ((n/x) > 0)
    {
        exponent += n/x;
        x *= p;
    }
    return exponent;
}
inline int countsetbit(int n)
{
    unsigned int count = 0;
    while (n)
    {
      n &= (n-1) ;
      count++;
    }
    return count;
}
inline int abs(int x){
	if(x<0)
	return -x;
	return x;
}
ll _sieve_size; 
bitset<10000010> bs; 
vector <int> primes; 
void sieve(ll upperbound) { 
	_sieve_size = upperbound + 1; 
	bs.set();
	bs[0] = bs[1] = 0;
	for (ll i = 2; i <= _sieve_size; i++) 
	if (bs[i]) {
		for (ll j = i * i; j <= _sieve_size; j += i) 
			bs[j] = 0;
		primes.push_back((int)i); 
	} 
} 
bool isPrime(ll N) {
if (N <= _sieve_size) return bs[N]; 
for (int i = 0; i < (int)primes.size(); i++)
if (N % primes[i] == 0) return false;
return true;
}
int n,m,val[MAX],wt[MAX];long double cv[MAX];
bool ck(long double mi){
	forall(i,0,n-1){
		cv[i]=val[i]-mi*wt[i];
	}
	sort(cv,cv+n,greater<long double>());
	long double tp=0;
	forall(i,0,m-1){
		tp+=cv[i];
	}
	return (tp>=0);
}
int main(){
	test{
		cin>>n>>m;
		forall(i,0,n-1)
		cin>>val[i]>>wt[i];
		long double lw=0,he=2e5,mi;
		while(he-lw>(1e-8)){
			mi=(lw+he)/2.0;
			if(ck(mi)){
				lw=mi;
			}
			else
			{
				he=mi;
			}
		}
		double as=(he+lw)/2.0;
		printf("%.8lf\n",as);
	}
} 