#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(zzz,a) for(int zzz=0; zzz<(int)(a); zzz++)
#define FORE(zzzz,a) for(int zzzz=1; zzzz<=(int)(a); zzzz++)
#define All(v) (v).begin(), (v).end()
#define zfill(a) memset(&a, 0 , sizeof(a))
#define nfill(a) memset(&a, -1, sizeof(a))
#define S(aaa) scanf("%d",&aaa)
#define pb push_back
#define C(x) cout<<x<<" "
#define CE(test,x) cout<<test<<" : "<<x<<endl

using namespace std;
using namespace __gnu_cxx;

typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;

// computes (ab mod p)
unsigned long long mulModOfLarge(unsigned long long a,unsigned long long b,unsigned long long c)
{
    unsigned long long x=0,y=a%c;
    while(b>0)
    {
      if(b&1) x=(x+y)%c;
    
      y=(y*2)%c; b>>=1;
    }
    return x;  
}

// computes (a^b mod p)
unsigned long long modOfLarge(unsigned long long a,unsigned long long b,unsigned long long c)
{
    unsigned long long x=1,y=a;
    while(b)
    {
      if(b&1)x = mulModOfLarge(x,y,c);
      y=mulModOfLarge(y,y,c);; b>>=1;
    }
    return x;    
}
  
bool MillerRabinTest(unsigned long long p)
{
     if(p<2)return false;		// 1
     if(p==2)return true;		// 2
     if(!(p&1))return false;	// even number
     unsigned long long s=p-1; 
     while(!(s&1))s>>=1;		// finding odd number 'd' of the Miller Rabin Test.
      unsigned long long temp;
      unsigned long long modAns;
     for(int h=0;h<5;h++)
     {
            temp=s;
            unsigned long long a=rand()%(p-1)+1; 	// generating 'a'.
           modAns  = modOfLarge(a,temp,p);			// a^d mod p
            while(modAns!=1 && temp!=p-1 && modAns!=p-1)
            {              
              modAns = mulModOfLarge(modAns,modAns,p);	// x^2 mod p
              temp<<=1;								// varying power...i.e. increasing 'r' from 0 to s-1 
            }
            if(modAns!=p-1 && !(temp&1))            
               return false;                   
     }  
     return true;   
}

int main()
{
    int t;
    ll pow[13]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000LL,100000000000LL,1000000000000LL}; 
    S(t);
    while(t--)
    {
          char s[13];
          scanf("%s",s);
          if(strlen(s)==1)
          {
             printf("2\n");
             continue;
          }
          ll n=0;           
          int pos[13],c=0;
          for(int i=strlen(s)-1;i>0;i--)          
                  if(s[i]=='?')
                  {
                      pos[c++]=i;
                      s[i]='0';
                  }          
          if(s[0]=='?')
          {
              pos[c++]=0;
              s[0]='1';
          }
          int i;
          while(1)
          {
                 int j=0;n=0;
                 for(i=strlen(s)-1;i>-1;i--)                 
                    n+=((s[i]-48)*pow[j++]);
                 if(MillerRabinTest(n)==true)
                 break;
                 i=0;
                 while(i<c && s[pos[i]]=='9')
                 {    
                     s[pos[i]]='0';
                     i++;   
                 }    
                 s[pos[i]]++;               
          }
          printf("%lld\n",n);
    }
return 0;
}