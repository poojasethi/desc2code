    //coding dijkstras in my own style
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
using namespace std;
struct compare
{
    bool operator()(const pair<double,int>& l, const pair<double,int>& r)
    {
        return l.first < r.first;
    }
};
int main()
{
        //cout<<MAX_INPUT;
    
    
    int test;
    cin>>test;
    
    
    while(test--)
    {
        int V;
        cin>>V;
        
        vector<pair<double,int> > adj[10000];
        int a,b;
        double w;
        scanf("%d%d%lf",&a,&b,&w);
        
        while(a!=-1&&b!=-1&&w!=-1)
        {
            adj[a].push_back(make_pair(w,b));
            adj[b].push_back(make_pair(w,a));
            
            scanf("%d%d%lf",&a,&b,&w);
            
            
        }
        
        
        
        double weight[1000]={0};
        bool color[10000]={0};//if the node is reached and shortest distance for it is calculated then there is no need to repush anything for it
        for(int i=1;i<=V;i++)
        {
            weight[i]=-1000000000;
            
            
        }
        
            //start with node a and push all it's vertices in the priority queue...check till the time the priority queue is not empty..if it is still full just go to those nodes which aren't yet colored and color only those nodes where you have reached the minimum way using the priority queue
        int source,dest;
        
        source=1;
        dest=V;
        
            //cin>>source>>dest;
        weight[source]=0;
        color[source]=true;
        priority_queue<pair<double,int>,vector<pair<double, int> >,compare > p1;
        
        for(int i=0;i<adj[source].size();i++)
        {
            p1.push(adj[source][i]);
                //  cout<<p1.top().first;
            
                // p1.top().second+=weight[source];
        }
        
        double min_weight=10000000;
        while(!p1.empty())
        {
            int curr=p1.top().second;
            
            
                //cout<<curr;
                //cout<<"is the node currently"<<endl;
            weight[curr]=p1.top().first;
            
                //cout<<weight[curr]<<endl;
            
            if(weight[curr]<min_weight)
                min_weight=weight[curr];
            
            
            color[curr]=true;
            
            if(p1.top().second==dest)
                break;
            
            p1.pop();
            
            for(int i=0;i<adj[curr].size();i++)
            {
                if(!color[adj[curr][i].second])
                {
                    
                    p1.push(make_pair(adj[curr][i].first, adj[curr][i].second));
                    
                    
                    
                    
                }
                
            }
            
            
            
            
            
        }
        
        
        
            //for(int i=1;i<=3;i++)
            //if(weight[dest]!=1000000000)
        
        if(V!=1)
            printf("%lf\n",min_weight);
        
        else
            printf("0\n");
                //cout<<min_weight<<endl;
        
            //else
            //cout<<-1<<endl;
            //cout<<weight[dest]<<endl;
        
        for(int i=0;i<=V;i++)
        {
            adj[i].clear();
        
        }
        
        
    }
    
    
}
