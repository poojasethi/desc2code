#include <stdio.h>
#include <math.h>
#include <string.h>
#include <iostream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <complex>
#define MAX_N 1001
#define INF -987654321
using namespace std;
typedef long long lld;

int n;

struct Node
{
    double dist;
    vector<int> adj;
    vector<double> weight;
};


struct pq_entry
{
    int node;
    double dist;
    bool operator <(const pq_entry &a) const
    {
        if (dist != a.dist) return (dist < a.dist);
        return (node < a.node);
    }
};

//Dijkstrin algoritam za nalazenje duzina najkracih puteva iz jednog izvora u grafu
//Slozenost: O((V+E)log V)

inline double Dijkstra(int source)
{

    Node graf[MAX_N];
    bool mark[MAX_N] = {0};
    scanf("%d",&n);
    int a,b;
    double w;
    while(1)
    {
        scanf("%d%d%lf",&a,&b,&w);
        if(a==-1 && b==-1 )
        {
            break;
        }
        graf[a-1].adj.push_back(b-1);
        graf[a-1].weight.push_back(w);
        graf[b-1].adj.push_back(a-1);
        graf[b-1].weight.push_back(w);

    }
    priority_queue<pq_entry> pq;
    pq_entry P;
    for (int i=0;i<n;i++)
    {
        if (i == source)
        {
            graf[i].dist = 0;
            P.node = i;
            P.dist = -INF;
            pq.push(P);
        }
        else graf[i].dist = INF;
    }
    while (!pq.empty())
    {
        pq_entry curr = pq.top();
        pq.pop();
        int nod = curr.node;
        double dis = curr.dist;
        for (int i=0;i<graf[nod].adj.size();i++)
        {
            if (!mark[graf[nod].adj[i]])
            {
                int nextNode = graf[nod].adj[i];
                //cout << graf[nod].weight[i] << endl;
                //if (dis + graf[nod].weight[i] > graf[nextNode].dist)
                if (min(dis, graf[nod].weight[i]) > graf[nextNode].dist)
                {
                    graf[nextNode].dist = min(dis, graf[nod].weight[i]);
                    P.node = nextNode;
                    P.dist = graf[nextNode].dist;
                    //cout<<P.dist<<endl;
                    pq.push(P);
                }
            }
        }
        mark[nod] = true;
    }
    return graf[n-1].dist;
}
void solve()
{


    //cout<<graf[3].dist<<endl;
    printf("%.6lf\n",Dijkstra(0));
}
int main()
{


    int t;
    scanf("%d",&t);
    while(t--)
    {
        solve();
    }
}
