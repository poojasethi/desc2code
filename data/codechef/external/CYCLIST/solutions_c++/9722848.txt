//mst cc
//cyclist

#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;
struct edge
{
    int a;
    int b;
    double c;
};
edge g[100000];
int par[100000],ran[100000];
int pfind(int x)
{
    if(par[x]==x)
        return x;
    int rem=pfind(par[x]);
    par[x]=rem;
    return rem;
}
void unite(int x,int y)
{
    int r1=pfind(x);
    int r2=pfind(y);
    if(ran[r1]>ran[r2])
        par[r2]=r1;
    else if(ran[r2]>ran[r1])
        par[r1]=r2;
    else
    {
        par[r2]=r1;
        ran[r1]++;
    }
}
bool comp(edge abc,edge def)
{
    return abc.c>def.c;
}
int main()
{
    int t,n,i,j,q,w;
    double ans,e;
    scanf("%d",&t);
    while(t--)
    {
        ans=1000000000;
        scanf("%d",&n);
        i=0;
        for(i=0;i<n+1;i++)
        {
            par[i]=i;
            ran[i]=0;
        }
        i=0;
        while(true)
        {
            scanf("%d%d%lf",&q,&w,&e);
            if(q==-1&&w==-1&&e==-1)
                break;
            g[i].a=q;
            g[i].b=w;
            g[i].c=e;
            i++;
        }
        int s=i;
        sort(g,g+s,comp);
        for(i=0;i<s;i++)
        {
            int p1=pfind(g[i].a);
            int p2=pfind(g[i].b);
            if(p1!=p2)
            {
                if(g[i].c<ans);
                    ans=g[i].c;
                unite(g[i].a,g[i].b);
            }
            if(pfind(1)==pfind(n))
                break;
        }
        printf("%lf\n",ans);
    }
    return 0;
}
