//kruskals
//max spanning trees
#include<stdio.h>
#include<iostream>
#include<vector>
#include<queue>
#include<set>
#include<algorithm>
#include<cstring>
#include<map>
#include<climits>
#include<math.h>
#define gc            getchar_unlocked
#define pu            putchar_unlocked
#ifndef ONLINE_JUDGE
    #define gc getchar
    #define pu putchar
#endif
#define pb   push_back
#define mp   make_pair
#define f    first
#define s    second
#define ll   long long
#define For(i,j,n)  for(int (i) = (j); i < n; i++)
#define Max  INT_MAX
#define Min  INT_MIN
#define mod  1000000007
using namespace std;
ll power(ll b,ll exp,ll m)
{ll ans=1;b%=m;
 while(exp){if(exp&1) ans=(ans*b)%m;
  exp>>=1;b=(b*b)%m;}
 return ans;}
template <typename T> inline void ifast(T &x)
{ register int c = gc();x = 0;int neg = 0;for(;((c < 48 || c > 57)&&c != '-');c = gc());if(c == '-') neg = 1, c = gc();
  for( ; c > 47 && c < 58 ; c = gc()) x = (x << 1) + (x << 3) + c - 48; if(neg) x = -x; }
  
struct node
{
	int x,y;
	double val;
	node operator ()(int a,int b,double c)
		{
			x=a;
			y=b;
			val=c;
			return *this;
		}
	friend bool operator <(node a,node b) {return a.val>b.val;}
}temp;
int parent[1005];
int find(int x)    //returns the parent of a node
{
	if(parent[x]==x)    
	  	return parent[x];
	return parent[x]=find(parent[x]);	  //path compression	
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    	{
			int a,b,n;
    		double c;
    		//scanf("%d",&n);
    		ifast(n);
    		//scanf("%d%d%lf",&a,&b,&c);
    		ifast(a);
    		ifast(b);
    		scanf("%lf",&c);
    		//ifast(c);
    		vector<node> graph;
			while(a!=-1)
    			{
    				graph.pb(temp(a,b,c));
					//scanf("%d%d%lf",&a,&b,&c);	
					ifast(a);
    				ifast(b);
    				scanf("%lf",&c);
    		//		ifast(c);
				}
			sort(graph.begin(),graph.end());	
			int sz=graph.size();
			For(i,1,n+1)
				parent[i]=i;
			double min;
			for(int i=0;i<sz;i++)
				{
					if(find(1)==find(n))
					  break;
					/*For(i,1,n+1)
						cout<<i<<"->"<<parent[i]<<"  ";
					cout<<"\n";*/	  
					int xset=find(graph[i].x);
					int yset=find(graph[i].y);
					if(xset!=yset)
						{
							parent[xset]=parent[yset];
							min=graph[i].val;
						}
				}
			printf("%lf\n",min);
		}
}
