#include <iostream>
#include <vector>
#include <algorithm>
#include <limits.h>
#include <stdio.h>
#define MAX 1000000
using namespace std;

typedef pair<double,int> PP;         //For MST's item
int arr[MAX], size[MAX],V;          //Union Data structure
vector<PP> adj[MAX];                //For storing Max Spanning Tree
bool visited[MAX];
struct Node {int u,v; double w;};

int root(int i){
    while(arr[i]!=i)
        i=arr[i];
    return i;
}
void UNION(int u,int v){
    int rootU=root(u) ,rootV=root(v);
    if(size[rootU] >= size[rootV])
    {   arr[rootV] = arr[rootU];
        size[rootU] += size[rootV];}
    else
    {   arr[rootU] = arr[rootV];
        size[rootV] += size[rootU];}
}
bool FindSetEquals(int u,int v)
{   return (root(u)==root(v));}

int compare(const Node& a,const Node& b)
{   return a.w>b.w;}

void MST_KRUSKAL(vector<Node> edges)
{   int i,u,v;
    double w;
    for( i=0;i<=V;i++)              //Make_set
        {arr[i]=i; size[i]=1;}
    sort(edges.begin(),edges.end(),compare);

    for(i=0;i<edges.size();i++)
    {
        u=edges[i].u;
        v=edges[i].v;
        w=edges[i].w;

        if(!FindSetEquals(u,v))
            {
                adj[u].push_back(make_pair(w,v));
                adj[v].push_back(make_pair(w,u));
                UNION(u,v);
            }
    }
}

void DFS(int v,double minn){
    visited[v]=true;
    if(v==V)
        {printf("%.6lf\n",minn);
         return;}

    for(int i=0;i<adj[v].size();i++)
        if(visited[adj[v][i].second]==false)
            {
                if(adj[v][i].first<minn)
                    DFS(adj[v][i].second,adj[v][i].first);
                else
                    DFS(adj[v][i].second,minn);
            }
}

int main(){
    int t, i,a,b;
    double w;
    cin>>t;
    Node node;

    while( t-- )
    {   vector<Node> edges;
        cin>>V;
       	for(i=1;i<=V;i++)
       		{adj[i].erase(adj[i].begin(),adj[i].end());
       		 visited[i]=false;}

        while(1)
        {   cin>>a>>b>>w;
            if(a==-1)
            	break;
            node.u=a;node.v=b;node.w=w;
            edges.push_back(node);
        }
	    MST_KRUSKAL(edges);
        DFS(1,500.0);
    }
    return 0;
}
