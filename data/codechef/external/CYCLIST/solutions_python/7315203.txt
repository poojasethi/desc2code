//kruskals
//max spanning trees
#include<stdio.h>
#include<iostream>
#include<vector>
#include<queue>
#include<set>
#include<algorithm>
#include<cstring>
#include<map>
#include<climits>
#include<math.h>

#define pb   push_back
#define mp   make_pair
#define f    first
#define s    second
#define ll   long long
#define For(i,j,n)  for(int (i) = (j); i < n; i++)
#define Max  INT_MAX
#define Min  INT_MIN
#define mod  1000000007
using namespace std;
ll power(ll b,ll exp,ll m)
{ll ans=1;b%=m;
 while(exp){if(exp&1) ans=(ans*b)%m;
  exp>>=1;b=(b*b)%m;}
 return ans;}

struct node
{
	int x,y;
	double val;
	node operator ()(int a,int b,double c)
		{
			x=a;
			y=b;
			val=c;
			return *this;
		}
	friend bool operator <(node a,node b) {return a.val>b.val;}
}temp;
int parent[1005];
vector<node> graph;
int find(int x)    //returns the parent of a node
{
	if(parent[x]==x)    
	  	return parent[x];
	return parent[x]=find(parent[x]);	  //path compression	
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    	{
			int a,b,n;
    		double c;
    		scanf("%d",&n);
    		scanf("%d%d%lf",&a,&b,&c);
    		while(a!=-1)
    			{
    				graph.pb(temp(a,b,c));
					scanf("%d%d%lf",&a,&b,&c);	
				}
			sort(graph.begin(),graph.end());	
			int sz=graph.size();
			For(i,1,n+1)
				parent[i]=i;
			double min;
			for(int i=0;i<sz;i++)
				{
					if(find(1)==find(n))
					  break;
					/*For(i,1,n+1)
						cout<<i<<"->"<<parent[i]<<"  ";
					cout<<"\n";*/	  
					int xset=find(graph[i].x);
					int yset=find(graph[i].y);
					if(xset!=yset)
						{
							parent[xset]=parent[yset];
							min=graph[i].val;
						}
				}
			printf("%lf\n",min);
			graph.clear();	
		}
}
