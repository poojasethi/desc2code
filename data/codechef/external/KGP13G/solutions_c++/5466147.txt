#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<map>
#include<algorithm>
#include<set>
#include<vector>
#include<limits.h>
#include<stack>
#include<queue>
using namespace std;
const double pi=acos(-1.0);
#define pb push_back
#define mk make_pair
#define eps 1e-9
#define ll long long
#define all(v) v.begin(),v.end()
#define MOD 1000000007
#define INF LONG_MAX
#define scani(n) scanf("%d",&n);
#define rep(i,n) for(int i=0;i<n;i++)
#define repp(i,x,y) for(int i=x;i<y;i++)
#define drep(a) sort(a.begin(),a.end());a.erase(unique(a.begin(),a.end()),a.end());
#define print(v) rep(i,v.size())cout<<v[i]<<" ";cout<<endl;
#define printt(v) rep(i,v.size()){rep(j,v[0].size())cout<<v[i][j]<<" ";cout<<endl;}
#define scan(v,n)  rep(i,n)cin>>v[i];
#define ITER(it,a) for(typeof(a.begin()) it = a.begin(); it!=a.end(); it++)
#define scann(v,n,m) rep(i,n){rep(j,m)cin>>v[i][j];}
//vector < vector<int> > v(n,vector<int>(m,0));
struct trienode
{
	int value;
	struct trienode* edge[26];
};
struct trie
{
	struct trienode* root;
	int count;
}tree;
struct trienode * getnode()
{
	struct trienode* temp=(struct trienode *)malloc(sizeof(struct trienode));
	temp->value=0;
	rep(i,26)
		temp->edge[i]=NULL;
		return temp;
}
void init(struct trie* tree)
{
	tree->count=0;
	tree->root=getnode();
}

void insert(struct trie * tree,char str[])
{
	struct trienode * pcrawl=tree->root;
	tree->count++;
	ll int index;
	rep(i,strlen(str))
	{
		index=str[i]-'a';
				if(pcrawl->edge[index]==NULL)
					pcrawl->edge[index]=getnode();
				pcrawl=pcrawl->edge[index];
	}
	pcrawl->value=tree->count;
}
int search(struct trie * tree,char * str)
{
	struct trienode * pcrawl=tree->root;

	ll int index;
	rep(i,strlen(str))
	{
		index=str[i]-'a';
				if(pcrawl->edge[index]==NULL)
					return 0;
				pcrawl=pcrawl->edge[index];
	}
	return ((pcrawl!=NULL) && (pcrawl->value) );
}

ll int seq[2000];
ll int m;
vector< int > v[10];
int vis[10005],dp[10005];

ll int dfs(ll int ind,struct trienode * root);
ll int dfsdriver(ll int ind)
{
	if(ind>=m)
		return 0;
	
	if(dp[ind]!=-1)
		return dp[ind];
	ll int res=INF;
		struct trienode * root=tree.root;
	res=dfs(ind,root);
	dp[ind]=res;
	return res;
}
ll int dfs(ll int ind,struct trienode * root)
{

	if(ind>=m)
	{
		if(root->value)
		return 1;
		else
		return INF;
	}
	ll int res=INF;
	if(root->value)
		res=dfsdriver(ind)+1;
	ll int p=seq[ind];
	rep(i,v[p].size())
	{
		ll int l=v[p][i];
		if(root->edge[l]==NULL)continue;
		res=min(res,dfs(ind+1,root->edge[l]));
	}
	return res;
}
int main()
{
 int t;
 scanf("%d",&t);
 
 for(ll int y=1;y<=t;y++)
 {
  ll int n;
  cin>>n;
  char str[100];
 
  init(&tree);
  rep(i,10005)
  	dp[i]=-1;
  rep(i,n)
	{
	  	scanf("%s",str);
	  	insert(&tree,str);
	  	//cout<<str<<endl;
	  }
	  char ch[10];
	   //cout<<"help"<<endl;
	rep(i,10)
	{
		ll int in,cnt;
		cin>>in>>cnt;
		rep(k,cnt)
		{
			scanf("%s",ch);
			v[in].pb((ch[0]-'a'));
		}
	}
	
		/*rep(i,10)
		{
				rep(j,v[i].size())
				{
					cout<<v[i][j]<<" ";
				}
				cout<<endl;
		}*/
	
	cin>>m;

	rep(i,m)
		cin>>seq[i];
		
	ll int ans;
	ans=dfsdriver(0);
	if(ans==LONG_MAX)
		ans=-1;
		
	
		
		
	cout<<"Case "<<y<<": "<<ans<<endl;


 }
 return 0;
}
