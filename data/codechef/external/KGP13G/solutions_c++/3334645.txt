#include <cstring>
#include <iostream>
#include <stdio.h>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#include <map>
#include <vector>
#include <list>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bits/stdc++.h>
#include <string>
#include <cmath>
using namespace std;
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define ll long long
#define int long long
#define ff first
#define ss second
#define inf  1e9
#define infll 1e18
#define pr(x) printf("%lld\n",x)
#define prs(x) printf("%lld ",x)
#define sc(x) scanf("%lld",&x)
#define trc(x) cout << #x << " = " << x << endl
#define pii pair<int,int>
#define fr(i,a,n) for(i=a;i<n;i++)
#define fd(i,a,n) for(i=n;i>a;i--)
#define fiv(v) for(i=0;i<v.size();i++)
#define clr(a) memset(a,0,sizeof(a))
#define fill(a,v) memset(a,v,sizeof(a))
#define all(a) a.begin(),a.end()
#define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++)
ll dp[1005];
set<string>st;
map<char,int>map1;
vector<char>c1;
ll solve(ll idx,ll n,string s)
{
   if(idx>=n)return 0;
   if(dp[idx]!=-1)return dp[idx];
   ll res=mod,f=0;
   if(st.count(s))
    f=1;
   else f=0;
   res=min(res,f+solve(idx+1,n,s+c1[idx]));
   return res;
}
main()
{
    int i,n,j,k,l,m,t,c=0,ans,x;
    sc(t);
    fr(x,1,t+1)
    {
      sc(n);
      st.clear();
      string s;
      vector<string>v;
      fr(i,0,n)
      {
          cin>>s;
          v.pb(s);
      }
      fr(i,0,10)
      {
          sc(l);
          sc(k);
          char ch;
          fr(j,0,k)
          {
              cin>>ch;
              map1[ch]=i;
          }
      }

      fr(i,0,v.size())
      {
         s=v[i];
         fr(j,0,s.size())
         {
             s[j]=map1[s[j]]+'0';
         }
         st.insert(s);
      }
      sc(n);
      c1.clear();
      fill(dp,0);
      fr(i,0,n)
      {
         char ch;
         cin>>ch;
         c1.pb(ch);
      }
     for(i=1;i<=n;i++)
      {
          string s1="";
          dp[i]=mod;
          for(j=0;j<i;j++)
          {
              s1+=string(1,c1[j]);
          }
          for(j=0;j<i;j++)
          {
             if(st.count(s1)&&dp[j]!=mod)
                dp[i]=min(dp[i],dp[j]+1);
             s1.erase(s1.begin());
          }
      }
     // c=solve(0,n,"");
     c=((dp[n]==mod)?0:dp[n]);
      printf("Case %lld: %lld\n",x,(c==0)?-1:c);

    }
    return 0;
}
