#include <iostream> 
#include<bits/stdc++.h>
typedef long long int ll; 
using namespace std;
/* naive solution is - use a circular ll and starting at first keep moving till you reach kth node 
    and then remove it . now k+1 is current element and now count k from here ..repeat till there is only
    onr node left .. which indicates the survivor
    */ 
/*josephus recursion is 
   if(n==1) return 1; 
   else return josephus((n-1,k)+(k-1) ) %n + 1; 
   the k remains constant .. so only 1-d array as per the value of n 
  */ 
int f[501]; 
 int n , k; 
/*
int josephus(int n , ll k)
{
	if(f[n]!=-1)
	return f[n]; 
	else if(n==1)
	return f[1]=1;
	else 
	
	//for(i=2;i<=n;i++)
	return f[n] = (josephus(n-1,k)+k-1) % n + 1; 
	//return f[n]; 
}
*/ 
int josephus(int n,int k ,int m)
{
	if(f[n]!=-1)
	return f[n]; 
	else if(n==1)
	return f[1]=1; 
	//for(int i=2;i<=n;i++)
	else 
	return f[n] = (josephus(n-1,k ,m+1)+k*m -1) % n + 1; 
}
int main() {
	int t; 
	//ll k; 
	scanf("%d",&t); 
	while(t--)
	{
	scanf("%d %d",&n,&k); 
	memset(f,-1,sizeof(f)); 
	printf("%d\n",josephus(n,k,1)); 
	}
	
	return 0;
}