#include <bits/stdc++.h>
using namespace std;
#define ll long long int
#define inf 20000000000000ll
#define ppi pair<ll,ll>
#define F first
#define S second
struct query{
int a,b,d;
ll ans,c;
};
struct tree{
ll l,r,sum,ans;
};
query Q[200010];
tree T[800100];
ppi A[200010];
bool comp(query q1,query q2)
{
    return q1.c<q2.c;
}
bool comp2(ppi p1,ppi p2)
{
    return p1.F<p2.F;
}
bool comp3(query q1,query q2)
{
    return q1.d<q2.d;
}
void combine(ll i)
{
    T[i].sum=T[2*i].sum+T[2*i+1].sum;
    T[i].l=max(T[2*i].l,T[2*i].sum+T[2*i+1].l);
    T[i].r=max(T[2*i+1].r,T[2*i+1].sum+T[2*i].r);
    T[i].ans=max(T[2*i].ans,max(T[2*i+1].ans,T[2*i].r+T[2*i+1].l));
}
void treenode(ll i,ll val)
{
    T[i].sum=val;
    T[i].l=T[i].r=T[i].ans=val;
}
void build_tree(int i, int a, int b)
{
  	if(a > b)
        return;
  	if(a == b)
  	{
  	    treenode(i,-inf);
		return;
	}
	build_tree(i*2, a, (a+b)/2);
	build_tree(i*2+1,1+(a+b)/2, b);
	combine(i);
}
tree query_tree(int x, int a, int b, int i, int j)
{
    if(a >= i && b <= j)
		return T[x];
    if(i>((a+b)/2))
        return query_tree(2*x+1,1+((a+b)/2),b,i,j);
     if(j<=((a+b)/2))
        return query_tree(2*x,a,(a+b)/2,i,j);
    tree q1,q2,q3;
	q1=query_tree(x*2, a, (a+b)/2, i, j);
	q2=query_tree(1+x*2, 1+(a+b)/2, b, i, j);
	q3.sum=q2.sum+q1.sum;
	q3.l=max(q1.l,q1.sum+q2.l);
	q3.r=max(q2.r,q2.sum+q1.r);
	q3.ans=max(q1.ans,max(q2.ans,q1.r+q2.l));
	return q3;
}

void update_tree(int x, int a, int b, int i, int j, ll val)
{
	if(a > b || a > j || b < i)
		return;
  	if(a >= i && b <= j) {
    		treenode(x,val);
    	return;
	}
	update_tree(x*2, a, (a+b)/2, i, j, val);
	update_tree(1+x*2, 1+(a+b)/2, b, i, j,val);
	combine(x);
}
int main()
{
    int t,n,q,i,j,l,r;
    ll x;
    tree Z;
        scanf("%d %d",&n,&q);
        for(i=0;i<n;i++)
        {
            scanf("%lld",&A[i].F);
            A[i].S=i;
           // update_tree(1,0,n-1,i,i,-inf);
        }
        for(i=0;i<q;i++)
        {
            scanf("%d %d %lld",&l,&r,&x);
            Q[i].a=l-1;
            Q[i].b=r-1;
            Q[i].c=x;
            Q[i].d=i;
        }
        build_tree(1,0,n-1);
        sort(A,A+n,comp2);
        sort(Q,Q+q,comp);
        j=0;
        for(i=0;i<q;i++)
        {
            for(;j<n;j++){
                if(A[j].F<=Q[i].c)
                    update_tree(1,0,n-1,A[j].S,A[j].S,A[j].F);
                else
                    break;
            }
            Z=query_tree(1,0,n-1,Q[i].a,Q[i].b);
            Q[i].ans=Z.ans;
        }
        sort(Q,Q+q,comp3);
        for(i=0;i<q;i++){
                if(Q[i].ans==-inf)
                printf("xx\n");
        else
        printf("%lld\n",Q[i].ans);
    }
}
