#include <bits/stdc++.h>
#define lli long long
#define INF 200000000000001LL
#define MAX 200005

using namespace std;

pair <lli, int> A[MAX];
lli ans[MAX];

struct query {
	int l,r,id;
	lli x;
	query() { }
	query(int l, int r, lli x, int id)
	{
		this->l = l, this->r = r, this->x = x, this->id = id;
	}
}v[MAX];

struct node {
	lli ans;
	lli tot_sum;
	lli pre_sum;
	lli suf_sum;
	node() { }
	node(lli ans, lli tot_sum, lli pre_sum, lli suf_sum) {
		this->ans = ans, this->tot_sum = tot_sum, this->pre_sum = pre_sum, this->suf_sum = suf_sum;
	}
}tree[4*MAX];

bool cmp(query a, query b)
{
	return a.x < b.x;
}

node combine(node a, node b)
{
	node ret;
	ret.tot_sum = a.tot_sum + b.tot_sum;
	ret.pre_sum = max(a.pre_sum, a.tot_sum + b.pre_sum);
	ret.suf_sum = max(a.suf_sum + b.tot_sum, b.suf_sum);
	ret.ans = max(a.suf_sum + b.pre_sum, max(a.ans, b.ans));
	return ret;
}

void build(int where, int left, int right)
{
	if ( left > right ) return;
	if ( left == right ) {
		tree[where] = node(-INF, -INF, -INF, -INF);
		return;
	}
	int mid = (left + right)/2;
	build(where*2, left, mid);
	build(where*2 + 1, mid + 1, right);
	tree[where] = node(-INF, -INF, -INF, -INF);
}

void update(int where, int left, int right, int idx, lli val)
{
	if ( left > right || left > idx || right < idx ) return;
	if ( left == right ) {
		tree[where] = node(val, val, val, val);
		return;
	}
	int mid = (left + right)/2;
	update(where*2, left, mid, idx, val);
	update(where*2 + 1, mid + 1, right, idx, val);
	tree[where] = combine(tree[where*2], tree[where*2 + 1]);
}

node query_tree(int where, int left, int right, int i, int j)
{
	if ( left > right || left > j || right < i ) return node(-INF, -INF, -INF, -INF);
	if ( left >= i && right <= j ) return tree[where];
	int mid = (left + right)/2;
	node ans = combine( query_tree(where*2, left, mid, i, j), query_tree(where*2 + 1, mid + 1, right, i, j));
	return ans;
}

int main()
{
	int n, q, l, r, idx = 0;
	lli x;
	cin >> n >> q;
	assert(n >= 1 && n <= 200000);
	assert(q >= 1 && q <= 200000);
	for ( int i = 0; i < n; i++ ) cin >> A[i].first, A[i].second = i, assert(A[i].first >= -100000000 && A[i].first <= 100000000);
	
	sort(A, A + n);
	
	for ( int i = 0; i < q; i++ ) {
		cin >> l >> r >> x;
		assert(l >= 1 && l <= n);
		assert(r >= 1 && r <= n);
		assert(l <= r);
		assert(x >= -100000000 && x <= 100000000);
		l--, r--;
		v[i] = query(l, r, x, i);
	}
	
	sort(v, v + q, cmp);
	
	build(1, 0, n - 1);
	
	for ( int i = 0; i < q; i++ ) {
		while ( idx < n && A[idx].first <= v[i].x ) {
			update(1, 0, n - 1, A[idx].second, A[idx].first);
			idx++;
		}
		ans[v[i].id] = query_tree(1, 0, n - 1, v[i].l, v[i].r).ans;
	}
	
	
	for ( int i = 0; i < q; i++ ) {
		if ( ans[i] > -INF ) cout << ans[i] << endl;
		else cout << "xx" << endl;
	}
	return 0;
}