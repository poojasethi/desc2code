#include <assert.h> 
#include <ctype.h> 
#include <float.h> 
#include <math.h> 
#include <stdio.h> 
#include <string> 
#include <stdlib.h> 
#include <time.h> 
#include <algorithm> 
#include <numeric> 
#include <functional> 
#include <utility> 
#include <vector> 
#include <list> 
#include <set> 
#include <map> 
#include <queue> 
#include <stack> 
#include <sstream> 
#include <iostream> 
#include <memory.h>

using namespace std; 

const int MAX_SIZE = 20000;
static char input[MAX_SIZE];
struct Scanner
{
	Scanner()
	{
		int sz = fread(input, 1, sizeof(input), stdin);
		curPos = input;
	}
	int nextInt()
	{
		int gap = input + MAX_SIZE - curPos;
		if (gap < 100)
		{
			memcpy(input, curPos, gap);
			fread(input + gap, 1, sizeof(input) - gap, stdin);
			curPos = input;

		}
		while (*curPos < '0') curPos++;

		int res = 0;
		while (*curPos >= '0') 
		{
			res = res * 10 + (*curPos) - '0';
			curPos++;
		}
		return res;
	}
	char* curPos;
};

const int MOD = 1000000007;

int dp[100002];
int sum[100002];

int main(int argc, char* argv[])
{
#ifndef ONLINE_JUDGE
	freopen("test.in", "r", stdin);
#endif

	Scanner sc;
	int T = sc.nextInt();

	while (T--)
	{
		int N = sc.nextInt();
		int Y = sc.nextInt();

		fill(dp, dp + Y + 1, 0);
		dp[0] = 1;

		int last = 0;
		int first = 0;

		for (int i = 0; i < N; i++)
		{
			int from = sc.nextInt();
			int to = sc.nextInt();

			last += to;
			if (last > Y)
				last = Y;

			int f = first;

			first += from;
			if (first >= Y + 1)
				first = Y + 1;

			for (int j = 0; j <= last; j++)
			{
				int& s = sum[j + 1];
				s = sum[j] + dp[j];
				if (s > MOD) s -= MOD;
			}

			for (int j = first; j <= last; j++)
			{
				int r = sum[j - from + 1];
				
				if (j - to >= 0)
				{
					r -= sum[j - to];

					if (r < 0) r += MOD;
				}
				dp[j] = r;
			}

			for (int j = f; j < first; j++)
				dp[j] = 0;

		}

		printf("%d\n", first > Y ? 0 : dp[Y]);
	}

		
	return 0;
}

