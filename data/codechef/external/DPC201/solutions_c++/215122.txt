#include<iostream>
#include<algorithm>
#include<iterator>
#include<map>
#include<vector>
#include<list>
#include<set>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<functional>
#include<utility>
#include<fstream>
#include<iosfwd>
#include<sstream>
#include<iomanip>
#include<string>
#include<cmath>
#include<cstring>
#include<ctime>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<cassert>
#include<complex>
#include<numeric>
 
using namespace std;
 
#define DEBUGGING              0
#define VAR(x,a)               __typeof(a) x(a)
#define FORD(i,a,b)            for(int i = (int)a,_b = (int)b;i>=(_b);--i)
#define FOREACH(it,v)          for(VAR(it,(v).begin());it!=(v).end();++it)
#define FOR(i,a,b)             for(int i=(int)(a),_b = (int)b;i<(int)(_b);++i)
#define REP(i,n)               FOR(i,0,n)
#define REPD(i,n)              FORD(i,n,0)
#define Size()                 size()
#define PushBack               push_back
#define PushFront              push_front
#define MakePair               make_pair
#define PopBack                pop_back
#define PopFront               pop_front
#define BitCount               __builtin_popcount
#define V(x)                   vector< x >
#define INF                    100000000
#define INFLL                  10000000000000000LL
#define First                  first
#define Second                 second
 
typedef V(int)                 VI;
typedef V(VI)                  VII;
typedef V(string)              VS;
typedef unsigned long long     ULL;
typedef long long              LL;
typedef pair<int,int>          PI;
typedef unsigned long          UL;
 
/*
** Description : ACM ICPC Kanpur Asia 2008 : Problem Apple Trees
** Verdict : Accepted at ACM ICPC Live Archive UVa
** Time Taken : 1.6 Seconds
*/
 
pair<pair<int,int>,int> GetSolution(vector< vector<int> > V);
pair<int,int> GetSlope(vector< vector<int> > V,int x1,int y1,int x2,int y2);
int GetTrees(vector< vector<int> > V,int Row,int Col);
int GetGcd(int x,int y);
int IsTree(vector< vector< pair<int,int> > > Slope,int Row,int Col,int x,int y,vector< vector<int> > V);
 
int main()
{
    int M,N;
    scanf("%d %d",&M,&N);
    while(M!=0) {
        vector< vector<int> > V;
        vector<int> X;
        for(int i=0;i<M;++i)
            V.PushBack(X);
        int x;
        for(int i=0;i<M;++i) {
            for(int j=0;j<N;++j) {
                scanf("%d",&x);
                V[i].PushBack(x);
            }
        }
        pair< pair<int,int>,int > Solution=GetSolution(V);
        printf("%d %d %d\n",Solution.First.First,Solution.First.Second,Solution.Second);
        scanf("%d %d",&M,&N);
    }
    return 0;
}
pair<pair<int,int>,int> GetSolution(vector< vector<int> > V)
{
    vector< vector< int > > Trees(V.size(),vector<int>(V[0].size()));
    for(int i=0;i<V.size();++i)
        for(int j=0;j<V[0].size();++j)
            Trees[i][j]=GetTrees(V,i,j);
    int MaxTrees=0;
    int MaxHeight=0;
    for(int i=0;i<Trees.size();++i)
        for(int j=0;j<Trees[0].size();++j)
            if(Trees[i][j]>MaxTrees)
                MaxTrees=Trees[i][j];
    for(int i=0;i<V.size();++i)
        for(int j=0;j<V[0].size();++j)
            if(Trees[i][j]==MaxTrees)
                if(V[i][j]>MaxHeight)
                    MaxHeight=V[i][j];
    int R,C;
    int Flag=0;
    int MonarchRow,MonarchCol;
    for(int i=0;i<V.size();++i)    
        for(int j=0;j<V[0].size();++j)
            if(Trees[i][j]==MaxTrees&&V[i][j]==MaxHeight) {
                MonarchRow=i+1;
                MonarchCol=j+1;
                ++Flag;
            }
    if(Flag>=2) {
        R=C=0;
    }
    else {
        R=MonarchRow;
        C=MonarchCol;
    }
    pair<int,int> P=MakePair(R,C);
    pair< pair<int,int>,int > S=MakePair(P,MaxTrees);
    return S;
}
int GetTrees(vector< vector<int> > V,int Row,int Col)
{
    vector< vector< pair<int,int> > > Slope;
    pair<int,int> TempP;
    vector< pair<int,int> > TempV;
    for(int i=0;i<V[0].size();++i)
        TempV.PushBack(TempP);
    for(int i=0;i<V.size();++i)    
        Slope.PushBack(TempV);
    for(int i=0;i<V.size();++i)
        for(int j=0;j<V[0].size();++j)
            Slope[i][j]=GetSlope(V,Row,Col,i,j);
    Slope[Row][Col].First=Slope[Row][Col].Second=1;
    vector< vector<int> > Tree(V.size(),vector<int> (V[0].size()));
    for(int i=0;i<V.size();++i)
        for(int j=0;j<V[0].size();++j)
            Tree[i][j]=IsTree(Slope,Row,Col,i,j,V);
    int Trees=0;
    for(int i=0;i<V.size();++i)
        for(int j=0;j<V[0].size();++j)
            Trees+=Tree[i][j];
    return Trees;
}
pair<int,int> GetSlope(vector< vector<int> > V,int x1,int y1,int x2,int y2)
{
    int Y=V[x2][y2]-V[x1][y1];
    int Sign;
    if(Y>0) 
        Sign=1;
    else
        Sign=-1;
    Y=Y*Y*Sign;
    int X=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
    pair<int,int> P=MakePair(Y,X);
    return P;
}
int IsTree(vector< vector< pair<int,int> > > Slope,int Row,int Col,int x,int y,vector< vector<int> > V)
{
    if(x==Row&&y==Col)
        return 0;
    if(V[x][y]==0)
        return 0;
    int Q=x-Row;
    if(Q<0) 
        Q=-Q;
    int R=y-Col;
    if(R<0)
        R=-R;
    int Gcd=GetGcd(Q,R);
    int Dx=(x-Row)/Gcd;
    int Dy=(y-Col)/Gcd;
    int K=Gcd;
    int Flag=1;
    for(int i=1;i<K;++i) {
        if((Slope[x][y].First)*(Slope[Row+i*Dx][Col+i*Dy].Second)<=(Slope[Row+i*Dx][Col+i*Dy].First)*(Slope[x][y].Second)) {
            Flag=0;
            break;
        }
    }
    return Flag;
}
int GetGcd(int x,int y)
{
    if(y==0)
        return x;
    else 
        return GetGcd(y,x%y);
}