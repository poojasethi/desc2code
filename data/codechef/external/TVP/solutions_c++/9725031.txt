#include<bits/stdc++.h>
using namespace std;
class RMQ{
public:
	int N;
	vector<int> v;
	vector<vector<int> > A;
	RMQ(int N):N(N), A(20){}
	void build(){
		for(int i = 0;i < N;++i){
			A[0].push_back(v[i]);
		}
		for(int p = 1;(1 << p) <= N;++p){
			for(int i = 0;(i + (1 << p) - 1) < N;++i){
				A[p].push_back(max(A[p - 1][i], A[p - 1][i + (1 << (p - 1))]));
			}
		}
		// for(int p = 0;p < 20;++p){
		// 	for(int i = 0;i < A[p].size();++i){
		// 		cout << A[p][i] << " ";
		// 	}
		// 	cout << "\n";
		// }
	}
	int query(int L, int R){
		int ans = -1;
		while(L <= R){
			int len = (R - L) + 1;
			int p = 0;
			while(len > 0){
				++p;
				len >>= 1;
			}
			--p;
			ans = max(ans, A[p][L]);
			L += (1 << p);
		}
		return ans;
	}
};
const int MAXN = 1e5 + 10;
const int INF  = 1e7;
int cap[MAXN];
int ans[MAXN];
vector<pair<int, int> > pairList;
int main(){
	int N, M;
	cin >> N >> M;
	for(int i = 0;i < N;++i){
		scanf("%d", &cap[i]);
	}
	for(int i = 0;i < M;++i){
		int u, v;
		scanf("%d%d",&u,&v);
		--u;
		--v;
		pairList.push_back(make_pair(u, v));
	}
	RMQ myMaxR(N);
	for(int i = 0;i < N;++i){
		myMaxR.v.push_back(INF);
	}
	int Q;
	cin >> Q;
	for(int query = 0;query < Q;++query){
		int ind;
		scanf("%d",&ind);
		--ind;
		--cap[ind];
		if(cap[ind] == 0){
			myMaxR.v[ind] = query;
		}
	}
	myMaxR.build();
	memset(ans, 0, sizeof ans);
	for(int i = 0;i < M;++i){
		int u = pairList[i].first;
		int v = pairList[i].second;
		int cur;
		if((cur = myMaxR.query(u, v)) != INF)
			++ans[cur];
	}
	for(int i = 1;i < Q;++i){
		ans[i] += ans[i - 1];
	}
	for(int i = 0;i < Q;++i){
		printf("%d\n", ans[i]);
	}
	return 0;
}					