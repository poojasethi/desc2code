#include <stdio.h>
#include<algorithm>
#include<iostream>
#define n 10000000
using namespace std;
 
struct list
{
  	int left,right,index,ans,K;
}bit[n+1];
 
int tree[n+1];
int prime[n+1];
 
int gcd(int a,int b)
{
	return b==0?a:gcd(b,a%b);
}
void update(int idx)
{
	while(idx<=n)
	{
		tree[idx]+=1;
		idx+=(idx&-idx);
	}
}
bool comp(const list &lhs,const list &rhs)
{
	return lhs.K<rhs.K;
}
 
bool comps(const list &lhs,const list &rhs)
{
	return lhs.index<rhs.index;
}
 
int query(int idx)
{
	int sum=0;
	while(idx>0)
	{
		sum+=tree[idx];
		idx-=(idx&-idx);
	}
	return sum;
}
 
int main()
{
	int q;
	cin>>q;
	
	for(int i=2;i<=n;i++)
	prime[i]=1;
	
	for(int i=0;i<q;i++)
	{
	scanf("%d%d%d",&bit[i].left,&bit[i].right,&bit[i].K);
	bit[i].index=i;
        bit[i].ans=bit[i].right-bit[i].left+1;
	}
	
	sort(bit,bit+q,comp);
	
	int count=0;
	int curr=0;
	for(int j=2;j<=n;j++)
	{
	   if(prime[j]==0)
	   continue;
	  
	  for(int i=j;i<=n;i+=j)
	  {
	  	if(prime[i]==1)
	  	{
	  	update(i);
	  	prime[i]=0;
	  	}
	  }
	  count++;
	  
	   while(curr<q&&bit[curr].K==count)
	   {
	   bit[curr].ans=query(bit[curr].right)-query(bit[curr].left-1);
	   curr++;
	   }
	}
	sort(bit,bit+q,comps);
	for(int i=0;i<q;i++)
	{
		int x=gcd(bit[i].ans,bit[i].right-bit[i].left+1);
		bit[i].ans/=x;
		int w=bit[i].right-bit[i].left+1;
		w/=x;
		printf("%d/%d\n",bit[i].ans,w);
		
	}
	return 0;
} 