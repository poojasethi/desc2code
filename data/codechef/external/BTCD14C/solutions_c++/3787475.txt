#include<stdio.h>
#include<algorithm>

using namespace std;

inline int read_int(){register char c=getchar_unlocked();while(c<'0' || c>'9')c=getchar_unlocked();int ret=0;while(c>='0'&&c<='9'){ret=(ret<<3)+(ret<<1)+c-48;c=getchar_unlocked();}return ret;}

inline void fastwriten(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)putchar_unlocked(snum[i--]);putchar_unlocked('\n');}


inline void fastwrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)putchar_unlocked(snum[i--]);putchar_unlocked('/');}


int primes[664578];
bool composite[9999992];
bool mark[10000001];

void sieve(int n)
{
    int i,j;
    composite[1]=1;
    for(j=4;j<=n;j+=2)
        composite[j]=1;
    for(i=3;i*i<=n;i+=2)
    {
        if(composite[i]==0)
        {
            for(j=i*i;j<=n;j+=i)
                composite[j]=1;
        }
    }
    i=0;
    primes[i++]=2;
    for(j=3;j<=n;j+=2)
    {
        if(!composite[j])
            primes[i++]=j;
    }
}

int tree[10000001];

void update(int idx,int val,int N)
{
    while(idx<=N)
    {
        tree[idx]+=(long long int)val;
        idx+=idx&-idx;
    }
}

int query(int idx)
{
    int sum=0;
    while(idx>0)
    {
        sum+=tree[idx];
        idx-=idx&-idx;
    }
    return sum;
}

struct inp
{
    int l,r,k,ans,in;
}que[100010];

int compare_k(struct inp a,struct inp b)
{
    return a.k<b.k;
}

int compare_in(struct inp a,struct inp b)
{
    return a.in<b.in;
}

int gcd(int a,int b)
{
    if(b==0)
        return a;
    return gcd(b,a%b);
}

int main()
{
    int q,n=0;
    q=read_int();
    for(int i=0;i<q;i++)
    {
        que[i].in=i;
        que[i].l=read_int();
        que[i].r=read_int();
        que[i].k=read_int();
        if(que[i].r>n)
            n=que[i].r;
    }
    sort(que,que+q,compare_k);
    sieve(n);

    int pid=0;
    int prevk=que[0].k;
    for(pid=0;pid<prevk;pid++)
    {
        if(primes[pid]==0)
            break;
        for(int i=primes[pid];i<=n;i+=primes[pid])
        {
            if(mark[i]==0)
            {
                mark[i]=1;
                update(i,1,n);
            }
        }
    }
    que[0].ans=query(que[0].r)-query(que[0].l-1);
    for(int qno=1;qno<q;qno++)
    {
        if(que[qno].k==prevk)
        {
            que[qno].ans=query(que[qno].r)-query(que[qno].l-1);
            continue;
        }
        prevk=que[qno].k;
        for(;pid<prevk;pid++)
        {
            if(primes[pid]==0)
            break;
            for(int i=primes[pid];i<=n;i+=primes[pid])
            {
                if(mark[i]==0)
                {
                    mark[i]=1;
                    update(i,1,n);
                }
            }
        }
        que[qno].ans=query(que[qno].r)-query(que[qno].l-1);
    }
    sort(que,que+q,compare_in);
    for(int qno=0;qno<q;qno++)
    {
        int gcdiv=gcd(que[qno].ans,que[qno].r-que[qno].l+1);
        fastwrite(que[qno].ans/gcdiv);
        fastwriten((que[qno].r-que[qno].l+1)/gcdiv);
    }
    return 0;
}
