def millerRabin(n):
	# Returns true if probable prime, false if composite
	bases     = [2,3,5,7,11,13,17,19,23]
	nm1       = n-1
	m         = nm1
	d         = 0

	if n in bases:
		return True
	if n < 2:
		return False

	while not m&1:
		d    += 1
		m   >>= 1

	for a in bases:
		done_for_base = False

		b   = pow(a,m,n)
		if b == 1 or b == nm1 :
			#done_for_base = True
			continue
		for k in range(d-1):
			b = pow(b,2,n)
			if b == 1:
				return False
			elif b == nm1:
				done_for_base = True
				break
		if not done_for_base:
			return False
	return True

def valAt(x,y):
	if x>y:
		if x+y > 0:
			n  = 4*x*x - 3*x + y
		else :
			n  = 4*y*y - 3*y + x
	else:
		if x+y > 0:
			n  = 4*y*y -  x - y
		else :
			n  = 4*x*x -  y - x
	return n

def solveCase(x,y):
	r    = 0
	n    = valAt(x,y)
	if millerRabin(n):
		return r
	while True:
		r  += 1
		for k in range(r):
			n1  = valAt(x + r-k, y + 0-k)
			n2  = valAt(x + 0-k, y - r+k)
			n3  = valAt(x - r+k, y + 0+k)
			n4  = valAt(x + 0+k, y + r-k)
			for n in [n1,n2,n3,n4]:
				if millerRabin(n):
					return r

def main():
	T  = int(raw_input(''))
	for t in range(T):
		x,y = [ int(i) for i in raw_input().split() ]
		ans = solveCase(x,y)
		print ans


main()
