#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <vector>
#include <cstdio>
#include <limits>
#include <limits.h>
using namespace std;
 
/** get number by coordinate */
inline long long getNumber(long long x, long long y)
{
if (x == 0 && y == 0)
return 0;
long long xL = (x > 0 ? (x << 1) : (-x) * 2 + 1);
long long yL = (y > 0 ? (y << 1) : (-y) * 2 + 1);
 
long long L = max(xL, yL);
long long low = -(L - 1) / 2;
long long high = L / 2;
 
long long ans = (L - 1) * (L - 1) - 1;
if ((L & 1) == 0)
{
if (x == high)
return ans + (y - low + 1);
else
return ans + (high - x + L);
}
else
{
if (x == low)
return ans + (high - y + 1);
else
return ans + (x - low + L);
}
}
 
class PrimeJudger
{
public:
const static int bits = 19, mask = (1<<bits) - 1;
static unsigned long long mul(unsigned long long x, unsigned long long y, unsigned long long M)
{
if (x <= UINT_MAX && y <= UINT_MAX) return x * y % M;
unsigned long long rslt = y * (x & mask) % M;
while (x >>= bits) rslt = (rslt + (y = (y << bits) % M) * (x & mask)) % M;
return rslt;
}
 
static int mtest(unsigned long long n, unsigned long long a) {
unsigned long long s, t, nmin1 = n - 1;
int r;
for (s = nmin1, r = 0; !(s & 1); s >>= 1, r++) ;
for(t = a; s >>= 1; )
{
a = mul(a, a, n);
if (s & 1) t = mul(t, a, n);
}
if (t == 1 || t == nmin1) return 1;
while (--r) if ((t = mul(t, t, n)) == nmin1) return 1;
return 0;
}
 
static bool isPrime(unsigned long long n) {
if(n<29) return n==2 || n==3 || n==5 || n==7 || n==11 || n==13 || n==17 || n==19 || n==23;
if(!(n&1 && n%3 && n%5 && n%7 && n%11 && n%13 && n%17 && n%19 && n%23)) return 0;
return mtest(n, 2) && mtest(n, 1215) &&
(n==17431 || mtest(n, 34862) && (n==3281359 || mtest(n, 574237825)));
}
};
 
void deal()
{
int x, y;
scanf("%d%d", &x, &y);
 
long long nowNum = getNumber(x, y);
if (PrimeJudger::isPrime(nowNum))
{
printf("0\n");
return;
}
 
long long k = 0;
long long nx, ny;
while (true)
{
k++;
for (long long i = -k; i <= k; ++i)
{
long long absi = i;
if (absi < 0) absi = -absi;
nx = x + i; ny = y + (k - absi);
if (PrimeJudger::isPrime(getNumber(nx, ny))) { printf("%lld\n", k); return; }
 
nx = x + i; ny = y - (k - absi);
if (PrimeJudger::isPrime(getNumber(nx, ny))) { printf("%lld\n", k); return; }
}
}
}
 
int main()
{
int T;
scanf("%d", &T);
while (T--)
deal();
 
return 0;
}