// SPOJ - CHEFJUN
// Maths
// Miller-Rabin primality testing

#include <stdio.h>
#include <iostream>
#include <queue>
#include <set>

using namespace std;
typedef long long LL;

// Miller-Rabin
LL mod;
int b[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};
LL a[] = {1996011519951206LL, 1995120619960115LL, 1995100319960115LL, 195100319951206LL, 1996011519951003LL};


LL multiply(LL x, LL y)
{
  LL w = x * y - mod * (LL(double(x) * y / mod + 1e-3));
 
  while(w < 0) w += mod;
  while(w >= mod) w -= mod;

  return w;
}

LL power(LL x, LL y)
{
  LL t = 1;

  while(y)
  {
    if(y & 1) t = multiply(t, x);
    x = multiply(x, x);
    y >>= 1;
  }

  return t;
}

int isPrime(LL n)
{
  if(n == 2) return 1;
  if(n < 2 || !(n & 1)) return 0;
	
  for(int i = 0; i < 25; i++)
   if(n % b[i] == 0 && n != b[i]) return 0;

  mod = n;
  int t = 0;
  LL u = n - 1;

  while(!(u & 1)) t++, u >>= 1;
  for(int i = 0; i < 5; i++)
  {
    LL x = a[i] % (n - 1) + 1;
    x = power(x, u);
    LL y = x;
    for(int j = 1; j <= t; j++)
    {
      x = multiply(x, x);
      if(x == 1 && y != 1 && y != n - 1) return 0;
      y = x;
    }
    if(x != 1) return 0;
  }

  return 1;
}
//

struct Node
{
  LL x, y;
};

LL absolute(LL x)
{
  return (x < 0) ? -x : x;
}

LL convert(LL x, LL y)
{
  if(absolute(x) > absolute(y) && x > 0) return 4 * x * x - 3 * x + y;
  if(absolute(x) > absolute(y) && x <= 0) return 4 * x * x - x - y;
  if(absolute(x) <= absolute(y) && y > 0) return 4 * y * y - y - x;
  if(absolute(x) <= absolute(y) && y <= 0) return 4 * y * y - 3 * y + x;
}

LL distance(LL x1, LL y1, LL x2, LL y2)
{
  return absolute(x1 - x2) + absolute(y1 - y2);
}

LL BFS(LL x1, LL y1)
{
  struct Node start, temp;
  queue<Node> Q;
  pair<LL, LL> P;
  set<pair<LL, LL> > S;

  start.x = x1; start.y = y1;
  Q.push(start);
  while(!Q.empty())
  {
    start = Q.front();
    Q.pop();
    P.first = start.x; P.second = start.y; // Visited
    S.insert(P);

    if(isPrime(convert(start.x, start.y))) 
     return distance(start.x, start.y, x1, y1);

    if(S.find(make_pair(start.x, start.y + 1)) == S.end())
    {
      temp.x = start.x; temp.y = start.y + 1;
      Q.push(temp);
    }
    if(S.find(make_pair(start.x, start.y - 1)) == S.end())
    {
      temp.x = start.x; temp.y = start.y - 1;
      Q.push(temp);
    }
    if(S.find(make_pair(start.x - 1, start.y)) == S.end())
    {
      temp.x = start.x - 1; temp.y = start.y;
      Q.push(temp);
    }
    if(S.find(make_pair(start.x + 1, start.y)) == S.end())
    {
      temp.x = start.x + 1; temp.y = start.y;
      Q.push(temp);
    }
  }
}

int main()
{
  int t;
  LL x, y;

  scanf("%d", &t);
  while(t--)
  {
    scanf("%lld %lld", &x, &y);
    printf("%lld\n", BFS(x, y));
  }

  return 0;
}