#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#define bit(n) (1<<(n))
using namespace std;
typedef long long ll;
typedef long long LL;
typedef pair<int,int> ii;
const int OFFSET = 250;
int x,y;
int visited[300][300];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
 
int H=17;
int p=bit(H)-1;
 
LL MOD(LL a,LL b,LL m)
{
	LL x[5];
	int n=0;
	for(;b;b>>=H) x[n++]=(b&p)*a%m;
	LL res=0;
	for(;n--;) res=((res<<H)+x[n])%m;
	return res;
}
 
LL powmod(LL a,LL n,LL mod)
{
	LL p=1;
	for(;n;)
	{
		if(n%2) p=MOD(p,a,mod);
		if(n/=2) a=MOD(a,a,mod);
	}
	return p;
}
 
bool witness(LL a,LL n)
{
	LL m,x,y;
	for(m=n-1;m%2==0;m/=2);
	x=powmod(a,m,n);
	for(;m<n-1;m*=2)
	{
		y=MOD(x,x,n);
		if(y==1 && 1<x && x<n-1) return false;
		x=y;
	}
	return x==1;
}
 
bool prob_prime(int x,int y)
{
	ll h=max(abs(x),abs(y));
	ll n=4*h*(h-1);
	if(x==h && h+y>0) n+=h+y; else
	{
		n+=2*h;
		if(y==h && h-x>0) n+=h-x; else
		{
			n+=2*h;
			if(x==-h && h-y>0) n+=h-y; else
			{
				n+=2*h;
				n+=h+x;
			}
		}
	};
	if(n<2) return false;
	if(n%2==0) return n==2;
	if(n%3==0) return n==3;
	if(n%5==0) return n==5;
	int s;
	for(s=0;s<1;s++)
	{
		ll a=rand()%(n-3)+2;
		if(!witness(a,n)) return false;
	}
	return true;
}
 
int bfs(int x, int y) {
	memset(visited, 0, sizeof visited);
	visited[0+OFFSET][0+OFFSET] = true;
	queue<ii> q;
	queue<int> dist;
	while (!dist.empty()) dist.pop();
	while (!q.empty()) q.pop();
	q.push(ii(0,0));
	dist.push(0);
	while (!q.empty()) {
		int d = dist.front(); dist.pop();
		ii now = q.front(); q.pop();
		if (!prob_prime(now.first+x, now.second+y)) {
			for (int i=0; i<4; i++) {
				int xx = now.first+dx[i];
				int yy = now.second+dy[i];
				if (!visited[xx+OFFSET][yy+OFFSET]) {
					visited[xx+OFFSET][yy+OFFSET] = true;
					q.push(ii(xx,yy));
					dist.push(d+1);
				}
			}
		} else {
			return d;
		}
	}
}
 
int main() {
	int t;
	scanf("%d", &t);
	while (t--) {
		scanf("%d %d", &x, &y);
		int ans = bfs(x,y);
		printf("%d\n", ans);
	}
}
