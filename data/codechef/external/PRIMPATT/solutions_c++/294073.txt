
#include <iostream>
#include <cstdio>
#include <cmath>
#include <limits.h>
 
using namespace std;
const bool PRIME = true;
const bool COMP = false;
 
unsigned long long mul(unsigned long long x, unsigned long long y, unsigned long long M) {
const static int bits = 19, mask = (1<<bits)-1;
if(x <= UINT_MAX && y <= UINT_MAX) return x * y % M;
unsigned long long ans = y * (x & mask) % M;
while(x>>=bits) ans = (ans + (y=(y<<bits)%M)*(x&mask))%M;
return ans;
}
 
template<typename T>
inline T mod_exp(T base, T expt, T mod) {
static T two = 2;
T result = 1;
//cout << "base = " << base << " expt = " << expt << " mod = " << mod << endl;
while(expt > 0) {
if(expt&1) {
result = mul(result, base, mod);
}
expt >>= 1;
base = mul(base, base, mod);
//cout << "base = " << base << " expt = " << expt << endl;
}
//cout << "result = " << result << endl;
return result%mod;
}
 
template<typename T>
inline bool millerRabin(T num) {
static T primes[20] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71};
size_t s = 0; T d;
for(d = num - 1; d%2 == 0; s++, d /= 2);
//const T UPPER_LIMIT = min(float(num - 1), floor(2*pow(log(float(num)), 2)));
for(int i = 0; i < 20 && primes[i] < num; i++) {
T a = primes[i];
T x = mod_exp(a, d, num);
//cout << "x = " << x << endl;
if(x == 1 || x == num - 1) continue;
for(int r = 1; r < s; r++) {
const static T two = 2;
x = mod_exp(x, two, num);
//cout << "x = " << x << endl;
if(x == 1) return COMP;
if(x == num - 1) break;
}
if(x != num - 1)
return COMP;
}
return PRIME;
}
 
template<typename T>
inline bool ptest(T num) {
if(num == 1) return COMP;
T primes[20] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71};
for(int i = 0; i < 20; i++) {
if(num == primes[i]) return PRIME;
else if(num%primes[i] == 0) return COMP;
}
return millerRabin(num);
}
 
template<typename T>
T spiral_num(const T& x, const T& y) {
if(y >= 0) {
const T n = y;
if(-n <= x && x <= n)
return 4*n*n - n - x;
}
if(x <= 0) {
const T n = -x;
if(-n <= y && y <= n)
return 4*n*n + n - y;
}
if(y <= 0) {
const T n = -y;
if(-n <= x && x <= n + 1)
return 4*n*n + 3*n + x;
}
if(x > 0) {
const T n = x - 1;
if(-n <= y && y <= n)
return (2*n + 1)*(2*n + 1) + n + y;
}
return 0;
}
 
template<typename T>
T solver(const T& x, const T& y) {
for(T dist = 0; ; dist++) {
for(T x_dist = 0; x_dist <= dist; x_dist++) {
T y_dist = dist - x_dist;
for(int i = 0; i < 2; i++, x_dist = -x_dist) {
for(int j = 0; j < 2; j++, y_dist = -y_dist) {
T num = spiral_num(x + x_dist, y + y_dist);
//cout << "num = " << num << endl;
if(num == 15999996000017LL) cout << "IT HAS BEEN FOUND!!" << endl;
if(ptest(num)) return dist;
}
}
}
//cout << "distance = " << dist << endl
}
}
int main() {
//cout << millerRabin(16000000000003LL) << endl;
size_t cases;
cin >> cases;
while(cases-- > 0) {
long long x, y;
cin >> x >> y;
cout << solver(x, y) << endl;
}
}
