//DSI
#include <vector>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <set>
#include <map>
//OTHERS
#include <algorithm>
#include <memory.h>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cstdlib>
#include <cstdio>
#include <climits>
#include <cctype>
#include <cmath>

using namespace std;

#define SD(t) scanf("%lf",&t)
#define SS(t) scanf("%s",t)
#define P(t)  printf("%d",t)
#define PD(t) printf("%f",t)
#define PS(t) printf("%s",t)
#define pn printf("\n")
#define ps printf(" ")
#define ck1 printf("OK1!\n")
#define ck2 printf("OK2!\n")
#define ck3 printf("OK3!\n")
#define hld1 int y; cin>>y;
#define sz(s) int((s).size())
#define S(n)  scanf("%d", &(n))
#define s(n)  int n; scanf("%d", &(n))
#define s2(n,m)  int (n), (m); scanf("%d %d",&(n),&(m))
#define s3(n,m,k)  int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k))
#define erU(V); (V).erase(unique(all(V)),(V).end())
#define erA(V,num); (V).erase(remove(all(V),(num)),(V).end())
#define IT(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)
#define nextP next_permutation
#define get getchar_unlocked
#define rep(i,a,b) for((i)=a;(i)<=(b);++(i))
#define repd(i,b,a) for((i)=b;(i)>=(a);--(i))
#define clr(a) memset(a, 0, sizeof(a))
#define all(x) (x).begin(),(x).end()
#define debug 0
#define pb push_back
#define mp make_pair
#define ff first
#define ss second

typedef long long llint;
typedef vector <int> VI;
typedef map <int , int> MII;
typedef map <pair <int,int >, int> PAIRIII;
typedef map <int, int> :: const_iterator it;
inline int inp() {int n=0, s=1; char p=get();if(p=='-') s=-1;while((p<'0'||p>'9')&&p!=EOF&&p!='-')p=get();if(p=='-')s=-1,p=get();while(p>='0'&&p<='9')n=(n<<3)+(n<<1)+(p-'0'),p=get();return n*s;}
template <class T> inline int cB(T x,T y,T r,T c){return(x>=1&&x<=r&&y>=1&&y<=c);}
template <class T> inline T gcd(T a,T b){return( !b? a : gcd(b,a%b));}
template <class T> inline T lcm(T a,T b){return a / gcd(a, b) * b;}
template <class T> inline T ABS(T x){return ((x)>0?(x):(-(x)));}
template <class T> inline T MAX(T a, T b) {return (a>b?a:b);}
template <class T> inline T MIN(T a, T b) {return (a<b?a:b);}
template <class T> inline T sqr(T x) {return x*x;}
template <class T> inline T cub(T x) {return x*x*x;}
const double PI = 3.14159265358979323846;
const int N = (1000 * 100)  + 10;
const int M = 100;
const int MOD = 100000000 + 7;
const int INF = INT_MAX;

class lights {
	public:
		char track [M];
		int  OFF;
		int  ONN;
		lights () {
			OFF = 0;
			ONN = 0;
		}
};

bool compONN (const lights &left, const lights &right) {
	return left.ONN < right.ONN;
}


int i, j;
int main()
{
	int testCase, t=1;
	S (t);
	for (testCase=1; testCase<=t; testCase++)
	{
		s3 (row , col ,opr);
		
		lights str [M];
		rep (i,1,row) {
			rep (j,1,col) {
				cin >> str [i].track [j];
				if (str [i].track [j] == '.')
					str [i]. OFF ++;
				else
					str [i]. ONN ++;
			}
		}
		
		sort (str+1, str+1+row, compONN);
		
		int good = col >> 1;
		if (col & 1) good++;
			
		rep (i,1,row) {
			if (str [i]. ONN < good) {
				swap (str [i]. OFF, str [i]. ONN);
				opr --;
			} else {
				break;
			}
			if (!opr) break;
		}

		
		if (opr > 0) {
			if (opr & 1) {
				sort (str+1, str+1+row, compONN);
				swap (str [1].OFF, str [1].ONN);
			}
		}
	
		
		int ans = 0;
		rep (i,1,row) {
			ans += str [i]. ONN;
		}

		cout << ans << "\n";
	}
}
			
			
			
		
			
				
				

