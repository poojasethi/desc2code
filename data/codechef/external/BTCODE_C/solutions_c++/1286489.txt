#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <math.h>
#include <map>
#include <tr1/unordered_map>

using namespace std;

typedef long long ll;

const ll inf = (ll)1e18+1;

struct par{
    ll f, s;
    par(ll _f, int _s) : f(_f), s(_s){}
    par(){};
    bool operator <(const par &p)const{
        return f < p.f;
    }
};

std::tr1::unordered_map<ll, int> eq, neq;

int main(){

    vector <par> v;
    int n, less = 0, Sn = 0;
    scanf("%d", &n);
    for(int i = 0; i < n; ++i){
        int t; ll x;
        scanf("%d%lld", &t, &x);
        if(t == 1)
            v.push_back(par(x, 1));
        if(t == 2){
            v.push_back(par(x, 2));
            ++less;
        }
        if(t == 3){
             v.push_back(par(x, 3));
             ++eq[x];
        }
        if(t == 4){
            v.push_back(par(x, 4));
            ++neq[x], ++Sn;
        }
    }

    sort(v.begin(), v.end());

    int over = 0;
    ll val  = 0;
    int sol = less + eq[0] + Sn - neq[0] + over, t = 0;
    while(t < v[0].f && (eq[t] != 0 && neq[t] != 0))++t;

    if(t != v[0].f){
        int tmp = less + Sn + over;
        if(tmp > sol)
            sol = tmp, val = t;
    }

    v.push_back(par(inf,0));
    for(int i = 0; i < v.size(); ++i){
       if(v[i].f == inf)break;
       int add = 0;
       if(v[i].s == 1)++add;
       if(v[i].s == 2)--less;

       if(v[i].f == v[i+1].f){
           int j = i+1;
           while(v[j].f == v[i].f){
               if(v[i].s == 1)++add;
               if(v[i].s == 2)--less;
               ++j;
           }
           i = j-1;
        }

       int cnt  = less + eq[v[i].f] + Sn - neq[v[i].f] + over;
       if(cnt > sol)
           sol = cnt, val = v[i].f;

       over += add;
       ll next = v[i+1].f, x = v[i].f+1;
       while(x < next && (eq[x] != 0 && neq[x] != 0)) ++x;

       if(x != next){
           cnt = less + Sn + over;
           if(cnt > sol)
              sol = cnt, val = x;
       }
    }

    printf("%d %lld\n", sol, val);
    return 0;
}
