#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(int i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long
#define ull unsigned ll
#define pii pair<int,int>
#define N 200009
char str[N];
struct node{
    int val1;
    int val2;
};

node st[6*N],qt[6*N];
/*
 * make_tree:
 * Used to construct the segment tree. It uses the baseArray for construction
 */
void make_tree(int cur, int s, int e) {
	if(s == e-1) {
		if(str[s]=='(')
		{
            st[cur].val1 =1;
            st[cur].val2=0;
		}
		else if(str[s]==')')
		{
            st[cur].val1 =0;
            st[cur].val2 =1;
		}
		return;
	}
	int c1 = (cur<<1), c2 = c1 | 1, m = (s+e)>>1;
	make_tree(c1, s, m);
	make_tree(c2, m, e);
	st[cur].val1 = st[c1].val1 + st[c2].val1 - min(st[c1].val1,st[c2].val2);
	st[cur].val2 = st[c1].val2 + st[c2].val2 - min(st[c1].val1,st[c2].val2);
}

/*
 * update_tree:
 * Point update. Update a single element of the segment tree.
 */
void update_tree(int cur, int s, int e, int x) {
	if(s > x || e <= x) return;
	if(s == x && s == e-1) {
		st[cur].val1 = 1-st[cur].val1;
		st[cur].val2 = 1-st[cur].val2;
		return;
	}
	int c1 = (cur<<1), c2 = c1 | 1, m = (s+e)>>1;
	update_tree(c1, s, m, x);
	update_tree(c2, m, e, x);
    st[cur].val1 = st[c1].val1 + st[c2].val1 - min(st[c1].val1,st[c2].val2);
	st[cur].val2 = st[c1].val2 + st[c2].val2 - min(st[c1].val1,st[c2].val2);

}

/*
 * query_tree:
 * Given S and E, it will return the maximum value in the range [S,E)
 */

void query_tree(int cur, int s, int e, int S, int E) {
	if(s >= E || e <= S) {
		qt[cur].val1 = 0;
		qt[cur].val2 = 0;
		return;
	}
	if(s >= S && e <= E) {
		qt[cur] = st[cur];
		return;
	}
	int c1 = (cur<<1), c2 = c1 | 1, m = (s+e)>>1;
	query_tree(c1, s, m, S, E);
	query_tree(c2, m, e, S, E);
	qt[cur].val1 = qt[c1].val1 + qt[c2].val1 - min(qt[c1].val1,qt[c2].val2);
	qt[cur].val2 = qt[c1].val2 + qt[c2].val2 - min(qt[c1].val1,qt[c2].val2);

}

int main()
{

    #ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
    #endif // ONLINE_JUDGE
    int n;
    scanf("%s",str);
    n = strlen(str);
    make_tree(1,0,n);
    int q;
    scanf("%d",&q);
    query_tree(1,0,n,0,n);
    while(q--)
    {
        int l,r;
        scanf("%d %d",&l,&r);
        if(str[l]!=str[r])
        {
            swap(str[l],str[r]);
            update_tree(1,0,n,l);
            update_tree(1,0,n,r);
            query_tree(1,0,n,0,n);
        }
        if(qt[1].val1==0 && qt[1].val2==0)
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}
