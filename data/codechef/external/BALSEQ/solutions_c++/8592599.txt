#include<bits/stdc++.h>
#define lc(idx) (2*idx+1)
#define rc(idx) (2*idx+2)
#define mid(l,r) ((l+r)/2)
using namespace std;
string s;
struct Node{int check[2];};
Node TREE[4*100000+11111];

Node MERGE(int l , int r)
{
    Node temp;
    temp.check[0]=0;
    temp.check[1]=0;
    int x = TREE[l].check[0];
    int y = TREE[r].check[1];
    if(x>y)
    {
        temp.check[0]=  x - y;
    }
    else
    {
        temp.check[1] = y - x  ;
    }

    temp.check[1] +=TREE[l].check[1];
    temp.check[0] +=TREE[r].check[0];
    return temp;

}

void build(int l , int r ,int idx )
{
    if(l==r)
    {
        TREE[idx].check[s[l]-'(']=1;
        TREE[idx].check[!(s[l]-'(')]=0;
        return ;
    }
    build(l,mid(l,r),lc(idx));
    build(mid(l,r)+1,r,rc(idx));
    TREE[idx]=MERGE(lc(idx),rc(idx));
}

void update(int l , int r  , int idx , int qe, int val)
{

    if(l>qe || r<qe)
        return ;

    if(l==r)
    {
        TREE[idx].check[val]=1;
        TREE[idx].check[!val]=0;
        return ;
    }

    update(l,mid(l,r),lc(idx),qe,val);
    update(mid(l,r)+1,r,rc(idx),qe,val);
    TREE[idx]=MERGE(lc(idx),rc(idx));
    return ;
}

bool check()
{
//    cout<<TREE[0].check[0]<<" "<<TREE[0].check[1]<<"\n";

    if( TREE[0].check[0] || TREE[0].check[1] )
            return 0;
    return 1;
}

int main()
{

    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>s;

    build(0,s.length()-1,0);
    int q;
//    check();

    cin>>q;
    for(;q;--q)
    {
        int l ,r ;
        cin>>l>>r;
        update(0,s.length()-1,0,l,s[r]-'(');
        update(0,s.length()-1,0,r,s[l]-'(');
        swap(s[l],s[r]);

        if(check())
            cout<<"Yes\n";
        else
            cout<<"No\n";
    }


    return 0;
}
