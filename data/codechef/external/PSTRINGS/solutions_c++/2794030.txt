using namespace std;
#include <cmath>
#include <cstdio>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <string>
#include <vector>
#include <cstring>
#include <iostream>
#include <sstream>
#include <algorithm>
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
typedef long long ll; 
typedef pair<int,int> pii; 
#define FOR(i,n) for (int i = 0; i < n; i++)
#define SZ(x) ((int)x.size())
#define PB push_back
#define MP make_pair
#define sf(x) scanf("%d",&x)
#define pf(x) printf("%d\n",x)
#define split(str) {vs.clear();istringstream ss(str);while(ss>>(str))vs.push_back(str);}
#define PI 3.141592653589793
#define MOD 1000000007
int dp[402][1025];
bool palin[1025];
bool palin1[1025];
void init(int k)
{
	for(int i = 0; i<(1<<k); i++)
	{
		vector<bool> s(k,false);
		int j = 0;
		int temp = i;
		while(temp != 0)
		{
			s[j++] = (temp%2);
			temp/=2;
		}
		//FOR(i1,k)
		//	cout<<s[i1];
		//cout<<endl;
		vector<bool> s1 = s;
		reverse(all(s1));
		palin[i] = (s1 == s);
	}
}
void init1(int k)
{
	for(int i = 0; i<(1<<k); i++)
	{
		vector<bool> s(k,false);
		int j = 0;
		int temp = i;
		while(temp != 0)
		{
			s[j++] = (temp%2);
			temp/=2;
		}
		vector<bool> s1 = s;
		reverse(all(s1));
		palin1[i] = (s1 == s);
	}
}
int main()
{
	int t;
	sf(t);
	while(t--)
	{
		int n,k;
		sf(n);sf(k);
		memset(palin, false, sizeof palin);
		memset(palin1, false, sizeof palin1);
		init(k);
		init1(k + 1);
		if(n < k)
		{
			int ans = 1;
			FOR(i,n)
				ans = (ans*2)%MOD;
			pf(ans);
		}
		else if(k == 1)
			pf(0);
		else
		{
			memset(dp, 0, sizeof dp);
			int lim = 1;
			FOR(i,k)
				lim *= 2;
			//memset(dp[0], 1, sizeof(dp[0]));
			/*FOR(i,lim*2)
				cout<<i<<" "<<palin[i]<<endl;
			cout<<"---"<<endl;
			FOR(i,lim*2)
				cout<<i<<" "<<palin1[i]<<endl;*/
			for(int j = 0; j < lim/2; j++)
				dp[0][j] = 1;
			for(int j = 0; j < lim; j++)
			{
				int i = 0;
				int temp = j<<1;
					temp = temp&((1<<k)-1);
					if(!palin[temp])
						dp[i+1][temp] = (dp[i+1][temp] + dp[i][j])%MOD;
					if(!palin[temp+1])
						dp[i+1][temp+1] = (dp[i+1][temp+1] + dp[i][j])%MOD;
			}
			for(int i = 1; i < n-(k-1); i++)
				for(int j = 0; j < lim; j++)
				{
					int temp = j<<1;
					temp = temp&((1<<k)-1);
					int temp2 = j<<1;
					if(!palin[temp] && !palin1[temp2])
						dp[i+1][temp] = (dp[i+1][temp] + dp[i][j])%MOD;
					if(!palin[temp+1] && !palin1[temp2 + 1])
						dp[i+1][(temp) +1] = (dp[i+1][(temp) +1] + dp[i][j])%MOD;
				}
			int ans = 0;
			for(int j = 0; j < lim; j++)
				ans = (ans + dp[n-(k-1)][j])%MOD;
			pf(ans);
		}
	}
}