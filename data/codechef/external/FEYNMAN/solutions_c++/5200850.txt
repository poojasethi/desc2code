#include <bits/stdc++.h>
using namespace std;
#define N 100000
vector <int> adj[N + 10];
int mark[N + 10];
//int poss[N + 10];

//int mp[N + 10];
int disc[N + 10];
int low[N + 10];
int par[N + 10];
int dtime,cnt;
int dfs(int,int);
//void Bridges(int);
int main()
{
    int tc,t;
    scanf("%d",&tc);
    while(tc--)
    {
        int n,m,i;
        scanf("%d %d",&n,&m);
        for(i = 1 ; i<=n ; i++)
        {
            //mp[i] = 0;
            //poss[i] = 0;
            mark[i] = 0;
            adj[i].clear();
            //adj2[i].clear();
            disc[i] = 0;
            low[i] = 0;
            par[i] = 0;
        }

        for(i = 1 ; i<=m ; i++)
        {
            int u,v;
            scanf("%d %d",&u,&v);
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        dtime = 0;
        cnt = 0;
        int temp = dfs(1,n);
        printf("%d\n",cnt);
        /*int cc = 0;
        for(i = 1 ; i<=n ; i++)
        {
            mark[i] = 0;
            if(poss[i] == 1)
            {
                cc++;
                mp[cc] = i;
                poss[i] = cc;
            }
        }
        for(i = 1 ; i<=n ; i++)
        {
            int sz = adj[i].size();
            for(int j = 0 ; j<sz; j++)
            {
                int v = adj[i][j];
                if(poss[i] > 0 && poss[v] > 0)
                {
                    adj2[mp[i]].push_back(mp[v]);
                    //adj2[mp[v]].push_back(mp[i]);
                }
            }
        }
        cnt = 0;
        Bridges(1);
        printf("%d\n",cnt);*/
    }
    return 0;
}
int dfs(int u,int n)
{
    dtime++;
    disc[u] = dtime;
    low[u] = disc[u];
    mark[u] = 1;
    int sz = adj[u].size();
    int fl = 0;
    if(u == n) fl = 1;
    for(int j = 0 ; j<sz ; j++)
    {
        int v = adj[u][j];
        if(mark[v] == 0)
        {
            par[v] = u;
            int temp = dfs(v,n);
            if(fl == 0) fl = temp;
            if(temp == 1)
            {
                if(low[v] > disc[u]) cnt++;
            }
        }
        if(v != par[u])
        {
            low[u] = min(low[u],low[v]);
        }
    }
    mark[u] = 2;
    //cout<<u<<" "<<fl<<" "<<low[u]<<" "<<disc[u]<<endl;
    return fl;
}
/*void Bridges(int u)
{
    dtime++;
    disc[u] = dtime;
    low[u] = disc[u];
    mark[u] = 1;
    int sz = adj2[u].size();
    for(int j = 0 ; j<sz ; j++)
    {
        int v = adj2[u][j];
        if(mark[v] == 0)
        {
            par[v] = u;
            Bridges(v);
            if(low[v] > disc[u])cnt++;
        }
        if(v != par[u])
        {
            low[u] = min(low[u],disc[v]);
        }
    }
}*/
