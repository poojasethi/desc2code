/* 
 * File:   REN2013I.cpp
 * Author: anuraganand
 * Created on 25 January, 2014, 12:40 PM
 */

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <iostream>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <list>
#include <utility>
#include <algorithm>
#include <cassert>

using namespace std;
#define ff first
#define ss second
#define pb push_back
#define mp make_pair
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef long long ll;
typedef vector<int> vi;
typedef long double ld;
#define var(a,b)  __typeof(b) a = b
#define rep(i,n)  for(int i = 0;(i) < (n);  ++i)
#define rept(i,a,b) for(var(i,a); i < (b); ++i)
#define tr(v,it)  for(var(it,v.begin());it!=v.end();++it)
#define fill(a,val) memset(a,val,sizeof(a))
#define gi(n) scanf("%d",&n);
#define all(v) v.begin(),v.end()

const double eps  = 1e-6;
int l[20];
double dp[1 << 18];

double area(int a,int b,int c) {
    double s = (a + b + c) / 2.0;
    if(s < a || s < b || s < c) return 0.0;
    double ar = sqrt(s * (s - a) * (s - b) * (s - c));
    return ar;
}

int main(int argc, char** argv) {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
    int n; gi(n);
    rep(i,n) gi(l[i]);
    double x;
    scanf("%lf",&x);
    int lim = 1 << n;
    rep(i,lim) dp[i] = 0.0;
    bool ok = false;
    rep(mask,lim) {
        rep(i,n) if(mask & (1 << i)) {
            rep(j,i) if(mask & (1 << j)) {
                rep(k,j) if(mask & (1 << k)) {
                    if(l[i] >= l[j] + l[k] || l[j] >= l[i] + l[k] || l[k] >= l[i] + l[j]) continue;
                    double a = area(l[i], l[j], l[k]);
                    dp[mask] = max(dp[mask], dp[mask - (1 << i) - (1 << j) - (1 << k)] + a);
                }
            }
        }
        if(abs(dp[mask] - x) < eps) {
            ok = true;
        }
    }
    if(ok) {
        if(abs(dp[(1 << n) - 1] - x) < eps) {
            puts("DRAW");
        } else {
            puts("BOB WINS");
            printf("%.8lf\n",dp[(1 << n) - 1]);
        }
    } else {
        puts("AREA NOT POSSIBLE");
    }
    return 0;
}

