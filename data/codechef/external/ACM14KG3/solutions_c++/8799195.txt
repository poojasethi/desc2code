/*
    AUTHOR:         BHUVNESH JAIN
    INSTITUITION:   BITS PILANI, PILANI
*/
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <iterator>
#include <cmath>
#include <cassert>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <climits>
 
using namespace std;
 
#define fastio          std::ios_base::sync_with_stdio(false)
#define PAUSE_EXE       assert(false)
#define inchar          getchar_unlocked
#define LL              long long
#define LD              long double
#define MAX             1005
#define MOD             1000000007
#define REP(i,n)        for(__typeof(n) i=0; i<n; ++i)
#define REP1(i,n)       for(__typeof(n) i=1; i<=n; ++i)
#define REP2(i,n)       for(__typeof(n) i=1; i<n; ++i)
#define CREP(i,n)       for(__typeof(n) i=n-1; i>=0; --i)
#define CREP1(i,n)      for(__typeof(n) i=n; i>=1; --i)
#define CREP2(i,n)      for(__typeof(n) i=n-1; i>=1; --i)
#define MYREP(i,a,b)    for(__typeof(a) i=a; i<=b; ++i)
#define MYCREP(i,a,b)   for(__typeof(a) i=b; i>=a; --i)
#define SET(a, b)       memset(a, b, sizeof(a))
#define sz(a)           int((a).size())
#define pb              push_back
#define mp              make_pair
#define fi              first
#define sec             second
#define all(c)          (c).begin(),(c).end()
#define allr(c)         (c).rbegin(),(c).rend()
#define loop(c,i)       for(typeof(c.begin()) i = c.begin(); i != c.end(); i++)
#define present(c,x)    ((c).find(x) != (c).end())
#define cpresent(c,x)   (find(all(c),x) != (c).end())
 
const double EPS = 1e-10;
 
template <typename T>
void inPos(T &x)
{
    register T c = inchar();
    while(((c<48) || (c>57)) && (c!='-')) c = inchar();
    x = 0;
    for(;c<48 || c>57; c = inchar());
    for(;c>47 && c<58; c = inchar())    x=(x<<3)+(x<<1)+(c-48);
}
 
// === tick a time ===
#include <ctime>
double tick() 
{
    static clock_t oldtick;
    clock_t newtick = clock();
    double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;
    oldtick = newtick;
    return diff;
}

template <typename T> T max(T &a, T &b) {return (!(a < b) ? a : b);}
template <typename T> T min(T &a, T &b) {return (a < b ? a : b);}
template <typename T> T mod(T a, T b) {return (a < b ? a : a % b);}
LL mulmod(LL a,LL b, LL m){LL q=(LL)(((LD)a*(LD)b)/(LD)m);LL r=a*b-q*m;if(r>m)r%=m;if(r<0)r+=m;return r;}
template <typename T>T expo(T e, T n){T x=1,p=e;while(n){if(n&1)x=x*p;p=p*p;n>>=1;}return x;}
template <typename T>T power(T e, T n, T m){T x=1,p=e;while(n){if(n&1)x=mod(x*p, m);p=mod(p*p, m);n>>=1;}return x;}
template <typename T> T InverseEuler(T a, T m){return (a==1? 1 : power(a, m-2, m));}
template <typename T> T gcd(T a, T b){return (!b)? a:gcd(b,a%b);}
template <typename T> T lcm(T a, T b){return (a*(b/gcd(a,b)));}

class Graph
{
    int V;                              // No. of vertices
    list<int> *adj;                     // Pointer to an array containing adjacency lists
    bool *visited;                      // Array to store visited vertices
public:
    Graph(int V);                       // Constructor
    void print();                       // Print Graph
    bool Valid(int a);                  // check if vertex is valid to be added/deleted/searched
    void addEdge(int v, int w);         // function to add an edge to graph
    bool BFS(int u, int v);             // prints BFS traversal from a given source s
};
 
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
    visited = new bool[V];
}
 
void Graph::print()
{
    REP(i, V)
    {
        printf("%d -> ", i);
        loop(adj[i], j)
        {
            printf("%d", *j);
        }
        printf("\n");
    }
}
 
bool Graph::Valid(int a)
{
    if (a<V && a>=0)
    return true;
    return false;
}
 
void Graph::addEdge(int v, int w)
{
    adj[v].pb(w);                     // Add w to v's list.
}
 
bool Graph::BFS(int u, int v)
{
    REP(i, V)
        visited[i] = false;
    int s = u;
    list<int> queue;
    visited[s] = true;
    queue.pb(s);
    while(!queue.empty())
    {
        s = queue.front();
        queue.pop_front(); 
        loop(adj[s], i)
        {
            if(!visited[*i])
            {
                visited[*i] = true;
                queue.pb(*i);
            }
        }
        if (visited[v])
            return true;
    }
    return visited[v];
}
 
char a[MAX], b[MAX];

bool lookup[26][26];

int main()
{
    int t, n, l1, l2, u, v;
    char x, y;
    scanf("%d", &t);
    bool check;
    while (t--)
    {
        scanf("%s %s", a, b);
        scanf("%d", &n);
        Graph g(26);
        SET(lookup, false);
        while (n--)
        {
            scanf("\n%c->%c", &x, &y);
            u = x-97;
            v = y-97;
            g.addEdge(u, v);
        }
        l1 = strlen(a);
        l2 = strlen(b);
        if (l1!=l2)
        {
            printf("NO\n");
            continue;
        }
        check = true;
        REP(i, l1)
        {
            if (a[i]==b[i])
                continue;
            if (lookup[a[i]-97][b[i]-97])
                continue;
            if (g.BFS(a[i]-97, b[i]-97))
            {
                lookup[a[i]-97][b[i]-97] = true;
                continue;
            }
            else
            {
                check = false;
                break;
            }
        }
        if (check)
            printf("YES\n");
        else
            printf("NO\n");

    }
    // cerr<<tick();
    return 0;
}  