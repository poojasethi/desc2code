// imp algo
//floyed warshall mainly in graphs or mapping or shotest paths
//dp





#include<bits/stdc++.h>
using namespace std;
//for cin with white space cin.getline(var,sizeof(var)); with  char var[100];
#define lli long long int
#define pb push_back
#define mp make_pair
#define sd(a) scanf("%lld",&a)
#define pd(a) printf("%lld\n",a)
#define F first
#define S second
//***dont forget to clear the vector using v.clear();***


int main()
{
    lli t,m,n,x,y,j,k,f,a,b;
    sd(t);
    while(t--)
    {
        string s,p,d;
        char c,ch;
        bool mapp[28][28];
        for(x=1;x<=26;x++){
            
            for(y=1;y<=26;y++){
                if(x==y)
                mapp[x][y]=1;
                else
              mapp[x][y]=0;
            }
        }
        cin>>s>>p;
        sd(m);
        
        for(x=0;x<m;x++)
        {
           // cout<<x<<endl;
            cin>>d;
            a=int (d[0])-96;
            b=int (d[3])-96;
            mapp[a][b]=1;
           // cout<<a<<" "<<b<<endl;
        }
        
        f=0;
        //main floyed warshal imlementation and mapping all possible transactions
        for(int z=1;z<27;z++)
        {
            for(x=1;x<27;x++)
            {
                for(y=1;y<27;y++)
                {
                    //if already prsesnt path is there or there is intermidiate node Z through which path
                    //is possible ie(X-Z -> Z-Y== X-Y)
                    mapp[x][y]= mapp[x][y] | (mapp[x][z] & mapp[z][y]);
                }
            }
        }
        j=s.length();
        if(j!=p.length()){
            cout<<"NO"<<endl;
            continue;
        }
        for(x=0;x<j;x++)
        {
            if(s[x]!=p[x] )
            {
                a=int(s[x])-96;
                b=int(p[x])-96;
                if(mapp[a][b]!=1){
                    f=1;
                    break;
                }
            }
        }
        
        printf((f==1)?"NO\n":"YES\n");
    }
    return 0;

}
