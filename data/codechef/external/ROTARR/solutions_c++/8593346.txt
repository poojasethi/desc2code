
#include<bits/stdc++.h>
#define mod 1000000007
#define len(a) strlen(a)
#define ll long long
#define nl printf("\n")

//#define ip(a) scanf("%I64d",&a)

#define db printf("debug")
#define yes printf("YES\n")
#define no printf("NO\n")
#define pb(a) push_back(a)
#define po(a) pop_back()
#define mp(a,b) make_pair(a,b)
#define set(a,v) memset(a,v,sizeof(a))

#define sz(v) v.size()
#define maxx 2000005
#define pcase(i) printf("Case #%d:\n",i)
#define gc getchar_unlocked

using namespace std;

inline void ip( ll &x) {
	    register  ll c = gc();
	    x = 0;
	    for(; ((c<48 || c>57) ); c = gc());
	    for(; c>47 && c<58 ; c = gc()) {
	        x = (x<<1) + (x<<3) + c - 48;
	    }

	}
/*--------------------------------------------------------------------------------------------------------------------------------*/

ll a[100005];
ll cnt[350][100005];
ll add [400];
ll lazy[400];
ll q, e_block, n_block, b;
void pnt(ll n)
{
    ll i, j;
    for(i=1;i<=n_block;i++)
    {
        for(j=0;j<=n;j++)
        {
            cout<<cnt[i][j]<<" ";
        }
        nl;
    }
}
void calc_cnt(ll n)
{
    ll i,j,b;
    for(i=1;i<=n;i++)
    {
        b = ceil( 1.0* i/e_block );
        //cout<<"b="<<b<<" ";
        cnt[b][a[i]]+=1;
    }
}
int main()
{
    ll n;
    ll i,b1,b2;
    ip(n);ip(q);

    e_block = floor(  sqrt(n*1.0) );
    n_block = ceil(  1.0*n/e_block);
    //printf("%lld %lld\n", n_block, e_block);
    for(i=1;i<=n;i++)
        ip(a[i]);

    calc_cnt(n);
    //pnt(n);nl;

    while(q--)
    {
        ll op,l,r,x,ans=0,val,end,st;
        ip(op);ip(l);ip(r);ip(x);
        l++; r++;
        if(op==1)                                // update query
        {
            b1 = ceil( 1.0* l/e_block );
            b2 = ceil( 1.0* r/e_block );
            if(b1==b2)                         // if in same block do brute-force update
            {
                for(i=l;i<=r;i++)
                {
                    cnt[b1][a[i]]--;
                    a[i]=(a[i]+x)%n;
                    cnt[b1][a[i]]++;
                }
            }
            else
            {
                end = b1*e_block;
                for(i=l;i<=end;i++)             // updating side ways- left
                {
                    cnt[b1][a[i]]--;
                    a[i]=(a[i]+x)%n;
                    cnt[b1][a[i]]++;
                }

                for(i=b1+1; i<=b2-1; i++)         // lazy -updating all block b1 to b2 excluding extremes block ie,(b1,b2).
                {
                    lazy[i]=(lazy[i]+x)%n;
                }

                st= (b2-1)* e_block +1;

                for(i=st;i<=r;i++)              // updating side ways- right
                {
                    cnt[b2][a[i]]--;
                    a[i]=(a[i]+x)%n;
                    cnt[b2][a[i]]++;
                }

            }

        }
        else
        {
            b1 = ceil( 1.0* l/e_block );
            b2 = ceil( 1.0* r/e_block );
            if(b1==b2)
            {
                for(i=l;i<=r;i++)
                {
                    val= (a[i]+ lazy[b1])%n;
                    if(val == x)
                        ans++;
                }
            }
            else
            {
                end = b1*e_block;
                for(i=l;i<=end;i++)             // calculating side ways- left b1
                {
                    val = (a[i]+lazy[b1])%n;
                    if(val==x)
                        ans++;
                }

                for(i=b1+1; i<=b2-1; i++)         // calculating for blocks
                {
                    val= x- lazy[i];
                    if(val<0)
                        val+=n;
                    ans= ans+ cnt[i][val];
                }

                st= (b2-1)* e_block +1;

                for(i=st;i<=r;i++)              // calculating side ways- right b2
                {
                    val= (a[i]+ lazy[b2])%n;
                    if(val == x)
                        ans++;
                }
            }
            printf("%lld\n",ans);
        }

    }
}
