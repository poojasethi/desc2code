#include<bits/stdc++.h>
using namespace std;
#define lli long long int
#define f(i,a,b) for(i=a;i<b;i++)
#define si(a) scanf("%d",&a);
#define slli(a) scanf("%lld",&a);
#define INF 1000000007
#define MAX 100005
#define pb(a) push_back(a)
#define sn struct node
lli arr[MAX],mul[MAX];
long double logproduct[MAX];
int GCDW(lli a, lli b, lli & l, lli & k) {
        if (!a) {
                // gcd(0, b) = 0 * 0 + 1 * b
                l = 0;
                k = 1;
                return b;
        }
        int d = GCDW(b % a, a, k, l);
        l -= (b / a) * k;
        return d;
}
lli RevMod(lli a, lli m)
{
        lli x, y;
        if (GCDW(a, m, x, y) != 1) return -1;
        x %= m;
        if (x < 0) x += m;
        return x;
}
lli fun(lli &fd,lli r,lli n)
{
    lli i,cur=1,l=1,p1,p2;
    long double tmp,diff;
    i=1;
    

    cur=(mul[r]*arr[1])%INF;
    tmp=logproduct[r]+log10(arr[1]);
    /*while(i<=n)
    {
    //cur=(cur*arr[i])%INF;
    tmp=tmp+log10(arr[i]);
    i+=r;
    }*/
    fd=1;
    tmp=tmp-floor(tmp);
    tmp=tmp*1000000000;
    for(i=1;i<=9;i++)
    {
    p1=log10(i)*1000000000;
    p2=log10(i+1)*1000000000;
    	if(tmp>=p1 && tmp<p2)
    	{
    		fd=i;
    		break;
    	}
    }
    return cur;
}
void change(lli index,lli value,lli r,lli inverse)
{
    mul[r]=(mul[r]*inverse)%INF;
    mul[r]=(mul[r]*value)%INF;
    logproduct[r]=(logproduct[r])-(log10(arr[index]+0.0))+(log10(value+0.0));
}
    int main()
    {
    	lli q,i,j,k,ans,m,n,r,t,p,a,b,fd,cur,tmp,tmp1,inverse;
        long double curlog;
    	slli(n);
     
    	f(i,1,n+1)
    	slli(arr[i]);

        f(r,1,n+1)
        {
        i=1;
        cur=1;
        curlog=0;

        while(i <= n)
        {
            if(i!=1)
            {
            cur=(cur*arr[i])%INF;
            curlog=(curlog)+log10(arr[i]);        
            }
            i+=r;
        }
        mul[r]=cur;
        logproduct[r]=(curlog);
        }

    	slli(q);
    	while(q--)
    	{
    		slli(p);
    		if(p == 1)
    		{
    			slli(a);
    			slli(b);
                tmp=a-1;

                if(tmp!=0)
                {
                    tmp1=sqrt(tmp);
                    for(i=1;i<=tmp1;i++)
                    {  
                        if(tmp%i == 0)
                        {
                            inverse=RevMod(arr[a],INF)%INF;
                            change(a,b,i,inverse);
                            if(i != (tmp/i))
                                change(a,b,tmp/i,inverse);
                        }
    
                    }
                }
                arr[a]=b;
    		}
    		else
    		{
    			fd=1;
    			slli(r);
    			ans=fun(fd,r,n);
    			printf("%lld %lld\n",fd,ans);
    		}
    	}
    } 