#include<bits/stdc++.h>

using namespace std;

#define in(a,x,y) (a>=x && a<=y)
#define out(a,x,y) (!in(a,x,y))
#define sz(a) ((int)a.size())
#define repv(i,a) for(int i=0;i<sz(a);i++)
#define revv(i,a) for(int i=sz(a)-1;i>=0;i--)
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define rev(i,a,b) for(int i=a;i>=b;i--)
#define all(a) a.begin(),a.end()
#define pb push_back

#define AND(a,b) ((a) & (b))
#define OR(a,b) ((a)|(b))
#define XOR(a,b) ((a) ^ (b))
#define xx first
#define yy second
#define mp make_pair
#define sqr(x) ((x)*(x))
#define sqrt(x) sqrt(1.0*(x))

#define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val.
#define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val.
#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)
#define left nokol_left
#define right nokol_right
#define countbit(x) __builtin_popcountll((ll)x)
#define PQ priority_queue
#define FAST ios_base::sync_with_stdio(0);cin.tie(0);
#define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin())
#define READ(f) freopen(f, "r", stdin)
#define WRITE(f) freopen(f, "w", stdout)

typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<long long,long long> pll;
typedef vector<int> vi;
typedef vector<long long> vll;

template<class T>T __sqr(const T x){return x*x;}
template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; }
template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);}
template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;}
inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);}
template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}}
template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}}
template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;}
template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}

template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; }
template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); }
template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); }
template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}

void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; }
pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }

const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103};
const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};

#define pi acos(-1.0)
#define eps  1e-12
#define MX   (100000+20)
#define inf  1000000000000000000LL
#define MOD  1000000007LL
//---------->0123456789123465789
#define lmt  10000

ll a[MX] , mob[MX];
ll sz = 0;

int vis[MX];
void mobius(){
    mob[1] = 1;
    int cnt = 0;
    rep(i,1,lmt){
        for(int j=i+i;j<=lmt;j+=i){
            mob[j] -= mob[i];
        }
    }
}

bool take[MX];
vector<int>prime , G[MX] , nb[MX];

void sieve(){
    prime.pb(2);
    for(int i=3;i<=lmt+100;i+=2){
        if(!vis[i]){ prime.pb(i);
            for(int j=i*3;j<=lmt+100;j+=2*i){
                vis[j] = true;
            }
        }
    }
//    cout<<prime.size()<<endl;
}

ll n;
void calc(){
    rep(i,1,n){
        if( !take[ a[i] ] ){
            ll sv = a[i];
            take[ a[i] ] = 1;

            ll lm = sqrt(a[i]);

//            cout<<"lm "<<lm<<endl;
            for(int j = 0;prime[j]<=lm;j++){
                int cnt =  0;
                while(a[i]%prime[j]==0){
                    a[i]/=prime[j];
                    cnt = 1;
                    lm = sqrt(a[i]);
                }
                if(cnt) nb[ sv ].pb(prime[j]);
            }

//            cout<<a[i]<<" ore "<<endl;
            if(a[i]!=1) nb[ sv ].pb( a[i] );
            a[i] = sv;
        }

//        if(a[i]==55) cout<<nb[ 55 ].size()<<" gu"<<endl;

        ll s = nb[ a[i] ].size();
        ll  hol = (1<<s)-1;
        for(int j=0;j<=hol;j++){
            ll mul = 1;
            rep(k,0,s-1){
                if(j&(1<<k)){
                    mul *= nb[ a[i] ][ k ];
                }
            }
            G[ mul ].pb(i);
        }
    }
}

struct DT{
    ll prev , cnt, mx,id;
    DT(){}
    DT(ll prev,ll cnt,ll mx,ll id):prev(prev),cnt(cnt),mx(mx),id(id){}
}stk[MX] ;

ll node[4*MX];
void build(int id,int s,int e){

    if(s==e){
        node[id] = a[s];
        return ;
    }
    int m = (s + e) / 2;
    int lf = 2 * id , rg = lf + 1;

    build(lf,s,m);
    build(rg,m+1,e);

    node[id] = max(node[lf],node[rg]);
}

ll query(int id,int s,int e,int st,int ed){

    if(st > ed) return 0;
    if(s==st && e==ed) return node[id];

    int m = (s + e) / 2;
    int lf = 2 * id , rg = lf + 1;

    ll ret = 0 ;
    if(ed<=m) ret = query(lf , s , m , st , ed);
    else if(st > m) ret = query(rg , m+1 , e , st , ed);
    else{
        ll r1 = query(lf , s, m , st ,m);
        ll r2 = query(rg , m+1,e ,m+1,ed);
        ret = max(r1 , r2);
    }
    return ret;
}

int main()
{
    sieve();
    mobius();

    scanf("%lld",&n);
    rep(i,1,n) scanf("%lld",a+i);
//
//    ll brute = 0;
//    rep(i,1,n){
//        ll mx = a[i];
//        rep(j,i+1,n){
//            mx = max(mx , a[j]);
//            if(__gcd(a[i],a[j])==1){
//                brute+=mx;
//            }
//        }
//    }
//
////    cout<<__gcd(a[1],a[2])<<endl;
//    cout<<brute<<endl;


    build(1,1,n);
    calc();
    ll ans = 0;
    rep(i,1,lmt){
        if(mob[i]){
            ll tot = 0;
            sz =0;

//        if(G[i].size()) {cout<<i<<" == "<<G[i].size()<<endl; }

            int lst;
            repv(j,G[i])
            {
                ll val = a[ G[i][j] ];
                ll nv = query(1,1,n,lst+1,G[i][j]-1);
                lst = G[i][j];

                if(sz){
                    swap(nv , val);
                    ll cnt = 0;
                    while(sz){
                        DT top = stk[sz-1];
                        if(top.mx<=val){
                            sz--;
                            tot += cnt*top.cnt*top.mx;
                            cnt += top.cnt;
                        }
                        else break;
                    }

                    if(cnt){
                        DT ob = DT(inf, cnt, val,j);
                        stk[sz++] = (ob);
                    }
                    swap(nv , val);
                }


                // divisible value gular position
//                if( val%i==0 ){
                DT ob;
                if(sz==0) {ob = DT(inf,1,val,j); stk[sz++] = ob;continue;}
                else       ob = DT(stk[sz-1].mx,1,val,j);

                ll cnt = 0;
                while(sz){
                    DT top = stk[sz-1];
                    if(top.mx <= val){
                        sz--;
                        tot += cnt*top.cnt*top.mx;
                        cnt += top.cnt;
                    }
                    else break;
                }

                tot += cnt*val;
                ob.cnt += cnt;
                stk[sz++] = ob;
//                }
            }

            if(sz){
                DT ob = stk[sz-1];sz--;

                while(sz){
                    DT nw = stk[sz-1]; sz--;
                    tot += nw.cnt*ob.cnt*nw.mx ;
                    nw.cnt += ob.cnt;
                    ob = nw;
                }
            }
            ans += mob[i] * tot;
//            cout<<i<<" ==> "<<ans<<endl;
//            if(i > 22) break;
        }
    }
    printf("%lld\n",ans);

    return 0;
}

/*
5
1 2 1 2 1

5
2 1 2 1 2

6
2 2 3 3 6 6

6
3 3 2 6 2 6

5
4 2 2 2 7

4
2 2 3 2

3
1 4 2

5
1 4 2 3 6
*/
