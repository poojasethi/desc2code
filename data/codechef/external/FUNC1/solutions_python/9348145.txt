//Done by: K Ashwin

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define TRvi(c, it) \
for (auto it = (c).begin(); it != (c).end(); it++)

#define s(x) scanf("%d", &x)
#define sl(x) scanf("%lld", &x)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define set0(a) memset(a, 0, sizeof(a))
#define setdp(a) memset(a, -1, sizeof(a))
#define INF 2000000000
#define MOD 1000000007

int isP[1000005];
vector <int> primes;
map <ll, ll> m;

void sieve()
{
    int i, j;

    isP[0] = isP[1] = 1;

    for (i = 2; i * i < 1000005; ++i) {
        if (!isP[i]) {
            primes.pb(i);

            for (j = i; i * j < 1000005; ++j)
                isP[i * j] = i;
        }
    }

    for (; i < 1000005; ++i)
        if (!isP[i])
            primes.pb(i);
}

ll powermul(ll x, ll n)
{
    if (n == 0)
        return 1LL;

    ll retval = powermul(x, n / 2);
    retval *= retval;

    if (n % 2)
        return retval * x;

    else
        return retval;
}

ll convert(ll x)
{
    vector <int> v;
    int cnt;

    TRvi (primes, it) {
        cnt = 0;

        while (x % *it == 0) {
            cnt++;
            x /= *it;
        }

        if (cnt)
            v.pb(cnt);

        if (x == 1)
            break ;
    }

    if (x != 1)
        v.pb(1);

    sort(v.rbegin(), v.rend());

    /*cout << "Here\n";
    TRvi (v, it)
        cout << *it << " ";
    cout << endl;*/

    x = 1;
    REP (i, 0, v.size() - 1) {
        x *= powermul(primes[i], v[i]);
    }

    return x;
}

ll solve(ll x)
{
    //cout << x << " ";
    x = convert(x);
    //cout << x << endl;

    if (m.find(x) != m.end())
        return m[x];

    vector <int> v;

    int tmp = sqrt(x);

    ll t1 = 1;
    REP (i, 2, tmp) {
        if (x % i == 0) {
            t1 += solve(i);

            if (t1 >= MOD)
                t1 -= MOD;

            if (x / i != i) {
                t1 += solve(x / i);

                if (t1 >= MOD)
                    t1 -= MOD;
            }
        }
    }

    m[x] = t1;

    return t1;
}

int main()
{
    int t;
    ll n, c;

    sieve();

    s(t);

    m[1] = 1;
    while (t--) {
        sl(n);
        sl(c);

        //cout << n << " " << c << endl;

        printf("%lld\n", (solve(n) * c) % MOD);
    }

    return 0;
}
