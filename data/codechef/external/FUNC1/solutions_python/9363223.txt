//==================================================================//
// Name        : flash7even                                         //
// Author      : Tarango Khan                                       //
// Codeforces  : flash_7                                            //
// Topcoder    : flash_7                                            //
// Hackerrank  : flash_7                                            //
// Email       : tarangokhan77@gmail.com                            //
// Facebook    : tarango.khan                                       //
//==================================================================//

//==================================================================//
#include <bits/stdc++.h>                                            //
using namespace std;                                                //
#define FOR(s,e)        for(int i=s;i<=e;i++)                       //
#define pb              push_back                                   //
#define ppb             pop_back                                    //
#define mp              make_pair                                   //
#define F               first                                       //
#define S               second                                      //
#define eps             1e-9                                        //
#define FABS(x)         ((x)+eps<0?-(x):(x))                        //
#define Set(x,p)        (x|(1<<p))                                  //
#define Reset(x,p)      (x & ~(1<<p))                               //
#define Check(x,p)      (x&(1<<p))                                  //
#define pf              printf                                      //
#define sf              scanf                                       //
#define pi              acos(-1.0)                                  //
#define mems(x,v)       memset(x,v,sizeof(x))                       //
#define SZ(x)           ((int)(x).size())                           //
#define fills(v,n)      fill(v.begin(), v.end(), n)                 //
#define vsort(v)        sort(v.begin(),v.end())                     //
#define asort(v,n)  	sort(a,a+n)                                 //
#define LL              long long                                   //
#define LLU             long long unsigned int                      //
//==================================================================//

//==================================================================//
bool equalTo(double a, double b) {                                  //
    if (fabs(a - b) <= eps) return true;return false;}              //
bool notEqual(double a, double b) {                                 //
    if (fabs(a - b) > eps) return true;return false;}               //
bool lessThan(double a, double b) {                                 //
    if (a + eps < b) return true;return false;}                     //
bool lessThanEqual(double a, double b) {                            //
    if (a < b + eps) return true;return false;}                     //
bool greaterThan(double a, double b) {                              //
    if (a > b + eps) return true;return false;}                     //
bool greaterThanEqual(double a, double b) {                         //
    if (a + eps > b) return true;return false;}                     //
LL GCD(LL a,LL b){ if(b == 0) return a; return GCD(b,a%b);}         //
LL LCM(LL a,LL b){ return a*b/GCD(a,b);}                            //
LL POW(LL a,LL p){ LL res = 1,x = a;while(p){if(p&1)                //
    res = (res*x); x = (x*x);p >>= 1;} return res;}                 //
//==================================================================//

//==================================================================//
//int knightDir[8][2] = {{-2,1},{-1,2},{1,2},{2,1},                 //
//                      {2,-1},{-1,-2},{1,-2},{-2,-1}};             //
//int dir8[4][2] = {{-1,0},{0,1},{1,0},{0,-1},                      //
//                 {-1,-1},{1,1},{1,-1},{-1,1}};                    //
//int dir4[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};                     //
                                                                    //
//=======// Done With The Shortcut Stuffs! Now Let's Code! //=======//

#define Size 1000005
#define Mod 1000000007

long long big_mod(long long N,long long P){
	if(P == 0) return 1;
	if(P%2 == 0){
		long long ret = big_mod(N,P/2);
		return ((ret%Mod)*(ret%Mod))%Mod;
	}else{
		return ((N%Mod)*(big_mod(N,P-1)%Mod))%Mod;
	}
}

map<LL,LL> Map;
LL N,C;
vector<LL> divs;
int total_Div;

void findDiv(LL cur){
	for(LL d = 1;d*d<=cur;d++){
		if(cur%d == 0){
			LL d2 = cur/d;
			divs.pb(d);
			if(d2 != d && d2!=cur) divs.pb(d2);
		}
	}
	sort(divs.begin(),divs.end());
	total_Div = divs.size();
	return;
	pf("Divisor List:");
	for(int i = 0;i<total_Div;i++){
		pf(" %lld",divs[i]);
	}
	pf("\n");
}

bool mark[Size];
vector <int> pL;
int pCnt;

void seive(){
    memset (mark, true, sizeof (mark));
    mark [0] = mark [1] = false;
    for(int i = 4;i<Size;i+=2) mark [i] = false;
    for(int i=3;i*i<=Size;i+=2){
        if(mark[i]){
            for(int j=i*i;j<Size;j+=2*i)
                mark [j] = false;
        }
    }
    pL.clear ();
    pL.push_back (2);
    for(int i=3;i<Size;i+=2){
        if(mark[i]){
            pL.push_back (i);
        }
    }
    pCnt = pL.size();
}

bool cmp(LL a,LL b){
	return (a>b);
}
vector<LL> pfList;

LL conv(LL num){
	pfList.clear();
	for(int i = 0;i<pCnt;i++){
		LL fctor = pL[i];
		LL cnt = 0;
		if(fctor*fctor>num) break;
		if(num%fctor == 0){
			while(num%fctor == 0){
				cnt++;
				num /= fctor;
			}
			pfList.pb(cnt);
		}
	}
	if(num>1){
		pfList.pb(1);
	}
	sort(pfList.begin(),pfList.end(),cmp);
	LL val = 1;
	int Sz = pfList.size();
	for(int i = 0;i<Sz;i++){
		LL r = big_mod(pL[i],pfList[i]);
		val = val*r;
	}
	return val;
}

LL solve(LL cur){
	LL ncur = conv(cur);
	//pf("Convert from %lld to %lld\n",cur,ncur);
	cur = ncur;
	if(Map[cur] != 0) return Map[cur];
	LL sum = 0;
	for(int i = 0;i<total_Div && divs[i]<cur;i++){
		LL d = divs[i];
		if(cur%d == 0){
			sum += solve(d);
		}
	}
	return Map[cur] = sum;
}

int main(){
	seive();
	int nCase;
	sf("%d",&nCase);
	Map.clear();
	Map[1] = 1;
	for(int cs = 1;cs<=nCase;cs++){
		sf("%lld %lld",&N,&C);
		N = conv(N);
		divs.clear();
		LL res = 0;
		findDiv(N);
		for(int i = 0;i<total_Div;i++){
			res += solve(divs[i]);
		}
		res = ((res%Mod)*C)%Mod;
		pf("%lld\n",res);
	}
}
