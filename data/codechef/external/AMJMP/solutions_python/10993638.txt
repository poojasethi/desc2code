// #include<abhi.944>
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
typedef double ld;
const long double PI=3.1415926535897932384626;
const ll MOD = 1000000000+7;
const int INF = 0x3f3f3f3f;
#define ps printf(" ")
#define pn printf("\n")
#define sc(n) scanf("%d",&n)
#define forall(it, x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++)
#define sz size()
#define ff first
#define ss second
#define pb push_back 
#define mp make_pair
#define fill(a,val) memset(a,val,sizeof(a))
#define pii pair<int ,int>
#define TRACE(x) cerr<<__FUNCTION__<<":"<<__LINE__<<": ERROR---->"<<x<<endl;
#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__,__VA_ARGS__)
template <typename Arg1> void __f(const char* name,Arg1&& arg1){cerr<<name<<" : "<<arg1<<std::endl;}
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args) {const char* comma=strchr(names+1,',');cerr.write(names,comma-names)<<" : "<<arg1<<" | ";__f(comma+1,args...);}
#else
#define trace(...)
#endif
ll Nmul(ll A,ll B){ll ret = (ll)((ll)(A)*(ll)(B));return ret;}ll Mmul(ll a,ll b,ll mod){ll c=Nmul(a,b);c%=mod;while(c<0){c+=mod;};return c;}
ll Nadd(ll A,ll B){ll ret = (ll)((ll)(A)+(ll)(B));return ret;}ll Madd(ll a,ll b,ll mod){ll c=Nadd(a,b);while(c>=mod){c-=mod;};while(c<0){c+=mod;};return c;}
ll Nsub(ll A,ll B){ll ret = (ll)((ll)(A)-(ll)(B));return ret;}ll Msub(ll a,ll b,ll mod){return Madd(a,mod-b,mod);}
ll Npow(ll A,ll p){ll ret=1;while(p){if(p&1){ret=(ret*A);}A=(A*A);p>>=1;}return ret;}ll Mpow(ll a,ll n,ll b){ll res=1;while(n){if(n&1) {res=Mmul(res,a,b);}a=Mmul(a,a,b);n>>=1;}return Madd(res,0,b);}
ll Ndiv(ld A,ld B,bool ud){if(B){ld ret=(ld)(A)/(ld)(B);if(ud)return ceil(ret);return floor(ret);}return INF;}ll Mdiv(ll a,ll b,ll mod){ll ans=Mmul(a,Mpow(b,mod-2,mod),mod);return ans;}


#define N 5555

int n;
int dp[N+1][3];
int a[N+1];

int main(int argc, char const *argv[])
{
	sc(n);
	for(int i=1;i<=n;i++) sc(a[i]);

	for(int i=1;i<=n;i++) {
		for(int j=i-1;j>=1;j--) {
			if(a[i] > a[j]) dp[i][0] = max(dp[i][0], dp[j][1]+1);
			if(a[i] < a[j]) dp[j][1] = max(dp[j][1], dp[i][0]+1);
		}
	}

	for(int i=1;i<=n;i++) {
		printf("%d ",max(dp[i][0],dp[i][1]));
	}pn;
	return 0;
}