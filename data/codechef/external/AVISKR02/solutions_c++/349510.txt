#if 1
// Utility functions. Scroll down to solution
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <list>
#include <algorithm>
#include <utility>
#include <functional>
using namespace std;

typedef long long LL;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;

#define mp(x, y) make_pair(x, y)
#define sz(v) (int) ((v).size())

#define rep(i, n) for (int i = 0; i < n; i++)
#define repb(i, n) for (int i = n; i >= 0; i--)
#define fori(i, b, e) for (int i = b; i < e; i++)
#define forb(i, b, e) for (int i = b; i >= e; i--)

#define BUF_SIZE 32768

char _inBuf[BUF_SIZE];
int _ip = 0, _il = 0;

inline
char nc()
{
	if (_ip == _il)
	{
		_il = fread(_inBuf, 1, BUF_SIZE, stdin);
		_ip = 0;
		if (_il == 0)
		{
			return -1;
		}
	}
	return _inBuf[_ip++];
}

inline
int ni()
{
	char ch = nc();
	for (; ch == ' ' || ch == '\t' || ch == '\n'; ch = nc()) ;
	if (ch == -1)
		return -1;
	
	int sign = 1;
	if (ch == '-')
	{
		sign = -1;
		ch = nc();
	}
	int res = 0;
	for (; ch >= '0' && ch <= '9'; ch = nc())
	{
		res = ((res << 3) + (res << 1));
		res += ch - '0';
	}
	return sign * res;
}

inline
LL nl()
{
	char ch = nc();
	for (; ch == ' ' || ch == '\t' || ch == '\n'; ch = nc()) ;
	if (ch == -1)
		return -1;

	LL sign = 1;
	if (ch == '-')
	{
		sign = -1;
		ch = nc();
	}
	LL res = 0;
	for (; ch >= '0' && ch <= '9'; ch = nc())
	{
		res = ((res << 3) + (res << 1));
		res += ch - '0';
	}
	return sign * res;
}

inline
int ns(char* s)
{
	char* os = s;
	char ch = nc();
	for (; ch == ' ' || ch == '\t' || ch == '\n'; ch = nc()) ;
	if (ch == -1)
		return 0;

	for (; ch != ' ' && ch != '\t' && ch != '\n' && ch != -1; ch = nc())
	{
		*s++ = ch;
	}
	*s = '\0';
	return s - os;
}

char _outBuf[BUF_SIZE];
int _op = 0;

inline
void out(char ch)
{
	if (_op == BUF_SIZE)
	{
		fwrite(_outBuf, 1, BUF_SIZE, stdout);
		_op = 0;
	}
	_outBuf[_op++] = ch;
}

inline
void out(int v)
{
	static char s[10];
	if (v == 0)
	{
		out('0');
		return;
	}
	if (v < 0)
	{
		out('-');
		v = -v;
	}
	int sp = 0;
	while (v > 0)
	{
		s[sp++] = v % 10 + '0';
		v /= 10;
	}
	while (--sp >= 0)
		out(s[sp]);
}

inline
void out(LL v)
{
	static char s[20];
	if (v == 0)
	{
		out('0');
		return;
	}
	if (v < 0)
	{
		out('-');
		v = -v;
	}
	int sp = 0;
	while (v > 0)
	{
		s[sp++] = v % 10 + '0';
		v /= 10;
	}
	while (--sp >= 0)
		out(s[sp]);
}

inline
void out(const char* s)
{
	for (; *s != '\0'; s++)
		out(*s);
}

inline
void _flush()
{
	if (_op > 0)
	{
		fwrite(_outBuf, 1, _op, stdout);
		_op = 0;
	}
}

void solve();

int main()
{
#ifdef __USER_HOME__
	freopen("1.txt", "r", stdin);
#endif

	solve();

	_flush();
	return 0;
}

#endif

// Solution

const LL MOD = 1000000007;

void matMul(const LL* a, const LL* b, LL *c)
{
	c[0] = (a[0] * b[0] + a[1] * b[2]) % MOD;
	c[1] = (a[0] * b[1] + a[1] * b[3]) % MOD;
	c[2] = (a[2] * b[0] + a[3] * b[2]) % MOD;
	c[3] = (a[2] * b[1] + a[3] * b[3]) % MOD;
}

const LL A[] = {1, 1, 1, 0};

LL Deep[100][4];

void matPow(const LL* a, LL b, int d, LL* c)
{
	if (b == 0)
	{
		c[0] = c[3] = 1;
		c[1] = c[2] = 0;
		return;
	}
	LL* r = Deep[d];
	if (b & 1)
	{
		matPow(a, b - 1, d + 1, r);
		matMul(r, A, c);
	}
	else
	{
		matPow(a, b / 2, d + 1, r);
		matMul(r, r, c);
	}
}

void solve()
{
	LL F[4];
	const LL inv5 = 400000003;
	int T = ni();
	rep(tc, T)
	{
		LL n = nl();
		matPow(A, 4 * n, 0, F);
		LL res = (3 * F[1]) % MOD;
		res = (res - 1 + MOD) % MOD;
		res = (res + F[3]) % MOD;
		res = (res * inv5) % MOD;
		out(res);
		out('\n');
	}
}

