N = input()
A = list(map(int, raw_input().split()))

maxTree = [0] * (4 * N + 7)
minTree = [0] * (4 * N + 7)

def maxbuild(node, a, b):
    mid = a + b >> 1
    left = node << 1
    right = left + 1

    if a == b: # leaf node
        maxTree[node] = A[a]

    else: # non-leaf node
        maxbuild(left, a, mid)
        maxbuild(right, mid+1, b)
        maxTree[node] = max(maxTree[left], maxTree[right])

def maxQuery(node, a, b, i, j):
    mid = a + b >> 1
    left = node << 1
    right = left + 1

    if a > j  or i > b:  return 0 # completely outside
    if i <= a and b <= j: return maxTree[node] # completely inside

    return max(maxQuery(left, a, mid, i, j),
               maxQuery(right, mid+1, b, i, j))

def minbuild(node, a, b):
    mid = a + b >> 1
    left = node << 1
    right = left + 1

    if a == b: # leaf node
        minTree[node] = A[a]

    else: # non-leaf node
        minbuild(left, a, mid)
        minbuild(right, mid+1, b)
        minTree[node] = min(minTree[left], minTree[right])

def minQuery(node, a, b, i, j):
    mid = a + b >> 1
    left = node << 1
    right = left + 1

    if a > j or i > b:  return 10**8 + 1 # completely outside
    if i <= a and b <= j: return minTree[node] # completely inside

    return min(minQuery(left, a, mid, i, j),
               minQuery(right, mid+1, b, i, j))

def solve():
    L, R = map(int, raw_input().split())
    time = minQuery(1, 0, N-1, L, R)
    initTime = (maxQuery(1, 0, N-1, L, R) - time) / 2.0
    return float(time + max(maxQuery(1, 0, N-1, 0, L-1), 
                            maxQuery(1, 0, N-1, R+1, N-1), 
                            initTime))

maxbuild(1, 0, N-1)
minbuild(1, 0, N-1)
print '\n'.join(str(solve()) for q in range(input()))