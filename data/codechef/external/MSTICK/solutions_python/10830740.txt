INF = 10 ** 20
Z = 0

def min_tree(low, high, pos):
    if low == high:
        mintree[pos] = a[low]
        return None

    mid = (high + low) / 2

    min_tree(low, mid, 2 * pos)
    min_tree(mid + 1, high, 2 * pos + 1)

    mintree[pos] = min(mintree[2 * pos], mintree[2 * pos + 1])


def max_tree(low, high, pos):
    # print pos, low
    if low == high:
        # print "hi"
        maxtree[pos] = a[low]
        return None

    mid = (high + low) / 2

    max_tree(low, mid, 2 * pos)
    max_tree(mid + 1, high, 2 * pos + 1)

    maxtree[pos] = max(maxtree[2 * pos], maxtree[2 * pos + 1])


def minquery(qlow, qhigh, low, high, pos):
    if (qlow > high or qhigh < low) or (qlow > qhigh):
        return INF
    if qlow <= low and qhigh >= high:
        return mintree[pos]

    mid = (high + low) / 2
    return min(minquery(qlow, qhigh, low, mid, 2 * pos),
               minquery(qlow, qhigh, mid + 1, high, 2 * pos + 1))


def maxquery(qlow, qhigh, low, high, pos):
    if (qlow > high or qhigh < low) or (qlow > qhigh):
        return Z
    if qlow <= low and qhigh >= high:
        return maxtree[pos]

    mid = (high + low) / 2
    return max(maxquery(qlow, qhigh, low, mid, 2 * pos),
               maxquery(qlow, qhigh, mid + 1, high, 2 * pos + 1))

a=[0]
n = input()
ar = map(int, raw_input().split())
a.extend(ar)

mintree = [0] * (4 * n + 1)
maxtree = [0] * (4 * n + 1)

max_tree(1, n, 1)
min_tree(1, n, 1)

for i in xrange(input()):
    l, r = map(int, raw_input().split())
    l += 1
    r += 1
    m = minquery(l, r, 1, n, 1)
    M = maxquery(l, r, 1, n, 1)

    Ml = maxquery(1, l - 1, 1, n, 1)
    Mr = maxquery(r + 1, n, 1, n, 1)

    max1 = max(Ml, Mr) + m
    max2 = m + (M - m) / 2.0

    if max2 > max1:
        print max2
    else:
        print float(max1)
