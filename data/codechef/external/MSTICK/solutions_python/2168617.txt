#!/usr/bin/env python
#-*- coding:utf-8 -*-

# http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor

from math import log

def log2(X):
    return int(log(X, 2))

class MinMaxSparseTables:

    def __init__(self, N, A):
        l = log2(N)
        self.m, self.M = [], []
        for i in xrange(N):
            self.m.append([A[i]] + [0] * l)
            self.M.append([A[i]] + [0] * l)
        j = 1
        while j <= l:
            i = 0
            w = 1 << j
            while i + w - 1 < N:
                self.m[i][j] = min(self.m[i][j - 1], self.m[i + w / 2][j - 1])
                self.M[i][j] = max(self.M[i][j - 1], self.M[i + w / 2][j - 1])
                i += 1
            j += 1

    def queryMin(self, i, j):
        k = log2(j - i + 1)
        return min(self.m[i][k], self.m[j - (1 << k) + 1][k])

    def queryMax(self, i, j):
        k = log2(j - i + 1)
        return max(self.M[i][k], self.M[j - (1 << k) + 1][k])

def main():
    N = int(raw_input().strip())
    B = map(int, raw_input().strip().split()[:N])
    MMST = MinMaxSparseTables(N, B)
    Q = int(raw_input().strip())
    for q in xrange(Q):
        L, R = map(int, raw_input().strip().split()[:2])
        P    =  MMST.queryMin(L, R)
        M    = (MMST.queryMax(L, R) - P) / 2.
        if 0   <= L-1:
           M = max(M, MMST.queryMax(0, L - 1))
        if R+1 <= N-1:
           M = max(M, MMST.queryMax(R + 1, N - 1))
        print '%.1f' % (P + M)

main()
