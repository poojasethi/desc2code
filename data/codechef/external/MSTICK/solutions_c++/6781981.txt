#include<bits/stdc++.h>
using namespace std;
void createmintree(int node, int l, int r, vector <int>& myvector, vector <int>& minst );
void createmaxtree(int node, int l, int r, vector <int>& myvector, vector <int>& maxst );
int findmax(int node, int d,int e, int a, int b, vector<int> &myvector, vector <int> & maxst   );
int findmin(int node, int d,int e, int a, int b, vector<int> &myvector, vector <int> & minst   );
int main()
{
    int n;
    cin>>n;
    vector <int> myvector(n);
    int i;
    for(i=0;i<n;i++)
       cin>>myvector[i];

    int s=2*(pow(2,floor(log2(n))+1));



    vector <int> minst(s) ;
    createmintree(0,0,n-1,myvector,minst);

    vector <int> maxst(s) ;
    createmaxtree(0,0,n-1,myvector,maxst);

    int q,a,b;
    cin>>q;
    int u1,u2,v1,v2;
    while(q--)
    {
        cin>>a>>b;
        u1=findmax(0,0,n-1,a,b,myvector,maxst);
        u2=findmin(0,0,n-1,a,b,myvector,minst);

        cout<<fixed;
        if (a==0 && b==n-1)
            cout<<setprecision(1)<<(double)(myvector[u2]+(myvector[u1]-myvector[u2])*1.0/2)<<'\n';
        else if (a==0)
        {
            v1=findmax(0,0,n-1,b+1,n-1,myvector,maxst);

            cout<<setprecision(1)<<(double)(myvector[u2]+max((myvector[u1]-myvector[u2])*1.0/2,myvector[v1]*1.0))<<'\n';
        }
        else if (b==n-1)
        {
            v1=findmax(0,0,n-1,0,a-1,myvector,maxst);

            cout<<setprecision(1)<<(double)(myvector[u2]+max((myvector[u1]-myvector[u2])*1.0/2,myvector[v1]*1.0))<<'\n';
        }
        else
        {
             v1=findmax(0,0,n-1,0,a-1,myvector,maxst);
             v2=findmax(0,0,n-1,b+1,n-1,myvector,maxst);
            double o;
            o=max(myvector[v1],myvector[v2]);
            cout<<setprecision(1)<<(double)(myvector[u2]+max((myvector[u1]-myvector[u2])*1.0/2,o))<<'\n';
        }


    }


    return 0;
}

void createmintree(int node, int l, int r, vector <int>& myvector, vector <int>& minst )
{
    if (l==r)
        minst[node]=r;
    else
    {
        createmintree(2*node+1,l,(l+r)/2,myvector,minst);
        createmintree(2*node+2,(l+r)/2+1,r,myvector,minst);

        if (myvector[minst[2*node+1]]<=myvector[minst[2*node+2]])
            minst[node]=minst[2*node+1];
        else
            minst[node]=minst[2*node+2];

    }
}

void createmaxtree(int node, int l, int r, vector <int>& myvector, vector <int>& maxst )
{
    if (l==r)
        maxst[node]=l;
    else
    {
        createmaxtree(2*node+1,l,(l+r)/2,myvector,maxst);
        createmaxtree(2*node+2,(l+r)/2+1,r,myvector,maxst);

        if (myvector[maxst[2*node+1]]>=myvector[maxst[2*node+2]])
            maxst[node]=maxst[2*node+1];
        else
            maxst[node]=maxst[2*node+2];

    }
}

int findmax(int node, int d,int e, int a, int b, vector<int> &myvector, vector <int> & maxst   )
{
    if (d>b||e<a)
        return -1;
    else if (d>=a&&e<=b)
        return maxst[node];

    int p1,p2;

    p1=findmax(2*node+1,d,(d+e)/2,a,b,myvector,maxst);
    p2=findmax(2*node+2,(d+e)/2+1,e,a,b,myvector,maxst);

    if (p1==-1)
        return p2;
    if (p2==-1)
        return p1;
    if (myvector[p1]>=myvector[p2])
        return p1;
    else
        return p2;
}

int findmin(int node, int d,int e, int a, int b, vector<int> &myvector, vector <int> & minst   )
{
    if (d>b||e<a)
        return -1;
    else if (d>=a&&e<=b)
        return minst[node];

    int p1,p2;

    p1=findmin(2*node+1,d,(d+e)/2,a,b,myvector,minst);
    p2=findmin(2*node+2,(d+e)/2+1,e,a,b,myvector,minst);

    if (p1==-1)
        return p2;
    if (p2==-1)
        return p1;
    if (myvector[p1]<=myvector[p2])
        return p1;
    else
        return p2;
}
