#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
typedef pair<int,int> pii;
#define MOD 1000000007

class segment_tree
{
private:
    int N;
    vector<ll> A;
    vector<pii> t;
public:
    segment_tree(int N) {
        this->N = N;
        A.resize(N);
        t.resize(4*N);
        for (int i = 0; i < N; i++) scanf("%lld",&A[i]);
        build(1,0,N-1);
    }
    pii combine(pii a, pii b) {
        int indMin,indMax;
        if(A[a.first] <= A[b.first]) indMin = a.first;
        else indMin = b.first;
        if(A[a.second] >= A[b.second]) indMax = a.second;
        else indMax = b.second;
        return make_pair(indMin,indMax);
    }
    void build(int v, int tl, int tr) {
        if (tl == tr) {
            t[v] = make_pair(tl,tl);
        }
        else {
            int tm = (tl + tr) >> 1;
            int z = (v << 1);
            build(z,tl,tm);
            build(z+1,tm+1,tr);
            pii a = t[z];
            pii b = t[z+1];
            t[v] = combine(a,b);
        }
    }
    pii Query(int v, int tl, int tr, int l, int r) {
        if(tl == l && tr == r) {
            return t[v];
        }
        int z = v << 1;
        int tm = (tl + tr) >> 1;
        if(r <= tm)
            return Query(z,tl,tm,l,r);
        if(l > tm)
            return Query(z+1,tm+1,tr,l,r);
        pii a = Query(z,tl,tm,l,tm);
        pii b = Query(z+1,tm+1,tr,tm+1,r);
        return combine(a,b);
    }
    ll getMin(pii a) {
        return A[a.first];
    }
    ll getMax(pii a) {
        return A[a.second];
    }
};
int main()
{
	#ifndef ONLINE_JUDGE
        freopen("input.txt","r",stdin);
        freopen("output.txt","w",stdout);
    #endif
    int N,Q,L,R;
    scanf("%d",&N);
    segment_tree S(N);
    scanf("%d",&Q);
    while(Q--) {
        scanf("%d%d",&L,&R);

        pii inInterval = S.Query(1,0,N-1,L,R);
        ll m = S.getMin(inInterval);
        ll M = S.getMax(inInterval);
        double a,b;
        a = b = -1.0;
        if(L-1 >= 0) {
            a = (double)(m + S.getMax(S.Query(1,0,N-1,0,L-1)));
        }
        if(R+1 < N) {
            b = (double)(m + S.getMax(S.Query(1,0,N-1,R+1,N-1)));
        }
        double c = (M + m) * 1.0;
        c /= 2.0;
        printf("%0.1lf\n",max(c,max(a,b)));
    }
    #ifndef ONLINE_JUDGE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
    #endif
    return 0;
}

