// Segment Tree lazy Propapgation ( Shivani Gupta , DTU )
#include<bits/stdc++.h>
using namespace std;
 
#define ll long long int
#define mp make_pair
#define pb push_back
#define s(n) scanf("%d",&n);
#define sl(n) scanf("%lld",&n);
#define p(n) printf("%d\n",n)
#define pl(n) printf("%lld\n",n)
 
struct node{	
	ll mini;
	ll maxi;
};
//ll lazy[4*100000+7];
node tree[3*100000+7];
ll a[100000+6];
node combine(node x,node y){
	node t;
	t.maxi=max(x.maxi,y.maxi);
	t.mini=min(x.mini,y.mini);
	return t;
}
node init(ll x){
	node t;
	t.maxi=t.mini=x;
	return t;
}
void build(ll s,ll e,ll idx){
	if(s==e){
		tree[idx]=init(a[s]);
		return ;
	}
	ll m=(s+e)>>1;
	ll l=(idx<<1)+1;
	ll r=l+1;
	build(s,m,l);
	build(m+1,e,r);
	tree[idx]=combine(tree[l],tree[r]);
}
/*
void update(ll idx,ll s,ll e,ll i,ll j,ll x)
{
	if(lazy[idx]!=0){
		tree[idx].sum=lazy[idx];
		if(s!=e){
			int m=(s+e)/2;
			lazy[2*idx+1]+=lazy[idx]*lazy[idx]*(m-s+1)+2*lazy[idx]*tree[2*idx+1].sum;
			lazy[2*idx+2]+=lazy[idx]*lazy[idx]*(e-m)+2*lazy[idx]*tree[2*idx+2].sum;
		}
		lazy[idx]=0;
	}
	if(s>e||s>j||e<i)
		return;
    //if(s>e||id>e||id<s)return;
   //Range update
    	if(s>=i&&e<=j){
    		
    		tree[idx].sum+=x*x*(e-s+1)+2*x*tree[idx].sum;
    		if(s!=e){
    			int m=(s+e)/2;
    			lazy[2*idx+1]+=x*x*(m-s+1)+2*x*tree[2*idx+1].sum;;
    			lazy[2*idx+2]+=x*x*(e-m)+2*x*tree[2*idx+2].sum;;
    		}
    		return;
    	}
   	
    /*Point update 
    if(s==e&&s==id)
    {
        tree[idx]=init(x);
        return;
    }
    
    ll m=(s+e)>>1;
	ll l=(idx<<1)+1;
	ll r=l+1;
    update(l,s,m,i,j,x);
    update(r,m+1,e,i,j,x);
    tree[idx]=combine(tree[l],tree[r]);
}

void update1(ll idx,ll s,ll e,ll i,ll j,ll x)
{
	if(lazy[idx]!=0){
		tree[idx].sum=lazy[idx];
		if(s!=e){
		
    			int m=(s+e)/2;
			lazy[2*idx+1]+=lazy[idx]*lazy[idx]*(m-s+1);
			lazy[2*idx+2]+=lazy[idx]*lazy[idx]*(e-m);
		}
		lazy[idx]=0;
	}
	if(s>e||s>j||e<i)
		return;
    //if(s>e||id>e||id<s)return;
   //Range update
    	if(s>=i&&e<=j){
    		tree[idx].sum+=x*x*(e-s+1);
    		if(s!=e){
    			int m=(s+e)/2;
    			lazy[2*idx+1]+=x*x*(m-s+1);
    			lazy[2*idx+2]+=x*x*(e-m);
    		}
    		return;
    	}
   	
    /*Point update 
    if(s==e&&s==id)
    {
        tree[idx]=init(x);
        return;
    }
    
    ll m=(s+e)>>1;
	ll l=(idx<<1)+1;
	ll r=l+1;
    update(l,s,m,i,j,x);
    update(r,m+1,e,i,j,x);
    tree[idx]=combine(tree[l],tree[r]);
}*/
node query(ll s,ll e,ll i,ll j,ll idx){
	/*if(lazy[idx]!=0){
		tree[idx].sum+=lazy[idx];
		if(s!=e){
			lazy[2*idx+1]+=lazy[idx];
			lazy[2*idx+2]+=lazy[idx];
		}
		lazy[idx]=0;
	}*/
	if(s>=i&&e<=j)
		return tree[idx];
	ll m=(s+e)>>1;
	ll l=(idx<<1)+1;
	ll r=l+1;
	if(m<i)
		return query(m+1,e,i,j,r);
	if(m>=j)
		return query(s,m,i,j,l);
	
	return combine(query(s,m,i,j,l),query(m+1,e,i,j,r));
}
int main(){
	ll n,q;
//	int t;
	//s(t);
	//while(t--){
	sl(n);
	int i;
//	memset(lazy,0,sizeof(lazy));
	for(i=0;i<n;i++)
		sl(a[i]);
	build(0,n-1,0);
	sl(q);
	while(q--){
		ll x,y;
		sl(x);
		sl(y);
		if(x>0&&y<n-1){
		node t=query(0,n-1,x,y,0);
			node tt=query(0,n-1,0,x-1,0);
		node ttt=query(0,n-1,y+1,n-1,0);
		printf("%.1f\n",max((t.maxi-t.mini)/2.0+t.mini,(double)(t.mini+max(tt.maxi,ttt.maxi))));
		}
		else if(x>0){
			node t=query(0,n-1,x,y,0);
			node tt=query(0,n-1,0,x-1,0);
		printf("%.1f\n",max((t.maxi-t.mini)/2.0+t.mini,(double)(t.mini+tt.maxi)));
		}
		else if(y<n-1){
			node t=query(0,n-1,x,y,0);
		node ttt=query(0,n-1,y+1,n-1,0);
		printf("%.1f\n",max((t.maxi-t.mini)/2.0+t.mini,(double)(t.mini+ttt.maxi)));
		}
		else{
			node t=query(0,n-1,x,y,0);
		printf("%.1f\n",(t.maxi-t.mini)/2.0+t.mini);
		}
	}
	return 0;
}