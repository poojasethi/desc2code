
#include<bits/stdc++.h>

using namespace std;

#define si(x) scanf("%d",&x)
#define pri(x) printf("%d",x)
#define sll(x) scanf("%lld",&x)
#define pll(x) printf("%lld",x)
#define sstr(s) scanf("%s",s)
#define pstr(s) printf("%s",s)
#define nl printf("\n")
#define ll long long int

struct sgt {
    int mini,mx;
};

sgt tr[1000000];

void build(int pos, int st, int end, int a[])
{
    if(st == end)
    {
	tr[pos].mini=tr[pos].mx=a[st];
	return;
    }
    build(pos*2+1,st,(st+end)/2,a);
    build(pos*2+2,1+(st+end)/2,end,a);
    tr[pos].mx=max(tr[pos*2+1].mx,tr[pos*2+2].mx);
    tr[pos].mini=min(tr[pos*2+1].mini,tr[pos*2+2].mini);
}

int minqry(int pos, int st, int end, int l, int r)
{
    if(st>r || end<l)
    {
	return 1000000000;
    }
    if(st>=l && end<=r)
    {
	return tr[pos].mini;
    }
    int p1=minqry(pos*2+1,st,(st+end)/2,l,r);
    int p2=minqry(pos*2+2,1+(st+end)/2,end,l,r);
    return min(p1,p2);
}
int mxquery(int pos, int st, int end, int l, int r)
{
    if(l>r)
	return 0;
    if(st>r || end<l)
	return 0;
    if(st>=l && end<=r)
	return tr[pos].mx;
    int p1=mxquery(pos*2+1,st,(st+end)/2,l,r);
    int p2=mxquery(pos*2+2,1+(st+end)/2,end,l,r);
//    tr[pos].mx=max(p1,p2);
    return max(p1,p2);
}
int main()
{
    int n;
    si(n);
    int b[n];
    for(int i=0;i<n;++i)
    {
	si(b[i]);
    }
    build(0,0,n-1,b);
    int q;
    si(q);
    while(q--)
    {
	int l,r;
	si(l);
	si(r);
	//double mncnt=mnqry(0,0,n-1,l,r);
	double mn=minqry(0,0,n-1,l,r);
	double maxi=max(mxquery(0,0,n-1,0,l-1),mxquery(0,0,n-1,r+1,n-1));
	double maxmid=mxquery(0,0,n-1,l,r);
	double ans1=mn,ans2=mn;
//	cout<<"totsum "<<totsum<<" sum "<<sum<<" mncnt "<<mncnt<<" mn "<<mn<<" maxmid "<<maxmid<<" maxi "<<maxi<<endl;
	
//	cout<<ans<<endl;
	ans1+=(maxmid-mn)/2.0;
	ans2+=maxi;
//	ans += (sum-(r-l+1)*mn)/2.0;
	printf("%.1lf",max(ans1,ans2));
	nl;
    }
    return 0;
}
