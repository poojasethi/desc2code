#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

class MinSegmentTree {
private : vector<int> st , A;
	int n;
	int left ( int p) { return p << 1; } // vi lagrer venstre
	//child paa indeks p*2
	int right ( int p) { return (p << 1) + 1; } // og hoeyre child
	//paa indeks p *2+1
void build ( int p, int L, int R) { // O(n log n)
	if (L == R)
	st[p] = L; // lagrer indeksen
	else { // rekursivt regnet ut verdiene
		build ( left (p) , L , (L + R) / 2) ;
		build ( right (p) , (L + R) / 2 + 1, R );
		int p1 = st[ left (p)], p2 = st[ right (p) ];
		st[p] = (A[p1] <= A[p2 ]) ? p1 : p2;
	}
}
int rmq ( int p, int L, int R, int i, int j) {// O( log n)
if (i > R || j < L) return -1; // segmentet er utenfor
//intervallet
if (L >= i && R <= j) return st[p]; // paa insiden av
//intervallet
// delvis innenfor intervallet , regner ut venstre og
//hoeyre del
int p1 = rmq ( left (p) , L , (L+R) / 2, i, j);
int p2 = rmq ( right (p) , (L+R) / 2 + 1, R , i, j);
if (p1 == -1) return p2; // hvis vi kommer utenfor
//segment f o r e s p o e r s e l e n
if (p2 == -1) return p1;
return (A[p1] <= A[p2 ]) ? p1 : p2;
}
int update_point ( int p, int L, int R, int idx , int new_value
) {
int i = idx , j = idx ;
// if the current interval does not intersect
// the update interval , return this st node value !
if (i > R || j < L)
return st[p];
// hvis intervallet er inkludert i oppdaterings omraadet
// oppdater st[ node ]
if (L == i && R == j) {
A[i] = new_value ; // oppdater under arrayen
return st[p] = L; // denne indeksen
}
// regner ut minste i venstre
// og hoeyre del av intervallet
int p1 , p2;
p1 = update_point ( left (p) , L , (L + R) /2, idx , new_value );
p2 = update_point ( right (p) , (L + R) / 2 + 1, R
, idx , new_value );
// returnerer indeksen til det minste tallet
return st[p] = (A[p1] <= A[p2 ]) ? p1 : p2;
}
public :
MinSegmentTree ( const vector <int > &_A) {
A = _A; // kopierer
n = ( int )A. size () ;
st. assign (4 * n, 0) ; // lagrer stor nok vector med
//nuller
build (1 , 0, n - 1) ; // rekursivt bygger treet
}
int rmq ( int i, int j) { return rmq (1 , 0, n - 1, i, j); } //
//bare overloading
int update_point ( int idx , int new_value ) {
return update_point (1 , 0, n - 1, idx , new_value );
}
};


class MaxSegmentTree {
private : vector <int > st , A;
int n;
int left ( int p) { return p << 1; } // vi lagrer venstre
//child paa indeks p*2
//46
int right ( int p) { return (p << 1) + 1; } // og hoeyre child
//paa indeks p *2+1
void build ( int p, int L, int R) { // O(n log n)
if (L == R)
st[p] = L; // lagrer indeksen
else { // rekursivt regnet ut verdiene
build ( left (p) , L , (L + R) / 2) ;
build ( right (p) , (L + R) / 2 + 1, R );
int p1 = st[ left (p)], p2 = st[ right (p) ];
st[p] = (A[p1] >= A[p2 ]) ? p1 : p2;
}
}
int rmq ( int p, int L, int R, int i, int j) {// O( log n)
if (i > R || j < L) return -1; // segmentet er utenfor
//intervallet
if (L >= i && R <= j) return st[p]; // paa insiden av
//intervallet
// delvis innenfor intervallet , regner ut venstre og
//hoeyre del
int p1 = rmq ( left (p) , L , (L+R) / 2, i, j);
int p2 = rmq ( right (p) , (L+R) / 2 + 1, R , i, j);
if (p1 == -1) return p2; // hvis vi kommer utenfor
//segment f o r e s p o e r s e l e n
if (p2 == -1) return p1;
return (A[p1] >= A[p2 ]) ? p1 : p2;
}
int update_point ( int p, int L, int R, int idx , int new_value
) {
int i = idx , j = idx ;
// if the current interval does not intersect
// the update interval , return this st node value !
if (i > R || j < L)
return st[p];
// hvis intervallet er inkludert i oppdaterings omraadet
// oppdater st[ node ]
if (L == i && R == j) {
A[i] = new_value ; // oppdater under arrayen
return st[p] = L; // denne indeksen
}
// regner ut minste i venstre
// og hoeyre del av intervallet
int p1 , p2;
p1 = update_point ( left (p) , L , (L + R) /2, idx , new_value );
p2 = update_point ( right (p) , (L + R) / 2 + 1, R
, idx , new_value );
// returnerer indeksen til det stoerste tallet
return st[p] = (A[p1] >= A[p2 ]) ? p1 : p2;
}
public :

MaxSegmentTree ( const vector <int > &_A) {
A = _A; // kopierer
n = ( int )A. size () ;
st. assign (4 * n, 0) ; // lagrer stor nok vector med
//nuller
build (1 , 0, n - 1) ; // rekursivt bygger treet
}
int rmq ( int i, int j) { return rmq (1 , 0, n - 1, i, j); } //
//bare overloading
int update_point ( int idx , int new_value ) {
return update_point (1 , 0, n - 1, idx , new_value );
}
};
int main(){
	int n;
	cin>>n;
	
	int b[n];
	
	for(int i = 0; i<n; i++){
		cin>>b[i];
	}
	
	vector<int> A(b, b+n);
	MinSegmentTree stmin(A);
	MaxSegmentTree stmax(A);
	
	int q;
	cin>>q;
	
	for(int i = 0; i<q; i++){
		int L, R;
		cin>>L>>R;
		
		int longest = b[stmax.rmq(L, R)];
		int shortest = b[stmin.rmq(L, R)];
		int longestOutside;
		if(L == 0){
			if(R != n-1){
				longestOutside = b[stmax.rmq(R+1, n-1)];
			}else{
				longestOutside = 0;
			}
		}else{
			if(R!= n-1){
				longestOutside = max(b[stmax.rmq(0, L-1)], b[stmax.rmq(R+1, n-1)]);
			}
			else{
				longestOutside = b[stmax.rmq(0, L-1)];
			}
		}
		
		float ans = max((float)(longestOutside + shortest), (longest + shortest)/2.0f);
		
		printf("%.1f\n", ans);
		
	}
	
	return 0;
}