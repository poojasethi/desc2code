#include <cstdio>
#include <iostream>
#include <cmath>
#include <climits>
#include <algorithm>

using namespace std;
typedef double D;

D  maxtree[400004];
pair<int,int> mintree[400004];

void buildmin(int A[],int node,int s,int e)
{
    if(s==e)
    {
        mintree[node]=make_pair(A[s],s);
        return;
    }
    int mid  = (e+s)/2;
    buildmin(A,2*node+1,s,mid);
    buildmin(A,2*node+2,mid+1,e);

    mintree[node]=min(mintree[2*node+1],mintree[2*node+2]);
}

pair<int,int> minquery(int node,int si,int ei,int l, int r)
{
    if(l>ei||si>r)
    {
        return make_pair(INT_MAX,-1);
    }
    if(si>=l&&ei<=r)
    {
        return mintree[node];
    }
    int mid = si+(ei-si)/2;
    pair<int,int> a = minquery(2*node+1,si,mid,l,r);
    pair<int,int> b = minquery(2*node+2,mid+1,ei,l,r);
    return min(a,b);
}


void buildmax(int A[],int node,int s,int e)
{
    if(s==e)
    {
        maxtree[node]=(D)A[s];
        return;
    }
    int mid  = s+(e-s)/2;
    buildmax(A,2*node+1,s,mid);
    buildmax(A,2*node+2,mid+1,e);

    maxtree[node]=max(maxtree[2*node+1],maxtree[2*node+2]);
}

D maxquery(int node,int si,int ei,int l, int r)
{
    if(l>ei||si>r)
    {
        return INT_MIN;
    }
    if(si>=l&&ei<=r)
    {
        return maxtree[node];
    }
    int mid = si+(ei-si)/2;
    D a = maxquery(2*node+1,si,mid,l,r);
    D b = maxquery(2*node+2,mid+1,ei,l,r);
    return max(a,b);
}

void updatemax(int node,int si,int ei,int l,int r,D val)
{
    if(si>ei||l>ei||r<si)
    {
        return;
    }
    if(si==ei)
    {
        maxtree[node]+=val;
        return;
    }
    int mid =si +(ei-si)/2;
    updatemax(2*node+1,si,mid,l,r,val);
    updatemax(2*node+2,mid+1,ei,l,r,val);

    maxtree[node]=max(maxtree[2*node+1],maxtree[2*node+2]);

}
void updatemax2(int node,int si,int ei,int l,int r,D val)
{
    if(si>ei||l>ei||r<si)
    {
        return;
    }
    if(si==ei)
    {
        maxtree[node]+=val;
        maxtree[node]/=2;
        return;
    }
    int mid =si +(ei-si)/2;
    updatemax2(2*node+1,si,mid,l,r,val);
    updatemax2(2*node+2,mid+1,ei,l,r,val);

    maxtree[node]=max(maxtree[2*node+1],maxtree[2*node+2]);

}
void printtree( D A[],int n)
{
    int m = pow(2,log2(n)+2);
    int i;
    for(i=0;i<m;i++)
    {
        printf("%0.1lf ",A[i]);
    }
    printf("\n\n");
}

D MAX(D a,D b,D c)
{
    return max(max(a,b),c);
}
int main()
{
    int n,i;
    scanf("%d",&n);
    int A[n];
    for(i=0;i<n;i++)
    {
        scanf("%d",&A[i]);
    }
    buildmin(A,0,0,n-1);
    buildmax(A,0,0,n-1);
    int q,l,r;
    D a1,a2,a3,sav,qq;
    scanf("%d",&q);
    for(i=0;i<q;i++)
    {
        scanf("%d%d",&l,&r);
        pair<int,int> a = minquery(0,0,n-1,l,r);
        sav=(D)a.first;
        a1=maxquery(0,0,n-1,l,r);
        a1=(a1-sav)/2;
        a2=maxquery(0,0,n-1,0,l-1);
        a3=maxquery(0,0,n-1,r+1,n-1);
        qq=MAX(a1,a2,a3);
        qq+=sav;
        printf("%0.1lf\n",qq);
    }
    return 0;


}
