#include <iostream>
#include <cstdio>
#define ll int
using namespace std;
 
ll mintree[2000005];
ll maxtree[200005];
ll arr[100005];
ll MAX = 1000000000;
ll n,q,l,r;
 
void buildmax(ll node, ll start, ll end)
{
    if(start == end)
    {
        // Leaf node will have a single element
       maxtree[node] = arr[start];
    }
    else
    {
        ll mid = (start + end) / 2;
        // Recurse on the left child
        buildmax(2*node, start, mid);
        // Recurse on the right child
        buildmax(2*node+1, mid+1, end);
        // Internal node will have the sum of both of its children
        ll d1 = maxtree[2*node];
        ll d2 = maxtree[2*node+1];
        maxtree[node] =  d1>d2 ? d1 : d2;
    }
}
 
void buildmin(ll node, ll start, ll end)
{
    if(start == end)
    {
        // Leaf node will have a single element
       mintree[node] = arr[start];
    }
    else
    {
        ll mid = (start + end) / 2;
        // Recurse on the left child
        buildmin(2*node, start, mid);
        // Recurse on the right child
        buildmin(2*node+1, mid+1, end);
        // Internal node will have the sum of both of its children
        ll d1 = mintree[2*node];
        ll d2 = mintree[2*node+1];
        mintree[node] =  d1<d2 ? d1 : d2;
    }
}
 
ll querymax(ll node, ll start, ll end, ll l, ll r)
{
    if(r < start or end < l)
    {
        // range represented by a node is completely outside the given range
        return -1;
    }
    if(l <= start and end <= r)
    {
        // range represented by a node is completely inside the given range
        return maxtree[node];
    }
    // range represented by a node is partially inside and partially outside the given range
    ll mid = (start + end) / 2;
    ll p1 = querymax(2*node, start, mid, l, r);
    ll p2 = querymax(2*node+1, mid+1, end, l, r);
    return  p1>p2 ? p1 : p2;
}
 
ll querymin(ll node, ll start, ll end, ll l, ll r)
{
    if(r < start or end < l)
    {
        // range represented by a node is completely outside the given range
        return MAX;
    }
    if(l <= start and end <= r)
    {
        // range represented by a node is completely inside the given range
        return mintree[node];
    }
    // range represented by a node is partially inside and partially outside the given range
    ll mid = (start + end) / 2;
    ll p1 = querymin(2*node, start, mid, l, r);
    ll p2 = querymin(2*node+1, mid+1, end, l, r);
    return  p1<p2 ? p1 : p2;
}
 
int main() {
	// your code goes here
	
	scanf("%d",&n);
	
	for(ll i=1;i<=n;i++){
		scanf("%d",arr+i);
	}
	
	buildmin(1,1,n);
	buildmax(1,1,n);
	
	scanf("%d",&q);
	
	while(q--){
		scanf("%d %d",&l,&r);
		l++;
		r++;
		ll a1 = querymin(1, 1, n, l, r);
		ll a2 = querymax(1, 1, n, l, r);
		ll b1 = querymax(1, 1, n, 1, l-1);
		ll b2 = querymax(1, 1, n, r+1, n);
		b1 = max(b1,b2);
		double dd1 = (double)b1;
		
		double dd2 = (double)a2;
		
		dd2 -= (double)a1;
		dd2 /= 2;
		double ans = dd1>dd2 ? dd1 : dd2;
		
		ans += (double)a1;
		
		printf("%0.1f\n",ans);
	}
	
	return 0;
} 