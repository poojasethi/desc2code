/*#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#define ll  long long int
#define len 1000001
#define len2 10001
#define MAX(A,B) (((A)>(B))? (A) : (B))
using namespace std;
      *************This method Gave TLE ********************
int main()
{
    ll n,k;
    int t;
    scanf("%lld",&n);
    vector<int> arr(len);
    vector<int> sorted(len);
    vector<int> first(len);
    vector<int> second(len,0);
    for(ll i=0;i<n;i++){
        scanf("%d",&t);
        arr[i]=t;
        second[t]++;
        first[i]=0;
    }
    k=0;
    for(unsigned i=0;i<len2;i++){
        for(unsigned j=0;j<second[i];j++){
            sorted[k]=i;
            k++;
        }
    }
    int temp;
    for(unsigned i=0;i<n;i++){
        for(unsigned j=0;j<n;j++){
            if( arr[i] == sorted[j] ) {
                if(j !=0)second[j] = first[j-1] + 1;
                else second[j]=1;
            }
            else {
                if(j != 0)second[j] = MAX(first[j] , second[j-1]);
                else second[j] = MAX(first[j] , 0);
            }
        }
        for(unsigned k=0;k<n;k++){
            temp = second[k] ;
            second[k] = first[k] ;
            first[k]=temp ;
        }
    }
    printf("%d\n",first[n-1]);
    return 0;
}
*/
#include <iostream>
#include <string>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
#define ll long long int
#define len 1000001
// Binary search (note boundaries in the caller)
// A[] is ceilIndex in the caller
vector<int> A(len);
vector<int> tailTable(len,0);

ll CeilIndex(ll l, ll r, ll key) {
    ll m;

    while( r - l > 1 ) {
        m = l + (r - l)/2;
        (tailTable[m] >= key ? r : l) = m; // ternary expression returns an l-value
    }

    return r;
}

ll LongestIncreasingSubsequenceLength(ll size) {
    // Add boundary case, when array size is one
    ll l; // always points empty slot

    //memset(tailTable, 0, sizeof(tailTable[0])*size);

    tailTable[0] = A[0];
    l = 1;
    for( int i = 1; i < size; i++ ) {
        if( A[i] < tailTable[0] )
            // new smallest value
            tailTable[0] = A[i];
        else if( A[i] > tailTable[l-1] )
            // A[i] wants to extend largest subsequence
            tailTable[l++] = A[i];
        else
            // A[i] wants to be current end candidate of an existing subsequence
            // It will replace ceil value in tailTable
            tailTable[CeilIndex( -1, l-1, A[i])] = A[i];
    }

    //delete[] tailTable;

    return l;
}

int main() {
    long long int n;
    scanf("%lld",&n);
    for(int i=0;i<n;i++){
            scanf("%d",&A[i]);
    }
    printf("%lld\n",LongestIncreasingSubsequenceLength(n));

    return 0;
}
