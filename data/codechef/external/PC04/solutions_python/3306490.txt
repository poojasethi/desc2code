import java.awt.geom.Line2D;
import java.io.*;
import java.math.*;
import java.util.*;
import java.lang.*;

class Main2{ 

	public static InputStream inputStream = System.in;
	public static OutputStream outputStream = System.out;
	public static FastReader in = new FastReader(inputStream);
	public static PrintWriter out = new PrintWriter(outputStream);


	public static void main(String[] args)throws java.lang.Exception{
		new Main2().run();
		out.close();
	}

	int[] v;
	int[] w;

	void run()throws java.lang.Exception{
		int t = in.nextInt();
		for(int i=0; i<t; i++){
			MyPoint[] arr = new MyPoint[4];
			for(int j=0; j<4; j++){
				arr[j] = new MyPoint(in.nextInt(), in.nextInt());
			}
			Line2D.Double line1 = new Line2D.Double(arr[0].x, arr[0].y, 
					arr[1].x, arr[1].y);
			Line2D.Double line2 = new Line2D.Double(arr[1].x, arr[1].y, 
					arr[2].x, arr[2].y);
			Line2D.Double line3 = new Line2D.Double(arr[2].x, arr[2].y, 
					arr[3].x, arr[3].y);
			Line2D.Double line4 = new Line2D.Double(arr[3].x, arr[3].y, 
					arr[0].x, arr[0].y);
			if(line1.intersectsLine(line3) || line2.intersectsLine(line4)){
				out.println("NONE");
				continue;
			}
			boolean none = false;
			for(int j=0; j<4; j++){
				if(Double.compare(cross(arr, j, (j+1)%4, (j+2)%4), 0.0)==0){
					none = true;
				}
			}
			if(none){
				out.println("NONE");
				continue;
			}
			double sq1 = arr[0].squareDistanceFrom(arr[1]);
			double sq2 = arr[1].squareDistanceFrom(arr[2]);
			double sq3 = arr[2].squareDistanceFrom(arr[3]);
			double sq4 = arr[3].squareDistanceFrom(arr[0]);
			double diagonal1 = arr[0].squareDistanceFrom(arr[2]);
			double diagonal2 = arr[1].squareDistanceFrom(arr[3]);
			boolean equalSides = Double.compare(sq1, sq2)==0 && 
					Double.compare(sq2, sq3)==0
					&& Double.compare(sq3, sq4)==0;
			boolean equalDiag = Double.compare(diagonal1, diagonal2)==0;
			if(equalSides && equalDiag){
				out.println("SQUARE");
			}else if(Double.compare(sq1, sq3)==0 && 
					Double.compare(sq2, sq4)==0 && equalDiag){
				out.println("RECTANGLE");
			}else if(equalSides){
				out.println("RHOMBUS");
			}else if(Double.compare(sq1, sq3)==0 && 
					Double.compare(sq2, sq4)==0){
				out.println("PARALLELOGRAM");
			}else{
				out.println("QUADRILATERAL");
			}
		}
	}
	
	double cross(MyPoint[] a, int x, int y, int z){
		double dx1 = a[x].x-a[y].x;
		double dx2 = a[y].x-a[z].x;
		double dy1 = a[x].y-a[y].y;
		double dy2 = a[y].y-a[z].y;
		return dx1*dy2 - dx2*dy1;
	}
}

class MyPoint{
	double x, y ;
	public final Comparator<MyPoint> POLAR_ORDER = new PolarOrder();

	public class PolarOrder implements Comparator<MyPoint>{
		public int compare(MyPoint q1, MyPoint q2){
			double dx1 = q1.x-x;
			double dy1 = q1.y-y;
			double dx2 = q2.x-x;
			double dy2 = q2.y-y;

			if	   (dy1>=0 && dy2<0)return -1;
			else if(dy2>=0 && dy1<0) return 1;
			else if(dy1==0 && dy2==0){
				if	   (dx1>=0 && dx2<0) return -1;
				else if(dx2>=0 && dx1<0) return 1;
				else					 return 0;
			}else{
				return -ccw(MyPoint.this, q1, q2);
			}
		}
	}

	public int ccw(MyPoint a, MyPoint b, MyPoint c){
		double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
		if		(area2<0)return -1;
		else if (area2>0) return 1;
		else 	return 0;
	}

	public double squareDistanceFrom(MyPoint b){
		return (x -b.x )*(x -b.x ) + (y -b.y )*(y -b.y );
	}

	public MyPoint midPoint(MyPoint b){
		return new MyPoint((x+b.x)/2.0, (y+b.y)/2.0);
	}

	public MyPoint(double a, double b){
		//    	System.out.println("a " + " " + b);
		x = a;
		y = b;
	}

	public String toString(){
		return "(" + x + ", " + y + ")" ;
	}
}


class FastReader{
	private boolean finished = false;

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public FastReader(InputStream stream){
		this.stream = stream;
	}

	public int read(){
		if (numChars == -1){
			throw new InputMismatchException ();
		}
		if (curChar >= numChars){
			curChar = 0;
			try{
				numChars = stream.read (buf);
			} catch (IOException e){
				throw new InputMismatchException ();
			}
			if (numChars <= 0){
				return -1;
			}
		}
		return buf[curChar++];
	}

	public int peek(){
		if (numChars == -1){
			return -1;
		}
		if (curChar >= numChars){
			curChar = 0;
			try{
				numChars = stream.read (buf);
			} catch (IOException e){
				return -1;
			}
			if (numChars <= 0){
				return -1;
			}
		}
		return buf[curChar];
	}

	public int nextInt(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		int res = 0;
		do{
			if(c==','){
				c = read();
			}
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		} while (!isSpaceChar (c));
		return res * sgn;
	}

	public long nextLong(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		long res = 0;
		do{
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		} while (!isSpaceChar (c));
		return res * sgn;
	}

	public String nextString(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		StringBuilder res = new StringBuilder ();
		do{
			res.appendCodePoint (c);
			c = read ();
		} while (!isSpaceChar (c));
		return res.toString ();
	}

	public boolean isSpaceChar(int c){
		if (filter != null){
			return filter.isSpaceChar (c);
		}
		return isWhitespace (c);
	}

	public static boolean isWhitespace(int c){
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0(){
		StringBuilder buf = new StringBuilder ();
		int c = read ();
		while (c != '\n' && c != -1){
			if (c != '\r'){
				buf.appendCodePoint (c);
			}
			c = read ();
		}
		return buf.toString ();
	}

	public String nextLine(){
		String s = readLine0 ();
		while (s.trim ().length () == 0)
			s = readLine0 ();
		return s;
	}

	public String nextLine(boolean ignoreEmptyLines){
		if (ignoreEmptyLines){
			return nextLine ();
		}else{
			return readLine0 ();
		}
	}

	public BigInteger nextBigInteger(){
		try{
			return new BigInteger (nextString ());
		} catch (NumberFormatException e){
			throw new InputMismatchException ();
		}
	}

	public char nextCharacter(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		return (char) c;
	}

	public double nextDouble(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		double res = 0;
		while (!isSpaceChar (c) && c != '.'){
			if (c == 'e' || c == 'E'){
				return res * Math.pow (10, nextInt ());
			}
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		}
		if (c == '.'){
			c = read ();
			double m = 1;
			while (!isSpaceChar (c)){
				if (c == 'e' || c == 'E'){
					return res * Math.pow (10, nextInt ());
				}
				if (c < '0' || c > '9'){
					throw new InputMismatchException ();
				}
				m /= 10;
				res += (c - '0') * m;
				c = read ();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted(){
		int value;
		while (isSpaceChar (value = peek ()) && value != -1)
			read ();
		return value == -1;
	}

	public String next(){
		return nextString ();
	}

	public SpaceCharFilter getFilter(){
		return filter;
	}

	public void setFilter(SpaceCharFilter filter){
		this.filter = filter;
	}

	public interface SpaceCharFilter{
		public boolean isSpaceChar(int ch);
	}
}