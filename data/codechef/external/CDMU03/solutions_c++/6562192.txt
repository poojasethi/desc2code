#include<bits/stdc++.h>
#define intMAX 1123456789LL
#define MAX intMAX * intMAX
#define F first
#define S second
#define mp make_pair
#define ll long long
#define pb push_back
#define pv(v,b,a) v.insert(v.begin()+b,a)
#define all(c) c.begin(),c.end()
#define sf(a) scanf("%d",&a);
#define sl(a) scanf("%lld",&a);
#define MAXCR 1000000000
#define mem(arr,a) memset(arr, a, sizeof arr)
#define er(vec,a,b) vec.erase(vec.begin() + a, vec.begin() + b+1)
#define traverse(a) for()
#define pii pair<int ,int>
#define mod 1000000007
#define LIM 100
using namespace std;
/*
list as stack=pop_front();push_front(ELEMENT);
list as queue=pop_front();push_back(ELEMENT);
to see first element q.front()
to see last element q.back()
*/
//str.find("live");//finds first occurance of string and returns its 0 based indes
//string str1=str.substr (a,n);//a=0 based start index,b=length of words//if length not given substring till end is formed
//auto bound_=upper_bound (v.begin(), v.end(), 20); //Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.
//auto bound_=lower_bound (v.begin(), v.end(), 20);//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
//for(???<???>:iterator itr;itr!=???.end();itr++)

int main()
{
	ll i,k,idx1,j,idx2,k1,dpmax[105][105],l,dpmin[105][105];
	string s;
	sl(k1)
	while(k1--)
	{
		cin>>s;
		ll num[105]={0},sign[105]={0},sum=0;
		idx1=1;
		idx2=1;
		for(i=0;i<s.length();i++)
		{
			if(s[i]=='*')
			{
				sign[idx2]=1;
				idx2++;
				num[idx1]=sum;
				idx1++;
				sum=0;
			}
			else if(s[i]=='+')
			{
				idx2++;
				num[idx1]=sum;
				idx1++;
				sum=0;
			}
			else
			{
				sum=sum*10+s[i]-48;
			}
		}
		num[idx1]=sum;
		for(i=1;i<=idx1;i++)
		{
			dpmin[i][i]=num[i];
			dpmax[i][i]=num[i];
		}
		for(k=1;k<idx1;k++)
		{
			for(i=1;i<=idx1-k;i++)
			{
				j=i+k;
				dpmin[i][j]=MAX;
				dpmax[i][j]=0;
				for(l=i;l<j;l++)
				{
					if(sign[l]==1)
					{
						dpmax[i][j]=max(dpmax[i][j],dpmax[i][l]*dpmax[l+1][j]);
						dpmin[i][j]=min(dpmin[i][j],dpmin[i][l]*dpmin[l+1][j]);
					}
					else
					{
						dpmax[i][j]=max(dpmax[i][j],dpmax[i][l]+dpmax[l+1][j]);
						dpmin[i][j]=min(dpmin[i][j],dpmin[i][l]+dpmin[l+1][j]);
					}
				}
			}
		}
		printf("%lld\n",dpmax[1][idx1]-dpmin[1][idx1]);
	}
	return 0;
}
/*
4
23*0+4+5+6*6+3
23+3+3+3
23*23+33*4*2*0+4
1+1*0
*/