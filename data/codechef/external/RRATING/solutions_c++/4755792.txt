#include<stdio.h>
#include<vector>
#include<algorithm>
#include<functional>
using namespace std;

int input() {
  char c = getchar();
  while(c<'0' || c>'9') c = getchar();
  int ret = 0;
  while(c>='0' && c<='9') {
    ret = 10 * ret + c - 48;
    c = getchar();
  }
  return ret;
}
/*
int insertInVector(vector<long>& reviews, long currentReview) {
	int start = 0, end = reviews.size()-1;
	if(end == -1) {
		reviews.push_back(currentReview);
	}
	else {
		bool found = false;
		int offset, loopVar, multipleOf2;
		vector<long>::iterator it = reviews.begin();
		while(!found) {
			offset = (end-start)/2;
			loopVar = start + offset;
			multipleOf2 = (end-start)%2;
			if(offset == 0){
				//we have reached the subspace
				if(multipleOf2 == 0) {//the subspace consists of only 1 number
					if(currentReview <= reviews[loopVar]) {//insert
						reviews.insert(it+loopVar, currentReview);
					}
					else {
						//if there are numbers to the right
						if(loopVar < reviews.size()-1) {
							reviews.insert(it+loopVar+1, currentReview);
						}
						else {
							reviews.push_back(currentReview);
						}
					}
				}
				else { //the subspace consists of 2 numbers
					if(currentReview <= reviews[start]) {//insert directly
						reviews.insert(it+start, currentReview);
					}
					else if(currentReview <= reviews[end]) {//insert before the second element
						reviews.insert(it+end, currentReview);
					}
					else { //the number is bigger than the second element
						if(end < reviews.size()-1) {
							reviews.insert(it+end+1, currentReview);
						}
						else {
							reviews.push_back(currentReview);
						}
					}
				}
				break;
			}
			if(reviews[loopVar] < currentReview) {//search in the right array
				start = loopVar;
			}
			else if (reviews[loopVar] > currentReview) {//search in the left array
				end = loopVar;
			}
			else {
				reviews.insert(it+loopVar, currentReview);
				break;
			}
		}
	}
}
*/

int main()
{
	int n,currentReview;
	int mode;
	//cin >> n;
	n = input();
	/* Approach 1 - Timelimit Exceeded
	vector<long> reviews;
	int currentMinPositive;
	for(int i=0; i < n; i++) {
		cin >> mode;
		if( mode == 1) {//input the review
			cin >> currentReview;
			//do a binary search on the vector to find the correct position of the incoming element and then insert
			insertInVector(reviews, currentReview);
		}
		else { //display the minimum positive review currently in database
			//printVector(reviews);
			if( reviews.size() < 3) {
				cout << "No reviews yet" << endl;
			} 
			else {
				//get the minimum most positive review
				int index = reviews.size()/3 -1;
				currentMinPositive = reviews[reviews.size()- 1 - index];
				cout << currentMinPositive << endl;
			}
		}
	}
	*/
	/*Approach 2 - Maintain 2 heaps */
	vector<int> min_heap, max_heap; //min -for 1/3 numbers(top bracket) and max for 2/3 numbers(bottom bracket)
	int count=0, transfer, minInMinHeap;
	for(int i=0; i<n; i++) {
		//cin >> mode;
		mode = input();
		if(mode == 1) {
			currentReview = input();
			count++;
			
			if(count%3 == 0) {//the biggest number from max_heap has to be transferred to min_heap
				if(min_heap.size() > 0) {
					minInMinHeap = min_heap.front();
					if(minInMinHeap < currentReview ) {
						min_heap.push_back(currentReview);
						push_heap(min_heap.begin(), min_heap.end(), std::greater<int>());
					}
					else {
						max_heap.push_back(currentReview);
						push_heap(max_heap.begin(), max_heap.end());
						transfer = max_heap.front();
						pop_heap(max_heap.begin(), max_heap.end());
						max_heap.pop_back();
						min_heap.push_back(transfer);
						push_heap(min_heap.begin(), min_heap.end(), std::greater<int>());
					}
				}
				else {
					max_heap.push_back(currentReview);
					push_heap(max_heap.begin(), max_heap.end());
					transfer = max_heap.front();
					pop_heap(max_heap.begin(), max_heap.end());
					max_heap.pop_back();
					min_heap.push_back(transfer);
				}
			}
			else {//exchange the values between the min and max heaps
				if( min_heap.size() > 0) {
					minInMinHeap = min_heap.front();
					if(currentReview > minInMinHeap) {//have to exchange values 
						min_heap.push_back(currentReview);
						push_heap(min_heap.begin(), min_heap.end(), std::greater<int>());
						pop_heap(min_heap.begin(), min_heap.end(), std::greater<int>());
						min_heap.pop_back();
						max_heap.push_back(minInMinHeap);
						push_heap(max_heap.begin(), max_heap.end());
					}
					else {
						max_heap.push_back(currentReview);
						push_heap(max_heap.begin(), max_heap.end());
					}
				}
				else {
					max_heap.push_back(currentReview);
					push_heap(max_heap.begin(), max_heap.end());
				}
			}
		}
		else {
			if(min_heap.size() == 0){
                printf("No reviews yet\n");
            }else{
                printf("%d\n", min_heap.front());
            }
		}
	}
	return 0;
}