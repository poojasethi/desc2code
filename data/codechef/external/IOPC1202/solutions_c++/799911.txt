#include<cstdio>
#include<cstdlib>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef long long ll;

const ll M=100000007;

struct point{ int x,y; };

point operator-(const point &a,const point &b){ return (point){a.x-b.x,a.y-b.y}; }
ll gcd(ll a,ll b){ return b?gcd(b,a%b):a; }

inline ll cross(const point &a,const point &b){
	return (ll)a.x*b.y-(ll)a.y*b.x;
}

ll area2(const point &a,const point &b,const point &c){
	return llabs(cross(b-a,c-a));
}

ll solve(point p[4]){
	ll nb=4; // 境界にある格子点の個数
	rep(i,4) nb+=gcd(abs(p[(i+1)%4].x-p[i].x),abs(p[(i+1)%4].y-p[i].y))-1;
	ll A=(area2(p[0],p[1],p[2])+area2(p[0],p[2],p[3]))/2; // 面積
	ll ni=A-nb/2+1; // 内部にある格子点の個数 (Pick の定理)
	return 2*(A%M)*(ni%M)%M;
}

int main(){
	int T; scanf("%d",&T);
	while(T--){
		point p[4];
		rep(i,4) scanf("%d%d",&p[i].x,&p[i].y);

		// 頂点を CW or CCW に並べ替え
		int u=0,b=0; // 上の頂点, 下の頂点
		rep(i,4){
			if(p[i].y<p[u].y || p[i].y==p[u].y && p[i].x<p[u].x) u=i;
			if(p[i].y>p[b].y || p[i].y==p[b].y && p[i].x>p[u].x) b=i;
		}
		int j1=0; while(j1==u || j1==b) j1++;
		int j2=0; while(j2==u || j2==b || j2==j1) j2++;

		point q[4]={p[u],p[j1],p[b],p[j2]};

		printf("%lld\n",solve(q));
	}

	return 0;
}
