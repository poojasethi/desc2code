#include<bits/stdc++.h>
using namespace std;
int color[100002],parent[100002],last_neighbour[100002],next_node_info[200004][2];
int ind;
void make_edge(int u,int v){

	// In this function we take care of last neighbour of node and 	on that index in next_node_info we store neighbour and index of previous neighbour
	
	next_node_info[ind][0]=v;
	next_node_info[ind][1]=last_neighbour[u];
	last_neighbour[u]=ind;	
	ind++;
}
int parent_node(int node){

	// function for find parent of a node

	if(node!=parent[node]) parent[node]=parent_node(parent[node]);
	return parent[node];
}
int main(){
	int n,q,i,j,u,v,type;
	//cin>>n;
	scanf("%d",&n);
	for(i=0;i<n;i++) parent[i]=i;
	for(i=1;i<n;i++){
		//cin>>u>>v;
		scanf("%d%d",&u,&v);
		make_edge(u,v);
		make_edge(v,u);
	}
	//cin>>q;
	scanf("%d",&q);
	while(q--){
		//cin>>type>>u>>v;
		scanf("%d%d%d",&type,&u,&v);	
		if(type==1){
			color[u]=v;
			//While all neighbour of node not cover we check color of that node if same then it as parent of that node
			for(j=last_neighbour[u];j!=0;j=next_node_info[j][1]){
				int node=next_node_info[j][0];
				int temp_parent=parent_node(node);
				if(color[node]==v&&temp_parent!=u) parent[temp_parent]=u;
			}
		}
		else if(parent_node(u)==parent_node(v)) printf("YES\n");//cout<<"YES"<<endl;
		else printf("NO\n");//cout<<"NO"<<endl;
	}

return 0;
}