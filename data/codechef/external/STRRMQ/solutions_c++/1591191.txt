#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <vector>
#include <ctime>
#include <queue>
#include <deque>
#include <stack>
#include <cmath>
#include <list>
#include <map>
#include <set>

#define MAXN
#define INF 1000000000
#define fi first
#define se second
using namespace std;

typedef pair <int, int> ii;
typedef vector <int> vi;
typedef vector <ii> vii;
typedef vector <vii> vvii;
typedef vector <vi> vvi;
//---------------------------------------------------------------------------------------------------------------------------------------------
#define maxn 1010
#define base 31
typedef struct node
{
    int start;
    int res;
};
node IT [maxn*10];
unsigned hash [maxn][maxn], p [maxn][maxn];
char pattern [maxn][maxn];
int n, m;

void init ()
{
    for (int i=1; i<=n; ++i)
        hash [i][0] = 0, p [i][0] = 1;
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=m; ++j) {
            hash [i][j] = hash [i][j-1]*base + pattern[i][j-1] - 'a';
            p [i][j] = p [i][j-1]*base;
        }
}

unsigned gethash (int i, int j, int ind)
{
    return hash [ind][j] - hash [ind][i-1]*p [ind][j-i+1];
}

bool check (int len, node a, node b)
{
    return gethash (a.start, a.start+len-1, a.res) == gethash (b.start, b.start+len-1, b.res);
}

node cmp (node a, node b)
{
    if ( a. start > m || b. start  == -1 ) return a;
    if ( b. start > m || a. start  == -1 ) return b;
    int len = min(m - a.start + 1, m - b.start + 1);
    int inf = 0, sup = len;
    while (inf < sup) {
		int mid = (inf + sup + 1)/2;
		if ( check(mid, a, b) ) inf = mid;
		else sup = mid - 1;
	}
    if ( inf == len && len == m - a.start + 1 && len == m - b.start + 1 ) return a.res<b.res?a:b;
    else {
        return (pattern[a.res][a.start+inf-1] < pattern[b.res][b.start+inf-1])?a:b;
    }
}

void build (int i, int L, int R)
{
    if ( L > R ) return;
    if ( L==R ) {
        IT[i]. res = L;
        IT[i]. start = 1;
        return;
    }
    int mid = (L+R)/2;
    build (2*i, L, mid);
    build (2*i+1, mid+1, R);
    IT[i] = cmp(IT[2*i], IT[2*i+1]);
}

void Update (int i, int pos, int L, int R)
{
    if ( pos > R || pos < L ) return;
    if ( pos == L && L == R ) {
        IT [i]. start++;
        return;
    }
    int mid = (L+R)/2;
    Update (2*i, pos, L, mid);
    Update (2*i+1, pos, mid+1, R);
    IT[i] = cmp(IT[2*i], IT[2*i+1]);
}

node query (int i, int U, int V, int L, int R)
{
    node tmp; tmp. start = -1; tmp. res = n+1;
    if ( U>R || V<L ) return tmp;
    if ( U<=L && V>=R ) return IT[i];
    int mid = (L+R)/2;
    node tmp2 = query (2*i, U, V, L, mid);
    node tmp3 = query (2*i+1, U, V, mid+1, R);
    return cmp(tmp2, tmp3);
}

//---------------------------------------------------------------------------------------------------------------------------------------------
int main()
{
    //freopen("inp","r",stdin);
    //freopen("out.txt","w",stdout);
    int tc;
    scanf ("%d\n", &tc);
    while (tc--) {
        scanf ("%d%d\n", &n,&m);
        for (int i=1; i<=n; ++i) {
            scanf ("%s\n", pattern[i]);
            pattern[i][m] = 'a' - 1;
        }
        init ();
        build (1, 1, n);
        int q;
        scanf ("%d", &q);
        for (int i=1; i<=q; ++i) {
            int a, b, c;
            scanf ("%d ", &a);
            if ( a == 1 ) {
                scanf ("%d\n", &b);
                b++;
                Update (1, b, 1, n);
            }
            else {
                scanf ("%d %d\n", &b,&c);
                b++, c++;
                node tmp = query (1, b, c, 1, n);
                printf ("%d\n", tmp.res -1);
            }
        }
    }
    //while (1);
    return 0;
}
