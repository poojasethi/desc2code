#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<stack>
#include<queue>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<deque>
#include<set>
#include<complex>
#define oo 1000000000
#define ooll 1ll<<50
#define base 1000000007ll
using namespace std;
typedef long long ll;
typedef pair<int,int> ii;
typedef pair<int,ii> iii;
typedef vector<int> vi;
typedef vector<ii> vii;
                            /*                           END OF TEMPLATE                            */

int start[1005],n,m,q;
string S[1005];
ll Hash[1005][1005],Pow[1005];
int IT[10005];
void Hashing()
{
    for(int i=1; i<=n; i++)
    {
        Hash[i][1]=S[i][0]-95;
        for(int j=2; j<=S[i].size(); j++) Hash[i][j]=(Hash[i][j-1]*31ll+S[i][j-1]-95);
    }
}
ll gethash(int t,int l,int r)
{
    return Hash[t][r]-Hash[t][l-1]*Pow[r-l+1];
}
int Min(int x,int y)
{
    if(x==0) return y;
    if(y==0) return x;
    if(S[x].size()<start[x] && S[y].size()<start[y]) return min(x,y);
    if(S[x].size()<start[x]) return x;
    if(S[y].size()<start[y]) return y;
    int len=min(S[x].size()-start[x]+1,S[y].size()-start[y]+1);
    if(gethash(x,start[x],start[x]+len-1)==gethash(y,start[y],start[y]+len-1))
    {
        if(S[x].size()-start[x]==S[y].size()-start[y]) return min(x,y);
        if(S[x].size()-start[x]+1==len) return x;
        return y;
    }
    int low=0,high=len;
    do
    {
        int mid=(low+high)>>1;
        if(gethash(x,start[x],start[x]+mid-1)==gethash(y,start[y],start[y]+mid-1)) low=mid;
        else high=mid;
    } while(low+1<high);
    if(S[x][start[x]+high-2]<S[y][start[y]+high-2]) return x;
    return y;
}
void dfs(int x,int l,int r)
{
    if(l==r)
    {
        IT[x]=l;
        return;
    }
    int mid=(l+r)>>1;
    dfs(x<<1,l,mid);
    dfs((x<<1)+1,mid+1,r);
    IT[x]=Min(IT[x<<1],IT[(x<<1)+1]);
}
void update(int x,int l,int r,int u)
{
    if(l>u || r<u) return;
    if(l==r) return;
    int mid=(l+r)>>1;
    update(x<<1,l,mid,u);
    update((x<<1)+1,mid+1,r,u);
    IT[x]=Min(IT[x<<1],IT[(x<<1)+1]);
}
int query(int x,int l,int r,int u,int v)
{
    if(l>v || r<u) return 0;
    if(l>=u && r<=v) return IT[x];
    int mid=(l+r)>>1;
    return Min(query(x<<1,l,mid,u,v),query((x<<1)+1,mid+1,r,u,v));
}
void execute()
{
    int t,a,b;
    scanf("%d %d",&n,&m);
    for(int i=1; i<=n; i++) start[i]=1;
    for(int i=1; i<=n; i++) cin>>S[i];
    Hashing();
    dfs(1,1,n);
    scanf("%d",&q);
    for(int i=1; i<=q; i++)
    {
        scanf("%d",&t);
        if(t)
        {
            scanf("%d",&a);
            start[a+1]++;
            update(1,1,n,a+1);
        }
        else
        {
            scanf("%d %d",&a,&b);
            printf("%d\n",query(1,1,n,a+1,b+1)-1);
        }
    }
}
int main()
{
    int test;
    Pow[0]=1ll;
    for(int i=1; i<=1000; i++) Pow[i]=(Pow[i-1]*31ll)%base;
    scanf("%d",&test);
    while(test--) execute();
    return 0;
}
