def LIS(A):
	DP = [0]*len(A)
	DP[0] = 1
	for x in range(1,len(A)): DP[x] = max([DP[y] + 1 if A[y] <= A[x] else 1 for y in range(x)])
	return max(DP)
raw_input()

 
# binary search
# search for *max* j in lo..hi, s.t., s[m[j]] < s[i]
def binary_search(s, i, m, p, lo, hi):
        
        if s[m[hi]] <= s[i]:
                return hi
 
        if lo > hi:
                return 0 # not found
 
        mid = lo + (hi - lo)/2
        if s[m[mid]] < s[i]:
                return binary_search(s, i, m, p, mid, hi - 1)
        else:
                return binary_search(s, i, m, p, lo, mid - 1)
 
 
def search(s, i, m, p, L):
        return binary_search(s, i, m, p, 1, L)
 
 

def lis(s):
        n = len(s)
 
        # for an increasing sequence of length j,
        # m[j] = k is the position of the smallest value s[k]
        # that is end of the sequence of length j.
        # so s[m[1]], s[m[2]], ... s[m[L]] is the longest sequence.
        m = [-1]*(n + 1)
 
        # p[i] is the position of the predecessor of s[i] in an increasing sequence.
        # need to use p[i] in binary search
        p = [0]*n
 
        # current max length
        L = 0
 
        for i, si in enumerate(s):
                # search for maximum j, s.t., s[m[j]] < s[i]
                # i.e., j is the max length of an i.s that has end value less than s[i]
                j = search(s, i, m, p, L)
 
                # parrent of i
                p[i] = m[j]
 
                if j == L or s[m[j + 1]] > s[i]:
                        # update the end of sequence of length j + 1 to be i
                        # it can happen when j == L, i.e., x[i] extends the current longest i.s
                        # OR, x[i] is a new end of an existing i.s. of length j + 1
                        m[j + 1] = i
 
                        L = max(L, j + 1)
 
    
        return L
 
print lis([int(x) for x in raw_input().split()])
