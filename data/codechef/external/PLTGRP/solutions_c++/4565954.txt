#include <iostream>
#include <stdio.h>
#include <vector>
#include <map>
#include <algorithm>
 
 
using namespace std;
// bool compare(const pair<float,int>& firstElem, const pair<float,int>& secondElem) {
// 	   if(firstElem.first==secondElem.first){
// 	return firstElem.second<secondElem.second;
// 	}
// 	return firstElem.first<secondElem.first;
 
// }
 
/* Finds longest strictly increasing subsequence. O(n log k) algorithm. */
void find_lis(vector<int> &a, vector<int> &b)
{
    vector<int> p(a.size());
    int u, v;
 
    if (a.empty()) return;
 
    b.push_back(0);
 
    for (size_t i = 1; i < a.size(); i++) 
        {
                // If next element a[i] is greater than last element of
                // current longest subsequence a[b.back()], just push it at back of "b" and continue
        if (a[b.back()] <= a[i]) 
                {
            p[i] = b.back();
            b.push_back(i);
            continue;
        }
 
                // Binary search to find the smallest element referenced by b which is just bigger than a[i]
                // Note : Binary search is performed on b (and not a).
                // Size of b is always <=k and hence contributes O(log k) to complexity.    
        for (u = 0, v = b.size()-1; u < v;) 
                {
            int c = (u + v) / 2;
            if (a[b[c]] <= a[i]) u=c+1; else v=c;
        }
 
                // Update b if new value is smaller then previously referenced value 
        if (a[i] <= a[b[u]]) 
                {
            if (u > 0) p[i] = b[u-1];
            b[u] = i;
        }   
    }
 
    for (u = b.size(), v = b.back(); u--; v = p[v]) b[u] = v;
}

int main() {
	int cases;
	//scanf("%d",&cases);
	//for(int i=0;i<cases;i++)
	//{
		int n;
		//map<long long int,int> myMap;
		scanf("%d",&n);
		vector<int> p; 
		for(int j=0;j<n;j++)
		{
			int d;
			scanf("%d",&d);
			p.push_back(d);
		}
		vector<int> lseq;
		find_lis(p,lseq);
		int ans = lseq.size();
		cout << ans;
		
	//}
	// your code goes here
	return 0;
} 