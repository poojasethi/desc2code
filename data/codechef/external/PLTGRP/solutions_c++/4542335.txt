/* The basic idea is to set an array of max size to infinity
*  and then search for any no in it if using binary search and
   it and the end of the right index.
   This gives us the O(log n) time.
   DO this for all array elements only if (x-i >= 0)
   This gives us the O(N) time.
*/
#include<iostream>
#include<vector>
#include<cstdlib>
#include<cstdio>
using namespace std;

#define max 1000005
#define inf 200000000
#define x getchar()
#define y putchar
typedef long long ll;
long a[max];
ll longest;                //TO help us keep track of the longest subsequence found
//Fast input
inline void read(ll & n){
	n = 0;
	char ch = x; int sign = 1;
	while(ch < '0' || ch > '9'){ if (ch == '-')sign = -1; ch = x;}
	while(ch >='0' && ch <= '9'){
		n = n*10 + ch - '0';
		ch = x;
	}
	n *= sign;
}
inline void out(ll k) {
	int n=k,i=0;
	char ch[15];
	if(n<=0) {
		if(n==0) y('0');		
		else 	y('-');
		n=n*-1;
		}
	while(n>0) {
		ch[i]=(n%10)+'0';
		n=n/10;
		i++;
		}
	while(i>0) {
		y(ch[i-1]);
		i--;
		}
	y('\n');
	}	

void bS(long key){
//	cout << "SEARCHING FOR: " << key << endl;
	int left = 1,right = longest;
	while(left <= right){
		int mid = (left + right)/2;
		if(a[mid] <= key)
			left = mid + 1;
		else
			right = mid - 1;
	}
	
	a[++right] = key;
	if(longest < right)
		longest = right ;
//	cout << "LEFT: " << left << " RIGHT : " << right << " LONGEST " <<  longest << endl;
}

int main(){
	ll n;              // No of elements in the prob array
	scanf("%lld",&n);
//	cout << n << endl;
	
	longest = 0;
	for(int i =0;i <= n;i++)
		a[i] = inf;
	
	long * ptr = (long *) malloc ((n+1) * sizeof(long));
	for(int i = 1; i <= n; i++)
		scanf("%ld",&ptr[i]);
		
//	for(int i = 1; i <= n; i++)
//		cout << ptr[i] << " " ;
//	cout << endl;
		
	for(int i = 1;i <= n; i++){
	//	cout << "THIS: " << ptr[i] << endl;
		bS(ptr[i]);
	}
	out(longest);
	free(ptr);
	return 0;
}
