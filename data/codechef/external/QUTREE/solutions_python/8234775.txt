#include<bits/stdc++.h>
using namespace std;
 
 
//order here
const int N=100000+143;
 
int Frequency[400][N];
//int len=400;
int timer=0;
int treestart[N];
int treeend[N];
int level[N]={0};
long long ParticularLevel[N]={0};
vector<int>v[N];
int positionarraywithtime[N];
void dfs(int node,int parent){
    level[node]=level[parent]+1;
    treestart[node]=++timer; // start position array here
    positionarraywithtime[timer]=node;
    for(vector<int>::iterator it = v[node].begin();it!=v[node].end();++it){
        if(*it!=parent)
            dfs(*it,node);
    }
    treeend[node]=timer;
}
 
 
int main(){
	
int n,Q;
cin>>n>>Q;
 
vector<int> a(n+143);
 
 
for(int i=0;i<=n;i++)
a[i]=0;
 
 
//edges here
 
for(int i=1;i<n;i++){
int p,q;
cin>>p>>q;
v[p].push_back(q);
v[q].push_back(p);
}
 
dfs(1,0);
 
//position check
/*
for(int i=1;i<=n;i++){
cout<< positionarraywithtime[i]<<" "<<treestart[i]<<" "<<treeend[i]<<endl;
}
*/
 
int len =  ceil(sqrt(n));
 
 
 
//store block values
 
vector<long long int> b (len+3);
//cout<<len<<endl;
for (int i=1; i<=n; ++i){
//	cout<<i/len<<endl;
	b[i / len] += a[i];  // store block sum
}
	
//end block values
 
 
memset(Frequency,0,sizeof(Frequency));
 
for(int i=1;i<=n;i++){
	int BlockNum=i/len;
	Frequency[BlockNum][level[positionarraywithtime[i]]]++; // find level of node and increase frequency
    //ParticularLevel[level[positionarraywithtime[i]]]++;                                                      //store particular array with sum of intial weights
}
 
//printing 
 
/*
for(int i=1;i<=n;i++){
	int BlockNum=i/len;
	cout<<level[positionarraywithtime[i]]<<" ";
	cout<<Frequency[BlockNum][level[positionarraywithtime[i]]]<<endl; // find level of node and increase frequency
    
}
*/
 
//queries goes here
 
while(Q--){
//query-1
int type;
cin>>type;
 
 
if(type==1){
    
    int p,q;
    cin>>p>>q;
    p++;
    ParticularLevel[p]+=q;   // increase level p by q
    //go to all blocks increase levels
    for(int i=0;i<len;i++){
    int BlockNum=i;
    b[BlockNum] += Frequency[BlockNum][level[p]]*q; // BlockNum will be updated
    }
  
     
}
else{
	
	int x;
	cin>>x;
	
	int starting_time=treestart[x];
	int ending_time=treeend[x];
	
	
	
	//decomposition here
	
	int l=starting_time,r=ending_time;
	long long int sum = 0; // sum stores sum of values between l and r
 
 
 
    int c_l = l / len,   c_r = r / len;
    if (c_l <= c_r)  // in same block
	for (int i=l; i<=r; ++i)
		sum += ParticularLevel[level[positionarraywithtime[i]]];
    else {  // in different blocks
		for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)  // partial block1 
			sum += ParticularLevel[level[positionarraywithtime[i]]];
		for (int i=c_l+1; i<=c_r-1; ++i)    // full block
			sum += b[i];
		for (int i=c_r*len; i<=r; ++i)     // partial block2
			sum += ParticularLevel[level[positionarraywithtime[i]]];
 
    	
    }
	cout<<sum<<endl;
  
 }
}
return 0;
} 