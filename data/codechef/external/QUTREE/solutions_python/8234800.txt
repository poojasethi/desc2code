#include<bits/stdc++.h>
using namespace std;
 
 
//order here
const int N=100000+143;
 
int Frequency[400][N];
//int len=400;
int timer=0;
int treestart[N];
int seen[N];
int treeend[N];
int level[N];
long long ParticularLevel[N];
vector<int>v[N];
int positionarraywithtime[N];
void dfs(int node,int parent){
    level[node]=level[parent]+1;
    seen[node]=1;
    treestart[node]=++timer; // start position array here
    positionarraywithtime[timer]=node;
    for(vector<int>::iterator it = v[node].begin();it!=v[node].end();++it){
        if(!seen[*it])
            dfs(*it,node);
    }
    treeend[node]=timer;
}
 
 
int main(){
 
int n,Q;
cin>>n>>Q;
 
vector<int> a(n+143);
 
 
for(int i=0;i<=n;i++)
a[i]=0;
 
 
//edges here
 
for(int i=1;i<n;i++){
int p,q;
cin>>p>>q;
v[p].push_back(q);
v[q].push_back(p);
}
 
/*
nt treestart[N];
int seen[N];
int treeend[N];
int level[N];
long long ParticularLevel[N];
*/
memset(treestart,0,sizeof(treestart));
memset(seen,0,sizeof(seen));
memset(treeend,0,sizeof(treeend));
memset(level,0,sizeof(level));
memset(ParticularLevel,0,sizeof(ParticularLevel));
memset(Frequency,0,sizeof(Frequency));
 
dfs(1,0);
 
//position check
/*
for(int i=1;i<=n;i++){
cout<< positionarraywithtime[i]<<" "<<treestart[i]<<" "<<treeend[i]<<endl;
}
*/
 
int len =  int(sqrt(n+.0)+1);
 
 
 
//store block values
 
vector<long long int> b (len+3);
//cout<<len<<endl;
for (int i=0; i< n; ++i){
//	cout<<i/len<<endl;
	b[i / len] += a[i];  // store block sum
}
 
//end block values
 
 
for(int i=0;i<n;i++){
	int BlockNum=i/len;
	Frequency[BlockNum][level[positionarraywithtime[i+1]]]++; // find level of node and increase frequency
    //ParticularLevel[level[positionarraywithtime[i]]]++;                                                      //store particular array with sum of intial weights
}
 
//printing
 
/*
for(int i=1;i<=n;i++){
	int BlockNum=i/len;
	cout<<level[positionarraywithtime[i]]<<" ";
	cout<<Frequency[BlockNum][level[positionarraywithtime[i]]]<<endl; // find level of node and increase frequency
 
}
*/
 
//queries goes here
 
while(Q--){
//query-1
int type;
cin>>type;
 
 
if(type==1){
 
    long long p,q;
    cin>>p>>q;
    ParticularLevel[p+1]+=q;   // increase level p by q
    //go to all blocks increase levels
    for(int i=0;i<len;i++){
    int BlockNum=i;
    b[BlockNum] += (long long)Frequency[BlockNum][level[p+1]]*q; // BlockNum will be updated
    }
 
 
}
else{
 
	int x;
	cin>>x;
 
	int starting_time=treestart[x];
	int ending_time=treeend[x];
 
 
 
	//decomposition here
 
	int l=starting_time-1,r=ending_time-1;
	long long int sum = 0; // sum stores sum of values between l and r
 
 
 
    int c_l = l / len,   c_r = r / len;
    if (c_l <= c_r)  // in same block
	for (int i=l; i<=r; ++i)
		sum += ParticularLevel[level[positionarraywithtime[i+1]]];
 /*   else {  // in different blocks
		
		for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)  // partial block1
			sum += ParticularLevel[level[positionarraywithtime[i+1]]];
		for (int i=c_l+1; i<=c_r-1; ++i)    // full block
			sum += b[i];
		for (int i=c_r*len; i<=r; ++i)     // partial block2
			sum += ParticularLevel[level[positionarraywithtime[i+1]]];
 
 
    } */
	cout<<sum<<endl;
 
 }
}
return 0;
}  