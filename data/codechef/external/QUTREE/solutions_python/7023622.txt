#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
using namespace std;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar_unlocked();
    }
    return x;
}
const int N = 100001;
const int SQN = 350;
int freq[SQN][N]={0};
long long val[SQN]={0};
int start[SQN];
int finish[SQN];
int n,sqn,m;
int timer=0;
int treestart[N];
int treeend[N];
int rev[N];
list<int> v[N];
int level[N]={0};
int lookup[N];
long long sum[N]={0};
void dfs(int node,int parent){
    level[node]=level[parent]+1;
    treestart[node]=++timer;
    rev[timer]=node;
    for(list<int>::iterator it = v[node].begin();it!=v[node].end();++it){
        if(*it!=parent)
            dfs(*it,node);
    }
    treeend[node]=timer;
}
int main(){
    n=scan(),m=scan();
    for(int i=1;i<n;++i){
        int a=scan(),b=scan();
        v[a].pb(b);
        v[b].pb(a);
    }
    dfs(1,0);
    int sqn = sqrt(n);
    int cur=1;
    for(int i=1;i<=n;){
        int j=i;
        start[cur]=i;
        while(j<i+sqn&&j<=n){
            freq[cur][level[rev[j]]]++;
            j++;
            lookup[j-1]=cur;
        }
        i=j;
        finish[cur]=j-1;
        ++cur;
    }
    while(m--){
        int type=scan();
        if(type==1){
            int levl = scan();
            long long vall = scan();
            for(int i=1;i<cur;++i){
                val[i]+=1LL*freq[i][levl+1]*vall;
            }
            sum[levl+1]+=vall;
        }
        else{
            int node = scan();
            int x=lookup[treestart[node]];
            int y=lookup[treeend[node]];
            long long res=0;
            for(int i=x;i<=y;++i){
                if(start[i]>=treestart[node]&&finish[i]<=treeend[node]){
                    res+=val[i];
                }
                else if(start[i]<treestart[node]){
                    for(int j=treestart[node];j<=min(treeend[node],finish[i]);++j){
                        res+=sum[level[rev[j]]];
                    }
                }
                else{
                    for(int j= max(start[i],treestart[node]);j<=treeend[node];++j){
                        res+=sum[level[rev[j]]];
                    }
                }
            }
            printf("%lld\n",res);
        }
    }
}