
//**************************************************template*****************************************/
//#pragma comment(linker, "/STACK:16777216")
#include<bits/stdc++.h>

using namespace std;
typedef long long int ll;
const ll MOD=1000000007;

#define FOR(i,a,b) for(i=(a);i<(b);i++)
#define ROF(i,a,b) for(i=(a);i>=(b);i--)
#define s(x)                    scanf("%d",&x);
#define sl(x)                   scanf("%lld",&x);
#define p(x)                    printf("%d\n",x);
#define pl(x)                   printf("%lld\n",x);
#define pi 3.14159265358979323846  //float type
#define MAX 100000  //for rmq
#define SQRTMAX 317   //for rmq
//#define gc getchar_unlocked
#define INF                 999999999999999999

/*#define swap(x,y) do \
   { unsigned char swap_temp[sizeof(x) == sizeof(y) ? (signed)sizeof(x) : -1]; \
     memcpy(swap_temp,&y,sizeof(x)); \
     memcpy(&y,&x,       sizeof(x)); \
     memcpy(&x,swap_temp,sizeof(x)); \
    } while(0)
*/
#define 	SZ(A) 		((int)A.size())
#define 	LEN(A) 		((int)A.length())
#define 	MS(A) 		memset(A, 0, sizeof(A))
#define 	MSV(A,a) 	memset(A, a, sizeof(A))
#define 	mp(x,y)		make_pair((x),(y))
#define 	pb(x) 		push_back(x)
#define		F 			first
#define 	S 			second

#define 	EPS 		1e-12

#define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;
#define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;
#define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;
#define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl;
#define trace5(a,b,c,d,e)   cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<" | "#e" = "<<e<<endl;
#define trace6(a,b,c,d,e,f) cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<" | "#e" = "<<e<<" | "#f" = "<<f<<endl;



#define 	chkbit(s, b) 	(s & (1<<b))
#define 	setbit(s, b) 	(s |= (1<<b))
#define 	clrbit(s, b) 	(s &= ~(1<<b))

//#define 	swap(x,y)  		{x=x+y-(y=x);}
#define 	FOUND(A, x) 	(A.find(x) != A.end())





 ll power(ll a, ll b, ll m) {
    ll r = 1;
    while(b) {
        if(b & 1) r = r * a % m;
        a = (a * a)% m;
        b >>= 1;
    }
    return r;
}
 ll power(ll a, ll b) {
     ll r = 1;
    while(b) {
        if(b & 1) r = r * a ;
        a = a * a;
        b >>= 1;
    }
    return r;
}

ll gcd(ll a,ll b){
      return b==0?a:gcd(b,a%b);
}
 //......long long int
ll lcm(ll a,ll b){
      return (a/gcd(a,b))*b;
}
 //......long long int with mod
ll modularInverse(ll a,ll m){
      return power(a,m-2,m);


}

 int mini(int a,int b) { return a<b? a : b; }
 int maxi(int a,int b) { return a>b? a : b; }


typedef long long ll;
typedef unsigned long long ull;

typedef vector<int> VI;
typedef pair<int, int> II;
typedef vector<long long> VLL;
typedef vector<bool> VB;


/*........................................................END OF TEMPLATES...................................................................
....*/

VLL tr[100005];
ll arr[200005];
ll lev[100005];
ll coun=0;
#define MAX 100000
#define SQRTMAX 204

ll block_size;
ll no_of_blocks;
ll newcoun=0;
ll vis[100005];

ll ans[SQRTMAX][MAX+2];
ll tot[SQRTMAX][MAX+2];
ll an[SQRTMAX];
ll st[100005],en[100005];

void dfs(ll node,ll level)
{   ll i;
    arr[coun++]=node;
    lev[node]=level;
    ll sz=tr[node].size();

    FOR(i,0,sz)
    {
        dfs(tr[node][i],level+1);
    }
    arr[coun++]=node;


}

void preprocess(ll n)
{
    ll i=0, j=0, k=0;
     block_size=1000;

    while(i<n){

		for(k=0 ; k<block_size && i<n ; k++){
                if(vis[arr[i]]==0)
                {
                   ans[j][lev[arr[i]]]++;
                   vis[arr[i]]=1;
                   st[arr[i]]=i;
                }
                else
                    {
                       en[arr[i]]=i;

                    }

			i++;
		}

		j++;
	}

	no_of_blocks=j;


}

void update(ll level,ll val)
{   ll i;
    FOR(i,0,no_of_blocks+1)
    {
        tot[i][level]=tot[i][level]+val;
        an[i]=an[i]+val*ans[i][level];
    }
}

ll query(ll node)
{
    ll l=st[node];
    ll r=en[node];
    //trace2(l,r)

    ll jawaab=0;
    //trace1(block_size)

    	ll j = (l/block_size) + 1;
    	//trace1(l)
	    ll j2 = (r/block_size) - 1;
	    //trace1(j)

	    while(l<j*block_size && l<=r){

                //trace1(l)
		    if(st[arr[l]]==l)
            {
                jawaab=jawaab+tot[j-1][lev[arr[l]]];

            }
		l++;
	     }

	     while(j<=j2 && l<=r && j<block_size){
		jawaab=jawaab+an[j];
		l = (j+1)*block_size;

		j++;
	     }

	     while(l<=r){
		 if(st[arr[l]]==l)
            {
                jawaab=jawaab+tot[j+1][lev[arr[l]]];

            }
		//printf("Checked for %d\n", l);
		l++;
	}


	return jawaab;
}



int main()
{ ll i,j,k,t,n,te,m;
    t=1;
    //s(t)
    while(t--)
    {
       sl(n)
       sl(m)
       FOR(i,0,n-1)
       {
           sl(j);
           sl(k);
           tr[j].pb(k);

       }
       dfs(1,0);
       //trace1(coun)

       preprocess(coun);



       while(m--)
       {
           ll num,l,y,x;
           sl(num)
           if(num==1)
           {
               sl(l)
               sl(y)

               update(l,y);



           }
           else
           {
               sl(x);
               ll corr=query(x);
               pl(corr)
           }
       }

    }



    return 0;
}
