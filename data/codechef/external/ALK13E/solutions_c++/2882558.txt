// Author: Aman Choudhary
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <cmath>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <map>
#include <cassert>
#define dholu 10000000
#define mod 100003
#define PHI 1000000006
#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define S1(x) scanf("%llu",&x)
#define MAX 100009
#define LOGMAXN 20
using namespace std;

void input()
{
   #ifndef ONLINE_JUDGE
   freopen("input54.txt","r",stdin);
   freopen("output54.txt", "w", stdout);
   #endif
}

string lower,upper;
string sub;
int n;
int nn;
int mask;
int length;
vector <int> digits;
int lps[27];
string s;
ill total[22];
ill sum[22];
ill dp[22][22][1LL<<10 +1][2];
ill dd[22][22][1LL<<10 +1][2];
vector <ill> multiply;

void calculate()
{
   int i,len,n;
   len = 0;
   lps[0] = 0;
   n = sub.size();
   i = 1;
   while (i < n) {
       if (sub[i] == sub[len]) {
           lps[i] = len+1;
           len++;
           i++;
           continue;
       }
       if (len == 0) {
           lps[i] = 0;
           i++;
       } else {
           len = lps[len-1];
       }
   }
}

ill get (ill a, ill b, ill c)
{
   a = a*b;
   if (a >= mod) {
       a = a%mod;
   }
   a = a*c;
   if (a >= mod) {
       a = a%mod;
   }
   return a;
}

ill f (int index, int ii, int mask, int flag)
{
   ill &result = dp[index][ii][mask][flag];
   if (ii == length) {
       result = 0;
       return 0;
   }
   if (index == nn) {
       if (mask == 0) {
           result = 1;
           return 1;
       }
       result = 0;
       return 0;
   }


   if (result != -1) {
       return result;
   }

   result = 0;

   int i;
   F (i, 0, 10) {
       int ff,iii,x = i;
       if (index == 0 && x == 0) {
           continue;
       }
       if ((sub[ii]-'0') == x) {
           iii = ii+1;
       } else {
           iii = ii;
           while (1) {
               if (x == (sub[iii]-'0')) {
                   iii++;
                   break;
               }
               if (iii == 0) {
                   break;
               }
               iii = lps[iii-1];
           }
       }

       if (flag == 1) {
           ff = 1;
       } else {
           if (x > (s[index]-'0')) {
               continue;
           }
           if (x == (s[index]-'0')) {
               ff = 0;
           } else {
               ff = 1;
           }
       }

       result = result + f (index+1, iii, mask&(~(1LL<<x)), ff);
       if (result >= mod) {
           result = result % mod;
       }
       dd[index][ii][mask][flag] += (get (dp[index+1][iii][mask&(~(1LL<<x))][ff], (ill)x, multiply[index]) + dd[index+1][iii][mask&(~(1LL<<x))][ff])%mod;
       if (dd[index][ii][mask][flag] >= mod) {
           dd[index][ii][mask][flag] = dd[index][ii][mask][flag]%mod;
       }
   }
   return result;
}

void precompute()
{
   s = "";
   int i;

   total[0] = sum[0] = 0;
    ill xx = 1;
   F (i, 1, 19) {
       memset (dp, -1, sizeof(dp));
       memset (dd, 0, sizeof(dd));
       nn = i;
       s = s + "9";

        multiply.insert (multiply.begin(), xx%mod);
        xx = xx*10;

       f (0, 0, mask, 0);
       total[i] = total[i-1] + dp[0][0][mask][0];
       sum[i] = sum[i-1] + dd[0][0][mask][0];
       if (total[i] >= mod) {
           total[i] = total[i]%mod;
       }
       if (sum[i] >= mod) {
           sum[i] = sum[i]%mod;
       }
   }
}

ill ax,ay;

void calculate (string &ss, int flag)
{
   memset (dp, -1, sizeof(dp));
   memset (dd, 0, sizeof(dd));
   int n = ss.size();
   s = ss;
   nn = n;
   ill xx=1;
   multiply.clear();
   for (ill j = 0; j < n; j++) {
       multiply.pb (xx%mod);
       xx = xx*10;
   }
   reverse (multiply.begin(), multiply.end());
   f (0, 0, mask, 0);

  // cout << s << " --> " << dp[0][0][mask][0] << " aa " << dd[0][0][mask][0] << endl;

   if (flag == 0) {
       ax = ax + dp[0][0][mask][0];
       ay = ay + dd[0][0][mask][0];
       ax = ax%mod;
       ay = ay%mod;
       ax = ax + total[n-1];
       ay = ay + sum[n-1];
       ax = ax%mod;
       ay = ay%mod;
   } else {
       ax = ax - dp[0][0][mask][0];
       ay = ay - dd[0][0][mask][0];
       if (ax < 0) {
           ax = ax + mod;
       }
       if (ay < 0) {
           ay = ay + mod;
       }
       ax = ax - total[n-1];
       ay = ay - sum[n-1];
       if (ax < 0) {
           ax = ax + mod;
       }
       if (ay < 0) {
           ay = ay + mod;
       }
   }
   ax = ax%mod;
   ay = ay%mod;
}

string subtract (string s)
{
   int i,j,n = s.size(),flag=0;
   for (i = n-1; i >= 0; i--) {
       if (s[i] == '0') {
           s[i] = '9';
           for (j = i-1; j >= 0; j--) {
               if (s[j] == '0') {
                   s[j] = '9';
                   continue;
               }
               s[j]--;
               break;
           }
           break;
       }
       s[i] = s[i]-1;
       break;
   }

   for (int i = 0; i < s.size(); i++) {
       if (s[i] == '0') {
           s.erase (s.begin());
           i--;
           continue;
       }
       break;
   }
   return s;
}


int main()
{
   //i/nput();
  //== freopen ("output.txt", "w", stdout);
   input();
   S (n);
   digits.resize (n);

   int i;
   mask = 0;
   F (i, 0, n) {
       S (digits[i]);
       mask = mask | (1LL<<digits[i]);
   }

   cin >> sub;
   length = sub.size();

   calculate();
   precompute();

   int queries;
   S (queries);

   while (queries--) {
        ax = ay = 0;
       cin >> lower >> upper;
       lower = subtract (lower);
       calculate (upper, 0);
       calculate (lower, 1);
       printf ("%lld %lld\n", ax, ay);
   }

   return 0;
}
