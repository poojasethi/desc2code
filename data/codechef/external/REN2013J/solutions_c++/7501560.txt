#include<bits/stdc++.h>
using namespace std;
#define lli long long int
int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}
void print_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<10);}
const int N=1e05+10;
struct node{
	lli sum;
	bool lazy;
	node(){
		sum=0;
		lazy=false;
	}
}tree[4*N];
lli arr[N];
void merge(int n){
	tree[n].sum=tree[2*n].sum+tree[2*n+1].sum;
}
void pushdown(int n,int l,int r){
	//
}
void build(int n,int l,int r){
	if(l==r){
		tree[n].sum=arr[l];
		return;
	}
	int mid=l+(r-l)/2;
	build(2*n,l,mid);
	build(2*n+1,mid+1,r);
	merge(n);
}
void update(int n,int l,int r,int ul,int ur){
	if(tree[n].sum==0)return;
	if(l>r||ur<l ||r<ul)return;
	if((l==r) && ul<=l && r<=ur){
		tree[n].sum>>=1;
		return;
	}
	int mid=l+(r-l)/2;
	update(2*n,l,mid,ul,ur);
	update(2*n+1,mid+1,r,ul,ur);
	merge(n);
}
lli query(int n,int l,int r,int ql,int qr){
	if(tree[n].sum == 0)
        return 0;
	if(l>r||qr<l ||r<ql)return 0;
	if(ql<=l && r<=qr){
		return tree[n].sum;
	}
	int mid=l+(r-l)/2;
	return query(2*n,l,mid,ql,qr)+
		query(2*n+1,mid+1,r,ql,qr);
}
int main(){
	int n,q;
	n=scan_d();
	//cin>>n;
	for(int i=0;i<n;i++){
		arr[i]=scan_d();
	}
	q=scan_d();//cin>>q;
	build(1,0,n-1);
	int c,l,r;
	while(q--){
		c=scan_d();
		l=scan_d();
		r=scan_d();
		//cin>>c>>l>>r;
		if(c==1){
			update(1,0,n-1,l-1,r-1);
		}
		else{
			lli ans=query(1,0,n-1,l-1,r-1);//cout<<query(1,0,n-1,l-1,r-1)<<"\n";
			print_d((int)ans);
			putchar_unlocked('\n');
		}
	}
	return 0;
}
