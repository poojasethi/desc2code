/*MD SHAKIM
  B.TECH 2ND YEAR
  CSE
  MNNIT ALLAHABAD*/
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <algorithm>
#include <vector>
#include <cstring>
#include <stack>
#include <cctype>
#include <utility>
#include <map>
#include <string>
#include <climits>
#include <set>
#include <string>
#include <sstream>
#include <utility>
#include <ctime>
using namespace std;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long LL;
#define getcx getchar
#define SIZE(A) ((int)A.size())
#define PB push_back
#define ALL(c) c.begin(), c.end()
#define INF (int(1e9))
#define INFL (LL(1e18))
#define F(i, a, n) for(int i = a; i < n; i++)
#define FE(i, a, n) for(int i = a; i <= n; i++)
#define R(i, a, n) for(int i = a; i > n; i--)
#define RE(i, a, n) for(int i = a; i >= n; i--)
#define loop(n) F(i, 0, n)
#define loop1(n) FE(i, 1, n)
#define TR(c,i) for(VI::iterator i = (c).begin(); i != (c).end(); i++)
#define pii pair< int,int >
#define piii pair< pii , int >
inline void in(int &n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
#define V 100000
vector<pii> adj[V];
vector<int> chainOfelem[V];
pii parent[V];
int depth[V], size[V] ,heavy[V],f[V];
int chain[V], head[V] ,sizeOfelem[V];
int q[V], *qf, *qb,trees; // BFS queue
struct SegmentTreeNode
{
    SegmentTreeNode *lc;
    SegmentTreeNode *rc;
    LL val;
}*start[V];
void init(int idx,SegmentTreeNode *node,int s,int e)
{
    if(s==e)
    {
        node->lc=NULL;
        node->rc=NULL;
        node->val=parent[chainOfelem[idx].at(s+1)].second;
        return;
    }
    SegmentTreeNode *tmp;

    tmp=(SegmentTreeNode *)malloc(sizeof(SegmentTreeNode));
    node->lc=tmp;
    tmp=(SegmentTreeNode *)malloc(sizeof(SegmentTreeNode));
    node->rc=tmp;

    int mid=(s+e)/2;

    init(idx,node->lc,s,mid);
    init(idx,node->rc,mid+1,e);

    node->val=node->lc->val+node->rc->val;

}
void heavylight_BFS(int N)
{
    SegmentTreeNode *tmp;
    qf = qb = q;
    parent[0].first=-1;
    parent[0].second=0;//wt of edge going from i to parent[i]
    depth[0] = 0;
    *qb++ = 0;
    while (qf < qb)
    {
        for (int i=*qf++, k=0; k<adj[i].size(); ++k)
        {
            int j = adj[i][k].first;

            if (j == parent[i].first)
                continue;

            parent[j].first=i;
            parent[j].second=adj[i][k].second;

            depth[j] = depth[i] + 1;
            *qb++ = j;
        }
    }

    memset(size, 0, sizeof(size));
    memset(heavy, -1, sizeof(heavy));

    for (int k=N-1; k>0; --k)
    {
        int j = q[k], i = parent[q[k]].first;
        size[j]++;
        size[i] += size[j];
        if (heavy[i] == -1 || size[j] > size[heavy[i]])
            heavy[i] = j;
    }
    //printf("done\n");
    int c = 0;
    for (int i=0; i<N; ++i)
    {
        if (parent[i].first == -1 || heavy[parent[i].first] != i)
        {
            for (int k = i; k != -1; k = heavy[k])
            {
                chain[k] = c;//the kth elem belongs to cth chain
                sizeOfelem[c]++;//size of cth chain is increased
                f[k]=sizeOfelem[c];//f keeps the location of the kth elem in a single chain in which it is present
                /*hence push the kth element in cth chain*/
                //chainOfelem[sizeOfelem[c]]=k;//parent is pushed first then its child
                //chainOfelem[c][sizeOfelem[c]]=k;
                chainOfelem[c].push_back(k);
                head[k] = i;
            }
            if(sizeOfelem[chain[i]]>1)
            {
                //printf("tree start\n");
                //printf("Size %d\n",sizeOfelem[chain[i]]);
                /*Initialise Segment Tree For  c th chain*/
                tmp=(SegmentTreeNode *)malloc(sizeof(SegmentTreeNode));
                //printf("b4 chain is %d, size is %d and other is %d\n",chain[i],chainOfelem[c].size(),sizeOfelem[c]);
                init(chain[i],tmp,1,sizeOfelem[chain[i]]-1);//chain,node,start,stop

                //printf("trees done\n");

                //trees++;
                start[chain[i]]=tmp;
            }
            c++;

        }
    }
}
LL rsq(int idx,SegmentTreeNode *node,int s,int e,int l,int r)
{
    //printf("inside rsq");

    if(l>e || r<s)
        return 0;

    if(s>=l && e<=r)
    {
        return node->val;
    }

    int mid=(s+e)/2;

    LL p1=rsq(idx,node->lc,s,mid,l,r);
    LL p2=rsq(idx,node->rc,mid+1,e,l,r);

    return p1+p2;
}
LL query(int i, int j)
{
    //printf("query\n");
    int low,high;
    LL ans=0;
    while (chain[i] != chain[j])
    {
        if (depth[head[i]] > depth[head[j]])
        {
            if(i!=head[i])//i and head[i] are of same chain
            {
                low=min(f[i],f[head[i]]);
                high=max(f[i],f[head[i]]);
                //ans=max(ans,rmq(chain[i],start[chain[i]],1,sizeOfelem[chain[i]]-1,low,high-1));

                ans=ans + rsq(chain[i],start[chain[i]],1,sizeOfelem[chain[i]]-1,low,high-1);
            }
            //ans=max(ans,parent[head[i]].second);

            ans=ans + parent[head[i]].second;
            i = parent[head[i]].first;
        }
        else
        {
            if(j!=head[j])
            {
                low=min(f[j],f[head[j]]);
                high=max(f[j],f[head[j]]);
                //ans=max(ans,rmq(chain[j],start[chain[j]],1,sizeOfelem[chain[j]]-1,low,high-1));
                ans=ans+rsq(chain[j],start[chain[j]],1,sizeOfelem[chain[j]]-1,low,high-1);
            }
            //ans=max(ans,parent[head[j]].second);
            ans=ans + parent[head[j]].second;
            j = parent[head[j]].first;
        }
    }
    if(i!=j)
    {
        low=min(f[i],f[j]);
        high=max(f[i],f[j]);
        //ans=max(ans,rmq(chain[i],start[chain[i]],1,sizeOfelem[chain[i]]-1,low,high-1));

        ans=ans+rsq(chain[i],start[chain[i]],1,sizeOfelem[chain[i]]-1,low,high-1);
    }
    return ans;
}

int main()
{
    int t,n,i,j,p,q,r,idx;
    while(1)
    {
        in(n);
        if(n==0)
            break;

        for(i=0; i<n; i++)
        {
            adj[i].clear();
            sizeOfelem[i]=0;
            chainOfelem[i].clear();
            chainOfelem[i].push_back(i);//so that it is 1-based
        }

        for(i=1; i<=n-1; i++)
        {
            in(p);
            in(q);

            adj[i].push_back(pii(p,q));
            adj[p].push_back(pii(i,q));
        }

        heavylight_BFS(n);

        in(q);

        while(q--)
        {
            scanf("%d %d",&p,&r);
            if(p==r)
                printf("0 ");
            else
                printf("%lld ",query(p,r));
        }//end of queries
        printf("\n");
    }//end of test cases
    return 0;
}
