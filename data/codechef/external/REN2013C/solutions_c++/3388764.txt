#include <bits/stdc++.h>
using namespace std;
#define FL(a) memset(a, 0, sizeof a);
#define pi(a) cout <<  a << endl;
#define si(n) scanf("%d",&n)
#define pis(n) printf("%d ",n);
#define FREP(b) for(int i=0;i<b;i++)
#define REP(a,b,c) for(int a=b;a<c;a++)
typedef pair<int,int> ii;
typedef long long LL;
/*
   struct data{
   };
   bool operator < (const data &a1, const data &a2){
   }
 */
const int MAX = 100003;
vector<ii> G[MAX];
int n;
LL dist[MAX]; int level[MAX], LCA[MAX][22];
void dfs(int v){
    for(int i = 0; i < G[v].size(); i++){
        level[G[v][i].first] = level[v] + 1;
        dist[G[v][i].first] = dist[v] + G[v][i].second;
        dfs(G[v][i].first);
    }
}
void Print(){
    // 0 is the root ..
    for(int i = 0; i < n; i++){
        cout << "dist: " << dist[i] << " :level " << level[i] << endl;
    }
}
void init(){
    for(int j = 1; 1 << j < n; j++){
       for(int i = 1; i < n; i++){
           if(LCA[i][j-1]!=-1) LCA[i][j] = LCA[LCA[i][j-1]][j-1];
       }
    }
}
int query(int p, int q){
    if(level[p] < level[q]) swap(p, q);
    int maxd;
    for(maxd = 1; 1 << maxd <= level[p]; maxd++); maxd--;
    for(int d = maxd; d >=0; d--){
        if(level[p] - (1 << d) >= level[q]) p = LCA[p][d];
    }
    if(p == q) return p;
    for(int d = maxd; d >= 0; d--){
        if(LCA[p][d]!=-1 && LCA[p][d] != LCA[q][d]) p = LCA[p][d], q = LCA[q][d];
    }
    return LCA[p][0];
}
LL distt(int p, int q){
    return dist[p] + dist[q] - 2*dist[query(p,q)];
}
int main()
{
    while(scanf("%d",&n) && n!=0){
        FREP(n+1) G[i].clear();
        FL(level);
        FL(dist);
        memset(LCA, -1, sizeof LCA);
        int to, cost;
        FREP(n-1){
            si(to);si(cost);
            G[to].push_back(ii(i+1, cost));
            LCA[i+1][0] = to;
        }
        level[0] = 0, dist[0] = 0;
        dfs(0);
        // Print();
        init();
        int q,a,b;
        si(q);
        while(q--){
            si(a); si(b);
            cout << distt(a,b) << " ";
        }
        cout << endl;
    }
    return 0;
}

