/* This code is based on Anton's one. */
/*
mu : Moebius function

gcd(a,b)=1 => mu(ab) = mu(a)*mu(b)
gcd(a,b)>1 => mu(ab) = 0

mu(a*b) == mu(a)*mu(b) <=> gcd(a,b)=1 || mu(a)==0 || mu(b)==0
mu(a*b) != mu(a)*mu(b) <=> gcd(a,b)>1 && mu(a)!=0 && mu(b)!=0

answer = n^2 - Sigma[i=2 to n] #{gcd(a,b)==i && mu(a)!=0 && mu(b)!=0}
	   = n^2 - Sigma[i=2 to n] mu(i) * #{gcd(a,b)>=i && mu(a)!=0 && mu(b)!=0}
	   = n^2 - Sigma[i=2 to n] mu(i) * #{i|a && i|b && mu(a)!=0 && mu(b)!=0}
	   = n^2 - Sigma[i=2 to n] mu(i) * #{i|a && mu(a)!=0} * #{i|b && mu(b)!=0}
	   = n^2 - Sigma[i=2 to n] mu(i) * #{i|a && mu(a)!=0}^2
*/

#include<cstdio>
#include<algorithm>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef long long ll;

int main(){
	// calculate prime numbers
	const int Ne=100000;
	static bool er[Ne+1]={true,true};
	for(int i=2;i*i<=Ne;i++) if(!er[i]) for(int j=i*i;j<=Ne;j+=i) er[j]=true;

	// calculate Moebius function
	const int Nm=100000;
	int mu[Nm+1];
	rep(i,Nm+1) mu[i]=1;
	for(int i=2;i<=Nm;i++) if(!er[i]) {
		for(int j=i;j<=Nm;j+=i) if(j/i%i==0) mu[j]=0; else mu[j]=-mu[j];
	}

	int T; scanf("%d",&T);
	while(T--){
		int n; scanf("%d",&n);
		ll ans=(ll)n*n;
		for(int i=2;i<=n;i++) if(mu[i]!=0) {
			int cnt=0;
			for(int j=i;j<=n;j+=i) if(mu[j]!=0) cnt++;
			ans+=(ll)mu[i]*cnt*cnt;
		}
		printf("%lld\n",ans);
	}

	return 0;
}
