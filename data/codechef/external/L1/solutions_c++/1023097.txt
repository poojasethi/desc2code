#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <cstring>
#include <assert.h>
using namespace std;
class BitMap {
private:
unsigned char* data, *data2;
int w, h, bw;
int x0, y0;
int size;
public:
BitMap() {
data=data2=NULL;
}
~BitMap() {
if (data) free(data); if (data2) free(data2);
}
void resize(int minx, int maxx, int miny, int maxy) {
w=maxx-minx+1; h=maxy-miny+1;
bw=(w+7)/8;
x0=minx; y0=miny;

data=(unsigned char*)malloc(bw*h*sizeof(unsigned char));
data2=(unsigned char*)malloc(bw*h*sizeof(unsigned char));
memset(data, 0, bw*h);
memset(data2, 0, bw*h);
size=bw*h;
}
inline void mark(int x, int y) {
x-=x0; y-=y0;
if (x<0||x>=w) return;
if (y<0||y>=h) return;
int off=y*bw+x/8;
assert(off<size);
int mask=1<<(x%8);
data2[off]|=mask;
}
inline bool valid(int x, int y) {
x-=x0; y-=y0;
if (x<0||x>=w) return false;
if (y<0||y>=h) return false;
return true;
}
inline unsigned char marked(int x, int y) {
x-=x0; y-=y0;
if (x<0||x>=w) return 0;
if (y<0||y>=h) return 0;
int off=y*bw+x/8;
assert(off<size);
unsigned char mask=1<<(x%8);

return data2[off]&mask;
}
inline unsigned char get(int x, int y) {
x-=x0; y-=y0;
assert(x>=0 && y>=0);
int off=y*bw+x/8;
assert(off<size);
unsigned char mask=1<<(x%8);
unsigned char ret=data[off]&mask;
return ret;
}
inline unsigned char set(int x, int y) {
x-=x0; y-=y0;
assert(x>=0 && y>=0);
int off=y*bw+x/8;
assert(off<size);
int mask=1<<(x%8);
unsigned char ret=data[off]&mask;
data[off]|=mask;
return ret;
}
inline int steps(int x, int y)
{
assert(x||y);
x=abs(x); y=abs(y);
if (x==0) return y;
if (y==0) return x;
while(y>0) {
x = x%y;

x^=y^=x^=y; //swap
}
return x;
}
inline short draw(int x1, int y1, int x2, int y2) {
if (x1>x2) return draw(x2,y2,x1,y1);
if (x1==x2 && y1>y2) return draw(x2,y2,x1,y1);
//cout << "draw " << x1 << " " << y1 << " " << x2 << " " << y2 << endl;
int st=steps(x2-x1, y2-y1);
int dx=(x2-x1)/st, dy=(y2-y1)/st;
unsigned char ret=0;
//set(x1,y1);
int i, j;
for (i=x1-dx, j=y1-dy; valid(i, j); i-=dx, j-=dy) {
if (get(i,j))
return 0;
}
for (i=x2+dx, j=y2+dy; valid(i, j); i+=dx, j+=dy) {
if (get(i,j))
return 0;
}
int total=0;
bool head = true;
for (i=x1+dx, j=y1+dy; (i!=x2)||(j!=y2); i+=dx, j+=dy) {
if (marked(i,j)) head = false;
if (get(i, j)) {
if (head)
total++;
head=true;

}
}
if (head) total++;
return total;
}
};
class Point {
public:
Point(int xx, int yy):x(xx), y(yy) { }
friend bool operator<(const Point&, const Point&);
short x, y;
};
inline bool operator<(const Point& a, const Point& b) {
if (a.y<b.y) return true;
if (a.y>b.y) return false;
return (a.x<b.x);
};
int towSize, skySize;
vector<Point> pt, skyscrappers;
#define INPUT cin
//#define INPUT input
//ifstream input("input.txt");
int main(int argc, char* argv[])
{
int ntest, n, m;
INPUT >> ntest;
int x, y;
while (ntest--) {

BitMap bitmap;
//bitmap.steps(2, -3);
pt.clear();
skyscrappers.clear();
INPUT >> n >> m;
towSize=n; skySize=m;
pt.reserve(n+1);
skyscrappers.reserve(m+1);
int minx=20000, maxx=-20000;
int miny=20000, maxy=-20000;
while (n--) {
INPUT >> x >> y;
minx=min(minx, x); maxx=max(maxx, x);
miny=min(miny, y); maxy=max(maxy, y);
pt.push_back(Point(x,y));
}
bitmap.resize(minx, maxx, miny, maxy);
int total=0;
short i, j;
for (i=0; i<towSize; i++) {
bitmap.set(pt[i].x, pt[i].y);
}
sort(pt.begin(), pt.end());
while (m--) {
INPUT >> x >> y;
bitmap.mark(x, y);
}
for (i=0; i<towSize; i++) {
for (j=i+1; j<towSize; j++) {

int n=(bitmap.draw(pt[i].x, pt[i].y, pt[j].x, pt[j].y));
total+=n;
//cout << i << " " << j << " " << n << " " << total << endl;
}
}
cout << total << endl;
}
return 0;
}