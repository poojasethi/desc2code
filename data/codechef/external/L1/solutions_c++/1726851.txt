//Header file declaration
#include <stdio.h>
#include <stdlib.h>
 
// Structure defination for Bulding, encription, steping
typedef struct bulding
{
    int x, y;
	int demo;
    int type;   
} bulding;
 
typedef struct encript
{
    int Demo;
	int Count;    
    unsigned long long int Tool;
}encript;
 
typedef union step_Tool
{
    double step;
    unsigned long long int Tool;
} step_Tool;
 
//Global variables 
int Point_x, Point_y;
int BuldingCounter;
 
#define SKYSCRAPER_T    2
#define TOWER_T  1
#define NO_T     0
 
#define FALSE 0
#define TRUE  (!FALSE)
 
#define encript1_md   2857
#define encript2_md   (encript1_md - 2)
 
bulding BuldingInfoArr[2048];
encript E_B_A[encript1_md + 2];
 
//Problem Calculation
int prb_cal( const void *pointer1, const void *pointer2 )
{
    bulding *deff_bul1 = (bulding *)pointer1;
    bulding *deff_bul2 = (bulding *)pointer2;
 
    if ( deff_bul1->x != deff_bul2->x )
    {
        return ( deff_bul1->x - deff_bul2->x );
    }
    else
    {
        return ( deff_bul1->y - deff_bul2->y );
    }
}
 
//Funtion for Encription technique 
int Take_Encript_Block( int x_ax_diff, int y_ax_diff )
{
    int Block;
 
    if ( x_ax_diff == 0 )
    {
        Block = encript1_md + 1;
	}
    else
    {
        if ( y_ax_diff == 0 )
        {
            Block = encript1_md;
        }
        else
        {
            int Offset, BlockFound;
            step_Tool sk;
 
            sk.step = ((double)y_ax_diff) / x_ax_diff;
 
            Block = sk.Tool % encript1_md;
            Offset = 1 + (sk.Tool % encript2_md);
 
            BlockFound = FALSE;
 
            while ( !BlockFound )
            {
                if ( ( E_B_A[Block].Count == 0 ) || ( E_B_A[Block].Tool == sk.Tool ) )
                {
                    BlockFound = TRUE;
                }
                else
                {
                    Block = (Block + Offset) % encript1_md;
                }
            }
 
            E_B_A[Block].Tool = sk.Tool;
		}
    }
 
    return Block;
}
 
//Function for problem Solution
void prb_sol( void )
{
    int Sol;
    int i, j;
    int x_ax_ref, y_ax_ref;
    int x_ax_diff, y_ax_diff;
    int Block;
 
    qsort( BuldingInfoArr, BuldingCounter, sizeof(BuldingInfoArr[0]), prb_cal );
 
    Sol = 0;
 
    for ( i = 0; i < BuldingCounter; i++ )
    {
        if ( BuldingInfoArr[i].type != TOWER_T )
        {
            continue;
        }
 
        x_ax_ref = BuldingInfoArr[i].x;
        y_ax_ref = BuldingInfoArr[i].y;
 
        for ( j = 0; j < ( sizeof(E_B_A) / sizeof(E_B_A[0]) ); j++ )
        {
            E_B_A[j].Count = 0;
        }
 
        for ( j = i + 1; j < BuldingCounter; j++ )
        {
            y_ax_diff = BuldingInfoArr[j].y - y_ax_ref;
            x_ax_diff = BuldingInfoArr[j].x - x_ax_ref;
 
            Block = Take_Encript_Block( x_ax_diff, y_ax_diff );
 
            if ( E_B_A[Block].Count == 0 )
            {
                if ( BuldingInfoArr[j].type == TOWER_T )
                {
                    Sol++;
                }
            }
            
			E_B_A[Block].Count++;
        }
    }
 
    printf( "%d\n", Sol );
}
 
//Main Function
int main(void)
{
    int input;
 
    scanf( "%d", &input );
 
    while ( input > 0 )
    {
        int i;
 
        BuldingCounter = 0;
		scanf( "%d%d", &Point_x, &Point_y );
 
        for ( i = 0; i < Point_x; i++ )
        {
            // x-axis input
			scanf( "%d%d", &BuldingInfoArr[BuldingCounter].x, &BuldingInfoArr[BuldingCounter].y );
            BuldingInfoArr[BuldingCounter++].type = TOWER_T;
         }
 
        for ( i = 0; i < Point_y; i++ )
        {
            // y-axis input
			scanf( "%d%d", &BuldingInfoArr[BuldingCounter].x, &BuldingInfoArr[BuldingCounter].y );
            BuldingInfoArr[BuldingCounter++].type = SKYSCRAPER_T;
        }
 
        prb_sol();
 
        input--;
    }
}