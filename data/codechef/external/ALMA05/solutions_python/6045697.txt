#include <iostream>
#include <cstdio>
#include <cstring>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <vector>
#include <sstream>
#include <ctime>
#include <iomanip>
#include <complex>
#include <utility>
#include <numeric>
#include <bitset>
#include <functional>
#include <cassert>
#include <string>
#include <cmath>
#include <cstdlib>
#include <iterator>
#include <algorithm>

using namespace std;

typedef long long LL;
typedef vector < int > vi;
typedef vector < vi > vvi;
typedef vector < LL > vLL;

#define pb push_back
#define mp make_pair
#define all(a) a.begin(),a.end()
#define tr(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it)
#define sz(a) (int)(a.size()) 
#define s(a) scanf("%d",&a)

const int MAXN = (int)(1e5 + 9);
const int MOD  = (int)(1e9 + 7);
const int INF  = 0x3f3f3f3f;
const LL INFL  = 0x3f3f3f3f3f3f3f3fLL;

LL dp[35][35][35][35];
int A[35][35];
int tc,N,M;

inline LL go(int up,int down,int left,int right){
	LL day = (N + M) - (down - up + 1) - (right - left + 1) + 1LL;

	if((up > down) || (left > right))   return 0LL;
	if((up == down) && (left == right)) return (day * 1LL * A[up][left]);
	
	if(dp[up][down][left][right] != -1) return dp[up][down][left][right];

	LL U,D,L,R;
	U = D = L = R = 0LL;

	for(int i = left;i <= right;++i) U = U + A[up][i];
	for(int i = left;i <= right;++i) D = D + A[down][i];
	for(int i = up;i <= down;++i) L = L + A[i][left];
	for(int i = up;i <= down;++i) R = R + A[i][right]; 

    LL retA = U * day + go(up + 1,down,left,right);
    LL retB = D * day + go(up,down - 1,left,right);
    LL retC = L * day + go(up,down,left + 1,right);
    LL retD = R * day + go(up,down,left,right - 1);

    return (dp[up][down][left][right] = max(retA,max(retB,max(retC,retD)))); 
}

int main(){

	scanf("%d",&tc);

	while(tc--){
		s(N);
		s(M);
		for(int i = 1;i <= N;++i){
			for(int j = 1;j <= M;++j){
				s(A[i][j]);
			}
		}
		memset(dp,-1LL,sizeof(dp));
		printf("%lld\n",go(1,N,1,M));
	}

	return 0;
}
