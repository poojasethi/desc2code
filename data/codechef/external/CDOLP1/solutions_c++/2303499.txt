/*
@author Anirudh Villayannur Raja
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>
#define pb push_back 
#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)
#define max(i,j) (i>j?i:j)
#define mod 1000000007
using namespace std;

list<int>  *adj;

int connected[100001],component,depth,pos;
bool visited[100001];

void dfs_util(int,int);

void dfs(int n,int s){
for(int i = 0; i < n; i++)
visited[i]=false;
component=0;
FOR(i,0,n){
depth=0;
if(!visited[i]){
dfs_util(i,s);
component++;
connected[component-1]=depth;
//cout<<endl;
}
}
}

void dfs_util(int v , int s){
 if(visited[v] == false)
{
if(v==s) pos=component;
//cout<<v<<" ";
visited[v] = true;
depth++;
list<int>::iterator i;
for(i = adj[v].begin(); i != adj[v].end(); ++i)
if(!visited[*i])
dfs_util(*i,s);
}
}


int main(){  
int t;
scanf("%d",&t);
while(t--){
int n,s,f;
 adj = new list<int>[1000001];
scanf("%d %d %d",&n,&s,&f);
//visited = new bool[n];
s--;
while(f--){
int a,b;
scanf("%d %d",&a,&b);
a--;b--;
adj[a].pb(b);
adj[b].pb(a);
}
dfs(n,s);

//adj.erase();
int maxi=INT_MIN;
FOR(i,0,component){
if(i!=pos && connected[i]>maxi)
maxi=connected[i];
}
if(maxi!=INT_MIN)
printf("%d\n",maxi);
else printf("0\n");
}
return 0;
}
