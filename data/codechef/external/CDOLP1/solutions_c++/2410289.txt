// Libraries 

#include <list>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>

// Definitions 

#define pb push_back
#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)
#define max(i,j) (i>j?i:j)
#define min(i,j) (i<j?i:j)
#define mod 1000000007
#define sf scanf
#define pf printf
#define LL long long int

using namespace std;

// Global Declarations

list<int> *adj;
bool *visited;
int component,depth,selected,connected[100001];

void dfs_util(int v,int s);

void dfs(int n,int s)
{
	FOR(i,0,n)
	{
		visited[i]=false;
	}
	component=0;
	FOR(i,0,n)
	{
		depth=0;
		if(!visited[i])
		{
			dfs_util(i,s);
		}
		connected[component]=depth;
		component++;
	}
}

void dfs_util(int v,int s)
{
	if (v==s)
		selected=component;
	visited[v]=true;
	depth++;
	list<int>::iterator i;
	for(i=adj[v].begin();i!=adj[v].end();i++)
	{
		if(!visited[*i])
		dfs_util(*i,s);
	}
}

int main()
{
	int t,n,s,f,a,b;
	sf("%d",&t);
	while(t--)
	{
		sf("%d %d %d",&n,&s,&f);
		adj=new list<int>[n];
		visited=new bool[n];
		while(f--)
		{
			sf("%d %d",&a,&b);
			a--;
			b--;
			adj[a].pb(b);
			adj[b].pb(a);
		}
		dfs(n,s);
		int maxi=INT_MIN;
		FOR(i,0,component)
		{
			if(i!=selected && connected[i]>maxi)
			maxi=connected[i];
		}
		if (maxi!=INT_MIN)
		pf("%d\n",maxi);
		else
		pf("0\n");
	}
	return 0;
}

