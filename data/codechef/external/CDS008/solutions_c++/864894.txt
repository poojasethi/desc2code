/* This solution is dedicated to Karl-Theodor zu Guttenberg */

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <vector>

using namespace std;

const double pi=acos(-1);

struct Point {
double angle;
int type;
Point(double a, int b) : angle(a), type(b) {}
bool operator<(const Point &b) const { return angle < b.angle; }
};

int num[2], accum[3];
vector<Point> v;

bool valid_cut(int i, int j)
{
for (int k=0; k<2; ++k)
        if(accum[k]<num[k]/2||accum[k]>num[k]/2+1||accum[k]==num[k]/2+1&&v[i].type!=k&&v[j].type!=k) return false;
return true;
}

main()
{
int caper, pepper, n;
while(scanf("%i%i",&caper,&pepper)==2&&(caper>=0||pepper>=0))
        {
        n=caper+pepper;
        v.clear();
        num[0]=num[1]=0;
        for(int i=0; i<n; ++i)
                 {
                 double x, y;
                 scanf("%lf%lf",&x,&y);
                 double ang=atan2(y,x)/pi;
                 if(ang<0) ang+=2;
                 int type=i<caper;
                 ++num[type];
                 v.push_back(Point(ang,type));
                 v.push_back(Point(fmod(ang+1,2.0),2));
                 }
        bool possible=v.empty();
        if(!possible)
                 {
                 sort(v.begin(),v.end());
                 accum[0]=accum[1]=0;
                 for(int j=0; j<=n; ++j)
                          ++accum[v[j].type];
                 for(int i=0, j=n; !possible; ++i,++j)
                          {
                          possible=valid_cut(i,j);
                          if(i==n-1) break;
                          --accum[v[i].type];
                          ++accum[v[j+1].type];
                          }
                 }
        puts(possible?"YES":"NO");
        }
return 0;
}
