#include<bits/stdc++.h>
using namespace std;

vector<int> factors[100010];
set< pair<int,int> > adj[100010];
set<int> affected1,affected2;
long long ans,maxLen[100010],tempLen[100010];
int n,depth[100010],subsize[100010];

inline int inp()
{
    register int r=0,c;
    for(c=getchar_unlocked(); c<=32; c=getchar_unlocked());
    if(c=='-')
        return -inp();
    for(; c>32; r=(r<<1)+(r<<3)+c-'0',c=getchar_unlocked());
    return r;
}

void dfs1(int v,int par)
{
  subsize[v]=1;
    for(set< pair<int,int> >::iterator it=adj[v].begin();it!=adj[v].end();it++){
    int vv = (*it).first;
    if(vv==par)
     continue;
    dfs1(vv,v);
    subsize[v]+=subsize[vv];
    }
}

int dfs2(int v,int par,int tot){
  for(set< pair<int,int> >::iterator it=adj[v].begin();it!=adj[v].end();it++){
     int vv = (*it).first;
     if(vv==par)
       continue;
    if(subsize[vv]>tot/2)
      return dfs2(vv,v,tot);
  }
  return v;
}

void dfs3(int v,int par,int gcd,int len,int centroid)
{
   int j = factors[gcd].size();
   for(int i=0;i<j;i++)
   {
      int f = factors[gcd][i];
      ans=max(ans,f*(len+maxLen[f]));
      tempLen[f]=max(tempLen[f],1LL*len);
   }
   affected1.insert(gcd);
   affected2.insert(gcd);
   for(set< pair<int,int> >::iterator it= adj[v].begin();it!=adj[v].end();it++)
   {
      int vv = (*it).first;
      int val = (*it).second;
      if(vv==par)
        continue;

    dfs3(vv,v,__gcd(gcd,val),len+1,centroid);

   }
}

void decompose(int v,int par)
{
   dfs1(v,-1);
   int centroid = dfs2(v,-1,subsize[v]);

   for(set< pair<int,int> >::iterator it=adj[centroid].begin();it!=adj[centroid].end();it++)
   {
     int vv = (*it).first;
     int cc = (*it).second;
     adj[vv].erase(adj[vv].lower_bound(make_pair(centroid,-1)));
     dfs3(vv,-1,cc,1,centroid);

      for(set<int>::iterator it=affected2.begin();it!=affected2.end();it++){
        for(int i=0;i<(int)factors[*it].size();i++){
          maxLen[factors[*it][i]]=max(maxLen[factors[*it][i]],tempLen[factors[*it][i]]);
          tempLen[factors[*it][i]]=0;
        }
    }
        affected2.clear();
      }

     for(set<int>::iterator it=affected1.begin();it!=affected1.end();it++)
        for(int i=0;i<(int)factors[*it].size();i++)
           maxLen[factors[*it][i]]=0;
    affected1.clear();

    for(set< pair<int,int> >::iterator it=adj[centroid].begin();it!=adj[centroid].end();it++){
       int vv = (*it).first;
       decompose(vv,centroid);

    }
adj[centroid].clear();
}

int main()
{

   for(int i=1;i<=100000;i++)
   {
     for(int j=1;1LL*j*j<=i;j++)
     {
       if(i%j==0)
       {
          factors[i].push_back(j);
          if(j!=(i/j))
            factors[i].push_back(i/j);
       }
     }
   }

   int t;
   t=inp();

   while(t--)
   {
      n=inp();
      for(int i=1;i<=n;i++)
         adj[i].clear();

         affected1.clear();
         affected2.clear();
         memset(maxLen,0,sizeof maxLen);
         memset(tempLen,0,sizeof tempLen);

         ans=0;
         int a,b,c;

         for(int i=1;i<n;i++)
         {
             a=inp();
             b=inp();
             c=inp();
             adj[a].insert(make_pair(b,c));
             adj[b].insert(make_pair(a,c));
         }
         decompose(1,-1);
         printf("%lld\n",ans);

   }

}
