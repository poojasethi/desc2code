#pragma comment(linker, "/STACK:102400000,102400000")
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <queue>
#include <set>
#include <cmath>
#include <fstream>
#include <assert.h>
#include <complex>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 100010

struct node;
node *null,*root;
struct node{
    node *left,*right;
    int id,sz,rng,sum;
    void init(int x=0){
        id=x;if(x)sz=sum=1;else sz=sum=0;
        left=right=null;
        rng=rand();
    }
    void upd(){
        sum=right->sum+left->sum+(id!=0);
    }
}t[N<<2];
int sz=0;
node* newnode(int x=0){
    sz++;
    node *e=&t[sz];
    e->init(x);
    return e;
}
pii a[N];
node* merge(node* a,node* b){
    if(a==null)return b;
    if(b==null)return a;
    if(a->rng>=b->rng){
        a->right=merge(a->right,b);
        a->upd();
        return a;
    }
    b->left=merge(a,b->left);
    b->upd();
    return b;
}
void split(node *rt,node* &a,node* &b,int k){
    if(k==0){
        a=null;b=rt;return;
    }
    if(rt->sum==k){
        a=rt,b=null;return;
    }
    if(rt->left->sum>=k){
        //b=newnode();
        b=rt;
        split(rt->left,a,b->left,k);
        b->upd();
    }
    else{
        //a=newnode();
        a=rt;
        split(rt->right,a->right,b,k-rt->left->sum-rt->sz);
        a->upd();
    }
}
int p[N],n1=0,vis[N],b[N];vi q[N];
pii ti[N];
void query(node *rt){
    if(rt==null)return;
    query(rt->left);
    if(rt->sz)p[n1++]=rt->id-1;
    query(rt->right);
}
ll ex_gcd(ll a,ll b,double &x,double &y){
    if(b==0){
        x=1;y=0;return a;
    }
    double x1,y1;
    ll d=ex_gcd(b,a%b,x1,y1);
    x=y1;
    y=(x1-a/b*x);
    return d;
}
ll solve(vector<pii>&v){
    int n=v.size(),i;
    ll a=1,n1=0;
    for(i=0;i<n;i++){
        ll b=v[i].x,n2=v[i].y,c=n2-n1;
        //if(c<0)swap(a,b),swap(n1,n2),c=-c;
        double x1,y1;
        ll d=ex_gcd(a,b,x1,y1);
        //assert(c%d==0);
        x1*=(c/d);
        assert(x1<=1e18&&x1>=-1e18);
        ll x=((ll)x1)%(b/d);
        if(x<0)x+=b/d;
        ll y=(c-a*x)/b;
        ll m,g=a/d*b;
        if(y<=0)m=(a*x+n1)%g;
        else{
            ll a1=a/d;
            ll k=(y+a1-1)/a1;
            y%=a1;
            if(y>0)y-=a1;
            m=(-y*b+n2)%g;
        }
        a=a/d*b;
        m%=a;
        if(m<0)m+=a;
        n1=m;
    }
    return n1;
}
int main()
{
    //freopen("2.txt","w",stdout);
    int T,i,j,k,ca=0,n,m;
    scanf("%d%d%d",&n,&m,&T);
    for(i=0;i<m;i++)scanf("%d%d",&a[i].x,&a[i].y);
    null=&t[0];null->init();
    root=null;
    for(i=1;i<=n;i++){
        node *e=newnode(i);
        root=merge(root,e);
    }
    //DBG(root->sum)
    for(i=0;i<m;i++){
        int l=a[i].x,r=a[i].y;
        node *a,*b,*d;
        split(root,a,b,l-1);
        //DBG(a->sum)
        //DBG(b->sum)
        split(b,b,d,r-l+1);
        //DBG(b->sum)
        //DBG(d->sum)
        root=merge(b,a);
        //DBG(root->sum)
        root=merge(root,d);
        //DBG(root->sum)
    }
    query(root);
    //for(i=0;i<n;i++)printf("%d ",p[i]);
    //puts("");
    n1=0;
    for(i=0;i<n;i++)if(!vis[i]){
        j=i;
        while(!vis[j]){
            q[n1].pb(j),vis[j]=1;j=p[j];
        }
        for(j=0;j<q[n1].size();j++)ti[q[n1][j]]=mp(n1,j);
        n1++;
    }
    //DBG(n1)
    if(T){
        ll K;cin>>K;
        for(i=0;i<n;i++){
            j=ti[i].x;int x=ti[i].y;
            k=q[j].size();
            printf("%d ",q[j][(x+K)%k]+1);
        }
    }
    else{
        vector<pii>ans;
        for(i=0;i<n;i++)scanf("%d",&j),j--,b[i]=j;
        for(i=0;i<n1;i++){
            j=q[i][0];
            k=q[i].size();
            int x=b[j],y=ti[x].x;
            //if(i!=y)while(1);
            y=ti[x].y;
            //DBG(y)
            ans.pb(mp(k,y));
        }
        sort(all(ans));
        ans.erase(unique(all(ans)),ans.end());
        ll res=solve(ans);
        printf("%lld\n",res);
    }
    
    return 0;
}