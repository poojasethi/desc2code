#include<bits/stdc++.h>

using namespace std;

// Shortcuts for "common" data types in contests
typedef long long int ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef set<int> si;
typedef map<string, int> msi;
// To simplify repetitions/loops, Note: define your loop style and stick with it!
#define s(i) scanf("%d",&i)
#define sl(i) scanf("%ld",&i)
#define sll(i) scanf("%lld",&i)
#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define TRvi(c, it) \
for (vi::iterator it = (c).begin(); it != (c).end(); it++)
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
#define TRmsi(c, it) \
for (msi::iterator it = (c).begin(); it != (c).end(); it++)
#define INF 2000000000 // 2 billion

const int maxnodes = 5000;

int nodes = maxnodes, src, dest , n ,m ,k;
int dist[maxnodes],work[maxnodes];

struct Edge {
  int to, rev;
  int f, cap;
};

vector <Edge> g[maxnodes];

// Adds bidirectional edge
void addEdge(int s, int t, int cap ,int revcap){
  Edge a = {t, g[t].size(), 0, cap};
  Edge b = {s, g[s].size(), 0, revcap};
  g[s].push_back(a);
  g[t].push_back(b);
}

bool dinic_bfs() {
  fill(dist, dist + nodes, -1);
  dist[src] = 0;
  queue <int> qu;qu.push(src);
  while( !qu.empty() )
  {
      int u = qu.front();qu.pop();
      for(int j = 0;j < g[u].size() ;j++)
      {
          Edge &e = g[u][j];
          int v = e.to;
          if(dist[v] == -1 && e.f < e.cap)
          {
              dist[v] = dist[u] + 1;
              qu.push(v);
          }
      }
  }
  return dist[dest] >= 0;
}

int dinic_dfs(int u, int f) {
  if (u == dest)
    return f;
  for (int &i = work[u]; i < (int) g[u].size(); i++) {
    Edge &e = g[u][i];
    if (e.cap <= e.f) continue;
    int v = e.to;
    if (dist[v] == dist[u] + 1) {
      int df = dinic_dfs(v, min(f, e.cap - e.f));
      if (df > 0) {
        e.f += df;
        g[v][e.rev].f -= df;
        return df;
      }
    }
  }
  return 0;
}

int maxFlow(int _src, int _dest) {
  src = _src;
  dest = _dest;
  int result = 0;
  while (dinic_bfs()) {
    fill(work, work + nodes, 0);
    while (int delta = dinic_dfs(src, INF))
      result += delta;
  }
  return result;
}


ll a[109][109];

bool check(ll mid)
{
    REP(i,1,n)
    {
        REP(j,1,m)
        {
            if(a[i][j] <= mid)
                addEdge(i , j + n , 1 , 0);
        }
    }
    REP(i,1,n)
        addEdge(0 , i , 1, 0);
    REP(i,1,m)
        addEdge(n + i , n + m + 1 , 1 , 0);
    int mf = maxFlow(0 , n + m + 1);
    REP(i,0,n + m + 1)
        g[i].clear();
    if( mf >= k)
        return true;
    return false;
}

int main()
{
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    s(n);s(m);s(k);
    ll high = -1;
    REP(i,1,n)
    {
        REP(j,1,m)
        {
            sll(a[i][j]);
            high = max(high , a[i][j]);
        }
    }
    ll low = 1;
    ll ans = high;
    while( low < high )
    {
        ll mid = ( low + high ) / 2;
        if( check(mid) == true && check(mid - 1) == false    )
        {
            ans = mid;
            break;
        }
        if( check(mid + 1) == true && check(mid) == false )
        {
            ans = mid + 1;
            break;
        }
        if( check(mid) == true )
            high = mid;
        else
            low = mid;
    }
    printf("%lld\n",ans);
    return 0;
}
