//
//  Created by x4150
//  Copyright (c) 2015 x4150. All rights reserved.
//
//#define DEBUG

#include <algorithm>
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <complex>
#include <cassert>
#include <cstdlib>
#include <cstdio>
#include <bitset>
#include <vector>
#include <string>
#include <cmath>
#include <ctime>
#include <queue>
#include <list>
#include <map>
#include <set>

using namespace std;

#define clear(p, x) memset(p, x, sizeof(p))
#define pb(x) push_back(x)
#define ff first
#define ss second
#define ll long long
#define ld long double

typedef vector<vector<ll> > matrix;
template<class T> inline void umax (T &a,T b) { if(a<b) a = b; }
template<class T> inline void umin (T &a,T b) { if(a>b) a = b; }
template<class T> inline T max (T a, T b, T c) { return max(a, max(b, c)); }
template<class T> inline T min (T a, T b, T c) { return min(a, min(b, c)); }

static short DP[451][451][451];
static char A[451], B[451], C[451];
int LCS()
{
	int n = strlen(A);
	int m = n;
	int o = n;

	for (int i = 0; i <= n; i++)
	{
		for (int j = 0; j <= m; j++)
		{
			for (int k = 0; k <= o; k++)
			{
				if (i == 0 || j == 0 || k == 0)
					DP[i][j][k] = 0;
				else if ((A[i - 1] == B[j - 1]) && (C[k - 1] == B[j - 1]))
					DP[i][j][k] = DP[i - 1][j - 1][k - 1] + 1;
				else
					DP[i][j][k] = max(DP[i - 1][j][k], DP[i][j - 1][k], DP[i][j][k - 1]);
			}
		}
	}
	return DP[n][m][o];
}

int main(int argc, char* argv[])
{
    #ifdef DEBUG
        freopen("in", "r", stdin);
        if (argc > 1)
        	freopen("out", "w", stdout);
    #endif

    int t;
    scanf("%d", &t);
    while(t--)
    {
    	scanf("%s %s %s", A, B, C);
    	int cc = LCS();
    	int pp = strlen(A);
    	printf("%d\n", (pp - cc) * 3);
	}

    #ifdef DEBUG
        fclose(stdout);
    #endif
    return 0;
}