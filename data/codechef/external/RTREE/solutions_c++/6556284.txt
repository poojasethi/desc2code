/*------------------------Subham Mishra--------------------------------------------------------*/
/*-----------------Heavy Light Decomposition-------------------------*/
#include<bits/stdc++.h>
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define pl(n) printf("%lld\n",n)
#define p(n) printf("%d\n",n)
#define pb push_back
#define mp make_pair
#define mod 1000000007LL
#define N 101000
#define LN 21
#define ll  long long
#define gc getchar_unlocked
using namespace std;
vector<int>adj[N];
int chainhead[N],chainind[N],chainsz[N],chainpos[N],subsize[N],chainno,otherend[N];
int pa[LN][N],depth[N],ptr,root=0;
ll tree[4*N];
int dis[N],actual[N];
int n;
ll flag[4*N];

int LCA(int u, int v)
{
	if(depth[u] < depth[v]) swap(u,v);
	int diff = depth[u] - depth[v];
	for(int i=0; i<LN; i++) if( (diff>>i)&1 ) u = pa[i][u];
	if(u == v) return u;
	for(int i=LN-1; i>=0; i--) if(pa[i][u] != pa[i][v]) {
		u = pa[i][u];
		v = pa[i][v];
	}
	return pa[0][u];
}
void bfs(int rot)
{
    bool vis[N];
    memset(vis,false,sizeof(vis));
    dis[root]=0;
    queue<int>q;
    q.push(rot);
    vis[rot]=true;
    while(!q.empty())
    {
     int x=q.front();
     q.pop();
     for(vector<int>::iterator it3=adj[x].begin();it3!=adj[x].end();it3++)
     if(!vis[*it3])
     {
            vis[*it3]=true;
            dis[*it3]=dis[x]+1;
            q.push(*it3);
     }
    }
}
void dfs(int curr,int prev,int dep)
{
 pa[0][curr]=prev;
 depth[curr]=dep;
 subsize[curr]=1;
 for(int i=0;i<adj[curr].size();++i)
 {
   if(adj[curr][i]!=prev)
   {
     //otherend[indexx[curr][i]]=adj[curr][i];
     dfs(adj[curr][i],curr,dep+1);
     subsize[curr]+=subsize[adj[curr][i]];
   }
 }
}
void hld(int curr,int prev)
{
 int i;
 if(chainhead[chainno]==-1)
 chainhead[chainno]=curr;
 chainind[curr]=chainno;
 chainpos[curr]=ptr++;
 actual[ptr-1]=curr;
 //chains[chainno].pb(curr);
 //basearray[ptr++]=cos;
 int sc=-1;
 for(i=0;i<adj[curr].size();++i)
  if(adj[curr][i]!=prev)
  if(sc==-1||(subsize[adj[curr][i]]>subsize[sc]))
  {
   sc=adj[curr][i];
  }
  if(sc!=-1)
  hld(sc,curr);
  for(i=0;i<adj[curr].size();++i)
  if(adj[curr][i]!=prev)
   if(sc!=adj[curr][i])
   {
    chainno++;
    hld(adj[curr][i],curr);
   }

}
int dv[N];
void build_tree(int idx,int l,int r)
{
 if(l==r)
 {
  tree[idx]=dv[actual[l]];
  //cout<<l<<" "<<r<<" "<<tree[idx]<<endl;
  return;
 }
 else
 {
  int mid=(l+r)/2;
  build_tree(2*idx,l,mid);
  build_tree(2*idx+1,mid+1,r);
  tree[idx]=tree[2*idx]+tree[2*idx+1];
  //cout<<l<<" "<<r<<" "<<tree[idx]<<endl;
 }
}
/*void update(int idx,int l,int r,int ql,int qr,ll va)
{
 if(ql>r||qr<l||l>r)
 return;
 else if(ql<=l && qr>=r)
 {
 tree[idx]=(tree[idx]+va*(r-l+1))%mod;
 if(l!=r)
 {
   flag[2*idx]+=va;
   flag[2*idx+1]+=va;
 }
 }
 else
 {
   int mid=(l+r)/2;
   update(2*idx,l,mid,ql,qr,va);
   update(2*idx+1,mid+1,r,ql,qr,va);
   tree[idx]=(tree[2*idx]+tree[2*idx+1])%mod;
 }
}*/
int query(int idx,int l,int r,int ql,int qr)
{
 if(qr<l||ql>r||l>r)
 return 0;
 if(ql<=l && qr>=r)
 {
 //cout<<l<<" "<<r<<" "<<tree[idx]<<endl;
 return tree[idx];
 }
 else
 {
  int mid=(l+r)/2;
  return (query(2*idx,l,mid,ql,qr)+query(2*idx+1,mid+1,r,ql,qr));
 }
}
int query_up(int u,int v)
{

 int uchain,vchain=chainind[v];
 int ans=0;
 while(1)
 {
  uchain=chainind[u];
  if(uchain==vchain)
  {
    ans+=query(1,0,ptr-1,chainpos[v],chainpos[u]);
    break;
  }
  ans+=query(1,0,ptr-1,chainpos[chainhead[uchain]],chainpos[u]);
  u=chainhead[uchain];
  u=pa[0][u];
 }

 return ans;
}
int que(int a,int b)
{
 int lca=LCA(a,b);
//cout<<a<<" "<<b<<" "<<lca<<endl;
if(dv[lca]==1)
 return query_up(a,lca)+query_up(b,lca)-1;
 else
 return query_up(a,lca)+query_up(b,lca);
}
/*void query2(int u,int v)
{
  int uchain,vchain=chainind[v],uhead;
  int ans=-1,id;
  while(1)
  {
   uchain=chainind[u];
   uhead=chainhead[uchain];
   if(uchain==vchain)
   {
     id=query(1,0,n-1,chainpos[v],chainpos[u]);
     if(id!=INT_MAX)
     ans=chains[uchain][id-uhead]+1;

     break;
   }
   id=query(1,0,n-1,chainpos[chainhead[uchain]],chainpos[u]);
   if(id!=INT_MAX)
   ans=chains[uchain][id-uhead]+1;
   u=chainhead[uchain];
   u=pa[0][u];
  }
  printf("%d\n",ans);
}*/
/*void que2(int u,int v,int k)
{
 int lca=LCA(u,v);
 int dlca=dis[lca];
 int du=dis[u];
 int dv=dis[v];
 if(du-dlca==k)
 printf("%d\n",lca+1);
 else if(du-dlca>k)
 query2(u,k);
 else
 {
  k=k-(du-dlca);
  k=(dv-dlca)-k;
  query2(v,k);
 }
}
ll ans[N];
void dfs22(int cur,int prev)
{
  ans[cur]=query(1,0,ptr-1,chainpos[cur]);
  int i;
  for(i=0;i<adj[cur].size();++i)
  {
     if(adj[cur][i]!=prev)
     dfs22(adj[cur][i],cur);
  }
  for(i=0;i<adj[cur].size();++i)
  {
     if(adj[cur][i]!=prev)
     {
       ans[cur]+=ans[adj[cur][i]];
       ans[cur]%=mod;
     }
  }
  //assert(ans[cur]>=0);
}*/
int main()
{
 int t,i,a,b,c,q,j,typ,u;
 t=1;
 while(t--)
 {
   s(n);
   for(i=0;i<n;++i)
   {
    chainhead[i]=-1;
    for(j=0;j<LN;++j)
    pa[j][i]=-1;
   }
   chainno=ptr=0;
   for(i=0;i<n-1;++i)
   {
    s(a);s(b);
    adj[a].pb(b);
    adj[b].pb(a);
   }
   dfs(root,-1,0);
   hld(root,-1);
   ll v;
   for(i=0;i<n;++i)
   {
    if(i==0)
    {
     v=1;
     dv[i]=0;
    }
    else
    {
     v=v*i;
     v%=mod;
     if(v%3==0)
     dv[i]=1;
     else
     dv[i]=0;
    }
   }
   build_tree(1,0,n-1);
   //bfs(root);

   for(i=1;i<LN;++i)
   for(j=0;j<n;++j)
   if(pa[i-1][j]!=-1)
   pa[i][j]=pa[i-1][pa[i-1][j]];
   s(q);
   for(i=0;i<q;++i)
   {
    int x,y;
    s(x);s(y);
    printf("%d\n",que(x,y));
   }
 }
 return 0;
}
