

		Donald duck loves learning new algorithms. Today, he learned binary search and understood how it works on integer arrays sorted in non-decreasing order. His knack of getting into problems is famous, and he wrote his version of binary search algorithm as follows:
 
		binarySearch(int[] array, int lo, int hi, int key)
		{
		    while (lo ≤ hi)
		    {
		        mid := random(lo, hi);
		        if a[mid] = key then
		            return mid;
		        else if (a[mid] > key)
		            hi := mid - 1;
		        else
		            lo := mid + 1;
		    }
		    return NOT_FOUND;
		}

		Yes! Donald did use random(lo, hi), instead of floor((lo+hi)/2) to calculate mid. The random(x, y) function returns a random integer between x and y, both inclusive. The problem did not stop here. Instead of giving arrays that are sorted in non-decreasing order as input, Donald was giving all sorts of integer arrays as input.
		Sure enough, the answers he got were far from expected. But he also noticed some interesting properties: searching for some numbers (which are already present in the array) in some arrays will always result in a successful search, but searching for some other numbers (which are also present in the array) in the same array need not always be successful.
		Formally, a number in an array (not necessarily sorted) is findable in the array, iff the number is guaranteed to be found in the array, using Donald's binary search, irrespective of whatever value the random function returns, whenever it is called. Given an integer array (not necessarily sorted) as input, Donald now wants to know the count of numbers that are findable in the array.
	

Input

		First line contains a single integer T, the number of test cases.

		Then 2T lines follow, two lines per test case.

		The first line of each test case contains a single integer N, the size of the array given as input to the function.

		The next line contains N unique space separated integers A[i], 0 ≤ i ≤ N-1


Output

		For each test case, print one integer (each on a new line) - the count of findable numbers in the array.
	

Constraints

		1 ≤ T ≤ 10

		1 ≤ N ≤ 10,000

		-1,000,000 ≤ A[i] ≤ 1,000,000
	

Example
Input:
2
10
-40 -61 -50 -25 14 45 28 71 65 72
5
20 46 48 57 90

Output:
3
5

Explanation

Test Case 1: Here, only -25, 14 and 72 are findable in the array.

Test Case 2: Here, all 5 numbers are findable in the array.
	

