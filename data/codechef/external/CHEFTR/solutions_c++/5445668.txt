#include <iostream>

using namespace std;
/*

	Editorial Ans:
	nCk(n,3) - nCk(k,3);
	//Remarks - Mientras mas chiquito es k, 
			    mas facil es calcular el nCk
		nCk(n,3) = n*(n-1)*(n-2)/3!;

	My ans:
	[k*(k-1)/2] * nCk(n-k, 1) +
	k * nCk(n-k,2)            +
	(n-k) * nCk(n-k-1,2)/3;

	[k * (k-1) /2] = Todas las uniones de 2 puntos de
					 k puntos colineales.
	nCk(n-k,1) = Coger 1 punto de los n-k arbitrarios
				 para completar la tripleta

	nCk(n-k, 2) = Coger 2 puntos de los n-k arbitrarios
				  hacer eso con los k puntos colineales.

	(n*k) * nCk(n-k-1, 2) / 3 = 
					De los n-k-1 puntos en el limbo
					coger 2, hacer lo mismo
					con los n-k 
					El /3 es para eliminar los 
					repetidos
*/

typedef long long ll;

ll nCk(ll n, ll k)
{
	if(k == 1) return n;
	else return n*(n-1)/2;
}

int main()
{
	int t;
	ll n, k;
	cin >> t;

	while(t--)
	{
		cin >> n >> k;

		cout << nCk(k,2) * nCk(n-k, 1) +
				k * nCk(n-k,2)         +
				(n-k) * nCk(n-k-1,2)/3 << endl;
	}

	return 0;
}