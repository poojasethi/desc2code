//dijkstra

#include<bits/stdc++.h>
#define mp(a,b) make_pair(a,b)
#define pb(a) push_back(a)
#define scan(a) scanf("%d",&a)
#define scanl(a) scanf("%lld",&a)
#define print(a) printf("%d",a)
#define printl(a) printf("%lld",a)
#define MAX 1003
using namespace std;

typedef pair<int,int>pii;
typedef long long LL;

/*bool cmp(const pii &left,const pii &right)
{
	return left.second<right.second;
}*/
int gcd(int a,int b)
{
	if(b==0)
	{
		return a;
	}
	else
		return gcd(b,a%b);
}

struct edge
{
	LL node,cost;
};
int visit[MAX],d[MAX];
int qv[MAX];
int graph[MAX][MAX];
vector<pair<LL,LL> > v;
bool operator<(const edge &a,const edge &b)
{
	return d[a.node]>d[b.node];
}

LL dist(int i,int j)
{
	LL c=((v[i].first-v[j].first)*(v[i].first-v[j].first)+((v[i].second-v[j].second)*(v[i].second-v[j].second)));
	return c;
}
LL dijkstra(int st,int end,int n)
{
	priority_queue<edge>q;
	q.push((edge){st,0});
	d[st]=0;
	visit[st]=1;
	while(!q.empty())
	{
		edge a=q.top();
		q.pop();
	
		if(a.node==end)
		{
			return d[end];
		}
		for(int i=1;i<n;i++)
		{
			edge k=(edge){i};
			if(d[a.node]+graph[a.node][k.node]<d[k.node])
			{
				//cout<<k.node<<endl;
				d[k.node]=d[a.node]+graph[a.node][k.node];
				q.push((edge){k.node,d[k.node]});
			}
		}
		
	}
	return d[end];
}
int main()
{
	int n;
	scan(n);
	v.pb(mp(0,0));
	LL a,b;
	for(int i=0;i<n;i++)
	{
		scanl(a);scanl(b);
		v.pb(mp(a,b));
	}
	scanl(a);scanl(b);
	v.pb(mp(a,b));
	n=v.size();
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			graph[i][j]=dist(i,j);
		}
	}
	for(int i=1;i<n;i++)
	{
		d[i]=INT_MAX;
		visit[i]=0;
		qv[i]=0;
	}
	LL min=dijkstra(0,n-1,n);
	cout<<min<<endl;
}