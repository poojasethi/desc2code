#include<stdio.h>
#include<queue>
#include<vector>
using namespace std;
typedef pair<int,int> ii;
typedef pair<ii,int> pii;
#define INFITY 999999999
#define tr(v,it) for(typeof(v.begin()) it=(v).begin();it!=(v).end();it++)
class comp
{
	public:
	bool operator()(const pii &a,const pii &b)
	{
		return a.second>b.second;
	}
};
int calc(int u,int v,int u1,int y1)
{
	return (u1-u)*(u1-u)+(y1-v)*(y1-v);
}
int mat[2020][2020];
void DIJIKSTRA(vector<ii> &WT,int d1,int d2)
{
	ii pp;
	int u,v,w,v1,u1,w1;
	pii p,p1;
	priority_queue<pii,vector<pii>,comp>Q;
	Q.push(pii(ii(0,0),0));
	mat[1000][1000]=0;
	//printf("pushed %d %d--%d\n",0,0,0);
	while(!Q.empty())
	{
		p1=Q.top();
		u1=p1.first.first;
		v1=p1.first.second;
		w1=p1.second;
		Q.pop();
		
		if(u1==d1&&v1==d2)
		{
	//		printf("poped dest %d %d\n",u1,v1);
			printf("%d\n",w1);
			return;
		}
		if(mat[u1+1000][v1+1000]<=w1)
		{
	//	printf("poped %d %d\n",u1,v1);	
		tr(WT,it)
		{
			pp=*it;
			u=pp.first;
			v=pp.second;
			if(mat[u+1000][v+1000]==INFITY)
			{
				mat[u+1000][v+1000]=p1.second+calc(u,v,u1,v1);
	//			printf("pushed %d %d --> %d\n",u,v,mat[u+1000][v+1000]);
				Q.push(pii(ii(u,v),mat[u+1000][v+1000]));
			}
			else if(mat[u+1000][v+1000]>p1.second+calc(u,v,u1,v1))
			{
				mat[u+1000][v+1000]=p1.second+calc(u,v,u1,v1);
	//			printf("pushed %d %d-->%d\n",u,v,mat[u+1000][v+1000]);
				Q.push(pii(ii(u,v),mat[u+1000][v+1000]));
			}
		}
	    }
    }
}
int main()
{
	int i;
	int n,u,v;
	vector< pair<int,int> >WT(1010);
	scanf("%d",&n);
	WT.push_back(ii(0,0));
	mat[1000][1000]=INFITY;
	for(i=1;i<=n+1;i++)
	{
		scanf("%d %d",&u,&v);
		mat[u+1000][v+1000]=INFITY;
		WT.push_back(ii(u,v));
	}
	DIJIKSTRA(WT,u,v);
}