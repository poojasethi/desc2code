//Implementation for Dijkstra's SSSP(Single source shortest path) algorithm
//This is an optimized algorithm running in O(E*log(V))
#include<bits/stdc++.h>
using namespace std;
#define INF INT_MAX //Infinity
#define ll long long
#define mp make_pair
#define pb push_back

const ll sz=10001; //Maximum possible number of vertices. Preallocating space for DataStructures accordingly
vector<pair<ll,ll> > a[sz]; //Adjacency list
vector <pair<pair<ll,ll>,ll > > v;
ll dis[sz]; //Stores shortest distance
bool vis[sz]={0}; //Determines whether the node has been visited or not

//Custom Comparator for Determining priority for priority queue (shortest edge comes first)
    class prioritize{public: bool operator ()(pair<ll, ll>&p1 ,pair<ll, ll>&p2){return p1.second>p2.second;}};
    priority_queue <pair<ll,ll> ,vector<pair<ll,ll> >, prioritize> pq; //Priority queue to store vertex,weight pairs
    
void Dijkstra(ll source, ll n) //Algorithm for SSSP
{
    for(ll i=0;i<sz;i++) //Set initial distances to Infinity
        dis[i]=INF;
    
    pq.push(make_pair(source,dis[source]=0)); //Pushing the source with distance from itself as 0
    
    while(!pq.empty())
    {
        pair<ll, ll> curr=pq.top(); //Current vertex. The shortest distance for this has been found
        pq.pop();
        
        ll cv=curr.first,cw=curr.second; //'cw' the final shortest distance for this vertex
        
        if(vis[cv]) //If the vertex is already visited, no poll in exploring adjacent vertices
            continue;
        
        vis[cv]=true;
        
        for(ll i=0;i<a[cv].size();i++) //Iterating through all adjacent vertices
            if(!vis[a[cv][i].first] && a[cv][i].second+cw<dis[a[cv][i].first]) //If this node is not visited and the current parent node distance+distance from there to this node is shorted than the initial distace set to this node, update it
                pq.push(make_pair(a[cv][i].first,(dis[a[cv][i].first]=a[cv][i].second+cw))); //Set the new distance and add to priority queue
    }
}

int main() //Driver Function for Dijkstra SSSP
{
    ll x,y,x1,y1,x2,y2,n,i,j,dx,dy,node1,node2,cost;
    cin>>n;
    v.pb(mp(mp(0,0),1));
    for(i=2;i<=n+2;i++)
    {
        cin>>x>>y;
        v.pb(mp(mp(x,y),i));
    }
    //dx=v[n+1].first.first;
    //dy=v[n+1].first.second;
    
    for(i=0;i<v.size();i++)
    {
        x1=v[i].first.first;
        y1=v[i].first.second;
        node1=v[i].second;
        
        for(j=0;j<v.size();j++)
        {
            if(i==j)
                continue;
            
            x2=v[j].first.first;
            y2=v[j].first.second;
            node2=v[j].second;
            
            cost=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
            a[node1].pb(mp(node2,cost));
            a[node2].pb(mp(node1,cost));
            
        }
    }
    
    Dijkstra(1,n+2);
    
    cout<<dis[n+2];
    
    
    return 0;
}