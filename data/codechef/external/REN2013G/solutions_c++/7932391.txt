#include<bits/stdc++.h>
using namespace std;
 
struct Node
{
    int index;
    int x,y;
    int wt;
 
} node[1005],temp;
 
struct compare
{
    bool operator()(Node &a,Node &b)
    {
        return (a.wt>b.wt);
    }
};
 
int adj[1005][1005];
 
int mark[1005],x,y,n,i,j;
int main()
{
    scanf("%d",&n);
    node[0].x=0;
    node[0].y=0;
    node[0].wt=0;
    node[0].index=0;
 
    for(i=1; i<=n; i++)
    {
        scanf("%d %d",&x,&y);
        node[i].x=x;
        node[i].y=y;
        node[i].index=i;
        node[i].wt=100000000;
    }
 
    scanf("%d %d",&x,&y);
    node[n+1].x=x;
    node[n+1].y=y;
    node[n+1].index=n+1;
    node[n+1].wt=100000000;
 
    for(i=0; i<=n+1; i++)
    {
        for(j=0; j<=n+1; j++)
            adj[i][j]=pow(node[i].x-node[j].x,2)+ pow(node[i].y-node[j].y,2);
    }
 
    std::priority_queue<Node,std::vector<Node>,compare>p;
 
    p.push(node[0]);
 
    while(!p.empty())
    {
        temp=p.top();
        p.pop();
        if(mark[temp.index])
            continue;
        mark[temp.index]=1;
        if(temp.index==n+1)
        {
            printf("%d\n",temp.wt);
            return 0;
        }
 
        for(i=0; i<n+2; i++)
        {
            if(!mark[i] && (node[i].wt>temp.wt+adj[temp.index][i]))
            {
                node[i].wt=temp.wt+adj[temp.index][i];
                p.push(node[i]);
            }
        }
    }
 
    return 0;
}