#include<vector>
#include<cstring>
#include<algorithm>
#include<stdio.h>
#include<climits>
#include<set>
#include<fstream>
#include<cmath>
#include<bitset>
#include<map>
#include<stack>
#include<fstream>
#include<iostream>
#include<queue>
#define test(t) while(t--)
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)

#define p(n) printf("%lld\n",n)
#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>

#define pb push_back
#define inf 1e16
#define mp make_pair

#define N 200014
//#define inf 100000000
#define ll  long long
using namespace std;

ll mval =3000000000;
ll mod = 1e9+7;
double eps = 1e-10;
ll powmod(ll a,ll b)
{
   ll res = 1;
   while(b>0)
   {
     if(b&1)
        res = (res*a)%mod;
        a=(a*a)%mod;
        b/=2;
   }
   return res;
}
ll minverse(ll a)
{
  if(a==0)
    return 1LL;
  else
   return powmod(a,mod-2);
}


ll tree[4*N];


struct T
{
   int co ;
   int mi ;
}node[N];

bool compare(const struct T&a ,const struct T&b)
{
 return a.co<b.co;
}

void build(int idx,int l,int r)
{
 if(l==r)
    tree[idx] = inf;
else{
   int mid = (l+r)/2;
   build(2*idx+1,l,mid);
   build(2*idx+2,mid+1,r);
   tree[idx] = inf;
 }
}

void update(int idx,int l,int r,int id,ll va)
{
	
   if(l==r)
   {
    tree[idx] = va;
    // cout<<l<<" "<<r<<" "<<tree[idx]<<endl;
   }
    else
    {
     int mid = (l+r)/2;
     if(id<=mid)
        update(2*idx+1,l,mid,id,va);
     else
        update(2*idx+2,mid+1,r,id,va);
        
    tree[idx] = min(tree[2*idx+1],tree[2*idx+2]);
     //cout<<tree[2*idx+1]<<" "<<tree[2*idx+2]<<endl;
     //cout<<l<<" "<<r<<" "<<tree[idx]<<endl;
    }
}

ll query(int idx,int l,int r,int ql,int qr)
{
   //	cout<<ql<<" "<<qr<<" "<<l<<" "<<r<<endl;
  if(ql>r||qr<l||l>r)
     return inf;
  else if(ql<=l && qr>=r)
    return tree[idx];
  else
    {
       int mid = (l+r)/2;
       return min(query(2*idx+1,l,mid,ql,qr),query(2*idx+2,mid+1,r,ql,qr));
    }
}
int main()
{
  int t,n,l,d,i;
  ll dp[N];
  s(t);
  while(t--)
  {
    s(n);s(l);s(d);
    build(0,0,n-1);
    for(i=0;i<n;++i)
    {
       s(node[i].co);s(node[i].mi);
    }
    sort(node,node+n,compare);
     if(d>=l)
     {
      cout<<"YES 0"<<endl;
     }
     else
     {
       int f = 1 ;

       for(i=0;i<n;++i)
       {
         dp[i] = inf;
         if(i==0)
         {
             if(d<node[0].co)
             {
               f = 0;
               break;
             }
             else
                dp[0] = 0;
         }
         else
         {
           if(d>=node[i].co)
                dp[i] = 0;
            else
            {
               int lo = 0;
               int hi = i-1;
               int an = i;

            while(lo<=hi)
            {
              int mid = (lo+hi)/2;
              if(node[mid].co+d>=node[i].co)
              {
                 an = mid;
                 hi = mid - 1;
              }
              else
               lo =mid+1;
            }
               if(an == i)
               {
                 f = 0;
                 break;
               }
        
               dp[i] = query(0,0,n-1,an,i-1);
               
            }
         }
         update(0,0,n-1,i,dp[i]+node[i].mi);
         //cout<<dp[i]<<endl;
       }

       if(f==0)
        cout<<"NO"<<endl;
       else
       {
          ll ans = inf;
          for(i=n-1;i>=0;--i)
          {
            if(node[i].co+d<l)
                break;
            else
                ans = min(ans,dp[i]+node[i].mi);
          }
          if(ans==inf)
          	 cout<<"NO"<<endl;
         else
          cout<<"YES "<<ans<<endl;
       }
     }
  }
}
