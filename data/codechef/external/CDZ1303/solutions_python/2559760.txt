#include<stdio.h>
#include<math.h>

/* -------------- FFT implementation begins here -------------- */

typedef struct
{
	double X,Y;
} Complex;
#define size ((1<<18)+5)
Complex FA[size],FB[size],Copy[size];

int Cmultiply(Complex *a,Complex b) { Complex p={(a->X)*(b.X)-(a->Y)*(b.Y),(a->X)*(b.Y)+(a->Y)*(b.X)}; *a=p; }

double PI; int bit[size],fftN,logN;

int BitReverseCopy(Complex *F)
{
	int i; for(i=0;i<fftN;i++) Copy[i]=F[i];
	for(i=0;i<fftN;i++) F[bit[i]]=Copy[i];
}

int fft(Complex *F,int inverse)
{
	BitReverseCopy(F);
	inverse=inverse?-1:1; int len,i,j;
	for(len=2;len<=fftN;len<<=1)
	{
		double angle=inverse*2*PI/len;
		Complex wl={cos(angle),sin(angle)};
		for(i=0;i<fftN;i+=len)
		{
			Complex w={1,0};
			for(j=0;j<(len>>1);j++)
			{
				Complex u=F[i+j],v=F[i+j+(len>>1)]; Cmultiply(&v,w);
				F[i+j].X=u.X+v.X; F[i+j].Y=u.Y+v.Y;
				F[i+j+(len>>1)].X=u.X-v.X; F[i+j+(len>>1)].Y=u.Y-v.Y;
				Cmultiply(&w,wl);
			}
		}
	}
	if(inverse==-1) for(i=0;i<fftN;i++) { F[i].X/=fftN; F[i].Y/=fftN; }
}

int bitReverse()
{
	int i,j; for(i=0;i<fftN;i++)
	{
		bit[i]=0;
		for(j=0;j<logN;j++) if(i&(1<<j)) bit[i]|=1<<(logN-1-j);
	}
}

int fftPprocess(int *A,int n,Complex *F)
{
	int i; for(i=0;i<n;i++) F[i].X=A[i],F[i].Y=0;
	for(i=n;i<fftN;i++) F[i].X=0,F[i].Y=0;
}

int MultiplyBruteForce(int *A,int n1,int *B,int n2,int *C,int *n3)
{
	*n3=n1+n2-1; int i,j; for(i=0;i<*n3;i++) C[i]=0;
	for(i=0;i<n1;i++) for(j=0;j<n2;j++) C[i+j]+=A[i]*B[j];
}

int PolyMultiply(int *A,int n1,int *B,int n2,int *C,int *n3)
{
	fftN=1; logN=0; int max=n1>=n2?n1:n2;
	while(fftN<max) { fftN<<=1; logN++; } fftN<<=1; logN++;
	long long comp_fft=(long long)(logN)*(fftN);
	long long comp_bruteforce=(long long)(n1)*(n2);
	if( comp_bruteforce <= comp_fft ) return MultiplyBruteForce(A,n1,B,n2,C,n3);
	PI=acos(-1);
	bitReverse();
	fftPprocess(A,n1,FA); fft(FA,0);
	fftPprocess(B,n2,FB); fft(FB,0);
	int i; for(i=0;i<fftN;i++) Cmultiply(&FA[i],FB[i]);
	fft(FA,1);
	*n3=n1+n2-1; for(i=0;i<*n3;i++) C[i]=FA[i].X>=0?(int)(FA[i].X+0.5):(int)(FA[i].X-0.5);
}

/* -------------- FFT implementation ends here -------------- */

int A[100005],N1,B[100005],N2,C[200005],N3;

int solve()
{
	PolyMultiply(A,N1,B,N2,C,&N3);
	printf("%d\n",N3-1);
	int i; for(i=0;i<N3;i++) printf("%d ",C[i]);
	printf("\n");
}

#define Get getchar_unlocked()
inline int GetInt() { int a=0,sign=1; register char ch=0; while(ch<33) ch=Get; if(ch=='-') { sign=-1; ch=Get; } while(ch>33) { a=(a<<3)+(a<<1)+ch-'0'; ch=Get; } return a*sign; }

int main()
{
	int T=GetInt();
	while(T--)
	{
		N1=GetInt(); N2=GetInt(); N1++; N2++;
		int i; for(i=0;i<N1;i++) A[i]=GetInt();
		for(i=0;i<N2;i++) B[i]=GetInt();
		solve();
	}
	return 0;
}