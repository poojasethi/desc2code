/* 	its_pheonix
	
	c++ -> Reloaded 4.3.2 

	:) Disjoint set data-structure 
*/
#include <cstdio>
#include <cmath>
#include <string>
#include <cstdlib>
#include <map>
#include <cstring>
#include <iostream>
#define Mx 100005
#define L int
#define LL long long int
#define C char
#define V void
#define TC() L t ; scanf("%d",&t) ; while(t--) 
using namespace std;
L parent[Mx] = {0} , Sz[Mx] = {0};
map<string,L> f ;
V create_set(int v)
{
	parent[v] = v ;
	Sz[v] = 1 ; // Rank heuristics on basis of size of tree
}
L find_set(int v)
{
	if( v == parent[v] ) 
		return v;
	else
		return parent[v] = find_set(parent[v]) ; // Path compression Heuristics
}
V union_set(int a , int b)
{
	a = find_set(a) ;
	b = find_set(b) ;
	if(a!=b)
	{
		if( Sz[a] < Sz[b] )
			swap(a,b) ;
			parent[b] = a ;
			Sz[a] +=Sz[b] ;
	}
	return ;
}
L main()
{
	TC()
	{
		L n , c = 0 ;
		scanf("%d",&n);
		string a , b ;
		f.clear() ;
		while(n--)
		{
		 
		 cin >>a>>b ;
		 if(!f.count(a))
		 {
		 	f[a] = c ;  // --Awesome-- //
		 	create_set(c) ;
		 	c++;
		 }
		 if(!f.count(b))
		 {
		 	f[b] = c ;
		 	create_set(c) ;
		 	c++;
		 }
		 	L x = f[a] ;
		 	L y = f[b] ;

		 	if(find_set(x)!=find_set(y)) union_set(x,y) ;
		 	printf("%d\n",Sz[find_set(y)]);
		}
	}
	return 0 ;
}