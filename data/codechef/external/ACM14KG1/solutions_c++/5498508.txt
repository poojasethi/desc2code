#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair <int,int> pii;
typedef vector <int> vi;

#define rep(i, n) for(int i = 0; i < (n); ++i)
#define forn(i, a, b) for(int i = (a); i < (b); ++i)
#define ford(i, a, b) for(int i = (a); i >= (b); --i)
#define fore(i, a, b) forn(i, a, b + 1)

#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define all(c) c.begin(), c.end()
#define mset(a, v) memset(a, v, sizeof(a))
#define sz(a) ((int)a.size())

#define gi(x) scanf("%d", &x)
#define pis(x) printf("%d ", x)
#define pin(x) printf("%d\n", x)
#define pnl printf("\n")
#define dbn cerr << "\n"
#define dbg(x) cerr << #x << " : " << (x) << " "
#define dbs(x) cerr << (x) << " "

#define foreach(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it)

const int MAX_N = 100100;

vi a[MAX_N];
vector <pii> toRemove[MAX_N];
pii toInsert[MAX_N], ans[MAX_N];
int cnt[MAX_N];

int main() {
    int T; gi(T);
    rep(z, T) {
        int n, m;
        gi(n), gi(m);
        rep(i, n) a[i].clear(), toRemove[i].clear(), toInsert[i] = mp(n, 0);
        rep(i, m + 1) cnt[i] = 0;

        rep(i, n) {
            int x; gi(x);
            rep(j, x) {
                int id; gi(id);
                a[i].pb(id);
            }
        }
        int ptr = n - 1, numTypes = 0;
        for(int i = n - 1; i >= 0; --i) {
            while(ptr >= 0 and numTypes < m) {
                rep(j, sz(a[ptr])) {
                    cnt[a[ptr][j]]++;
                    if(cnt[a[ptr][j]] == 1) ++numTypes;
                }
                --ptr;
            }
            if(numTypes == m) {
                toRemove[ptr + 1].pb(mp(i - ptr, ptr + 1));
                toInsert[i] = mp(i - ptr, ptr + 1);
            }

            rep(j, sz(a[i])) {
                cnt[a[i][j]]--;
                assert(cnt[a[i][j]] >= 0);
                if(cnt[a[i][j]] == 0) --numTypes;
            }
        }

        set <pii> possible;

        for(int i = n - 1; i >= 0; --i) {
            possible.insert(toInsert[i]);
            ans[i] = *possible.begin();
            if(i < n - 1) ans[i] = min(ans[i], mp(ans[i + 1].ff + 1, ans[i + 1].ss - 1));

            foreach(toRemove[i], it) possible.erase(*it);
        }
        rep(i, n) pis(ans[i].ss + 1), pin(ans[i].ss + ans[i].ff);
    }
    return 0;
}