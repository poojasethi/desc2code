#include<bits/stdc++.h>

#define PB push_back
#define MP make_pair
#define F first
#define S second

#define RI(a) scanf("%d",&a);
#define RIL(a) scanf("%lld",&a);
#define PI(a) printf("%d\n",a);
#define PIL(a) printf("%lld\n",a);

#define SZ(a) (int)(a.size())

#define SET(a,b) memset(a,b,sizeof(a))

#define TR(a,t) for(__typeof(a.begin()) t=a.begin();t!=a.end();t++)

#define REP(i,l,h) for(int i=(l); i<=(h);i++)
#define REPD(i,h,l) for(int i=(h);i>=(l);i--)

#define ALL(a) a.begin(),a.end()

#define DRT()  int t; cin>>t; while(t--)

#define PRSNT(a,e) (a.find(e) != a.end())

#define MINH priority_queue<int, vector<int>, greater<int> >

#define trace1(x) cerr << #x << ": " << x << endl;
#define trace2(x, y) cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
#define trace3(x, y, z) cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;

#define N 100001
#define MOD 1000000007

typedef long long LL;

using namespace std;

vector < vector < int > > a(N,vector<int>());
vector < pair < int, int> > toadd[N];
vector < pair < int, int> > torem[N];
pair < int, int>  ans[N];
set< pair<int,int> > possi;
int cnt[N];
int cnt2[N];
int main()
{
        int n,m,x,temp,j;
        DRT(){
                RI(n);
                RI(m);
                REP(i,0,n-1){
                        a[i].clear();
                        
                RI(x);
                        REP(j,0,x-1){
                               RI(temp);
                                a[i].PB(temp);

                        }
                toadd[i].clear();
                torem[i].clear();
                }
                
                possi.clear();
                SET(cnt,0);
                int num=0;
                /*REP(i,0,n-1) {
                        TR(a[i],it) {
                                cnt[*it]++;
                                if(cnt[*it]==1) num++;
                        }
                        cnt2[i]=num;
                }
                 */       
                REP(l,1,m) cnt[l]=0;
                j=0;
                REP(i,0,n-1){
                //         trace2(i,num);
                       
                       //trace3(i,j,num);
                       while(j<n&&num<m){
                                TR(a[j],it) {
                                        cnt[*it]++;
                                        if(cnt[*it]==1) num++;
                                }
                 //               trace2(j,num);
                                j++;
                        }
                        
                        if(num==m){

                               // j--;
                 //               s.clear();
                                toadd[i].PB(MP(j-i,i));
                                torem[j-1].PB(MP(j-i,i));
                        }
                        else
                        {
                                if(j==n)
                                toadd[i].PB(MP(INT_MAX,i));
                        }
                       //cout<<" end "; 
                       //trace3(i,j,num);
                       //s.clear();
                TR(a[i],it) {
                        //trace2(*it,cnt[*it]);
                        cnt[*it]--;
                        if(cnt[*it]==0) num--;
                }
                        //cout<<"dec ";
                        //trace2(i,num);
                }
                /*
                REP(i,0,n-1) {
                        trace1(i);
                        TR(toadd[i],it) {
                                int xx=it->F;
                                int yy=it->S;
                                trace2(xx,yy);
                        }
                 cout<<"rem\n";
                        TR(torem[i],it) {
                                int xx=it->F;
                                int yy=it->S;
                                trace2(xx,yy);
                        }
                }*/

    
                int xx,yy;
                REP(i,0,n-1){
                        
                        //trace1(i);
                        TR(toadd[i],it)
                                possi.insert(*it);
                        if(i>0) {TR(torem[i-1],it)
                                possi.erase(*it);
                        }
                        ans[i]=*(possi.begin());
                        /*TR(possi,it){
                                int xx=it->F;
                                int yy=it->S;
                                trace3(yy,yy+xx-1,xx);
                        }*/
                        if(i>0)
                        ans[i]=min(ans[i],MP(ans[i-1].F+1,ans[i-1].S));
                       // trace2(ans[i].F,ans[i].S);
                }

                REP(i,0,n-1){

                        printf("%d %d\n",(ans[i].S+1),(ans[i].S+ans[i].F));

                }

        }

        return 0;
}
