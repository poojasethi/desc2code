#include<cstdio>
#include<iostream>
#include<cstdlib>

using namespace std;
typedef struct node *NODEPTR;
#define LIM 100005
#define debug(args...) dbg(),args
#define DBGCHECK if (argc > 1) DBG = ((*argv[1] == '0') ? 0 : 1)
bool DBG;
struct dbg { template<typename T> dbg& operator , (const T& v) { if (DBG) cerr << v << " "; return *this; } ~dbg() { if (DBG) cerr << endl; } };

enum color {red,black};

NODEPTR root,nil;
int num,ans;

struct node{
	color c;
	//key is how many are greater than this number
	//count is no of times this node has occured
	int data,key,count;
	struct node *parent,*left,*right;
};

NODEPTR make_tree( NODEPTR p,int n ){
    NODEPTR temp;
    temp = (struct node*)malloc(sizeof(struct node));
    temp->data = n;
    temp->key = 0;
    temp->count = 1;
	temp->c = red;
    temp->left = nil;
    temp->right = nil;
	temp->parent = p;
    return(temp);
}

void trav_inorder( NODEPTR m ){
    if(m != nil){
        trav_inorder(m->left);
        cout << m->data << " " << endl;
		trav_inorder(m->right);
    }
}

NODEPTR insert(int n){
	if(root == nil){
		root = make_tree(nil,n);
		return root;
	}
	NODEPTR p,q;
    p = q = root;
	debug("root",root->data);
    while(q != nil){
        p = q;
		if(n == p->data){
			ans += p->key;
			p->count ++;
			return NULL;
			}
        else if(n > p->data){
             q = p->right;
			 p->key ++;
			 //debug(n,p->data);
			 }
		else{
			q = p->left;
			ans += p->count;
			ans += p->key;
			//debug(n,p->data);
			}
        }
		//debug("ans",n,ans);
    if(n > p->data){
        p->right = make_tree(p,n);
		return (p->right);
		}
    else{
        p->left = make_tree(p,n);
		return (p->left);
		}
}

void left_rotate( NODEPTR x) {
    NODEPTR y = x->right;
    x->right = y->left;
    if ( y->left != nil )
        y->left->parent = x;
    y->parent = x->parent;
    if ( x->parent == nil ) root = y;
    else
        if ( x == (x->parent)->left )
            x->parent->left = y;
        else
            x->parent->right = y;
    y->left = x;
    x->parent = y;
    }
	
void right_rotate( NODEPTR x ) {
    NODEPTR y;
    y = x->left;
    x->left = y->right;
    if ( y->right != nil )
        y->right->parent = x;
    y->parent = x->parent;
    if ( x->parent == nil ) root = y;
    else
        if ( x == (x->parent)->left )
            x->parent->left = y;
        else
            x->parent->right = y;
    y->right = x;
    x->parent = y;
}

void rb_insert( int n ) {
    NODEPTR x,y;
	x = insert( n );
	debug("insert",n);	
	trav_inorder(root);	
	if(x != NULL){
    x->c = red;
    while ( (x != root) && (x->parent->c == red) ) {
       if ( x->parent == x->parent->parent->left ) {
           y = x->parent->parent->right;
           if ( y->c == red ) {
               x->parent->c = black;
               y->c = black;
               x->parent->parent->c = red;
               }
           else {
               if ( x == x->parent->right ) {
                   x = x->parent;
                   left_rotate( x );
                   }
               x->parent->c = black;
               x->parent->parent->c = red;
               right_rotate( x->parent->parent );
               }
           }
       else {
           y = x->parent->parent->left;
           if ( y->c == red ) {
               x->parent->c = black;
               y->c = black;
               x->parent->parent->c = red;
               x = x->parent->parent;
               }
           else {
               if ( x == x->parent->left ) {
                   x = x->parent;
                   right_rotate( x );
                   }
               x->parent->c = black;
               x->parent->parent->c = red;
               left_rotate( x->parent->parent );
               }
           }
       }
    }
	root->c = black;
}

int main(int argc,char *argv[]){
	DBGCHECK;
	nil = (struct node*)malloc(sizeof(struct node));
	nil->c = black;
	nil->left = NULL;
	nil->right = NULL;
	int t;
	scanf("%d",&t);
	while(t-- > 0){
		int n;
		root = nil;
		ans = 0;
		scanf("%d",&n);
		for(int i=0;i < n;i++){
			scanf("%d",&num);
			insert(num);
			//trav_inorder(root);
		}
		//trav_inorder(root);
		printf("%d\n",ans);
	}
}
