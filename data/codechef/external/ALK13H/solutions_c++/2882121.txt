#include <cstdio>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <algorithm>
#include <cstring>
using namespace std;
typedef pair<int, int> ii;
typedef vector<ii> vii;
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
const int inf = 1000000000, nil = -1;

class HopcroftMaxBPM {
	// main inputs
	vector< vector<int> > G;
	int n1, n2;
	// used by algorithm
	vector< int > mate;
	vector< int > level;

	bool checkAugmentingPath() {
		queue<int> Q;
		int v;
		bool canAugment = 0;
		fill(level.begin(), level.end(), inf);
		for (int i = 0; i < n1; i++)
			if( mate[i] == nil )
			{
				level[i] = 0;
				Q.push(i);
			}

		while ( Q.empty() ==  false )
		{
			v = Q.front(); Q.pop();
			for (int i = 0; i < G[v].size(); i++)
				if ( mate[ G[v][i] ] == nil )
					canAugment = 1;
				else if (level[ mate[ G[v][i] ] ] == inf)
				{
					level[ mate[ G[v][i] ] ] = level[ v ] + 1;
					Q.push( mate[ G[v][i] ] );
				}
		}
		return canAugment;
	}

	bool augment(int v){
		for (int i = 0; i < G[v].size(); i++ )
			if( mate[ G[v][i] ] == nil || \
			    (level[ mate[ G[v][i] ] ] == level[v] + 1 && augment( mate[ G[v][i] ] ) ) )
			{
				mate[v] = G[v][i];
				if ( G[v][i] != nil )
					mate[ G[v][i] ] = v;
				level[v] = inf;
				return true;
			}
		level[v] = inf;
		return false;
	}

public:
	HopcroftMaxBPM(){}
	HopcroftMaxBPM(vector< vector<int> > _G, int _n1, int _n2) : \
	   G(_G), n1(_n1), n2(_n2) {
		mate  = vector<int> (n1 + n2);
		level = vector<int> (n1);
	}

	pair<int, vector<int> > getMaxBPM(){
		int matching = 0;
		fill(mate.begin(), mate.end(), nil);
		while ( checkAugmentingPath() == true )
		{
			for(int i = 0; i < n1; i++)
			{
				if( mate[i] == nil )
					if( augment(i) == true )
						matching = matching + 1;
			}
		}
		return make_pair(matching, mate);
	}

};

stack<int> dfs_scc; // additional information for SCC
set<int> in_stack; // for dfs_low update check
int dfs_low[500] ,dfs_num[500] ,dfsNumberCounter,val[500],con;
#define DFS_WHITE 0
vector< vector<int> > g(500);
void tarjanSCC(int u) {
    dfs_low[u] = dfs_num[u] = dfsNumberCounter++; // dfs_low[u] <= dfs_num[u]
    dfs_scc.push(u); in_stack.insert(u); // stores u based on order of visitation
    for(int i = 0 ; i < g[u].size(); i++){
        int v = g[u][i];
        if (dfs_num[v] == DFS_WHITE) // a tree edge
            tarjanSCC(v);
        if (in_stack.find(v) != in_stack.end()) // condition for update
        dfs_low[u] = min(dfs_low[u], dfs_low[v]); // update dfs_low[u]
    }
    if (dfs_low[u] == dfs_num[u]) { // if this is a root of SCC
        //printf("SCC: ");
        while (!dfs_scc.empty() && dfs_scc.top() != u) {
            val[dfs_scc.top()] = con ;
            in_stack.erase(dfs_scc.top());
            dfs_scc.pop();
        }
        val[dfs_scc.top()] = con ;
        in_stack.erase(dfs_scc.top());
        dfs_scc.pop();
        con++;
    }
}


main(){
	int t, n;
	pair<int, vector<int> > bpm;
	scanf("%d", &t);
	while (t--){
		scanf ("%d", &n);
		int k, v;
		for (int i = 0; i < 2*n; i++) g[i].clear();
		for (int i = 0; i < n; i++) {
			scanf ("%d", &k);
			while (k--) {
				scanf ("%d", &v);
				v--;
				g[v].push_back( n + i );
			}
		}
		HopcroftMaxBPM h(g, n, n);
		bpm = h.getMaxBPM();
		if(bpm.first== n ){
		    //printf("Hello");
            int ans = 0;
            memset(dfs_low,0,sizeof(dfs_low));
            memset(dfs_num,0,sizeof(dfs_num));
            memset(val,0,sizeof(val));
            while(!dfs_scc.empty()) dfs_scc.pop();
            in_stack.clear();
            con = 1;
            dfsNumberCounter = 1 ;

            for(int i=0;i<n;i++)
                g[bpm.second[i]].push_back(i);

            for(int i = 0; i < n; i++)
                if(dfs_num[i] == 0) tarjanSCC(i);
            //return 0;
            for(int u=0; u<n;u++)
                for(int j = 0; j < g[u].size();j++){
                    v = g[u][j];
                    if( (val[u] == val[v]) && val[u] >= 1) ans++;
                }
            printf("1 %d\n",ans);
		}
        else
            printf("0 0\n");
	}
	return 0;
}
