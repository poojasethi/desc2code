#include<iostream>
#include <list>
#include <map>
 #include <limits.h>
 
#include<stdio.h>
 
 
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
using namespace std;
 
 static bool   visited[100005];
static long long    y[100005];
 
//static long long    y[50001];

//static long long    co[50001];
//static long long    visit[50001];
static long long    c1;
static long long    c2;
//static long long    k;
 
  long long Co(long long n, long long r) {
  	if(n==0) return 0;
    if(r > n / 2) r = n - r; // because C(n, r) == C(n, n - r)
    long long ans = 1;
    int i;
 
    for(i = 1; i <= r; i++) {
        ans *= n - r + i;
        ans /= i;
    }
 
    return ans;
}
   long long   readint()
{
   long long    cc = getc(stdin);
    for (;cc < '0' || cc > '9';)
            cc = getc(stdin);
  long long   ret = 0;
    for (;cc >= '0' && cc <= '9';)
    {
            ret = ret * 10 + cc - '0';
            cc = getc(stdin);
    }
    return ret;
}
// This class represents a directed graph using adjacency list representation
class Graph
{
    long long    V;    // No. of vertices
    list<long long   > *adj;    // Polong long   er to an array containing adjacency lists
public:
    Graph(long long    V);  // Constructor
    void addEdge(long long    v, long long    w); // function to add an edge to graph
    void BFS(long long    s);  // prlong long   s BFS traversal from a given source s
};
 
Graph::Graph(long long    V)
{
    this->V = V;
    adj = new list<long long   >[V];
}
 
void Graph::addEdge(long long    v, long long    w)
{
    adj[v].push_back(w); // Add w to vÃ?ï¿½?Ã?ï¿½Ã?Â¢??s list.
}
int printpath(long long    s,long long    v)
{
	//int c2=0;
    
 
	if(v==s)
	{//cout<<v<<" in ";
	return 1;}
	else if(y[v]==-1)
	{
	//cout<<v<<" "<<"in2 ";
	return 0;
	}
	//cout<<s<<" "<<"in ";
	//else if(y[v]==-1)
	//cout<<" no path ";
	else{
 
	 if(printpath(s,y[v]))
	 return 1;
	else return 0;
	//cout<<v<<" "<<"in2 ";
}
}
void Graph::BFS(long long    s)
{
 
    int temp=s;
  
    for(long long i = 0; i < V; i++)
       y[i]=-1;
    
    // Create a queue for BFS
    list<long long   > queue;
 
    // Mark the current node as visited and enqueue it
    visited[s] = true;
    	//d1[s]= INT_MAX;
       	y[s]=-1;
    queue.push_back(s);
 
    // 'i' will be used to get all adjacent vertices of a vertex
    list<long long   >::iterator i;
 
    while(!queue.empty())
    {
        // Dequeue a vertex from queue and prlong long    it
        s = queue.front();
       // cout << s << " ";
        queue.pop_front();
      
 
       {
 
 
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
 
            if(!visited[*i])
            {
           	
       			y[*i]=s;
                visited[*i] = true;
                queue.push_back(*i);
            }
 
        }
       	
         
       }
    }
   // return false;
}
int  main()
{
   
 
  long long   n,m,s,d,c=0,u,so,des;
	   n =readint();
       m=readint();
       u=readint();
       
   // cin>>n>>m;
    Graph g(n);
   // long long  * h= new long long   [n];
     //long long * pa= new long long   [n];
 
   
        //scanf("%lld",&h[i]);}
    for(long long  i=0;i<n-1;i++)
    {
	       s =readint();
           d =readint();//  cin>>s>>d;
        //scanf("%lld%lld",&s,&d);
    g.addEdge(s, d);
    //g.addEdge(d, s);
	}
 g.BFS(u);
 
 //printpath(2,8);
 for(long long  i=0;i<m;i++)
        {
        	so=readint();
        	des=readint();
        	if(printpath(so,des)==1)
        {
        	
        	printf("-1\n");
        }
             else if(printpath(des,so)==1)
        	{printf("1\n");
			//cout<<printpath(des,so)<<"is";
			}
        	else printf("0\n");
        }
 
      
        
        
//}
    return 0;
}