#include <bits/stdc++.h>
 
using namespace std;
 
#define ll long long int
#define pb push_back
#define mp make_pair
#define INF (ll)(1e18)
#define inf 0x7fffffff
#define inff 100000
#define ff first
#define ss second
#define sz(x) ((int) (x).size())
#define fast cin.sync_with_stdio(0);cin.tie(0)
#define rep(i,N) for(int i = 0;i < N;i++)
#define frep(i,a,b) for(int i = a;i <= b;i++)
#define pii pair<int , int>
#define pll pair<ll , ll>
#define vii vector< int >
#define vll vector< ll >
#define vpii vector< pii >
#define fill(A,v) memset(A,v,sizeof(A))
#define setbits(x) __builtin_popcount(x)
#define print(A,j,k) for(int ii=j;ii<=k;ii++)cout<<A[ii]<<" ";cout<<"\n"
#define all(x) (x).begin(), (x).end()
#define gcd __gcd
#define SQRT 350
#define CASES int t;cin>>t;while(t--)
#define FILE freopen("inp.txt" , "r" , stdin);

const int N = 1e5 + 5;
const int MOD = 1e9 + 7;

int A[N] , B[N] , inv[N];

int sum[10*N];

void update(int node , int l , int r , int ql , int qr) {
	if (l > r || ql > qr || l > qr || r < ql)
		return;

	if (l >= ql && r <= qr) {
		sum[node]++;
		return;
	}

	int mid = (l + r) / 2;
	update(2*node , l , mid , ql , qr);
	update(2*node + 1 , mid + 1 , r , ql , qr);
	sum[node] = sum[2*node] + sum[2*node + 1];
}

void remove(int node , int l , int r , int ql , int qr) {
	if (l > r || ql > qr || l > qr || r < ql)
		return;

	if (l >= ql && r <= qr) {
		sum[node]--;
		return;
	}

	int mid = (l + r) / 2;
	remove(2*node , l , mid , ql , qr);
	remove(2*node + 1 , mid + 1 , r , ql , qr);
	sum[node] = sum[2*node] + sum[2*node + 1];
}


int query(int node , int l , int r , int ql , int qr) {
	if (l > r || ql > qr || l > qr || r < ql)
		return 0;

	if (l >= ql && r <= qr) {
		return sum[node];
	}

	int mid = (l + r) / 2;
	return query(2*node , l , mid , ql , qr) + query(2*node + 1 , mid + 1 , r , ql , qr);
}


void zero(int n) {
	rep(i , n) {
		cin >> A[i];
	}
	A[n] = -1;
	int r = 0 , l = 0;
	ll ans = 0;
	while(r < n) {
		if (A[r] <= A[r + 1]) {
			r++;
			if (r == n - 1) {
				ll len = r - l + 1;
				len *= len + 1;
				len /= 2;
				ans += len;
				r++;
				l = r;
			}
		}
		else {
			ll len = r - l + 1;
			len *= len + 1;
			len /= 2;
			ans += len;
			r++;
			l = r;
		}
	}
	cout << ans << '\n';
	exit(0);
}

bool done[N];

int main(int argc, char const *argv[])
{
	fast;

	// FILE;

	ll n , k;
	cin >> n >> k;

	if (k == 0)
		zero(n);

	rep(i , n) {
		cin >> A[i];
		B[i] = A[i];
	}
	sort(B , B + n);

	int c = 0;
	map<int , int> M;
	rep(i , n)
		if (M[B[i]] == 0)
			M[B[i]] = ++c;

	rep(i , n)
		A[i] = M[A[i]];

	int l = 0 , r = 0 ;
	ll inversions = 0 , cnt = 0;

	while (l <= r && l < n && r < n) {

		while (r < n && inversions < k) {

			if (done[r]) {
				r++;
				continue;
			}
			done[r] = true;
			inv[r] = query(1 , 0 , 3e5 , A[r] + 1 , 3e5);
			// cout << "inversions of index " << r << " are " << inv[r] << '\n';
			if (inv[r] + inversions < k) {
				inversions += inv[r];
				update(1 , 0 , 3e5 , A[r] , A[r]);
				r++;
			}
			else {
				inversions += inv[r];
				update(1 , 0 , 3e5 , A[r] , A[r]);
				break;
			}
		}

		if (r == n)
			r = n - 1;

		// cout << "range " << l << ' ' << r << " inversions " << inversions << '\n';

		if (inversions >= k)
			cnt += n - r;
		
		remove(1 , 0 , 3e5 , A[l] , A[l]);
		if (A[l] > 0) {
			// cout << "removing index " << l << '\n';
			// cout << "inversions reduced by " << query(1 , 0 , 3e5 , 0 , A[l] - 1) << "\n\n";
			inversions -= query(1 , 0 , 3e5 , 0 , A[l] - 1);
		}
		l++;
	}

	cout << cnt << '\n';

    return 0;
}

