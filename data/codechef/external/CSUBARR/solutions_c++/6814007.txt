/* PROBLEM STATEMENT :
There is an array A of n elements . You need to tell the number of subarrays having inversion count greater than equal to a particular value K

CONSTRAINTS :
1<=n<=1*10^5
1<=K<=n*(n-1)/2
1<=A[i]<=10^9

INPUT :
5 3
5 4 3 2 1


OUTPUT :
6


EXPECTED COMPLEXITY : NLOGN
TIME LIMIT : 1 sec */
#include<bits/stdc++.h>
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define pl(n) printf("%lld\n",n)
#define p(n) printf("%d\n",n)
#define pb push_back
#define mp make_pair
#define N 100005
#define LN 25
#define ll  long long
using namespace std;
int n,maxval;
int b1[2*N],ar[N],newar[N],tmp[N];
ll k,ans;


int upd(int id,int va)
{
    while(id<=maxval)
    {
     b1[id]+=va;
     id+=(id & -id);
    }
}

int que(int id)
{
    int su=0;
    while(id>0)
    {
     su+=b1[id];
     id-=(id & -id);
    }

    return su;
}

void input()
{
    cin>>n>>k;
    for(int i=0;i<n;++i)
    {
    cin>>ar[i];
    tmp[i]=ar[i];
    }
    maxval = 2*n;
    memset(b1,0,sizeof(b1));
    ans = 0;
}

void coordinate_compress()
{
     map<int,int>m1;
     sort(tmp,tmp+n);
     int tt=1;
     for(int i=0;i<n;++i)
     {
        if(i==0||tmp[i]==tmp[i-1])
            m1[tmp[i]]=tt;
        else
        {
            tt++;
            m1[tmp[i]]=tt;
        }
     }

     for(int i=0;i<n;++i)
        newar[i] = m1[ar[i]];
}

void DEBUG()
{
    for(int i=0;i<=10;++i)
    cout<<b1[i]<<" ";
}

void solve()
{
    ll inv=0;
    int la=0;
    upd(newar[0],1);
    if(k==0)
    {
     ans=n;
     ans=ans*(n+1)/2;
     return;
    }
    //DEBUG();
    for(int i=1;i<n;++i)
    {
        inv+=(i-la-que(newar[i]));
        upd(newar[i],1);

        while(la<i)
        {
         if(inv<k)
            break;
         else
            {
                inv-=que(newar[la]-1);
                upd(newar[la],-1);
                la++;
            }
        }
        ans+=la;
       // DEBUG();
    }
}

int main()
{
  input();
  coordinate_compress();
  solve();

  cout<<ans<<endl;
}
