#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N = 5e5 + 10;
const int Q = 1e5 + 10;

const int LOG = 20;

#define left LEFt
#define right RIGHT
#define index INDEX
#define copy COPY

vector<int> edge[N];
int n, m;
int father[N][LOG], left[N], right[N], dep[N];

void get_dfs_order() {
	vector<pair<int, int> > stack;
	stack.push_back(make_pair(1, 0));
	father[1][0] = 0;
	
	int index = 0;
	left[1] = ++index;
	dep[1] = 0;
	while (stack.size()) {
		int x = stack.back().first, e = stack.back().second;
		stack.pop_back();
		if (e == edge[x].size()) {
			right[x] = index;
			continue;
		}
		int y = edge[x][e++];
		stack.push_back(make_pair(x, e));
		if (y == father[x][0]) {
			continue;
		} else {
			left[y] = ++index;
			dep[y] = dep[x] + 1;
			stack.push_back(make_pair(y, 0));
			father[y][0] = x;
		}
	}
	
	for (int i = 0; i + 1 < LOG; i++) {
		for (int j = 1; j <= n; j++) {
			father[j][i + 1] = father[father[j][i]][i];
		}
	}
}

const int POOL = (int)(Q * 0.55 * LOG * LOG * 4);

struct Node {
	int lchild, rchild, sum;
	Node(int lchild, int rchild, int sum) : lchild(lchild), rchild(rchild), sum(sum) {
	}
	Node() {}
}pool[POOL];
int used = 0;

int copy;

int build_inner(int l, int r) {
	int x = used++;
	Node& tmp = pool[x];
	if (l == r) {
		tmp.sum = 0;
		tmp.lchild = tmp.rchild = -1;
	} else {
		int mid = (l + r) >> 1;
		tmp = Node(build_inner(l, mid), build_inner(mid + 1, r), 0);
	}
	return x;
}

struct ONode {
	int lchild, rchild, root;
	ONode(int lchild, int rchild, int root) : lchild(lchild), rchild(rchild), root(root) {}
	ONode() {}
}Opool[Q * LOG * 4];
int Oused = 0;

int root[Q];

int build_outter(int l, int r) {
	int x = Oused++;
	ONode& tmp = Opool[x];
	if (l == r) {
		tmp.root = copy;
		tmp.lchild = tmp.rchild = -1;
	} else {
		int mid = (l + r) >> 1;
		tmp = ONode(build_outter(l, mid), build_outter(mid + 1, r), copy);
	}
	return x;
}

struct Query {
	int type, u, v, w, k;
	Query() {}
}query[Q];

int get_lca(int u, int v) {
	if (dep[u] < dep[v]) {
		swap(u, v);
	}
	for (int i = LOG - 1; i >= 0; i--) {
		if (dep[u] - (1 << i) >= dep[v]) {
			u = father[u][i];
		}
	}
	if (u == v) {
		return u;
	}
	for (int i = LOG - 1; i >= 0; i--) {
		if (father[u][i] != father[v][i]) {
			u = father[u][i];
			v = father[v][i];
		}
	}
	return father[u][0];
}

int insert_inner(int rt, int l, int r, int pos, int delta) {
	int x = used++;
	Node& tmp = pool[x];
	tmp = pool[rt];
	
	tmp.sum += delta;
	
	if (l == r) {
		return x;
	} else {
		int mid = (l + r) >> 1;
		if (pos <= mid) {
			tmp.lchild = insert_inner(tmp.lchild, l, mid, pos, delta);
		} else {
			tmp.rchild = insert_inner(tmp.rchild, mid + 1, r, pos, delta);
		}
	}
	return x;
}

int insert(int rt, int l, int r, int pos, int w, int delta) {
	int x = Oused++;
	ONode& tmp = Opool[x];
	tmp = Opool[rt];
	
	tmp.root = insert_inner(tmp.root, 0, m - 1, w, delta);
	
	if (l == r) {
		return x;
	}
	
	int mid = (l + r) >> 1;
	if (pos <= mid) {
		tmp.lchild = insert(tmp.lchild, l, mid, pos, w, delta);
	} else {
		tmp.rchild = insert(tmp.rchild, mid + 1, r, pos, w, delta);
	}
	return x;
}

void get_node(int x, int l, int r, int ql, int qr, vector<int> &ret) {
	if (r < ql || qr < l) {
		return;
	}
	if (ql <= l && r <= qr) {
		ret.push_back(Opool[x].root);
		return ;
	}
	int mid = (l + r) >> 1;
	get_node(Opool[x].lchild, l, mid, ql, qr, ret);
	get_node(Opool[x].rchild, mid + 1, r, ql, qr, ret);
}

int solve(int l, int r, int x, int k) {
	static vector<int> rnode, lnode;
	rnode.clear(); get_node(root[r], 1, n, left[x], right[x], rnode);
	lnode.clear(); get_node(root[l - 1], 1, n, left[x], right[x], lnode);
	
	{
		int tot = 0;
		for (int i = 0; i < rnode.size(); i++) tot += pool[rnode[i]].sum;
		for (int i = 0; i < lnode.size(); i++) tot -= pool[lnode[i]].sum;
		if (tot < k) {
			return -1;
		}
	}
	
	int lv = 0, rv = m - 1;
	while (lv < rv) {
		int lsum = 0, dir = 0;
		for (int i = 0; i < rnode.size(); i++) lsum += pool[pool[rnode[i]].lchild].sum;
		for (int i = 0; i < lnode.size(); i++) lsum -= pool[pool[lnode[i]].lchild].sum;
		int mid = (lv + rv) >> 1;
		if (lsum < k) {
			k -= lsum;
			dir = 1;
			lv = mid + 1;
		} else {
			dir = 0;
			rv = mid;
		}
		
		for (int i = 0; i < rnode.size(); i++) {
			rnode[i] = dir ? pool[rnode[i]].rchild : pool[rnode[i]].lchild;
		}
		for (int i = 0; i < lnode.size(); i++) {
			lnode[i] = dir ? pool[lnode[i]].rchild : pool[lnode[i]].lchild;
		}
	}
	return lv;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i < n; i++) {
		int u, v;
		scanf("%d %d", &u, &v);
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	
	get_dfs_order();
	
	vector<int> values;
	
	int q;
	scanf("%d", &q);
	for (int i = 1; i <= q; i++) {
		int type;
		scanf("%d", &type);
		query[i].type = type;
		if (type == 1) {
			int u, v, w;
			scanf("%d %d %d", &u, &v, &w);	
			query[i].u = u;
			query[i].v = v;
			query[i].w = w;
			values.push_back(w);
		} else {
			int x, l, r, k;
			scanf("%d %d %d %d", &x, &l, &r, &k);
			query[i].u = l;
			query[i].v = r;
			query[i].k = k;
			query[i].w = x;
		}
	}
	
	sort(values.begin(), values.end());
	values.erase(unique(values.begin(), values.end()), values.end());
	m = values.size();
	
	copy = build_inner(0, m - 1);
	root[0] = build_outter(1, n);
	
	for (int i = 1; i <= q; i++) {
		if (query[i].type == 1) {
			int u = query[i].u;
			int v = query[i].v;
			int w = query[i].w;
			w = lower_bound(values.begin(), values.end(), w) - values.begin();
			int lca = get_lca(u, v);
			if (dep[u] > dep[v]) swap(u, v);
			
			root[i] = insert(root[i - 1], 1, n, left[v], w, 1);
			if (u != lca) {
				root[i] = insert(root[i], 1, n, left[u], w, 1);
				root[i] = insert(root[i], 1, n, left[lca], w, -1);
			}
			if (father[lca][0]) root[i] = insert(root[i], 1, n, left[father[lca][0]], w, -1);
		} else {
			int l = query[i].u;
			int r = query[i].v;
			int x = query[i].w;
			int k = query[i].k;
			root[i] = root[i - 1];
			int ret = solve(l, r, x, k);
			printf("%d\n", ret == -1 ? ret : values[ret]);
		}
	}
	
	return 0;
}