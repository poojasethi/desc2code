/*Team ALGO 
     ACM ICPC MNNIT */
#include<iostream>
#include<stdio.h>
#include<cassert>
#include<bitset>
#include<algorithm>
#include<vector>
#include<stack>
#include<queue>
#include<deque>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long int LL;
#define SL(x) scanf("%lld",&x)
#define S(x) scanf("%d",&x)
#define SS(x) scanf("%s",s)
#define P(x) printf("%d",x)
#define PL(x) printf("%lld",x)
#define PS(x) printf("%s",x)
#define LINE printf("\n")
#define FOR(x) for(int i=0;i<x;i++)
#define FORREV(x) for(int i=x;i>=0;i++)
#define W(x) while(x--)
#define REP(i,n) for(int i=1;i<=n;i++)
#define mod 8388608
/*
BJORNER -WELKER SEQUENCE 
FROMULA :- 2^(N-3)*(N^2-5*N+8)-1
LINK:-http://oeis.org/A055580
*/
long long int power(long long int num,long long int expo)
{
num=num%mod;
if(expo==0)
return 1;
if(expo%2)
return num*(power(num,(expo-1)/2)%mod)*(power(num,(expo-1)/2)%mod);
else
return (power(num,(expo)/2)%mod)*(power(num,(expo)/2)%mod);
}
long long int solve(long long int n)
{
//PS("hello");
long long int nt,n2,res;
nt=power(2,n-3);
//n2=power(n,2);
//res=(((nt%mod)*((n2%mod-(5*(n%mod))%mod+8)%mod))%mod-1)%mod;
n2=(n*n-5*n+8)%mod;
res=((nt*n2)-1)%mod;
return res;
}
int main()
{
int tc;
long long int ans,n;
S(tc);
   W(tc)
      {
       scanf("%lld",&n);
      if(n<=21)
      {n=n+2;
       ans=solve(n);}
      else
       ans=8388607;
       PL(ans);LINE;
      }
return 0;
}

