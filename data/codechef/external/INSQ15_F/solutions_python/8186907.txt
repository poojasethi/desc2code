#include<stdio.h>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<string>
#include<cmath>
#include<cstring>
#include<stdlib.h>
#include<algorithm>
using namespace std;
#define MAX 100005
typedef pair<long long int,int> p;
typedef pair<pair<long long,int>,int> pii;
#define fi first
#define se second
#define pb push_back
#define UP 1
#define DN 0

vector<int> v;
int H[MAX];
int C[MAX];
vector<int> G[MAX];
long long int cost[MAX][2];
int visited[MAX][2] = {0};
long long int dijkstra(int N)
{
	int i,j;
//	int cost = 1;
	int u;
	long long c;
//	memset(cost,-1,sizeof(cost));
	for(i=0;i<MAX;i++)
	{
		cost[i][0] = cost[i][1] = -1;
	}
	priority_queue< pii , vector<pii> , greater<pii> > q;
	q.push(pii(p(C[1],1),UP));
	q.push(pii(p(C[1],1),DN));
	cost[1][0] = cost[1][1] = C[1];
	long long upc,dnc;
	while(!q.empty())
	{
		pii cur = q.top();
		q.pop();
		u = cur.fi.se;
		c = cur.fi.fi;
		if(cost[u][cur.se] < c)
			continue;
//		printf("U : %d %d\n",u,cur.se);
//		if(visited[u][cur.se]==1 && visited[u][1-cur.se]==1)
//			continue;
		
//		visited[u][cur.se] = 1;
//		printf("u : %d\n",u);
//		if(cost[u][cur.se] > c || cost[u][cur.se]==-1)
//			cost[u][cur.se] = c;
		for(i=0;i<G[u].size();i++)
		{
//			printf("HEY\n");
			
			if(H[u] == H[G[u][i]])
			{
				if(cur.se) // up
				{
					upc = c;
					dnc = c + C[G[u][i]];
				}
				else
				{
					upc = c + C[G[u][i]];
					dnc = c;
				}
//					q.push( pii( p(c , G[u][i].fi)  , cur.se ) );
//				if(visited[G[u][i].fi][1-cur.se] == 0)
//					q.push( pii( p(c + C[G[u][i].fi], G[u][i].fi)  , 1-cur.se ) );
			}
			else if(H[u] > H[G[u][i]])
			{
				
				if(cur.se == DN)
				{
					dnc = c;
					upc = c + C[G[u][i]];
				}
				else
				{
					dnc = c + C[u];
					upc = c + C[G[u][i]] + C[u];
				}
				
			}
			else
			{
				if(cur.se==UP)
				{
					upc = c;
					dnc = c + C[G[u][i]];
				}
				else
				{
					upc = c + C[u];
					dnc = dnc = c + C[G[u][i]] + C[u];
				}
			}
			if(cost[G[u][i]][UP] > upc || cost[G[u][i]][UP]==-1)
			{
				cost[G[u][i]][UP] = upc;	
				q.push(pii ( p(upc , G[u][i]) , UP ));
			}
			if(cost[G[u][i]][DN] > dnc || cost[G[u][i]][DN] == -1)
			{
				cost[G[u][i]][DN] = dnc;
				q.push(pii ( p(dnc , G[u][i]) , DN ));
			}
		}
	}
//	for(i=1;i<=N;i++)
//		printf(" %d : %d  \n",i,min(cost[i][0],cost[i][1]));
/*	if(cost[N][0]==0)
		return cost[N][1];
	else if(cost[N][1]==0)
		return cost[N][0];
*/	return min(cost[N][0],cost[N][1]);
}

int main()
{
	int N,R;
	int i,j;
	scanf("%d%d",&N,&R);
	for(i=1;i<=N;i++)
	{
		scanf("%d",H+i);
	}
	for(i=1;i<=N;i++)
	{
		scanf("%d",C+i);
	}
	int u,v;
	for(i=0;i<R;i++)
	{
		scanf("%d%d",&u,&v);
		G[u].pb(v);
		G[v].pb(u);
		continue;
/*		if(H[u]==H[v])
		{
			G[u].pb(p(v,0));
			G[v].pb(p(u,0));
		}
		else
		{
			G[u].pb(p(v,C[u]));
			G[v].pb(p(v,C[v]));
		}
*/	}
	long long ans = dijkstra(N);
//	if(ans == 0)
//		ans = -1;
	printf("%lld\n",ans);
	return 0;
}