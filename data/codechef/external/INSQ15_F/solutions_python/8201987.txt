#include <vector>
#include <queue>
#include <set>
#include <climits>
#include <iostream>
using namespace std;

typedef pair<int, int> pii;
typedef pair<long long, int> pli;
typedef vector<pii> Graph;
const int maxn = 100100;
int h[maxn], c[maxn];
Graph g[2 * maxn + 2];
vector<long long> prio;

long long dijkstra(int s, int size) {
    int n = size;
    prio.assign(n, LLONG_MAX);
    prio[s] = 0;
    priority_queue<pli, vector<pli> , greater<pli> > q;
    q.push(make_pair(prio[s], s));

    while (!q.empty()) {
        long long d = q.top().first;
        int u = q.top().second;
        q.pop();
        if (d != prio[u])
            continue;
        for (int i = 0; i < g[u].size(); i++) {
            int v = g[u][i].first;
            long long nprio = prio[u] + g[u][i].second;
            if (prio[v] > nprio) {
                prio[v] = nprio;
                q.push(make_pair(nprio, v));
            }
        }
    }
    return prio[size - 1] == LLONG_MAX ? -1 : prio[size - 1];
}

int main() {
    ios::sync_with_stdio(false);
        
    	   int n, m, x, y;
    	   cin >> n >> m;
    	   for (int i = 1; i <= n; i++) cin >> h[i];
    	   for (int i = 1; i <= n; i++) cin >> c[i];
    	   
    	   g[0].push_back(make_pair(1, c[1]));
    	   g[0].push_back(make_pair(n + 1, c[1]));
    	   
    	   
    	   for (int i = 1; i <= n; i++) {
    	   	    g[i].push_back(make_pair(n + i, c[i]));
    	            g[n + i].push_back(make_pair(i, c[i]));
    	   }
    	   
    	   g[n].push_back(make_pair(2 * n + 1, 0));
    	   g[2 * n].push_back(make_pair(2 * n + 1, 0));
    	   
    	   for (int i = 0; i < m; i++) {
    	   	    cin >> x >> y;
    	   	    for (int j = 0; j < 2; j++) {
    	   	    	 if (h[x] <= h[y]) g[x].push_back(make_pair(y,0));
    	   	         if (h[x] >= h[y]) g[n + x].push_back(make_pair(n + y, 0));
    	   	         int temp = x;
    	   	         x = y;
    	   	         y = temp;
    	   	    }
    	   }
    	   
    	   cout << dijkstra(0, 2 * n + 2) << endl;
    	   
    return 0;
}