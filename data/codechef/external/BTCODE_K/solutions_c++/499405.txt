#include <iostream>
#include <iosfwd>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cctype>
#include <vector>
#include <bitset>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <deque>
#include <string>
#include <list>
#include <iterator>
#include <sstream>
#include <complex>
#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>

using namespace std;

#define BUG(x) if (DEBUG) cout << __LINE__ << ": " << #x << " = " << x << endl
#define LET(x, a) __typeof(a) x = a
#define FOREACH(it, v) for(LET(it, (v).begin()); it != (v).end(); ++it)

typedef long long LL;

template <class T> inline int size(const T& c) {return (int) c.size();}
int rInt() {int nT = -1; scanf("%d", &nT); return nT;}
string rStr() {char nStr[1 << 20] = ""; scanf("%s", nStr); return nStr;}
LL rLL() {LL nT = -1; scanf("%lld", &nT); return nT;}
inline LL two(int x) {return (1LL << (x));}
template <class T> ostream& operator << (ostream& o, const vector <T>& v)
{o << "{"; FOREACH(it, v) o << *it << ","; return o << "}";}
template <class A, class B> ostream& operator << (ostream& o, const pair <A, B>& p)
{o << "("; o << p.first << "," << p.second << ")"; return o;}

const bool DEBUG = true;
const double EPS = 1e-8;
const int INF  = 1000000000;
const LL INFLL = 1000000000000000000LL;

struct Node
{
	int leftMost, rightMost;
	bool inc, dec;
	int value, sign;
};

bool operator == (const Node& x, const Node& y) {
	return x.leftMost == y.leftMost && x.rightMost == y.rightMost;
}

Node invalid;

struct SegmentTree
{
	vector <Node> tree;
	int N;
	SegmentTree(int N, vector <int>& x) {
		this -> N = N;
		N = (N << 1);
		if ((N & (N - 1)) != 0)
			N = 1 << (1 + (int)log2(N));
		tree.resize(N);
		recurse(1, 0, this -> N - 1, x);
	}
	void updateNode(int node) {
		int left = 2 * node, right = 2 * node + 1;
		tree[node].value = 0;
		tree[node].sign = 1;
		tree[node].leftMost = tree[left].leftMost;
		tree[node].rightMost = tree[right].rightMost;
		tree[node].inc = (tree[left].inc && tree[right].inc && tree[left].rightMost <= tree[right].leftMost);
		tree[node].dec = (tree[left].dec && tree[right].dec && tree[left].rightMost >= tree[right].leftMost);
	}
	void recurse(int node, int b, int e, vector <int>& x) {
		if (b == e) {
			tree[node].leftMost = tree[node].rightMost = x[b];
			tree[node].inc = tree[node].dec = true;
			tree[node].value = 0;
			tree[node].sign = 1;
		}
		else {
			int mid = (b + e) >> 1;
			recurse(2 * node, b, mid, x);
			recurse(2 * node + 1, mid + 1, e, x);
			updateNode(node);
		}
	}
	void update(int node, int b, int e, int low, int high, int v, int add = 0, int sign = 1) {
		if (sign < 0)
			swap(tree[node].inc, tree[node].dec);
		tree[node].value = tree[node].value * sign + add;
		tree[node].sign *= sign;
		tree[node].leftMost = tree[node].leftMost * sign + add;
		tree[node].rightMost = tree[node].rightMost * sign + add;
		if (b > high || e < low) 
			return;
		else if (b >= low && e <= high) {
			tree[node].value = v - tree[node].value;
			tree[node].sign = -tree[node].sign;
			swap(tree[node].inc, tree[node].dec);
			tree[node].leftMost = v - tree[node].leftMost;
			tree[node].rightMost = v - tree[node].rightMost;	
		}
		else {
			int mid = (b + e) >> 1;
			update(2 * node, b, mid, low, high, v, tree[node].value, tree[node].sign);
			update(2 * node + 1, mid + 1, e, low, high, v, tree[node].value, tree[node].sign);
			updateNode(node);
		}
	}
	Node query(int node, int b, int e, int low, int high, int add = 0, int sign = 1) {
		if (sign < 0)
			swap(tree[node].inc, tree[node].dec);
		tree[node].value = tree[node].value * sign + add;
		tree[node].sign *= sign;
		tree[node].leftMost = tree[node].leftMost * sign + add;
		tree[node].rightMost = tree[node].rightMost * sign + add;
		if (b > high || e < low)
			return invalid;
		else if (b >= low && e <= high)
			return tree[node];
		else {
			int mid = (b + e) >> 1;
			Node left = query(2 * node, b, mid, low, high, tree[node].value, tree[node].sign);
			Node right = query(2 * node + 1, mid + 1, e, low, high, tree[node].value, tree[node].sign);
			updateNode(node);
			if (left == invalid) return right;
			else if (right == invalid) return left;
			else {
				Node result;
				result.inc = (left.inc && right.inc && left.rightMost <= right.leftMost);
				result.dec = (left.dec && right.dec && left.rightMost >= right.leftMost);
				result.leftMost = left.leftMost;
				result.rightMost = right.rightMost;
				result.value = 0;
				result.sign = 1;
				return result;
			}
		}
	}
};

int main()
{
	const bool contest = false;
	if (contest == true) {
		freopen("input.txt", "r", stdin);
		freopen("output.txt", "w", stdout);
	}
	invalid.leftMost = invalid.rightMost = INF;
	int nTest = 1;
	for (int test = 1; test <= nTest; ++test) {
		int N = rInt(), Q = rInt();
		vector <int> x;
		for (int i = 0; i < N; ++i)
			x.push_back(rInt());
		SegmentTree tree(N, x);
		for (int i = 0; i < Q; ++i) {
			int v = rInt(), low = rInt(), high = rInt();
			if (v != 0) tree.update(1, 0, N - 1, low, high, v, 0, 1);
			else {
				Node result = tree.query(1, 0, N - 1, low, high);
				int answer;
				if (result.inc && result.dec) answer = 3;
				else if (result.dec) answer = 2;
				else if (result.inc) answer = 1;
				else answer = 0;
				printf("%d\n", answer);
			}
		}
	}
	return 0;
}

// Powered by PhoenixAI
