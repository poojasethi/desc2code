#include<stdio.h>
//Segment tree with lazy propagation
int a[100005];
int v[1000006],sign[1000006],left[1000006],right[1000006],iflag[1000006],dflag[1000006];




void init(int node,int b,int e)
{
	if(b==e)
	{	v[node]=0;
		sign[node]=1;
		left[node]=a[b];
		right[node]=a[b];
		iflag[node]=1;
		dflag[node]=1;
		return;
	}
	
	init(2*node,b,(b+e)/2);
	init(2*node +1 ,(b+e)/2+1,e);
	
	v[node]=0;
	sign[node]=1;
	left[node]=left[2*node];
	right[node]=right[2*node+1];
	iflag[node]=(iflag[2*node] && iflag[2*node+1] && right[2*node]<=left[2*node +1]);
	dflag[node]=(dflag[2*node] && dflag[2*node+1] && right[2*node]>=left[2*node +1]);
}
	
void update(int node,int b ,int e,int i,int j ,int vaa,int va,int si)	
{
	if(si==-1)
	{
	int temp;
	temp=iflag[node];
	iflag[node]=dflag[node];
	dflag[node]=temp;
	}
	
	v[node]=v[node]*si + va;
	sign[node]=sign[node]*si;
	left[node]=va+ si*left[node];
	right[node]=va+ si*right[node];
	  	
	if(i>e || j<b )
	  return ;
	
	  
	if(b>=i && e<=j)
	  {
	  	v[node]=vaa-v[node];
	  	sign[node]=-1*sign[node];
	  	
		  
		int temp;
		temp=iflag[node];
	  	iflag[node]=dflag[node];
	  	dflag[node]=temp;
	  	
	  	left[node]= vaa-left[node];
	  	right[node]= vaa-right[node];
	  	return ;
	 }
	 
	update(2*node,b,(b+e)/2,i,j,vaa,v[node],sign[node]);
	update(2*node+1,(b+e)/2 +1,e,i,j,vaa,v[node],sign[node]);
	v[node]=0;
	sign[node]=1;
	left[node]=left[2*node];
	right[node]=right[2*node+1];
	iflag[node]=(iflag[2*node] && iflag[2*node+1] && right[2*node]<=left[2*node +1]);
	dflag[node]=(dflag[2*node] && dflag[2*node+1] && right[2*node]>=left[2*node +1]);
	 
	  	
	
}
struct N
{ int v;
  int sign;
  int left;
  int right;
  int iflag;
  int dflag;
  int flag;
};
	
struct N query(int node,int b,int e,int i,int j,int va,int si)
{ 
	if(si==-1)
	{
	int temp;
	temp=iflag[node];
	iflag[node]=dflag[node];
	dflag[node]=temp;
	}
	
	v[node]=v[node]*si + va;
	sign[node]=sign[node]*si;
	left[node]=va+ si*left[node];
	right[node]=va+ si*right[node];
	  	
	if(i>e || j<b )
	  { struct N C;
	    C.flag=1;
	    return C;
	 }
	
	  
	if(b>=i && e<=j)
	  { struct N C;
	  	C.v=v[node];
	  	C.sign=sign[node];
	  	
		C.flag=0;  
		C.iflag=iflag[node];
	  	C.dflag=dflag[node];
	  	
	  	C.left=left[node];
	  	C.right=right[node];
	  	return C;
	 }
	 
	struct N X,Y,Z;
	X=query(2*node,b,(b+e)/2,i,j,v[node],sign[node]);
	Y=query(2*node+1,(b+e)/2 +1,e,i,j,v[node],sign[node]);
	v[node]=0;
	sign[node]=1;
	left[node]=left[2*node];
	right[node]=right[2*node+1];
	iflag[node]=(iflag[2*node] && iflag[2*node+1] && right[2*node]<=left[2*node +1]);
	dflag[node]=(dflag[2*node] && dflag[2*node+1] && right[2*node]>=left[2*node +1]);
	if(X.flag==1) return Y;
	else if(Y.flag==1) return X;
	 
	Z.iflag = (X.iflag && Y.iflag && X.right <= Y.left);
				Z.dflag = (X.dflag && Y.dflag && X.right >= Y.left);
				Z.left = X.left;
				Z.right = Y.right;
				Z.v = 0;
				Z.flag=0;
				Z.sign = 1;
				return Z; 
	
}

int main()
{
	
int n,q,i,va,aa,bb;
scanf("%d %d",&n,&q);

for(i=0;i<n;i++)
	scanf("%d",&a[i]);

init(1,0,n-1);

while(q--)
{
	scanf("%d %d %d",&va,&aa,&bb);
	if(va!=0)
		update(1,0,n-1,aa,bb,va,0,1);
	else
		{ 
		struct N u=query(1,0,n-1,aa,bb,va,1);
		  if(u.dflag==1 && u.iflag==1) 
		    printf("3\n");
		  else if(u.dflag==1)
		    printf("2\n");
		  else if(u.iflag==1)
		    printf("1\n");
		 else
		    printf("0\n");
		    
		}

}
return 0;
}
	
	