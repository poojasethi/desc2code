#include<bits/stdc++.h>
#define pb(x) push_back(x)
#define all(x) x.begin(), x.end()
#define cout2(x, y) cout << x << " " << y <<  endl


using namespace std;


#define MOD 1000000007
#define SIZE 6

struct Matrix
{
    long long X[SIZE][SIZE];

    Matrix () {}
    Matrix (int k)
    {
        memset(X, 0, sizeof(X));

        for(int i=0; i<SIZE; i++)
            X[i][i] = k;
    }
};

Matrix operator *(Matrix &A, Matrix &B)
{
    Matrix M;

    for(int i=0; i<SIZE; i++)
    {
        for(int j=0; j<SIZE; j++)
        {
            long long tmp = 0;
            for(int k=0; k<SIZE; k++)
			{
                tmp += (A.X[i][k] * B.X[k][j])%MOD;
                tmp %= MOD;
            }

            M.X[i][j] = tmp;
        }
    }

    return M;
}

Matrix pow(Matrix x, long long n)
{
    Matrix P(1);

    while(n)
    {
        if(n & 1)
            P = P * x;

        n >>= 1;
        x = x * x;
    }

    return P;
}


long long F[7];

int main(){

	int tc = 0;
	scanf("%d", &tc);

	while(tc--)
    {

		int n;
		scanf("%d", &n);

		Matrix M;
		memset(M.X, 0, sizeof M.X);

		for(int i = 0; i < 5; i++)
		{
            scanf("%lld", &M.X[0][i]);
            M.X[0][i] = (M.X[0][i]%MOD + MOD)%MOD;
		}
		for(int i = 0; i < 4; i++)
		{
		    scanf("%lld", &F[i]);
		    F[i] = (F[i]%MOD + MOD)%MOD;
		}
		F[4]=1;

		swap(F[4], M.X[0][4]);
		reverse(F, F + 4);

		for(int i = 1; i < 4; i++)
            M.X[i][i - 1] = 1;
		M.X[4][4] = 1;

		M = pow(M, n - 4);

		long long ans = 0;
		for(int i = 0; i < 5; i++)
            ans = (ans + M.X[0][i] * F[i])%MOD;

		printf("%lld\n", ans);

	}

}

