#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <fstream>
#include <iostream>
#include <iterator>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#define MAXIND 700200
#define MAXN 200200
using namespace std;

#define gc getchar_unlocked
inline void fps(int &x)
{
    register int c = gc();
    x = 0;
    //int neg = 0;
    for(;((c<48 || c>57) /*&& c != '-'*/);c = gc());
    //if(c=='-') {neg=1;c=gc();}
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
    //if(neg) x=-x;
}

//Fast IO
 
char *ipos, ifile[ 10000000 ];
inline int nl( int flag = 0 )
{
	while( *ipos <= 32 ) ++ipos;
	if( flag  ) return( *ipos++ - '0' );
	int x = 0, neg = 0;
	char c;
	while( true )
	{
		c = *ipos++;
		if( c == '-' ) neg = 1;
		else
		{
			if( c <= 32 ) return neg ? -x : x;
			x = ( x << 1 ) + ( x << 3 ) + c - '0';
		}
	}
}
 
inline void initFastIO(){
	ipos = ifile;
	fread_unlocked( ifile, 10000000, 1, stdin );
}
 
//end Of Fast IO
void initialize(int node, int b, int e, int M[MAXIND], int A[MAXN], int N);
int query(int node, int b, int e, int M[MAXIND], int A[MAXN], int i, int j);

int main()
{
    int n,a[MAXN],m[MAXIND],i,x,y,t,c,d,l;
    //cout << "Enter the no of numbers\n";
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    initFastIO();
    n = nl();
    for(i=0;i<n;i++)
       a[i] = nl();
    t = nl();
    initialize(1,0,n-1,m,a,n);
    while(t--)
    {
    //cout << "Enter the Query";
    x = nl();
    y = nl();
    x--;
    y--;
    
    c =  query(1,0,n-1,m,a,0,x-1);
    d =  query(1,0,n-1,m,a,y+1,n-1);
    //cout << c << " " << d << endl;
    if(c != -1 && d != -1)
         printf("%d\n",max(a[c],a[d]));
    else if(c == -1 && d!= -1)
          printf("%d\n",a[d]);
    else if(d == -1 && c!=-1)
          printf("%d\n",a[c]);
    else
          printf("0\n");
    }
    return 0;
}

void initialize(int node, int b, int e, int M[MAXIND], int A[MAXN], int N)
{
      if (b == e)
          M[node] = b;
      else
       {
  //compute the values in the left and right subtrees
          initialize(2 * node, b, (b + e) / 2, M, A, N);
          initialize(2 * node + 1, (b + e) / 2 + 1, e, M, A, N);
  //search for the minimum value in the first and 
  //second half of the interval
          if (A[M[2 * node]] >= A[M[2 * node + 1]])
              M[node] = M[2 * node];
          else
              M[node] = M[2 * node + 1]; 
      }
}
  
int query(int node, int b, int e, int M[MAXIND], int A[MAXN], int i, int j)
  {
      int p1, p2;

   
  //if the current interval doesn't intersect 
  //the query interval return -1
      if (i > e || j < b)
          return -1;
   
  //if the current interval is included in 
  //the query interval return M[node]
      if (b >= i && e <= j)
          return M[node];
   
  //compute the minimum position in the 
  //left and right part of the interval
      p1 = query(2 * node, b, (b + e) / 2, M, A, i, j);
      p2 = query(2 * node + 1, (b + e) / 2 + 1, e, M, A, i, j);
   
  //return the position where the overall 
  //minimum is
      if (p1 == -1)
          return  p2;
      if (p2 == -1)
          return  p1;
      if (A[p1] >= A[p2])
          return  p1;
      return  p2;

  }
