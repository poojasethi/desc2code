#include<iostream>
#include<algorithm>
#define MAXIND 700200
#define MAXN 200200
using namespace std;

#define gc getchar_unlocked
inline void fps(int &x)
{
    register int c = gc();
    x = 0;
    //int neg = 0;
    for(;((c<48 || c>57) /*&& c != '-'*/);c = gc());
    //if(c=='-') {neg=1;c=gc();}
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
    //if(neg) x=-x;
}

void initialize(int node, int b, int e, int M[MAXIND], int A[MAXN], int N);
int query(int node, int b, int e, int M[MAXIND], int A[MAXN], int i, int j);

int main()
{
    int n,a[MAXN],m[MAXIND],i,x,y,t,c,d,l;
    //cout << "Enter the no of numbers\n";
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    fps(n);
    for(i=0;i<n;i++)
       fps(a[i]);
    fps(t);
    initialize(1,0,n-1,m,a,n);
    while(t--)
    {
    //cout << "Enter the Query";
    fps(x);fps(y);
    x--;
    y--;
    
    c =  query(1,0,n-1,m,a,0,x-1);
    d =  query(1,0,n-1,m,a,y+1,n-1);
    //cout << c << " " << d << endl;
    if(c != -1 && d != -1)
         printf("%d\n",max(a[c],a[d]));
    else if(c == -1 && d!= -1)
          printf("%d\n",a[d]);
    else if(d == -1 && c!=-1)
          printf("%d\n",a[c]);
    else
          printf("0\n");
    }
    return 0;
}

void initialize(int node, int b, int e, int M[MAXIND], int A[MAXN], int N)
{
      if (b == e)
          M[node] = b;
      else
       {
  //compute the values in the left and right subtrees
          initialize(2 * node, b, (b + e) / 2, M, A, N);
          initialize(2 * node + 1, (b + e) / 2 + 1, e, M, A, N);
  //search for the minimum value in the first and 
  //second half of the interval
          if (A[M[2 * node]] >= A[M[2 * node + 1]])
              M[node] = M[2 * node];
          else
              M[node] = M[2 * node + 1]; 
      }
}
  
int query(int node, int b, int e, int M[MAXIND], int A[MAXN], int i, int j)
  {
      int p1, p2;

   
  //if the current interval doesn't intersect 
  //the query interval return -1
      if (i > e || j < b)
          return -1;
   
  //if the current interval is included in 
  //the query interval return M[node]
      if (b >= i && e <= j)
          return M[node];
   
  //compute the minimum position in the 
  //left and right part of the interval
      p1 = query(2 * node, b, (b + e) / 2, M, A, i, j);
      p2 = query(2 * node + 1, (b + e) / 2 + 1, e, M, A, i, j);
   
  //return the position where the overall 
  //minimum is
      if (p1 == -1)
          return  p2;
      if (p2 == -1)
          return  p1;
      if (A[p1] >= A[p2])
          return  p1;
      return  p2;

  }
