#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define end endddddd
#define find findddddd
#define begin beginnnnn

const int MAXN = 100100;

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<pii, int> tii;

#define clear(arr) do {for (int i = 0; i < MAXN; i++) {__typeof(arr[0]) v; arr[i].swap(v);}} while(0)

struct BIT {
ll bit[MAXN];
void reset() {
	memset(bit, 0, sizeof(bit));
}
void update(int i, ll v) {
	i += 5;
	while (i < 100100) {
		bit[i] += v;
		i += (i & -i);
	}
}
ll read(int i) {
	i += 5;
	ll res = 0;
	while (i) {
		res += bit[i];
		i -= (i & -i);
	}
	return res;
}
};

int par[MAXN];
void reset() {
	for (int i = 0; i < MAXN; i++) {
		par[i] = i;
	}
}
int find(int a) {
	return par[a] == a ? a : par[a] = find(par[a]);
}
bool merge(int a, int b) {
	a = find(a);
	b = find(b);
	if (a == b) return false;
	par[a] = b;
	return true;
}

int n, m;
vector<int> adj[MAXN];
vector<pii> query[MAXN];  // query[a] has (b, weight)

int ancestor[MAXN];
vector<tii> lca[MAXN];  // (a, b, weight)

int start[MAXN];
int end[MAXN];
int z;

void tarjanlca(int a, int p) {
	start[a] = z++;
	ancestor[a] = a;
	for (int i = 0; i < adj[a].size(); i++) {
		int b = adj[a][i];
		if (b == p) continue;
		// cout << a << ' ' << b << endl;
		tarjanlca(b, a);
		merge(a, b);
		ancestor[find(a)] = a;
	}
	end[a] = z;
	for (int i = 0; i < query[a].size(); i++) {
		int b = query[a][i].first;
		// cout << a <<  ' ' << b << ' ' << end[b] << endl;
		if (end[b] > 0) {
			int c = ancestor[find(b)];
			int w = query[a][i].second;
			lca[c].push_back(tii(pii(a, b), w));
			// cout << a << ' ' << b << ' ' << c << ' ' << w << endl;
		}
	}
}

ll dp[MAXN][2];  // with, without
BIT dpsums;  // sum to root of dp[i][0] values
BIT negsums;  // sum to root of dp[i][1] values, which should be subtracted

void dfs(int a, int p) {
	dp[a][0] = 0;
	for (int i = 0; i < adj[a].size(); i++) {
		int b = adj[a][i];
		if (b == p) continue;
		dfs(b, a);
		dp[a][0] += dp[b][1];
	}
	dpsums.update(start[a], dp[a][0]);
	dpsums.update(end[a], -dp[a][0]);

	ll best = dp[a][0];
	for (int i = 0; i < lca[a].size(); i++) {
		pair<pii, int> cur = lca[a][i];
		// cout << a << ' ' << cur.first.first << ' ' << cur.first.second << ' ' << cur.second << endl;
		ll res = cur.second;
		// cout << " + " << cur.second << endl;
		ll rootp = dpsums.read(start[p]) + dpsums.read(start[a]);
		ll leafp = dpsums.read(start[cur.first.first]) + dpsums.read(start[cur.first.second]);
		res += leafp - rootp;
		// cout << leafp << ' ' << rootp << endl;
		// cout << " + " << leafp - rootp << endl;
		ll rootn = negsums.read(start[a]) * 2;
		ll leafn = negsums.read(start[cur.first.first]) + negsums.read(start[cur.first.second]);
		res -= leafn - rootn;
		// cout << leafn << ' ' << rootn << endl;
		// cout << " - " << leafn - rootn << endl;
		best = max(best, res);
	}
	dp[a][1] = max(best, dp[a][0]);
	negsums.update(start[a], dp[a][1]);
	negsums.update(end[a], -dp[a][1]);

	// cout << "dp " << a << ' ' << 0 << ' ' << dp[a][0] << endl;
	// cout << "dp " << a << ' ' << 1 << ' ' << dp[a][1] << endl;
}

int main() {
	int cases;
	scanf("%d", &cases);
	for (int ci = 1; ci <= cases; ci++) {
		reset();
		memset(end, 0, sizeof(end));
		clear(adj);
		clear(query);
		clear(lca);
		dpsums.reset();
		negsums.reset();
		z = 1;

		scanf("%d", &n);
		for (int i = 0; i < n - 1; i++) {
			int a, b;
			scanf("%d%d", &a, &b);
			a--; b--;
			adj[a].push_back(b);
			adj[b].push_back(a);
		}
		scanf("%d", &m);
		for (int i = 0; i < m; i++) {
			int a, b, c;
			scanf("%d%d%d", &a, &b, &c);
			a--; b--;
			query[a].push_back(make_pair(b, c));
			query[b].push_back(make_pair(a, c));
		}
		tarjanlca(0, MAXN-1);
		dfs(0, MAXN-1);  // dummy at start = 0
		printf("Case %d: %lld\n", ci, dp[0][1]);
	}
}