#include <bits/stdc++.h>

using namespace std;
#define INF 1010000000
#define EPS 1E-12
#define MP make_pair
#define MT make_tuple
#define ST first
#define ND second
#define REP(i, n) for(int i = 0; i < (n); ++i)
#define REPD(i, n) for(int i = (n) - 1; i >= 0; --i)
#define FOR(i, a, n) for(int i = (a); i <= (n); ++i)
#define FORD(i, a, n) for(int i = (a); i >= (n); --i)
#define DD(x, args...) { vector<string> _v = _split(#args, ','); _err(x, _v.begin(), args); }
#define D(args...) DD(", ", args)
#define DE(args...) DD("\n", args)
#define D2(a, args...) { cerr << a << ": "; D(args); }
#define DD2(x, a, args...) { cerr << a << ": "; DD(x, args); }
#define E cerr << endl;
#define OUT(...) ostream& operator<<(ostream& ost, const __VA_ARGS__& _cnt) { return _out(ost, ALL(_cnt)); }
#define SZ(x) ((int)(x).size())
#define PB push_back
#define EB emplace_back
#define ALL(x) x.begin(), x.end()
#define endl '\n'

typedef long long LL;
typedef pair<int, int> PII;
typedef pair<LL, LL> PLL;
typedef pair<double, double> PDD;

template<class c1> ostream &_out(ostream &ost, c1 a, c1 b);

template<class... Types> ostream& operator<<(ostream& out, const tuple<Types...>& value);
template<class T1, class T2> ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt);

template<class T1> OUT(vector<T1>);
template<class T1> OUT(deque<T1>);
template<class T1> OUT(list<T1>);
template<class T1, class T2> OUT(set<T1, T2>);
template<class T1, class T2> OUT(multiset<T1, T2>);
template<class T1, class T2, class T3> OUT(map<T1, T2, T3>);
template<class T1, class T2, class T3> OUT(multimap<T1, T2, T3>);

template<class T1, class T2> 
ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt)
	{ return ost << '(' << _cnt.ST << ", " << _cnt.ND << ')'; }

template<class T1>
ostream& _out(ostream& ost, T1 a, T1 b)
	{ ost << '{'; if(a != b) { ost << *a; while(++a != b) ost << ", " << *a; } return ost << '}'; }

template<class Type, unsigned N, unsigned Last>
struct tuple_printer {
	static void print(ostream& out, const Type& value) 
	{ out << get<N>(value) << ", "; tuple_printer<Type, N + 1, Last>::print(out, value); }
};
template<class Type, unsigned N>
struct tuple_printer<Type, N, N> {
	static void print(ostream& out, const Type& value) 
		{ out << get<N>(value); }
};
template<class... Types>
ostream& operator<<(ostream& out, const tuple<Types...>& value) 
	{ out << '('; tuple_printer<tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value); out << ')'; return out; }

vector<string> _split(const string& s, char c) {
	int br = 0;
	vector<string> v(1);
	REP(i, SZ(s)) {
		if(s[i] == '[' || s[i] == '(' || s[i] == '{'/* || s[i] == '<'*/) br++;
		else if(s[i] == ']' || s[i] == ')' || s[i] == '}'/* || s[i] == '>'*/) br--;
		if(s[i] == c && br == 0) v.PB("");
		else v.back().PB(s[i]);
  }
  return v;
}

template<class T1>
void _err(string del, vector<string>::iterator it, T1 a) { 
	bool wb = (*it)[0] == ' ', we = (*it).back() == ' ';
	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << endl; 
	(void)del;
}
template<class T1, class... Args>
void _err(string del, vector<string>::iterator it, T1 a, Args... args) { 
	bool wb = (*it)[0] == ' ', we = (*it).back() == ' ';
	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << del; 
	_err(del, ++it, args...); 
}

template<class T> 
T maxx(const T& a) 
	{ return a; }
template<class T, class... Args> 
T maxx(const T& a, Args... args) 
	{ return max(a, maxx(args...)); }
template<class T> 
T minn(const T& a) 
	{ return a; }
template<class T, class... Args> 
T minn(const T& a, Args... args) 
	{ return min(a, minn(args...)); }

/////////////////////////////////////////////////////////////////////

vector<vector<int> > v;
vector<vector<tuple<int, int, int> > > seg;
int power;
vector<vector<int> > jump;
vector<int> dep;
vector<PII> inter;
vector<int> T;
int N;

int prep(int a, int pp, int cur = 0) {
	jump[a][0] = pp;
	FOR(i, 1, power)
		jump[a][i] = jump[jump[a][i - 1]][i - 1];
	
	inter[a].ST = cur;
	for(auto& i : v[a]) {
		if(i == pp)
			continue;
		dep[i] = dep[a] + 1;
		cur = prep(i, a, cur + 1);
	}
	inter[a].ND = cur;
	
	return cur;
}

int LCA(int a, int b) {
	if(dep[a] < dep[b])
		swap(a, b);
	
	int sub = dep[a] - dep[b];
	int len = 0;
	while(sub > 0) {
		if(sub % 2 == 1)
			a = jump[a][len];
		len++;
		sub /= 2;
	}
	
	if(a != b) {
		len = power;
		while(len >= 0) {
			if(jump[a][len] != jump[b][len]) {
				a = jump[a][len];
				b = jump[b][len];
			}
			len--;
		}
		a = b = jump[a][0];
	}
	
	return a;
}

int get(int a) {
	int res = 0;
	a += N;
	while(a != 0) {
		res += T[a];
		a /= 2;
	}
	return res;
}

void add(int a, int b, int val) {
	a += N;
	b += N;
	
	T[a] += val;
	if(a != b)
		T[b] += val;
	while(a + 1 < b) {
		if(a % 2 == 0)
			T[a + 1] += val;
		if(b % 2 == 1)
			T[b - 1] += val;
		a /= 2;
		b /= 2;
	}
}

int solve(int a, int pp = -1) {
	int res = 0;
	for(auto& i : v[a]) {
		if(i == pp)
			continue;
		res += solve(i, a);
	}
	int tres = res;
	
	for(auto& i : seg[a]) {
		int bg, en, cost;
		tie(bg, en, cost) = i;
		res = max(res, cost + get(inter[bg].ST) + get(inter[en].ST) + tres);
	}
	
	add(inter[a].ST, inter[a].ND, tres - res);
	
	return res;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int ts;
	cin >> ts;
	
	FOR(zz, 1, ts) {
		int n;
		cin >> n;
		power = sizeof(n) * 8 - __builtin_clz(n - 1);
		v.clear(); 			v.resize(n + 1);
		seg.clear(); 		seg.resize(n + 1);
		jump.clear(); 		jump.resize(n + 1, vector<int>(power + 1));
		dep.clear(); 		dep.resize(n + 1);
		inter.clear(); 	inter.resize(n + 1);
		T.clear();			T.resize(1 << (power + 1));
		N = 1 << power;
		
		REP(i, n - 1) {
			int a, b;
			cin >> a >> b;
			v[a].EB(b);
			v[b].EB(a);
		}
		
		prep(1, 1);
		
		int q;
		cin >> q;
		
		REP(i, q) {
			int a, b, c;
			cin >> a >> b >> c;
			seg[LCA(a, b)].EB(a, b, c);
		}
		
		cout << "Case " << zz << ": " << solve(1) << endl;
	}
	
	return 0;
}
/*
2
7
1 2
1 3
2 4
2 5
3 6
3 7
3
4 7 10
2 5 6
6 7 5
9
1 5 
1 2 
1 3 
2 7 
3 4 
3 8 
8 9 
8 6
5
5 1 4
7 3 8
3 4 3
1 8 11
6 9 4
*/ 