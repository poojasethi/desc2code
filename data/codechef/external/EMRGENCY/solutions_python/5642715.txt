#include<iostream>
#include<vector>
#include<list>
#include<algorithm>
#include<cstdio>
using namespace std;

vector < vector<int> > graph;
vector <int> cost ;
list<int> q;

bool visited[100005];




void bfs(int v,int &cost1)
{


              //queue is made of list since the removing of firdtelement is done in constant time
    vector<int> ::iterator i;
    q.push_back(v);
     visited[v]=true;
     cost1=min(cost1,cost[v]);
     //leader[l].push_back(v);


    while(!q.empty())
    {
        int v1=q.front();
        q.pop_front();

        for(i=graph[v1].begin();i!=graph[v1].end();i++)
        {
            if(visited[*i]==false)
            {
                cost1=min(cost1,cost[*i]);
                q.push_back(*i);
                visited[*i]=true;


            }

        }

    }

    q.clear();


}



void bfsloop(int n)
{


   int i;
   for(int h=1;h<=n;h++)
    visited[h]=false;


   int cost=0;
   for(i=1;i<=n;i++)
   {
       int cost1=1000005;
       if(visited[i]==false)
       {
        bfs(i,cost1);
        cost+=cost1;
       }
   }

   printf("%d",cost);



}


int main()
{

int t,n,m,temp,a,b;
 scanf("%d",&t);
 while(t--)
 {

    scanf("%d%d",&n,&m);
    cost.push_back(0);
     graph.resize(n+4);
     for(int i=1;i<=n;i++)
     {
        scanf("%d",&temp);
        cost.push_back(temp);
     }
     while(m--)
     {

         scanf("%d%d",&a,&b);
         if(a!=b){
         graph[a].push_back(b);

         graph[b].push_back(a);}
     }


     bfsloop(n);
     printf("\n");

     for(int i=0;i<=n;i++)
        graph[i].clear();

     graph.clear();

     cost.clear();

 }
return 0;
}
