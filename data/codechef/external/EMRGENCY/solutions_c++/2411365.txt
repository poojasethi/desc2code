// Libraries 

#include <list>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>

// Definitions 

#define pb push_back
#define max(i,j) (i>j?i:j)
#define min(i,j) (i<j?i:j)
#define mod 1000000007
#define sf scanf
#define pf printf
#define LL long long int
#define FOR(i,a,b) for(LL i=(LL)(a);i<(LL)(b);i++)
#define REV(i,a,b) for(LL i=(LL)(a);i>=(LL)(b);i--)

using namespace std;

// Global Declarations
list<LL> *adj;
list<LL> *comp;
bool *visited;
LL cost[100001];
LL component,depth,connected[100001];

void dfs_util(LL v);

void dfs(LL n)
{
	component=0;
	FOR(i,0,n)
	visited[i]=false;
	FOR(i,0,n)
	{
		depth=0;
		if(!visited[i])
		dfs_util(i);
		connected[component]=depth;
		component+=1;
	}
}

void dfs_util(LL v)
{
	comp[component].pb(v);
	visited[v]=true;
	depth++;
	list<LL>::iterator i;
	for(i=adj[v].begin();i!=adj[v].end();i++)
	{
		if(!visited[*i])
		{
			dfs_util(*i);
		}
	}
}

int main()
{
	LL t,n,m;
	sf("%lld",&t);
	while(t--)
	{
		sf("%lld %lld",&n,&m);
		adj=new list<LL>[n];
		comp=new list<LL>[n];
		visited=new bool[n];
		FOR(i,0,n)
		sf("%lld",&cost[i]);
		LL a,b;
		while(m--)
		{
			sf("%lld %lld",&a,&b);
			a--;b--;
			adj[a].pb(b);
			adj[b].pb(a);
		}
		dfs(n);
		LL answer=0;
		LL toi;
		FOR(i,0,component)
		{
			if(connected[i]!=0)
			{
				toi=INT_MAX;
				//pf("For connected component %lld \n",connected[i]);
				list<LL>::iterator j;
				for(j=comp[i].begin();j!=comp[i].end();j++)
				{
					//pf("%lld haha %lld\n",*j+1,cost[*j]);
					if (toi>cost[*j])
					toi=cost[*j];
				}
				//cout<<toi<<endl;
				answer+=toi;
				//cout<<answer<<endl;
			}
		}
		pf("%lld\n",answer);
	}
	return 0;
}
