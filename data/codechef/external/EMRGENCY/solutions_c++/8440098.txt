// author : avinash khare
// algo : finding connected component of graph
// level : so easy that a child coming straight out of women womb can code;
#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>
using namespace std;
typedef vector<int> vi;


#ifndef ONLINE_JUDGE
inline int getchar_unlocked()
{
	return getchar();
}
#endif
inline long long scn()
{
	long long n = 0, c = getchar_unlocked(),t=0;
	while(c < '0' || c > '9')
	{
		if(c==45)t=1;
		c = getchar_unlocked();
	}
	while(c >= '0' && c <= '9')n = (n<<3) + (n<<1) + c - '0', c = getchar_unlocked();
 
	if(t==0)return n;
	else return -n;
}





int main()
{
	
	int t;
	cin>>t;
	while(t--)
	{
       stack<int> s;
vector<vi> graph;
vector<int> cost;
vi mark;

int comp_cost;

		
		int n,m;
	    cin>>n>>m;
	    graph.resize(n+1);
	    cost.resize(n+1);
		mark.resize(n+1,0);
		
		for(int i=1;i<=n;i++)
		{ cost[i]=scn();
		}
	
	for(int i=0;i<m;i++)
	{
		int x=scn(),y=scn();
		//cin>>x>>y;
		graph[x].push_back(y);
	    graph[y].push_back(x);
	}
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		if(!mark[i])
		{
			comp_cost=100000;
			
			
			mark[i]=1;
	s.push(i);
	while(!s.empty())
	{
		int temp=s.top();
		if(cost[temp]<comp_cost)
		comp_cost=cost[temp];
		s.pop();
		for(vi::iterator v=graph[temp].begin();v!=graph[temp].end();v++)
		{
			if(!mark[*v])
			{
				mark[*v]=1;
				s.push(*v);
			}
		}
	}
	
			
			//cout<<comp_cost<<" "<<endl;
			ans+=comp_cost;
		}
		
	}
	
	cout<<ans<<endl;
	}
	
}