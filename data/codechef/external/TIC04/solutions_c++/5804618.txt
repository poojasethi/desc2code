#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

//using the steven skiena template of backtracking

bool noSolution = true ; /* found all solutions yet */
/* check first k elements of vector is complete solution */
int is_a_solution(int a[],int k,int input)
{
  return k==input ;
}

/*prints the elements of a particular subset */
void process_solution(int a[],int k,int input){
    int i,j;
    noSolution = false;
    for(i=1;i<=k;i++){
      for(j=1;j<=k;j++){
       if(a[i]==j)
         printf("Q\t");
       else
         printf("-\t");
      }
      printf("\n");
    }
    printf("\n");
}

void construct_candidates(int a[],int k,int input,int c[],int *ncandidates){
  int i,j;
  bool legalMove=true;
  *ncandidates=0;
  for(i=1;i<=input;i++){
     legalMove=true;
     for(j=1;j<k;j++){
        if(i==a[j]) {//same column
          legalMove=false;
          break;
        }
        if(abs(k-j)==abs(i-a[j])){ //check for diagonal
         legalMove=false;
          break; 
        }
     }
     if(legalMove){
      c[*ncandidates]=i;
      *ncandidates=*ncandidates+1;
     }
  }
   
}


void backtrack(int a[],int k,int input){
  int c[input] ; /* candidates for next position */
  int ncandidates ; /* next candidates count */
  int i ; /* counter */
  if(is_a_solution(a,k,input)){
    process_solution(a,k,input);
  }
  else{
	k++;
	construct_candidates(a,k,input,c,&ncandidates);
	for(i=0;i<ncandidates;i++){
	  a[k]=c[i];
	  backtrack(a,k,input);
	  
	}
  }
}

int main()
{
  int t,x;
  char c[100];
  //cin >> t ;
  while(cin>>x){
    noSolution = true;
    int *a= (int *)malloc(sizeof(int)*(x+1));
    backtrack(a,0,x);
    if(noSolution)
      cout << "Not Possible\n" ;
    free(a);
  }
  return 0;
}
