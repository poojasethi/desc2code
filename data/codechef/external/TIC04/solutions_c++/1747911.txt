
// This program is based on permutations

// Notes
// Clever pruing in backtracking can yield better results.
// Even we can make use of parallel processing in backtracking, one tree branch per core.

#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>
#include <tr1/unordered_set>

using namespace std;
using namespace tr1;

typedef char data_t;
typedef vector<data_t> Tuple;
typedef vector<Tuple> Bag;

void PrintBoard(Tuple v) {
    for(size_t i = 0; i < v.size(); i++) {
        Tuple t(v.size(), '-');
        t[v[i]-'0'] = 'Q'; // not portable
        copy(t.begin(), t.end(), ostream_iterator<data_t>(cout, "\t")), cout << endl;
    }
}

Bag GeneratePermutations(Tuple v) {
    Bag b;
    do {
        b.push_back(v);
    } while( next_permutation(v.begin(), v.end()) );

    return b;
}

void GenerateValidTuples(const Bag &b) {
    for(Bag::const_iterator i = b.begin(); i != b.end(); ++i) {
        Tuple const &t = *i;
        unordered_set<data_t> a, b;

        for(size_t j = 0; j < t.size(); j++)
            a.insert(t[j] + j);
        for(size_t j = 0; j < t.size(); j++)
            b.insert(t[j] - j);

        if( t.size() == a.size() && t.size() == b.size() ) {
            PrintBoard(t);
            cout << endl;
        }
    }
}

int main () {
    int N;

    while( cin >> N ) {

        if( N == 1 ) {
            cout << 'Q' << endl;
            return 0;
        }

        if( N == 2 || N == 3 ) {
            cout << "Not Possible" << endl;
            return 0;
        }

        vector<data_t> v(N);

        for(int i = 0; i < N; i++)
            v[i] = '0' + i;

        GenerateValidTuples(GeneratePermutations(v));
    }

    return 0;
}
