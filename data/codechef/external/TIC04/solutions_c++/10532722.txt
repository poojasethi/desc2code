/*
Na pocetku ucitavam broj n. Ako je n=1 onda na jedinstvenom polju
postavljam damu. Za n=2 i n=3 nije moguce postaviti.
Pozivam funkciju ispitaj za nultu kolonu n puta.
Ona poziva funkciju moguce_postaviti koja ispituje da li
u toj vrsti postoji dama, u tom redu i po dijagonalama.
Ako postoji vraca false i time je i funkcija ispitaj zavrsena (tj ne radi nista).
Ako je moguce postaviti onda bas na tom mestu polje[][] dobija vrednost 1 i
za svaku kolonu rekurzivno pozivam funkciju ispitaj.
Kako u main klasu pozivam funkciju ispitaj n puta a u okviru funkcije ispitaj jos n puta
slozenost je T O(n*n!). 
Sto se tice mem. slozenost koristim dodatki niz polje[8][8] sto znaci da je M O(64).

*/


#include<iostream>
#include<cstdlib>
 

int n;
bool polje[8][8];
 
bool moguce_postaviti(int red, int kolona) {
    int i = red, j = kolona;
    
	for(i=red;i>=0;i--) //proverava da li u vrsti postoji
        if(polje[kolona][i]) return false;
    
    for(i=kolona;i>=0;i--) //proverava da li u koloni postoji
        if(polje[i][red]) return false;
    i = red;
    while(--i >= 0 && --j >= 0) //proverava gornju dijagonalu levo
        if(polje[j][i]) return false;
    i = red;
    j = kolona;
    while(++i < n && --j >= 0) //proverava gornju dijagonalu
        if(polje[j][i]) return false;
    return true;
}

void ispitaj(int x, int y) {
    int i, j;
    if(moguce_postaviti(x,y)) {
        polje[y][x] = 1;
        if(y < n-1)
            for(i = 0; i < n; ++i)
                ispitaj(i, y + 1);
        else
            for(j = 0; j < n; printf(j == n-1 ? "\n\n" : "\n"), ++j)
                for(i = 0; i < n; printf(polje[j][i] ? "Q\t" : "-\t"), ++i);
        polje[y][x] = 0;
    }
}
 
int main() {
    int i;
    scanf("%d", &n);        
            if(n == 1)
                printf("Q\n\n");
            else if(n==2 || n==3)
                printf("Not Possible\n");
        else
            for(i = 0; i < n; ++i)
                ispitaj(i, 0);
   
	system("pause");
} 