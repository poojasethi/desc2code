//union disjoint sets
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007

typedef vector<int> v;
//set<int>s;
//set<int>::iterator it;  
// using both path compression --recursively findset &
//union by rank strategy
// rank stores the upper bound of the height of the tree

class unionset
{
v pset, rank, setsize; 
int numsets ; // number of sets 

public:
unionset(int n)
{   numsets =n; // number of sets
	setsize.assign(n,1); // each set with size 1
	rank.assign(n,0); // assigning rank to 0 for each set in union set
	pset.assign(n,0); // n size initialized with 0 .. pset represents the representative of the set 
    for(int i=0; i<n;i++)
    pset[i]=i;
  //  cc.assign(n,0); // to get no. of elements related to the certain representative 
}
int numdisjointset()
{
	return numsets; 
}
int sizeofset(int i)
{
	return setsize[findset(i)]; //with findset find the representative then find the size of set
}
int findset(int i)      // returns the representative  
{
	return (pset[i]==i)?i:(pset[i]=findset(pset[i])); 
}
bool issameset(int i , int j)
{
	return (findset(i)==findset(j)); 
}

/* rank helps in keepint the tree height short & more balanced 
if rank is lower means it has fewer members so on union make its representative the set with larger rank
*/ 

void unionofset(int i , int j )
{
	if(!issameset(i , j))
	{ 
	numsets--; // making union of two disjoint sets so total sets gets decreased by1 	
	int x = findset(i); 
	int y = findset(j); 
	if(rank[x]>rank[y])
	{
		pset[y] = x; 
		setsize[x] += setsize[y];
	}
	else 
	{
		pset[x] = y; 
		setsize[y]+=setsize[x];
		if(rank[x]==rank[y])
		rank[y]++;
	}
	
	}
}



}; 
int main() {
int t , n ,c, a, b, q, s , d;
long long int ans;
scanf("%d",&t);
while(t--)
{ 
	
	scanf("%d %d",&n, &c); 
	unionset u(n); 
	while(c--)
	{
		scanf("%d %d",&a,&b); 
		u.unionofset(a-1,b-1); 
	}
	scanf("%d",&q); 
	while(q--)
	{
		scanf("%d %d",&s,&d);
		if(u.issameset(s-1,d-1))
		printf("Yes\n"); 
		else 
		printf("No\n"); 
		
	}
	
	
}
	
	return 0;
}