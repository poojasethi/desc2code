#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#include <map>
#include <vector>
#include <list>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <string>
#include <cmath>
using namespace std;
#define FOR(i,a,b) for(i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
struct pb
{
	int x,y;
}posb[251],tmpb;
vector<pb>useb;
vector<int> a[251];
vector<int> b[251];
int n,s;
struct pa
{
	int x,y;
}posa[251],tmpa;
vector<pa>usea;
int sa,sb;
int pres(int a1,int b1)
{
	int i,j;
	for(i=1;i<=sa;i++)
	{
		if(posa[i].x==a1&&posa[i].y==b1)
			return 1;
	}
	for(j=1;j<=sb;j++)
	{
		if(posb[j].x==a1&&posb[j].y==b1)
			return 1;
	}		
	return 0;
}
int frea(int a1,int b1)
{
	int i;
	if(a1<1||b1<1||a1>n||b1>n)
		return 0;
	for(i=0;i<usea.size();i++)
		if(usea[i].x==a1&&usea[i].y==b1)
			return 0;
	if(!pres(a1,b1))
	{
		tmpa.x=a1;
		tmpa.y=b1;
		usea.push_back(tmpa);
	}
}
int freb(int a1,int b1)
{
	if(a1<1||b1<1||a1>n||b1>n)
		return 0;
	int i;
	for(i=0;i<useb.size();i++)
		if(useb[i].x==a1&&useb[i].y==b1)
			return 0;
	if(!pres(a1,b1))
	{
		tmpb.x=a1;
		tmpb.y=b1;
		useb.push_back(tmpb);
	}
}
int chka(int f,int g)
{
	if(posa[f].x==posa[g].x&&posa[f].y==posa[g].y)
		return 0;
	if(abs(posa[f].x-posa[g].x)==1&&posa[f].y==posa[g].y)
		return 1;
	else if(abs(posa[f].y-posa[g].y)==1&&posa[f].x==posa[g].x)
		return 1;
	return 0;
}
int chkb(int f,int g)
{
	if(posb[f].x==posb[g].x&&posb[f].y==posb[g].y)
		return 0;
	if(abs(posb[f].x-posb[g].x)==1&&posb[f].y==posb[g].y)
		return 1;
	else if(abs(posb[f].y-posb[g].y)==1&&posb[f].x==posb[g].x)
		return 1;
	return 0;
}

int tot,visita[1001],visitb[1001];
int dfsa(int v)
{
	int i;
	tot++;
	visita[v]=1;
	frea(posa[v].x+1,posa[v].y);
	frea(posa[v].x,posa[v].y+1);
	frea(posa[v].x-1,posa[v].y);
	frea(posa[v].x,posa[v].y-1);
	for(i=0;i<a[v].size();i++)
	{
		if(!visita[a[v][i]])
			dfsa(a[v][i]);
	}
}
int dfsb(int v)
{
	int i;
	tot++;
	visitb[v]=1;
	freb(posb[v].x+1,posb[v].y);
	freb(posb[v].x,posb[v].y+1);
	freb(posb[v].x-1,posb[v].y);
	freb(posb[v].x,posb[v].y-1);

	for(i=0;i<b[v].size();i++)
	{
		if(!visitb[b[v][i]])
			dfsb(b[v][i]);
	} 
}
struct an
{
	char col;
	int d,c;
}ans[1001];
bool cmpa(an p1, an p2)
{
	if(p1.c!=p2.c)
		return (p1.c>p2.c);
	return (p1.d>p2.d);
}
bool cmpb(an p1,an p2)
{
	if(p1.c!=p2.c)
		return (p1.c>p2.c);
	return (p1.d>p2.d);
}

int main()
{
	int t,i,j;
	scanf("%d\n",&t);
	int xt=0;
	char c;
	while(xt<t)
	{
		xt++;
		sa=0;
		sb=0;
		fill(visita,visita+1001,0);
		fill(visitb,visitb+1001,0);
		scanf("%d %d",&n,&s);
		for(i=1;i<=s;i++)
		{
			a[i].clear();
			b[i].clear();
			scanf(" %c ",&c);
				if(c=='B')
				{
					sb++;
					scanf("%d %d",&posb[sb].x,&posb[sb].y);
				}
				else
				{
					sa++;
					scanf("%d %d",&posa[sa].x,&posa[sa].y);
				}
		}
		printf("Case #%d:\n",xt);
		for(i=1;i<=sb;i++)
		{
			for(j=i+1;j<=sb;j++)
			{
				if(chkb(i,j))
				{
					b[i].push_back(j);
					b[j].push_back(i);
				}
			}
		}
	
		int ant=0;
		useb.clear();
		for(i=1;i<=sb;i++)
		{
			tot=0;
			if(!visitb[i])
			{
				dfsb(i);
				ans[ant].d=useb.size();
				ans[ant].col='B';
				ans[ant++].c=tot;
//				printf("%d\n",tot);
			//	for(j=0;j<useb.size();j++)
		//			printf("%d %d, ",useb[j].x,useb[j].y);
	//			printf("\n");
				useb.clear();
			}
		}
		sort(ans,ans+ant ,cmpb);
		for(i=0;i<ant;i++)
			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d);
//		printf("\n\n");
		for(i=1;i<=sa;i++)
		{
			for(j=i+1;j<=sa;j++)
			{
				if(chka(i,j))
				{
					a[i].push_back(j);
					a[j].push_back(i);
				}
			}
		}
		ant=0;
		usea.clear();
		for(i=1;i<=sa;i++)
		{
			tot=0;
			if(!visita[i])
			{
				dfsa(i);
				ans[ant].d=usea.size();
				ans[ant].col='W';
				ans[ant++].c=tot;
				usea.clear();
			}
		}
//		for(i=1;i<=sa;i++)
//		{
//			for(j=0;j<a[i].size();j++)
//				printf("%d ",a[i][j]);
//			printf("\n");
//		}
	sort(ans,ans+ant,cmpa);
		for(i=0;i<ant;i++)
			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d);
		printf("\n");
	}
	return 0;
}
