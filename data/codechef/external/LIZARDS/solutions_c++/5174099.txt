#include<bits/stdc++.h>
//#define inf 100000000
#define ll  long long
#define pb push_back
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)

#define p(n) printf("%lld\n",n)
#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>
#define pb push_back
#define inf 1000000000LL
#define mp make_pair
#define MOD 1000000007LL
#define N 1000007
using namespace std;
ll powmod(long long a, long long b, long long c)
{
    ll ret=1LL;

    while(b)
    {
        if(b & 1)
            ret = (ret*a)%c;
        a=(a*a)%c;

        b>>=1;
    }
    return (ret)%c;
}
ll minverse(ll a,ll mod1)
{
    if(a==0LL)
        return 1LL;
    return powmod(a,(1LL*(mod1-2LL)),mod1)*1LL;
}
string s1;
struct tree
{
 ll ans;
 ll l;
 ll r;
 int f;
}node[4*80000+5];
void build_tree(int idx,int l,int r)
{
 if(l==r)
 {
   if(s1[l]=='L')
   {
    node[idx].l=1;
    node[idx].r=0;
    node[idx].ans=0;
   }
   else
   {
      node[idx].l=0;
    node[idx].r=1;
    node[idx].ans=0;
   }
   node[idx].f=0;
 }
 else
 {
  int mid=(l+r)/2;
  build_tree(2*idx+1,l,mid);
  build_tree(2*idx+2,mid+1,r);
  node[idx].l=node[2*idx+1].l+node[2*idx+2].l;
  node[idx].r=node[2*idx+1].r+node[2*idx+2].r;
  node[idx].ans=node[2*idx+1].ans+node[2*idx+2].ans+node[2*idx+1].r*node[2*idx+2].l;
  node[idx].f=0;
 }
}
void update(int idx,int l,int r,int ql,int qr)
{
 if(node[idx].f==1)
 {
  ll val1=node[idx].l;
  ll val2=node[idx].r;
  ll tot=(ll)(r-l+1)*(r-l)/2;
  swap(node[idx].l,node[idx].r);
  node[idx].ans=tot-node[idx].ans-(val1)*(val1-1)/2-(val2)*(val2-1)/2;
  node[idx].f=0;
  if(l<r)
  {
   node[2*idx+1].f=(node[2*idx+1].f)^1;
   node[2*idx+2].f=(node[2*idx+2].f)^1;
  }
 }
 if(ql>r||qr<l||l>r)
 return;
 if(ql<=l && qr>=r)
 {
   ll val1=node[idx].l;
    ll val2=node[idx].r;
   ll tot=(ll)(r-l+1)*(r-l)/2;
   swap(node[idx].l,node[idx].r);
   node[idx].ans=tot-node[idx].ans-(val1)*(val1-1)/2-(val2)*(val2-1)/2;
   if(l<r)
   {
   node[2*idx+1].f=(node[2*idx+1].f)^1;
   node[2*idx+2].f=(node[2*idx+2].f)^1;
   }
 }
 else
 {
   int mid=(l+r)/2;
   update(2*idx+1,l,mid,ql,qr);
   update(2*idx+2,mid+1,r,ql,qr);
   node[idx].l=node[2*idx+1].l+node[2*idx+2].l;
  node[idx].r=node[2*idx+1].r+node[2*idx+2].r;
  node[idx].ans=node[2*idx+1].ans+node[2*idx+2].ans+node[2*idx+1].r*node[2*idx+2].l;
 }
}
int main()
{

int n,i,n1,n2;
s(n);
cin>>s1;
build_tree(0,0,n-1);
/*cout<<node[0].l<<" "<<node[0].r<<" "<<node[0].ans<<endl;
 cout<<node[1].l<<" "<<node[1].r<<" "<<node[1].ans<<endl;
 cout<<node[2].l<<" "<<node[2].r<<" "<<node[2].ans<<endl;*/
int q;
cin>>q;
while(q--)
{
 s(n1);s(n2);
 update(0,0,n-1,n1,n2);
 /*cout<<node[0].l<<" "<<node[0].r<<" "<<node[0].ans<<" "<<node[0].f<<endl;
 cout<<node[1].l<<" "<<node[1].r<<" "<<node[1].ans<<" "<<node[1].f<<endl;
 cout<<node[2].l<<" "<<node[2].r<<" "<<node[2].ans<<" "<<node[2].f<<endl;*/
 p(node[0].ans);
}
}
