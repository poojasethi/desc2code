#include <vector> 
#include <list> 
#include <map> 
#include <set> 
#include <queue>
#include <stack> 
#include <bitset> 
#include <algorithm> 
#include <numeric> 
#include <utility> 
#include <sstream> 
#include <iostream> 
#include <iomanip> 
#include <cstdio> 
#include <cmath> 
#include <cstdlib> 
#include <ctime> 
#include <cstring> 

using namespace std; 

typedef long long ll; 
typedef pair<int, int> pii;

#define INF 1000000000
#define pb push_back 
#define itr iterator 
#define sz size() 
#define mp make_pair

int n, u, v, t;
long long k;
vector<int> adj[110000];
int parent[110000];
int tam[110000];

void dfs(int v, int p) {
	parent[v] = p;
	tam[v] = 1;

	for (int i = 0; i < adj[v].sz; i++) {
		int child = adj[v][i];
		if (child == p) continue;
		dfs(child, v);
		tam[v] += tam[child];
	}
}

void create_path(int v, int p, int k) {
	//printf("%d %d %d\n",v,p,k );
	if (p != -1) printf(" ");
	printf("%d", v+1);
	
	if (k == 0) return;

	for (int i = 0; i < adj[v].sz; i++) {
		int child = adj[v][i];
		if (child == p) continue;

		int sub;
		if (child == parent[v]) {
			sub = n - tam[v];
		}
		else sub = tam[child];

		if (sub >= k) {
			create_path(child, v, k-1);
			return;
		}
		else {
			k -= sub;
		}
	}
}

int main() {
	for (scanf("%d", &t); t; t--) {
		scanf("%d %lld", &n, &k); k--;

		for (int i = 0; i < n; i++) adj[i].clear();

		for (int i = 0; i < n-1; i++) {
			scanf("%d %d", &u, &v); u--; v--;
			adj[u].pb(v);
			adj[v].pb(u);
		}

		for (int i = 0; i < n; i++) {
			sort(adj[i].begin(), adj[i].end());
		}

		dfs(0, -1);

		create_path(k/n, -1, k%n);
		printf("\n");
	}
}