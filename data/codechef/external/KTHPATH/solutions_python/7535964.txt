#include<bits/stdc++.h>
using namespace std;
#define inf 10000000
#define ll long long
#define mp make_pair
#define pb push_back
#define PI pair<ll,ll>
#define VI vector<ll>
#define reset(x,y) memset(x,y,sizeof x)
#define loop(r,s) for(r=0;r<s;r++)
#define s1(x) scanf("%ld",&x)
#define s2(x,y) scanf("%ld%ld",&x,&y)
#define s3(x,y,z) scanf("%ld%ld%ld",&x,&y,&z)
#define logn 28
#define debug 0 
#define MAXN 1000009
#ifndef ONLINE_JUDGE
    #define gc getchar
#else
    #define gc getchar_unlocked
#endif
ll read() {
  char c = gc();
  ll mul=1;
  while(c<'0' || c>'9'){
  	if(c=='-')
  	{
  		mul=-1;
  		c=gc();
  		break;
  	}

  	c = gc();
  }
  ll ret = 0;
  while(c>='0' && c<='9') {
    ret = 10 * ret + c - 48LL;
    c = gc();
  }
  return ret*mul;
}
VI subtree,parent;
vector<VI>graph;
vector<VI>subgraph,sumgraph;
void dfs(ll cur,ll prev)
{
    subtree[cur]=1;
    parent[cur]=prev;
    for(ll i=0;i<graph[cur].size();i++)
    {
        if(graph[cur][i]!=prev)
        {
            dfs(graph[cur][i],cur);
            subtree[cur]+=subtree[graph[cur][i]];
        }
    }
}

void print(vector<VI>g,ll n)
{
	for(ll i=0;i<n;i++)
	{
		for(ll j=0;j<g[i].size();j++)
		{
			printf("%ld ",g[i][j]);
		}
		printf("\n");
	}
	
}
void solve(ll cur,ll prev,ll q)
{
     if(debug)
     printf("%ld prev=%ld q=%ld\n",cur+1,prev,q);
     printf("%lld ",cur+1);
    if(q==1)
        {
          return;
        }
        else
        {
        	q--;
           VI::iterator it=lower_bound(sumgraph[cur].begin(),sumgraph[cur].end(),q);
           VI::iterator nit=lower_bound(graph[cur].begin(),graph[cur].end(),prev);
           ll index=it-sumgraph[cur].begin();
           if(graph[cur][index]>=prev&&prev!=-1)
           {
  	 it=lower_bound(sumgraph[cur].begin(),sumgraph[cur].end(),q+subgraph[cur][nit-graph[cur].begin()]);
           index=it-sumgraph[cur].begin();
           }
           ll sub=0;
           if(index)
           sub=sumgraph[cur][index-1];
           if(graph[cur][index]>=prev&&prev!=-1)
           sub=sub-subgraph[cur][nit-graph[cur].begin()];
           solve(graph[cur][index],cur,q-sub);
        }
}
int main(void)
{
    ll test=read();
    while(test--)
    {
       ll n=read();
      ll q=read();
       graph=vector<VI>(n);
       subgraph=vector<VI>(n);
       sumgraph=vector<VI>(n);
       subtree.resize(n,0);
       parent.resize(n,0);
       for(ll i=1;i<n;i++)
       {
           ll x,y;
           x=read();
           y=read();
           x--;
           y--;
           graph[x].pb(y);
           graph[y].pb(x);
        }
        if(debug){
        printf("graph:\n");
        print(graph,n);
        }
        for(ll i=0;i<n;i++)
            sort(graph[i].begin(),graph[i].end());
            if(debug)
            {
            printf("sorted graph\n");
            print(graph,n);
            }
        dfs(0,-1);
        for(ll i=0;i<n;i++)
        {
            for(ll j=0;j<graph[i].size();j++)
            {
            	long  tot;
            	if(graph[i][j]==parent[i])
                tot=n-subtree[i];
               else 
               tot=subtree[graph[i][j]];
            subgraph[i].pb(tot);
            if(!j)
            sumgraph[i].pb(subgraph[i][j]);
            else
            sumgraph[i].pb(sumgraph[i][j-1]+subgraph[i][j]);
            }
        }
        if(debug){
        printf("subgraph\n");
        print(subgraph,n);
        }
        ll sub=0,index;
        if(debug){
       printf("sumgraph\n");
       print(sumgraph,n);
        }
        index=q/n-((q%n)==0LL);
        sub=(index)*n;
        if(debug)
        {
        	printf("index=%ld sub=%ld\n",index,sub);
        }
       solve(index,-1,q-sub);
       printf("\n");
        graph.clear();
        subgraph.clear();
        sumgraph.clear();
        subtree.clear();
    }
    return 0;
}
