
//~        Author : Sarvesh Mahajan                             
//               IIIT,Hyderabad                                   
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#ifndef ONLINE_JUDGE
//#define DEBUG
#endif

#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define For(i,a,b) for(i=a;i<b;i++)
#define loop(i,b) for(i=0;i<b;i++)
#define Loop(i,b) for(i=1;i<=b;i++)
#define pi(n) cout<<n<<' '
#define si(n) cin>>n
const int MOD=1e9+7;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef long long LL;
#define F first
#define S second
#define sz(x) (int) x.size()
#define pLL(x) cout<<x<<' '
#define fill(x,c) memset(x,c,sizeof(x))
#define LET(x,a) __typeof(a) x(a)
#define IFOR(i,a,b) for(LET(i,a);i!=(b);++i)
#define EACH(it,v) IFOR(it,v.begin(),v.end())
#ifdef DEBUG
#define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;
#else
#define DB(x)
#define DB2(x,y)
#define DB3(x,y,z)
#endif


const int N=2e5+5;
VI g[N];
int ct;
int subtree[N];
int path[N];
void dfs(int s,int par)
{
	int i,l=g[s].size();
	subtree[s]=1;
	loop(i,l)
	{
		int v=g[s][i];
		if(v!=par)
		{
		dfs(v,s);
		subtree[s]+=subtree[v];
		}
	}
}


void solve(int s,int k,int par)
{
	if(k<=0)
		return;
	int l=g[s].size();
	int i,cum=0,v;
	loop(i,l)
	{
		v=g[s][i];
		if(v == par)
			continue;
		if(cum+subtree[v]>=k)
		{
			path[ct++]=(v);
			k-=cum;
			break;
		}
		cum+=subtree[v];
		
	}

	solve(v,k-1,s);
}

		
void printVector(VI path)
{
	int i,l=path.size();
	loop(i,l)
		cout<<path[i]<<' ';
	cout<<'\n';
}

	










int main()
{
int n,t,m,l,ans,i,j,res=0,fl;
t=1;
cin>>(t);
while(t--)
{	
	LL k;
	int x,y;
	scanf("%d%lld",&n,&k);
	ct=0;
	Loop(i,n)
		g[i].clear();
	loop(i,n-1)
	{
		scanf("%d%d",&x,&y);
		g[x].pb(y);
		g[y].pb(x);
	}

	Loop(i,n)
		sort(g[i].begin(),g[i].end());

	
	k--;
	int start=k/n+1;
	k%=n;

	path[ct++]=(start);
	dfs(start,0);

	int par=0;

	int iter=0;
	while(k>0)
	{
		iter++;
		if(iter>1e6)
		{
			cout<<"WHAT"<<endl;
			return 0;
		}
		LL cum=0,v;
		int l=g[start].size();
		loop(i,l)
		{
			v=g[start][i];
			if(v == par)
				continue;
			if(cum+subtree[v]>=k)
			{
			path[ct++]=(v);
			k-=cum;
			break;
			}
			cum+=subtree[v];
		}
		k--;
		par=start;
		start=v;
	}











	//solve(start,k,0);

	loop(i,ct)
		cout<<path[i]<<' ';
	cout<<'\n';








}
return 0;
}
