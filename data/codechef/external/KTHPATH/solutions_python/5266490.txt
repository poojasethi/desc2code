# include <iostream>
# include <sstream>
# include <algorithm>
# include <cstdio>
# include <cmath>
# include <numeric>
# include <cstdlib>
# include <cstring>
# include <vector>
# include <list>
# include <set>
# include <map>
# include <stack>
# include <queue>
# include <cctype>
# include <climits>
# include <complex>
using namespace std;
typedef long long ll ;
typedef unsigned long long ull;
ll INF = 1e9 ;
typedef pair < int , int > pii ;
typedef  vector < int > vi ;
typedef vector < pii > vpi ;
typedef vector < ll > vl ;
typedef pair < int , pii > tri ;
typedef vector < string > vs ;
typedef vector < vi > mat ;
#define all(a) a.begin(),a.end()
#define si(n) scanf("%d",&n)
#define ss(n) scanf("%s" , n)
#define sl(n) scanf("%lld" , &n)
#define pi(n) printf("%d" , n)
#define ps(n) printf("%s" , n)
#define pl(n) printf("%lld" , n)
#define pnl() printf("\n")
#define fors( i , a , b ) for ( int i = a ; i < b ; i++ )
#define pb push_back
#define ff first
#define mp make_pair
#define sz(a) a.size()
#define fill(a,v)  memset(a,v,sizeof(a))
#define index(arr,ind) (lower_bound(all(arr),ind)-arr.begin())
ll n , nnum , pnum , dis[100005] , p[100005] , tim ;
set < int > g[100005] ;
int ans ;

void cl()
{
fors( i , 1 , n + 1 )
{
    g[i].clear() ;
    dis[i] = -1 ;
    p[i] = -1 ;
}
nnum = pnum = 0 ;
tim = 0 ;
}

void dfs( int i )
{
    dis[i] = tim++ ;
    if ( tim == pnum )
        {
        ans = i ;
        return ;
        }
else
     {
        set<int>::iterator it ;
        for ( it = g[i].begin() ; it != g[i].end() ; it++)
         {
            int v = *it ;

            if ( dis[v] == -1 )
             {
            p[v] = i ;
            dfs(v) ;
             }
         }
    }
   return ;

}

void pripar( int i )
{

    if ( p[i] == -1)
        cout << i << " " ;
    else
    {
        pripar(p[i]);
        cout << i << " " ;
    }
    return ;
}



int main()
{
    int t , fr , to ;
    ll q ;
    si(t) ;
    while ( t-- )
    {

        sl(n) , sl(q) ;
         cl() ;
        fors(i , 0 , (n-1))
        {
            si(fr) , si(to) ;
            g[fr].insert(to) ;
            g[to].insert(fr) ;
        }
        if ( ( q % n ) == 0 )
        {
            nnum = q / n ;
            pnum = n ;
        }
        else
        {
            nnum = ( q / n ) + 1 ;
            pnum = q % n ;
        }
        dfs(nnum) ;
        pripar(ans) ;
        pnl() ;
    }
    return 0 ;
}
