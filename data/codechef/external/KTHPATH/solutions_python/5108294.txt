#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <string>
#include <cstring>
#include <cassert>
using namespace std;
 
#define GI ({int t;scanf("%d",&t);t;})
#define GD ({double t;scanf("%lf",&t);t;})
#define GF ({float t;scanf("%f",&t);t;})
#define GLL ({long long t;scanf("%lld",&t);t;})
#define GLD ({long double t;scanf("%Lf",&t);t;})
#define SET(c) memset(c,-1,sizeof(c))
// #define s(n) scanf("%d",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
 
#define sstr(str) scanf ("%s", str); 
 
#define p(n) printf("%d ",n)
#define pl(n) printf("%ld ",n)
#define pll(n) printf("%lld ",n)
 
#define pf(n) printf("%f\n",n)
#define pd(n) printf("%lf\n",n)
 
#define pnl(n) printf("%d\n",n)
#define plnl(n) printf("%ld\n",n)
#define pllnl(n) printf("%lld\n",n)
 
#define ll long long
#define MAX(a,b) a>b?a:b
#define all(c) c.begin(), c.end()
#define rall(c) c.rbegin(), c.rend()    // reverse all 
#define pb push_back
#define mp make_pair
#define ff first
#define ss second

#define rep(i, n) for(int i = 0; i < (n); ++i)
#define forn(i, a, b) for(int i = (a); i < (b); ++i)
#define ford(i, a, b) for(int i = (a); i >= (b); --i)
#define fore(i, a, b) forn(i, a, b + 1)
#define MALLOC(n,T) (T*)malloc(n*sizeof(T))
 
typedef vector<int> vi;
typedef vector<char> vc;
typedef vector<long long> vll;
typedef vector< vector<int> > vvi;
typedef vector< vector<char> > vvc;
typedef vector<string> vstr;
typedef map<int,int> mapii;
typedef pair<int,int> pii;
typedef std::vector<pii> vpii;
 
#define sz(a) int((a).size()) 
#define szar(ar) int(sizeof(ar)/sizeof(ar[0]))
#define osit ostream_iterator 
 
#define mod 1000000007LL
void print1Dvec(const vi & v, char* msg)
{
  printf("%s\n",msg );
  for (int i = 0; i < sz(v); ++i)
  {
    printf("%d ",v[i] );
  }
  printf("\n");
}

// CONSUMES THE NEW LINE CHARACTER AT THE END
inline int get()                  // working even in loops, working excellent
{
  char c;
  while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-'));
  bool Flag=(c=='-');
  if(Flag)
    c=getchar_unlocked();
  int X=0;
  while(c>='0'&&c<='9')
    {
      X=X*10+c-48;
      c=getchar_unlocked();
    }
  return Flag?-X:X;
}

// CONSUMES THE NEW LINE CHARACTER AT THE END
inline ll getll()                  // working even in loops, working excellent
{
  char c;
  while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-'));
  bool Flag=(c=='-');
  if(Flag)
    c=getchar_unlocked();
  ll X=0;
  while(c>='0'&&c<='9')
    {
      X=X*10+c-48;
      c=getchar_unlocked();
    }
  return Flag?-X:X;
}

 
// CONSUMES THE NEW LINE CHARACTER AT THE END
inline void get(char *str)
 
{
    register char c = 0;
    register int i = 0;
    while (c < 33)
        c = getchar_unlocked();
 
    while (c != '\n') {
        str[i] = c;
        c = getchar_unlocked();
        i = i + 1;
    }
    str[i] = '\0';
 
}
 
// DOES NOT PRINT NEW LINE CHARACTER
inline void output(int X)        // working even in loops, working excellent
{
  if(X<0)
    {
      putchar_unlocked('-');
      X=-X;
    }
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar_unlocked(Data[Len]+48);
 
  putchar_unlocked(' ');
}
 
// DOES NOT PRINT NEW LINE CHARACTER
inline void output(ll X)        // working even in loops, working excellent
{
  if(X<0)
    {
      putchar_unlocked('-');
      X=-X;
    }
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar_unlocked(Data[Len]+48);
 
  putchar_unlocked(' ');
}

// vvi G;
// vi dp(100010,0);
// vi visited(100010,0);

void DFS(vvi& G, int root, vi& dp, vi& visited)
{
  visited[root] = 1;
  ll count =1;
  forn(i,0,sz(G[root])) {
    if(!visited[G[root][i]]) {
      DFS(G,G[root][i],dp,visited);
      count += dp[G[root][i]];
      visited[G[root][i]] = 1;
    }
  }
  dp[root] = count;
}

void PrintPath(vvi& G, int root, ll k, vi& dp, vi& visited)
{
  visited[root] = 1;
  output(root);
  k--;
  if(k<=0) {   
    return;
  }

  // ll count = 0;
  rep(i,sz(G[root])) {
    if(!visited[G[root][i]]) {
      // count += dp[G[root][i]];
      if(k > dp[G[root][i]]) k -= dp[G[root][i]];
      else {
        PrintPath(G,G[root][i],k,dp,visited);
        break;
      }
      visited[G[root][i]] = 1;
    }
    
  }
}

 
int main()
{  
  // int t = GI;
  int t = get();
  while(t--)
  {

    // int n=GI;
    int n=get();
    vvi G(n+1);
    vi dp(n+1,0);
    vi visited(n+1,0);
    // ll k=GLL;
    ll k = getll();
    G.resize(n+1);

    rep(i,n-1) {
      // int x=GI, y=GI;
      int x=get(), y=get();
      G[x].pb(y);
      G[y].pb(x);
    }

    fore(i,1,n) {
      sort(all(G[i]));
    }
    
    
    int start = ceil((double)k/n);
    k -= (ll)(start-1)*n;
    DFS(G,start,dp,visited);
    fill(all(visited),0);
    PrintPath(G,start,k,dp,visited);
    // printf("\n");
    // printf("\n");
    putchar_unlocked('\n');


    // fill(all(dp),0);
    // fill(all(visited),0);
    // G.clear();
  }
 
 
 
  
  return 0;
  
  
}  