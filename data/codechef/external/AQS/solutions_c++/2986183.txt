#include<stdio.h>
#include<iostream>
#include<math.h>
#include<vector>
#include<map>
#include<string>
#include<string.h>
#include<algorithm>
#define PI acos(-1.0)
#define SIZE 100007
#define Fi(a,n) for(int i=a;i<n;i++)
#define Fj(a,n) for(int j=a;j<n;j++)
using namespace std;

vector<int> adj[SIZE],children[SIZE];
int ins[SIZE],outs[SIZE],parent[SIZE],treesize[SIZE],timer=0;

void dfs(int u)
{
	ins[u]=timer++;
	treesize[u]=1;
	int v;
	for(int i=0;i<adj[u].size();i++)
	{
		v=adj[u][i];
		if(parent[u]==v)
		continue;
		children[u].push_back(v);
		parent[v]=u;
		dfs(v);
		treesize[u]+=treesize[v];
	}
	outs[u]=timer++;
}

bool isAncestor(int u,int v)
{
	return ins[u]<=ins[v] && outs[u]>=outs[v];
}

int main()
{
	int N,Q;
	scanf("%d %d",&N,&Q);
	memset(ins,0,sizeof(ins));
	memset(outs,0,sizeof(outs));
	memset(parent,0,sizeof(parent));
	memset(treesize,0,sizeof(treesize));
	int u,v;
	for(int i=0;i<N-1;i++)
	{
		scanf("%d %d",&u,&v);
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	dfs(0);
	int ans=0;
	while(Q--)
	{
		scanf("%d %d",&u,&v);
		if(isAncestor(v,u))
			swap(u,v);
		if(isAncestor(u,v))
		{
			int i;
			for(i=0;i<children[u].size();i++)
			if(isAncestor(children[u][i],v))
			break;
			ans=N-(treesize[children[u][i]]-treesize[v]);
		}else
		ans=treesize[u]+treesize[v];
		printf("%d\n",ans);
	}
}
