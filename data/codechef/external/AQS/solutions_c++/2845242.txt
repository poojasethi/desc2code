/*
 	C++ Template
	Pradeep George Mathias
 */


#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cstdlib>
using namespace std;

#define s(T) scanf("%d", &T)
#define sl(T) scanf("%lld", &T)
#define fill(a, val) memset(a, val, sizeof(a))
#define mp make_pair
#define pb push_back
#define all(x) x.begin(), x.end()
#define DREP(x) sort(all(x)); x.erase(unique(all(x)), x.end())
#define INDEX(a, val) (lower_bound(all(a), val) - a.begin())

const int maxn = 100000;
const int maxq = 100000;

int totalCases, testNum;
int N, Q;

int tin[maxn], tout[maxn];
int sizes[maxn], parent[maxn];

vector <int> children[maxn];
vector <int> adjl[maxn];

int ts;

void preprocess()
{
	
}

bool input()
{
	s(N);
	s(Q);
	int u, v;
	for(int i = 0; i < N-1; i++)
	{
		s(u);
		s(v);
		if(!(u != v && u >= 0 && u < N && v >= 0 && v < N))
			cerr << u << " " << v << " " << N << endl;
		assert(u != v && u >= 0 && u < N && v >= 0 && v < N);
		adjl[u].push_back(v);
		adjl[v].push_back(u);
	}
	return true;
}

bool anc(int u, int v)
{
	return tin[u] <= tin[v] && tout[u] >= tout[v];
}

void dfs(int u)
{
	assert(sizes[u] == 0);
	tin[u] = ts++;
	sizes[u] = 1;
	for(int i = 0; i < adjl[u].size(); i++)
	{
		int v = adjl[u][i];
		if(v == parent[u])
			continue;
		children[u].push_back(v);
		parent[v] = u;
		dfs(v);
		sizes[u] += sizes[v];
	}
	tout[u] = ts++;
}

void solve()
{
	fill(sizes, 0);
	ts = 0;
	parent[0] = 0;
	dfs(0);
	assert(sizes[0] == N);	// check if valid tree
	int ans;
	int u, v;
	
	for(int i = 0; i < Q; i++)
	{
		s(u);
		s(v);
		if(anc(v, u))
			swap(u, v);
		if(anc(u, v))
		{
			int lo = 0, hi = children[u].size();
			for(int mid = (lo + hi)/2; hi - lo > 1; mid = (lo + hi)/2)
				(tin[ children[u][mid] ] <= tin[v] ? lo : hi) = mid;
//SLOWER VERSION: Times out on Star Input
//			for(lo = 0; lo < children[u].size(); lo++)
//				if(anc(children[u][lo], v))
//					break;
			assert(anc(children[u][lo], v));
			ans = (N - sizes[children[u][lo]]) + sizes[v];
		}
		else 
			ans = sizes[u] + sizes[v];
		printf("%d\n", ans);
	}
}

int main()
{
	preprocess();
	totalCases = 1;
	for(testNum = 1; testNum <= totalCases; testNum++)
	{
		if( !input())
			break;
		solve();
	}
}
