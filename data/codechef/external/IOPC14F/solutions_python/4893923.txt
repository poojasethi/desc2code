#include <cstdio>
#include <utility>
#include <algorithm>
#include <cstring>

#define MAX 100005

using namespace std;

typedef long long int lli;

lli prime[MAX],val[MAX];

lli power(lli base, lli index);
void matrixMultiply(lli a[][2], lli b[][2], lli mod);
pair<lli, lli> findFib(lli index, lli mod);
lli findPeriod(lli p);
lli findPisanoPeriod(lli num);
lli gcd(lli a, lli b);
void sieve();
void powerCounter(int num, int add);
lli powMod(lli base, lli index, lli mod);


int main()
{
  lli i,temp,t,n,r,mod,period;
  pair<lli, lli> ans;
  sieve();
  scanf("%lld",&t);
  while(t--) {
    scanf("%lld %lld %lld",&n,&r,&mod);
    period = findPisanoPeriod(mod);
    memset(val, 0, sizeof(val));
    for(i=2;i<=n;i++) powerCounter(i, 1);
    for(i=2;i<=r;i++) powerCounter(i, -1);
    for(i=2;i<=n-r;i++) powerCounter(i, -1);
    temp = 1;
    for(i=2;i<=n;i++) temp = (temp * powMod(i, val[i], period)) % period;
    ans = findFib(temp, mod);
    printf("%lld\n", ans.first);
  }
  return 0;
}

void powerCounter(int num, int add)
{
  lli curr;
  while(num > 1) {
    curr = prime[num];
    while(num % curr == 0) {
      val[curr] += add;
      num /= curr;
    }
  }
}

void sieve()
{
  lli i,j;
  for(i=1;i<MAX;i++) prime[i] = i;
  for(i=2;i * i<MAX;i++)
    if(prime[i] == i)
      for(j=i;j<MAX;j+=i)
        prime[j] = i;
}

lli power(lli base, lli index)
{
  lli res = 1, temp = base;
  while(index)
  {
    if(index & 1)
      res *= temp;
    temp *= temp;
    index >>= 1;
  }
  return res;
}

lli powMod(lli base, lli index, lli mod)
{
  lli res = 1, temp = base;
  while(index)
  {
    if(index & 1)
      res = (res * temp)%mod;
    temp = (temp * temp)%mod;
    index >>= 1;
  }
  return res;
}

void matrixMultiply(lli a[][2], lli b[][2], lli mod)
{
  lli spare[2][2]={0},i,j,k;
  for(i=0;i<2;i++)
    for(j=0;j<2;j++){
      spare[i][j] = 0;
      for(k=0;k<2;k++)
        spare[i][j] = (spare[i][j] + (a[i][k] * b[k][j]) % mod)%mod;
    }
  memcpy(a, spare, sizeof(spare));
}

pair<lli, lli> findFib(lli index, lli mod)
{
  if(index == 0) return make_pair(0, 1);
  if(index == 1) return make_pair(1, 1);
  index--;
  lli res[2][2], temp[2][2];
  res[0][0] = res[1][1] = temp[0][0] = temp[0][1] = temp[1][0] = 1;
  res[0][1] = res[1][0] = temp[1][1] = 0;
  while(index) {
    if(index & 1) matrixMultiply(res, temp, mod);
    matrixMultiply(temp, temp, mod);
    index >>= 1;
  }
  return make_pair(res[0][0], res[1][0]);
}

lli findPeriod(lli p)
{
  if(p == 2) return 3;
  else if(p == 3) return 8;
  else if(p == 5) return 20;
  
  lli rem = p % 5, multiple, i;
  pair<lli, lli> temp;
  if(rem == 1 || rem == 4) multiple = p - 1;
  else multiple = 2 * p + 2;
  
  for(i=2;i * i<=multiple;i++)
    if(multiple % i == 0) {
      temp = findFib(i, p);
      if(temp.first == 0 && temp.second == 1) return i;
    }
  return multiple;
}

lli findPisanoPeriod(lli num)
{
  lli i,cnt,period = 1,curr;
  for(i=2;i * i<=num;i++)
    if(num % i == 0) {
      cnt = 0;
      while(num % i == 0) {
        cnt++;
        num /= i;
      }
      curr = power(i, cnt - 1) * findPeriod(i);
      period = (period * curr) / gcd(period, curr);
    }
  if(num > 1) {
    curr = findPeriod(num);
    period = (period * curr) / gcd(period, curr);
  }
  return period;
}

lli gcd(lli a, lli b)
{
  if(b>a) gcd(b,a);
  if(b==0) return a;
  return gcd(b, a%b);
}

// http://www.jstor.org/stable/2309169?seq=1