#include <cstdio>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
using namespace std;
typedef long long LL;
#define N 100003
int num,prime[N];
bool vis[N];
struct Matrix{
    LL m[3][3];
}E,D;
LL M,mt;
void init(){
    int num=0;
    memset(vis,true,sizeof(vis)); vis[0]=vis[1]=false;
    for(int i=2;i<N;i++){
        if(vis[i]){
            prime[num++]=i;
            for(int j=2*i;j<N;j+=i) vis[j]=false;
        }
    }
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++){
            E.m[i][j]=(i==j);
            D.m[i][j]=1;
        }
    D.m[2][2]=0;
}
Matrix multi(Matrix A,Matrix B){
    Matrix ans;
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++){
            ans.m[i][j]=0;
            for(int k=1;k<=2;k++)
                ans.m[i][j]=(ans.m[i][j]+A.m[i][k]*B.m[k][j])%M;
        }
    return ans;
}
LL s_mod(LL n)
{
    LL a1 = 0, a2 = 1, a3 = 1, tmp, ans = 1;
    while (a2 != 0 || a3 != 1)
    {
        ans++;
        tmp = (a2 + a3)%n;
        a2 = a3;
        a3 = tmp;
    }
    return ans;
}
Matrix Pow(Matrix A,LL k){
    Matrix ans=E;
    while(k){
        if(k&1) k--,ans=multi(ans,A);
        else k/=2,A=multi(A,A);
    }
    return ans;
}
LL get_fib(LL n){
    return Pow(D,n).m[1][1]%M;
}
LL Pow(LL a,LL b,LL mod){
    LL ans=1;
    while(b){
        if(b&1) b--,ans=(ans*a)%mod;
        else b/=2,a=(a*a)%mod;
    }
    return ans;
}
/*LL get(LL x,LL p){
    LL ans=0,pnt=p;
    while(pnt<=x){
        ans+=x/pnt;
        pnt*=p;
    }
    return ans;
}*/
LL get(LL x,LL p){
    LL ans=0,pnt=p;
    while(x){
        ans+=x/pnt;
        x/=p;
    }
    return ans;
}
LL C(LL n,LL m,LL mod){
    LL ans=1,p;
    for(int i=0;i<9592&&prime[i]<=n;i++){
        p=get(n,prime[i])-get(m,prime[i])-get(n-m,prime[i]);
        if(p) ans=(ans*Pow(prime[i],p,mod))%mod;
    }
    ans--;
    return (ans%mod+mod)%mod;
}
LL findPeriod(int M) {
    int a = 1, b = 1, c = -1;
    LL p = 0, cnt = 3;
    if (M <= 20) {
        while (1) {
            c = (a + b);
            if (c >= M) c -= M;
            if (c == 1 && b == 1) {
                cnt -= 2;
                break;
            }
            a = b;
            b = c;
            cnt++;
        }
    } else {
        int ret = M % 5;
        if (ret == 1 || ret == 4) cnt = M - 1;
        else cnt = (M * (LL)M - 1);
    }
    return cnt;
}
LL GCD(LL a,LL b){
    if(b==0) return a; return GCD(b,a%b);
}
LL LCM(LL a,LL b){
    return a/GCD(a,b)*b;
}
LL findPisano(int M) {
    LL period = -1;
    for (int i = 2; i * i <= M; i++) {
        int cp = 1;
        if (M % i == 0) {
            while (M % i == 0) {
                cp *= i;
                M /= i;
            }
            if (period == -1) period = findPeriod(i) * (cp/i);
            else period = LCM(period, findPeriod(i) * (cp/i));
        }
    }
    if (M > 1) {
        if (period == -1) period = findPeriod(M);
        else period = LCM(period, findPeriod(M));
    }
    //if (period > 1e15) cerr<<"WATCH OUT\n";
    return period;
}
int main(){
    //freopen("1.txt","r",stdin);
    clock_t startTime = clock();
    ios_base::sync_with_stdio(false);
    init();
    int T; scanf("%d",&T);
    while(T--){
        int n,r; scanf("%d%d%lld",&n,&r,&M); mt=M;
        /*LL period=1;
        for(int i=2;i*i<=mt;i++){
            if(mt%i==0){
                if(i==2) period*=3;
                else if(i==5) period*=20;
                else period*=1LL*(i-1)*(i+1);
                mt/=i;
                while(mt%i==0){
                    period*=i;
                    mt/=i;
                }
            }
        }
        if(mt>1){
            if(mt==2) period*=3;
            else if(mt==5) period*=20;
            else period*=1LL*(mt-1)*(mt+1);
        }*/
        LL period = findPisano(M);
        printf("%lld\n",get_fib(C(n,r,period)));
    }
    clock_t endTime = clock();
    //cerr<<"\nTime:"<< double(endTime - startTime) / CLOCKS_PER_SEC <<" seconds\n" ;
    return 0;
}
