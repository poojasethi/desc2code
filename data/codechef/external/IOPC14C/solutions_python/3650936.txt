#include <bits/stdc++.h>
using namespace std;
typedef complex<double> Point;
const double EPS = 1e-8;
 
namespace std {
  bool operator<(const Point &lhs, const Point &rhs) {
    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();
  }
}
 
inline double cross(const Point &a, const Point &b) {
  return imag(conj(a) * b);
}
 
inline double dot(const Point &a, const Point &b) {
  return real(conj(a) * b);
}
 
int ccw(Point a, Point b, Point c) {
    b -= a; c -= a;
    double len = abs(b) * abs(c);
    if (cross(b, c) > 0)   return +1;
    if (cross(b, c) < 0)   return -1;
    if (dot(b, c) < 0)     return +2;
    if (norm(b) < norm(c)) return -2;
    return 0;
}
 
int convex_hull(vector<Point> ps){
  int n = ps.size();
  int k = 0;
  sort(ps.begin(), ps.end());
  vector<Point> ch(2 * n);
  for (int i = 0; i < n; ch[k++] = ps[i++])
    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;
  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])
    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;
  ch.resize(k - 1);
  return ch.size();
}
 
int solve(){
    int n;
    scanf("%d",&n);
    vector<Point> vp(n);
    for(int i = 0; i < n; i++){
        double x,y;
        scanf("%lf%lf",&x,&y);
        vp[i] = complex<double>(x,y);
    }
    return 3*(n-1) - convex_hull(vp);
}
 
int main(){
    int t;
    scanf("%d",&t);
    while(t--) printf("%d\n",solve());
}