using namespace std;
#include <bits/stdc++.h>
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
typedef long long ll; 
typedef pair<int,int> pii; 
typedef vector<vector<ll> > matrix;
#define REP(i,n) for (int i = 0; i < n; i++)
#define FOR(i,n) for (int i = 0; i < n; i++)
#define SZ(x) ((int)x.size())
#define PB push_back
#define sf(x) scanf("%d",&x)
#define MOD 1000000007
#define MAX 100
int modulo (int m, int n) { return m >= 0 ? m % n : ( n - abs ( m%n ) ) % n; }
int K;
// computes A * B
//matrix A(MAX, vector<ll>(MAX)), B(MAX, vector<ll>(MAX));
/*
matrix C(MAX, vector<ll>(MAX));
void mul(matrix &A, matrix &B)
{
    REP(i, K) REP(j, K) REP(k, K)
    {
      if(C[i][j] + A[i][k] * B[k][j]>=MOD)
           C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;
      else
           C[i][j] = (C[i][j] + A[i][k] * B[k][j]);
    }
    REP(i, K) REP(j, K)
        A[i][j] = C[i][j];
}

matrix APOW(MAX, vector<ll>(MAX)), POWRES(MAX, vector<ll>(MAX));
void pow (int n) 
{
  REP(i, K) REP(j, K) POWRES[i][j] = 0;
  REP(i, K) POWRES[i][i] = 1;
  while (n) 
  {
    if (n & 1)
        mul(POWRES, APOW);
    mul(APOW, APOW);
    n >>= 1;
  }
  //return res;
}
*/
matrix mul(matrix A, matrix B)
{
    matrix C(K, vector<ll>(K));
    REP(i, K) REP(j, K) REP(k, K)
    {
      if(C[i][j] + A[i][k] * B[k][j]>=MOD)
        C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;
      else
        C[i][j] = (C[i][j] + A[i][k] * B[k][j]);
    }
        
    return C;
}
// computes A ^ p
matrix pow(matrix A, int p)
{
    if(p == 1)
        return A;
    if(p & 1)
        return mul(A, pow(A, p-1));
    matrix X = pow(A, p/2);
    return mul(X, X);
}
int arr[102];
int sigma[102];
int main()
{
  int t;
  sf(t);
  while(t--)
  {
    int m, n;
    sf(m); sf(n);
    FOR(i, m)
      sf(arr[i]);
    FOR(i, m)
      arr[i] = modulo(arr[i], MOD);
    FOR(i, m)
      sf(sigma[i]);
    if(n < m)
    {
      cout<<arr[n]<<endl;
      continue;
    }

    K = m;
    matrix T(K, vector<ll>(K,0));
    FOR(i, K)
      T[0][i] = sigma[m-i-1];
    FOR(i, K-1)
      T[i+1][i] = 1;

    int N = n-m+1;

    vector<ll> F1(K);
    FOR(i, K)
      F1[i] = arr[m-i-1];
    //APOW = T;
    T = pow(T, N);

    //cout<<"hello"<<N<<endl;
    ll res = 0;
    REP(i, K)
        res = (res + T[0][i] * F1[i]) % MOD;
    cout<<res<<endl;
  }
  return 0;
}