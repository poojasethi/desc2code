// created by: Prashant Kumar Singh :)
#include<iostream>
#include<algorithm>
#include<utility>
#include<cstring>
#include<string.h>
#include<set>
#include<queue>
#include<map>
#include<math.h>
#include<stdio.h>
#include<vector>
#include<functional>
#include<bitset>
#include<iomanip>
#define ll long long
#define gr greater<ll>()
#define pi acos(-1.0)
#define pb push_back
#define MS0(ar) memset(ar,0,sizeof ar)
#define f first
#define s second
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ind(a) scanf("%d",&a)
#define inf(a) scanf("%lf",&a)
#define inl(a) scanf("%lld",&a)
#define ins(a) scanf("%s",a)
#define pd(a) printf("%d\n",a)
#define pl(a) printf("%lld\n",a);
#define bitcnt(x) __builtin_popcountll(x)
#define mp make_pair
#define mod 1000000007
using namespace std;
int dp[2][10001],n;
int dis[10005],vis[10005];
int w[10005];
vector<pii>v[10005];
void dijistra(int src)
{
  for (int i = 1; i < n; i++)
    dis[i] = mod;
  MS0(vis);
  int s, tmp;
  dis[src] = 0;
  priority_queue<pii, vector<pii>, greater<pii> > q;
  q.push(pii(0, 0));
  pii cur, tmp1;
  while (!q.empty())
  {
    cur = q.top();
    q.pop();
    if (vis[cur.second])
      continue;
    vis[cur.second] = 1;
    s = v[cur.second].size();
    for (int i = 0; i < s; i++)
    {
      tmp1 = v[cur.second][i];
      tmp = cur.first + tmp1.second;
      if (dis[tmp1.first] > tmp)
      {
        dis[tmp1.first] = tmp;
        q.push(pii(tmp, tmp1.first));
      }
    }
  }

  for (int i = 1; i < n; i++)
    dis[i] *= 2;
  return;

}
int main()
{
  ios_base::sync_with_stdio(0);
  cin.tie(0);
#ifndef ONLINE_JUDGE
  freopen("input.txt", "r", stdin);
#endif
  int e,t,a,b,c,d;
  cin >> t;
  while (t--)
  {
    cin >> n >> e >> d;
    for (int i = 0; i < e; i++)
    {
      cin >> a >> b >> c;
      v[a].pb(mp(b, c));
      v[b].pb(mp(a, c));
    }
    MS0(dp);
    for (int i = 1; i < n; i++)
    {
      cin >> w[i];
    }
    dijistra(0);
    for (int i = 1; i < n; i++)
    {
      for (int j = 0; j <= d; j++)
      {
        if (j - dis[i] >= 0)
        {
          dp[(i&1)][j] = max(dp[!(i&1)][j], dp[!(i&1)][j - dis[i]] + w[i]);
        }
        else
          dp[i&1][j] = dp[!(i&1)][j];
      }
    }
    cout << dp[(n-1)&1][d] << endl;
      for(int i = 0; i <= n; i++)
        v[i].clear();
  }

  return 0;
}