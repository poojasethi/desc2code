#include<stdio.h>
#include<vector>
using std::vector;

struct node
{
    int value[10];
    int lazy;
};

int GetSize(int n)
{
    int count = 1;
    while(n)
    {
       n >>= 1;
       count++;
    }
    count = 1<<count;
    return count;
}

void Init(vector<node>& segment, int index, vector<int>& A, int a, int b)
{
    if(a > b) return;
    segment[index].lazy = 0;
    if(a == b)
    {
        for(int i=0; i<10; ++i) segment[index].value[i] = 0;
        segment[index].value[A[a]] = 1;
        return;
    }
    int mid = a + (b-a)/2;
    Init(segment, 2*index, A, a, mid);
    Init(segment, 2*index+1, A, mid+1, b);
    for(int i=0; i<10; ++i) segment[index].value[i] = segment[2*index].value[i] + segment[2*index+1].value[i];
}

void BuildTree(vector<node>& segment, vector<int>& A)
{
    int n = A.size();
    int count = GetSize(n);
    segment.resize(count);
    Init(segment, 1, A, 0, n-1);
}

void LazyUpdate(vector<node>& segment, int index, int left, int right, int a, int b, int v)
{
    if(segment[index].lazy)
    {
        int C = segment[index].lazy;
        int temp[10];
        for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];
        for(int i=0; i<10; ++i) segment[index].value[(i+C)%10] = temp[i];
        if(left < right)
        {
            segment[2*index].lazy += segment[index].lazy;
            segment[2*index+1].lazy += segment[index].lazy;
        }
        segment[index].lazy = 0;
    }
    if(left > right || a > right || b < left) return;
    if(a <= left && b >= right)
    {
        int temp[10];
        for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];
        for(int i=0; i<10; ++i) segment[index].value[(i+v)%10] = temp[i];
        if(left < right)
        {
            segment[2*index].lazy += v;
            segment[2*index+1].lazy += v;
        }
        return;
    }
    int mid = left + (right-left)/2;
    LazyUpdate(segment, 2*index, left, mid, a, b, v);
    LazyUpdate(segment, 2*index+1, mid+1, right, a, b, v);
    for(int i=0; i<10; ++i) segment[index].value[i] = segment[2*index].value[i] + segment[2*index+1].value[i];
}

int primes[] = {2,3,5,7};

int LazyQuery(vector<node>& segment, int index, int left, int right, int a, int b)
{
    if(left > right || a > right || b < left) return 0;
    if(segment[index].lazy)
    {
        int C = segment[index].lazy;
        int temp[10];
        for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];
        for(int i=0; i<10; ++i) segment[index].value[(i+C)%10] = temp[i];
        if(left < right)
        {
            segment[2*index].lazy += segment[index].lazy;
            segment[2*index+1].lazy += segment[index].lazy;
        }
        segment[index].lazy = 0;
    }
    if(a <= left && b >= right)
    {
        int ans = 0;
        for(int i=0; i<4; ++i) ans += segment[index].value[primes[i]];
        return ans;
    }
    int mid = left + (right-left)/2;
    return LazyQuery(segment, 2*index, left, mid, a, b) + LazyQuery(segment, 2*index+1, mid+1, right, a, b);
}

const int MaxN = 100000+5;
int N;
vector<int> AdjList[MaxN];
int subtree[MaxN];
int parent[MaxN];
int depth[MaxN];
vector<int> chains[MaxN];
int chainID[MaxN];
int position[MaxN];
int firstv[MaxN];
int size[MaxN];
int cost[MaxN];
bool explored[MaxN];
vector<node> segment[MaxN];
int cid;

void DFS(int v, int d)
{
    subtree[v] = 1;
    depth[v] = d;
    for(vector<int>::iterator it=AdjList[v].begin(); it != AdjList[v].end(); ++it)
    {
        int o = *it;
        if(parent[o] == -1)
        {
            parent[o] = v;            
            DFS(o,d+1);
            subtree[v] += subtree[o];
        }
    }
}

void FloodFill(int v, int id)
{
    position[v] = chains[id].size();
    chains[id].push_back(v);
    firstv[v] = chains[id][0];
    chainID[v] = id;
    explored[v] = true;
    for(vector<int>::iterator it=AdjList[v].begin(); it != AdjList[v].end(); ++it)
    {
        int o = *it;
        if(parent[o] == v && 2*subtree[o] >= subtree[v])
        {
            FloodFill(o, id);
            break;
        }
    }
    size[v] = chains[id].size();
}

void HeavyLightDecomposition()
{
    for(int i=1; i<=N; ++i) parent[i] = -1;
    parent[1] = 0;
    DFS(1, 0);
    parent[1] = -1;
    for(int i=1; i<=N; ++i) explored[i] = false;
    cid = 0;
    for(int i=1; i<=N; ++i)
    {
        if(!explored[i] && ((i == 1) || (2*subtree[i] < subtree[parent[i]])))
        {
            FloodFill(i, cid);
            cid++;
        }
    }
    for(int i=0; i<cid; ++i)
    {
        vector<int> A;
        for(int j=0; j<chains[i].size(); ++j) A.push_back(cost[chains[i][j]]);
        BuildTree(segment[i], A);
    }
}

int LCA(int a, int b)
{
    while(chainID[a] != chainID[b])
    {
        if(depth[firstv[a]] > depth[firstv[b]]) a = parent[firstv[a]];
        else b = parent[firstv[b]];
    }
    return (depth[a] <= depth[b]) ? a : b;
}

int Dist(int lca, int a)
{
    int ans = 0;
    while(chainID[a] != chainID[lca])
    {
        ans += LazyQuery(segment[chainID[a]], 1, 0, size[a]-1, 0, position[a]);
        a = parent[firstv[a]];
    }
    ans += LazyQuery(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[a]);
    return ans;
}

int Query(int A, int B)
{
    int lca = LCA(A,B);
    return Dist(lca, A) + Dist(lca, B) - LazyQuery(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[lca]);
}

void Change(int lca, int a, int C)
{
    while(chainID[a] != chainID[lca])
    {
        LazyUpdate(segment[chainID[a]], 1, 0, size[a]-1, 0, position[a], C);
        a = parent[firstv[a]];
    }
    LazyUpdate(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[a], C);
}

void Update(int A, int B, int C)
{
    int lca = LCA(A,B);
    Change(lca, A, C);
    Change(lca, B, C);
    LazyUpdate(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[lca], 10 - C);
}

int main()
{
    //freopen("test.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    int u,v,T,A,B,C;
    int str;
    scanf("%d",&N);
    for(int i=1; i<=N; ++i) scanf("%d",&cost[i]);
    for(int i=1; i<N; ++i)
    {
        scanf("%d%d",&u,&v);
        AdjList[u].push_back(v);
        AdjList[v].push_back(u);
    }
    HeavyLightDecomposition();
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d%d",&str,&A,&B);
        if(str == 0) printf("%d\n", Query(A,B));
        else
        {
            scanf("%d",&C);
            Update(A,B,C%10);
        }
    }
    return 0;
}
