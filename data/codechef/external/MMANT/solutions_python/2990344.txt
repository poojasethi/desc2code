#include <string>
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <stack>
#include <queue>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <list>
#include <set>
#include <sstream>
#include <istream>
#include <fstream>
#include <climits>
#include <string.h>
#include <ctime>

#define infinity        200000000
#define pusb(a)         push_back(a)
#define SZ(val)         ((int)val.size())
#define mp(a,b)         make_pair(a,b)
#define fs              first
#define sc              second
#define sqr(a)          ((a)*(a))
#define pi              (2.0*acos(0.0))
#define ALL(a)          a.begin(),a.end()
#define memos(ARR,VAL)  memset(ARR,VAL,sizeof(ARR))
#define fileinput       freopen("input.txt","r",stdin)
#define fileoutput      freopen("output.txt","w",stdout)

const int SIZE=25;
const int SIZE2=25;

using namespace std;

typedef long long Bint;
typedef vector<int> Vint;
typedef vector<string> Vstring;
typedef pair<int,int> Prr;
typedef vector<Prr> Vprr;
typedef multiset<int> MSet;
typedef map<Prr,int> PM;
typedef map<Prr,int> ::iterator PMit;
typedef multiset<int>::iterator MSetit;
typedef priority_queue< int, Vint, greater<int> > MinPQ;
typedef priority_queue< int, Vint, less<int> > MaxPQ;

///int BigMod(Bint B,Bint P,Bint M){Bint R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return (int)R;}
///int cx[]= {0, 1, 1, 1, 0, -1, -1, -1};
///int cy[]= {1, 1, 0, -1, -1, -1, 0, 1};
int cx[]= {-1,0,0,1};
int cy[]= {0,-1,1,0};
///int hx[]={-2,-2,-1,-1,1,1,2,2};
///int hy[]={-1,1,-2,2,-2,2,-1,1};

char grid[SIZE][SIZE];
int level[SIZE][SIZE];
int dist[SIZE][SIZE],item,row,col;
int dp[10][10][(1<<9)+5];

vector<Prr> food;

int bfs(int sx, int sy);
void giveConnection(int ver);
int rec(int,int,int);

int main()
{
//    fileinput;
    int test,homeNode=0,res;
    char ch;
    scanf("%d",&test);

    for(int kase=1; kase<=test; kase++)
    {
        scanf("%d %d",&row,&col);
        for(int i=0; i<row; i++)
        {
            for(int j=0; j<col; j++)
            {
                scanf(" %c",&ch);
                if(ch=='H')
                {
                    food.pusb(mp(i,j));
                    homeNode = SZ(food)-1;
                }
                else if(ch=='F')
                    food.pusb(mp(i,j));

                grid[i][j]=ch;
            }
        }

        item = SZ(food);
        int foodFound=0;
        for(int i=0; i<item; i++)
        {
            foodFound = bfs(food[i].fs,food[i].sc);
            if(foodFound!=item)
                break;
            giveConnection(i);
        }

        if(foodFound!=item)
            printf("Case %d: -1\n",kase);
        else
        {
            memos(dp,-1);
            res = rec(homeNode,homeNode,0|(1<<homeNode));

            if(res&1)
                res = (res>>1)+1;
            else
                res = (res>>1);

            printf("Case %d: %d\n",kase,res);
        }
        food.clear();
    }
    return 0;
}

int rec(int f1,int f2,int mask)
{
    if(mask==(1<<item)-1) return dist[f1][f2];

    int &ret=dp[f1][f2][mask];
    if(ret!=-1) return ret;
    ret=infinity;

    for(int i=0; i<item; i++)
    {
        if((mask&(1<<i))==0)
        {
            ret = min(ret,rec(i,f2,mask|(1<<i)) + dist[f1][i]);
            ret = min(ret,rec(f1,i,mask|(1<<i)) + dist[f2][i]);
            for(int j=0; j<item; j++)
            {
                if(i!=j && (mask&(1<<j))==0)
                    ret = min(ret,(rec(i,j,(mask|(1<<i))|(1<<j)) + dist[f1][i] + dist[f2][j]));
            }
        }
    }
    return ret;
}

void giveConnection(int ver)
{
    int u,v,x,y;
    u = food[ver].fs;
    v = food[ver].sc;
    for(int i=0; i<item; i++)
    {
        x = food[i].fs;
        y = food[i].sc;
        dist[ver][i]=level[x][y]-level[u][v];
    }
    return ;
}

int bfs(int sx, int sy)
{
    memos(level,0);
    queue<int> Q;

    Q.push(sx);
    Q.push(sy);
    level[sx][sy]=1;

    int x,y,foodFound=1;

    while(!Q.empty())
    {
        sx = Q.front();
        Q.pop();
        sy = Q.front();
        Q.pop();

        for(int i=0; i<4; i++)
        {
            x = sx + cx[i];
            y = sy + cy[i];
            if(x>=0 && x<row && y>=0 && y<col && level[x][y]==0 && grid[x][y]!='#')
            {
                level[x][y]=level[sx][sy]+1;
                Q.push(x);
                Q.push(y);
                if(grid[x][y]=='F' || grid[x][y]=='H')
                    foodFound++;
            }
        }
    }
    return foodFound;
};
