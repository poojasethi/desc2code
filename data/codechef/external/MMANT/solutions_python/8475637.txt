#include<bits/stdc++.h>
using namespace std;
#define SIZE(X) ((int)(X.size()))//NOTES:SIZE(
#define LENGTH(X) ((int)(X.length()))//NOTES:LENGTH(
#define MP(X,Y) make_pair(X,Y)//NOTES:MP(
#define two(X) (1<<(X))//NOTES:two(
#define twoL(X) (((int64)(1))<<(X))//NOTES:twoL(
#define contain(S,X) (((S)&two(X))!=0)//NOTES:contain(
#define containL(S,X) (((S)&twoL(X))!=0)//NOTES:containL(
#define INF 1000000007
typedef pair<int,int> ipair;//NOTES:ipair
typedef long long int64;//NOTES:int64
 /*author flame-alchemist*/
int a[13][13][13][13];
int dp[257][9][9];
string s[13];
int n,r,c;
struct node{
	int x;
	int y;
};
vector<struct node> v;
int rec(int mask,int k1,int k2,int s1,int s2){
	int c=((1<<(n))-1);
//	cout<<v[k1].x<<" "<<v[k1].y<<endl;
	if((mask)==c){
		int mn=INF;
		for(int i=0;i<r;i++){
			for(int j=0;j<c;j++){
				if(a[v[k1].x][v[k1].y][i][j]!=-1&&a[v[k2].x][v[k2].y][i][j]!=-1){
					mn=min(mn,max(s1+a[v[k1].x][v[k1].y][i][j],s2+a[v[k2].x][v[k2].y][i][j]));
				}
			}
			
		}
	//	cout<<s1<<" "<<s2<<endl;
		return mn;
	}
	if(dp[mask][k1][k2]!=-1){
		return dp[mask][k1][k2];
	}
	int ans=INF;
	for(int i=0;i<n;i++){
		if(!(mask&(1<<i))){
			if(a[v[k1].x][v[k1].y][v[i].x][v[i].y]!=-1)
				ans=min(ans,rec(mask|(1<<i),i,k2,s1+a[v[k1].x][v[k1].y][v[i].x][v[i].y],s2));
			if(a[v[k2].x][v[k2].y][v[i].x][v[i].y]!=-1)
				ans=min(ans,rec(mask|(1<<i),k1,i,s1,s2+a[v[k2].x][v[k2].y][v[i].x][v[i].y]));
		}
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(!(mask&(1<<i))&&!(mask&(1<<j)&&i!=j)){
				if(a[v[k1].x][v[k1].y][v[i].x][v[i].y]!=-1&&a[v[k2].x][v[k2].y][v[j].x][v[j].y]!=-1)
					ans=min(ans,rec((mask|(1<<i))|(1<<j),i,j,s1+a[v[k1].x][v[k1].y][v[i].x][v[i].y],s2+a[v[k2].x][v[k2].y][v[j].x][v[j].y]));
			}
		}
	}
	return dp[mask][k1][k2]=ans;
}

int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};
	

int bfs(int x,int y){
	queue<pair<struct node,int> > q;
	struct node temp;
	bool vis[r][c];
	memset(vis,0,sizeof(vis));
	pair<struct node,int> temp1;
	temp1.first.x=x;
	temp1.first.y=y;
	temp1.second=0;
	q.push(temp1);
	vis[x][y] = true;
	a[x][y][x][y]=0;
	while(!q.empty()){
		temp1=q.front();
		q.pop();
		for(int i=0;i<4;i++){
			int k1=temp1.first.x+dx[i];
			int k2=temp1.first.y+dy[i];
		//	cout << k1 << " " << k2 << " " << temp1.first.x << " " << temp1.first.y << " ";
			if(k1<r&&k1>=0&& k2>=0&&k2<c&&vis[k1][k2]!=true){
			//	cout << k1 << " " << k2 << " " << temp1.first.x << " " << temp1.first.y << " " << s[k1][k2]<< " ";
				if(s[k1][k2] != '#') {
					pair<struct node,int> temp2;
					temp2.first.x=k1;
					temp2.first.y=k2;
					temp2.second=temp1.second+1;
					vis[k1][k2]=true;
					q.push(temp2);
					a[x][y][k1][k2]=temp2.second;
				}
			}
		//	cout << "\n";
		}
	//	vis[temp1.first.x][temp1.first.y] = true;
	}
	
	
	
	return 0;
}
int main(){
	int t;
	scanf("%d",&t);
	int z=1;
	while(t--){
		//int r,c;
		v.clear();
		scanf("%d%d",&r,&c);
		struct node temp,k;
		memset(dp,-1,sizeof(dp));
		memset(a,-1,sizeof(a));
		for(int i=0;i<r;i++){
			cin>>s[i];
			for(int j=0;j<c;j++){
				if(s[i][j]=='H'){
					temp.x=i;
					temp.y=j;
				}
				else if(s[i][j]=='F'){
					k.x=i;
					k.y=j;
					v.push_back(k);
				}
			}
		}
		for(int i=0;i<r;i++){
			for(int j=0;j<c;j++){
				if(s[i][j] != '#')
					bfs(i,j);
			}
		}
		
		v.push_back(temp);
		n=v.size();
		n--;
	/*	int ans=rec(0,n,n,0,0);
		*/
		vector<int> per;
		for(int i=0;i<n;i++){
			per.push_back(i);
		}
		int ans=INF;
		while(1){
			int path=0;
			k.x=temp.x;
			k.y=temp.y;
			for(int i=0;i<n;i++){
				if(a[k.x][k.y][v[per[i]].x][v[per[i]].y]!=-1)
					path+=a[k.x][k.y][v[per[i]].x][v[per[i]].y];
				else{
					path=INF;
					break;
				}
				k.x=v[per[i]].x;
				k.y=v[per[i]].y;
			}
			if(a[k.x][k.y][temp.x][temp.y]!=-1)
				path+=a[k.x][k.y][temp.x][temp.y];
			else{
				path=INF;
			}
			ans=min(ans,path);
			if(!next_permutation(per.begin(),per.end())){
				break;
			}
		}
		if(ans>=INF){
			cout<<"Case "<<z++<<": "<<"-1\n";
			continue;
		}
		int m=ans%2;
		ans=ans>>1;
		cout<<"Case "<<z++<<": "<<ans+m<<endl;
	}
	return 0;
}