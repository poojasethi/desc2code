#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>
#include <map>
#include <cstdio>
#include <queue>
using namespace std;

typedef pair<int,int> ii;
const int INF = 1000;

int R,C;
char G[15][15];
ii home;
vector<ii> food;
int D[10][15][15]; // D[0] is distance from home, D[i] is the (i-1)th food...

int moves [4][2] = { {1,0}, {-1,0}, {0,1}, {0,-1} };

void bfs(int s, int si, int sj){
    for (int i = 0; i < R; i++){
        for (int j = 0; j < C; j++){
            D[s][i][j] = INF;
        }
    }
    D[s][si][sj] = 0;
    queue<ii> nodes;
    nodes.push(ii(si,sj));
    while(!nodes.empty()){
        ii n = nodes.front();
        //cout << "Visiting " << n.first << ' ' << n.second << ' ' << G[n.first][n.second] << " with distance : " << D[s][n.first][n.second] << endl;
        nodes.pop();
        int d = D[s][n.first][n.second];
        for (int m = 0; m < 4; m++){
            int di = moves[m][0], dj = moves[m][1];
            int i = n.first + di, j = n.second + dj;
            if(i < 0 or i >= R or j < 0 or j >= C)
               continue;
            if(G[i][j] == '#' or D[s][i][j] < INF)
                continue;
            D[s][i][j] = d+1;
            nodes.push(ii(i,j));
        }
    }
}

int totaltime(const vector<int>& fs, int s, int e){ // fs[s...e-1]
    if(s == e){
        return 0;
    }
    // visit from home to each of the foods in order
    // return time on which last food is reached
    int ans = 0;
    ans += D[0][food[fs[s]].first][food[fs[s]].second];
    for (int i = s; i+1 < e; i++){
        // go from i to i+1
        ans += D[fs[i]+1][food[fs[i+1]].first][food[fs[i+1]].second];
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    int T;
    cin >> T;
    for (int q = 1; q <= T; q++){

        food.clear();
        cin >> R >> C;
        for (int i = 0; i < R; i++){
            for (int j = 0; j < C; j++){
                cin >> G[i][j];
                if(G[i][j] == 'H')
                    home = ii(i,j);
                if(G[i][j] == 'F')
                    food.push_back(ii(i,j));
            }
        }
        
        bfs(0,home.first,home.second);
        for (int i = 0; i < food.size(); i++){
            bfs(i+1,food[i].first,food[i].second);
            // printf("Distance from food %d: %d = %d\n",
            //        i,D[0][food[i].first][food[i].second],
            //        D[i+1][home.first][home.second]);
        }
        int besttime = INF;
        // if food empty?
        vector<int> iota;
        for (int i = 0; i < food.size(); i++){
            iota.push_back(i);
        }
        do{
            // cout << endl << totaltime(iota,0,iota.size()) << endl;
            int thistime;
            for (int j = 0; j <= food.size(); j++){ // [0,j) for Mr, [j,f) for Mrs

                // for (int i = 0; i < j; i++){
                //     cout << iota[i];
                // }
                // cout << " : ";

                // for (int i = j; i < iota.size(); i++){
                //     cout << iota[i];
                // }
                // cout << endl;
                int t1 = totaltime(iota,0,j);
                int t2 = totaltime(iota,j,iota.size());
                int a = min(t1,t2), b = max(t1,t2);
                int d; 
                int k = iota.size()-1;
                if(j == 0){
                    d = D[0][food[iota[k]].first][food[iota[k]].second];
                }
                else if(j == iota.size()){
                    d = D[0][food[iota[k]].first][food[iota[k]].second];
                }
                else {
                    d = D[iota[j-1]+1][food[iota[k]].first][food[iota[k]].second];
                }
                if(b > INF/2)
                    continue;
                int thistime = b >= a+d ? b : b + ((d-b+a+1)/2);
                besttime = min(thistime,besttime);
                // cout << d << ' ' << t1 << ' ' << t2  << ' ' << thistime << endl;
            }
        }while(next_permutation(iota.begin(),iota.end()));

        cout << "Case " << q << ": ";
        if(besttime < (INF/2))
            cout << besttime << '\n';
        else
            cout << -1 << '\n';

    }

    

    
    return 0;
}

