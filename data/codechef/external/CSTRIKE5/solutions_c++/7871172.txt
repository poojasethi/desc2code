#include<bits/stdc++.h>

using namespace std;

#define ll long long int
#define NN 200005
#define pb push_back
#define mp make_pair
#define INF (((ll)1000000000) * ((ll)1000000000))
#define inf 0x7fffffff
#define inff 100000
#define ff first
#define ss second
#define MOD 1000000007
#define fast cin.sync_with_stdio(0);cin.tie(0)
#define rep(i,N) for(int i=0;i<N;i++)
#define frep(i,a,b) for(int i=a;i<=b;i++)
#define pii pair<int,int>
#define fill(A,v) memset(A,v,sizeof(A))
#define setbits(x) __builtin_popcount(x)
#define print(A,j,k) for(int ii=j;ii<=k;ii++)cout<<A[ii]<<" ";cout<<"\n"
#define all(x) (x).begin(), (x).end()
#define gcd __gcd

ll cnt[NN],ans[NN];
vector<pii > V[NN],FW[NN],REV[NN];
int vis[NN];
int n;

void dfs(int node) {
	//cout<<"node "<<node<<"\n";
	vis[node]=1;
	rep(i,V[node].size()) 
		if(vis[V[node][i].ff]==0) {
			FW[node].pb(mp(V[node][i].ff,V[node][i].ss));
			REV[V[node][i].ff].pb(mp(node,V[node][i].ss));
			dfs(V[node][i].ff);
		}
}

void forward(int node) {
	vis[node]=1;
	cnt[node]=1;
	rep(i,FW[node].size()) {
		int v=FW[node][i].ff;
		ll w=FW[node][i].ss;
		if(vis[v]==0) {
			forward(v);
			ans[node]+=ans[v]+w*cnt[v];
			cnt[node]+=cnt[v];
		}
	}
}

void reverse(int node) {
	vis[node]=1;
	cnt[node]=1;
	rep(i,FW[node].size()) {
		int v=FW[node][i].ff;
		//cout<<"node "<<v<<"\n";
		ll w=FW[node][i].ss;
		if(vis[v]==0) {
			ans[v] = ans[node]+(n-cnt[v])*w-cnt[v]*w;
			reverse(v);
		}
	}
}

int main(int argc, char const *argv[])
{

	fast;

	int t;cin>>t;while(t--) {

	cin>>n;

	frep(i,1,n) {
		FW[i].clear();
		V[i].clear();
	}

	rep(i,n-1) {
		int a,b,c;
		cin>>a>>b>>c;
		V[a].pb(mp(b,c));
		V[b].pb(mp(a,c));
	}
	for(int i=1;i<=n;i++) {
		ans[i]=0;
		vis[i]=0;
	}
	dfs(1);
	for(int i=1;i<=n;i++)
		vis[i]=0;
	for(int i=1;i<=n;i++)
		if(vis[i]==0)
			forward(i);
	//print(ans,1,n);
	for(int i=1;i<=n;i++)
		vis[i]=0;
	for(int i=1;i<=n;i++)
		if(vis[i]==0)
			reverse(i);
	//print(ans,1,n);
	frep(i,1,n)
		cout<<ans[i]<<"\n";

	}

	return 0;
}
