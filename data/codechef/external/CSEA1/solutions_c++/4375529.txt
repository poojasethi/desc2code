#include<bits/stdc++.h>
using namespace std;

#define sc( x ) scanf( "%d" , &x )
#define REP( i , n ) for( int i = 0 ; i < n ; ++i )
#define clr( t , val ) memset( t , val , sizeof( t ) )

#define pb push_back
#define all( v ) v.begin() , v.end()
#define SZ( v ) ((int)(v).size())

#define mp make_pair
#define fi first
#define se second

#define N 24
#define EPS (1e-70)
#define test puts( "************************test*********************" );

typedef long double ld;
typedef long long ll;

ld root2 = sqrt( 2.0 );
bool equals( const ld &x , const ld &y ){ return abs( x - y ) < EPS;}
bool Less( const ld &x , const ld &y ){ return EPS < y - x;}
ll maxi = 0;
ll mini = LLONG_MAX;
struct Complex{
	ll re , im;
	Complex(){ re = im = 0;}
	Complex( ll re , ll im ) : re( re ) , im( im ) { (mini = min( mini , re ) );(maxi = max( maxi , re ) );/*cout <<(maxi = max( maxi , im ) )<< endl;*/ }
	Complex mult(){ return Complex( im << 1LL , re );}
	ld getVal(){ return (ld) re + (ld) im * root2; }
	void impr(){ cout << re << " + " << im << " i " << endl;}
};
bool operator == ( const Complex &a , const Complex &b ){ return a.im == b.im && a.re == b.re;}
bool operator < ( const Complex &a , const Complex &b ){
	if( a.re == b.re ) return a.im < b.im;
	return a.re < b.re;
}
Complex operator - ( const Complex &a , const Complex &b ){ return Complex( a.re - b.re , a.im - b.im );}
Complex operator + ( const Complex &a , const Complex &b ){ return Complex( a.re + b.re , a.im + b.im );}
struct Point{
	Complex x , y;
	Point(){}
	Point( Complex x , Complex y ) : x( x ) , y( y ) {}
	Point mult(){ return Point( x.mult() , y.mult() ); }
};
Point operator - ( const Point &A , const Point &B ){ return Point( A.x - B.x , A.y - B.y );}
Point operator + ( const Point &A , const Point &B ){ return Point( A.x + B.x , A.y + B.y );}
bool operator == (const Point &A, const Point &B ){
    return A.x == B.x && A.y == B.y;
}
bool operator < ( const Point &A , const Point &B ){
    if( A.x == B.x ) return A.y < B.y ;
    return A.x < B.x;
}

int limit;
Point pt;
ld ans;
Point dir[ 10 ];
ld x , y;
inline ll hash( const pair< Point , int > &p ){
	ll ans = 0LL;
	ans = ans * 231LL + p.fi.x.im + 110LL;
	ans = ans * 231LL + p.fi.y.im + 110LL;
	ans = ans * 461LL + p.fi.x.re + 210LL;
	ans = ans * 461LL + p.fi.y.re + 210LL;
	ans = ans * 25LL + p.se;
	return ans;
}
//map< ll , int > DIST;
map< pair< Point , int > , int > DIST;
void bfs(){
	queue< pair< Point , int > >Q;
	//map< pair< Point , int > , int > DIST;
	//map< ll , int > DIST;
	Point P;
	int k = 0;
	Q.push( mp( P , k ) );
	//DIST[ hash( mp( P , k ) ) ] = 0;
	DIST[ ( mp( P , k ) ) ] = 0;
	ans = min( ans , (ld)hypot( P.x.getVal() - x , P.y.getVal() - y ) );
	while( !Q.empty() ){
		pair< Point , int > U = Q.front() , V ; Q.pop();
		P = U.fi; k = U.se;
		ans = min( ans , (ld)hypot( P.x.getVal() - x , P.y.getVal() - y ) );
		if( DIST[ U ] == limit ) continue;
		//if( DIST[ hash( U ) ] == limit ) continue;
		
		/*
		Point nP = P ;
		int nk = ( k == 7 ? 0 : (k + 1) );
		V = mp( nP , nk );
		if( !DIST.count( hash( V ) ) && DIST[ hash( V ) ] < limit ){
			Q.push( V );
			DIST[ hash( V ) ] = DIST[ hash( U ) ] + 1;
		}
		nP = P + dir[ k ];
		nk = k;
		V = mp( nP , nk );
		if( !DIST.count( hash( V ) ) && DIST[ hash( V ) ] < limit ){
			Q.push( V );
			DIST[ hash( V ) ] = DIST[ hash( U ) ] + 1;
		}
		*/
		
		Point nP = P ;
		int nk = ( k == 7 ? 0 : (k + 1) );
		V = mp( nP , nk );
		if( !DIST.count( V )  ){
			Q.push( V );
			DIST[ ( V ) ] = DIST[ ( U ) ] + 1;
		}
		nP = P + dir[ k ];
		nk = k;
		V = mp( nP , nk );
		if( !DIST.count( ( V ) )  ){
			Q.push( V );
			DIST[ ( V ) ] = DIST[ ( U ) ] + 1;
		}
		
	}
	//printf( "%d\n" , SZ( DIST ) );
}
int main(){
	dir[ 0 ] = Point( Complex( 10 , 0 ) , Complex( 0 , 0 ) );
	dir[ 1 ] = Point( Complex( 0 , 5 ) , Complex( 0 , -5 ) );
	for( int i = 2 ; i < 8 ; ++i ) dir[ i ] = dir[ i - 1 ].mult() - dir[ i - 2 ];
	limit = 24;
	bfs();
	vector< vector< Point > > vec( 25 );
	for( map< pair< Point , int > , int > :: iterator it = DIST.begin() ; it != DIST.end() ; ++it ){
		Point P = (it->fi).fi;
		vec[ it->se ].pb( P );
	}
	for( int i = 1 ; i <= limit ; ++i )
		REP( j , SZ( vec[ i - 1 ] ) ) vec[ i ].pb( vec[ i - 1 ][ j ] );
	int cases , pos;

	cin >> cases;
	REP( tc , cases ){
		cin >> pos >> x >> y;
		ans = 1e100;
		limit = pos;
		//bfs();
		
		REP( i , SZ( vec[ pos ] ) ){
			Point P = vec[ pos ][ i ];
			ans = min( ans , (ld)hypot( P.x.getVal() - x , P.y.getVal() - y ) );
		}
		
		printf( "%.6f\n" , (double) ans );
	}

}
