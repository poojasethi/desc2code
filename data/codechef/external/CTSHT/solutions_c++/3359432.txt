//shortest path for unweighted graph using BFS
#include <iostream>
#include<vector>
#include<list>
#include<cstdio>
#include<cstring>
#define pb push_back
#define gc getchar_unlocked
#define pc putchar_unlocked
using namespace std;
inline int scan()
{
	register int n=0,c=gc();
	while(c<'0' || c>'9')c=gc();
	while(c<='9' && c>='0')n=(n<<3)+(n<<1)+c-'0',c=gc();
	return n;
}
int main() {
	int t,i,n,q,j,front,rear,x,v,l;
	t=scan();
	while(t--)
	{
		n=scan();
		vector<int> adj[201];
		int path[201][201];
		memset(path,0,sizeof(int)*201*201);
		//for(i=0;i<201;i++)for(j=0;j<201;j++)printf("%d,",path[i][j]);
		for(i=0;i<n;i++)
			for(j=0;j<n+1;j++)
				if(gc()=='Y')adj[i].pb(j);
		for(i=0;i<n;i++)
		{
			int visited[201]={0};
			visited[i]=1;
			path[i][i]=0;
			list<int> queue;
			queue.pb(i);
			while(!queue.empty())
			{	
				x=queue.front();
				//printf("looking out for %d\n",x);
				queue.pop_front();
				l=adj[x].size();
				for(j=0;j<l;j++)
				{	v=adj[x][j];
					if(!visited[v])
					{
						visited[v]=1;
						queue.pb(v);
						path[v][i]=path[i][v]=1+path[i][x];
						//printf("path between %d %d via %d is:%d\n",i,v,x,path[i][v]);
					}
				}
			}
		}
		q=scan();
		//for(i=0;i<n;i++){for(j=0;j<adj[i].size();j++)printf("%d ",adj[i][j]);pc('\n');}
		for(i=0;i<q;i++)
			printf("%d\n",path[scan()][scan()]);
	}
	return 0;
}