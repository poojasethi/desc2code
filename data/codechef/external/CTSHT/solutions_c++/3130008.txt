// FLOYD WARSHALL ALGORITHM
#include<iostream>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<stack>
#include<string>
#include<algorithm>
#include<functional>
#include<iomanip>
#include<cstdio>
#include<cmath>
#include<limits.h>
#include<cstring>
#include<cstdlib>
#include<cfloat>
#include<cassert>
#define maxm(a,b) a>b?a:b;
#define minm(a,b) a<b?a:b;
using namespace std;
//M lazy ;)
typedef long long ll;
typedef vector <int> vi;
typedef pair< int ,int > pii;
typedef istringstream iss;
typedef ostringstream oss;
typedef map<int,int> mp;
#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define sz size()
#define ln length()
#define rep(i,n) for(int i=0;i<n;i++)
#define fu(i,a,n) for(int i=a;i<=n;i++)
#define fd(i,n,a) for(int i=n;i>=a;i--)
#define all(a)  a.begin(),a.end()
#define ESP (1e-9)
#define gi(n) scanf("%d",&n)
#define gl(n) cin >> n
#define pi(n) printf("%d",n)
#define pl(n) cout << n
#define ps printf(" ")
#define pn printf("\n")
#define dg(n,s); printf("%s %d",s,n)
#define imax numeric_limits<int>::max()
#define imin numeric_limits<int>::min()
#define lmax numeric_limits<ll>::max()
#define lmin numeric_limits<ll>::min()
#define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it)
#define MOD 1000000007
#define MAX 1000001
#define cases() int t; cin>>t; while(t--)
// fast input function
#define getcx getchar_unlocked
// fast input function
#ifdef ONLINE_JUDGE
 inline void inp( int &n )
 {
    n=0;
    int ch=getcx();int sign=1;
    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}

    while(  ch >= '0' && ch <= '9' )
            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
    n=n*sign;
  }
#else
inline void inp(int &n){
 cin>>n;
}
#endif
class graph{
 int V;
 int **adj;
 public:
 graph(int V);
 void FloydWarshall();
 void addedge(int u,int v,int w);// for directed graph
};
// constructor
graph::graph(int V){
  this->V=V;
  adj=(int**)malloc(V*sizeof(*adj));
  int i;
  rep(i,V)
  adj[i]=(int*)malloc(V*sizeof(int));
};
void graph::addedge(int u,int v,int w){
  adj[u][v]=w;
}
int **dist;
void graph::FloydWarshall(){

 dist=(int**)malloc(V*sizeof(*dist));
 int i;
 rep(i,V)
  dist[i]=(int*)malloc(V*sizeof(int));
 for(i=0;i<V;i++)
  for(int j=0;j<V;j++)
    dist[i][j]=adj[i][j];


for(int k=0;k<V;k++)
  for(i=0;i<V;i++){
		for(int j=0;j<V;j++){
			if(i==j)
			 dist[i][j]=0;
			else if(dist[i][k]!=-1&&dist[k][j]!=-1&&dist[i][j]==-1)
			  dist[i][j]=dist[i][k]+dist[k][j];
			else if((dist[i][k]+dist[k][j])<dist[i][j]&&dist[i][k]!=-1&&dist[k][j]!=-1)
              dist[i][j]=dist[i][k]+dist[k][j];
		}
  }
  /*
  for(i=0;i<V;i++){
   for(int j=0;j<V;j++)
   cout<<dist[i][j]<<" ";
   cout<<endl;
 }*/
}
int main(){
 int t;
 inp(t);
 while(t--){
   int v,q;
   inp(v);// input vertices
   graph g(v);
   int i,j;
   char str[210];
   
   rep(i,v){
		cin>>str;
	 rep(j,v){

	   if(str[j]=='Y')
	   g.addedge(i,j,1);
	   else
	   g.addedge(i,j,-1);
	 }
	}
  g.FloydWarshall();
  inp(q);
  while(q--){
   int u,v;
   inp(u);
   inp(v);
   cout<<dist[u][v]<<endl;
  }
  
  free(dist);
 }
 return 0;
}
