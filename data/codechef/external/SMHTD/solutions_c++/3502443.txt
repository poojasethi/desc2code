/* The basic idea is to set an array of max size to infinity
*  and then search for any no in it if using bunary search and
   it and the end of the right index.
   This gives us the O(log n) time.
   DO this for all array elements only if (x-i >= 0)
   This gives us the O(N) time.
*/
#include<iostream>
#include<vector>
#include<cstdlib>
#include<cstdio>
using namespace std;

#define max 1000005
#define inf 200000000

typedef long long ll;
int a[max];
int longest;                //TO help us keep track of the longest subsequence found
void bS(ll key){
	int left = 1,right = longest;
	while(left <= right){
		int mid = (left + right)/2;
		if(a[mid] <= key)
			left = mid + 1;
		else
			right = mid - 1;
	}
	a[++right] = key;
	if(longest < right)
		longest = right ;
}

int main(){
	int n;              // No of elements in the prob array
	scanf("%d",&n);
	longest = 0;
	for(int i =0;i <= n;i++)
		a[i] = inf;
	for(int i = 1;i <= n; i++){
		int x;
		scanf("%d",&x);
		if((x -= i) >= 0)
			bS(x);
	}
	printf("%d\n",n-longest);
	return 0;
}
