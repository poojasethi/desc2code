#include<algorithm>
#include<iostream>
#include<cstdio>
#include<vector>
#include<fstream>
#include<iomanip>
#include<bitset>
#include<deque>
#include<queue>
#include<string>
#include<map>
#include<cstring>
#include<sstream>
#include<cmath>
#include<cassert>
using namespace std;
#define MOD 10000

int divisors[500001];

int fpow(int a, int b)
{
    int x = 1, y = a;
    while (b > 0)
    {
        if (b%2 == 1)
        {
            x = x*y;
            x %= MOD;
        }
        y = y*y;
        y %= MOD;
        b >>= 1;
    }
    return x;
}

int main()
{
	memset(divisors, 0, sizeof divisors);
	for (int i = 1; i <= 500000; i++)
		for (int j = i; j <= 500000; j += i)
			divisors[j]++;
	int T, N;
	scanf("%d", &T);
	for (int t = 0; t < T; t++)
	{
		scanf("%d", &N);
		if (N == 1)
		{
			printf("1\n");
			continue;
		}
		int fac = divisors[N]-2;
		bool exceed = 0;
		if ((fac&1) == 0)
		{
			int ans = 1;
			int r = (fac>>1);
			if (N >= MOD && r >= 1)
				exceed = 1;
			else
			{
				for (int i = 0; i < r; i++)
				{
					ans = ans*N;
					if (ans >= MOD)
					{
						exceed = 1;
						break;
					}
				}
			}
			if (exceed)
				printf("%04d\n", fpow(N%MOD, r));
			else
				printf("%d\n", ans);
		}
		else
		{
			int ans = (int)sqrt(N);
			int anss = ans;
			int r = ((fac-1)>>1);
			if (N >= MOD && r >= 1)
				exceed = 1;
			else
			{
				for (int i = 0; i < r; i++)
				{
					ans = ans*N;
					if (ans >= MOD)
					{
						exceed = 1;
						break;
					}
				}
			}
			if (exceed)
				printf("%04d\n", (anss*fpow(N%MOD, r))%MOD);
			else
				printf("%d\n", ans);
		}
	}
	return 0;
}
