#include <bits/stdc++.h>
#define ll int
#define s(a) scanf("%d",&a)
#define f first
#define sc second
#define pb push_back
#define mp make_pair
#define VALUETYPE long long int
#define inf 10e16
#define EVEN(x) ((x%2)==0)
#define ODD(x) ((x%2)==1)

using namespace std;

ll tree[2000001];
ll lft[500001];
ll rgt[500001];
ll a[500001];
vector<pair<ll,ll> >v[500001];
vector<pair<ll,ll> >u[500001];

ll construct(ll l,ll r,ll ind)
{
    if(l>r) return 0;
    if(l==r) {
        tree[ind]=0;
        return 0;
    }
    ll mid=(l+r)/2;
    tree[ind]=max(construct(l,mid,2*ind),construct(mid+1,r,2*ind+1));
    return tree[ind];
}

ll query(ll l,ll r,ll ind,ll x,ll y)
{
    if(l>r) return 0;
    if(x>r || y<l) return 0;
    if(x<=l && r<=y) return tree[ind];
    ll mid=(l+r)/2;
    return max(query(l,mid,2*ind,x,y),query(mid+1,r,2*ind+1,x,y));
}

ll xxx;

void yoman()
{
    ll ind=xxx;
    while(ind>=1) {
        tree[ind]=max(tree[2*ind],tree[2*ind+1]);
        ind/=2;
    }
}

void update(ll l,ll r,ll ind,ll x,ll y) //change a[x]=y
{
    if(l>r) return;
    if(l>x || r<x) return;
    if(l==r) {
        tree[ind]=y;
        xxx = ind/2;
        return;
    }
    ll mid=(l+r)/2;
    update(l,mid,2*ind,x,y);
    update(mid+1,r,2*ind+1,x,y);
}

bool cmp(pair<ll,ll>x,pair<ll,ll>y)
{
    if(x.f < y.f) return true;
    else if(x.f == y.f) {
        if(x.sc > y.sc) return true;
        else return false;
    }
    else return false;
}

int main()
{
    ll t,n,i,j,k,l,w,ww,x,y,z;
    s(n);
    for(i=1;i<=n;i++) s(a[i]);
    for(i=1;i<=n;i++) {
        w = query(1,n,1,1,a[i]-1);
        lft[i]=w;
        update(1,n,1,a[i],w+1);
        yoman();
    }
    construct(1,n,1);
    for(i=n;i>=1;i--) {
        w = query(1,n,1,a[i]+1,n);
        rgt[i]=w;
        update(1,n,1,a[i],w+1);
        yoman();
    }
    for(i=1;i<=n;i++) {
        v[lft[i]+1].pb(mp(a[i],lft[i]+rgt[i]+1));
    }
    for(i=1;i<=n;i++) {
        if(v[i].size()>0) sort(v[i].begin(),v[i].end(),cmp);
    }
    /////////////////////cleaning///////////////////////

    for(i=1;i<=n;i++) {
        if(v[i].size()==0) continue;
        u[i].pb(v[i][0]);
        x = v[i][0].f;
        y = v[i][0].sc;
        for(j=1;j<v[i].size();j++) {
            if(x == v[i][j].f || y >= v[i][j].sc) {
                continue;
            }
            else {
                u[i].pb(v[i][j]);
                x = v[i][j].f;
                y = v[i][j].sc;
            }
        }
    }

    ////////////////////cleaning ends///////////////////

   /* for(i=1;i<=n;i++) {
        cout<<i<<" : ";
        for(j=0;j<u[i].size();j++) {
            cout<<u[i][j].f<<","<<u[i][j].sc<<"  ";
        }
        cout<<endl;
    }*/

    s(t);
    while(t--) {
        s(x);s(y);
        if(u[y].size()==0) {
            printf("Not Possible\n");
            continue;
        }
        if(u[y][u[y].size()-1].sc < x) {
            printf("Not Possible\n");
            continue;
        }
        ll low = 0;
        ll high = u[y].size()-1;
        ll mid;
        while(low < high) {
            mid = (low+high)/2;
            if(u[y][mid].sc >= x) {
                high = mid;
            }
            else {
                low = mid+1;
            }
        }
        printf("%d\n",u[y][low].f);
    }

    return 0;
}
