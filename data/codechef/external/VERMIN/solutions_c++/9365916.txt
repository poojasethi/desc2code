#include <iostream>
#include <bits/stdc++.h>
using namespace std;

using VI = vector<int>;
using VVI = vector<VI>;
using ll = long long;

//No compta nodes aillats

struct Edge {
  int u, v; //Fill this
  int bicomp; //Index of the biconnected component (don't fill this)
};

VI bic_vertex; //One entry per biconnected component: the vertex representant
VI num, low; //Initialize to -1
int act, bicos; //Put this to zero for every testcase
stack<int> S;
VI coun;

void dfs(int u, VVI& adj, vector<Edge>& E, int p = -1) {
  num[u] = low[u] = act++;
  for (int i = 0; i < int(adj[u].size()); ++i) {
    int v = E[adj[u][i]].v;
    if (v == u) v = E[adj[u][i]].u;
    if (num[v] == -1) {
      int size = S.size();
      S.push(adj[u][i]);
      dfs(v, adj, E, u);
      low[u] = min(low[u], low[v]);
      if (low[v] >= num[u]) {
        while (int(S.size()) != size) {
          E[S.top()].bicomp = bicos;
          ++coun[bicos];
          S.pop();
        }
        bic_vertex.push_back(u);
        ++bicos;
      }
    }
    else if (v != p and num[v] < num[u]) {
      S.push(adj[u][i]);
      low[u] = min(low[u], num[v]);
    }
  }
}

int dfs2(int u, VVI& adj) {
  num[u] = 1;
  int r = 1;
  for (int v : adj[u]) {
    if (num[v] == -1) r += dfs2(v, adj);
  }
  return r;
}

VVI d;
// sqrt(100000) = 316.
const int mm = 450;

int din(int c, int t, int g) {
  int &r = d[c][t];
  if (r != -1) return r;

  if (c == g) return r = 0;

  r = 2000000;
  for (int i = 1; i <= mm; ++i) {
    int l = c + i * (i + 1) / 2;
    if (l > g) break;
    int cost = i + 1;
    if (t == 1) ++cost;
    if (t == 2) --cost;
    r = min(r, cost + din(l, min(t + 1, 3), g));
  }
  return r;
}

int main() {
  int n, m, M;
  cin >> n >> m >> M;
  vector<Edge> E(m);
  VVI adj(n);
  for (int i = 0; i < m; ++i) {
    cin >> E[i].u >> E[i].v;
    --E[i].u; --E[i].v;
    adj[E[i].u].push_back(i);
    adj[E[i].v].push_back(i);
  }

  //cerr << "Biconnected components" << endl;
  num = low = VI(n, -1);
  act = bicos = 0;
  coun = VI(n);
  for (int i = 0; i < n; ++i) if (num[i] == -1) dfs(i, adj, E);
  //for (const Edge& e : E) cerr << e.u << " " << e.v << " " << e.bicomp << endl;
  
  //cerr << "Copy G" << endl;
  adj = VVI(n);
  for (const Edge& e : E) {
    if (coun[e.bicomp] == 1) {
      adj[e.u].push_back(e.v);
      adj[e.v].push_back(e.u);
    }
  }

  //cerr << "Compute k:" << endl;
  ll k = 0;
  num = VI(n, -1);
  for (int i = 0; i < n; ++i) {
    if (num[i] == -1) {
      int c = dfs2(i, adj);
      k += ll(c) * ll(c - 1) / 2;
    }
  }
  //cerr << k << endl;

  if (k < M) {
    d = VVI(k + 2, VI(4, -1));
    cout << din(0, 0, k + 1) << endl;
  } else cout << -1 << endl;
}
