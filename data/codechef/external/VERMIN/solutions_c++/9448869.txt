#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100000 + 10;

int vs[MAXN], dp[MAXN];
vector<int> G[MAXN], V[MAXN];
int n, m, M;

class Articulation {
public:
  typedef pair<int,int> PII;
  static const int SIZE = 100005; // 最大结点个数
  int cnt;  // 对于旧版编译器，将上面cc[SIZE]改成vector的形式
  // 传入结点个数n及各结点的出边e[]，返回双连通分量的个数cnt
  int gao(int n, const vector<int> e[]){
    memset(tag,use=0,sizeof(tag));
    memset(low,cnt=0,sizeof(low));
    for(int i=0;i<n;i++) if(!tag[i]) dfs(i,1,e);
    return cnt;
  }
private:
  int tag[SIZE],low[SIZE],dot[SIZE],use;
  void dfs(int x, int dep, const vector<int> e[]){
    int src=0,out=1<dep;
    dot[use++]=x;
    tag[x]=low[x]=dep;
    for(size_t i=0;i<e[x].size();i++){
      int y=e[x][i];
      if(!tag[y]){
        dfs(y,dep+1,e);
        low[x]=min(low[x],low[y]);
        if(low[y]> tag[x]) {
          V[x].push_back(y);
          V[y].push_back(x);
        }
        if(low[y]>=tag[x]){
          ++out; while(dot[--use]!=y);
        }
      }else if(tag[y]!=tag[x]-1 || src++){
        low[x]=min(low[x],tag[y]);
      }
    }
  }
} art;

void dfs(int u, int &c) {
  vs[u] = 1; ++c;
  for (auto &v: V[u]) {
    if (!vs[v]) dfs(v, c);
  }
}

int main() {
  scanf("%d%d%d", &n, &m, &M);
  for (int i = 0, u, v; i < m; ++i) {
    scanf("%d%d", &u, &v); --u, --v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  art.gao(n, G);
  long long K = 1;
  for (int i = 0; i < n; ++i) if (!vs[i]) {
    int c = 0; dfs(i, c);
    K += 1ll * c * (c - 1) / 2;
  }
  if (K <= M) {
    for (int i = 1; i <= K; ++i) dp[i] = 1e9;
    for (int i = 2; i <= K + 1; ++i) {
      int x = i * (i - 1) / 2; if (x > K) break;
      if (x == K) {printf("%d\n", i); return 0;}
      for (int j = 2; j <= i; ++j) {
        int y = j * (j - 1) / 2;
        if (x + y > K) break;
        dp[x + y] = min(dp[x + y], i + j + 1);
      }
    }
    if (dp[K] != 1e9) {printf("%d\n", dp[K]); return 0;}
    for (int i = 1; i <= K; ++i) {
      for (int c = 2; ; ++c) {
        int x = c * (c - 1) / 2;
        if (x > i) break;
        dp[i] = min(dp[i], dp[i - x] + c);
      }
    }
    printf("%d\n", dp[K]);
  } else puts("-1");
}
