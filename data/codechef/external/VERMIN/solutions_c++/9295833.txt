#include <bits/stdc++.h>
using namespace std;

const int MAX = 100005;

vector < int > edgeList[MAX], bridgeTree[MAX];
int A[MAX], B[MAX], V[MAX], D[MAX], L[MAX], N, M, Q, cur = 0;
pair < int, int > DP[MAX];
bool isBridge[MAX];

inline void dfs(int u, int p){
	D[u] = L[u] = ++cur;
	V[u] = 1;
	for(int i = 0 ; i < edgeList[u].size() ; i++){
		int v = A[edgeList[u][i]] + B[edgeList[u][i]] - u;
		if(v == p) continue;
		if(V[v] == 0){ // An edge below the current node
			dfs(v, u);
			L[u] = min(L[u], L[v]);
			if(L[v] > D[u]) isBridge[edgeList[u][i]] = true;
		}
		else L[u] = min(L[u], D[v]); // Back edge
	}
}

inline int dfs2(int u, int p){
	int x = 1;
	V[u] = 1;
	for(int i = 0 ; i < bridgeTree[u].size() ; i++){
		int v = bridgeTree[u][i];
		if(v == p) continue;
		x += dfs2(v, u);
	}
	return x;
}

inline long long choose(int x){
	long long res = ( (x)*1LL*(x-1) ) / 2;
	return res;
}

int main(){
		
	scanf("%d %d %d\n", &N, &M, &Q);
	for(int i = 1 ; i <= M ; i++){
		scanf("%d %d\n", &A[i], &B[i]);
		edgeList[A[i]].push_back(i);
		edgeList[B[i]].push_back(i);
	}

	for(int i = 1 ; i <= N ; i++){
		if(V[i] == 0)
			dfs(i, -1);
	}

	for(int i = 1 ; i <= M ; i++){
		if(isBridge[i]){
			bridgeTree[A[i]].push_back(B[i]);
			bridgeTree[B[i]].push_back(A[i]);
		}
	}

	for(int i = 1 ; i <= N ; i++) V[i] = 0;
	
	long long K = 0;
	for(int i = 1 ; i <= N ; i++){
		if(V[i] == 0) K += choose(dfs2(i, -1));
	}

	if(K >= Q){
		printf("-1\n");
		return 0;
	}

	++K;

	DP[0].first = DP[0].second = 0;
	DP[1].first = 2, DP[1].second = 1;
	
	for(int i = 2; i <= K ; i++){
		DP[i].first = 1e9;
		for(int j = 2 ; ; j++){
			long long p = choose(j);
			if(i >= p && (DP[i - p].first + j < DP[i].first) ){
				DP[i].first  = DP[i - p].first  + j;
				DP[i].second = DP[i - p].second + 1;
			}
			if(i < p) break;
		}
	}

	int res = DP[K].first += (DP[K].second == 2);
	printf("%d\n",res);
}