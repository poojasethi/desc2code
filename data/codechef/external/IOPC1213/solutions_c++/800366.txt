#include<cstdio>
#include<vector>
#include<algorithm>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef long long ll;

const ll M=100000007;

struct edge{ int u,v; };

class union_find{
	vector<int> a;
public:
	union_find(int n):a(n,-1){}
	int find(int x){
		if(a[x]<0) return x;
		return a[x]=find(a[x]);
	}
	void unite(int x,int y){
		x=find(x),y=find(y);
		if(x!=y){ a[x]+=a[y]; a[y]=x; }
	}
	int size(int x){ return -a[find(x)]; }
};

int main(){
	int T; scanf("%d",&T);
	while(T--){
		int n,m,q; scanf("%d%d%d",&n,&m,&q);
		edge E[100];
		rep(i,m){
			int u,v; scanf("%d%d",&u,&v);
			E[i]=(edge){u,v};
		}

		while(q--){
			int k; scanf("%d",&k);
			if(k<2){
				int u,v; scanf("%d%d",&u,&v);
				if(k==0) E[m++]=(edge){u,v};
				else{
					int i;
					for(i=0;!(E[i].u==u && E[i].v==v || E[i].u==v && E[i].v==u);i++);
					swap(E[i],E[--m]);
				}
			}
			else{
				union_find uf(n);
				rep(i,m) uf.unite(E[i].u,E[i].v);

				ll ans=1;
				bool used[100]={};
				rep(u,n){
					int r=uf.find(u);
					if(!used[r]){
						used[r]=true;

						int a=uf.size(r);
						ans=ans*k%M;
						rep(i,a-1) ans=ans*(k-1)%M;
					}
				}
				printf("%lld\n",ans);
			}
		}
	}

	return 0;
}
