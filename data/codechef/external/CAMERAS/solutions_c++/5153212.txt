// Author: thecodekaiser
#include <bits/stdc++.h>
 
using namespace std;
typedef long long ll;
typedef pair<int, int> PII;
typedef vector<int, int> vi;
typedef vector<vi> vii;
#define pb push_back
 
struct interval
{
	int start, end;
};
 
bool compare_interval(interval A, interval B)
{
	return (A.start < B.start) ? true:false;
}
 
// This is where I am gonna store merged intervals
vector<interval> ARR;
 
// Procedure : To merge intervals..Learned this from one of my seniors : Aditya Boss(aditya_1234)
void mergeIntervals(vector<interval> & vct)
{
    // Test if the given set has at least one interval
    if (vct.size() <= 0)
        return;
 
    // Create an empty stack of intervals
    stack<interval> s;
 
    // sort the intervals based on start time
    sort(vct.begin(), vct.end(), compare_interval);
 
    // push the first interval to stack
    s.push(vct[0]);
 
    // Start from the next interval and merge if necessary
    for (int i = 1 ; i < vct.size(); i++)
    {
        // get interval from stack top
        interval top = s.top();
 
        // if current interval is not overlapping with stack top,
        // push it to the stack
        if (top.end < vct[i].start)
        {
            s.push( vct[i] );
        }
        // Otherwise update the ending time of top if ending of current
        // interval is more
        else if (top.end < vct[i].end)
        {
            top.end = vct[i].end;
            s.pop();
            s.push(top);
        }
    }
    while(!s.empty())
    {
        interval t = s.top();
        ARR.push_back(t);
        s.pop();
    }
    sort(ARR.begin(), ARR.end(),compare_interval);
}

int bs(ll * ptr, ll val, int lo, int hi)
{
	int mid;
	while(lo <= hi)
	{
		mid = lo + ((hi-lo)>>2);

		if(ptr[mid] == val) return mid+1;
		else if(ptr[mid] > val) hi = mid - 1;
		else			lo = mid + 1;
	}
	return hi+1;
}

void solve()
{
	int N,Q;
	cin >> N >> Q;
	ll ptr[N];	
	for(int i = 0; i < N; i++)
		cin >> ptr[i];
	
	sort(ptr,ptr+N);
	vector<interval> VCT;
	interval I;

	int x,y;
	for(int i = 0; i < Q; i++)
	{
		cin >> x >> y;
		I.start = x, I.end = y;
		VCT.pb(I);
	}

	mergeIntervals(VCT);
	ll ans = 0;
	for(int	i = 0; i < ARR.size(); i++)
	{
		ans += (bs(ptr, ARR[i].end, 0, N-1) - bs(ptr,ARR[i].start-1, 0, N-1));
	}
	cout << ans << endl; 
}

int main()
{
	solve();
	return 0;
}