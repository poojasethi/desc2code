/*pranjuldb*/
#include <bits/stdc++.h>
#define pri(a) printf("%d",a)
#define prl(a) printf("%lld",a)
#define nl printf("\n")
#define sp printf(" ")
#define prs(str) printf("%s", str)
#define pb push_back
#define mem(a,b) memset(a, b, sizeof(a))
#define pi pair<int, int>
#define ll long long
#define rep(i,j,k) for(i = j; i < k; i++)
#define nrep(i,j,k) for(i = j; i >= k; i--)
#define scs(str) scanf("%s", str)
#define sci(a) scanf("%d",&a)
#define scl(a) scanf("%lld",&a)
#define Rep(i,n) for(typeof(n) i = 0; i < (n); ++i)
#define Repd(i,n) for(typeof(n) i = (n)-1; i >= 0; --i)


using namespace std;

// source : from old code : struct Dinic complete part is taken from here : http://www.codechef.com/viewplaintext/4935714

int source,sink;
vector <bool> used;
#define maxv 301
#define maxe 90001
const int inf = (int)1e9 + 5;
struct Dinic {
    int s, t, E, adj[maxe], cap[maxe], flow[maxe], next[maxe], last[maxv], que[maxv], level[maxv], run[maxv];
    void fun()
    {
        mem(last, -1);
    }
    void init(int _s, int _t) {
        s = _s; t = _t;
        E = 0; mem(last, -1);
    }

    void add(int u, int v, int c1, int c2) {
        adj[E] = v; cap[E] = c1; flow[E] = 0; next[E] = last[u]; last[u] = E++;
        adj[E] = u; cap[E] = c2; flow[E] = 0; next[E] = last[v]; last[v] = E++;
    }

    bool bfs() {
        mem(level, -1); level[s] = 0;
        int qsize = 0; que[qsize++] = s;

        Rep(i, qsize) {
            for (int u = que[i], e = last[u]; e != -1; e = next[e]) {
                int v = adj[e];
                if (level[v] == -1 && flow[e] < cap[e]) {
                    level[v] = level[u] + 1;
                    que[qsize++] = v;
                }
            }
        }

        return level[t] != -1;
    }

    int dfs(int u, int bot) {
        if (u == t) return bot;

        for (int &e = run[u]; e != -1; e = next[e]) {
            int v = adj[e], delta = 0;
            if (level[v] == level[u] + 1 && flow[e] < cap[e] && (delta = dfs(v, min(bot, cap[e] - flow[e]))) > 0) {
                flow[e] += delta;
                flow[e ^ 1] -= delta;
                return delta;
            }
        }

        return 0;
    }

    int maxflow() {
        int total = 0;
        while (bfs()) {
            memcpy(run, last, sizeof(last));
            for (int delta = dfs(s, inf); delta > 0; delta = dfs(s, inf)) total += delta;
        }
        return total;
    }
};

Dinic dinic;

int main()
{
    int n, m, i, j;
    vector <int> v1,v2,v3;
    sci(n);sci(m);
    while (m--) {
        int x,y,z;
        sci(x); sci(y); sci(z);
        v1.pb(x);
        v2.pb (y);
        v3.pb (z);
    }
    int tt;
    sci(tt);
    while (tt--) {
        sci(source);
        sci(sink);
        dinic.init(source, sink);
        for (int i = 0; i < v1.size(); i++) {
            dinic.add (v1[i], v2[i], v3[i], 0);
        }
        printf ("%d\n", dinic.maxflow());
    }

    return 0;
}
