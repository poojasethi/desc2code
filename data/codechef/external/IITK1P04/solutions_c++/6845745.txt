//Maximum flow problem using Dinitz algorithm

#include<bits/stdc++.h>

using namespace std;

#define ll long long int
#define ull unsigned long long int
#define maxN 305
#define maxW 1005
#define MOD 1000000007
#define pb push_back
#define mp make_pair
#define INF (((ll)1000000000) * ((ll)1000000000))
#define e 2.7182818284590452353602874
#define maxT 100000
#define inf 0x7fffffff
#define inff 100000
#define ff first
#define ss second
#define rep(i,N) for(int i=0;i<N;i++)

int C[maxN][maxN],RG[maxN][maxN],F[maxN][maxN];
int vis[maxN],parent[maxN];
int s,t,N,M;
queue<int> Q;
vector<int> L[maxN],V[maxN];


//BFS on the residual graph to create level graph
void bfs(int node) {
memset(vis,0,sizeof(vis));
for(int i=0;i<N;i++)
 L[i].clear();
while(Q.empty()==false)
 Q.pop();
Q.push(node);
vis[node]=1;
while(Q.empty()==false) {
 int u=Q.front();
 Q.pop();
 for(int i=0;i<V[u].size();i++) {
  int v=V[u][i];
  if(RG[u][v]>0&&vis[v]==0) {
   vis[v]=1;
   Q.push(v);
   parent[u]=v;
   L[u].pb(v);
  }
 }
}
}


void path() {
int u=t;
vector<int> V;
V.clear();
while(parent[u]!=-1) {
V.pb(u);
u=parent[u];
}
V.pb(s);
for(int i=V.size()-1;i>=0;i--)
 cout<<V[i]<<" ";
cout<<"\n";
}



//run DFS on the level graph to determine all s-t paths
//dfs on level graph will always give shortest s-t path
void dinitz_dfs(int u) {
if(u==t)
 return;
for(int i=0;i<L[u].size();i++) {
 int v=L[u][i];
 if(RG[u][v]>0&&vis[v]==0) {
  vis[v]=1;
  parent[v]=u;
  dinitz_dfs(v);
 }
}
}


int min_edge() {
int min=inf;
int v=t;
while(parent[v]!=-1) {
 int u=parent[v];
 if(RG[u][v]<min)
  min=RG[u][v];
 v=u;
 }
return min;
}


int dinitz() {
int maxflow=0;
while(true) {
 bfs(s);	//create level graph from the residual graph
 if(vis[t]==0)	//no s-t path possible in residual graph
  break;
 while(true) {
  memset(vis,0,sizeof(vis));
  memset(parent,-1,sizeof(parent));
  dinitz_dfs(s);
  //path();
  if(vis[t]==0)
   break;
  int v=t;
  int added_flow=min_edge();
  maxflow+=added_flow;
  while(parent[v]!=-1) {	//augment residual graph along the s-t path
   int u=parent[v];
   F[u][v]+=added_flow;
   RG[u][v]=C[u][v]-F[u][v];
   RG[v][u]=F[u][v];
   v=u;
  }
 }
}
return maxflow;
}




int main() {

cin.sync_with_stdio(0);
cin.tie(0);

cin>>N>>M;
for(int i=0;i<=N;i++)
 V[i].clear();
while(M--) {
 int a,b,c;
 cin>>a>>b>>c;
 C[--a][--b]=c;	//capacity of edge (a,b)
 RG[a][b]=c;
 V[a].pb(b);
}

int T;
cin>>T;
while(T--) {
cin>>s>>t;
s--;
t--;
for(int i=0;i<N;i++) 
 for(int j=0;j<N;j++) {
  F[i][j]=0;
  RG[i][j]=C[i][j];
  }
int flow=dinitz();
cout<<flow<<"\n";
}
return 0;
}
