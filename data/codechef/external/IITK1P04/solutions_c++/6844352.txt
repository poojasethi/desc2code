//http://backtrack-it.blogspot.in/2013/03/max-flow-algorithm-with-sample-c-code.html
#include<cstdio>
#include<cstdio>
#include<queue>
#include<cstring>
#include<vector>
#include<iostream>
#define MAX_NODES 400  
#define INF 2147483646  
#define UNINITIALIZED -1 
using namespace std; 
int capacities[MAX_NODES][MAX_NODES];
int flowPassed[MAX_NODES][MAX_NODES];
vector<int> graph[MAX_NODES];
int parentsList[MAX_NODES];       
int currentPathCapacity[MAX_NODES];  
int bfs(int startNode, int endNode)
{
memset(parentsList, UNINITIALIZED, sizeof(parentsList));
memset(currentPathCapacity, 0, sizeof(currentPathCapacity));
queue<int> q;
q.push(startNode);
parentsList[startNode]=-2;
currentPathCapacity[startNode]=INF;
while(!q.empty())
{
int currentNode = q.front(); q.pop();
for(int i=0; i<graph[currentNode].size(); i++)
{
int to = graph[currentNode][i];
if(parentsList[to] == UNINITIALIZED)
{
if(capacities[currentNode][to] - flowPassed[currentNode][to] > 0)
{
parentsList[to] = currentNode;
currentPathCapacity[to] = min(currentPathCapacity[currentNode], 
capacities[currentNode][to] - flowPassed[currentNode][to]);
if(to == endNode) return currentPathCapacity[endNode];
q.push(to);
}
}
}
}
return 0;
}

int edmondsKarp(int startNode, int endNode){
int maxFlow=0;
while(true)
{
int flow=bfs(startNode, endNode);
if(flow==0) 
break;
maxFlow +=flow;
int currentNode=endNode;
while(currentNode != startNode){
int previousNode = parentsList[currentNode];
flowPassed[previousNode][currentNode] += flow;
flowPassed[currentNode][previousNode] -= flow;
currentNode=previousNode;
}
}
return maxFlow;
}

int main()
{
int nodesCount, edgesCount;
cin>>nodesCount>>edgesCount;
int source, sink;
for(int edge=0; edge<edgesCount; edge++){
int from, to, capacity;
cin>>from>>to>>capacity;
capacities[from][to]=capacity;
graph[from].push_back(to);
//adding the negative edge
graph[to].push_back(from);
}
int T;
cin>>T;
int N=nodesCount;
while(T--) {
cin>>source>>sink;

for(int i=0;i<=N;i++)
 for(int j=0;j<=N;j++)
  flowPassed[i][j]=0;

int maxFlow = edmondsKarp(source, sink);
cout<<maxFlow<<endl;
}
return 0;
}
