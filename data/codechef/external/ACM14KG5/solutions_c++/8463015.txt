#include <bits/stdc++.h>
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>

//using namespace __gnu_pbds;
using namespace std;

//#pragma comment(linker, "/STACK:16777216")

#define Foreach(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define rof(i,a,b) for(int (i)=(a);(i) > (b); --(i))
#define rep(i, c) for(auto &(i) : (c))
#define x first
#define y second
#define pb push_back
#define mp make_pair
#define PB pop_back()
#define iOS ios_base::sync_with_stdio(false)
#define sqr(a) (((a) * (a)))
#define all(a) a.begin() , a.end()
#define error(x) cerr << #x << " = " << (x) <<endl
#define Error(a,b) cerr<<"( "<<#a<<" , "<<#b<<" ) = ( "<<(a)<<" , "<<(b)<<" )\n";
#define errop(a) cerr<<#a<<" = ( "<<((a).x)<<" , "<<((a).y)<<" )\n";
#define coud(a,b) cout<<fixed << setprecision((b)) << (a)
#define L(x) ((x)<<1)
#define R(x) (((x)<<1)+1)
#define umap unordered_map
//#define double long double
#define mod 1000000007
#define mod1 1000000009
#define LIMIT 10000000000000000LL
#define MAX1 1000000000
#define si(n) scanf("%d",&n)
#define sii(n,m) scanf("%d%d",&n,&m)
#define pi(n) printf("%d\n",n)
const int inf=0x3f3f3f3f;
#define MAXN 30
//template <typename T> using os =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
typedef long long ll;
typedef pair<int,int>pii;
typedef vector<int> vi;
typedef complex<double> point;

ll f[200011];
ll invf[200011];

ll power(ll b,ll e){
	if(e==0){
		return 1;
	}
	else{
		ll p=power(b,e/2);
		if(e%2==0){
			return (p*p)%mod;
		}
		else{
			p=(p*p)%mod;
			p=(p*b)%mod;
			return p;
		}
	}
}

void calc(){
	f[0]=1LL;

	For(i,1,200011){
		f[i]=(f[i-1]*i)%mod;
	}

	invf[200010]=power(f[200010],mod-2);

	rof(i,200009,-1){
		invf[i]=(invf[i+1]*(i+1))%mod;
	}
}

int main(){
	calc();
	int t;
	scanf("%d",&t);

	while(t--){
		ll n,k;
		scanf("%lld%lld",&n,&k);
		ll limit1=-1;

		if(n==1){
			printf("-1\n");
			continue;
		}

		for(ll i=1;i<=k;i++){
			if(i*i>k){
				break;
			}
			else{
				limit1=i;
			}
		}

		ll numb=k-limit1;
		ll answer1=0;
		//Error(limit1,numb);
		answer1=f[n+limit1-1];
		answer1=(answer1*invf[limit1-1])%mod;
		answer1=(answer1*invf[n])%mod;
		//error(answer1);
		ll start1=limit1+1;

		ll end1=k;
		for(ll i=1;true;i++){
			ll end2=k/(i+1)+1;
			if(end1<=limit1){
				break;
			}
			else if(end1>limit1 && end2<=limit1){
				end2=limit1+1;
			}
			//Error(end1,end2);
			ll temp1=(end1-end2+1);
			temp1=(temp1*f[n+i-2])%mod;
			temp1=(temp1*invf[i-1])%mod;
			temp1=(temp1*invf[n-1])%mod;
			//error(temp1);
			answer1=(answer1+temp1)%mod;
			end1=end2-1;
		}
		printf("%lld\n",answer1);
	}
return 0;}