#ifndef COMPRESS_KARNE_KE_LIYE
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS 
#define getchar_unlocked() getchar()
#endif 
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<set>
#include<map>
#include<utility>
#include<stack>
#include<queue>
#include<deque>
#include<list>
#include<string>
#include<climits>
#include<bitset>
#include<cfloat>
#include<sstream>
#include<iomanip>
#include<array>
#include<unordered_set>
#include<unordered_map>
#include<limits>
using namespace std;
const int maxs = (int)1e5;
inline void in(char &d)
{
	d = getchar_unlocked();
	while ((d<33) || (d>126))
	{
		d = getchar_unlocked();
	}
}
inline void in(string &str)
{
	str.clear();
	//str.reserve(maxs);
	char c = getchar_unlocked();
	while ((c<33) || (c>126))
	{
		c = getchar_unlocked();
	}
	while ((c >= 33) && (c <= 126))
	{
		str.push_back(c);
		c = getchar_unlocked();
	}
	return;
}
inline void in(double &d)
{
	string str;
	in(str);
	d = atof(str.data());
}
template<typename T>
inline void in(T & t){
	char c, m = 0;
	t = 0;
	c = getchar_unlocked();
	while ((c<'0' || c>'9') && c != '-')
		c = getchar_unlocked();
	if (c == '-')
		m = 1,
		c = getchar_unlocked();
 
	while (c >= '0' && c <= '9'){
		t = (t << 3) + (t << 1) + c - '0';
		c = getchar_unlocked();
	}
	if (m)
		t = -t;
}
#endif 
 
const int maxn = (int)1e5 + 5;
const int maxm = 330;
 
int pre[maxn][maxm];
long long mod_ke_lode;
 
void initialise()
{
	for (size_t i = 0; i < maxn; i++)
	{
		pre[i][1] = 1;
	}
	for (size_t i = 1; i < maxm; i++)
	{
		pre[1][i] = i;
	}
}
 
const int mod = (int)1e9 + 7;
inline int pre_solve(int m , int n)
{
	if (pre[m][n]!=0)
	{
		return pre[m][n];
	}
	mod_ke_lode = (long long)pre_solve(m, n - 1) + pre_solve(m - 1, n);
	if (mod_ke_lode >= mod)
	{
		mod_ke_lode -= mod;
	}
	pre[m][n] = mod_ke_lode;
	return pre[m][n];
}
 
 
 
 
int main(){
	initialise();
	int t, n, k,sq,temp1,temp2,temp3,ans;
	
	in(t);
	while (t--)
	{
		in(n);
		in(k);
		if (n==1)
		{
			printf("-1\n");
			continue;
		}
		sq = sqrt(k);
		temp1 = sq;
 
		ans = pre_solve( n,sq);
		for (int i = sq; i >= 1; i--)
		{
			temp2 = k / i;
			mod_ke_lode=(long long)ans+(temp2 - temp1)*(long long)pre_solve(n-1, i);
			if (mod_ke_lode>=mod)
			{
				mod_ke_lode %= mod;
			}
			ans = mod_ke_lode;
			temp1 = temp2;
		}
		printf("%d\n", ans);
 
 
	}
 
 
 
	return 0;
} 
