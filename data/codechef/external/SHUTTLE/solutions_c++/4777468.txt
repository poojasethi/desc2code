#include<iostream>
#include<cmath>
//#include<vector>
using namespace std;

/*
Following are the steps to find all prime factors.
1) While n is divisible by 2, print 2 and divide n by 2.
2) After step 1, n must be odd. Now start a loop from i = 3 to square root of n. While i divides n, print i and divide n by i, increment i by 2 and continue.
3) If n is a prime number and is greater than 2, then n will not become 1 by above two steps. So print n if it is greater than 2.

// Program to print all prime factors
# include <stdio.h>
# include <math.h>
 
// A function to print all prime factors of a given number n
void primeFactors(int n)
{
    // Print the number of 2s that divide n
    while (n%2 == 0)
    {
        printf("%d ", 2);
        n = n/2;
    }
 
    // n must be odd at this point.  So we can skip one element (Note i = i +2)
    for (int i = 3; i <= sqrt(n); i = i+2)
    {
        // While i divides n, print i and divide n
        while (n%i == 0)
        {
            printf("%d ", i);
            n = n/i;
        }
    }
 
    // This condition is to handle the case whien n is a prime number
    // greater than 2
    if (n > 2)
        printf ("%d ", n);
}

void combination(int n, vector<int>& remaining, int start, int end, vector<int>& combinationVector){
	if(start == end) { //reached the end of the list
		combinationVector.push_back(n);
		return;
	}
	combination(n*remaining[start], remaining, start+1, end, combinationVector);
	combination(n, remaining, start+1,end, combinationVector);
}

void combination(int n, vector<int>& remaining, int start, int end, bool check){
	if(start == end) { //reached the end of the list
		if(check) {
		combinationVector.push_back(n);
		cout << "Pushed " << n <<  endl;
	}
		return;
	}
	combination(n*remaining[start], remaining, start+1, end, true);
	combination(n, remaining, start+1,end, check);
}
int main() {
	vector<int> test;
	test.push_back(2);
	test.push_back(3);
	test.push_back(5);
	combination(1, test, 0, test.size(), false);
	for(int i=1; i<combinationVector.size()-1; i++) {
		cout << combinationVector[i] << " ";
	}
	cout << endl;
	return 0;
}
*/
/*
int main() {
	vector<int> test;
	test.push_back(2);
	test.push_back(3);
	test.push_back(5);
	combination(1, test, 0, test.size());
	bool check;
	for(int i=1; i<combinationVector.size()-1; i++) {
		check = false;
		for(int j=0;j<test.size();j++) {
			if(combinationVector[i]/test[j] == 1) {
				check = true;
				break;
			}
		}
		if(check){
			cout << combinationVector[i] << " ";
		}
	}
	cout << endl;
	return 0;
}
*/
/*
Wrong algorithm failed
int main()
{
	int t;
	cin >> t;
	int n,output;
	int copy;
	for( int T=0;T < t; T++) {
		cin >> n;
		copy = n;
		vector<int> nonRepeatingPrimeFactors;
		vector<int> combinationVector;
		bool check = false;
		//divide by 2's
		while(n%2 == 0) {
			n = n/2;
			check = true;
		}
		if(check) {//add 2 to the list of prime factors
			nonRepeatingPrimeFactors.push_back(2);
			check = false;
		}
		for(int j=3; j<=sqrt(n); j=j+2){//n is odd by now, so increase j by 2 each time
			check = false;
			if(n%j == 0){
				n = n/j;
				check = true;
			}
			if(check) {//this is a prime factor, see if is repeating
				for(int k=0;k<nonRepeatingPrimeFactors.size();k++){
					if(nonRepeatingPrimeFactors[k]==j) {
						check = false;
						break;
					}
				}
				if(check) {
					nonRepeatingPrimeFactors.push_back(j);
				}
			}
		}
		if(n > 2) {
			check = true;
			for(int k=0;k<nonRepeatingPrimeFactors.size();k++){
				if(nonRepeatingPrimeFactors[k]==n) {
					check = false;
					break;
				}
			}
			if(check) {
				nonRepeatingPrimeFactors.push_back(n);
			}
		}
		//now we have the list of all non repeating primes
		cout << "The list of primes = ";
		for(int i=0; i<nonRepeatingPrimeFactors.size(); i++) {
			cout << nonRepeatingPrimeFactors[i] << " ";
		}
		cout << endl;
		
		//Populate all the combinations
		combination(1, nonRepeatingPrimeFactors, 0, nonRepeatingPrimeFactors.size(), combinationVector);
		cout << "The list of combinations = ";
		for(int i=1; i<combinationVector.size()-1; i++) {
			cout << combinationVector[i] << " ";
		}
		cout << endl;
		//Apply the algorithm now
		//1) All factors of combinations should be substracted
		//2) All factors of direct primes should be added
		output = 0;
		if(combinationVector.size() > 2) {
			for(int i=1; i<combinationVector.size()-1; i++) {
				bool check = false;
				for(int j=0;j<nonRepeatingPrimeFactors.size();j++) {
					int a = combinationVector[i];
					int b = nonRepeatingPrimeFactors[j];
					if((combinationVector[i]%nonRepeatingPrimeFactors[j]) == 0 
						&& combinationVector[i]/nonRepeatingPrimeFactors[j] == 1) {
						check = true;
						break;
					}
				}
				if(check) {
					output = output + ((copy/combinationVector[i])-1);
				}
				else {
					output = output - ((copy/combinationVector[i])-1);
				}
			}
			cout << output << endl;
		}
		else {
			cout << "1" << endl;
		}
	}
	system("pause");
	return 0;
}
*/
int main() {
	int T;
	cin >> T;
	int n, output, temp;
	for(int t=0; t<T; t++) {
		cin >> n;
		output = 1;
		for(int i=2;i<n;i++ ) {
			int start = i;
			int last = n;
			while(!(last%start == 0 || last%start == 1)) {
				temp = last;
				last = start;
				start = temp%start;
			}
			if(last%start == 0) {
			} 
			else {
				output++;
			}
		}
		cout << output << endl;
		
	}
}