#include <bits/stdc++.h>
using namespace std;

/* Uzumaki Naruto */
#define TRACE

#ifdef TRACE
#define dbgarr(a,n)   cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n";
#define dbg(args...)  {debug,args; cerr<<endl;}
#define pause()       cin.get();cin.get();

#else
#define dbgarr(a,n)
#define dbg(args...)
#define pause()

#endif

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

#define fr first
#define se second
typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int NN = 4123456;
int fail[NN];

void build(string &msg){
    int n = (int)msg.size();
    int k = fail[0] = 0;
    for(int i = 1; i < n; ++i){
        while(k > 0 and msg[k] != msg[i])
            k = fail[k-1];
        fail[i] = (k += (msg[k] == msg[i]));
    }
}

bool solve(){
    string msg;
    cin >> msg;
    if (msg == "End")
        return false;
    build(msg);
    int n = (int)msg.size();
    for(int i = 0; i < n; ++i){
        cout << fail[i];
        if (i != n-1) cout << " ";
        else cout << endl;
    }
    return true;
}

int main()
{
    ios_base::sync_with_stdio(0);
    while(solve()){}
    return 0;
}
