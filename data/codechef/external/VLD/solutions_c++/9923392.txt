#include <bits/stdc++.h>
#define ll long long int
#define s(a) scanf("%lld", &a);
#define pb push_back
#define mp make_pair
#define f first
#define sc second
#define inf 10e16

using namespace std;

ll cnt[1000001];
vector<ll>v[1000001];
vector<ll>u[1000001];
vector<ll>num;
ll a[100001];

ll pow1[1000001];
ll pow2[1000001];

ll mod1 = 999999937;
ll mod2 = 999999929;

void sieve()
{
    int i,j;
    for(i=2;i<=1000000;i++) {
        cnt[i]++;
        for(j=i;j<=1000000;j=j+i) {
            cnt[j]++;
        }
    }
    cnt[1]=1;
    for(i=2;i<=1000000;i++) {
        if(v[i].size()!=0) {
            continue;
        }
        for(j=i;j<=1000000;j+=i) {
            v[j].pb(i);
        }
    }
}

ll power_count(ll x,ll y)
{
    ll ans=0;
    while(x%y==0) {
        x/=y;
        ans++;
    }
    return ans;
}

void compute_powers()
{
    pow2[0]=1;
    pow1[0]=1;
    for(int i=1;i<=1000000;i++) {
        pow1[i]=pow1[i-1]*31;
        if(pow1[i]>mod1) pow1[i]%=mod1;
        pow2[i]=pow2[i-1]*37;
        if(pow2[i]>mod2) pow2[i]%=mod2;
    }
}

int main()
{
    //freopen("inp.txt","r",stdin);
    sieve();
    compute_powers();
    map<pair<ll,ll>,ll>mark;
    map<pair<ll,ll>,ll>present;
    bitset<1000001>b;
    ll t,n,i,j,k,l,w,ww,x,y,z;
    s(t);
    while(t--) {
        num.clear();
        mark.clear();
        present.clear();
        s(n);
        for(i=1;i<=n;i++) {
            s(x);
            if(cnt[x]%2==1) {
                x = sqrt(x);
            }
            else {
                w = cnt[x]/2;
                if(w%2==0) {
                    x = 1;
                }
            }
            a[i]=x;
            if(x!=1 && b[x]==0) num.pb(x);
            b[x]=1;
        }
        for(i=0;i<num.size();i++) {
            w = num[i];
            for(j=0;j<v[w].size();j++) {
                ww = power_count(w,v[w][j]);
                if(ww%2==1) u[w].pb(v[w][j]);
            }
        }
        mark[mp(0,0)]=1;
        ll ans=0;
        ll mask = 0;
        ll mask1 = 0;
        for(i=1;i<=n;i++) {
            if(a[i]==1) {
                ans = ans + mark[mp(mask,mask1)];
                mark[mp(mask,mask1)]++;
            }
            else {
                for(j=0;j<u[a[i]].size();j++) {
                    ll kk = u[a[i]][j];
                    ll kk1 = pow2[kk];
                    kk = pow1[kk];
                    if(present[mp(kk,kk1)]==1) {
                        present[mp(kk,kk1)]=0;
                        mask = mask - kk;
                        mask1 = mask1 - kk1;
                        if(mask<0) mask+=mod1;
                        if(mask1<0) mask1+=mod2;
                    }
                    else {
                        present[mp(kk,kk1)]=1;
                        mask=mask+kk;
                        mask1=mask1+kk1;
                        if(mask1>mod2) mask1-=mod2;
                        if(mask>mod1) mask-=mod1;
                    }
                }
                ans=ans+mark[mp(mask,mask1)];
                mark[mp(mask,mask1)]++;
            }
            //cout<<mask<<endl;
        }
        cout<<ans<<endl;
    }
    return 0;
}
