#include <algorithm>
#include <vector>
#include <list>
#include <queue>
using namespace std;
#include <stdio.h>
#include <memory.h>
 typedef pair <int, int> pii;
int test, cnt, n[2], taxi[501], people[1001], m, u, v, c, s[501], t[501], minCost[1502][1502];
int edges, last[500], pre[500000], head[500000], matching[1000], dist[500], Q[500];
bool fr[1502], used[500], vis[500];
vector <pii> adj[1502];
queue <int> que;
 void spfa(const int& index){
	int start = (index < cnt ? taxi[index] : index);
	fill(minCost[start] + 1, minCost[start] + 1 + cnt, 1e9);
	memset(fr + 1, false, cnt);
 
	que.push(start);
	fr[start] = true;
	minCost[start][start] = 0;
	while (!que.empty()){
		int u = que.front();
		que.pop();
		fr[u] = false;
 
		for (int i = 0; i < adj[u].size(); ++i)
		if (minCost[start][adj[u][i].first] > minCost[start][u] + adj[u][i].second){
			minCost[start][adj[u][i].first] = minCost[start][u] + adj[u][i].second;
			if (!fr[adj[u][i].first]){
				fr[adj[u][i].first] = true;
				que.push(adj[u][i].first);
			}}}}
void addEdge(int u, int v) {
	head[edges] = v;
	pre[edges] = last[u];
	last[u] = edges++;
}
 void bfs() {
	fill(dist, dist + n[0], -1);
	int sizeQ = 0;
	for (int u = 0; u < n[0]; ++u) {
		if (!used[u]) {
			Q[sizeQ++] = u;
			dist[u] = 0;
		}
	}
	for (int i = 0; i < sizeQ; i++) {
		int u1 = Q[i];
		for (int e = last[u1]; e >= 0; e = pre[e]) {
			int u2 = matching[head[e]];
			if (u2 >= 0 && dist[u2] < 0) {
				dist[u2] = dist[u1] + 1;
				Q[sizeQ++] = u2;
			}
		}
	}
}
 
bool dfs(int u1) {
	vis[u1] = true;
	for (int e = last[u1]; e >= 0; e = pre[e]) {
		int v = head[e];
		int u2 = matching[v];
		if (u2 < 0 || !vis[u2] && dist[u2] == dist[u1] + 1 && dfs(u2)) {
			matching[v] = u1;
			used[u1] = true;
			return true;
		}
	}
	return false;
}
 
int maxMatching() {
	fill(used, used + n[0], false);
	fill(matching, matching + n[1], -1);
	for (int res = 0;;) {
		bfs();
		fill(vis, vis + n[0], false);
		int f = 0;
		for (int u = 0; u < n[0]; ++u)
		if (!used[u] && dfs(u))
			++f;
		if (!f)
			return res;
		res += f;
	}
}
 
int main(){
	scanf("%d", &test);
	while (test--){
		scanf("%d %d %d", n, n + 1, &m);
		cnt = n[0] + n[1] + 1;
 
		for (int i = 1; i <= n[0]; ++i)
			scanf("%d", taxi + i);
		for (int i = 1; i <= n[1]; ++i)
			scanf("%d", people + i);
 
		for (int i = 1; i <= cnt; ++i)
			adj[i].clear();
 
		for (int i = 1; i <= m; ++i){
			scanf("%d %d %d", &u, &v, &c);
			adj[u].push_back(pii(v, c));
			adj[v].push_back(pii(u, c));
		}
 
		for (int i = 1; i <= n[0]; ++i)
			scanf("%d", s + i);
		for (int i = 1; i <= n[0]; ++i)
			scanf("%d", t + i);
 
		for (int i = 1; i <= n[0]; ++i)
			spfa(i);
		spfa(cnt);
 
		edges = 0;
		fill(last, last + n[0], -1);
		for (int i = 1; i <= n[0]; ++i)
		for (int j = 1; j <= n[1]; ++j)
		if (s[i] * t[i] >= minCost[taxi[i]][people[j]] + minCost[cnt][people[j]])
			addEdge(i - 1, j - 1);
 		printf("%d\n", maxMatching());
	}
	return 0;
} 