/** author : ayush sharma **/
#include<iostream>
#include<functional>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<string>
#include<sstream>
#include<vector>
#include<queue>
#include<set>
#include<map>
#include<stack>
#define FOR(i,a,b) for(int i=a; i<b; i++)
#define FORr(i,a,b) for(int i=a ; i>=b; i--)
#define pb push_back
#define mp make_pair
#define ub upper_bound
#define lb lower_bound
#define si1(n) scanf("%d",&n)
#define si2(n1, n2) scanf("%d%d",&n1,&n2)
#define si3(n1,n2,n3) scanf("%d%d%d",&n1, &n2, &n3)
#define si4(n1,n2,n3,n4) scanf("%d%d%d%d",&n1, &n2, &n3, &n4)
#define FF first
#define SS second
#define READ(x) freopen(x,"r",stdin)
#define WRITE(x) freopen(x,"w",stdout)
#define show1(a) cout<<a<<"\n"
#define show2(a, b) cout<<a<<"   "<<b<<"\n"
#define show3(a, b, c) cout<<a<<"   "<<b<<"    "<<c<<"\n"
#define show4(a, b, c,d) cout<<a<<"   "<<b<<"    "<<c<<"   "<<d<<"\n"

using namespace std;
typedef long long LL;
typedef pair <int,int> pii;
typedef pair<string,int> psi;
typedef vector<int> vi;
typedef unsigned long long ull;


#define sz 100003

int n;
struct rec{
    int x1, x2, y1, y2, id;
    rec* par;
    rec(int x1_, int y1_, int x2_, int y2_, int id_){ x1=x1_; y1=y1_; x2=x2_; y2=y2_; id=id_; par=NULL;}
};

struct point{
    int x,y;
    rec* r;
    point(int x_, int y_, rec* r_){ x=x_; y=y_; r=r_; }
};

bool comp(const point & p1, const point &p2){
    if(p1.x==p2.x) return p1.y> p2.y;
    return p1.x<p2.x;
}

vector<point> vv;
typedef pair<int, rec*> pr;
multimap<int, rec*> m; // maps x coord with retangle
map<int, rec*> cs;
set<int> pts;
int par[sz];
rec* findlwr(int y){
    map<int,rec*> :: iterator it;
    it = cs.ub(y); it--;
    rec * r= it->SS;
    return r;
}

void sweep(){
    multimap<int,rec*> :: iterator it;
    pair< multimap<int,rec*> :: iterator, multimap<int,rec*> :: iterator > pit;
    while(!pts.empty()){
        int x= *(pts.begin()); pts.erase(pts.begin());
        pit=m.equal_range(x);
//        show3("outer",pit.FF->FF, pit.SS->FF);
        for(it=pit.FF; it!=pit.SS; it++ ) {
            rec * r1 = it->SS;
//            show3(it->FF, r1->y2, r1->y1);
            if(r1->x1 == x){
                rec * r2=findlwr(r1->y1);
                if(r2->y2 > r1->y1 && r2->y1 < r1->y1) { r1->par=r2; par[r1->id] = r2->id; }
                else if( r2->y2 < r1->y1 && r2->y1 < r1->y1 ) { r1->par=r2->par; par[r1->id] = r2->par->id; }
                cs.insert(pr(r1->y1, r1));
                cs.insert(pr(r1->y2, r1));
            }
            else if(r1->x2==x){
                map<int,rec*> :: iterator it1;
                it1=cs.find(r1->y1); cs.erase(it1);
                it1=cs.find(r1->y2); cs.erase(it1);
            }
        }
    }
}

void takeInput(){
    rec * rd = new rec(-1,-1,1200000000, 1200000000, 0);
    m.insert(pr(-1, rd));
    cs.insert(pr(-1,rd));
    FOR(i,1,n+1){
        int x1, y1, x2, y2;
        si4(x1,y1,x2,y2);
        rec * r= new rec(x1,y1,x2, y2,i);
        point p1(x1,y2,r); point p2(x2,y2,r);
        vv.pb(p1); vv.pb(p2);
        pts.insert(x1); pts.insert(x2);
    }
    sort(vv.begin(), vv.end(), comp);
    FOR(i,0,vv.size()){
        point p = vv[i];
        m.insert(pr(p.x,p.r));
    }
    map<int, rec*> ::iterator it;
//    show1("");
}

int main(){
  //  READ("input.txt");
    si1(n);
    takeInput();
    sweep();
    FOR(i,1,n+1){
        printf("%d\n",par[i]-1);
    }
    return 0;
}
