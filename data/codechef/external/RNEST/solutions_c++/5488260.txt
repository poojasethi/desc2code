#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair <int,int> pii;
typedef vector <int> vi;

#define rep(i, n) for(int i = 0; i < (n); ++i)
#define forn(i, a, b) for(int i = (a); i < (b); ++i)
#define ford(i, a, b) for(int i = (a); i >= (b); --i)
#define fore(i, a, b) forn(i, a, b + 1)

#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define all(c) c.begin(), c.end()
#define mset(a, v) memset(a, v, sizeof(a))
#define sz(a) ((int)a.size())

#define gi(x) scanf("%d", &x)
#define pis(x) printf("%d ", x)
#define pin(x) printf("%d\n", x)
#define pnl printf("\n")
#define dbn cerr << "\n"
#define dbg(x) cerr << #x << " : " << (x) << " "
#define dbs(x) cerr << (x) << " "

#define foreach(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it)

const int MAX_N = 2e5 + 100;
const int INF = 1e9;

struct event {
    bool start;
    int idx;
    int x, y1, y2;
    event() {}
    event(int i, int p, int q, int r, bool b) : idx(i), x(p), y1(q), y2(r), start(b) {}
} events[MAX_N];

bool cmp(const event & p, const event & q) {
    if(p.x != q.x) return p.x < q.x;
    else return p.y1 < q.y1;
}

int parent[MAX_N];

int main() {
    int n; gi(n);
    rep(i, n) {
        int x1, y1, x2, y2;
        gi(x1); gi(y1);
        gi(x2); gi(y2);
        events[2 * i] = event(i, x1, y1, y2, true);
        events[2 * i + 1] = event(i, x2, y1, y2, false);
    }
    
    mset(parent, -1);
    sort(events, events + 2 * n, cmp);

    set < pair <pii, int> > active;

    rep(i, (n << 1)) {
        int idx = events[i].idx;
        if(events[i].start) {
            set < pair <pii, int> >::iterator it = active.lower_bound(mp(mp(events[i].y1, -1), -1));
            if(it != active.begin()) {
                --it;
                if(it->ss) parent[idx] = parent[it->ff.ss];
                else parent[idx] = it->ff.ss;
            }
            active.insert(mp(mp(events[i].y1, idx), 0));
            active.insert(mp(mp(events[i].y2, idx), 1));
        } else {
            active.erase(mp(mp(events[i].y1, idx), 0));
            active.erase(mp(mp(events[i].y2, idx), 1));
        }
        
    }

    rep(i, n) pin(parent[i]);
    return 0;
}