// Solution for the SPOJ problem "BTCODE_J"

#include <cstdio>

// Fast Input
#define R(x) while((ch = getchar()) < '0'); for(x = ch - '0';(ch = getchar()) >= '0';) x = x * 10 + ch - '0';

using namespace std;

typedef long long ll;
const int mod = 1000000007;
char ch;
int T;
long long n, k, mat[10][10], ans[10][10], c[10][10], a[10], Ans[10];

void set(ll* mat, ll a1, ll a2, ll a3, ll a4, ll a5, ll a6) 
{
  mat[1] = a1; mat[2] = a2; mat[3] = a3; mat[4] = a4; mat[5] = a5; mat[6] = a6;
  for(int i = 1; i <= 6; i++) 
   if(mat[i] >= mod) 
    mat[i] %= mod;
}

void mul(ll a[10][10], ll b[10][10]) 
{
  for(int i = 1; i <= 6; i++) 
   for(int j = 1; j <= 6; j++) 
   {
     c[i][j] = 0;
     for(int k = 1; k <= 6; k++) 
      c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % mod;
   }

  for(int i = 1; i <= 6; i++) 
   for(int j = 1; j <= 6; j++) 
    a[i][j] = c[i][j];
}

void pow(ll a[10][10], ll n) 
{
  for(int i = 1; i <= 6; i++) 
   for(int j = 1; j <= 6; j++) 
    ans[i][j] = (i == j);

  for(int i = 0; n >> i; i++) 
  {
    if((n >> i) & 1) 
     mul(ans, a);
    mul(a, a);
  }
}

int main() 
{
  R(T);
  while(T--) 
  {
    R(n);R(k);
    if(n == 1) 
     printf("%d\n", k * k);
    if(n == 2) 
     printf("%lld\n", k * k * k * k % mod);
    if(n <= 2) 
     continue;

    set(mat[1], k - 1, (k - 1) * (k - 2), 1, 0, 0, 2 * (k - 1));
    set(mat[2], k - 2, (k - 2) * (k - 1) + 1, 0, 1, 2, 2 * (k - 2));
    set(mat[3], k - 1, (k - 1) * (3 * k - 4), 0, 0, 2 * (k - 1), 0);
    set(mat[4], k - 2, (k - 2) * (k - 1) * 3 + 1, 0, 0, 2 * (k - 2), 0);
    set(mat[5], k - 1, (k - 1) * (k - 2), 0, 0, 0, k - 1);
    set(mat[6], k - 2, (k - 2) * (k - 2), 0, 0, 0, k - 2);
    set(a, k * k * k, k * k * k * (k - 1), k, k * (k - 1), k * k * 2, k * k * (k - 1) * 2);
    pow(mat, n - 2);

    for(int i = 1; i <= 6; i++) 
    {
      Ans[i] = 0;
      for(int j = 1; j <= 6; j++) 
       Ans[i] = (Ans[i] + a[j] * ans[j][i]) % mod;
    }

    printf("%lld\n", (Ans[1] + Ans[2]) % mod);
  }

  return 0;
}