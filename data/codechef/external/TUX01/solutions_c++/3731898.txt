/* Name- Aayush Agarwal
   Language -C++
   */
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <list>
#include <deque>
#include <stack>
#include <iterator>
#include <cassert>
#include <cctype>
#include <string>
#include <sstream>
#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>
#define fOr(i,n) for(int i=0;i<n;i++)
#define For(i,n) for(int i=1;i<=n;i++)
#define ss(a) scanf("%s",a)
#define si(a) scanf("%d",&a)
#define sl(a) scanf("%lld",&a)
#define pi(a) printf("%d ",a)
#define pl(a) printf("%lld ",a)
#define ps(a) printf("%s ",a)
#define nl    printf("\n");
#define ll long long int
#define ull unsigned long long int
#define mod 1000000007
using namespace std;

const double eps=1e-9;
const double PI=2*acos(0.0);

#define VI vector<int>
#define VS vector<string>
#define VL vector<long long int>
#define VVI vector<VI>
#define PII pair<int,int>
#define PLL pair<ll,ll>
#define PSS pair<string,string>
#define PSI pair<string,int>
#define VPII vector<PII>
#define VPLL vector<PLL>
#define VPSS vector<PSS>
#define VPSI vector<PSI>
#define pb(a) push_back(a)
#define mp(a,b) make_pair(a,b)
#define sqr(x) ((x)*(x))
#define min(a,b) ((a<b)?a:b)


struct segtree
{
	int mini;
	int cnt;
	
};
segtree tree[4*1000005],ans;
int arr[1000005];

void build(int a,int b,int n)
{
	if(a>b)return ;
	if(a==b)
	{
		if(arr[a]%2==0)
		{
			tree[n].mini=arr[a];
			tree[n].cnt=1;
		}
		else
		{
			tree[n].mini=-1;
			tree[n].cnt=0;
		}
		return ;
	}
	build(a,(a+b)/2,2*n+1);
	build((a+b)/2+1,b,2*n+2);
	int val1=tree[2*n+1].mini;
	int val2=tree[2*n+2].mini;
	int occur1=tree[2*n+1].cnt;
	int occur2=tree[2*n+2].cnt;
	if(val1==-1 && val2!=-1)
	{
		tree[n].mini=val2;
		tree[n].cnt=occur2;
	}
	else if(val1!=-1 && val2==-1)
	{
		tree[n].mini=val1;
		tree[n].cnt=occur1;
	}
	else if(val1!=-1 && val2!=-1)
	{
		tree[n].mini=min(val1,val2);
		if(val1==val2)
		{
			tree[n].cnt=occur1+occur2;
		}
		else if(val1<val2)
		{
			tree[n].cnt=occur1;
		}
		else
			tree[n].cnt=occur2;
	}
	else
	{
		tree[n].mini=-1;
		tree[n].cnt=0;
	}
	
}
void update(int ss,int se,int i,int val,int n)
{
	
	if(ss==se)
	{
		if(val%2==0)
		{
			tree[n].mini=val;
			tree[n].cnt=1;
		}
		else
		{
			tree[n].mini=-1;
			tree[n].cnt=0;
		}
	}
	else
	{
		int mid=(ss+se)/2;
		if(i>=ss && i<=mid)
		update(ss,(ss+se)/2,i,val,2*n+1);
		else if( i>mid && i<=se)
		update((ss+se)/2+1,se,i,val,2*n+2);
		
		int val1=tree[2*n+1].mini;
	 	int val2=tree[2*n+2].mini;
		int occur1=tree[2*n+1].cnt;
		int occur2=tree[2*n+2].cnt;
		
		if(val1==-1 && val2!=-1)
		{
			tree[n].mini=val2;
			tree[n].cnt=occur2;
		}
		else if(val1!=-1 && val2==-1)
		{
			tree[n].mini=val1;
			tree[n].cnt=occur1;
		}
		else if(val1!=-1 && val2!=-1)
		{
			tree[n].mini=min(val1,val2);
			if(val1==val2)
			{
				tree[n].cnt=occur1+occur2;
			}
			else if(val1<val2)
			{
				tree[n].cnt=occur1;
			}
			else
				tree[n].cnt=occur2;
		}
		else
		{
			tree[n].mini=-1;
			tree[n].cnt=0;
		}
	}
}
segtree query(int ss,int se,int i,int j,int n)
{
	segtree node,node2,node3,node4,node5;
	if(se<i || ss > j)
	{
		node2.mini=-1;
		node2.cnt=0;
		return node2;
	}
	if(ss>=i && se<=j)
	return tree[n];
	node3=query(ss,(ss+se)/2,i,j,2*n+1);
	node4=query((ss+se)/2+1,se,i,j,2*n+2);
	int val1=node3.mini;
	int val2=node4.mini;
	int occur1=node3.cnt;
	int occur2=node4.cnt;
	if(val1==-1 && val2!=-1)
	{
		return node4;
	}
	else if(val1!=-1 && val2==-1)
	{
		return node3;
	}
	else if(val1!=-1 && val2!=-1)
	{
		
		if(val1==val2)
		{
			node5.mini=val1;
			node5.cnt=occur1+occur2;
			return node5;
		}
		else if(val1<val2)
		{
			return node3;
		}
		else
			return node4;
	}
	else
	{
		node.mini=-1;
		node.cnt=0;
		return node;
	}
	
}
int main()
{	
	int n,q,l,r,choice;
	si(n);
	si(q);
	for(int i=0;i<n;i++)
	{
		si(arr[i]);
	}
	build(0,n-1,0);
	while(q--)
	{
		si(choice);
		si(l);
		si(r);
		ans.mini=-1;
		ans.cnt=0;
		if(choice==1)
		{	
			l--;r--;
			if(l<=r)
			ans=query(0,n-1,l,r,0);
			pi(ans.mini);
		    pi(ans.cnt);nl;
		}
		else
		{	
			l--;
			update(0,n-1,l,r,0);
		}
		
	}
}