#include<cstdio>
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
#include<set>
#include<cmath>
#include<bitset>
#include<map>
#include<queue>
#define test(t) while(t--)
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
 
#define p(n) printf("%lld\n",n)
#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>
#define pb push_back
#define inf 1000000000LL
#define mp make_pair
#define imax (int) 1000000007
#define ll long long
#define gc getchar_unlocked
using namespace std;
int fcin(){register int c = gc();int x = 0;for(;(c<48 || c>57);c = gc());for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}return x;}
int ar[1000005];
struct T
{
	int minev;
	int ct;
 
}node[4*1000000+9];
void build_tree(int idx,int ss,int se)
{
	int mid;
	mid=(ss+se)/2;
	if(ss==se)
	{
	//	cout<<ss<<" "<<ar[ss]<<" "<<idx<<endl;
	    if(ar[ss]%2==0)
	    {
	    	node[idx].minev=ar[ss];
	    	node[idx].ct=1;
	    	
	    }
	    else
	    {
	    	node[idx].minev=-1;
	    	node[idx].ct=0;
	    	
	    }
	}
	else
	{
		build_tree(2*idx+1,ss,mid);
		build_tree(2*idx+2,mid+1,se);
		if(node[2*idx+1].minev==-1 && node[2*idx+2].minev==-1)
		{
			node[idx].minev=-1;
	    	node[idx].ct=0;
	    	
		}
		else if(node[2*idx+1].minev==-1)
		{
			node[idx].minev=node[2*idx+2].minev;
	    	node[idx].ct=node[2*idx+2].ct;
	    	
		}
		else if(node[2*idx+2].minev==-1)
		{
			node[idx].minev=node[2*idx+1].minev;
	    	node[idx].ct=node[2*idx+1].ct;
		}
		else
		{
			if(node[2*idx+1].minev<node[2*idx+2].minev)
			{
				node[idx].minev=node[2*idx+1].minev;
	    	node[idx].ct=node[2*idx+1].ct;
			}
			else if(node[2*idx+1].minev>node[2*idx+2].minev)
			{
				node[idx].minev=node[2*idx+2].minev;
	    	    node[idx].ct=node[2*idx+2].ct;
	    	    
			}
			else
			{
				node[idx].minev=node[2*idx+2].minev;
				node[idx].ct=node[2*idx+2].ct+node[2*idx+1].ct;
				
			}
		}
	}
}
void update(int idx,int ss,int se,int ci,int val)
{
	int mid;
	mid=(ss+se)/2;
	if(ci<ss||ci>se)
	return;
	else if(ss==se)
	{
		if(val%2==0)
	    {
	    	node[idx].minev=val;
	    	node[idx].ct=1;
	    }
	    else
	    {
	    	node[idx].minev=-1;
	    	node[idx].ct=0;
	    }
	}
	else
	{
		update(2*idx+1,ss,mid,ci,val);
		update(2*idx+2,mid+1,se,ci,val);
		if(node[2*idx+1].minev==-1 && node[2*idx+2].minev==-1)
		{
			node[idx].minev=-1;
	    	node[idx].ct=0;
		}
		else if(node[2*idx+1].minev==-1)
		{
			node[idx].minev=node[2*idx+2].minev;
	    	node[idx].ct=node[2*idx+2].ct;
		}
		else if(node[2*idx+2].minev==-1)
		{
			node[idx].minev=node[2*idx+1].minev;
	    	node[idx].ct=node[2*idx+1].ct;
		}
		else
		{
			if(node[2*idx+1].minev<node[2*idx+2].minev)
			{
				node[idx].minev=node[2*idx+1].minev;
	    	node[idx].ct=node[2*idx+1].ct;
			}
			else if(node[2*idx+1].minev>node[2*idx+2].minev)
			{
				node[idx].minev=node[2*idx+2].minev;
	    	    node[idx].ct=node[2*idx+2].ct;
			}
			else
			{
				node[idx].minev=node[2*idx+2].minev;
				node[idx].ct=node[2*idx+2].ct+node[2*idx+1].ct;
			}
		}
	}
}
T query(int idx,int ss,int se,int qs,int qe)
{
	T node1,node2,node3;
	int mid=(ss+se)/2;
	
	if(qs>se||qe<ss)
	{
		node3.minev=-1;
		node3.ct=0;
		return node3;
	}
	else if(qs<=ss && qe>=se||ss==se)
	return node[idx];
	else
	{
		if(qe<=mid)
		return query(2*idx+1,ss,mid,qs,qe);
		else if(qs>mid)
		return query(2*idx+2,mid+1,se,qs,qe);
		else
		{
			node1=query(2*idx+1,ss,mid,qs,qe);
			node2=query(2*idx+2,mid+1,se,qs,qe);
			
			
		if(node1.minev==-1 && node2.minev==-1)
		{
			node3.minev=-1;
	    	node3.ct=0;
		}
		else if(node1.minev==-1)
		{
			node3.minev=node2.minev;
	    	node3.ct=node2.ct;
		}
		else if(node2.minev==-1)
		{
			node3.minev=node1.minev;
	    	node3.ct=node1.ct;
		}
		else
		{
			if(node1.minev<node2.minev)
			{
			   node3.minev=node1.minev;
	    	node3.ct=node1.ct;
			}
			else if(node2.minev<node1.minev)
			{
					node3.minev=node2.minev;
	    	node3.ct=node2.ct;
			}
			else
			{
				node3.minev=node2.minev;
	    	     node3.ct=node2.ct+node1.ct;
			}
		}
			return node3;
		}
	}
}
int main()
{
int t,i;
int type,n1,n2;
int n,q;
t=1;
while(t--)
{
	int f;
	s(n);s(q);
	for(i=0;i<n;++i)
     ar[i]=fcin();
//	
	/*for(i=0;i<=8;++i)
	{
		cout<<node[i].minev<<" "<<node[i].ct<<endl;
	}*/
	build_tree(0,0,n-1);
 
	while(q--)
	{
		type=fcin();
		n1=fcin();
		n2=fcin();
		if(type==1)
		{
		T node4=query(0,0,n-1,n1-1,n2-1);
		 printf("%d %d\n",node4.minev,node4.ct);
	    }
	    else
	    {
	     update(0,0,n-1,n1-1,n2);
	    }
	}
}
	return 0;
} 