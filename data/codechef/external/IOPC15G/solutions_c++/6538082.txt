/*Programmed by Ayush Jaggi*/

#include<bits/stdc++.h>

using namespace std;

#define pb push_back
#define mp make_pair
#define F first
#define S second
#define L(i,x,y) for(i=x;i<y;i++)
#define l0(i,x) for(i=0;i<x;i++)
#define l1(i,x) for(i=1;i<x;i++)
#define pd(n) printf("%d",n)
#define pdn(n) printf("%d\n",n)
#define pds(n) printf("%d ",n)
#define plld(n) printf("%lld",n)
#define plldn(n) printf("%lld\n",n)
#define pllds(n) printf("%lld ",n)
#define pc(n) printf("%c",n)
#define pn printf("\n")
#define ps printf(" ")
#define plf(n) printf("%.6lf",n)
#define plfn(n) printf("%.6lf\n",n)
#define plfs(n) printf("%.6lf ",n)
#define pllf(n) printf("%.6llf",n)
#define pllfn(n) printf("%.6llf\n",n)
#define pllfs(n) printf("%.6llf ",n)
#define psn(n) printf("%s\n",n)
#define pss(n) printf("%s ",n)
#define sd(n) scanf("%d",&n)
#define sld(n) scanf("%ld",&n)
#define slld(n) scanf("%lld",&n)
#define slf(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define sc(n) scanf("%c",&n)
#define mem(n,m) memset(n,m,sizeof(n))
#define W(t) while(t--)

typedef long long LL;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef vector<string> VS;

/*template<class T> inline T gcd(T a, T b)
{
    return b ? gcd(b, a % b) : a;
}
inline void prime()
{
    int s, d, count=0;
    lb=sqrt(n);
    for(s=2; s<=lb; s++)
        if(!pr[s])
        {
            sieve[count++]=s;
            for(d=s*s; d<=n; d+=s)
                pr[d]=1;
        }
}

inline LL expo(LL base, int nent)
{
    if(nent==1)
        return base;
    else if(nent&1)
    {
        LL temp=expo(base,nent/2);
        temp=temp*temp*base;
        if(temp>=MOD)
            temp%=MOD;
        return temp;
    }
    else
    {
        LL temp=expo(base,nent/2);
        temp*=temp;
        if(temp>=MOD)
            temp%=MOD;
        return temp;
    }
}*/

LL MOD=1000000007, ans;
string str1, str2, str;
int sa[100005], pos[100005], lcp[100005], tmp[100005], gap, len, i, j, k, l1, fflag, beg, end, cur_beg, temp, t;
//sorting can be improved in suffix arrays from std::sort to stable_sort or radix sort to make the complexity O(n) from O(nlogn)

inline bool sufcmp(int x, int y)
{
    if(pos[x]!=pos[y])
        return pos[x]<pos[y];
    x+=gap;
    y+=gap;
    return (x<len && y<len) ? pos[x]<pos[y] : x>y;
}

inline void build_sa()
{
    len=str.length();
    l0(i,len)
    {
        pos[i]=str[i];
        sa[i]=i;
    }
    for(gap=1;; gap*=2)
    {
        sort(sa,sa+len,sufcmp);
        tmp[0]=0;
        l1(i,len)
        tmp[i]=tmp[i-1]+sufcmp(sa[i-1],sa[i]);
        l0(i,len)
        pos[sa[i]]=tmp[i];
        if(tmp[len-1]==len-1)
            break;
    }
}

inline void build_lcp()
{
    k=0;
    l0(i,len)
    {
        if(pos[i]!=len-1)
            for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);
        lcp[pos[i]]=k;
        if(k)k--;
    }
}

/*inline void build_lcp()
{
    k=0;
    l0(i,l1)
    if(pos[i]!=len-1)
    {
        for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);
        lcp[pos[i]]=k;
        if(j>l1)
            if(k>ans)
            {
                ans=k;
                beg=j;
                end=beg+k;
                flag[j]=1;
                val[j].nlcp=k;
            }
            else if(k && k==ans)
            {
                if(j<beg)
                {
                    beg=j;
                    end=beg+k;
                }
                flag[j]=1;
                val[j].nlcp=k;
            }
        if(k)
            k--;
    }
    else
        k=0;
    k=0;
    L(i,l1+1,len)
    if(pos[i]!=len-1)
    {
        for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);
        lcp[pos[i]]=k;
        if(j<l1)
        {
            if(k>ans)
            {
                ans=k;
                if(val[i].nlcp>=k)
                    beg=val[i].start;
                else
                    beg=i;
                end=beg+k;
            }
            else if(k && k==ans)
            {
                //if(i==20)
                //cout<<"hi";
                if(val[i].nlcp>=k && val[i].start<beg)
                {
                    beg=val[i].start;
                    end=beg+k;
                }
                else if(i<beg)
                {
                    beg=i;
                    end=beg+k;
                }
            }
        }
        else if(flag[i] && val[i].nlcp==ans && k>=ans)
        {
            if(j<beg)
            {
                beg=j;
                end=beg+ans;
            }
            flag[j]=1;
            val[j].nlcp=ans;

        }
        else if(j>i)
        {
            val[j].nlcp=k;
            val[j].start=i;
        }
        if(k)
            k--;
    }
    else
        k=0;
}*/

int main()
{
    //cout<<val[5].nlcp<<" "<<val[7].start<<endl;
    sd(t);
    while(t--)
    {
        sd(l1);
        sd(temp);
        cin>>str1>>str2;
        str=str1+'$'+str2;
        build_sa();
        build_lcp();
        //cout<<val[20].nlcp<<" "<<val[20].start<<endl;
        /*l0(i,len)
        cout<<sa[i]<<" ";
        cout<<endl;
        l0(i,len)
        cout<<lcp[i];
        cout<<endl;
        l0(i,len)
        cout<<flag[i]<<" ";
        cout<<endl;*/
        /*L(i,beg,end)
        pc(str[i]);
        if(ans)
            pn;*/
        temp=0;
        ans=0;
        //l0(i,len)
        //cout<<lcp[i]<<" ";
        //cout<<endl;

        l1(i,len-1)
        {
            //cout<<lcp[i];
            //cout<<lcp[i];
            temp=min(temp,lcp[i]);
            if((sa[i]<l1 && sa[i+1]>l1) || (sa[i]>l1 && sa[i+1]<l1))
                //if(temp<lcp[i])
            {
                ans+=(lcp[i]-temp);
                temp=lcp[i];
            }
        }
        plldn(ans);
    }
    return 0;
}
