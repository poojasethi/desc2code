#include <iostream>
#include<stack>
#include<string>
#include<vector>
#include<set>
#include<queue>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<algorithm>
using namespace std;

#define gc getchar
#define p 1000000007
#define MOD 1000000007
#define pc(x) putchar(x);
#define pi(n) printf("%d",n)
#define pis(n) printf("%d ",n)
#define pin(n) printf("%d\n",n)
#define pll(n) printf("%lld",n)
#define ps printf(" ")
#define pn printf("\n")
#define rep(i,n) for(i=0;i<n;i++)
#define fu(i,a,n) for(i=a;i<=n;i++)
#define fd(i,n,a) for(i=n;i>=a;i--)
#define INV 333333336
#define ll long long
#define EPS 1e-9
#define infi 2000000000

inline int sn()
{
    int n=0;
    int ch=gc();
    while( ch <48 )ch=gc();
    while( ch >47 )
    n = (n<<3)+(n<<1) + ch-'0', ch=gc();
        return n;
}

typedef struct
{
	int a,b;
}node;

node arr[1000];
int arr1[105][2000];

void partition(int low,int high);
void mergeSort(int low,int mid,int high);
void partition(int low,int high){

    int mid;

    if(low<high){
         mid=(low+high)/2;
         partition(low,mid);
         partition(mid+1,high);
         mergeSort(low,mid,high);
    }
}

void mergeSort(int low,int mid,int high){

    int i,m,k,l;
    node temp[1000];

    l=low;
    i=low;
    m=mid+1;

    while((l<=mid)&&(m<=high)){

         if((arr[l].b<arr[m].b)||(arr[l].b==arr[m].b && arr[l].a<=arr[m].a)){
             temp[i]=arr[l];
             l++;
         }
         else{
             temp[i]=arr[m];
             m++;
         }
         i++;
    }

    if(l>mid){
         for(k=m;k<=high;k++){
             temp[i]=arr[k];
             i++;
         }
    }
    else{
         for(k=l;k<=mid;k++){
             temp[i]=arr[k];
             i++;
         }
    }

    for(k=low;k<=high;k++){
         arr[k]=temp[k];
    }
}


int f(int n, int tym)
{
	int h;
							//printf("inside %d %d\n",n,tym);
	if(arr1[n][tym]!=-1)
	{
		return arr1[n][tym];
	}
	if(n==1)
	{
		if(tym>=arr[1].a) h=0;
		else h=1;
							//printf("	outside %d %d -> %d\n",n,tym,h);
		arr1[n][tym]=h;
		return h;
	}

	if(tym<arr[n].a) 
		h=1+f(n-1,min(tym,arr[n-1].b));
	else
		h=min( 1 + ( f(n-1,min(tym,arr[n-1].b)) ) , f(n-1,min(tym-arr[n].a,arr[n-1].b)) );
	
							//printf("	outside %d %d -> %d\n",n,tym,h);
	arr1[n][tym]=h;
	return h;
	
}

int main()
{
	int t;
	t=sn();
	for(int q=1;q<=t;q++)
	{
		int n,i,j;
		n=sn();
		fu(i,1,n) arr[i].a=sn();
		fu(i,1,n) 
		{
			scanf("%d",&arr[i].b);
			arr[i].b-=30;
			if(arr[i].b<0) arr[i].b=1998;
		}
		partition(1,n);
		rep(i,n+1) rep(j,2000) arr1[i][j]=-1;
								/*fu(i,1,n)
								{
									printf("%d %d %d\n",i,arr[i].a,arr[i].b);
								}*/
		printf("Case %d: ",q);			
		pin(f(n, arr[n].b));		
					
	}
  	
    return 0;
}













