//Common headers
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<utility>
#include<algorithm>
#include<string>

using namespace std;


#define ipair std::pair< int, int >
#define ull unsigned long long
#define traverse(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define rtraverse(container, it) for(typeof(container.rbegin()) it = container.rbegin(); it != container.rend(); it++)
/*
	Initialize count to the number of people who don't need to leave
	
	Sort DESC according to departure
		Start from last leaving person. If yes, Subtract the time from time remaining, Else add to heap
		
	
*/

#define TOLERANCE 1e-5

bool departureSort(const ipair &a, const ipair &b){
	return ( a.second < b.second );
}

bool durationSort(const ipair& a,const ipair& b){
	if( a.first == b.first )
		return (a.first > b.second);	//Later ones are better... Not really.
	else
		return (a.first < b.first);
}

int main(){
	int testCases= 0;
	cin >> testCases;
	
	for(int tc=1;tc<=testCases;tc++){
		int K;
		cin >> K;
		
		
		ipair read[K];	// first => Duration, Second => departure
		//Read durations
		for(int i=0;i<K;i++){
			cin >> read[i].first;
		}
		//Read departures
		for(int i=0;i<K;i++){	
			cin >> read[i].second;
		}
		vector<ipair> times;
		for(int i=0;i<K;i++){
			if( read[i].second != -1)
				times.push_back(read[i]);
		}
		
		sort( times.begin(), times.end(), departureSort);	//Sort according to
		vector<ipair> timeLeft;	//timeLeft[i] Stores the timeLeft in timeslots before the given time
		
		map<int,int> tmap; //maps the time to the index
		
		int i=0;
		ipair buf;
		buf.first = -1;
		traverse(times,it){
			if( (it->second) == (buf.first) )
				continue ; // No need for duplicates
			buf.first = it->second;
			buf.second = it->second - 30;
			timeLeft.push_back(buf);
			tmap[it->second] = i;
			i++;
		}
		
		
		const int tSize = times.size();
		int ans = 0;
		sort(times.begin(),times.end(), durationSort);//Sorted according to duration.
		
		int index;
		
		
		
		
		
		bool canAcco;
		traverse( times , t){
			index = tmap[t->second];
			
			//Do a quick check that we're all good to add this guy
			
			canAcco = true;
			for(int i=index;i<timeLeft.size();i++){
				if(  t->first > timeLeft[i].second ){

					ans++;
					canAcco = false;
					break;
				}
			}
			if(!canAcco)
				continue;
			
			for(int i=index;i< timeLeft.size();i++){
				timeLeft[i].second -= t->first;
			}
		}
		
		printf("Case %d: %d\n", tc, ans);
		
	}
	return 0;
}