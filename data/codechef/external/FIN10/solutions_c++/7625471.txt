#include <stdio.h>
#include <string.h>
#include <queue>
#include <algorithm>
using namespace std;

struct P
{
    int r, c;
}mid;

char maze[1005][1005];
int step_j[1005][1005];
int step_f[1005][1005];
int r, c;
int rmove[4] = {1, -1, 0, 0};
int cmove[4] = {0, 0, 1, -1};

queue<P> q;

void bfs(P joe)
{
    // 搜 fire
    while(!q.empty())
    {
        for(int i = 0; i < 4; i++)
        {
            P p = q.front();
            int nr = p.r + rmove[i], nc = p.c + cmove[i];
            if(0 <= nr && nr < r && 0 <= nc && nc < c && maze[nr][nc] != '#' && step_f[nr][nc] == 0)
            {
                step_f[nr][nc] = step_f[p.r][p.c] + 1;
                mid.r = nr, mid.c = nc;
                q.push(mid);
            }
        }
        q.pop();
    }

    // 搜 joe
    q.push(joe);
    while(!q.empty())
    {
        for(int i = 0; i < 4; i++)
        {
            P p = q.front();

            if(p.r == 0 || p.r == r - 1 || p.c == 0 || p.c == c - 1)
            {
                printf("%d\n", step_j[p.r][p.c]);
                return ;
            }

            int nr = p.r + rmove[i], nc = p.c + cmove[i];
            if(0 <= nr && nr < r && 0 <= nc && nc < c && maze[nr][nc] != '#' && step_j[nr][nc] == 0 && (step_j[p.r][p.c] + 1 < step_f[nr][nc] || step_f[nr][nc] == 0) )
            {
                step_j[nr][nc] = step_j[p.r][p.c] + 1;
                mid.r = nr, mid.c = nc;
                q.push(mid);
            }
        }
        q.pop();
    }

    printf("IMPOSSIBLE\n");
}

int main()
{
    memset(step_j, 0, sizeof(step_j));
    memset(step_f, 0, sizeof(step_f));
        
    scanf("%d%d", &r, &c);
    for(int i = 0; i < r; i++)
        scanf("%s", maze[i]);

    P joe;
    for(int i = 0; i < r; i++)
        for(int j = 0; j < c; j++)
        {
            if(maze[i][j] == 'J')
            {
                step_j[i][j] = 1;
                joe.r = i, joe.c = j;
            }
            if(maze[i][j] == 'F')
            {
                step_f[i][j] = 1;
                mid.r = i, mid.c = j;
                q.push(mid);
            }
        }

    bfs(joe);

    return 0;
}
