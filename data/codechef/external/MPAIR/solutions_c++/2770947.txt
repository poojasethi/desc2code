//{{{
#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
//#undef thecodegame
#ifdef thecodegame
    #include<debug.h>
#else
    #define DBG_ARR(a,b,c) {}
    #define DBG_MAT(a,s,b,c) {}
    #define DBG_VECT(a) {}
    #define db(...) {}
    #define dbt(x, ...) {}
#endif

using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}}
#define MOD 	 1000000007LL
#define LL 		 long long
#define ULL      unsigned long long
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define SD(n)    scanf("%d",&n)
#define SD2(n,m) scanf("%d %d",&n,&m)
#define SLL(n)   scanf("%lld",&n)
#define SLU(n)   scanf("%llu",&n)
#define SS(n)    scanf("%s",n)
#define pnl      printf("\n")
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second

const double PI=acos(-1.0);
const double EPS=1e-11;
template<typename T>inline T mod(T N,T M){return (N%M+M)%M;}
double start;//time
#ifdef amy
    #define getcx getchar
#else
	#define SD(x) inp(x)
	#define SD2(x,y) SD(x);SD(y);
    #define getcx getchar_unlocked
#endif
template<typename T>inline void inp(T &n){
    n=0;int ch=getcx();int sign=1;
    while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}
    while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}
    n=n*sign;
}

//}}}
#define SIZE 100000009
#define MAXX 100000009

void pre(){}//end precompute
class Set{
    vector<int>pset,prank;
    public:
    Set(int n){
        pset.resize(n);
        prank.assign(n,1);
        REP(i,n){
            pset[i]=i;
        }
    }
    int getSet(int i){
        return pset[i];
    }
    int getRank(int i){
        return prank[i];
    }
    int findSet(int i){
        if(pset[i]==i){
            return i;
        }
        return  pset[i]=findSet(pset[i]);
    }
    bool isSameSet(int i,int j){
        return findSet(i)==findSet(j);
    }
    void unionSet(int i,int j){
        int x=findSet(i),y=findSet(j);
        if(x==y){
            return;
        }
        if(prank[x]<prank[y]){
            pset[x]=y;
            prank[y]+=prank[x];
        }else{
            pset[y]=x;
            prank[x]+=prank[y];
        }
    }
};
LL nc2(LL x){
    return (x*(x-1))>>1;
}
int N,M,x,y;
LL ans;
int arr[SIZE];
void doThis(int ccc){
    SD2(N,M);
    ans = nc2(N);
    if(!M){
        printf("%lld\n",ans);
        return;
    }
    Set s(N);
    REP(i,M){
        SD2(x,y);
        s.unionSet(x-1,y-1);
    }
    REP(i,N){
        if(s.getSet(i)==i){
            ans-=nc2(s.getRank(i));
        }
    }
    printf("%lld\n",ans);

}//end doThis
int main(){
start = clock();
ios_base::sync_with_stdio(false);
#ifdef amy
	freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\out.txt","w",stderr);
#endif
pre();
int cases = 1;
//SD(cases);
FORE(i,1,cases){doThis(i);}
#ifdef amy
	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)(clock()-start)/(CLOCKS_PER_SEC));
#endif
//while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D
return 0;
}//end main
