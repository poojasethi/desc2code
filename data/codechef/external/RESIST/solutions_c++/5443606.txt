#include<iostream>
using namespace std;

class Matrix {
	public:
		int rows;
		int cols;
		long long** m;
		Matrix(int rows, int cols) {
			this->rows = rows;
			this->cols = cols;
			m = new long long*[rows];
			for(int i=0;i<rows;i++){
				m[i] = new long long[cols];
			}
		}
};

Matrix matrixMultiplicationUtil(Matrix a, Matrix b, int dimension, int M) {
	Matrix c(dimension, dimension);
	for(int i=0; i<dimension; i++) {
		for(int j=0; j < dimension; j++ ) {
			c.m[i][j] = 0;
			//cout << "Hello " << endl;
			for(int k=0;k<dimension; k++) {
				c.m[i][j] = c.m[i][j] + a.m[i][k]*b.m[k][j];  
			}
			c.m[i][j] = c.m[i][j]%M;
		}
	}
	//cout << c.m[0][0] <<  " " << c.m[0][1] << " " << c.m[1][0] << " " << c.m[1][1] << endl;
	return c;
}

Matrix matrixMultiplication(Matrix a, int dimension, int N, int M) {
	if(N == 1) {
		return a;
	}
	//cout << "Hello" << endl;
	Matrix c = matrixMultiplication(a, dimension, N/2, M);
	//cout << c.m[0][0] <<  " " << c.m[0][1] << " " << c.m[1][0] << " " << c.m[1][1] << endl;
	c = matrixMultiplicationUtil(c, c, dimension, M);
	if(N%2 == 1) {
		c = matrixMultiplicationUtil(c, a, dimension, M);
	}
	return c;
}

int main() {
	
	int T;
	cin >> T;
	int dimension = 2;
	for(int t=0; t<T; t++) {
		long long N,M;
		cin >> N >> M;
		Matrix result(2,2);
		Matrix unityMatrix(2,2);
		unityMatrix.m[0][0] = unityMatrix.m[0][1] = unityMatrix.m[1][0] = 1;
		unityMatrix.m[1][1] = 0;
		long long num, denom;
		if(N==1) {
			cout << "1/1" << endl;
		}
		else {
			result = matrixMultiplication(unityMatrix, dimension, 2*(N-1), M);
			num = result.m[1][0] + result.m[1][1];
			denom = result.m[0][0] + result.m[0][1];
			cout << num%M << "/" << denom%M << endl;
		}
	}
	return 0;
}

/*
int gcd(int m, int n)     	// function definition
{                         	// block begin
   int  r;                	// declaration of remainder

   while (n != 0) {       	// not equal
      r = m % n;          	// modulus operator
      m = n;              	// assignment
      n = r;
   }                      	// end while loop
   return m;              	// exit gcd with value m
}

void populateResistance(int N, long long& num, long long& denom) {
	long long prevNum = num, prevDenom = denom;
	for(int i = 1; i < N; i++) {
		cout << "i = " << i << endl;
		num = prevNum + prevDenom;
		denom = prevDenom + num;
		long long gc = gcd(num, denom);
		num = num/gc;
		denom = denom/gc;
		cout << " Num = " << num << " Denom = " << denom << " GCD = " << gc << endl;
		prevNum = num;
		prevDenom = denom;
	}
}
*/