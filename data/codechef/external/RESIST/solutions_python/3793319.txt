def multiplyMatrices( A, B, K ):	#e.g. A = [ [1, 1], [1, 0] ], B = [ [ F(n) ], [ F(n-1) ] ]
	C = []
	if len(A[0]) != len(B):
		raise RuntimeError("These matrices cant be multiplied")
	for i in xrange(len(A)):
		C.append([])
		for k in xrange(len(B[0])):
			sum = 0
			for j in xrange(len(A[0])):
				sum += A[i][j] * B[j][k]
			C[i].append(sum%K)
	return C

def findNthPowerModK( M , n, k ):
	if n == 1:
		return M;
	R = findNthPowerModK( M , n/2, k )
	R = multiplyMatrices(R, R, k)  # matrix multiplication
	if n%2 == 1:
		R = multiplyMatrices(R, M, k)  # matrix multiplication
	return R




T = int(raw_input())


while T>0:
	T-=1
	N, M = map(int, raw_input().split())
	"""
	R = resistance_of_blocks(N)
	print(str(R[0])+"/"+str(R[1]))
	"""
	"""
	a=1
	b=1
	for i in xrange(2*(N-1)):
		c = a
		a = b
		b = (c+b) % M
	print(str(a%M)+"/"+str(b%M))
	"""
	if N==1:
		print("1/1")
		continue
	The_Famous_Fibonacci_Matrix = [ [1, 1], [1, 0] ]
	The_Nth_Fibonacci_Matrix = findNthPowerModK(The_Famous_Fibonacci_Matrix, 2*(N-1), M)
	The_F1_F0_Fib_Mat = [ [ 1 ], [ 1 ] ]
	The_Result_Matrix = multiplyMatrices( The_Nth_Fibonacci_Matrix, The_F1_F0_Fib_Mat, M )
	
	print(str(The_Result_Matrix[1][0]%M)+"/"+str(The_Result_Matrix[0][0]%M))