// profile : sunnyO4
/* Program to find number of moves to move first empty cell to nearest empty cell such that order should be maintained.  given all cell are ordered in increasing order from left to right and top to bottom. Cell value in less than its right and down cell. Empty cell has value = INF. Cell represent car parking place here.
Eg:
input::
123
456
789

3 INF
4 INF
output ::
4
1
Sample 1# : 1 will be removed then created empty cell can move to replace cell 2, 3 , 6, 9. so ans = 4.
Sample 2# : 3 will be removed then empty cell can only move down.
*/
// fundamentals headers
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <cstdio>
#include <cmath>
#include <bitset>
#include <cassert>
#include <map>
#include <set>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <ctime>
// Include all header files
// #include <bits/stdc++.h>

using namespace std;

#define SIZE        40000
#define EPS         1.0E-8
#define nmax        100010
#define mmax        100010
#define eql(a,b)    fabs(a-b) < EPSILON
#define mp          make_pair
#define pb          push_back
#define ppb         pop_back
#define sd          second
#define fs          first
#define TRACE

#define FOR(i,a,b)                  for(int i=a;i<b;i++)
#define RFOR(i,a,b)                 for(int i=a;i>=b;i--)
#define s(n)                        scanf("%d",&n)
#define su(n)                       scanf("%u",&n)
#define sl(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)

#ifdef TRACE
    #define trace1(x)                cerr << #x << ": " << x << endl;
    #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
    #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
    #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
    #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
    #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif



typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair<int,int> pint;
typedef vector<string> vs;
typedef vector<int> vi;

int park[102][102];
int m,n,INF = 2147483647;

int count_move(int curr_i, int curr_j,int count)
{
    //trace3(curr_i, curr_j, count);
    if(curr_i < m && curr_j < n && park[curr_i][curr_j] != INF)
    {
        if (park[curr_i][curr_j+1] > park[curr_i+1][curr_j]){
            count++;
            count_move(curr_i+1,curr_j,count);
        }
        else if(park[curr_i][curr_j+1] < park[curr_i+1][curr_j]){
            count++;
            count_move(curr_i,curr_j+1,count);
        }
        else
            return count;
    }

}

int main()
{

    //freopen("read.in","r",stdin);
    //freopen("out.in","w",stdout);

    int tc,c=0;
    s(tc);


    while(tc--)
    {
        s(m); s(n);
        FOR(i,0,m)
        {
            FOR(j,0,n)
                s(park[i][j]);
        }
        FOR(i,0,m+1)
            park[i][n] = INF;
        FOR(j,0,n+1)
            park[m][j] = INF;
/*
        FOR(i,0,m+1)
        {
            FOR(j,0,n+1)
                printf("%d ",park[i][j]);
            printf("\n");
        }
*/
        printf("%d\n",count_move(0,0,0));

    }

    return 0;
}
