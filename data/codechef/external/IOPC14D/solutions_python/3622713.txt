#include <bits/stdc++.h>
#define REP(i,n) for(int i=0; i<(int)(n); ++i)

using namespace std;

class OnlineTopologicalSort{
    typedef vector<int> Node;
    typedef vector<Node> Graph;

    Graph G; // グラフ
    vector<int> order; // 頂点uの順位
    vector<int> order_inv; // 順位iの頂点
    vector<bool> color; // dfsで辿れるノードを保存する
    int lb, ub;

    // 頂点xの順位をiに定める
    inline void allocate(int x, int i){
        order[x] = i;
        order_inv[i] = x;
    }

    // 順位がub以下の頂点を経由して辿れる頂点に色を塗る
    void dfs(int v){
        color[v] = true;
        for(int i = 0; i < G[v].size(); i++){
            int next = G[v][i];
        // for(int next : G[v]){
            if(order[next] < ub && !color[next]){
                dfs(next);
            }
        }
    }

    // 色が塗られた頂点を右側に寄せる
    void shift_node(){
        vector<int> shift;
        for(int i = lb; i <= ub; i++){
            int w = order_inv[i];
            if(color[w]){
                color[w] = false;
                shift.push_back(w);
            }else{
                allocate(w, i - shift.size());
            }
        }
        for(int i = 0; i < shift.size(); i++){
            allocate(shift[i], ub - shift.size() + i + 1);
        }
    }

    public: 

    // 頂点数N
    OnlineTopologicalSort(int N) : 
        G(N), order(N), order_inv(N), color(N)
    {
        for(int i = 0; i < N; i++){
            allocate(i, i);
        }
    }

    // 有向辺 a -> b を加える
    void add_edge(int a, int b){
        G[a].push_back(b);
        lb = order[b];
        ub = order[a];
        if(lb < ub){ // bがaよりも左側にあるとき
            dfs(b); // bから辿れる頂点を列挙する
            shift_node(); // bから辿れる頂点を右側に，残りの頂点を左側に，順序を保ったまま移動する
        }
    }

    // 頂点uのトポロジカル順序 (0-based index)
    int get_order(int u) const {
        return order[u];
    }

    // トポロジカル順序がnth番目の頂点 (0-based index)
    int get_node(int nth) const {
        return order_inv[nth];
    }

};


int main(){
    int T;
    cin >> T;
    while(T--){
        int N;
        cin >> N;
        char str[64];
        bool rev = false;
        OnlineTopologicalSort solver(N);
        while(true){
            scanf("%s", str);
            if(str[0] == 'E') break;
            int a, b;
            scanf("%d %d", &a, &b);
            a--; b--;
            if(str[0] == 'U'){
                if(rev) swap(a, b);
                solver.add_edge(a, b);
            }else{
                a = solver.get_order(a);
                b = solver.get_order(b);
                if(a < b){
                    cout << "YES" << endl;
                }else{
                    cout << "NO" << endl;
                    rev ^= 1;
                }
            }
        }
    }
    return 0;
}
