#include <iostream>
#include <vector>
#include <queue>
using namespace std;
typedef vector<int> VI;
typedef vector<VI> VVI;

VI depth;
VVI G;
int dfs(int u, int p = -1) {
  depth[u] = 0;
  for (int v : G[u]) if (v != p) {
    depth[u] = max(depth[u], 1 + dfs(v, u));
  }
  return depth[u];
}

int num(int u, int d, int p = -1) {
  int ans = 1;
  int qnt = 0;
  int which = 0;
  for (int v : G[u]) {
    if (depth[v] == d) {
      ++qnt;
      which = v;
    }
  }
  if (qnt == 1) {
    ans += num(which, d-1, u);
  }
  return ans;
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  int T; cin >> T;
  while (T--) {
    int N; cin >> N;
    G = VVI(N);
    VI degree(N, 0);
    for (int i = 1; i < N; ++i) {
      int x; cin >> x;
      G[i].push_back(x);
      G[x].push_back(i);
      ++degree[i];
      ++degree[x];
    }
    queue<int> leaves;
    for (int i = 0; i < N; ++i) {
      if (degree[i] == 1) {
        leaves.push(i);
      }
    }
    int root = 0;
    while (!leaves.empty()) {
      int u = leaves.front(); leaves.pop();
      root = u;
      for (int v : G[u]) {
        if (--degree[v] == 1) {
          leaves.push(v);
        }
      }
    }
    depth = VI(N, 0);
    dfs(root);
    int d1 = 0, d2 = 0;
    for (int u : G[root]) {
      if (depth[u] >= d1) {
        swap(d1, d2);
        d1 = depth[u];
      } else if (depth[u] > d2) {
        d2 = depth[u];
      }
    }
    int ans = 1;
    int num_d1 = 0;
    int num_d2 = 0;
    for (int u : G[root]) {
      if (depth[u] == d1) ++num_d1;
      if (depth[u] == d2) ++num_d2;
    }
    if (d1 != d2) {
      for (int u : G[root]) {
        if (depth[u] == d1 && num_d1 == 1) {
          ans += num(u, d1-1, root);
        } else if (depth[u] == d2 && num_d2 == 1) {
          ans += num(u, d2-1, root);
        }
      }
    } else {
      for (int u : G[root]) {
        if (depth[u] == d1 && num_d1 <= 2) {
          ans += num(u, d1-1, root);
        }
      }
    }
    cout << ans << endl;
  }
}
