//Author : pakhandi
//
using namespace std;

#include<bits/stdc++.h>

#define wl(n) while(n--)
#define fl(i,a,b) for(i=a; i<b; i++)
#define rev(i,a,b) for(i=a; i>=b; i--)

#define si(n) scanf("%d", &n)
#define sll(l) scanf("%lld",&l)
#define ss(s) scanf("%s", s)
#define sc(c) scanf("%c", &c)
#define sd(f) scanf("%lf", &f)

#define pi(n) printf("%d\n", n)
#define pll(l) printf("%lld\n", l)
#define ps(s) printf("%s\n", s)
#define pc(c) printf("%c\n", c)
#define pd(f) printf("%lf\n", f)

#define debug(x) cout<<"\n#("<<x<<")#\n"
#define nline printf("\n")

#define mem(a,i) memset(a,i,sizeof(a))

#define MOD 1000000007
#define ll long long int
#define u64 unsigned long long int

#define mclr(strn) strn.clear()
#define ignr cin.ignore()
#define PB push_back
#define SZ size
#define MP make_pair
#define fi first
#define sec second

std::vector<int> adj[100005];
int dist[100005];
bool vis[100005];

std::vector<int> path;

std::vector<int> C, X;

int counts[100005];
int nodes;
int center[2];

int endNode, startNode;

int diameter, radius;

void dfs(int node, int level)
{
	if(vis[node])
		return;
	vis[node] = 1;
	dist[node] = level;

	int i, limit = adj[node].SZ();

	fl(i,0,limit)
	{
		int v = adj[node][i];
		dfs(v,level+1);
	}

	return;
}

pair<int,pair<int,int> > getDiameter()
{
	int i;

	int maxDist = -1, newMaxDist = -1;
	int farthestNode = 0, newFarthestNode = 0;

	fl(i,0,nodes)
		vis[i] = 0;
	dfs(0,0);

	fl(i,0,nodes)
	{
		if(dist[i] > maxDist)
		{
			maxDist = dist[i];
			farthestNode = i;
		}
	}

	fl(i,0,nodes)
		vis[i] = 0;
	dfs(farthestNode,0);

	fl(i,0,nodes)
	{
		if(dist[i] > newMaxDist)
		{
			newMaxDist = dist[i];
			newFarthestNode = i;
		}
	}

	if(newMaxDist > maxDist)
		return MP(newMaxDist, MP(farthestNode,newFarthestNode));
	return MP(maxDist , MP(0,farthestNode) );
}

int getCenter(int node)
{
	if(node == endNode)
	{
		path.PB(node);
		return 1;
	}

	if(vis[node])
		return 0;

	int ret = 0;

	vis[node] = 1;

	int i, limit = adj[node].SZ();

	fl(i,0,limit)
	{
		int v = adj[node][i];
		ret |= getCenter(v);
	}

	if(ret == 1)
		path.PB(node);
	return ret;
}

int magic(int node, int level, int thisCenter)
{
	if(vis[node] || node == center[!thisCenter])
		return 0;
	if(level==0)
	{
		counts[node] = 1;
		return 1;
	}
	vis[node] = 1;

	int ret = 0;

	int i, limit = adj[node].SZ();

	fl(i,0,limit)
	{
		int v = adj[node][i];
		ret += magic(v, level-1,thisCenter);
	}

	counts[node] = ret;

	return ret;
}

int solve(int node, int parent, int val)
{
	if(counts[node] != val)
		return 0;
	if(vis[node] || node == parent)
		return 0;
	vis[node] = 1;

	int i, limit = adj[node].SZ();

	int ret = 0;

	fl(i,0,limit)
	{
		int v = adj[node][i];

		ret = max(ret, 1+solve(v,parent,val));
	}

	return ret;
}

int main()
{
	int i, j;

	int cases;

	si(cases);

	wl(cases)
	{
		si(nodes);

		//---------------

		fl(i,0,nodes)
		{
			adj[i].clear();
		}

		ll ans = 0;

		center[0] = center[1] = -1;

		path.clear();
		C.clear();
		X.clear();

		//---------------

		fl(i,0,nodes-1)
		{
			int temp;
			si(temp);

			adj[i+1].PB(temp);
			adj[temp].PB(i+1);
		}

		pair<int,pair<int,int> > diaTriplet = getDiameter();

		diameter = diaTriplet.first;
		radius = diameter / 2;

		startNode = diaTriplet.second.first;
		endNode = diaTriplet.second.second;

		fl(i,0,nodes)
			vis[i] = 0;
		getCenter(startNode);

		int inlimit = path.SZ();

		int target = inlimit / 2;

		center[0] = path[target];

		if(inlimit%2 == 0)
			center[1] = path[target - 1];

		fl(i,0,nodes)
			vis[i] = 0;
		magic(center[0],radius,0);
		if(center[1] != -1)
		{
			fl(i,0,nodes)
				vis[i] = 0;
			magic(center[1],radius,1);
		}

		int u = center[0];
		inlimit = adj[u].SZ();

		fl(i,0,nodes)
			vis[i] = 0;

		fl(i,0,inlimit)
		{
			int v = adj[u][i];
			if(v == center[1])
				continue;
			if(counts[v]==0) continue;
			int val = solve(v,u,counts[v]) ;
			if(val != 0)
				C.PB(val);
		}

		if(center[1] != -1)
		{
			u = center[1];
			inlimit = adj[u].SZ();
			fl(i,0,inlimit)
			{
				int v = adj[u][i];
				if(v == center[0])
					continue;
				if(counts[v]==0) continue;
				int val = solve(v,u,counts[v]) ;
					if(val != 0)
						X.PB(val);
			}
			sort(X.begin(), X.end());
			reverse(X.begin(), X.end());
		}

		sort(C.begin(), C.end());
		reverse(C.begin(), C.end());

		if(center[1] == -1)
		{
			if(C.SZ() == 2)
			{
				ans = C[0] + C[1] + 1;
			}
			else
			{
				ans = 1;
			}
		}
		else
		{
			if(C.SZ()==1 && X.SZ()==1)
				ans = C[0] + X[0] + 2;
			else
				ans = 2;
		}
		printf("%lld\n",ans);

	}


	return 0;
}
/*
	Powered by Buggy Plugin
*/
