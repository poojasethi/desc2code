#include <bits/stdc++.h>
using namespace std;
const int MAX = 100050;
 
int N, D, E[MAX], M[MAX], C[MAX], allow;
vector < int > adj[MAX];
pair < int, int > DP[MAX];
 
void dfs(int u, int p){
 	DP[u].first = DP[u].second = 0;
    for(auto v: adj[u]){ 
	    if(v == p) continue;
	    dfs(v, u);
	    if(DP[v].first + 1 >= DP[u].first){
	    	DP[u].second = DP[u].first;
	    	DP[u].first  = DP[v].first + 1;
	    }
	    else if(DP[v].first + 1 > DP[u].second)
	    	DP[u].second = DP[v].first + 1;
	}
}

void dfs2(int u, int p, int val){
	E[u] = max(val, DP[u].first);
	for(auto v : adj[u]){
		if(v == p) continue;
		if(DP[u].first == DP[v].first + 1) 
		dfs2(v, u, max(val, DP[u].second) + 1);
		else
		dfs2(v, u, max(val, DP[u].first)  + 1);
	}
}
 
pair < int, int > get_center(){
 
    dfs(0, -1);
    dfs2(0, -1, 0);
    
    pair < int , int > res;
    res.first = res.second = -1;
    int val = 1e8;
    
    for(int i = 0 ; i < N ; i++){
    	if(E[i] < val) val = E[i];
    	if(E[i] > D) D = E[i];
    }
    
    for(int i = 0 ; i < N ; i++){
    	if(E[i] == val){
    		if(res.first == -1) res.first = i;
    		else res.second = i;
    	}
    }

    return res;
}
 
void dfs3(int u, int p, int d, int lvl = 1){
 
    if(d == 0){
    	M[u] = 1;
    	return;
    }
 
    for(auto v: adj[u]){ 
    	if(v == p) continue;
        dfs3(v, u, d - 1, lvl + 1);
        M[u] |= M[v];
        if(M[v]) C[u]++;
    }
    
    if(C[u] >= 2) allow = lvl; 
}
 
 
int main(){
 
	int T;
	scanf("%d",&T);
 
	while(T--){
	    
	    scanf("%d", &N);
	    
	    // Cleanup
	    D = 0;
	    for(int i = 0; i <= N ; i++) adj[i].clear();
	    memset(M, 0, sizeof M);
	    memset(C, 0, sizeof C);
	    memset(E, 0, sizeof E);

	    // Input Tree
	    int x;
	    for(int i = 1 ; i < N; i++){
	        scanf("%d", &x);
	        adj[i].push_back(x);
	        adj[x].push_back(i);
	    }
 	
 		// Find Diameter and Center(s)
	    pair < int, int > cen = get_center();
	    
	    // One Center Case
	    if(cen.second == -1){
 
	        int cnt = 0, ans = 0;
	        
	        for(auto v: adj[cen.first]){
	        	allow = D / 2;
	            dfs3(v, cen.first, D / 2 - 1);
	            if(M[v]) cnt++, ans += allow;
	        }
 
	        if(cnt >= 3) printf("1\n");
	        else printf("%d\n",ans + 1);
	    }

	    // Two Center Case
	    else{
 
	        int u1 = cen.first, u2 = cen.second;
	        int a = 0, b = 0, res1 = 0, res2 = 0;
 
	       	for(auto v: adj[u1]){
	       		if(v != u2){
	       			allow = D / 2;
	       			dfs3(v, u1, D / 2 - 1);
	       			if(M[v]) a++, res1 += allow;
	       		}
	       	}
	      
	        for(auto v: adj[u2]){
	       		if(v != u1){
	       			allow = D / 2;
	       			dfs3(v, u2, D / 2 - 1);
	       			if(M[v]) b++, res2 += allow;
	       		}
	       	}
 
 
	        if(a >= 2 and b >= 2) printf("2\n");
	        else if( a == 1 and b == 1) printf("%d\n", res1 + res2 + 2);
	        else if( a == 1 ) printf("%d\n", res1 + 2);
	        else printf("%d\n", res2 + 2);
	    }
	}
} 