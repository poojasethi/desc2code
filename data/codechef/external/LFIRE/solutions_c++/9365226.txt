#include <iostream>
#include <vector>
#include <string.h>
#include <queue>

using namespace std;

typedef pair<int,int> ii;
typedef vector<int> vi;
typedef vector<vi> vvi;

#define MAXN 100010

int n;
vvi fills;
int pare[MAXN];
int tree[MAXN];
int mxcami[MAXN],mxroot[MAXN];

int calcroot(int a){
  if(mxroot[a] == -1){
    mxroot[a] = 0;
    for(int i = 0; i < fills[a].size(); ++i){
      mxroot[a] = max(mxroot[a],1+calcroot(fills[a][i]));
    }
  }
  return mxroot[a];
}

int calccami(int a){
  if(mxcami[a] == -1){
    for(int i = 0; i < fills[a].size(); ++i){
      mxcami[a] = max(mxcami[a],calccami(fills[a][i]));
    }
    int maxim[2] = {0,0};
    for(int i = 0; i < fills[a].size(); ++i){
      int aux = calcroot(fills[a][i]);
      if(aux > maxim[0]){ maxim[1] = maxim[0]; maxim[0] = aux; }
      else if(aux > maxim[1]) maxim[1] = aux;
    }
    int val;
    if(fills[a].size() == 0) val = 0;
    else if(fills[a].size() == 1) val = 1+maxim[0];
    else val = 2+maxim[0]+maxim[1];
    mxcami[a] = max(mxcami[a],val);
  }
  return mxcami[a];
}

int main(){
  int t; cin >> t;
  for(int cass = 0; cass < t; ++cass){
    cin >> n;
    memset(tree,-1,sizeof(tree));
    memset(mxcami,-1,sizeof(mxcami));
    memset(mxroot,-1,sizeof(mxroot));
    fills = vvi(n);
    for(int i = 1; i < n; ++i){
      cin >> pare[i];
      fills[pare[i]].push_back(i);
    }
    for(int i = 0; i < n; ++i){
//       cout << i << endl;
      int aux = calcroot(i);
    }
    for(int i = 0; i < n; ++i){
//       cout << i << endl;
      int aux = calccami(i);
    }
    int length = mxcami[0];
    queue<int> q;
    q.push(0);
    int sol = 0;
    int index;
    while(!q.empty()){
      int aux = q.front(); q.pop();
      bool f = false;
//       cout << aux << endl;
      for(int i = 0; i < fills[aux].size(); ++i){
	if(mxcami[fills[aux][i]] == length){
	  q.push(fills[aux][i]);
	  f = true;
	}
      }
      if(!f){
	++sol;
	index = aux;
      }
    }
    int pata = 0;
    if(index != 0){
      int aux2 = pare[index];
      int aux3 = index;
      int depth = 1;
      while(aux2 != 0){
	for(int i = 0; i < fills[aux2].size(); ++i){
	  if(fills[aux2][i] != aux3) pata = max(pata,1+depth+calcroot(fills[aux2][i]));
	}
	aux3 = aux2;
	aux2 = pare[aux2];
	++depth;
	pata = max(pata,depth);
      }
      for(int i = 0; i < fills[aux2].size(); ++i){
	if(fills[aux2][i] != aux3) pata = max(pata,1+depth+calcroot(fills[aux2][i]));
      }
    }
    int maxim[2] = {0,0};
    int num[2] = {0,0};
    for(int i = 0; i < fills[index].size(); ++i){
      int aux = calcroot(fills[index][i])+1;
//       cout << fills[index][i] << ' ' << aux << endl;
      if(aux > maxim[0]){ maxim[1] = maxim[0]; maxim[0] = aux; num[1] = num[0]; num[0] = 1;}
      else if(aux > maxim[1]){ maxim[1] = aux; num[1] = 1; }
      else if(aux == maxim[1]) ++num[1];
    }
    if(pata == maxim[1]) ++num[1];
//     cout << pata << endl;
//     cout << "idx " << index << endl;
//     cout << maxim[0] << ' ' << maxim[1] << ' ' << num[1] << endl;
    queue<ii> q2;
    if(maxim[1] == maxim[0] and num[1] > 1){
      cout << sol << '\n';
      continue;
    }
    else if(maxim[1] == maxim[0]){
      for(int i = 0; i < fills[index].size(); ++i){
	if(calcroot(fills[index][i])+1 == maxim[0]) q2.push(ii(fills[index][i],maxim[0]-1));
      }
    }
    else{
      for(int i = 0; i < fills[index].size(); ++i){
	if(calcroot(fills[index][i])+1 == maxim[0]) q2.push(ii(fills[index][i],maxim[0]-1));
	if(num[1] == 1 and calcroot(fills[index][i])+1 == maxim[1]) q2.push(ii(fills[index][i],maxim[1]-1));
      }
    }
    while(!q2.empty()){
      ii aux = q2.front(); q2.pop();
      int a = aux.first; int d = aux.second;
      ++sol;
      int idx = -1;
//       cout << a << ' ' << d << endl;
      bool f = true;
      for(int i = 0; i < fills[a].size(); ++i){
	if(calcroot(fills[a][i]) == d-1){
	  if(idx != -1) f = false;
	  idx = fills[a][i];
	}
      }
      if(f and idx != -1){ q2.push(ii(idx,d-1)); }
    }
    cout << sol << '\n';
  }
}