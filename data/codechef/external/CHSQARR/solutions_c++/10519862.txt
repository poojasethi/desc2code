#include<iostream>
#include<stdio.h>
using namespace std;
#define ll long long
#include<deque>
#include<limits.h>
deque<int> myq;
int maxcolumn[1001][1001];
int main()
{
    ll n,m;
    scanf("%lld%lld",&n,&m);
    int arr[n+1][m+1];
    ll i,j;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&arr[i][j]);
    int sum[n+1][m+1];

    int columnsum=0;
    for(j=1;j<=m;j++)
    {
        columnsum=0;
        for(i=1;i<=n;i++)
            {
                columnsum+=arr[i][j];
                if (j==1)
                    sum[i][j]=columnsum;
                else
                    sum[i][j]=columnsum+sum[i][j-1];
            }
    }


    int q;
    scanf("%d",&q);
    while(q--)
        {
            int a,b;
            scanf("%d%d",&a,&b);
            for(j=1;j<=m;j++)
            {
                while(!myq.empty())
                    myq.pop_back();
                for(i=1;i<=n;)
                    {
                        while(i<=a)
                            {
                                if (myq.empty())
                                    {myq.push_back(i);maxcolumn[i][j]=arr[myq.front()][j];i++;}
                                else
                                    {
                                        while(!myq.empty()&&arr[myq.back()][j]<=arr[i][j])
                                            myq.pop_back();
                                        myq.push_back(i);
                                        maxcolumn[i][j]=arr[myq.front()][j];
                                        i++;
                                    }
                            }
                        if (i>a&&i<=n)
                            {
                                while(!myq.empty()&&myq.front()<i-a+1)
                                    myq.pop_front();
                                while(!myq.empty()&&arr[myq.back()][j]<=arr[i][j])
                                    myq.pop_back();
                                myq.push_back(i);
                                maxcolumn[i][j]=arr[myq.front()][j];
                                i++;
                            }
                    }
            }

            i=a;j=b;
            long long int minimum=LONG_LONG_MAX;
            for(;i<=n;i++)
                {
                    j=b;
                    while(!myq.empty())
                    myq.pop_back();
                    int columnj=1;
                    for(;j<=m;j++)
                        {
                            long long int maxpartialsum=0;
                            int maxelement=0;
                            maxpartialsum=sum[i][j];
                            if (j-b+1>1)
                                maxpartialsum-=sum[i][j-b];
                            if (i-a+1>1)
                                maxpartialsum-=sum[i-a][j];
                            if (j-b+1>1&&i-a+1>1)
                                maxpartialsum+=sum[i-a][j-b];
                            while(columnj<=b)
                            {
                                if (myq.empty())
                                    {myq.push_back(columnj);columnj++;}
                                else
                                    {
                                        while(!myq.empty()&&maxcolumn[i][myq.back()]<=maxcolumn[i][columnj])
                                            myq.pop_back();
                                        myq.push_back(columnj);
                                        columnj++;
                                    }
                            }

                            if (j==b){
                            maxelement=maxcolumn[i][myq.front()];
                            if (minimum>maxelement*a*b-maxpartialsum)
                                minimum=maxelement*a*b-maxpartialsum;
                            }
                            if (j>b)
                            {
                                while(!myq.empty()&&myq.front()<j-b+1)
                                    myq.pop_front();
                                while(!myq.empty()&&maxcolumn[i][myq.back()]<=maxcolumn[i][j])
                                    myq.pop_back();
                                myq.push_back(j);
                                maxelement=maxcolumn[i][myq.front()];
                                if (minimum>maxelement*a*b-maxpartialsum)
                                minimum=maxelement*a*b-maxpartialsum;
                            }

                        }
                }
            cout<<minimum<<"\n";
        }
    return 0;
}
