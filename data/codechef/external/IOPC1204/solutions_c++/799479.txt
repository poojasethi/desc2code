#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <algorithm>
#include <bitset>
#include <deque>
#include <list>
#include <stack>
#include <queue>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <cstdio>
#include <cctype>
#include <complex>
#include <cassert>
using namespace std;
#define REP(i,n) for(int i=0;i<(int)(n);i++)
#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)
#define FOR(i,k,n) for (int i=(k);i<(int)(n);i++)
#define FEQ(i,k,n) for(int i=(k);i<=(int)(n);i++)
typedef long long ll;
typedef complex<double> P;

ll mulMod(ll x, ll y, ll mod)
{ 
  ll m1 = x >> 20;
  m1 = ((m1 * y) % mod) << 20;
  ll m2 = x & ((1 << 20) - 1);
  m2 = (m2 * y) % mod;
  return (m1 + m2) % mod;
}

ll powMod(ll x, ll n, ll mod)
{ 
  ll res = 1;
  while (n) {
    if (n & 1) res = mulMod(res, x, mod);
    x = mulMod(x, x, mod);
    n >>= 1;
  }
  return res;
}

int test[] = {2, -1};

bool is_prime(ll q)
{
  ll d = (q - 1) >> 1;
  while (!(d & 1)) d >>= 1;

  for (int i = 0; test[i] < q && test[i] != -1; i++){
    ll t = d;
    ll y = powMod((ll)test[i], t, q);
    while (t != q - 1 && y != 1 && y != q - 1){
      y = mulMod(y, y, q);
      t <<= 1;
    }
    if (y != q - 1 && !(t & 1)) return false;
  }
  return true;
}

int main(int argc, char *argv[])
{
  int tc; scanf("%d", &tc);
  while(tc--){
    ll n; scanf("%lld", &n);
    if (!n) puts("1");
    else if (n == 1) puts("3");
    else if (n == 2 || n == 3) puts("5");
    else{
      for (ll i = (n / 6) * 6; ;i += 6){
        if (i - 1 >= n + 2 && is_prime(i - 1)){
          printf("%lld\n", i - 1);
          break;
        }
        if (i + 1 >= n + 2 && is_prime(i + 1)){
          printf("%lld\n", i + 1);
          break;
        }
      }
    }
  }
  return 0;
}