// CodeChef
// Richard Lee
// CEO Ride
//
#include <algorithm>
#include <iostream>
#include <vector>
#include <string>
#include <unistd.h>

using namespace std;

vector<string> cars;
bool* car_assigned;
vector<vector<int>*>  pref_mat;

vector<string*> s_array;
vector<bool> s_taken;

const int def_mod = 4561;

// open address hashing
int get_hash(string *s, int m) {
   int t = 1;
   string::iterator i = s->begin();
   string::iterator e = s->end();
   while (i != e) {
      t = (t * ((*i) << 2)) % m;
      i++;
   }
   return t;
}

void add_string(string *s, int id) {
   int h = get_hash(s, def_mod);
   vector<bool>::iterator sti;
   sti = s_taken.begin();
   sti += h;
   while (*sti) {
      sti ++;
      if (sti == s_taken.end()) {
         h = 0;
         sti = s_taken.begin();
      }
   }
   h = sti - s_taken.begin();
   *sti = true;
   s_array[h] = s;
}

int get_id(string s) {
   int h = get_hash(&s, def_mod);
   int id = 0;
   int h_s = h; // are we cycling back?
   vector<string*>::iterator si;
   
   si = s_array.begin() + h;
   // cout << "searching for " << s;
   while ((*si) == NULL || (*si)->compare(s) != 0) {
      si ++;
      h ++;
      if (si == s_array.end()) {
         si = s_array.begin();
         h = 0;
      }
      if (h == h_s) {
         h = -1;
         break;
      }
   }
   // cout << " found @ " << h << endl;
   return h;
}

int get_max_d(int c_i, int c_d, int m_d) {
   vector<int>* r = NULL;
   int d = c_d;
   int n_ci;
   //cout << "c_i: " << c_i << " c_d: " << c_d << " m_d: " << m_d << endl;
   if (c_i == pref_mat.size()) return m_d;
   r = pref_mat.at(c_i);
   for (int i = 0; i < r->size(); i++) {
      n_ci = car_assigned[r->at(i)];
      if (!n_ci) {
         car_assigned[n_ci] = true;
         d = get_max_d(c_i + 1, c_d + 1, m_d);
         car_assigned[n_ci] = false;
         if (d > c_d) c_d = d;
         if (c_d == m_d) break;
      }
   }
   return c_d;
}

int main(int argc, char** argv) {
   int n;
   string dig;
   string car;
   int pref_c;
   int c_id;
   bool pref_choice = true;
   vector<int>* c_v;
   int max_d = 0;
   cin >> n;
   
   if (s_array.size() < def_mod) 
      for (int i = 0; i < def_mod; i++) {
         s_array.push_back(NULL);
         s_taken.push_back(false);
      }
   car_assigned = new bool[def_mod];
   for (int i = 0; i < def_mod; i++) car_assigned[i] = false;
   
   // read in the names of the dignitaries
   for (int i = 0; i < n; i++) {
      cin >> dig;
   }
   
   // read in the names of the cars
   for (int i = 0; i < n; i++) {
      cin >> car;
      // cars.push_back(car);
      add_string(new string(car), i);
   }
   
   // read in the preferences
   for (int i = 0; i < n; i++) {
      cin >> pref_c;
      if (!pref_choice) {
         for (int j = 0; j < pref_c; j++) cin >> car;
      }
      else {
         c_v = new vector<int>();
         for (int j = 0; j < pref_c && pref_choice; j++) {
            cin >> car;
            c_id = get_id(car);
            c_v->push_back(c_id);
         }
         if (pref_c == 1) {
            if (car_assigned[c_v->at(0)]) pref_choice = false;
            else car_assigned[c_v->at(0)] = true;
            delete c_v;
         }
         else if (pref_choice) pref_mat.push_back(c_v);
      }
   }
   
   // determine if all cars can be allocated
   if (pref_choice && pref_mat.size() > 0) {
      max_d = get_max_d(0, 0, pref_mat.size());
      pref_choice = max_d == pref_mat.size();
   }
   
   cout << (pref_choice ? "Yes" : "No") << endl;
   for (int i = 0; i < pref_mat.size(); i++) delete pref_mat.at(i);
   delete [] car_assigned;
   return 0;
}







