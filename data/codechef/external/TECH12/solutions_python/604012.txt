#include <algorithm>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <typeinfo>
using namespace std;

typedef long long LL;

#define RI(x) int x; scanf("%i", &x)
#define RS(x) char buf_[500]; scanf("%s", buf_); string x(buf_)
#define RL(x) string x; getline(cin, x)
#define FOPEN(path) freopen(path, "r", stdin)

#define ALL(x) x.begin(), x.end()
#define FOR(i, a, b) for(int i=(a), _b=(b); i<_b; ++i)
#define FE(it, c) for(typeof(c.begin()) it=c.begin(); it!=c.end(); ++it)

#define PB push_back
#define SZ(c) (int)c.size()



// Find all prime numbers between 1 and x inclusive.
const int x = 100005;
bool p[x+1];
static void primes() {
     fill(p,p+x+1,true);
     for(int i = 2; i*i < x+1; ++i)
          //If i is a prime, then the multiples of i are not prime.
          if(p[i]) {
              //We start at i*i when considering the multiples of i since smaller multiples have already been labeled in previous steps.
              for(int k = i*i; k < x+1; k += i) p[k] = false;
          }
}


int main(int argc, char** argv) {
	primes();
	RI(t);
	FOR(i,0,t) {
		RI(n);
		RI(k);
		if(k == 0) {
			LL nn = n;
			printf("%lld\n",nn-1+(nn-1)*(nn-2)/2);
		}



		else {
			LL res[100005] = {0};
			int i = 2;
			int nump = 1;
			while(nump < k && i <= n) {
				++i;
				if(p[i]) ++nump;
			}
			int a = 2; //a is the number such that there are k primes in [a,i]

			if(nump == k) {
				res[i] = 1;
				++i;
				for(; i <= n; ++i) {
					if(p[i]) {
						//can move a forward to next prime
						while(!p[++a]);
					}

					res[i] = res[i-1]; //subrange doesn't include i
					//subrange does include i
					//range must extend at least to a but could go further
					res[i] += a-1;
				}
			}




			printf("%lld\n",res[n]);
		}
	}

}
