/*	
TDuke
Otto Alberto Le?n Negr?n
5978. Frequent Prime Ranges
Problem code: FRQPRIME
March 2010
*/
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long int64;

const int N = (int)1e5 + 2;

#define SET(x) (mark[x >> 5] |= (1 << (x & 31)))
#define GET(x) (mark[x >> 5] & (1 << (x & 31)))

int mark[N / 31];

void sieve(){
	int k;
	int k2;
	for(int i = 6; (i + 1) * (i + 1) <= N; i += 6){
		k = i - 1;
		k2 = 2 * k;
		if(!GET( k ))
			for(int j = k * k; j <= N; j += k2)
				SET(j);

		k = i + 1; 
		k2 = 2 * k;
		if(!GET( k ))
			for(int j = k * k; j <= N; j += k2)
				SET(j);
	}	
}

bool isprime(int n){
	if(n == 1)
		return false;
	if(n < 4)
		return true;
	if(!(n % 2 && n % 3))
		return false;
	return !GET(n);
}

int sumprimes[N];

void fill(){
	sumprimes[2] = 1;
	sumprimes[3] = 2;
	for(int i = 4; i < N; i++)
		sumprimes[i] = sumprimes[i - 1] + isprime(i);
}

int position(int sm, int maximun){
	if(maximun < 0)
		return 0;
	int lo = 1, hi = sm, temp;
	while(1){
		temp = (lo + hi) / 2;
		if(temp == lo)
			return temp;
		if(sumprimes[temp] <= maximun)
			lo = temp;
		else
			hi = temp;
	}
}

int64 query(int n, int k){
	int64 quantity = 0;
	for(int i = 2; i <= n; i++)
		quantity += position(i, sumprimes[i] - k);
	return quantity;
	
}

int main(){
	sieve();
	fill();
	int T, n, k;
	for(scanf("%d", &T); T; T--){
		scanf("%d %d", &n, &k);
		printf("%lld\n", query(n, k));
	}
	return 0;
}
