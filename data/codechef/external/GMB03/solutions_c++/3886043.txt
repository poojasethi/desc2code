/* Here I am implementing the weighted_quick union data-structure.
   This data-srructure allows us to quickly find if we have two connected
   components in the data.
   Author: thecodekaiser
*/
 
 
#include <iostream>
#include <vector>
#include <cstdlib>
#include <cstdio>
 
using namespace std;
#define REP(i,N)	for(int i = 0; i < N; i++)
 
class WeightedQU
{
 
public:
	int * id, *sz;
 
	// Constructor
	WeightedQU(int B)
	{
		id = (int *) calloc((B+1),sizeof(int));
		sz = (int *) calloc((B+1),sizeof(int));
		for(int i = 0; i < B+1; i++)
			id[i] = i;
	}
 
	void join(int p,int q)
	{
		int i = root(p);
		int j = root(q);
		if(sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; }
		else		      { id[j] = i; sz[i] += sz[j]; }
	}
 
	// This method uses path compression thereby decreasing the height of tree by half
	int root(int i)
	{
		while(i != id[i])
		{ 
			id[i] = id[id[i]];
			i = id[i];
		}
		return i;
	}
 
	// Method to check if the two components are conncectd or not
	bool connected(int p, int q)
	{
		return root(p) == root(q);
	}
};
 
void solve()
{
	int C, B, Q, x, y;
	scanf("%d %d %d",&C, &B, &Q);
	WeightedQU qf(C);
 
	REP(i,B)
	{
		scanf("%d %d",&x,&y);
		qf.join(x,y);
	}
 
	REP(i,Q)
	{
		scanf("%d %d",&x,&y);
		if(qf.connected(x,y))
			printf("only bus\n");
		else
			printf("bus and taxi\n");
	}
}
 
int main()
{
	// your code goes here
	int t;
	scanf("%d",&t);
	while(t--)
	{
		solve();
	}
	return 0;
}