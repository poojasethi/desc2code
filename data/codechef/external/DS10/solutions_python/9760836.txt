#include <bits/stdc++.h>
using namespace std;
using ll = long long int;
using ull = unsigned long long;
const int BUF_SIZE = 65536;
char input[BUF_SIZE];

struct Scanner {
	char* curPos;

	Scanner() {
		fread(input, 1, sizeof(input), stdin);
		curPos = input;
	}

	void ensureCapacity() {
		int size = input + BUF_SIZE - curPos;
		if (size < 100) {
			memcpy(input, curPos, size);
			fread(input + size, 1, BUF_SIZE - size, stdin);
			curPos = input;
		}
	}

	int nextInt() {
		ensureCapacity();
		while (*curPos <= ' ')
			++curPos;
		bool sign = false;
		if (*curPos == '-') {
			sign = true;
			++curPos;
		}
		int res = 0;
		while (*curPos > ' ')
			res = res * 10 + (*(curPos++) & 15);
		return sign ? -res : res;
	}

	char nextChar() {
		ensureCapacity();
		while (*curPos <= ' ')
			++curPos;
		return *(curPos++);
	}
};
template<class T> inline T mypow(T x, int n)
{
	if (n == 0)
		return 1;
	T y = 1;
	while (n > 1)
	{
		if (n % 2 == 0)
		{
			x = x*x;
			n = n / 2;
		}
		else
		{
			y = x*y;
			x = x*x;
			n = (n - 1) / 2;
		}
	}
	return x*y;
}

int Primes[25] =
{ 2, 3, 5, 7, 11, 13, 17, 19, 23,
29, 31, 37, 41, 43, 47, 53, 59,
61, 67, 71, 73, 79, 83, 89, 97 };
const int _startNum = 101;

void FactorizeFast(map<ull, ull>& _arrFactors, ull Num)
{
	ull _num = Num;
	for (int k = 0; k < 25; k++)
	{
		if (_num == Primes[k])
		{
			_arrFactors[Primes[k]]++;
			return;
		}
	}
	for (int k = 0; k < 25; k++)
	{
		ull m = Primes[k];
		if (_num < m) break;
		while (_num % m == 0)
		{
			_arrFactors[m]++;
			_num = _num / m;
		}
	}
	if (_num < _startNum)
		return;
	ull _upMargin = (ull)sqrt(_num) + 1;
	ull i = _startNum;
	while (i <= _upMargin)
	{
		if (_num % i == 0)
		{
			_arrFactors[i]++;
			_num = _num / i;
			_upMargin = (int)sqrt(_num) + 1;
			i = _startNum;
		}
		else { i = i + 2; }
	}
	_arrFactors[_num]++;
	return;
}

inline int sigma_1(ull number)
{
	map<ull, ull>primeFactors;
	FactorizeFast(primeFactors, number);
	int k = 1;
	for (auto f : primeFactors)
	{
		int tmp = 1;
		for (int j = 1; j <= f.second; j++)
			tmp += mypow(f.first, j);
		k *= tmp;
	}
	return k;
}

int main()
{
	int t; cin >> t;
	cout << sigma_1(t) - t << '\n';
}