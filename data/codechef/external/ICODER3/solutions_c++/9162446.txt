#include <iostream>
#include <vector>
 
using namespace std;
 
int noOfBlocks, columnLength, rowLength;
 
struct Block
{
int period, cellNumber, row, column;
vector<int> cells, rowChange, columnChange;
};
Block *blocks;
 
int GCD(int a, int b)
{
return !b?a:GCD(b,a%b);
}
 
inline int LCM(int a, int b)
{
return(a*b)/GCD(a,b);
}
 
void sortBlocks()
{
int min=blocks[0].period;
int index=0;
for(int i=0; i<noOfBlocks; i++)
	{
	if(min>blocks[i].period)
		{
		min=blocks[i].period;
		index=i;
		}
	}
if(index)
	{
	Block temp;
	temp=blocks[0];
	blocks[0]=blocks[index];
	blocks[index]=temp;
	}
}
 
int findTotalCells()
{
int limit=1, lcm=1, maxCells=blocks[0].period, minimumPeriod=blocks[0].period;
bool flag;
vector<int> newCommonCells;
vector<bool> successfulCases;
for(int j=0; j<noOfBlocks; j++)
	lcm=LCM(lcm,blocks[j].period);
limit=lcm/blocks[0].period;
for(int j=0; j<blocks[0].period; j++)
	{
	int cellN=blocks[0].cells[j];
	int k=0;
	flag=false;
	for(int I=0; I<limit&&!flag; I++)
		{
		flag=true;
		for(int i=1; i<noOfBlocks; i++)
			{
			if(cellN!=blocks[i].cells[(k+j)%blocks[i].period])
				{
				flag=false;
				break;
				}
			}
		k=k+minimumPeriod;
		}
	successfulCases.push_back(flag);
	}
for(int i=0; i<minimumPeriod; i++)
	{
	flag=true;
	int temp;
	if(successfulCases[i]==true)
		{
		temp=blocks[0].cells[i];
		for(int j=0; j<newCommonCells.size(); j++)
			if(temp==newCommonCells[j])
				{
				flag=false;
				break;
				}
		if(flag)
			newCommonCells.push_back(temp);
		}
	}
return newCommonCells.size();
}
 
main()
{
int fall, temp;
for(cin>>fall; fall--;)
	{
	cin>>rowLength>>columnLength>>noOfBlocks;
	blocks=new Block[noOfBlocks];
	for(int i=0; i<noOfBlocks; i++)
		{
		cin>>blocks[i].cellNumber;
		cin>>blocks[i].period;
		for(int j=0; j<blocks[i].period; j++)
			{
			cin>>temp;
			blocks[i].rowChange.push_back(temp);
			}
		for(int j=0; j<blocks[i].period; j++)
			{
			cin>>temp;
			blocks[i].columnChange.push_back(temp);
			}
		for(int j=0; j<blocks[i].period; j++)
			blocks[i].cells.push_back(blocks[i].cellNumber+blocks[i].rowChange[j]*columnLength+blocks[i].columnChange[j]);
		blocks[i].rowChange.clear();
		blocks[i].columnChange.clear();
		}
	sortBlocks();
	cout<<findTotalCells()<<endl;
	delete[] blocks;
	}
return 0;
}