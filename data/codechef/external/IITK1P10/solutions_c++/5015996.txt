#include <bits/stdc++.h>
 
using namespace std;
 
#define    mp(a,b)   make_pair(a,b)
#define    vi        vector<int> 
#define    X         first
#define    Y         second
 
typedef long long LL;
typedef pair<int,int> pii;
 
vi List[100000];
int st[100000];	// start of a subtree
int ln[100000];	// length of the subtree rooted at i
int val[100000];
LL val1[100000];	// value of ith elemnet in the tree
 
int BIT[100001];
 
void update(int idx, int val, int N){ // idx is 0 based
	idx += 1;
	while(idx <= N){
		BIT[idx] += val;
		idx += (idx & -idx);
	}
	return ;
}
 
int query(int l, int r){	// l, r are 0 based
	r += 1;
	int ans = 0;
	while(r > 0){
		ans += BIT[r];
		r -= (r & -r);
	}
	while(l > 0){
		ans -= BIT[l];
		l -= (l & -l);
	}
	return ans;
}
 
int dfs(int r, bool vis[], int & s){
	val1[s] = val[r];
	vis[r] = true;
	st[r] = s++;
	int sz = 1;
	for(int i=0;i<List[r].size();++i){
		int c = List[r][i];
		if(vis[c]) continue;
		ln[c] = dfs(c, vis, s);
		sz += ln[c];
	}
	return sz;
}
 
int main()
{
	int N, Q;
	cin >> N >> Q;
	assert(1<=N and N<=100000);
	assert(1<=Q and Q<=200000);
	for(int i=0;i<N-1;++i)
	{
		int x, y;
		cin >> x >> y;
		assert(1<=x and x<=N);
		assert(1<=y and y<=N);
		--x, --y;
		List[x].push_back(y);
		List[y].push_back(x);
	}
 
	for(int i=0;i<N;++i){
		cin >> val[i];
		assert(-1000000000 <= val[i] and val[i] <= 1000000000);
	}
	
	bool vis[100000];
	memset(vis, 0, sizeof vis);
	memset(st, -1, sizeof st);
	memset(ln, -1,sizeof ln);
	int s = 0;
	ln[0] = dfs(0, vis, s);
	
	// assert that the given data represents a tree
	int ct = 0;
	for(int i=0;i<N;++i)
		ct += vis[i];
	assert(ct == N);
 
	// cout << endl;
	// for(int i=0;i<N;++i)
	// 	cout << st[i] << " ";
	// cout << endl;
	// for(int i=0;i<N;++i)
	// 	cout << ln[i] << " ";
	// cout << endl;
	// for(int i=0;i<N;++i)
	// 	cout << val1[i] << " ";
	// cout << endl;
 
	memset(BIT, 0, sizeof BIT);
	for(int i=0;i<N;++i){
		if(val1[i] == 0) update(i, 1, N);
	}
	while(Q--){
		char f[2];
		int u, v;
		cin >> f;
		if(f[0] == 'U'){
			cin >> u >> v;
			u--;
			u = st[u];
			val1[u] += (LL)v;
			if(val1[u] == 0) update(u, 1, N);
		}
		else{
			cin >> u;
			u--;
			v = ln[u];
			u = st[u];
			v += u-1;
			assert(0<= u and u<N);
			assert(0<= v and v<N);
			cout << query(u, v) << endl;
		}
	}
 
	return 0;
}
 