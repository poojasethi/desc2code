//CodeChef--Trees ans Queries
#include<bits/stdc++.h>
#define MAX 100005

using namespace std;

typedef long long int lli;

vector<lli> adjList[MAX];

struct node{
	
	lli ans;
	
	node(){	ans=0;}
	
	void makeLeaf(lli val){
		
		if(val==0) this->ans=1;
		else this->ans=0;
		
	}
	
	void merge(const struct node &lhs,const struct node &rhs){
		
		this->ans=lhs.ans+rhs.ans;		
		
	}	
	
};

lli array[MAX],L[MAX],R[MAX],t=-1,Visited[MAX];
struct node Tree[3*MAX];

void DFS(lli );
void makeTree(lli ,lli ,lli );
lli query(lli ,lli ,lli ,lli ,lli );
void update(lli ,lli ,lli ,lli ,lli ,lli );

int main(void){
	
	lli totalElements,queries,i;
	lli src,dest;
	char queryType;
	
	scanf("%lld%lld",&totalElements,&queries);
	
	for(i=0;i<totalElements-1;i++){
		
		scanf("%lld%lld",&src,&dest);
		src--;dest--;
		adjList[src].push_back(dest);
		adjList[dest].push_back(src);
		
	}
		
	for(i=0;i<totalElements;i++)
	  scanf("%lld",&array[i]);
	
	makeTree(0,0,totalElements-1);
	DFS(0);
	
	//scanf("%*c");
	while(queries--){
		
		scanf("%*c%c",&queryType);
				
		if(queryType=='U'){
			
			scanf("%lld%lld",&src,&dest);
			src--;
			update(0,0,totalElements-1,src,src,dest);
						
		}
		
		else{
			
			scanf("%lld",&src);
			src--;
			lli ans=query(0,0,totalElements-1,L[src],R[src]);
			printf("%lld\n",ans);
			
		}   
		
	}	
	
	return 0;
	
}

//pre--order traversal of the tree
void DFS(lli u){
	
	L[u]=++t;
	Visited[u]=1;
	
	lli i,v;
	for(i=0;i<adjList[u].size();i++){
		
		v=adjList[u][i];
		if(!Visited[v])
	    	DFS(v);
		
	}
	
	R[u]=t;
	
}

void makeTree(lli idx,lli assStart,lli assEnd){
	
	if(assStart==assEnd){
		
		Tree[idx].makeLeaf(array[assStart]);
		return;
		
	}
	
	lli mid=(assStart+assEnd)/2;
	
	makeTree(2*idx+1,assStart,mid);
	makeTree(2*idx+2,mid+1,assEnd);
	
	Tree[idx].merge(Tree[2*idx+1],Tree[2*idx+2]);
	
}

void update(lli idx,lli assStart,lli assEnd,lli s,lli e,lli val){
	
	if(assStart>assEnd||assStart>e||s>assEnd)//out of range
	 return;
	
	if(assStart>=s&&assEnd<=e){
		
		array[assStart]+=val;
		Tree[idx].makeLeaf(array[assStart]);
		return;
		
	}
	
	lli mid=(assStart+assEnd)/2;
	
	update(2*idx+1,assStart,mid,s,e,val);
	update(2*idx+2,mid+1,assEnd,s,e,val);
	
	Tree[idx].merge(Tree[2*idx+1],Tree[2*idx+2]);
	
}

lli query(lli idx,lli assStart,lli assEnd,lli s,lli e){
	
	if(assStart>assEnd||assStart>e||s>assEnd)//out of range;
	 return 0;
	
	if(assStart>=s&&assEnd<=e)
	  return Tree[idx].ans;
	
	lli v1,v2,mid;
	
	mid=(assStart+assEnd)/2;
	
	v1=query(2*idx+1,assStart,mid,s,e);
	v2=query(2*idx+2,mid+1,assEnd,s,e);
	
	return v1+v2;
	
}   