#include <queue>
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <algorithm>
#include <bitset>
#include <cstdlib>
#include <list>
#include <stack>
#include <deque>
#include <cmath>
#include <string>
#include <string.h>
#include <iomanip>
#include <sstream> 
#include <set> 
#include <cassert>
#include <ctype.h> 
using namespace std; 
#define rep(i,n)        for(int i = 0;  i < n ; ++i)
#define REP(i,a,b)      for(int i = a ; i <= b; ++i)
#define s(n)            scanf("%d",&n)
#define rev(i,n)        for(int i = n ; i >= 0 ; --i)
#define REV(i,a,b)      for(int i = a ; i >= b ; --i)
#define INF             1000000000 
#define pii             pair<int,int> 
#define pb(a)           push_back(a)
#define ll              long long
#define VI              vector<int> 
#define MII             map<int,int> 
#define MSI             map<string,int> 
#define VII             vector<vector<int> > 
#define VPP             vector<pair<int,int> > 
#define MOD             1000000007
#define PDD             pair<double,double>
#define VL              vector<long long>
#define pil             pair<int,long long>
#define pll             pair<long long,long long>
#define mp              make_pair
struct ST
{
    int val , zero ; 
}tree[4*100001] ; 
vector<vector<int> > G; 
vector<int> dfs_order(100001,-1) ;
vector<int> sz(100001) ;
vector<int> node_here(100001)  ;
vector<int> W(100001) ; 
int order = 1 ; 
int dfs_tour(int node , int prev)
{
    sz[node] = 1; 
    if(dfs_order[node] == -1)
    {
        node_here[order] = node ; 
        dfs_order[node] = order++ ; 
    }
    for(int i = 0 ; i < G[node].size() ; ++i)
    {
        if(G[node][i] != prev)
        {
            sz[node] += dfs_tour(G[node][i],node) ; 
        }
    }
    return sz[node] ; 
}
void build_tree(int node , int a , int b)
{
    if(a == b)
    {
        tree[node].val = W[node_here[a]] ; 
        if(tree[node].val == 0)
            tree[node].zero = 1 ;
        return ; 
    }
    build_tree(2*node,a,(a+b)/2) ; 
    build_tree(2*node+1,(a+b)/2 + 1 , b) ; 
    tree[node].zero = tree[2*node].zero + tree[2*node+1].zero ; 
    return ; 
}
int query(int node ,int a , int b ,int i , int j)
{
    if(i > b or j < a)
    {
        return 0 ; 
    }
    if(a >= i and b <= j)
    {
        return tree[node].zero ; 
    }
    return (query(2*node,a,(a+b)/2,i,j) + query(2*node+1,(a+b)/2 + 1 ,b , i , j)) ; 
}
void update(int node , int a , int b , int idx , int val)
{
    if(idx > b or idx < a )
    {
        return ; 
    }
    if(a == idx and b==idx)
    {
        tree[node].zero = 0 ; 
        tree[node].val += val ; 
        if(tree[node].val == 0)
        {
            tree[node].zero = 1; 
        }
        return ; 
    }
    update(2*node , a , (a+b)/2 , idx , val) ; 
    update(2*node+1,(a+b)/2 + 1, b , idx , val) ; 
    tree[node].zero = tree[2*node].zero + tree[2*node+1].zero ; 
    return ; 
}
int main()
{
 //   freopen("input.txt","r",stdin) ; 
    ios_base::sync_with_stdio(0) ; 
    int q  , N , v , x , u;
    char type ; 
    cin >> N  >> q; 
    G.resize(N+1) ; 
    for(int i = 1 ; i <= N-1 ; ++i)
    {
        cin >> u >> v;  
        G[u].pb(v) ;
        G[v].pb(u) ; 
    }
    for(int i = 1 ; i <= N ; ++i)
    {
        cin >> W[i] ; 
    }
    dfs_tour(1,-1) ; 
    build_tree(1,1,N) ; 
    int node , val ; 
    while(q--)
    {
        cin >> type ; 
        if(type == 'Q')
        {
            cin >> x; 
            cout << query(1,1,N,dfs_order[x],dfs_order[x] + sz[x] - 1) << "\n" ;
        }
        else
        {
            cin >> node >> val ; 
          //  cout << node << " " << dfs_order[node] << " " << val << "\n" ; 
            update(1,1,N,dfs_order[node],val) ; 
        }
    }
    return 0 ; 
}