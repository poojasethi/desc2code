#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <limits.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <map>
using namespace std;

#define pb push_back
#define INF 1000000000
#define MAXN 100000
#define MOD 1000000007
#define OFFSET 4000000
#define LL long long int

int inouttime;
int tree[4 * MAXN + 5];
LL arr[MAXN + 5];
vector <int> G[MAXN + 5];
pair <int, int> traverse[MAXN + 5];

int query(int indx, int begin, int end, int start, int finish){
	if (start > end || finish < begin){
		return 0;
	}
	else if (begin >= start && end <= finish)
		return tree[indx];
	else{
		int a = query(2 * indx, begin, (begin + end) / 2, start, finish);
		int b = query(2 * indx + 1, (begin + end) / 2 + 1, end, start, finish);
		return a + b;
	}
}

void update(int indx, int begin, int end, int pos, int val){
	if (begin == pos && end == pos){
		tree[indx] += val;
	}
	else{
		if (pos > (begin + end) / 2)
			update(2 * indx + 1, (begin + end) / 2 + 1, end, pos, val);
		else
			update(2 * indx, begin, (begin + end) / 2, pos, val);
		tree[indx] = tree[2 * indx] + tree[2 * indx + 1];
	}
}

void dfs(int u, int p) {
	inouttime++;
	traverse[u].first = inouttime;
	for (int i = 0; i < G[u].size(); i++) {
		int v = G[u][i];

		if (v != p) {
			dfs(v, u);
		}
	}
	traverse[u].second = inouttime;
}

int main() {
	int N, Q, u, v;
	LL x;
	char cmd[5];

	scanf("%d %d", &N, &Q);

	for (int i = 0; i < N - 1; i++){
		scanf("%d %d", &u, &v);

		G[u].push_back(v);
		G[v].push_back(u);
	}

	dfs(1, -1);

	for (int i = 1; i <= N; i++){
		scanf("%lld", &arr[i]);
		if (arr[i] == 0){
			update(1, 1, inouttime, traverse[i].first, 1);
		}
	}

	for (int i = 0; i < Q; i++){
		scanf("%s", cmd);

		if (cmd[0] == 'U'){
			scanf("%d %lld", &u, &x);
			x += arr[u];
			if (x == 0 && arr[u] != 0){
				update(1, 1, inouttime, traverse[u].first, 1);
			}
			else if (x != 0 && arr[u] == 0){
				update(1, 1, inouttime, traverse[u].first, -1);
			}
			arr[u] = x;
		}
		else{
			scanf("%d", &u);
			printf("%d\n", query(1, 1, inouttime, traverse[u].first, traverse[u].second));
		}
	}
	return 0;
}