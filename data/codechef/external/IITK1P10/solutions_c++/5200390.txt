#include<bits/stdc++.h>
#define FOR(i,a,b) for(i=(a);i<(b);i++)
#define pnt pair<int,int>
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define gc getchar_unlocked
 
typedef long long ll;
typedef unsigned long long ull;
 
const ll MOD=1000000007;
 
using namespace std;
 
inline int inp(){
	int n=0,sign=1;
	char c;
	c=gc();
	while(c<'0' || c>'9'){
		if(c=='-')	sign=-sign;
		c=gc();
	}
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+c-'0';
		c=gc();
	}
	n=n*sign;
	return n;
}
 
 
ll power(ll a,ll b,ll mod){
      if(b==0)
            return 1;
      ll temp=power(a,b/2,mod);
      temp=(temp*temp)%mod;
      if(b&1)
            temp=(temp*a)%mod;
      return temp;
}
 
int pwr(int a,int b){
      if(b==0)
            return 1;
      int temp=pwr(a,b/2);
      temp=(temp*temp);
      if(b&1)
            temp=(temp*a);
      return temp;
}
 
ll gcd(ll a,ll b){
      return b==0?a:gcd(b,a%b);
}
 
ll lcm(ll a,ll b){      
      return (a/gcd(a,b))*b;
}
 
ll modularInverse(ll a,ll m){
      return power(a,m-2,m);
}

int ceill(int a,int b){
	return (a+b-1)/b;
}

struct n{
	int val,data;
	struct n *next;
}*node[100001];

pnt p[100001];

int count1;

void dfs(int ind){
	struct n *temp;
	if(node[ind]->val==0)	count1++;
	temp=node[ind];
	while(temp->next){
		dfs(temp->next->data);
		temp=temp->next;
	}
}

int main(){
	int n,q,i,x,y,v,ind,a[100001];
	char c;
	struct n *newnode,*temp;
	#ifndef ONLINE_JUDGE
		freopen("inpu.txt","r",stdin);
	#endif
	n=inp();
	q=inp();
	FOR(i,0,n-1){
		x=inp();
		y=inp();
		x--;
		y--;
		p[i]=mp(x,y);
	}
	sort(p,p+n-1);
	FOR(i,0,n){
		a[i]=inp();
		node[i]=(struct n *)malloc(sizeof(struct n));
		node[i]->val=a[i];
		node[i]->data=i;
		node[i]->next=NULL;
	}
	FOR(i,0,n-1){
		newnode=(struct n *)malloc(sizeof(struct n));
		newnode->data=p[i].second;
		newnode->val=a[p[i].second];
		newnode->next=NULL;
		if(node[p[i].first]->next==NULL){
			node[p[i].first]->next=newnode;
		}
		else{
			temp=node[p[i].first]->next;
			node[p[i].first]->next=newnode;
			newnode->next=temp;
		}
	}
	FOR(i,0,q){
		cin>>c;
		ind=inp();
		ind--;
		if(c=='Q'){
			count1=0;
			dfs(ind);
			printf("%d\n",count1);
		}
		else{
			v=inp();
			node[ind]->val+=v;
		}
	}
	return 0;
}  