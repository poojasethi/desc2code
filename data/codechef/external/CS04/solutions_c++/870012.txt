#include <iostream>
#include <vector>
#include <queue>
#include <string>
#include <map>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

#include <list>

#define REP(i,n)      FOR(i,0,n)
#define FOR(i,a,b)    for(int i = a; i < b; i++)
#define ROF(i,a,b)    for(int i=a;i>b;i--)
using namespace std;
struct sort_pred {
    bool operator()(const std::pair<int,int> &left, const std::pair<int,int> &right) {
        return left.second < right.second;
    }
};

int main(){
  int count = 0;
  while(1){
  int c,e;
  cin >> c >> e;
  
  if(c == 0)
    break;
  else count++;
  vector < list < pair <int, int> > > adj(c);
  vector < pair<int,int> > costs(c);
  map <int, bool> visited;
  
  REP(i,e){
    int s,d, cost;
    cin >> s >> d >> cost;
    pair <int, int> k;
    k.first = d-1;
    k.second = cost;
    adj[s-1].push_front(k);
    k.first = s-1;
    k.second = cost;
    adj[d-1].push_front(k);
  }
  int beg, end, total;
  cin >> beg >> end >> total;
  short r;
  

  REP(i,c){
    costs[i].second = 0;
    costs[i].first = i;
  }
  costs[beg-1].second = total;
  priority_queue <pair <int, int>, vector <pair <int, int> >, sort_pred> check;
  REP(i,c)
    check.push(costs[i]);
  

  // algorithm begins here

  

  while(!check.empty()){
    pair<int,int> elem = check.top();
    // cout << elem.first << " " << elem.second <<endl;
    check.pop();
    visited[elem.first] = true;
    check = priority_queue <pair <int, int>, vector <pair <int, int> >, sort_pred>();

    list <pair<int, int> > ::iterator iter;
    for(iter = adj[elem.first].begin(); iter != adj[elem.first].end(); iter++){
      
      int cost_path = (*iter).second;
      int dest = (*iter).first;
      if(visited[dest]) continue;
      int est = min(cost_path, costs[elem.first].second);
      costs[dest].second = max(costs[dest].second, est);
      check.push(costs[dest]);
    }
  }
  
  if(beg != end){
  int trip = costs[end - 1].second;
  //  cout << "Scenario #"<< count << endl;
  //  cout << "Minimum Number of Trips = ";
  if((total+1) % trip == 0)
    cout << (total+1)/trip - 1 << endl;
  else
    cout << (total+1) / trip  <<endl;
  }
  else{
    //cout << count << endl;
    cout << 0 << endl;
  }
    
  }
  return 0;
}
    
    
  
    
    
  

  
