#include<stdio.h>
#include<iostream>
#include<vector>
#include<string.h>
#include<algorithm>
#include<deque>
#include<map>
#include<set>
#include<stdlib.h>
#include<math.h>
#include<queue>
#include<stack>
#include<functional>
using namespace std;
#define LL long long
#define si(x) scanf("%d",&x)
#define sc(x) scanf("%c",&x)
#define sl(x) scanf("%I64d",&x)
#define all(x) x.begin(),x.end()
#define compress(x) {sort(all(x));(x).resize(unique(all(x))-(x).begin());}
template<class T> inline void umax(T &a,T b){if(a<b) a = b ;}
typedef pair<int, int> ii;
typedef pair<LL, LL> PII;
typedef pair<ii, int> iii;
typedef pair<ii, ii> iiii;
#define vl vector<>
#define vi vector<int>
#define vii vector<ii>
#define vvl vector< vl >
#define vvi vector< vi >
#define vvii vector< vii >
#define sz size()
#define pb push_back
#define F first
#define S second
#define mem(x,y) memset(x,y,sizeof(x))
#define rep(i,a,b) for(int i=(a);i<(b);i++)
#define repv(i,b,a) for(int i=(b);i>=(a);i--)
#define mod 1000000007
#define pb push_back
#define mp make_pair
#define PDD pair<LL, LL>
#define LLD long double

const int maxn = 5000 + 2;
const int INF  = 1e9 + 7;
//const LL INF = 0x0123456789ABCDEFLL;
LL modpow(LL base, LL exponent,LL modulus){
    if(base==0&&exponent==0)return 0;
    LL result = 1;
    while (exponent > 0){
        if (exponent % 2 == 1)
            result = (result * base) % modulus;
        exponent = exponent >> 1;
        base = (base * base) % modulus;
    }
    return result;
}
LL mod1(LL a, LL b) {
  return ((a%b)+b)%b;
}
LL extended_euclid(LL a, LL b, LL &x, LL &y) {  
  LL xx = y = 0;
  LL yy = x = 1;
  while (b) {
    LL q = a/b;
    LL t = b; b = a%b; a = t;
    t = xx; xx = x-q*xx; x = t;
    t = yy; yy = y-q*yy; y = t;
  }
  return a;
}
LL mod_inverse(LL a, LL n) {
  LL x, y;
  LL d = extended_euclid(a, n, x, y);
  if (d > 1) return -1;
  return mod1(x,n);
}

LL solve(LL a, LL b , LL m){  // returns x such that a^x is congruent to b mod m 
     LL X = sqrt(m+1) , val , tmp;
     map<LL , LL> p1 , idx;
     val  = 1;
     for(int i=0;i<=X+1;i++){
         p1[val] = 1;
         idx[val] = i;
         val  = (val * a)%m;
     }
     LL inv  = mod_inverse(modpow(a , X , m) , m);
     LL mul =  b;
     for(int i=0;i<=X+1;i++){
        if(p1[mul] > 0){
        if(i >0 || idx[mul] > 0)
        return  X * i + idx[mul];
        }
        mul = (mul * inv)%m;
     }
     return -1;
}
inline void solve(void){
        int t;
        cin >> t;
        while(t--){
            LL a, c , m , k;
            cin >> a >> c >> m >> k;
            if(m==1){

            }
            LL x = solve(a , c , m);
            LL d = solve(a , 1 , m);
            if(x==-1 || d==-1   ){
                cout <<"0\n";
                continue;
            }
            LL ret = ( (2 * x)%mod + ((k - 1) * d)%mod)%mod;
            ret = (ret * k)%mod;
            ret = (ret  * modpow(2 ,mod-2,mod))%mod;
            cout << ret <<"\n";
        }
           
}
/*void init() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
}*/
int main(int argc, const char * argv[]){
    //freopen("positive.in","r",stdin);
    //freopen("positive.out","w",stdout);
   // init();
    solve();
    return 0;
}