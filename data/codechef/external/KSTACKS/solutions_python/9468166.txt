#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int MAXN = 100000 + 10, inf = ~0U>>1;
const int P = 333;

namespace Treap {
  struct Node {
    int pri, sz;
    LL val;
    Node* ch[2];
    Node() {}
    Node (LL v, Node* n) : val(v) {
      ch[0]=ch[1]=n; sz=1; pri=rand()-1;
    }
    void upd() {sz=ch[0]->sz+ch[1]->sz+1;}
  } pool[MAXN], *null, *np;
  Node *newNode(LL v) {
    np->val = v; np->sz = 1; np->pri = rand() - 1;
    np->ch[0] = np->ch[1] = null; return np ++;
  }
  void rot(Node* &o,int d) { //d = 1, left; d = 0, right
    Node* k=o->ch[d];
    o->ch[d]=k->ch[!d]; k->ch[!d]=o;
    o->upd(); k->upd(); o=k;
  }
  void ins(Node* &o,LL val) {
    if (o==null) o = newNode(val);
    else {
      //if (val==o->val) return; //same val
      int d=val>o->val; ins(o->ch[d],val);
      if (o->ch[d]->pri<o->pri) rot(o,d);
      else o->upd();
    }
  }
  void del(Node* &o,LL val) {
    if (o==null) return;
    if (o->val==val) {
      int d=o->ch[1]->pri<o->ch[0]->pri;
      if (o->ch[d]==null) {o=null; return;}
      rot(o,d);  del(o->ch[!d],val);
    } else del(o->ch[val>o->val], val);
    o->upd();
  }
  Node* merge(Node *p, Node *q) {
    if (p == null) return q;
    if (q == null) return p;
    if (p->pri >= q->pri) {
      p->ch[1] = merge(p->ch[1], q);
      p->upd(); return p;
    } else {
      q->ch[0] = merge(p, q->ch[0]);
      q->upd(); return q;
    }
  }
  void split(Node *o, LL v, Node* &p, Node* &q) {//[0, v), [v, inf)
    if (o == null) {p = q = null; return;}
    if (o->val < v) {
      split(o->ch[1], v, o->ch[1], q); p = o;
    } else {
      split(o->ch[0], v, p, o->ch[0]); q = o;
    }
    o->upd();
  }
  int kth(Node* o,int k) { //kth number k >= 1
    int s=o->ch[0]->sz+1;
    if (k==s) return o->val;
    return kth(o->ch[k>s],(k<s)?k:k-s);
  }
  int rank(Node* o,int val) { //return how many elements smaller than val
    if (o==null) return 0;
    int s=o->ch[0]->sz;
    if (val==o->val) return s;
    if (val<o->val) return rank(o->ch[0],val);
    else return s+1+rank(o->ch[1],val);
  }
  bool find(Node *o, int x) {
    if (o==null) return 0;
    if (x==o->val) return 1;
    else return find(o->ch[x>o->val],x);
  }
  void init() {
    null=new Node(0,0); np = pool;
    null->ch[0]=null->ch[1]=null;
    null->sz=0; null->pri=inf;
  }
}

LL sum[MAXN];
Treap::Node *tr[MAXN], *p;

void ins(Treap::Node* &rt, LL v) {
  split(rt, v, rt, p);
  rt = Treap::merge(Treap::merge(rt, Treap::newNode(v)), p);
}

void run1(int k) {
  Treap::init(); 
  for (int i = 0; i < k; ++i) {
    tr[i] = Treap::null; sum[i] = 0;
    int n; scanf("%d", &n);
    for (int j = 0; j < n; ++j) {
      int c, w; scanf("%d%d", &c, &w);
      ::ins(tr[i], (sum[i] += w) + c);
    }
  }
  int q; scanf("%d", &q);
  for (int _ = 0; _ < q; ++_) {
    int c, w; scanf("%d%d", &c, &w);
    int id = -1, cnt;
    for (int i = 0; i < k; ++i) {
      Treap::split(tr[i], sum[i] + w, tr[i], p);
      int sz = tr[i]->sz;
      tr[i] = Treap::merge(tr[i], p);
      if (id == -1 || sz < cnt) id = i, cnt = sz;
    }
    printf("%d %d\n", id, cnt);
    Treap::split(tr[id], sum[id] += w, p, tr[id]);
    ::ins(tr[id], sum[id] + c);
  }
}

priority_queue<LL, vector<LL>, greater<LL>> S[MAXN];
#define lson (rt<<1)
#define rson (rt<<1|1)
#define mid ((l+r)>>1)
int mx[MAXN << 4], n, K, M;
void build(int rt, int l, int r) {
  mx[rt] = inf; if (l + 1 == r) return;
  build(lson, l, mid); build(rson, mid, r);
}
int ask(int rt, int l, int r, int w) {
  if (l + 1 == r) return l;
  if (mx[lson] >= w) return ask(lson, l, mid, w);
  else return ask(rson, mid, r, w);
}
void ins(int rt, int l, int r, int x, int v) {
  if (l + 1 == r) {mx[rt] = v; return;}
  if (x < mid) ins(lson, l, mid, x, v);
  else ins(rson, mid, r, x, v);
  mx[rt] = max(mx[lson], mx[rson]);
}

void ins(int i, int c, int w) {
  sum[i] += w;
  while (!S[i].empty() && S[i].top() < sum[i]) S[i].pop();
  vector<LL> pt; S[i].push(c + sum[i]);
  for (int m = 0; m < M; ++m) {
    if (S[i].empty()) ins(1, 0, n, m * K + i, inf);
    else {
      pt.push_back(S[i].top()); S[i].pop();
      ins(1, 0, n, m * K + i, pt.back() - sum[i]);
    }
  }
  for (auto &x: pt) S[i].push(x);
}

void run2(int k) {
  K = k; M = MAXN / K + 1; n = K * M;
  build(1, 0, n);
  for (int i = 0; i < K; ++i) {
    while (!S[i].empty()) S[i].pop();
    sum[i] = 0;
    int n; scanf("%d", &n);
    for (int j = 0; j < n; ++j) {
      int c, w; scanf("%d%d", &c, &w);
      ins(i, c, w);
    }
  }
  int q; scanf("%d", &q);
  for (int i = 0; i < q; ++i) {
    int c, w; scanf("%d%d", &c, &w);
    int r = ask(1, 0, n, w);
    int id = r % K, cnt = r / K;
    printf("%d %d\n", id, cnt);
    ins(id, c, w);
  }
}

int main() {
  int T; scanf("%d", &T);
  for (int cas = 1; cas <= T; ++cas) {
    int k; scanf("%d", &k);
    if (k < P) run1(k);
    else run2(k);
  }
  return 0;
}
