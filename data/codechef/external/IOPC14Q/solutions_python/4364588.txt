#include <bits/stdc++.h>

using namespace std;

const int V = 55;
const int E = V * V * 2 + 4 * V;
const int INF = (int)1e9;

int row[V], col[V], rowsum, colsum, idx[V][V], ans[V][V], cnt, source[V], sink[V];
int vertex[E], cap[E], flow[E], next[E];
int ptr[V << 1], temp[V << 1], Q[V << 1], level[V << 1];

void reset()
{
	cnt = rowsum = colsum = 0;
	memset(next, -1, sizeof(next));
	memset(ptr, -1, sizeof(ptr));
}

void AddEdge(int u, int v, int c)
{
	vertex[cnt] = v;	cap[cnt] = c;	flow[cnt] = 0;	next[cnt] = ptr[u];		ptr[u] = cnt++;
	vertex[cnt] = u;	cap[cnt] = 0;	flow[cnt] = 0;	next[cnt] = ptr[v];		ptr[v] = cnt++;
}

bool bfs(int s, int t)
{
	memset(level, -1, sizeof(level));
	int head = 0, tail = 0;
	Q[tail++] = s;
	level[s] = 0;
	while(head < tail)
	{
		int v = Q[head++];
		for(int i = ptr[v]; i >= 0; i = next[i])
			if(flow[i] < cap[i] && level[vertex[i]] == -1)
			{
				Q[tail++] = vertex[i];
				level[vertex[i]] = level[v] + 1;
			}
	}
	return level[t] >= 0;
}

int dfs(int s, int t, int f)
{
	if(s == t)
		return f;
	for(int &i = temp[s]; i >= 0; i = next[i])
		if(flow[i] < cap[i] && level[vertex[i]] == level[s] + 1)
		{
			int res = dfs(vertex[i], t, min(f, cap[i] - flow[i]));
			if(res)
			{
				flow[i] += res;
				flow[i ^ 1] -= res;
				return res;
			}
		}
	return 0;
}

int Dinic(int s, int t)
{
	int res = 0;
	while(bfs(s, t))
	{
		memcpy(temp, ptr, sizeof(ptr));
		while(true)
		{
			int add = dfs(s, t, INF);
			if(add == 0)
				break;
			res += add;
		}
	}
	return res;
}

void BuildGraph(int n, int m)
{
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &row[i]);
		rowsum += row[i];
		source[i] = cnt;
		AddEdge(0, i, row[i]);
	}

	for(int i = 1; i <= m; i++)
	{
		scanf("%d", &col[i]);
		colsum += col[i];
		sink[i] = cnt;
		AddEdge(n + i, n + m + 1, col[i]);
	}
	
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
		{
			idx[i][j] = cnt;
			AddEdge(i, n + j, 1);
		}
}

bool IsPossible(int n, int m)
{
	if(rowsum != colsum)
		return false;
	if(Dinic(0, n + m + 1) != rowsum)
		return false;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
		{
			int id = idx[i][j];
			if(flow[id] == 1)
			{
				ans[i][j] = 0;
				cap[id] = flow[id] = flow[id ^ 1] = 0;
				int id1 = source[i], id2 = sink[j];
				flow[id1]--;	flow[id1 ^ 1]++;
				flow[id2]--;	flow[id2 ^ 1]++;
				if(Dinic(0, n + m + 1) != 1)
				{
					cap[id] = flow[id] = 1;
					flow[id ^ 1] = -1;
					flow[id1]++;	flow[id1 ^ 1]--;
					flow[id2]++;	flow[id2 ^ 1]++;
					ans[i][j] = 1;
				}
			}
			else
			{
				cap[id] = 0;
				ans[i][j] = 0;
			}
		}
	return true;
}

int main()
{
	int T, n, m;
	scanf("%d", &T);
	for(int testcase = 1; testcase <= T; testcase++)
	{
		reset();
		scanf("%d %d", &n, &m);
		BuildGraph(n, m);
		bool flag = IsPossible(n, m);
		printf("TestCase #:%d\n", testcase);
		if(!flag)
			printf("-1\n");
		else
			for(int i = 1; i <= n; i++)
			{
				for(int j = 1; j <= m; j++)
					printf("%d", ans[i][j]);
				printf("\n");
			}
	}
	return 0;
}