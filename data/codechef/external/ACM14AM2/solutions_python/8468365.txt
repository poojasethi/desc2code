//============================================================================
// Author      : TAPAN SAHNI 
//============================================================================
#include<stdio.h>
#include<iostream>
#include<vector>
#include<string>
#include<cstring>
#include<algorithm>
#include<deque>
#include<map>
#include<set>
#include<stdlib.h>
#include<math.h>
#include<fstream>
#include<sstream>
#include<queue>
#include<stack>
#include<cstdio>
#include<cstdlib>
#include<functional>
using namespace std;
#define LL long long
#define sd(x) scanf("%d",&x)
#define sc(x) scanf("%c",&x)
#define sl(x) scanf("%lld",&x)
#define pdn(x) printf("%d\n",x);
#define pln(x) printf("%lld\n",x);
#define pds(x) printf("%d ",x);
#define pls(x) printf("%lld ",x);
#define pst(x) printf("%s",x);
#define ss(x) scanf("%s",x)
#define all(x) x.begin(),x.end()
#define compress(x) {sort(all(x));(x).resize(unique(all(x))-(x).begin());}
template<class T> inline void umax(T &a,T b){if(a<b) a = b ;}
typedef pair<int, int> ii;
typedef pair<LL, LL> PII;
#define bitcount  __builtin_popcount
#define sz size()
#define pb push_back
#define F first
#define S second
#define rep(i,a,b) for(int  i=(a);i<(b);i++)
#define repl(i,a,b) for(LL i=(a);i<(b);i++)
#define repv(i,b,a) for(int i=(b);i>=(a);i--)
#define mod 1000000007
#define pb push_back
#define mp make_pair
#define LLD long double

const int maxn =  1e5 + 10;
const int INF  = 1e9 + 7;
const double eps = 1e-8;
//const LL INF = 0x0123456789ABCDEFLL;
struct BIT{
    LL t[maxn + 6];
    BIT (void){
        rep(i,0,maxn + 6) t[i] = 0;
    }
    void set(int i, LL v){
        for (; i <= 100000 ; i += i & -i) t[i] += v;
    }
    LL get(int i){
        LL s = 0;
        for (; i; i -= i & -i) s += t[i];
        return s;
    }
};
int m ,val[maxn];
vector<ii> queries;
vector<int> Adj[maxn];
int curr=1 , start[maxn] , end1[maxn] ,level[maxn];
void dfs1(int node,  int par , int hgt ){
    level[node] = hgt;
    start[node] = curr++;
    rep(i,0,Adj[node].sz) if(Adj[node][i] !=par) dfs1(Adj[node][i] , node , hgt + 1);
    end1[node] = curr;
    return;
}
void ref(){
    queries.clear();
    rep(i,0,maxn) Adj[i].clear(),val[i]=0;
    curr = 1;
    return;
}
inline void  solve(void){
    int t;
    sd(t);
    while(t--){ 
        ref();
        sd(m);
        int typ , v , rd = 1,x;
        while(m--){
            sd(typ);sd(v);
            if(typ == 0){
                Adj[v].pb(rd);
                rd++;
            }
            queries.pb(ii(typ ,v));
        }  
        dfs1(0,-1,0);
        rep(i,0,rd) val[i] = start[i] + 1;
        BIT t1 , t2;
        rd = 1;
        t1.set(start[0],1);
        rep(i,0,queries.sz){
            typ=queries[i].F , v=queries[i].S;
            if(typ == 0){
                x = rd;
                if(level[x]%2 == 0){
                    t1.set(start[x],1);
                }   
                else{
                    t2.set(start[x],1);
                }
                rd++;
            }
            else{
               LL e1 = t1.get(end1[v]-1)-t1.get(start[v] - 1);
               e1 = e1 * (e1 - 1);
               e1/=2;
               LL e2 = t2.get(end1[v]-1)-t2.get(start[v] - 1);
               e2 = e2 * (e2 - 1);
               e2/=2;
               pln(e1 + e2);
            }   
        }
    }
    return;     
}   
/*void init() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
}*/
int main(int argc, const char * argv[]){
    //freopen("binary.in","r",stdin);
    //freopen("binary.out","w",stdout);
    //init();
    solve();
    return 0;
}
// NEVER QUIT
