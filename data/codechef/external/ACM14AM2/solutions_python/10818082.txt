#include<bits/stdc++.h>
using namespace std;
#define fs first
#define sc second
#define p 1000000007
#define pb push_back
#define mp make_pair
typedef long long Int;
typedef pair<Int,Int> pii;
typedef vector<Int> vi;
typedef vector<pii> vii;

//segment trees
struct node
{
    Int val;
    Int left;
    Int right;
};
struct node Tree[400000];
struct node Tree2[400000];
void merge(Int a)
{
    Tree[a].val=Tree[2*a].val+Tree[2*a+1].val;
    Tree[a].left=Tree[2*a].left;
    Tree[a].right=Tree[2*a+1].right;
}
 void update(Int curr,Int i,Int v)
 {
     if (Tree[curr].left==Tree[curr].right&&Tree[curr].left==i)
        Tree[curr].val+=v;
     else if (Tree[curr].left<=i&&Tree[curr].right>=i)
     {
         Tree[curr].val+=v;
         update(2*curr,i,v);
         update(2*curr+1,i,v);
     }
 }
void buildtree(Int curr,Int L,Int R)
{
    if (L>R)
        return;
    else if (L==R)
    {
        Tree[curr].val=0;
        Tree[curr].left=L;
        Tree[curr].right=R;
    }
    else
    {
        Int mid=L+(R-L)/2;//to avoid overflow
        buildtree(2*curr,L,mid);
        buildtree(2*curr+1,mid+1,R);
        merge(curr);
    }
}
Int query(Int curr,Int L,Int R)
{
    if (Tree[curr].left>=L&&Tree[curr].right<=R)
        return Tree[curr].val;
    else if (Tree[curr].right<L||Tree[curr].left>R)
        return 0;
    else
        return query(2*curr,L,R)+query(2*curr+1,L,R);
}
//second tree
void merge2(Int a)
{
    Tree2[a].val=Tree2[2*a].val+Tree2[2*a+1].val;
    Tree2[a].left=Tree2[2*a].left;
    Tree2[a].right=Tree2[2*a+1].right;
}
 void update2(Int curr,Int i,Int v)
 {
     if (Tree2[curr].left==Tree2[curr].right&&Tree2[curr].left==i)
        Tree2[curr].val+=v;
     else if (Tree2[curr].left<=i&&Tree2[curr].right>=i)
     {
         Tree2[curr].val+=v;
         update2(2*curr,i,v);
         update2(2*curr+1,i,v);
     }
 }
void buildtree2(Int curr,Int L,Int R)
{
    if (L>R)
        return;
    else if (L==R)
    {
        Tree2[curr].val=0;
        Tree2[curr].left=L;
        Tree2[curr].right=R;
    }
    else
    {
        Int mid=L+(R-L)/2;//to avoid overflow
        buildtree2(2*curr,L,mid);
        buildtree2(2*curr+1,mid+1,R);
        merge2(curr);
    }
}
Int query2(Int curr,Int L,Int R)
{
    if (Tree2[curr].left>=L&&Tree2[curr].right<=R)
        return Tree2[curr].val;
    else if (Tree2[curr].right<L||Tree2[curr].left>R)
        return 0;
    else
        return query2(2*curr,L,R)+query2(2*curr+1,L,R);
}
//ends here

vi G[100005];
Int tim;
Int in[100005];
Int out[100005];
Int level[100005];
pii Query[100005];
void initialise()
{
    for (Int i=0;i<100004;++i)
    {
        tim=-1;
        G[i].clear();
    }
    buildtree(1,0,100003);
    buildtree2(1,0,100003);
    update2(1,0,1);
}
void dfs(Int src)
{
    in[src]=++tim;
    for (Int i=0;i<G[src].size();++i)
    {
        level[G[src][i]]=level[src]+1;
        dfs(G[src][i]);
    }
    out[src]=tim;
}
int main()
{
    Int T;
    cin>>T;
    while (T--)
    {
        initialise();
        Int M,type,V,N=0;
        cin>>M;
        for (Int i=0;i<M;++i)
        {
            cin>>Query[i].fs>>Query[i].sc;
            if (Query[i].fs==0)
            {
                ++N;
                G[Query[i].sc].pb(N);
            }
        }
        level[0]=0;
        dfs(0);
        Int temp=0;
        for (Int i=0;i<M;++i)
        {
            if (Query[i].fs==0)
            {
                ++temp;
                if (level[temp]%2==1)
                    update(1,in[temp],1);
                else
                    update2(1,in[temp],1);
            }
            else
            {
                Int u=query(1,in[Query[i].sc],out[Query[i].sc]);//number of ones
                Int v=query2(1,in[Query[i].sc],out[Query[i].sc]);//number of zeroes
                u=u*(u-1)/2;
                v=v*(v-1)/2;
                cout<<u+v<<"\n";
            }
        }
    }
    return 0;
}
