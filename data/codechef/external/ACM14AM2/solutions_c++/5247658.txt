#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cassert>

using namespace std;

const int LM = 100003;

int bits[2][LM], st[LM], en[LM], t, lv[LM];
vector<int> adjlist[LM];
int n;

void dfs(int u, int parent, int level) {
  int v;
  st[u] = ++t;
  lv[u] = level;
  for(int i = 0; i < adjlist[u].size(); i++) {
    v = adjlist[u][i];
    if(v == parent) continue;
    dfs(v, u, level^1);
  }
  en[u] = t;
}

void update(int x, int idx, int val) {
  while(idx <= n) {
    bits[x][idx] += val;
    idx += (idx & -idx);
  }
}

long long query(int x, int idx) {
  long long ret = 0;
  while(idx > 0) {
    ret += bits[x][idx];
    idx -= (idx & -idx);
  }
  return ret;
}

int main() {
  int T;
  scanf("%d", &T);
  int qry[LM][2];
  while(T--) {
    int m, type, v = 1, u;
    scanf("%d", &m);
    for(int i = 0; i <= m; i++) adjlist[i].clear();
    for(int i = 0; i < m; i++) {
      scanf("%d %d", &type, &u);
      qry[i][0] = type; qry[i][1] = u;
      if(type == 0) adjlist[u].push_back(v++);
    }
    n = v; v = 1;
    t = 0;
    dfs(0, -1, 0);
    assert(t == n);
    memset(bits, 0, sizeof bits);
    update(lv[0], st[0], 1);   // vertex 0 is present
    long long o, e, ans;
    for(int i = 0; i < m; i++) {
      switch(qry[i][0]) {
        case 0: update(lv[v], st[v], 1);
                v++;
                break;
        case 1: u = qry[i][1];
                o = query(1, en[u]) - query(1, st[u] - 1);
                e = query(0, en[u]) - query(0, st[u] - 1);
                //cerr << o << " " << e << "\n";
                ans = o * (o - 1) / 2  + e * (e - 1) / 2;
                printf("%lld\n", ans);
                break;
      }
    }
  }
  return 0;
}
