/*
By : Yash Kumar
Dhirubhai Ambani Institute Of Information And Communication Technology, Gandhinagar (DA-IICT GANDHINAGAR)
1st Year ICT BTECH student
*/
#include<bits/stdc++.h>

#define lli long long int
#define llu unsigned long long int
#define all(v) v.begin(),v.end()

const double EPS = 1e-24;
const lli MOD = 1000000007ll;
const double PI = 3.14159265359;
int INF = 2147483645;
lli INFINF = 9223372036854775807;

template <class T>T Max2(T a,T b){return a<b?b:a;}
template <class T>T Min2(T a,T b){return a<b?a:b;}
template <class T>T Max3(T a,T b,T c){return Max2(Max2(a,b),c);}
template <class T>T Min3(T a,T b,T c){return Min2(Min2(a,b),c);}
template <class T>T Max4(T a,T b,T c,T d){return Max2(Max2(a,b),Max2(c,d));}
template <class T>T Min4(T a,T b,T c,T d){return Min2(Min2(a,b),Max2(c,d));}

using namespace std;

lli T,M,N;
vector<lli> G[100010];
vector<pair<lli,pair<lli,lli> > > queries;
vector<lli> ans;
bool vis[100010];
lli starttime[100010];
lli endtime[100010];
lli dfstime;
lli odd[100010];
lli even[100010];
lli oddsegtree[400010];
lli evensegtree[400010];

void dfsorder(lli u,lli l)
{
    vis[u]=true;
    starttime[u]=dfstime;
    if(l==0)
        even[starttime[u]]=1;
    else
        odd[starttime[u]]=1;
    for(lli v:G[u])
        if(!vis[v])
        {
            dfstime++;
            dfsorder(v,l^1);
        }
    endtime[u]=dfstime;

}

void buildoddsegtree(int s,int e,int idx)
{
    if(s==e)
        oddsegtree[idx]=odd[s];
    else
    {
        int mid=(s+e)/2;
        buildoddsegtree(s,mid,2*idx+1);
        buildoddsegtree(mid+1,e,2*idx+2);
        oddsegtree[idx]=oddsegtree[2*idx+1]+oddsegtree[2*idx+2];
    }
}

void buildevensegtree(int s,int e,int idx)
{
    if(s==e)
        evensegtree[idx]=even[s];
    else
    {
        int mid=(s+e)/2;
        buildevensegtree(s,mid,2*idx+1);
        buildevensegtree(mid+1,e,2*idx+2);
        evensegtree[idx]=evensegtree[2*idx+1]+evensegtree[2*idx+2];
    }
}

lli queryoddsegtree(int s,int e,int x,int y,int idx)
{
    if(s==x && e==y)
        return oddsegtree[idx];
    int mid=(s+e)/2;
    if(y<=mid)
        return queryoddsegtree(s,mid,x,y,2*idx+1);
    else if(x>mid)
        return queryoddsegtree(mid+1,e,x,y,2*idx+2);
    else
        return queryoddsegtree(s,mid,x,mid,2*idx+1)+queryoddsegtree(mid+1,e,mid+1,y,2*idx+2);
}


lli queryevensegtree(int s,int e,int x,int y,int idx)
{
    if(s==x && e==y)
        return evensegtree[idx];
    int mid=(s+e)/2;
    if(y<=mid)
        return queryevensegtree(s,mid,x,y,2*idx+1);
    else if(x>mid)
        return queryevensegtree(mid+1,e,x,y,2*idx+2);
    else
        return queryevensegtree(s,mid,x,mid,2*idx+1)+queryevensegtree(mid+1,e,mid+1,y,2*idx+2);
}

void updateoddsegtree(int s,int e,int x,int idx)
{
    if(x>=s && x<=e)
        oddsegtree[idx]--;
    if(s==e)
        return ;
    int mid=(s+e)/2;
    if(x<=mid)
        updateoddsegtree(s,mid,x,2*idx+1);
    else
        updateoddsegtree(mid+1,e,x,2*idx+2);
}

void updateevensegtree(int s,int e,int x,int idx)
{
    if(x>=s && x<=e)
        evensegtree[idx]--;
    if(s==e)
        return ;
    int mid=(s+e)/2;
    if(x<=mid)
        updateevensegtree(s,mid,x,2*idx+1);
    else
        updateevensegtree(mid+1,e,x,2*idx+2);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);

    cin>>T;
    while(T--)
    {
        cin>>M;
        N=1;
        for(int i=0;i<100010;i++)
            G[i].clear();
        ans.clear();
        queries.clear();
        for(int i=0;i<100010;i++)
            vis[i]=false;
        for(int i=0;i<100010;i++)
            odd[i]=even[i]=0;

        for(int i=1;i<=M;i++)
        {
            lli a,b;
            cin>>a>>b;
            if(a==0)
                G[b].push_back(N);
            queries.push_back({a,{b,N}});
            if(a==0)
                N++;
        }
        dfstime=0;
        dfsorder(0,0);

        /*for(int i=0;i<N;i++)
            cout<<starttime[i]<<" ";
        cout<<"\n";
        for(int i=0;i<N;i++)
            cout<<endtime[i]<<" ";
        cout<<"\n";
        for(int i=0;i<N;i++)
            cout<<odd[i]<<" ";
        cout<<"\n";
        for(int i=0;i<N;i++)
            cout<<even[i]<<" ";
        cout<<"\n";*/

        buildoddsegtree(0,N-1,0);
        buildevensegtree(0,N-1,0);
        reverse(all(queries));

        for(pair<lli,pair<lli,lli> > q : queries)
        {
            //cout<<q.first<<" "<<q.second.first<<"\n";
            if(q.first==0)
            {
                if(odd[starttime[q.second.second]])
                    updateoddsegtree(0,N-1,starttime[q.second.second],0);
                else
                    updateevensegtree(0,N-1,starttime[q.second.second],0);
            }
            else
            {
                lli curans1,curans2;
                curans1=queryevensegtree(0,N-1,starttime[q.second.first],endtime[q.second.first],0);
                curans2=queryoddsegtree(0,N-1,starttime[q.second.first],endtime[q.second.first],0);
                ans.push_back( ((curans1*(curans1-1))/2) + ((curans2*(curans2-1))/2) );
            }
        }
        reverse(all(ans));
        for(lli it:ans)
            cout<<it<<"\n";
    }

    return 0;
}
