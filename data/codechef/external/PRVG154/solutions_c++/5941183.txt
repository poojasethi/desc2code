#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
ll pwr(ll a,ll b,ll mod) {ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); }
const int mod=1000000007;
    int n,m;
    int v[1001][1001];

    int dp_max(int,int);
    int dp_min(int,int);
    bool isValid(int r,int c)
    {
      if(r>=0 && c>=0 && r<n && c<m)
        return true;
      return false;
    }
    int DP_MAX[501][501];
    int DP_MIN[501][501];

    int dp_max(int r,int c)
    {
      // cout<<r<<" "<<c<<endl;
      if(r==n-1 && c==m-1)
        return 0;
      if(DP_MAX[r][c]!=-1)
        return DP_MAX[r][c];
      
      int o1=-1e9;
      int o2=-1e9;
      if(r!=n-1)
        o1=-dp_max(r+1,c)+v[r+1][c];
      if(c!=m-1)
        o2=-dp_max(r,c+1)+v[r][c+1];

      return DP_MAX[r][c]=max(o1,o2);

    }

    // int dp_min(int r,int c)
    // {
    //   if(r==n-1 && c==m-1)
    //     return 0;

    //   if(DP_MIN[r][c]!=-1)
    //     return DP_MIN[r][c];
    //   int o1=1e9;
    //   int o2=1e9;
    //   if(r!=n-1)
    //     o1=dp_max(r+1,c)-v[r+1][c];
    //   if(c!=m-1)
    //     o2=dp_max(r,c+1)-v[r][c+1];

    //   return DP_MIN[r][c]=min(o1,o2);
    // }
int main()
{
  std::ios::sync_with_stdio(false);
  

   int t;
   cin>>t;
   while(t--)
   {
    memset(DP_MAX,-1,sizeof DP_MAX);
    memset(DP_MIN,-1,sizeof DP_MIN);
    cin>>n>>m;
    for(int i=0;i<n;++i)
      for(int j=0;j<m;++j)
        cin>>v[i][j];
    cout<<v[0][0]-dp_max(0,0)<<"\n";

      // cout<<dp_max(1,0)<<endl;

      // cout<<dp_min(0,0)<<endl;
   }

}