#include <iostream> 
#include<bits/stdc++.h>
typedef long long int ll; 
using namespace std;
/* naive solution is - use a circular ll and starting at first keep moving till you reach kth node 
    and then remove it . now k+1 is current element and now count k from here ..repeat till there is only
    onr node left .. which indicates the survivor
    */ 
/*josephus recursion is 
   if(n==1) return 1; 
   else return josephus((n-1,k)+(k-1) ) %n + 1; 
   the k remains constant .. so only 1-d array as per the value of n 
  */ 
int f[100001]; 
///*
int josephus(int n , ll k)
{
	if(f[n]!=-1)
	return f[n]; 
	else if(n==1)
	return f[1]=1;
	else 
	
	//for(i=2;i<=n;i++)
	return f[n] = (josephus(n-1,k)+k-1) % n + 1; 
	//return f[n]; 
}

int main() {
	int n,k  ; 
	
	
	memset(f,-1,sizeof(f));
	scanf("%d %d",&n,&k); 
	 
	printf("%d\n",josephus(n,k)); 
	
	
	return 0;
}