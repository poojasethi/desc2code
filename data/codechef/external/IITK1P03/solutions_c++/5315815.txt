#include<bits/stdc++.h>

using namespace std;
vector<int> graph[100100];
int visited[100100];
int n , e, k;
int population[100100];
bool isph[100100];
long long cost[33];
map<int,int> mp;
vector<int> ph;
long long  p , cst;
vector<pair<long long,long long> > first;
vector<pair<long long,long long> > second;
vector <pair<long long ,long long> > first_subsets;
vector <pair<long long ,long long> > second_subsets;

//bool  dp[17][(1<<17)];
//bool dp1[17][(1<<17)];

void dfs(int u)
{

    if(visited[u])
    {
        return;
    }
    visited[u] = true;
    p += population[u];
    if(isph[u])
        cst = min(cst,cost[mp[u]]);
    for(int i = 0 ; i < graph[u].size() ; i++)
    {
		if(!visited[graph[u][i]])
        dfs(graph[u][i]);
    }
}
/*void generate_subsets(int pos , int bitmask)
{

	if(dp[pos][bitmask]!= 0)
	 return;

    if(pos == first.size())
    {
		dp[pos][bitmask] = 1;
        long long cnt = 0;
        int pop = 0;
        for(int i = 0 ; i < first.size(); i++)
        {

            if((1<<i) & bitmask)
               cnt +=first[i].first, pop += first[i].second;
        }
        first_subsets.push_back(make_pair(cnt,pop));
		    }else
   {
 	dp[pos][bitmask] = 1;
     generate_subsets(pos + 1 , bitmask|(1<<pos));
     generate_subsets(pos + 1 , bitmask);
	}
}

void generate_subsets1(int pos , int bitmask)
{
	if(	dp1[pos][bitmask] != 0)
	return;
    if(pos == second.size())
    {
	dp1[pos][bitmask] = 1;

        long long cnt = 0;
        int pop = 0;
        for(int i = 0 ; i < second.size() ; i++)
        {

            if((1<<i) & bitmask)
               cnt += second[i].first, pop += second[i].second;
        }
        second_subsets.push_back(make_pair(cnt,pop));
    }else
	{
	dp1[pos][bitmask] = 1;
	 
     generate_subsets1(pos + 1 , bitmask|(1<<pos));
     generate_subsets1(pos + 1 , bitmask);
	}
}*/
int main()
{

    cin >> n >> e >> k;
    memset(visited , 0 , sizeof visited);
//	memset(dp,0,sizeof dp);
//	memset(dp1,0,sizeof dp1);
    memset(isph,0,sizeof isph);
    for(int i = 0 ; i < e ; i++)
    {
        int u , v;
        cin >> u >> v;
        u--;
        v--;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    for(int i = 0 ; i < n ; i++)
        cin >> population[i];
    for(int i = 0 ; i < k ; i++)
    {
        int x ;
        cin >> x;
        x--;
        isph[x] = 1;
        ph.push_back(x);
        mp[x] = i;
    }
    for(int i = 0 ; i < k ; i++)
    {
        int  x;
        cin >> x;
        
        cost[i] = x;

    }
    long long m;
    int x;
    cin >> x >> m;
    for(int i = 0 ; i < x ; i++)
    {
        int c ;
        cin >> c;
        m += cost[mp[ph[c-1]]];
    }
    vector <pair<long long,long long > > all;

    for(int i = 0 ; i < ph.size() ; i++)
    {
        p = 0;
        cst = 2e9;
		if(!visited[ph[i]])
		{
        dfs(ph[i]);
        all.push_back(make_pair(cst,p));
		}    
	}
    for(int i = 0 ; i < all.size() / 2 ; i++)
    {
        first.push_back(all[i]);
    }
    for(int i = all.size()/2 ; i < all.size() ; i++)
    {

        second.push_back(all[i]);
    }

  /* generate_subsets(0,0);
   generate_subsets1(0,0);*/
   for(int i = 0 ; i < (1<<first.size()) ; i++)
   {
   	 long long ct = 0; long long tp = 0;
   	 for(int x = 0 ; x < first.size() ; x++)
   	 {
   	 	if((1<<x) &i)
   	 		ct += first[x].first,tp += first[x].second;
   	 	
   	 }
   	 first_subsets.push_back(make_pair(ct,tp));
   }
	
   for(int i = 0 ; i < (1<<second.size()) ; i++)
   {
   	 long long ct = 0; long long tp = 0;
   	 for(int x = 0 ; x < second.size() ; x++)
   	 {
   	 	if((1<<x) &i)
   	 		ct += second[x].first,tp += second[x].second;
   	 	
   	 }
   	 second_subsets.push_back(make_pair(ct,tp));
   }
    long long maxb[(1<<17)];
	memset(maxb,0,sizeof maxb);

    sort(second_subsets.begin() , second_subsets.end());

	for(int i = 0 ; i < second_subsets.size();i++)
    {
        if(i == 0)
            maxb[i] = second_subsets[i].second;
        else
         maxb[i] = max(second_subsets[i].second,maxb[i-1]);
    }
    long long mx = 0;
    for(int i = 0 ; i < first_subsets.size() ; i++)
    {

        int lo = 0; int hi = second_subsets.size()-1;
        int mid;
        int temp = -1;
        while(lo <= hi)
        {
            mid = (lo + hi)/2;
            if(second_subsets[mid].first + first_subsets[i].first <= m)
            {
              temp = mid;
              lo = mid + 1;
            }else
            {
                hi = mid - 1;
            }
        }
		if(temp != -1)
        mx = max(mx,first_subsets[i].second + maxb[temp]);
    }
    cout << mx << endl;
    return 0;
}