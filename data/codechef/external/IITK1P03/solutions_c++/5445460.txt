#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define ll long long

const int mod=1000000007;
long long pwr(long long a,long long b,long long mod)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2,mod);
  temp=(temp*temp)%mod;
  if(b&1)
    temp=(temp*a)%mod;
  return temp;
}
long long pwr(long long a,long long b)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2);
  temp=(temp*temp);
  if(b&1)
    temp=(temp*a);
  return temp;
}
long long gcd(long long a,long long b)
{
  return b==0?a:gcd(b,a%b);
}
long long lcm(long long a,long long b)
{  
  return (a/gcd(a,b))*b;
}
long long modularInverse(long long a,long long m)
{
      return pwr(a,m-2,m);
}
bool* isPrime;
void generatePrimeSieve(const int lim)
{
  isPrime=(bool *)malloc(lim+1);
  memset(isPrime,true,lim+1);
  isPrime[0]=false;
  isPrime[1]=false;
  for(int i=2;i<=lim;++i)
    if(isPrime[i])
      for(int j=i+i;j<=lim;j+=i)
        isPrime[j]=false;
}
#define matrix vector<vector<int> >
matrix identityMatrix;
matrix mul(const matrix &a,const matrix &b)
{
  int n=a.size();
  matrix ans(n,vector<int> (n) );
  for (int i = 0; i < n; ++i)
  {
    for (int j = 0; j < n; ++j)
    {
      for (int k = 0; k < n; ++k)
      {
        ans[i][j]+= ((long long)a[i][k]*b[k][j])%mod;
        ans[i][j]%=mod;
      }
    }
  }
  return ans;
} 
matrix pwr(const matrix &a,long long n)
{
    if(n==0)
    {
      /*define identity */
      assert(false);
      return identityMatrix;
    }
    if(n==1)
     return a;
    matrix tmp=pwr(a,n/2);
    tmp=mul(tmp,tmp);
    if(n&1)
      tmp=mul(a,tmp);
    return tmp;
}
vector<int> nbrs[100005];
int pop[100005];
int powerHouse[40];
ll cost[100005];

ll weight[40];
ll value[40];
ll total;
ll minCost;
bool visited[100005];
int isPowerHouse[100005];
void dfs(int u)
{
  visited[u]=true;
  total+=pop[u];
  minCost=min(minCost,cost[u]);

  for(int i=0;i<nbrs[u].size();++i)
  {
    int v=nbrs[u][i];
    
    if(visited[v])
      continue;

    dfs(v);

  }
}

#define pll pair<long long,long long>

vector<pll> generateAllSubsets(vector<ll> &w,vector<ll> &v)
{
  int n=w.size();

  vector<pll> ans;
  for(int mask=0;mask<(1<<n);++mask)
  { 
      ll weight=0;
      ll value=0;

      for(int i=0;i<n;++i)
      {
        if(mask&(1<<i))
        {
          weight+=w[i];
          value+=v[i];
        }
      }

      ans.push_back(pll(weight,value));

  }

  sort(ans.begin(),ans.end());
  assert(ans.size()>=1);
  return ans;
}
ll MITM(ll capacity,ll weight[],ll value[],int n)
{
  /* partition into 2 sets */

  int size1=n/2;
  int size2=n-n/2;

  vector<ll> w,v;
  for(int i=0;i<size1;++i)
  {
    w.push_back(weight[i]);
    v.push_back(value[i]);
  }

  vector<pll> setA= generateAllSubsets(w,v);


  w.clear();
  v.clear();
  for(int i=size1;i<n;++i)
  {
    w.push_back(weight[i]);
    v.push_back(value[i]);
  }
  vector<pll> setB= generateAllSubsets(w,v);

  vector<ll> maxUptoThis;
  ll maxm=0;
  
  for(int i=0;i<setB.size();++i)
  {
    maxm=max(maxm,setB[i].second);
    maxUptoThis.push_back(maxm);
  }

  ll best=-1;
  for(int i=0;i<setA.size();++i)
  {
    ll leftOverCapacity = capacity - setA[i].first;  

    pll searchArguement=pll(leftOverCapacity,1000000000000000ll);
    int index=upper_bound(setB.begin(),setB.end(),searchArguement)-setB.begin();

    // --index;


    // cout<<setA[i].first<<" "<<setA[i].second<<" matches to";
    if(index>=1)
    {
      // cout<<
      --index;
      leftOverCapacity-=setB[index].first;

      assert(leftOverCapacity>=0);
      
      ll curr = setA[i].second + maxUptoThis[index];
      best=max(curr,best);
    }
    else
    {

    }

  }

  return best;

}

int main()
{
  std::ios::sync_with_stdio(false);
  
  memset(visited,false,sizeof visited);

  for(int i=1;i<=100000;++i)
    cost[i]=1e9+7;

  int n,e,k;
  cin>>n>>e>>k;
  for(int i=1;i<=e;++i)
  {
    int u,v;
    cin>>u>>v;
    nbrs[u].push_back(v);
    nbrs[v].push_back(u);
  }

  for(int i=1;i<=n;++i)
    cin>>pop[i];
  

  for(int i=1;i<=k;++i)
    cin>>powerHouse[i];
  
  for(int i=1;i<=k;++i)
    {
      int c;
      cin>>c;
      cost[powerHouse[i]]=c;
    }
  
  int x;
  ll money;
  cin>>x>>money;
  while(x--)
  {
    ll i;
    cin>>i;
    money+=cost[powerHouse[i]];
  }


  /* for each component: cost= cheapest PowerHouse, value: all population */

  int cnt=0;
  for(int i=1;i<=k;++i)
  {
    int p=powerHouse[i];
    if(!visited[p])
    {
      minCost=infinity;
      total=0;

      dfs(p);
      weight[cnt]= minCost;
      value[cnt] = total;
      ++cnt;
    }
  }

  cout<<MITM(money,weight,value,cnt);
  // cout<<LKS(money,weight,value,cnt);
  



  
}