// adijimmy
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define MAX 100005
#define pb push_back
#define mp make_pair
ll population[MAX];
bool powerhouse[MAX];
ll cost[MAX];
ll visited[MAX];
vector<ll> G[MAX];
ll component;
ll n,e,k;
ll solve(vector<ll> costRequired,vector<ll> profit,ll money){
 ll sz = costRequired.size();
  if(sz==1){
    if(costRequired[0]<=money)
        return profit[0];
    else
        return 0;
  }
  vector<pair<ll,ll> > FV,SV;
  for(ll i=0;i<sz/2;i++){
    FV.pb(mp(costRequired[i],profit[i]));
  }
  for(ll i=sz/2;i<sz;i++){
    SV.pb(mp(costRequired[i],profit[i]));
  }
  set<pair<ll,ll> > FS,SS;
  for(ll mask=1;mask<(1<<FV.size());mask++){
		ll costNeeded = 0;
		ll profitAttained = 0;
		for(ll i=0;i<FV.size();i++){
			if (mask&(1<<i)){
				costNeeded += FV[i].first;
				profitAttained += FV[i].second;
			}
		}
		FS.insert(mp(costNeeded,profitAttained));
  }
  for(ll mask=1;mask<(1<<SV.size());mask++){
		ll costNeeded = 0;
		ll profitAttained = 0;
		for(ll i=0;i<SV.size();i++){
			if (mask&(1<<i)){
				costNeeded += SV[i].first;
				profitAttained += SV[i].second;
			}
		}
		SS.insert(mp(costNeeded,profitAttained));
  }
    vector<pair<ll,ll> > F = vector<pair<ll,ll> >(FS.begin(),FS.end());
	vector<pair<ll,ll> > S = vector<pair<ll,ll> >(SS.begin(),SS.end());
	vector<ll> mxValues(S.size());
	ll mx = 0;
	for(ll i=0;i<S.size();i++){
		mx = max(mx, S[i].second);
		mxValues[i] = mx;
	}
	mx = 0;
	vector<ll> mxValuesAgain(F.size());
	for(ll i=0;i<F.size();i++){
		mx = max(mx,F[i].second);
		mxValuesAgain[i] = mx;
	}
	ll ans = 0;
	ll id = upper_bound(S.begin(), S.end(),mp(money, 0LL)) - S.begin();
	id--;
	if(id >= 0)
		ans = max(ans, mxValues[id]);
	id = upper_bound(F.begin(), F.end(),mp(money, 0LL)) - F.begin();
	id--;
	if(id >= 0)
		ans = max(ans, mxValuesAgain[id]);
	for(ll i = 0; i < F.size(); i++){
		ll id = upper_bound(S.begin(), S.end(), make_pair(money -  F[i].first, 0LL)) - S.begin();
		id --;
		if(id >= 0 && id < S.size()){
			ll cur = F[i].second;
			cur += mxValues[id];
			ans = max(ans, cur);
		}
	}
	return ans;
}
void dfs(ll u){
visited[u] = component;
    for(ll i=0;i<G[u].size();i++){
      if(!visited[G[u][i]])
        dfs(G[u][i]);
    }
}
int main(){
ll u,v,c,m,money;
cin >> n >> e >> k;
for(ll i=0;i<e;i++){
    cin >> u >> v;
    u--;v--;
    G[u].pb(v);
    G[v].pb(u);
}
for(ll i=0;i<n;i++)
    cin >> population[i];
vector<int> city;
for(ll i=0;i<k;i++){
    cin >> u;
    u--;
    powerhouse[u] = true;
    city.pb(u);
}
for(ll i=0;i<k;i++){
    cin >> c;
    cost[city[i]] = c;
}
cin >> m >> money;
for(ll i=0;i<m;i++){
    cin >> u;
    u--;
    money += cost[city[u]];
}
component = 1;
for(ll i=0;i<n;i++){
    if(!visited[i]){
      dfs(i);
      component++;
    }
}
vector<ll> values(component+1);
vector<ll> Size(component+1);
for(ll i=0;i<component+1;i++)
  values[i]=(ll)1e18;
for(ll i=0;i<n;i++){
    ll id = visited[i];
    Size[id] += population[i];
    if(powerhouse[i])
      values[id] = min(values[id],cost[i]);
}
vector<ll> costRequired;
vector<ll> profit;
for(ll i=0;i<=component;i++){
    if (values[i]!=(ll)1e18){
        costRequired.push_back(values[i]);
        profit.push_back(Size[i]);
    }
}
cout << solve(costRequired,profit,money) << endl;
return 0;
}
