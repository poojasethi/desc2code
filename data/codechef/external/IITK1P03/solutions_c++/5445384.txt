#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define ll long long

const int mod=1000000007;
long long pwr(long long a,long long b,long long mod)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2,mod);
  temp=(temp*temp)%mod;
  if(b&1)
    temp=(temp*a)%mod;
  return temp;
}
long long pwr(long long a,long long b)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2);
  temp=(temp*temp);
  if(b&1)
    temp=(temp*a);
  return temp;
}
long long gcd(long long a,long long b)
{
  return b==0?a:gcd(b,a%b);
}
long long lcm(long long a,long long b)
{  
  return (a/gcd(a,b))*b;
}
long long modularInverse(long long a,long long m)
{
      return pwr(a,m-2,m);
}
bool* isPrime;
void generatePrimeSieve(const int lim)
{
  isPrime=(bool *)malloc(lim+1);
  memset(isPrime,true,lim+1);
  isPrime[0]=false;
  isPrime[1]=false;
  for(int i=2;i<=lim;++i)
    if(isPrime[i])
      for(int j=i+i;j<=lim;j+=i)
        isPrime[j]=false;
}
#define matrix vector<vector<int> >
matrix identityMatrix;
matrix mul(const matrix &a,const matrix &b)
{
  int n=a.size();
  matrix ans(n,vector<int> (n) );
  for (int i = 0; i < n; ++i)
  {
    for (int j = 0; j < n; ++j)
    {
      for (int k = 0; k < n; ++k)
      {
        ans[i][j]+= ((long long)a[i][k]*b[k][j])%mod;
        ans[i][j]%=mod;
      }
    }
  }
  return ans;
} 
matrix pwr(const matrix &a,long long n)
{
    if(n==0)
    {
      /*define identity */
      assert(false);
      return identityMatrix;
    }
    if(n==1)
     return a;
    matrix tmp=pwr(a,n/2);
    tmp=mul(tmp,tmp);
    if(n&1)
      tmp=mul(a,tmp);
    return tmp;
}
vector<int> nbrs[100005];
int pop[100005];
int powerHouse[40];
ll cost[100005];

ll weight[40];
ll value[40];
ll total;
ll minCost;
bool visited[100005];
int isPowerHouse[100005];
void dfs(int u)
{
  visited[u]=true;
  total+=pop[u];
  minCost=min(minCost,cost[u]);

  for(int i=0;i<nbrs[u].size();++i)
  {
    int v=nbrs[u][i];
    
    if(visited[v])
      continue;

    dfs(v);

  }
}

int n;
// double k;
double maxm=-1;
double v[32],w[32],r[32];
double estimate(int starting,double wl)
  {
  if(starting >=n) return 0;
  if(wl<0) return 0; 
  int i;
  double ans=0;
  double wt=0;
    for(i=starting;i<n;++i)
      {
 
      if( wt+w[i]<=wl ){ans+=v[i];wt+=w[i];}
      else {ans+=(v[i]*(wl-wt)/w[i]);break;}
 
      }
  return ans;
  }
void swap(double &a,double &b)
  {
  double t=a;
  a=b;
  b=t;
  }
void swap(long long &a,long long &b)
  {
  long long t=a;
  a=b;
  b=t;
  }
void evaluate(int i,double cv,double wl)
  {
    if(wl<0 ) return;
    if(i>n) return;
 
    double e=estimate(i,wl)+cv;
 
    if( e<maxm ) return;
 
 
    if(cv>maxm ) maxm=cv;
    
    if(    e==cv   ) return;  
    
    else 
      {
      evaluate(i+1,cv+v[i],wl-w[i]) ;   
      evaluate(i+1,cv,wl);
      }
  }
long long LKS(long long capacity, ll weight[],ll value[],int cnt)
{
// scanf("%f%d",&k,&n); 
 n=cnt;
 double k=capacity;
for(int i=0;i<n;++i)
  {
  v[i]=value[i];
  w[i]=weight[i];
  // scanf("%f%f",&v[i],&w[i]);
  r[i]=v[i]/w[i];
  }
 
 // for(int i=0;i<n;++i)
 // {
 //  cout<<w[i]<<" "<<v[i]<<endl;
 // }
for(int i=0;i<n;++i)
  for(int j=0;j<n-1;++j)
    {
    if( r[j]<r[j+1] )
        {
 
        swap(r[j],r[j+1]);
        swap(v[j],v[j+1]);
        swap(w[j],w[j+1]);
        }
    }
    // for(int i=0;i<n;++i)
    //  {
    //   cout<<w[i]<<" "<<v[i]<<" "<<r[i]<<endl;
    //  }
  // return maxm;

  evaluate(0,0,k);
  return maxm;
 
}
int main()
{
  std::ios::sync_with_stdio(false);
  
  memset(visited,false,sizeof visited);

  for(int i=1;i<=100000;++i)
    cost[i]=1e9+7;

  int n,e,k;
  cin>>n>>e>>k;
  for(int i=1;i<=e;++i)
  {
    int u,v;
    cin>>u>>v;
    nbrs[u].push_back(v);
    nbrs[v].push_back(u);
  }

  for(int i=1;i<=n;++i)
    cin>>pop[i];
  

  for(int i=1;i<=k;++i)
    cin>>powerHouse[i];
  
  for(int i=1;i<=k;++i)
    {
      int c;
      cin>>c;
      cost[powerHouse[i]]=c;
    }
  
  int x;
  ll money;
  cin>>x>>money;
  while(x--)
  {
    ll i;
    cin>>i;
    money+=cost[powerHouse[i]];
  }


  /* for each component: cost= cheapest PowerHouse, value: all population */

  int cnt=0;
  for(int i=1;i<=k;++i)
  {
    int p=powerHouse[i];
    if(!visited[p])
    {
      minCost=infinity;
      total=0;

      dfs(p);
      weight[cnt]= minCost;
      value[cnt] = total;
      ++cnt;
    }
  }


  cout<<LKS(money,weight,value,cnt);
  



  
}