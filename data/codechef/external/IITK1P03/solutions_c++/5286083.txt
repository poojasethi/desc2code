#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std ;

const int MAXN = 1e5;
const long long oops = 1e18;

struct Component {
    long long cost, population;
    Component() {}
    Component(long long c, long long p) : cost(c), population(p) {}
    bool operator < (const Component& that) const {
        return make_pair(cost, population) < make_pair(that.cost, that.population);
    }
};

typedef Component Combination;

vector<vector<int> > G;
int population[MAXN+5];
bool powerhouse[MAXN+5];
int cost[MAXN+5];
vector<int> houses;

vector<Combination> lefts, rights;
vector<Component> components;
vector<long long> bestCombination;
bool vis[MAXN+5];

long long budget;
int n,m,K;

void dfs(int u) {
    if (vis[u]) return ;
    vis[u] = true;
    components.back().population += population[u];
    if (powerhouse[u])
        components.back().cost = min(components.back().cost, cost[u] * 1LL);
    for (int c=0;c<G[u].size();c++)
        dfs(G[u][c]);
    return;
}

void getComponents() {
    memset(vis, 0, sizeof(vis));
    for (int u=0;u<n;u++) {
        if (vis[u])continue;
        components.push_back(Component(oops, 0));
        dfs(u);
        if (components.back().cost == oops)
            components.pop_back();
    }
}

void getCombinations(int start, int end, vector<Combination>& combinations) {
    int sz = end - start;
    for (int mask = 0; mask < (1 << sz); mask ++) {
        Combination comb(0,0);
        for (int c=0;c<sz;c++)
            if (mask & (1<<c)) {
                comb.cost += components[start + c].cost;
                comb.population += components[start + c].population;
            }
        combinations.push_back(comb);
    }
    return ;
}

long long solve() {
    long long ret = 0;
    for (int c=0;c<lefts.size();c++) {
        long long rem = budget - lefts[c].cost;
        if (rem < 0) continue;
        int i = upper_bound(rights.begin(), rights.end(), Combination(rem, -1)) - rights.begin();
        i--;
        if (i < 0) continue;
        ret = max(ret, lefts[c].population + bestCombination[i]);
    }
    return ret;
}

int main() {
    //freopen("powerhouse.in","r",stdin);
    int c,c2;
    scanf("%d%d%d",&n,&m,&K);
    G.resize(n);
    for (c=0;c<m;c++) {
        int u,v;
        scanf("%d%d",&u,&v);
        u--;v--;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (c=0;c<n;c++)
        scanf("%d",&population[c]);
    houses.resize(K);
    for (c=0;c<K;c++) {
        scanf("%d",&houses[c]);
        houses[c]--;
        powerhouse[houses[c]] = true;
    }
    for (c=0;c<K;c++) {
        scanf("%d",&cost[houses[c]]);
    }
    int mine;
    scanf("%d%lld",&mine,&budget);
    for (c=0;c<mine;c++) {
        int i;
        scanf("%d",&i);
        budget += cost[houses[i - 1]];
    }
    getComponents();
    int half = components.size() + 1 >> 1;
    getCombinations(0, half, lefts);
    getCombinations(half, components.size(), rights);
    sort(rights.begin(), rights.end());
    bestCombination.resize(rights.size());
    for (c=0;c<rights.size();c++) {
        if (c == 0)
            bestCombination[c] = rights[c].population;
        else bestCombination[c] = max(bestCombination[c - 1], rights[c].population);
    }
    long long ret = solve();
    printf("%lld\n",ret);
    return 0;
}
