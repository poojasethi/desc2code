//#include "programming_contests.h"




#ifndef PROGRAMMING_CONTESTS_H
#define PROGRAMMING_CONTESTS_H
#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <tr1/random>
#include <tr1/unordered_map>
#include <tr1/unordered_set>
#include <typeinfo>
#include <utility>
#include <vector>
#ifdef LOCALHOST
static FILE* _freopen = freopen("input.txt", "r", stdin);
#else
#define NDEBUG
#endif
#include <cassert>
using namespace std;
using namespace std::tr1;





typedef long long LL;

inline int RI(){int res;int r=scanf("%i ",&res);assert(r);return res;}
inline LL RLL(){LL res;int r=scanf("%lld ",&res);assert(r);return res;}
inline string RS(){char buf[2000];int r=scanf("%s ",buf);assert(r);return string(buf);}
inline string RL(){string res;getline(cin,res);assert(cin.good());return res;} //Requires and discards line break at end of line.
#define FIN(path) freopen(path, "r", stdin)
#define FOUT(path) freopen(path, "w", stdout)


#define IT(c) typeof(c.begin())
#define ALL(x) x.begin(), x.end()
#define PB push_back
#define MP make_pair
#define LEN(a) (sizeof(a)/sizeof(a[0]))

#define FOR(i, a, b) for(typeof(a) i=(a), _b=(b); i<_b; ++i)
#define FORD(i, a, b) for(typeof(a) i=(b-1), _a=(a); i>=_a; --i)
#define FORE(i,c) for(IT(c) i=(c).begin(); i!=(c).end(); ++i)



static const double PI = acos(-1.0);
static const double GOLD = (1+sqrt(5.0))/2;








template<typename T> inline T sqr(const T& x){return x*x;}
double eucDist(const double& x0, const double& y0, const double& x1, const double& y1){return sqrt(sqr(x0-x1)+sqr(y0-y1));}
template<typename T> inline T manDist(const T& x0, const T& y0, const T& x1, const T& y1){return abs(x0-x1)+abs(y0-y1);}

// Requires that type of v is the type that a contains.
template <typename A, typename V>
static void fillArray(A &a, const V &v) {
  fill_n((V*)a, sizeof(a)/sizeof(V), v);
}

















// Stuff for debugging.

static void sleep(const int ms) {
    clock_t goal = ms + clock();
    while (goal > clock());
}

template<typename T>
static void print(T x) {
  cerr << x << endl;
}

template<typename T>
static void print(T first, const T &last) {
  while(first != last) cerr << *(first++) << " ";
  cerr << endl;
}

template<typename T, size_t LENGTH>
static void print(const T (&a)[LENGTH]) {
  print(a,a+LENGTH);
}

template<typename T, size_t LENGTH0, size_t LENGTH1>
static void print(const T (&a)[LENGTH0][LENGTH1]) {
  for(int i = 0; i < LENGTH0; ++i) {
    print(a[i]);
  }
}

static double timer() {
  return 1.0*clock()/CLOCKS_PER_SEC;
}

#endif // PROGRAMMING_CONTESTS_H






// Requires x >= 2.
// m[p] is the number of times p appears in the prime factorization of x
static void primeFactorization(long long x, map<long long,int>& m) {
  long long fac = 2;
  while (fac*fac <= x) {
      if (x % fac == 0) {
          // The smallest factor of x that is > 1 is prime.
          ++m[fac];
          x /= fac;
      } else fac += (fac == 2 ? 1 : 2);
  }
  if (x > 1) ++m[x];
}


int main() {
  int t = RI();
  FOR(test,0,t) {
    LL x = RLL(), y = RLL(), z = RLL();
    map<LL,int> m;
    primeFactorization(z,m);
    LL res = numeric_limits<LL>::max();
    FORE(i,m) {
      LL p = i->first;
      LL N = 0;
      LL xy = x*y;
      while(xy > 0){N+=xy/p;xy/=p;}
      int x = i->second;
      res = N/x;//min(res,N/x);
    }
    printf("%lld\n",res);
  }
  return 0;
}
