#pragma comment(linker, "/STACK:102400000,102400000")
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <queue>
#include <set>
#include <cmath>
#include <fstream>
#include <assert.h>
#include <complex>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 1000000

const int M=999999;
double t[N<<2],s[N<<2],c[N<<2];
bool f[N<<2];
void up(int p){
    t[p]=t[p<<1]+t[p<<1|1];
    s[p]=s[p<<1]+s[p<<1|1];
}
void cal(int p,int l,int r,double v){
    t[p]+=v*(r-l+1)*(l+r)/2;
    s[p]+=v*(r-l+1);
    c[p]+=v;
}
void cal1(int p){
    t[p]=s[p]=c[p]=0;
    f[p]=1;
}
void down(int p,int l,int r){
    int m=(l+r)>>1;
    if(f[p]){
        cal1(p<<1);
        cal1(p<<1|1);
        f[p]=0;
    }
    if(c[p]>0){
        cal(p<<1,l,m,c[p]);
        cal(p<<1|1,m+1,r,c[p]);
        c[p]=0;
    }
}
void add(int p,int l,int r,int x,int y,double v){
    if(x>y)return;
    if(l==x&&r==y){
        cal(p,l,r,v);
        return;
    }
    int m=(l+r)>>1;
    down(p,l,r);
    if(y<=m)add(p<<1,l,m,x,y,v);
    else if(x>m)add(p<<1|1,m+1,r,x,y,v);
    else{
        add(p<<1,l,m,x,m,v);
        add(p<<1|1,m+1,r,m+1,y,v);
    }
    up(p);
}
void query(int p,int l,int r,int x,int y,double &a,double &b){
    if(x>y){a=b=0;return;}
    if(l==x&&r==y){
        a=t[p],b=s[p];return ;
    }
    int m=(l+r)>>1;
    down(p,l,r);
    if(y<=m)query(p<<1,l,m,x,y,a,b);
    else if(x>m)query(p<<1|1,m+1,r,x,y,a,b);
    else{
        query(p<<1,l,m,x,m,a,b);
        double a1=0,b1=0;
        query(p<<1|1,m+1,r,m+1,y,a1,b1);
        a+=a1,b+=b1;
    }
    up(p);
}
void build(int p,int l,int r){
    if(l==r){t[p]=1.*l/N;s[p]=1./N;return;}
    int m=(l+r)>>1;
    build(p<<1,l,m);
    build(p<<1|1,m+1,r);
    up(p);
}
void clear(int p,int l,int r,int x,int y){
    if(x>y)return;
    if(l==x&&r==y){
        cal1(p);
        return;
    }
    int m=(l+r)>>1;
    down(p,l,r);
    if(y<=m)clear(p<<1,l,m,x,y);
    else if(x>m)clear(p<<1|1,m+1,r,x,y);
    else{
        clear(p<<1,l,m,x,m);
        clear(p<<1|1,m+1,r,m+1,y);
    }
    up(p);
}
int main()
{
    //freopen("2.txt","w",stdout);
    int T,i,j,k,ca=0,n,m;
    scanf("%d",&n);
    int s=0,start=0,v;
    bool flag=false;
    double ans;
    build(1,0,M);
    while(n--){
        scanf("%d",&v);
        if(!flag){
            if(s+v<=M){
                s+=v;ans=s;
            }
            else flag=true;
        }
        else{
            double s=0;
            if(v>start){
                double a=0,b=0;
                query(1,0,M,0,start-1,a,b);
                s=b;a=b=0;
                query(1,0,M,N-(v-start),M,a,b);
                s+=b;
                clear(1,0,M,0,start-1);
                clear(1,0,M,N-(v-start),M);
            }
            else{
                double a;
                query(1,0,M,start-v,start-1,a,s);
                clear(1,0,M,start-v,start-1);
            }
            add(1,0,M,0,M,s/N);
            start-=v;
            if(start<0)start+=N;
        }
        if(flag){
            double a=0,b=0;
            query(1,0,M,start,M,a,b);
            ans=a;a=b=0;
            query(1,0,M,0,start-1,a,b);
            ans+=a;a=b=0;
            query(1,0,M,0,start-1,a,b);
            ans+=b*N-start;
        }
        printf("%.9lf\n",ans);
    }
    return 0;
}