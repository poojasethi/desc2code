//BFS traversal using STL
#include<iostream>
#include<cstdio>
#include<queue>

#define max 100005
#define P 1000000007

using namespace std;

queue<int> Q;
int visited[max];
vector<int> A[max];		//Array of vectors for adjacency list


void bfs(int node)
{
int x;
visited[node]=1;	//node has been visited

if(Q.empty()==false)	//queue is not empty
for(x=0;x<A[node].size();x++)
if(visited[A[node][x]]==0)	//vertex i in the edge list of vertex node is unvisited
{
Q.push(A[node][x]);
//cout<<"count is "<<count<<endl;
visited[A[node][x]]=1;
}


Q.pop();
if(Q.empty()==false)
bfs(Q.front());	//run bfs from the next vertex

}

int main()
{
int T,N,M,i,x,y;
cin>>T;

while(T--)
{
cin>>N>>M;

for(i=0;i<=N;i++)
{
visited[i]=0;	//mark all vertices unvisited
A[i].clear();
}

for(i=0;i<M;i++)
{
cin>>x>>y;
x++;
y++;
A[x].push_back(y);	// y is a edge on x's adjacency list
A[y].push_back(x);
}



int component=0;

for(i=1;i<=N;i++)	//all vertices of the graph
{
if(visited[i]==0)	//unvisited vertice
{
component++;	//one more connected component of the graph
Q.push(i);	//push ith vertex in the queue
bfs(i);
}

}

cout<<component<<endl;


}	//end T--;

return 0;
}


