/*
Author : Tushar Makkar (tusharmakkar08) 
*/

// Libraries 

#include <list>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>

// Definitions 

//Constants
#define mod 1000000007

// Input Output
#define s(n)					scanf("%d",&n)
#define sl(n) 					scanf("%lld",&n)
#define sf(n) 					scanf("%lf",&n)
#define ss(n) 					scanf("%s",n)
#define pf printf
#define pl(n) 					printf("%lld\n",n)
#define pb push_back

// function Definition
#define maX(i,j) (i>j?i:j)
#define miN(i,j) (i<j?i:j)
#define mset(x,v) memset(x,v,sizeof(x))
#define FOR(i,a,b) for(LL i=(LL)(a);i<(LL)(b);i++)
#define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)	
#define REV(i,a,b) for(LL i=(LL)(a);i>=(LL)(b);i--)
#define foreach(v, c)     for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v)
#define checkbit(n,b)                ( (n >> b) & 1)

// Useful hardware instructions
#define bitcount                    __builtin_popcount
#define gcd                         __gcd

//Debugging
#define dbgarr(a,m,n)				FOR(i,m,n)pf("%lld ",a[i])
#define dbgmat(a,m,n,k,l)			FOR(i,m,n){FOR(j,k,l)pf("%lld ",a[i]);pf("\n")}

using namespace std;

// Variables type
#define LL long long int
typedef vector < LL > row;
typedef vector < row > matrix;

// Global Declarations
LL a[100000],maze[2000][2000];
char mat[2000][2000];
char str[1000010];
list<int> *adj;
bool *visited;
LL component;
void dfs_util(LL u);
void dfs(LL n)
{
	component=0;
	FOR(i,0,n)
	visited[i]=false;
	FOR(i,0,n)
	{
		if(!visited[i])
		{
			dfs_util(i);
			component+=1;
		}
	}
}

void dfs_util(LL u)
{
	visited[u]=true;
	ITER(i,adj[u])
	{
		if(!visited[*i])
		{
			dfs_util(*i);
		}
	}
}

int main()
{
	LL T,N,M,a,b,ans=0;
	sl(T);
	while(T--)
	{
		sl(N);
		adj=new list<int>[N];
		visited=new bool[N];
		sl(M);
		FOR(i,0,M)
		{
			sl(a);sl(b);
			adj[a].pb(b);
			adj[b].pb(a);
		}
		dfs(N);
		pl(component);
	}
	return 0;
}
