#include <bits/stdc++.h>
using namespace std;

typedef long long int ll;
typedef vector<int> vi;
typedef vector< vector<int> > vvi;
#define rep(i,n) for(int i=0;i<(n);i++)
int tcs, tc;

class Tree {
	int n, blocks;
	vi parents;
	vector<bool> blocked;
	vvi adj_list;
	bool parents_calculated;

	void cal_parents_dfs(int i, bool* seen) {
		if (seen[i]) return;
		seen[i] = true;
		for (vi::iterator it = adj_list[i].begin(); it != adj_list[i].end(); ++it) {
			if (!seen[*it]) parents[*it] = i;
			cal_parents_dfs(*it, seen);
		}
	}
	void cal_parents() {
		if (parents_calculated) return;
		bool *seen = new bool[n+1];
		cal_parents_dfs(1, seen);
		delete[] seen;
		parents_calculated = true;
	}
public:
	Tree(int _n) {
		n = _n;
		blocks = 0;
		parents_calculated = false;
		adj_list.resize(n+1, vi());
		parents.resize(n+1, -1);
		blocked.resize(n+1, false);
	}

	void add_edge(int i, int j) {
		adj_list[i].push_back(j);
		adj_list[j].push_back(i);
	}

	void block(int i) {
		if (!parents_calculated) cal_parents();
		while (i!=-1 && !blocked[i]) {
			blocked[i] = true;
			i = parents[i];
			blocks++;
		}
	}

	int canBlastCount() {
		return n - blocks;
	}
};

void solve() {
	int n, m, a, b;
	cin >> n;
	Tree t(n);
	rep (i, n-1) {
		cin >> a >> b;
		t.add_edge(a, b);
	}

	cin >> m;
	rep (i, m) {
		cin >> a;
		t.block(a);
		cout << t.canBlastCount() << endl;
	}
}

int main () {
	std::ios::sync_with_stdio(false);
	cin >> tcs; for (tc=1; tc<=tcs; ++tc) solve();
	return 0;
}
