#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <algorithm>
#include <sstream>
#include <utility>
#include <list>
#include <iterator>
using namespace std;

#pragma comment(linker, "/STACK:36777216")

#define rep(i, n) for (int i = 0; i < n; i++)
#define sz(v) (int) ((v).size())
#define mp(x, y) make_pair(x, y)

void solve();
int main()
{
//    freopen("../QtConsoleApp/1.txt", "r", stdin);
//    freopen("../QtConsoleApp/1.out", "w", stdout);
//    freopen("input.txt", "r", stdin);
//    freopen("output.txt", "w", stdout);
    solve();
    return 0;
}

typedef long long LL;
const LL MOD = 1000000007;

LL C[23][23];

int data[40000];
int nxt[40000];
int head[20000];
int sp = 0;
int N, K;

void addEdge(int a, int b)
{
    data[sp] = b;
    nxt[sp] = head[a];
    head[a] = sp;
    sp++;
}

int dp[20000][21];

void dfs1(int v, int pv)
{
    bool leaf = true;
    for (int j = head[v]; j != -1; j = nxt[j])
    {
        int u = data[j];
        if (u != pv)
        {
            leaf = false;
            dfs1(u, v);
        }
    }

    if (leaf)
    {
        for (int i = 0; i <= K; i++)
            dp[v][i] = 1;
    }
    else
    {
        static LL a[21];
        for (int i = 0; i <= K; i++)
        {
            LL res = 0;
            for (int j = head[v]; j != -1; j = nxt[j])
            {
                int u = data[j];
                if (u != pv)
                {
                    res = (res + dp[u][i]) % MOD;
                }
            }
            a[i] = res;
        }

        for (int k = 0; k <= K; k++)
        {
            LL res = 1;
            for (int j = 0; j <= k; j++)
            {
                res = (res + (C[k][j] * a[j]) % MOD) % MOD;
            }
            dp[v][k] = res;
        }
    }
}

LL buf[20000][21];
LL tmp[20000][21];
int ans[20000];

LL tmp2[20000][21];
int vertex[20000];
int vp = 0;

void dfs2(int v, int pv)
{
    ans[v] = (buf[v][K] + dp[v][K]) % MOD;

    for (int k = 0; k <= K; k++)
    {
        LL res = 0;
        for (int j = 0; j <= k; j++)
        {
            res = (res + (C[k][j] * buf[v][j]) % MOD) % MOD;
        }
        tmp[v][k] = res;
    }

    int from = vp;
    for (int j = head[v]; j != -1; j = nxt[j])
    {
        int u = data[j];
        if (u != pv)
        {
            vertex[vp++] = u;
        }
    }
    int to = vp;
    LL all[21];
    for (int i = 0; i <= K; i++)
        all[i] = 0;

    for (int i = from; i < to; i++)
    {
        int u = vertex[i];
        for (int k = 0; k <= K; k++)
        {
            LL res = 0;
            for (int j = 0; j <= k; j++)
            {
                LL add = (C[k][j] * (1LL << (k - j))) % MOD;
                add = (add * dp[u][j]) % MOD;
                res = (res + add) % MOD;
            }
            tmp2[i][k] = res;
            all[k] = (all[k] + res) % MOD;
        }
    }

    for (int i = from; i < to; i++)
    {
        int u = vertex[i];
        for (int k = 0; k <= K; k++)
        {
            LL diff = (all[k] - tmp2[i][k] + MOD) % MOD;
            diff = (diff + tmp[v][k]) % MOD;
            buf[u][k] = (diff + (1LL << k)) % MOD;
        }

        dfs2(u, v);
    }
}

void solve()
{
    for (int n = 0; n <= 22; ++n)
    {
        C[n][0] = C[n][n] = 1;
        for (int k = 1; k < n; ++k)
        {
            C[n][k] = (C[n - 1][k - 1] + C[n - 1][k]) % MOD;
        }
    }

    int T;
    scanf("%d", &T);
    rep(tc, T)
    {
        scanf("%d%d", &N, &K);
        memset(head, -1, sizeof(head[0]) * N);
        sp = 0;

        rep(i, N - 1)
        {
            int a, b;
            scanf("%d%d", &a, &b);
            addEdge(a, b);
            addEdge(b, a);
        }

        dfs1(0, -1);
        for (int i = 0; i <= K; i++)
            buf[0][i] = 0;
        vp = 0;
        dfs2(0, -1);

        rep(i, N)
        {
            printf("%d\n", ans[i]);
        }
        puts("");
    }
}
