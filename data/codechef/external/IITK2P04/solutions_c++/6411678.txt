#include<stdio.h>
#include<iostream>
#include<string.h>
#include<sstream>
#include<math.h>
#include<vector>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<stdlib.h>
#include<algorithm>
#define pb push_back
#define sz 1000005
#define siz 1002
using namespace std;

pair<int,int>par[siz][siz];
int n,m,store[sz],calculate[siz][siz],color[sz],data[siz][siz],visit[siz][siz];

int X[]={-1,1,0,0};
int Y[]={0,0,-1,1};
void BFS2(int c,int x,int y);

//*******************************************************************************************************//

void BFS(int col,int x,int y)
{
    int i,p,q,fx,fy,r1,r2,sig,maxi = -1;
    queue<int>qx,qy;

    sig = 0;
    qx.push(x);
    qy.push(y);
    visit[x][y] = 1;

    while(!qx.empty())
    {
        p = qx.front();
        q = qy.front();
        qx.pop();
        qy.pop();

        if(visit[p][q] > maxi)
        maxi  = visit[p][q],fx = p,fy = q;

        for(i = 0;i < 4;++i)
        {
            r1 = p + X[i];
            r2 = q + Y[i];

            if(data[r1][r2] == col && visit[r1][r2] == 0 && (r1 >= 1 && r1 <= n) && (r2 >= 1 && r2 <= m))
            {
                qx.push(r1);
                qy.push(r2);
                visit[r1][r2] = visit[p][q] + 1;
                par[r1][r2] = make_pair(p,q);
            }
            else if(data[r1][r2] == col  && (par[p][q] != make_pair(r1,r2)) && (r1 >= 1 && r1 <= n) && (r2 >= 1 && r2 <= m) && visit[r1][r2] != 0)
            sig = 1;
        }
     }

    if(sig == 1)
    store[col] = color[col];

    if(sig == 1)
    return;

    BFS2(col,fx,fy);
}
//********************************************************************

void BFS2(int col, int fx, int fy)
{
    int i,p,q,r1,r2,maxi;
    queue<int>qx,qy;

    maxi = -1;
    qx.push(fx);
    qy.push(fy);
    calculate[fx][fy] = 1;

    while(!qx.empty())
    {
        p = qx.front();
        q = qy.front();
        qx.pop();
        qy.pop();

        if(calculate[p][q] > maxi)
        maxi = calculate[p][q];

        for(i = 0;i < 4;++i)
        {
            r1 = p + X[i];
            r2 = q + Y[i];

            if(data[r1][r2] == col && calculate[r1][r2] == 0 && (r1 >= 1 && r1 <= n) && (r2 >= 1 && r2 <= m))
            {
                qx.push(r1);
                qy.push(r2);
                calculate[r1][r2] = calculate[p][q] + 1;
            }
        }
     }

    if(store[col] < maxi)
    store[col] = maxi;
}

//********************************************************************

int main()
{
    int i,j,maxi;

    while(scanf("%d %d",&n,&m) == 2)
    {
       int  max_color  = maxi = -1;

        memset(store,0,sizeof(store));
        memset(color,0,sizeof(color));
        memset(visit,0,sizeof(visit));
        memset(calculate,0,sizeof(calculate));



        for(i = 1;i <= n;++i)
        for(j = 1;j <= m;++j)
        {
          scanf("%d",&data[i][j]);
          color[data[i][j]] += 1;

          if(data[i][j] > max_color)
          max_color = data[i][j];
        }

        for(i = 1;i <= n;++i)
        for(j = 1;j <= m;++j)
        {
            if(visit[i][j] == 0)
            BFS(data[i][j],i,j);
        }

        for(i = 1;i <= max_color;++i)
        {
            if(store[i] > maxi)
            maxi = store[i];
        }

      printf("%d\n",maxi);
    }

   return 0;
}
