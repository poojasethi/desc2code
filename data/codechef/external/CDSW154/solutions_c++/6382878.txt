#include<bits/stdc++.h>

using namespace std;

// Shortcuts for "common" data types in contests
typedef long long int ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef set<int> si;
typedef map<string, int> msi;
// To simplify repetitions/loops, Note: define your loop style and stick with it!
#define s(i) scanf("%d",&i)
#define sl(i) scanf("%ld",&i)
#define sll(i) scanf("%lld",&i)
#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define TRvi(c, it) \
for (vi::iterator it = (c).begin(); it != (c).end(); it++)
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
#define TRmsi(c, it) \
for (msi::iterator it = (c).begin(); it != (c).end(); it++)
#define INF 2000000000 // 2 billion

const int maxnodes = 5000;

int nodes = maxnodes, src, dest;
int dist[maxnodes], q[maxnodes], work[maxnodes];

struct Edge {
  int to, rev;
  int f, cap;
};

vector <Edge> g[maxnodes];

// Adds bidirectional edge
void addEdge(int s, int t, int cap ,int revcap){
  Edge a = {t, g[t].size(), 0, cap};
  Edge b = {s, g[s].size(), 0, revcap};
  g[s].push_back(a);
  g[t].push_back(b);
}

bool dinic_bfs() {
  fill(dist, dist + nodes, -1);
  dist[src] = 0;
  queue <int> qu;qu.push(src);
  while( !qu.empty() )
  {
      int u = qu.front();qu.pop();
      for(int j = 0;j < g[u].size() ;j++)
      {
          Edge &e = g[u][j];
          int v = e.to;
          if(dist[v] == -1 && e.f < e.cap)
          {
              dist[v] = dist[u] + 1;
              qu.push(v);
          }
      }
  }
  return dist[dest] >= 0;
}

int dinic_dfs(int u, int f) {
  if (u == dest)
    return f;
    dist[u] = 1;
  for (int i =0 ; i < (int) g[u].size(); i++) {
    Edge &e = g[u][i];
    if (e.cap <= e.f) continue;
    int v = e.to;
    if (dist[v] == -1) {
      int df = dinic_dfs(v, min(f, e.cap - e.f));
      if (df > 0) {
        e.f += df;
        g[v][e.rev].f -= df;
        return df;
      }
    }
  }
  return 0;
}

int maxFlow(int _src, int _dest) {
  src = _src;
  dest = _dest;
  int result = 0;
  while (1) {
    memset(dist,-1,sizeof(dist));
        int delta = dinic_dfs(src, INT_MAX);
        result += delta;
    if(delta == 0)
        break;
  }
  return result;
}

int main()
{
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    int n;s(n);
    REP(i,0,8)
    {
        int p;s(p);
        addEdge(n + i + 1 , n + 10 , p , 0);
    }
    vi a[109];
    REP(i,0,n - 1)
    {
        int q;s(q);
        REP(j,0,q - 1)
        {
            int p;s(p);
    //        addEdge(i + 1,n + p,1,0);
            a[i].push_back(p);
        }
        addEdge(0,n - i,1,0);
    }
    for( int j = n - 1 ; j >= 0 ; j-- )
    {
        TRvi(a[j],it)
        {
            //cout << *it + n << endl;
            addEdge(j + 1,*it + n,1,0);
        }
    }
    int mf = maxFlow(0,n + 10);
    if( mf == n )
    {
        REP(i,1,n)
        {
            REP(j,0,g[i].size() - 1)
            {
                if(g[i][j].f >= g[i][j].cap && g[i][j].cap > 0)
                {
                    printf("%d ",g[i][j].to - n);
                    break;
                }
            }
        }
    }
    else
        printf("It seems MSG");
    printf("\n");
}

