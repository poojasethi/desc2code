#include<bits/stdc++.h>

using namespace std;

inline void out(int number) ;
inline void inp( int &n );
inline void inps(char *str);

#define MAXN 505
#define min(a,b) ((a)<(b)?(a):(b))
#define abs(a)  ((a)>=0?(a):-(a))

struct node
{
    int first,second;
};

node host[MAXN],guest[MAXN];
int N,H,G,K,dist,C;
//pair<int,int> host[MAXN],guest[MAXN];
vector<vector<int> > adj(MAXN,vector<int>(0,0));
int graph[MAXN][MAXN],temp;
int visited[MAXN],prev[MAXN];
vector<int> ::iterator it;
queue<int> Q;

bool bfs(int s, int t)
{
    prev[s]=-1;
    queue<int> empty;
    swap(empty,Q);
    Q.push(s);
    memset(visited,0,sizeof(visited));
    visited[s]=1;
    while(!Q.empty())
    {
        temp=Q.front();
        Q.pop();
        for(it=adj[temp].begin();it!=adj[temp].end();it++)
        {
            if(visited[*it]==0&&graph[temp][*it]>0)
                {
                    prev[*it]=temp;
                    if(*it==t)return true;
                    Q.push(*it);
                    visited[*it]=1;
                }
        }
    }
    return false;
}


int maxFlow(int s,int t)
{
    int flow=0;
    while(bfs(s,t)) //there exists a path
    {
        temp=INT_MAX;
        int j=t;
        while(prev[j]!=-1)
        {
            temp=min(temp,graph[prev[j]][j]);
            j=prev[j];
        }
        j=t;
        while(prev[j]!=-1)
        {
            graph[prev[j]][j]-=temp;
            graph[j][prev[j]]+=temp;
            j=prev[j];
        }
        flow+=temp;
    }
    return flow;
}
int main()
{
    inp(N);
    for(int po=1;po<=N;po++)
    {
        for(int i=0;i<MAXN;i++)
            adj[i].clear();

        inp(H);inp(G);inp(K);inp(C);
        for(int i=0;i<H;i++)
        {
            inp(host[i].first);inp(host[i].second);
        }
        for(int i=0;i<G;i++)
        {
            inp(guest[i].first);inp(guest[i].second);
        }

        for(int i=0;i<G+H+2;i++)memset(graph[i],0,sizeof(graph[i]));
        for(int i=0;i<H;i++)
        {
            //super source
            adj[H+G].push_back(i);
            adj[i].push_back(H+G);
            graph[H+G][i]=1;
        }
        for(int j=0;j<G;j++)
        {
            //super sink
            adj[H+G+1].push_back(H+j);
            adj[H+j].push_back(H+G+1);
            graph[H+j][H+G+1]=1;
        }


        for(int i=0;i<H;i++)
        {
            for(int j=0;j<G;j++)
            {
                dist=abs(host[i].first-guest[j].first)+abs(host[i].second-guest[j].second)+abs(guest[j].first-K)+abs(guest[j].second-K);
                if(dist<=C)
                {
                    adj[i].push_back(H+j);
                    adj[H+j].push_back(i);
                    graph[i][H+j]=1;
                }
            }
        }

        printf("Case %d: %d\n",po,maxFlow(G+H,G+H+1));
    }

    return 0;
}


inline void inp( int &n )
{
n=0;
int ch=getchar();int sign=1;
while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();}

while(  ch >= '0' && ch <= '9' )
n = (n<<3)+(n<<1) + ch-'0', ch=getchar();
n=n*sign;

}


inline void out(int number)
{
	if (number)
	{
    char str[11];

		int i = 10;
		while (number > 0)
		{
			--i;
			str[i] = (number % 10) + '0';
			number /= 10;
		}
		str[10] = 0;

		fwrite(str + i, 1, 10 - i, stdout);
	}
	else
	{
		putchar('0');
	}
}


inline void inps(char *str)
{
    register char c = 0;
    register int i = 0;
    while (c < 33)
        c = getchar();
    while (c != '\n') {
        str[i] = c;
        c = getchar();
        i = i + 1;
    }
    str[i] = '\0';
}
