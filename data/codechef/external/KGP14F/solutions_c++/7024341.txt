#include<bits/stdc++.h>

using namespace std;

inline void out(int number) ;
inline void inp( int &n );
inline void inps(char *str);


int N,H,G,K,x,y,dist;
long long C;
pair<int,int> host[510],guest[510];
vector<vector<int> > adj(510,vector<int>(0,0));
int graph[510][510],rgraph[510][510],temp;
int visited[510],prev[510];
vector<int> ::iterator it;

bool bfs(int s, int t)
{
    prev[s]=-1;
    queue<int> Q;
    Q.push(s);
    memset(visited,0,sizeof(visited));
    visited[s]=1;
    while(!Q.empty())
    {
        temp=Q.front();
        Q.pop();
        for(it=adj[temp].begin();it!=adj[temp].end();it++)
        {
            if(visited[*it]==0&&rgraph[temp][*it]>0)
                {
                    prev[*it]=temp;Q.push(*it);
                    visited[*it]=1;
                }
        }
    }
    return visited[t]!=0;
}

int maxFlow(int s,int t)
{
    for(int i=0;i<G+H+2;i++)for(int j=0;j<G+H+2;j++)rgraph[i][j]=graph[i][j];
    int flow=0;
    while(bfs(s,t)) //there exists a path
    {
        temp=INT_MAX;
        int j=t;
        while(prev[j]!=-1)
        {
            temp=min(temp,rgraph[prev[j]][j]);
            j=prev[j];
        }
        j=t;
        while(prev[j]!=-1)
        {
            rgraph[prev[j]][j]-=temp;
            rgraph[j][prev[j]]+=temp;
            j=prev[j];
        }
        flow+=temp;
    }
    return flow;
}
int main()
{
    inp(N);
    for(int po=1;po<=N;po++)
    {
        for(int i=0;i<510;i++)
            adj[i].resize(0,0);

        inp(H);inp(G);inp(K);
        scanf("%lld",&C);
        for(int i=0;i<H;i++)
        {
            inp(x);inp(y);
            host[i].first=x;host[i].second=y;
        }
        for(int i=0;i<G;i++)
        {
            inp(x);inp(y);
            guest[i].first=x;guest[i].second=y;
        }

        for(int i=0;i<G+H+2;i++)
            for(int j=0;j<G+H+2;j++)graph[i][j]=0;
        for(int i=0;i<H;i++)
        {
            //super source
            adj[H+G].push_back(i);
            adj[i].push_back(H+G);
            graph[H+G][i]=1;
        }
        for(int j=0;j<G;j++)
        {
            //super sink
            adj[H+G+1].push_back(H+j);
            adj[H+j].push_back(H+G+1);
            graph[H+j][H+G+1]=1;
        }


        for(int i=0;i<H;i++)
        {
            for(int j=0;j<G;j++)
            {
                dist=abs(host[i].first-guest[j].first)+abs(host[i].second-guest[j].second)+abs(guest[j].first-K)+abs(guest[j].second-K);
                if(dist<=C)
                {
                    adj[i].push_back(H+j);
                    adj[H+j].push_back(i);
                    graph[i][H+j]=1;
                }
            }
        }

        printf("Case %d: %d\n",po,maxFlow(G+H,G+H+1));
    }

    return 0;
}


inline void inp( int &n )
{
n=0;
int ch=getchar();int sign=1;
while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();}

while(  ch >= '0' && ch <= '9' )
n = (n<<3)+(n<<1) + ch-'0', ch=getchar();
n=n*sign;

}


inline void out(int number)
{
	if (number)
	{
    char str[11];

		int i = 10;
		while (number > 0)
		{
			--i;
			str[i] = (number % 10) + '0';
			number /= 10;
		}
		str[10] = 0;

		fwrite(str + i, 1, 10 - i, stdout);
	}
	else
	{
		putchar('0');
	}
}


inline void inps(char *str)
{
    register char c = 0;
    register int i = 0;
    while (c < 33)
        c = getchar();
    while (c != '\n') {
        str[i] = c;
        c = getchar();
        i = i + 1;
    }
    str[i] = '\0';
}
