#include<bits/stdc++.h>
using namespace std;
vector<int> tree[100010];
int col[100010];
vector<int> child[100010];
vector<int> norder;
long long ans;

set<int> subtree[100010];
int idx[100010];

inline int inp()
{
    register int r=0,c;
    for(c=getchar_unlocked();c<=32;c=getchar_unlocked())
    {
         if(c=='-')
           return -inp();
    }

    for(;c>32; r = (r<<1)+(r<<3)+c-'0', c = getchar_unlocked());

    return r;
}


void dfs(int v,int p)
{
   for(int i=0;i<tree[v].size();i++)
   {
        if(tree[v][i]!=p)
        {
           dfs(tree[v][i],v);
           child[v].push_back(tree[v][i]);
        }
   }
}

void order(int v)
{
    for(int i=0;i<child[v].size();i++)
       order(child[v][i]);
    norder.push_back(v);
}


void countElem(int v)   // The most important function
{
   int mxchild=0;
   int big=v,i;
   int temp;

   for(i=0;i<child[v].size();i++)          // finding the child with biggest subtree size
   {
      temp = child[v][i];
      if(subtree[idx[temp]].size()>mxchild)
      {
          mxchild=subtree[idx[temp]].size();
          big = idx[temp];
      }
   }

   for(i=0;i<child[v].size();i++)
   {
       temp = child[v][i];

       if(idx[temp]!=big)   // if its not the child with biggest subtree size, iterate
       {
           for(set<int>::const_iterator it = subtree[idx[temp]].begin();it!=subtree[idx[temp]].end();it++)  //read-only iterator
                subtree[big].insert(*it);

           subtree[idx[temp]].clear();
       }
    }

       subtree[big].insert(col[v]);

       ans+=subtree[big].size();
       idx[v] = big;
}




int main()
{
    int n,k,i,x;
    n=inp();
    k=inp();

    for(i=1;i<n;i++)
    {
        x=inp();
        x--;   //Zero based
        tree[i].push_back(x);
        tree[x].push_back(i);
    }

    for(i=0;i<n;i++)
      col[i]=inp();

    dfs(0,-1);
    order(0);   //saved DFS order

    for(i=0;i<norder.size();i++)
    {
       countElem(norder[i]);
    }

    printf("%lld",ans);




}
