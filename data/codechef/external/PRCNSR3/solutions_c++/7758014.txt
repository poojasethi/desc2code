#include <bits/stdc++.h>

typedef long long int li;

#define min(a,b) a<=b?a:b
#define max(a,b) a>=b?a:b
#define Fi(i, st, ft) for(i = st;i <= ft; ++i)
#define Fd(i, st, ft) for(i = st;i >= ft; --i)
#define pb(a, b) a.push_back(b)
#define mod 1000000007
#define mod2 100000
#define mp make_pair
#define MAXN 1500000
#define MX 1450000
#define inf 1000000000000000000ll
const int maxBufSize = (10000000);

using namespace std;

li n , q , w , m , d , timer;
li bit[100005] , in[100005] , out[100005] , vis[100005];
vector<li> v[100005];

void update(li ind , li val)
{
	while(ind <= 100000) {
		bit[ind] = (bit[ind]+val)%mod;
		ind = ind+(ind&(-ind));
	}
	return;
}

li query(li ind)
{
	li ret = 0;
	while(ind > 0) {
		ret = (ret+bit[ind])%mod;
		ind = ind-(ind&(-ind));
	}
	return ret;
}

li mat1[2][2] , mat2[2][1] , mat3[2][2] , mat4[2][1];

void sq_mul_mat(li a[2][2] , li b[2][2] , li d)
{
	li i , j , k;
	li temp[10][10];
	Fi(i , 0 , d-1) {
		Fi(j , 0 , d-1) {
			temp[i][j] = 0;
		}
	}
	Fi(i , 0 , d-1) {
		Fi(j , 0 , d-1) {
			Fi(k , 0 , d-1) {
				temp[i][k] = (temp[i][k]+a[i][j]*b[j][k])%mod2;
			}
		}
	}
	Fi(i , 0 , d-1) {
		Fi(j , 0 , d-1) {
			a[i][j] = temp[i][j];
		}
	}
	return;
}

void mul_mat(li a[2][2] , li b[2][1] , li c[2][1])
{
	li i , j , k;
	Fi(i , 0 , 1) {
		Fi(j , 0 , 1) {
			Fi(k , 0 , 0) {
				c[i][k] = (c[i][k] + a[i][j]*b[j][k])%mod2;
			}
		}
	}
	return;
}

void power_matrix(li a[2][2] , li b , li temp[2][2])
{
	li i , j , k;
	if(b == 0) {
		Fi(i , 0 , d-1) {
			Fi(j , 0 , d-1) {
				temp[i][j] = 0;
			}
			temp[i][i] = 1;
		}
		return;
	}
	power_matrix(a , b/2 , temp);
	sq_mul_mat(temp , temp , d);
	if(b&1) {
		sq_mul_mat(temp , a , d);
	}
	return;
}

li getK(li a)
{
	if(a == 0) {
		return 0;
	}
	if(a == 1) {
		return 1;
	}
	if(a == 2) {
		return 2;
	}
	d = 2;
	mat1[0][0] = mat1[0][1] = mat1[1][0] = 1;
	mat3[0][0] = mat3[0][1] = mat3[1][0] = mat3[1][1] = mat1[1][1] = 0;
	mat2[0][0] = 2;
	mat2[1][0] = 1;
	mat4[0][0] = mat4[0][1] = 0;
	power_matrix(mat1 , a-2 , mat3);
	mul_mat(mat3 , mat2 , mat4);
	return mat4[0][0]%mod2;
}

void dfs(li ind)
{
	++timer;
	in[ind] = timer;
	vis[ind] = 1;
	li i , len;
	len = v[ind].size();
	Fi(i , 0 , len-1) {
		if(!vis[v[ind][i]]) {
			dfs(v[ind][i]);
		}
	}
	out[ind] = timer;
	return;
}

int main()
{
	li i , j , a , b , c , ans;
	scanf("%lld %lld" , &n , &q);
	Fi(i , 1 , n-1) {
		scanf("%lld %lld" , &a , &b);
		pb(v[a] , b);
		pb(v[b] , a);
	}
	timer = 0;
	dfs(1);
	Fi(i , 1 , n) {
		update(i , 1);
	}
	Fi(i , 1 , q) {
		scanf("%lld" , &a);
		if(a == 0) {
			scanf("%lld %lld" , &w , &m);
			if(!(m&1)) {
				
				m = (m*getK(m/2))%mod;
				update(in[w] , m);
			}
		} else {
			scanf("%lld" , &w);
			ans = query(out[w])-query(in[w]-1);
			ans = (ans+mod)%mod;
			printf("%lld\n" , ans);
		}
	}
	return 0;
}