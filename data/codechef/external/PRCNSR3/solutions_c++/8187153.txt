#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define pb push_back
#define pob pop_back
#define pf push_front
#define pof pop_front
#define mp make_pair
#define all(a) a.begin(),a.end()
#define bitcnt(x) __builtin_popcountll(x)
#define MOD 1000000007
#define MOD2 100000
#define MAXN 100002
#define BASE 31
typedef unsigned long long int uint64;
typedef long long int int64;
 
 
vector<int>v[10005];
int in[10005],out[10005];
int timer=0;
int64 BIT[10005];

void upd(int x,int64 val){
	for(int i=x;i<=10002;i+=i&(-i)){
		BIT[i]+=val;
		if(BIT[i]>=MOD)
		BIT[i]%=MOD;
	}
}

int64 query(int x){
	int64 ret=0;
	while(x){
		ret+=BIT[x];
		x-=x&(-x);
		if(ret>=MOD)
		ret%=MOD;
	}
	return ret;
}

void dfs(int nod,int par){
	in[nod]=++timer;
	for(int i=0;i<v[nod].size();i++){
		int to=v[nod][i];
		if(to==par)
		continue;
		dfs(to,nod);
	}
	out[nod]=timer;
}
int64 f[2][2];
int64 m[2][2]={{1,1},{1,0}};

void mul(int64 a[2][2],int64 b[2][2]){
	int64 p=a[0][0]*b[0][0]+a[0][1]*b[1][0];
	int64 q=a[0][0]*b[0][1]+a[0][1]*b[1][1];
	int64 r=a[1][0]*b[0][0]+a[1][1]*b[1][0];
	int64 s=a[1][0]*b[0][1]+a[1][1]*b[1][1];
	p%=MOD2;
	q%=MOD2;
	r%=MOD2;
	s%=MOD2;
	a[0][0]=p;
	a[0][1]=q;
	a[1][0]=r;
	a[1][1]=s;
}

void fibo(int n){
	if((n==0)||(n==1))
	return;
	fibo(n/2);
	mul(f,f);
	if(n&1)
	mul(f,m);
}
int64 fib(int n){
	f[0][0]=1;
	f[0][1]=1;
	f[1][0]=1;
	f[1][1]=0;
	if(!n)
	return n;
	fibo(n);
	return f[0][0];
}

int main(){
	int n,q,i,x,y;	

	cin>>n>>q;
	
	for(i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		v[x].pb(y);
		v[y].pb(x);
	}
	dfs(1,-1);
	
	for(i=1;i<=n;i++)
	upd(in[i],1);
	int typ,v,m;
	
	while(q--){
		scanf("%d",&typ);
		if(!typ){
			scanf("%d%d",&v,&m);
			if(m&1)
			continue;
			int64 val=fib(m/2);
			val=val*(int64)m;
			val%=MOD;
			upd(in[v],val);
		}
		else{
			scanf("%d",&v);
			int64 ret=query(out[v]);
			ret-=query(in[v]-1);
			if(ret<0)
			ret+=MOD;
			printf("%lld\n",ret);
		}
	}
	return 0;
}