#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <math.h>
#include <string>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <map>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <iomanip>
using namespace std;
 
 
 
 
#define LL long long
#define rep(i,a,n) for(LL i = a;i<n;i++)
#define S(a) scanf("%d",&a)
#define P(a) printf("%d\n",a)
#define PS(s) printf(s)
#define SLL(a) scanf("%lld",&a)
#define PLL(a) printf("%lld\n",a)
 
 
#define II LL
 
 
#define MOD 1000000007      
#define mp make_pair
bool visited[2][1111];
 
int main()
{
	LL test;
	SLL(test);
	pair<int,pair<int,int> >  tiii;
	pair<int,int> tii;
	while(test--)
	{
		int n,a,b,c,d,k,q;
		 scanf("%d%d%d%d%d%d%d",&n,&a,&b,&c,&d,&k,&q);
		// n = 1+rand()%1000;
		// a = 1+rand()%1000;
		// b = 1+rand()%1000;
		// c = 1+rand()%1000;
		// d = 1+rand()%1000;
		// k = 1+rand()%1000;
		// q = 1+rand()%1000;
		// printf("%d %d %d %d %d %d %d \n",n,a,b,c,d,k,q );
		q %= k;
		queue<pair<int,pair<int,int> > >  bfs = queue<pair<int,pair<int,int> > >() ;
		memset(visited,0,sizeof(visited));
		if( (n%k) == q ) { printf("0\n"); continue;}
		bfs.push(mp(0,mp(0,n%d))); visited[0][n%d] = true;
		bfs.push(mp(0,mp(1,n%k))); visited[1][n%k] = true;
		bool found = false;
		while(bfs.size())
		{
			tiii = bfs.front(); bfs.pop();
			int lev = tiii.first;
			tii = tiii.second;
 
 
			if(!tii.first)
			{
				int A = ((tii.second)+ (a) )%d ,
				B = ((tii.second)-(b%d)+d)%d ,
				C = ((tii.second)*c )%d,
				D = ((tii.second))%k;
				if(!visited[0][A] && (visited[0][A] = true) ) bfs.push(mp(lev+1,mp(0,A)));
				if(!visited[0][B] && (visited[0][B] = true)) bfs.push(mp(lev+1,mp(0,B)));
				if(!visited[0][C] && (visited[0][C] = true)) bfs.push(mp(lev+1,mp(0,C)));
				if(!visited[1][D] && (visited[1][D] = true)) {bfs.push(mp(lev+1,mp(1,D)));
					if(D== q)
					{
						//cerr<<"tiisec="<<tii.second<<"tiisec/k = "<<(tii.second)%k<<"q/k"<<q%k<<endl;
						found = true;
						printf("%d\n",lev+1);
						break;
					}
				}
			}
			else
			{
				// if(tii.second== q)
				// {
				// 	//cerr<<"tiisec="<<tii.second<<"tiisec/k = "<<(tii.second)%k<<"q/k"<<q%k<<endl;
				// 	found = true;
				// 	printf("%d\n",lev);
				// 	break;
				// }
				int A = ((tii.second)+ a )%k;
				int B = ((tii.second)-(b%k)+k)%k;
				int C = ((tii.second)*c )%k;
				if(!visited[1][A] && (visited[1][A] = true)) {bfs.push(mp(lev+1,mp(1,A)));
					if(A== q)
					{
						//cerr<<"tiisec="<<tii.second<<"tiisec/k = "<<(tii.second)%k<<"q/k"<<q%k<<endl;
						found = true;
						printf("%d\n",lev+1);
						break;
					}
				}
				if(!visited[1][B] && (visited[1][B] = true )) {bfs.push(mp(lev+1,mp(1,B)));
					if(B== q)
					{
						//cerr<<"tiisec="<<tii.second<<"tiisec/k = "<<(tii.second)%k<<"q/k"<<q%k<<endl;
						found = true;
						printf("%d\n",lev+1);
						break;
					}
				}
				if(!visited[1][C] && (visited[1][C] = true)) {bfs.push(mp(lev+1,mp(1,C)));
					if(C== q)
					{
						//cerr<<"tiisec="<<tii.second<<"tiisec/k = "<<(tii.second)%k<<"q/k"<<q%k<<endl;
						found = true;
						printf("%d\n",lev+1);
						break;
					}
				}
			}
		}
		if(!found){
			printf("-1\n");
		}
	}
	
	
    
	return 0;
}
 