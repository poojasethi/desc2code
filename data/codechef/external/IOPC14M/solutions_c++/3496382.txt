#include <iostream>
#include <cstdlib>
#include <cassert>
#include <utility>
#include <algorithm>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cmath>
#include <vector>
#include <stack>
#include <set>
#include <map>
#include <deque>
#include <string>

#define all(i,n) for(i = 0; i < (n); i++)
#define SET(p) memset(p,-1,sizeof(p))
#define CLR(p) memset(p,0,sizeof(p))
#define maX(a,b)    ((a)>(b)?(a):(b))
#define miN(a,b)        ((a)<(b)?(a):(b))
#define cin(n)    scanf("%d",&n)

#define p(n)    printf("%d\n",n)
#define cinl(n)   scanf("%lld",&n)
#define pl(n)   printf("%lld\n",n)
#define Sf(n)   scanf("%lf",&n)
#define Ss(n)   scanf("%s",n)
#define ill  long long
#define ULL unsigned long long
#define pb push_back
#define pii pair<int,int>
#define edge pair<int,pii>
#define ll long long
#define co(e) e.first
#define n1(e) e.second.first
#define n2(e) e.second.second
#define ALL(A) A.begin(), A.end()
#define oo        (1<<30)
#define PI          3.141592653589793
#define ERR         1e-6
#define pi          2*acos(0)
#define PB          push_back
using namespace std;
#define max2 1000000
#define i64 unsigned long long

#define LL long long

#define mp make_pair
LL mulmod (LL a, LL b, LL mod) {
    LL res = (a * ((long double) b / (long double) mod));
    // put the number in long double, and then reduce the value to LL, forget
   // overflow.
    res = a * b - res * mod;
    if (res >= mod) res -= mod;
    if (res < 0) res += mod;
    return res;
}

ill powe(ill a,ill b,ill mod)
{
    ill ans=1;
    while(b)
    {
        if(b&1)
            ans=mulmod(a,ans,mod);
        a=mulmod(a,a,mod);
        b=b/2;
    }
    return ans;
}
int main()
{
    int m,last,n,i,j,k,t;
    cin(t);
    //string s;

    while(t--)
    {
        int n,a,b,c,d,qq,k;
        cin(n);cin(a);cin(b);cin(c);cin(d); cin(k);cin(qq);


        queue<pair<int,pair<int,int> > >q;


        int vis[1008][3];
        int req=qq%k;
        int ans=-1;
        memset(vis,0,sizeof(vis));

        while(q.size())
            q.pop();

        q.push(mp(n,mp(1,1)));
        q.push(mp(n%d,mp(2,2)));
        vis[n%k][0]=1;
        vis[n%d][1]=1;
        while(q.size())
        {
            pair<int,pair<int,int> > p=q.front();
            q.pop();

            int va=p.first;
            int mv=p.second.first;
            int flag=p.second.second;

            int val;
            if(va%k==req)
            {
                ans=mv;
                break;
            }
            if(flag==2)
            {
                val=(va+a)%d;
                if(!vis[val][1])
                {
                    q.push(mp(val,mp(mv+1,flag)));
                    vis[val][1]=1;
                    vis[val%k][0]=1;
                }

                val=((va-b)%d+d)%d;
                if(!vis[val][1])
                {
                    q.push(mp(val,mp(mv+1,flag)));
                    vis[val][1]=1;
                    vis[val%k][0]=1;
                }

                val=(va*c)%d;
                if(!vis[val][1])
                {
                    q.push(mp(val,mp(mv+1,flag)));
                    vis[val][1]=1;
                    vis[val%k][0]=1;
                }
            }
            flag=1;
            val=(va+a)%k;
            if(!vis[val][0])
            {
                q.push(mp(val,mp(mv+1,flag)));
                vis[val][0]=1;
            }

            val=((va-b)%k+k)%k;
            if(!vis[val][0])
            {
                q.push(mp(val,mp(mv+1,flag)));
                vis[val][0]=1;
            }

            val=(va*c)%k;
            if(!vis[val][0])
            {
                q.push(mp(val,mp(mv+1,flag)));
                vis[val][0]=1;
            }
        }
        if(ans>=1)
            cout<<ans-1<<"\n";
        else
            cout<<-1<<"\n";

    }
return 0;
}
