#include <bits/stdc++.h>

using namespace std;

const int N = 1005;

int n, a, b, c, d, k, q;
int dis[2][N];

int MOD (int num, int p)
{
	while (num >= p)
		num -= p;
	while (num < 0)
		num += p;
	return num;
}

int Transform (int op, int num, int m)
{
	if (op == 0)
		return num + a;
	else if (op == 1)
		return num - b;
	else if (op == 2)
		return num * c;
	return MOD (num, m);
}

int bfs ()
{
	memset (dis, -1, sizeof (dis));
	q = MOD (q, k);
	queue < pair < int, int > > Q;
	dis[0][MOD (n, d)] = dis[1][MOD (n, k)] = 0;
	Q.push (make_pair (0, MOD (n, d)));
	Q.push (make_pair (1, MOD (n, k)));
	while (!Q.empty ())
	{
		pair < int, int > temp = Q.front ();
		Q.pop ();
		int tag = temp.first, val = temp.second;
		if (tag && val == q)
			return dis[tag][val];
		for (int i = 0; i < 4; i++)
		{
			int next, newtag;
			if (tag)
			{
				next = Transform (i, val, k);
				next = MOD (next, k);
				newtag = tag;
			}
			else
			{
				next = Transform (i, val, k);
				if (i != 3)
					next = MOD (next, d);
				newtag = tag | (i == 3);
			}
			if (dis[newtag][next] == -1)
			{
				dis[newtag][next] = dis[tag][val] + 1;
				Q.push (make_pair (newtag, next));
			}
		}
	}
	return -1;
}

int main ()
{
	int T;
	cin >> T;
	while (T--)
	{
		cin >> n >> a >> b >> c >> d >> k >> q;
		cout << bfs () << endl;
	}
	return 0;
}
