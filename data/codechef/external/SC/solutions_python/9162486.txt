/* Author: Karlheinz Jung */
/* Compiler: Borland Turbo C 2.01 */
/* Computer: Rabbit 286 */
/* Problem: Spiral Chess (SC) */
 
#include <stdio.h>
 
#ifndef ONLINE_JUDGE
	#define siz 10
#else
	#define siz 110
#endif
#define MI(a,b) a<b?a:b
 
int N, Q;
int grid[siz][siz], qBlack[siz][siz], qWhite[siz][siz];
int dir[][2]= {{0,1},{1,0},{0,-1},{-1,0}};
 
int bQuery(int r1, int c1, int r2, int c2)
{
return qBlack[r1][c1]-qBlack[r1][c2+1]-qBlack[r2+1][c1]+qBlack[r2+1][c2+1];
}
 
int wQuery(int r1, int c1, int r2, int c2)
{
return qWhite[r1][c1]-qWhite[r1][c2+1]-qWhite[r2+1][c1]+qWhite[r2+1][c2+1];
}
 
int main()
{
int T, total, caseID=1, i, j, k, curDir, ii, jj, blackSum, whiteSum, r1, c1, r2, c2, sol1, sol2;
 
for(scanf("%d",&T); caseID<=T; caseID++)
	{
	scanf("%d", &N);
	total=N*N;
	i=j=curDir=0;
	memset(grid, -1, sizeof grid);
	for(k=0; k<total; k++)
		{
		scanf("%d",&grid[i][j]);
		ii=i+dir[curDir][0];
		jj=j+dir[curDir][1];
		if(ii<0||ii>=N||jj<0||jj>=N||grid[ii][jj]!=-1) curDir=(curDir+1)%4;
		i+=dir[curDir][0];
		j+=dir[curDir][1];
		}
	memset(qBlack,0,sizeof(qBlack));
	memset(qWhite,0,sizeof(qWhite));
	for(i=N-1; i>=0; i--)
		{
		blackSum=whiteSum=0;
		for(j=N-1; j>=0; j--)
			{
			if((i+j)%2)
				blackSum+=grid[i][j];
			else
				whiteSum+=grid[i][j];
			qBlack[i][j]=i==N-1?blackSum:qBlack[i+1][j]+blackSum;
			qWhite[i][j]=i==N-1?whiteSum:qWhite[i+1][j]+whiteSum;
			}
		}
	scanf("%d",&Q);
	printf("Case #%d:\n", caseID);
	for(k=0; k<Q; k++)
		{
		scanf("%d %d %d %d",&r1,&c1,&r2,&c2);
		sol1=wQuery(r1,c1,r2,c2);
		sol2=bQuery(r1,c1,r2,c2);
		printf("%d\n",MI(sol1,sol2));
		}
	printf("\n");
	}
return 0;
}
 