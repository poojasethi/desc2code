#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <map>
#include <cassert>

using namespace std;

int bkt_size;
int n;
int tree[223][200005];
int A[100005];

//Code for FAST INPUT :)
template <typename T>
inline void fi(T *a)
{
    register char c=0;
    while (c<33) c=getchar_unlocked();
    *a=0;
    int tmp = 0;
    while (c>33)
    {
        if ( c == 45 ) tmp = 1;
        else *a=*a*10+c-'0';
        c=getchar_unlocked();
    }
    if ( tmp == 1 ) *a = 0-(*a);
}

void update(int idx1, int idx2, int val)
{
    while ( idx2 <= n ) {
        tree[idx1][idx2] += val;
        idx2 += (idx2 & (-idx2));
    }
    return;
}

int query(int idx1, int idx2)
{
    int ans = 0;
    while ( idx2 > 0 ) {
        ans += tree[idx1][idx2];
        idx2 -= (idx2 & (-idx2));
    }
    return ans;
}

struct node {
    int type;
    int a;
    int b;
    int val;
    node() {  }
    node(int type, int a, int b, int val)
    {
         this->type = type;
         this->a = a;
         this->b = b;
         this->val = val;
    }
}Q[100005];

int main()
{
    map <int, int> mp;
    map <int, int> :: iterator it;
    int q, cnt = 1, type, x, y, val, ans, idx;

    fi(&n), fi(&q);
    assert(n >= 1 && n <= 100000);
    assert(q >= 1 && q <= 100000);
    bkt_size = 220;

    for ( int i = 1; i <= n; i++ ) fi(&A[i]), mp[A[i]] = 1, assert(A[i] >= 1 && A[i] <= 1000000000);

    for ( int i = 1; i <= q; i++ ) {
        fi(&type);
        assert(type >= 1 && type <= 2);
        if ( type == 1  ) {
            fi(&x), fi(&val);
            assert(x >= 1 && x <= n);
            assert(val >= 1 && val <= 1000000000);
            mp[val] = 1;
            Q[i] = node(1,x,x,val);
        }
        else {
            fi(&x), fi(&y), fi(&val);
            assert(x <= y);
            assert(x <= n && x >= 1 && y >= 1 && y <= n);
            mp[val] = 1;
            Q[i] = node(2,x,y,val);
        }
    }

    for ( it = mp.begin(); it != mp.end(); it++ ) it->second = cnt++;

    for ( int i = 1; i <= n; i++  ) A[i] = mp[A[i]];
    for ( int i = 1; i <= q; i++ ) Q[i].val = mp[Q[i].val];

    for ( int i = 1; i <= n; i++ ) update(i/bkt_size, A[i], 1);

    for ( int i = 1; i <= q; i++ ) {
        if ( Q[i].type == 1  ) {
            update(Q[i].a/bkt_size, A[Q[i].a], -1);
            A[Q[i].a] = Q[i].val;
            update(Q[i].a/bkt_size, A[Q[i].a], 1);
        }
        else {
            ans = 0;
            idx = Q[i].a;
            while ( idx%bkt_size != 0 && idx <= Q[i].b  ) {
                ans += (A[idx] <= Q[i].val);
                idx++;
            }
            while ( idx+bkt_size-1 <= Q[i].b ) {
                ans += query(idx/bkt_size, Q[i].val);
                idx += bkt_size;
            }
            while ( idx <= Q[i].b ) {
                ans += (A[idx] <= Q[i].val);
                idx++;
            }
            printf("%d\n", ans);
        }
    }
    return 0;
}
