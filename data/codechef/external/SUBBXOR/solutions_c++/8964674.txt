#include <cstdio>
#include <iostream>
using namespace std;

struct Node
{
	int lCount,rCount;
	Node *lChild, *rChild;
	Node()
	{
		lCount=rCount=0;
		lChild=rChild=NULL;
	}
};

void addBit(Node* root, int num)
{
	
	for(int i=17;i>=0;i--)
	{
		int bit = (num>>i) & 1;
		if(bit == 1)
		{
			root->rCount++;
			if(root->rChild == NULL)
				root->rChild = new Node();
			root = root->rChild;
		}
		else
		{
			root->lCount++;
			if(root->lChild == NULL)
				root->lChild = new Node();
			root = root->lChild;
		}
	}
	//addBit(root, num, level-1);
}

long long getNumOfSubsets(Node* root, long long cumulative_xor, int k)
{
	if(root == NULL)
		return 0;
	long long result = 0;
	for(int i=17;i>=0;i--)
	{
		int bit1 = (k>>i) & 1;
		int bit2 = (cumulative_xor>>i) & 1;
		
		if(bit1 == 1)
		{
			if(bit2 == 1)
			{
				//bit2 is the ith bit of new cumulative_xor, If I XOR it with all the existing cumulatives with ith position of bit set as 1, then I will get 0 at this position,
				//Thus making the new cumulative XOR to be less than k and hence we count all of it and move to the left(ith bit set 0) 
				result += root->rCount;
				if(root->lChild == NULL)
					return result;
				root = root->lChild;
			}
			else
			{
				result += root->lCount;
				if(root->rChild == NULL)
					return result;
				root = root->rChild;
			}
		}
		else
		{
			if(bit2 == 1)
			{
				//result += root->rCount;
				if(root->rChild == NULL)
					return result;
				root = root->rChild;
			}
			else
			{
				//result += root->lCount;
				if(root->lChild == NULL)
					return result;
				root = root->lChild;
			}
		}
	}
	return result;	
}

int main()
{
	int t;
	scanf("%d",&t);
	
	while(t--)
	{
		int n, k;
		scanf("%d%d",&n,&k);
		
		long long cumulative_xor = 0;
		int num;
		Node* root = new Node();
		long long ans=0;
		//int level = 17;
		addBit(root, cumulative_xor);
		for(int i=0;i<n;i++)
		{
			scanf("%d",&num);
			cumulative_xor = num^cumulative_xor;
			ans += getNumOfSubsets(root, cumulative_xor, k);
			addBit(root, cumulative_xor);
		}
		cout<<ans<<endl;
	}
}
