//akartik80

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>

#define null NULL
#define get getchar_unlocked
#define put putchar//_unlocked
#define ll long long int
#define pb push_back
#define mp make_pair
#define pd(x) printf("%d", x)
#define pdn(x) printf("%d\n", x)
#define plld(x) printf("%lld", x)
#define plldn(x) printf("%lld\n", x)
#define sd(x) scanf("%d", &x)
#define slld(x) scanf("%lld", &x)
#define ss(x) scanf("%s", x)
#define sc(x) scanf("%c", &x)
#define pc(x) printf("%c", x)
#define ps(x) printf("%s", x)
#define psn(x) printf("%s\n", x)
#define pf(x) printf("%f", x)
#define pfn(x) printf("%f\n", x)
#define plf(x) printf("%lf", x)
#define plfn(x) printf("%lf\n", x)
#define sf(x) scanf("%f", &x)
#define slf(x) scanf("%lf", &x)
#define mod 1000000007

using namespace std;

inline int scan()
{
	int n = 0, sign = 1, ch = get();

	while (ch < 48 || ch > 57) {
		if (ch == '-') {
			sign = -1;
		}

		ch = get();
	}

	while (ch >= 48 && ch <= 57) {
		n = (n << 3) + (n << 1) + ch - 48;
		ch = get();
	}

	return n * sign;
}

struct node {
    int left, right;
    node *child[2];
};

node *insert(node *p, int val, int m)
{
    if (m == -1) {
        return p;
    }

    if (p == null) {
        p = (node *) malloc(sizeof(node));
        p -> child[0] = p -> child[1] = null;
        p -> left = p -> right = 0;
    }

    if ((val >> m) & 1) {
        (p -> right)++;
        p -> child[1] = insert(p -> child[1], val, m - 1);
    } else {
        (p -> left)++;
        p -> child[0] = insert(p -> child[0], val, m - 1);
    }

    return p;
}

int query(node *p, int q, int k, int m)
{
    bool bitk, bitq;
    int res = 0;

    if (p == null) {
        return 0;
    }

    while (m >= 0) {
        bitk = (k >> m) & 1;
        bitq = (q >> m) & 1;
        //cout << "m " << m << " bitk " << bitk << " bitq " << bitq << endl;
        m--;

        if (bitk == 0 && bitq == 0) {
            if (p -> left) {
                p = p -> child[0];
            } else {
                return res;
            }
        }

        if (bitk == 0 && bitq == 1) {
            if (p -> right) {
                p = p -> child[1];
            } else {
                return res;
            }
        }

        if (bitk == 1 && bitq == 0) {
            res += p -> left;

            if (p -> right) {
                p = p -> child[1];
            } else {
                return res;
            }
        }

        if (bitk == 1 && bitq == 1) {
            res += p -> right;

            if (p -> left) {
                p = p -> child[0];
            } else {
                return res;
            }
        }
    }

    return res;
}

int main()
{
    //freopen("in.txt", "r+", stdin);
	int m, t, n, k, q, i, num, mx;
	ll ans;

    t = scan();

    while(t--) {
        n = scan();
        k = scan();

        q = ans = mx = 0;

        node *p = null;
        m = 20;

        /*for (i = 0; i < n; i++) {
            q = scan();
            //2ans += (a[i] < k);
            mx = max(mx, a[i]);
        }

        m = ceil(log2(mx + 1)) + 1;
        //m = 20;
        //cout << "m " << m << endl;*/

        p = insert(p, 0, m);

        for (i = 0; i < n; i++) {
            num = scan();
            q ^= num;
            //cout << "querying for " << q << endl;
            //cout << "ans " << query(p, q, k, m) << endl;
            ans += (ll) query(p, q, k, m);
            p = insert(p, q, m);
        }

        plldn(ans);
    }
}
