//{
#include<iostream>
#include<cmath>
#include<algorithm>
#include<climits>
#include<vector>
#include<queue>
#include<stack>
#include<bitset>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
using namespace std;
#define MOD 1000000007LL
#define LL long long
#define ULL unsigned long long
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) ((x)*(x))
#define CUBE(x) ((x)*(x)*(x))
#define si(n) scanf("%d",&n)
#define si2(n,m) scanf("%d %d",&n,&m)
#define sll(n) scanf("%lld",&n)
#define slu(n) scanf("%llu",&n)
#define ss(n) scanf("%s",n)
#define pnl printf("\n")
#define FORD(i,a,b,d) for(typeof(b) i=(a);i<(b);i+=(d))
#define FOR(i,a,b) for(typeof(b) i=(a);i<(b);i++)
#define REP(i,n) for(typeof(n) i=0;i<(n);i++)
#define FORR(i,n,e) for(typeof(n) i=(n);i>=(e);i--)
#define FORRD(i,n,e,d) for(typeof(n) i=(n);i>=(e);i-=(d))
#define FILL(a,b) memset(a,b,sizeof(a))
//#undef mydebug//DEBUGGING PURPOSE
#ifdef mydebug
#define debug(args...) {printf("\nLine-->%d  ",__LINE__);printf(#args);printf(" ---> ");dbg,args;printf("\n");}
#define DB(x) cout<<#x<<": "<<x<<"\n"
#define DB2(x,y) cout<<#x<<": "<<(x)<<"\t"<<#y<<": "<<(y)<<"\n"
#define DB3(x,y,z) cout<<#x<<": "<<(x)<<"\t"<<#y<<": "<<(y)<<"\t"<<#z<<": "<<(z)<<"\n"
#define DB4(x,y,z,a) cout<<#x<<": "<<(x)<<"\t"<<#y<<": "<<(y)<<"\t"<<#z<<": "<<(z)<<"\t"<<#a<<": "<<(a)<<"\n"
#define DBG_ARR(a,b,c) printf(#a);DBG(a,b,c)
#define DBG_MAT(a,s,b,c) printf(#a);printf("\n");DBGM(a,s,b,c)
#else
#define debug(args...)
#define DB(x)
#define DB2(x,y)
#define DB3(x,y,z)
#define DB4(x,y,z,a)
#define DBG_ARR(a,b,c)
#define DBG_MAT(a,s,b,c)
#endif
template<typename T>void DBG(const T A,int S,int N){cout<<"[";FOR(i,S,N){cout<<"#"<<i<<":"<<A[i]<<" ";}cout<<"]\n";}
template<typename T>void DBGM(const T A,int S,int M,int N){FOR(i,S,M){FOR(j,S,N){cout<<A[i][j]<<" ";}printf("\n");}}
struct debugger{template<typename T>debugger&operator,(const T&v){cout<<" #"<<v;return *this;}}dbg;
const double PIE=acos(-1.0);
const double EPS=1e-5;
template<typename T>inline T Mod(T N,T M){return (N%M+M)%M;}
//template<typename T>void swap(T &x,T &y){T t=x;x=y;y=t;}
template<typename T>inline int countbit(T n){return (n==0)?0:(1+countbit(n&(n-1)));}
bool isUpperCase(char c){return c>='A'&&c<='Z';}
bool isLowerCase(char c){return c>='a'&&c<='z';}
bool isLetter(char c){return c>='A'&&c<='Z'||c>='a'&&c<='z';}
bool isDigit(char c){return c>='0'&&c<='9';}
char toLowerCase(char c){return (isUpperCase(c))?(c+32):c;}
char toUpperCase(char c){return (isLowerCase(c))?(c-32):c;}
template<typename T> inline T gcd(T a,T b){if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);}
template<typename T>T _gcd(T a,T b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);}
//int dx[]={1,0,-1,0};int dy[]={0,1,0,-1};//4 Direction
//int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction
//int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction
//int dx[]={-1,-1,+0,+1,+1,+0};int dy[]={-1,+1,+2,+1,-1,-2}; //Hexagonal Direction
//int month[]={-1,31,28,31,30,31,30,31,31,30,31,30,31}; //Not Leap Year
//string monthName[]={"","January","February","March","April","May","June","July","August","September","October","November","December"};
//string dayName[]={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
//}

void precompute(){}
char arr[1001];
int N;
void permute(char *s,int start,int end){
    if(start==end){
        printf("%s\n",arr);
        return;
    }
    FOR(i,start,end+1){
        swap(*(s+start),*(s+i));
        permute(s,start+1,end);
        swap(*(s+start),*(s+i));
    }

}
void doThis(){
    ss(arr);
    N=strlen(arr);
    permute(arr,0,N-1);
}
int main(){
#ifdef amy
freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt","w",stderr);
#endif
doThis();
#ifdef amy
fprintf(stdout,"\nTIME: %.3lf sec\n",(double)clock()/(CLOCKS_PER_SEC));
#endif
return 0;
}
