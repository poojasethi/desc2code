//O(n^2) solution
#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <functional>
#include <utility>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <list>
#define endl "\n"
#define pb push_back
#define sz() size()
#define all(a) a.begin(),a.end()
#define mp make_pair
#define ff first
#define ss second
#define mod 1000000007
#define d(x) printf(#x" = %d",x)
#define pl puts("")
#define ps pc(' ')
#define gc getchar_unlocked
#define pc putchar_unlocked
#define bitcount __builtin_popcount
#define gcd __gcd
#define SZ
#define INF 
using namespace std;
typedef long long ll;
typedef vector <int> vi;
typedef pair<int,int> pii;
#ifdef _WIN32
int getchar_unlocked() { return getchar(); }
int putchar_unlocked(char c) { return putchar(c); }
#endif
template <typename T>void sc(T &n){register int f=1;n=0;char c=gc();while(c!='-'&&c<'0')c=gc();if(c=='-')f=-1,c=gc();while(c>='0'&&c<='9')n=(n<<3)+(n<<1)+c-'0',c=gc();n=n*f;}
template <typename T>void pr(T &a){char s[30];if(a<0){pc('-');a*=-1;}int i=0;do{s[i++]=a%10+'0';a/=10;}while(a);i--;while(i>=0)pc(s[i--]);}
template <typename T>T sub(T x,T y){if(x<y)return y-x;return x-y;}
int main()
{
	int t;
	sc(t);
	int a[100][100];
	while(t--)
	{
		int n,m;
		sc(n); sc(m);
		int i,j,k;
		for(i=0;i<n;i++)
			for(j=0;j<m;j++)
				sc(a[i][j]);
		ll ans = -1000000000;
		//consider each point as intersection
		ll sum;
		for(i=0;i<n;i++)
		{
			for(j=0;j<m;j++)
			{
				sum = a[i][j];
				//ans = max(ans,sum);
				for(k=1;;k++)//increase len all 4 sides
				{
					if(i+k>=n || j+k>=m || i-k<0 || j-k<0)
						break;
					sum += a[i+k][j+k];
					sum += a[i+k][j-k];
					sum += a[i-k][j+k];
					sum += a[i-k][j-k];
					ans = max(ans , sum);
				}
				if(i+1>=n || j+1>=m)break;
				//consider center 2 side square as a single point
				sum = a[i][j]+a[i+1][j] + a[i][j+1] + a[i+1][j+1];
				ans =max( ans ,sum);
				for(k=1;;k++)
				{
					if(i-k<0 || j-k<0 || j+k+1>=m || i+k+1>=n)
						break;
					sum += a[i-k][j-k];
					sum += a[i-k][j+k+1];
					sum += a[i+k+1][j+k+1];
					sum += a[i+k+1][j-k];
					ans = max(ans , sum);
				}
			}
		}
		pr(ans);pl;
	}
	return 0;
}