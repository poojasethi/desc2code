#include<bits/stdc++.h>
#define intMAX 1123456789LL
#define MAX intMAX * intMAX
#define F first
#define S second
#define mp make_pair
#define ll long long
#define pb push_back
#define pv(v,b,a) v.insert(v.begin()+b,a)
#define all(c) c.begin(),c.end()
#define sf(a) scanf("%d",&a);
#define sl(a) scanf("%lld",&a);
#define MAXCR 1000000000
#define mem(arr,a) memset(arr, a, sizeof arr)
#define er(vec,a,b) vec.erase(vec.begin() + a, vec.begin() + b+1)
#define traverse(a) for()
#define pii pair<int ,int>
#define mod 1000000007
#define LIM 100
using namespace std;
/*
list as pop_front();push_front(ELEMENT);
list as pop_front();push_back(ELEMENT);
to see first element stack=q.front()
to see last element queue=q.back()
*/
//str.insert(6,str3,3,4); to insert 4 words from str3 starting from 3rd position(0 based indexing) to str from 6th position (0 based indexing)
//str.find("live");//finds first occurance of string and returns its 0 based indes
//string str1=str.substr (a,n);//a=0 based start index,n=length of words//if length not given substring till end is formed
//auto bound_=upper_bound (v.begin(), v.end(), 20); //Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.
//auto bound_=lower_bound (v.begin(), v.end(), 20);//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
//bool ans=binary_search();//Returns true if any element in the range [first,last) is equivalent to val, and false otherwise.
//for(???<???>:iterator itr;itr!=???.end();itr++) or for(auto &tt : t.edges)
//getline(cin,s,'\n');  to get input terminating at'\n';excluding '\n'
//(a/b)%m = ((a%m)(b^(m-2)%m))%m.
//(a^b)%m=
//vector<ll>v(size,default val);
//reverse(all(s))//to reverse some vector or string;
//cin.eof() //checks for end of file return true when cin takes input as end of file
typedef struct
{
	int twos;
	int fives;
}segnode;
int two[2001],five[2001],arr[100005];
segnode seg[500025],lazy[500025];
void set_()
{
	int i;
	mem(arr,0);
	for(i=0;i<500025;i++)
	{
		seg[i].twos=0;
		seg[i].fives=0;
		lazy[i].twos=0;
		lazy[i].fives=0;		
	}
}
segnode arrange(segnode s1,segnode s2)
{
	segnode s;
	s.twos=s1.twos+s2.twos;
	s.fives=s1.fives+s2.fives;
	return s;
}
void initialize(int node,int a,int b)
{
	if(a==b)
	{
		seg[node].twos=two[arr[a]];
		seg[node].fives=five[arr[a]];
		return ;
	}
	initialize(node*2,a,(a+b)/2);
	initialize(node*2+1,(a+b)/2+1,b);
	seg[node]=arrange(seg[node*2],seg[node*2+1]);
}
void update(int node,int a,int b,int i,int j,segnode s)
{
	if(lazy[node].twos!=0||lazy[node].fives!=0)
	{
		seg[node].twos+=(b-a+1)*(lazy[node].twos);
		seg[node].fives+=(b-a+1)*(lazy[node].fives);
		if(a!=b)
		{
			lazy[2*node].twos+=lazy[node].twos;
			lazy[2*node].fives+=lazy[node].fives;
			lazy[2*node+1].twos+=lazy[node].twos;
			lazy[2*node+1].fives+=lazy[node].fives;
		}
		lazy[node].twos=0;
		lazy[node].fives=0;
	}
	if(i>b||j<a)
		return ;
	if(a>=i&&b<=j)
	{
		seg[node].twos+=(b-a+1)*(s.twos);
		seg[node].fives+=(b-a+1)*(s.fives);
		if(a!=b)
		{
			lazy[2*node].twos+=s.twos;
			lazy[2*node].fives+=s.fives;
			lazy[2*node+1].twos+=s.twos;
			lazy[2*node+1].fives+=s.fives;
		}
		return ;
	}
	update(node*2,a,(a+b)/2,i,j,s);
	update(node*2+1,(a+b)/2+1,b,i,j,s);
	seg[node]=arrange(seg[node*2],seg[node*2+1]);
}
segnode query(int node,int a,int b,int i,int j)
{
	if(j<a||i>b)
	{
		segnode s;
		s.twos=-1;
		s.fives=-1;
		return s;
	}
	if(lazy[node].twos!=0||lazy[node].fives!=0)
	{
		seg[node].twos+=(b-a+1)*(lazy[node].twos);
		seg[node].fives+=(b-a+1)*(lazy[node].fives);
		if(a!=b)
		{
			lazy[2*node].twos+=lazy[node].twos;
			lazy[2*node].fives+=lazy[node].fives;
			lazy[2*node+1].twos+=lazy[node].twos;
			lazy[2*node+1].fives+=lazy[node].fives;
		}
		lazy[node].twos=0;
		lazy[node].fives=0;
	}
	if(a>=i&&b<=j)
		return seg[node];
	segnode q1=query(node*2,a,(a+b)/2,i,j);
	segnode q2=query(node*2+1,(a+b)/2+1,b,i,j);
	if(q1.twos==-1)
		return q2;
	if(q2.twos==-1)
		return q1;
	return arrange(q1,q2);
}
int main()
{
	int i,cnt2,cnt5,l,r,v,t,a,n,q;
	for(i=1;i<=2000;i++)
	{
		cnt2=0;
		a=i;
		while(a%2==0)
		{
			a=a/2;
			cnt2++;
		}
		cnt5=0;
		a=i;
		while(a%5==0)
		{
			a=a/5;
			cnt5++;
		}
		two[i]=cnt2;
		five[i]=cnt5;
	}
	sf(t)
	while(t--)
	{
		set_();
		sf(n)
		sf(q)
		for(i=1;i<=n;i++)
		{
			sf(arr[i])
		}
		initialize(1,1,n);
		for(i=1;i<=q;i++)
		{
			sf(a)
			if(a==1)
			{
				sf(l)
				sf(r)
				segnode s=query(1,1,n,l,r);
				printf("%d\n",min(s.twos,s.fives));
			}
			else
			{
				sf(l)
				sf(r)
				sf(v)
				segnode s;
				s.twos=two[v];
				s.fives=five[v];
				update(1,1,n,l,r,s);
			}
		}
	}
	return 0;
}