#include<bits/stdc++.h>
using namespace std;
void build(int node,int a,int b,vector<pair<int,int> >& v,vector<pair<int,int> >& tree)
{
	if(a>b)
		return;
	if(a==b)
	{
		tree[node].first=v[a].first;
		tree[node].second=v[a].second;
		return;
	}
	build(node*2,a,(a+b)/2,v,tree);
	build(node*2+1,(a+b)/2+1,b,v,tree);
	tree[node].first=(tree[node*2].first+tree[node*2+1].first);
	tree[node].second=(tree[node*2].second+tree[node*2+1].second);
}
void update(int node,int a,int b,int i,int j,vector<pair<int,int> >&tree,vector<pair<int,int> >&lazy,int val1,int val2)
{
	if(lazy[node].first+lazy[node].second!=0)
	{
		tree[node].first+=(b-a+1)*lazy[node].first;
		tree[node].second+=(b-a+1)*lazy[node].second;
		if(a!=b)
		{
			lazy[node*2].first+=lazy[node].first;
			lazy[node*2].second+=lazy[node].second;
			lazy[node*2+1].first+=lazy[node].first;
			lazy[node*2+1].second+=lazy[node].second;	
		}
		lazy[node].first=0;
		lazy[node].second=0;
	}
	if((a>b)||(a>j)||(i>b))
		return;
	if((a>=i)&&(b<=j))
	{
		tree[node].first+=(b-a+1)*val1;
		tree[node].second+=(b-a+1)*val2;
		if(a!=b)
		{
			lazy[node*2].first+=val1;
			lazy[node*2].second+=val2;
			lazy[node*2+1].first+=val1;
			lazy[node*2+1].second+=val2;	
		}
		return;
	}
	update(node*2,a,(a+b)/2,i,j,tree,lazy,val1,val2);
	update(node*2+1,(a+b)/2+1,b,i,j,tree,lazy,val1,val2);
	tree[node].first=(tree[node*2].first+tree[node*2+1].first);
	tree[node].second=(tree[node*2].second+tree[node*2+1].second);
}
int query(int node,int a,int b,int i,int j,vector<pair<int,int> >&tree,vector<pair<int,int> >&lazy,int type)
{
	if(lazy[node].first+lazy[node].second!=0)
	{
		tree[node].first+=(b-a+1)*lazy[node].first;
		tree[node].second+=(b-a+1)*lazy[node].second;
		if(a!=b)
		{
			lazy[node*2].first+=lazy[node].first;
			lazy[node*2].second+=lazy[node].second;
			lazy[node*2+1].first+=lazy[node].first;
			lazy[node*2+1].second+=lazy[node].second;	
		}
		lazy[node].first=0;
		lazy[node].second=0;
	}
	if((a>b)||(a>j)||(i>b))
		return 0;
	if((a>=i)&&(b<=j))
	{
		if(type==1)
			return (tree[node].first);
		else
			return (tree[node].second);
	}
	int q1=query(node*2,a,(a+b)/2,i,j,tree,lazy,type);
	int q2=query(node*2+1,(a+b)/2+1,b,i,j,tree,lazy,type);
	return (q1+q2);
}
int main()
{
	int i,t,n,q,res1,res2,num,val1,val2,temp,l,r,op;
	int df[2001],dt[2001];
	for(i=1;i<=2000;i++)
	{
		temp=i;
		val1=val2=0;
		while(temp%5==0)
		{
			val1++;
			temp/=5;
		}
		while(temp%2==0)
		{
			val2++;
			temp/=2;
		}
		df[i]=val1;
		dt[i]=val2;
	}
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&q);
		vector<pair<int,int> > v(n),tree(4*n),lazy(4*n);
		for(i=0;i<n;i++)
		{
			scanf("%d",&num);
			temp=num;
			val1=df[num];
			val2=dt[num];
			v[i].first=val1;
			v[i].second=val2;
		}
		build(1,0,n-1,v,tree);
		while(q--)
		{
			scanf("%d",&op);
			if(op==1)
			{
				scanf("%d%d",&l,&r);
				l--;
				r--;
				res1=query(1,0,n-1,l,r,tree,lazy,1);
				res2=query(1,0,n-1,l,r,tree,lazy,2);
				printf("%d\n",min(res1,res2));
			}
			else
			{
				scanf("%d%d%d",&l,&r,&num);
				l--;
				r--;
				val1=df[num];
				val2=dt[num];
			if(val1+val2!=0)
			{
				update(1,0,n-1,l,r,tree,lazy,val1,val2);
			}
			}
		}
	}
	return 0;
}