#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<utility>
#include<cstring>
#include<cmath>
#define LL long long int
#define mod 1000000007
#define vi vector<int>
#define vvi vector < vi >
#define pii pair<int,int>
#define all(c) c.begin(),c.end()
#define sf(x) scanf("%d",&x);
#define sf2(x,y) scanf("%d%d",&x,&y);
#define mem(a,val) memset(a,val,sizeof(a))
#define nl printf("\n");
#define pb push_back
#define mp make_pair
//#define f first
//#define s second
#define cf I64
using namespace std;
int arr[100005],two[2005],five[2005];
struct node
{	int two;
	int five;
}tree[500005];
struct lazynode
{	int two;
	int five;
}lazy[500005];
void numfactortwo()
{	int cnt=0,i,num;
	for(i=1;i<=2000;i++)
	{	num=i;cnt=0;
		while(num%2==0)
		{	num/=2;
			cnt++;
		}
		two[i]=cnt;
	}
	return ;
}
void numfactorfive()
{	int cnt=0,i,num;
	for(i=1;i<=2000;i++)
	{	cnt=0;num=i;
		while(num%5==0)
		{	num/=5;
			cnt++;
		}
		five[i]=cnt;
	}
	return ;
}
void build(int node,int a,int b)
{	if(a>b) return ;
	if(a==b)
	{	tree[node].two=two[arr[a]];
		tree[node].five=five[arr[a]];
		return ;
	}
	build(2*node,a,(a+b)/2);
	build(2*node+1,(a+b)/2+1,b);
	tree[node].two=tree[2*node].two+tree[2*node+1].two;
	tree[node].five=tree[2*node].five+tree[2*node+1].five;
	return ;
}
void update(int node,int a,int b,int start,int end,int val2,int val5)
{	if(lazy[node].two!=0)
	{	tree[node].two+=(b-a+1)*lazy[node].two;
		if(a!=b)
		{	lazy[2*node].two+=lazy[node].two;
			lazy[2*node+1].two+=lazy[node].two;	
		}
		lazy[node].two=0;	
	}
	if(lazy[node].five!=0)
	{	tree[node].five+=(b-a+1)*lazy[node].five;
		if(a!=b)
		{	lazy[2*node].five+=lazy[node].five;
			lazy[2*node+1].five+=lazy[node].five;
		}
		lazy[node].five=0;
	}
	if(a>b||b<start||a>end) return ;
	if(a>=start&&b<=end)
	{	tree[node].two+=(b-a+1)*val2;
		tree[node].five+=(b-a+1)*val5;
		if(a!=b)
		{	lazy[2*node].two+=val2;
			lazy[2*node+1].two+=val2;
			lazy[2*node].five+=val5;
			lazy[2*node+1].five+=val5;
		}
		return ;
	}
	update(2*node,a,(a+b)/2,start,end,val2,val5);
	update(2*node+1,(a+b)/2+1,b,start,end,val2,val5);
	tree[node].two=tree[2*node].two+tree[2*node+1].two;
	tree[node].five=tree[2*node].five+tree[2*node+1].five;
	return ;
}
int query2(int node,int a,int b,int start,int end)
{	if(a>b||b<start||a>end) return 0;
	if(lazy[node].two!=0)
	{	tree[node].two+=(b-a+1)*lazy[node].two;
		if(a!=b)
		{	lazy[2*node].two+=lazy[node].two;
			lazy[2*node+1].two+=lazy[node].two;
		}
		lazy[node].two=0;
	}
	if(lazy[node].five!=0)
	{	tree[node].five+=(b-a+1)*lazy[node].five;
		if(a!=b)
		{	lazy[2*node].five+=lazy[node].five;
			lazy[2*node+1].five+=lazy[node].five;
		}
		lazy[node].five=0;
	}
	if(a>=start&&b<=end) return tree[node].two;
	return query2(2*node,a,(a+b)/2,start,end)+query2(2*node+1,(a+b)/2+1,b,start,end);
}
int query5(int node,int a,int b,int start,int end)
{	if(a>b||b<start||a>end) return 0;
	if(lazy[node].two!=0)
	{	tree[node].two+=(b-a+1)*lazy[node].two;
		if(a!=b)
		{	lazy[2*node].two+=lazy[node].two;
			lazy[2*node+1].two+=lazy[node].two;
		}
		lazy[node].two=0;
	}
	if(lazy[node].five!=0)
	{	tree[node].five+=(b-a+1)*lazy[node].five;
		if(a!=b)
		{	lazy[2*node].five+=lazy[node].five;
			lazy[2*node+1].five+=lazy[node].five;
		}
		lazy[node].five=0;
	}
	if(a>=start&&b<=end) return tree[node].five;
	return query5(2*node,a,(a+b)/2,start,end)+query5(2*node+1,(a+b)/2+1,b,start,end);
}
int main()
{	int t,i,j,n,m,ans,sum,q,l,r,x,y,u,v,num2,num5;
	sf(t);
	numfactortwo();
	numfactorfive();
	while(t--)
	{	sf(n);sf(q);
		mem(tree,0);
		mem(lazy,0);
		for(i=1;i<=n;i++) sf(arr[i]);
		build(1,1,n);
		while(q--)
		{	scanf("%d%d%d",&u,&l,&r);
			if(u==1)
			{	x=query2(1,1,n,l,r);
				y=query5(1,1,n,l,r);
				printf("%d\n",min(x,y));
			}
			else if(u==2)
			{	sf(v);
				num2=two[v];
				num5=five[v];
				update(1,1,n,l,r,num2,num5);
			}
		}
	}
	return 0;
}
/*
2
8 10
2 4 15 40 30 8 100 50
1 1 3
1 1 2
1 3 3
1 4 5
1 5 8
1 6 8
1 6 6
2 1 2 5
2 6 7 25
1 6 7
8 10
2 4 15 40 30 8 100 50
1 1 3
1 1 2
1 3 3
1 4 5
1 5 8
1 6 8
1 6 6
2 1 2 5
2 6 7 25
1 6 7

*/
