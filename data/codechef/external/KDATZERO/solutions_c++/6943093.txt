
// (c) agaurav77
#include <iostream>
#include <map>          // find(), clear()
#include <vector>       // push_back(), pop_back(), front(), back()
#include <list>         // push_back(), pop_back(), front(), back() --- SEQUENTIAL ACCESS
#include <queue>        // push(), pop(), front(), back()
#include <utility>      // make_pair()
#include <algorithm>    // sort()
#include <cmath>
#include <cstdio>
#include <climits>      // inf, minf
#include <cstdlib>      // malloc()
#include <sstream>
#include <string>
#include <cstring>      // memset()
#define mp make_pair
#define pb push_back
using namespace std;

#define inf INT_MAX
#define minf INT_MIN
#define t(N) scanf("%d", &N);
#define f(i,a,b) for(int i=a;i <= b; ++i)
#define str string
#define ll long long 
#define inMap(a,b) (a.find(b) != a.end())
#define lastOne(i) (i&(-i))
#define MAX 100005

int B2a[MAX], B2b[MAX],  B5a[MAX], B5b[MAX];
int N;

// create an update function
void update(int *BIT, int i, int val) {
  while (i < N+5) {
    BIT[i] += val;
    i = i+lastOne(i);
  }
}

// create a cumulative query function
int query(int *BIT, int i) {
  int sum = 0;
  while (i > 0) {
    sum += BIT[i];
    i = i-lastOne(i);
  }
  return sum;
}

// create a function to update over range
void updateRange(int *BIT, int *off, int L, int R, int val) {
  update(BIT, L, val);
  update(BIT, R+1, -val);
  update(off, L, val*(L-1));
  update(off, R+1, -val*R);
}

int bitquery(int *BIT, int *off, int i) {
  return i*query(BIT, i)-query(off, i);
}

int main() {
  // take in the test cases
  int T;
  t(T);

  while (T--) {
    // take in N, Q
    int Q;
    t(N); t(Q);

    // empty BIT
    memset(B2a, 0, sizeof(int)*(N+5));
    memset(B2b, 0, sizeof(int)*(N+5));
    memset(B5a, 0, sizeof(int)*(N+5));
    memset(B5b, 0, sizeof(int)*(N+5));

    // insert into BIT
    int tmp;
    f(i, 1, N) {
      t(tmp);
      int pow2 = 0, pow5 = 0;
      while (tmp > 0 && tmp%2 == 0) {tmp /= 2; pow2++;}
      while (tmp > 0 && tmp%5 == 0) {tmp /= 5; pow5++;}
      updateRange(B2a, B2b, i, i, pow2);
      updateRange(B5a, B5b, i, i, pow5);
    }

    // handle queries
    int num, L, R, val;
    f(i, 0, Q-1) {
      // sanity check
      // print number of 2s and 5s for each index
      //f(j, 1, N) {
      //  cout << j << " -> " << bitquery(B2a, B2b, j)-bitquery(B2a, B2b, j-1)
      //            << "    " << bitquery(B5a, B5b, j)-bitquery(B5a, B5b, j-1) << endl;
      //}
    
      t(num);
      if (num == 1) {
        t(L); t(R);
        // find number of trailing zeroes in L,R
        // find powers of 2, 5 and take min
        printf("%d\n", min( bitquery(B2a,B2b,R)-bitquery(B2a,B2b,L-1),
                          bitquery(B5a,B5b,R)-bitquery(B5a,B5b,L-1) ));
      } else {
        t(L); t(R); t(val);
        int pow2 = 0, pow5 = 0;
        while (val > 0 && val%2 == 0) {val /= 2; pow2++;}
        while (val > 0 && val%5 == 0) {val /= 5; pow5++;}
        updateRange(B2a, B2b, L, R, pow2);
        updateRange(B5a, B5b, L, R, pow5);
      }
    }
  }
  return 0;
}

