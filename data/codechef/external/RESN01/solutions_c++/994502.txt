#include <iostream>
#include <stdio.h>
#include <queue>
#include <algorithm>
#include <vector>
#include <list>
using namespace std;


//trocar para 0 para desabilitar output
#if 1
#define DEBUG(x) cout << x << endl
#define PAUSE() cin.get(); cin.get()
#else
#define DEBUG(x)
#define PAUSE()
#endif

#define TRACE(x) DEBUG(#x << " = " << x)
#define DEBUGS() DEBUG("***************************")

typedef struct node{
    int a, b;
    int andState;
}node;

vector<node> tree(100000);
vector<int> ands(20000);

int createSegTree(int v, int a, int b){
    tree[v].a = a;
    tree[v].b = b;
    if (a == b){
	tree[v].andState = ands[a];
	return ands[a];
    }
    tree[v].andState = createSegTree(2*v+1, a, (a+b)/2);
    tree[v].andState &= createSegTree(2*v+2, (a+b)/2+1, b);
    return tree[v].andState;
}


int query(int v, int a, int b){
    int left = 2*v+1, right = 2*v+2;
    if (tree[v].a >= a && tree[v].b <= b){
	return tree[v].andState;
    }
    
    int totalAnds = 0xFFFFFFFF;
    if (tree[left].a <= b && tree[left].b >= a) totalAnds &= query(left, a, b);
    if (tree[right].a <= b && tree[right].b >= a) totalAnds &= query(right, a, b);
    return totalAnds;
}

void showSegTree(int v){
    printf("intervalo [%d, %d], andState: %d\n", tree[v].a, tree[v].b, tree[v].andState);
    if (tree[v].a == tree[v].b) return;
    printf("esquerda:\n");
    showSegTree(2*v+1);
    printf("direita:\n");
    showSegTree(2*v+2);
}

int main(){
    int t, n, k;
    scanf("%d", &t);

    for (int i = 0; i < t; ++i){
	scanf("%d %d", &n, &k);
	for (int j = 0; j < n; ++j){
	    scanf("%d", &ands[j]);
	}
	createSegTree(0, 0, n-1);
	for (int j = 0; j < n; ++j){
	    int result;
	    int a = j-k, b = j+k;
	    if (k >= n/2) result = query(0, 0, n-1);
	    else if (a < 0) result = query(0, 0, b)&query(0, n+a, n-1);
	    else if (b >= n) result = query(0, a, n-1)&query(0, 0, b-n);
	    else result = query(0, a, b);
	    printf("%d ", result);
	}
	printf("\n");
	//showSegTree(0);
    }
    return 0;
}
