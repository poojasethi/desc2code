#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <memory>
#include <cctype>
#include <string>
#include <vector>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <set>
#include <algorithm>
using namespace std;
#define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i))
#define RFOR(i,a,b) for(int (i) = (a); (i) >= (b); --(i))
#define INITIALIZE(a,b) memset((a),b,sizeof(a))
#define INF 1000000000
#define pi 2*acos(0.0)
#define SQR(a) (a)*(a)
#define MP make_pair
#define MAX 100001
#define MODV 1000000007
#define mod(a,mb) if(a >= mb) a = a - mb;
#define modx(a) mod(a,MODV)

typedef unsigned long long UInt;
typedef long long Int;

int read_int(){ int x; scanf("%d", &x); return x;}
Int read_Int(){ Int x; scanf("%lld", &x); return x;}

void compPrime(int *primeArr,int n){}
void compPhi(int *phiArr, int n){}
void compFact(int *factArr, int n){}
void compPow(int *powArr, int x, int n)
{   int i;
    powArr[0] = 1;
    FOR(i,1,n){powArr[i] = powArr[i-1]*x;mod(powArr[i],MODV);}
}

int CountBit(int n)
{
  unsigned int c; // c accumulates the total bits set in v

  for (c = 0; n; c++)
    n = n >>1; // clear the least significant bit set
  return c;
}

int main()
{
  int test,i,j, sum;
  int *A, *B;
  int N, K;
  int max;
  int cBIT;

  scanf("%d",&test);

  while(test--)
  {
        N = read_int();
        K = read_int();
        max = -1;
        A = new int[N+1];
        B = new int[3*N+1];
        FOR(i,1,N)
        {
             A[i] = read_Int();
             B[i] = B[i+N] = B[i+2*N] = A[i];
             if(A[i] > max) max = A[i];
        }
     //   A[0] = A[N];

        cBIT = CountBit(max);

        int lstZeroBit = -1;
        int bit;
        while(cBIT>=1)
        {
            lstZeroBit = -1;

            FOR(i,1,N)
            {
                bit = (B[i] & ( 1u << (cBIT-1))) >> (cBIT-1);
                if(bit==0)  lstZeroBit = i;
            }

            FOR(i,1,N) //// Left Scan
            {
                bit = (B[i+N] & ( 1u << (cBIT-1))) >> (cBIT-1);

                if( lstZeroBit!= -1 && (i + N - lstZeroBit) <= K)
                {
                    A[i] &= ~(1u << (cBIT - 1) ) ;
                }

                if(bit==0) lstZeroBit = N + i;

            }

            lstZeroBit = -1;

            for(i=3*N; i>2*N;i--)
            {
                bit = (B[i] & ( 1u << (cBIT-1))) >> (cBIT-1);
                if(bit==0)lstZeroBit = i;
            }

            for(i=N;i>0;i--)  //// Right Scan
            {
                bit = (B[i+N] & ( 1u << (cBIT-1))) >> (cBIT-1);


                if(lstZeroBit != -1 && (lstZeroBit - (N + i))<= K)
                {
                    A[i] &= ~(1u << (cBIT -1)) ;
                }


                if(bit==0)
                {
                    lstZeroBit = N+i;
                }

            }
            cBIT--;
        }

        printf("%d",A[1]);
        FOR(i,2,N)printf(" %d",A[i]);
        printf("\n");


	// your code goes here
  }


}
