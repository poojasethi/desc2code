#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
#include<queue>
#include<map>
#include<vector>
#include<stack>
#include<set>
#include<fstream>
#include<iomanip>
#define pb push_back
#define mp make_pair
#define M 500
#define limit 150000
#define Inf 1e6+1
#define accr 1e-6
#define PI 3.141592653589793238462643383279502884197
#define ll (long long)
#define ld long double
using namespace std;

vector<int> graph[M];
vector<ld> one,X;
int cnt;
string s;

void DFS(int node)
{
    if(s[node]=='x')
    {
        cnt++;
        return ;
    }
    cnt++;
    graph[node].pb(cnt);
    DFS(cnt);
    graph[node].pb(cnt);
    DFS(cnt);
    return ;
}


vector<ld> Integrate(vector<ld> P)
{
    int i,j,k;
    vector<ld> F;
    F.pb(0);
    for(i=0;i<P.size();i++)
    {
        F.pb(P[i]/(ld) (i+1));
    }
    return F;
}

vector<ld> mul(vector<ld> P1,vector<ld> P2)
{
    int i,j,k,sz;
    vector<ld> P;
    ld sum;
    sz=P1.size()+P2.size()-1;
    for(i=0;i<sz;i++)
    {
        sum=0;
        for(j=max(0,i+1-(int)P2.size());j<=min(i,(int)P1.size()-1);j++)
        {
            sum+=P1[j]*P2[i-j];
        }
        P.pb(sum);
    }
    return P;
}

vector<ld> flip(vector<ld> P)
{
    for(int i=0;i<P.size();i++)
    {
        P[i]=-P[i];
    }
    return P;
}

vector<ld> add(vector<ld> P1,vector<ld> P2)
{
    int i,j,k;
    vector<ld> P;
    for(i=0;i<min((int)P1.size(),(int)P2.size());i++)
    {
        P.pb(P1[i]+P2[i]);
    }
    k=i;
    for(j=i;j<P1.size();j++)
    {
        P.pb(P1[j]);
    }
    for(j=k;j<P2.size();j++)
    {
        P.pb(P2[j]);
    }
    return P;
}

ld result(vector<ld> P)
{
    int i,j,k;
    ld sum;
    sum=0;
    for(i=0;i<P.size();i++)
    {
        sum+=P[i];
    }
    return sum;
}

vector<ld> DFSsolve(int node)
{
    if(s[node]=='x')
    {
        return one;
    }
    vector<ld> P1,P2,F1,F2,ans1,ans2;
    P1=DFSsolve(graph[node][0]);
    P2=DFSsolve(graph[node][1]);
    F1=Integrate(P1);
    F2=Integrate(P2);
    ans1=mul(P1,F2);
    ans2=mul(P2,F1);
    if(s[node]=='M')
    {
        return add(ans1,ans2);
    }
    else
    {
        return add(P1,add(P2,flip(add(ans1,ans2))));
    }
}

int main()
{
    int i,j,k,t;
    scanf("%d",&t);
    one.pb(1);
    X.pb(0);
    X.pb(1);
    while(t--)
    {
        cin>>s;
        cnt=0;
        DFS(0);
        vector<ld> P,F;
        P=DFSsolve(0);
        F=Integrate(mul(P,X));
        printf("%.19Lf\n",result(F));
        for(i=0;i<s.length();i++)
        {
            graph[i].clear();
        }
    }
    return 0;
}
