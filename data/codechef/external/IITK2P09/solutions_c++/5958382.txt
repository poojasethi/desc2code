/*
***************************************************************************************************************

							Author : Yash Sadhwani

**************************************************************************************************************
*/
#include<stdio.h>
#include<iostream>
#include<vector>
#include<string.h>
#include<algorithm>
#include<deque>
#include<map>
#include<set>
#include<stdlib.h>
#include<math.h>
#include<queue>
#include<functional>
using namespace std;
#define ll long long
#define si(x) scanf("%d",&x)
#define sl(x) scanf("%lld",&x)
#define sc(x) scanf("%c",&x)
#define vl vector<ll>
#define vi vector<int>
#define vvl vector< vl >
#define vvi vector< vi >
#include <stack>
#define pb push_back
#define mod 1000000007
#define mem(x,y) memset(x,y,sizeof(x))
#define f(i,a,b) for(int i=(a);i<(b);i++)
#define max_int_value 2147483647
#define max_long_value 9223372036854775807



//qsort(ww,cc,sizeof(tp),compare);
/*int compare(const void *a,const void *b){
	ll y=((((tp*)a)->w)-(((tp*)b)->w));
	if(y>0)return 1;
	else if(y==0)return 0;
	else return -1;
}
bool way(ii x,ii y){
	return x.first<y.first or x.first==y.first and x.second<y.second;
}
*/


#define MAXN 200010
#define ls (node<<1)
#define rs ((node<<1)+1)
#define ii pair<int,int>

int depth[MAXN];
int upper[MAXN];
vi AdjList[MAXN];
bool visited[MAXN];
vi tempo;
int N;
int maxPath[MAXN];

void dfs(int node){
	stack<ii> pp;
	int dad=0;
	pp.push(ii(node,dad));
	while(!pp.empty()){
		node=pp.top().first;
		dad=pp.top().second;
		if(!visited[node]){
			visited[node]=true;
			for(int i=0;i<AdjList[node].size();i++){
				if(!visited[AdjList[node][i]])pp.push(ii(AdjList[node][i],node));
			}
		}else{
			pp.pop();
            depth[node]=0;
			for(int i=0;i<AdjList[node].size();i++)if(AdjList[node][i]!=dad)depth[node]=max(depth[node],depth[AdjList[node][i]]+1);
		}
	}
}

void dfsr(int node,int upper){
	stack<ii> pp;
	pp.push(ii(node,upper));
	while(!pp.empty()){
		node=pp.top().first;
		upper=pp.top().second;
		if(!visited[node]){
			visited[node]=true;
			int m1=-1,m2=-1;
			int c1=-1,c2=-1;
    		for(int i=0;i<AdjList[node].size();i++){
    	   		if(visited[AdjList[node][i]])continue;
				if(depth[AdjList[node][i]]>m1){
					m2=m1;
					c2=c1;
					m1=depth[AdjList[node][i]];
					c1=i;
				}
				else if(depth[AdjList[node][i]]>m2){
					m2=depth[AdjList[node][i]];
					c2=i;
				}
			}
			for(int i=0;i<AdjList[node].size();i++){
				if(!visited[AdjList[node][i]]){
					if(depth[AdjList[node][i]]==m1){
						pp.push(ii(AdjList[node][i],max(upper+1,(c2!=-1?m2+2:0))));
					}else{
						pp.push(ii(AdjList[node][i],max(upper+1,(c1!=-1?m1+2:0))));
					}
				}
			}
		}else{
			maxPath[node]=max(upper,depth[node]);
            pp.pop();
		}
	}
}


inline void ReadInput(void){
	si(N);
	for(int i=0;i<N-1;i++){
		int a,b;
		si(a); si(b);
		AdjList[a].pb(b);
		AdjList[b].pb(a);
	}
}

inline void solve(void){
	fill(visited,visited+MAXN,false);
	dfs(1);
	fill(visited,visited+MAXN,false);
    dfsr(1,0);
    double total=0;
    for(int i=1;i<=N;i++)total+=(double(maxPath[i]));
	total=(total/(double(N)));
	printf("%.9lf\n",total );
}

inline void Refresh(void){

}

int main()
{
    ios_base::sync_with_stdio(false);
    int t; si(t);
    while(t--){
    	for(int i=0;i<MAXN;i++)AdjList[i].clear();
        fill(maxPath,maxPath+MAXN,0);
        fill(depth,depth+MAXN,0);
    	ReadInput();
    	solve();
    }
	return 0;
}