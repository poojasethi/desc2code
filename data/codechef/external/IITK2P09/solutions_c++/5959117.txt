// An AVL tree node
/*------------------------Subham Mishra--------------------------------------------------------*/
#include<bits/stdc++.h>
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define pl(n) printf("%lld\n",n)
#define p(n) printf("%d\n",n)
#define pb push_back
#define mp make_pair
#define mod 1000000007LL
#define N 200005
#define LN 25
#define SQN 5000
#define SQN1 500100000000000
#define ll  long long
#define gc getchar_unlocked
using namespace std;
int depth[N];
ll ans;
vector<int>adj[N];
stack<int>s1;
int vis[N],parent[N],maxv[N];
void dfs(int curr)
{
   s1.push(curr);
   vis[curr]=1;
   while(!s1.empty())
   {
    int val=s1.top();
    int f=0;
    if(vis[val]==1)
    for(int i=0;i<adj[val].size();++i)
    {
      vis[val]=2;
      if(vis[adj[val][i]]==0)
      {
      f=1;
      parent[adj[val][i]]=val;
      s1.push(adj[val][i]);
      vis[adj[val][i]]=1;
      }
    }
    if(f)
    continue;
    if(val!=0)
    depth[parent[val]]=max(depth[parent[val]],depth[val]+1);
    s1.pop();
   }

}
void dfs2(int curr)
{
queue<int>q;
memset(maxv,0,sizeof(maxv));
  int firm,secm,i;
  memset(vis,0,sizeof(vis));
  vis[curr]=1;
  q.push(curr);
  while(!q.empty())
  {
  int val=q.front();
  ans+=max(depth[val],maxv[val]);
  q.pop();
  firm=maxv[val];
  secm=0;
  for(i=0;i<adj[val].size();++i)
  {
     if(vis[adj[val][i]]==0)
     {
       if(depth[adj[val][i]]+1>firm)
       {
         secm=firm;
         firm=depth[adj[val][i]]+1;
       }
       else if(depth[adj[val][i]]+1>secm)
       secm=depth[adj[val][i]]+1;
     }
  }
  for(i=0;i<adj[val].size();++i)
  {
     if(vis[adj[val][i]]==0)
     {
       if(depth[adj[val][i]]+1==firm)
       {
       maxv[adj[val][i]]=secm+1;
       vis[adj[val][i]]=1;
       q.push(adj[val][i]);
       }
       else
       {
       maxv[adj[val][i]]=firm+1;
       vis[adj[val][i]]=1;
       q.push(adj[val][i]);
       }
     }
  }
  }
}
/*void hld(int curr,int prev)
{
 int i;
 chains[chainno].pb(curr);
 int sc=-1;
 for(i=0;i<adj[curr].size();++i)
  if(adj[curr][i]!=prev)
  if(sc==-1||(subsize[adj[curr][i]]>subsize[sc]))
  {
   sc=adj[curr][i];
  }
  if(sc!=-1)
  hld(sc,curr);
  for(i=0;i<adj[curr].size();++i)
  if(adj[curr][i]!=prev)
   if(sc!=adj[curr][i])
   {
    chainno++;
    hld(adj[curr][i],curr);
   }

}*/
int main()
{
 int t,i,j,n1,n2;
 int n;
 s(t);
 while(t--)
 {
   s(n);
   ans=0;
   for(i=0;i<n;++i)
   adj[i].clear();
   for(i=0;i<n-1;++i)
   {
    s(n1);s(n2);
    //assert(n1!=n2);
    n1--;
    n2--;
    adj[n1].pb(n2);
    adj[n2].pb(n1);
   }
   while(!s1.empty())
   s1.pop();
   memset(vis,0,sizeof(vis));
   memset(depth,0,sizeof(depth));
   dfs(0);
   /*for(i=0;i<n;++i)
   cout<<depth[i]<<" ";
   cout<<endl;*/
   dfs2(0);
   double fans=((double)ans*1.0/n*1.0);
   if(fans<0.0)
   exit(0);
   printf("%0.6lf\n",fans);
 }
}
