#include <bits/stdc++.h>
#define Max 1000

using namespace std;

bool isPrime[Max+5];
vector <int> smallPrimes;
bool valid[Max+5];
int existed[Max+5];
vector <int> currentPrimes;
int sz,n,T,cas;
int arr[Max+5],nxt[Max+5];
int dp[Max+5][(1<<12)];
int visited[Max+5][(1<<12)];

struct stype{
    int mask,big;
}s[Max+5];

bool mycomp(stype x,stype y)
{
    return (x.big<y.big);
}

int f(int pos,int curMask)
{
    if(pos==n) return 0;
    if(visited[pos][curMask]==cas) return dp[pos][curMask];

    visited[pos][curMask]=cas;

    int r = f(pos+1,curMask);

    if((s[pos].mask & curMask)==0 ) r= max( r , 1+f(nxt[pos],curMask | s[pos].mask));

    return dp[pos][curMask]=r;
}

int main()
{
    int i,j,k,ret;

    memset(isPrime,1,sizeof(isPrime));

    for(i=2;i*i<=Max;i++)
    {
        if(!isPrime[i]) continue;

        for(j=i*i;j<=Max;j+=i) isPrime[j]=0;
        smallPrimes.push_back(i);

    }

    //freopen("input.txt","r",stdin);
   // freopen("out.txt","w",stdout);

    scanf("%d",&T);


    for(cas=1;cas<=T;cas++)
    {
        scanf("%d",&n);

        for(i=0;i<n;i++)    scanf("%d",&arr[i]);

        // big is the prime which is bigger that 31. There can be only one big prime for each number.

        for(i=0;i<n;i++)
        {
            s[i].mask=0;
            s[i].big=arr[i];

            for(j=0;j<smallPrimes.size();j++)
            {
                if(s[i].big%smallPrimes[j]) continue;
                s[i].mask|=(1<<j);

                while(s[i].big%smallPrimes[j]==0) s[i].big/=smallPrimes[j];
            }
        }

        // Sort according to the big prime so that numbers with same big primes are together

        sort(s,s+n,mycomp);

        if(n) nxt[n-1]=n;
        // When we take a number if that has a big prime , for the next state of the DP skip all the numbers with that big prime
        for(i=n-2;i>=0;i--)
        {
            if(s[i].big==1 || s[i].big!=s[i+1].big) nxt[i]=i+1;
            else nxt[i]=nxt[i+1];
        }

        printf("%d\n",ret+f(0,0));


    }

    return 0;
}
