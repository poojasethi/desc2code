#include <bits/stdc++.h>
#define Max 1000

using namespace std;

bool isPrime[Max+5];
vector <int> smallPrimes;
bool valid[Max+5];
int existed[Max+5];
vector <int> currentPrimes;
int sz,n,T,cas;
int arr[Max+5],nxt[Max+5];
int dp[Max+5][(1<<12)];
int visited[Max+5][(1<<12)];

struct stype{
    int a,mask,big;
}s[Max+5];

bool mycomp(stype x,stype y)
{
    return (x.big<y.big);
}

int f(int pos,int curMask)
{
    if(pos==n) return 0;
    if(visited[pos][curMask]==cas) return dp[pos][curMask];

    visited[pos][curMask]=cas;

    int r = f(pos+1,curMask);

    if((s[pos].mask & curMask)==0 ) r= max( r , 1+f(nxt[pos],curMask | s[pos].mask));

    return dp[pos][curMask]=r;
}

int main()
{
    int i,j,k,ret;

    memset(isPrime,1,sizeof(isPrime));

    for(i=2;i*i<=Max;i++)
    {
        if(!isPrime[i]) continue;

        for(j=i*i;j<=Max;j+=i) isPrime[j]=0;
        smallPrimes.push_back(i);

    }

    //freopen("input.txt","r",stdin);
   // freopen("out.txt","w",stdout);

    scanf("%d",&T);


    for(cas=1;cas<=T;cas++)
    {
        currentPrimes.clear();

        scanf("%d",&n);
        for(ret=i=0;i<n;i++) valid[i]=1;

        for(i=0;i<n;i++)
        {

            scanf("%d",&arr[i]);
            k=arr[i];

            if(k==1)
            {
                ret++;
                valid[i]=0;
                continue;
            }

            if(existed[k]==cas) valid[i]=0;

            else
            {
                existed[k]=cas;

                if(isPrime[k])
                {
                    ret++;
                    currentPrimes.push_back(k);
                    valid[i]=0;
                }

            }
        }

        for(i=0;i<n;i++)
        {
            if(valid[i])
            {
                for(j=0;j<currentPrimes.size();j++)
                {
                    k=currentPrimes[j];

                    if(arr[i]%k==0) break;
                }

                if(j<currentPrimes.size()) valid[i]=0;
            }
        }

        int sz=0;

        for(i=0;i<n;i++)
        {
            if(!valid[i]) continue;
            arr[sz]=arr[i];
            sz++;
        }

        n=sz;

        for(i=0;i<n;i++)
        {
            k=s[i].a=arr[i];
            s[i].mask=0;
            s[i].big=k;

            for(j=0;j<smallPrimes.size();j++)
            {
                if(k%smallPrimes[j]) continue;
                s[i].mask|=(1<<j);

                while(s[i].big%smallPrimes[j]==0) s[i].big/=smallPrimes[j];
            }

            //cout<<s[i].a<<" "<<s[i].big<<" "<<s[i].mask<<endl;

        }

        sort(s,s+n,mycomp);

        if(n) nxt[n-1]=n;

        for(i=n-2;i>=0;i--)
        {
            if(s[i].big==1 || s[i].big!=s[i+1].big) nxt[i]=i+1;
            else nxt[i]=nxt[i+1];
        }

        printf("%d\n",ret+f(0,0));


    }

    return 0;
}
