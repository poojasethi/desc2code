// Author: suh_ash2008
#include <iostream>
#include <cstdio>
#include <cctype>
#include <string>
#include <cmath>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue>
#include <map>
#include <set>
#include <sstream>
#include <fstream>
#include <ctime>
#include <cassert>
#include <string.h>

using namespace std;

#define GI ({int t;scanf("%d",&t);t;})
#define GL ({LL t;scanf("%lld",&t);t;})
#define GD ({double t;scanf("%lf",&t);t;})
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
#define ROF(i,a,b) for(int i=a;i>b;i--)
#define SET(x,a) memset(x,a,sizeof(x))
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define tr(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)
#define pb push_back
#define sz(a) (int)(a.size())
#define INF (int)1e9
#define EPS (double)1e-9

#define is istringstream
#define os ostringstream
#define lb lower_bound
#define ub upper_bound
#define bs binary_search

typedef unsigned long long ULL;
typedef long long LL;
typedef set <int> si;
typedef pair< LL,LL > ii;
typedef pair< LL, ii > pi;
typedef vector< ii > vii;
typedef vector < vii > vvii;
typedef vector< int > vi;
typedef vector< vi > vvi;

#define MAXN 300000+5
#define MOD 1000000007
			

int tmax[2*MAXN];
int tmin[2*MAXN];
int xs[2*MAXN];
int a[MAXN];
int p[MAXN];
int q[MAXN];
int lcm[MAXN];

inline void update(int lo, int hi, int lo1, int hi1, int dp, int i){
	if(lo>hi1 || hi<lo1)	return;
	if(lo>=lo1 && hi<=hi1){
		tmax[i]+=dp;
		tmin[i]+=dp;
		xs[i]+=dp;
		return;
	}
	int mid=(lo+hi)>>1,i2=(i<<1);
	update(lo,mid,lo1,hi1,dp,i2+1);
	update(mid+1,hi,lo1,hi1,dp,i2+2);
	tmax[i]=max(tmax[i2+1],tmax[i2+2])+xs[i];
	tmin[i]=min(tmin[i2+1],tmin[i2+2])+xs[i];
}

inline void build(int lo, int hi, int i){
	if(lo==hi){
		tmax[i]=a[lo];
		tmin[i]=a[lo];
		return;
	}
	int mid=(lo+hi)>>1,i2=(i<<1);
	build(lo,mid,i2+1);
	build(mid+1,hi,i2+2);
	tmax[i]=max(tmax[i2+1],tmax[i2+2]);
	tmin[i]=min(tmin[i2+1],tmin[i2+2]);
}

inline int query(int lo, int hi, int lo1, int hi1, int prop, int i, int flag){
	if(lo>hi1 || hi<lo1){
		if(flag)	return -1;
		return INF;
	}
	if(lo>=lo1 && hi<=hi1){
		if(flag)	return tmax[i]+prop;
		return tmin[i]+prop;
	}
	int mid=(lo+hi)>>1,i2=(i<<1);
	int m1=query(lo,mid,lo1,hi1,prop+xs[i],i2+1,flag), m2=query(mid+1,hi,lo1,hi1,prop+xs[i],i2+2,flag);
	if(flag)	return max(m1,m2);
	return min(m1,m2);
}

// FAST I/O
#define MAXX 10000000
char *ipos, *opos, InpFile[MAXX], OutFile[MAXX], DIP[30];
inline int input_int(int flag = 0){
	while(*ipos <= 32)    ++ipos;
	if ( flag  ) return (*ipos++ - '0');
	int x = 0, neg = 0; char c;
	while( true ) {
		c = *ipos++; if(c == '-')    neg = 1;
		else{
			if(c <= 32)    return neg ? -x : x;
			x = (x << 1) + (x << 3) + c - '0';
		}
	}
}
inline LL input_LL(int flag = 0){
	while(*ipos <= 32)    ++ipos;
	if ( flag  ) return (*ipos++ - '0');
	LL x = 0, neg = 0; char c;
	while( true ) {
		c = *ipos++; if(c == '-')    neg = 1;
		else{
			if(c <= 32)    return neg ? -x : x;
			x = (x << 1) + (x << 3) + c - '0';
		}
	}
}
inline void input_st(char *s){
	while(*ipos <= 32)    ++ipos;
	int pos = 0;char c;
	while( true ) {
		c = *ipos++;
		if(c <= 32)    {s[pos] = '\0'; break;}
		else s[pos++] = c;
	}
}
inline void output(int x){
	int y;
	int dig = 0;
	while(x || !dig)    {y = x / 10; DIP[dig++] = x - ((y << 3) + (y << 1)) + '0'; x = y;}
	while(dig--)    *opos++ = DIP[dig];
}
inline void InitFASTIO(){
	ipos = InpFile; opos = OutFile;
	fread_unlocked(InpFile, MAXX, 1, stdin);
}
inline void FlushFASTIO(){
	fwrite_unlocked(OutFile, opos - OutFile, 1, stdout);
}
//End of FAST I/O

int main(){
	p[0]=p[1]=1;
	FOR(i,2,MAXN){
		if(!p[i]){
			for(int j=i+i;j<MAXN;j+=i)	p[j]=1;
			for(LL x=i;x<MAXN;x*=i)		q[x]=i;
		}
	}
	lcm[0]=1;
	FOR(i,1,MAXN){
		lcm[i]=lcm[i-1];
		if(q[i])	lcm[i]=(lcm[i]*LL(q[i]))%MOD;
	}
	lcm[0]=0;
	InitFASTIO();
	int n=input_int(),m=input_int();
	REP(i,n)	a[i+1]=input_int();
	build(1,n,0);
	int x,l,r,dp,v;
	REP(i,m){
		x=input_int(),l=input_int()+1,r=input_int()+1;
		if(x==0){
			dp=input_int();
			update(1,n,l,r,dp,0);
		}
		else{
			v=query(1,n,l,r,0,0,x&1);
			output(lcm[v]);
			*opos++='\n';
		}
	}
	FlushFASTIO();
	//GI;
	return 0;
}
