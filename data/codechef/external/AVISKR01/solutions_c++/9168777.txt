/*itamiyo uketore ,itamiyo sire  */
#include <bits/stdc++.h>
#define ff first
#define re return
#define ss second
#define pb push_back
#define mpk make_pair
#define couts(a) cout<<a<<endl
#define pno cout<<"NO"<<endl
#define fr(i,a,b) for(ll i=a;i<b;++i)
#define cina(a,n) fr(i,0,n)cin>>a[i]
#define rf(i,a,b) for(ll  i=a;i>=b;--i)
#define pyes cout<<"YES"<<endl
#define coutd(a,b) cout<<a<<" "<<b<<endl
#define ioS ios_base::sync_with_stdio(0);cin.tie(0);
#define coutt(a,b,c)cout<<a<<" "<<b<<" "<<c<<endl;
#define coutar(a,n)  fr(i,0,n)cout<<a[i]<<" ";cout<<endl;
#define coutq(a,b,c,d)cout<<a<<" "<<b<<" "<<c<<" "<<d<<endl;

using namespace std;
typedef long long int ll;
typedef long double ld;
typedef pair<int,int>pi;
typedef long long int ll;
typedef vector<int> vi;

const int MAXN = 100005;
const ll MOD = 1000000007LL;

ll lcm[3*MAXN], small[3*MAXN];
int arr[MAXN];

struct Node {
  int Min,Max,lazy;
} sq[4*MAXN];

void sieveprecal()
 {
   lcm[0] = 0, lcm[1] = 1;
   for(int i=2; i<3*MAXN; ++i)
    {
    if(!small[i])
       {
            for(int j=i; j<3*MAXN; j+=i) small[j] = i;
        }
    int p = small[i], j;
    for(j=i; j%p==0; j/=p);

    if(j == 1) lcm[i] = (lcm[i-1]*(ll)p) % MOD;
     else lcm[i] = lcm[i-1];
   }

}
int ma, mi;

void init(int p, int lo, int hi)
{
  if(lo == hi) sq[p].Min = sq[p].Max = arr[lo];

  else
{
        int mid = (lo+hi)/2;
    init(2*p, lo, mid);
    init(2*p+1, mid+1, hi);

    sq[p].Min = min(sq[2*p].Min, sq[2*p+1].Min);
    sq[p].Max = max(sq[2*p].Max, sq[2*p+1].Max);

  }
}

void lazyp(int p, int lo, int hi)
{
  if(sq[p].lazy)
    {

    sq[2*p].Min += sq[p].lazy, sq[2*p+1].Min += sq[p].lazy;
    sq[2*p].Max += sq[p].lazy, sq[2*p+1].Max += sq[p].lazy;
    sq[2*p].lazy += sq[p].lazy, sq[2*p+1].lazy += sq[p].lazy;
    }

  sq[p].lazy = 0;
}

void update(int p, int lo, int hi, int i, int j, int key)
{
  if(lo == i && hi == j)
{

    sq[p].Min += key;
    sq[p].Max += key;
    sq[p].lazy += key;
     re;
}

  lazyp(p, lo, hi);
   int mid = (lo+hi)/2;

  if(j <= mid) update(2*p, lo, mid, i, j, key);
  else if(i > mid) update(2*p+1, mid+1, hi, i, j, key);
  else
    {
    update(2*p, lo, mid, i, mid, key);
    update(2*p+1, mid+1, hi, mid+1, j, key);

   }

  sq[p].Min = min(sq[2*p].Min, sq[2*p+1].Min);
  sq[p].Max = max(sq[2*p].Max, sq[2*p+1].Max);
}

void query(int p, int lo, int hi, int i, int j)
{
  if(lo == i && hi == j)
    {
    mi = min(sq[p].Min, mi);
    ma = max(sq[p].Max, ma);
    re;
    }

  lazyp(p, lo, hi);
  int mid = (lo+hi)/2;

  if(j <= mid) query(2*p, lo, mid, i, j);
  else if(i > mid) query(2*p+1, mid+1, hi, i, j);
  else
    {
    query(2*p, lo, mid, i, mid);
    query(2*p+1, mid+1, hi, mid+1, j);

    }
}

int main() {
ioS;
  int n,q;

 cin>>n>>q;
 cina(arr,n);

  sieveprecal();
   init(1, 0, n-1);

  while(q--)
{
    int t, i, j, p;
    cin>>t>>i>>j;

    if(t == 0)
    {
         cin>>p;
         update(1, 0, n-1, i, j, p);
    }
    else
        {

      mi =  INT_MAX;
      ma = -INT_MAX;
      query(1, 0, n-1, i, j);
     // coutd(maximum,minimum)
      if(t == 1) couts( lcm[ma]);
      else couts( lcm[mi]);
      }

  }
}




