#!/usr/bin/python
# coding=utf8
import sys
import math
from time import time
from itertools import permutations, combinations
import collections
import functools
from fractions import gcd, Fraction
import string
import random


class timed(object):
    def __init__(self, func):
        self.func = func
    def __call__(self, *args):
        t1 = time()
        ret = self.func(*args)
        dif_time = time() - t1
        print "%s: returned %s in %f seconds" % (self.func.__name__, ret, dif_time)
        return ret


def comp(f1, f2, *args):
    t1 = time()
    r1 = f1(*args) if f1 is not None else None
    t2 = time()
    r2 = f2(*args) if f2 is not None else None
    t3 = time()
    res = "%5s: %s in %f\n%5s: %s in %f" % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2)
    if r1 != r2:
        dr = "!! DIFFERENT RESULTS !!"
        res = dr + "\n" + res + "\n" + dr
    print res


def alg(N, M):
    m1 = [list([0] * M) for i in xrange(N)]
    m2 = [list([0] * M) for i in xrange(N)]
    v = 1
    for i in xrange(N):
        for j in xrange(M):
            m1[i][j] = v
            v += 1
    v = 1
    for j in xrange(M):
        for i in xrange(N):
            m2[i][j] = v
            v += 1

    res = 0
    for i in xrange(N):
        for j in xrange(M):
            if m1[i][j] == m2[i][j]:
                res += 1
    return res


def alg2(N, M):

    if N <=1 or M <= 1:
        return 1

    #m1 = [list([0] * M) for i in xrange(N)]
    #m2 = [list([0] * M) for i in xrange(N)]
    #for i in xrange(N):
    #    for j in xrange(M):
    #        m1[i][j] = 1 + i*M + j
    #        m2[i][j] = 1 + i + N*j

    # Aij = 1 + j + i*M
    # Bij = 1 + i + j*N
    # trouver Aij = Bij
    # 1+j+i*M = 1+i+j*N
    # inconnue : i, j, integers
    # i+j*N-j-i*M = 0
    # i(1-M) + j(N-1) = 0
    # ax+by=0
    # res : i=j=0
    # pour tous les i, si j est entier >= 0, alors c'est bon
    # j = i(M-1)/(N-1)
    # donc i doit est multiple de N-1
    # donc i(M-1) doit etre multiple de N-1

    # solve k for k(M-1) = 0 mod (N-1)


    res = 0
    for i in xrange(N):
        if i*(M-1) % (N-1) == 0:
            res += 1
            #j = i*(M-1)/(N-1)
            #print "we have a case here:", i, j, m1[i][j], m2[i][j]


    #res = 0
    #for i in xrange(N):
    #    for j in xrange(M):
    #        if m1[i][j] == m2[i][j]:
    #            res += 1
    return res


def alg3(N, M):

    # first we reduce
    #d = gcd(N, M)
    #N /= d
    #M /= d

    if N <=1 or M <= 1:
        return max(M, N)

    if M == N:
        return M

    return gcd(N-1, M-1) + 1


def main():
    data = sys.stdin
    nb = int(data.readline())
    #random.seed(0)

    #comp(alg2, alg3, 100, 103)

    #for i in xrange(100, 500):
    #    for j in xrange(100, 500):
    #        comp(alg2, alg3, i, j)

    #comp(alg, alg3, 2, 100)
    #for i in xrange(100):
    #    comp(alg3, alg2, random.randint(1, 1000), random.randint(1, 1000))
    #comp(alg2, alg3, 1987654, 986000)
    for icase in xrange(nb):
        N, M = map(int, data.readline().split())  # int
        #L = map(float, data.readline().split())  # float
        #L = data.readline().split()  # string
        #s = data.readline().strip()
        #i = int(data.readline().strip())
        res = alg3(N, M)
        print res


if __name__ == "__main__":
    main()
