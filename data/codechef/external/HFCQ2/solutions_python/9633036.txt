
using namespace std;
#include <bits/stdc++.h>
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define wl(n) while(n--)
#define ll long long
#define P(x) printf("%d\n",x)
#define PB push_back
#define MP make_pair
#define fl(i,n) for(i=0;i<n;i++)
#define fil(i,a,n) for(i=a;i<n;i++)
#define rev(i,a,n) for(i=n-1;i>=a;i--)
#define mem(a,i) memset(a,i,sizeof(a))
#define F first
#define S1 second
typedef pair<int,int> P;
vector<int> v1;
pair<int,int> p1;
#define MOD 1000000007
#define debug(x)  printf("####%d####\n",x);
#define nl printf("\n");
#define str string
int a[1234567];
string s;
int dp[1001];
ll pow1(ll x,ll y)
{
    if(y==0)
    return 1;
    ll temp= pow1(x,y/2)%MOD;
    if(y%2==0)
    return (temp*temp)%MOD;
    else
    return (((temp*temp)%MOD)*x)%MOD;
}
int prime[100008];
void sieve()
{
    prime[0]=1;
    prime[1]=1;
    int i,j;
    for(i=2;i*i<=100000;i++)
    {
        if(!prime[i])
        {
            for(j=i*i;j<=100000;j+=i)
                prime[j]=1;
        }
    }
    j=0;
    for(i=0;i<100000;i++)
    {
        if(!prime[i])
        {
            prime[j]=i;
            j++;
        }
    }
    // cout<<j<<endl;
}
// miller rabin starts
long long mod=1e9+7;
inline long long multiply(long long a,long long b){
    a %= mod;
    b %= mod;
    long double res = a;
    res *= b;
    long long c = (long long)(res / mod);
    a *= b;
    a -= c * mod;
    a %= mod;
    if (a < 0) a += mod;
        return a;
}

inline long long power(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1)
            ans=multiply(ans,a);
        a=multiply(a,a);
        b>>=1;
    }
    return ans;
}
int b[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
inline bool Miller(long long p){
    if(p<2) return false;
    if(p!=2 && !(p&1)) return false;

    for(int i=0;i<25;i++){
        if(p==b[i])return true;
        else if(p%b[i]==0)return false;
    }

    int count = 0;
    long long s=p-1;
    while(!(s&1)){
        s/=2;
        count++; //p-1 = 2^s*d here count is s and d is remaining s
    }

    long long accuracy=40; //increase accuarcy to get more accurate answer
    for(int i=0;i<accuracy;i++){
        long long a=rand()%(p-1)+1;
        mod=p;
        long long x=power(a,s);
        if(x == 1 || x == p-1) continue;
        int flag = 0;
        for(int i = 1; i < count; i++){
            x = multiply(x,x);
            //if(x == 1) return false;
            if(x == p-1){
                flag = 1;
                break;
            }
        }
        if(flag) continue;
        return false;
    }
    return true;
}
// miller rabin ends
ll func(ll k)
{
    int i,j=9592,ans=0;
    fl(i,j)
    {
        if(k<1)
            break;
        if(k%prime[i]==0)
        {
            k/=prime[i];
            ans++;
        }
    }
    if(k==1)
        return ans;
    if(Miller(k))
        return ans+1;
    return ans+2;
}
int main()
{
    //std::ios_base::sync_with_stdio(false);
    int t;
    int n,i,j,k,m,l;
    sieve();
    S(t);
    wl(t)
    {
        ll n,k;
        cin>>n>>k;
        ll x=func(k);
        ll y=func(n);
        x=pow1(2ll,x);
        ll ans=pow1((x+1),y);
        cout<<ans<<"\n";
    }
    return 0;
}
