#include <bits/stdc++.h>
#define ll long long int
#define pb push_back
#define mp make_pair
#define s(x) scanf("%lld", &x)
using namespace std;
#define VALUETYPE long long int
#define EVEN(x) ((x&1)==0)
#define ODD(x) ((x&1)==1)

//  Compute x^n mod y in a quick way.
VALUETYPE PowerMod(VALUETYPE x, VALUETYPE y, VALUETYPE n) {
	if (n == 0) return 1;
	if (n == 1) return x;
	if EVEN(n) return PowerMod(x*x%y, y, n/2) % y;
	return PowerMod(x*x%y, y, n/2) * x % y;
}

//  If n is a prime
bool Miller_Rabin(VALUETYPE n) {
	if (n == 2) return true;
	if ((n<2)||EVEN(n)) return false;
	VALUETYPE d;
	d = n-1;
	while EVEN(d) d = d >> 1;
	VALUETYPE base[12] = { 2, 3, 5, 7, 11, 13, 17,19,23,29,31,37};
	int td, t;
	for (int i=0; i<12; i++) {
		if (base[i] >= n) break;
		td = d;
		t = PowerMod( base[i], n, td);
		while ((td!=n-1)&&(t!=1)&&(t!=n-1)) {
			t = t*t % n;
			td = td << 1;
		}
		if ((t == n-1)||ODD(td)) ; else return false;
	}
	return true;
}

ll mulmod (ll a, ll b, ll mod)
{
	ll x = 0,y = a % mod;
	while (b > 0) {
		if (b&1)
			x = (x + y) % mod;

		y = (y * 2) % mod;
		b /= 2;
	}
	return x;
}

ll bin(ll a, ll b, ll M)
{
	ll x = 1;
	ll y = a;

	while(b > 0) {
		if(b&1)
			x = mulmod(x, y, M);
		y = mulmod(y, y, M);

		b/= 2;
	}

	return x;
}
ll arr[12] = { 2, 3, 5, 7, 11, 13, 17,19,23,29,31,37};
bool isprime(ll p)
{
	if (p < 2)
		return false;
	if (p != 2 && p % 2==0)
		return false;

	ll s = p - 1;
	while (s % 2 == 0)
		s /= 2;
	int i;
	for (i = 0; i < 12; i++) {
		ll a = arr[i] % (p - 1) + 1, temp = s;
		ll mod = bin(a, temp, p);

		while ((temp != p-1) && (mod != 1) && (mod != p-1)) {
			mod = mulmod(mod, mod, p);
			temp *= 2;
		}

		if (mod != p-1 && temp%2 == 0)
			return false;
	}
	return true;
}


bool prime[1000001];

vector<int> v;
void sieve() {
	memset(prime,true,sizeof(prime));
	prime[0] = false;prime[1] = false;
	for (int p=2; p*p<= 1000000; p++)
	{
		if (prime[p] == true)
		{
			for (int i=p*2; i<=1000000; i += p) {
				prime[i] = false;
			}
		}
	}

	for (int i = 0; i < 1000001; i++) {
		if (prime[i]) {
			v.push_back(i);
		}
	}
}
#define mod (ll)(1e9 + 7)

ll power (ll a, ll b)
{
	if (b == 0)
		return 1;
	ll x = power(a, b/2);
	if (b % 2 == 0)
		return (x*x)%mod;
	else
		return (((x*x)%mod)*a)%mod;
}

int main()
{
	sieve();
	ll test,n,k;
	s(test);

	while (test--) {
		s(n);s(k);
		ll nprimes = 0,kprimes = 1;
		ll tempn = n,tempk = k;
		for (int i = 0; i < v.size(); i++) {
			if (n < v[i]* v[i]) {
				break;
			}
			if (n % v[i] == 0) {
				n /= v[i];
				nprimes += 1;
			}
		}
		for (int i = 0; i < v.size(); i++) {
			if (k < v[i] * v[i]) {
				break;
			}
			if (k % v[i] == 0) {
				k /= v[i];
				kprimes *= 2;
			}
		}
		if (n > 1) {
			if (isprime(n)) {
				nprimes += 1;
			} else {
				nprimes += 2;
			}
		}
		if (k > 1) {
			if (isprime(k)) {
				kprimes *= 2;
			} else {
				kprimes *= 4;
			}
		}
		//		cout << nprimes << " " << kprimes << endl;
		ll ans = power((kprimes + 1) % mod,nprimes % mod);
		ans %= mod;

		printf("%lld\n",ans);
	}
	return 0;
}
