#include <bits/stdc++.h>
 
using namespace std;
 
#define ll long long
#define pb push_back
#define mp make_pair
#define pii pair< int , int >
#define vii vector< int >
#define ff first
#define ss second
#define rep(i,n) for(int i=0;i<n;i++)
#define frep(i , a , b) for(int i = a;i <= b;i++)
#define fast cin.sync_with_stdio(0);cin.tie(0);
#define CASES int t;cin >> t;while(t--)
typedef unsigned long long ULL;
 
const ll MOD = 1e9 + 7;
 
ll modular_pow(ll base, ll exponent, ll modulus)
{
	/* initialize result */
	ll result = 1;
 
	while (exponent > 0)
	{
		/* if y is odd, multiply base with result */
		if (exponent & 1)
			result = (result * base) % modulus;
 
		/* exponent = exponent/2 */
		exponent = exponent >> 1;
 
		/* base = base * base */
		base = (base * base) % modulus;
	}
	return result;
}
 
/* method to return prime divisor for n */
ULL mulmod(ULL a, ULL b, ULL c) {
	ULL x = 0, y = a % c;
 
	while (b > 0) {
		if (b & 1) x = (x + y) % c;
		y = (y << 1) % c;
		b >>= 1;
	}
 
	return x;
}
 
ULL pow(ULL a, ULL b, ULL c) {
	ULL x = 1, y = a;
 
	while (b > 0) {
		if (b & 1) x = mulmod(x, y, c);
		y = mulmod(y, y, c);
		b >>= 1;
	}
 
	return x;
}
 
bool miller_rabin(ULL p, int it) {
	if (p < 2) return false;
	if (p == 2) return true;
	if ((p & 1) == 0) return false;
 
	ULL s = p - 1;
	while (s % 2 == 0) s >>= 1;
	it = 2;
	while (it--) {
		ULL a = rand() % (p - 1) + 1, temp = s;
		ULL mod = pow(a, temp, p);
 
		if (mod == -1 || mod == 1) continue;
 
		while (temp != p - 1 && mod != p - 1) {
			mod = mulmod(mod, mod, p);
			temp <<= 1;
		}
 
		if (mod != p - 1) return false;
	}
 
	return true;
}
 
 
ll ff(ll n)
{
	ll cbr = pow(n, 1.0 / 3.0), res = 0;
	ll m = n;
	// number of factors less than cube root
	// calculate power of prime and multiply res by +1
	frep(i, 2, cbr)
	{
		if(m<=1)
			break;
		if (m % i == 0)
		{
			ll temp = 0;
			// res++;
			while (m % i == 0)
			{
				temp++;
				m /= i;
			}
			res++;
			// res%=mod;
		}
	}
	if (m > 1 && miller_rabin(m, 5))
		res++;
	else
	{
		if (m > 1)
			res += 2;
	}
 
	return modular_pow(2,res,MOD);
}
 
 
ll ff1(ll n, ll k)
{
	ll cbr = pow(n, 1.0 / 3.0), res = 0;
	ll m = n;
	// number of factors less than cube root
	// calculate power of prime and multiply res by +1
	frep(i, 2, cbr)
	{
		if(m<=1)
			break;
		if (m % i == 0)
		{
			ll temp = 0;
			// res++;
			while (m % i == 0)
			{
				temp++;
				m /= i;
			}
			res++;
			// res%=mod;
		}
	}
	if (m > 1 && miller_rabin(m, 5))
		res++;
	else
	{
		if (m > 1)
			res += 2;
	}
 
	return modular_pow(k+1,res,MOD);
}
 
 
int main()
{
	fast
	// cout<<miller_rabin(1,18)<<"\n";
	CASES
	{
		ll n, k;
		cin >> n >> k;
		ll pk = ff(k);
		// ll nppk = modular_pow(n, pk, MOD);
		// cout<<pk<<"\n";
		cout << ff1(n, pk) % MOD << "\n";
	}
	return 0;
} 