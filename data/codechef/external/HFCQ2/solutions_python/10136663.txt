//hamiltonian cycle
#include<bits/stdc++.h>
#define ll long long
#define maxe 2147483647
#define INF 1e16
#define si(x) scanf("%d",&x)
#define sl(x) scanf("%ld",&x)
#define sll(x) scanf("%lld",&x)
#define ss(x) scanf("%s",x)
#define pi(x) printf("%d\n",x)
#define pl(x) printf("%ld\n",x)
#define pll(x) printf("%lld\n",x)
#define ps(x) printf("%s\n",x)
#define iter(i,a,b) for(int i=a; i<b; i++)
#define ited(i,a,b) for(int i=a;i>b;i--)
#define mp make_pair 
#define pb push_back 
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
//#define pop pop_back 
#define mod 1000000007
using namespace std;
bool prime[1000001];
vector<int> vec;
void seivec()
{
	prime[0]=prime[1]=true;
	for(int i=2;i*i<1000001;i++)
		if(prime[i]==false)
			for(int j=2*i;j<1000001;j+=i)
				prime[j]=true;
	for(int i=2;i<1000001;i++)
		if(prime[i]==false)
			vec.pb(i);	
}
ll mulmd(ll a,ll b,ll n)
{
	ll an=0;
	while(b!=0)
	{
		if(b%2==1)
			an=(an+a)%n;
		a=(a+a)%n;
		b/=2;
	}
	return an;
}
ll powe(ll a,ll b,ll n)
{
	ll an=1;
	while(b!=0)
	{
		if(b%2==1)
			an=mulmd(an,a,n);
		a=mulmd(a,a,n);
		b/=2;
	}
	return an;
}
bool miller(ll n,ll d)
{
	ll a=2+rand()%(n-4);
	ll x=powe(a,d,n);
	if(x==1 || x==n-1) return true;
	while(d!=n-1)
	{
		x=mulmd(x,x,n);
		d*=2;
		if(x==1) return false;
		if(x==n-1) return true;
	}
	return false;
}
bool checkp(ll n)
{
	if(n<=1 && n==4) return false;
	if(n<=3)	return true;
	ll d=n-1;
	while(d%2==0)
		d/=2;
	int k=3;
	for(int i=0;i<k;i++)
		if(miller(n,d)==false) return false;
	return true;
}
ll calc(ll v)
{
	ll an=0;
	for(int i=0;i<vec.size();i++)
	{
		while(v%vec[i]==0)
		{
			v/=vec[i];
			an++;
		}
	}
	if(v==1) return an;
	if(checkp(v)) return an+1;
	else return an+2;
}
int main()
{
	seivec();
	int t;
	si(t);
	while(t--)
	{
		ll n,k;
		sll(n);sll(k);
		ll tmp1=calc(k);
		ll tmp2=calc(n);
		ll t1=powe(2,tmp1,mod);
		ll an=powe(t1+1,tmp2,mod);
		pll(an);
	}
	return 0;
}