#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include <queue>
#include <set>
#include <cassert>

using namespace std;

#define _ ios_base::sync_with_stdio(0);cin.tie(0);
#define S(x) 			scanf("%d",&x)
#define all(c) 			(c).begin(),(c).end() 
#define sz(c) 			int((c).size())
#define pb 				push_back
#define present(c,x) 	((c).find(x) != (c).end()) 
#define rep(i,x,y) 		for(int i = x; i < y; i++)
#define REV(i,x,y) 		for(int i = x; i >= y; i--)
#define foreach(c,itr)	for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)
#define FILL(a,v) 		memset(a,v,sizeof(a))
#define DB(x)			cerr<<#x<<" = "<<x<<endl
#define debugarr(A,a,b) cerr<<#A<<" : ";rep(i,a,b) cerr<<A[i]<<" ";cerr<<endl;
//#define R(x) 			((rand()%x) + 1)

typedef long long int LL;
typedef vector<int> vi; 
typedef vector<vi> vvi; 
typedef pair<int,int> ii;
typedef vector<ii> vii;

/* ------------------------Main Code----------------------- */
const int MAX = 1000001;

int A[MAX], idx, sqn, n;
struct bucket{
	LL sum, es, os;
	int e, o;
	int state;
} B[1001];

void breakBucket(int id, int l, int r, bool fe, bool fo)
{
	B[id].e = 0;
	B[id].o = 0;
	int end = min(n,(id+1)*sqn);
	rep(i,id*sqn,end){
		A[i] += A[i]&1 ? B[id].os : B[id].es;
	}
	rep(i,l,r+1){
		if( (A[i]&1) && fe){
			A[i]++;
			B[id].sum++;
		}
		else if( !(A[i]&1) && fo){
			A[i]++;
			B[id].sum++;
		}
	}
	rep(i,id*sqn,end)
		A[i]&1 ? B[id].o++: B[id].e++; 
	B[id].state = 0;
	B[id].es = B[id].os = 0;
}

LL query(int x, int y)
{
	LL res = 0;
	int l = x / sqn, r = y / sqn;
	//DB(sqn); DB(l); DB(r); DB(ts);
	if (l == r){
		breakBucket(l,x,y,0,0);
		rep(i,x,y+1) res += A[i];
	}
	else {
		breakBucket(l,x,(l+1)*sqn-1,0,0);
		for (int i = x, e = (l+1)*sqn-1; i <= e; ++i)
			res += A[i];
		for (int i = l+1; i<=r-1; ++i)
			res += B[i].sum;
		breakBucket(r,r*sqn,y,0,0);
		for (int i=r*sqn; i <= y; ++i)
			res += A[i];
	}
	return res;
}

void update(int x, int y, bool fe, bool fo)
{
	int l = x / sqn, r = y / sqn;
	//DB(sqn); DB(l); DB(r); DB(ts);
	if (l == r)
		breakBucket(l,x,y,fe,fo);
	else {
		breakBucket(l,x,(l+1)*sqn-1,fe,fo);
		for (int i = l+1; i<=r-1; ++i){
			int total = B[i].e + B[i].o;
			if(B[i].state == 0){
				if(fe && fo){
					B[i].sum += total;
					swap(B[i].e,B[i].o);
					B[i].es++; B[i].os++;
				}else if(fe){
					B[i].sum += B[i].o;
					B[i].state = 1;
					if(B[i].es & 1) B[i].es++;
					else B[i].os++;
				}else{
					B[i].sum += B[i].e;
					B[i].state = 2;
					if(B[i].es & 1) B[i].os++;
					else B[i].es++;
				}
			}else if(B[i].state == 1 && fo){
				B[i].sum += total;
				B[i].es++; B[i].os++;
				B[i].state = 2;
			}else if(B[i].state == 2 && fe){
				B[i].sum += total;
				B[i].os++; B[i].es++;
				B[i].state = 1;
			}
		}
		breakBucket(r,r*sqn,y,fe,fo);
	}
}

int main()
{

	S(n);
	sqn = sqrt(n + 0.0) + 1;
	idx = -1;

	rep(i,0,n){
		S(A[i]);
		if(i % sqn == 0) idx++;
		B[idx].sum += A[i];
		A[i]&1 ? B[idx].o++ : B[idx].e++;
	}
	//DB(idx); 
	idx++;
	int q; S(q);
	while(q--){
		// debugarr(A,0,n);
		// rep(i,0,idx) printf("%lld ",B[i].sum);
		// printf("\n");
		char type; cin >> type;
		int l, r; S(l); S(r); l--; r--;
		if(type == 'O'){
			update(l,r,0,1);
		}else if(type == 'E'){
			update(l,r,1,0);
		}else if(type == 'I'){
			update(l,r,1,1);
		}else{
			printf("%lld\n",query(l,r));
		}
	}

	return 0;
}