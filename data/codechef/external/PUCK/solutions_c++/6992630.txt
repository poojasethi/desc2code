/*-----square root decomposition with lazy propagation-----*/
#include<bits/stdc++.h>
//#define DEBUG
//#ifdef DEBUG
//code to debug
//#endif
//#undef DEBUG
using namespace std;
const int maxn=1000005,sz=1205;

const int mod=1e9+7;
#define F(i,p,n) for(int i=p;i<n;i++)
#define I(i,p,q) for(int i=p;i>=q;i--)
#define Ss(x) scanf("%s",x)
//#define S(x) scanf("%d",&x)
#define getcx getchar
inline void S(int& n)
{
    n=0; int ch = getcx(); int sign = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }
    while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }
    n = n * sign;
}
#define Ps(x) printf("%d  ",x)
#define P(x) printf("%d\n",x)
typedef long long int LL;
#define Bug(x) cout << #x << "=" << x << endl
#define pii pair<int,int>
#define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int
#define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit

LL sum[sz];
int arr[maxn],even[sz],odd[sz],cnt[sz],bsize;

int _sqrt(int n)
{
    int p=1,q=1005;
    while(p!=q)
    {
        int m=(p+q)>>1;
        if(m*m<n)
            p=m+1;
        else
            q=m;
    }
    return p;
}

int _size(int q,int n)
{
    return min(n-q*bsize,bsize);
}

int bucketNo(int ind)
{
    return ind/bsize;
}

void _build(int n)
{
    int p,q=0,ptr=0;
    while(ptr<n)
    {
        p=0;
        while(p<bsize&&ptr<n)
        {
            if(!(arr[ptr]&1))
                cnt[q]++;

            sum[q]+=arr[ptr];
            ptr++;
            p++;

        }
        q++;
    }
    /*F(i,0,(n+bsize-1)/bsize)
    {
        Bug(sum[i]);
        Bug(cnt[i]);
        printf("\n");
    }*/
}

void update(int q,int n)
{
    F(i,q*bsize,min(n,(q+1)*bsize))
    if(arr[i]&1)
        arr[i]+=odd[q];
    else
        arr[i]+=even[q];
    even[q]=odd[q]=0;
}

void _updateO(int l,int r ,int n)
{
    int q=l/bsize;
    if(l<=r)
    update(q,n);
    while(l<(q+1)*bsize&&l<=r)
    {
        if(!(arr[l]&1))
        {
            cnt[q]--;
            sum[q]++;
            arr[l]++;
        }
        l++;
    }
    l--;
    while(l+bsize<=r)
    {
        ++q;
        sum[q]+=cnt[q];
        if(even[q]%2==0)
            even[q]++;
        if((1+odd[q])%2==0)
            odd[q]++;
        l+=bsize;
        cnt[q]=0;
    }
    l++;
    if(l<=r)
    update(++q,n);
    while(l<=r)
    {
        if(!(arr[l]&1))
        {
            cnt[q]--;
            sum[q]++;
            arr[l]++;
        }
        l++;
    }
}

void _updateE(int l,int r ,int n)
{
    int q=l/bsize;
    if(l<=r)
    update(q,n);
    while(l<(q+1)*bsize&&l<=r)
    {
        if((arr[l]&1))
        {
            cnt[q]++;
            sum[q]++;
            arr[l]++;
        }
        l++;
    }
    l--;
    while(l+bsize<=r)
    {
        ++q;

        sum[q]+=_size(q,n)-cnt[q];

        if(even[q]%2)
            even[q]++;
        if((1+odd[q])%2)
            odd[q]++;
        l+=bsize;
        cnt[q]=_size(q,n);
    }
    l++;
    if(l<=r)
    update(++q,n);
    while(l<=r)
    {
        if((arr[l]&1))
        {
            cnt[q]++;
            sum[q]++;
            arr[l]++;
        }
        l++;
    }
}

void _updateI(int l,int r ,int n)
{
    int q=l/bsize;
    if(l<=r)
    update(q,n);
    while(l<(q+1)*bsize&&l<=r)
    {
        if((arr[l]&1))
        {
            cnt[q]++;
            sum[q]++;
            arr[l]++;
        }
        else
        {
            cnt[q]--;
            sum[q]++;
            arr[l]++;
        }
        l++;
    }
    l--;
    while(l+bsize<=r)
    {
        ++q;
        sum[q]+=_size(q,n);

        even[q]++;

        odd[q]++;

        l+=bsize;

        cnt[q]=_size(q,n)-cnt[q];
    }
    l++;
    if(l<=r)
    update(++q,n);
    while(l<=r)
    {
        if((arr[l]&1))
        {
            cnt[q]++;
            sum[q]++;
            arr[l]++;
        }
        else
        {
            cnt[q]--;
            sum[q]++;
            arr[l]++;
        }
        l++;
    }
}

LL _queryM(int l,int r ,int n)
{
    LL res=0;
    int q=l/bsize;
    if(l<=r)
    update(q,n);
    while(l<(q+1)*bsize&&l<=r)
    {
        res+=arr[l++];
    }
    l--;
    while(l+bsize<=r)
    {
        res+=sum[++q];
        l+=bsize;
    }
    l++;
    if(l<=r)
    update(++q,n);
    while(l<=r)
    {
        res+=arr[l++];
    }
    return res;
}

int main()
{
    int n;
    S(n);
    F(i,0,n)
    S(arr[i]);

    bsize=_sqrt(n);

    //Bug(bsize);
    _build(n);
    int q,l,r;
    S(q);
    while(q--)
    {
        char str[3];
        Ss(str);

        S(l);
        S(r);
        l--,r--;
        if(str[0]=='E')
            _updateE(l,r,n);
        else if(str[0]=='O')
            _updateO(l,r,n);
        else if(str[0]=='I')
            _updateI(l,r,n);
        else
            printf("%lld\n",_queryM(l,r,n));
    }
    return 0;
}
