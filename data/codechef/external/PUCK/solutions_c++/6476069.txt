/* Pranet Verma */
/* Yeh mera template hai. Apna khud banao =_= */
#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
#define mp make_pair
#define s(n) scanf("%d",&n)
#define s2(n,m) scanf("%d%d",&n,&m)
#define s3(n,m,l) scanf("%d%d%d",&n,&m,&l)
#define rep(i,n) for(int i=0;i<n;++i)
ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); }
const int mod=1000000007;

int a[1200001];
int base;
int n;
enum STATE{INIT,FLIP,EVEN,ODD};

ll sum[1001];
int even[1001];
int odd[1001];
int incOdd[1001];
int incEven[1001];
STATE state[1001];

void flushBlock(int i)
{
  int l=base*i;
  int r=l+base-1;

  for(int j=l;j<=r;++j)
  {
    if(j>=n)
      break;

    if(a[j]&1)
      a[j]+=incOdd[i];
    else
      a[j]+=incEven[i];
  }
}
void refreshBlock(int i)
{
  int l=base*i;
  int r=l+base-1;
    sum[i]=0;
    odd[i]=0;
    even[i]=0;
    incOdd[i]=0;
    incEven[i]=0;
    state[i]=INIT;
  for(int j=l;j<=r;++j)
  {
    if(j>=n)
      break;
    sum[i]+=a[j];

    if(a[j]&1)
      ++odd[i];
    else
      ++even[i];

    
  }
}
void preprocess()
{
  base=ceil(sqrt(n));
  for(int i=0;i<base;++i)
    refreshBlock(i);
}
void makeBlockEven(int i)
{
  if(state[i]==EVEN)
    return;
  
  else if(state[i]==ODD)
  {
    ++incOdd[i];
    ++incEven[i];
  }
  else if(state[i]==INIT)
  {
    ++incOdd[i];
  }
  else if(state[i]==FLIP)
  {
    ++incEven[i];
  }

  state[i]=EVEN;
  sum[i]+=odd[i];
  even[i]+=odd[i];
  odd[i]=0;
}
void makeBlockOdd(int i)
{
  if(state[i]==ODD)
    return;
  
  else if(state[i]==EVEN)
  {
    ++incOdd[i];
    ++incEven[i];
  }
  else if(state[i]==INIT)
  {
    ++incEven[i];
  }
  else if(state[i]==FLIP)
  {
    ++incOdd[i];
  }
  state[i]=ODD;
  sum[i]+=even[i];
  odd[i]+=even[i];
  even[i]=0;
}
void invertBlock(int i)
{
  if(state[i]==INIT)
  {
    ++incOdd[i];
    ++incEven[i];
    state[i]=FLIP;
  }
  else if(state[i]==FLIP)
  {
    ++incOdd[i];
    ++incEven[i]; 
    state[i]=INIT;
  }
  else if(state[i]==EVEN)
  {
    ++incOdd[i];
    ++incEven[i]; 
    state[i]=ODD; 
  }
  else if(state[i]==ODD)
  {
    ++incOdd[i];
    ++incEven[i]; 
    state[i]=EVEN; 
  }

  sum[i]+=even[i]+odd[i];
  swap(even[i],odd[i]);
}
void makeEven(int x,int y)
{
  for (int i = 0; i < base; ++i)
  {
    int l=base*i;
    int r=l+base-1;

    /* node is in query */
    if(x<=l && r<=y)
    {
      makeBlockEven(i);
      continue;
    }

    if(x>r || y<l)
      continue;
    
    flushBlock(i);
    for(int j=max(x,l);j<=min(y,r);++j)
    {
      if(a[j]&1)
        ++a[j];
    }

    refreshBlock(i);

  }
}
void makeOdd(int x,int y)
{
  for (int i = 0; i < base; ++i)
  {
    int l=base*i;
    int r=l+base-1;

    /* node is in query */
    if(x<=l && r<=y)
    {
      makeBlockOdd(i);
      continue;
    }

    if(x>r || y<l)
      continue;
    
    flushBlock(i);

    for(int j=max(x,l);j<=min(y,r);++j)
    {
      if(a[j]&1)
        {

        }
      else
        ++a[j];
    }

    refreshBlock(i);

  }
}

void invert(int x,int y)
{
 for (int i = 0; i < base; ++i)
  {
    int l=base*i;
    int r=l+base-1;

    /* node is in query */
    if(x<=l && r<=y)
    {
      invertBlock(i);
      continue;
    }

    if(x>r || y<l)
      continue;
    
    flushBlock(i);
    for(int j=max(x,l);j<=min(y,r);++j)
    {
        ++a[j];
    }

    refreshBlock(i);

  } 
}

ll query(int x,int y)
{
  ll ans=0;
  for(int i=0;i<base;++i)
  {
    int l=base*i;
    int r=l+base-1;
    if(x<=l && r<=y)
      {
        ans+=sum[i];
        continue;
      }

    else if(x>r || y<l)
      continue;

    flushBlock(i);
    for(int j=max(x,l);j<=min(y,r);++j)
      ans+=a[j];
    refreshBlock(i);
  }

  return ans;
}
int main()
{
  s(n);
  for(int i=0;i<n;++i)
    s(a[i]);

  preprocess();

  int q;
  s(q);
  while(q--)
  {
    int l,r;
    char t;
    scanf("\n%c",&t);
    scanf("%d%d",&l,&r);
    --l;
    --r;
    switch(t)
    {
      case 'E':
        makeEven(l,r);
        break;
      case 'O':
        makeOdd(l,r);
        break;
      case 'I':
        invert(l,r);
        break;
      case 'M':
        printf("%lld\n",query(l,r));
        break;
      default:
        assert(false);
    }


  }

     


}