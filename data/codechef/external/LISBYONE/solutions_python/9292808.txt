/**
* He who forgives and acknowledges himself... that is what it truly means to be strong!
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
#include <climits>
#include <iomanip>
#include <cassert>
#include <cmath>
using namespace std;

#define trace(x) {cerr << #x << "=" << x <<endl;}
#define trace2(x, y) {cerr << #x << "=" << x << " " << #y << "=" << y <<endl;}
#define track(x) {cerr << #x << ":" << endl; for (int q = 0; q < x.size(); q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackarr(x, n) {cerr << #x << ":" << endl; for (int q = 0; q < n; q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;}
#define trackcr(x) {cerr << #x << ":" << endl; for (auto i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;}
template <typename Tk, typename Tv> ostream& operator<<(ostream& os, const pair<Tk, Tv> &p){os << "{" << p.first << ',' << p.second << "}";return os;}

typedef long long ll;

const int INF = 1000000005;

typedef vector<pair<int,int> > vii;
void scanline(vii p, vii &interval) {
    int beg = p[0].first, last = p[0].second;
    for (int i = 1; i < p.size(); i++) {
        if (p[i].first <= last)
            last = max(last, p[i].second);
        else {
            interval.push_back(make_pair(beg, last));
            beg = p[i].first, last = p[i].second;
        }
    }
    interval.push_back(make_pair(beg, last));
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, K;
        scanf("%d%d", &n, &K);
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            scanf("%d", &a[i]);
        }

        const int MAX = 1005;
        int starts[MAX]={}, ends[MAX]={};

        ends[0] = 1;
        for (int i = 1; i < n; i++) {
            ends[i] = 1;
            for(int j = i-1; j >= 0; j--) {
                if (a[j] < a[i]) {
                    ends[i] = max(ends[i], ends[j]+1);
                }
            }
        }

        starts[n-1]=1;
        for (int i = n-2; i >=0 ; i--) {
            starts[i] = 1;
            for (int j = i+1; j < n; j++) {
                if (a[j] > a[i]) {
                    starts[i] = max(starts[i], starts[j]+1);
                }
            }
        }

        int lis=1;
        for (int i = 0; i < n; i++) {
            lis = max(lis, starts[i]);
        }

        ll answer = 0;

        for (int i = 0; i < n-1; i++) {
            int mxStart[MAX], mnEnd[MAX];
            for (int k = 0; k <= n; k++) {
                mxStart[k] = 0, mnEnd[k] = INF;
            }
            mxStart[0] = INF, mnEnd[0] = 0;
            for (int k = i+1; k < n; k++) {
                mxStart[starts[k]] = max(mxStart[starts[k]], a[k]);
            }
            for (int k = 0; k <= i; k++) {
                mnEnd[ends[k]] = min(mnEnd[ends[k]], a[k]);
            }

            vii range;

            for (int k = 0; k <= n; k++) {
                int mx = mxStart[lis-k]-1;
                mx = min(mx, K);
                int mn = mnEnd[k]+1;
                if (mx >= mn) {
                    range.push_back(make_pair(mn, mx));
                }
            }

            sort(range.begin(), range.end());
            if (!range.empty()) {
                vii mer;
                scanline(range, mer);
                for (int j = 0; j < mer.size(); j++) {
                    answer += mer[j].second-mer[j].first+1;
                }
            }
        }

        int mx = 0;
        for (int i = 0; i < n; i++) {
            if (starts[i]==lis) {
                mx = max(mx, a[i]);
            }
        }
        answer += min(K, mx-1);

        int mn = INF;
        for (int i = n-1; i >= 0; i--) {
            if (ends[i]==lis) {
                mn = min(mn, a[i]);
            }
        }
        answer += max(0, K-mn);

        printf("%lld\n", answer);
    }
}
