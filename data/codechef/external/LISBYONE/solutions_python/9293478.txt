#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <algorithm>
using namespace std;

#define nln        puts("")                         ///prLLInewline
#define getLLI(a)  scanf("%d",&a);
#define max3(a,b,c) max(a,max(b,c))                  ///3 ta theke max
#define min3(a,b,c) min(a,min(b,c))                  ///3 ta theke min

#define FOR1(i,n)  for(LLI i=1;i<=n;i++)
#define FOR0(i,n)  for(LLI i=0;i<n;i++)                 ///looping
#define FORR(i,n)  for(LLI i=n-1;i>=0;i--)
#define ALL(p)     p.begin(),p.end()

#define SET(p)     memset(p,-1,sizeof(p))
#define CLR(p)     memset(p,0,sizeof(p))            ///memset
#define MEM(p,v)   memset(p,v,sizeof(p))

#define READ(f)    freopen(f, "r", stdin)           /// file
#define WRITE(f)   freopen(f, "w", stdout)

#define SZ(c)      (LLI)c.size()
#define PB(x)      push_back(x)                     ///STL defines
#define MP(x,y)    make_pair(x,y)
#define ff         first
#define ss         second

#define LI         long LLI
#define LLI        long long
#define f64        long double
#define PI         acos(-1.0)                        ///PI er value

LLI Set(LLI N,LLI pos)
{
    return N=N | (1<<pos);
}
LLI reset(LLI N,LLI pos)
{
    return N= N & ~(1<<pos);
}
bool check(LLI N,LLI pos)
{
    return (bool)(N & (1<<pos));
}
void CI(int &_x)
{
    scanf("%d",&_x);
}

void CO(LLI &_x)
{
    cout<<_x;
}

template<typename T> void getarray(T a[],LLI n)
{
    for(LLI i=0; i<n; i++) cin>>a[i];
}
template<typename T> void prLLIarray(T a[],LLI n)
{
    for(LLI i=0; i<n-1; i++) cout<<a[i]<<" ";
    cout<<a[n-1]<<endl;
}

const double EPS=1e-9;                              ///constatnts
const LLI INF=0x7f7f7f7f;

LLI dr8[8]= {1,-1,0,0,1,-1,-1,1};            ///8 direction move
LLI dc8[8]= {0,0,-1,1,1,1,-1,-1};
LLI dr4[4]= {0,0,1,-1};                      ///4 direction move
LLI dc4[4]= {-1,1,0,0};                      ///or adjacent dir.
LLI kn8r[8]= {1,2,2,1,-1,-2,-2,-1};          ///knight moves
LLI kn8c[8]= {2,1,-1,-2,-2,-1,1,2};
#define mx 1005
int n,k;
int ar[mx];
void input()
{
    CI(n);
    CI(k);
    FOR1(i,n)
    {
        int temp;
        CI(temp);
        ar[i]=temp;
    }
}
int dp_f[mx];
int dp_b[mx];
int LIS=0;
void pre()
{
    LIS=0;
    for(int i=1; i<=n; i++)
    {
        dp_b[i]=1;
        for(int j=1; j<i; j++)if(ar[i]>ar[j])dp_b[i]=max(dp_b[i],1+dp_b[j]);

    }
    for(int i=n; i>=1; i--)
    {
        dp_f[i]=1;
        for(int j=i+1; j<=n; j++)
            if(ar[i]<ar[j])
            {
                dp_f[i]=max(dp_f[i],1+dp_f[j]);
            }
        LIS=max(LIS,dp_f[i]);
    }

}
void print()
{
    int inx;
    while(cin>>inx)
    {
        cout<<"FUCK "<<dp_f[inx]<<" "<<dp_b[inx]<<"\n";
    }
}

int zero_pos()
{
    int maxi=0;
    for(int i=1; i<=n; i++)if(dp_f[i]==LIS)
        {

            maxi=max(maxi,ar[i]);
        }
    return min(maxi-1,k);
}
int N_plus_one_pos()
{
    int mini=1<<30;
    for(int i=1; i<=n; i++)
        if(dp_b[i]==LIS)
        {
            mini=min(mini,ar[i]);
        }
//    mini++;
    return max(k-mini,0);


}
int minival[mx],maxival[mx];
int process_pos(int pos)
{
    LLI ans=0;
    for(int i=0; i<mx; i++)minival[i]=1<<30,maxival[i]=-(1<<30);
    minival[0]=0,maxival[0]=1<<30;
    for(int i=1; i<=pos; i++)
    {
        int len=dp_b[i];
        minival[len]=min(minival[len],ar[i]);

    }
    for(int i=pos+1; i<=n; i++)
    {
        int len=dp_f[i];
//cout<<"SS "<<i<<" "<<len<<"\n";
        maxival[len]=max(maxival[len],ar[i]);
    }
//cout<<"PORN : "<<minival[1]<<" "<<maxival[1]<<"\n";
    vector<pair<int,int> >Seg,V;
    for(int left_len=0; left_len<=LIS; left_len++)
    {
        int mn=minival[left_len]+1;
        int maxi=maxival[LIS-left_len]-1;
        maxi=min(maxi,k);
        if(maxi>=mn)Seg.PB(MP(mn,maxi));
    }
//    cout<<"FF "<<Seg.size()<<"\n";
////    puts("OKK");


    sort(ALL(Seg));
    if(Seg.size()==0)return 0;
    int L=Seg[0].ff,R=Seg[0].ss;
    for(int i=1; i<Seg.size(); i++)
        if(Seg[i].ff<=R)
        {
            R=max(R,Seg[i].ss);

        }
        else
        {
            V.PB(MP(L,R));
            L=Seg[i].ff,R=Seg[i].ss;
        }
//        puts("OKK");
    V.PB(MP(L,R));
    for(int i=0; i<V.size(); i++)ans+=V[i].ss-V[i].ff+1;
    return ans;
}
int main()
{
    int t;
    CI(t);
    while(t--)
    {
        input();

        pre();
//        print();
//                       puts("MMMMMMM");
        LLI ans=0;
        ans+=zero_pos();
//        cout<<"ZERO "<<zero_pos()<<" "<<N_plus_one_pos()<<"\n";
        ans+=N_plus_one_pos();
//        puts("FUCK");
        for(int i=1; i<n; i++)
//            if(i==2)
            {
//                cout<<i<<" : "<<process_pos(i)<<"\n";
ans+=process_pos(i);
            }
//        puts("OKKK");
        cout<<ans<<"\n";
    }


}
