#include<stdio.h>
#define getcx getchar_unlocked
inline void inp( int &n )//fast input function
{
   n=0;
   int ch=getcx();int sign=1;
   while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}

   while(  ch >= '0' && ch <= '9' )
           n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
   n=n*sign;
}
// exactly similar to inversion count . there we compared a[i] with a[j]
// here d[] with d[] .

// see video of courseera
long long int o;
int a[4000005],b[1000000],d[1000000];
int c[2000001];
void sort(int a[],int low,int high,int mid){
	int i=low;
	int j=mid+1;
	int k=low;
		while(i<=mid&&j<=high)// i pointing to 1st element of left array and j to 1st
		//element of 2nd array
		{
			if(d[a[i]]<d[a[j]])
			c[k++]=a[i++];// no inversions
            else
            {
				 o = o + mid - i + 1;//size of left array ((mid+1)-i)==no of el. left in left==no of swaps
			     c[k++]=a[j++];
			}//size of left ==0 to mid == mid-0+1==mid + 1
		}
		while(i<=mid)
		c[k++]=a[i++];

		while(j<=high)
		c[k++]=a[j++];

		for(i=low;i<=high;i++)
		a[i]=c[i];
}
void merge (int a[],int low,int high){

	int mid;
	if(low<high){
		mid=(low+high)/2;
		merge(a,low,mid);
		merge(a,mid+1,high);
		sort(a,low,high,mid);
	}

}
int main () {
	int t;
	inp(t);
	while(t--){
		int n;
		inp(n);
		o = 0;
	        int i;
		for(i=0;i<n;i++)
		inp(a[i]);
		for(i=0;i<n;i++){
                         inp(b[i]);
                         d[b[i]]=i;
                         }
		merge(a,0,n-1);
		printf("%lld\n",o);
	}
	return 0;
}
