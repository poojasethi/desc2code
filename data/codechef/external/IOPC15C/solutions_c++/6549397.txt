#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<list>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#define maxm 200005

using namespace std;

struct node
{
    int x, y;
};

class UF
{
public:
    int *id, cnt, *sz;
	// Create an empty union find data structure with N isolated sets.
    UF(int N)
    {
        cnt = N;
        id = new int[N];
        sz = new int[N];
        for(int i=0; i<N; i++)
        {
            id[i] = i;
            sz[i] = 1;
        }
	//cout<<"Done"<<endl;
    }
    ~UF()
    {
        delete [] id;
        delete [] sz;
    }
	// Return the id of component corresponding to object p.
    int find(int p)
    {
        int root = p;
        while (root != id[root])root = id[root];
        while (p != root)
        {
            int newp = id[p];
            id[p] = root;
            p = newp;
        }
        //cout<<"!!"<<root<<endl;
        return root;
    }
	// Replace sets containing x and y with their union.
    void merge(int x, int y)
    {
        int i = find(x);
        int j = find(y);
        if (i == j) return;

		// make smaller root point to larger one
        if(sz[i] < sz[j])
        {
            id[i] = j;
            sz[j] += sz[i];
        }
        else
        {
            id[j] = i;
            sz[i] += sz[j];
        }
        cnt--;
    }
	// Are objects x and y in the same set?
    bool connected(int x, int y)
    {
        return find(x) == find(y);
    }
	// Return the number of disjoint sets.
    int count()
    {
        return cnt;
    }
};

pair<int, pair<int, int> > pr[maxm];

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int n;
        cin >> n;
        UF disj(n);

        for(int i = 0; i < (n-1); i++)
        {
            int a, b, c;
            //cin >> a >> b >> c;
            scanf("%d%d%d", &a, &b, &c);
            pr[i] = make_pair(c, make_pair(a, b));
        }
        sort(pr, pr + n - 1);

        long long ans = 0;
        for(int i = n-2; i >= 0; i--)
        {
            //cout << pr[i].first << " " << (pr[i].second).first << " " << (pr[i].second).second << endl;
            int val = pr[i].first, x = (pr[i].second).first, y = (pr[i].second).second;

            int id1 = disj.find(x-1);
            int id2 = disj.find(y-1);
            //cout << id2 << endl;
            //cout << id1 << " id " << id2 << endl;
            ans = ans + (long long)(disj.sz[id1]) * (long long)(disj.sz[id2])* val;
            //cout << disj.sz[id1] << " szs " << disj.sz[id2] << " " << disj.sz[4] << endl;
            disj.merge(id1, id2);
            //cout << ans << endl;
        }
        //cout << ans << endl;
        printf("%lld\n", ans);
        //~ disj;
    }

}
