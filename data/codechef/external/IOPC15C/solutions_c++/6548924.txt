#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<list>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>

using namespace std;

struct node
{
    int x, y;
};

#define INF 10000000000000000LL
#define M 1000000007LL
typedef long long ll;
typedef list<int> li;
typedef stack<int> si;
typedef queue<int> qi;
typedef priority_queue<int> pqi;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<int,string> pis;
typedef pair<string,int> psi;

class UF
{

public:
    int *id, cnt, *sz;
	// Create an empty union find data structure with N isolated sets.
    UF(int N)
    {
        cnt = N;
        id = new int[N];
        sz = new int[N];
        for(int i=0; i<N; i++)
        {
            id[i] = i;
            sz[i] = 1;
        }
	//cout<<"Done"<<endl;
    }
    ~UF()
    {
        delete [] id;
        delete [] sz;
    }
	// Return the id of component corresponding to object p.
    int find(int p)
    {
        int root = p;
        while (root != id[root])root = id[root];
        /*while (p != root)
        {
            int newp = id[p];
            id[p] = root;
            p = newp;
        }*/
        //cout<<"!!"<<root<<endl;
        return root;
    }
	// Replace sets containing x and y with their union.
    void merge(int x, int y)
    {
        int i = find(x);
        int j = find(y);
        if (i == j) return;

		// make smaller root point to larger one
        if(sz[i] < sz[j])
        {
            id[i] = j;
            sz[j] += sz[i];
        }
        else
        {
            id[j] = i;
            sz[i] += sz[j];
        }
        cnt--;
    }
	// Are objects x and y in the same set?
    bool connected(int x, int y)
    {
        return find(x) == find(y);
    }
	// Return the number of disjoint sets.
    int count()
    {
        return cnt;
    }
};
vector<pair<int, pair <int,int > > > edg;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        edg.clear();
        int n;
        scanf("%d",&n);
        int t1,t2,t3;
        for(int i=0;i<n-1;i++)
        {
            scanf("%d",&t1);
            scanf("%d",&t2);
            scanf("%d",&t3);

            edg.push_back(make_pair(-1*t3 , make_pair(t1,t2)));
        }
        sort(edg.begin(),edg.end());

        UF sets(n);
        long long ans=0;
        int cnt1,cnt2,f1,f2;
        for(int i=0;i<edg.size();i++)
        {
            //cout<<edg[i].second.first<<" "<<edg[i].second.second<<endl;
            f1=sets.find(edg[i].second.first - 1);
            //cout<<f1<<endl;
            f2=sets.find(edg[i].second.second - 1);
            //cout<<f1<<" "<<f2<<endl;
            ans-=(((long long)(edg[i].first))*(long long)sets.sz[f1]*(long long)sets.sz[f2]);

            sets.merge(f1,f2);

        }
        printf("%lld\n",ans);

    }

}
