#include<stdio.h>
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<sstream>
#include<set>
#include<map>
#include<stack>
#include<cmath>
#include <map>
#include<cstdlib>
#include<cstring>
#include<string>
#include<set>
#include<cassert>
using namespace std;
 
#define DEBUG //on-off switch for prlling statements
 
// Input macros
#define s(n)                        scanf("%d",&n)
#define sc(n)                       scanf("%c",&n)
#define sl(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)
#define ss(n)                       scanf("%s",n)
 
// Useful constants
#define INF                        1000000000
#define EPS                         1e-14
 
// Useful hardware instructions
#define bitcount                    __builtin_popcount
#define gcd                         __gcd
 
// Useful container manipulation / traversal macros
#define forall(i,a,b)               for(ll i=a;i<b;i++)
#define foreach(v, c)               for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v)
#define all(a)                      a.begin(), a.end()
#define in(a,b)                     ( (b).find(a) != (b).end())

#define fill(a,v)                    memset(a, v, sizeof a)
#define sz(a)                       ((ll)(a.size()))
 
// Some common useful functions
#define maX(a,b)                     ( (a) > (b) ? (a) : (b))
#define miN(a,b)                     ( (a) < (b) ? (a) : (b))
 
#define ll long long int
#define llu long long unsigned
#define ld long
#define mod 1000000007
#define F first
#define S second
#define pb push_back
#define llu long long unsigned
#define ld long
ll ans[402];
ll dp[402][402][402];
ll wt[402];
ll c[402][402];
ll powval[402][402];
ll power(ll x,ll y)
{
	if(y == 0)
	return 1;
	ll d=power(x,y/2);
	d=(d*d)%mod;
	if(y&1)
	{
		d=(x*d)%mod;
	}
	return d;
}
ll divmodulo(ll num,ll den)
{
	num=num%mod;
	den=power(den,mod-2);
	return (num*den)%mod;
}
ll mul(ll x,ll y)
{
	return ((x%mod)*(y%mod))%mod;
}
ll ncr(ll n,ll r)// calculatencr
{
	if(r == 0 || r==n)
	return n;
	ll num=1;
	ll den=1;
	for(int i=0;i<r;i++)
	{
		num=(num*((n-i)%mod))%mod;
		den=(den*(i+1))%mod;
	}
	return divmodulo(num,den);
	
}

void calc(int x,ll k)
{
	ll ans=0;
	ll y=wt[0];
	ll val=divmodulo(((power(y,k+1)-1)%mod+mod)%mod,y-1);
	for(int j=0;j<=min((ll)400,k);j++)
	{
	
		ll zero=k-j;
		ans=(ans+(val*dp[400][x][j]))%mod;

		val=divmodulo(((ncr(k+1,j+1)*power(y,k-j)-val)%mod+mod)%mod,y-1);
	}
	ans=((ans-dp[400][x][0])%mod+mod)%mod;
	printf("%lld\n",ans%mod);
}

void preprocess() 
{
	for(int i=0;i<=401;i++)
	{
		powval[i][0] = 1;
		for(int j=1;j<=401;j++)
		{
			powval[i][j] =( powval[i][j-1]*wt[i])%mod;
		}
	}
	fill(c,0);
	for(int i=0;i<=401;i++)
	{
		c[i][0]= 1;
		c[i][i]=1;
	}
	for(int i=1;i<=401;i++)
	{
		for(int j=1;j<i;j++)
		{
			c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod;
		
		}
	}
}
void solvedp()
{
	dp[0][0][0]=1;
	for(int i=0;i<=400;i++)
	{
		for(int j=0;j<=400;j++)
		{
			for(int k=0;k<=j;k++)
			{

				int next=i+1;
				dp[next][j][k] =(dp[next][j][k]+dp[i][j][k] )%mod;
				int val=j;
				for(int l=1;l+k<=400;l++)
				{
					val += next;
					if(val > 400) break;
					dp[next][val][k+l] = (dp[next][val][k+l]+((c[l+k][k]*powval[next][l])%mod)*dp[i][j][k])%mod;
		
				}
			}
		}
	}
}

int main()
{
	fill(wt,0);
int n;
	ll k;
	s(n);
	sl(k);
	for(int i=0;i<n;i++)
	{
		int x;
		s(x);
		wt[x]++;
	}
	preprocess();
	solvedp();
	assert(wt[0] != 1);
	int q;
	s(q);
	for(int i=0;i<q;i++)
	{
		int x;
		s(x);
		if(wt[0] == 0)
		{
			ll sum=0;
			for(int j=1;j<=min((ll)400,k);j++)
			{
				sum=(sum+dp[400][x][j])%mod;
			}
			printf("%lld\n",sum%mod);
			continue;
		}
		calc(x,k);
	}
}