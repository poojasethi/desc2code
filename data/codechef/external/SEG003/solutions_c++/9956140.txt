#include <bits/stdc++.h>
using namespace std;
#define ll long long int 
#define mod (ll)(1e9 + 7)
ll a[100001];
ll tree[500000][2];
 struct tag
{
    int a1,a2;
};
void build(ll node , ll start , ll end){
 
 if( start > end )
  return;
  if( start == end ){
    if( start & 1 )
    tree[node][1] = a[start];
    else
    tree[node][0] = a[start];
  }
  else {
      ll mid = (start + end)/2;
    build(2*node,start,mid);
    build(2*node+1,mid+1 , end);
    tree[node][1] = max(tree[2*node][1],tree[2*node+1][1]);
    tree[node][0] = max(tree[2*node][0],tree[2*node+1][0]);
  }
}
void update(ll node , ll start ,ll  end , ll ind , ll val){
 if(start>end || ind< start || ind > end )
 return ;
 if(start==end){
     if(start & 1){
         tree[node][1] = val;
     }
     else
     tree[node][0] = val;
 }
 else{
     ll mid = (start + end)/2;
     update(2*node , start , mid , ind , val);
     update(2*node+1 , mid+1 , end , ind , val);
     tree[node][0] = max(tree[2*node][0]  , tree[2*node+1][0]);
     tree[node][1] = max(tree[2*node][1]  , tree[2*node+1][1]);
 }
}
 
tag  query(ll node,ll start , ll end , ll L ,ll R){
   tag ans;
 
   if( start > end || L > end || R < start ) {
     ans.a1=ans.a2=0;
    return ans;
    }
    if(  start >= L && end <= R ) {
      ans.a1=tree[node][0];
      ans.a2=tree[node][1];
     return ans;
     }
     else {
      tag p = query(2*node,start,(start+end)/2,L,R);
      tag q = query(2*node+1,(start+end)/2+1,end,L,R);
      ans.a1=max(p.a1,q.a1);
      ans.a2=max(p.a2,q.a2);
      return ans;
  }
 }
int main() {
	int n,q;
	cin >> n >> q;
	for(int i=1;i<=n;i++) {
	  cin  >> a[i];
	  }
	 build(1,1,n); 
	 while(q--) {
	   int ch,x,y;
	   cin >> ch >> x >> y;
	   if(ch == 1) 
	     update(1,1,n,x,y);
	   else {
	    tag res = query(1,1,n,x,y);
	     cout << res.a1+res.a2 << endl;
	     }
	    }
	return 0;
}