#include<bits/stdc++.h>
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define p(n) printf("%d\n",n)
#define mod 1000000009LL
#define ll long long
#define pb push_back
#define mp make_pair
#define N 100011
#define LN 21
using namespace std;

ll fib[N];
ll cfib[N];
struct T
{
 ll sum;
 ll x;
 ll y;
}tree[4*N+14],tree1[4*N+14];
void build_tree(int idx,int l,int r)
{
 if(l==r)
 {
 tree[idx].sum=tree[idx].x=tree[idx].y=0;
 tree1[idx].sum=tree1[idx].x=tree1[idx].y=0;
 }
 else
 {
  int mid=(l+r)/2;
  build_tree(2*idx+1,l,mid);
  build_tree(2*idx+2,mid+1,r);
  tree[idx].sum=tree[idx].x=tree[idx].y=0;
  tree1[idx].sum=tree1[idx].x=tree1[idx].y=0;
 }
}
void lazy(int id,int l,int r,int ql,int qr)
{
  if(l>r)
  return;
  int el=r-l+1;
  ll val=(tree[id].x*fib[el])%mod;
  val=(val+tree[id].y*cfib[el-1])%mod;
  tree[id].sum=(tree[id].sum+val)%mod;
  if(l!=r)
  {
   int mid=(l+r)/2;
   tree[2*id+1].x=(tree[2*id+1].x+tree[id].x)%mod;
   tree[2*id+1].y=(tree[2*id+1].y+tree[id].y)%mod;
   int el=mid-l+1;
   tree[2*id+2].x=(tree[2*id+2].x+(tree[id].x*fib[el-1])%mod+(tree[id].y*fib[el])%mod)%mod;
   tree[2*id+2].y=(tree[2*id+2].y+(tree[id].x*fib[el])%mod+(tree[id].y*fib[el+1])%mod)%mod;
  }
  tree[id].x=tree[id].y=0;
}

void lazy2(int id,int l,int r,int ql,int qr)
{
  if(l>r)
  return;
  int el=r-l+1;
  ll val=(tree1[id].x*fib[el])%mod;
  val=(val+tree1[id].y*cfib[el-1])%mod;
  tree1[id].sum=(tree1[id].sum+val)%mod;
  if(l!=r)
  {
   int mid=(l+r)/2;
   tree1[2*id+1].x=(tree1[2*id+1].x+tree1[id].x)%mod;
   tree1[2*id+1].y=(tree1[2*id+1].y+tree1[id].y)%mod;
   int el=mid-l+1;
   tree1[2*id+2].x=(tree1[2*id+2].x+(tree1[id].x*fib[el-1])%mod+(tree1[id].y*fib[el])%mod)%mod;
   tree1[2*id+2].y=(tree1[2*id+2].y+(tree1[id].x*fib[el])%mod+(tree1[id].y*fib[el+1])%mod)%mod;
  }
  tree1[id].x=tree1[id].y=0;
}
void update(int idx,int l,int r,int ql,int qr,int tr)
{
   int mid=(r+l)/2;
   lazy(idx,l,r,ql,qr);

 if(qr<l||ql>r||l>r)
 return;
 else if(ql<=l && qr>=r)
 {
  int en=r-ql+1+tr;
  int str=l-ql+1+tr;
  tree[idx].sum=((tree[idx].sum+cfib[en]-cfib[str-1])%mod+2*mod)%mod;
  ll lx,ly;
  lx=fib[str];
  ly=fib[str+1];
  if(l!=r)
  {
   int mid=(l+r)/2;
   tree[2*idx+1].x=(tree[2*idx+1].x+lx)%mod;
   tree[2*idx+1].y=(tree[2*idx+1].y+ly)%mod;
   int el=mid-l+1;
   tree[2*idx+2].x=(tree[2*idx+2].x+(lx*fib[el-1])%mod+(ly*fib[el])%mod)%mod;
   tree[2*idx+2].y=(tree[2*idx+2].y+(lx*fib[el])%mod+(ly*fib[el+1])%mod)%mod;
  }
 }
 else
 {
  update(2*idx+1,l,mid,ql,qr,tr);
  update(2*idx+2,mid+1,r,ql,qr,tr);
  tree[idx].sum=(tree[2*idx+1].sum+tree[2*idx+2].sum)%mod;
 }
}

void update2(int idx,int l,int r,int ql,int qr,int tr)
{
   int mid=(r+l)/2;
   lazy2(idx,l,r,ql,qr);

 if(qr<l||ql>r||l>r)
 return;
 else if(ql<=l && qr>=r)
 {
  int en=r-ql+1+tr;
  int str=l-ql+1+tr;
  tree1[idx].sum=((tree1[idx].sum+cfib[en]-cfib[str-1])%mod+2*mod)%mod;
 // cout<<l<<" "<<r<<" "<<tree1[idx].sum<<" "<<ql<<" "<<qr<<endl;
  ll lx,ly;
  lx=fib[str];
  ly=fib[str+1];
  if(l!=r)
  {
   int mid=(l+r)/2;
   tree1[2*idx+1].x=(tree1[2*idx+1].x+lx)%mod;
   tree1[2*idx+1].y=(tree1[2*idx+1].y+ly)%mod;
   int el=mid-l+1;
   tree1[2*idx+2].x=(tree1[2*idx+2].x+(lx*fib[el-1])%mod+(ly*fib[el])%mod)%mod;
   tree1[2*idx+2].y=(tree1[2*idx+2].y+(lx*fib[el])%mod+(ly*fib[el+1])%mod)%mod;
  }
 }
 else
 {
  update2(2*idx+1,l,mid,ql,qr,tr);
  update2(2*idx+2,mid+1,r,ql,qr,tr);
  tree1[idx].sum=(tree1[2*idx+1].sum+tree1[2*idx+2].sum)%mod;
  //cout<<l<<" "<<r<<" "<<tree1[idx].sum<<endl;
 }
}

ll query(int idx,int l,int r,int ql,int qr)
{
  int mid=(r+l)/2;


   lazy(idx,l,r,ql,qr);
  if(qr<l||ql>r||l>r)
  return 0;
  else if(ql<=l && qr>=r)
  return tree[idx].sum;
  else
  return (query(2*idx+1,l,mid,ql,qr)+query(2*idx+2,mid+1,r,ql,qr))%mod;
}

ll query2(int idx,int l,int r,int ql,int qr)
{
  int mid=(r+l)/2;


   lazy2(idx,l,r,ql,qr);
  if(qr<l||ql>r||l>r)
  return 0;
  else if(ql<=l && qr>=r)
  {
  return tree1[idx].sum;
  }
  else
  return (query2(2*idx+1,l,mid,ql,qr)+query2(2*idx+2,mid+1,r,ql,qr))%mod;
}
int main()
{
 int i;
 fib[0]=cfib[0]=0;
 fib[1]=1;
 for(i=2;i<N;++i)
 fib[i]=(fib[i-1]+fib[i-2])%mod;
 for(i=1;i<N;++i)
 cfib[i]=(cfib[i-1]+fib[i])%mod;
 int n,q;
 cin>>n>>q;
 build_tree(0,0,n-1);
 for(i=0;i<q;++i)
 {
  int ty,x,y;
  s(ty);s(x);s(y);
  if(ty==1)
  {
   x--;
   if(y<=x+1)
   update(0,0,n-1,x-y+1,x,0);
   else
   update(0,0,n-1,0,x,y-x-1);
   if(y>1)
   {
   if(x+y-1<=n-1)
   update2(0,0,n-1,n-x-y,n-x-2,0);
   else
   update2(0,0,n-1,0,n-x-2,x+y-n);
   }
  }
  else
  {
   x--;y--;
   //assert(x<=y);
   ll ans=query(0,0,n-1,x,y);
   ans+=query2(0,0,n-1,n-1-y,n-1-x);
   ans%=mod;
   printf("%lld\n",ans);
  }
 }
}
