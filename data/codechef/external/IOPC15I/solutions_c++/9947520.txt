#include <bits/stdc++.h>
#define lli long long
#define M 1000000009
#define MAX 100005

using namespace std;

//Code for FAST INPUT :)
template <typename T>
inline void fi(T *a)
{
    register char c=0;
    while (c<33) c=getchar_unlocked();
    *a=0;
    int tmp = 0;
    while (c>33)
    {
        if ( c == 45 ) tmp = 1;
        else *a=*a*10+c-'0';
        c=getchar_unlocked();
    }
    if ( tmp == 1 ) *a = 0-(*a);
}

struct matrix {
	
	int P[2][2];
	
	matrix operator + (const matrix &A) {
		matrix answer;
		for ( int i = 0; i < 2; i++ ) {
			for ( int j = 0; j < 2; j++ ) {
				answer.P[i][j] = P[i][j] + A.P[i][j];
				if ( answer.P[i][j] >= M ) answer.P[i][j] -= M;
			}
		}
		return answer;
	}
	
	matrix operator * (const matrix &A) {
		matrix answer;
		for ( int i = 0; i < 2; i++ ) {
			for ( int j = 0; j < 2; j++ ) {
				answer.P[i][j] = 0;
				for ( int k = 0; k < 2; k++ ) {
					answer.P[i][j] += ((lli)P[i][k]*(lli)A.P[k][j])%M;
					if ( answer.P[i][j] >= M ) answer.P[i][j] -= M;
				}
			}
		}
		return answer;
	}
	
}FIB[MAX], FIB_SUM[MAX], identity, null, fib, tree[4 * MAX], lazy_a[4 * MAX], lazy_b[4 * MAX];

void init()
{
	for ( int i = 0; i < 2; i++ ) {
		for ( int j = 0; j < 2; j++ ) {
			null.P[i][j] = 0;
			fib.P[i][j] = 1;
			if ( i == j ) identity.P[i][j] = 1;
			else identity.P[i][j] = 0;
		}
	}
	fib.P[1][1] = 0;
	FIB[0] = FIB_SUM[0] = identity;
	for ( int i = 1; i <= MAX - 5; i++ ) FIB[i] = FIB[i - 1]*fib;
	for ( int i = 1; i <= MAX - 5; i++ ) FIB_SUM[i] = FIB_SUM[i - 1] + FIB[i];
	return;
}

matrix combine(matrix A, matrix B) {
	return (A + B);
}

void push_down_a(int where, int left, int right)
{
	tree[where] = (tree[where] + (lazy_a[where]*FIB_SUM[right - left]));
	if ( left != right ) {
		int mid = (left + right)/2;
		lazy_a[where*2] = lazy_a[where*2] + lazy_a[where];
		lazy_a[where*2 + 1] = lazy_a[where*2 + 1] + FIB[mid - left + 1]*lazy_a[where];
	}
	lazy_a[where] = null;
	return;
}

void push_down_b(int where, int left, int right)
{
	tree[where] = (tree[where] + (lazy_b[where]*FIB_SUM[right - left]));
	if ( left != right ) {
		int mid = (left + right)/2;
		lazy_b[where*2] = lazy_b[where*2] + FIB[right - mid]*lazy_b[where];
		lazy_b[where*2 + 1] = lazy_b[where*2 + 1] + lazy_b[where];
	}
	lazy_b[where] = null;
	return;
}

void update_a(int where, int left, int right, int i, int j, int val) {
	push_down_a(where, left, right);
	push_down_b(where, left, right);
	if ( left > right || left > j || right < i ) return;
	if ( left >= i && right <= j ) {
		lazy_a[where] = lazy_a[where] + FIB[val + left - i];
		push_down_a(where, left, right);
		return;
	}
	int mid = (left + right)/2;
	update_a(where*2, left, mid, i, j, val);
	update_a(where*2 + 1, mid + 1, right, i, j, val);
	tree[where] = combine(tree[where*2], tree[where*2 + 1]);
}

void update_b(int where, int left, int right, int i, int j, int val) {
	push_down_a(where, left, right);
	push_down_b(where, left, right);
	if ( left > right || left > j || right < i ) return;
	if ( left >= i && right <= j ) {
		lazy_b[where] = lazy_b[where] + FIB[val + j - right];
		push_down_b(where, left, right);
		return;
	}
	int mid = (left + right)/2;
	update_b(where*2, left, mid, i, j, val);
	update_b(where*2 + 1, mid + 1, right, i, j, val);
	tree[where] = combine(tree[where*2], tree[where*2 + 1]);
}

matrix query(int where, int left, int right, int i, int j) {
	push_down_a(where, left, right);
	push_down_b(where, left, right);
	if ( left > right || left > j || right < i ) return null;
	if ( left >= i && right <= j ) return tree[where];
	int mid = (left + right)/2;
	return combine(query(where*2, left, mid, i, j), query(where*2 + 1, mid + 1, right, i, j));
}

int main()
{
	int n, q, type, x, y, d;
	init();
	fi(&n), fi(&q);
	assert(n >= 1 && n <= 100000);
	assert(q >= 1 && q <= 100000);
	
	while ( q-- ) {
		fi(&type);
		assert(type == 1 || type == 2);
		if ( type == 1 ) {
			fi(&x), fi(&d);
			assert(x >= 1 && x <= 100000);
			assert(d >= 1 && d <= 100000);
			update_a(1, 1, n, max(x - d, 1), x, d - (x - max(x - d, 1)));
			update_b(1, 1, n, x + 1, min(x + d, n), d - (min(x + d, n) - x));
		}
		else {
			fi(&x), fi(&y);
			assert(x >= 1 && x <= 100000);
			assert(y >= 1 && y <= 100000);
			assert(x <= y);
			matrix answer = query(1, 1, n, x, y);
			printf("%d\n", answer.P[1][0]);
		}
	}
	return 0;
}