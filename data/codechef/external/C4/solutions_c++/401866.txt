#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) 
#define REV(i,a,b) for(int i= (int )a ; i > (int )b ; --i) 
#define REP(i,n) FOR(i,0,n)
#define PB push_back
#define PP pop()
#define EM empty()
#define INF 1000000000
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a) 	    __typeof(a) x(a)
#define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i)
#define EACH(it,v)  	IFOR(it,v.begin(),v.end())
#define PRESENT(c,x) 	((c).find(x) != (c).end())
#define SZ(x) 		x.size();
#define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end())
#define D(N) 		int N
#define S(N)		scanf("%d",&N)

#define CREATE_CLOCK() clock_t ____start, ____diff = 0 ;
#define START_CLOCK() ____start = clock() ;
#define REPORT_CLOCK() ({float f = (((float)clock()) - ____start)/((float)CLOCKS_PER_SEC);printf ("Time = %.6f\n" , f);})

typedef pair<int,int>  PI;
typedef pair<int,PI>   TRI;
typedef V( int )       VI;
typedef V( PI  )       VII;
typedef V( string )    VS;
typedef long long      LL;

inline string compute (int n, string order, int total, int *ingred) {
	int col = order.length ();
	int row = total + 1;
	string arr [row][col];
	const string emty = "";
	stringstream ss;
	FOR (i, 0, row) FOR (j, 0, col) arr [i][j] = emty;
	
	ss << order [0];
	if (ingred [order [0]-'a'] <= total) arr [ingred [order [0]-'a']][0] = ss.str ();
	int piv;
	ss.str (string ());
	/**
		we accept or reject the new ingred when comparing the formed string lexi. with previous possible one
	*/
	FOR (ind, 1, col) {
		piv = order [ind]-'a';
		FOR (wt, 0, row) {
			if (ingred [piv] == wt) {
				ss << order [ind];
				arr [wt][ind] = arr [wt][ind-1].compare ("")!=0 && arr [wt][ind-1].compare (ss.str ()) < 0 ? arr [wt][ind-1] : ss.str ();
				ss.str (string ());
			}
			else if (ingred [piv] > wt) arr [wt][ind] = arr [wt][ind-1];
			else {
				ss << order [ind];
				string newstr = arr [wt-ingred [piv]][ind-1];
				if (newstr.compare ("") != 0) {
					newstr += ss.str ();
					arr [wt][ind] = arr [wt][ind-1].compare ("")!=0 && arr [wt][ind-1].compare (newstr) < 0 ? arr [wt][ind-1] : newstr;
				}
				else arr [wt][ind] = arr [wt][ind-1];
				ss.str (string ());
			}
		}
	}
	if (arr [total][col-1].compare ("") == 0) return "IMPOSSIBLE";
	return arr [total][col-1];
}

int main () {
	int guests; cin >> guests;
	while (guests-- >0) {
		int n;	cin >> n;
		int ingred [n];
		FOR (i, 0, n) 	cin >> ingred [i];
		string order;	cin >> order;
		int total;		cin >> total;
		cout << compute (n, order, total, ingred) << endl;
	}
	return 0;
}