#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;

int dp[501][1001];
string sol[501][1001];
char seq[1005];
int vals[26];

int main() {
    for(int i=0;i<501;++i) dp[i][0] = 0;
    for(int j=0;j<1001;++j) dp[0][j] = 0;
    int t;
    scanf("%d",&t);
    while(t--) {
        int k, l, n;
        scanf("%d",&k);
        for(int i=0;i<k;++i) scanf("%d",vals+i);
        scanf("%s",seq+1);
        l = strlen(seq+1);
        for(int i=1;i<=l;++i) seq[i]-='a';
        scanf("%d",&n);

        for(int i=1;i<=n;++i) {
            for(int j=1;j<=l;++j) {
                if(vals[seq[j]]<=i) { // this conditions checks that dp[n][l]<=n always
                    int opt1 = dp[i][j-1];
                    int opt2 = dp[i-vals[seq[j]]][j-1]+vals[seq[j]];
                    if (opt1 > opt2) {
                        dp[i][j] = opt1;
                        sol[i][j] = sol[i][j-1];
                    } else if (opt2 > opt1) {
                        dp[i][j] = opt2;
                        sol[i][j] = sol[i-vals[seq[j]]][j-1]+char(seq[j]+'a');
                    } else {
                        // it is not that the sequence should have chars in lexi order.
                        // but for more than one result lexi small is preferred.
                        dp[i][j] = opt1;
                        sol[i][j] = min(sol[i][j-1],sol[i-vals[seq[j]]][j-1]+char(seq[j]+'a'));
                    }
                } else {
                    dp[i][j] = dp[i][j-1];
                    sol[i][j] = sol[i][j-1];
                }
            }
        }
        if (dp[n][l]<n) printf("IMPOSSIBLE\n");
        else printf("%s\n",sol[n][l].c_str());
    }
    return 0;
}
