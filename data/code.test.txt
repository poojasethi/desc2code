import java.util.*; _NEWLINE import java.lang.*; _NEWLINE import java.io.*; _NEWLINE  _NEWLINE class JALEBI _NEWLINE { _NEWLINE 	static int min; _NEWLINE 	static char best[]; _NEWLINE 	public static void main (String[] args) throws java.lang.Exception _NEWLINE 	{ _NEWLINE 		Reader re = new Reader(System.in); _NEWLINE 		int T = re.nextInt(); _NEWLINE 		while(T-->0){ _NEWLINE 			int K = re.nextInt(); _NEWLINE 			String A[] = new String[K]; _NEWLINE 			for(int i=0; i<K; i++) _NEWLINE 				A[i] = re.next(); _NEWLINE 			char s[] = new char[16]; _NEWLINE 			min = 17; _NEWLINE 			best = new char[16]; _NEWLINE 			work(s, A, 0); _NEWLINE 			String out = new String(best); _NEWLINE 			System.out.println(out); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static void work(char s[], String A[], int i){ _NEWLINE 		if(hasAll(s, A, i)){ _NEWLINE 			if(i<min){ _NEWLINE 				System.arraycopy(s, 0, best, 0, 16); _NEWLINE 				min = i; _NEWLINE 			} _NEWLINE 			return; _NEWLINE 		} _NEWLINE 		if(i>15) _NEWLINE 			return; _NEWLINE 		s[i] = 'B'; _NEWLINE 		work(s, A, i+1); _NEWLINE 		s[i] = 'G'; _NEWLINE 		work(s, A, i+1); _NEWLINE 		s[i] = 0; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static boolean hasAll(char s[], String A[], int max){ _NEWLINE 		for(String s1 : A){ _NEWLINE 			if(s1.length()>max) _NEWLINE 				return false; _NEWLINE 			int j = 0; _NEWLINE 			for(int i=0; i<max; i++) _NEWLINE 				if(s[i]==s1.charAt(j)){ _NEWLINE 					j++; _NEWLINE 					if(j>=s1.length()) _NEWLINE 						break; _NEWLINE 				} _NEWLINE 			if(j<s1.length()) _NEWLINE 				return false; _NEWLINE 		} _NEWLINE 		return true; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE class Reader{ _NEWLINE  _INDENT  _INDENT BufferedReader br; _NEWLINE  _INDENT  _INDENT StringTokenizer st; _NEWLINE  _INDENT  _INDENT Reader(InputStream in) throws Exception{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT br = new BufferedReader(new InputStreamReader(in)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT st = new StringTokenizer(""); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT String next() throws Exception{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(!st.hasMoreTokens()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st = new StringTokenizer(br.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return st.nextToken(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT int nextInt() throws Exception{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Integer.parseInt(next()); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
import re _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT q=n.split(' ',1) _NEWLINE  _INDENT  _INDENT q[0]=int(q[0]) _NEWLINE  _INDENT  _INDENT x=re.split('(\D+)',q[1]) _NEWLINE  _INDENT  _INDENT k=[] _NEWLINE  _INDENT  _INDENT rem=[] _NEWLINE  _INDENT  _INDENT for j in range(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[j]=='**': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.append(pow(int(x[j-1]),int(x[j+1]),q[0])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem.append(x[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem.append(x[j+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.append(x[j]) _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _INDENT  _INDENT #print rem _NEWLINE  _INDENT  _INDENT for j in rem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j in k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.remove(j) _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT for j in range(0,len(k),2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=((ans%q[0])*(k[j]%q[0]))%q[0] _NEWLINE  _INDENT  _INDENT print ans
N = 3400 _NEWLINE res = [0 for x in range(N)] _NEWLINE res[2] = 2 _NEWLINE for i in range(3, N): _NEWLINE  _INDENT  _INDENT if i % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = i / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res[i] = (2 * n - 1) * res[i - 1] / n _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res[i] = 2 * res[i - 1] _NEWLINE def f(val): _NEWLINE  _INDENT  _INDENT if val == 2 or val == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT elif val < 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (le, ri) = (2, N - 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while le < ri: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT me = (le + ri) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if res[me - 2] >= val: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ri = me _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT le = me + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if res[le - 2] == val : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t = int(raw_input()) _INDENT _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT val = int(raw_input()) _NEWLINE  _INDENT  _INDENT if f(val) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' _NEWLINE 
count=0 _NEWLINE def inversion(a,n): _NEWLINE  _INDENT  _INDENT if(n<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return [a[0],] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=a[0:n/2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=a[n/2:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return merge(inversion(l,n/2),inversion(r,n-(n/2))) _NEWLINE def merge(a,b): _NEWLINE  _INDENT  _INDENT global count _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT l1=len(a) _NEWLINE  _INDENT  _INDENT l2=len(b) _NEWLINE  _INDENT  _INDENT i=0;j=0; _NEWLINE  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT while(i<l1 and j<l2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][1]>b[j][1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=l1-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(b[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT while(i<l1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT while(j<l2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(b[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT return c _NEWLINE  _NEWLINE n=input() _NEWLINE m=[] _NEWLINE f=[] _NEWLINE  _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT a=a.strip().split() _NEWLINE  _INDENT  _INDENT m.append((int(a[0]),int(a[1]))) _NEWLINE m=sorted(m) _NEWLINE inversion(m,n) _NEWLINE print count _NEWLINE  _NEWLINE 
import sys _NEWLINE x = lambda : [int(n) for n in sys.stdin.readline().rstrip().split()] _NEWLINE def bfs(i, mode): _NEWLINE  _INDENT  _INDENT stack = [i+1] _NEWLINE  _INDENT  _INDENT while len(stack)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT current = stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if graph.has_key(current): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for node in graph[current]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val = graph[current][node]^answer[current-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if visit[node-1] == mode: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visit[node-1] = not visit[node-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT answer[node-1] = val _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.append(node) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif val != answer[node-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT return 1 _NEWLINE (n,m,k) = x() _NEWLINE k-=1 _NEWLINE answer = [0]*n _NEWLINE visit = [False]*n _NEWLINE graph = {} _NEWLINE while m: _NEWLINE  _INDENT  _INDENT (a,b,w) = x() _NEWLINE  _INDENT  _INDENT if not graph.has_key(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT graph[a] = {} _NEWLINE  _INDENT  _INDENT if not graph.has_key(b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT graph[b] = {} _NEWLINE  _INDENT  _INDENT graph[a][b] = w _NEWLINE  _INDENT  _INDENT graph[b][a] = w _NEWLINE  _INDENT  _INDENT m-=1 _NEWLINE exists = True _NEWLINE lastGraph = 0 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT if not visit[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visit[i] = not visit[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lastGraph = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not bfs(i, False): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exists = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE if not exists: _NEWLINE  _INDENT  _INDENT print -1 _NEWLINE else: _NEWLINE  _INDENT  _INDENT answer[lastGraph] ^= k _NEWLINE  _INDENT  _INDENT bfs(lastGraph, True) _NEWLINE  _INDENT  _INDENT print ' '.join(str(n) for n in answer) _NEWLINE 
numOfTests = int(raw_input()) _NEWLINE  _NEWLINE def computeMaxProd(N, N4, N7): _NEWLINE  _INDENT  _INDENT if N == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return N4*N7 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT x = (N+N7-N4)/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = x+1 _NEWLINE  _INDENT  _INDENT elif x > N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = N _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = x _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = x+1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return max( (x+N4)*(N-x+N7) , (y+N4)*(N-y+N7)) _NEWLINE  _NEWLINE def defMaxProd(L, R, N=0, N4=0, N7=0): _NEWLINE  _INDENT  _INDENT if not L: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return computeMaxProd(N, N4, N7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT r = int(R[0]) _NEWLINE  _INDENT  _INDENT l = int(L[0]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if not r - l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N7 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N4 += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = L[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = R[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return defMaxProd(L, R, N4=N4, N7=N7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT elif r - l == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rN4 = lN4 = N4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rN7 = lN7 = N7 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rN7 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rN4 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif l == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lN7 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif l == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lN4 += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = L[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = R[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return max(defMaxProd(['0']*len(L), R, N4=rN4, N7=rN7), defMaxProd(L, ['9']*len(R), N4=lN4, N7=lN7)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT elif r - l > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = L[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = R[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N += len(R) _INDENT _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxprod = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if 4 in map(lambda x: x%10, range(l+1, r)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = computeMaxProd(N=N,N4=N4+1,N7=N7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if 7 in map(lambda x: x%10, range(l+1, r)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max( maxprod, computeMaxProd(N,N4,N7+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not maxprod: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = computeMaxProd(N=N,N4=N4,N7=N7) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(['0']*len(L), R, N4=N4, N7=N7+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(['0']*len(L), R, N4=N4+1, N7=N7)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(L, ['9']*len(R), N4=N4, N7=N7+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(L, ['9']*len(R), N4=N4+1, N7=N7)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return maxprod _NEWLINE  _NEWLINE for test in xrange(numOfTests): _NEWLINE  _INDENT  _INDENT L, R = raw_input().split() _NEWLINE  _NEWLINE  _INDENT  _INDENT L = list(L) _NEWLINE  _INDENT  _INDENT R = list(R) _NEWLINE  _NEWLINE  _INDENT  _INDENT L = ['0']*(len(R)-len(L)) + L _NEWLINE  _NEWLINE  _INDENT  _INDENT print defMaxProd(L, R, N=0, N4=0, N7=0) _NEWLINE 
mod = 1000000007 _NEWLINE fact = [1] _NEWLINE for i in xrange(1,5003): _NEWLINE  _INDENT  _INDENT fact.append((i*fact[i-1])%mod) _NEWLINE inv = [] _NEWLINE for j in xrange(5003): _NEWLINE  _INDENT  _INDENT nv = pow(fact[j] , mod-2 , mod) _NEWLINE  _INDENT  _INDENT inv.append(nv) _NEWLINE for j in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT l = raw_input() _NEWLINE  _INDENT  _INDENT four = l.count('4') _NEWLINE  _INDENT  _INDENT seven = l.count('7') _NEWLINE  _INDENT  _INDENT if (four == 0 or seven == 0 ): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (fact[len(l)]*inv[four]*inv[len(l) - four])%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (ans - fact[len(l)-2]*inv[four-1]*inv[len(l)-1-four])%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans%mod
#!/usr/bin/python _NEWLINE # Richard Lee _NEWLINE import os _NEWLINE import sys _NEWLINE  _NEWLINE def champion_possible(team_id, r_m, c_list): _NEWLINE  _INDENT  def team_sort(x, y): _NEWLINE  _INDENT  _INDENT  _INDENT rx = r[x] _NEWLINE  _INDENT  _INDENT  _INDENT ry = r[y] _NEWLINE  _INDENT  _INDENT  _INDENT if rx == ry: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return p[y] - p[x] _NEWLINE  _INDENT  _INDENT  _INDENT return rx - ry _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  def team_sort_r(x, y): _NEWLINE  _INDENT  _INDENT  _INDENT rx = r[x] _NEWLINE  _INDENT  _INDENT  _INDENT ry = r[y] _NEWLINE  _INDENT  _INDENT  _INDENT if rx == ry: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return p[x] - p[y] _NEWLINE  _INDENT  _INDENT  _INDENT return ry - rx _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  r, p, t_a = r_m _NEWLINE  _INDENT  team_sz = len(c_list) _NEWLINE  _INDENT  r[team_id] += p[team_id] _NEWLINE  _INDENT  p[team_id] = 0 _NEWLINE  _INDENT  t_r = t_a[team_id] _NEWLINE  _INDENT  while len(t_r) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT j = t_r.pop() _NEWLINE  _INDENT  _INDENT  _INDENT p[j] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT t_a[j].remove(team_id) _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  c_win = True _NEWLINE  _INDENT  t_l = [i for i in xrange(team_sz)] _NEWLINE  _INDENT  t_l.remove(team_id) _NEWLINE  _INDENT  t_l = sorted(t_l, lambda x,y: team_sort(x,y)) _NEWLINE  _INDENT  while len(t_l) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT t_i = t_l.pop() _NEWLINE  _INDENT  _INDENT  _INDENT t_r = t_a[t_i] _NEWLINE  _INDENT  _INDENT  _INDENT t_s = r[t_i] + p[t_i] _NEWLINE  _INDENT  _INDENT  _INDENT if t_s > r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t_r = sorted(t_r, lambda x,y: team_sort_r(x,y)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t_r_sz = len(t_r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  d = t_s - r[team_id] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for i in xrange(0, t_r_sz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_low = t_r.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r[t_low] + 1 <= r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p[t_i] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p[t_low] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r[t_low] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  t_a[t_low].remove(t_i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  t_r.append(t_low) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if d == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break _NEWLINE  _INDENT  _INDENT  _INDENT r[t_i] += p[t_i] _NEWLINE  _INDENT  _INDENT  _INDENT if r[t_i] > r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  c_win = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  break _NEWLINE  _INDENT  _INDENT  _INDENT elif p[t_i] > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  while len(t_r) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_low = t_r.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[t_low] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_a[t_low].remove(t_i) _NEWLINE  _INDENT  if c_win: _NEWLINE  _INDENT  _INDENT  _INDENT for i in xrange(team_sz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if r[i] == r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c_list[i] = 1 _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT _NEWLINE tc = int(sys.stdin.readline()) _NEWLINE for t_i in xrange(tc): _NEWLINE  _INDENT  teamcount = int(sys.stdin.readline()) _NEWLINE  _INDENT  max_s = 0 _NEWLINE  _INDENT  r = [0 for i in xrange(teamcount)] _NEWLINE  _INDENT  t = r[:] _NEWLINE  _INDENT  p = r[:] _NEWLINE  _INDENT  champ_list = r[:] _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  for i in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT l = sys.stdin.readline().rstrip() _NEWLINE  _INDENT  _INDENT  _INDENT l_p = l.split() _NEWLINE  _INDENT  _INDENT  _INDENT t_r = [] _NEWLINE  _INDENT  _INDENT  _INDENT for j in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  c = int(l_p[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if c == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  elif c == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_r.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT if r[i] > max_s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  max_s = r[i] _NEWLINE  _INDENT  _INDENT  _INDENT t[i] = t_r _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  if max_s == 0: _NEWLINE  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  for i in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT if r[i] + p[i] >= max_s and not champ_list[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t_c = [0 for j in xrange(teamcount)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for j in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_c[j] = t[j][:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  champion_possible(i, (r[:],p[:],t_c), champ_list) _NEWLINE  _NEWLINE  _INDENT  s_o = "" _NEWLINE  _INDENT  for i in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT s_o += "%i" %(champ_list[i]) _NEWLINE  _INDENT  print s_o _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE exit(0) _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
tests = int(raw_input()) _NEWLINE while tests: _NEWLINE 	K = int(raw_input()) _NEWLINE 	digits = map(int, str(K)) _NEWLINE 	highest = 100 _NEWLINE 	perm = range(highest, highest - digits[0], -1) _NEWLINE 	highest -= digits[0] _NEWLINE 	for i, d in enumerate(digits[1:], 1): _NEWLINE 		perm[0:0] = range(highest, highest - 10, -1) _NEWLINE 		highest -= 10 _NEWLINE 		perm.extend(range(highest - i, highest - d - i, -1) + range(highest - i + 1, highest + 1)) _NEWLINE 		highest -= d + i _NEWLINE 	perm[0:0] = range(1, highest + 1) _NEWLINE 	print len(perm) _NEWLINE 	print " ".join(map(str, perm)) _NEWLINE 	tests -= 1 _NEWLINE 
from fractions import Fraction _NEWLINE k = int(raw_input()) _NEWLINE i=0 _NEWLINE  _NEWLINE def fct(n,k): _NEWLINE  _INDENT  _INDENT ct=Fraction(1,1) _NEWLINE  _INDENT  _INDENT if n-k>k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ct*=Fraction(n,k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ct _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while n-k>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ct*=Fraction(n,n-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #k+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ct _INDENT  _INDENT _NEWLINE  _NEWLINE while i<k: _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,r=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n-r==0: print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print fct(n-1,r-1) _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break 
import sys _NEWLINE  _INDENT _NEWLINE mod= 100000000000007 _NEWLINE a=[0]*10004 _NEWLINE a[0]=1 _NEWLINE a[1]=0 _NEWLINE for j in xrange(2,10002): _NEWLINE 	a[j]=(j-1)*(2*a[j-1]+3*a[j-2])/(j+1) _NEWLINE for j in xrange(0,10002): _NEWLINE 	a[j]=(a[j]+a[j+1]) _NEWLINE #print a[10000] _NEWLINE #print filter(lambda y: y==0, [x%(43**3) for x in a[1:10001]]) _NEWLINE  _INDENT _NEWLINE c=[0]*10004 _NEWLINE c[0]=1 _NEWLINE for j in xrange(0,10001): _NEWLINE 	c[j+1]=2*(2*j+1)*c[j]/(j+2) _NEWLINE 	 _NEWLINE #for j in xrange(0,10001): _NEWLINE #	c[j]%=mod _NEWLINE #print c[:20] _NEWLINE #print a[:20] _NEWLINE  _INDENT _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	n,k=map(int,sys.stdin.readline().split()) _NEWLINE 	if k==0: _NEWLINE 		print 0 _NEWLINE 	elif n==0: _NEWLINE 		print 0 _NEWLINE 	elif k==1: _NEWLINE 		w=a[n]%mod-1 _NEWLINE 		if w>=0: _NEWLINE 			print w _NEWLINE 		else: _NEWLINE 			print mod-1 _NEWLINE 	elif k>=2: _NEWLINE 		w=c[n]%mod-1 _NEWLINE 		if w>=0: _NEWLINE 			print w _NEWLINE 		else: _NEWLINE 			print mod-1 
def opt(par,data): _NEWLINE  _INDENT  _INDENT fail,total=par _NEWLINE  _INDENT  _INDENT success=0 _NEWLINE  _INDENT  _INDENT data=sorted(data) _NEWLINE  _INDENT  _INDENT for a in data: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT half=a/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(total-half<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total-=half _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fail-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT half=a/2+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(total-half<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total-=half _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fail-=1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT for a in data: _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT remhalf=a/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(total-remhalf<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total-=remhalf _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT success+=1 _NEWLINE  _INDENT  _INDENT return str(fail)+" "+str(success) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE def process(s): _NEWLINE  _INDENT  _INDENT return map(int,s.split()) _NEWLINE  _NEWLINE print opt(process(raw_input()),process(raw_input())) _NEWLINE 
from sys import stdin _NEWLINE readln = stdin.readline _NEWLINE while True : _NEWLINE 	line = readln() _NEWLINE 	if len(line)==0 : break; _NEWLINE 	N = int(line) _NEWLINE 	data = map(int,readln().split()) _NEWLINE 	mixtures = [ [0]*N for i in xrange(N) ] _NEWLINE 	smoke _INDENT  _INDENT = [ [-1]*N for i in xrange(N) ] _NEWLINE 	 _NEWLINE 	for i in xrange(N): _INDENT _NEWLINE 		mixtures[i][i] = data[i] _NEWLINE 		smoke[i][i] = 0 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	for j in xrange(1,N): _NEWLINE 		for i in xrange(j-1,-1,-1): _NEWLINE 			for k in xrange(i,j): _NEWLINE 				smk = smoke[i][k]+smoke[k+1][j]+mixtures[i][k]*mixtures[k+1][j] _NEWLINE 				mix = (mixtures[i][k]+mixtures[k+1][j])%100 _NEWLINE 				if smoke[i][j]==-1 or smk<smoke[i][j] : _NEWLINE 					smoke[i][j] = smk _NEWLINE 					mixtures[i][j] = mix _NEWLINE 				 _NEWLINE 	print smoke[0][N-1]
# your code goes here _NEWLINE t=int(raw_input()) _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	n=int(raw_input()) _NEWLINE 	arr=raw_input().split(' ') _NEWLINE 	arr=map(int, arr) _NEWLINE 	a,b,c=(raw_input().split(' ')) _NEWLINE 	a=int(a) _NEWLINE 	b=int(b) _NEWLINE 	c=int(c) _NEWLINE 	bo=True _NEWLINE 	mul=1 _NEWLINE 	add=0 _NEWLINE 	i=0 _NEWLINE 	j=n-1 _NEWLINE 	str=raw_input() _NEWLINE 	for o in str: _NEWLINE 		if (o=='R'): _NEWLINE 			bo=not bo _NEWLINE 		elif (o=='A'): _NEWLINE 			add=(add+a)%c _NEWLINE 		else: _NEWLINE 			add=(add*b)%c _NEWLINE 			mul=(mul*b)%c _NEWLINE 		if(bo): _NEWLINE 			print ((arr[i]*mul)%c+add)%c, _NEWLINE 			i+=1 _NEWLINE 		else: _NEWLINE 			print ((arr[j]*mul)%c+add)%c, _NEWLINE 			j-=1 _NEWLINE 	print '' _NEWLINE 	 _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <queue> _NEWLINE #include <cassert> _NEWLINE #define rep(i,a,n) for(int i=a;i<n;i++) _NEWLINE #define in(n) scanf("%d",&n) _NEWLINE #define inl(n) scanf("%lld",&n) _NEWLINE #define out(n) printf("%d ",n) _NEWLINE #define outln(n) printf("%d\n",n) _NEWLINE #define outl(n) printf("%lld ",n) _NEWLINE #define outlln(n) printf("%lld\n",n) _NEWLINE #define LL long long _INDENT _NEWLINE #define pb push_back _NEWLINE #define f first _NEWLINE #define s second _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int a[10]; _NEWLINE long long int n; _NEWLINE double x,y,s; _NEWLINE double g[10][4]; _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE void ne(double tmp[], double& xx, double& yy, double tt) { _NEWLINE  _INDENT  _INDENT xx = tmp[0] + tmp[2]*tt; _NEWLINE  _INDENT  _INDENT yy = tmp[1] + tmp[3]*tt; _NEWLINE } _NEWLINE  _INDENT _NEWLINE double re(double tmp[], double xx, double yy, double tt) { _NEWLINE  _INDENT  _INDENT double py = tmp[1], px = tmp[0], vx = tmp[2], vy = tmp[3]; _NEWLINE  _INDENT  _INDENT px = px + vx * tt, py = py + vy * tt; _NEWLINE  _INDENT  _INDENT double aa = s*s - vy*vy - vx*vx; _NEWLINE  _INDENT  _INDENT double bb = -2*((py - yy)*vy + (px-xx)*vx); _NEWLINE  _INDENT  _INDENT double cc = -1*(py-yy)*(py-yy) + -1LL*(px-xx)*(px-xx); _NEWLINE  _INDENT  _INDENT double aax; _NEWLINE  _INDENT  _INDENT double sol1 = -bb + (aax = sqrt(bb*bb - 4 * aa * cc)); _NEWLINE  _INDENT  _INDENT double sol2 = -bb - aax; _NEWLINE  _INDENT  _INDENT if(sol2 > 0.0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return sol2/(2*aa); _NEWLINE  _INDENT  _INDENT return sol1/(2*aa); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int nt, kase = 1; _NEWLINE  _INDENT  _INDENT while(1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double ix, iy; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i,0,10)a[i] = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double mint = 1000000000000000000LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(inl(n)==EOF)break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n==0LL)break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i,0,n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(tt,0,4)scanf("%lf",&g[i][tt]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lf%lf%lf",&x,&y,&s); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ix = x, iy = y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT do { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = ix, y = iy; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double cur = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double xx = re(g[a[i]], x, y, cur/3600LL); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double tt = xx*3600LL + 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur += tt; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ne(g[a[i]], x, y, cur/3600LL); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double back = (x - ix)*(x-ix) + (y-iy)*(y-iy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT back = sqrt(back); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT back /= s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT back = back * 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mint = min(mint, cur + back); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(next_permutation(a,a+n)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long miint = ceil(mint); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long hrs = miint / 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT miint = miint % 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long mins = miint / 60LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT miint = miint % 60LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d %lld %lld %lld\n",kase++, hrs, mins, miint); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<queue> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	cin >> T; _NEWLINE 	long long int waiting[1000000]; _NEWLINE 	while(T--){ _NEWLINE 		long long int p, q, m, n, k; _NEWLINE 		scanf("%lld%lld%lld%lld%lld",&p,&q,&m,&n,&k); _NEWLINE 		long long int alreadyTook = 0; _NEWLINE 		long long int readyToLand = p; _NEWLINE 		long long int alreadyLanded = 0; _NEWLINE 		long long int initial = 0; _NEWLINE 		long long int final = -1; _NEWLINE 		long long int waitingCount = 0; _NEWLINE 		long long int readyToFly = q; _NEWLINE 		queue <long long int> temp; _NEWLINE 		for (long long int i=1;i<k+2;i++){ _NEWLINE 			if(! temp.empty()){	 _NEWLINE 			if(temp.front()+n <= i){ _NEWLINE 				temp.pop(); _NEWLINE 				readyToFly++; _NEWLINE 			} _NEWLINE 			} _NEWLINE 			if(readyToLand){ _NEWLINE 				readyToLand--; _NEWLINE 				alreadyLanded++; _NEWLINE 				//insert _NEWLINE 				temp.push(i); _NEWLINE 				//final++; _NEWLINE 				//waiting[final] = n; _NEWLINE 			} _NEWLINE 			else if(readyToFly){ _NEWLINE 				readyToFly--; _NEWLINE 				alreadyTook++; _NEWLINE 			} _NEWLINE 			if ((i)%m == 0 ){ _NEWLINE 				readyToLand++; _NEWLINE 			} _NEWLINE 		//cout << _INDENT alreadyTook << " " << readyToLand << " " << waitingCount << " " << readyToFly << endl; _NEWLINE 		} _NEWLINE 		//printf("%lld %lld %lld %lld\n", alreadyLanded, alreadyTook, readyToLand, _INDENT _NEWLINE  _INDENT _NEWLINE 		cout << alreadyLanded << " " << alreadyTook << " " << readyToLand << " " << readyToFly+temp.size() << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
/* package codechef; // don't place package name! */ _NEWLINE  _NEWLINE import java.util.*; _NEWLINE import java.lang.*; _NEWLINE import java.io.*; _NEWLINE  _NEWLINE /* Name of the class has to be "Main" only if the class is public. */ _NEWLINE class Codechef _NEWLINE { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT static int ans(int[][] a,int order) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(order==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a[0][0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int max=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<order;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int[][] b = new int[order-1][order-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<order;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int subindex=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<order;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i!=k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[j-1][subindex++] = a[j][k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int temp = a[0][i] + ans(b,order-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp>max) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return max; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	public static void main (String[] args) throws java.lang.Exception _NEWLINE 	{ _NEWLINE 		// your code goes here _NEWLINE 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); _NEWLINE 		 _NEWLINE 		int given[][]={ _NEWLINE 			{55,60,4,25,18,10,12,8,11,50}, _NEWLINE 			{60,45,75,23,27,20,24,7,33,12}, _NEWLINE 			{4,75,78,32,36,30,36,6,12,65}, _NEWLINE 			{25,23,32,15,45,40,48,5,14,23}, _NEWLINE 			{18,27,36,45,54,50,60,4,15,12}, _NEWLINE 			{10,20,30,40,50,60,72,3,32,34}, _NEWLINE 			{12,24,36,48,60,72,84,2,23,34}, _NEWLINE 			{8,7,6,5,4,3,2,1,34,123}, _NEWLINE 			{11,33,12,14,15,32,23,34,65,48}, _NEWLINE 			{50,12,65,23,12,34,34,123,48,71} _NEWLINE 		}; _NEWLINE 		 _NEWLINE 		int T = Integer.parseInt(br.readLine()); _NEWLINE 		for(int p=0;p<T;p++) _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT  _NEWLINE 		 _INDENT  String line = _INDENT br.readLine(); _NEWLINE 		 _INDENT line = br.readLine(); _NEWLINE 		 _INDENT  _NEWLINE 		 _INDENT String[] h = line.split(" "); _NEWLINE 		 _INDENT int[] reward = new int[7]; _NEWLINE 		 _INDENT int count=0; _NEWLINE 		 _INDENT for(int i=0;i<10;i++) _NEWLINE 		 _INDENT { _NEWLINE 		 _INDENT  _INDENT  _INDENT int x = Integer.parseInt(h[i]); _NEWLINE 		 _INDENT if(x==1) _NEWLINE 		 _INDENT reward[count++] = i; _NEWLINE 		 _INDENT  _INDENT  _INDENT  _NEWLINE 		 _INDENT } _INDENT _NEWLINE 		 _INDENT int[][] a = new int[count][count]; _NEWLINE 		 _INDENT  _NEWLINE 		 _INDENT for(int i=0;i<count;i++) _NEWLINE 		 _INDENT { _NEWLINE 		 _INDENT  _INDENT  _INDENT for(int j=0;j<count;j++) _NEWLINE 		 _INDENT  _INDENT  _INDENT { _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j] = given[reward[i]][reward[j]]; _NEWLINE 		 _INDENT  _INDENT  _INDENT } _NEWLINE 		 _INDENT } _NEWLINE 		 _INDENT  int finalans _INDENT = ans(a,count); _NEWLINE 	 _INDENT  out.write(Integer.toString(finalans)); _NEWLINE 		 _INDENT  out.newLine(); _NEWLINE 		} _NEWLINE 		out.flush(); _NEWLINE 	} _NEWLINE } _NEWLINE 
MAXN = 30 _NEWLINE  _NEWLINE hash = [[2,2] for i in range(MAXN+1)] _NEWLINE hash[0] = [0,0] _NEWLINE  _NEWLINE for i in range(2, MAXN + 1): _NEWLINE 	hash[i][0] = (i+1) + hash[i/2][0] + hash[i-i/2 - 1][0] _NEWLINE 	hash[i][1] = (i+1) + hash[i-1][1] _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t): _NEWLINE 	(n,m) = tuple(map(int, str(raw_input()).split(' '))) _NEWLINE  _NEWLINE 	if m>=hash[n][0] and m<=hash[n][1]: _NEWLINE 		print(0) _NEWLINE 	elif m>hash[n][1]: _NEWLINE 		print(m - hash[n][1]) _NEWLINE 	else: _NEWLINE 		print(-1) _NEWLINE  _NEWLINE 
 _NEWLINE def factor(n): _NEWLINE  _INDENT """ _NEWLINE  _INDENT factorize a number _NEWLINE  _INDENT """ _NEWLINE  _INDENT r = {} _NEWLINE  _INDENT q = 2 _NEWLINE  _INDENT w = int(n**.5)+1 _NEWLINE  _INDENT while n > 1 and q <= w: _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _INDENT  _INDENT while n % q == 0: n /= q; c += 1 _NEWLINE  _INDENT  _INDENT if c: r[q] = c _NEWLINE  _INDENT  _INDENT q += 1 _NEWLINE  _INDENT if n > 1: r[n] = 1 _INDENT  _NEWLINE  _INDENT return r _NEWLINE  _NEWLINE def join(f, g): _NEWLINE  _INDENT for k in g: _NEWLINE  _INDENT  _INDENT if k in f: _NEWLINE  _INDENT  _INDENT  _INDENT f[k] += g[k] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT f[k] = g[k] _NEWLINE  _NEWLINE T = input() _NEWLINE for t in range(T): _NEWLINE  _INDENT l = input() _NEWLINE  _INDENT s = map(int,raw_input().split()) _NEWLINE  _INDENT f = {} _NEWLINE  _INDENT for q in s: _NEWLINE  _INDENT  _INDENT g = factor(q) _NEWLINE  _INDENT  _INDENT join(f, g) _NEWLINE  _INDENT p = 1 _NEWLINE  _INDENT for d in f.values(): _NEWLINE  _INDENT  _INDENT p *= d + 1 _NEWLINE  _INDENT print p _INDENT 
import sys _NEWLINE import math _NEWLINE  _NEWLINE # def ndigits(n): _NEWLINE  _INDENT  _INDENT # return int(math.floor(math.log10(n)) + 1.1) _NEWLINE # _INDENT _NEWLINE # m = 10**100 _NEWLINE # _INDENT _NEWLINE # def tostr(n): _NEWLINE  _INDENT  _INDENT # if n < m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # return str(n) _NEWLINE  _INDENT  _INDENT # ndig = ndigits(n) _NEWLINE  _INDENT  _INDENT # botdig = ndig//2 _NEWLINE  _INDENT  _INDENT # mid = 10 ** botdig _NEWLINE  _INDENT  _INDENT # top = tostr(n // mid) _NEWLINE  _INDENT  _INDENT # bot = tostr(n % mid) _NEWLINE  _INDENT  _INDENT # if len(bot) != botdig: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # return top + '0'*(botdig - len(bot)) + bot _NEWLINE  _INDENT  _INDENT # return top + bot _NEWLINE  _NEWLINE DIG = 300 _NEWLINE MAX = 10**DIG _NEWLINE M2 = (MAX >> 1) _NEWLINE  _NEWLINE def div2(l): _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] & 1 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i-1] += MAX/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i] /= 2 _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i] += MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i+1] -= 1 _NEWLINE  _INDENT  _INDENT if l[-1] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT del l[-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def add1(l): _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] < MAX: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == len(l)-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _NEWLINE def multlists(l1, l2): _NEWLINE  _INDENT  _INDENT rtn = [0] * (len(l1) + len(l2) - 1) _NEWLINE  _INDENT  _INDENT for i in xrange(len(l1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(l2)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rtn[i+j] += l1[i] * l2[j] _NEWLINE  _INDENT  _INDENT # print rtn _NEWLINE  _INDENT  _INDENT for i in xrange(len(rtn)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn[i+1] += rtn[i] / MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn[i] %= MAX _NEWLINE  _INDENT  _INDENT while rtn[-1] > MAX: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = rtn[-1] / MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn[-1] %= MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn.append(n) _NEWLINE  _INDENT  _INDENT return rtn _NEWLINE  _NEWLINE def fromstr(s): _NEWLINE  _INDENT  _INDENT chars = list(reversed(s)) _NEWLINE  _INDENT  _INDENT # print chars _NEWLINE  _INDENT  _INDENT l = [int(''.join(reversed(chars[i:i+DIG]))) for i in xrange(0, len(chars), DIG)] _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE def tolist(n): _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(n % MAX) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n /= MAX _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE t = int(sys.stdin.readline()) _NEWLINE for _t in xrange(t): _NEWLINE  _INDENT  _INDENT s = sys.stdin.readline() _NEWLINE  _INDENT  _INDENT n = fromstr(s.strip()) _NEWLINE  _INDENT  _INDENT # print n _NEWLINE  _INDENT  _INDENT n1 = list(n) _NEWLINE  _INDENT  _INDENT add1(n1) _NEWLINE  _INDENT  _INDENT if n[0] & 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT div2(n1) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT div2(n) _NEWLINE  _INDENT  _INDENT # print n _NEWLINE  _INDENT  _INDENT # print n1 _NEWLINE  _INDENT  _INDENT x = multlists(n, n1) _NEWLINE  _INDENT  _INDENT # print x _NEWLINE  _INDENT  _INDENT sys.stdout.write('%d' % x.pop()) _NEWLINE  _INDENT  _INDENT FMT = '%%0%dd' % DIG _NEWLINE  _INDENT  _INDENT for i in reversed(x): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write(FMT % i) _NEWLINE  _INDENT  _INDENT print _NEWLINE 
t=int(raw_input()) _NEWLINE def powerfn(n,power): _NEWLINE 	value=1 _NEWLINE 	while power>0 : _NEWLINE 		 _NEWLINE 		if not power%2==0: _NEWLINE 			value=value*n _NEWLINE 			value=value%1000000007 _NEWLINE 		n=n*n _NEWLINE 		n=n%1000000007 _NEWLINE 		power=power/2 _NEWLINE 	return value _NEWLINE def inversemod(n): _NEWLINE 	return powerfn(n,1000000005) _NEWLINE factorial=[1] _NEWLINE for i in range(1,2000002): _NEWLINE 	factor=(i*factorial[i-1])%1000000007 _NEWLINE 	factorial.append(factor) _NEWLINE def combination(n,r): _NEWLINE 	if n<r: _NEWLINE 		return 0 _NEWLINE 	else: _NEWLINE 		return (factorial[n]*((inversemod(factorial[r])*inversemod(factorial[n-r]))%1000000007))%1000000007 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE for i in range(t): _NEWLINE 	n,k=map(int,raw_input().split(" ")) _NEWLINE 	print (((2*combination(n+k+1,k+2))%1000000007)-n+1000000007)%1000000007
def res(l,n): _NEWLINE 	l.sort(key=lambda x:x[0]) _NEWLINE 	ans=[l[0]] _NEWLINE 	 _NEWLINE 	for i in range(1,n): _NEWLINE 		 _NEWLINE 		if ans[-1][1]<l[i][0] : _NEWLINE 			ans.append(l[i]) _NEWLINE 		if ans[-1][1]>l[i][0] and ans[-1][1]<l[i][1]: _NEWLINE 			k=ans[-1][1] _NEWLINE 			ans=ans[:len(ans)-1] _NEWLINE 			ans.append((l[i][0],k)) _NEWLINE 		if ans[-1][1]>l[i][0] and ans[-1][1]>l[i][1]: _NEWLINE 			ans=ans[:len(ans)-1] _NEWLINE 			ans.append(l[i]) _NEWLINE  _NEWLINE 		 _NEWLINE  _NEWLINE 	return len(ans) _NEWLINE  _NEWLINE 	 _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	n=int(raw_input()) _NEWLINE 	l=[] _NEWLINE 	for i in range(0,n): _NEWLINE 		p,q=raw_input().split() _NEWLINE 		ran=(int(p),int(q)) _NEWLINE 		l.append(ran) _NEWLINE 	print res(l,n) _NEWLINE 	t-=1	 _NEWLINE  _NEWLINE 
INFINITY = 10**9+7 _NEWLINE from heapq import * _NEWLINE def dijkstra(s): _NEWLINE 	global mini _NEWLINE 	q, seen = [(0, s)], set() _NEWLINE 	while q: _NEWLINE 		cost, v1 = heappop(q) _NEWLINE 		if v1 not in seen: _NEWLINE 			seen.add(v1) _NEWLINE 			shortestDistance[v1] = cost _NEWLINE 			if cost > mini: _NEWLINE 				break _NEWLINE 			if specials[v1] == 1: _NEWLINE 				if v1 != s: _NEWLINE 					mini = cost _NEWLINE 					break _NEWLINE 			for c, v2 in g[v1]: _NEWLINE 				if v2 not in seen: _NEWLINE 					heappush(q, (cost+c, v2)) _NEWLINE  _NEWLINE N, M, K = map(int, raw_input().split()) _NEWLINE A = map(int, raw_input().split()) _NEWLINE specials = [-1 for _ in xrange(N+1)] _NEWLINE for a in A: _NEWLINE 	specials[a] = 1 _NEWLINE g = [[] for _ in xrange(N+1)] _NEWLINE for m in xrange(M): _NEWLINE 	X, Y, Z = map(int, raw_input().split()) _NEWLINE 	g[X].append((Z, Y)) _NEWLINE 	g[Y].append((Z, X)) _NEWLINE ds = [] _NEWLINE mini = INFINITY _NEWLINE shortestDistance = [-1 for _ in xrange(N+1)] _NEWLINE for i in xrange(1, K+1): _NEWLINE 	if shortestDistance[A[i-1]] == -1: _NEWLINE 		dijkstra(A[i-1]) _NEWLINE print mini
def solution(): _NEWLINE  _INDENT  _INDENT T = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT for i in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT numb = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print palindrome(numb) _NEWLINE  _NEWLINE def palindrome(numb): _NEWLINE  _INDENT  _INDENT len_numb = len(numb) _NEWLINE  _NEWLINE  _INDENT  _INDENT if numb == '9' * len_numb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(numb) + 2 _NEWLINE  _NEWLINE  _INDENT  _INDENT if len_numb == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if numb == '9': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return int(numb) + 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return int(numb) + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT mid = len_numb // 2 _NEWLINE  _INDENT  _INDENT left = numb[0:mid] _NEWLINE  _INDENT  _INDENT # print left, right _NEWLINE  _INDENT  _INDENT if len_numb % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT center = '' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT center = numb[mid] _NEWLINE  _INDENT  _INDENT right = left[::-1] _NEWLINE  _INDENT  _INDENT string = left + center + right _NEWLINE  _INDENT  _INDENT # print string _NEWLINE  _INDENT  _INDENT if string > numb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return string _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT if (len_numb % 2) != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if center != '9': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT center = str(int(center) + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT string = left + center + right _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return string _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT center = '0' _NEWLINE  _NEWLINE  _INDENT  _INDENT left_list = list(left) _NEWLINE  _INDENT  _INDENT i = mid - 1 _NEWLINE  _INDENT  _INDENT while left_list[i] == '9': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT left_list[i] = '0' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i -= 1 _NEWLINE  _INDENT  _INDENT left_list[i] = str(int(left[i]) + 1) _NEWLINE  _INDENT  _INDENT left = ''.join(k for k in left_list) _NEWLINE  _INDENT  _INDENT right = left[::-1] _NEWLINE  _INDENT  _INDENT string = left + center + right _NEWLINE  _NEWLINE  _INDENT  _INDENT return string _NEWLINE solution() _NEWLINE 
#parallel.py _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE  _NEWLINE #n=5 _NEWLINE nstep = 0 _NEWLINE total = 0 _NEWLINE for xx in range(1): _NEWLINE ## _INDENT  _INDENT if xx==0: _NEWLINE ## _INDENT  _INDENT  _INDENT  _INDENT n=501 _NEWLINE ## _INDENT  _INDENT else: _NEWLINE ## _INDENT  _INDENT  _INDENT  _INDENT n=500 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT lines = [] _NEWLINE  _INDENT  _INDENT k=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while k<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT steps="" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(k,n,2*k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i+k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT step = " "+ str(i)+"+"+str(j)+"="+str(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT steps += step _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = str(count)+steps _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lines.append(line) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total += count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nstep +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k *=2 _NEWLINE  _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _NEWLINE  _INDENT  _INDENT k//=2 _NEWLINE  _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _INDENT  _INDENT while k>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT steps="" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(k,n+1,k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i+k/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT step = " "+ str(i)+"+"+str(j)+"="+str(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT steps += step _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = str(count)+steps _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lines.append(line) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total += count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nstep +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k /=2 _NEWLINE  _NEWLINE  _NEWLINE print nstep _NEWLINE for line in lines: _NEWLINE  _INDENT  _INDENT print line _NEWLINE  _NEWLINE #print nstep, total _NEWLINE 
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n,f=map(long,raw_input().split()) _NEWLINE  _INDENT  _INDENT a=map(long,raw_input().split()) _NEWLINE  _INDENT  _INDENT l=[] _NEWLINE  _INDENT  _INDENT d={} _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k%f==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k/=f _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[k]=0 _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[i]+=1 _NEWLINE  _INDENT  _INDENT ans=0L _NEWLINE  _INDENT  _INDENT for i in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=(d[i]*(d[i]-1))/2 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
def gcd(a, b): _NEWLINE  _INDENT  _INDENT while b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a, b = b, a%b _NEWLINE  _INDENT  _INDENT return a _NEWLINE  _NEWLINE def solve(a,b,c): _NEWLINE  _INDENT  _INDENT if c==0:return 0 _NEWLINE  _INDENT  _INDENT if c==a or c==b:return 1 _NEWLINE  _INDENT  _INDENT if a>b:a,b=b,a _NEWLINE  _INDENT  _INDENT if c>b:return -1 _NEWLINE  _INDENT  _INDENT if c==b-a:return 2 _NEWLINE  _INDENT  _INDENT d=gcd(a,b) _NEWLINE  _INDENT  _INDENT if d!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c%d:return -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a/=d;b/=d;c/=d; _NEWLINE  _INDENT  _INDENT q=b/a _NEWLINE  _INDENT  _INDENT rk=0 _NEWLINE  _INDENT  _INDENT r=a _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c==r:return rk _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rk+=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c==b-r:return rk _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=r;y=b-r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(1,q+2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x+=a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=b-x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rk+=2 _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y<0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=-y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c==x or c==y:return rk _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT a=int(raw_input()) _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT c=int(raw_input()) _NEWLINE  _INDENT  _INDENT print solve(a,b,c) _NEWLINE 
#!/usr/bin/env python _NEWLINE #-*- coding:utf-8 -*- _NEWLINE  _NEWLINE import random _NEWLINE  _NEWLINE  _NEWLINE def count_bits(n): _NEWLINE  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n >>= 1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT lst = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT #lst = [random.randint(0, (1 << 16) - 1) for i in range(10**5)] _NEWLINE  _NEWLINE  _INDENT  _INDENT n_bits = count_bits(max(lst)) _NEWLINE  _INDENT  _INDENT counts = [(0, 0, 0) for _ in range(n_bits)] _NEWLINE  _INDENT  _INDENT for num in lst: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, (c0, c1, count) in enumerate(counts): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bit = (num & (1 << i)) >> i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if bit == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0, c1 = c1, c0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c1 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += c1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counts[i] = c0, c1, count _NEWLINE  _NEWLINE  _INDENT  _INDENT result = 0 _NEWLINE  _INDENT  _INDENT for i, (c0, c1, count) in enumerate(counts): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result += count << i _NEWLINE  _NEWLINE  _INDENT  _INDENT print result _NEWLINE  _NEWLINE ''' _NEWLINE count = 0 _NEWLINE  _NEWLINE c0, c1 = 0, 0 _NEWLINE for i, bit in enumerate(lst): _NEWLINE  _INDENT  _INDENT #print c0, c1, "bit", bit, "->", _NEWLINE  _INDENT  _INDENT if bit == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c0, c1 = c1, c0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c1 += 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c0 += 1 _NEWLINE  _INDENT  _INDENT count += c1 _NEWLINE  _INDENT  _INDENT #print c0, c1, "count", count _NEWLINE  _NEWLINE print count _NEWLINE ''' _NEWLINE 
"""Prime Generator _NEWLINE  _NEWLINE  _NEWLINE All submissions for this problem are available. _NEWLINE  _NEWLINE Shridhar wants to generate some prime numbers for his cryptosystem. Help him! Your task is to generate all prime numbers between two given numbers. _NEWLINE Input _NEWLINE  _NEWLINE The first line contains t, the number of test cases (less then or equal to 10). Followed by t lines which contain two numbers m and n (1 <= m <= n <= 1000000000, n-m<=100000) separated by a space. _NEWLINE Output _NEWLINE  _NEWLINE For every test case print all prime numbers p such that m <= p <= n, one number per line. Separate the answers for each test case by an empty line. _NEWLINE Example _NEWLINE  _NEWLINE Input: _NEWLINE 2 _NEWLINE 1 10 _NEWLINE 3 5 _NEWLINE  _NEWLINE Output: _NEWLINE 2 _NEWLINE 3 _NEWLINE 5 _NEWLINE 7 _NEWLINE  _NEWLINE 3 _NEWLINE 5 _NEWLINE  _NEWLINE Warning: large Input/Output data, be careful with certain languages (though most should be OK if the algorithm is well designed) """ _NEWLINE  _NEWLINE import random _NEWLINE  _NEWLINE def getkq(no): _NEWLINE  _INDENT  _INDENT x = 0 _NEWLINE  _INDENT  _INDENT while no % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT no /= 2 _NEWLINE  _INDENT  _INDENT return (x, no) _NEWLINE  _NEWLINE def primalityTest(no): _NEWLINE  _INDENT  _INDENT (k, q) = getkq(no-1) _NEWLINE  _INDENT  _INDENT a = random.randint(2, no - 2) _NEWLINE  _INDENT  _INDENT # print "no = ", no, "a = ", a _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT x = pow(a, q, no) _NEWLINE  _INDENT  _INDENT no -= 1 _NEWLINE  _INDENT  _INDENT if (x == 1) or (x == no) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT i = 1 _NEWLINE  _INDENT  _INDENT while i < k : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = pow(x, 2, (no+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x == no : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _NEWLINE def primeGenerator(): _NEWLINE  _INDENT  _INDENT t = eval(raw_input()) _NEWLINE  _INDENT  _INDENT while t > 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (j, end) = (raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = eval(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end = eval(end) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == 2 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == 3 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j <= end: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print "j = ", j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print "i at start = ", i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isPrime = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (i <= 5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print "i = ", i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if primalityTest(j) == False : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isPrime = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isPrime : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT  _NEWLINE if __name__ == "__main__" : _NEWLINE  _INDENT  _INDENT # i = 1; _NEWLINE  _INDENT  _INDENT # while i < 10: _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT  print i _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT  i += 1 _NEWLINE  _INDENT  _INDENT primeGenerator() _NEWLINE  _INDENT  _INDENT 
def isvalid(s, c): _NEWLINE  _INDENT  _INDENT if c.difference(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT l = raw_input().split() _NEWLINE  _INDENT  _INDENT s = set(l) _NEWLINE  _INDENT  _INDENT answer = 0 _NEWLINE  _INDENT  _INDENT for _ in xrange(111, 1000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = [i for i in str(_)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isvalid(s, set(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for __ in xrange(11, 100): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = [i for i in str(__)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isvalid(s, set(b)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1 = _ * int(b[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a2 = _ * int(b[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT final = (a1*10)+a2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1_set = set([i for i in str(a1)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a2_set = set([i for i in str(a2)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT final_set = set([i for i in str(final)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a1<1000 and a2 < 1000 and final < 10000 and isvalid(s, a1_set) and isvalid(s, a2_set) and isvalid(s, final_set): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT answer += 1 _NEWLINE  _INDENT  _INDENT print answer _NEWLINE main() _NEWLINE 
import sys _NEWLINE  _NEWLINE def get_int(): _NEWLINE  _INDENT  _INDENT return int(sys.stdin.readline()) _NEWLINE  _NEWLINE def get_ints(): _NEWLINE  _INDENT  _INDENT return [int(i) for i in sys.stdin.readline().split()] _NEWLINE  _NEWLINE def find_max(line, pos, L, H): _NEWLINE  _INDENT  _INDENT for i in range(H-L): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT new_pos = [ j + 1 for j in pos if j != len(line) - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print 'new', new_pos _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(new_pos) < len(pos): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(pos), L+i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i0 in range(len(new_pos) -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if line[new_pos[i0]] != line[new_pos[i0+1]]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(pos), L+i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos = new_pos _NEWLINE  _INDENT  _INDENT return len(pos), H _NEWLINE  _NEWLINE def run(): _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L, H = get_ints() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if L == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = sys.stdin.readline()[:-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Find the maximun occurrence of length L _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dd = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(line)-L+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = line[i:i+L] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dd.setdefault(s, []).append(i+L-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_l = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poses = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT br = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print line, dd _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k, v in dd.viewitems(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(v) > max_l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_l = len(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT poses = [v,] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif len(v) == max_l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT poses.append(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_l = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = None _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for pos in poses: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m = find_max(line, pos, L, H) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print 'm', m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m[1] > max_l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_l = m[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print r[0], r[1] _NEWLINE  _NEWLINE  _NEWLINE run() _NEWLINE 
from sys import stdin _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE adjList={} _NEWLINE def ConnectedComp(V): _NEWLINE  dfs_num=[0]*(len(V)+1) _NEWLINE  def dfs(i,cc): _NEWLINE  _INDENT dfs_num[i]=True _NEWLINE  _INDENT cc.add(i) _NEWLINE  _INDENT for j in adjList[i]: _NEWLINE  _INDENT  if not dfs_num[j]: dfs(j,cc) _NEWLINE  _INDENT return cc _NEWLINE  ccset=[] _NEWLINE  for i in V: _NEWLINE  _INDENT if not dfs_num[i]: ccset.append(dfs(i,set([]))) _NEWLINE  return ccset _NEWLINE n=input() _NEWLINE adjList={i:set([]) for i in xrange(n)} _NEWLINE bitvals=[0]*n _NEWLINE for i in xrange(n): _NEWLINE  li=stdin.readline() _NEWLINE  bitvals[i]=int(li,2)# take as base 2 no _NEWLINE  for j in xrange(n): _NEWLINE  _INDENT if li[j]=="1": _NEWLINE  _INDENT  adjList[i].add(j) _NEWLINE #cc=ConnectedComp(adjList.keys()) _NEWLINE ans=0 _NEWLINE for i in xrange(n): _NEWLINE  temp=0 _NEWLINE  for j in adjList[i]: _NEWLINE  _INDENT temp|=bitvals[j] _NEWLINE  #print temp,str(bin(temp)) _NEWLINE  temp=list(str(bin(temp&(~bitvals[i])))[2:]) _NEWLINE  #print temp _NEWLINE  temp=temp.count("1")-1 _NEWLINE  ans+=(temp if temp>0 else 0) _NEWLINE print ans _NEWLINE  
import sys _NEWLINE  _NEWLINE hs = [0.0]*(10**5+1) _NEWLINE def compute() : _NEWLINE  _INDENT  _INDENT for i in range(1,10**5+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hs[i] = hs[i-1] + (1.0/i) _NEWLINE  _NEWLINE if __name__ == "__main__" : _NEWLINE  _INDENT  _INDENT compute() _NEWLINE  _INDENT  _INDENT for __ in range(input()) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.1f"%(n*hs[n]) _NEWLINE 
import gc; gc.disable() _NEWLINE from sys import stdin,stdout _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT sr = stdin.readline _NEWLINE  _INDENT  _INDENT m,n = sr().split() _NEWLINE  _INDENT  _INDENT m=int(m);n=int(n) _NEWLINE  _INDENT  _INDENT a=map(int,sr().split()) _NEWLINE  _INDENT  _INDENT ar = [[set(),set(),i,x,None,None] for i,x in enumerate(a)] _NEWLINE  _INDENT  _INDENT ar[0][5] = ar[1];ar[m-1][4] = ar[m-2] _NEWLINE  _INDENT  _INDENT for i in xrange(1,m-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[i][5]=ar[i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[i][4]=ar[i-1] _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l,r = sr().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[int(l)-1][0].add(j);ar[int(r)-1][1].add(j) _NEWLINE  _INDENT  _INDENT y=0 _NEWLINE  _INDENT  _INDENT ys=[] _NEWLINE  _INDENT  _INDENT for k in xrange(int(sr())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = ar[y+int(sr())-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n[3]>1: n[3]-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if n[5] is not None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[5][0]|=n[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[5][4] = n[4] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if n[4] is not None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[4][1]|=n[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[4][5] = n[5] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y+=len(n[0]&n[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ys.append(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT stdout.write( "\n".join(map(str,ys)) ) _NEWLINE  _INDENT _NEWLINE main()
# collect primes until 100 _NEWLINE primes = [p for p in xrange(2,100) if all(p % q for q in xrange(2,p))] _NEWLINE  _NEWLINE def memoize(func): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Given a function, return a memoized version of it, i.e., _NEWLINE  _INDENT  _INDENT it never calls the original function more than once given the same arguments. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT memo = {} # storage for already-calculated results _NEWLINE  _INDENT  _INDENT def new_func(*args): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if args not in memo: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # not found in memo, so new set of args. call func _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[args] = func(*args) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return memo[args] _NEWLINE  _INDENT  _INDENT return new_func _NEWLINE  _NEWLINE def ave(vs): _NEWLINE  _INDENT  _INDENT ''' Returns the average of vs ''' _NEWLINE  _INDENT  _INDENT return sum(vs) / len(vs) _NEWLINE  _NEWLINE @memoize _NEWLINE def simplify(a,b): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Normalize the primes of a, and fix b along with it. _NEWLINE  _INDENT  _INDENT simplify(3*7*11^2,2*5*7*11*13) = 3*5 _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if b % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res *= primes[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE @memoize _NEWLINE def winning_optimal(g,*vs): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Returns the probability of winning, given that the numbers are vs, the current gcd is g, _NEWLINE  _INDENT  _INDENT and both players play optimally. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT n = len(vs) _NEWLINE  _INDENT  _INDENT if g == 1: return 1 _NEWLINE  _INDENT  _INDENT if n == 0: return 0 _NEWLINE  _INDENT  _INDENT if g != 0: return winning_optimal(0, *sorted(simplify(g,v) for v in vs)) _NEWLINE  _INDENT  _INDENT return max([1 - winning_optimal(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)]) _NEWLINE  _NEWLINE @memoize _NEWLINE def winning_random(g,*vs): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Returns the probability of winning, given that the numbers are vs, the current gcd is g, _NEWLINE  _INDENT  _INDENT and both players play randomly. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT n = len(vs) _NEWLINE  _INDENT  _INDENT if g == 1: return 1. _NEWLINE  _INDENT  _INDENT if n == 0: return 0. _NEWLINE  _INDENT  _INDENT if g != 0: return winning_random(0, *sorted(simplify(g,v) for v in vs)) _NEWLINE  _INDENT  _INDENT return ave([1 - winning_random(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)]) _NEWLINE  _NEWLINE z = input() _NEWLINE for cas in xrange(z): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT vs = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT print "%d %.4f" % (winning_optimal(0,*vs), winning_random(0,*vs)) _NEWLINE 
import sys, decimal _NEWLINE raw_input = sys.stdin.readline _NEWLINE  _NEWLINE for tc in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT N, M = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT deno = 0 _NEWLINE  _INDENT  _INDENT for n in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT product = decimal.Decimal('1.0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for p in map(decimal.Decimal, raw_input().split()): product *= p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n == 0: num = product _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT deno += product _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print "%.6f" % (num/deno if num else 0)
import itertools _NEWLINE MODULO=1000000007 _NEWLINE visited = [0] * 100001 _NEWLINE count_connected_components = 0 _NEWLINE #functions _NEWLINE def depth_first_traversal(graph, node, visited): _NEWLINE 	stack = [] _NEWLINE 	visited[node] = 1 _NEWLINE 	stack.extend(graph[node]) _NEWLINE 	while len(stack) != 0: _NEWLINE 		seed = stack.pop() _NEWLINE 		if not visited[seed]: _NEWLINE 			visited[seed] = 1 _NEWLINE 			stack.extend(graph[seed]) _NEWLINE 	 _NEWLINE def connected_components(graph): _NEWLINE 	global count_connected_components, visited _NEWLINE 	count_connected_components = 0 _NEWLINE 	count_indegree_1 = 0 _NEWLINE 	bInvalid = False _NEWLINE 	for node in graph: _NEWLINE 		if not visited[node]: _NEWLINE 			count_connected_components += 1 _NEWLINE 			depth_first_traversal(graph, node, visited) _NEWLINE 	for node in graph: _NEWLINE 		if len(graph[node]) > 2: _NEWLINE 			bInvalid = True _NEWLINE 		elif len(graph[node]) == 1: _NEWLINE 			count_indegree_1 += 1 _NEWLINE 		visited[node] = 0 _NEWLINE 	if bInvalid or (count_indegree_1 != 2 * count_connected_components): _NEWLINE 		return -1 _NEWLINE 	return count_connected_components _NEWLINE  _NEWLINE def find_count(edges, N): _NEWLINE 	#prepare the adjacency graph _NEWLINE 	global count_connected_components _NEWLINE 	graph = {} _NEWLINE 	for e in edges: _NEWLINE 		if e[0] in graph: _NEWLINE 			graph[e[0]].append(e[1]) _NEWLINE 		else: _NEWLINE 			graph[e[0]] = [e[1]] _NEWLINE 		if e[1] in graph: _NEWLINE 			graph[e[1]].append(e[0]) _NEWLINE 		else: _NEWLINE 			graph[e[1]] = [e[0]] _NEWLINE 	count_connected_components = connected_components(graph) _NEWLINE 	if count_connected_components == -1: _NEWLINE 		return 0 _NEWLINE 	connected_components_including_solo_vertices = N - len(graph) + count_connected_components _NEWLINE 	#calculate connected_components_including_solo_vertices! _NEWLINE 	fact_connected_components_including_solo_vertices = fact_n[connected_components_including_solo_vertices] _NEWLINE 	answer = fact_connected_components_including_solo_vertices _NEWLINE 	answer *= (1 << count_connected_components) _NEWLINE 	answer %= MODULO _NEWLINE 	return answer _NEWLINE  _NEWLINE def process_case(N, M): _NEWLINE 	sign = 1 _NEWLINE 	global fact_n _NEWLINE 	#read list of edges, call it gaps _NEWLINE 	#print fact_n _NEWLINE 	gaps = [] _NEWLINE 	for i in range(M): _NEWLINE 		e1, e2 = raw_input().split() _NEWLINE 		e1, e2 = int(e1), int(e2) _NEWLINE 		if e1 != e2: _NEWLINE 			gaps.append([e1, e2]) _NEWLINE 	 _NEWLINE 	removed_edges = 0 _NEWLINE 	for n_m in range(1, M+1): _NEWLINE 		combination_of__n_m = list(itertools.combinations(gaps, n_m)) _NEWLINE 		for combination in combination_of__n_m: _NEWLINE 			count = find_count(combination, N) _NEWLINE 			#print count, combination, sign _NEWLINE 			removed_edges = (removed_edges + sign * count) #% MODULO _NEWLINE 		#toggle the sign after value of n_m increases _NEWLINE 		sign *= -1 _NEWLINE  _NEWLINE 	#to avoid negative answer _NEWLINE 	answer = fact_n[N] _NEWLINE 	answer += MODULO _NEWLINE 	#if removed_edges < 0: _NEWLINE 	#	removed_edges += MODULO _NEWLINE 	#print "removed edges:" + str(removed_edges) _NEWLINE 	fact = answer - removed_edges + MODULO _NEWLINE 	fact = fact % MODULO _NEWLINE 	return fact _NEWLINE 			 _NEWLINE #main program _NEWLINE #calculate n! modulo MODULO _NEWLINE fact_n = [0] * 100001 _NEWLINE fact_n[1] = 1 _NEWLINE for i in range(2, 100001): _NEWLINE 	fact_n[i] = (i * fact_n[i-1]) % MODULO _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE for test_case in range(T): _NEWLINE 	N, M = raw_input().split() _NEWLINE 	N, M = int(N), int(M) _NEWLINE  _NEWLINE 	print process_case(N, M)
s = bytearray() _NEWLINE x=0 _NEWLINE for i in range(200010): _NEWLINE  _INDENT  _INDENT x = (x*1103515245 + 12345) % 4294967296 _NEWLINE  _INDENT  _INDENT s.append('1' if (x >> 16)&1 else '0') _NEWLINE #print s _NEWLINE test = input() _NEWLINE while test: _NEWLINE  _INDENT  _INDENT test-=1 _NEWLINE  _INDENT  _INDENT st = raw_input() _NEWLINE  _INDENT  _INDENT if st[:50] in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'LCG' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Xorshift' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
import sys _NEWLINE  _INDENT _NEWLINE dp =[0 for __ in range(10**5+100)] _NEWLINE MOD = 10**9+7 _NEWLINE def solve(n,k) : _NEWLINE 	if dp[n] : _NEWLINE 		return dp[n] _NEWLINE 	if k > n : _NEWLINE 		dp[n] = 1 _NEWLINE 		return dp[n] _NEWLINE 	if k == n : _NEWLINE 		dp[n] = 2 _NEWLINE 		return dp[n] _NEWLINE 	dp[n] = solve(n-1,k)+solve(n-k,k) _NEWLINE 	return dp[n]%MOD _NEWLINE  _INDENT _NEWLINE for __ in range(input()) : _NEWLINE 	n , k = map(int,sys.stdin.readline().split()) _NEWLINE 	dp[0] = dp[1] = 1 _NEWLINE 	if k==1 : _NEWLINE 		print pow(2,n,10**9+7) _NEWLINE 		continue _NEWLINE 	for i in range(1,n+1) : _NEWLINE 		dp[i] = dp[i-1] _NEWLINE 		if i>=k : _NEWLINE 			dp[i] += dp[i-k] _NEWLINE 		dp[i] %= MOD _NEWLINE 	print dp[n]
itr = int(raw_input()) _NEWLINE for i in xrange(itr): _NEWLINE  _INDENT  _INDENT b = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = raw_input().split() _NEWLINE  _INDENT  _INDENT a = [int(s) for s in a] _NEWLINE  _INDENT  _INDENT for s in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1 _NEWLINE  _INDENT  _INDENT d = sum(a) _NEWLINE  _INDENT  _INDENT if d<=(99+b) and d>=100: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
#!/usr/bin/python _NEWLINE import sys _NEWLINE file = sys.stdin _NEWLINE  _NEWLINE first = file.readline() _NEWLINE  _NEWLINE noitems, money = [ int(x) for x in first.split()] _NEWLINE items = [[], [], [], [], [], []] _NEWLINE for x in range(noitems): _NEWLINE  _INDENT li = file.readline().split() _NEWLINE  _INDENT if len(li) != 3: _NEWLINE  _INDENT  _INDENT continue _NEWLINE  _INDENT itemno, price, quality = [ int(x) for x in li] _NEWLINE  _INDENT if itemno > 6 or itemno < 1: _NEWLINE  _INDENT  _INDENT continue _NEWLINE  _INDENT items[itemno - 1].append( (price, quality,) ) _NEWLINE  _NEWLINE #import pdb; pdb.set_trace() _NEWLINE try: _NEWLINE  _INDENT for k in range(6): _NEWLINE  _INDENT  _INDENT items[k] = sorted(items[k]) _NEWLINE  _INDENT  _INDENT x = 1 _NEWLINE  _INDENT  _INDENT val = items[k][0][1] _NEWLINE  _INDENT  _INDENT while x < len(items[k]): _NEWLINE  _INDENT  _INDENT  _INDENT if items[k][x][1] <= val: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT del items[k][x] _NEWLINE  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = items[k][x][1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = x + 1 _NEWLINE  _INDENT  _INDENT items[k] = [(0,0)] + items[k] _NEWLINE  _NEWLINE except: _NEWLINE  _INDENT pass _NEWLINE  _NEWLINE def argmin(array): _NEWLINE  _INDENT ans = 0; _NEWLINE  _INDENT for x in range(1, len(array)): _NEWLINE  _INDENT  _INDENT if array[x] < array[ans]: _NEWLINE  _INDENT  _INDENT  _INDENT ans = x _NEWLINE  _INDENT return ans _NEWLINE  _INDENT  _INDENT  _NEWLINE cur = [0,0,0,0,0,0] _NEWLINE min_quality_off = 0 _NEWLINE try: _NEWLINE  _INDENT while True: _NEWLINE  _INDENT  _INDENT min_quality_off = argmin([ items[x][cur[x]][1] for x in range(6) ]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if len(items[min_quality_off]) > cur[min_quality_off] + 1 and items[min_quality_off][cur[min_quality_off] + 1][0] <= money: _NEWLINE  _INDENT  _INDENT  _INDENT cur[min_quality_off] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT money -= items[min_quality_off][cur[min_quality_off]][0] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT break _NEWLINE except: _NEWLINE  _INDENT pass _NEWLINE  _NEWLINE print items[min_quality_off][cur[min_quality_off]][1] _INDENT  _INDENT _NEWLINE 
ct=[0,1,2,3,6,10,20,35,70,126,252,462,924,1716,3432,6435,12870,24310,48620,92378,184756,352716,705432,1352078,2704156,5200300,10400600,20058300,40116600,77558760,155117520,300540195,601080390,1166803110,2333606220,4537567650,9075135300,17672631900,35345263800,68923264410,137846528820,269128937220,538257874440,1052049481860,2104098963720,4116715363800,8233430727600,16123801841550,32247603683100,63205303218876,126410606437752,247959266474052,495918532948104,973469712824056,1946939425648112,3824345300380220,7648690600760440,15033633249770520,30067266499541040,59132290782430712,118264581564861424,232714176627630544,465428353255261088,916312070471295267,1832624140942590534] _NEWLINE l=65 _NEWLINE for t in range(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT h=64 _NEWLINE  _INDENT  _INDENT while h>=l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=(h+l)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ct[m]>=n and ct[m-1]<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ct[m]<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=m+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h=m-1 _NEWLINE  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
""" _NEWLINE The stable marriage problem from CodeChef _NEWLINE """ _NEWLINE from collections import defaultdict _NEWLINE  _NEWLINE def revdict(dic): _NEWLINE  _INDENT  _INDENT for key in dic.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[key] = dic[key][::-1] _NEWLINE  _INDENT  _INDENT return dic _NEWLINE  _NEWLINE def smp(boy_prefs, girl_prefs): _NEWLINE  _INDENT  _INDENT stable = {} _NEWLINE  _NEWLINE  _INDENT  _INDENT ranks = dict() _NEWLINE  _INDENT  _INDENT for girl, gpref in girl_prefs.items(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, boy in enumerate(gpref): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ranks[(girl, boy)] = i _NEWLINE  _NEWLINE  _INDENT  _INDENT free_boys = set(boy_prefs.keys()) _NEWLINE  _INDENT  _INDENT free_girls = set(girl_prefs.keys()) _NEWLINE  _NEWLINE  _INDENT  _INDENT n = len(boy_prefs) _NEWLINE  _INDENT  _INDENT # Reverse orders _NEWLINE  _INDENT  _INDENT boy_prefs = revdict(boy_prefs) _NEWLINE  _INDENT  _INDENT while free_boys: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT boy = free_boys.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not boy_prefs.has_key(boy): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT girl = boy_prefs[boy].pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if girl in free_girls: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stable[girl] = (boy, ranks[(girl, boy)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free_girls.remove(girl) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif ranks[(girl, boy)] < stable[girl][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free_boys.add(stable[girl][0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stable[girl] = (boy, ranks[(girl, boy)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free_boys.add(boy) _NEWLINE  _NEWLINE  _INDENT  _INDENT results = sorted((boy, girl) for girl, (boy, rank) in stable.items()) _NEWLINE  _INDENT  _INDENT return results _INDENT  _INDENT  _NEWLINE  _NEWLINE def test(): _NEWLINE  _INDENT  _INDENT gprefs = { 1: [4, 3, 1, 2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  2: [2, 1, 3, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  3: [1, 3, 4, 2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  4: [4, 3, 1, 2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT bprefs = { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 1: [3, 2, 4, 1], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 2: [2, 3, 1, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 3: [3, 1, 2, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 4: [3, 2, 4, 1] _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT print smp(bprefs, gprefs) _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT cases = int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(cases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gprefs, bprefs = {}, {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for a in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gprefs[a+1] = map(int, raw_input().split())[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for b in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bprefs[b+1] = map(int, raw_input().split())[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for boy, girl in smp(bprefs, gprefs): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print boy, girl _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE  _NEWLINE 
#Manage maximum events given start date and duration for a case _NEWLINE def main(): _NEWLINE 	#f = open('C:\\Users\\GLCR3257\\Desktop\\pyLogics\\test.txt','r') _NEWLINE 	N=int(raw_input()) _NEWLINE 	#print N _NEWLINE 	E=[] _NEWLINE 	for i in range(N): _NEWLINE 		start,duration=map(int,raw_input().split()) _NEWLINE 		E.append([start+duration,start]) _NEWLINE  _INDENT _NEWLINE 	E.sort() _NEWLINE 	#print E _NEWLINE 	x=E[0][0] _NEWLINE 	#print x _NEWLINE 	ans=1 _NEWLINE  _INDENT _NEWLINE 	for i in range(1,N): _NEWLINE 		if(E[i][1]>x): _NEWLINE 			#print x _NEWLINE 			ans=ans+1 _NEWLINE 			x=E[i][0] _NEWLINE  _INDENT _NEWLINE 	print(ans) _NEWLINE 	 _NEWLINE if __name__=='__main__': _NEWLINE 	main()
import sys _NEWLINE  _INDENT _NEWLINE for __ in range(input()) : _NEWLINE 	n = input() _NEWLINE 	ch = raw_input() _NEWLINE 	ops = {')':'(','}':'{',']':'[','>':'<'} _NEWLINE 	cls = ['}',')','>',']'] _NEWLINE 	lists = map(int,sys.stdin.readline().split()) _NEWLINE 	dp , res , temp = [0]*(n+1) , 0 , 0 _NEWLINE 	for j,i in enumerate(lists) : _NEWLINE 		dp[j] = dp[j-1]+i _NEWLINE 	par_st , max_pr = [] , [-1]*(n+1) _NEWLINE 	for j,i in enumerate(ch) : _NEWLINE 		if len(par_st) > 0 : _NEWLINE 			if i in cls and ch[par_st[-1]] == ops[i] : _NEWLINE 				max_pr[j] = par_st.pop() _NEWLINE 			else : _NEWLINE 				par_st.append(j) _NEWLINE 		else : _NEWLINE 			par_st.append(j) _NEWLINE 	ans = [0]*(n+1) _NEWLINE 	for i,j in enumerate(lists) : _NEWLINE 		if max_pr[i]!=-1 : _NEWLINE 			ans[i] = max(dp[i] - dp[max_pr[i]-1]+ans[max_pr[i]-1],ans[i]) _NEWLINE  _INDENT _NEWLINE 	print max(ans)
 _NEWLINE N = input() _NEWLINE S = [] _NEWLINE for i in range(N): _NEWLINE  _INDENT S += [input()] _NEWLINE  _NEWLINE #N = 4 _NEWLINE #S = [5, 3, 4, 1] _NEWLINE #S = [2,4,8,10] _NEWLINE  _NEWLINE ma = 0 _NEWLINE for i in range(N): _NEWLINE  _INDENT a = S[i].bit_length() _NEWLINE  _INDENT if ma < a: _NEWLINE  _INDENT  _INDENT ma = a _NEWLINE  _NEWLINE for e in range(ma,-1,-1): _NEWLINE  _INDENT msk = 1 << e _NEWLINE  _INDENT t = [] _NEWLINE  _INDENT for s in S: _NEWLINE  _INDENT  _INDENT if s & msk: _NEWLINE  _INDENT  _INDENT  _INDENT t += [s] _NEWLINE  _INDENT if len(t) > 1: _NEWLINE  _INDENT  _INDENT S = t _NEWLINE  _NEWLINE m = (1 << ma) - 1 _NEWLINE for a in S: _NEWLINE  _INDENT m &= a _NEWLINE print m _NEWLINE  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
n,x,y = map(int,raw_input().split()) _NEWLINE n1 = [int(i) for i in raw_input().split()] _NEWLINE n2 = [int(i) for i in raw_input().split()] _NEWLINE num = [n1[i]-n2[i] for i in xrange(n) ] _NEWLINE num.sort(reverse=True) _NEWLINE mx = max(0,n-y) _NEWLINE Mx = min(n,x) _NEWLINE xy = sum(n2) _NEWLINE for i in xrange(mx): _NEWLINE  _INDENT  _INDENT xy += num[i] _NEWLINE ans = xy _NEWLINE for i in xrange(mx,Mx): _NEWLINE  _INDENT  _INDENT xy += num[i] _NEWLINE  _INDENT  _INDENT ans = _INDENT max(ans,xy) _NEWLINE print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  
import sys _NEWLINE  _NEWLINE for i1 in xrange(int(sys.stdin.readline())): _NEWLINE  _INDENT  _INDENT a = set() _NEWLINE  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT n,k,p = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.add(x) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(p): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x not in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE 
 _NEWLINE n = input() _NEWLINE a = raw_input() _NEWLINE b = raw_input() _NEWLINE  _NEWLINE n0 = n / 2 _NEWLINE n1 = n0 / 2 _NEWLINE while n1: _NEWLINE  _INDENT idx = b.find(a[:n0]) _INDENT _NEWLINE  _INDENT if idx >= 0: n0 += n1 _NEWLINE  _INDENT else: n0 -= n1 _NEWLINE  _INDENT n1 /= 2 _NEWLINE  _INDENT  _NEWLINE while b.find(a[:n0]) < 0: _NEWLINE  _INDENT n0 -= 1 _NEWLINE print b.find(a[:n0]) _INDENT  _INDENT  
#!/usr/bin/python _NEWLINE import math; _NEWLINE  _NEWLINE def eliminate(M,r,c): _NEWLINE 	N=[]; _NEWLINE 	n=len(M); _NEWLINE  _NEWLINE 	for i in xrange(n):	 _NEWLINE 		if(i==r): _NEWLINE 			continue; _NEWLINE 		row=[] _NEWLINE 		 _NEWLINE 		for j in xrange(n): _NEWLINE 			if(j!=c): _NEWLINE 				row.append(M[i][j]); _NEWLINE 		N.append(row); _NEWLINE  _NEWLINE 	return N; _NEWLINE 	 _NEWLINE  _NEWLINE  _NEWLINE def det(M): _NEWLINE 	n=len(M); _NEWLINE 	if(n==0) : _NEWLINE 		return 0; _NEWLINE 	elif(n==1): _NEWLINE 		return M[0][0]; _NEWLINE  _NEWLINE 	sign=1 _NEWLINE 	delta=0 _NEWLINE 	for i in xrange(len(M)): _NEWLINE 		if (M[0][i]!=0): _NEWLINE 			delta+=sign*M[0][i]*det(eliminate(M,0,i)); _NEWLINE 		sign*=-1; _NEWLINE  _NEWLINE 	return delta; _NEWLINE  _NEWLINE  _NEWLINE def getMat(size): _NEWLINE 	M=[] _NEWLINE 	for i in xrange(size):	 _NEWLINE 		row=[] _NEWLINE 		for j in xrange(size): _NEWLINE 			row.append(0); _NEWLINE 		M.append(row); _NEWLINE 	return M; _NEWLINE  _NEWLINE def printMat(M): _NEWLINE 	for i in xrange(len(M)): _NEWLINE 		for j in xrange(len(M)): _NEWLINE 			print M[i][j], _NEWLINE 		print _NEWLINE  _NEWLINE #Main _NEWLINE  _NEWLINE def area(a,b,c): _NEWLINE 	s=float(a+b+c)/2.0; _NEWLINE 	ar= math.sqrt(s*(s-a)*(s-b)*(s-c));	 _NEWLINE 	#print ar; _NEWLINE 	return ar; _NEWLINE  _NEWLINE  _NEWLINE M=getMat(5); _NEWLINE for i in xrange(1,5): _NEWLINE 	M[0][i]=M[i][0]=1; _NEWLINE  _NEWLINE #printMat(M); _NEWLINE  _NEWLINE  _NEWLINE cases=int(input()); _NEWLINE for i in xrange(cases): _NEWLINE 	line=raw_input(); _NEWLINE 	dist=line.split(" "); _NEWLINE 	 _NEWLINE 	for i in xrange(len(dist)): _NEWLINE 		dist[i]=int(dist[i]); _NEWLINE 		 _NEWLINE 	 _NEWLINE  _NEWLINE 		# dist[0] d12 _INDENT dist[1] d13 _INDENT dist[2] d14 _NEWLINE 		#		dist[3] d23 _INDENT dist[4] d24 _NEWLINE 		#				dist[5] d34 _NEWLINE  _NEWLINE 	M[1][2]=M[2][1]=dist[0]*dist[0]; _NEWLINE 	M[1][3]=M[3][1]=dist[1]*dist[1]; _NEWLINE 	M[1][4]=M[4][1]=dist[2]*dist[2]; _NEWLINE 		 _NEWLINE 	M[2][3]=M[3][2]=dist[3]*dist[3]; _NEWLINE 	M[2][4]=M[4][2]=dist[4]*dist[4]; _NEWLINE 	M[3][4]=M[4][3]=dist[5]*dist[5]; _NEWLINE  _NEWLINE 	X=float(det(M)); _NEWLINE 	Volume= math.sqrt(X/288.00) _NEWLINE 		# _INDENT  _INDENT 12 13 14 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  12 14 24 _INDENT  _INDENT 		13 _INDENT  14 34 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 23 _INDENT  _INDENT  _INDENT 24 _INDENT 34 _NEWLINE 	Surface=area(dist[0], dist[1],dist[3])+area(dist[0],dist[2],dist[4])+area(dist[1], dist[2],dist[5])+ area(dist[3],dist[4],dist[5]); _NEWLINE 	#print Volume, Surface; _NEWLINE  _NEWLINE 	Radius=3*Volume/Surface; _NEWLINE 	print "%.4f"% round(Radius,4); 	 _NEWLINE 					 _NEWLINE 						 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
ip=raw_input().split() _NEWLINE n,k=int(ip[0]),int(ip[1]) _NEWLINE MOD=1000000007 _NEWLINE if n<k and n==1: _NEWLINE 	print "0" _NEWLINE elif n==1: _NEWLINE 	print "1" _NEWLINE else: _NEWLINE 	ans=pow(n,n-2,MOD) _NEWLINE 	if k==1: _NEWLINE 		print ans _NEWLINE 	else: _NEWLINE 		print (ans*pow(k,n*k-2,MOD)*pow(n-1,n*(k-1),MOD))%MOD
 _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #if !ONLINE_JUDGE _NEWLINE #include "debug.h" _NEWLINE #else _NEWLINE #endif _NEWLINE  _NEWLINE typedef long long int LL; _NEWLINE typedef unsigned long long LLU; _NEWLINE typedef long double LD; _NEWLINE  _NEWLINE #define INF 1500000000000000000LL _NEWLINE #define MOD 1000000007 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define PB push_back _NEWLINE #define MK make_pair _NEWLINE #define LEN(vale) strlen(vale) _NEWLINE #define SZ(vale) (int)vale.size() _NEWLINE #define SQ(A) ((A)*(A)) _NEWLINE #define FI(i,fa,fb) for(int i=fa;i<fb;++i) _NEWLINE #define FD(i,fa,fb) for(int i=fa;i>fb;--i) _NEWLINE #define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) _INDENT _NEWLINE #define bits(vale) __builtin_popcount(vale) _NEWLINE #define VT vector _NEWLINE  _NEWLINE #define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val; _NEWLINE #define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val; _NEWLINE  _NEWLINE #define ALL(a) (a.begin(),a.end()) _NEWLINE #define LB (lower_bound) _NEWLINE #define UB (upper_bound) _NEWLINE  _NEWLINE #define SI(vale) scanf("%d",&vale) _NEWLINE #define PI(vale) printf("%d\n",vale) _NEWLINE #define PIS(vale) printf("%d ",vale) _NEWLINE #define SL(vale) scanf("%lld",&vale) _NEWLINE #define PL(vale) printf("%lld\n",vale) _NEWLINE #define PLS(vale) printf("%lld ",vale) _NEWLINE #define SS(vale) scanf("%s",vale) _NEWLINE #define PS(vale) printf("%s\n",vale) _NEWLINE #define SLD(vale) scanf("%Lf",&vale) _NEWLINE #define PLD(vale) printf("%0.12Lf\n",vale) _NEWLINE #define NL printf("\n") _NEWLINE #define TCS() int testcase; SI(testcase);while(testcase--) _INDENT _NEWLINE  _NEWLINE typedef pair<int,int> PR; _NEWLINE bool deb = false; _NEWLINE const int N = 50011; _NEWLINE const int LOGN = 32; _NEWLINE int n,Ncount; _NEWLINE bool mark[N]; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE int dp[N][LOGN+5],dep[N],in[N],T; _NEWLINE int out[N],q[N]; // q stores query _INDENT _NEWLINE vector<int >gr[N]; _INDENT  _INDENT  // tree stores auxiliary tree _NEWLINE int deg[N]; _NEWLINE  _NEWLINE void dfs(int v,int p) { _NEWLINE  _INDENT  _INDENT  in[v] = ++T; _NEWLINE  _INDENT  _INDENT  dp[v][0] = p; _NEWLINE  _INDENT  _INDENT  for(int i=1;i<=LOGN;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[v][i] = dp[dp[v][i-1]][i-1]; _NEWLINE  _INDENT  _INDENT  dep[v] = dep[p] + 1; _NEWLINE  _INDENT  _INDENT  for(int i = 0;i<gr[v].size();i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int u = gr[v][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(u != p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dfs(u,v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  out[v] = T; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int LCA(int a,int b) { _NEWLINE  _INDENT  _INDENT  if(a == b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT  if(dep[a] < dep[b]) swap(a,b); _NEWLINE  _INDENT  _INDENT  int diff = dep[a] - dep[b]; _NEWLINE  _INDENT  _INDENT  int i = 0; _NEWLINE  _INDENT  _INDENT  while(i < LOGN) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( (diff >> i) & 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a = dp[a][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  if(a == b) return _INDENT a; _NEWLINE  _INDENT  _INDENT  i = LOGN-1; _NEWLINE  _INDENT  _INDENT  while(i >= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dp[a][i] != dp[b][i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a = dp[a][i],b = dp[b][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i--; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  return dp[a][0]; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE bool isAnc(int p,int u) { _NEWLINE  _INDENT  _INDENT  return (in[p] <= in[u] && out[p] >= out[u]); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE bool comp(int aa,int ab) { _NEWLINE  _INDENT  _INDENT  return in[aa] < in[ab]; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int build_tree() { _INDENT  _INDENT  _INDENT  _INDENT // build auxiliary tree _NEWLINE  _INDENT  _INDENT  set<int>st; _NEWLINE  _INDENT  _INDENT  for(int i=0;i<Ncount;i++) st.insert(q[i]); _NEWLINE  _INDENT  _INDENT  Ncount = 0; _NEWLINE  _INDENT  _INDENT  for(auto it : st) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[Ncount++] = it; _NEWLINE  _INDENT  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // find the unique nodes _NEWLINE  _INDENT  _INDENT  int TNodes = Ncount; _NEWLINE  _INDENT  _INDENT  sort(q,q+Ncount,comp); _NEWLINE  _INDENT  _INDENT  for(int i=0;i<TNodes-1;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int lca = LCA(q[i],q[i+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(st.find(lca) != st.end()) _INDENT  // if parent already exists _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[Ncount++] = lca; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st.insert(lca); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  sort(q,q+Ncount,comp); _NEWLINE  _INDENT  _INDENT  stack<int>S; _NEWLINE  _INDENT  _INDENT  S.push(q[0]); _NEWLINE  _INDENT  _INDENT  for(int i=1;i<Ncount;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while((!isAnc(S.top(),q[i]))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  S.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT deg[S.top()]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT deg[q[i]]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S.push(q[i]); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  return q[0]; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void dfs2(int v,int p) { _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void init() { _NEWLINE  _INDENT  _INDENT  T = 0; _NEWLINE  _INDENT  _INDENT  dp[1][0] = 0; _NEWLINE  _INDENT  _INDENT  dfs(1,0); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  //clock_t tStart = clock(); _NEWLINE  _INDENT  _INDENT  int t,m; _NEWLINE  _INDENT  _INDENT  TCS(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT SI(n);SI(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,0,n+2)gr[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,1,n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int u,v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  SI(u),SI(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gr[u].PB(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gr[v].PB(u); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT init(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(m--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  SI(Ncount); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int orc = Ncount; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  FI(i,0,Ncount) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT SI(q[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mark[q[i]] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(Ncount == 2) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT PI(dep[q[0]]+dep[q[1]]-2*dep[LCA(q[0],q[1])]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int root = build_tree(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,0,Ncount) if(deg[q[i]] == orc && !mark[q[i]]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ans++; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT PI(ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  FI(i,0,Ncount) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mark[q[i]] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT deg[q[i]] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  //exectime(); _NEWLINE  _INDENT  _INDENT  return 0; _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
test_case=int(raw_input()) _NEWLINE for _ in range(test_case): _NEWLINE  _INDENT  _INDENT node= int(raw_input()) _NEWLINE  _INDENT  _INDENT sumx=0 _NEWLINE  _INDENT  _INDENT listp=[] _NEWLINE  _INDENT  _INDENT for i in range(node): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p,c =[int(u) for u in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT listp.append(p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumx=sumx+p-c _NEWLINE  _INDENT  _INDENT for x in range(node): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if listp[x] == sumx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print sumx _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
from sys import stdin _NEWLINE def printBS(li): _NEWLINE  print " ".join([str(x) for x in li]) _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE cases=input() _NEWLINE for case in range(cases): _NEWLINE  n=input() _NEWLINE  li=listInput() _NEWLINE  turn=1 _NEWLINE  xor=0 _NEWLINE  for i in li: xor^=i _NEWLINE  while li and xor: _NEWLINE  _INDENT #print li,xor _NEWLINE  _INDENT xorli=[] _NEWLINE  _INDENT #print xorli _NEWLINE  _INDENT for i in li: _INDENT _NEWLINE  _INDENT  xorli.append(xor^i) _NEWLINE  _INDENT i=0 _NEWLINE  _INDENT while i<len(li) and not xorli[i]: i+=1 _NEWLINE  _INDENT if i==len(li): _INDENT _NEWLINE  _INDENT  turn=1-turn _NEWLINE  _INDENT  break _NEWLINE  _INDENT li.remove(li[i]) _NEWLINE  _INDENT xor=xorli[i] _NEWLINE  _INDENT turn=1-turn _NEWLINE  if turn==1: print "First" _NEWLINE  else: print "Second"
n,k = [int(p) for p in raw_input().split()] _NEWLINE  _NEWLINE listq=[] _NEWLINE for i in range(1,int(n)+1): _NEWLINE  _INDENT  _INDENT listq.append('CLICK '+str(i)) _NEWLINE dic={key: 0 for key in listq} _NEWLINE  _NEWLINE def clk(n,k,x): _NEWLINE  _INDENT  _INDENT if 'CLICK' in x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[x] += 1 _NEWLINE  _INDENT  _INDENT elif x =='CLOSEALL': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(1,int(n)+1):dic['CLICK '+str(i)] = 0 _NEWLINE  _INDENT  _INDENT for t in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[t]%=2 _NEWLINE  _INDENT  _INDENT return sum(dic.values()) _NEWLINE  _NEWLINE cnt = 0 _NEWLINE while cnt<k: _NEWLINE  _INDENT  _INDENT cnt+=1 _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print clk(n,k,x) _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE 
def prejdi_strom(linky, presiel, zoznam): _NEWLINE  _INDENT  _INDENT cache = {} _NEWLINE  _INDENT  _INDENT ret = [] _NEWLINE  _INDENT  _INDENT for p in zoznam: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for q in linky.get(p,[]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q not in presiel and q not in cache: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret.append(q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[q] = 1 _NEWLINE  _INDENT  _INDENT return ret _NEWLINE  _NEWLINE def rozhodni(prve, druhe, linky): _NEWLINE  _INDENT  _INDENT zaznam = {} _NEWLINE  _INDENT  _INDENT for p1 in prve: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT delta = prve.get(p1,0) - druhe.get(p1,0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if delta==0 : continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if abs(delta) > 1 : return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if delta in zaznam: return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT zaznam[delta] = p1 _NEWLINE  _NEWLINE  _INDENT  _INDENT for p1 in druhe: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if p1 not in prve: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if druhe[p1] != 1: return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if -1 in zaznam: return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT zaznam[-1] = p1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if 1 in zaznam: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start = zaznam[1] _NEWLINE  _INDENT  _INDENT else: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for p1 in prve: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start = p1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT presiel = [start] _NEWLINE  _INDENT  _INDENT zoznam _INDENT = [start] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nc = prejdi_strom(linky, presiel, zoznam) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if nc == [] : break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT presiel += nc _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT zoznam = nc _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return [x for x in prve if x not in presiel] == [] and [x for x in prve if x not in presiel]== [] _NEWLINE  _INDENT  _INDENT  _NEWLINE def readInput(file): _NEWLINE  _INDENT  _INDENT n = int(file.readline()) _NEWLINE  _INDENT  _INDENT prve = {} _NEWLINE  _INDENT  _INDENT druhe = {} _NEWLINE  _INDENT  _INDENT linky = {} _NEWLINE  _INDENT  _INDENT for _ in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = file.readline().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prve[s[0]] = prve.setdefault(s[0],0) + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT druhe[s[-1]] = druhe.setdefault(s[-1],0) + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT linky.setdefault(s[0],[]).append(s[-1]) _NEWLINE  _INDENT  _INDENT return prve, druhe, linky _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT import sys _NEWLINE  _INDENT  _INDENT file = sys.stdin _NEWLINE  _INDENT  _INDENT tc = int(file.readline()) _NEWLINE  _INDENT  _INDENT for _ in xrange(0,tc): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prve, druhe, linky = readInput(file) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ["The door cannot be opened.","Ordering is possible."][rozhodni(prve, druhe, linky)] _INDENT _NEWLINE 
T=input() _NEWLINE x=[ '']*T _NEWLINE t=['rgb','rbg','grb','gbr','brg','bgr'] _NEWLINE def min_time(r): _NEWLINE 	minval=0 _NEWLINE 	m=0 _NEWLINE 	#print t _NEWLINE 	for i in t: _NEWLINE 		mint=0 _NEWLINE 		count=0 _NEWLINE 		for k in range(0,len(r)): _NEWLINE 			if(r[k]==i[0]):	 _NEWLINE 				mint+=k-count _INDENT _NEWLINE 				if(m==1 and minval <mint): _NEWLINE 					continue _NEWLINE 				count+=1 _INDENT _NEWLINE 		minl=0 _NEWLINE 		count=0 _NEWLINE 		q=[ -p for p in range(1,len(r)+1)] _NEWLINE 		a=0 _NEWLINE 		for k in q: _NEWLINE 		 _NEWLINE 			if(r[k]==i[0]): _NEWLINE 				a+=1 _NEWLINE 				continue _NEWLINE 			if(r[k]==i[2]): _NEWLINE 				minl+= -k-count-a-1 _NEWLINE 				if(m==1 and minval <minl): _NEWLINE 					continue _NEWLINE 				count+=1 _NEWLINE 		if(m==0): _NEWLINE 			m=1 _NEWLINE 			minval=minl+mint _NEWLINE 			#print i,mint,minl _NEWLINE 			continue _NEWLINE 		if(minl+mint<minval): _NEWLINE 			minval=minl+mint _NEWLINE 		#print i,mint,minl,'\n' _NEWLINE 	return minval _NEWLINE 		 _NEWLINE #def find_cluster(): _NEWLINE 	#print x[i] _NEWLINE for i in range(0,T): _NEWLINE 	x[i]=raw_input() _NEWLINE #	find_cluster() _NEWLINE 	print min_time(x[i]) _NEWLINE exit(0) _NEWLINE 
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n , m = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT cood = [] _NEWLINE  _INDENT  _INDENT for __ in range(m) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cood.append(map(int,sys.stdin.readline().split())) _NEWLINE  _INDENT  _INDENT x , y = [i[0] for i in cood] , [i[1] for i in cood] _NEWLINE  _INDENT  _INDENT if m==2 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = set() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in x : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in y : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(k)==3 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT elif m > 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE 
#include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdlib> _NEWLINE #include <cmath> _NEWLINE #include <complex> _NEWLINE #include <utility> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef complex<double> point; _NEWLINE typedef pair<double, int> PDI; _NEWLINE  _NEWLINE const double INF = 1E100; _NEWLINE const int MAX_P = 26; _NEWLINE  _NEWLINE struct edge { _NEWLINE  _INDENT int a, b; double fuel; _NEWLINE  _INDENT edge(int a_, int b_, double fuel_) : a(a_), b(b_), fuel(fuel_) {} _NEWLINE  _INDENT }; _NEWLINE  _NEWLINE point getUV(double t, const point &p, const point &q, const point &r) { _NEWLINE  _INDENT point pp = p-q, rp = r-q; _NEWLINE  _INDENT point rh = rp / abs(rp); _NEWLINE  _NEWLINE  _INDENT point dc = conj(pp) * rh; _NEWLINE  _INDENT double u = dc.real() + dc.imag()/tan(t); _NEWLINE  _INDENT double v = dc.real() - dc.imag()/tan(t); _NEWLINE  _INDENT u /= abs(rp); v /= abs(rp); _NEWLINE  _NEWLINE  _INDENT if (u > v) swap(u, v); _NEWLINE  _INDENT return point(u, v); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT cout << fixed << setprecision(3); _NEWLINE  _INDENT int n, f, cNum = 0; _NEWLINE  _INDENT while ((cin >> n >> f) && n) { _NEWLINE  _INDENT  _INDENT double theta = acos(1.0 / f); _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<point> verts; _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT int x, y; cin >> x >> y; _NEWLINE  _INDENT  _INDENT  _INDENT verts.push_back(point(x, y)); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<edge> edges; _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= n; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (j != i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(i, j, f*abs(verts[j]-verts[i]))); _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT set<PDI> jumpPts; _NEWLINE  _INDENT  _INDENT  _INDENT for (int i = 0; i <= n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT point uv = getUV(theta, verts[i], verts[j], verts[j+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double u = uv.real(), v = uv.imag(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((0 < u) && (u < 1)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT point t = verts[j] + u*(verts[j+1] - verts[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ti = verts.size(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT verts.push_back(t); jumpPts.insert(PDI(u, ti)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(ti, i, f*abs(verts[i] - t))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((0 < v) && (v < 1)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT point t = verts[j] + v*(verts[j+1] - verts[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ti = verts.size(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT verts.push_back(t); jumpPts.insert(PDI(v, ti)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(i, ti, f*abs(t - verts[i]))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT int prev = j; _NEWLINE  _INDENT  _INDENT  _INDENT for (set<PDI>::const_iterator k = jumpPts.begin(); k != jumpPts.end(); ++k) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(prev, k->second, abs(verts[k->second] - verts[prev]))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev = k->second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT edges.push_back(edge(prev, j+1, abs(verts[j+1] - verts[prev]))); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int nV = verts.size(); _NEWLINE  _INDENT  _INDENT vector< vector<edge> > g(nV); _NEWLINE  _INDENT  _INDENT for (vector<edge>::const_iterator i = edges.begin(); i != edges.end(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT g[i->a].push_back(*i); _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<double> fuelTo(nV, INF); fuelTo[0] = 0; _NEWLINE  _INDENT  _INDENT priority_queue<PDI> q; q.push(PDI(0, 0)); _NEWLINE  _NEWLINE  _INDENT  _INDENT while (!q.empty()) { _NEWLINE  _INDENT  _INDENT  _INDENT PDI t = q.top(); q.pop(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT if (t.first == -fuelTo[t.second]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (vector<edge>::const_iterator i = g[t.second].begin(); i != g[t.second].end(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fuelTo[t.second] + i->fuel < fuelTo[i->b]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fuelTo[i->b] = fuelTo[t.second] + i->fuel; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(PDI(-fuelTo[i->b], i->b)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT cout << "Case " << ++cNum << ": " << fuelTo[n] << '\n'; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE 
#include<iostream> _NEWLINE #include<cstring> _NEWLINE #include<string> _NEWLINE #include<vector> _NEWLINE #include<cassert> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE const int mx_nodes = 100; _NEWLINE  _NEWLINE enum Op { _NEWLINE 	PL, _NEWLINE 	MI, _NEWLINE 	MU, _NEWLINE 	ID _NEWLINE }; _NEWLINE  _NEWLINE struct Parse_Node { _NEWLINE 	int id; _NEWLINE 	Op op; _NEWLINE 	Parse_Node * lc, * rc; _NEWLINE 	int num_vars; _NEWLINE }; _NEWLINE  _NEWLINE string s; _NEWLINE int n; _NEWLINE long long l, h; _NEWLINE long long a[15]; _NEWLINE int match[mx_nodes]; _NEWLINE int num_nodes; _NEWLINE vector<pair<long long,int> > vals[mx_nodes][1 << 12]; _NEWLINE  _NEWLINE Parse_Node* go(int lo, int hi) { _NEWLINE 	while (match[lo] == hi - 1) lo ++, hi --; _NEWLINE 	Parse_Node* res = new Parse_Node; _NEWLINE 	int lvl = 0; _NEWLINE 	int pos_pl = -1, pos_mi = -1, pos_mu = -1; _NEWLINE 	for (int i = lo; i < hi; i ++) { _NEWLINE 		if (s[i] == '(') lvl ++; else _NEWLINE 		if (s[i] == ')') lvl --; else _NEWLINE 		if (lvl == 0 && s[i] == '+') pos_pl = i; else _NEWLINE 		if (lvl == 0 && s[i] == '-') pos_mi = i; else _NEWLINE 		if (lvl == 0 && s[i] == '*') pos_mu = i; _NEWLINE 	} _NEWLINE 	int pos = -1; _NEWLINE 	if (pos_pl >= 0) { _NEWLINE 		res -> op = PL; _NEWLINE 		pos = pos_pl; _NEWLINE 	} _NEWLINE 	else if (pos_mi >= 0) { _NEWLINE 		res -> op = MI; _NEWLINE 		pos = pos_mi; _NEWLINE 	} _NEWLINE 	else if (pos_mu >= 0) { _NEWLINE 		res -> op = MU; _NEWLINE 		pos = pos_mu; _NEWLINE 	} _NEWLINE 	else { _NEWLINE 		res -> op = ID; _NEWLINE 		res -> num_vars = 1; _NEWLINE 	} _NEWLINE 	if (pos >= 0) { _NEWLINE 		res -> lc = go(lo, pos); _NEWLINE 		res -> rc = go(pos + 1, hi); _NEWLINE 		res -> num_vars = res -> lc -> num_vars + res -> rc -> num_vars; _NEWLINE 	} _NEWLINE 	res -> id = num_nodes ++; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE Parse_Node* parse() { _NEWLINE 	vector<int> a; _NEWLINE 	memset(match,-1,sizeof(match)); _NEWLINE 	int len = s.size(); _NEWLINE 	for (int i = 0; i < len; i ++) { _NEWLINE 		if (s[i] == '(') a.push_back(i); else _NEWLINE 		if (s[i] == ')') match[a.back()] = i, a.pop_back(); _NEWLINE 	} _NEWLINE 	num_nodes = 0; _NEWLINE 	return go(0, len); _NEWLINE } _NEWLINE  _NEWLINE pair<long long, int> t[5000000]; _NEWLINE // int its; _NEWLINE void calc(Parse_Node* node) { _NEWLINE 	int cnt_t; _NEWLINE 	if (node -> op == ID) { _NEWLINE 		for (int i = 0; i < n; i ++) { _NEWLINE 			vals[node -> id][1 << i].push_back(make_pair(a[i], 1)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	else { _NEWLINE 		calc(node -> lc); _NEWLINE 		calc(node -> rc); _NEWLINE 		for (int i = 0; i < (1 << n); i ++) if (__builtin_popcount(i) == node -> num_vars) { _NEWLINE 			cnt_t = 0; _NEWLINE 			for (int i1 = i; i1 != 0; i1 = (i1 - 1) & i) if (__builtin_popcount(i1) == node -> lc -> num_vars) { _NEWLINE 				// its += vals[node -> lc -> id][i1].size() * vals[node -> rc -> id][i ^ i1].size(); _NEWLINE 				vector<pair<long long,int> >::iterator p1, p2; _NEWLINE 				if (node -> op == PL) _NEWLINE 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) _NEWLINE 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) _NEWLINE 						t[cnt_t].first = (*p1).first + (*p2).first, _NEWLINE 						t[cnt_t].second = (*p1).second * (*p2).second, _NEWLINE 						cnt_t ++; _NEWLINE 				else if (node -> op == MI) _NEWLINE 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) _NEWLINE 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) _NEWLINE 						t[cnt_t].first = (*p1).first - (*p2).first, _NEWLINE 						t[cnt_t].second = (*p1).second * (*p2).second, _NEWLINE 						cnt_t ++; _NEWLINE 				else _NEWLINE 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) _NEWLINE 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) _NEWLINE 						t[cnt_t].first = (*p1).first * (*p2).first, _NEWLINE 						t[cnt_t].second = (*p1).second * (*p2).second, _NEWLINE 						cnt_t ++; _NEWLINE 			} _NEWLINE 			sort(t, t + cnt_t); _NEWLINE 			for (int j = 0; j < cnt_t; j ++) { _NEWLINE 				if (j < cnt_t - 1 && t[j + 1].first == t[j].first) _NEWLINE 					t[j + 1].second += t[j].second; _NEWLINE 				else vals[node -> id][i].push_back(make_pair(t[j].first, t[j].second)); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE void solve() { _NEWLINE 	cin >> n >> l >> h; _NEWLINE 	for (int i = 0; i < n; i ++) cin >> a[i]; _NEWLINE 	cin >> s; _NEWLINE 	Parse_Node* root = parse(); _NEWLINE 	for (int i = 0; i < mx_nodes; i ++) for (int j = 0; j < (1 << 12); j ++) vals[i][j].clear(); _NEWLINE 	// cout << num_nodes << endl; _NEWLINE 	calc(root); _NEWLINE 	 _NEWLINE 	int res = 0; _NEWLINE 	vector<pair<long long,int> > m = vals[root -> id][(1 << n) - 1]; _NEWLINE 	vector<pair<long long,int> >::iterator it; _NEWLINE 	for (it = m.begin(); it != m.end(); it ++) { _NEWLINE 		if ((*it).first >= l && (*it).first <= h) res += (*it).second; _NEWLINE 		// cout << (*it).first << " (" << (*it).second << ")" << endl; _NEWLINE 	} _NEWLINE 	int b[10]; memset(b,0,sizeof(b)); _NEWLINE 	for (int i = 0; i < n; i ++) b[a[i]] ++; _NEWLINE 	for (int i = 0; i < 10; i ++) { _NEWLINE 		for (int j = 1; j <= b[i]; j ++) res /= j; _NEWLINE 	} _NEWLINE 	cout<<res<<endl; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int T; cin >> T; while (T--) solve(); _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <queue> _NEWLINE #include <list> _NEWLINE #include <stack> _NEWLINE #include <algorithm> _NEWLINE #include <cassert> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int re() { _NEWLINE 	static int n = 0, ch; _NEWLINE 	ch = getchar(); n = 0; _NEWLINE 	while(!isdigit(ch)) ch = getchar(); _NEWLINE 	while(isdigit(ch)) n = n * 10 + ch - '0', ch = getchar(); _NEWLINE 	return n; _NEWLINE } _NEWLINE struct Vector _NEWLINE { _NEWLINE 	double x , y; _NEWLINE 	Vector(double x=0 , double y=0):x(x),y(y){} _NEWLINE 	 _NEWLINE 	double real() { return x; } _NEWLINE 	double imag() { return y; } _NEWLINE 	Vector operator +(Vector b) { return Vector(x + b.x , y + b.y); } _NEWLINE 	Vector operator -(Vector b) { return Vector(x - b.x , y - b.y); } _NEWLINE 	Vector operator *(Vector b) { return Vector(x * b.x - y * b.y , x * b.y + y * b.x);; } _NEWLINE 	Vector operator /(double _INDENT b) { return Vector(x / b , y / b); } _NEWLINE }; _NEWLINE  _NEWLINE typedef Vector cd; _NEWLINE typedef vector<cd> vc; _NEWLINE typedef vector<double> vd; _NEWLINE  _NEWLINE int m = 1; _NEWLINE  _NEWLINE inline void FFT(vc &a , int inv) _NEWLINE { _NEWLINE 	int n = m; _NEWLINE 	for(int i=0,j=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		if(j > i) swap(a[i] , a[j]); _NEWLINE 		 _NEWLINE 		int k = n; _NEWLINE 		while(j & (k >>= 1)) j &= ~k; _NEWLINE 		j |= k; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	double Pi = inv * acos(-1); _NEWLINE 	for(int i=1;i<n;i <<= 1) _NEWLINE 	{ _NEWLINE 		cd wn = cd(cos(Pi/i) , sin(Pi/i)); _NEWLINE 		for(int j=0;j<n;j += i<<1) _NEWLINE 		{ _NEWLINE 			cd w = cd(1 , 0); _NEWLINE 			for(int k=j;k<i+j;k++) _NEWLINE 			{ _NEWLINE 				cd x = a[k]; _NEWLINE 				cd y = a[k+i] * w; _NEWLINE 				a[k] = x + y; _NEWLINE 				a[k+i]=x - y; _NEWLINE 				w = w*wn; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	if(inv == -1) for(int i=0;i<n;i++) a[i] = a[i] / n; _NEWLINE } _NEWLINE  _NEWLINE vc c , d; vd res; _NEWLINE vd operator *(vd&a , vd&b) _NEWLINE { _NEWLINE 	for(int i=0;i<m;i++) c[i] = d[i] = 0; _NEWLINE 	for(int i=0;i<m;i++) c[i] = a[i]; _NEWLINE 	FFT(c , 1); _NEWLINE  	for(int i=0;i<m;i++) d[i] = b[i]; _NEWLINE 	FFT(d , 1); _NEWLINE 	for(int i=0;i<m;i++) _INDENT c[i] = c[i] * d[i]; _NEWLINE 	FFT(c ,-1); _NEWLINE 	 _NEWLINE 	for(int i=0;i<m;i++) res[i] = c[i].real(); _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE const int maxn = 7e5+1e3; _NEWLINE const int blockSize = 2000; _NEWLINE const int blockNum = maxn/blockSize + 10; _NEWLINE  _NEWLINE  _NEWLINE int n , a[maxn] , book[maxn]; _NEWLINE int l[blockNum] , r[blockNum]; _NEWLINE  _NEWLINE void move(vd &v , int w , int inv) _NEWLINE { _NEWLINE 	for(int i=l[w];i<=r[w];i++) v[a[i]] += inv; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	n = re(); _NEWLINE 	int mx = 0; _NEWLINE 	for(int i=0;i<n;i++) mx = max(mx , a[i] = re()); _NEWLINE 	++(mx *= 2); _NEWLINE 	 _NEWLINE 	while(m < mx) m <<= 1; _NEWLINE 	c = d = vc(m , 0); res = vd(m , 0); _NEWLINE  _NEWLINE 	int cnt = n/blockSize; _NEWLINE 	for(int i=0;i<cnt;i++) l[i] = i * blockSize , r[i] = l[i] + blockSize - 1; _NEWLINE 	if(n%blockSize) l[cnt] = n/blockSize*blockSize , r[cnt++] = n-1; _NEWLINE  _NEWLINE 	long long res = 0; _NEWLINE 	for(int i=0;i<cnt;i++) _INDENT _NEWLINE 	{ _NEWLINE 		memset(book , 0 , sizeof (int) * m); _NEWLINE 		for(int j=l[i];j<=r[i];book[a[j++]]++) for(int k=j+1;k<=r[i];k++) if(2 * a[j] >= a[k]) res += book[2*a[j] - a[k]]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	vd L(m , 0) , R(m , 0); _NEWLINE 	for(int i=cnt-1;i;i--) move(R , i , 1); _NEWLINE 	for(int i=0;i<cnt;) _NEWLINE 	{	 _NEWLINE 		for(int j=l[i];j<=r[i];j++) for(int k=j+1;k<=r[i];k++) _INDENT _NEWLINE 		{ _NEWLINE 			if(2 * a[j] >= a[k]) res += int(L[2*a[j] - a[k]] + 0.5); _NEWLINE 			if(2 * a[k] >= a[j]) res += int(R[2*a[k] - a[j]] + 0.5); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		vd now = L * R; _NEWLINE 		for(int j=l[i];j<=r[i];j++) res += (long long)(now[a[j]*2] + 0.5); _NEWLINE 		 _NEWLINE 		move(L , _INDENT i , 1); _NEWLINE 		move(R ,++i ,-1); _NEWLINE 	} _NEWLINE 	printf("%lld\n" , res); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import random _NEWLINE class Ordinal(object): _NEWLINE  _INDENT  _INDENT def __init__(self, v, r = 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (v&1)==0 and r > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v >>= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.v, self.r = v, r _NEWLINE  _NEWLINE  _INDENT  _INDENT def __repr__(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return '%d / 2^%d' % (self.v, self.r) _NEWLINE  _NEWLINE  _INDENT  _INDENT def __add__(self, o): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isinstance(o, int): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o = Ordinal(o) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o.r < self.r: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v+(o.v<<(self.r-o.r)), self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(o.v+(self.v<<(o.r-self.r)), o.r) _NEWLINE  _NEWLINE  _INDENT  _INDENT def __eq__(self, o): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return self.r == o.r and self.v == o.v _NEWLINE  _NEWLINE  _INDENT  _INDENT def sign(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if self.v > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif self.v < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT def colon(self, o): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # return (1:x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if self.v >= 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v+(1L<<self.r), self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = 1-(self.v >> self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v+(k<<self.r), self.r+(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif o == -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # return (-1:x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if self.v <= 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v-(1L<<self.r), self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = 1-((-self.v) >> self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v-(k<<self.r), self.r+(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT raise ValueError _NEWLINE  _NEWLINE  _INDENT  _INDENT @staticmethod _NEWLINE  _INDENT  _INDENT def stick_test(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r1 = Ordinal(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r1.r == 0 and r1.v * x >= 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1 += x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1 += Ordinal(x, r1.r+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r2 = Ordinal(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in s[::-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r2 = r2.colon(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not (r1 == r2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(s) + ': exp ' + str(r1) + ', _INDENT got ' + str(r2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT raise ValueError _NEWLINE  _NEWLINE def HackenbushTree(n, e): _NEWLINE  _INDENT  _INDENT ve = [list() for _ in range(n+1)] _NEWLINE  _INDENT  _INDENT for x in e: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ve[x[0]].append((x[1], x[2])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ve[x[1]].append((x[0], x[2])) _NEWLINE  _INDENT  _INDENT q = [[1, 0, None, None]] _NEWLINE  _INDENT  _INDENT res = None _NEWLINE  _INDENT  _INDENT while len(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x, cx, px, v = q.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur = [x, cx, px, Ordinal(0)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.append(cur) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for y, cy in ve[x]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if px is None or y != px[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.append([y, cy, cur, None]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if px is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = v _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT px[3] += v.colon(cx) _NEWLINE  _INDENT  _INDENT return res.sign() _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT for _ in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in range(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT u, v, c = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e.append((u, v, 1-2*c)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = HackenbushTree(n, e) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if res > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Chef Chef' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif res < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Ksen Ksen' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Ksen Chef' _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
#!/usr/bin/python _NEWLINE #Filename: happy.py _NEWLINE  _NEWLINE def getInt(): _NEWLINE 	while True: _NEWLINE 		s=raw_input().strip() _NEWLINE 		if(s!=""): return int(s) _NEWLINE  _NEWLINE def getString(): _NEWLINE 	while True: _NEWLINE 		s = raw_input() _NEWLINE 		if(s!=""): return s _NEWLINE  _NEWLINE def det(A,n): _NEWLINE 	r=1 _NEWLINE 	for i in range(n): _NEWLINE 		for j in range(i+1,n): _NEWLINE 			 while(A[j][i]!=0): _INDENT # non-zero, swap with row i :) _NEWLINE 				 f = A[i][i]/A[j][i] _NEWLINE 				 for k in range(i,n): _NEWLINE 					 A[i][k] = A[i][k] - A[j][k]*f _NEWLINE 				 for k in range(i,n): _NEWLINE 					 t = A[i][k] _NEWLINE 					 A[i][k] = A[j][k] _NEWLINE 					 A[j][k] = t _NEWLINE 		r = r * A[i][i] _NEWLINE 	return abs(r) _NEWLINE  _NEWLINE  _NEWLINE kases = getInt() _NEWLINE for kase in range(kases): _NEWLINE 	G = [] _NEWLINE  _NEWLINE 	sa = getString().split() _NEWLINE 	n = int(sa[0]) _NEWLINE 	m = int(sa[1]) _NEWLINE 	 _NEWLINE 	A = [] _NEWLINE 	for i in range(n): _NEWLINE 		t = [] _NEWLINE 		for j in range(n): _NEWLINE 			t.append(0) _NEWLINE 		A.append(t) _NEWLINE  _NEWLINE 	for i in range(m): _NEWLINE 		sa = getString().split() _NEWLINE 		a = int(sa[0])-1 _NEWLINE 		b = int(sa[1])-1 _NEWLINE 		if(a!=b): _NEWLINE 			A[a][b]-=1 _NEWLINE 			A[b][a]-=1 _NEWLINE 			A[a][a]+=1 _NEWLINE 			A[b][b]+=1 _NEWLINE  _NEWLINE 	if(n==1): print "1" _NEWLINE 	else: _NEWLINE 		print det(A,n-1)		 _NEWLINE 
 _NEWLINE import java.io.*; _NEWLINE import java.util.*; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE class WaitForIt { _NEWLINE  _NEWLINE // _INDENT static Map<Integer,Long> memo = new HashMap<Integer, Long>(); _NEWLINE  _INDENT  _NEWLINE  _INDENT static ILMap memo; _NEWLINE  _INDENT  _NEWLINE  _INDENT static final long mod = 1_000_000_007; _NEWLINE  _NEWLINE  _INDENT static void init(){ _NEWLINE  _INDENT  _INDENT memo = new ILMap(); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static class ILMap{ _NEWLINE  _INDENT  _INDENT static int S = 20_000_003; _NEWLINE  _INDENT  _INDENT int[] in = new int[S]; _NEWLINE  _INDENT  _INDENT long[] out = new long[S]; _NEWLINE  _INDENT  _INDENT public ILMap() { _NEWLINE  _INDENT  _INDENT  _INDENT Arrays.fill(out,-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int getLoc(long x){ _NEWLINE  _INDENT  _INDENT  _INDENT int loc = (int) ((x+x) % (long) S); _NEWLINE  _INDENT  _INDENT  _INDENT while(in[loc]!= 0 && in[loc]!=x){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT loc ++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(loc == S) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc = 0; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT return loc; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long get(int x){ _NEWLINE  _INDENT  _INDENT  _INDENT return out[getLoc(x)]; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT void put(int x,long y){ _NEWLINE  _INDENT  _INDENT  _INDENT int l = getLoc(x); _NEWLINE  _INDENT  _INDENT  _INDENT in[l] = x; _NEWLINE  _INDENT  _INDENT  _INDENT out[l] = y; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static long count(int n){ _NEWLINE  _INDENT  _INDENT if(n == 1) return 1; _NEWLINE  _INDENT  _INDENT long ret = memo.get(n); _NEWLINE  _INDENT  _INDENT if(ret != -1) _NEWLINE  _INDENT  _INDENT  _INDENT return ret; _NEWLINE  _INDENT  _INDENT long r = n; _NEWLINE  _INDENT  _INDENT r *= r; _NEWLINE  _INDENT  _INDENT int rn = (int) Math.sqrt(n); _NEWLINE  _INDENT  _INDENT for(int i=2; i<=rn; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT r -= count(n/i); _NEWLINE  _INDENT  _INDENT rn = n/rn; _NEWLINE  _INDENT  _INDENT for(int i=1; i<rn; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT r -= count(i)*(n/i - n/(i+1)); _NEWLINE  _INDENT  _INDENT r %= mod; _NEWLINE  _INDENT  _INDENT if (r < 0) r += mod; _NEWLINE  _INDENT  _INDENT memo.put(n,r); _NEWLINE  _INDENT  _INDENT return r; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static long solve(long a0, long b0, int n){ _NEWLINE  _INDENT  _INDENT long ret = 0; _NEWLINE  _INDENT  _INDENT long a,b; _NEWLINE  _INDENT  _INDENT a=b=1; _NEWLINE  _INDENT  _INDENT for(int i=1; i<=n; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT a = a*a0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT b = b*b0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(n/i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT System.out.println(ret); _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT static long pow(long x,int y){ _NEWLINE  _INDENT  _INDENT x %= mod; _NEWLINE  _INDENT  _INDENT long ret = 1; _NEWLINE  _INDENT  _INDENT for(;y>0; y>>=1){ _NEWLINE  _INDENT  _INDENT  _INDENT if((y & 1) > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret * x) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT x = (x * x) % mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT public static long[] gcd(long p, long q){ _NEWLINE  _INDENT  _INDENT if (q == 0) _NEWLINE  _INDENT  _INDENT  _INDENT return new long[] { p, 1, 0 }; _NEWLINE  _NEWLINE  _INDENT  _INDENT long[] vals = gcd(q, p % q); _NEWLINE  _INDENT  _INDENT long d = vals[0]; _NEWLINE  _INDENT  _INDENT long a = vals[2]; _NEWLINE  _INDENT  _INDENT long b = vals[1] - (p / q) * vals[2]; _NEWLINE  _INDENT  _INDENT return new long[] { d, a, b }; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT public static long inv(long x){ _NEWLINE  _INDENT  _INDENT if(x < 0) _NEWLINE  _INDENT  _INDENT  _INDENT x += mod; _NEWLINE  _INDENT  _INDENT long ret = gcd(mod,x)[2]; _NEWLINE  _INDENT  _INDENT if(ret < 0) _NEWLINE  _INDENT  _INDENT  _INDENT ret += mod; _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _NEWLINE  _INDENT static long solve2(long a0, long b0, int n){ _NEWLINE  _INDENT  _INDENT long ret = 0; _NEWLINE  _INDENT  _INDENT long a,b; _NEWLINE  _INDENT  _INDENT a=b=1; _NEWLINE  _INDENT  _INDENT int rn = (int) Math.sqrt(n); _NEWLINE  _INDENT  _INDENT for(int i=1; i<=rn; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT a = a*a0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT b = b*b0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(n/i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT rn = n/rn; _NEWLINE  _INDENT  _INDENT long ai = inv(a0-1); _NEWLINE  _INDENT  _INDENT long bi = b0==1 ? 1 : inv(b0-1); _NEWLINE  _INDENT  _INDENT for(int i=1; i<rn; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT int i0 = n/(i+1)+1; _NEWLINE  _INDENT  _INDENT  _INDENT int i1 = n/i; _NEWLINE  _INDENT  _INDENT  _INDENT a = pow(a0,i1+1)-pow(a0,i0); _NEWLINE  _INDENT  _INDENT  _INDENT b = b0 == 1 ? i1-i0+1 : pow(b0,i1+1)-pow(b0,i0); _NEWLINE  _INDENT  _INDENT  _INDENT a *= ai; _NEWLINE  _INDENT  _INDENT  _INDENT b *= bi; _NEWLINE  _INDENT  _INDENT  _INDENT a %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT b %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT c %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT System.out.println(ret); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT static long solve3(long a0, long b0, int n){ _NEWLINE  _INDENT  _INDENT long ret = 0; _NEWLINE  _INDENT  _INDENT long a,b; _NEWLINE  _INDENT  _INDENT a=b=1; _NEWLINE  _INDENT  _INDENT int rn = (int) Math.sqrt(n); _NEWLINE  _INDENT  _INDENT for(int i=1; i<=rn; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT a = a*a0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT b = b*b0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(n/i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT rn = n/rn; _NEWLINE  _INDENT  _INDENT long ai = inv(a0-1); _NEWLINE  _INDENT  _INDENT long bi = b0==1 ? 1 : inv(b0-1); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int i1 = n/(rn); _NEWLINE  _INDENT  _INDENT long ap = pow(a0,i1+1); _NEWLINE  _INDENT  _INDENT long bp = pow(b0,i1+1); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=rn-1; i>0; --i){ _NEWLINE  _INDENT  _INDENT  _INDENT int i0 = i1; _NEWLINE  _INDENT  _INDENT  _INDENT i1 = n/i; _NEWLINE  _INDENT  _INDENT  _INDENT a = - ap; _NEWLINE  _INDENT  _INDENT  _INDENT ap *= pow(a0,i1-i0); _NEWLINE  _INDENT  _INDENT  _INDENT ap %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT a += ap; _NEWLINE  _INDENT  _INDENT  _INDENT a %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT if(b0 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = i1-i0; _NEWLINE  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = - bp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bp *= pow(b0,i1-i0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bp %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b += bp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT a *= ai; _NEWLINE  _INDENT  _INDENT  _INDENT b *= bi; _NEWLINE  _INDENT  _INDENT  _INDENT a %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT b %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT c %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT System.out.println(ret); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT public static void main(String[] args) throws Exception{ _NEWLINE  _INDENT  _INDENT //goFile("input/input.txt"); _NEWLINE  _INDENT  _INDENT init(); _NEWLINE  _INDENT  _INDENT go(); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static int[] getInts(BufferedReader br) throws IOException{ _NEWLINE  _INDENT  _INDENT String[] ss = new String[0]; _NEWLINE  _INDENT  _INDENT while(ss.length==0 || "".equals(ss[0])) ss = _INDENT br.readLine().split(" "); _NEWLINE  _INDENT  _INDENT int[] ret = new int[ss.length]; _NEWLINE  _INDENT  _INDENT for(int i=0; i<ss.length; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT ret[i] = Integer.parseInt(ss[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT static void goFile(String s) throws Exception{ _NEWLINE  _INDENT  _INDENT go(new FileReader(new File(s))); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT static void go() throws Exception{ _NEWLINE  _INDENT  _INDENT go(new InputStreamReader(System.in)); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT static void go(Reader r) throws Exception{ _NEWLINE  _INDENT  _INDENT BufferedReader br = new BufferedReader(r); _NEWLINE  _INDENT  _INDENT int t = getInts(br)[0]; _NEWLINE  _INDENT  _INDENT for(int i=0; i<t; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT int[] x = getInts(br); _NEWLINE  _INDENT  _INDENT  _INDENT solve3(x[0],x[1],x[2]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <sstream> _NEWLINE #include <fstream> _NEWLINE #include <string> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <climits> _NEWLINE #include <cstring> _NEWLINE #include <ctime> _NEWLINE #include <cmath> _NEWLINE #include <cassert> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <utility> _NEWLINE #include <numeric> _NEWLINE #include <functional> _NEWLINE  _INDENT _NEWLINE #define forn(i, n) for (int i = 0; i < int(n); i++) _NEWLINE #define forl(i, n) for (int i = 1; i <= int(n); i++) _NEWLINE #define ford(i, n) for (int i = int(n) - 1; i >= 0; i--) _NEWLINE #define fore(i, l, r) for (int i = int(l); i <= int(r); i++) _NEWLINE #define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m)) _NEWLINE #define all(a) (a).begin(), (a).end() _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define pb(a) push_back(a) _NEWLINE #define mp(x, y) make_pair((x), (y)) _NEWLINE #define ft first _NEWLINE #define sc second _NEWLINE #define x first _NEWLINE #define y second _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long li; _NEWLINE typedef long double ld; _NEWLINE typedef pair<int, int> pt; _NEWLINE  _INDENT _NEWLINE template<typename X> inline X abs(const X& a) { return a < 0? -a: a; } _NEWLINE template<typename X> inline X sqr(const X& a) { return a * a; } _NEWLINE  _INDENT _NEWLINE const int INF = int(1e9); _NEWLINE const li INF64 = li(1e18); _NEWLINE const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795; _NEWLINE  _INDENT _NEWLINE int m, w[10]; _NEWLINE  _INDENT _NEWLINE inline bool read() _NEWLINE { _NEWLINE 	if (scanf("%d", &m) != 1) _NEWLINE 		return false; _NEWLINE 		 _NEWLINE 	forn(i, 10) _NEWLINE 		assert(scanf("%d", &w[i]) == 1); _NEWLINE 		 _NEWLINE 	return true; _NEWLINE } _NEWLINE  _INDENT _NEWLINE typedef unsigned int uint; _NEWLINE  _INDENT _NEWLINE const int N = 4 * 1000 * 1000 + 3, C = (1 << 9) + 3; _NEWLINE  _INDENT _NEWLINE int szcur, sznext; _NEWLINE int cur[N], next[N]; _NEWLINE int minPos[N]; _NEWLINE uint ans[N]; _NEWLINE int u = 0, used[N]; _NEWLINE int d1[N], d2[N]; _NEWLINE queue<int> q[C]; _NEWLINE  _INDENT _NEWLINE inline void solve(int test) _NEWLINE { _NEWLINE 	forn(i, m) d1[i] = d2[i] = INF; _NEWLINE 	 _NEWLINE 	d1[0] = 0; _NEWLINE 	q[d1[0]].push(0); _NEWLINE 	 _NEWLINE 	for (int qq = 0, dd = 0; ; qq = (qq + 1) & 511, dd++) _NEWLINE 	{ _NEWLINE 		bool end = true; forn(i, 512) end &= q[i].empty(); _NEWLINE 		if (end) break; _NEWLINE 		 _NEWLINE 		while (!q[qq].empty()) _NEWLINE 		{ _NEWLINE  _INDENT  _INDENT 		int v = q[qq].front(); _NEWLINE  _INDENT  _INDENT 		q[qq].pop(); _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		if (d1[v] != dd) continue; _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		int nrm = v * 10; _NEWLINE  _INDENT  _INDENT 		(nrm >= m) && (nrm %= m); _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		int dd1 = d1[v]; _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		forn(i, 10) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			int next = nrm + i; _NEWLINE  _INDENT  _INDENT 			while (next >= m) next -= m; _NEWLINE  _INDENT  _INDENT 			int nd1 = dd1 + w[i]; _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 			if (d1[next] > nd1) _NEWLINE  _INDENT  _INDENT 			{ _NEWLINE  _INDENT  _INDENT 				d1[next] = nd1; _NEWLINE  _INDENT  _INDENT 				q[d1[next] & 511].push(next); _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 		} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	cerr << clock() << endl; _NEWLINE 	 _NEWLINE 	queue<int> qq; _NEWLINE 	d2[0] = 0; _NEWLINE 	qq.push(0); _NEWLINE 	 _NEWLINE 	while (!qq.empty()) _NEWLINE 	{ _NEWLINE 		int v = qq.front(); _NEWLINE 		qq.pop(); _NEWLINE 		 _NEWLINE 		int nrm = v * 10; _NEWLINE 		(nrm >= m) && (nrm %= m); _NEWLINE 		 _NEWLINE 		int dd1 = d1[v]; _NEWLINE 		int dd2 = d2[v]; _NEWLINE 		 _NEWLINE 		forn(i, 10) _NEWLINE 		{ _NEWLINE 			int next = nrm + i; _NEWLINE 			while (next >= m) next -= m; _NEWLINE 			int nd1 = dd1 + w[i]; _NEWLINE 			int nd2 = dd2 + 1; _NEWLINE 			 _NEWLINE 			if (d1[next] == nd1 && d2[next] > nd2) _NEWLINE 			{ _NEWLINE 				d2[next] = nd2; _NEWLINE 				qq.push(next); _NEWLINE 			} _NEWLINE 		} _NEWLINE  	} _NEWLINE 	 _NEWLINE 	//forn(i, m) assert(d[i].ft < INF / 2); _NEWLINE 	 _NEWLINE 	cerr << clock() << endl; _NEWLINE 	 _NEWLINE 	forn(i, m) minPos[i] = INF; _NEWLINE 	 _NEWLINE 	u++; _NEWLINE 	used[0] = u; _NEWLINE 	szcur = 0; _NEWLINE 	cur[szcur++] = 0; _NEWLINE 	ans[0] = 0; _NEWLINE 	 _NEWLINE 	li res = 0; _NEWLINE 	int sum = 0; _NEWLINE 	 _NEWLINE 	while (szcur > 0) _NEWLINE 	{ _NEWLINE 		sum += szcur; _NEWLINE 		 _NEWLINE 		forn(t, szcur) _NEWLINE 		{ _NEWLINE 			int v = cur[t]; _NEWLINE 			res += ::ans[v]; _NEWLINE 			 _NEWLINE  _INDENT  _INDENT 		forn(i, 10) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			int next = (v * 10 + i) % m; _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1) minPos[next] = min(minPos[next], t); _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	 _NEWLINE 		sznext = 0; _NEWLINE 		 _NEWLINE 		forn(t, szcur) _NEWLINE 		{ _NEWLINE 			int v = cur[t]; _NEWLINE 			 _NEWLINE  _INDENT  _INDENT 		forn(i, 10) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			int next = (v * 10 + i) % m; _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1 && minPos[next] == t && used[next] != u) _NEWLINE  _INDENT  _INDENT 			{ _NEWLINE  _INDENT  _INDENT 				used[next] = u; _NEWLINE  _INDENT  _INDENT 				ans[next] = ans[v] * 3141 + i; _NEWLINE  _INDENT  _INDENT 				::next[sznext++] = next; _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT 	//sort(next, next + sznext); _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT 	szcur = sznext; _NEWLINE  _INDENT  _INDENT 	forn(i, szcur) cur[i] = next[i]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	//cerr << sum << ' ' << m << endl; _NEWLINE 	assert(sum == m); _NEWLINE 	 _NEWLINE 	cout << res << endl; _NEWLINE 	 _NEWLINE 	cerr << clock() << endl; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE #ifdef SU2_PROJ _NEWLINE  _INDENT  _INDENT freopen("input.txt", "rt", stdin); _NEWLINE  _INDENT  _INDENT freopen("output.txt", "wt", stdout); _NEWLINE #endif _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT cout << setprecision(10) << fixed; _NEWLINE  _INDENT  _INDENT cerr << setprecision(5) << fixed; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int testCount; _NEWLINE  _INDENT  _INDENT cin >> testCount; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT forn(test, testCount) _NEWLINE  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT assert(read()); _NEWLINE 		solve(test); _NEWLINE 	} _NEWLINE 	 _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int T; _NEWLINE int N; _NEWLINE  _NEWLINE struct bian_ _NEWLINE { _NEWLINE 	int to; _NEWLINE 	int next; _NEWLINE }bian[200010]={{0,0}}; _NEWLINE int First[100010]={0}; _NEWLINE  _NEWLINE struct Tree _NEWLINE { _NEWLINE 	int fas,fax; _NEWLINE 	int son[2]; _NEWLINE 	int Min; _NEWLINE }tree[100010]={{0,0,{0},0}}; _NEWLINE  _NEWLINE struct SegTree _NEWLINE { _NEWLINE 	long long Sum; _NEWLINE 	long long add; _NEWLINE }segtree[400010]={{0,0}}; _NEWLINE  _NEWLINE int St[100010]={0},En[100010]={0}; _NEWLINE int dfsp=0; _NEWLINE  _NEWLINE void Add(int p,int q,int k) _NEWLINE { _NEWLINE 	bian[k].to=q; _NEWLINE 	bian[k].next=First[p]; _NEWLINE 	First[p]=k; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Merge(int x) _NEWLINE { _NEWLINE 	tree[x].Min=x; _NEWLINE 	if(tree[x].son[0]!=0) _NEWLINE 		tree[x].Min=tree[tree[x].son[0]].Min; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Rotate(int x) _NEWLINE { _NEWLINE 	int Fa=tree[x].fas; _NEWLINE 	swap(tree[x].fax,tree[Fa].fax); _NEWLINE 	tree[x].fas=tree[Fa].fas; _NEWLINE 	if(tree[Fa].fas!=0) _NEWLINE 	{ _NEWLINE 		int g=(tree[tree[Fa].fas].son[1]==Fa); _NEWLINE 		tree[tree[Fa].fas].son[g]=x; _NEWLINE 	} _NEWLINE 	tree[Fa].fas=x; _NEWLINE 	int g=(tree[Fa].son[1]==x); _NEWLINE 	tree[Fa].son[g]=tree[x].son[g^1]; _NEWLINE 	if(tree[x].son[g^1]!=0) _NEWLINE 		tree[tree[x].son[g^1]].fas=Fa; _NEWLINE 	tree[x].son[g^1]=Fa; _NEWLINE 	Merge(Fa);Merge(x); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Splay(int x) _NEWLINE { _NEWLINE 	for(;tree[x].fas!=0;) _NEWLINE 	{ _NEWLINE 		int Fa=tree[x].fas; _NEWLINE 		if(tree[Fa].fas!=0) _NEWLINE 		{ _NEWLINE 			int g1=(tree[tree[Fa].fas].son[1]==Fa); _NEWLINE 			int g2=(tree[Fa].son[1]==x); _NEWLINE 			if(g1==g2) _NEWLINE 				Rotate(Fa); _NEWLINE 			else Rotate(x); _NEWLINE 		} _NEWLINE 		Rotate(x); _NEWLINE 	} _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void update(int l,int r,int k,long long c) _NEWLINE { _NEWLINE 	segtree[k].add+=c; _NEWLINE 	segtree[k].Sum+=c*(r-l+1); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void pushdown(int l,int r,int k) _NEWLINE { _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	update(l,mid,k<<1,segtree[k].add); _NEWLINE 	update(mid+1,r,k<<1|1,segtree[k].add); _NEWLINE 	segtree[k].add=0; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Change(int l,int r,int k,int al,int ar,long long c) _NEWLINE { _NEWLINE 	if(al<=l && r<=ar) _NEWLINE 	{ _NEWLINE 		update(l,r,k,c); _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	pushdown(l,r,k); _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	if(al<=mid) Change(l,mid,k<<1,al,ar,c); _NEWLINE 	if(ar>mid) Change(mid+1,r,k<<1|1,al,ar,c); _NEWLINE 	segtree[k].Sum=segtree[k<<1].Sum+segtree[k<<1|1].Sum; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE long long Query(int l,int r,int k,int al,int ar) _NEWLINE { _NEWLINE 	if(al<=l && r<=ar) return segtree[k].Sum; _NEWLINE 	pushdown(l,r,k); _NEWLINE 	long long ret=0; _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	if(al<=mid) ret+=Query(l,mid,k<<1,al,ar); _NEWLINE 	if(ar>mid) ret+=Query(mid+1,r,k<<1|1,al,ar); _NEWLINE 	return ret; _NEWLINE } _NEWLINE  _NEWLINE void cut(int x,int g) _NEWLINE { _NEWLINE 	if(tree[x].son[g]==0) return; _NEWLINE 	int Son=tree[x].son[g]; _NEWLINE 	tree[x].son[g]=0; _NEWLINE 	swap(tree[Son].fax,tree[Son].fas); _NEWLINE 	Change(1,N,1,St[tree[Son].Min],En[tree[Son].Min],1); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Link(int x,int y) _NEWLINE { _NEWLINE 	tree[x].son[1]=y; _NEWLINE 	swap(tree[y].fas,tree[y].fax); _NEWLINE 	Change(1,N,1,St[tree[y].Min],En[tree[y].Min],-1); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void access(int x) _NEWLINE { _NEWLINE 	Splay(x); _NEWLINE 	cut(x,1); _NEWLINE 	for(;tree[x].fax!=0;) _NEWLINE 	{ _NEWLINE 		Splay(tree[x].fax); _NEWLINE 		cut(tree[x].fax,1); _NEWLINE 		Link(tree[x].fax,x); _NEWLINE 		Splay(x); _NEWLINE 	} _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void buildtree(int cnt,int fa) _NEWLINE { _NEWLINE 	St[cnt]=++dfsp; _NEWLINE 	tree[cnt].Min=cnt; _NEWLINE 	for(int i=First[cnt];i!=0;i=bian[i].next) _NEWLINE 	{ _NEWLINE 		int u=bian[i].to; _NEWLINE 		if(u==fa) continue; _NEWLINE 		tree[u].fax=cnt; _NEWLINE 		buildtree(u,cnt); _NEWLINE 		Change(1,N,1,St[u],En[u],1); _NEWLINE 	} _NEWLINE 	En[cnt]=dfsp; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	cin>>T; _NEWLINE 	for(;T>0;T--) _NEWLINE 	{ _NEWLINE 		cin>>N; _NEWLINE 		memset(First,0,sizeof(First)); _NEWLINE 		memset(tree,0,sizeof(tree)); _NEWLINE 		memset(segtree,0,sizeof(segtree)); _NEWLINE 		dfsp=0; _NEWLINE 		for(int i=1;i<N;i++) _NEWLINE 		{ _NEWLINE 			int p,q; _NEWLINE 			scanf("%d%d",&p,&q); _NEWLINE 			p++,q++; _NEWLINE 			Add(p,q,(i<<1)-1); _NEWLINE 			Add(q,p,i<<1); _NEWLINE 		} _NEWLINE 		buildtree(1,0); _NEWLINE 		int Q; _NEWLINE 		cin>>Q; _NEWLINE 		for(;Q>0;Q--) _NEWLINE 		{ _NEWLINE 			char ch[20]="\0"; _NEWLINE 			int x; _NEWLINE 			scanf("%s%d",ch,&x); _NEWLINE 			x++; _NEWLINE 			if(ch[0]=='O') _NEWLINE 				access(x); _NEWLINE 			else printf("%.10lf\n",Query(1,N,1,St[x],En[x])*1.0/(En[x]-St[x]+1)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
# cook your code here _NEWLINE test = input() _NEWLINE for t in xrange(test): _NEWLINE  _INDENT  _INDENT s = range(1, input()+1) _NEWLINE  _INDENT  _INDENT w = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(len(w)-1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if w[i] > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.insert(i, s.pop(i - w[i])) _NEWLINE  _INDENT  _INDENT print ' '.join(map(str, s)) _NEWLINE  _INDENT  _INDENT 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstdio> _NEWLINE #define N 100001 _NEWLINE using namespace std; _NEWLINE struct node{ _NEWLINE 	long long K,B; _NEWLINE 	long long sum; _NEWLINE 	int son[2]; _NEWLINE 	int belong; _NEWLINE 	long long calc(long long x){ _NEWLINE 		return x*B+K*(x-1)*x/2; _NEWLINE 	} _NEWLINE }f[N*17*17]; _NEWLINE int L; _NEWLINE int n,m,now,last,top; _NEWLINE int dfn[N],b[N][2],deep[N],g[N],h[N],fa[N][17],a[N*2][2],q[N]; _NEWLINE void ins(int x,int y){ _NEWLINE 	static int sum=1; _NEWLINE 	a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum; _NEWLINE } _NEWLINE void dfs(int x){ _NEWLINE 	for (int i=0;fa[fa[x][i]][i];i++)fa[x][i+1]=fa[fa[x][i]][i]; _NEWLINE 	deep[x]++; _NEWLINE 	for (int i=g[x];i;i=a[i][1]) _NEWLINE 		if (a[i][0]!=fa[x][0]){ _NEWLINE 			deep[a[i][0]]=deep[x]; _NEWLINE 			fa[a[i][0]][0]=x; _NEWLINE 			dfs(a[i][0]); _NEWLINE 			if (b[a[i][0]][1]+1>b[x][1]) _NEWLINE 				b[x][1]=b[a[i][0]][1]+1,b[x][0]=a[i][0]; _NEWLINE 		} _NEWLINE } _NEWLINE void dfs1(int x){ _NEWLINE 	static int sum=0; _NEWLINE 	dfn[x]=++sum; _NEWLINE 	if (b[x][0]) _NEWLINE 		h[b[x][0]]=h[x],dfs1(b[x][0]); _NEWLINE 	for (int i=g[x];i;i=a[i][1]) _NEWLINE 		if (a[i][0]!=b[x][0]&&a[i][0]!=fa[x][0]) _NEWLINE 			h[a[i][0]]=a[i][0],dfs1(a[i][0]); _NEWLINE } _NEWLINE int getlca(int x,int y){ _NEWLINE 	static int i; _NEWLINE 	i=16; _NEWLINE 	if (deep[x]<deep[y])swap(x,y); _NEWLINE 	while (deep[x]!=deep[y]){ _NEWLINE 		for (;deep[fa[x][i]]<deep[y];i--); _NEWLINE 		x=fa[x][i]; _NEWLINE 	} _NEWLINE 	i=16; _NEWLINE 	while (x!=y){ _NEWLINE 		for (;i&&fa[x][i]==fa[y][i];i--); _NEWLINE 		x=fa[x][i],y=fa[y][i]; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE int getlca1(int x,int y){ _NEWLINE 	static int i; _NEWLINE 	i=16; _NEWLINE 	while (deep[x]>y){ _NEWLINE 		for (;deep[fa[x][i]]<y;)i--; _NEWLINE 		x=fa[x][i]; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE long long get(int s,int l,int r,int ll,int rr){ _NEWLINE 	ll=max(ll,l); _NEWLINE 	rr=min(rr,r); _NEWLINE 	if (ll>rr||!s)return 0; _NEWLINE 	if (ll==l&&r==rr)return f[s].sum; _NEWLINE 	return get(f[s].son[0],l,(l+r)>>1,ll,rr)+get(f[s].son[1],((l+r)>>1)+1,r,ll,rr)-f[s].calc(ll-l)+f[s].calc(rr-l+1); _NEWLINE } _NEWLINE long long up(int x,int y){ _NEWLINE 	static long long s; _NEWLINE 	s=0; _NEWLINE 	while (deep[x]>=deep[y]){ _NEWLINE 		if (deep[h[x]]<=deep[y]){ _NEWLINE 			s+=get(now,1,n,dfn[y],dfn[x]); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		s+=get(now,1,n,dfn[h[x]],dfn[x]); _NEWLINE 		x=fa[h[x]][0]; _NEWLINE 	} _NEWLINE 	return s; _NEWLINE } _NEWLINE long long getans(int x,int y){ _NEWLINE 	static long long s; _NEWLINE 	s=0; _NEWLINE 	while (deep[x]>=deep[y]){ _NEWLINE 		if (deep[h[x]]<=deep[y]){ _NEWLINE 			s+=get(now,1,n,dfn[y],dfn[x]); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		s+=get(now,1,n,dfn[h[x]],dfn[x]); _NEWLINE 		x=fa[h[x]][0]; _NEWLINE 	} _NEWLINE 	return s; _NEWLINE } _NEWLINE int ins(int s,int l,int r,int ll,int rr,long long K,long long B){ _NEWLINE 	ll=max(ll,l),rr=min(rr,r); _NEWLINE 	if (ll>rr)return s; _NEWLINE 	if (!s) _NEWLINE 		f[s=++L].belong=now; _NEWLINE 	else _NEWLINE 	if (f[s].belong!=now){ _NEWLINE 		f[++L]=f[s]; _NEWLINE 		f[L].belong=now; _NEWLINE 		s=L; _NEWLINE 	} _NEWLINE 	if (ll<=l&&r<=rr){ _NEWLINE 		f[s].K+=K,f[s].B+=B; _NEWLINE 		f[s].sum+=K*(r-l)*(r-l+1)/2+B*(r-l+1); _NEWLINE 		return s; _NEWLINE 	} _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	if (mid>=ll){ _NEWLINE 		f[s].son[0]=ins(f[s].son[0],l,(l+r)>>1,ll,rr,K,B); _NEWLINE 		f[s].son[1]=ins(f[s].son[1],((l+r)>>1)+1,r,ll,rr,K,B+K*(mid-ll+1)); _NEWLINE 	}else _NEWLINE 		f[s].son[1]=ins(f[s].son[1],((l+r)>>1)+1,r,ll,rr,K,B); _NEWLINE 	f[s].sum=f[f[s].son[0]].sum+f[f[s].son[1]].sum+f[s].calc(r-l+1); _NEWLINE 	return s; _NEWLINE } _NEWLINE void up(int x,int y,long long K,long long B){ _NEWLINE 	static int sum; _NEWLINE 	while (deep[x]>=deep[y]){ _NEWLINE 		if (deep[h[x]]<=deep[y]){ _NEWLINE 			sum=deep[x]-deep[y]+1; _NEWLINE 			ins(now,1,n,dfn[y],dfn[x],-K,B+(sum-1)*K); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		sum=deep[x]-deep[h[x]]+1; _NEWLINE 		ins(now,1,n,dfn[h[x]],dfn[x],-K,B+(sum-1)*K); _NEWLINE 		B+=sum*K; _NEWLINE 		x=fa[h[x]][0]; _NEWLINE 	} _NEWLINE } _NEWLINE int main(){ _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	for (int i=1;i<n;i++){ _NEWLINE 		int x,y; _NEWLINE 		scanf("%d %d",&x,&y); _NEWLINE 		ins(x,y),ins(y,x); _NEWLINE 	} _NEWLINE 	dfs(1); _NEWLINE 	h[1]=1; _NEWLINE 	dfs1(1); _NEWLINE 	now=1; _NEWLINE 	q[0]=1; _NEWLINE 	L=1; _NEWLINE 	f[1].belong=1; _NEWLINE 	long long ans=0; _NEWLINE 	while (m--){ _NEWLINE 		char c; _NEWLINE 		int x,y,K,B; _NEWLINE 		scanf(" %c",&c); _NEWLINE 		if (c=='c'){ _NEWLINE 			scanf("%d %d %d %d",&x,&y,&B,&K); _NEWLINE 			x=(x+ans)%n+1,y=(y+ans)%n+1; _NEWLINE 			int lca=getlca(x,y); _NEWLINE 			last=now,now=++L,f[now]=f[last]; _NEWLINE 			q[++top]=now; _NEWLINE 			f[now].belong=now; _NEWLINE 			up(x,lca,K,B); _NEWLINE 			if (y==lca)continue; _NEWLINE 			int lca1=getlca1(y,deep[lca]+1); _NEWLINE 			up(y,lca1,-K,B+K*(deep[x]+deep[y]-deep[lca]*2)); _NEWLINE 		}else _NEWLINE 		if (c=='q'){ _NEWLINE 			scanf("%d %d",&x,&y); _NEWLINE 			x=(x+ans)%n+1,y=(y+ans)%n+1; _NEWLINE 			if (deep[x]<deep[y])swap(x,y); _NEWLINE 			int lca=getlca(x,y); _NEWLINE 			if (lca==y){ _NEWLINE 				printf("%lld\n",ans=getans(x,lca)); _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			int lca1=getlca1(y,deep[lca]+1); _NEWLINE 			printf("%lld\n",ans=getans(x,lca)+getans(y,lca1)); _NEWLINE 		}else{ _NEWLINE 			scanf("%d",&x); _NEWLINE 			x=(x+ans)%(top+1); _NEWLINE 			now=q[x]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <stack> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE template <typename T> T sqr(T x) { return x * x; } _NEWLINE template <typename T> T abs(T x) { return x < 0? -x : x; } _NEWLINE  _INDENT _NEWLINE const int MAXN = 10007; _NEWLINE const int MAXK = 80; _NEWLINE  _INDENT _NEWLINE #define A first _NEWLINE #define S second _NEWLINE  _INDENT _NEWLINE #define left dsalkhfas _NEWLINE #define right sdjkfhkas _NEWLINE  _INDENT _NEWLINE typedef map < int, stack <int> > mmap; _NEWLINE  _INDENT _NEWLINE int ans[MAXN]; _NEWLINE mmap M; _NEWLINE int n, m, k; _NEWLINE int L, H, N; _NEWLINE int left, right; _NEWLINE  _INDENT _NEWLINE vector < pair <int, int> > a, b; _NEWLINE map < int, int > f[MAXK][MAXK], g[MAXK][MAXK]; _NEWLINE  _INDENT _NEWLINE void solve(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK]) _NEWLINE { _NEWLINE 		for (int i = 0; i <= (int)a.size(); i++) _NEWLINE 			for (int j = 0; j <= N; j++) _NEWLINE 				f[i][j].clear(); _NEWLINE 				 _NEWLINE 		f[0][0][0] = 0; _NEWLINE 		for (int i = 0; i < (int)a.size(); i++) _NEWLINE 			for (int j = 0; j <= N; j++) _NEWLINE 				for (int k = 0; k <= N - j && k * H <= a[i].S; k++) _NEWLINE 					if ((a[i].S - k * H) % L == 0) _NEWLINE 						for (map < int, int > :: iterator iter = f[i][j].begin(); iter != f[i][j].end(); iter++) _NEWLINE 							f[i + 1][j + k][(iter->first + (k + (a[i].S - k * H) / L) * (long long)a[i].A) % m] = k; _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE void recovery(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK], int x, int y, int z) _NEWLINE { _NEWLINE 	while (x) _NEWLINE 	{ _NEWLINE 		int c = f[x][y][z]; _NEWLINE 		x--; _NEWLINE 		 _NEWLINE 		stack <int> &st = M[a[x].A]; _INDENT _NEWLINE 		for (int i = 0; i < c; i++) _NEWLINE 		{ _NEWLINE 			for (int j = 0; j < H; j++) _NEWLINE 			{ _NEWLINE 				ans[left + k * j] = st.top(); _NEWLINE 				st.pop(); _NEWLINE 			} _NEWLINE 			left++; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		for (int i = 0; i < (a[x].S - c * H) / L; i++) _NEWLINE 		{ _NEWLINE 			for (int j = 0; j < L; j++) _NEWLINE 			{ _NEWLINE 				ans[right + k * j] = st.top(); _NEWLINE 				st.pop(); _NEWLINE 			} _NEWLINE 			right--; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		z = ((z - (c + (a[x].S - c * H) / L) * (long long)a[x].A) % m + m) % m; _NEWLINE 		y -= c; _NEWLINE 	}	 _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	#ifndef ONLINE_JUDGE _NEWLINE 		freopen("in", "r", stdin); _NEWLINE 		freopen("out", "w", stdout); _NEWLINE 	#endif _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		M.clear(); _NEWLINE 		scanf("%d %d %d", &n, &m, &k); _NEWLINE 		for (int i = 0; i < n; i++) _NEWLINE 		{ _NEWLINE 			int x; _NEWLINE 			scanf("%d", &x); _NEWLINE 			M[x % m].push(x); _NEWLINE 		} _NEWLINE 		if ((int)M.size() > k) _NEWLINE 		{ _NEWLINE 			puts("-1"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		a.clear(); _NEWLINE 		b.clear(); _NEWLINE 		for (mmap :: iterator iter = M.begin(); iter != M.end(); ++iter) _NEWLINE 		{ _NEWLINE 			if (a.size() == b.size()) _NEWLINE 				a.push_back(make_pair(iter->first, iter->second.size())); _NEWLINE 			else _NEWLINE 				b.push_back(make_pair(iter->first, iter->second.size())); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		H = n / k + 1; _NEWLINE 		L = H - 1; _NEWLINE 		N = n % k; _NEWLINE 		 _NEWLINE 		solve(a, f); _NEWLINE 		solve(b, g); _NEWLINE 		 _NEWLINE 		bool flg = false; _NEWLINE 		left = 0; _NEWLINE 		right = k - 1; _NEWLINE 		for (int i = 0; i <= N && !flg; i++) _NEWLINE 			for (map < int, int > :: iterator iter = f[(int)a.size()][i].begin(); iter != f[(int)a.size()][i].end(); iter++) _NEWLINE 				if (g[(int)b.size()][N - i].find((m - iter->first) % m) != g[(int)b.size()][N - i].end()) _NEWLINE 				{ _NEWLINE 					recovery(a, f, a.size(), i, iter->first); _NEWLINE 					recovery(b, g, b.size(), N - i, (m - iter->first) % m); _NEWLINE 					flg = true; _NEWLINE 					break; _NEWLINE 				} _NEWLINE  _INDENT _NEWLINE 		if (!flg) _NEWLINE 		{ _NEWLINE 			puts("-1"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		for (int i = 0; i < n; i++) _NEWLINE 		{ _NEWLINE 			if (i) printf(" "); _NEWLINE 			printf("%d", ans[i]); _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
def c(n,p,q,pp,qq): _NEWLINE  _INDENT  _INDENT p.sort(reverse=pp);q.sort(reverse=qq) _NEWLINE  _INDENT  _INDENT ta=tb=0 _NEWLINE  _INDENT  _INDENT ma=mb=-1 _NEWLINE  _INDENT  _INDENT ca=cb=0 _NEWLINE  _INDENT  _INDENT a=[-1]*n;b=[-1]*n _NEWLINE  _INDENT  _INDENT A=[i for i in xrange(n)];B=[i for i in xrange(n)] _NEWLINE  _INDENT  _INDENT while 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ta==tb:ma=mb=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ta<=tb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p[i][1]==mb:continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[p[i][1]]=ta;ma=p[i][1];ta+=p[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0;A.remove(i);ca+=1;break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if f:ta=tb _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ta>=tb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in B: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i][1]==ma:continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[q[i][1]]=tb;mb=q[i][1];tb+=q[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0;B.remove(i);cb+=1;break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if f:tb=ta _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ca==n and cb==n:break _NEWLINE  _INDENT  _INDENT return max(ta,tb),a,b _NEWLINE  _INDENT _NEWLINE t=input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT p=[0]*n;q=[0]*n _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p[i]=[tmp[0],i];q[i]=[tmp[1],i] _NEWLINE  _INDENT  _INDENT ans=2*10**9+1 _NEWLINE  _INDENT  _INDENT for i in xrange(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp=c(n,p,q,i,j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if tmp[0]<ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=tmp[0];a=tmp[1];b=tmp[2] _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print a[i],b[i]
from itertools import combinations _NEWLINE from collections import defaultdict _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def small_j(sticks, cum, k): _NEWLINE  _INDENT  _INDENT for j in range(k - 1, len(sticks)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = j - k + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp = sticks[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rest = cum[j - 1] - cum[i] + sticks[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if rest > hyp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return i, j _NEWLINE  _INDENT  _INDENT return None, None _NEWLINE  _INDENT _NEWLINE def small_ii(sticks, cum, k): _NEWLINE  _INDENT  _INDENT for jj in range(-1, k - len(sticks) - 1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ii = jj - k + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp = sticks[jj] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rest = cum[jj - 1] - cum[ii] + sticks[ii] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if rest > hyp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(sticks) + ii, len(sticks) + jj _NEWLINE  _INDENT  _INDENT assert False _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def solve(n, k, sticks): _NEWLINE  _INDENT  _INDENT len_pos = defaultdict(list) _NEWLINE  _INDENT  _INDENT for pos, len_ in enumerate(sticks): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT len_pos[len_].append(str(pos + 1)) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT sticks.sort() _NEWLINE  _INDENT  _INDENT tot = 0 _NEWLINE  _INDENT  _INDENT cum = [] _NEWLINE  _INDENT  _INDENT for s in sticks: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tot += s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cum.append(tot) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT i, j = small_j(sticks, cum, k) _NEWLINE  _INDENT  _INDENT if j is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "No" _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT ii, jj = small_ii(sticks, cum, k) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT if ii > j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = sticks[i:j+1] + sticks[ii:jj+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans_i = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for len_ in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans_i.append(len_pos[len_].pop()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "Yes\n" + " ".join(ans_i) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT if jj < 2*k - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "No" _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT chosen_sticks = list(enumerate(sticks[jj - 2*k + 1: jj+1])) _NEWLINE  _INDENT  _INDENT assert len(chosen_sticks) == 2*k _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT positions = range(len(chosen_sticks)) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT solution = None _NEWLINE  _INDENT  _INDENT for poly1 in combinations(positions, r=k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poly1 = list(poly1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i1 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp1 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp2 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for pos, cs in chosen_sticks: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i1 < k and pos == poly1[i1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum1 += cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i1 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hyp1 = cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum2 += cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hyp2 = cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1 -= hyp1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2 -= hyp2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sum1 > hyp1 and sum2 > hyp2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT solution = poly1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT if solution is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "No" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT chosen_sticks = [v for _, v in chosen_sticks] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poly1 = [chosen_sticks[i] for i in solution] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for v in poly1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chosen_sticks.remove(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poly2 = chosen_sticks _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = poly1 + poly2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans_i = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for len_ in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans_i.append(len_pos[len_].pop()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "Yes\n" + " ".join(ans_i) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE # from random import randint _NEWLINE # _NEWLINE # for i in range(100): _NEWLINE # _INDENT  _INDENT  break _NEWLINE # _INDENT  _INDENT  for mx in range(1,100, 5): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  for x in range(0, 5): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for k in range(3, 10): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half1 = [randint(1, mx) for i in range(k-1)] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half1.append(sum(half1)-1) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half2 = [randint(1, mx) for i in range(k-1)] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half2.append(sum(half2)-1) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  extra = [randint(1, mx) for i in range(x)] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sticks = half1 + half2 + extra _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ans = solve(len(sticks), k, sticks) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if ans == "No": _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print half1, half2, sticks _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  pass _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #print ans _NEWLINE # _NEWLINE # print solve(6,3, [4, 46, 53, 59, 62, 98]) _NEWLINE  _INDENT _NEWLINE n, k = map(int, raw_input().split()) _NEWLINE sticks = map(int, raw_input().split()) _NEWLINE print solve(n, k, sticks) 
n,k = map(int, raw_input().split()) _NEWLINE b = map(int, raw_input().split()) _NEWLINE bs = sorted(set(b)) _NEWLINE  _NEWLINE lst = bs[0] _NEWLINE add = 1 _NEWLINE for i in range(1,len(bs)): _NEWLINE  _INDENT  _INDENT if(bs[i]>=lst+k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lst=bs[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE print add
#include <bits/stdc++.h> _NEWLINE #define MOD 1000000007 _NEWLINE #define maxn 555 _NEWLINE #define maxm 1111111 _NEWLINE using namespace std; _NEWLINE int B[] = {1,500000004,166666668,0,766666672,0,23809524,0,766666672,0,348484851,0,469963373,0,166666669,0,413725486,0,865914848,0,948484326,0,427542427,0,469876793,0,168092185,0,980747753,0,678176322,0,297409831,0,781306726,0,35337905,0,482221937,0,83084250,0,310292012,0,334581823,0,437628892,0,708314481,0,860344292,0,643009310,0,159517512,0,742356578,0,392872747,0,465850017,0,647900229,0,431346688,0,461733065,0,255588829,0,307276324,0,610411531,0,197137262,0,18565655,0,852238879,0,284923925,0,483196916,0,208794235,0,148591948,0,244784253,0,416223553,0,138705149,0,711847843,0,394739272,0,39530788,0,94103270,0,944699132,0,555008829,0,134395782,0,775574192,0,526027076,0,366329102,0,997501812,0,64960653,0,917154602,0,537182455,0,171713000,0,799849313,0,974650756,0,764681019,0,129465940,0,514970793,0,185828032,0,874015104,0,8063031,0,637955273,0,873230471,0,104279039,0,836586090,0,597557491,0,392225623,0,676908015,0,88768944,0,498487309,0,451730794,0,566607730,0,444106794,0,181463496,0,127835995,0,763021163,0,570276863,0,393273175,0,462754189,0,379663078,0,318486088,0,208134750,0,178450624,0,960012260,0,180738104,0,756632653,0,645210773,0,79148833,0,45135138,0,965798517,0,513668750,0,569147985,0,377199181,0,822327589,0,256265266,0,791964162,0,29587355,0,327610019,0,862621077,0,549923786,0,132821305,0,674078980,0,961947656,0,919724059,0,689243733,0,72331329,0,586420422,0,773720988,0,443408114,0,908991031,0,207009656,0,296402826,0,77102696,0,369815072,0,310161627,0,631457613,0,604069632,0,716006985,0,510023389,0,167568388,0,694658101,0,706710536,0,838416939,0,240289128,0,696217436,0,343729523,0,34462081,0,373123193,0,279501781,0,519692461,0,869446785,0,529273692,0,499794482,0,658700293,0,493702151,0,342395770,0,729371213,0,301819236,0,128980415,0,132306570,0,241791898,0,492800463,0,663928117,0,609246064,0,742804971,0,191205480,0,733562164,0,534291334,0,100454741,0,680938365,0,112611490,0,518509669,0,515895557,0,650367989,0,482520941,0,608281652,0,132944223,0,980310087,0,492175239,0,276254120,0,937618650,0,342877120,0,603124736,0,499580133,0,956083803,0,647937936,0,391675275,0,551847266,0,189330612,0,536587296,0,137527475,0,634139293,0,547079242,0,62582319,0,874691594,0,953985920,0,123065123,0,102680251,0,598629189,0,765865958,0,122003913,0,5388217,0,985831463,0,35749021,0,5485253,0,610847551,0,957553266,0,966107971,0,434637748,0,891023940,0,368937249,0,743121746,0,647582764,0,394861194,0,259611444,0,401218546,0,280958587,0,146726474,0,73728156,0,420484782,0,860432061,0,263555720,0,171370950,0,288940895,0,433962809,0,12810405,0,389000258,0,232347992,0,457377160,0,611980685,0,931117158,0,528373281,0,776924478,0,895196991,0,52260137,0,103734862,0,534188375,0,528819173,0,515009883,0,358459629,0,411876639,0,110831030,0,369807092,0,151928066,0,481598434,0,213781569,0,946564591,0,22612993,0,147058031,0,705049590,0,671160341,0,274407250,0,803279265,0,296028218,0,829477416,0,627699152,0,889545991,0,602277421,0,440283672,0,574919593,0,151551215,0,467285232,0,590802585,0,914358666,0,760187446,0,475666672,0,666337315,0,666685349,0,972161058,0,141242138,0,210381798,0,330198584,0,489119877,0,165342809,0,412027566,0,35036448,0,301656123,0,275725170,0,723660845,0,97140868,0,687293653,0,756858419,0,740061355,0,477765430,0,978160109,0,170517295,0,603571894,0,856182503,0,315060077,0,604702699,0,188059190,0,746154800,0,590957649,0,598277218,0,632775339,0,664543162,0,2176347,0,672563104,0,128051225,0,589594871,0,122041955,0,448233270,0,648217760,0,348479553,0,3463898,0,601897670,0,948217634,0,981358001,0,667164726,0,394191524,0,925543283,0,325843658,0,541338833,0,746489435,0,91488040,0,715678547,0,750655274,0,814132750,0,116397711,0,914346845,0,556250432,0,324132590,0,690119570,0,828813439,0,239695356,0,365272463,0,666187216,0,195595943,0,421967346,0,775431091,0,962497750,0,26142436,0,83393779,0,705969466,0,91227746,0,753015148,0,413503277,0,931653254,0,580717169,0,154398267,0,837431357,0,350394676,0,451728855,0,255961371,0,646092315,0,193948002,0,229698568,0,24114743,0,600293174,0,92511515,0,119801205,0,836131171,0,11051624,0,402298382,0,379031843,0,726940835,0,701472598,0,810405972,0,232826697,0,66223100,0,314900196,0,714385546,0,432605375,0,653849391,0,215662321,0,305796813,0,198384728,0,360640745,0,597797231,0,962965419,0,233437891,0,390675234,0,358927306,0,440784360,0,416144987,0,736130703,0,923999423,0,421227050,0,937497055,0,904911796,0,177537196,0,832966398,0,955747054,0,769028146,0,217829919,0,121312046,0,642425322,0,16482376,0,595844855,0,577119793,0,317026562,0,954366898,0,828469135,0,962293354,0,385244332,0,665114228,0,410022759,0,112347819,0,168547779,0,152521210,0,52115211,0,578426471,0,541479976,0,259759934,0,328695806,0,816904224,0,959827211,0,507215664,0,910936985,0,547178368,0,134666216,0,270841805,0,188889050,0,204016097,0,373911022,0,516605109,0,809450330,0,867867022,0,412200713,0,123461364,0,54686621,0,335364566,0,565701631,0,761346648,0,375958382,0,291271867,0,169228778,0,929819070,0,344008620,0,397270941,0,341713260,0,557438041,0,975894363,0,220974084,0,304187612,0,82742958,0,747790793,0,622077487,0,170945937,0,907505719,0,908097107,0,327932984,0,351751775,0,134879555,0,330690210,0,395457038,0,466835879,0,914274480,0,739247533,0,91394730,0,109420689,0,785342130,0,511158008,0,964424181,0,792887384,0,422772213,0,513370334,0,606290202,0,267324432,0,619123502,0,268619297,0,455319584,0,949580630,0,294472744,0,251873935,0,194966337,0,977958395,0,453441611,0,202648831,0,469022610,0,921283067,0,592849363,0,825258420,0,146297264,0,729026590,0,717160336,0,365993381,0,92261170,0,219584935,0,315450728,0,403464842,0,960156873,0,69810174,0,435551605,0,1412253,0,941905734,0,698038089,0,717005321,0,77477037,0,270474705,0,601555224,0,635487116,0,841345296,0,322347063,0,67096504,0,839915524,0,406371237,0,528931370,0,18278769,0,247546212,0,875698645,0,23327113,0,35115245,0,80637764,0,973745532,0,515280823,0,341936397,0,67429829,0,765714429,0,574598713,0,840447354,0,206666322,0,674749538,0,842767205,0,16011385,0,881411065,0,79476894} ; _NEWLINE  _INDENT _NEWLINE int nCr[maxn][maxn]; _NEWLINE bool isPrime[maxm]; _NEWLINE int inv[maxn]; _NEWLINE vector<long long> prime; _NEWLINE vector<long long> Ft; _NEWLINE long long pws[maxn]; _NEWLINE long long n, k; _NEWLINE  _INDENT _NEWLINE void comb() { _NEWLINE 	inv[0] = 1 ; _NEWLINE  _INDENT  _INDENT inv[1] = 1 ; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=300;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inv[i] = 1LL * (MOD - MOD/i) * (inv[MOD%i]) % MOD ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<=300;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nCr[i][0] = 1 ; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=1;i<=300;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=i;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nCr[i][j] = nCr[i-1][j-1] + nCr[i-1][j] ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(nCr[i][j] >= MOD) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nCr[i][j] = nCr[i][j]%MOD ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE void seive() { _NEWLINE 	for(int i=2;i<maxm; i++) { _NEWLINE 		if(!isPrime[i]) { _NEWLINE 			prime.push_back(i); _NEWLINE 			for(int j=2*i ;j<maxm; j+=i) { _NEWLINE 				isPrime[j] = true; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE void factorize() { _NEWLINE 	long long temp = n; _NEWLINE 	int i=0; _NEWLINE 	Ft.clear(); _NEWLINE 	while(1LL * prime[i] * prime[i] <= temp) { _NEWLINE 		if(temp % prime[i] == 0) { _NEWLINE 			Ft.push_back(prime[i]); _NEWLINE 			while(temp%prime[i] == 0 ) { _NEWLINE 				temp = temp / prime[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		i++; _NEWLINE 	} _NEWLINE 	if(temp > 1) { _NEWLINE 		Ft.push_back(temp); _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE long long powermod(long long a, long long p) { _NEWLINE 	long long temp = 1; _NEWLINE 	while(p) { _NEWLINE 		if(p & 1) { _NEWLINE 			temp = temp * a; _NEWLINE 		} _NEWLINE 		if(temp >= MOD) { _NEWLINE 			temp = temp _INDENT % MOD; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		a = a * a; _NEWLINE 		if(a>=MOD) { _NEWLINE 			a = a%MOD; _NEWLINE 		} _NEWLINE 		p = p/2; _NEWLINE 	} _NEWLINE 	return _INDENT temp; _NEWLINE } _NEWLINE void task1() { _NEWLINE 	long long res = 0; _NEWLINE 	for(long long i=1;i<=n; i++) { _NEWLINE 		if(__gcd(i, n) == 1) { _NEWLINE 			res = res + powermod(i, k); _NEWLINE 		} _NEWLINE 		if(res >= MOD) { _NEWLINE 			res = res % MOD; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	printf("%lld\n",res); _NEWLINE } _NEWLINE long long fun(long long n, long long k) { _NEWLINE 	long long s = 0 ; _NEWLINE  _INDENT  _INDENT long long temp = n ; temp %= MOD ; _NEWLINE  _INDENT  _INDENT for(int i=0;i<=k;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = (1LL * s * temp % MOD ) + (1LL * nCr[k+1][i] * B[i]) % MOD ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s >= MOD) s = s % MOD ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT s = 1LL * s * temp % MOD ; _NEWLINE  _INDENT  _INDENT s = 1LL * s * inv[k+1] % MOD ; _NEWLINE  _INDENT  _INDENT return s ; _NEWLINE } _NEWLINE void solve() { _NEWLINE 	if(k > 256) { _NEWLINE 		task1(); _NEWLINE 	} else { _NEWLINE 		factorize(); _NEWLINE 		 _NEWLINE 		int fSize = Ft.size(); _NEWLINE 		//cout<<fSize<<"\n"; _NEWLINE 		long long res = 0; _NEWLINE 		for(int mask = 0; mask < (1<<fSize); mask++) { _NEWLINE 			int cnt = 0; _NEWLINE 			long long num = 1; _NEWLINE 			for(int j=0; j<fSize; j++) { _NEWLINE 				if((1<<j)&mask) { _NEWLINE 					cnt++; _NEWLINE 					num *= Ft[j]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			if(cnt&1) { _NEWLINE 				res = res - (1LL*fun(n/num, k) * (powermod(num%MOD, k))%MOD); _NEWLINE 				if(res < 0) { _NEWLINE 					res = res + MOD; _NEWLINE 				} _NEWLINE 			} else { _NEWLINE 				res = res + (1LL*fun(n/num, k) * (powermod(num%MOD, k))%MOD); _NEWLINE 				if(res >= MOD) { _NEWLINE 					res = res - MOD; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%lld\n",res); _NEWLINE 	} _NEWLINE } _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	int t; _NEWLINE 	comb(); _NEWLINE 	seive(); _NEWLINE 	 _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%lld %lld",&n, &k); _NEWLINE 		solve(); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
import sys _NEWLINE import math _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE #n=(10**100)-222 _NEWLINE  _NEWLINE a={} _NEWLINE a[n]=1 _NEWLINE v=1 _NEWLINE while v<=n: _NEWLINE  _INDENT a[v]=[v/2,v/2] _NEWLINE  _INDENT v*=2 _NEWLINE def close(x): _NEWLINE  _INDENT ret=1 _NEWLINE  _INDENT while ret*2<=x: _NEWLINE  _INDENT  _INDENT ret*=2 _NEWLINE  _INDENT return ret _NEWLINE def see(x): _NEWLINE  _INDENT if x==0 or x==1: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT if x%2: _NEWLINE  _INDENT  _INDENT a[x]=[1,x-1] _NEWLINE  _INDENT  _INDENT if not a.has_key(x-1): _NEWLINE  _INDENT  _INDENT  _INDENT a[x-1]=1 _NEWLINE  _INDENT  _INDENT  _INDENT see(x-1) _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT v=x-close(x) _NEWLINE  _INDENT if v==0: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT a[x]=[v,x-v] _NEWLINE  _INDENT if not a.has_key(v): _NEWLINE  _INDENT  _INDENT a[v]=1 _NEWLINE  _INDENT  _INDENT see(v) _NEWLINE see(n) _NEWLINE ta=a _NEWLINE if len(a)<len(ta): _NEWLINE  _INDENT ta=a _NEWLINE ########################################################### _NEWLINE primes=[3,5,7,11,13,17,19]#,23,29,31,37,41] _NEWLINE a={} _NEWLINE a[1]=1 _NEWLINE a[n]=1 _NEWLINE def get2(x): _NEWLINE  _INDENT if x==1: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT a[x]=[x/2,x/2] _NEWLINE  _INDENT  _INDENT if not a.has_key(x/2): _NEWLINE  _INDENT  _INDENT  _INDENT a[x/2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x/2) _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT if x%p==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v=x/p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=[v,x-v] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(x-v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[x-v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(x-v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT a[x]=[1,x-1] _NEWLINE  _INDENT  _INDENT if not a.has_key(x-1): _NEWLINE  _INDENT  _INDENT  _INDENT a[x-1]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x-1) _NEWLINE get2(n) _NEWLINE #print 'here2',len(a) _NEWLINE if len(a)<len(ta): _NEWLINE  _INDENT ta=a _NEWLINE  _NEWLINE ########################################################### _NEWLINE def get3(x): _NEWLINE  _INDENT if x==1: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT c=a.keys() _NEWLINE  _INDENT c.sort() _NEWLINE  _INDENT atx=0 _NEWLINE  _INDENT aty=len(c)-1 _NEWLINE  _INDENT while atx<=aty: _NEWLINE  _INDENT  _INDENT if c[atx]+c[aty]==x: _NEWLINE  _INDENT  _INDENT  _INDENT a[x]=[c[atx],c[aty]] _NEWLINE  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT elif c[atx]+c[aty]>x: _NEWLINE  _INDENT  _INDENT  _INDENT aty-=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT atx+=1 _NEWLINE  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT a[x]=[x/2,x/2] _NEWLINE  _INDENT  _INDENT if not a.has_key(x/2): _NEWLINE  _INDENT  _INDENT  _INDENT a[x/2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x/2) _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT if x%p==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v=x/p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=[v,x-v] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(x-v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[x-v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(x-v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT a[x]=[1,x-1] _NEWLINE  _INDENT  _INDENT if not a.has_key(x-1): _NEWLINE  _INDENT  _INDENT  _INDENT a[x-1]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x-1) _NEWLINE for at in range(2,9): _NEWLINE  _INDENT a={} _NEWLINE  _INDENT a[1]=1 _NEWLINE  _INDENT visit=[] _NEWLINE  _INDENT for i in range(2,2**at): _NEWLINE  _INDENT  _INDENT visit.append(0) _NEWLINE  _INDENT  _INDENT #a[i]=[1,i-1] _NEWLINE  _NEWLINE  _INDENT mod=int(2**at) _NEWLINE  _INDENT #print at,mod _NEWLINE  _INDENT def get(x): _NEWLINE  _INDENT  _INDENT if a.has_key(x): _NEWLINE  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if x<mod: _NEWLINE  _INDENT  _INDENT  _INDENT visit[x-2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT while(x%2)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=x/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=[y,y] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=y _NEWLINE  _INDENT  _INDENT  _INDENT get(y) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT y=x%mod _NEWLINE  _INDENT  _INDENT  _INDENT visit[y-2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT a[x]=[y,x-y] _NEWLINE  _INDENT  _INDENT  _INDENT get(x-y) _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT get(n) _NEWLINE  _INDENT last=1 _NEWLINE  _INDENT for i in range(2,2**at): _NEWLINE  _INDENT  _INDENT if visit[i-2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT get3(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT #print len(a),len(ta) _NEWLINE  _INDENT if len(a)<len(ta): _NEWLINE  _INDENT  _INDENT ta=a _NEWLINE  _NEWLINE b=ta.keys() _NEWLINE b.sort() _NEWLINE l=len(b) _NEWLINE #print b _NEWLINE  _NEWLINE def find(start, end, v): _NEWLINE  _INDENT if start==end: _NEWLINE  _INDENT  _INDENT return start _NEWLINE  _INDENT mid=(start+end)/2 _NEWLINE  _INDENT if v<=b[mid]: _NEWLINE  _INDENT  _INDENT return find(start,mid,v) _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT return find(mid+1,end,v) _NEWLINE  _NEWLINE print l-1 _NEWLINE for key in b: _NEWLINE  _INDENT if key!=1: _NEWLINE  _INDENT  _INDENT #print key _NEWLINE  _INDENT  _INDENT x=ta[key] _NEWLINE  _INDENT  _INDENT (x,y)= (find(0,l-1,x[0]), find(0,l-1,x[1])) _NEWLINE  _INDENT  _INDENT print x,y _NEWLINE 
print"0"
#!/usr/bin/env python _NEWLINE  _NEWLINE def process(N, M, mines): _NEWLINE  _INDENT  _INDENT G = [0] * (2 ** N) _NEWLINE  _INDENT  _INDENT for x, y in mines: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G[x] |= 1 _NEWLINE  _INDENT  _INDENT print G.count(0) _NEWLINE  _INDENT  _INDENT for x in xrange(2 ** N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT not G[x]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print x, 0 _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT N = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT M = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT mines = [] _NEWLINE  _INDENT  _INDENT for m in xrange(M): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mines.append(map(int, raw_input().strip().split()[:2])) _NEWLINE  _INDENT  _INDENT process(N, M, mines) _NEWLINE  _NEWLINE main() _NEWLINE 
def payed(amount,mark,arr,n): _NEWLINE 	#print "fun" _NEWLINE 	#print "amount",amount _NEWLINE 	if(amount==0): _NEWLINE 	#	print "if-1" _NEWLINE 		return 1 _NEWLINE 	i=0;count=0 _NEWLINE 	while(i<n): _NEWLINE 		if(arr[i]<=amount and mark[i]!=1): _NEWLINE 	#		print "minus",arr[i],"from",amount _NEWLINE 			mark[i]=1 _NEWLINE 			if( payed(amount-arr[i],mark[:],arr,n ) ): _NEWLINE 	#			print "if-2" _NEWLINE 				return 1 _NEWLINE 		i+=1 _NEWLINE 	#print "ducki" _NEWLINE 	return 0 _NEWLINE  _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	i=0;arr=[0]*n;mark=[0]*n _NEWLINE 	while(i<n): _NEWLINE 		arr[i]=input() _NEWLINE 		i+=1 _NEWLINE 	if(payed(m,mark,arr,n)): _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No"
def check(): _NEWLINE 	a=[] _NEWLINE 	k=int(raw_input()) _NEWLINE 	a[0:]=map(int,raw_input().split()) _NEWLINE 	s=0.5 _NEWLINE 	for i in range(len(a)): _NEWLINE 		s=s*2-a[i] _NEWLINE 	if s == 0: _NEWLINE 		return 1 _NEWLINE 	else: _NEWLINE 		return 0 _NEWLINE  _NEWLINE def main(): _NEWLINE 	m=0	 _NEWLINE 	j=int(raw_input()) _NEWLINE 	while m<j: _NEWLINE 		if(check()): _NEWLINE 			print "Yes" _NEWLINE 		else: _NEWLINE 			print "No" _NEWLINE 	 	m=m+1 _NEWLINE 	return _INDENT _NEWLINE if __name__=="__main__": _NEWLINE 	main()
import sys _NEWLINE from collections import Counter _NEWLINE  _INDENT _NEWLINE t = sys.stdin.readline() _NEWLINE m = 1 _NEWLINE M = 1000000000 _NEWLINE for _ in range(int(t)): _NEWLINE 	k = sys.stdin.readline() _NEWLINE 	k = int(k) _NEWLINE 	assert(1 <= k <= 100000) _NEWLINE 	c = Counter() _NEWLINE 	for _ in range(k): _NEWLINE 		line = sys.stdin.readline() _NEWLINE 		o, l, v = line.strip().split() _NEWLINE 		l = int(l) _NEWLINE 		assert(m <= l <= M) _NEWLINE 		v = v.upper() _NEWLINE 		if o == '<' and v == 'YES': #less _NEWLINE 			c[l] += 1				 _NEWLINE 		elif o == '<' and v == 'NO': #great or equal _INDENT _NEWLINE 			c[m] += 1				 _INDENT _NEWLINE 			c[l] -= 1 _NEWLINE 		elif o == '>' and v == 'YES':	#great _NEWLINE 			c[m] += 1 _NEWLINE 			c[l+1] -= 1 _NEWLINE 		elif o == '>' and v == 'NO':	#less or equal _NEWLINE 			c[l+1] += 1 _NEWLINE 		elif o == '=' and v == 'YES': _NEWLINE 			c[m] += 1 _NEWLINE 			c[l] -= 1 _NEWLINE 			c[l+1] += 1 _NEWLINE 		elif o == '=' and v == 'NO': _NEWLINE 			c[l] += 1 _NEWLINE 			c[l+1] -= 1 _NEWLINE  _INDENT _NEWLINE 	count = 0 _NEWLINE 	mcount = k _NEWLINE 	for key in sorted(c): _NEWLINE 		count += c[key] _NEWLINE 		if key <= M: _NEWLINE 			mcount = min(mcount, count) _NEWLINE 	print(mcount)
s2 = ['AA', 'BB'] _NEWLINE s2a = ['A', 'B'] _NEWLINE s3 = ['ABA', 'BAB', 'AAB', 'BBA', 'BAA', 'ABB'] _NEWLINE s3a = ['A', 'B', 'A', 'B', 'A', 'B'] _NEWLINE t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT s = raw_input().upper() _NEWLINE  _INDENT  _INDENT if len(s) == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s in s2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s2a[s2.index(s)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT elif len(s) == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s in s3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s3a[s3.index(s)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[0] == 'A': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = 'B' + s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = 'A' + s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[len(s) - 1] == 'A': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = s + 'B' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = s + 'A' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = len(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if 'ABBA' in s or 'BAAB' in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = s.find('ABBA') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if index < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = s.find('BAAB') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if index == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s[1] + s[3 : n - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif index == n - 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s[1 : n - 2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s[1 : index + 2] + s[index + 3: n - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 
#include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<limits> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) ((x)<0?-(x):(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n")//print new line _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++)//repeat n times _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++)//end not included _NEWLINE #define FORR(i,n) for(int i=(n);i>=0;i--)//reverse for _NEWLINE #define DB(x) cout<<"\n"<<#x<<" = "<<(x)<<"\n";//debugging _NEWLINE #define CL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE void swaps (char *x,char *y){char temp;temp=*x;*x=*y;*y=temp;} _NEWLINE void swapi(int *a,int *b){int temp;temp=*a;*a=*b;*b=temp;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE  _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	string n=""; _NEWLINE 	int f=2; _NEWLINE 	while(1){ _NEWLINE 		string s; _NEWLINE 		cin>>s; _NEWLINE 		if(s[0]=='#'){ _NEWLINE 			LL ans=0; _NEWLINE 			reverse(n.begin(),n.end()); _NEWLINE 			for(int i=0;i<n.size();i++) _NEWLINE 				ans += (n[i]-'0')<<i; _NEWLINE 			cout<<ans<<endl; _NEWLINE 			n=""; _NEWLINE 			f=2; _NEWLINE 		}else if(s[0]=='~'){ _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		int l=s.size(); _NEWLINE 		if(l==1)f=1; _NEWLINE 		else if(l==2)f=0; _NEWLINE 		for(int i=0;i<l-2;i++)n+='0'+f; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
n,m = map(int,raw_input().split()) _NEWLINE arr = raw_input() _NEWLINE my = [0]*10 _NEWLINE  _NEWLINE ans = [ 0 for i in xrange(n)] _NEWLINE  _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT x = ord(arr[i])-48 _NEWLINE  _INDENT  _INDENT y = 0 _NEWLINE  _INDENT  _INDENT for j in xrange(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans[i] +=abs(x-j)*my[j] _NEWLINE  _INDENT  _INDENT my[x] +=1 _NEWLINE  _NEWLINE for i in xrange(m): _NEWLINE  _INDENT  _INDENT x = input()-1 _NEWLINE  _INDENT  _INDENT print ans[x] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE 
fib=[1,1,2,3,5] _NEWLINE i=4 _NEWLINE while fib[i] < 10e18: _NEWLINE 	i+=1 _NEWLINE 	fib+=[fib[i-1]+fib[i-2]] _NEWLINE t=int(input()) _NEWLINE while t: _NEWLINE 	n=int(input()) _NEWLINE 	i=0 _NEWLINE 	while fib[i]<=n: _NEWLINE 		i+=1 _NEWLINE 	print i-1 _NEWLINE 	t-=1
import sys _NEWLINE import math _INDENT _NEWLINE  _INDENT _NEWLINE  _NEWLINE check={} _NEWLINE  _INDENT _NEWLINE def primes(n): _NEWLINE  _INDENT  _INDENT # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188 _NEWLINE  _INDENT  _INDENT """ Input n>=6, Returns a list of primes, 2 <= p < n """ _NEWLINE  _INDENT  _INDENT correction = (n%6>1) _NEWLINE  _INDENT  _INDENT n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6] _NEWLINE  _INDENT  _INDENT sieve = [True] * (n/3) _NEWLINE  _INDENT  _INDENT sieve[0] = False _NEWLINE  _INDENT  _INDENT for i in xrange(int(n**0.5)/3+1): _NEWLINE  _INDENT  _INDENT  _INDENT if sieve[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=3*i+1|1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sieve[ _INDENT  _INDENT  _INDENT ((k*k)/3) _INDENT  _INDENT  _INDENT ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sieve[(k*k+4*k-2*k*(i&1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&1))/6-1)/k+1) _NEWLINE  _INDENT  _INDENT return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]] _NEWLINE  _INDENT _NEWLINE upto=5000000+1 _NEWLINE for i in primes(upto): _NEWLINE  _INDENT  _INDENT if i%4==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i,upto,i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT check[j]=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if check.has_key(num): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE main() _NEWLINE 
import sys _NEWLINE import math _NEWLINE  _NEWLINE M = 1000000007 _NEWLINE  _NEWLINE rs = {} _NEWLINE  _NEWLINE def fn(An, En, V, l=0): _NEWLINE  _INDENT  _INDENT global rs, M _NEWLINE  _INDENT  _INDENT if V < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if rs.has_key(An): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if rs[An].has_key(En): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if rs[An][En].has_key(V): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return rs[An][En][V] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En] = {} _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An] = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En] = {} _NEWLINE  _NEWLINE  _INDENT  _INDENT rs[An][En][V] = None _NEWLINE  _INDENT  _INDENT if V < An: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT if An == 0 and En == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if V == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if An == 1 and En == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if V == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if An == 0 and En == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if rs[An][En][V] == None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vRemain = V - An _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = (An + En) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for an1 in range(max(0, s - En), min(An, s)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT an2 = An - an1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT en1 = s - an1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT en2 = En - en1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt1 = cnt2 = 0L _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt1 = fn(an1, en1, vRemain, l+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt2 = fn(an2, en2, vRemain, l+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += cnt1 * cnt2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = cnt % M _NEWLINE  _INDENT  _INDENT return rs[An][En][V] _NEWLINE  _INDENT  _INDENT  _NEWLINE def main(): _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT testCases = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT cases = [] _NEWLINE  _INDENT  _INDENT for n in range(0, testCases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT An, En, V = sys.stdin.readline().split(' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%s" % ((fn(int(An), int(En), int(V)) - fn(int(An), int(En), int(V)-1) + M ) % M) _NEWLINE  _INDENT _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
import string,sys _NEWLINE s = sys.stdin.readline() _NEWLINE maxi = 0 _NEWLINE l = 0 _NEWLINE a = 0 _NEWLINE j = 0 _NEWLINE for i in string.uppercase: _NEWLINE  _INDENT  _INDENT if i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE if l: _NEWLINE  _INDENT  _INDENT l = 0 _NEWLINE  _INDENT  _INDENT length = len(s) _NEWLINE  _INDENT  _INDENT for i in xrange(length): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[i] in string.uppercase: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nm = int(s[a:j]+"9"+s[j+1:i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if maxi < nm: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi = nm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = j + 1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == length - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nm = int(s[a:j]+"9"+s[j+1:i + 1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if maxi < nm: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi = nm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = j + 1 _INDENT _NEWLINE else: _NEWLINE  _INDENT  _INDENT maxi = int(s) _NEWLINE print maxi
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT b=[0]*n _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT b=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT while i<(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b[i]==b[i+1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT n=n-l _NEWLINE  _INDENT  _INDENT m=((n-l)*(n-l-1))/2 _NEWLINE  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE 
#! /usr/bin/env python _NEWLINE # -*- coding: utf-8 -*- _NEWLINE  _NEWLINE lst = [0, 1] _NEWLINE for i in range(2, 5020): _NEWLINE  _INDENT  _INDENT lst.append(lst[i-2]+lst[i-1]) _NEWLINE  _NEWLINE def evaluate(fromd, to): _NEWLINE  _INDENT  _INDENT if length <= 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fromd = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT to _INDENT  _INDENT = 20 _NEWLINE  _INDENT  _INDENT for i in range(fromd, to): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if int(fib_int) == lst[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT print "NO" _NEWLINE  _NEWLINE num = input() _NEWLINE while num: _NEWLINE  _INDENT  _INDENT fib_int = raw_input() _NEWLINE  _INDENT  _INDENT length _INDENT = len(fib_int) _NEWLINE  _INDENT  _INDENT fromd _INDENT  = int(length*4.784688995215311)-10 _NEWLINE  _INDENT  _INDENT to _INDENT  _INDENT  _INDENT = int(length*4.784688995215311)+10 _NEWLINE  _INDENT  _INDENT evaluate(fromd, to) _NEWLINE  _INDENT  _INDENT num _INDENT  _INDENT  = num-1 _NEWLINE 
def ans(l,k): _NEWLINE 	n = len(l) _NEWLINE 	if (n%(k+1) == 0): _NEWLINE 		k = n/(k+1) _NEWLINE 	else: _NEWLINE 		k = (n/(k+1)) + 1 _NEWLINE 	return (l[k-1]) _NEWLINE  _NEWLINE n = int(input()) _NEWLINE l = list(map(int,raw_input().split())) _NEWLINE l.sort() _NEWLINE i = 0 _NEWLINE s = 0 _NEWLINE while (i < len(l)): _NEWLINE 	s += l[i] _NEWLINE 	l[i] = s _NEWLINE 	i += 1 _NEWLINE q = int(input()) _NEWLINE while (q != 0): _NEWLINE 	k = int(input()) _NEWLINE 	q -= 1 _NEWLINE 	print(ans(l,k)) _NEWLINE 
t=int(raw_input()) _NEWLINE def gcd(a,b): _NEWLINE 	if a==0: _NEWLINE 		return b _NEWLINE 	return gcd(b%a,a) _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	b=gcd(a[0],a[1]) _NEWLINE 	if n>2: _NEWLINE 		for i in range(2,n): _NEWLINE 		 _INDENT  _INDENT b=gcd(b,a[i]) _NEWLINE 	print b	
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,m = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mx = max(l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn = min(l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out = [max(abs(mx-i), abs(i-mn)) for i in range(n)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print " ".join(map(str,out))
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT i=sum=0 _NEWLINE  _INDENT  _INDENT p = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT p.sort() _NEWLINE  _INDENT  _INDENT p.reverse() _NEWLINE  _INDENT  _INDENT j=int(b/4) _NEWLINE  _INDENT  _INDENT l=b%4 _NEWLINE  _INDENT  _INDENT while i<j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=p[4*i]+p[(4*i)+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if b==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print p _NEWLINE  _INDENT  _INDENT elif l==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print sum _NEWLINE  _INDENT  _INDENT elif l==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (sum+p[4*j]) _NEWLINE  _INDENT  _INDENT elif l==3 or l==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (sum+p[4*j]+p[(4*j)+1]) _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	n = int(raw_input()) _NEWLINE 	if 360 % n == 0: _NEWLINE 		print 'y', _NEWLINE 	else: _NEWLINE 		print 'n', _NEWLINE 	if n <= 360: _NEWLINE 		print 'y', _NEWLINE 	else: _NEWLINE 		print 'n' _NEWLINE 	if (n*(n+1)/2) <= 360: _NEWLINE 		print 'y', _NEWLINE 	else: _NEWLINE 		print 'n'
import math _NEWLINE output = list() _NEWLINE prime = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	nums = list() _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	a = float(nums[0]) _NEWLINE 	b = float(nums[1]) _NEWLINE 	output.append(a+b-1) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print (n+1)**2-(n*(n+1))/2-1
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	N= 103993;R=33102;index=0;s="3." _NEWLINE #	print "r" _NEWLINE 	r=N%R _NEWLINE #	print r _NEWLINE 	while(index<n): _NEWLINE 	#	print "while" _NEWLINE 	#	print "index" _NEWLINE 		index+=1 _NEWLINE 	#	print index _NEWLINE 		r=r*10 _NEWLINE 		while(r<R and index<n): _NEWLINE 		#	print "while-while" _NEWLINE 			r=r*10 _NEWLINE 			s=s+str(0) _NEWLINE 			index+=1 _NEWLINE #		p#rint "r" _NEWLINE 		#print r _NEWLINE 		s=s+str(r/R) _NEWLINE 		r=r%R _NEWLINE #		print "s" _NEWLINE #		print s _NEWLINE #		print "r" _NEWLINE #		print r _NEWLINE 	if(n==0):print 3 _NEWLINE 	else: print s _NEWLINE 
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT x.sort() _NEWLINE  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT mini=20000000000 _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if abs(x[j]+x[k]-y)<mini: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mini=abs(x[j]+x[k]-y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif abs(x[j]+x[k]-y)==mini: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT print mini,counter 
def binInt(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = bin(n)[2:].zfill(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = b[::-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return [int(b,2),int(r,2)] _NEWLINE  _NEWLINE  _NEWLINE for _ in range(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k,s = raw_input().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sl = [i for i in s] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = [0] * (2**k) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2**k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b,r = binInt(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l[b] == 0 or l[r] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sl[b],sl[r] = sl[r],sl[b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[b] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[r] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "".join(sl)
''' _NEWLINE Yet Another Nice Girl _NEWLINE  _NEWLINE Problem code: ARRGAME2 _NEWLINE  _NEWLINE Problem Statement _NEWLINE  _NEWLINE Little Chef doesn't love math anymore. He loves Aleksandra. _NEWLINE  _NEWLINE Sashen'ka is nice. They spend all the time together. Even their _NEWLINE birthdays they are celebrating together, because they were born on the _NEWLINE same day :) _NEWLINE  _NEWLINE And now, this day is coming... _NEWLINE  _NEWLINE Chef know that most of all Sasha loves numbers, that's why he bought N _NEWLINE positive numbers to a girl. _NEWLINE  _NEWLINE From her side, Sasha as all girls, thought that if she likes _NEWLINE something, then all people like that too. And bought to a boy N _NEWLINE numbers too. xD _NEWLINE  _NEWLINE After all greeting young people decide to play a game with their gifts. _NEWLINE The game will be continued for N turns, in each turn the following will _NEWLINE  be done: _NEWLINE  _NEWLINE Chef randomly choose some number x from his gift. _NEWLINE  _NEWLINE Sasha randomly choose some number y form her gift. _NEWLINE  _NEWLINE If x^y > y^x then girl will kiss fellow. _NEWLINE  _NEWLINE Numbers x,y will be discarded from gifts. _NEWLINE  _NEWLINE Now chef is wondering what is the expected number of times he will be _NEWLINE kissed by Sasha ? _NEWLINE  _NEWLINE Input _NEWLINE  _NEWLINE The first line of the input contains an integer T denoting the number _NEWLINE of test cases. The description of T test cases follows. _NEWLINE  _NEWLINE The first line of each test case contains a single integer N denoting _NEWLINE the number of numbers in each gift. The second line contains N _NEWLINE space-separated integers A1, A2, ..., AN denoting the numbers Sasha _NEWLINE gave to Chef. Next line describe B1, B2, ..., BN numbers boy gave to _NEWLINE girl in the same way. _NEWLINE  _NEWLINE Output _NEWLINE  _NEWLINE For each test case, output a single line containing answer for _NEWLINE corresponding test. Your answer will be considered as correct if it _NEWLINE will have absolute error not more then 10^-6. _NEWLINE  _NEWLINE Constraints _NEWLINE 1 <= T <= 5 _NEWLINE 1 <= N <= 10^5 _NEWLINE 1 <= Ai <= 10^9 _NEWLINE 1 <= Bi <= 10^9 _NEWLINE  _NEWLINE Example _NEWLINE  _NEWLINE Input _NEWLINE 3 _NEWLINE 1 _NEWLINE 3 _NEWLINE 4 _NEWLINE 2 _NEWLINE 2 3 _NEWLINE 1 4 _NEWLINE 2 _NEWLINE 2 4 _NEWLINE 2 2 _NEWLINE  _NEWLINE Output: _NEWLINE 1.000000 _NEWLINE 1.500000 _NEWLINE 0.000000 _NEWLINE  _NEWLINE Explanation _NEWLINE  _NEWLINE Example case 1. Game will have only 1 turn. Chef will choose 3, while _NEWLINE Sasha will choose 4. Since 3^4>4^3 girl will kiss boy. Hence answer is _NEWLINE 1. _NEWLINE  _NEWLINE Author: _INDENT  _INDENT  _INDENT  _INDENT  ballon_ziq _NEWLINE Tester: _INDENT  _INDENT  _INDENT  _INDENT  shangjingbo _NEWLINE Tags _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ballon_ziq _NEWLINE Date Added: _INDENT  _INDENT  2-08-2013 _NEWLINE Time Limit: _INDENT  _INDENT  2 sec _NEWLINE Source Limit: _INDENT  50000 Bytes _NEWLINE ''' _NEWLINE  _NEWLINE from math import log _NEWLINE from sys import stdin _NEWLINE  _NEWLINE #### codechef 2013-10 Yet Another Nice Girl _NEWLINE  _NEWLINE def search(x,B): _NEWLINE  _INDENT  _INDENT def is_yes(mid): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = B[mid] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # log(x^y) > log(y^x) whack a big number with log(). _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # a = y * log(x); b = x * log(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return x < y _NEWLINE  _INDENT  _INDENT n = len(B); lo = 0; hi = n-1 _NEWLINE  _INDENT  _INDENT while lo < hi: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = lo + (hi-lo)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if is_yes(mid): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hi = mid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lo = mid + 1 _NEWLINE  _INDENT  _INDENT if is_yes(lo) is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Reach to the end but still cannot find 'Yes'. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT return n-lo _NEWLINE  _NEWLINE def solve(A,B): _NEWLINE  _INDENT  _INDENT B = sorted(B); ans = 0; n = len(A) _NEWLINE  _INDENT  _INDENT ones = twos = 0 _NEWLINE  _INDENT  _INDENT for b in B: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ones += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT twos += 1 _NEWLINE  _INDENT  _INDENT # This can be modeled as throwing balls A to bins B? _NEWLINE  _INDENT  _INDENT for a in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = 4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt = search(a,B) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += twos _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += cnt + ones _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans = ans * 1.0/n _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE def check_test(A, B, data='', case=[0]): _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT print "test %d:" % case[0] _NEWLINE  _INDENT  _INDENT print A _NEWLINE  _INDENT  _INDENT if abs(A-B) > 1e-9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if data: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print data _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '>>>', A _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '<<<', B _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "!!!!!!!! FAIL !!!!!!!!" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ":::::::) OK" _NEWLINE  _INDENT  _INDENT case[0] += 1 _NEWLINE  _NEWLINE def unit_test(): _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT A,B, ans = (3,),(4,), 1.0 _NEWLINE  _INDENT  _INDENT check_test(solve(A,B), ans, (A,B)) _NEWLINE  _NEWLINE  _INDENT  _INDENT A,B, ans = (2,3),(1,4), 1.5 _NEWLINE  _INDENT  _INDENT check_test(solve(A,B), ans, (A,B)) _NEWLINE  _NEWLINE  _INDENT  _INDENT A,B, ans = (2,4),(2,2), 0 _NEWLINE  _INDENT  _INDENT check_test(solve(A,B), ans, (A,B)) _NEWLINE  _NEWLINE def output(): _NEWLINE  _INDENT  _INDENT for case in xrange(1, int(stdin.next()) + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(stdin.next()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = [int(i) for i in stdin.next().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B = [int(i) for i in stdin.next().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = solve(A,B) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.6f" % ans _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE # _INDENT  _INDENT unit_test() _NEWLINE  _INDENT  _INDENT output() _NEWLINE 
__author__ = 'robert' _NEWLINE from collections import defaultdict _NEWLINE import sys _NEWLINE  _NEWLINE def solve(cache, between, i, j): _NEWLINE  _INDENT  _INDENT if (i, j) in cache: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return cache[(i, j)] _NEWLINE  _INDENT  _INDENT if not between[(i, j)]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if len(between[(i, j)]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT grundy_numbers = set() _NEWLINE  _INDENT  _INDENT for word in between[(i, j)]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start, end = word _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT grundy_numbers.add( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT solve(cache, between, i, start) ^ solve(cache, between, end, j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ) _NEWLINE  _INDENT  _INDENT mex = 0 _NEWLINE  _INDENT  _INDENT while mex in grundy_numbers: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mex += 1 _NEWLINE  _INDENT  _INDENT cache[(i, j)] = mex _NEWLINE  _INDENT  _INDENT return mex _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE def run(): _NEWLINE  _INDENT  _INDENT input_ = (i.strip() for i in sys.stdin) _NEWLINE  _INDENT  _INDENT test_cases = int(next(input_)) _NEWLINE  _INDENT  _INDENT for case in range(test_cases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = next(input_) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(next(input_)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT words = [next(input_) for i in range(n)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT word_locations = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i + 1, len(s) + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i:j] in words: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT word_locations.append((i, j)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT between = defaultdict(list) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for word in word_locations: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start, end = word _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(start + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(end, len(s) + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT between[(i, j)].append(word) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cache = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Teddy" if solve(cache, between, 0, len(s)) else "Tracy" _NEWLINE  _NEWLINE run()
import heapq _NEWLINE  _INDENT  _INDENT  _NEWLINE def solve(s, k): _NEWLINE  _INDENT  _INDENT res = [] _NEWLINE  _INDENT  _INDENT start_index = -1 _NEWLINE  _INDENT  _INDENT end_index = len(s) - k _NEWLINE  _INDENT  _INDENT #choose the staring window _NEWLINE  _INDENT  _INDENT h = [(y, x) for x, y in enumerate(s[:end_index])] _NEWLINE  _INDENT  _INDENT heapq.heapify(h) _NEWLINE  _NEWLINE  _INDENT  _INDENT for _ in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # enlarge the window by increamenting one (character, pos_of_haracter) from right _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappush(h, (s[end_index], end_index)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end_index += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # get the min from s[start_index : end_index] by using heappop (O(logN)) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val, ind = heapq.heappop(h) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ind > start_index: break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # save the min, shorten the window _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(val) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start_index = ind _NEWLINE  _INDENT  _INDENT return ''.join(res) _NEWLINE  _NEWLINE def astring(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in range(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(s,k) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT astring()
# create atoms from the input _NEWLINE tc=int(raw_input()) _NEWLINE  _NEWLINE for i in range(tc): _NEWLINE 	n_m = (raw_input()) _NEWLINE 	n = int(n_m.split()[0]) _NEWLINE 	m = int(n_m.split()[1]) _NEWLINE 	#generate list of atoms _NEWLINE 	atoms=[] _NEWLINE 	for j in range(n): _NEWLINE 		atoms.append(j) _NEWLINE 	atomlist = ['']*n _NEWLINE  _NEWLINE 	for k in range(m): _NEWLINE 		s=[] _NEWLINE 		s.extend(raw_input().split()[1:])	 _NEWLINE 		for w in range(n): _NEWLINE 			if str(w) in s: _NEWLINE 				atomlist[w]+="1" _NEWLINE 			else: _NEWLINE 				atomlist[w]+="0" _NEWLINE  _NEWLINE 	print len(set(atomlist)) _NEWLINE  _NEWLINE  _NEWLINE 		 _NEWLINE 
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT i=l=c=0 _NEWLINE  _INDENT  _INDENT k=s.split("#") _NEWLINE  _INDENT  _INDENT b=len(k) _NEWLINE  _INDENT  _INDENT while i<b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=k[i].count(".") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j>l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE 
no_cases =int(raw_input()) _NEWLINE for i in range(no_cases): _NEWLINE  _INDENT  _INDENT m, p= raw_input().split(' ') _NEWLINE  _INDENT  _INDENT m= int(m) _NEWLINE  _INDENT  _INDENT p=float(p) _NEWLINE  _INDENT  _INDENT a= (10**9)*(1-(-p)**m)/(1+p) _NEWLINE  _INDENT  _INDENT b= (10**9)*(p+(-p)**m)/(1+p) _NEWLINE  _INDENT  _INDENT print a,b
import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT n_books = 0 _NEWLINE  _INDENT min_q = [] _NEWLINE  _NEWLINE  _INDENT for (a, s) in actions(): _NEWLINE  _INDENT  _INDENT if a == -1: _NEWLINE  _INDENT  _INDENT  _INDENT _, n, s = min_q.pop() _NEWLINE  _INDENT  _INDENT  _INDENT print (n_books-n), s _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT n_books = n-1 _NEWLINE  _INDENT  _INDENT elif a > 0: _NEWLINE  _INDENT  _INDENT  _INDENT n_books += 1 _NEWLINE  _INDENT  _INDENT  _INDENT if (not min_q) or (a <= min_q[-1][0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_q.append((a, n_books, s)) _NEWLINE  _NEWLINE def actions(cin = sys.stdin): _NEWLINE  _INDENT n = int(cin.next()) _NEWLINE  _INDENT for _ in xrange(n): _NEWLINE  _INDENT  _INDENT ss = cin.next() _NEWLINE  _INDENT  _INDENT if ss[0] == '-': _NEWLINE  _INDENT  _INDENT  _INDENT yield (-1, "") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT ss = ss.split() _NEWLINE  _INDENT  _INDENT  _INDENT yield (int(ss[0]), ss[1]) _NEWLINE  _NEWLINE if __name__ == "__main__": sys.exit(main()) _NEWLINE  _NEWLINE 
k=int(raw_input()) _NEWLINE def powerfn(n,power): _NEWLINE 	value=1 _NEWLINE 	while power>0 : _NEWLINE 		 _NEWLINE 		if not power%2==0: _NEWLINE 			value=value*n _NEWLINE 			value=value%1000000009 _NEWLINE 		n=n*n _NEWLINE 		n=n%1000000009 _NEWLINE 		power=power/2 _NEWLINE 	return value _NEWLINE def inversemod(n): _NEWLINE 	return powerfn(n,1000000007) _NEWLINE factorial=[1] _NEWLINE for i in range(1,1048577): _NEWLINE 	factor=(i*factorial[i-1])%1000000009 _NEWLINE 	factorial.append(factor) _NEWLINE def combination(n,r): _NEWLINE 	if n<r: _NEWLINE 		return 0 _NEWLINE 	else: _NEWLINE 		return (factorial[n]*((inversemod(factorial[r])*inversemod(factorial[n-r]))%1000000009))%1000000009 _NEWLINE n=powerfn(2,k) _NEWLINE strength=n/2 _NEWLINE for i in range(1,n+1): _NEWLINE 	print (((combination(i-1,strength-1)*((factorial[strength]*factorial[strength])%1000000009))%1000000009)*2)%1000000009
output = list() _NEWLINE prime = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	nums = list() _NEWLINE 	counter = 0 _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	a1 = int(nums[0]) _NEWLINE 	b1 = int(nums[1]) _NEWLINE 	if a1>b1 : _NEWLINE 		a = a1 _NEWLINE 		b = b1 _NEWLINE 	else : _NEWLINE 		a = b1 _NEWLINE 		b = a1	 _NEWLINE 	c = a _NEWLINE 	d = b _NEWLINE 	lev1 = 0 _NEWLINE 	lev2 = 0 _NEWLINE 	while c > 0: _NEWLINE 		c = c/2 _NEWLINE 		lev1 = lev1 + 1 _NEWLINE 	while d > 0: _NEWLINE 		d = d/2 _NEWLINE 		lev2 = lev2 + 1 _NEWLINE 	diff = lev1 - lev2 _NEWLINE 	while diff > 0 : _NEWLINE 		a = a/2 _NEWLINE 		diff = diff - 1 _NEWLINE 		counter = counter + 1 _NEWLINE 	while True : _NEWLINE 		if a == b : _NEWLINE 			break _NEWLINE 		a = a/2 _NEWLINE 		b = b/2 _NEWLINE 		counter = counter + 2 _NEWLINE 	output.append(counter) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
 _INDENT  _INDENT # cook your code here _NEWLINE import math _NEWLINE t = int(raw_input()) _NEWLINE while(t): _NEWLINE 	n,k = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mod1 _INDENT = 1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (pow(k-1,n-1,mod1)*k)%mod1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = t-1 _INDENT _NEWLINE 	
def foo(a,b): _NEWLINE  _INDENT  _INDENT x=a _NEWLINE  _INDENT  _INDENT y=b _NEWLINE  _INDENT  _INDENT while y!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=x%y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ( a/x, b/x ) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE em={0:(0,0),1:(1,1),2:(2,1)} _NEWLINE  _INDENT _NEWLINE piss=2 _NEWLINE tc=input() _NEWLINE for xyz in xrange(tc): _NEWLINE  _INDENT  _INDENT number=input() _NEWLINE  _INDENT  _INDENT mass=max(piss,number) _NEWLINE  _INDENT  _INDENT if(mass==piss): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c,d=em[number] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "%d/%d" %(c,d) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(piss,number): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m,n=em[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o,p=em[i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT em[i+1]=foo(n*p*((i+1)**2-3*i)+2*(i)*m*p-n*o,(2*i-1)*n*p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT piss=number _NEWLINE  _INDENT  _INDENT  _INDENT  # print em _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c,d=em[piss] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "%d/%d" %(c,d)
output = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	nums = list() _NEWLINE 	fault = 0 _NEWLINE 	indi = list() _NEWLINE 	val2 = raw_input() _NEWLINE 	players = int(val2) _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	for j in range(players) : _NEWLINE 		nums[j] = int(nums[j]) _NEWLINE 	if nums[0] != nums [1] : _NEWLINE 		fault+=1 _NEWLINE 	for j in range(1,(players-1)) : _NEWLINE 		if nums[j] != nums[j+1] or nums[j] != nums[j-1] : _NEWLINE 			fault += 1 _NEWLINE 	if nums[-1] != nums[-2] : _NEWLINE 		fault += 1 _NEWLINE 	output.append(fault) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <string.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long int t,n,x,i,ramt,sum; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT sum=0; _NEWLINE 	 _INDENT  _INDENT cin>>n>>x; _NEWLINE 	 _INDENT  _INDENT long int a[n]; _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT sum+=a[i]; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT ramt=sum%x; _NEWLINE 	 _INDENT  _INDENT sort(a,a+n); _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(a[i]<=ramt) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(i<n) _NEWLINE 	 _INDENT  _INDENT cout<<"-1\n"; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT cout<<sum/x<<endl; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <cstdio> _NEWLINE  _INDENT _NEWLINE #define MOD 1000000007 _NEWLINE  _INDENT _NEWLINE struct mat{ _NEWLINE 	int vals[3][3]; _NEWLINE 	mat(){ _NEWLINE 		for(int i=0; i<3; i++) _NEWLINE 		for(int j=0; j<3; j++) _NEWLINE 			vals[i][j]=i==j; _NEWLINE 	} _NEWLINE }; _NEWLINE  _INDENT _NEWLINE mat operator*(const mat &lhs, const mat &rhs){ _NEWLINE 	mat res; _NEWLINE 	for(int i=0; i<3; i++) _NEWLINE 	for(int j=0; j<3; j++){ _NEWLINE 		long long sum=0; _NEWLINE 		for(int k=0; k<3; k++) _NEWLINE 			sum+=(long long)lhs.vals[i][k]*rhs.vals[k][j]; _NEWLINE 		res.vals[i][j]=sum%MOD; _NEWLINE 	} _NEWLINE 	return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE mat pow(const mat &base, int exp){ _NEWLINE 	mat res; _NEWLINE 	mat sq(base); _NEWLINE 	for(; exp; exp>>=1){ _NEWLINE 		if(exp&1) _NEWLINE 			res=res*sq; _NEWLINE 		sq=sq*sq; _NEWLINE 	} _NEWLINE 	return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int m[3][3]={ _NEWLINE 	1, 4, 2, _NEWLINE 	1, 0, 0, _NEWLINE 	0, 1, 0, _NEWLINE }; _NEWLINE  _INDENT _NEWLINE int solve(int N){ _NEWLINE 	mat base; _NEWLINE 	for(int i=0; i<3; i++) _NEWLINE 	for(int j=0; j<3; j++) _NEWLINE 		base.vals[i][j]=m[i][j]; _NEWLINE 	return pow(base, N).vals[0][0]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	scanf("%d", &T); _NEWLINE 	while(T--){ _NEWLINE 		int N; _NEWLINE 		scanf("%d", &N); _NEWLINE 		printf("%d\n", solve(N)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
t = int(raw_input()) _NEWLINE for ii in range(t): _NEWLINE  _INDENT  _INDENT n , m = raw_input().split() _NEWLINE  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT m=int(m) _NEWLINE  _INDENT  _INDENT if n<m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,m = m,n _NEWLINE  _INDENT  _INDENT if n==1 or m==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n*(n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT print (n*m) * (n*m-1) - 4*( (n-1)*(m-2) + (n-2)*(m-1)) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
 _NEWLINE a=int(raw_input()) _NEWLINE ans=[] _NEWLINE for i in range(0,a): _NEWLINE  _INDENT  _INDENT q=0 _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT c=raw_input() _NEWLINE  _INDENT  _INDENT if b==2 and c[0]=='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c.find('0')>0 and c.find('1')>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c.find('1') < c.find('0') and c.find('1')%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif c.find('1') > c.find('0') and c.find('0')%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c.find('1') < 0 and c.find('0') > 0 and c.find('0')%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c.find('0') < 0 and c.find('1') > 0 and c.find('1')%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT if len(c)==1 and c[0]!='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans.append(c) _NEWLINE  _INDENT  _INDENT elif c[0]==c[-1] and c[0]!='?' and len(c)>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(0,len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]=='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(0,b+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j+1<len(c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(k)!=c[j-1] and str(k)!=c[j+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c[:j]+str(k)+c[j+1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(k)!=c[j-1] and str(k)!=c[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c[:j]+str(k)+c[j+1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k==b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j+1<len(c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]==c[j-1] or c[j]==c[j+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]==c[j-1] or c[j]==c[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if q==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append(c) _NEWLINE  _NEWLINE for i in ans: _NEWLINE  _INDENT  _INDENT print(i) _NEWLINE 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT r,c = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a = [list(raw_input()) for _ in range(r)] _NEWLINE  _INDENT  _INDENT tot = 0 _NEWLINE  _INDENT  _INDENT for i in range(r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i][j] != '^': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT L = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[k][j] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT L += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i+1,r,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[k][j] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT T = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(j-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i][k] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT T += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(j+1,c,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i][k] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fi = min(L,T,B,R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if fi >= 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tot += 1 _NEWLINE  _INDENT  _INDENT print(tot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	arr=map(int,raw_input().split()) _NEWLINE 	arr=sorted(arr) _NEWLINE 	index=0;time=1 _NEWLINE 	while(index<n-1): _NEWLINE 		if( arr[index]!=arr[index+1] ): _NEWLINE 			time+=1 _NEWLINE 		index+=1 _NEWLINE 	print time
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT L = [int(i) for i in raw_input().split()] _NEWLINE  _INDENT  _INDENT cars = 1 _NEWLINE  _INDENT  _INDENT for i in range(len(L)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if L[i] > L[i+1]: cars+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: L[i+1] = L[i] _NEWLINE  _INDENT  _INDENT print cars _NEWLINE 
T = int(raw_input()) _NEWLINE n = [] _NEWLINE a = [] _NEWLINE m = [] _NEWLINE  _NEWLINE for t in xrange(T): _NEWLINE 	n.append(int(raw_input())) _NEWLINE 	a.append(map(int, raw_input().split())) _NEWLINE 	m.append(max(a[-1])) _NEWLINE  _NEWLINE M = max(m) _NEWLINE l = [False, False] + [True] * (M-1) _NEWLINE  _NEWLINE for i in xrange(2,M+1): _NEWLINE 	if (l[i]): _NEWLINE 		for j in range(2*i, M+1, i): _NEWLINE 			l[j]=False _NEWLINE  _NEWLINE for t in xrange(T): _NEWLINE 	x = 0 _NEWLINE 	for i in xrange(1, n[t]): _NEWLINE 		if (a[t][i] < a[t][i-1]): _NEWLINE 			x += a[t][i-1] - a[t][i] _NEWLINE 			a[t][i] = a[t][i-1] _NEWLINE 	y = 0 _NEWLINE 	for j in a[t]: _NEWLINE 		y += ((2 - (j % 2)) % 2) _NEWLINE 	for i in range(3,m[t]+1): _NEWLINE 		temp = 0 _NEWLINE 		if (l[i]): _NEWLINE 			for j in a[t]: _NEWLINE 				temp += ((i - (j % i)) % i) _NEWLINE 				if (temp > y): _NEWLINE 					break _NEWLINE 			y = min(y,temp) _NEWLINE 			if (y == 0): _NEWLINE 				break _NEWLINE 	print x+y
string1 = raw_input() _NEWLINE t = int(string1) _NEWLINE for i in range(t) : _NEWLINE 	memory = list() _NEWLINE 	string3 = raw_input() _NEWLINE 	n = int(string3) _NEWLINE 	string2 = raw_input() _NEWLINE 	nums1 = string2.split() _NEWLINE 	for j in range(n): _NEWLINE 		memory.append(int(nums1[j])) _NEWLINE 	counter = memory[0] _NEWLINE 	for j in range(1,n) : _NEWLINE 		if memory[j]>memory[j-1] : _NEWLINE 			counter = counter + memory[j] - memory[j-1] _NEWLINE 	print counter _NEWLINE 
for n in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  i,j,m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  k = int(raw_input()) _NEWLINE  _INDENT  _INDENT  print min(k-1,i) + min(k-1,j) + min(k-1,m) + 1
# your code goes here _NEWLINE t=input() _NEWLINE for i in range(t): _NEWLINE 	b = raw_input().split() _NEWLINE 	if(b[0]==b[2] and b[2]==b[4] and b[4]==b[0]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[0]==b[2] and b[2]==b[5] and b[5]==b[0]): _NEWLINE 		print 'YES'	 _NEWLINE 	elif(b[0]==b[3] and b[3]==b[4] and b[4]==b[0]): _NEWLINE 		print 'YES'	 _NEWLINE 	elif(b[0]==b[3] and b[3]==b[5] and b[5]==b[0]): _NEWLINE 		print 'YES'	 _NEWLINE 	elif(b[1]==b[3] and b[3]==b[5] and b[5]==b[1]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[1]==b[3] and b[3]==b[4] and b[4]==b[1]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[1]==b[2] and b[2]==b[4] and b[4]==b[1]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[1]==b[2] and b[2]==b[5] and b[5]==b[1]): _NEWLINE 		print 'YES'	 _NEWLINE 	else: _NEWLINE 		print 'NO'
 _NEWLINE from math import* _NEWLINE # your code goes here _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a.sort(reverse=True) _NEWLINE 	i=0 _NEWLINE 	maxi=a[i] _NEWLINE 	while i<n: _NEWLINE 		i=i+2 _NEWLINE 		if(i<n): _NEWLINE 			maxi+=a[i] _NEWLINE 	print maxi	 _NEWLINE 	
 _NEWLINE n, m, p = map(int, raw_input().split()) _NEWLINE arr = [dict() for _ in xrange(n)] _NEWLINE for _ in xrange(p): _NEWLINE  _INDENT  _INDENT i,j = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT i -= 1 _NEWLINE  _INDENT  _INDENT j -= 1 _NEWLINE  _INDENT  _INDENT if j not in arr[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[i][j] = j+1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[i][j] += 1 _NEWLINE  _INDENT _NEWLINE def chefbm(arr,i): _NEWLINE  _INDENT  _INDENT for (e,_) in arr[i].iteritems(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e == m-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e+1 in arr[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = arr[i][e+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = e+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if arr[i][e] > c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE  _INDENT  _INDENT y = arr[i][m-1] if m-1 in arr[i] else m-1 _NEWLINE  _INDENT  _INDENT x = arr[i][0] if 0 in arr[i] else 0 _NEWLINE  _INDENT  _INDENT return y-x _NEWLINE  _INDENT _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT print chefbm(arr,i) 
for t in xrange(int(raw_input())): _NEWLINE 	x=0 _NEWLINE 	for c in xrange(int(raw_input())): _NEWLINE 		n,m=map(int,raw_input().split()) _NEWLINE 		g=(m+n-2)%3 _NEWLINE 		x=x^g _NEWLINE 	if x: _NEWLINE 		print "MasterChef" _NEWLINE 	else: _NEWLINE 		print _INDENT "Football"
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT y=list(raw_input()) _NEWLINE  _INDENT  _INDENT z=y _NEWLINE  _INDENT  _INDENT add=count=0 _NEWLINE  _INDENT  _INDENT if y[0]=='+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE  _INDENT  _INDENT z[0]='-' _NEWLINE  _INDENT  _INDENT y[0]='+' _NEWLINE  _INDENT  _INDENT for i in range(1,len(z)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if z[i]!='+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if z[i]!='-': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT for i in range(1,len(z)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y[i]!='-': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y[i]!='+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE  _INDENT  _INDENT print min(add,count)
for _ in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a.insert(0,-1) _NEWLINE  _INDENT  _INDENT b = [0]*(n+2) _NEWLINE  _INDENT  _INDENT b.insert(0,-1) _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b[a[i]]+=1 _NEWLINE  _INDENT  _INDENT m = b.index(max(b)) _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i] != m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=1 _NEWLINE  _INDENT  _INDENT print(ans)
#include <iostream> _NEWLINE #include <bits/stdc++.h> _NEWLINE typedef long long int ll; _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ll t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ll n,m; _NEWLINE 		cin>>n>>m; _NEWLINE 		ll sum =0; _NEWLINE 		for(ll i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			ll a; _NEWLINE 			cin>>a; _NEWLINE 			sum += a; _NEWLINE 		} _INDENT _NEWLINE 		if((sum+m)%n == 0) cout<<"Yes"<<endl; _NEWLINE 		else cout<<"No"<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 	
from math import sqrt _NEWLINE T = int(raw_input()) _NEWLINE def computesumoffactors(n): _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(n))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n % i: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n/i) != i: sum+=(n/i+i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: sum+=i _NEWLINE  _INDENT  _INDENT return sum _NEWLINE while T: _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT print computesumoffactors(N) _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE 
T = int(raw_input()) _NEWLINE  _NEWLINE for x in xrange(T): _NEWLINE 	path = raw_input() _NEWLINE  _NEWLINE 	node = 1 #the root node, which will later on represent the current node under consideration _NEWLINE 	i = 0 _NEWLINE 	for ch in path: _NEWLINE 		if ch == 'l': _NEWLINE 			if i%2 == 0: _NEWLINE 				node = node*2 _NEWLINE 			else: _NEWLINE 				node = node*2 - 1 _NEWLINE  _NEWLINE 		elif ch == 'r': _NEWLINE 			if (i%2 == 0): _NEWLINE 				node = node*2 + 2 _NEWLINE 			else: _NEWLINE 				node = node*2 + 1 _NEWLINE  _NEWLINE 		i += 1 _NEWLINE 		node = node % (1000000007) _NEWLINE  _NEWLINE 	print node % (1000000007)
'''input _NEWLINE 5 _NEWLINE 12 1 _NEWLINE 13 1 _NEWLINE 13 2 _NEWLINE 13 3 _NEWLINE 13 4 _NEWLINE ''' _NEWLINE  _INDENT _NEWLINE #~~~~~~~~~~~~~~~~~~~~dwij28 == Abhinav Jha~~~~~~~~~~~~~~~~~~ _NEWLINE  _INDENT _NEWLINE from sys import stdin, stdout _NEWLINE from math import sqrt, floor, ceil, log _NEWLINE from collections import defaultdict, Counter _NEWLINE  _INDENT _NEWLINE def read(): return stdin.readline().rstrip() _NEWLINE def write(x): stdout.write(str(x)) _NEWLINE def endl(): write("\n") _NEWLINE  _INDENT _NEWLINE chef, mod = [1, 2], 1000000007 _NEWLINE while chef[-1] <= 1e9: chef.append(chef[-1] + chef[-2]) _NEWLINE  _INDENT _NEWLINE def solve(x, k, n): _NEWLINE 	if k == 0: return int(x == 0) _NEWLINE 	ans = 0 _NEWLINE 	for i in xrange(n, -1, -1): _NEWLINE 		if (chef[i]*k < x): _NEWLINE 			return ans _NEWLINE 		if (chef[i] <= x): _NEWLINE 			ans = (ans + solve(x - chef[i], k-1, i)) % mod _NEWLINE 	return ans _NEWLINE  _INDENT _NEWLINE for Q in xrange(int(read())): _NEWLINE 	x, k = map(int, read().split()) _NEWLINE 	write(solve(x, k, 43)) _NEWLINE 	endl()
for _ in range(input()): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	if n%2==0 and m%2==0: print 'Yes' _NEWLINE 	elif (n%2==0 and m%2==1 and m!=1) or (m%2==0 and n%2==1 and n!=1): print 'Yes' _NEWLINE 	elif n%2==1 and m%2==1 and n!=1 and m!=1: print 'No' _NEWLINE 	elif (n==1 and m==2) or (m==1 and n==2): print 'Yes' _NEWLINE 	else: print 'No' _NEWLINE 
for i in range(input()): _NEWLINE  _INDENT  _INDENT x = input() _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a.sort() _NEWLINE  _INDENT  _INDENT if a[0]==1: print '-1' _NEWLINE  _INDENT  _INDENT else: print sum(a[1:])+2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
from math import * _NEWLINE t = long(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT a = raw_input().split(' ') _NEWLINE  _INDENT  _INDENT x = float(a[0]) _NEWLINE  _INDENT  _INDENT k = float(a[1]) _NEWLINE  _INDENT  _INDENT n = 2**(long(log(k,2))+1) _NEWLINE  _INDENT  _INDENT l = k - 2**long(log(k,2)) _NEWLINE  _INDENT  _INDENT print '%.16f' %float((x/n)+(l*(x/(2**(long(log(k,2)))))))
arr=map(int,raw_input().split()) _NEWLINE Mremain=arr[2]-arr[0] _NEWLINE Psocks=arr[1] _NEWLINE socks=0 _NEWLINE while(Mremain>=Psocks): _NEWLINE 	socks+=Mremain/Psocks _NEWLINE 	Mremain=Mremain%Psocks _NEWLINE if(socks%2==0): _NEWLINE 	print "Lucky Chef" _NEWLINE else: _NEWLINE 	print "Unlucky Chef"
def is_subseq(x, y): _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT for c in x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i < len(y) and y[i] != c: i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == len(y): return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE for cas in xrange(input()): _NEWLINE  _INDENT  _INDENT a = raw_input() _NEWLINE  _INDENT  _INDENT n = len(a) _NEWLINE  _INDENT  _INDENT print 'YES' if n > 1 and (is_subseq(a[:n/2], a[n/2:]) or is_subseq(a[(n+1)/2:], a[:(n+1)/2])) else 'NO' _NEWLINE 
n = input() _NEWLINE s = [] _NEWLINE dic = {} _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s.append(a) _NEWLINE  _INDENT  _INDENT foo = str(a[0])+','+str(a[1]) _NEWLINE  _INDENT  _INDENT dic[foo] = 1 _NEWLINE if n == 0: _NEWLINE  _INDENT  _INDENT print '4' _NEWLINE elif n == 1: _NEWLINE  _INDENT  _INDENT print '3' _NEWLINE elif n == 2: _NEWLINE  _INDENT  _INDENT print '2' _NEWLINE else: _NEWLINE  _INDENT  _INDENT ans = 2 _NEWLINE  _INDENT  _INDENT for i in range(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxm = 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x1,x2,y1,y2 = s[i][0],s[i][1],s[j][0],s[j][1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cx = x1 - y2+y1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cy = y1 + x1-x2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dx = x2 + y2-y1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dy = y2 + x1-x2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = str(cx)+','+str(cy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d = str(dx)+','+str(dy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxm += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if d in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxm += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = max(ans,maxm) _NEWLINE  _INDENT  _INDENT print 4-ans _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,k = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = map(int, raw_input().strip().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print max([b[i]*(k/a[i]) for i in range(n)])
import sys _NEWLINE def nCr (n,k) : _NEWLINE  _NEWLINE 	if k == 0 : _NEWLINE 		return 1 _NEWLINE 	else : _NEWLINE 		return ( n*(nCr(n-1,k-1))/k ) _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE while T : _NEWLINE 	 _NEWLINE 	T-=1 _NEWLINE 	 _NEWLINE 	n , k = map(int,sys.stdin.readline().split()) _NEWLINE 	if n < k : _NEWLINE 		print "0" _NEWLINE 	elif n == k : _NEWLINE 		print "1" _NEWLINE 	else : _NEWLINE 		if k > n-k : _NEWLINE 			k = n-k _NEWLINE 		print nCr(n,k) _NEWLINE 	
for t in xrange(int(raw_input())): _NEWLINE 	n, k, m = map(int,raw_input().split()) _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	b = map(int,raw_input().split()) _NEWLINE 	y = sorted(map(int,(raw_input()+" "+raw_input()).split()), reverse = True) _NEWLINE 	x = [] _NEWLINE 	for i in xrange(n): _NEWLINE 		x.append(a[i]-b[i]) _NEWLINE 	x = sorted(x, reverse = True) _NEWLINE 	left = sum(x) _NEWLINE 	i = 0 _NEWLINE 	j = 0 _NEWLINE 	lx = n _NEWLINE 	ly = k + m _NEWLINE 	while (i<lx and j<ly): _NEWLINE 		if (x[i]>=y[j]): _NEWLINE 			left -= y[j] _NEWLINE 			i += 1 _NEWLINE 			j += 1 _NEWLINE 		else: _NEWLINE 			j += 1 _NEWLINE 	print left
n=input() _NEWLINE arr=map(int,raw_input().split()) _NEWLINE i=0;maxp=0;mapl=0 _NEWLINE while(i<n): _NEWLINE 	p=1;l=i _NEWLINE 	while(i<n): _NEWLINE 		if(arr[i]==0): _NEWLINE 			break _NEWLINE 		p=p*arr[i] _NEWLINE 		i+=1 _NEWLINE 	if(p>maxp): _NEWLINE 		maxp=p _NEWLINE 		maxl=i-l _NEWLINE 	elif(p==maxp _INDENT and maxl<i-l): _NEWLINE 		maxl=i-l _NEWLINE 	i+=1 _NEWLINE print maxl
problem='https://www.codechef.com/problems/CHFANS' _NEWLINE __author__='Ravindra Singh' _NEWLINE  _NEWLINE  _NEWLINE def gcd(a,b): _NEWLINE  _INDENT  _INDENT if a%b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE T=int(raw_input()) _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if a>b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print abs(abs((a-b))//gcd(a,b)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print abs(abs((a-b))//gcd(b,a)) _NEWLINE 
 _NEWLINE def cmp(tup): _NEWLINE 	return (tup[1], tup[0]) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE def get_decoder(text,freqseq): _NEWLINE 	mymap = {} _NEWLINE 	for ch in text: _NEWLINE 		if ch.isalpha(): _NEWLINE 			if ch.lower() in mymap: _NEWLINE 				mymap[ch.lower()] += 1 _NEWLINE 			else: _NEWLINE 				mymap[ch.lower()] = 1 _NEWLINE  _NEWLINE 	v = [] _NEWLINE 	for k in mymap: _NEWLINE 		v.append((k,mymap[k])) _NEWLINE  _NEWLINE 	v = sorted(v,key=cmp) _NEWLINE  _NEWLINE 	length = len(v) _NEWLINE 	lastcut = freqseq[-length:] _NEWLINE  _NEWLINE 	decoder = {} _NEWLINE 	for i in range(length): _NEWLINE 		decoder[v[i][0]] = lastcut[i] _NEWLINE  _NEWLINE  _NEWLINE 	return decoder _NEWLINE  _NEWLINE  _NEWLINE t = input() _NEWLINE while t: _NEWLINE 	freqseq = raw_input() _NEWLINE 	text = raw_input() _NEWLINE  _NEWLINE 	#decoder = {} _NEWLINE 	decoder = get_decoder(text,freqseq) _NEWLINE  _NEWLINE 	ans = list(text) _NEWLINE 	for i in range(len(ans)): _NEWLINE 		if ans[i].isalpha(): _NEWLINE 			if ans[i].isupper(): _NEWLINE 				ans[i] = decoder[ans[i].lower()].upper() _NEWLINE 			else: _NEWLINE 				ans[i] = decoder[ans[i]] _NEWLINE  _NEWLINE 	ans = ''.join(ans) _NEWLINE  _NEWLINE 	print ans _NEWLINE  _NEWLINE 	t = t-1 _NEWLINE  _NEWLINE 
 _NEWLINE t = input() _NEWLINE for j in range(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT maxEdge = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lis = list(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in lis[::2]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x.append(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxEdge.append([max(x), i]) _NEWLINE  _INDENT  _INDENT maxEdge.sort(reverse=True) _NEWLINE  _INDENT  _INDENT for k in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxEdge[k][0] = n-1-k; _NEWLINE  _INDENT  _INDENT maxEdge.sort(key=lambda x:x[1]) _NEWLINE  _INDENT  _INDENT for k in maxEdge: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print k[0], _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
def rect(x,y,k): _NEWLINE  _INDENT  _INDENT if (x == 1 and y==1) or (x==1 and y ==2) or (x==2 and y==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT elif x == 1 or y == 1 or k == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return k _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return k/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (k/2)+ 1 _NEWLINE  _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE  _NEWLINE for i in range(int(sys.stdin.readline())): _NEWLINE  _INDENT  _INDENT a = sys.stdin.readline() _NEWLINE  _INDENT  _INDENT a = a.split() _NEWLINE  _INDENT  _INDENT print rect(int(a[0]),int(a[1]),int(a[2])) _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
a,b=map(int,raw_input().split()) _NEWLINE c=a-b; _NEWLINE if(c%10<9): _NEWLINE  _INDENT  _INDENT c+=1 _NEWLINE else: _NEWLINE  _INDENT  _INDENT c-=1 _NEWLINE print (str)(c)
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ds,dt,d = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print max(0, d-(ds+dt), ds-(d+dt), dt-(d+ds))
def solution(): _NEWLINE  _INDENT  _INDENT N = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT ceil_number = [] _NEWLINE  _INDENT  _INDENT not_ceil_number = [] _NEWLINE  _INDENT  _INDENT len_ceil_number = 0 _NEWLINE  _INDENT  _INDENT len_not_ceil_number = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d_k_0_flag = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT eight_digit _INDENT = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT five_digit = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT three_digit = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr = map(str, raw_input().strip().split(' ')) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = arr[-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i == '8': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT eight_digit += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif i == '5': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT five_digit += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif i == '3': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT three_digit += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len_not_ceil_number += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d_k_0_flag = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d_k_0_flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if eight_digit >= five_digit >= three_digit: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len_ceil_number += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len_not_ceil_number += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print "%d"%(len_ceil_number) _NEWLINE  _NEWLINE solution()
NumOfTests = int(raw_input()) _NEWLINE  _NEWLINE for test in range(NumOfTests): _NEWLINE  _INDENT  _INDENT N, M = map(lambda s: int(s), raw_input().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT # n: min_distance, is_visited, num_of_paths _NEWLINE  _INDENT  _INDENT D = {} _NEWLINE  _INDENT  _INDENT # paths {vertex: [(neighb_vertex, length), ...], ...} _NEWLINE  _INDENT  _INDENT P = {} _NEWLINE  _INDENT  _INDENT for i in range(1, N+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT D[i]=[float("inf"), None, 0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[i] = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT D[1] = [0, None, 1] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for m_th in range(M): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A, B, C = map(lambda s: int(s), raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[A].append((B, C)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[B].append((A, C)) _NEWLINE  _NEWLINE  _INDENT  _INDENT ################ _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vertex = min(filter(lambda v: v[1][1]==None, D.items()), key=lambda x: x[1][0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vertex = vertex[0] _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if vertex == N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for nv in P[vertex]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not D[nv[0]][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if D[vertex][0] + nv[1] < D[nv[0]][0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D[nv[0]][0] = D[vertex][0] + nv[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D[nv[0]][2] = D[vertex][2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif D[vertex][0] + nv[1] == D[nv[0]][0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D[nv[0]][2] += D[vertex][2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT D[vertex][1] = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print D[vertex][2]
values = [] _NEWLINE  _INDENT _NEWLINE def evalNode(k): _NEWLINE  _INDENT  _INDENT #print "eval(", k, ")" _NEWLINE  _INDENT  _INDENT if values[k]>=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values[k] _NEWLINE  _INDENT  _INDENT if nodes[k][0]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Input node- should have been set." _NEWLINE  _INDENT  _INDENT elif nodes[k][0]==2: # AND gate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = evalNode(nodes[k][1]-1) * evalNode(nodes[k][2]-1) _NEWLINE  _INDENT  _INDENT else: # OR gate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = 1.0 - (1.0-evalNode(nodes[k][1]-1))*(1.0-evalNode(nodes[k][2]-1)) _NEWLINE  _INDENT  _INDENT values[k] = val _NEWLINE  _INDENT  _INDENT return val _NEWLINE def evaluate(prob): _NEWLINE  _INDENT  _INDENT global values _NEWLINE  _INDENT  _INDENT #print "Evaluate", prob _NEWLINE  _INDENT  _INDENT values = [-1.0]*len(nodes) _NEWLINE  _INDENT  _INDENT for i in range(len(nodes)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if nodes[i][0]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[i] = prob _NEWLINE  _INDENT  _INDENT return evalNode(len(nodes)-1) _NEWLINE  _INDENT _NEWLINE ntest = int(raw_input()) _NEWLINE  _INDENT _NEWLINE for test in range(ntest): _NEWLINE  _INDENT  _INDENT xx = raw_input() _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT nodes = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nodes.append(node) _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT if nodes[-1][0] ==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0.50000" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT prLow = 0.0 _NEWLINE  _INDENT  _INDENT prHigh = 1.0 _NEWLINE  _INDENT  _INDENT eps = 1e-5 _NEWLINE  _INDENT  _INDENT while prHigh-prLow>eps or round(prHigh,5)>round(prLow,5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prMid = (prLow+prHigh)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT valueMid = evaluate(prMid) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if valueMid>0.5: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prHigh = prMid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prLow = prMid _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT print "%.5f" % ((prLow+prHigh)/2) _NEWLINE 
NT = int(raw_input()) _NEWLINE MOD = 1000000007 _NEWLINE while NT > 0: _NEWLINE  _INDENT  _INDENT NT -= 1 _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT ans = 1 _NEWLINE  _INDENT  _INDENT if N%2 == 0: _NEWLINE 	k = N/2 _NEWLINE 	ans = 3*pow(2,k,MOD) - 2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE 	k = (N+1)/2 _NEWLINE 	ans = pow(2,k+1,MOD) - 2 _NEWLINE  _INDENT  _INDENT ans = (ans+MOD)%MOD; _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT _NEWLINE 
for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT o=[] _NEWLINE  _INDENT  _INDENT for i in range(1,a+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i not in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o.append(i) _NEWLINE  _INDENT  _INDENT print ' '.join(map(str,o[0::2])) _NEWLINE  _INDENT  _INDENT print ' '.join(map(str,o[1::2])) _NEWLINE 
from heapq import * _NEWLINE import itertools _NEWLINE  _NEWLINE pq = [] _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # list of entries arranged in a heap _NEWLINE entry_finder = {} _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # mapping of tasks to entries _NEWLINE REMOVED = '<removed-task>' _INDENT  _INDENT  _INDENT # placeholder for a removed task _NEWLINE counter = itertools.count() _INDENT  _INDENT  # unique sequence count _NEWLINE  _NEWLINE  _NEWLINE def init(): _NEWLINE  _INDENT  _INDENT global pq _NEWLINE  _INDENT  _INDENT global entry_finder _NEWLINE  _INDENT  _INDENT pq = [] _NEWLINE  _INDENT  _INDENT entry_finder = {} _NEWLINE  _NEWLINE  _NEWLINE def add_task(task, priority=0): _NEWLINE  _INDENT  _INDENT 'Add a new task or update the priority of an existing task' _NEWLINE  _INDENT  _INDENT if task in entry_finder: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT remove_task(task) _NEWLINE  _INDENT  _INDENT count = next(counter) _NEWLINE  _INDENT  _INDENT entry = [priority, count, task] _NEWLINE  _INDENT  _INDENT entry_finder[task] = entry _NEWLINE  _INDENT  _INDENT heappush(pq, entry) _NEWLINE  _NEWLINE  _NEWLINE def remove_task(task): _NEWLINE  _INDENT  _INDENT 'Mark an existing task as REMOVED. _INDENT Raise KeyError if not found.' _NEWLINE  _INDENT  _INDENT entry = entry_finder.pop(task) _NEWLINE  _INDENT  _INDENT entry[-1] = REMOVED _NEWLINE  _NEWLINE  _NEWLINE def pop_task(): _NEWLINE  _INDENT  _INDENT 'Remove and return the lowest priority task. Raise KeyError if empty.' _NEWLINE  _INDENT  _INDENT while pq: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT priority, count, task = heappop(pq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if task is not REMOVED: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT del entry_finder[task] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return task _NEWLINE  _INDENT  _INDENT raise KeyError('pop from an empty priority queue') _NEWLINE  _NEWLINE  _NEWLINE def next_pos(cust, s, orders): _NEWLINE  _INDENT  _INDENT for i in xrange(s, len(orders)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = orders[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if cust == o: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(orders) - i - 1 _NEWLINE  _INDENT  _INDENT return -1 _NEWLINE  _NEWLINE  _NEWLINE def solve(N, orders): _NEWLINE  _INDENT  _INDENT init() _NEWLINE  _INDENT  _INDENT free = N _NEWLINE  _INDENT  _INDENT customer_table = set() _NEWLINE  _INDENT  _INDENT clean_count = 0 _NEWLINE  _INDENT  _INDENT s = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT for i, o in enumerate(orders): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not free: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o not in customer_table: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT customer_table.add(o) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT clean_count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #heappush(farthest, (next_pos(o, i + 1, orders), o)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(s, len(orders)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = orders[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print pq, customer_table, o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o not in customer_table: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # d, f = heappop(farthest) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f = pop_task() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT customer_table.remove(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT customer_table.add(o) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # heappush(farthest, (next_pos(o, i + 1, orders), o)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT clean_count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _NEWLINE  _INDENT  _INDENT return clean_count _NEWLINE  _NEWLINE  _NEWLINE assert solve(1, [1]) == 1 _NEWLINE assert solve(1, [1, 1]) == 1 _NEWLINE assert solve(2, [1, 1]) == 1 _NEWLINE assert solve(2, [1, 2]) == 2 _NEWLINE assert solve(1, [1, 1, 2, 2]) == 2 _NEWLINE assert solve(1, [1, 1, 1, 1]) == 1 _NEWLINE assert solve(2, [1, 1, 1, 1]) == 1 _NEWLINE assert solve(2, [1, 1, 2, 1]) == 2 _NEWLINE assert solve(4, [1, 2, 3, 4]) == 4 _NEWLINE assert solve(1, [1, 2, 1, 2]) == 4 _NEWLINE assert solve(4, [1, 2, 1, 3, 1]) == 3 _NEWLINE assert solve(4, [1, 2, 1, 3, 1, 1, 1]) == 3 _NEWLINE assert solve(1, range(100)) == 100 _NEWLINE assert solve(4, [1, 2, 3, 4, 5, 1, 1]) == 5 _NEWLINE assert solve(4, [1, 2, 3, 4, 5, 1, 1, 1, 1]) == 5 _NEWLINE assert solve(2, [1, 2, 3, 2, 3, 1, 1, 1, 1]) == 4 _NEWLINE assert solve(1, [1]) == 1 _NEWLINE assert solve(2, [1, 1, 1]) == 1 _NEWLINE assert solve(4, [1, 2, 3, 4, 1, 2, 3, 4]) == 4 _NEWLINE assert solve(3, [1, 2, 3, 4, 5, 1, 1, 1]) == 5 _NEWLINE assert solve(2, [1, 2, 2, 1, 2, 2, 1, 1]) == 2 _NEWLINE  _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT N, M = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT orders = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT print solve(N, orders) _NEWLINE 
import math _NEWLINE fib=[] _NEWLINE fib.append(0) _NEWLINE fib.append(1) _NEWLINE for i in range(2,1000001): _NEWLINE  _INDENT  _INDENT fib.append((fib[i-1]+fib[i-2])%1000000007) _NEWLINE t=int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT #n+=1 _NEWLINE  _INDENT  _INDENT #phi=(1+(5**0.5))/2 _NEWLINE  _INDENT  _INDENT #nphi=(1-(5**0.5))/2 _NEWLINE  _INDENT  _INDENT #fib=int(((phi**n)-(nphi**n))/(5**0.5)) _NEWLINE  _INDENT  _INDENT #fib=fib%1000000007 _NEWLINE  _INDENT  _INDENT #x=list(bin(fib)) _NEWLINE  _INDENT  _INDENT #print fib[n+1] _NEWLINE  _INDENT  _INDENT counter=str(bin(fib[n+1])).count('1') _NEWLINE  _INDENT  _INDENT #for j in x: _NEWLINE  _INDENT  _INDENT  # _INDENT  if(j=='1'): _NEWLINE  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT if(counter==k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "CORRECT" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "INCORRECT"
test = input() _NEWLINE while test: _NEWLINE  _INDENT  _INDENT test = ~(-test) _NEWLINE  _INDENT  _INDENT n,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT arr = ['0']*n _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i&1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = ')' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = '(' _NEWLINE  _INDENT  _INDENT while k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = ~(-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l,r = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT change = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(l,r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if change: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = ')' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT change = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = '(' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT change = 1 _NEWLINE  _INDENT  _INDENT print ''.join(arr) _NEWLINE 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT n, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if k != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = [] _NEWLINE  _INDENT  _INDENT A.sort() _NEWLINE  _INDENT  _INDENT ans = 1 _NEWLINE  _INDENT  _INDENT i = 1 _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT l = 0 _NEWLINE  _INDENT  _INDENT while i < n + 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j < k and i == A[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ans < i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j < k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nx = A[j] - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nx = n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += ((nx * (nx + 1))/2) - ((i * (i + 1))/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = nx + 1 _NEWLINE  _INDENT  _INDENT if ans % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Mom" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Chef" _NEWLINE 
t=int(raw_input()) _NEWLINE for q in xrange(0,t): _NEWLINE  _INDENT  _INDENT x,y,k,n=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans= "UnluckyChef" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p,c=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k>=c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x-y)<=p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans= "LuckyChef" _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
i, k, s = map(int, raw_input().strip().split()) _NEWLINE a, b = map(int, raw_input().strip().split()) _NEWLINE  _NEWLINE from math import sqrt _NEWLINE sqrt2 = sqrt(2) _NEWLINE sqrt6 = sqrt(6) _NEWLINE if (i ^ k) & 1: _NEWLINE  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT a, b = ( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sqrt2 * (a + b) - sqrt6 * (a - b), _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sqrt2 * (a - b) + sqrt6 * (a + b), _NEWLINE  _INDENT  _INDENT ) _NEWLINE  _NEWLINE ans = (a + b) * pow(0.5, s + 2*(i - k)) _NEWLINE print "%.11lf" % ans
t = int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT n, m, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT b = [] _INDENT # gain _NEWLINE  _INDENT  _INDENT for _ in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT c = [] _INDENT # loss _NEWLINE  _INDENT  _INDENT for _ in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT init_cost = [0]*n _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT init_cost[i] = b[i][a[i] -1] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_gain = [0]*n _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mp = 0 # max profit _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT np = b[i][j] - c[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mp = max(mp, np) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # calc gain with respect to init cost _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_gain[i] = _INDENT mp - init_cost[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_gain.sort() _NEWLINE  _INDENT  _INDENT max_gain.reverse() _NEWLINE  _INDENT  _INDENT print sum(init_cost) + sum(max_gain[:k]) _NEWLINE 
#-*- coding:utf-8 -*- _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE  _NEWLINE # class Point: _NEWLINE # _INDENT  _INDENT  def __init__(self, x, y): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.x = x _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.y = y _NEWLINE  _NEWLINE # _INDENT  _INDENT  def mul(self, k): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return Point(k * self.x, k * self.y) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __add__(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return Point(self.x + other.x, self.y + other.y) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __sub__(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return self + (-other) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __neg__(self): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return Point(-self.x, -self.y) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __eq__(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return self.x == other.x and self.y == other.y _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __getitem__(self, index): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return (self.x, self.y)[index] _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __str__(self): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return "(%d;%d)" % (self.x, self.y) _NEWLINE  _NEWLINE  _NEWLINE DIRS = dict( _NEWLINE  _INDENT  _INDENT U=(0, 1), _NEWLINE  _INDENT  _INDENT D=(0, -1), _NEWLINE  _INDENT  _INDENT R=(1, 0), _NEWLINE  _INDENT  _INDENT L=(-1, 0) _NEWLINE ) _NEWLINE KOEF = 0.2 _NEWLINE  _NEWLINE  _NEWLINE def div(a, b): _NEWLINE  _INDENT  _INDENT return round(float(a) / b, 1) _NEWLINE  _NEWLINE  _NEWLINE # class Moving: _NEWLINE # _INDENT  _INDENT  def __init__(self, x, y, dir): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.p = Point(x, y) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.dir = Point(*DIRS[dir.upper()]) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def collide(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  times = [] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  for coord in range(2): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d = abs(self.p[coord] - other.p[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d2 = abs((self.p + self.dir.mul(KOEF) - other.p)[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d3 = abs((other.p + other.dir.mul(KOEF) - self.p)[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d_next = abs((self.p + self.dir.mul(KOEF) - (other.p + other.dir.mul(KOEF)))[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if d2 > d or d3 > d: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return None _NEWLINE  _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  speed = abs(d_next - d) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if speed == 0: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if self.p[coord] != other.p[coord]: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return None _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  times.append( div(d, speed / KOEF) ) _NEWLINE  _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  if len(times) == 2 and times[0] != times[1]: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return times[0] _NEWLINE  _NEWLINE  _NEWLINE def collide_coord(ex, edx, x, dx): _NEWLINE  _INDENT  _INDENT d = abs(ex - x) _NEWLINE  _INDENT  _INDENT d2 = abs(ex + edx - x) _NEWLINE  _INDENT  _INDENT d3 = abs(ex - x - dx) _NEWLINE  _INDENT  _INDENT if d2 > d or d3 > d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _NEWLINE  _INDENT  _INDENT d_next = abs(ex + edx * KOEF - x - dx * KOEF) _NEWLINE  _INDENT  _INDENT speed = abs(d_next - d) _NEWLINE  _INDENT  _INDENT if speed == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ex != x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "all" _INDENT # all _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return div(d, speed / KOEF) _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT for _ in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ex, ey, dir = sys.stdin.readline().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ex = int(ex) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ey = int(ey) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edx, edy = DIRS[dir] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_time = float("+inf") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x, y, dir = sys.stdin.readline().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = int(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y = int(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dx, dy = DIRS[dir] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tx = collide_coord(ex, edx, x, dx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if tx is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ty = collide_coord(ey, edy, y, dy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ty is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if tx == "all": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_time = min(min_time, ty) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif ty == "all": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_time = min(min_time, tx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif tx == ty: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_time = min(min_time, tx) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print min_time if min_time < 1000000 else "SAFE" _NEWLINE  _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
p=input() _NEWLINE while(p>0): _NEWLINE 	p-=1 _NEWLINE 	n=input() _NEWLINE 	x=[0]*n;l=[0]*n;f=[0]*n;t=[0]*n _NEWLINE 	i=0 _NEWLINE 	while(i<n): _NEWLINE 		x[i],l[i],f[i]=map(int,raw_input().split()) _NEWLINE 		i+=1 _NEWLINE 	t[0]=x[0]+l[0] _NEWLINE 	i=1 _NEWLINE 	while(i<n): _NEWLINE 		if( t[i-1]>x[i] ): _NEWLINE 			if((t[i-1]-x[i])%f[i]==0): _NEWLINE 				t[i]=l[i]+t[i-1] _NEWLINE 			else: _NEWLINE 				t[i]=f[i]-(t[i-1]-x[i])%f[i] + l[i]+t[i-1] _NEWLINE 		if( t[i-1]<=x[i] ): _NEWLINE 			t[i]=x[i]-t[i-1]+l[i]+t[i-1] _NEWLINE 		i+=1 _NEWLINE 	#$print t _NEWLINE 	print t[n-1] _NEWLINE 
t = int(raw_input().strip()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT length = -1 _NEWLINE  _INDENT  _INDENT l = list(raw_input().strip()) _NEWLINE  _INDENT  _INDENT for i in range(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] == "<": count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: count -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count == 0: length = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif count < 0: break _NEWLINE  _INDENT  _INDENT print length + 1
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT for oo in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i, j, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j%2 ==0 or i == k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j/2 +1
from fractions import gcd _NEWLINE from sys import stdin _NEWLINE  _NEWLINE  _NEWLINE def p(n): _NEWLINE  _INDENT  _INDENT s = int(n ** .5) _NEWLINE  _INDENT  _INDENT c = sum(n/i for i in xrange(1, s+1)) * 2 - s**2 _NEWLINE  _INDENT  _INDENT g = gcd(c, n ** 2) _NEWLINE  _INDENT  _INDENT return '{}/{}'.format(c / g, n**2 / g) _NEWLINE  _NEWLINE  _NEWLINE print( _NEWLINE  _INDENT  _INDENT '\n'.join( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p(int(ln)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, ln in enumerate(stdin) if i _NEWLINE  _INDENT  _INDENT ) _NEWLINE )
#include <bits/stdc++.h> _NEWLINE  _NEWLINE #define test int t; scanf("%d",&t);while(t--) _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE using namespace std; _NEWLINE  _NEWLINE int MOD=1e8+7; _NEWLINE  _NEWLINE int prod(int a,int b){ _NEWLINE 	ll aa=a,bb=b; _NEWLINE 	return (aa*bb)%MOD; _NEWLINE } _NEWLINE int sum(int a,int b){ _NEWLINE 	ll aa=a,bb=b; _NEWLINE 	return (aa+bb)%MOD; _NEWLINE } _NEWLINE int power(int x,ll n){ _NEWLINE 	if(n==0)return 1; _NEWLINE  _NEWLINE 	int temp=power(x,n/2); _NEWLINE  _NEWLINE 	if(n%2==0)return prod(temp,temp); _NEWLINE 	return prod(temp,prod(temp,x)); _NEWLINE } _NEWLINE int inv=power(2,MOD-2); _NEWLINE int main(){ _NEWLINE 	test{ _NEWLINE 		ll n; cin >> n; _NEWLINE  _NEWLINE 		int ans1=0,ans2=0; _NEWLINE 		ans1=sum(power(3,n),1); _NEWLINE 		ans1=(ans1-power(2,n+1)+MOD)%MOD; _NEWLINE 		ans1=prod(ans1,inv); _NEWLINE  _NEWLINE 		ans2=sum(power(4,n),sum(power(2,n),power(2,n+1))); _NEWLINE 		ans2=(ans2-1+MOD)%MOD; _NEWLINE 		ans2=(ans2-power(3,n+1)+MOD)%MOD; _NEWLINE 		ans2=prod(ans2,inv); _NEWLINE  _NEWLINE 		cout << ans1 << " " << ans2 << "\n"; _NEWLINE 	} _NEWLINE } _NEWLINE 
p=1000003 _NEWLINE  _NEWLINE ''' _NEWLINE  _NEWLINE calculating modulo inverse of 'a' using Euclid's Extended Lemma _NEWLINE ''' _NEWLINE  _NEWLINE def invert_mod(a): _NEWLINE 	n=1 _NEWLINE 	old=0 _NEWLINE 	q=p _NEWLINE 	r=0 _NEWLINE 	h=0 _NEWLINE  _NEWLINE 	pos=0 _NEWLINE  _NEWLINE 	while a>0: _NEWLINE 		r=q%a _NEWLINE 		q=q/a _NEWLINE 		h=q*n+old _NEWLINE 		old=n _NEWLINE 		n=h _NEWLINE 		q=a _NEWLINE 		a=r _NEWLINE 		if pos==0: _NEWLINE 			pos=1 _NEWLINE 		else: _NEWLINE 			pos=0 _NEWLINE  _NEWLINE 	if(pos): _NEWLINE 		return old _NEWLINE 	else: _NEWLINE 		return p-old _NEWLINE  _NEWLINE ''' _NEWLINE Calculating C(n,k)--- No of ways of selecting k from n things _NEWLINE ''' _NEWLINE  _NEWLINE def cal(n,k): _NEWLINE 	if(n<k): _NEWLINE 		return 0 _NEWLINE 	elif(n==k): _NEWLINE 		return 1 _NEWLINE 	elif(n==0): _NEWLINE 		return 0 _NEWLINE  _NEWLINE 	num=1 _NEWLINE  _NEWLINE 	for i in xrange(0,k): _NEWLINE 		num=(num*(n-i))%p _NEWLINE  _NEWLINE 	denom=1 _NEWLINE  _NEWLINE 	for i in xrange(1,k+1): _NEWLINE 		denom=(denom*i)%p _NEWLINE  _NEWLINE 	return (num*invert_mod(denom))%p _NEWLINE  _NEWLINE  _NEWLINE t=input() _NEWLINE  _NEWLINE for test in xrange(t): _NEWLINE 	 _NEWLINE 	n,l,r=map(int,raw_input().split()) _NEWLINE 	 _NEWLINE 	d=r-l+1	 _NEWLINE 	# d stands for number of numbers to be considered for selection _NEWLINE  _NEWLINE 	a=[0,0] _NEWLINE 	b=[0,0] _NEWLINE 	 _NEWLINE 	y=n+d _NEWLINE  _NEWLINE 	j=0 _NEWLINE 	s=0 _NEWLINE  _NEWLINE 	while y!=0: _NEWLINE 		a[j]=y%p _NEWLINE 		y=y/p _NEWLINE 		j=j+1 _NEWLINE 	 _NEWLINE 	k=0 _NEWLINE  _NEWLINE 	if n>=d: _NEWLINE 		y=d _NEWLINE 		while y!=0: _NEWLINE 			b[k]=y%p _NEWLINE 			y=y/p _NEWLINE 			k=k+1 _NEWLINE 		s=cal(a[0],b[0]) _NEWLINE  _NEWLINE 		if(s!=0): _NEWLINE 			s=(s*cal(a[1],b[1]))%p _NEWLINE 	else : _NEWLINE 		y=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while y!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[k]=y%p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=y/p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=cal(a[0],b[0]) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(s*cal(a[1],b[1]))%p _NEWLINE  _NEWLINE 	s=(s-1+p)%p _NEWLINE  _NEWLINE 	print s _NEWLINE  _NEWLINE 			 _NEWLINE 
t=raw_input() _NEWLINE  _NEWLINE t=int(t) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT cnt=0 _NEWLINE  _INDENT  _INDENT sm=0 _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT st=raw_input() _NEWLINE  _INDENT  _INDENT cnt=st.count('1') _NEWLINE  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT temp=(cnt*(cnt-1))/2 _NEWLINE  _INDENT  _INDENT sm=cnt+temp _NEWLINE  _INDENT  _INDENT print sm _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
from heapq import * _NEWLINE from math import * _INDENT _NEWLINE  _NEWLINE #young => max heap (by using -ve) _NEWLINE #old => min heap (by default) _NEWLINE  _NEWLINE young_team = [] _NEWLINE young_score = 0 _NEWLINE  _NEWLINE older_team = [] _NEWLINE older_score = 0 _NEWLINE  _NEWLINE counter = 1 _INDENT _NEWLINE temp = [] _NEWLINE  _NEWLINE a = int(raw_input()) _NEWLINE for c in range(a): _NEWLINE  _INDENT  _INDENT k = raw_input().split(" ") _NEWLINE  _INDENT  _INDENT age = int(k[0]) _NEWLINE  _INDENT  _INDENT rate = int(k[1]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT new_entry = [age,rate] _NEWLINE  _NEWLINE  _INDENT  _INDENT if counter > 2 : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(young_team) == len(older_team): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if older_team[0][0] < age : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current = heappop(older_team) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score - current[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current[0] = current[0] * -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team,current) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + current[1] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + rate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '=', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new_entry[0] = new_entry[0]* -1 _INDENT ## added -ve value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + rate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '==', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif len(young_team) > len(older_team) : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((young_team[0][0]*-1) > age) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current = heappop(young_team) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score - current[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current[0] = current[0] * -1 ##again maken +ve _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team,current) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + current[1] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new_entry[0] = new_entry[0] * -1 ## added -ve _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + rate _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '===', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + rate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '====', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print abs(older_score-young_score) _NEWLINE  _NEWLINE  _INDENT  _INDENT else : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if counter == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print new_entry[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print abs(temp[0][1]-temp[1][1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_add_by_neagting = temp[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_add_by_neagting[0] = temp_add_by_neagting[0] * -1 # add by -ve so it will become max heap _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team ,temp_add_by_neagting) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + temp_add_by_neagting[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team ,temp[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + temp[1][1] _NEWLINE  _NEWLINE  _INDENT  _INDENT counter _INDENT = counter + 1 _NEWLINE 
def removeTop(i,j,k): _NEWLINE  _INDENT  _INDENT return a[i-1][j][k] if i else 0 _NEWLINE def removeBack(i,j,k): _NEWLINE  _INDENT  _INDENT return (a[i][j-1][k] - removeTop(i,j-1,k)) if j else 0 _NEWLINE def removeSide(i,j,k): _NEWLINE  _INDENT  _INDENT return (a[i][j][k-1] - removeBack(i,j,k-1) - removeTop(i,j,k-1)) if k else 0 _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT (i,j,k) = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT for x in range(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d2 = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for y in range(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d2.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(d2) _NEWLINE  _INDENT  _INDENT for x in range(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for y in range(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ' '.join(str(a[x][y][z] - (removeTop(x,y,z) + removeBack(x,y,z) + removeSide(x,y,z))) for z in range(k)) _NEWLINE  _INDENT  _INDENT t-=1
text = raw_input() _NEWLINE result = '' _NEWLINE l = text.split() _NEWLINE n = int(l[0]) _NEWLINE m = int(l[1]) _NEWLINE dicn = {} _NEWLINE dicch = {} _NEWLINE dicco = {} _NEWLINE for i in range(n): _NEWLINE 	t = raw_input() _NEWLINE 	l = t.split() _NEWLINE 	dicn[l[0]] = l[1] _NEWLINE 	dicch[l[0]] = 0; _NEWLINE 	dicco[l[1]] = 0; _NEWLINE for i in range(m): _NEWLINE 	t = raw_input() _NEWLINE 	nt = dicch[t] _NEWLINE 	dicch[t] = nt+1 _NEWLINE 	nt = dicco[dicn[t]] _NEWLINE 	dicco[dicn[t]] = nt + 1 _NEWLINE  _INDENT _NEWLINE outch = 'ZZZZZZZZZZZ' _NEWLINE outco = 'ZZZZZZZZZZZ' _NEWLINE maxch = 0 _NEWLINE maxco = 0 _NEWLINE for e in dicch: _NEWLINE 	if maxch < dicch[e]: _NEWLINE 		outch = e _NEWLINE 		maxch = dicch[e] _NEWLINE 	if maxch == dicch[e] and outch > e: _NEWLINE 		outch = e _NEWLINE 		maxch = dicch[e] _NEWLINE  _INDENT _NEWLINE for e in dicco: _NEWLINE 	if maxco < dicco[e]: _NEWLINE 		outco = e _NEWLINE 		maxco = dicco[e] _NEWLINE 	if maxco == dicco[e] and outco > e: _NEWLINE 		outco = e _NEWLINE 		maxco = dicco[e] _NEWLINE  _INDENT _NEWLINE print outco _NEWLINE print outch
mapa = None _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE valid = lambda x,y : x>=0 and x<101 and y>=0 and y<101 _NEWLINE  _NEWLINE for tt in xrange(T): _NEWLINE  _INDENT  _INDENT mapa = [ [False for i in xrange(101)] for j in xrange(101) ] _NEWLINE  _NEWLINE  _INDENT  _INDENT numPoints = int(raw_input()) _NEWLINE  _INDENT  _INDENT points = [] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in xrange(numPoints): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (x,y) = map( lambda a: int(a)+50 ,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT points.append((x,y)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mapa[x][y]=True _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT points.sort() _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(numPoints): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,numPoints): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dx = points[j][0] - points[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dy = points[j][1] - points[i][1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x3 = points[j][0] - dy _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y3 = points[j][1] + dx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if valid(x3,y3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x4 = points[i][0] - dy _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y4 = points[i][1] + dx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if valid(x4,y4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (mapa[points[i][0]][points[i][1]] and _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mapa[x3][y3] and mapa[x4][y4]) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print count/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 
def permute(count,per): _NEWLINE 	num=1;din=1 _NEWLINE 	while(per>0): _NEWLINE 		num*=count _NEWLINE 		din*=per _NEWLINE 		per-=1 _NEWLINE 		count-=1 _NEWLINE 	return num/din _NEWLINE  _NEWLINE x,n=map(int,raw_input().split()) _NEWLINE poss=0 _NEWLINE while(n>0): _NEWLINE 	count=map(int,list(raw_input())) _NEWLINE 	s=[0]*55;s[1:]=count _NEWLINE 	#print s _NEWLINE 	n-=1 _NEWLINE 	i=1;j=54 _NEWLINE 	while(i<34): _NEWLINE 		while(j>27): _NEWLINE 			'''print "i-j" _NEWLINE 			print ("%d %d ")%(i,j)''' _NEWLINE 			count=[0]*2 _NEWLINE 			count[s[i]]+=1 _NEWLINE 			count[s[i+1]]+=1 _NEWLINE 			count[s[i+2]]+=1 _NEWLINE 			count[s[i+3]]+=1 _NEWLINE 			count[s[j]]+=1 _NEWLINE 			count[s[j-1]]+=1 _NEWLINE 			'''print _INDENT _NEWLINE 			print s[i] _NEWLINE 			print s[i+1] _NEWLINE 			print s[i+2] _NEWLINE 			print s[i+3] _NEWLINE 			print s[j] _NEWLINE 			print s[j-1] _NEWLINE 			print''' _NEWLINE 			break _NEWLINE 		i+=4 _NEWLINE 		j-=2 _NEWLINE 		if(count[0]>=x): _NEWLINE 			poss+=permute(count[0],x) _NEWLINE 		#print "poss" _NEWLINE 		#print poss _NEWLINE print poss
import bisect _NEWLINE import time _NEWLINE import sys _NEWLINE A = [] _NEWLINE subarray = {} _NEWLINE keys = [] _NEWLINE subarray_low = {} _NEWLINE subarray_high = {} _NEWLINE subarray_length = 0 _NEWLINE # (val,start,pos) stack _NEWLINE # (start,end,pos) dict _NEWLINE  _NEWLINE def preprocess(n): _NEWLINE 	global keys _NEWLINE 	global A _NEWLINE 	global subarray _NEWLINE 	global subarray_low _NEWLINE 	global subarray_high _NEWLINE 	global subarray_length _NEWLINE  _NEWLINE 	for i in A: _NEWLINE 		subarray[i] = 0 _NEWLINE 	stack = [] _NEWLINE 	for i in range(n): _NEWLINE 		if i == 0: _NEWLINE 			stack.append((A[0],0,0)) _NEWLINE 		else: _NEWLINE 			top = stack[-1] _NEWLINE 			if A[i] <= top[0]: _NEWLINE 				stack.append((A[i],i,i)) _NEWLINE 			else: _NEWLINE 				while len(stack) > 0 and A[i] > stack[-1][0]: _NEWLINE 					top = stack[-1] _NEWLINE 					stack.pop() _NEWLINE 					subarray[top[0]] += (i-top[2]) * (top[2]-top[1]+1) _NEWLINE 				stack.append((A[i],top[1],i)) _NEWLINE 	end = n-1 _NEWLINE  _NEWLINE 	length = len(stack) _NEWLINE 	i = 0 _NEWLINE 	while i<length: _NEWLINE 		top = stack[-1] _NEWLINE 		stack.pop() _NEWLINE 		subarray[top[0]] += (end-top[2]+1)*(top[2]-top[1]+1) _NEWLINE 		i += 1 _NEWLINE  _NEWLINE 	keys = sorted(subarray.keys()) _NEWLINE  _NEWLINE 	t = 0 _NEWLINE 	for i in keys: _NEWLINE 		t += subarray[i] _NEWLINE 		subarray_low[i] = t _NEWLINE  _NEWLINE 	t = 0 _NEWLINE 	for i in reversed(keys): _NEWLINE 		t += subarray[i] _NEWLINE 		subarray_high[i] = t _NEWLINE  _NEWLINE 	subarray_length = len(subarray) _NEWLINE  _NEWLINE  _NEWLINE def play(symbol,number,starter): _NEWLINE 	global keys _NEWLINE 	global A _NEWLINE 	global subarray _NEWLINE 	global subarray_low _NEWLINE 	global subarray_high _NEWLINE 	global subarray_length _NEWLINE  _NEWLINE 	ans = 0 _NEWLINE 	if symbol == '<': _NEWLINE 		k = bisect.bisect_left(keys,number) _NEWLINE 		if k: _NEWLINE 			ans = subarray_low[keys[k-1]] _NEWLINE 	elif symbol == '=': _NEWLINE 		if number in subarray: _NEWLINE 			ans = subarray[number] _NEWLINE 	else: _NEWLINE 		k = bisect.bisect_right(keys,number) _NEWLINE 		if k<subarray_length: _NEWLINE 			ans = subarray_high[keys[k]] _NEWLINE  _NEWLINE 	if ans%2 == 0: _NEWLINE 		if starter == 'C': _NEWLINE 			return 'D' _NEWLINE 		else: _NEWLINE 			return 'C' _NEWLINE 	else: _NEWLINE 		return starter _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	n, m = map(int,sys.stdin.readline().split()) _NEWLINE 	A = map(int,sys.stdin.readline().split()) _NEWLINE 	preprocess(n) _NEWLINE 	s = '' _NEWLINE 	for j in range(m): _NEWLINE 		C, K, X = sys.stdin.readline().split() _NEWLINE 		K = int(K) _NEWLINE 		s = s+play(C,K,X) _NEWLINE 	print(s) _NEWLINE  _NEWLINE 
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE def yo(x): _NEWLINE  _INDENT  _INDENT s="a" _NEWLINE  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT while i<=x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=chr(97+i)+s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT return s _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT b = _INDENT int(raw_input()) _NEWLINE  _INDENT  _INDENT if (b<=25): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print yo(b) _NEWLINE  _INDENT  _INDENT elif (b<=50 and b>25): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=yo(b-25)+yo(25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print y _NEWLINE  _INDENT  _INDENT elif (b<=75 and b>50): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w=yo(b-50)+yo(25)+yo(25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print w _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u=yo(b-75)+yo(25)+yo(25)+yo(25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print u _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
 _NEWLINE # Property 1: _NEWLINE #j and k cannot have gap _NEWLINE #because if have gap > 0, one side will eat it up _NEWLINE  _NEWLINE # hence for each middle position j or k _NEWLINE # calculate the min/max values for each section, one to the left _NEWLINE # and one to the right of j/k _NEWLINE # then calculate the largest absolute difference between each _NEWLINE # pair of left/right sections _NEWLINE  _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE  _NEWLINE T = int(sys.stdin.readline().strip()) _NEWLINE  _NEWLINE for z in range(T): _NEWLINE 	N = int(sys.stdin.readline().strip()) _NEWLINE 	numbers = [] _NEWLINE 	leftMins = [] _NEWLINE 	leftMaxs = [] _NEWLINE 	rightMins = [] _NEWLINE 	rightMaxs = [] _NEWLINE 	max_delish = 0 _NEWLINE 	lines = sys.stdin.readline().strip() _NEWLINE 	for n in lines.split(" "): _NEWLINE 		numbers.append(int(n)) _NEWLINE 		leftMins.append(10000001) _NEWLINE 		leftMaxs.append(-10000001) _NEWLINE 		rightMins.append(10000001) _NEWLINE 		rightMaxs.append(-10000001) _NEWLINE  _NEWLINE 	leftMins[0] = numbers[0] _INDENT _NEWLINE 	leftMaxs[0] = numbers[0] _NEWLINE  _NEWLINE 	rightMins[len(numbers)-1] = numbers[len(numbers)-1] _INDENT _NEWLINE 	rightMaxs[len(numbers)-1] = numbers[len(numbers)-1] _NEWLINE  _NEWLINE  _NEWLINE 	# for left sides _NEWLINE 	for j in range(1,N-1): _NEWLINE 		# for minimums _NEWLINE 		if leftMins[j-1] >= 0: _NEWLINE 			leftMins[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			leftMins[j] = leftMins[j-1] + numbers[j] _NEWLINE  _NEWLINE 		# for maximums _NEWLINE 		if leftMaxs[j-1] <= 0: _NEWLINE 			leftMaxs[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			leftMaxs[j] = leftMaxs[j-1] + numbers[j] _NEWLINE  _NEWLINE 	# for right sides _NEWLINE 	for z in range(1,N-1): _NEWLINE 		j = N - 1 - z _NEWLINE 		# for minimums _NEWLINE 		if rightMins[j+1] >= 0: _NEWLINE 			rightMins[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			rightMins[j] = rightMins[j+1] + numbers[j] _NEWLINE  _NEWLINE  _NEWLINE 		# for maximums _NEWLINE 		if rightMaxs[j+1] <= 0: _NEWLINE 			rightMaxs[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			rightMaxs[j] = rightMaxs[j+1] + numbers[j] _NEWLINE 		 _NEWLINE 	max_delish = 0 _NEWLINE 	for j in range(N-1): _NEWLINE 		k = j+1 _NEWLINE 		delish = max(rightMaxs[k] - leftMins[j], leftMaxs[j] - rightMins[k]) _NEWLINE 		if delish > max_delish: _NEWLINE 			max_delish = delish _NEWLINE 	print max_delish _NEWLINE 
# Author : Avikalp Srivastava _NEWLINE  _NEWLINE T = int(raw_input('')) _NEWLINE while T > 0: _NEWLINE 	T -= 1 _NEWLINE 	N = int(raw_input('')) _NEWLINE 	A_str = raw_input('') _NEWLINE 	A = [x for x in A_str.split()] _NEWLINE 	if len(A) == 1: _NEWLINE 		print '1' _NEWLINE 		continue _NEWLINE 	A.sort() _NEWLINE 	y = 2 _NEWLINE 	x = len(A)-1 _NEWLINE 	mid = 1 + ((x-1) / y) _NEWLINE 	median = A[mid] _NEWLINE 	count = 0 _NEWLINE 	for item in A: _NEWLINE 		if item == median: _NEWLINE 			count += 1 _NEWLINE 	if count >= (len(A)/2 + 1): _NEWLINE 		print count _NEWLINE 	else: _NEWLINE 		if len(A)%2 == 0: _NEWLINE 			print len(A)/2 _NEWLINE 		else: _NEWLINE 			print (len(A)/2 + 1) _NEWLINE 	del A[:]
t=int(input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT typ=int(input()) _NEWLINE  _INDENT  _INDENT s=list(raw_input()) _NEWLINE  _INDENT  _INDENT if(abs(s.count('B')-s.count('G'))>1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if('B' not in s and 'G' not in s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT m=-1 _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT li=[] _NEWLINE  _INDENT  _INDENT li2=[] _NEWLINE  _INDENT  _INDENT temp_li=[] _NEWLINE  _INDENT  _INDENT temp_li2=[] _NEWLINE  _INDENT  _INDENT if(s.count('B')>s.count('G')): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=1 _NEWLINE  _INDENT  _INDENT elif(s.count('B')<s.count('G')): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=-1 _NEWLINE  _INDENT  _INDENT for j in xrange(0,len(s),2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='B'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(m==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='G'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]==s[0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_li.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li.append(j) _NEWLINE  _INDENT  _INDENT if(m==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not temp_li: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not li: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if not li: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT for j in xrange(1,len(s),2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='B'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li2.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(m==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='G'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li2.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]==s[0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li2.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_li2.append(j) _NEWLINE  _INDENT  _INDENT if(typ==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT typ=0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT typ=1 _NEWLINE  _INDENT  _INDENT for j in xrange(0,len(li)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=(abs(li[j]-li2[j]))**(typ) _NEWLINE  _INDENT  _INDENT if(m==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(0,len(temp_li)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=(abs(temp_li[k]-temp_li2[k]))**(typ) _NEWLINE  _INDENT  _INDENT if(m==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print min(temp,ans) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT continue _INDENT 
for t in xrange(int(raw_input())): _NEWLINE 	n, m = map(int, raw_input().split()) _NEWLINE 	r, c = n, m _NEWLINE 	row = [] _NEWLINE 	col = [] _NEWLINE 	 _NEWLINE 	for i in xrange(m): _NEWLINE 		col.append("") _NEWLINE 	for i in xrange(n): _NEWLINE 		s = raw_input() _NEWLINE 		row.append(s) _NEWLINE 		for j in xrange(m): _NEWLINE 			col[j] += s[j] _NEWLINE 			 _NEWLINE 	for i in range(n): _NEWLINE 		if (row[i].count(".") == m): _NEWLINE 			r -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	for i in range(n-1,n-r-1,-1): _NEWLINE 		if (row[i].count(".") == m): _NEWLINE 			r -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	for i in range(m): _NEWLINE 		if (col[i].count(".") == n): _NEWLINE 			c -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	for i in range(m-1,m-c-1,-1): _NEWLINE 		if (col[i].count(".") == n): _NEWLINE 			c -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	if (r+c): _NEWLINE 		print max(r,c)/2+1 _NEWLINE 	else: _NEWLINE 		print 0
def r(): _NEWLINE 	return map(int,raw_input().split()) _NEWLINE def process(stack): _NEWLINE 	if len(stack)<k+1: _NEWLINE 		ans.extend(stack) _NEWLINE 		return _NEWLINE 	# print stack, _NEWLINE 	# global count _NEWLINE 	if len(stack)%(k+1)==0: _NEWLINE 		# print "as" _NEWLINE 		for i in range(k,len(stack)-1,k+1): _NEWLINE 			stack[i]=(stack[i]+1)%2 _NEWLINE 		stack[-2]=(stack[-2]+1)%2 _NEWLINE 	else: _NEWLINE 		for i in range(k,len(stack),k+1): _NEWLINE 			# print i _NEWLINE 			stack[i]=(stack[i]+1)%2 _NEWLINE 	# count+=((len(stack)+k)/(k+1)) _NEWLINE 	# print stack _NEWLINE 	ans.extend(stack) _NEWLINE for i in range(input()): _NEWLINE 	n,k = r() _NEWLINE 	arr = map(int,list(raw_input())) _NEWLINE 	if k==1: _NEWLINE 		s=[] _NEWLINE 		c=0 _NEWLINE 		for i in range(n): _NEWLINE 			s.append((c+1)%2) _NEWLINE 			c+=1 _NEWLINE 		s1=[] _NEWLINE 		c=1 _NEWLINE 		for i in range(n): _NEWLINE 			s1.append((c+1)%2) _NEWLINE 			c+=1 _NEWLINE 		ans1,ans2=0,0 _NEWLINE 		for i in range(n): _NEWLINE 			if arr[i]!=s1[i]: _NEWLINE 				ans2+=1 _NEWLINE 			if arr[i]!=s[i]: _NEWLINE 				ans1+=1 _NEWLINE 		s1=map(str,s1) _NEWLINE 		s=map(str,s) _NEWLINE 		if ans1<ans2: _NEWLINE 			print ans1 _NEWLINE 			print ''.join(s) _NEWLINE 		else: _NEWLINE 			print ans2 _NEWLINE 			print ''.join(s1) _NEWLINE 	else: _NEWLINE 		# print japasas _NEWLINE 		ans=[] _NEWLINE 		c=1 _NEWLINE 		count=0 _NEWLINE 		stack=[arr[0]] _NEWLINE 		for i in range(1,n): _NEWLINE 			if arr[i]==arr[i-1]: _NEWLINE 				stack.append(arr[i]) _NEWLINE 			else: _NEWLINE 				process(stack) _NEWLINE 				stack=[arr[i]] _NEWLINE 		# ans.extend(stack) _NEWLINE 		process(stack) _NEWLINE 		count=0 _NEWLINE 		for i in range(n): _NEWLINE 			if ans[i]!=arr[i]: _NEWLINE 				count+=1 _NEWLINE 		print count _NEWLINE 		ans=map(str,ans) _NEWLINE 		print ''.join(ans) _NEWLINE 
"""http://www.codechef.com/problems/ _NEWLINE Shortest path algorithm [x] _NEWLINE Dynamic programming _NEWLINE """ _NEWLINE  _NEWLINE import sys _NEWLINE from collections import deque _NEWLINE  _NEWLINE inf = int(pow(2,63) - 1) _NEWLINE  _NEWLINE def digdump(digits): _NEWLINE  _INDENT  _INDENT digits = convert(digits) _NEWLINE  _INDENT  _INDENT dtable = [inf,] * 10 _NEWLINE  _INDENT  _INDENT dist = [inf,] * len(digits) _NEWLINE  _INDENT  _INDENT dist[0] = 0 _NEWLINE  _INDENT  _INDENT dtable[digits[0]] = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(1, len(digits)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = digits[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev_cost = dist[i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prev_cost < dtable[d]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i] = prev_cost + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if d == digits[i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dtable[d] = prev_cost _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dtable[d] = prev_cost + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i] = dtable[d] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print dist[i], dtable[d] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # fix prev cost by step back _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prev_cost > dist[i] + 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i-1] = dist[i] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dist[i-1] < dtable[digits[i-1]]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dtable[digits[i-1]] = dist[i-1] _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print 'back', i, dist[i-1], d, prev_cost _NEWLINE  _INDENT  _INDENT # print dist, dtable _NEWLINE  _INDENT  _INDENT return dist[-1] _NEWLINE  _NEWLINE  _INDENT _NEWLINE def convert(line): _NEWLINE  _INDENT  _INDENT return [int(i) for i in line] _NEWLINE  _INDENT _NEWLINE  _NEWLINE def debug_dtab(group): _NEWLINE  _INDENT  _INDENT for i, v in enumerate(group): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print len(v) _NEWLINE  _NEWLINE  _NEWLINE def digjump_bfs(digits): _NEWLINE  _INDENT  _INDENT visited_digits.clear() _NEWLINE  _INDENT  _INDENT visited = set() _NEWLINE  _INDENT  _INDENT parent = [None,] * len(digits) _NEWLINE  _INDENT  _INDENT queue = deque() _NEWLINE  _INDENT  _INDENT tab = build_group(digits) _NEWLINE  _INDENT  _INDENT #debug_dtab(tab) _NEWLINE  _INDENT  _INDENT queue.append(0) _NEWLINE  _INDENT  _INDENT visited.add(0) _NEWLINE  _INDENT  _INDENT while queue: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = queue.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print 'node', node _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for child in gen_children(digits, tab, node, parent): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if child not in visited: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited.add(child) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print 'c', child _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[child] = node _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT queue.appendleft(child) _NEWLINE  _INDENT  _INDENT # Trace back _NEWLINE  _INDENT  _INDENT n = len(digits) - 1 _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while n != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = parent[n] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT return count _NEWLINE  _NEWLINE visited_digits = set() _NEWLINE  _NEWLINE def gen_children(digits, tab, i, parent): _NEWLINE  _INDENT  _INDENT if i > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yield i - 1 _NEWLINE  _INDENT  _INDENT if i < len(digits) - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yield i + 1 _NEWLINE  _INDENT  _INDENT d = digits[i] _NEWLINE  _INDENT  _INDENT if d not in visited_digits: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visited_digits.add(d) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT # if parent[i] is not None and digits[parent[i]] == digits[i]: _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT  return _NEWLINE  _INDENT  _INDENT for j in tab[d]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j not in (i, i-1, i+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield j _NEWLINE  _NEWLINE  _NEWLINE def build_group(digits): _NEWLINE  _INDENT  _INDENT tab = [] _NEWLINE  _INDENT  _INDENT for i in range(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tab.append(set()) _NEWLINE  _INDENT  _INDENT for i, d in enumerate(digits): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tab[d].add(i) _NEWLINE  _INDENT  _INDENT return tab _NEWLINE  _NEWLINE  _NEWLINE def test(): _NEWLINE  _INDENT  _INDENT # test_func = digdump _NEWLINE  _INDENT  _INDENT test_func = digjump_bfs _NEWLINE  _INDENT  _INDENT print test_func(convert('0')) _NEWLINE  _INDENT  _INDENT print test_func(convert('101')) _NEWLINE  _INDENT  _INDENT # print test_func(convert('0121344444434443')) _NEWLINE  _INDENT  _INDENT # print test_func(convert('01234567890')) _NEWLINE  _INDENT  _INDENT # print test_func(convert('0123410193837418926571657382471036517356173084')) _NEWLINE  _INDENT  _INDENT print test_func(convert('0998887776665554443322223300885577')) _NEWLINE  _INDENT  _INDENT print test_func(convert('099887730085577')) _NEWLINE # _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT import random _NEWLINE  _INDENT  _INDENT digits = [] _NEWLINE  _INDENT  _INDENT for i in xrange(pow(10, 6)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT digits.append(random.randint(0, 9)) _NEWLINE  _INDENT  _INDENT print 'starting..' _NEWLINE  _INDENT  _INDENT print test_func(digits) _NEWLINE # _INDENT  _INDENT ''' _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT line = raw_input().strip() _NEWLINE  _INDENT  _INDENT print digjump_bfs(convert(line)) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE main() _NEWLINE #test() _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	a=[0]*n;c=[0]*n;i=0 _NEWLINE 	while(i<n): _NEWLINE 		b=raw_input().split() _NEWLINE 		a[i]=b[0];c[i]=b[2:] _NEWLINE 		i+=1 _NEWLINE 	print "Begin on", _NEWLINE 	for j in c[n-1]: _NEWLINE 		print j, _NEWLINE 	print _NEWLINE 	i=n-2 _NEWLINE 	while(i>=0): _NEWLINE 		if(a[i+1]=='Left'): _NEWLINE 			print "Right on", _NEWLINE 			for j in c[i]: _NEWLINE 				print j, _NEWLINE 			print _NEWLINE 		elif(a[i+1]=='Right'): _NEWLINE 			print "Left on", _NEWLINE 			for j in c[i]: _NEWLINE 				print j, _NEWLINE 			print			 _NEWLINE 		i-=1
output = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	string1 = raw_input() _NEWLINE 	dstring = list() _NEWLINE 	for j in range(len(string1)) : _NEWLINE 		if string1[j] not in dstring : _NEWLINE 			dstring.append(string1[j]) _NEWLINE 	output.append(len(dstring)) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
#!/usr/bin/env python _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE parent = None _NEWLINE #child = dict() _NEWLINE  _NEWLINE def find_set(x): _NEWLINE  _INDENT  _INDENT global parent _NEWLINE  _INDENT  _INDENT while parent[x] != x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT parent[x] = parent[parent[x]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = parent[x] _NEWLINE  _INDENT  _INDENT return parent[x] _NEWLINE  _NEWLINE if __name__=='__main__': _NEWLINE  _INDENT  _INDENT t = int(sys.stdin.readline()) _NEWLINE  _NEWLINE  _INDENT  _INDENT while t > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT si = map(int, sys.stdin.readline().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT parent = range(n) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while q > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d = map(int, sys.stdin.readline().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = len(d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l, m = find_set(d[1]-1), find_set(d[2]-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l == m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Invalid query!" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif si[l] > si[m]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[m] = l _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif si[l] < si[m]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[l] = m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print find_set(d[1]-1) + 1 _NEWLINE 
for t in xrange(int(raw_input())): _NEWLINE 	n=int(raw_input()) _NEWLINE 	inp=raw_input() _NEWLINE 	inp=list(inp) _NEWLINE 	arr=[] _NEWLINE 	#print inp[0] _NEWLINE 	for i in xrange(n): _NEWLINE 		temp=list(inp) _NEWLINE 		ch=temp[i] _NEWLINE 		temp.pop(i) _NEWLINE 		for j in xrange(n-1): _NEWLINE 			if ord(temp[j]) > ord(ch): _NEWLINE 				temp.insert(j,ch) _NEWLINE 				temp=''.join(temp) _NEWLINE 				arr.append(temp) _NEWLINE 				break _NEWLINE 		temp=list(inp) _NEWLINE 		temp.insert(n,ch) _NEWLINE 		temp.pop(i) _NEWLINE 		temp=''.join(temp) _NEWLINE 		arr.append(temp) _NEWLINE 	print min(arr) _NEWLINE 
n = int(raw_input()) _NEWLINE stamp = map(int, raw_input().split()) _NEWLINE if sum(stamp[:]) == n*(n+1)/2: _NEWLINE 	print 'YES' _NEWLINE else: _NEWLINE 	print 'NO'
T = input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT N,M = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT A = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT A = sorted(A,reverse = False) _NEWLINE  _INDENT  _INDENT Reqd = M-1 _NEWLINE  _INDENT  _INDENT k = 0 _NEWLINE  _INDENT  _INDENT Total = 0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[k] + 1 < Reqd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Reqd -= (A[k] + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Total += A[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif A[k] + 1 == Reqd or A[k] == Reqd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Reqd = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Total += A[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Total += Reqd _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT print Total _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE 	n,a,b=map(int,raw_input().strip().split()) _NEWLINE 	a1=list(format(a,'0'+str(n)+'b')) _NEWLINE 	b1=list(format(b,'0'+str(n)+'b')) _NEWLINE 	a1.sort() _NEWLINE 	b1.sort(reverse=True) _NEWLINE 	c=[] _NEWLINE 	for i in xrange(len(a1)): _NEWLINE 		if a1[i]!=b1[i]:res='1' _NEWLINE 		else:res='0' _NEWLINE 		c.append(res) _NEWLINE 	c.sort(reverse=True)	 _NEWLINE 	final=''.join(c)	 _NEWLINE 	max_num=int(final,2) _NEWLINE 	print max_num _NEWLINE 	t-=1
n, k = map(int, raw_input().split()) _NEWLINE times = map(int, raw_input().split()) _NEWLINE times = sorted(zip(times, xrange(len(times))), key=lambda x: x[0]) _NEWLINE  _NEWLINE cnt, i = 0, 0 _NEWLINE while(i < n): _NEWLINE  _INDENT j = i+1 _NEWLINE  _INDENT while(j < n and times[i][0] == times[j][0] and times[j][1] - times[i][1] < k): _NEWLINE  _INDENT  j += 1 _NEWLINE  _INDENT cnt += 1 _NEWLINE  _INDENT i = j _NEWLINE print cnt _NEWLINE 
def solution(): _NEWLINE 	T = raw_input('') _NEWLINE 	answers = [] _NEWLINE 	for i in range(0,int(T)): _NEWLINE 		N,M = map(int,raw_input('').split(' ')) _NEWLINE 		power_of_soints = {} _NEWLINE 		power_of_sofloats = {} _NEWLINE 		for i in range(0,N): _NEWLINE 			power, level = map(int,raw_input('').split(' ')) _NEWLINE 			if level not in power_of_soints.keys(): _NEWLINE 				power_of_soints[level] = power _NEWLINE 			else: _NEWLINE 				power_of_soints[level] += power _NEWLINE 		for i in range(0,M): _NEWLINE 			power,level = map(int,raw_input('').split(' ')) _NEWLINE 			if level not in power_of_sofloats.keys(): _NEWLINE 				power_of_sofloats[level] = power _NEWLINE 			else: _NEWLINE 				power_of_sofloats[level] += power _NEWLINE 		if sum(power_of_soints.values()) == 0: _NEWLINE 			sochef += 1 _NEWLINE 		sochef = sochef_extra(power_of_soints,power_of_sofloats) _NEWLINE 		answers.append(sochef) _NEWLINE 	for i in answers: _NEWLINE 		print "%d"%(i) _NEWLINE  _NEWLINE def sochef_extra(dict1,dict2): _NEWLINE 	sochef = 0 _NEWLINE 	for i in dict1.keys(): _NEWLINE 		if dict1[i] < dict2[i]: _NEWLINE 			sochef += dict2[i] - dict1[i] _NEWLINE 	return sochef _NEWLINE solution()
import fractions _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT l = map(long, raw_input().split()) _NEWLINE  _INDENT  _INDENT a,b,c,d,k = l[0],l[1],l[2],l[3],l[4] _NEWLINE  _INDENT  _INDENT gcd1 = fractions.gcd(a,b) _NEWLINE  _INDENT  _INDENT gcd2 = fractions.gcd(c,d) _NEWLINE  _INDENT  _INDENT lcm = (gcd1*gcd2)/fractions.gcd(gcd1,gcd2) _NEWLINE  _INDENT  _INDENT ans = 2*(k/lcm)+1 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
137=2(2(2)+2+2(0))+2(2+2(0))+2(0) _NEWLINE 1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) _NEWLINE 73=2(2(2)+2)+2(2+2(0))+2(0) _NEWLINE 136=2(2(2)+2+2(0))+2(2+2(0)) _NEWLINE 255=2(2(2)+2+2(0))+2(2(2)+2)+2(2(2)+2(0))+2(2(2))+2(2+2(0))+2(2)+2+2(0) _NEWLINE 1384=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2)+2(2(2)+2(0))+2(2+2(0)) _NEWLINE 16385=2(2(2+2(0))+2(2)+2)+2(0)
import math _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT counter,rem=0,0 _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(rem>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[j]<=rem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem-=x[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif x[j]>rem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=counter _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=int(math.ceil((x[j]-rem)/float(k))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print ((x[j]-rem)/k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem=((counter-temp)*k)-(x[j]-rem) _NEWLINE  _INDENT  _INDENT print counter
import fractions _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT l = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT n = l[0] _NEWLINE  _INDENT  _INDENT change = l[1] _NEWLINE  _INDENT  _INDENT gcd = fractions.gcd(n,change) _NEWLINE  _INDENT  _INDENT if n/gcd == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No "+str(n/gcd) _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
# your code goes here _NEWLINE # your code goes here _NEWLINE import math _NEWLINE A=[] _NEWLINE t=int(raw_input()) _NEWLINE for u in range(0,t): _NEWLINE 	size=int(raw_input()) _NEWLINE 	A=map(int,raw_input().split()) _NEWLINE 	idli=[0]*(size+1) _NEWLINE 	count=0 _NEWLINE 	for k in A: _NEWLINE 		idli[k]+=1 _NEWLINE 		count =count+k _NEWLINE 	if(count%size!=0): _NEWLINE 		print("-1") _NEWLINE 	else: _NEWLINE 		i=0 _NEWLINE 		j=size _NEWLINE 		count=0 _NEWLINE 		while i<j: _NEWLINE 			while idli[i]==0: _NEWLINE 				i += 1 _NEWLINE 			while idli[j]==0: _NEWLINE 				j -= 1 _NEWLINE 			if(i==j): _NEWLINE 				break _NEWLINE 			r=int(math.ceil((j-i)/2)) _NEWLINE 		#	r=(j-i)/2 + (j-i)%2 _NEWLINE 		 _NEWLINE 			idli[j] -= 1 _NEWLINE 			idli[i] -= 1 _NEWLINE 			idli[j-r] += 1 _NEWLINE 			idli[i+r] += 1 _NEWLINE 			count += 1 _NEWLINE 		print(count) _NEWLINE 		 _NEWLINE 			 _NEWLINE 			 _NEWLINE 
T=int(raw_input()) _NEWLINE ans=[] _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT N=int(raw_input()) _NEWLINE  _INDENT  _INDENT perm=[] _NEWLINE  _INDENT  _INDENT raw_ans=raw_input() _NEWLINE  _INDENT  _INDENT raw_ans=raw_ans.split(' ') _NEWLINE  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT perm.append(int(raw_ans[j])) _NEWLINE  _INDENT  _INDENT perm=[int(j) for j in perm] _NEWLINE  _INDENT  _INDENT temp_ans=[] _NEWLINE  _NEWLINE  _INDENT  _INDENT sum_X=sum(perm)/(N-1) _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp_ans.append(sum_X-perm[i]) _NEWLINE  _INDENT  _INDENT ans.append(temp_ans) _NEWLINE for k in ans: _NEWLINE  _INDENT  _INDENT for l in k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print l, _NEWLINE  _INDENT  _INDENT print		 _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define ll long long int _NEWLINE #define ld long double _NEWLINE using namespace std; _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT int i,j,k,s[35],a[35],t,n,flag,p,temp,m,count; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[4]=4; s[6]=5; s[8]=12; s[9]=6; s[10]=7; s[12]=16; s[14]=9; s[15]=8; s[16]=32; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[18]=21; s[20]=24; s[21]=10; s[22]=13; s[24]=44; s[25]=10; s[26]=15; s[27]=27; s[28]=32; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[30]=31; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[2]=s[3]=s[5]=s[7]=s[11]=s[13]=s[17]=s[19]=s[23]=s[29]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%d",&n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  count=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  flag=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%d",&a[0]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  for(i=1;i<n;++i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]!=a[i-1]) flag=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  flag=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  if(flag==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("0\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  else _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[n]==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;++i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",i); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d\n",s[n]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=n; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(p=29;p>=2;p--) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[p]==0 && k%p==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  temp=p; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=k/p; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0;i<k;++i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",p); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i*p;j<(i+1)*p;++j) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",j+1); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=p;i>=2;--i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]==0 && k%i==0 _INDENT && k>1) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(j=1;j<=30;++j) a[j]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(j=1;j<=n;++j) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[j]==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d ",i); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(m=0;m<i;++m) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",j+m*temp); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j+m*temp]=1; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  temp=temp*i; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=k/i; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ++i; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE } _NEWLINE 
def sol(n): _NEWLINE  _INDENT  _INDENT if n>=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ((n+3)*(n+2)*(n+1))/6 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE  _NEWLINE for _ in range(input()): _NEWLINE  _INDENT  _INDENT n,a,b,c= map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print _INDENT sol(n)-sol(n-a-1)-sol(n-b-1)-sol(n-c-1)+sol(n-a-b-2)+sol(n-b-c-2)+sol(n-a-c-2)-sol(n-a-b-c-3)
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT a='010' _NEWLINE  _INDENT  _INDENT b='101' _NEWLINE  _INDENT  _INDENT x=s.find(a) _NEWLINE  _INDENT  _INDENT y=s.find(b) _NEWLINE  _INDENT  _INDENT if x!=-1 or y!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Good' _NEWLINE  _INDENT  _INDENT else:print 'Bad' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
T=input() _NEWLINE for i in xrange(T): _NEWLINE  _INDENT  _INDENT data=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT N=int(data[0]) _NEWLINE  _INDENT  _INDENT K=int(data[1]) _NEWLINE  _INDENT  _INDENT r=K _NEWLINE  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT nm=r _NEWLINE  _INDENT  _INDENT for j in xrange(1,N-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j==N-2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r=(m*K+nm*(K-1))%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m=nm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=(r*K)%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nm=r-m _NEWLINE  _INDENT  _INDENT print(r)
class unionFind: _NEWLINE 	def __init__(self, noOfClasses): _NEWLINE 		self.sets = [[-1, 1, 1] for i in range(noOfClasses)] _NEWLINE 		self.parentIndex 			= 0 _NEWLINE 		self.rankIndex 				= 1 _NEWLINE 		self.classElement			= 2 _NEWLINE 		self.noOfClasses 			= noOfClasses _NEWLINE 		self.noOfElements			= noOfClasses _NEWLINE  _NEWLINE 	def find(self, element): _NEWLINE 		if self.sets[element][self.parentIndex] == -1: _NEWLINE 			return element _NEWLINE 		self.sets[element][self.parentIndex] = self.find(self.sets[element][self.parentIndex]) _NEWLINE 		return self.sets[element][self.parentIndex] _NEWLINE  _NEWLINE 	def union(self, element1, element2): _NEWLINE 		parent1 = self.find(element1) _NEWLINE 		parent2 = self.find(element2) _NEWLINE  _NEWLINE 		if parent1 != parent2: _NEWLINE 			if self.sets[parent1][self.rankIndex] < self.sets[parent2][self.rankIndex]: _NEWLINE 				self.sets[parent1][self.parentIndex] = parent2 _NEWLINE 				self.sets[parent2][self.classElement] += self.sets[parent1][self.classElement] _NEWLINE 			elif self.sets[parent1][self.rankIndex] > self.sets[parent2][self.rankIndex]: _NEWLINE 				self.sets[parent2][self.parentIndex] = parent1 _NEWLINE 				self.sets[parent1][self.classElement] += self.sets[parent2][self.classElement] _NEWLINE 			else: _NEWLINE 				self.sets[parent1][self.parentIndex] = parent2 _NEWLINE 				self.sets[parent2][self.rankIndex] += 1 _NEWLINE 				self.sets[parent2][self.classElement] += self.sets[parent1][self.classElement] _NEWLINE  _NEWLINE 			self.noOfClasses -= 1 _NEWLINE  _NEWLINE 	def getNoOfClasses(self): _NEWLINE 		return self.noOfClasses _NEWLINE  _NEWLINE 	def getClassElements(self): _NEWLINE 		elements = list() _NEWLINE 		for i in range(self.noOfElements): _NEWLINE 			if self.sets[i][self.parentIndex] == -1: _NEWLINE 				elements.append(self.sets[i][self.classElement]) _NEWLINE 		return elements _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	import sys _NEWLINE 	test_cases = int(sys.stdin.readline()) _NEWLINE 	mod = 1000000007 _NEWLINE 	while test_cases > 0: _NEWLINE 		test_cases -= 1 _NEWLINE 		noOfEmp, noOfRel = map(int, sys.stdin.readline().split()) _NEWLINE 		uf = unionFind(noOfEmp) _NEWLINE 		for i in range(noOfRel): _NEWLINE 			frnd1, frnd2 = map(int, sys.stdin.readline().split()) _NEWLINE 			uf.union(frnd1 - 1, frnd2 - 1) _NEWLINE 		noOfClasses = uf.getNoOfClasses() _NEWLINE 		elements = uf.getClassElements() _NEWLINE 		ways = 1 _NEWLINE 		for i in elements: _NEWLINE 			ways = (ways * i) % mod _NEWLINE 		print noOfClasses, ways _NEWLINE 
from sys import stdin,stdout _NEWLINE n,w,l = map(int,stdin.readline().split(' ')) _NEWLINE h = [] _NEWLINE r = [] _NEWLINE for i in xrange(n): _NEWLINE 	a,b = map(int,stdin.readline().strip().split(' ')) _NEWLINE 	h.append(a) _NEWLINE 	r.append(b) _NEWLINE tl = 0 _NEWLINE th = 10000000000000000000 _NEWLINE while tl <= th: _NEWLINE 	cut = 0 _NEWLINE 	tm = (th+tl)/2 _NEWLINE 	for i in xrange(n): _NEWLINE 		if (h[i] + r[i]*tm) >= l: _NEWLINE 			cut += (h[i] + r[i]*tm) _NEWLINE 		if cut > w: _NEWLINE 			break _NEWLINE 	if cut < w: _NEWLINE 		tl = tm+1 _NEWLINE 	elif cut > w: _NEWLINE 		th = tm-1 _NEWLINE 	else: _NEWLINE 		break _NEWLINE cut = 0 _NEWLINE for i in xrange(n): _NEWLINE 		if (h[i] + r[i]*tm) >= l: _NEWLINE 			cut += (h[i] + r[i]*tm) _NEWLINE if cut < w: _NEWLINE 	tm += 1 _NEWLINE stdout.write(str(tm))
# Chef changed the password of his laptop a few days ago, but he can't remember it today. Luckily, he wrote the encrypted password on a piece of paper, along with the rules for decryption. _NEWLINE # The encrypted password is a string S consists of ASCII printable characters except space (ASCII 33 - 126, in decimal notation, the same below). Read here for more details: ASCII printable characters. _NEWLINE # Each rule contains a pair of characters ci, pi, denoting that every character ci appears in the encrypted password should be replaced with pi. Notice that it is not allowed to do multiple replacements on a single position, see example case 1 for clarification. _NEWLINE # After all the character replacements, the string is guaranteed to be a decimal number. The shortest notation of this number is the real password. To get the shortest notation, we should delete all the unnecessary leading and trailing zeros. If the number contains only non-zero decimal part, the integral part should be omitted (the shortest notation of "0.5" is ".5"). If the number contains zero decimal part, the decimal point should be omitted as well (the shortest notation of "5.00" is "5"). _NEWLINE # Please help Chef to find the real password. _NEWLINE  _NEWLINE # Input _NEWLINE # The first line of the input contains an interger T denoting the number of test cases. _NEWLINE # The description of T test cases follows. _NEWLINE # The first line of each test case contains a single interger N, denoting the number of rules. _NEWLINE # Each of the next N lines contains two space-separated characters ci and pi, _NEWLINE # denoting a rule. _NEWLINE # The next line contains a string S, denoting the encrypted password. _NEWLINE  _NEWLINE # Output _NEWLINE # For each test case, output a single line containing the real password. _NEWLINE  _NEWLINE # Constraints _NEWLINE # _INDENT  _INDENT  1 <= T <= 1000 _NEWLINE # _INDENT  _INDENT  0 <= N <= 94 _NEWLINE # _INDENT  _INDENT  All characters in S and ci may be any ASCII printable character except space. (ASCII 33 - 126) _NEWLINE # _INDENT  _INDENT  All ci in a single test case are distinct. _NEWLINE # _INDENT  _INDENT  pi is a digit ("0" - "9") or a decimal point "." (ASCII 46). _NEWLINE # _INDENT  _INDENT  The total length of S in a single input file will not exceed 106. _NEWLINE  _NEWLINE # Example _NEWLINE  _NEWLINE # Input: _NEWLINE # 4 _NEWLINE # 2 _NEWLINE # 5 3 _NEWLINE # 3 1 _NEWLINE # 5 _NEWLINE # 0 _NEWLINE # 01800.00 _NEWLINE # 0 _NEWLINE # 0.00100 _NEWLINE # 3 _NEWLINE # x 0 _NEWLINE # d 3 _NEWLINE # # . _NEWLINE # 0xd21#dd098x _NEWLINE  _NEWLINE # Output: _NEWLINE # 3 _NEWLINE # 1800 _NEWLINE # .001 _NEWLINE # 321.33098 _NEWLINE  _NEWLINE #Status - Successful _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE T=input() _NEWLINE S_list=[] _NEWLINE  _NEWLINE for testcases in xrange(T): _NEWLINE  _NEWLINE 	N=input() _NEWLINE 	#cp_list=[] _NEWLINE 	ci_list="" _NEWLINE 	pi_list="" _NEWLINE  _NEWLINE 	for rules in xrange(N): _NEWLINE  _NEWLINE 		ci,pi=sys.stdin.readline().split() _NEWLINE 		#cp_list.append([ci,pi]) _NEWLINE 		ci_list+=ci _NEWLINE 		pi_list+=pi _NEWLINE  _NEWLINE 	S=raw_input() _NEWLINE  _NEWLINE 	if N!=0: # If N == 0, saves len(S) loops _NEWLINE  _NEWLINE 		S=list(S) # To use assignment operator _NEWLINE 		for index in xrange(0,len(S)): _NEWLINE  _NEWLINE 			#char=S[index] _NEWLINE 			index2=ci_list.find(S[index]) _NEWLINE 			if index2 != -1: # Find first ci corresponding to char in S _NEWLINE 				S[index]=pi_list[index2] _NEWLINE 		S="".join(S) # Convert S back to string _NEWLINE  _NEWLINE 	if S.count('.')==0: # In case there is a number without decimal point. We don't want to rstrip it! _NEWLINE 		S=S.lstrip('0') _NEWLINE 	else: _NEWLINE 		S=S.strip('0') _NEWLINE 		S=S.rstrip('.') _NEWLINE 	if S=="": S="0" _NEWLINE 	S_list.append(S) _NEWLINE print '\n'.join(S_list)
def f(x): _NEWLINE  _INDENT  _INDENT return x[1] _NEWLINE n, k, p= map(int, raw_input().split()) _NEWLINE a = map(int, raw_input().split()) _NEWLINE l = [] #index, position, max_dist _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT l.append([i, a[i], 0]) _NEWLINE l = sorted(l, key = f, reverse = True) _NEWLINE #print l _NEWLINE l[0][2] = l[0][1] + k _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT if (l[i-1][1] - l[i][1] <= k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i][2] = l[i-1][2] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i][2] = l[i][1] + k _NEWLINE #print l _NEWLINE l = sorted(l) _NEWLINE #print l _NEWLINE for _ in range(p): _NEWLINE  _INDENT  _INDENT x,y = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if (l[x-1][2] == l[y-1][2]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE 
global FACT _NEWLINE FACT=[] _NEWLINE FACT.append(1) _NEWLINE for i in range(1,1001): _NEWLINE 	FACT.append(i*FACT[i-1]) _NEWLINE  _NEWLINE def nCr(n,r): _NEWLINE 	if n<r: _NEWLINE 		return 0 _NEWLINE 	else: _INDENT _NEWLINE 		return (FACT[n]/FACT[n-r]/FACT[r]) _NEWLINE 		 _NEWLINE t=input() _NEWLINE for _ in range(0,t): _NEWLINE 	s,n,m,k=map(int,raw_input().split(' ')) _NEWLINE 	ans=0 _NEWLINE 	if k==0: _NEWLINE 		print "1.000000" _NEWLINE 	elif s==n: _NEWLINE 		print "1.000000" _NEWLINE 	elif k>=n: _NEWLINE 		print "0.000000" _NEWLINE 	else: _NEWLINE 		if m>n: _NEWLINE 			p=n _NEWLINE 		else: _NEWLINE 			p=m _NEWLINE 		for j in range(k,m): _NEWLINE 			a=nCr(m-1,j) _NEWLINE 			b=nCr(s-m,n-j-1) _NEWLINE 			ans+=(a*b) _NEWLINE 		print"%.8f"%(ans/float(nCr(s-1,n-1))) _NEWLINE 
MAXINT = 1000000 _NEWLINE  _INDENT _NEWLINE from sys import stdin _NEWLINE  _INDENT _NEWLINE N, M = map(int, stdin.readline().split()) _NEWLINE AdjList = [[] for i in xrange(N)] _NEWLINE  _INDENT _NEWLINE for i in xrange(M): _NEWLINE 	A, B = map(int, stdin.readline().split()) _NEWLINE 	AdjList[A-1].append(B-1) _NEWLINE 	AdjList[B-1].append(A-1) _NEWLINE  _INDENT _NEWLINE C = [int(stdin.readline()) for i in xrange(N)] _NEWLINE  _INDENT _NEWLINE Visited = [0 for i in xrange(N)] _NEWLINE start = 0 _NEWLINE CCs = [] _NEWLINE  _INDENT _NEWLINE while True: _NEWLINE 	for i in xrange(start, N): _NEWLINE 		if not(Visited[i]): _NEWLINE 			start = i+1 _NEWLINE 			break _NEWLINE 	else: _NEWLINE 		break #No more unvisited planets _NEWLINE 	MinPosC = MAXINT _NEWLINE 	Buffer = [i] _NEWLINE 	Visited[i] = 1 _NEWLINE 	 _NEWLINE 	while Buffer: _NEWLINE 		i = Buffer.pop() _NEWLINE 		if 0 <= C[i] < MinPosC: _NEWLINE 			MinPosC = C[i] _NEWLINE 		for j in AdjList[i]: _NEWLINE 			if not(Visited[j]): _NEWLINE 				Buffer.append(j) _NEWLINE 				Visited[j] = 1 _NEWLINE 	CCs.append(MinPosC) _NEWLINE  _INDENT _NEWLINE CCsmin, CCsmax = min(CCs), max(CCs) _NEWLINE  _INDENT _NEWLINE if len(CCs) == 1: _NEWLINE 	print 0 _NEWLINE elif CCsmax == MAXINT: _NEWLINE 	print -1 _NEWLINE else: _NEWLINE 	print sum(CCs) + (len(CCs)-2)*min(CCs)
t = int(raw_input()) _NEWLINE  _NEWLINE def grundy(a,b): _NEWLINE  _INDENT  _INDENT if a==b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if b>a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = b,a _NEWLINE  _INDENT  _INDENT if a%b == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a/b - 1 _NEWLINE  _INDENT  _INDENT g = grundy(a%b, b) _NEWLINE  _INDENT  _INDENT if g>=(a/b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (a/b)-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (a/b) _NEWLINE  _NEWLINE  _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = map(int, (raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res ^= grundy(a,b) _NEWLINE  _INDENT  _INDENT if res: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
def iterF(arr,n,m,iter1): _NEWLINE 	#print "fyuv" _NEWLINE 	i=iter1;j=iter1;count=0 _NEWLINE 	while(i<n): _NEWLINE 		j=iter1 _NEWLINE 		while(j<m): _NEWLINE 			#print "i,j,iter",i,j,iter1 _NEWLINE 			if(arr[i][j]==arr[i][j-iter1] and arr[i][j]==arr[i-iter1][j]\ _NEWLINE 				and arr[i-iter1][j-iter1]==arr[i][j] ): _NEWLINE 				#print "i,j,iter",i,j,iter1,"trure re" _NEWLINE 				count+=1 _NEWLINE 			j+=1 _NEWLINE 		i+=1 _NEWLINE 	return count _NEWLINE  _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	arr=[[] for i in range(n)] _NEWLINE 	#print arr _NEWLINE 	i=0 _NEWLINE 	while(i<n): _NEWLINE 		arr[i][:]=list(raw_input()) _NEWLINE 		i+=1 _NEWLINE 	iter1=min(n,m) _NEWLINE 	i=1;count=0 _NEWLINE 	while(i<n): _NEWLINE 		count+=iterF(arr,n,m,i) _NEWLINE 		i+=1 _NEWLINE 	print count
from fractions import gcd _NEWLINE for i in xrange(input()): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print gcd(a,b) _NEWLINE 
t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT l=[0]*(n+1) _NEWLINE  _INDENT  _INDENT r=[0]*(n+1) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i],r[i]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT ans="" _NEWLINE  _INDENT  _INDENT while i<(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i+1]>=r[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L+"*(r[i]-l[i]-1)+"R+L+"*(l[i+1]-r[i]+1)+"R+"*(r[i+1]-l[i+1]-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=r[i] and l[i+1]>=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L+"*(l[i+1]-l[i])+"R+"*(r[i+1]-r[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=r[i] and l[i+1]<=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L-"*(l[i]-l[i+1]) +"R+"*(r[i+1]-r[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=l[i] and l[i+1]>=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L+"*(l[i+1]-l[i])+"R-"*(r[i]-r[i+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=l[i] and l[i+1]<=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L-"*(l[i]-l[i+1]) +"R-"*(r[i]-r[i+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L-"*(l[i]-l[i+1])+"R-"*(r[i]-r[i+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT print len(ans)/2 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT gf=map(int,raw_input().split(":")) _NEWLINE  _INDENT  _INDENT chef=map(int,raw_input().split(":")) _NEWLINE  _INDENT  _INDENT dist=input() _NEWLINE  _INDENT  _INDENT t1=(gf[0]-chef[0])*60+gf[1]-chef[1]+dist _NEWLINE  _INDENT  _INDENT t2=t1-dist _NEWLINE  _INDENT  _INDENT t2=float(t2) _NEWLINE  _INDENT  _INDENT dist=float(dist) _NEWLINE  _INDENT  _INDENT if 2*dist>t2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t2=t2+(2*dist-t2)/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT print float(t1),t2 _NEWLINE 
mod = 1000000007 _NEWLINE comb_cache = {} _NEWLINE def combinations(n, r): _NEWLINE  _INDENT  if r < (n // 2): r = n - r _NEWLINE  _INDENT  if (n, r) in comb_cache: return comb_cache[(n, r)] _NEWLINE  _INDENT  comb = 1 _NEWLINE  _INDENT  for i in xrange(r + 1, n + 1): comb *= i _NEWLINE  _INDENT  for i in xrange(1, n - r + 1): comb /= i _NEWLINE  _INDENT  comb_cache[(n, r)] = comb % mod _NEWLINE  _INDENT  return comb _NEWLINE  _NEWLINE F_cache = {} _NEWLINE A0, A1, A2, A3 = (0, 0, 0, 0) _NEWLINE def F(N): _NEWLINE  _INDENT  if N not in F_cache: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT F_cache[N] = (((A3 * N + A2) * N + A1) * N + A0) % mod _NEWLINE  _INDENT  return F_cache[N] _NEWLINE  _INDENT  _INDENT _NEWLINE meal = {} _NEWLINE def cook(N, S): _NEWLINE  _INDENT  if S == 0: return 1 _NEWLINE  _INDENT  if N == 0: return 0 _NEWLINE  _INDENT  if (N, S) in meal: return meal[(N, S)] _NEWLINE  _INDENT  food = 0 _NEWLINE  _INDENT  for rank in xrange(N, 0, -1): _NEWLINE  _INDENT  _INDENT  _INDENT for count in xrange(S // rank, 0, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  food = (food + combinations(F(rank) + count - 1, count) * cook(rank - 1, S - (rank * count))) % mod _NEWLINE  _INDENT  meal[(N, S)] = food _NEWLINE  _INDENT  return food _NEWLINE  _INDENT  _INDENT _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  A0, A1, A2, A3 = map(int, raw_input().split()) _NEWLINE  _INDENT  S = int(raw_input()) _NEWLINE  _INDENT  F_cache = {} _NEWLINE  _INDENT  meal = {} _NEWLINE  _INDENT  print cook(S, S)
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	s=raw_input().split(' ') _NEWLINE 	s1=s[0] _NEWLINE 	s2=s[1] _NEWLINE 	d1={} _NEWLINE 	d2={} _NEWLINE 	flag1=1 _NEWLINE 	flag2=1 _NEWLINE 	for i in range(len(s1)): _NEWLINE 		if d1.has_key(s1[i]): _NEWLINE 			d1[s1[i]]=d1[s1[i]]+1 _NEWLINE 		else: _NEWLINE 		 _INDENT  d1[s1[i]]=1 _NEWLINE 	for i in range(len(s2)): _NEWLINE 		if d2.has_key(s2[i]): _NEWLINE 			d2[s2[i]]=d2[s2[i]]+1 _NEWLINE 		else: _NEWLINE 		 _INDENT  d2[s2[i]]=1 _NEWLINE 	if len(d1) == len(d2): _NEWLINE 		for i in range(len(s2)): _NEWLINE 				if d1.has_key(s2[i]): _NEWLINE 					if d2[s2[i]]!=d1[s2[i]]: _NEWLINE 						flag1=0 _INDENT _NEWLINE 						break _NEWLINE  _NEWLINE 				else: _NEWLINE 					flag1=0 _NEWLINE 					break _NEWLINE 		for i in range(len(s2)): _NEWLINE 			if s2[i] not in d1: _NEWLINE 				flag2=0 _NEWLINE 				break _NEWLINE 		if flag1==flag2: _NEWLINE 			print "YES" _NEWLINE 		else: _NEWLINE 			print "NO" _NEWLINE 				 _NEWLINE 			 _NEWLINE 	else: _NEWLINE 		print "YES" _NEWLINE  _NEWLINE 	t=t-1 _NEWLINE  _NEWLINE  _NEWLINE 	 _NEWLINE 
import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT s = sys.stdin.readline _NEWLINE  _INDENT  _INDENT n = int(s()) _NEWLINE  _INDENT  _INDENT if n>=135: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT nums = map(int, s().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(k+1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nums[i]^nums[j]^nums[k]^nums[l]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT return _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE def test(): _NEWLINE  _NEWLINE 	L1 = raw_input() _NEWLINE 	L2 = raw_input() _NEWLINE  _NEWLINE 	d1 = [ch == '#' for ch in L1] _NEWLINE 	d2 = [ch == '#' for ch in L2] _NEWLINE  _NEWLINE 	data = zip(d1, d2) _NEWLINE 	possible = (True, True) not in data _NEWLINE  _NEWLINE 	print 'Yes' if possible else 'No' _NEWLINE  _NEWLINE 	if not possible: _NEWLINE 		return _NEWLINE  _NEWLINE 	# Filter out cells where both slots are open _NEWLINE 	data = filter(lambda pair: pair != (False, False), data) _NEWLINE  _NEWLINE 	count = 0 _NEWLINE 	if len(data): _NEWLINE 		last = data[0] _NEWLINE 		for cell in data: _NEWLINE 			if cell != last: _NEWLINE 				count += 1 _NEWLINE 				last = cell _NEWLINE  _NEWLINE 	print count _NEWLINE  _NEWLINE for x in range(0, T): _NEWLINE 	test()
for i in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT arr = [] _NEWLINE  _INDENT  _INDENT dp = [[-2 for i in range(n)] for j in range(n)] _NEWLINE  _INDENT  _INDENT for c in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append(list(raw_input())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n - 1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[c][j] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[c][j] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n - 1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[j][i] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j][i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dp[i][j] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT print count _NEWLINE 
from __future__ import division _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tokens = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT default , talktime, addons _INDENT = _INDENT float(tokens[0]), int(tokens[1]), int(tokens[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT defaultCost = round(talktime * default,3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bestPlan = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bestPlanVal = defaultCost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for plan in range(addons): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tokens = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT months, rate, cost _INDENT = int(tokens[0]), float(tokens[1]), int(tokens[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT planCost _INDENT = talktime * rate + cost/months _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT planCost = round(planCost, 3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print planCost, defaultCost _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if planCost < bestPlanVal : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestPlan = plan + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestPlanVal = planCost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print bestPlan _NEWLINE  _NEWLINE main() _NEWLINE 
def f(ar): _NEWLINE 	ax,ay,bx,by,cx,cy = ar _NEWLINE 	area = abs(ax*(by-cy)+bx*(cy-ay)+cx*(ay-by))/2.0 _NEWLINE 	return area _NEWLINE 	 _NEWLINE mix=10000000000000 _NEWLINE mii=0 _NEWLINE max=0 _NEWLINE mai=0 _NEWLINE for i in range(int(raw_input())): _NEWLINE 	a= f([int(x) for x in raw_input().split()]) _NEWLINE 	if a<=mix: _NEWLINE 		mix=a _NEWLINE 		mii=i+1 _NEWLINE 	if a>=max: _NEWLINE 		max=a _NEWLINE 		mai=i+1 _NEWLINE print mii,mai _INDENT _NEWLINE 
def solve(n, horse): _NEWLINE  _INDENT  _INDENT horse.sort() _NEWLINE  _INDENT  _INDENT res = horse[1]-horse[0] _NEWLINE  _INDENT  _INDENT for h in range(1,n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = min(res, horse[h+1]-horse[h]) _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE def horses(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT horse = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(n, horse) _NEWLINE  _INDENT _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT horses() _INDENT _NEWLINE 
a=[[0 for i in xrange(1001)] for y in range(1001)] _NEWLINE  _NEWLINE def row(i,j): _NEWLINE  _INDENT  _INDENT for k in xrange(1001-j-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i][k+j+1]=2 _NEWLINE  _NEWLINE def col(i,j): _NEWLINE  _INDENT  _INDENT for k in xrange(1001-i-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[k+i+1][j]=2 _NEWLINE  _NEWLINE def diag(i,j): _NEWLINE  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT j=j+1 _NEWLINE  _INDENT  _INDENT while(i<1001)and(j<1001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=j+1 _NEWLINE  _NEWLINE def main(): _NEWLINE 	test=input() _NEWLINE 	for i in xrange(1001): _NEWLINE 		for j in xrange(1001): _NEWLINE 			if(a[i][j]==0): _NEWLINE 				a[i][j]=1 _NEWLINE 				row(i,j) _NEWLINE 				col(i,j) _NEWLINE 				diag(i,j) _NEWLINE 	for t in xrange(test): _NEWLINE 		m,n,p,q=map(int,raw_input().split()) _NEWLINE 		if(a[m-p][n-q]==1): _NEWLINE 			print "Bob" _NEWLINE 		else: _NEWLINE 			print "Alice" _NEWLINE 	return 0 _NEWLINE 	 _NEWLINE if __name__ == '__main__': _NEWLINE 	main() _NEWLINE 
 _NEWLINE def initialArray(matrix, n, letter): _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if matrix[i][j] == letter: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield (i,j) _NEWLINE  _NEWLINE def nextMove(matrix, n, pos, letter): _NEWLINE  _INDENT  _INDENT for d in diagonals: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nm = nextMove1(matrix, n, pos, letter, d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if nm != None: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield nm _NEWLINE  _NEWLINE def nextMove1(matrix, n, pos, letter, delta): _NEWLINE  _INDENT  _INDENT x,y = pos[0]+delta[0], pos[1]+delta[1] _NEWLINE  _INDENT  _INDENT if 0 <= x < n and _INDENT 0 <= y < n and letter == matrix[x][y]: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (x,y) _NEWLINE  _NEWLINE def flatten(lst): _NEWLINE  _INDENT  _INDENT for elem in lst: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in elem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield i _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _NEWLINE  _INDENT  _INDENT matrix = [] _NEWLINE  _INDENT  _INDENT diagonals = [(-1,-1),(1,-1),(-1,1),(1,1)] _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT matrix.append(raw_input().strip().split(' ')) _NEWLINE  _NEWLINE  _INDENT  _INDENT hladaj = raw_input().strip() _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT for i in xrange(0,len(hladaj)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = list(initialArray(matrix, n, hladaj[i])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = list(flatten(nextMove(matrix, n, pos, hladaj[i]) for pos in l)) _NEWLINE  _NEWLINE  _INDENT  _INDENT print len(l)
n=int(raw_input()) _NEWLINE x=list(map(int,raw_input().split())) _NEWLINE cost=int(raw_input()) _NEWLINE neg=[abs(i) for i in x if i<0] _NEWLINE neg.sort() _NEWLINE total=len(neg) _NEWLINE ans=0 _NEWLINE if total==0: _NEWLINE  _INDENT  _INDENT print "0" _NEWLINE elif x==0: _NEWLINE  _INDENT  _INDENT print "0" _NEWLINE elif total==1: _NEWLINE  _INDENT  _INDENT print neg[0] _NEWLINE elif total<=cost: _NEWLINE  _INDENT  _INDENT print sum(neg) _NEWLINE else: _NEWLINE  _INDENT  _INDENT ans=neg[-1]*cost _NEWLINE  _INDENT  _INDENT arr=[neg[0]] _NEWLINE  _INDENT  _INDENT for i in range(1,total): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append(arr[i-1]+neg[i]) _NEWLINE  _INDENT  _INDENT for i in range(total): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=min(ans,neg[i]*cost+arr[-1]-arr[i]-(neg[i]*(total-1-i))) _NEWLINE  _INDENT  _INDENT print ans
t = input() _NEWLINE while(t>0): _NEWLINE 	p,s =map(int, list(raw_input().split())) _NEWLINE 	a = (p-pow(p*p-24*s,0.5))/12 _NEWLINE 	b = (p+pow(p*p-24*s,0.5))/12 _NEWLINE 	h = (p-8*a)/4 _NEWLINE 	h1 = (p-8*b)/4 _NEWLINE 	v= a*a*h _NEWLINE 	v1 = b*b*h1 _NEWLINE 	if( v>v1 ): _NEWLINE 		print("%.2f" % v) _NEWLINE 	else: _NEWLINE 		print("%.2f" % v1) _NEWLINE 	t-=1
for i in range(input()): _NEWLINE 	n = input() _NEWLINE 	a= map(int,raw_input().split()) _NEWLINE 	c=a[input()-1] _NEWLINE 	a=sorted(a) _NEWLINE 	while(n>0): _NEWLINE 		if(a[n-1]==c): _NEWLINE 			print n _NEWLINE 			break _NEWLINE 		n-=1 _NEWLINE 
import sys _NEWLINE  _NEWLINE def F(x): _NEWLINE 	return (x-1)%9+1 _NEWLINE  _NEWLINE T =int(sys.stdin.readline()) _NEWLINE  _NEWLINE for t in range(T): _NEWLINE 	inp =sys.stdin.readline().split() _NEWLINE 	A, D, L, R = int(inp[0]), int(inp[1]), int(inp[2])-1, int(inp[3])-1 _NEWLINE 	sum_per9 =0; _NEWLINE 	for i in range(1,10): sum_per9 +=F(A+D*i) _NEWLINE 	ans =0 _NEWLINE 	while (R-L+1)%9 != 0: _NEWLINE 		ans +=F(A+D*R) _NEWLINE 		R -=1 _NEWLINE 	ans +=sum_per9*(R-L+1)//9 _NEWLINE 	sys.stdout.write(str(ans)+"\n")
t=input() _NEWLINE def function(l,i,j): _NEWLINE 	if i>=j: _NEWLINE 		return 0 _NEWLINE 		 _NEWLINE 	if l[j]-l[i]<=k: _NEWLINE 		return 0 _NEWLINE  _NEWLINE 	if mat[i][j]!=-1: _NEWLINE 		return mat[i][j] _NEWLINE  _NEWLINE 	count1=l[i] _NEWLINE 	count1+=function(l,i+1,j) _NEWLINE  _NEWLINE 	count2=l[j]-l[i]-k _NEWLINE 	count2+=function(l,i,j-1) _NEWLINE 	mat[i][j]=min(count1,count2) _NEWLINE 	return mat[i][j] _NEWLINE 	#mat[i][j]=min(l[i]+mat[i+1][j],mat[i][j-1]+l[j]-l[i]-k) _NEWLINE  _NEWLINE def find_kgood(word,k): _NEWLINE 	a={} _NEWLINE 	for i in word: _NEWLINE 		if i in a: _NEWLINE 			a[i]+=1 _NEWLINE 		else: _NEWLINE 			a[i]=1 _NEWLINE 	l=sorted([a[i] for i in a]) _NEWLINE 	res=function(l,0,len(l)-1) _NEWLINE 	return res _NEWLINE  _NEWLINE  _NEWLINE while(t>0): _NEWLINE 	word,k=raw_input().strip().split() _NEWLINE 	mat=[[-1 for i in range(26)] for j in range(26)] _NEWLINE 	#mat[0][0]=0 _NEWLINE 	#mat[] _NEWLINE 	k=int(k) _NEWLINE 	print find_kgood(word,k) _NEWLINE 	t-=1 _NEWLINE  _NEWLINE  _NEWLINE 
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT num=min(arr) _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT done=False _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT for each in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if each==num and done==False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT done=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=num*each _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print sum _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
def check(a): _NEWLINE 	v = ord(a[0])-ord(a[3]) _NEWLINE 	u = ord(a[1])-ord(a[4]) _NEWLINE 	if((abs(v)==1 and abs(u)==2)or(abs(v)==2 and abs(u)==1)): _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No" _NEWLINE def check2(a): _NEWLINE 	w=ord(a[0])-96 _NEWLINE 	x=ord(a[3])-96 _NEWLINE 	y=ord(a[1])-48 _NEWLINE 	z=ord(a[4])-48 _NEWLINE 	if((w<=8 and w>=1)and(x<=8 and x>=1)and(y<=8 and y>=1)and(z<=8 and z>=1)): _NEWLINE 		return True _NEWLINE 	else: _NEWLINE 		return False _NEWLINE def main(): _NEWLINE 	t = input() _NEWLINE 	for i in range(t): _NEWLINE 		a = raw_input() _NEWLINE 		if(len(a)!=5): _NEWLINE 			print "Error" _NEWLINE 		elif (not(a[1].isdigit() and a[4].isdigit() and a[0].isalpha() and a[3].isalpha() and a[2]=='-' and check2(a) )): _NEWLINE 			print "Error" _NEWLINE 		else: _NEWLINE 			check(a) _NEWLINE if(__name__=="__main__"): _NEWLINE 	main() _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #define MOD 10000000 _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int T, N, sum, values[1000],i,j; _NEWLINE  _INDENT long long dp[10001],total; _NEWLINE  _INDENT scanf("%d",&T); _NEWLINE  _INDENT while(T--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%d",&N); _NEWLINE  _INDENT  _INDENT sum = 0; _NEWLINE  _INDENT  _INDENT for(i=0; i<N; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d",&values[i]); _NEWLINE  _INDENT  _INDENT  _INDENT sum += values[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0; i<=sum; i++) _NEWLINE  _INDENT  _INDENT  dp[i] = 0; _NEWLINE  _INDENT  _INDENT dp[0] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0; i<N; i++) //coin-change DP _NEWLINE  _INDENT  _INDENT  for(j=sum; j>=0; j--) _NEWLINE  _INDENT  _INDENT  _INDENT if(dp[j] > 0 )//&& j + values[i] <= sum) _NEWLINE  _INDENT  _INDENT  _INDENT  dp[j + values[i]] = ((dp[j+values[i]]) + (dp[j]))%MOD; _NEWLINE  _NEWLINE  _INDENT  _INDENT total = 0; _NEWLINE  _INDENT  _INDENT for(i=0; i<=sum; i++) _NEWLINE  _INDENT  _INDENT  if(dp[i] > 0) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  long long inc = ((long long)((((long long)abs(sum - 2*i))) * (dp[i])))%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  total = (total + inc)%MOD; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT printf("%ld\n",total); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long llu; _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT FIO _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a>>b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector<int> ca(26,0),cb(26,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool poss = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<a.length()&&i<d; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i; j<n; j+=d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ca[a[j]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cb[b[j]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0; j<26; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ca[j]!=cb[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT poss = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ca[j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cb[j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!poss) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<(poss?"Yes":"No")<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //Author: Sharad Chandran _NEWLINE #define lld long long int _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //Handle: sharad07 _NEWLINE #define llu unsigned long long int _NEWLINE #define pb(x) push_back(x) _NEWLINE #define pii pair<int,int> _NEWLINE #define pll pair<lld,lld> _NEWLINE #define pq priority_queue<int> _INDENT _NEWLINE #define mp(x,y) make_pair(x,y) _NEWLINE #define sz size() _NEWLINE #define inp1(x) scanf("%lld",&x) _NEWLINE #define inp2(x,y) scanf("%lld%lld",&x,&y) _NEWLINE #define inp3(x,y,z) scanf("%d%d%d",&x,&y,&z) _NEWLINE #define print(x) printf("%d",x) _NEWLINE #define println(x) printf("%lld\n",x) _NEWLINE #define _for(i,x,y) for(int i=x;i<y;i++) _NEWLINE using namespace std; _NEWLINE const int maxx=1e5+2; _NEWLINE lld mod=1e9+7; _NEWLINE lld A[maxx],C[102][102]; _NEWLINE lld k,sum[102][maxx],flag,n,Pow[102][maxx]; _NEWLINE  _INDENT _NEWLINE inline bool cmp(const lld &a,const lld &b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return a>b?1:0; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline lld neg_mod(lld &num) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(num>mod) num-=(num/mod)*mod; _INDENT _NEWLINE  _INDENT  _INDENT else if(num<0) _INDENT _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lld temp=-num,quo; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT quo=temp/mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(quo*mod!=temp) quo++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=quo*mod-temp; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld modPow(lld a, lld x, lld p) _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT //calculates a^x mod p in logarithmic time. _NEWLINE  _INDENT  _INDENT lld res = 1; _NEWLINE  _INDENT  _INDENT while(x > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( x % 2 != 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = (res * a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = (a * a) % p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld modInverse(lld a, lld p) _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT return modPow(a, p-2, p); _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld nCr(lld n, lld k, lld p) // calculates C(n,k) mod p (assuming p is prime). _NEWLINE { _NEWLINE  _INDENT  _INDENT lld numerator = 1; _INDENT _NEWLINE  _INDENT  _INDENT for (lld i=0; i<min(k,p); i++) _INDENT _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT numerator = (numerator * (n-i) ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(numerator); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lld denominator = 1; _INDENT _NEWLINE  _INDENT  _INDENT for (lld i=1; i<=min(k, p); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT denominator = (denominator * i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(denominator); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT lld ans=numerator* modInverse(denominator,p); _NEWLINE  _INDENT  _INDENT neg_mod(ans); _NEWLINE  _INDENT  _INDENT return _INDENT ans; _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld calc(int r) _NEWLINE { _NEWLINE  _INDENT  _INDENT lld ans=0,coeff=C[k][r]; _NEWLINE  _INDENT  _INDENT _for(i,0,n-1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans+Pow[k-r][i]*sum[r][i+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans*=coeff; _NEWLINE  _INDENT  _INDENT neg_mod(ans); _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void solve() _INDENT //..O(NK +NlogN) _NEWLINE { _NEWLINE  _INDENT  _INDENT inp2(n,k); _NEWLINE  _INDENT  _INDENT _for(i,0,n) _INDENT _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inp1(A[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Pow[0][i]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sort(A,A+n,cmp); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT _for(i,0,k+1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i>0) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Pow[i][n-1]=Pow[i-1][n-1]*A[n-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(Pow[i][n-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum[i][n-1]=Pow[i][n-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=n-2;j>=0;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Pow[i][j]=Pow[i-1][j]*A[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(Pow[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum[i][j]=sum[i][j+1]+Pow[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(sum[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lld res=0; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT for(int r=0;r<=k;r++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=res+calc(r)*flag; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag*=-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT res=(res*2)%mod; _NEWLINE  _INDENT  _INDENT println(res); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT inp1(t); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT _for(i,0,101) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _for(j,0,i+1) C[i][j]=nCr(i,j,mod); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT solve(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
import java.io.OutputStreamWriter; _NEWLINE import java.io.BufferedWriter; _NEWLINE import java.util.Comparator; _NEWLINE import java.io.OutputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.RandomAccess; _NEWLINE import java.util.AbstractList; _NEWLINE import java.io.Writer; _NEWLINE import java.util.List; _NEWLINE import java.io.IOException; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE import java.math.BigInteger; _NEWLINE import java.io.InputStream; _NEWLINE import java.util.ArrayList; _NEWLINE import java.util.Collection; _NEWLINE import java.util.HashMap; _NEWLINE import java.util.Map; _NEWLINE import java.util.Iterator; _NEWLINE import java.util.Random; _NEWLINE import java.math.BigInteger; _NEWLINE import java.io.InputStreamReader; _NEWLINE import java.io.BufferedReader; _NEWLINE import java.math.BigDecimal; _NEWLINE import java.text.DecimalFormat; _NEWLINE import java.util.Stack; _NEWLINE  _NEWLINE public class Main _INDENT _NEWLINE { _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		InputStream inputStream = System.in; _NEWLINE 		OutputStream outputStream = System.out; _NEWLINE  _NEWLINE 		InputReader in = new InputReader(inputStream); _NEWLINE 		OutputWriter out = new OutputWriter(outputStream); _NEWLINE 		SaveTheTrees solver = new SaveTheTrees(); _NEWLINE 		int T = in.readInt(); _NEWLINE 		for(int count = 0; count < T; count++) _NEWLINE 		{ _NEWLINE 			solver.solve(count+1, in, out);			 _NEWLINE 		} _NEWLINE 		out.close(); _NEWLINE  _NEWLINE 	}//end of main() _NEWLINE } _NEWLINE  _INDENT _NEWLINE class SaveTheTrees _INDENT _NEWLINE { _NEWLINE 	int N; _NEWLINE 	int[] A; _NEWLINE 	Point2D[] points; _NEWLINE  _NEWLINE 	public void solve(int testNumber, InputReader in, OutputWriter out) throws Exception _NEWLINE 	{ _NEWLINE 		N = in.readInt(); _NEWLINE 		A = new int[N]; _NEWLINE  _NEWLINE 		for(int count = 0; count < N; count++) _NEWLINE 		{ _NEWLINE 			A[count] = in.readInt(); _NEWLINE 		} _NEWLINE  _NEWLINE 		int numOfPoints = (N*2 - 3); _NEWLINE 		points = new Point2D[numOfPoints]; _NEWLINE 		 _NEWLINE 		long[] yMin = new long[N]; _NEWLINE 		long[] yMax = new long[N]; _NEWLINE 		yMin[N-1] = A[N-1]; _NEWLINE 		yMax[N-1] = A[N-1]; _NEWLINE 		for(int count = N-2; count >= 0; count--) { _NEWLINE 			yMin[count] = Math.min(yMin[count+1], A[count+1]); _NEWLINE 			yMax[count] = Math.max(yMax[count+1], A[count+1]); _NEWLINE 		} _NEWLINE  _NEWLINE 		int pointCount = 0; _NEWLINE 		for(int xCount = 0; xCount < N-2; xCount++) { _NEWLINE 			points[pointCount] = new Point2D(A[xCount], yMin[xCount]); _NEWLINE 			//System.out.println(points[pointCount]); _NEWLINE 			points[pointCount+1] = new Point2D(A[xCount], yMax[xCount]); _NEWLINE 			//System.out.println(points[pointCount+1]); _NEWLINE 			pointCount+=2; _NEWLINE 		} _NEWLINE 		points[pointCount] = new Point2D(A[N-2], A[N-1]); _NEWLINE 		//System.out.println(points[pointCount]); _NEWLINE 		//System.out.println(pointCount+1); _NEWLINE 		out.print(getArea(points, out) + "\n");		 _NEWLINE 		//long ans = getSchedule(X, Y, N); _NEWLINE 		//out.print(ans + "\n"); _NEWLINE  _NEWLINE 	}//end of solve() _NEWLINE  _NEWLINE 	public long getArea(Point2D[] points, OutputWriter out) _NEWLINE 	{ _NEWLINE 		GrahamScan gs = new GrahamScan(); _NEWLINE 		gs.grahamScan(points); _NEWLINE 		Point2D[] hull = gs.getCCWHull(); _NEWLINE 		long area = 0; _NEWLINE 		for(int count = 1; count < hull.length; count++) { _NEWLINE 			area += ((hull[count-1].x * hull[count].y) - (hull[count-1].y * hull[count].x)); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return Math.abs(area); _NEWLINE 	} _NEWLINE  _NEWLINE }//end of class SaveTheTrees _NEWLINE  _NEWLINE class InputReader _INDENT _NEWLINE { _NEWLINE 	private InputStream stream; _NEWLINE 	private byte[] buf = new byte[1024]; _NEWLINE 	private int curChar; _NEWLINE 	private int numChars; _NEWLINE  _INDENT _NEWLINE 	public InputReader(InputStream stream) _INDENT _NEWLINE 	{ _NEWLINE 		this.stream = stream; _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public int read() _INDENT _NEWLINE 	{ _NEWLINE 		if (numChars == -1) _NEWLINE 			throw new InputMismatchException(); _NEWLINE 		if (curChar >= numChars) _INDENT _NEWLINE 		{ _NEWLINE 			curChar = 0; _NEWLINE 			try _INDENT _NEWLINE 			{ _NEWLINE 				numChars = stream.read(buf); _NEWLINE 			} _INDENT _NEWLINE 			catch (IOException e) _INDENT _NEWLINE 			{ _NEWLINE 				throw new InputMismatchException(); _NEWLINE 			} _NEWLINE  _NEWLINE 			if (numChars <= 0) _NEWLINE 				return -1; _NEWLINE 		} _NEWLINE 		return buf[curChar++]; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int readInt() _INDENT _NEWLINE 	{ _NEWLINE 		int c = read(); _NEWLINE  _NEWLINE 		while (isSpaceChar(c)) _NEWLINE 			c = read(); _NEWLINE  _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-') _INDENT _NEWLINE 		{ _NEWLINE 			sgn = -1; _NEWLINE 			c = read(); _NEWLINE 		} _NEWLINE  _NEWLINE 		int res = 0; _NEWLINE 		do _INDENT _NEWLINE 		{ _NEWLINE 			if (c < '0' || c > '9') _NEWLINE 				throw new InputMismatchException(); _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read(); _NEWLINE 		} _INDENT _NEWLINE 		while (!isSpaceChar(c)); _NEWLINE  _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _NEWLINE 	public String readString() _INDENT _NEWLINE 	{ _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		int c = read(); _NEWLINE 		while (isWhiteSpace(c)) _INDENT _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT c = read(); _NEWLINE 		} _NEWLINE  _NEWLINE 		while (!isWhiteSpace(c)) _INDENT _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT sb.appendCodePoint(c); _NEWLINE 		 _INDENT  _INDENT c = read(); _NEWLINE 		} _NEWLINE  _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE  _NEWLINE 	public static boolean isWhiteSpace(int c) _INDENT _NEWLINE 	{ _NEWLINE 		return c >= -1 && c <= 32; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public static boolean isSpaceChar(int c) _INDENT _NEWLINE 	{ _NEWLINE 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE class OutputWriter _INDENT _NEWLINE { _NEWLINE 	private final PrintWriter writer; _NEWLINE 	 _INDENT _NEWLINE 	public OutputWriter(OutputStream outputStream) _INDENT _NEWLINE 	{ _NEWLINE 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public OutputWriter(Writer writer) _INDENT _NEWLINE 	{ _NEWLINE 		this.writer = new PrintWriter(writer); _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public void print(Object...objects) _INDENT _NEWLINE 	{ _NEWLINE 		for (int i = 0; i < objects.length; i++) _INDENT _NEWLINE 		{ _NEWLINE 			if (i != 0) _NEWLINE 				writer.print(' '); _NEWLINE 			writer.print(objects[i]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public void printLine(Object...objects) _INDENT _NEWLINE 	{ _NEWLINE 		print(objects); _NEWLINE 		writer.println(); _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public void close() _INDENT _NEWLINE 	{ _NEWLINE 		writer.close(); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE class GrahamScan { _NEWLINE 	Stack<Point2D> hull = new Stack<Point2D>(); _NEWLINE 	 _NEWLINE 	public void grahamScan(Point2D[] points) { _NEWLINE 		int pointsCount = points.length; _NEWLINE 	 _NEWLINE 		// sort by y-coordinate _NEWLINE 		Arrays.sort(points); _NEWLINE 		 _NEWLINE 		// sort by points[0].polarOrder _NEWLINE 		Arrays.sort(points, 1, pointsCount, points[0].polarOrder()); _NEWLINE 		 _NEWLINE 		hull.push(points[0]); _NEWLINE 		 _NEWLINE 		// find index k1 such that points[0] != points[k1] _NEWLINE 		int k1; _NEWLINE 		for(k1 = 1; k1 < pointsCount; k1++) { _NEWLINE 			if(!points[k1].equals(points[0])) { _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// if all points co-incide _NEWLINE 		if (k1 == pointsCount) { _NEWLINE 			return; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// find index k2 such that points[0], points[k1], points[k2] are non-collinear _NEWLINE 		int k2; _NEWLINE 		for(k2 = k1+1; k2 < pointsCount; k2++) { _NEWLINE 			if(Point2D.ccw(points[0], points[k1], points[k2]) != 0) { _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// points[k2-1] is the second extreme point _NEWLINE 		hull.push(points[k2-1]); _NEWLINE 		 _NEWLINE 		for(; k2 < pointsCount; k2++) { _NEWLINE 			Point2D top = hull.pop(); _NEWLINE 			while(Point2D.ccw(hull.peek(), top, points[k2]) <= 0) { _NEWLINE 				top = hull.pop(); _NEWLINE 			} _NEWLINE 			hull.push(top); _NEWLINE 			hull.push(points[k2]); _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public Point2D[] getCCWHull() { _NEWLINE 		Point2D[] ccwHull = new Point2D[hull.size() + 1]; _NEWLINE 		int count = hull.size(); _NEWLINE 		while(count > 0) { _NEWLINE 			ccwHull[count-1] = hull.pop(); _NEWLINE 			count--; _NEWLINE 		} _NEWLINE 		ccwHull[ccwHull.length - 1] = ccwHull[0]; _NEWLINE 		 _NEWLINE 		return ccwHull; _NEWLINE 	} _NEWLINE  _NEWLINE }// end of Graham Scan _NEWLINE  _NEWLINE class Point2D implements Comparable<Point2D> { _NEWLINE 	long x, y; _NEWLINE 	 _NEWLINE 	public Point2D(long x, long y) { _NEWLINE 		this.x = x; _NEWLINE 		this.y = y; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public int compareTo(Point2D that) { _NEWLINE 		if (this.y < that.y) return -1; _NEWLINE 		if (this.y > that.y) return 1; _NEWLINE 		if (this.x < that.x) return -1; _NEWLINE 		if (this.x > that.x) return 1; _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public boolean equals(Object other) { _NEWLINE 		if (this == other) return true; _NEWLINE 		if (other == null) return false; _NEWLINE 		if (this.getClass() != other.getClass()) return false; _NEWLINE 		Point2D that = (Point2D) other; _NEWLINE 		return this.x == that.x && this.y == that.y; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public int hashCode() { _NEWLINE 		int hashX = ((Long)x).hashCode(); _NEWLINE 		int hashY = ((Long)x).hashCode(); _NEWLINE 		return 31*hashX + hashY; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int ccw(Point2D a, Point2D b, Point2D c) { _NEWLINE 		long area1 = (c.y - a.y) * (b.x - a.x); _NEWLINE 		long area2 = (b.y - a.y) * (c.x - a.x); _NEWLINE 		 _NEWLINE 		if (area1 > area2) { _NEWLINE 			return 1; _NEWLINE 		} _NEWLINE 		if (area2 > area1) { _NEWLINE 			return -1; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private class PolarOrder implements Comparator<Point2D> { _NEWLINE 	 _NEWLINE 		public int compare(Point2D p1, Point2D p2) { _NEWLINE 			long dy1 = p1.y - y; _NEWLINE 			long dy2 = p2.y - y; _NEWLINE 			long dx1 = p1.x - x; _NEWLINE 			long dx2 = p2.x - x; _NEWLINE 			if (dy1 >= 0 && dy2 < 0) return -1; _NEWLINE 			if (dy1 < 0 && dy2 >= 0) return 1; _NEWLINE 			// 3 collinear and horizontal points _NEWLINE 			if (dy1 == 0 && dy2 == 0) { _NEWLINE 				if (dx1 < 0 && dx2 >= 0) return 1; _NEWLINE 				if (dx1 >= 0 && dx2 < 0) return -1; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			return -ccw(Point2D.this, p1, p2); _NEWLINE 		} _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public Comparator<Point2D> polarOrder() { _NEWLINE 		return new PolarOrder(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public String toString() { _NEWLINE 		return "(" + x + "," + y + ")"; _NEWLINE 	} _NEWLINE }
import sys _NEWLINE  _NEWLINE def sieve(n): _NEWLINE  _INDENT  _INDENT A=[0,0]+[1 for i in range(n-1)] _NEWLINE  _INDENT  _INDENT s=int(n**.5) _NEWLINE  _INDENT  _INDENT for i in xrange(2,s+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[i]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i*i,n+1,i): A[j]=0 _NEWLINE  _INDENT  _INDENT return [i for i, p in enumerate(A) if p] _NEWLINE  _NEWLINE T = int(sys.stdin.readline()) _NEWLINE L=100000 _NEWLINE p = sieve(L) _NEWLINE distinct=[0]*(L+1) _NEWLINE  _NEWLINE for i in p: _NEWLINE  _INDENT  _INDENT for j in range(i,L+1,i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT distinct[j]+=1 _NEWLINE  _NEWLINE counts = [[0 for i in range(L+1)] for j in range(6)] _NEWLINE  _NEWLINE for k in range(1,6): _NEWLINE  _INDENT  _INDENT for i in range(1,L+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counts[k][i] = counts[k][i-1] + int(distinct[i]==k) _NEWLINE  _NEWLINE for trial in range(T): _NEWLINE  _INDENT  _INDENT A,B,k=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT print counts[k][B] - counts[k][A-1] _NEWLINE  _NEWLINE 
from heapq import heappush as insert, heappop as extractMax _NEWLINE  _NEWLINE def KSums(): _NEWLINE 	n,k = map(int, raw_input().split()) _NEWLINE 	a = map(int, raw_input().split()) _NEWLINE 	heap = [] _NEWLINE 	insert(heap, (-sum(a), (0, n-1))) _NEWLINE 	pairs = set() _NEWLINE 	pairs.add((0,n-1)) _NEWLINE 	for x in xrange(k): _NEWLINE 		value = extractMax(heap) _NEWLINE 		print -value[0], _NEWLINE 		i,j = value[1] _NEWLINE 		if (i+1, j) not in pairs: _NEWLINE 			pairs.add((i+1, j)) _NEWLINE 			insert(heap, (a[i]+value[0], (i+1,j))) _NEWLINE 		if (i, j-1) not in pairs: _NEWLINE 			pairs.add((i, j-1)) _NEWLINE 			insert(heap, (a[j]+value[0], (i, j-1))) _NEWLINE  _NEWLINE KSums()
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT x=len(s) _NEWLINE  _INDENT  _INDENT y=x/2 _NEWLINE  _INDENT  _INDENT t=[0]*2 _NEWLINE  _INDENT  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[0]=s[:y] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[1]=s[y:] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[0]=s[:y] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[1]=s[y+1:] _NEWLINE  _INDENT  _INDENT z=122 _NEWLINE  _INDENT  _INDENT v=[0]*26 _NEWLINE  _INDENT  _INDENT u=[0]*26 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT k=25 _NEWLINE  _INDENT  _INDENT while z>=97: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[z-97]+=t[0].count(chr(z)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u[z-97]+=t[1].count(chr(z)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT z-=1 _NEWLINE  _INDENT  _INDENT while k>-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v[k]!=u[k]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k-=1 _NEWLINE  _INDENT  _INDENT if i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ("YES") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ("NO") _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
n=int(raw_input()) _NEWLINE a=map(int,raw_input().split()) _NEWLINE for i in a: _NEWLINE 	temp=i; _NEWLINE 	count=0 _NEWLINE 	while (temp%5==0): _NEWLINE 		count+=1 _NEWLINE 		temp/=5 _NEWLINE 	while (temp%2==0): _NEWLINE 		count-=1 _NEWLINE 		temp/=2 _NEWLINE 	while (count>0): _NEWLINE 		count-=2 _NEWLINE 		i*=4 _NEWLINE 	print i
for _ in xrange(input()): _NEWLINE 	a = list(raw_input()) _NEWLINE 	b = list(raw_input()) _NEWLINE 	a.sort() _NEWLINE 	b.sort() _NEWLINE 	la, lb = len(a), len(b) _NEWLINE 	i, j, ans = 0, 0, 0 _INDENT  _NEWLINE 	while(i<la and j<lb): _NEWLINE 		oa = ord(a[i]) _NEWLINE 		ob = ord(b[j]) _NEWLINE 		if(oa == ob): _NEWLINE 			ans += 1 _NEWLINE 			i += 1 _NEWLINE 			j += 1 _NEWLINE 		elif(oa<ob): _NEWLINE 			i+=1 _NEWLINE 		elif(oa>ob): _NEWLINE 			j+=1 _NEWLINE 	print ans _NEWLINE 	
#!/usr/bin/python _NEWLINE from sys import stdin _NEWLINE  _NEWLINE T = int(stdin.readline()) _NEWLINE global N,K,M,R _NEWLINE global minimal _NEWLINE  _NEWLINE def check(i,current): _NEWLINE  _INDENT  _INDENT global N,K,M,R _NEWLINE  _INDENT  _INDENT global minimal _NEWLINE  _INDENT  _INDENT #print current,minimal,i,R _NEWLINE  _INDENT  _INDENT if current >= minimal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if i >= N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if current < minimal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minimal = current _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT #print current,R _NEWLINE  _INDENT  _INDENT for add in [0,1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R[i] += add _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i >= K - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start = 1 + min(i - K, N - K) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT end _INDENT  = start + K _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print start, end _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high = R[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while start < end: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if R[start] == high: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif R[start] > high: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high = R[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count < M: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT check(i+1, current + add) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if minimal == 0:return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R[i] -= add _NEWLINE  _NEWLINE #T = 1 _NEWLINE for _ in xrange(T): _NEWLINE  _INDENT  _INDENT N,K,M = (int(x) for x in stdin.readline().split()) _NEWLINE  _INDENT  _INDENT R = [int(x) for x in stdin.readline().split()] _NEWLINE  _INDENT  _INDENT current = 0 _NEWLINE  _INDENT  _INDENT minimal = N+1 _NEWLINE  _INDENT  _INDENT if M == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT minimal = 0 _NEWLINE  _INDENT  _INDENT elif M != 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT check(0,0) _NEWLINE  _INDENT  _INDENT if minimal == N+1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '-1' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minimal _NEWLINE  _NEWLINE 
def fn(): _NEWLINE  _INDENT  _INDENT n,m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT tnum,tcost = [0 for i in range(41)], [0 for i in range(41)] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tnum[a]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tcost[a]+=b _NEWLINE  _INDENT  _INDENT num, cost = [], [] _NEWLINE  _INDENT  _INDENT for i in range(41): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if tnum[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num.append(tnum[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cost.append(tcost[i]) _NEWLINE  _INDENT  _INDENT dpd = [[0 for i in range(41)] for i in range(41)] _NEWLINE  _INDENT  _INDENT dpn = [[0 for i in range(41)] for i in range(41)] _NEWLINE  _INDENT  _INDENT k = len(num) _NEWLINE  _INDENT  _INDENT for i in range(k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dpd[i][0] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dpd[i][j] = dpd[i-1][j] + dpd[i-1][j-1]*(pow(2,num[i-1])-1) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dpn[i][j] = dpn[i-1][j] + dpn[i-1][j-1]*(pow(2,num[i-1])-1) + dpd[i-1][j-1]*cost[i-1]*pow(2,num[i-1]-1) _NEWLINE  _NEWLINE  _INDENT  _INDENT d, n = 0, 0.0 _NEWLINE  _NEWLINE  _INDENT  _INDENT for j in range(m,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d += dpd[k][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n += dpn[k][j] _NEWLINE  _NEWLINE  _INDENT  _INDENT print '{0:.9f}'.format(n/d) _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn()
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT h = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT d = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if (n != 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((sum(d) - sum(h)) % abs(n-2) != 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = (sum(d) - sum(h)) / (n-2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (s < 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sm = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for _INDENT i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mi = s - (d[i] - h[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (mi % 2 != 0 or mi/2 < 0 or mi/2 > s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sm += mi/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sm == s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (h[0]+h[1] != d[0]+d[1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print abs(h[0]-d[0]) _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	number = int(raw_input()) _NEWLINE 	building = raw_input() _NEWLINE 	not_blown = 0 _NEWLINE 	for b in range(len(building)): _NEWLINE 		if number == 1: _NEWLINE 			if building[b] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 				break _NEWLINE 		elif b == 0: _NEWLINE 			if building[b] == '0' and building[b+1] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 		elif b == number -1: _NEWLINE 			if building[b] == '0' and building[b-1] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 		else: _NEWLINE 			if building[b] == '0' and building[b-1] == '0' and building[b+1] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 	print not_blown
# -*- coding: utf-8 -*- _NEWLINE """ _NEWLINE Created on Tue Feb 12 10:42:41 2013 _NEWLINE  _NEWLINE @author: Ross _NEWLINE """ _NEWLINE  _NEWLINE def comb(N,k): # from scipy.comb(), but MODIFIED! _NEWLINE  _INDENT  _INDENT if (k > N) or (N < 0) or (k < 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0L _NEWLINE  _INDENT  _INDENT N,k = map(long,(N,k)) _NEWLINE  _INDENT  _INDENT top = N _NEWLINE  _INDENT  _INDENT val = 1L _NEWLINE  _INDENT  _INDENT while (top > (N-k)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val *= top _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT top -= 1 _NEWLINE  _INDENT  _INDENT n = 1L _NEWLINE  _INDENT  _INDENT while (n < k+1L): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val /= n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n += 1 _NEWLINE  _INDENT  _INDENT return val _NEWLINE  _NEWLINE def ways(n): _NEWLINE  _INDENT  _INDENT if n % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 2**(n-1) _NEWLINE  _INDENT  _INDENT return int((2**n - comb(n, n/2))/2) _NEWLINE  _NEWLINE T = input() _NEWLINE sizes = [] _NEWLINE for test in range(T): _NEWLINE  _INDENT  _INDENT le = raw_input() _NEWLINE  _INDENT  _INDENT sizes.append(le) _NEWLINE  _INDENT  _INDENT inputs = raw_input() _NEWLINE  _NEWLINE for size in sizes: _NEWLINE  _INDENT  _INDENT print ways(int(size)) % 1000000007
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE  _NEWLINE def prime(n): _NEWLINE  _INDENT  _INDENT for i in range(2,int(n**0.5)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return i _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _NEWLINE  _NEWLINE for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT N=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT g=0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g=gcd(g,N[i]) _NEWLINE  _INDENT  _INDENT if g==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print prime(g)
def solve(i, ld, pf): _NEWLINE  _INDENT  _INDENT if i == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return pf _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT for (l,P) in [(A[i], p[i]), (B[i], 100-p[i])]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ld[l-1] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ld[l-1] = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += solve(i+1, ld, pf*P/100.0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ld[l-1] = False _NEWLINE  _INDENT  _INDENT return ans _NEWLINE for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT l = [False] * 16; _NEWLINE  _INDENT  _INDENT p = [] _NEWLINE  _INDENT  _INDENT A, B = [], [] _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P, a, b = map(int, raw_input().split(' ')) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p.append(P) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A.append(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B.append(b) _NEWLINE  _INDENT  _INDENT if n<=16: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT finalans = solve(0, l, 1) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT finalans = 0 _NEWLINE  _INDENT  _INDENT print finalans
for _ in range(input()): _NEWLINE  _INDENT  _INDENT m,n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT arr.sort() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT drink = [] _NEWLINE  _INDENT  _INDENT for i in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lem = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT drink.append(lem[1:]) _NEWLINE  _INDENT  _INDENT for room in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if drink[room]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxdrink = max(drink[room]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += maxdrink _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT drink[room].remove(maxdrink) _NEWLINE  _INDENT  _INDENT print count
#! /usr/bin/python _NEWLINE  _NEWLINE MAX_M = 100000 _NEWLINE  _NEWLINE def xdiff(i, j, matrix, isYflow): _NEWLINE 	""" coming to i,j position in the matrix from x direction. _INDENT _NEWLINE 	isYflow states the direction of second last move considering this as last, _NEWLINE 	0 represents from left, 1 from top and -1 for the case when both are possible. _NEWLINE 	Returns the additional affected mice because of this x shift""" _NEWLINE  _NEWLINE 	psum = get(i, j+1, matrix) + get(i+1, j, matrix) _NEWLINE 	return psum if isYflow else psum + get(i-1, j, matrix) _NEWLINE  _NEWLINE def ydiff(i, j, matrix, isYflow): _NEWLINE 	""" Read xdiff """ _NEWLINE  _NEWLINE 	psum = get(i+1, j, matrix) + get(i, j+1, matrix) _NEWLINE 	return psum + get(i, j-1, matrix) if isYflow == 1 else psum _NEWLINE  _NEWLINE def get(i, j, matrix): _NEWLINE 	""" returns matrix[i][j]. For the cases where i, j is not in matrix	returns 0. """ _NEWLINE  _NEWLINE 	n, m = len(matrix), len(matrix[0]) _NEWLINE 	if i < 0 or i >= n or j < _INDENT 0 or j >= m: _NEWLINE 		return 0 _NEWLINE 	else: _NEWLINE 		return matrix[i][j] _NEWLINE  _NEWLINE def get_affected(i, j, matrix): _NEWLINE 	""" Returns number of the affected mice for a given point """ _NEWLINE  _NEWLINE 	return (get(i+1, j, matrix) + get(i, j-1, matrix) + get(i, j+1, matrix) + get(i-1, j, matrix) + get(i, j, matrix)) _NEWLINE  _NEWLINE l = int(raw_input()) # number of test cases _NEWLINE for x in xrange(0, l): _NEWLINE 	input = raw_input().split(' ') _NEWLINE 	n, m = int(input[0]), int(input[1]) _NEWLINE 	matrix = [] _INDENT # matrix for each test case _NEWLINE 	for y in xrange(0, n): _NEWLINE 		matrix.append([int(c) for c in raw_input()]) _NEWLINE 	matrix_soln = []	# matrix_soln[i][j] = (least number of mice touched from 0,0 to i-1,j-1 in matrix, 0 or 1 based on last move from x or y position) _NEWLINE 	# dynamic approach _NEWLINE 	for i in xrange(0, n+1): _NEWLINE 		current_row_soln = [] _NEWLINE 		for j in xrange(0, m+1): _NEWLINE 			if i == 0: # initialization, for first column assume that the last move was from x direction i.e. coming from out of the box hence a 0 _NEWLINE 				current_row_soln.append((MAX_M, 0)) _NEWLINE 			elif j == 0: # coming from out of box from y direction hence a 1 _NEWLINE 				current_row_soln.append((MAX_M, 1)) _NEWLINE 			elif i == 1 and j == 1: _NEWLINE 				current_row_soln.append((get_affected(i-1, j-1, matrix), 0)) _NEWLINE 			else: _NEWLINE 				from_up = matrix_soln[i-1][j][0] + ydiff(i-1,j-1,matrix, matrix_soln[i-1][j][1]) _NEWLINE 				from_left = current_row_soln[j-1][0] + xdiff(i-1,j-1,matrix, current_row_soln[j-1][1]) _NEWLINE 				if from_up < from_left: _NEWLINE 					soln = (from_up, 1) _NEWLINE 				elif from_up > from_left: _NEWLINE 					soln = (from_left, 0) _NEWLINE 				else: _NEWLINE 					soln = (from_up, -1) _NEWLINE 				current_row_soln.append(soln) _NEWLINE 		matrix_soln.append(current_row_soln) _NEWLINE #	for sol in matrix_soln: _NEWLINE #		print sol _NEWLINE 	print matrix_soln[n][m][0] _NEWLINE  _NEWLINE 
from operator import itemgetter _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT arr=[] _NEWLINE  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[0] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dic[x[0]]>x[1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(x[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(dic[x[0]]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr.append(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[0]]=x[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr.append(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[0]]=x[1] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT print dic _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT print arr _NEWLINE  _INDENT  _INDENT sweetness=0 _NEWLINE  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT arr2=[] _NEWLINE  _INDENT  _INDENT for j in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(dic[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr2.append(c) _NEWLINE  _INDENT  _INDENT arr2=sorted(arr2,key=itemgetter(1)) _NEWLINE  _INDENT  _INDENT for j in range(len(arr2)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sweetness+=arr2[j][1]*(counter) _NEWLINE  _INDENT  _INDENT arr=sorted(arr,key=itemgetter(1)) _NEWLINE  _INDENT  _INDENT for j in range(len(arr)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sweetness+=counter*arr[j][1] _NEWLINE  _INDENT  _INDENT print sweetness
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT a=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT ct1=0 _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i]>a[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ct1+=1 _NEWLINE  _INDENT  _INDENT ct2=0 _NEWLINE  _INDENT  _INDENT for i in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]<a[i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ct2+=1 _NEWLINE  _INDENT  _INDENT if ct1==ct2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
from math import sqrt _NEWLINE def sieve(n): _NEWLINE 	L = [0 for i in range(n+1)]; s = int(sqrt(n)); P,S = {},[]; _INDENT L[0],L[1] = 1,1 _NEWLINE 	for i in range(2,s+1): _NEWLINE 		if L[i] is 0: _NEWLINE 			for j in range(i*i,n+1,i): L[j] = 1 _NEWLINE 	for i in range(len(L)): _NEWLINE 		if L[i] is 0: P[i] = None; S.append(i) _NEWLINE 	return P,S _NEWLINE def precompute(): _NEWLINE 	P,S = sieve(int(1e4)); l = len(S); cnt = [0 for i in range(int(1e4)+1)] _NEWLINE 	for i in range(l): _NEWLINE 		for j in range(l): _NEWLINE 			if 2*S[j] + S[i] > 10000: break _NEWLINE 			cnt[2 * S[j] + S[i]]+=1 _NEWLINE 	return cnt _NEWLINE def LEVY(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	cnt = precompute() _NEWLINE 	while t: _NEWLINE 		n = int(raw_input()) _NEWLINE 		print cnt[n]; t-=1 _NEWLINE if __name__ == '__main__': LEVY() _NEWLINE 		 _NEWLINE 		 _NEWLINE 
val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	val1 = raw_input() _NEWLINE 	n = int(val1) _NEWLINE 	a = list() _NEWLINE 	val2 = raw_input() _NEWLINE 	val3 = val2.split() _NEWLINE 	for i in range(n) : _NEWLINE 		a.append(int(val3[i])) _NEWLINE 	num = max(a) _NEWLINE 	c = a.count(num) _NEWLINE 	print ((2**c) - 1 )% 1000000007 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
#program for one dimensional game of life _NEWLINE iteration = int(raw_input()) _NEWLINE match = [[0,1],[3,2],[5,4],[6,7]] _NEWLINE poss = [[0,3,5,6],[1,2,4,7]] _NEWLINE for i in range(iteration): _NEWLINE 	count = 0 _NEWLINE 	row = raw_input() _NEWLINE 	arr = poss[int(row[-1])] _NEWLINE 	for el in arr: _NEWLINE 		output = str(el % 2) _NEWLINE 		current = el _NEWLINE 		for j in range(len(row)): _NEWLINE 			current = match[current % 4][int(row[j])] _NEWLINE 			if j == len(row)-1: _NEWLINE 				if current == el: _NEWLINE 					count = count + 1 _NEWLINE 					finalout = output _NEWLINE 			else: _NEWLINE 				output = output + str(current % 2) _NEWLINE 	if count == 0: _NEWLINE 		print 'No solution' _NEWLINE 	elif count > 1: _NEWLINE 		print 'Multiple solutions' _NEWLINE 	else: _NEWLINE 		print finalout
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT maxy = [999999999999,-999999999999, 0] _NEWLINE  _INDENT  _INDENT maxx = [-999999999999,-999999999999, 0] _NEWLINE  _INDENT  _INDENT miny = [999999999999,999999999999, 0] _NEWLINE  _INDENT  _INDENT minx = [999999999999,999999999999, 0] _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT ref = [] _NEWLINE  _INDENT  _INDENT for j in range (n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x, y = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ref.append([x,y,j+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if y > maxy[1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxy[0], maxy[1], maxy[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x > maxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxx[0], maxx[1], maxx[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if y < miny[1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT miny[0], miny[1], miny[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x < minx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minx[0], minx[1], minx[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT maxyminx = maxy _NEWLINE  _INDENT  _INDENT maxymaxx = maxy _NEWLINE  _INDENT  _INDENT minyminx = miny _NEWLINE  _INDENT  _INDENT minymaxx = miny _NEWLINE  _INDENT  _INDENT for k in ref: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == maxyminx[1] and k[0] < maxyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxyminx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == maxymaxx[1] and k[0] > maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxymaxx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == minyminx[1] and k[0] < minyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minyminx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == minymaxx[1] and k[0] > minymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minymaxx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT """ _NEWLINE  _INDENT  _INDENT print maxymaxx, _NEWLINE  _INDENT  _INDENT print maxyminx _NEWLINE  _INDENT  _INDENT print maxx _NEWLINE  _INDENT  _INDENT print minymaxx, _NEWLINE  _INDENT  _INDENT print minyminx _NEWLINE  _INDENT  _INDENT print minx""" _NEWLINE  _INDENT  _INDENT if maxx[0] == minymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NW" _NEWLINE  _INDENT  _INDENT elif maxx[0] == maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SW" _NEWLINE  _INDENT  _INDENT elif minx[0] == minyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minyminx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NE" _NEWLINE  _INDENT  _INDENT elif minx[0] == maxyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxyminx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SE" _NEWLINE  _INDENT  _INDENT elif maxx[0] > minymaxx[0] and minx[0] < minymaxx[0] and minymaxx[0] <= maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "2" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NE" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SW" _NEWLINE  _INDENT  _INDENT elif maxx[0] > minymaxx[0] and minx[0] < minymaxx[0] and minymaxx[0] > maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "2" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NW" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SE" 
def solve(a,b,num): _NEWLINE 	# temp=[w for w in c] _NEWLINE 	# heapify(temp) _NEWLINE 	# for i in xrange(num): _NEWLINE 	# 	ans=heappop(temp) _NEWLINE 	# 	heapify(temp) _NEWLINE 	# return ans	 _NEWLINE 	while(len(a)*len(b)>num): _NEWLINE 		if len(a)==1 or len(b)==1: _NEWLINE 			break _NEWLINE 		if a[-1]>b[-1]: _NEWLINE 			a.pop() _NEWLINE 		else: _NEWLINE 			b.pop() _NEWLINE 	p=[] _NEWLINE 	for i in xrange(len(a)): _NEWLINE 		for j in xrange(len(b)): _NEWLINE 			p.append(a[i]+b[j]) _NEWLINE 	return sorted(p)						 _NEWLINE  _NEWLINE from heapq import * _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE 	k,q=map(int,raw_input().strip().split()) _NEWLINE 	a=sorted([int(x) for x in raw_input().strip().split()]) _NEWLINE 	b=sorted([int(x) for x in raw_input().strip().split()]) _NEWLINE 	c=solve(a,b,100001) _NEWLINE 	# c=[] _NEWLINE 	# for i in xrange(k): _NEWLINE 	# 	for j in xrange(k): _NEWLINE 	# 		c.append(a[i]+b[j]) _NEWLINE 	# c.sort()		 _NEWLINE 	while(q>0): _NEWLINE 		num=input() _NEWLINE 		print c[num-1] _NEWLINE 		q-=1 _NEWLINE 	t-=1 _NEWLINE 
import sys, copy _NEWLINE  _NEWLINE def makeLucky( ss ): _NEWLINE  _INDENT  _INDENT # return tuple ( lowpal, changecnt ) or (None,None) if unlucky _NEWLINE  _NEWLINE  _INDENT  _INDENT s = bytearray( ss ) _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lens = len(s) _NEWLINE  _INDENT  _INDENT if lens<9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (None,None) _NEWLINE  _INDENT  _INDENT swaplim = int(lens/2) _NEWLINE  _INDENT  _INDENT if swaplim*2 == lens: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # even _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT firstspanx = swaplim - (5-1) _INDENT # 1st index of 'lucky' span pal area _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lastspanx _INDENT = swaplim - 1 _INDENT  _INDENT  _INDENT # last such index _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT firstspanx = swaplim - (5-2) _INDENT # 1st index of 'lucky' span pal area _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lastspanx _INDENT = swaplim - 1 _INDENT  _INDENT  _INDENT # last such index _NEWLINE  _NEWLINE  _INDENT  _INDENT blucky = bytearray( b'lucky' ) _NEWLINE  _INDENT  _INDENT spal = copy.copy( s ) _NEWLINE  _INDENT  _INDENT spchgs = bytearray( lens ) _INDENT #zeros _NEWLINE  _INDENT  _INDENT totspchgs = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(lens): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ii = lens-1-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if spal[i] > spal[ii]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[i] = spal[ii] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spchgs[i] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT totspchgs += 1 _NEWLINE  _INDENT  _INDENT save1 = bytearray( 5 ) _NEWLINE  _INDENT  _INDENT save2 = bytearray( 5 ) _NEWLINE  _NEWLINE  _INDENT  _INDENT minchgs = 999999 _NEWLINE  _INDENT  _INDENT bestpal = bytearray( lens ) _NEWLINE  _INDENT  _INDENT for i in xrange(lens-4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # complentary slices [i:i+5] and [lens-5-i:lens-i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  calc: [ lens-1-(i+4) = lens-5-i _INDENT : _INDENT (lens-5-i)+ 5 = lens-i ] _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i >= firstspanx and i <= lastspanx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # part of 'lucky' is in pal midpoint area; known can't form palindrome _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pass _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # count changes to get lucky _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(i,i+5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs += (s[k] != blucky[k-i]) _INDENT # move to put lucky in _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT kk = lens-1-k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if kk != k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs += (s[kk] != blucky[k-i]) # copy to match lucky _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # count swaps generally needed less our two uniquely modified areas _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT notdone = sum(spchgs[i:i+5]) + sum(spchgs[lens-5-i:lens-i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs += totspchgs - notdone _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if chgs <= minchgs: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # construct seq in spal, compare, and remember if it is best _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save1[:] = spal[i:i+5] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save2[:] = spal[lens-5-i:lens-i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[i:i+5] = blucky _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(i,i+5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if spal[lens-1-k] != spal[k]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[lens-1-k] = spal[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if chgs < minchgs: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minchgs = chgs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestpal[:] = spal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if spal < bestpal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestpal[:] = spal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if testing: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(spal), chgs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[i:i+5] = save1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[lens-5-i:lens-i] = save2 _NEWLINE  _INDENT  _INDENT return (str(bestpal),minchgs) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def testLucky( s ): _NEWLINE  _INDENT  _INDENT global testing _NEWLINE  _INDENT  _INDENT testing = False #True _NEWLINE  _INDENT  _INDENT print s, '<------ input' _NEWLINE  _INDENT  _INDENT best, cnt = makeLucky( s ) _NEWLINE  _INDENT  _INDENT print best, cnt, '<------ output' _NEWLINE  _NEWLINE def testit( ): _NEWLINE  _INDENT  _INDENT testLucky( 'evenlength' ) _NEWLINE  _INDENT  _INDENT testLucky( 'eventyngth' ) _NEWLINE  _INDENT  _INDENT testLucky( 'yuckykcuy' ) _NEWLINE  _INDENT  _INDENT testLucky( 'ykcuxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'yuckxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'lzckxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'luckxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'abcdefyedabc' ) _NEWLINE  _INDENT  _INDENT testLucky( 'abcdefyfedabc' ) _NEWLINE  _INDENT  _INDENT testLucky( 'laubcdkey' ) _NEWLINE  _INDENT  _INDENT testLucky( 'luckycodechef' ) _NEWLINE  _INDENT  _INDENT testLucky( 'aaaaaaaa' ) _NEWLINE  _INDENT  _INDENT testLucky( 'qrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbd' ) _NEWLINE  _INDENT  _INDENT testLucky( 'xrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqb' ) _NEWLINE  _INDENT  _INDENT #testLucky( 'qrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' ) _NEWLINE  _NEWLINE def runit(): _NEWLINE  _INDENT  _INDENT global testing _NEWLINE  _INDENT  _INDENT testing = False _NEWLINE  _INDENT  _INDENT ncases = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT for cn in xrange(ncases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = sys.stdin.readline().rstrip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT best, cnt = makeLucky( s ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if best == None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "unlucky" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print best, cnt _NEWLINE  _NEWLINE  _NEWLINE runit() _NEWLINE 
lis = [0] * 100001 _NEWLINE num4 = [0] * 100001 _NEWLINE num7 = [0] * 100001 _NEWLINE diff = [0] * 100001 _NEWLINE diff[0] = 1 _NEWLINE  _NEWLINE def preCompute(): _NEWLINE 	cnt4 = cnt7 = 0 _NEWLINE 	for i in range(1, 100001): _NEWLINE 		t = i _NEWLINE 		while t > 0: _NEWLINE 			if t % 10 == 4 : _NEWLINE 				cnt4 += 1 _NEWLINE 			elif t % 10 == 7 : _NEWLINE 				cnt7 += 1 _NEWLINE 			t /= 10 _NEWLINE 		num4[i] = cnt4 _NEWLINE 		num7[i] = cnt7 _NEWLINE 		lis[i] = lis[i-1] + diff[num4[i] - num7[i]] _NEWLINE 		diff[num4[i] - num7[i]] += 1 _NEWLINE  _NEWLINE preCompute() _NEWLINE n = int(raw_input()) _NEWLINE while(n > 0): _NEWLINE 	n = n - 1 _NEWLINE 	c = int(raw_input()) _NEWLINE 	print lis[c]
import sys, os _NEWLINE # import unittest _NEWLINE  _NEWLINE def getToTarget(target, values, priorities): _NEWLINE 	returnTarget = 0 _NEWLINE 	returnValues = values _NEWLINE 	for p in priorities: _NEWLINE 		x = values[p] _NEWLINE 		toTarget = target-returnTarget _NEWLINE 		add = min(x,toTarget) _NEWLINE 		returnValues[p] = x-add _NEWLINE 		returnTarget += add _NEWLINE  _NEWLINE 	return returnTarget, returnValues _NEWLINE  _NEWLINE def solve(values, sevensTarget, foursTarget): _NEWLINE 	sevens, values = getToTarget(sevensTarget, values, [2, 0, 1, 3]) _NEWLINE 	fours, values = getToTarget(foursTarget, values, [0,1]) _NEWLINE  _NEWLINE 	return sevens, fours, values _NEWLINE  _NEWLINE def count(str): _NEWLINE 	counts = [0] * 10 _NEWLINE 	for x in str: _NEWLINE 		d = ord(x)-ord('0') _NEWLINE 		counts[d] += 1 _NEWLINE  _NEWLINE 	return _INDENT [ _INDENT _NEWLINE 			 _INDENT counts[0] + counts[1] + counts[2] + counts[3], _NEWLINE 			 _INDENT counts[4], _NEWLINE 			 _INDENT counts[5] + counts[6], _NEWLINE 			 _INDENT counts[7] _NEWLINE 		 	] _NEWLINE  _NEWLINE def solveCase(a,b): _NEWLINE 	valuesA = count(a) _NEWLINE 	valuesB = count(b) _NEWLINE  _NEWLINE 	# print valuesA, valuesB _NEWLINE 	sevensA, foursA, valuesB = solve(valuesB, valuesA[3], 0) _NEWLINE 	valuesA[3] -= sevensA _NEWLINE 	valuesA[1] -= foursA _NEWLINE 	sevensB, foursB, valuesA = solve(valuesA, valuesB[3], 0) _NEWLINE  _NEWLINE 	sevens = sevensA + sevensB _NEWLINE  _NEWLINE 	sevensA, foursA, valuesB = solve(valuesB, 0, valuesA[1]) _NEWLINE 	valuesA[3] -= sevensA _NEWLINE 	valuesA[1] -= foursA _NEWLINE 	sevensB, foursB, valuesA = solve(valuesA, 0, valuesB[1]) _NEWLINE  _NEWLINE 	fours = foursB + foursA _NEWLINE  _NEWLINE 	return '7'*(sevens) + '4'*(fours) _NEWLINE  _NEWLINE # class Tests(unittest.TestCase): _NEWLINE # 	def test_0(self): _NEWLINE # 		self.assertEqual(solveCase('4', '7'), '7') _NEWLINE  _NEWLINE # 	def test_1(self): _NEWLINE # 		self.assertEqual(solveCase('435', '479'), '74') _NEWLINE  _NEWLINE # 	def test_2(self): _NEWLINE # 		self.assertEqual(solveCase('7','8'), '') _NEWLINE  _NEWLINE # 	def test_3(self): _NEWLINE # 		self.assertEqual(solveCase('1675475', '9756417'), '777744') _NEWLINE  _NEWLINE # 	def test_4(self): _NEWLINE # 		self.assertEqual(solveCase('777444', '666666'), '777') _NEWLINE  _NEWLINE # 	def test_5(self): _NEWLINE # 		self.assertEqual(solveCase('777444', '666444'), '777444') _NEWLINE  _NEWLINE # 	def test_6(self): _NEWLINE # 		self.assertEqual(solveCase('666444', '777444'), '777444') _NEWLINE  _NEWLINE # 	def test_7(self): _NEWLINE # 		self.assertEqual(solveCase('111344', '777433'), '777444') _NEWLINE  _NEWLINE # 	def test_8(self): _NEWLINE # 		self.assertEqual(solveCase('778888', '111174'), '77') _NEWLINE  _NEWLINE # 	def test_9(self): _NEWLINE # 		self.assertEqual(solveCase('87432', '87643'), '7744') _NEWLINE  _NEWLINE # 	def test_10(self): _NEWLINE # 		self.assertEqual(solveCase('84847487764', '19887294978'), '77777') _NEWLINE  _NEWLINE # 	def test_11(self): _NEWLINE # 		# 777778934 _NEWLINE # 		# 774409861 _NEWLINE # 		# 88487786847 _NEWLINE # 		# 79774772742 _NEWLINE # 		self.assertEqual(solveCase('88487786847', '79774772742'), '777777') _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	# unittest.main() _NEWLINE 	# sys.stdin = open('test.txt') _NEWLINE 	cases = int(sys.stdin.readline().strip()) _NEWLINE 	for x in range(cases): _NEWLINE 		a = sys.stdin.readline().strip() _NEWLINE 		b = sys.stdin.readline().strip() _NEWLINE 		print solveCase(a,b)
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	n = raw_input().strip() _NEWLINE 	print len(n) - n.count('4') - n.count('7')
n = input() _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT str = raw_input() _NEWLINE  _INDENT  _INDENT l = len(str) _NEWLINE  _INDENT  _INDENT megacounter = 0 _NEWLINE  _INDENT  _INDENT counter = 0 _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<l and str[i]=='7'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter=counter+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i>=l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT megacounter = megacounter + (counter*(counter+1))/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT megacounter = megacounter + (counter*(counter+1))/2 _NEWLINE  _INDENT  _INDENT supercounter = (l*(l+1))/2 - megacounter _NEWLINE  _INDENT  _INDENT print supercounter
import sys _NEWLINE a,b = map(int,sys.stdin.readline().split()) _NEWLINE i=j=0 _NEWLINE k=[0]*a _NEWLINE l=[0]*b _NEWLINE while i<a: _NEWLINE  _INDENT  _INDENT k[i]=(raw_input()) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE while j<b: _NEWLINE  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT l[j]=(raw_input()) _NEWLINE  _INDENT  _INDENT x=len(l[j]) _NEWLINE  _INDENT  _INDENT if x>46: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT while m<a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (k[m] in l[j])==True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m+=1 _NEWLINE  _INDENT  _INDENT if c>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Good" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Bad" _NEWLINE  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
''' _NEWLINE from collections import Counter _NEWLINE import string,sys _NEWLINE N = int(raw_input()); s = raw_input(); _NEWLINE if N == 1: print s; sys.exit(0) _NEWLINE sc = Counter(s) _NEWLINE for i in range(N-1): _NEWLINE  _INDENT  _INDENT st = raw_input(); stc = Counter(st) _NEWLINE  _INDENT  _INDENT for i in list(string.ascii_lowercase): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sc.get(i) != None and stc.get(i) == None: sc.pop(i,None) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif sc.get(i) != None and stc.get(i) != None and sc.get(i) != stc.get(i): sc[i] = abs(sc.get(i) - stc.get(i)) _NEWLINE if sc == {}: print 'no such string'; sys.exit(0) _NEWLINE letters = sorted(sc.keys()) _NEWLINE print "".join(letters) _NEWLINE from math import sqrt _NEWLINE t = int(raw_input()) _NEWLINE fromset = set('0149') _NEWLINE while t: _NEWLINE  _INDENT  _INDENT a,b = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT sa,sb,count = int(sqrt(a)),int(sqrt(b)),0 _NEWLINE  _INDENT  _INDENT if sa ** 2 < a: sa = sa + 1 _NEWLINE  _INDENT  _INDENT for i in range(sa,sb+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = i * i; st = str(s); stset = set(st) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if stset.issubset(fromset): count+=1 _INDENT _NEWLINE  _INDENT  _INDENT print count; t-=1 _NEWLINE ''' _NEWLINE ''' _NEWLINE # Second attempt :-) Previous code above... _NEWLINE squares = [i**2 for i in range(1,int(1e5)+1) if set(str(i**2)).issubset(set('0149'))] _NEWLINE def binary_search(A,left,right,key): _NEWLINE  _INDENT  _INDENT while left < right: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = left + ( right - left ) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[mid] < key: left = mid + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif A[mid] > key: right = mid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif A[mid] == key: return mid _NEWLINE  _INDENT  _INDENT return left _NEWLINE t = int(raw_input()) _NEWLINE l = len(squares) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT a,b = map(int,raw_input().split()); count = 0 _NEWLINE  _INDENT  _INDENT lower_limit = binary_search(squares,0,l,a) _NEWLINE  _INDENT  _INDENT upper_limit = binary_search(squares,0,l,b) _NEWLINE  _INDENT  _INDENT if squares[upper_limit] == b: print upper_limit - lower_limit + 1 _NEWLINE  _INDENT  _INDENT else: print upper_limit - lower_limit _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE ''' _NEWLINE from math import sqrt _NEWLINE def isoverlucky(x): _NEWLINE  _INDENT  _INDENT return '4' in x or '7' in x _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT n = int(raw_input()); count = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(n)+1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n % i: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isoverlucky(str(i)): count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n / i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j != i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isoverlucky(str(j)): count+=1 _NEWLINE  _INDENT  _INDENT print count; t-=1 _NEWLINE  _NEWLINE 
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT ans = "No" _NEWLINE  _INDENT  _INDENT c = 1 _NEWLINE  _INDENT  _INDENT p = a[0] _NEWLINE  _INDENT  _INDENT for i in a[1:]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = 1 _NEWLINE  _INDENT  _INDENT print ans 
output = list() _NEWLINE string1 = raw_input() _NEWLINE n = int(string1) _NEWLINE for i in range(n) : _NEWLINE 	inp1 = raw_input() _NEWLINE 	todo = list(inp1) _NEWLINE 	for j in range(len(todo)-1,-1,-1) : _NEWLINE 		if (j>=3 and (todo[j-3]=='C' or todo[j-3]=='?') and (todo[j-2]=='H' or todo[j-2]=='?') and (todo[j-1]=='E' or todo[j-1]=='?') and (todo[j]=='F' or todo[j]=='?')) : _NEWLINE 			todo[j-3:j+1] = 'CHEF' _NEWLINE 		elif todo[j] == '?' : _NEWLINE 			todo[j] = 'A' _NEWLINE 	transstr = ''.join(todo) _NEWLINE 	output.append(transstr) _NEWLINE for i in range(n) : _NEWLINE 	print output[i]
def choices(n,m,banknotes): _NEWLINE  _INDENT  _INDENT """n <= 20; _INDENT the value of a single banknote <= 1000 """ _NEWLINE  _INDENT  _INDENT if m == 0 or m < 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT elif n == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if banknotes[0] == m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return [banknotes[0]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT choice = choices(n-1,(m - banknotes[0]), banknotes[1:]) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if choice: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return [banknotes[0]] + choice _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return choices(n-1, m, banknotes[1:]) _NEWLINE  _NEWLINE def solve(n,m,banknotes): _NEWLINE  _INDENT  _INDENT if choices(n,m,banknotes): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 'Yes' _NEWLINE  _INDENT  _INDENT return 'No' _NEWLINE  _NEWLINE def marcha1(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n, m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT banknotes = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT banknotes.append(int(raw_input())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(n,m, banknotes) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT marcha1()
#!/usr/bin/python _NEWLINE  _NEWLINE # read the number of testcases _NEWLINE testcases = int(raw_input()) _NEWLINE  _NEWLINE # for each testcase _NEWLINE for i in range(0, testcases): _NEWLINE 	# read the number of levels _NEWLINE 	beanlevel = int(raw_input()) _NEWLINE 	# read the leaf count _NEWLINE 	leafcount = map(int, str(raw_input()).split()) _NEWLINE 	# sanity check _NEWLINE 	if len(leafcount) > 1 and leafcount[0] > 0: _NEWLINE 		print 'No' _NEWLINE 		continue _NEWLINE 	# reverse leafcount _NEWLINE 	leafcount.reverse() _NEWLINE 	# set noflag to false _NEWLINE 	noflag = False _NEWLINE 	# initialize stems to zero _NEWLINE 	stems = 0 _NEWLINE 	# verify if john counted correctly _NEWLINE 	for j in leafcount: _NEWLINE 		stems = int(stems / 2) _NEWLINE 		stems = stems + j _NEWLINE 		if stems % 2 and stems > 1: _NEWLINE 			noflag = True _NEWLINE 			break _NEWLINE 		 _NEWLINE 	# check if the last level matches _NEWLINE 	if noflag == False and stems == 1: _NEWLINE 		print 'Yes' _NEWLINE 	else: _NEWLINE 		print 'No' _NEWLINE  _NEWLINE 
from sys import stdin _NEWLINE from collections import defaultdict _NEWLINE  _NEWLINE class Event(object): _NEWLINE 	def __init__(self, start, end, value): _NEWLINE 		self.start = start _NEWLINE 		self.end = end _NEWLINE 		self.value = value _NEWLINE  _NEWLINE T = int(stdin.readline()) _NEWLINE  _NEWLINE for _ in range(T): _NEWLINE 	number_of_events = int(stdin.readline()) _NEWLINE 	events = defaultdict(list) _NEWLINE 	for _ in range(number_of_events): _NEWLINE 		event = Event(*[int(x) for x in stdin.readline().split()]) _NEWLINE 		events[event.start].append(event) _NEWLINE 	max_value = [0]*49 _NEWLINE 	def event_value(event): _NEWLINE 		return event.value + max_value[event.end] _NEWLINE  _NEWLINE 	for start in reversed(range(48)): _NEWLINE 		e = events[start] _NEWLINE 		if e: _NEWLINE 			best = max([event_value(x) for x in e]) _NEWLINE 			max_value[start] = max(best, max_value[start + 1]) _NEWLINE 		else: _NEWLINE 			max_value[start] = max_value[start + 1] _NEWLINE 	print(max_value[0])
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT n,k = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT b=[0]*n _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT b=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT while i<n: _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=b[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT b.sort() _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT if k>=((n+1)/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=n-k _NEWLINE  _INDENT  _INDENT while j<k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=b[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT m=abs((l)-(2*sum)) _NEWLINE  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	n,k=map(int,raw_input().strip().split()) _NEWLINE 	a=map(int,raw_input().strip().split()) _NEWLINE 	b=map(int,raw_input().strip().split()) _NEWLINE 	sum=0 _NEWLINE 	high=-1 _NEWLINE 	for i in range(n): _NEWLINE 		sum+=a[i]*b[i] _NEWLINE 		if abs(b[i])>high: _NEWLINE 			high=abs(b[i]) _NEWLINE 	sum+=high*k _NEWLINE 	print sum _NEWLINE 	t-=1 _NEWLINE 
mod = 10**9+7 _NEWLINE def fast_exp(base, exp): _NEWLINE  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT while (exp>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (exp%2==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = (base*res)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base = (base*base)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT exp/=2 _NEWLINE  _INDENT  _INDENT return res _NEWLINE for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT print fast_exp(2,int(raw_input()))-1 _NEWLINE  _NEWLINE 
def f(i, j): _NEWLINE  _INDENT  _INDENT if (score[i][j] is not None): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return score[i][j] _NEWLINE  _INDENT  _INDENT elif (i==0 and j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] _NEWLINE  _INDENT  _INDENT elif (i==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] + f(i, j-1) _NEWLINE  _INDENT  _INDENT elif (j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] + f(i-1, j) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] + max(f(i-1, j), f(i, j-1)) _NEWLINE  _INDENT  _INDENT return score[i][j] _NEWLINE for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT score = [] _NEWLINE  _INDENT  _INDENT grid = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score.append([None]*n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT grid.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT f(n-1,n-1) _NEWLINE  _INDENT  _INDENT if (score[n-1][n-1]<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Bad Judges" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print score[n-1][n-1] / float(n+n-3) _NEWLINE  _INDENT  _INDENT  _NEWLINE 
n,m=map(int,raw_input().split()) _NEWLINE arr=[] _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT arr.append(x) _NEWLINE l=int(raw_input()) _NEWLINE b=[] _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT a=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT b.append(a) _NEWLINE sum1=0 _NEWLINE sum2=0 _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT if((b[i][0]-1)<n and (b[i][1]-1)<m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1+=arr[b[i][0]-1][b[i][1]-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT if((b[i][1]-1)<n and (b[i][0]-1)<m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2+=arr[b[i][1]-1][b[i][0]-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE #print arr _NEWLINE #print b _NEWLINE print max(sum1,sum2)
inp = raw_input() _NEWLINE inp = inp.split() _NEWLINE n = int(inp[0]) _NEWLINE q = int(inp[1]) _NEWLINE lookups = {} _NEWLINE for i in range(0, n): _NEWLINE 	x = raw_input() _NEWLINE 	x = (x.strip()).split() _NEWLINE 	lookups[x[0]] = x[1] _NEWLINE keyset = lookups.keys() _NEWLINE for i in range(0, q): _NEWLINE 	f = raw_input() _NEWLINE 	f = f.strip() _NEWLINE 	idx = f.rfind('.') _NEWLINE 	if idx==-1: _NEWLINE 		print "unknown" _NEWLINE 	else: _NEWLINE 		ext = f[idx+1:] _NEWLINE 		if ext in keyset: _NEWLINE 			print lookups[ext] _NEWLINE 		else: _NEWLINE 			print "unknown" _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE def R(): return map(int, raw_input().split()) _NEWLINE  _NEWLINE T = R()[0] _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT N = R()[0] _NEWLINE  _INDENT  _INDENT A = R() _NEWLINE  _NEWLINE  _INDENT  _INDENT all_negative = True _NEWLINE  _INDENT  _INDENT max_element = None _NEWLINE  _INDENT  _INDENT max_so_far = 0 _NEWLINE  _INDENT  _INDENT max_ending_left = 0 _INDENT  _INDENT  # maximum subsequence ending at prev position _NEWLINE  _INDENT  _INDENT max_skipped_one = 0 _INDENT  _INDENT  # maximum subsequence ending at curr position where one element was skipped _NEWLINE  _INDENT  _INDENT for x in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_element = max(max_element, x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT all_negative = all_negative and x < 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_ending_left, max_skipped_one _INDENT = max(0, max_ending_left + x), max(0, max_ending_left, max_skipped_one + x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_so_far = max(max_so_far, max_skipped_one, max_ending_left) _NEWLINE  _NEWLINE  _INDENT  _INDENT print max_element if all_negative else max_so_far _NEWLINE 
t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b,c=raw_input().split() _NEWLINE  _INDENT  _INDENT a = int(a) _NEWLINE  _INDENT  _INDENT b = int(b) _NEWLINE  _INDENT  _INDENT c = int(c) _NEWLINE  _INDENT  _INDENT maxV = a*100+b _NEWLINE  _INDENT  _INDENT step = 0 _NEWLINE  _INDENT  _INDENT result = 0 _NEWLINE  _INDENT  _INDENT temp = maxV _NEWLINE  _INDENT  _INDENT while(c<=temp and step < 10000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b < c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = a-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = b+100 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=b-c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = a*100+b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT step = step + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if maxV < temp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxV = temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = step _NEWLINE  _INDENT  _INDENT print result
import sys _NEWLINE  _NEWLINE tokenizedInput = sys.stdin.read().split() _NEWLINE mod=1000000007 _NEWLINE arr=[1]*5001 _NEWLINE for i in range(1,5001): _NEWLINE  _INDENT arr[i]=(arr[i-1]*i)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE def Power(base,expo): _NEWLINE  _INDENT  _INDENT if(expo==0): _NEWLINE  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(expo&1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return(base*Power(base,expo-1)%mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT root=Power(base,expo>>1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return(root*root%mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def combo(r,n,mod): _NEWLINE  _INDENT  _INDENT q=arr[n] _NEWLINE  _INDENT  _INDENT r=(arr[r]*arr[n-r])%mod _NEWLINE  _INDENT  _INDENT return (q*Power(r,mod-2))%mod _NEWLINE  _NEWLINE elm=0 _NEWLINE  _NEWLINE for i in range (0,5001): _NEWLINE  _INDENT  _INDENT n=int(tokenizedInput[elm]) _NEWLINE  _INDENT  _INDENT elm=elm+1 _NEWLINE  _INDENT  _INDENT k=int(tokenizedInput[elm]) _NEWLINE  _INDENT  _INDENT elm=elm+1 _NEWLINE  _INDENT  _INDENT if(n==0 and k==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT out=0 _NEWLINE  _INDENT  _INDENT if(((k-1)/2)!=(k/2)): _NEWLINE  _INDENT  _INDENT  _INDENT out=(2*combo((k-1)/2,n-2,mod)*combo(k/2,n-2,mod))%mod _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT out=(2*combo(k/2,n-2,mod)**2)%mod _NEWLINE  _INDENT  _INDENT print out
def fn(): _NEWLINE  _INDENT  _INDENT n,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(0) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i-1] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT g = t = tc = 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1000,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT g += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tc = (g-1)/k + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += tc _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print t _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn()
import sys _NEWLINE  _NEWLINE q = [] _NEWLINE visited = {} _NEWLINE backTrack = {} _NEWLINE goalState = [0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0] _NEWLINE  _NEWLINE rotations = { _NEWLINE  _INDENT  _INDENT 0 : { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'R' : [0, 2, 5, 8, 6, 3], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'L' : [0, 3, 6, 8, 5, 2], _NEWLINE  _INDENT  _INDENT }, _NEWLINE  _INDENT  _INDENT 1 : { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'R' : [1, 3, 6, 9, 7, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'L' : [1, 4, 7, 9, 6, 3], _NEWLINE  _INDENT  _INDENT }, _NEWLINE  _INDENT  _INDENT 2 : { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'R' : [6, 8, 10, 12, 11, 9], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'L' : [6, 9, 11, 12, 10, 8], _NEWLINE  _INDENT  _INDENT }, _NEWLINE } _NEWLINE  _NEWLINE def getHashKey(state): _NEWLINE  _INDENT  _INDENT h = 0 _NEWLINE  _INDENT  _INDENT for i in range(13): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h = h * 2 + int(state[i]) _NEWLINE  _INDENT  _INDENT return h _NEWLINE  _NEWLINE def printSolution(key): _NEWLINE  _INDENT  _INDENT target = key _NEWLINE  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT while key != 600: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT key, no, direction, state = backTrack[key] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT direction = 1 if direction == 'L' else 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append((no, direction)) _NEWLINE  _NEWLINE  _INDENT  _INDENT print cnt _NEWLINE  _INDENT  _INDENT for no, direction in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print no, direction _NEWLINE  _NEWLINE def solve(key): _NEWLINE  _INDENT  _INDENT startKey = key _NEWLINE  _NEWLINE  _INDENT  _INDENT if len(q) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.insert(0, goalState) _NEWLINE  _NEWLINE  _INDENT  _INDENT while len(q) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT state = q.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sKey = getHashKey(state) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT found = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for rstate, no, direction in rotate(state): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rKey = getHashKey(rstate) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if rKey == startKey: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT found = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not visited.has_key(rKey): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[rKey] = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT backTrack[rKey] = (sKey, no, direction, state) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.insert(0, rstate) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if found: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printSolution(startKey) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _NEWLINE def rotate(state): _NEWLINE  _INDENT  _INDENT for no in range(3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for direction in ['L', 'R']: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = state[:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rot = rotations[no][direction] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prev = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = result[rot[prev]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for cur in range(1, 6): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result[rot[prev]] = result[rot[cur]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prev = cur _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result[rot[prev]] = tmp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield result, no, direction _NEWLINE  _NEWLINE noTestCases = int(sys.stdin.readline().rstrip()) _NEWLINE while noTestCases > 0: _NEWLINE  _INDENT  _INDENT noTestCases -= 1 _NEWLINE  _INDENT  _INDENT state = sys.stdin.readline().rstrip() _NEWLINE  _INDENT  _INDENT key = getHashKey(state) _NEWLINE  _INDENT  _INDENT if backTrack.has_key(key): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printSolution(key) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT solve(key) _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = raw_input().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pl = [i for i in a+b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c += raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cl = [i for i in c] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in set(cl): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if cl.count(i) > pl.count(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' if flag else 'YES'
def is_subsequence(male, female): _NEWLINE 	if len(male) >= len(female): _NEWLINE 		f = 0 _NEWLINE 		for i in range(len(male)): _NEWLINE 			if male[i] == female[f]: _NEWLINE 				f += 1 _NEWLINE 			if f == len(female): return True _NEWLINE 		return False _NEWLINE 	return False _NEWLINE  _NEWLINE test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	male, female = map(str, raw_input().split()) _NEWLINE 	if is_subsequence(male, female) or is_subsequence(female, male): _NEWLINE 		print 'YES' _NEWLINE 	else: _NEWLINE 		print 'NO'
import string _NEWLINE dic = list(string.ascii_lowercase) _NEWLINE n=input() _NEWLINE while n > 0 : _NEWLINE  _INDENT  _INDENT t = input() _NEWLINE  _INDENT  _INDENT if t < 27 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print string.ascii_lowercase[0:t] _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = string.ascii_lowercase _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a *= t/26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = a[0:t % 26] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a += b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print a _NEWLINE  _INDENT  _INDENT n -= 1 _NEWLINE 
while 1: _NEWLINE  _INDENT  _INDENT n = raw_input() _NEWLINE  _INDENT  _INDENT if n == '': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT n = int(n) _INDENT  _NEWLINE  _INDENT  _INDENT if n == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT users = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(0 , n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vote , score = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score = int(score) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if vote == 'P': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vote = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vote = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score -= vote _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score = abs(score) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if score >= users: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT users = score _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT users += (score - users)%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT print users
import sys _NEWLINE import logging _NEWLINE import copy _NEWLINE from heapq import * _NEWLINE import cProfile _NEWLINE from math import * _NEWLINE  _NEWLINE class Map: _NEWLINE  _NEWLINE 	def __init__(self): _NEWLINE 		self.map = [] _NEWLINE  _NEWLINE 	def read_map(self,f): _NEWLINE 		size_d = f.readline().split() _NEWLINE 		self.height = int(size_d[0]) _NEWLINE 		self.width = int(size_d[1]) _NEWLINE 		logging.info("Size: %s x %s", self.height, self.width)	 _NEWLINE 		for i in range(0,self.height): _NEWLINE 			self.map.extend([int(x) for x in f.readline().strip().split()]) _NEWLINE 		p_l = f.readline().split() _NEWLINE 		self.p_y = int(p_l[0])-1 _NEWLINE 		self.p_x = int(p_l[1])-1 _NEWLINE 		self.p_pos = self.p_y * self.width + self.p_x _NEWLINE 		self.T = int(p_l[2]) _NEWLINE 		logging.info("Princess x: %d y: %d , T=%d", self.p_x, self.p_y, self.T) _NEWLINE  _NEWLINE  _NEWLINE 	def build_neighbour_list(self): _NEWLINE 		size = len(self.map) _NEWLINE 		self.neighbours = size * [None] _NEWLINE 		 _NEWLINE 		h = self.height _NEWLINE 		w = self.width _NEWLINE # Corners _NEWLINE 		self.neighbours[0] = [1,w] _NEWLINE 		ne = w-1 _NEWLINE 		self.neighbours[ne] = [ne-1,ne+w] _NEWLINE 		sw = size-w _NEWLINE 		self.neighbours[sw] = [sw+1,sw-w] _NEWLINE 		se = size-1 _NEWLINE 		self.neighbours[se] = [se-1,se-w] _NEWLINE  _NEWLINE # Top row _NEWLINE 		for i in range(1,w-1): _NEWLINE 			self.neighbours[i]=[i-1,i+1,i+w] _NEWLINE # Bottom row _NEWLINE 		for i in range(size-w+1,size-1): _NEWLINE 			self.neighbours[i]=[i-1,i+1,i-w] _NEWLINE # Left and right columns _NEWLINE 		for i in range(1,h-1): _NEWLINE 			l = i*w _NEWLINE 			r = (i+1)*w-1 _NEWLINE 			self.neighbours[l]=[l-w,l+w,(l+1)] _NEWLINE 			self.neighbours[r]=[r-w,r+w,(r-1)] _NEWLINE 			 _NEWLINE 		for i in xrange(size): _NEWLINE 			if not self.neighbours[i]: _NEWLINE 				self.neighbours[i]=[i-w, i-1, i+1, i+w] _INDENT _NEWLINE  _NEWLINE 			 _NEWLINE 	def print_map(self): _NEWLINE 		for n in range(self.height): _NEWLINE 			i = n*self.width _NEWLINE 			print self.map[i:i+self.width] _NEWLINE 		 _NEWLINE 	def get_neighbours(self,pos): _NEWLINE 		return self.neighbours[pos] _NEWLINE  _NEWLINE  _NEWLINE 	def init_dist_map(self): _NEWLINE 		self.dist_map=self.height*self.width * [None] _NEWLINE 			 _NEWLINE  _NEWLINE 	def solve(self): _NEWLINE 		h = [] _NEWLINE 		T = self.T - self.map[self.p_pos] _NEWLINE 		heappush(h, (-T,self.p_pos)) _NEWLINE 		 _NEWLINE 		while h: _NEWLINE 			(T, pos) = heappop(h) _NEWLINE 			T = -T _NEWLINE 			if T < 0: _NEWLINE 				break; _NEWLINE  _NEWLINE 			if not self.dist_map[pos] or (self.dist_map[pos] < T): _NEWLINE 				self.dist_map[pos]=T _NEWLINE 				for p in self.get_neighbours(pos): _NEWLINE 					if self.dist_map[p] == None: _NEWLINE 						heappush(h, (self.map[p]-T,p))	 _NEWLINE 			 _NEWLINE 		 _NEWLINE 		spare_time = self.dist_map[0] _NEWLINE 		if spare_time >= 0: _NEWLINE 			print "YES" _NEWLINE 			print spare_time _NEWLINE 		else: _NEWLINE 			print "NO" _NEWLINE 			 _NEWLINE 			 _NEWLINE def run(): _NEWLINE #	logging.basicConfig(level=logging.DEBUG) _NEWLINE 	m = Map() _NEWLINE 	m.read_map(sys.stdin) _NEWLINE 	m.build_neighbour_list() _NEWLINE 	m.init_dist_map() _NEWLINE 	m.solve() _NEWLINE  _NEWLINE  _NEWLINE run() _NEWLINE #cProfile.run('run()') _NEWLINE 
mod=1000000007 _NEWLINE t=input() _NEWLINE  _NEWLINE while t: _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT print (pow(3,n,mod)+3*pow(-1,n))%mod _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
import math _NEWLINE listx=[0]*10 _NEWLINE def no(x): _NEWLINE  _INDENT  _INDENT i=int(x)-1 _NEWLINE  _INDENT  _INDENT el=0 _NEWLINE  _INDENT  _INDENT while(i>=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT el+=listx[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i-=1 _NEWLINE  _INDENT  _INDENT return el _NEWLINE t=int(raw_input().strip()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT listx=[0]*10 _NEWLINE  _INDENT  _INDENT num=raw_input().strip() _NEWLINE  _INDENT  _INDENT for i in num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT listx[int(i)]+=1 _NEWLINE  _INDENT  _INDENT leng=len(num)-1 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while leng>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=no(num[i])*math.factorial(leng) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(temp>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for x in listx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp/=math.factorial(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT listx[int(num[i])]-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT leng-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT ans+=no(num[i]) _NEWLINE  _INDENT  _INDENT print(ans) _NEWLINE 
#include <stdio.h> _NEWLINE  _INDENT _NEWLINE #define min(A,B) ((A) > (B) ? (B) : (A)) _NEWLINE #define max(A,B) ((A) > (B) ? (A) : (B)) _NEWLINE  _INDENT _NEWLINE int main(void){ _NEWLINE 	int testCount; _NEWLINE 	scanf("%d", &testCount); _NEWLINE  _INDENT _NEWLINE 	while (testCount--){ _NEWLINE 		int cars, wander, ready, p, r, k; _NEWLINE 		int doneCount, ridingCount, carsWaiting; _NEWLINE 		int carArrives[50]; _NEWLINE 		int becomeReady[5100]; _NEWLINE 		int nextCar; _NEWLINE 		int totalPeople; _NEWLINE 		int i, time; _NEWLINE  _INDENT _NEWLINE 		scanf("%d %d %d %d %d %d", &cars, &wander, &ready, &p, &r, &k); _NEWLINE 		 _NEWLINE 		if (cars == 0){ _NEWLINE 			int movedToReady = min(wander, k/r); _NEWLINE 			printf("0 0 %d %d\n", wander - movedToReady, ready + movedToReady); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		doneCount = ridingCount = 0; _NEWLINE  _INDENT _NEWLINE 		for (i = 0; i < cars; i++) _NEWLINE 			carArrives[i] = 0; _NEWLINE 		 _NEWLINE 		totalPeople = wander+ready; _NEWLINE 		for (i = 0; i < ready; i++) _NEWLINE 			becomeReady[i] = 0; _NEWLINE 		for (i = ready; i < totalPeople; i++) _NEWLINE 			becomeReady[i] = (i-ready+1)*r; _NEWLINE  _INDENT _NEWLINE 		nextCar = 0; _NEWLINE 		for (i = 0; i < totalPeople; i++){ _NEWLINE 			int readyTime = becomeReady[i]; _NEWLINE 			if (readyTime > k) _NEWLINE 				break; _NEWLINE 			 _NEWLINE 			if (carArrives[nextCar] > readyTime) _NEWLINE 				readyTime = carArrives[nextCar]; _NEWLINE 			carArrives[nextCar] = readyTime + p; _NEWLINE 			nextCar = (nextCar+1) % cars; _NEWLINE  _INDENT _NEWLINE 			if (readyTime + p <= k) _NEWLINE 				doneCount++; _NEWLINE 			else if (readyTime <= k) _NEWLINE 				ridingCount++; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		carsWaiting = 0; _NEWLINE 		for (i = 0; i < cars; i++) _NEWLINE 			if (carArrives[i] <= k) _NEWLINE 				carsWaiting++; _NEWLINE  _INDENT _NEWLINE 		printf("%d %d %d %d\n", carsWaiting, doneCount, max(0, wander - k/r), ready + min(wander, k/r) - doneCount - ridingCount); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	return 0; _NEWLINE } 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <climits> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long adj[2510][2510]; _NEWLINE long long swe(pair<int,int> const &p1,pair<int,int> const & p2) _NEWLINE { _NEWLINE 	return (long long)(p1.first - p2.first)*(p1.first-p2.first)+ _NEWLINE 		(long long)(p1.second-p2.second)*(p1.second-p2.second); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		vector<pair<int,int>> pos(n+2); _NEWLINE 		for(int i=0;i<n+2;++i) _NEWLINE 		{ _NEWLINE 			cin>>pos[i].first>>pos[i].second; _NEWLINE 			for(int j=0;j<=i;++j) _NEWLINE 			{ _NEWLINE 				adj[i][j] = adj[j][i] = swe(pos[i],pos[j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		vector<long long> dis(n+2,INT_MAX); _NEWLINE 		dis[n]=0; _NEWLINE 		vector<char> visit(n+2,0); _NEWLINE 		while(1) _NEWLINE 		{ _NEWLINE 			int idx=-1,mi=INT_MAX; _NEWLINE 			for(int i=0;i<n+2;++i) _NEWLINE 			{ _NEWLINE 				if(visit[i]==0 && dis[i]<mi) _NEWLINE 				{ _NEWLINE 					idx=i; _NEWLINE 					mi = dis[i]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(idx==-1) break; _NEWLINE 			visit[idx]=1; _NEWLINE 			for(int i=0;i<n+2;++i) _NEWLINE 			{ _NEWLINE 				if(visit[i]==0) _NEWLINE 				{ _NEWLINE 					dis[i] = min(dis[i],mi+adj[i][idx]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<dis[n+1]<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT x=len(s)*11 _NEWLINE  _INDENT  _INDENT y=ord(s[0])-97 _NEWLINE  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT while i<len(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w=ord(s[i])-97 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(w>=y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=w-y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=w _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=26-y+w _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=w _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT sum+=(len(s)+1) _NEWLINE  _INDENT  _INDENT if sum>x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
/* _INDENT IF THIS COMMENT IS REMOVED THE PROGRAM WIint BLOW UP _NEWLINE  * _NEWLINE  * _INDENT Copyright (c) 2016, Aadil _NEWLINE  * _INDENT Aint rights reserved. _NEWLINE  * _NEWLINE  * _INDENT This program is licensed under the F**cked_UP_Coder (FUP) License v0.2 _NEWLINE  * _NEWLINE  * _INDENT You can use this program freely, if : _NEWLINE  * _INDENT - this code works :P _NEWLINE  * _INDENT - you are a FUP _NEWLINE  */ _NEWLINE  _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <climits> _NEWLINE #include <string> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef long double ld; _NEWLINE typedef unsigned long long ull; _NEWLINE #define input0based(arr, n) for(ll i = 0; i < n; ++i) cin >> arr[i]; _NEWLINE #define input1based(arr, n) for(ll i = 1; i <= n; ++i) _INDENT cin >> arr[i]; _NEWLINE #define forLoop(start, end) for(ll i = (start); i < (end); ++i) _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT cin.sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ll t; _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT vector<string> arr; _NEWLINE  _INDENT  _INDENT cin.clear(); _NEWLINE  _INDENT  _INDENT cin.ignore(INT_MAX, '\n'); _NEWLINE  _INDENT  _INDENT string temp; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ll z = t; _NEWLINE  _INDENT  _INDENT while (z-- > 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getline(cin, temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.push_back(temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (ll i = 0; i < t; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ch[26] = { 0 }; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll len = arr[i].length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (ll j = 0; j < len; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (arr[i][j] >= 'A' && arr[i][j] <= 'Z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++ch[tolower(arr[i][j]) % 97]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if (arr[i][j] >= 'a' && arr[i][j] <= 'z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++ch[arr[i][j] % 97]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char x = '~'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (ll i = 0; i < 26; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout << ch[i] << " "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (ch[i] == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = i + 97; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << x << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
def sum_pair_less_than(v, S): _NEWLINE 	i,j,pair_count = 0,len(v)-1,0 _NEWLINE 	while i < j: _NEWLINE 		if v[i]+v[j] < S : _NEWLINE 			pair_count += j-i _NEWLINE 			i+=1 _NEWLINE 		else: _NEWLINE 			j-=1 _NEWLINE 	return pair_count _NEWLINE  _NEWLINE def not_a_triangle_count(v): _NEWLINE 	non_tri_count = 0 _NEWLINE 	v.sort() _NEWLINE 	i=len(v)-1 _NEWLINE 	while i >= 2 : _NEWLINE 		non_tri_count += sum_pair_less_than(v[0:i],v[i]) _NEWLINE 		i-=1 _NEWLINE 	return non_tri_count _NEWLINE  _NEWLINE while True: _NEWLINE 	n = input() _NEWLINE 	if n==0 : _NEWLINE 		exit() _NEWLINE 	v = [int(x) for x in raw_input().split(' ')] _NEWLINE 	print not_a_triangle_count(v)
statement = raw_input('') _NEWLINE a,n,k = statement.split(' ') _NEWLINE a= int(a) _NEWLINE n = int(n) _NEWLINE k = int(k) _NEWLINE numb = 0 _NEWLINE for i in range(0,k): _NEWLINE 	numb = a%(n+1) _NEWLINE 	print(numb) _NEWLINE 	a = _INDENT a //(n+1) _NEWLINE 
from operator import itemgetter _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT arr=[] _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b=map(str,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=int(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append([a,b]) _NEWLINE  _INDENT  _INDENT arr=sorted(arr,key=itemgetter(1)) _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print arr[0][0] _NEWLINE  _INDENT  _INDENT elif arr[0][1]!=arr[1][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print arr[0][0] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print arr _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[j][1]!=arr[j-1][1] and arr[j][1]!=arr[j+1][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print arr[j][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flag==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[n-1][1]!=arr[n-2][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print arr[n-1][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Nobody wins."
for i in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n%4==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "ALICE" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "BOB" _NEWLINE 
md = 1000000007 _NEWLINE n,b = map(int,raw_input().split()) _NEWLINE  _NEWLINE sum = [] _NEWLINE dp = [] _NEWLINE l = [0] _NEWLINE for i in range(n): _NEWLINE 	t = int(raw_input()) _NEWLINE 	l.append(t) _NEWLINE  _NEWLINE for i in range(n+5): _NEWLINE 	dp.append(0) _NEWLINE 	sum.append(0) _NEWLINE  _NEWLINE dp[b] = 1 _NEWLINE sum[b] = 1 _NEWLINE  _NEWLINE for i in range(b-1,0,-1): _NEWLINE 	dp[i] = (sum[i+1]-sum[i+1+l[i]])%md _NEWLINE 	sum[i] = (dp[i]+sum[i+1])%md _NEWLINE  _NEWLINE  _NEWLINE q = int(raw_input()) _NEWLINE for i in range(q): _NEWLINE 	t = int(raw_input()) _NEWLINE 	print dp[t] _NEWLINE 
def f(n): _NEWLINE 	divsum = 0 _NEWLINE 	for i in xrange(1, n + 1, 2): _NEWLINE 		divsum += i * (n / i) _NEWLINE 	return divsum _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE 	T = raw_input() _NEWLINE 	T = int(T) _NEWLINE 	while(T > 0): _NEWLINE 		T -= 1 _NEWLINE 		l_and_r = raw_input() _NEWLINE 		l, r = l_and_r.split() _NEWLINE 		l = int(l) _NEWLINE 		r = int(r) _NEWLINE 		print f(r) - f(l-1)
a=int(raw_input()) _NEWLINE r=a%6 _NEWLINE if r==0 or r==1 or r==3 or r==6 : _NEWLINE 	print "yes" _NEWLINE else : _NEWLINE 	print "no" _NEWLINE 	
t=input() _NEWLINE while(t>0): _NEWLINE 	hh,mm=map(int,raw_input().strip().split()) _NEWLINE 	acc=0 _NEWLINE 	for i in xrange(hh): _NEWLINE 		for j in xrange(mm): _NEWLINE 			if len(set(str(i)+str(j)))==1: _NEWLINE 				acc+=1 _NEWLINE 	print acc _NEWLINE 	t-=1			
# your code goes here _NEWLINE n = int(raw_input()) _NEWLINE arr = map(int, raw_input().split()) _NEWLINE # arr.sort() _NEWLINE extra = 0 _NEWLINE ans = 0 _NEWLINE sum = 0 _NEWLINE for i in arr: _NEWLINE 	sum += i _NEWLINE sum += (sum%2) _NEWLINE sum /= 2 _NEWLINE ans = max(sum,n) _NEWLINE print ans
n = input() _NEWLINE for i in range(0,n): _NEWLINE  _INDENT  _INDENT p = input() _NEWLINE  _INDENT  _INDENT box = [] _NEWLINE  _INDENT  _INDENT band = [] _NEWLINE  _INDENT  _INDENT t = raw_input() _NEWLINE  _INDENT  _INDENT t = t.split() _NEWLINE  _INDENT  _INDENT for j in range(0,p): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT box.append(4*int(t[j])) _NEWLINE  _INDENT  _INDENT q = input() _NEWLINE  _INDENT  _INDENT for k in range(0,q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = a.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT band.append((2*22.0/7*int(b[0]),2*22.0/7*int(b[1]))) _NEWLINE  _INDENT  _INDENT box = sorted(box,reverse=True) _NEWLINE  _INDENT  _INDENT band = sorted(band,key=lambda band:band[0],reverse=True) _NEWLINE  _INDENT  _INDENT band_e = sorted(band,key=lambda band:band[1],reverse=True) _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT exi=0 _NEWLINE  _INDENT  _INDENT while len(box)!=0 and len(band)!=0 and len(band_e)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while len(band)!=0 and len(box)!=0 and box[0]<band[0][0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT band_e.remove(band.pop(0)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(band)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exi=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if exi==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if box[0]>band_e[0][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT box.pop(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while t<len(band): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if band[t][1]>=box[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT band_e.remove(band.pop(t)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t= t+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT box.pop(0) _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
output = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	pairs = list() _NEWLINE 	avail = list() _NEWLINE 	output1 = list() _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	n = int(nums[0]) _NEWLINE 	m = int(nums[1]) _NEWLINE 	for j in range(m) : _NEWLINE 		string2 = raw_input() _NEWLINE 		num = string2.split() _NEWLINE 		a = int(num[0]) _NEWLINE 		b = int(num[1]) _NEWLINE 		pairs.append(a) _NEWLINE 		pairs.append(b) _NEWLINE 	output1.append(m-1) _NEWLINE 	spe1 = pairs[-1] _NEWLINE 	spe2 = pairs[-2] _NEWLINE 	avail = range(n) _NEWLINE 	avail.remove(spe1) _NEWLINE 	avail.remove(spe2) _NEWLINE 	c = m-2 _NEWLINE 	for j in range(((2*m)-3),-1,-2) : _NEWLINE 		if pairs[j] in avail : _NEWLINE 			if pairs[j-1] in avail : _NEWLINE 				output1.append(c) _NEWLINE 				avail.remove(pairs[j]) _NEWLINE 				avail.remove(pairs[j-1]) _NEWLINE 		c = c - 1 _NEWLINE 	output1.sort() _NEWLINE 	for j in range(len(output1)) : _NEWLINE 		output1[j] = str(output1[j]) _NEWLINE 	strfinal = ' '.join(output1) _NEWLINE 	output.append(strfinal) _NEWLINE for i in range(t) : _NEWLINE 	print output[i] _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
test=int(raw_input()) _NEWLINE dp=[[0 for _ in range(0,1002)] for _ in range(0,1002)] _NEWLINE mod=1e9+7 _NEWLINE for i in range(1,1001): _NEWLINE 	dp[i][i]=1 _NEWLINE for i in range(1,1001): _NEWLINE 	for j in range(1,i): _NEWLINE 		dp[i][j]=(dp[i-1][j]*j+dp[i-1][j-1])%mod _NEWLINE for _ in range(0,test): _NEWLINE 	n=int(raw_input()) _NEWLINE 	ans=0 _NEWLINE 	for i in range(0,n+1): _NEWLINE 		ans=(ans+dp[n][i])%mod _NEWLINE 	print int(ans) _NEWLINE 
n=input() _NEWLINE li=list(map(int,raw_input().split())) _NEWLINE dp=[0]*n _NEWLINE temp=[] _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT t=[] _NEWLINE  _INDENT  _INDENT if dp[i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t.append(j+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while dp[j]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t.append(li[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=li[j]-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp.append(t) _NEWLINE print len(temp) _NEWLINE for i in temp: _NEWLINE  _INDENT  _INDENT for j in i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print j, _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
intv_new = [] _NEWLINE def bsearch(lo, hi, key): _NEWLINE 	global intv_new _NEWLINE 	mid = 0 _NEWLINE 	while hi >= lo: _NEWLINE 		mid = (hi + lo)/2 _NEWLINE 		if key[0] < intv_new[mid][0]: _NEWLINE 			hi = mid-1 _NEWLINE 		elif key[1] > intv_new[mid][1]: _NEWLINE 			lo = mid+1 _NEWLINE 		elif key[0] >= intv_new[mid][0] and key[1] <= intv_new[mid][1]: _NEWLINE 			return True _NEWLINE 	return False _NEWLINE  _NEWLINE t = input() _NEWLINE while t != 0: _NEWLINE 	t -=1 _INDENT _NEWLINE 	fg = False _NEWLINE 	perm,intv,l,r = [],[],0,0 _NEWLINE 	intv_new = [] _NEWLINE 	nt = () _NEWLINE 	n,m = map(int, raw_input().strip().split()) _INDENT _NEWLINE 	perm = map(int, raw_input().strip().split()) _INDENT _NEWLINE 	for _ in xrange(m): _NEWLINE 		l,r = map(int,raw_input().strip().split()) _INDENT _NEWLINE 		intv.append((l,r)) _NEWLINE 	intv = sorted(intv) _NEWLINE 	prev = intv[0] _INDENT _NEWLINE 	for i in intv[1:]: _NEWLINE 		#left matches,or right.. merge them.. _NEWLINE 		if prev[1] == i[0]+1 or prev[1] >= i[0]: _NEWLINE 			prev = (prev[0],max(i[1],prev[1])) _NEWLINE 		#else add to new intv list _NEWLINE 		else: _NEWLINE 			intv_new.append(prev) _NEWLINE 			prev = i _INDENT _NEWLINE 	intv_new.append(prev) _NEWLINE 	for i in xrange(n): _NEWLINE 		if not i+1 == perm[i] and i+1 < perm[i] and not bsearch(0,len(intv_new)-1,(min(i+1,perm[i]),max(i+1,perm[i]))): _NEWLINE 			print "Impossible" _NEWLINE 			fg = True _INDENT _NEWLINE 			break _NEWLINE 	if not fg: _NEWLINE 		print "Possible" _NEWLINE 
def p(s): _NEWLINE 	print "".join(map(str,s)) _NEWLINE def f(i): _NEWLINE 	op = [] _NEWLINE 	if i == 'a': return 0 _NEWLINE 	if i == 'b': return 1 _NEWLINE 	if i == 'c': return 2 _NEWLINE 	if i == 'd': return 3 _INDENT _NEWLINE 	if i == 'e': return 4 _NEWLINE 	if i == 'A': return 5 _NEWLINE 	if i == 'B': return 6 _NEWLINE 	if i == 'C': return 7 _NEWLINE 	if i == 'D': return 8 _NEWLINE 	if i == 'E': return 9 _NEWLINE  _NEWLINE  _NEWLINE T = input() _NEWLINE d = { _NEWLINE 		'a':['e', 'b', 'A'], _NEWLINE 		'b':['a', 'c', 'B'], _NEWLINE 		'c':['b', 'd', 'C'], _NEWLINE 		'd':['c', 'e', 'D'], _NEWLINE 		'e':['d', 'a', 'E'], _NEWLINE 		'A':['C', 'D', 'a'], _NEWLINE 		'B':['D', 'E', 'b'], _NEWLINE 		'C':['E', 'A', 'c'], _NEWLINE 		'D':['A', 'B', 'd'], _NEWLINE 		'E':['B', 'C', 'e'] _NEWLINE 	} _NEWLINE while T > 0: _NEWLINE 	T -= 1 _NEWLINE 	s = raw_input() _NEWLINE 	i = 1 _NEWLINE 	l = [] _NEWLINE 	l.append(f(s[0].lower())) _NEWLINE 	while i < len(s): _NEWLINE 		x = f(s[i]) _NEWLINE 		y = f(s[i].lower()) _NEWLINE 		 _NEWLINE 		if l[-1] < 5: _NEWLINE 			if x == l[-1] + 5: _NEWLINE 				l.append(x) _NEWLINE 			elif y == (l[-1]+1) % 5 or y == (l[-1]-1) %5: _NEWLINE 				l.append(y) _NEWLINE 			else: break _NEWLINE 		 _NEWLINE 		else: _NEWLINE 			if y == l[-1] - 5: _NEWLINE 				l.append(y) _NEWLINE 			elif abs(l[-1]-x) == 2 or abs(l[-1]-x) == 3: _NEWLINE 				l.append(x) _NEWLINE 			else: break _NEWLINE  _NEWLINE 		i += 1 _NEWLINE 	if len(l) == len(s): _NEWLINE 		p(l) _NEWLINE 	else: _NEWLINE 		i = 1 _NEWLINE 		l = [] _NEWLINE 		l.append(f(s[0])) _NEWLINE 		while i < len(s): _NEWLINE 			x = f(s[i]) _NEWLINE 			y = f(s[i].lower()) _NEWLINE 			 _NEWLINE 			if l[-1] < 5: _NEWLINE 				if x == l[-1] + 5: _NEWLINE 					l.append(x) _NEWLINE 				elif y == (l[-1]+1) % 5 or y == (l[-1]-1) %5: _NEWLINE 					l.append(y) _NEWLINE 				else: break _NEWLINE 			 _NEWLINE 			else: _NEWLINE 				if y == l[-1] - 5: _NEWLINE 					l.append(y) _NEWLINE 				elif abs(l[-1]-x) == 2 or abs(l[-1]-x) == 3: _NEWLINE 					l.append(x) _NEWLINE 				else: break _NEWLINE  _NEWLINE 			i += 1 _NEWLINE 		if len(l) == len(s): _NEWLINE 			p(l) _NEWLINE 		else: _NEWLINE 			print -1
for _ in range(input()): _NEWLINE 	s=raw_input() _NEWLINE 	n=input() _NEWLINE 	t,st=0,0 _NEWLINE 	for i in s: _NEWLINE 		if i=='T': _NEWLINE 			t+=2 _NEWLINE 			#print t _NEWLINE 		else: _NEWLINE 			st+=1 _NEWLINE 	sum=t+st _NEWLINE 	#print sum _NEWLINE 	temp=12*n _NEWLINE 	j,i,c=temp,1,0 _NEWLINE 	while i<=temp: _NEWLINE 		j=temp-i _NEWLINE 		while j: _NEWLINE 			j-=sum _NEWLINE 			if j>=0: _NEWLINE 				c+=1 _NEWLINE 			 _NEWLINE 			if j-sum<0: _NEWLINE 				break _NEWLINE 		i+=1 _NEWLINE 		if temp-i<sum: _NEWLINE 			break _NEWLINE 	print c	 _NEWLINE 		
t = int(raw_input()) _NEWLINE for _ in xrange(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	mi = 100000000000 _NEWLINE 	mii = -1 _NEWLINE 	ma = -1 _NEWLINE 	mai = -1 _NEWLINE 	ans = -1 _NEWLINE 	mi = a[0] _NEWLINE 	for i in range(1,n): _NEWLINE 		if a[i]<mi: _NEWLINE 			mi = a[i] _NEWLINE 		elif a[i]>mi: _NEWLINE 			ans = max(ans, a[i] - mi) _NEWLINE 	if ans == -1: _NEWLINE 		print "UNFIT" _NEWLINE 	else: _NEWLINE 		print ans
import math _NEWLINE test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	l, d , s ,c = map(int, raw_input().split()) _NEWLINE 	#print 'log value =', math.log(s) + (d-1) * math.log(c+1) - math.log(l), 'log(s) =', math.log(s), '(d-1) * log(c+1) =', (d-1)* math.log(c+1), 'log(l) =', math.log(l) _NEWLINE 	if math.log(s) + (d-1)*math.log(c+1) - math.log(l) < 0: _NEWLINE 		print 'DEAD AND ROTTING' _NEWLINE 	else: _NEWLINE 		print 'ALIVE AND KICKING'
from operator import itemgetter _NEWLINE N,M,H = map(int,raw_input().split()); residual = N * M; cost = 0 _NEWLINE L = sorted([tuple(map(int,raw_input().split())) for i in range(H)],key=itemgetter(1)) _NEWLINE for pair in L: _NEWLINE  _INDENT  _INDENT if pair[0] <= residual: cost += (pair[0] * pair[1]); residual -= pair[0] _NEWLINE  _INDENT  _INDENT elif pair[0] > residual: cost += (residual * pair[1]); residual = 0 _NEWLINE  _INDENT  _INDENT if residual == 0: print cost; break _NEWLINE else: print 'Impossible' _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _NEWLINE 
totalCases = int(raw_input()) _NEWLINE for i in range(totalCases): _NEWLINE  _INDENT  _INDENT cards = [] _NEWLINE  _INDENT  _INDENT cards.extend(raw_input().split()) _NEWLINE  _INDENT  _INDENT values = [] _NEWLINE  _INDENT  _INDENT suits = [] _NEWLINE  _INDENT  _INDENT for item in cards: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT values.append(item[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT suits.append(item[1]) _NEWLINE  _INDENT  _INDENT aceInHand = 0 _NEWLINE  _INDENT  _INDENT for j in range(len(values)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if values[j] == 'A': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 14 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT aceInHand = j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'K': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 13 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'Q': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 12 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'J': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 11 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = int(values[j]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #First check for hands that deal with being in order: _NEWLINE  _INDENT  _INDENT flush = 0 _NEWLINE  _INDENT  _INDENT straight = 0 _NEWLINE  _INDENT  _INDENT royal = 0 _NEWLINE  _INDENT  _INDENT if suits[0] == suits[1] and suits[0] == suits[2] and suits[0] == suits[3] and suits[0] == suits[4]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flush = 1 _NEWLINE  _INDENT  _INDENT tempValues = [] _NEWLINE  _INDENT  _INDENT tempValues.extend(values) _NEWLINE  _INDENT  _INDENT tempValues.sort() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if tempValues[4] == 14 and tempValues[3] == 13 and tempValues[2] == 12 and tempValues[1] == 11 and tempValues[0] == 10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT royal = 1 _NEWLINE  _INDENT  _INDENT if (tempValues[4] - tempValues[3]) == 1 and (tempValues[3] - tempValues[2]) == 1 and (tempValues[2] - tempValues[1]) == 1 and (tempValues[1] - tempValues[0]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT straight = 1 _NEWLINE  _INDENT  _INDENT if aceInHand: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues.extend(values) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues[aceInHand-1] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (tempValues[4] - tempValues[3]) == 1 and (tempValues[3] - tempValues[2]) == 1 and (tempValues[2] - tempValues[1]) == 1 and (tempValues[1] - tempValues[0]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT straight = 1 _NEWLINE  _INDENT  _INDENT if royal and flush: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "royal flush" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif straight and flush: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "straight flush" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif flush: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "flush" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif straight: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "straight" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #Next deal with hands that require multiple of a value: _NEWLINE  _INDENT  _INDENT fourOfAKind = 0 _NEWLINE  _INDENT  _INDENT threeOfAKind = 0 _NEWLINE  _INDENT  _INDENT pair = 0 _NEWLINE  _INDENT  _INDENT for x in range(13): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cardCount = values.count(x+2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if cardCount == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fourOfAKind = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif cardCount == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT threeOfAKind = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif cardCount == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pair += 1 _NEWLINE  _INDENT  _INDENT if fourOfAKind: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "four of a kind" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if threeOfAKind and pair: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "full house" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if threeOfAKind: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "three of a kind" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if pair == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "two pairs" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if pair == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "pair" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT print "high card" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
prime=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173 _INDENT _NEWLINE ,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281 _INDENT _NEWLINE ,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409 _INDENT _NEWLINE ,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541 _INDENT _NEWLINE ,547,557,563,569,571,577,587,593,599,601 _INDENT _NEWLINE ,607,613,617,619,631,641,643,647,653,659 _INDENT _NEWLINE ,661,673,677,683,691,701,709,719,727,733 _INDENT _NEWLINE ,739,743,751,757,761,769,773,787,797,809 _INDENT _NEWLINE ,811,821,823,827,829,839,853,857,859,863 _INDENT _NEWLINE ,877,881,883,887,907,911,919,929,937,941 _INDENT _NEWLINE ,947,953,967,971,977,983,991,997,1009,1013 _INDENT _NEWLINE ,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069 _INDENT _NEWLINE ,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151 _INDENT _NEWLINE ,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223 _INDENT _NEWLINE ,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291 _INDENT _NEWLINE ,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373 _INDENT _NEWLINE ,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451 _INDENT _NEWLINE ,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511 _INDENT _NEWLINE ,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583 _INDENT _NEWLINE ,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657 _INDENT _NEWLINE ,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733 _INDENT _NEWLINE ,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811 _INDENT _NEWLINE ,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889 _INDENT _NEWLINE ,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987 _INDENT _NEWLINE ,1993,1997,1999,2003] _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT L=[int(x) for x in raw_input().split(' ')] _NEWLINE  _INDENT  _INDENT x=L[0]+L[1] _NEWLINE  _INDENT  _INDENT for i in range(0,len(prime)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prime[i] > x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print(prime[i]-x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
import sys _NEWLINE import math _NEWLINE  _NEWLINE t= int(sys.stdin.readline()) _NEWLINE while(t>0) : _NEWLINE 	t = t-1 _NEWLINE 	l,r = sys.stdin.readline().split(' ') _NEWLINE 	l = int(l) _NEWLINE 	r = int(r) _NEWLINE 	cat1 = int(math.log10(l)); _NEWLINE 	cat2 = int(math.log10(r)); _NEWLINE 	if cat1==cat2: _NEWLINE 		sum = _INDENT (r*(r+1)/2 - (l*(l-1)/2))*(cat1+1); _NEWLINE 		print sum%1000000007 _NEWLINE 	else: _NEWLINE 		cat1 = cat1+1 _NEWLINE 		num1 = pow(10,cat1); _NEWLINE 		num2 = pow(10,cat2); _NEWLINE 		sum1 = (((num1-1)*num1)/2 - (l*(l-1))/2)*cat1; _NEWLINE 		sum2 = ((r*(r+1))/2 - ((num2-1)*num2)/2)*(cat2+1); _NEWLINE 		sum3 = 0; _NEWLINE 		for i in range(cat1, cat2):			 _NEWLINE 			num1 = pow(10,i); _NEWLINE 			num2 = pow(10,i+1); _NEWLINE 			sum3 += _INDENT (num2*(num2-1)/2 - (num1*(num1-1)/2))*(i+1); _NEWLINE 		print (sum1+sum2+sum3)%1000000007 _NEWLINE 	
def check(w,n,arr,stock): _NEWLINE 	#print "func" _NEWLINE 	#print "w,n",w,n _NEWLINE 	if(w<0): _NEWLINE 		#print "return----" _NEWLINE 		return -arr[n][1] _NEWLINE 	if(stock[w][n]>=0 or w==0 or n==0): _NEWLINE 		return stock[w][n] _NEWLINE 	#print "return" _NEWLINE 	#print "w,n,c1",w-arr[n-1][0],n-1,c1 _NEWLINE 	#print "w,n,c2",w,n-1,c2 _NEWLINE 	#if(stock[w][n]!=-1): _NEWLINE 		#return stock[w][n] _NEWLINE 	#else: _NEWLINE 		#stock[w][n]= _INDENT _NEWLINE 	stock[w][n]= max(check(w-arr[n-1][0],n-1,arr,stock)+arr[n-1][1],check(w,n-1,arr,stock)) _NEWLINE 	return stock[w][n] _NEWLINE 	#print "max1",max1 _NEWLINE  _NEWLINE t=input() _NEWLINE while(t): _NEWLINE 	t-=1 _NEWLINE 	n,w=map(int,raw_input().split()) _NEWLINE 	arr=[];stock=[[-1 for i in range(n+1)]for j in range(w+1)] _NEWLINE 	i=0 _NEWLINE 	while(i<n): _NEWLINE 		stock[0][i]=0 _NEWLINE 		a=map(int,raw_input().split()) _NEWLINE 		arr.append([a[2],a[0]*a[1]]) _NEWLINE 		i+=1 _NEWLINE 	i=0 _NEWLINE 	while(i<w): _NEWLINE 		stock[i][0]=0 _NEWLINE 		i+=1 _NEWLINE 	if(n>0): _NEWLINE 		print max(check(w-arr[n-1][0],n-1,arr,stock)+arr[n-1][1],check(w,n-1,arr,stock)) _NEWLINE 	else: _NEWLINE 		print 0
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT PA = float(raw_input()) _NEWLINE  _INDENT  _INDENT if(PA >= 0.5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (10000 + 10000 * (1 - PA) * (2 * PA - 1)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (10000 + 10000 * PA * (1 - 2 * PA))
#include <stdio.h> _NEWLINE #define N 100 _NEWLINE int a[N]; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int t, n, k, i, j, k1, x, c; _NEWLINE  _INDENT  _INDENT  scanf("%d", &t); _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d", &n, &k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (i = 0; i < n; i++) { _NEWLINE 			for (j = i; j < n; j++) { _NEWLINE 				c = 0; _NEWLINE 				for (k1 = i; k1 <= j; k1++) { _NEWLINE 					if (a[k1] % 2 == 0) { _NEWLINE 						c++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				if (c == k) { _NEWLINE 					x = 1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("NO\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE } _NEWLINE  
#!/usr/bin/python _NEWLINE import numpy as np _NEWLINE isPrime=[bool(1) for num in range(1000000)] _NEWLINE primes=[] _NEWLINE idx1=-1 _NEWLINE idx2=-1 _NEWLINE isPrime[0]=isPrime[1]=bool(0) _NEWLINE for num in range(2,1000000): _NEWLINE 		if(isPrime[num]==bool(1)): _NEWLINE 			for k in range(num*num,1000000,num): _NEWLINE 				isPrime[k]=bool(0) _NEWLINE 			if(num>100 and idx1==-1): idx1=len(primes) _NEWLINE 			if(num>1000 and idx2==-1): idx2=len(primes) _NEWLINE 			primes.append(num) _NEWLINE num=input() _NEWLINE while num!=0: _NEWLINE 	found=0 _NEWLINE 	for i in range(0,idx1): _NEWLINE 		if (num-primes[i]*primes[i]*primes[i])>0: _INDENT _NEWLINE 			for j in range(0,idx2): _NEWLINE 				if(num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j])>0: _NEWLINE 					if(isPrime[num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j]]): _NEWLINE 						print "{0} {1} {2}".format((num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j]),primes[j],primes[i]) _NEWLINE 						found=1 _NEWLINE 				if found==1: break _NEWLINE 		if found==1: break _NEWLINE 	if found==0: print "0 0 0" _NEWLINE 	num=input()
# Devajit Asem _NEWLINE # PRLADDU _NEWLINE t = int(raw_input()) _NEWLINE def display(a): _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE  _INDENT  _INDENT print _INDENT _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT D = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT k=0 _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=D[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k+=abs(c) _NEWLINE  _INDENT  _INDENT print k _NEWLINE 
for i in range(input()): _NEWLINE 	n =[] _NEWLINE 	n = map(float,list(raw_input().split())) _NEWLINE 	print (n[0])/(n[0]+n[1])
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = raw_input().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = l.count('1') + l.count('0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = l.count('2') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = t*(t-1)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n -= o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n*(n-1)/2 - t
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT length=len(s) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT j=length-1 _NEWLINE  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT while(i<j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT if(counter<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=length-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(counter<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT t-=1
t =input() _NEWLINE for i in range(t): _NEWLINE 	r,g,b,m =map(int,raw_input().split()) _NEWLINE 	rlist =map(int,raw_input().split()) _NEWLINE 	listg = map(int,raw_input().split()) _NEWLINE 	listb = map(int,raw_input().split()) _NEWLINE 	rmax = max(rlist) _NEWLINE 	gmax = max(listg) _NEWLINE 	bmax = max(listb) _NEWLINE 	ls=[rmax,gmax,bmax] _NEWLINE 	for j in xrange(m):	 _NEWLINE 		ls[ls.index(max(ls))]/=2 _NEWLINE 	print max(ls) _NEWLINE 	
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if(a%2!=0 and b%2!=0): _NEWLINE 		print "Vanka" _NEWLINE 	else: _NEWLINE 		print "Tuzik"
#!/usr/bin/python _NEWLINE # coding=utf8 _NEWLINE import sys _NEWLINE import math _NEWLINE from time import time _NEWLINE from itertools import permutations, combinations _NEWLINE import collections _NEWLINE import functools _NEWLINE from fractions import gcd, Fraction _NEWLINE import string _NEWLINE import random _NEWLINE import bisect _NEWLINE  _NEWLINE  _NEWLINE class timed(object): _NEWLINE  _INDENT  _INDENT def __init__(self, func): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.func = func _NEWLINE  _INDENT  _INDENT def __call__(self, *args): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t1 = time() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret = self.func(*args) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dif_time = time() - t1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%s: returned %s in %f seconds" % (self.func.__name__, ret, dif_time) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ret _NEWLINE  _NEWLINE  _NEWLINE def comp(f1, f2, *args): _NEWLINE  _INDENT  _INDENT t1 = time() _NEWLINE  _INDENT  _INDENT r1 = f1(*args) if f1 is not None else None _NEWLINE  _INDENT  _INDENT t2 = time() _NEWLINE  _INDENT  _INDENT r2 = f2(*args) if f2 is not None else None _NEWLINE  _INDENT  _INDENT t3 = time() _NEWLINE  _INDENT  _INDENT res = "%5s: %s in %f\n%5s: %s in %f" % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2) _NEWLINE  _INDENT  _INDENT if r1 != r2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dr = "!! DIFFERENT RESULTS !!" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = dr + "\n" + res + "\n" + dr _NEWLINE  _INDENT  _INDENT print res _NEWLINE  _NEWLINE  _NEWLINE def alg(bubbles): _NEWLINE  _INDENT  _INDENT nb_lines = 10 _NEWLINE  _INDENT  _INDENT nb_lanes = 9 _NEWLINE  _NEWLINE  _INDENT  _INDENT not_valid = 0 _NEWLINE  _INDENT  _INDENT for m in xrange(1, 501): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line_has_paint = [True] * nb_lines _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for start, end, line in bubbles: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m >= start and m <= end: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT line_has_paint[line] = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(nb_lanes): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not line_has_paint[l] and not line_has_paint[l + 1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT not_valid += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT return 500 - not_valid _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT #import cProfile _NEWLINE  _INDENT  _INDENT #cProfile.runctx('alg()', globals(), locals()) _NEWLINE  _INDENT  _INDENT data = sys.stdin _NEWLINE  _INDENT  _INDENT nb = int(data.readline()) _NEWLINE  _INDENT  _INDENT #a, b = map(int,data.readline().split()) _NEWLINE  _INDENT  _INDENT for icase in xrange(nb): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nb_bubbles = int(data.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bubbles = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for ib in xrange(nb_bubbles): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bubbles.append(map(int, data.readline().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = alg(bubbles) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
a=int(raw_input()) _NEWLINE if a<13: _NEWLINE 	print 0 _NEWLINE else: _NEWLINE 	x=a-13 _NEWLINE 	x=x/2 _NEWLINE 	n=x+6 _NEWLINE 	res=n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5) _NEWLINE 	res=res/720 _NEWLINE 	res=res%1000000007 _NEWLINE 	print res
t=int(raw_input()) _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x=(8.0*(b-a))+1 _NEWLINE  _INDENT  _INDENT n=int(((x**0.5)+1)/2.0) _INDENT _NEWLINE  _INDENT  _INDENT print a-n _NEWLINE  _INDENT  _INDENT t-=1 _INDENT 
from sys import stdin _NEWLINE from math import log _NEWLINE def printBS(li): _NEWLINE  print " ".join([str(x) for x in li]) _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE def lcaP(a,b): _NEWLINE  if a==b: return a _NEWLINE  parents=set([]) _NEWLINE  while a!=0: _NEWLINE  _INDENT parents.add(a) _NEWLINE  _INDENT a/=2 _NEWLINE  while b!=0: _NEWLINE  _INDENT if b in parents: _NEWLINE  _INDENT  return b _NEWLINE  _INDENT b/=2 _NEWLINE  return 1 _NEWLINE #returns whether node black or red,blackcount,red count pair _NEWLINE def calc(node,rootBlack): _NEWLINE  if node==0: return (0,0,0) _NEWLINE  if node==1: level=1 _NEWLINE  else: level=int(log(node,2))+1 _NEWLINE  if level%2: _NEWLINE  _INDENT if rootBlack: _NEWLINE  _INDENT  return (True,(level+1)/2,level/2) _NEWLINE  _INDENT else: return (False,level/2,(level+1)/2) _NEWLINE  return (not rootBlack,level/2,level/2) _NEWLINE n=input() _NEWLINE blackRoot=True _NEWLINE for i in xrange(n): _NEWLINE  q=stdin.readline().split() _NEWLINE  if q[0]=="Qi": _NEWLINE  _INDENT blackRoot=not blackRoot _NEWLINE  else: _INDENT _NEWLINE  _INDENT a=int(q[1]) _NEWLINE  _INDENT b=int(q[2]) _NEWLINE  _INDENT ad=calc(a,blackRoot) _NEWLINE  _INDENT bd=calc(b,blackRoot) _NEWLINE  _INDENT lcan=lcaP(a,b) _NEWLINE  _INDENT if q[0]=="Qb": _NEWLINE  _INDENT  print ad[1]+bd[1]-calc(lcan,blackRoot)[1]-calc(lcan/2,blackRoot)[1] _NEWLINE  _INDENT else: _NEWLINE  _INDENT  print ad[2]+bd[2]-calc(lcan,blackRoot)[2]-calc(lcan/2,blackRoot)[2] _NEWLINE  _NEWLINE  _INDENT 
def main(): _INDENT  _INDENT # Don't leave the code in the global namespace, it runs slower _NEWLINE  _INDENT  _INDENT sumBelowCache = [[0.0 for x in range(0, 32)] for x in range(0, 100001)] _NEWLINE  _INDENT  _INDENT for b in range (0, 32): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[0][b] = 0.0; _NEWLINE  _INDENT  _INDENT for a in range (1, 100001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[a][0] = sumBelowCache[a-1][0] + a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[a][1] = sumBelowCache[a-1][1] + 0.5*a - 0.5 _NEWLINE  _INDENT  _INDENT for b in range (2, 32): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for a in range (2, 100000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[a][b] = sumBelowCache[a-1][b] + sumBelowCache[a-1][b-1]/a _NEWLINE  _NEWLINE  _INDENT  _INDENT tokenizedInput = map(int, sys.stdin.read().split()) _INDENT  _INDENT # Read at once, tokenize _NEWLINE  _INDENT  _INDENT testcases = tokenizedInput[0] _NEWLINE  _INDENT  _INDENT readAt = 1 _INDENT  _INDENT # Position to begin reading _NEWLINE  _INDENT  _INDENT for count in range(0,testcases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,k = tokenizedInput[readAt:readAt+2] _INDENT  _INDENT # Read the tokenized input _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k >= 32: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("0.0") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT output = sumBelowCache[n-1][k-1]/float(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if output < 0.000001: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("0.0") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print(output) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT readAt = readAt + 2 _NEWLINE  _NEWLINE import sys _NEWLINE main()
import sys _NEWLINE from math import sqrt _NEWLINE def RESQ(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	while t: _NEWLINE 		n = int(raw_input()); diff = sys.maxint _NEWLINE 		for i in range(1,int(sqrt(n))+1): _NEWLINE 			if n % i is 0 and diff > (n/i - i): _NEWLINE 				diff = n/i - i _NEWLINE 		print diff; t-=1 _NEWLINE if __name__ == '__main__': RESQ() _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT x,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x,y=abs(x),abs(y) _NEWLINE  _INDENT  _INDENT if x==y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print x+y _NEWLINE  _INDENT  _INDENT elif x<y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x+y)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*y-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x+y)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*x+1
n, m = map(int, raw_input().split()) # verticies, edges _NEWLINE g = dict(zip((i for i in xrange(n)), ([] for i in xrange(n)))) _NEWLINE anti_g = dict(zip((i for i in xrange(n)), ([] for i in xrange(n)))) _NEWLINE for _ in xrange(m): _NEWLINE  _INDENT  _INDENT a, b = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a, b = a-1, b-1 _NEWLINE  _INDENT  _INDENT g[a].append(b) _NEWLINE  _INDENT  _INDENT anti_g[b].append(a) _NEWLINE  _NEWLINE # find minimum number of edges to reverse to complete a path from 1 to n _NEWLINE dp = [100001 for _ in xrange(n)] _NEWLINE dp[0] = 0 _NEWLINE q = [0] _NEWLINE aq = [] _NEWLINE visited = [False for _ in xrange(n)] _NEWLINE while q or aq: _NEWLINE  _INDENT  _INDENT if q: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = q.pop(0) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = aq.pop(0) _NEWLINE  _INDENT  _INDENT if visited[node]: continue _NEWLINE  _INDENT  _INDENT visited[node] = True _NEWLINE  _INDENT  _INDENT for k in g[node]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[k] = min(dp[k], dp[node]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.append(k) _NEWLINE  _INDENT  _INDENT for ak in anti_g[node]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[ak] = min(dp[ak], dp[node]+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT aq.append(ak) _NEWLINE  _NEWLINE if dp[n-1] == 100001: _NEWLINE  _INDENT  _INDENT print '-1' _NEWLINE else: _NEWLINE  _INDENT  _INDENT print dp[n-1] _NEWLINE 
import math _NEWLINE test = int(raw_input().strip()) _NEWLINE for i in range(test): _NEWLINE 	h,s = map(float,raw_input().strip().split(" ")) _NEWLINE 	try: _NEWLINE 		th2 = math.asin((4.0*s)/float(h*h)) _NEWLINE 		th = float(th2)/2.00	 _NEWLINE 		l = [ h,h*math.sin(th), h*math.cos(th)] _NEWLINE 		l.sort() _NEWLINE 		print l[0],l[1],l[2] _NEWLINE 	except Exception as e: _NEWLINE 		print -1 _NEWLINE 
''' _NEWLINE from operator import itemgetter _NEWLINE N,M,H = map(int,raw_input().split()); residual = N * M; cost = 0 _NEWLINE L = sorted([tuple(map(int,raw_input().split())) for i in range(H)],key=itemgetter(1)) _NEWLINE for pair in L: _NEWLINE  _INDENT  _INDENT if pair[0] <= residual: cost += (pair[0] * pair[1]); residual -= pair[0] _NEWLINE  _INDENT  _INDENT elif pair[0] > residual: cost += (residual * pair[1]); residual = 0 _NEWLINE  _INDENT  _INDENT if residual == 0: print cost; break _NEWLINE else: print 'Impossible' _NEWLINE ''' _NEWLINE N,M = map(int,raw_input().split()) _NEWLINE L = [int(i) for i in raw_input().split()]; ns = 0 _NEWLINE for i in range(M): _NEWLINE  _INDENT  _INDENT O,S = raw_input().split(); S = int(S) _NEWLINE  _INDENT  _INDENT if O == 'R': print L[(S-1+ns)%N] _NEWLINE  _INDENT  _INDENT elif O == 'C': ns += S _NEWLINE  _INDENT  _INDENT else: ns -= S _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<malloc.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,q; _NEWLINE 	int *row,*column; _NEWLINE 	int i; _NEWLINE 	int add,k; _NEWLINE 	int maxrow,maxcolumn; _NEWLINE 	char input[10]; _NEWLINE 	scanf("%d %d",&n,&q); _NEWLINE 	row=(int *)malloc((n+1)*sizeof(int)); _NEWLINE 	column=(int *)malloc((n+1)*sizeof(int)); _NEWLINE 	for(i=0;i<=n;i++) _NEWLINE 		row[i]=column[i]=0; _NEWLINE 	maxrow=maxcolumn=1; _NEWLINE 	for(i=0;i<q;i++) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		scanf("%s %d %d",input,&k,&add); _NEWLINE 		if(input[0]=='R') _NEWLINE 		{ _NEWLINE 				if(maxrow==k) _NEWLINE 				{ _NEWLINE 					row[k]=row[k]+add; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					row[k]=row[k]+add; _NEWLINE 					if(row[k]>row[maxrow]) _NEWLINE 						maxrow=k; _NEWLINE 				} _INDENT _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			if(maxcolumn==k) _NEWLINE 			{ _NEWLINE 				column[k]=column[k]+add; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				column[k]=column[k]+add; _NEWLINE 				if(column[k]>column[maxcolumn]) _NEWLINE 					maxcolumn=k; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 	} _NEWLINE 	printf("%d",row[maxrow]+column[maxcolumn]); _NEWLINE 	return 0; _NEWLINE }
 _NEWLINE cases = int(raw_input()) _NEWLINE while cases: _NEWLINE  _INDENT  _INDENT cases -= 1 _NEWLINE  _INDENT  _INDENT n,k,init = map(int , raw_input().split()) _NEWLINE  _INDENT  _INDENT arr = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT op = raw_input().strip() _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT if k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print init _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if op == 'AND': _NEWLINE  _INDENT  _INDENT  _INDENT  # for i in xrange(1,k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp &= arr[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = init&tmp _NEWLINE  _INDENT  _INDENT elif op == 'OR': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp |=arr[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = init|tmp _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #or i in xrange(1,k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp ^= arr[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = tmp^init _NEWLINE  _INDENT  _INDENT print ans
from math import* _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a.sort() _NEWLINE 	sum=1 _NEWLINE 	for i in range(1,n): _NEWLINE 		if a[i]!=a[i-1]: _NEWLINE 			sum+=1 _NEWLINE 	print sum _NEWLINE 	t-=1
T = int(raw_input()); M = int(1e7) + 9 _NEWLINE while T: _NEWLINE  _INDENT  _INDENT s = raw_input(); l = len(s) - 1; r = 1 _NEWLINE  _INDENT  _INDENT for i in range(l/2+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[i] == '?' and s[l-i] == '?': r *= 26; r %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif s[i] != s[l-i] and ( s[i] != '?' and s[l-i] != '?' ): _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0; break _NEWLINE  _INDENT  _INDENT else: print r _NEWLINE  _INDENT  _INDENT T -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 
import sys _NEWLINE  _NEWLINE N, M, K = map(lambda x: int(x), sys.stdin.readline().split()) _NEWLINE A = map(lambda x: int(x), sys.stdin.readline().split()) _NEWLINE moves = map(lambda x: (M - x) / K + 1, A) _NEWLINE  _NEWLINE moves_sum = sum(moves) _NEWLINE moves_max = max(moves) _NEWLINE moves.remove(moves_max) _NEWLINE moves_max2 = max(moves) _NEWLINE  _NEWLINE min_moves = max((moves_sum - moves_max + 1) / 2, moves_max2) _NEWLINE max_moves = min(moves_sum / 2, moves_sum - moves_max) _NEWLINE  _NEWLINE print (max_moves - min_moves + 1) % (10 ** 9 + 7)
mod = 10**7 + 7 _NEWLINE n, m _INDENT = map(int, raw_input().split()) _NEWLINE s = [0]*m _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT temp = (map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT for j in xrange(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[j]+=temp[j] _NEWLINE p = 1 _NEWLINE for e in s: _NEWLINE  _INDENT  _INDENT p*=e _NEWLINE  _INDENT  _INDENT p%=mod _NEWLINE print (p+mod)%mod _NEWLINE 
import sys _NEWLINE  _NEWLINE n,k=map(int,sys.stdin.readline().split()) _NEWLINE a=map(int,sys.stdin.readline().split()) _NEWLINE if k==0: _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE else: _NEWLINE  _INDENT  _INDENT if k%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lar=max(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=lar-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE  _INDENT  _INDENT if k%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lar=max(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=lar-a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lar=max(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=lar-a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print a[i],
N,M = map(int,raw_input().split()) _NEWLINE while M: _NEWLINE  _INDENT  _INDENT q = int(raw_input()) _NEWLINE  _INDENT  _INDENT L,U = N + 2,3*N _NEWLINE  _INDENT  _INDENT if q < L or q > U: print 0 _NEWLINE  _INDENT  _INDENT elif q >= L and q <= 2*N + 1: print q - L + 1 _NEWLINE  _INDENT  _INDENT elif q > 2*N + 1 and q <= U: print U - q + 1 _NEWLINE  _INDENT  _INDENT M-=1 _INDENT _NEWLINE 
#gift rift prob on cc _NEWLINE dim = raw_input() _NEWLINE dim = map(int,dim.split()) _NEWLINE max_col = [0]*dim[1] _NEWLINE min_row = [] _NEWLINE min_row_ind = [] _NEWLINE max_col_ind = [[] for i in range(dim[1])] _NEWLINE for i in range(0,dim[0]): _NEWLINE  _INDENT  _INDENT row = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT mr = min(row) _NEWLINE  _INDENT  _INDENT min_row_ind.append([p for p,v in enumerate(row) if v==mr]) _NEWLINE  _INDENT  _INDENT min_row.append(mr) _NEWLINE  _INDENT  _INDENT for j in range(0,dim[1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if max_col[j]<row[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_col[j]=row[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_col_ind[j]=[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif max_col[j] == row[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_col_ind[j].append(i) _NEWLINE state = 1 _NEWLINE for j in range(0,dim[1]): _NEWLINE  _INDENT  _INDENT for k in max_col_ind[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if min_row_ind[k].count(j)>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(max_col[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT state = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if state==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE if state: _NEWLINE  _INDENT  _INDENT print "GUESS"
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT N=int(raw_input()) _NEWLINE  _INDENT  _INDENT arr = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print sum(arr)-N*min(arr) _NEWLINE 
def possible(A, e, n): _NEWLINE  _INDENT  _INDENT def rec(i, r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[i] > 0 and r >= A[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = rec(i + 1, r - A[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[i] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = rec(i + 1, r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT for i in xrange(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not rec(0, e): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE T = int(raw_input()) _NEWLINE while T > 0: _NEWLINE  _INDENT  _INDENT n, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT total = sum(a) _NEWLINE  _INDENT  _INDENT if n < k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "no" _NEWLINE  _INDENT  _INDENT elif total % k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if possible(a, sum(a)/k, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "no" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "no" _NEWLINE  _INDENT  _INDENT T -= 1 _NEWLINE 
import re _NEWLINE def solution(): _NEWLINE 	T = input() _NEWLINE 	lists = [] _NEWLINE 	for i in range(1,100000+1): _NEWLINE 		val = str(i*i) _NEWLINE 		a = re.search('[2,3,5,6,7,8]',val) _NEWLINE 		if a == None : _NEWLINE 			lists.append(int(val)) _NEWLINE 	#print lists, len(lists) _NEWLINE 	len_list = len(lists) _NEWLINE 	for i in range(T): _NEWLINE 		result = 0 _NEWLINE 		start, stop = map(int,raw_input('').split(' ')) _NEWLINE 		for i in range(0,len_list): _NEWLINE 			if lists[i] >= start: _NEWLINE 				index1 = i _NEWLINE 				break _NEWLINE 		for j in range(0,len_list): _NEWLINE 			if lists[j] == stop: _NEWLINE 				index2 = j _NEWLINE 				break _NEWLINE 			if lists[j] > stop: _NEWLINE 				index2 = j - 1 _NEWLINE 				break _NEWLINE 		result = index2 - index1 + 1 _NEWLINE 		print "%d"%(result) _NEWLINE  _NEWLINE solution() _NEWLINE 
def mod(a,b,c): _NEWLINE  _INDENT  _INDENT x = 1 _NEWLINE  _INDENT  _INDENT y = a _NEWLINE  _INDENT  _INDENT while(b>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = (x*y)%c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y)%c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /=2 _NEWLINE  _INDENT  _INDENT return x%c _NEWLINE t = int(raw_input()) _NEWLINE num = 10**9+7 _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,m,q,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if m<=q: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a1 = m-q _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a2 = mod(q+1,n,num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a3 = mod(q-1,n,num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a4 = mod(q,n,num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a5 = a2-2*a4+a3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = a1*a5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (ans%num) _NEWLINE 
from collections import Counter _NEWLINE  _NEWLINE # compute factorials and inverse factorials _NEWLINE mod = 10**9 + 7 _NEWLINE N = 10**5 + 11 _NEWLINE fac = [1]*N _NEWLINE ifc = [1]*N _NEWLINE for i in xrange(2,N): _NEWLINE  _INDENT  _INDENT ifc[i] = (mod - mod/i) * ifc[mod%i] % mod _NEWLINE  _NEWLINE for i in xrange(2,N): _NEWLINE  _INDENT  _INDENT fac[i] = fac[i-1] * _INDENT  _INDENT  i _INDENT % mod _NEWLINE  _INDENT  _INDENT ifc[i] = ifc[i-1] * ifc[i] % mod _NEWLINE  _NEWLINE for cas in xrange(input()): _NEWLINE  _INDENT  _INDENT # only the frequencies of letters matter _NEWLINE  _INDENT  _INDENT A = Counter(raw_input().strip()).values() _NEWLINE  _INDENT  _INDENT t = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT # no swap _NEWLINE  _INDENT  _INDENT t += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT # 1 swap _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * A[j] _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, ab cd _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += 3 * A[i] * A[j] * A[k] * A[l] _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, ab ac _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i != j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i != k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * (A[i]-1) * A[j] * A[k] _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, ab ab _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * (A[i]-1)/2 * A[j] * (A[j]-1)/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, abc _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * A[j] * A[k] * 2 _NEWLINE  _NEWLINE  _INDENT  _INDENT p = fac[sum(A)] _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = p * ifc[A[i]] % mod _NEWLINE  _INDENT  _INDENT print (p * p - p * t) % mod
def lcm(a, b): _NEWLINE  _INDENT  _INDENT if b == 0 or a == b or a%b == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp_a, temp_b = a,b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while temp_b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = temp_b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_b = temp_a%temp_b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_a = temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a*b/temp_a _NEWLINE  _NEWLINE for i in xrange(int(raw_input())): _NEWLINE 	size = int(raw_input()) _NEWLINE 	bandit = map(int, raw_input().split()) _NEWLINE 	whistle = [0 for i in xrange(size)] _NEWLINE 	for i in xrange(size): _NEWLINE 		if whistle[i] == 0: _NEWLINE 			new_band = bandit[i] _NEWLINE 			temp_count = 1 _NEWLINE 			while new_band != i+1: _NEWLINE 				whistle[new_band-1] = 1 _NEWLINE 				new_band = bandit[new_band-1] _NEWLINE 				temp_count += 1 _NEWLINE 			whistle[new_band-1] = temp_count _NEWLINE 			count_whistle = 1 _INDENT _NEWLINE 	for i in xrange(size): _NEWLINE 		if whistle[i] > 1: _NEWLINE 			count_whistle = lcm(count_whistle, whistle[i])			 _NEWLINE 	print count_whistle%1000000007 _NEWLINE 
t = _INDENT input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT l = list(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT n = l[0] _NEWLINE  _INDENT  _INDENT m = l[1] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print abs(n-m) _NEWLINE  _INDENT  _INDENT t-=1
limit = 10**6 + 1 _NEWLINE a = [i for i in range(limit)] _NEWLINE a[1] = 0 _NEWLINE for i in range(2, limit): _NEWLINE  _INDENT  _INDENT if a[i] == i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i, limit, i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]/=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]*=(i-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE b = [0]*(limit) _NEWLINE for i in range(1, limit): _NEWLINE  _INDENT  _INDENT b[i] = b[i-1] + a[i] _NEWLINE #print time.time() - s _NEWLINE  _INDENT  _INDENT  _NEWLINE for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT print b[int(raw_input())] _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	candle, k = map(int, raw_input().split()) _NEWLINE 	if candle == 0: _NEWLINE 		print 0, 0 _NEWLINE 	elif k == 0: _NEWLINE 		print 0, candle _NEWLINE 	else: _NEWLINE 		print candle//k , candle%k
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT row,col = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(row): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(raw_input().lower()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if row < 5 and col < 5: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'There is indeed no spoon!' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(col): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append("".join([i[j] for i in r])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in r: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if 'spoon' in i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if 'spoon' in i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'There is a spoon!' if flag else 'There is indeed no spoon!'
''' _NEWLINE from __future__ import division _NEWLINE from math import sqrt _NEWLINE N,A,index = int(raw_input()),[],1 _NEWLINE def euclideanDist(x1,y1,x2,y2): _NEWLINE  _INDENT  _INDENT return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) _NEWLINE while N: _NEWLINE  _INDENT  _INDENT L = [int(i) for i in raw_input().split()]; _NEWLINE  _INDENT  _INDENT a,b,c = euclideanDist(L[0],L[1],L[2],L[3]),euclideanDist(L[2],L[3],L[4],L[5]),euclideanDist(L[0],L[1],L[4],L[5]) _NEWLINE  _INDENT  _INDENT s = (a + b + c) / 2 _NEWLINE  _INDENT  _INDENT area = sqrt(s*(s-a)*(s-b)*(s-c)); A.append((area,index)); index+=1; N-=1 _NEWLINE A.sort(key=lambda x: x[0]) _NEWLINE print A[0][1],A[-1][1] _NEWLINE ''' _NEWLINE def modular_exponentiation(base,power,modulus): _NEWLINE  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT while power: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if power % 2 == 1: res = ( res * base ) % modulus _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base = (base * base) % modulus; power >>= 1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE def decimal_to_binary(n): _NEWLINE  _INDENT  _INDENT s = '' _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = str(n%2) + s; n/=2 _NEWLINE  _INDENT  _INDENT return int(s) _NEWLINE def SPOTWO(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT while t: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print modular_exponentiation(2,2*decimal_to_binary(N),int(1e9)+7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t-=1 _NEWLINE SPOTWO() _NEWLINE 
def calc(n): _NEWLINE  _INDENT  _INDENT k=2 _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT while k<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=k*3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while q<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q*=3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k*=2 _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for z in range(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT mainans=0 _NEWLINE  _INDENT  _INDENT x=calc(b) _NEWLINE  _INDENT  _INDENT y=calc(a-1) _NEWLINE  _INDENT  _INDENT #print x,y _NEWLINE  _INDENT  _INDENT if 1>=a and 1<=b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (x-y)+1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print x-y
def binarysearch(li, val): _NEWLINE  _INDENT  _INDENT low=0 _NEWLINE  _INDENT  _INDENT high=len(li)-1 _NEWLINE  _INDENT  _INDENT ret=-1 _NEWLINE  _INDENT  _INDENT while(low<=high): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid=(low+high)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if li[mid]>val: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=mid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high=mid-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT low=mid+1 _NEWLINE  _INDENT  _INDENT return ret _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT li=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT ans=[] _NEWLINE  _INDENT  _INDENT ans.append(li[0]) _NEWLINE  _INDENT  _INDENT for i in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=binarysearch(ans, li[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if temp==-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append(li[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[temp]=li[i] _NEWLINE  _INDENT  _INDENT print len(ans), _NEWLINE  _INDENT  _INDENT for i in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE 	n=int(raw_input()) _NEWLINE 	arr=raw_input().split() _NEWLINE 	ss=[] _NEWLINE 	j=len(arr[0]) _NEWLINE 	while j>0: _NEWLINE 		i=0 _NEWLINE 		while i+j<=len(arr[0]): _NEWLINE 			ss.append(arr[0][i:i+j]) _NEWLINE 			i+=1 _NEWLINE 		j-=1 _NEWLINE 	for j in arr[1:]: _NEWLINE 		cn=0 _NEWLINE 		while cn<len(ss): _NEWLINE 			if ss[cn] not in j: _NEWLINE 				ss.remove(ss[cn]) _NEWLINE 			else: _NEWLINE 				cn+=1	 _NEWLINE 	if not ss: _NEWLINE 		print "" _NEWLINE 	else:	 _NEWLINE 		na=[] _NEWLINE 		n=len(ss[0]) _NEWLINE 		k=0 _NEWLINE 		while len(ss[k])==n: _NEWLINE 			na.append(ss[k]) _NEWLINE 			k+=1 _NEWLINE 			if k==len(ss)-1: _NEWLINE 				break _NEWLINE 		na.sort() _NEWLINE 		print na[0]	 _INDENT _NEWLINE 			 _NEWLINE 			
t=input() _NEWLINE for _ in range(t): _NEWLINE 	k=map(int,raw_input().split(" ")) _NEWLINE 	v=[0]*(k[0]+1) _NEWLINE 	m,s=0,1 _NEWLINE 	for i in range(k[1]): _NEWLINE 		p=map(int,raw_input().split(" ")) _NEWLINE 		a,b=p[0],p[1] _NEWLINE 		if s: _NEWLINE 			if v[a] == 0: v[a] = 1 _NEWLINE 			if v[b] == 0: v[b] = v[a]+1	 _NEWLINE 			if v[b] < v[a]: s=0 _NEWLINE 			if m < v[b]: m=v[b] _NEWLINE 	if s == 0: _NEWLINE 		print 'IMPOSSIBLE' _NEWLINE 	else: _NEWLINE 		print m
def series(maxx,m): _NEWLINE  _INDENT  _INDENT global seriesSum _NEWLINE  _INDENT  _INDENT seriesSum=[1] _NEWLINE  _INDENT  _INDENT for i in range(1,maxx+2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seriesSum.append((seriesSum[i-1]*i%m)%m) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE n,m=map(int,raw_input().split()) _NEWLINE arr=map(long,raw_input().split()) _NEWLINE  _NEWLINE final=0 _NEWLINE  _NEWLINE maxx=max(arr) _NEWLINE  _NEWLINE if maxx<=1000000: _NEWLINE  _INDENT  _INDENT series(maxx,m) _NEWLINE else: _NEWLINE  _INDENT  _INDENT series(1000000,m) _NEWLINE  _NEWLINE for num in arr: _NEWLINE  _INDENT  _INDENT if num%2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first=second=num _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT third=(num+1)/2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first=num+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT second=num _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT third=num/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT ans=(first%m*second%m*third%m)%m _NEWLINE  _NEWLINE  _INDENT  _INDENT if num+1>=m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans%m+seriesSum[num+1]%m-1)%m _NEWLINE  _NEWLINE  _INDENT  _INDENT final=(final%m+ans%m)%m _NEWLINE  _NEWLINE print final%m _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE 
from sys import stdin as ip _NEWLINE for _ in xrange(int(ip.readline())): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT j=raw_input() _NEWLINE  _INDENT  _INDENT ct=0 _NEWLINE  _INDENT  _INDENT for i in set(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ct+=j.count(i) _NEWLINE  _INDENT  _INDENT print ct _NEWLINE 
#!/usr/bin/env python _NEWLINE # -*- encoding: utf-8 -*- _NEWLINE # pylint: disable=invalid-name,missing-docstring,bad-builtin _NEWLINE import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT dstream = iter(sys.stdin.read().split()) _NEWLINE  _INDENT  _INDENT for _ in xrange(int(next(dstream))): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n, k = int(next(dstream)), int(next(dstream)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = next(dstream) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT updates = [0]*(n + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val, count = 0, 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, chx in enumerate(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val += updates[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((chx == 'R') + val) % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT updates[min(n, i + k)] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print count _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
ch=str(raw_input()) _NEWLINE length=len(ch) _NEWLINE arr=[] _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='h'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE dp=[] _NEWLINE for i in range(4): _NEWLINE  _INDENT  _INDENT dp.append([]) _NEWLINE  _INDENT  _INDENT for k in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i].append([0]) _NEWLINE for i in range(4): _NEWLINE  _INDENT  _INDENT for j in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i==j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(1,length): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(j==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(j==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(j==3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='h'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE q=int(raw_input()) _NEWLINE for i in range(q): _NEWLINE  _INDENT  _INDENT z=raw_input().split() _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT a=z[0] _NEWLINE  _INDENT  _INDENT b=z[1] _NEWLINE  _INDENT  _INDENT l=int(z[2]) _NEWLINE  _INDENT  _INDENT r=int(z[3]) _NEWLINE  _INDENT  _INDENT temp2=0 _NEWLINE  _INDENT  _INDENT temp1=0 _NEWLINE  _INDENT  _INDENT if(a=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=0 _NEWLINE  _INDENT  _INDENT elif(a=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=1 _NEWLINE  _INDENT  _INDENT elif(a=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=3 _NEWLINE  _INDENT  _INDENT if(b=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  temp2=0 _NEWLINE  _INDENT  _INDENT elif(b=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2=1 _NEWLINE  _INDENT  _INDENT elif(b=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2=2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2=3 _NEWLINE  _INDENT  _INDENT if(l==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=dp[temp1][temp2][r-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=dp[temp1][temp2][r-1]-dp[temp1][temp2][l-2]-arr[temp1][l-2]*(arr[temp2][r-1]-arr[temp2][l-2]) _NEWLINE  _INDENT  _INDENT print ans _INDENT _NEWLINE 
def sumv(fr, to): _NEWLINE  _INDENT  _INDENT num = to - fr + 1 _NEWLINE  _INDENT  _INDENT return (to + fr) * num / 2 _NEWLINE t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n, k, q = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT s = raw_input().rstrip() _NEWLINE  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT c1 = 0 _NEWLINE  _INDENT  _INDENT c0 = 0 _NEWLINE  _INDENT  _INDENT far = [0 for x in xrange(n)] _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (c0 == k and s[j] == '0') or (c1 == k and s[j] == '1'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT far[cnt] = j - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[cnt] == '0': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0 -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c1 -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[j] == '0': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c1 += 1 _NEWLINE  _INDENT  _INDENT for j in xrange(cnt, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT far[j] = n - 1 _NEWLINE  _INDENT  _INDENT cdf = [0 for x in xrange(n)] _NEWLINE  _INDENT  _INDENT cdf[0] = far[0] _NEWLINE  _INDENT  _INDENT for j in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cdf[j] = cdf[j - 1] + far[j] _NEWLINE  _INDENT  _INDENT last = [None for x in xrange(n)] _NEWLINE  _INDENT  _INDENT pre = None _NEWLINE  _INDENT  _INDENT r = n - 1 _NEWLINE  _INDENT  _INDENT for j in xrange(n - 1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if pre == None or pre != far[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pre = far[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind = j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while r >= pre: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last[r] = ind _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r -= 1 _NEWLINE  _INDENT  _INDENT for j in xrange(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l, r = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h = last[r] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l <= h: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += cdf[h] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += cdf[h] - cdf[l - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += r * (r - h) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res -= sumv(l - 1, r - 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += sumv(1, r - l + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
t=input() _NEWLINE c=t _NEWLINE count=[[0 for i in range(t)] for j in range(26)];arr=[[]for i in range(t)] _NEWLINE while(t>0): _NEWLINE 	arr[t-1]=list(raw_input()) _NEWLINE 	t-=1 _NEWLINE j=0 _NEWLINE ##print arr _NEWLINE while(j<c): _NEWLINE 	i=0;n=len(arr[j]) _NEWLINE 	while(i<n): _NEWLINE 		iter1=(ord(arr[j][i])-19)%26 _NEWLINE 		count[iter1][j]+=1 _NEWLINE 		i+=1 _NEWLINE 	j+=1 _NEWLINE #print count _NEWLINE i=0;t=c;c='' _NEWLINE while(i<26): _NEWLINE 	j=t;min1=99999999 _NEWLINE 	while(j>=0): _NEWLINE 		j-=1 _NEWLINE 		if(count[i][j]<min1): _NEWLINE 			min1=count[i][j] _NEWLINE 	j=0 _NEWLINE 	while(j<min1): _NEWLINE 		c+=chr(97+i) _NEWLINE 		j+=1 _NEWLINE 	i+=1 _NEWLINE if(len(c)==0): _NEWLINE 	print "no such string" _NEWLINE else: _NEWLINE 	print c
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b == 0: return a _NEWLINE  _INDENT  _INDENT else: return gcd(b,a%b) _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT N = int(raw_input()); L = [int(i) for i in raw_input().split()]; r = gcd(L[0],L[1]) _NEWLINE  _INDENT  _INDENT if r is 1: print N; t-=1; continue _NEWLINE  _INDENT  _INDENT for i in range(2,N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = gcd(r,L[i]); _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r is 1: print N; break _NEWLINE  _INDENT  _INDENT else: print -1 _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
# your code goes here _NEWLINE n=int(raw_input()) _NEWLINE a=map(int,raw_input().split()) _NEWLINE q=int(raw_input()) _NEWLINE  _NEWLINE while q>0: _NEWLINE 	q-=1 _NEWLINE 	k=int(raw_input()) _NEWLINE 	count=0 _NEWLINE 	for i in range(n): _NEWLINE 		min=a[i] _NEWLINE 		for j in range(i,n): _NEWLINE 			if a[j]<min: _NEWLINE 				min=a[j] _NEWLINE 			if min==k: _NEWLINE 				count+=1 _NEWLINE 	print count _NEWLINE 	
t = int(raw_input().strip()) _NEWLINE while(t>0): _NEWLINE 	n,d=map(int,raw_input().strip().split(" ")) _NEWLINE 	arr = map(int,raw_input().strip().split(" ")) _NEWLINE 	#arr = list(set(arr)) _NEWLINE 	arr = sorted(arr,reverse=True) _NEWLINE 	i=0 _NEWLINE 	sumn = 0 _NEWLINE 	while(i<n-1): _NEWLINE 		if((arr[i]-arr[i+1])<d): _NEWLINE 			sumn += arr[i]+arr[i+1] _NEWLINE 			i+=2 _NEWLINE 		else: _NEWLINE 			i+=1 _NEWLINE 	print sumn _NEWLINE 	t-=1 _NEWLINE 
t=int(raw_input()) _NEWLINE p=list() _NEWLINE p.append(0) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT s=len(p) _NEWLINE  _INDENT  _INDENT for i in range(s,n+1): p.append(p[i-1]*1.1+0.45-0.1*p[i-2]); _NEWLINE  _INDENT  _INDENT print p[n] _NEWLINE  _INDENT  _INDENT t=t-1
n ,k = map(int,raw_input().split()) _NEWLINE lis = [] _NEWLINE for i in xrange(n): _NEWLINE 	lis.append(int(raw_input())) _NEWLINE lis = sorted(lis) _NEWLINE ans = 0 _NEWLINE i = 0 _NEWLINE while(i<n-1): _NEWLINE 	if lis[i+1]-lis[i]<=k: _NEWLINE 		ans+=1 _NEWLINE 		i+=2 _NEWLINE 	else: _NEWLINE 		i+=1 _NEWLINE print ans
import sys _NEWLINE  _NEWLINE MOD = 1000000007 _NEWLINE  _NEWLINE A = 26 _NEWLINE  _NEWLINE _ = sys.stdin.readline().rstrip() _NEWLINE  _NEWLINE for ns in sys.stdin: _NEWLINE  _INDENT  _INDENT n = int(ns) _NEWLINE  _INDENT  _INDENT p = (n+1) // 2 _NEWLINE  _NEWLINE  _INDENT  _INDENT prod = pow(A,p,MOD) _NEWLINE  _INDENT  _INDENT den = pow(A-1, MOD-2, MOD) _NEWLINE  _NEWLINE  _INDENT  _INDENT res = (((2 * A * ((prod - 1) % MOD)) % MOD) * den) % MOD _NEWLINE  _NEWLINE  _INDENT  _INDENT if n%2 != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = (res - prod) % MOD _NEWLINE  _NEWLINE  _INDENT  _INDENT print res _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	n , c, q = map(int, raw_input().split()) _NEWLINE 	for i in range(q): _NEWLINE 		l, r = map(int, raw_input().split()) _NEWLINE 		if c <= r and c >= l: _NEWLINE 			c = r - (c - l) _NEWLINE 			#print 'c =', c _NEWLINE 	print c
# cook your code here _NEWLINE it = int(raw_input()) _NEWLINE for i in range(it): _NEWLINE  _INDENT  _INDENT r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT r.sort() _NEWLINE  _INDENT  _INDENT m= 1000000007 _NEWLINE  _INDENT  _INDENT print (r[0]*((r[1]-1)*(r[2]-2))%m)%m
from collections import defaultdict as dd _NEWLINE  _INDENT _NEWLINE def pre_times(): _NEWLINE 	rs=dd(list) _NEWLINE 	for h in xrange(12): _NEWLINE 		ha=0.0+h*30 _NEWLINE 		ma=0.0 _NEWLINE 		for m in xrange(60): _NEWLINE  _INDENT _NEWLINE 			calculated_angle=min(abs(ha-ma),360-abs(ha-ma)) _NEWLINE 			index=int(calculated_angle) _NEWLINE 			rs[index].append({calculated_angle:[h,m]}) _NEWLINE  _INDENT _NEWLINE 			ha+=0.5 _NEWLINE 			ma+=6.0 _NEWLINE  _INDENT _NEWLINE 	return rs _NEWLINE  _INDENT _NEWLINE def get_actual_time(rs,given_angle): _NEWLINE 	key=int(given_angle) _NEWLINE 	sorted_output=[] _NEWLINE  _INDENT _NEWLINE 	if rs.has_key(key): _NEWLINE 		for valid_time_angle in rs[key]: _NEWLINE 			valid_angle=valid_time_angle.keys()[0] _NEWLINE 			valid_time=valid_time_angle.values()[0] _NEWLINE  _INDENT _NEWLINE 			if abs(valid_angle- given_angle)<1.0/120: _NEWLINE 				sorted_output.append([valid_time[0],valid_time[1]]) _NEWLINE  _INDENT _NEWLINE 		for h,m in sorted(sorted_output): _NEWLINE 			print "%02d:%02d"%(h,m) _NEWLINE  _INDENT _NEWLINE def main(rs): _NEWLINE 	temp = int(input()) _NEWLINE 	for i in xrange(temp): _NEWLINE 		angle=float(input()) _NEWLINE 		get_actual_time(rs,angle) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT _NEWLINE 	rs=pre_times() _NEWLINE 	main(rs)
 _NEWLINE Line1=raw_input().split(' ') _NEWLINE t=int(Line1[0]) _NEWLINE  _NEWLINE dic={} _NEWLINE  _NEWLINE for i in range(0,26): _NEWLINE  _INDENT  _INDENT dic[chr(i+97)]=Line1[1][i] _NEWLINE  _INDENT  _INDENT dic[chr(i+65)]=Line1[1][i].upper() _NEWLINE  _NEWLINE dic['_']=' ' _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT Line=raw_input() _NEWLINE  _INDENT  _INDENT O="" _NEWLINE  _INDENT  _INDENT for x in Line: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT O=O+dic[x] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT O=O+x _NEWLINE  _INDENT  _INDENT print(O) _NEWLINE  _INDENT  _INDENT 
from sys import stdin,stdout _NEWLINE def printBS(li): _NEWLINE  print " ".join([str(x) for x in li]) _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE cases=input() _NEWLINE for case in xrange(cases): _NEWLINE  n=input() _NEWLINE  no=0 _NEWLINE  mapping={} _NEWLINE  revmap={} _NEWLINE  count=[0]*n _NEWLINE  adjList={i:[] for i in xrange(n)} _NEWLINE  for i in xrange(n-1): _NEWLINE  _INDENT a,b,w=stdin.readline().strip().split() _NEWLINE  _INDENT if a not in mapping: _NEWLINE  _INDENT  mapping[a]=no _NEWLINE  _INDENT  revmap[no]=a _NEWLINE  _INDENT  no+=1 _NEWLINE  _INDENT if b not in mapping: _NEWLINE  _INDENT  mapping[b]=no _NEWLINE  _INDENT  revmap[no]=b _NEWLINE  _INDENT  no+=1 _NEWLINE  _INDENT count[mapping[a]]+=1 _NEWLINE  _INDENT count[mapping[b]]+=1 _NEWLINE  _INDENT adjList[mapping[a]]=(mapping[b],int(w[:-1])) _NEWLINE  s=0 _NEWLINE  #print adjList _NEWLINE  for i in xrange(n): _NEWLINE  _INDENT if count[i]==1 and adjList[i]: _NEWLINE  _INDENT  s=i _NEWLINE  _INDENT  break _NEWLINE  i=s _NEWLINE  output="" _NEWLINE  cost=0 _NEWLINE  while adjList[i]: _NEWLINE  _INDENT output=output+"%s %s %d$\n"%(revmap[i],revmap[adjList[i][0]],adjList[i][1]) _NEWLINE  _INDENT cost+=adjList[i][1] _NEWLINE  _INDENT i=adjList[i][0] _NEWLINE  stdout.write(output) _NEWLINE  print str(cost)+"$"
#include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE #define ll long long _NEWLINE using namespace std; _NEWLINE const int N = 1e4 + 2; _NEWLINE ll arr[N]; _NEWLINE double brr[N]; _NEWLINE int main(){ _NEWLINE 	int t, i, j, n, m, _INDENT tempn; _NEWLINE 	double pr; _NEWLINE 	scanf( "%d", &t ); _NEWLINE  _INDENT  _INDENT 	while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %lf", &n, &m, &pr ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pr /= 100.0f; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &tempn ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = tempn-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sort( arr, arr+m ) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ) brr[i] = 1.0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( j=1 ; j<n ; j<<=1 ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ) arr[i] >>= 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int k = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( arr[i] == arr[i+1] && m!=1 && i!=m-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i-k] = arr[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT brr[i-k] = brr[i]*brr[i+1] + pr*brr[i]*(1.0-brr[i+1]) + pr * ( 1- brr[i] ) * brr[i+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++;k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i-k] = arr[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT brr[i-k] = brr[i]*pr; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m -= k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.13lf\n", 100.0*brr[0]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	return 0; _NEWLINE } _NEWLINE 
import math _NEWLINE t=int(raw_input()) _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT a=[] _NEWLINE  _INDENT  _INDENT b=[] _NEWLINE  _INDENT  _INDENT nodes=2**t-1 _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT a.append(0) _NEWLINE  _INDENT  _INDENT b.append(0) _NEWLINE  _INDENT  _INDENT for i in range(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(x[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b.append(0) _NEWLINE # _INDENT  _INDENT print a _NEWLINE # _INDENT  _INDENT print b _NEWLINE  _INDENT  _INDENT for i in range(len(a)-1,0,-1): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (2*i<=(len(a)-1) and 2*i+1<=(len(a)-1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i]=max(a[i]*b[2*i],a[i]*b[2*i+1]) _NEWLINE #	elif (2*i<=len(a)-1): _NEWLINE #	 _INDENT  _INDENT b[i]=a[i]*b[2*i] _NEWLINE #	elif (2*i+1<=len(a)-1): _NEWLINE #	 _INDENT  _INDENT b[i]=a[i]*b[2*i+1] _NEWLINE 	else: _NEWLINE 	 _INDENT  _INDENT b[i]=a[i] _NEWLINE # _INDENT  _INDENT print a _NEWLINE # _INDENT  _INDENT print b _NEWLINE  _INDENT  _INDENT print b[1]%1000000007 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT t=int(raw_input())
n=int(raw_input()) _NEWLINE s=list(map(str,raw_input().split())) _NEWLINE m=int(raw_input()) _NEWLINE dic={} _NEWLINE for i in range(m): _NEWLINE  _INDENT  _INDENT a,b,c=map(str,raw_input().split()) _NEWLINE  _INDENT  _INDENT c=int(c) _NEWLINE  _INDENT  _INDENT dic[(a,b)]=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT x=list(map(str,raw_input().split())) _NEWLINE  _INDENT  _INDENT y=len(x) _NEWLINE  _INDENT  _INDENT if int(x[0])==1 and x[1] in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT elif int(x[0])==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT elif x[1]==x[y-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if int(x[0])>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic2={} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x[j] in dic2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic2[x[j]]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic2[x[j]]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in dic2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dic2[j]>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if flag==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,len(x)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x[j],x[j+1]) in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=dic[(x[j],x[j+1])] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if flag==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ans
t = int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE 	list = [] _NEWLINE 	sum = 0 _NEWLINE 	n = int(raw_input()) _NEWLINE 	sum = ((n)*(n+1))/2 _NEWLINE 	if n%2 ==0: _NEWLINE 		n = n/2 _NEWLINE 	else: _NEWLINE 		n = (n+1)/2 	 _NEWLINE 	number_notprinted = raw_input() _NEWLINE 	list = number_notprinted.split(" ") _NEWLINE 	for j in range(1,len(list)): _NEWLINE 		sum-=int(list[j]) _NEWLINE 	number_torn = int(raw_input()) _NEWLINE 	number_left = n-number_torn	 _NEWLINE 	result = float(number_left) *float(sum)/n _NEWLINE 	print "%.4f" % result _NEWLINE 	 _NEWLINE 	
dic={} _NEWLINE def calc(x,y): _NEWLINE  _INDENT  _INDENT a=max(dic[x][0]+1,dic[y][0]+1) _NEWLINE  _INDENT  _INDENT b=max(n-dic[x][-1],n-dic[y][-1]) _NEWLINE  _INDENT  _INDENT c=max(dic[x][0]+1,n-dic[y][-1]) _NEWLINE  _INDENT  _INDENT d=max(n-dic[x][-1],dic[y][0]+1) _NEWLINE  _INDENT  _INDENT #print x,y,"=>","a=",a,"b=",b,"c=",c,"d=",d _NEWLINE  _INDENT  _INDENT return min(a,b,c,d) _NEWLINE  _NEWLINE n,k=map(int,raw_input().split()) _NEWLINE x=list(map(int,raw_input().split())) _NEWLINE for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT if x[i] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[x[i]].append(i) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[x[i]]=[i] _NEWLINE #print dic _NEWLINE ans=10000000000 _NEWLINE for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT if k-x[i] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print x[i],k-x[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[i]!=(k-x[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=min(ans,calc(x[i],k-x[i])) _NEWLINE if ans!=10000000000: _NEWLINE  _INDENT  _INDENT print ans _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "-1"
d={} _NEWLINE for z in range(input()): _NEWLINE  _INDENT  _INDENT s,v=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT d[int(v)]=s _NEWLINE s=sorted(d,reverse=True) _NEWLINE for x in range(input()): _NEWLINE  _INDENT  _INDENT q=raw_input() _NEWLINE  _INDENT  _INDENT found,l=False,len(q) _NEWLINE  _INDENT  _INDENT for i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d[i][:l]==q: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print d[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT found=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if not found:print 'NO'
array_len, allowed_changes = map(int, raw_input().split()) _NEWLINE array = map(int, raw_input().split()) _NEWLINE  _NEWLINE MAX = 10 ** 9 + 1 _NEWLINE  _NEWLINE best_a = MAX _NEWLINE best_d = MAX _NEWLINE for start in xrange(allowed_changes + 1): _NEWLINE  _INDENT  _INDENT rem = allowed_changes - start _NEWLINE  _INDENT  _INDENT for end in xrange(max(start + 1, array_len - rem - 1), array_len): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = (array[end] - array[start]) / (end - start) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = (array[start] - start * d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT changes = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(array_len): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (array[i] != a + d * i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT changes += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if changes <= allowed_changes: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (a < best_a or (a == best_a and d < best_d)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT best_a, best_d = a, d _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE print " ".join(map(str, [best_a + i * best_d for i in xrange(array_len)]))
from sys import stdin _NEWLINE  _INDENT _NEWLINE def merge(v): _NEWLINE  _INDENT  _INDENT T, last = [0], -1 _NEWLINE  _INDENT  _INDENT v.sort() _NEWLINE  _INDENT  _INDENT for i in range(len(v) - 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v[i] == last: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v[i] == v[i+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T.append(v[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T[0] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  last = v[i] _NEWLINE  _INDENT  _INDENT return T _NEWLINE  _INDENT _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT n = sum(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT v = map(int, stdin.readlines()) _NEWLINE  _INDENT  _INDENT x = merge(v) _NEWLINE  _INDENT  _INDENT for i in x: print i _NEWLINE  _INDENT _NEWLINE main()
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT p = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT while i<b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p[i]+=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT x=max(p) _NEWLINE  _INDENT  _INDENT print (x) _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t=int(input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT length=len(s) _NEWLINE  _INDENT  _INDENT for i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[i]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[i]=1 _NEWLINE  _INDENT  _INDENT j=length _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT while(j>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans*=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT for var in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=dic[var] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans2*=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans/=ans2 _NEWLINE  _INDENT  _INDENT print ans%1000000007 _NEWLINE  _INDENT  _INDENT t-=1
#!/usr/bin/python _NEWLINE mainlis=[] _NEWLINE maxv=1000000080798150871 _NEWLINE for i in range(0,1000,1): _NEWLINE  _INDENT mainlis.append([]) _NEWLINE  _INDENT varlis=mainlis[i]	 _NEWLINE  _INDENT for j in range(0,3,1): _NEWLINE  _INDENT  _INDENT varlis.append(0)	 _NEWLINE test=input() _NEWLINE while test >0: _NEWLINE  _INDENT string=raw_input() _NEWLINE  _INDENT lis=string.split() _NEWLINE  _INDENT n=int(lis[0]) _NEWLINE  _INDENT m=int(lis[1]) _NEWLINE  _INDENT l=int(lis[2]) _NEWLINE  _INDENT k=int(lis[3]) _NEWLINE  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT string=raw_input() _NEWLINE  _INDENT  _INDENT varlis=mainlis[i]	 _NEWLINE  _INDENT  _INDENT for j in range(0,m,1): _NEWLINE  _INDENT  _INDENT  _INDENT varlis[j]=int(string[j]) _NEWLINE  _INDENT if m==1: _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT if varlis[0]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT ans=(ans*(count-i))/(i+1) _NEWLINE  _INDENT elif m==2: _NEWLINE  _INDENT  _INDENT if k==2: _NEWLINE  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*(count-i))/(i+1) _NEWLINE  _INDENT  _INDENT elif k==1:	 _NEWLINE  _INDENT  _INDENT  _INDENT count1=0 _NEWLINE  _INDENT  _INDENT  _INDENT count2=0	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count1=count1+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count2=count2+1	 _NEWLINE  _INDENT  _INDENT  _INDENT ans1=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans2=1	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=(ans1*(count1-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=(ans2*(count2-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT ans=ans1%maxv+ans2%maxv _NEWLINE  _INDENT elif m==3: _NEWLINE  _INDENT  _INDENT if k==3: _NEWLINE  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[1]==1 and varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*(count-i))/(i+1) _NEWLINE  _INDENT  _INDENT elif k==1: _NEWLINE  _INDENT  _INDENT  _INDENT count1=0 _NEWLINE  _INDENT  _INDENT  _INDENT count2=0 _NEWLINE  _INDENT  _INDENT  _INDENT count3=0	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count1=count1+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count2=count2+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count3=count3+1 _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT  _INDENT ans1=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans2=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans3=1 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=(ans1*(count1-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=(ans2*(count2-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans3=(ans3*(count3-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT ans=ans1%maxv + ans2%maxv +ans3%maxv _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT elif k==2: _NEWLINE  _INDENT  _INDENT  _INDENT count1=0 _NEWLINE  _INDENT  _INDENT  _INDENT count2=0 _NEWLINE  _INDENT  _INDENT  _INDENT count3=0 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i]	 _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count1=count1+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count2=count2+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[1]==1 and varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count3=count3+1 _NEWLINE  _INDENT  _INDENT  _INDENT ans1=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans2=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans3=1 _NEWLINE # print count1,count2,count3	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=(ans1*(count1-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=(ans2*(count2-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans3=(ans3*(count3-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT ans=ans1%maxv + ans2%maxv + ans3%maxv	 _NEWLINE  _INDENT  _INDENT 	 _NEWLINE 	 _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT  _INDENT 	 _NEWLINE  _INDENT print ans%maxv	 _NEWLINE  _INDENT test=test-1 _NEWLINE 	 _NEWLINE  _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT  _NEWLINE  _NEWLINE 
from math import sqrt _NEWLINE import os,sys _NEWLINE h=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] _NEWLINE skip=[1,2,1,2,3,4,5,6,1,2,3,4,1,2,1,2,3,4,1,2,1,2,3,4,1,2,3,4,5,6] _NEWLINE lookup={1373653:1373639,25326001:25325981,3215031751:3215031749,2152302898747:2152302898729,3474749660383:3474749660329,341550071728321:341550071728289} _NEWLINE def f(n): _NEWLINE  _INDENT  _INDENT if n==2: return 2 _NEWLINE  _INDENT  _INDENT if not (n&1):n-=1 _NEWLINE  _INDENT  _INDENT mod=n%30 _NEWLINE  _INDENT  _INDENT while 1: _NEWLINE  _INDENT  _INDENT  _INDENT b=False _NEWLINE  _INDENT  _INDENT  _INDENT if n== 1373653 or n==25326001 or n==3215031751 or n==2152302898747 or n==3474749660383 or n==341550071728321:return lookup[n] _NEWLINE  _INDENT  _INDENT  _INDENT v=sqrt(n) _NEWLINE  _INDENT  _INDENT  _INDENT for x in h: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not n%x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x>v:return n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT if not b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d,s=n-1,0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while not (d & 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d >>= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT atp = pow(2, d, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if atp==1 or atp == n-1 : return n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(s-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT atp = (atp*atp)%n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if atp == n - 1: return n _NEWLINE  _INDENT  _INDENT  _INDENT n,mod=n-skip[mod],mod-skip[mod] _NEWLINE  _INDENT  _INDENT  _INDENT if mod<0:mod+=30 _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _INDENT _NEWLINE v=os.read(0,500*19).split() _NEWLINE for x in xrange(1,len(v)): _NEWLINE  _INDENT sys.stdout.write(str(f(int(v[x])))+"\n") 
# cook your code here _NEWLINE for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n,h=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a=[0]*(n+2) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[l+1]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[r+2]-=1 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]=a[i]+a[i-1] _NEWLINE  _INDENT  _INDENT for i in range(n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]=a[i]+a[i-1] _NEWLINE  _INDENT  _INDENT print n*h-max(a[i+h]-a[i] for i in range(n-h+1))
D = {2**i - 1:True for i in range(31)} _NEWLINE T = int(raw_input()) _NEWLINE while T: _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT if N == 1: print '2' _NEWLINE  _INDENT  _INDENT elif D.get(N): print N/2 _NEWLINE  _INDENT  _INDENT else: print '-1' _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE 
def least_bit_set(x): _NEWLINE  _INDENT  _INDENT return x & (-x) _NEWLINE  _NEWLINE def eliminate(values): _NEWLINE  _INDENT  _INDENT values = list(values) _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT values = [v for v in values if v > 0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i >= len(values): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return values _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i + 1, len(values)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if least_bit_set(values[k]) < least_bit_set(values[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT values[i], values[j] = (values[j], values[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i + 1, len(values)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if least_bit_set(values[k]) == least_bit_set(values[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[k] ^= values[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _NEWLINE def in_span(x, eliminated_values): _NEWLINE  _INDENT  _INDENT for y in eliminated_values: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if least_bit_set(y) & x != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x ^= y _NEWLINE  _INDENT  _INDENT return x == 0 _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT n, k = map(int, raw_input().split()) _NEWLINE  _INDENT values = map(int, raw_input().split()) _NEWLINE  _INDENT eliminated_values = eliminate(values) _NEWLINE  _INDENT res = k _NEWLINE  _INDENT for target in xrange(1023, 0, -1): _NEWLINE  _INDENT  _INDENT if in_span(target ^ k, eliminated_values): _NEWLINE  _INDENT  _INDENT  _INDENT res = target _NEWLINE  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT print res _NEWLINE 
t=int(raw_input()) _NEWLINE b=[] _NEWLINE l=[] _NEWLINE d=0 _NEWLINE for i in xrange(0,t*t): _NEWLINE 	k=raw_input() _NEWLINE 	if(k[0]=='Y'): _NEWLINE 		d='1'	 _NEWLINE 	elif(k[0]=='N'): _NEWLINE 		d='0' _NEWLINE 	l.append(d) _NEWLINE 	if(i%t==t-1): _NEWLINE 		b.append(''.join(l)) _NEWLINE 		l=[] _NEWLINE  _NEWLINE #print b _NEWLINE ans=0 _NEWLINE for i in xrange(0,t): _NEWLINE 	f=1 _NEWLINE 	for j in xrange(0,t): _NEWLINE 		if((b[i]==b[j] and b[i][j]=='0') or (b[i]!=b[j] and b[i][j]=='1')): _NEWLINE 			f=0 _NEWLINE 			break _NEWLINE #		print f _NEWLINE 	if(f==1): _NEWLINE 		ans=b[i] _NEWLINE 		break; _NEWLINE  _NEWLINE #print ans _NEWLINE if(ans!=0): _NEWLINE 	for i in ans: _NEWLINE 		if(i=='1'): _NEWLINE 			print 'YES' _NEWLINE 		else: _NEWLINE 			print 'NO' _NEWLINE else: _NEWLINE 	for i in xrange(0,t): _NEWLINE 		print 'NO' _NEWLINE 
