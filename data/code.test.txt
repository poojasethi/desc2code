#include<bits/stdc++.h> using namespace std; int main() { 	int i,j,k,n,m,t; 	double a[20][10005]; 	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		for(i=1;i<=n;i++) 		{ 			for(j=1;j<=m;j++) 			cin>>a[i][j]; 		} 		double ans=1; 		int flag=1; 		for(j=1;j<=m;j++) 		{ 			if(a[1][j]<=0.00+1e-9) 			flag=0; 		} 		if(!flag) 		{ 			cout<<"0.000000\n"; 			continue; 		} 	 		double temp=0; 		 		for(i=1;i<=n;i++) 		{    		    double tt=1; 			for(j=1;j<=m;j++) 			{ 				tt*=a[i][j]/a[1][j]; 			} 			temp+=tt; 		} 		if(temp<=0.0+1e-9) 		cout<<"0.000000\n"; 		else 		printf("%.6lf\n",1/temp); 		 	} 	 }
#include<bits/stdc++.h> using namespace std; #define mod 1000000007 #define ll long long   ll fact[100002],xpow[10]; pair<int,int> bad[7]; ll ans; int n,m; map<int,int>::iterator it;   void calc() {     fact[0]=1;     for(int i=1;i<=100001;i++)     {         fact[i]=fact[i-1]*i;         if(fact[i]>=mod) fact[i]%=mod;     }     xpow[0]=1;     for(int i=1;i<=10;i++) xpow[i]=xpow[i-1]*2; }   class dsu { public:     map<int,int> parent;     void add(int i) {parent[i]=i;}     int find(int a) {return a==parent[a]?a:parent[a]=find(parent[a]);}     void join(int i,int j) {parent[find(j)]=find(i);}     bool check(int i,int j) {return find(i)==find(j);}     int size() {return parent.size();} };   void reduce(vector<int> a,int index) {     //actual reduction     dsu d;     for(int i=0;i<a.size();i++)     {         d.add(bad[a[i]].first);         d.add(bad[a[i]].second);     }     int p = d.size(),q = d.size();     bool cycle=false;     for(int i=0;i<a.size();i++)     {         int x=bad[a[i]].first,y=bad[a[i]].second;         if(d.check(x,y))         {             cycle=true;             break;         }         d.join(x,y);         q--;     }     map<int,int> M;     for(int i=0;i<a.size();i++)     {         int x=a[i];         M[bad[x].first]++;         M[bad[x].second]++;         if(M[bad[x].first]>2 || M[bad[x].second]>2)         {             cycle=true;             break;         }     }     ll N;     if(!cycle)     {         N=(fact[n-p+q]*xpow[q]);         if(N>=mod) N%=mod;         if(a.size()%2==0)         {             ans+=N;             if(ans>=mod) ans%=mod;         }         else         {             ans=(ans+mod-N);             if(ans>=mod) ans%=mod;         }     }     //ends    // for(int i=0;i<a.size();i++) cout<<a[i]<<" ";    // cout<<endl<<"ans="<<ans<<" p="<<p<<" q="<<q<<endl;     for(int i=index+1;i<m;i++)     {         vector<int> b=a;         b.push_back(i);         reduce(b,i);     } }   void solve() {     cin>>n>>m;     ans=fact[n];     for(int i=0;i<m;i++) cin>>bad[i].first>>bad[i].second;    // cout<<ans<<endl;     for(int i=0;i<m;i++)     {         vector<int> a;         a.push_back(i);         reduce(a,i);     }     cout<<ans<<endl; }   int main() {     ios_base::sync_with_stdio(false);     cin.tie(0);    // freopen("input.c","r",stdin);     calc();     int t;     cin>>t;     while(t--) solve();     return 0; }
#include <cstdio> #include <cmath> #include <cstring> #include <iostream> #include <algorithm> #include <vector> #include <string> #include <map> #include <queue> #include <set> #include <cassert>  using namespace std;  #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define S(x) 			scanf("%d",&x) #define all(c) 			(c).begin(),(c).end()  #define sz(c) 			int((c).size()) #define pb 				push_back #define present(c,x) 	((c).find(x) != (c).end())  #define rep(i,x,y) 		for(int i = x; i < y; i++) #define REV(i,x,y) 		for(int i = x; i >= y; i--) #define foreach(c,itr)	for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) #define FILL(a,v) 		memset(a,v,sizeof(a)) #define DB(x)			cerr<<#x<<" = "<<x<<endl #define debugarr(A,a,b) cerr<<#A<<" : ";rep(itr,a,b) cerr<<A[itr]<<" ";cerr<<endl; //#define R(x) 			((rand()%x) + 1)  typedef long long int LL; typedef vector<int> vi;  typedef vector<vi> vvi;  typedef pair<int,int> ii; typedef vector<ii> vii;  /* ------------------------Main Code----------------------- */ const int MAX = 302;  int A[MAX][MAX], cnt[MAX][MAX]; int BIT[MAX];  void update(int idx, int val) { 	while(idx < MAX){ 		BIT[idx] += val; 		idx += idx & -idx; 	} }  int query(int idx) { 	int res = 0; 	while(idx > 0){ 		res += BIT[idx]; 		idx -= idx & -idx; 	} 	return res; }  //int x_cnt[MAX] = 0; int main() { 	int t; 	S(t); 	while(t--){ 		int n; 		S(n); 		FILL(cnt,0); 		rep(i,1,n+1) rep(j,1,n){ 			S(A[i][j]); 			//if(i != 1)  				cnt[A[i][j]][j]++; 		} 		int x[MAX], flag = 0; 		// rep(i,1,n+1){ 		// 	rep(j,1,n) printf("%d ",cnt[i][j]); 		// 	printf("\n"); 		// } 		rep(i,1,n+1){ 			rep(j,1,n+1){ 				x[j] = i; 				int y = 1; 				rep(k,1,n){ 					if(k == j) x[y++] = i; 					x[y++] = A[1][k] >= i ? A[1][k]+1 : A[1][k]; 				} 				FILL(BIT,0); 				//FILL(s_cnt,0); 				flag = 1; 				// rep(k,1,n+1) printf("%d ",x[k]); 				// printf("\n"); 				rep(k,1,n){ 					update(x[k]+1,1); 					int fs;  					fs = query(x[k+1]); 					if(cnt[x[k+1]-1][k] < fs || cnt[x[k+1]][k] < (k-fs)){flag = 0;break;} 					//DB(fs); 					fs = query(x[k]); 					//DB(fs); 					if(cnt[x[k]-1][k] < x[k]-fs-1 || cnt[x[k]][k] < n-x[k]-(k-fs-1)){flag = 0; break;} 				} 				if(flag) break; 			} 			if(flag) break; 		} 		rep(i,1,n+1) printf("%d ",x[i]); 		printf("\n"); 	} }
#include<iostream> #include<cstdio> using namespace std;  int generator(char str[],int x) {     int seed;     int flag;     for(int i = 0;i < 35;++i)     {         x = x*1103515245+12345;         seed = x>>16;         if((seed&1) == 1 && str[i] == '0' || !(seed&1) && str[i] == '1')             flag = 1;         else         {              flag = 0;              break;         }      }     return flag; }  int main() {     int t;     scanf("%d",&t);     char str[200001];     while(t--)     {         scanf("%s",str);         int res = 0;         for(int i = 0;i <= 1000000;++i)         {             res = generator(str,i);             if(res == 1)                 break;         }         if(res == 1)             printf("LCG\n");         else             printf("Xorshift\n");     }     return 0; } 
//Template by @sai krishna #include <map> #include <set> #include <queue> #include <cmath> #include <stack> #include <vector> #include <cstdio> #include <bitset> #include <sstream> #include <cassert> #include <cstring> #include <utility> #include <iterator> #include <iostream> #include <algorithm> #include <functional> using namespace std; #define rep(i,a,n) for(int i=a;i<n;i++) #define srt(x) sort(x.begin(),x.end()) #define clear(x,val) memset(x,val,sizeof x) #define rl(x) scanf("%lld",&x) #define ri(x) scanf("%d",&x) #define gc getchar_unlocked #define pi2 pair<pii,int> #define pii pair<int,int> #define MOD 1000000007 #define LL long long #define MAX 100000001 #define ss second #define INF 1<<32 #define ff first LL fact[2000054],inv_fact[2000054]; LL powerMOD(LL a,LL b) { 	LL x=1,y=a; 	while(b) 	{ 		if(b&1) 		x*=y; 		if(x>MOD)x%=MOD; 		y*=y; 		if(y>MOD)y%=MOD; 		b>>=1; 	} 	return x; } void factorial() { 	inv_fact[0]=fact[0]=inv_fact[1]=1; 	for(int i=1;i<=2000050;i++) 	{ 		fact[i]=(fact[i-1]*i)%MOD; 	}     for(int i=2;i<=2000050;++i){         inv_fact[i]=(powerMOD(i,MOD-2)*inv_fact[i-1])%MOD;     } } LL nCr(LL n,LL r) { 	return (fact[n]*inv_fact[n-r]%MOD * inv_fact[r])%MOD; } int main() { 	int t; 	ri(t); 	while(t--) 	{ 		LL n,k; 		rl(n),rl(k); 		LL ans[n+1]; 		if(k==1) 		{ 			cout<<(powerMOD(2,n))<<endl; 			continue; 		} 		ans[0]=1; 		ans[1]=(k==1)?2:1; 		for(int i=2;i<=n;i++) 		{ 			if(i<k) 				ans[i]=1; 			else 				ans[i]=(ans[i-k]+ans[i-1])%MOD; 		} 		cout<<ans[n]<<endl; 	} 	return 0; }  
#include <cstdio> #include <cstring> #include <cstdlib> #include <cmath>  #include <iostream> #include <string> using namespace std;  const int MAX_LEN = 100000+2; const int MAX_K = 101; const int INF = 0x3f3f3f3f; int a,b,k;  char s1[MAX_LEN]="0"; char s2[MAX_LEN]="0"; char tmp[MAX_LEN]; int len1,len2; int P[MAX_LEN][2*MAX_K+1];  inline bool isDelta(int d) { 		return abs(d)<=k; }  int min3(const int& a,const int& b,const int& c) { 		return min(min(a,b),c); }   int main() { 		int test; 		scanf("%d",&test); 		int tt=0; 		while(tt++<test) 		{ 				scanf("%s",tmp); 				strcat(s1,tmp); 				scanf("%s",tmp); 				strcat(s2,tmp); 				scanf("%d %d %d",&a,&b,&k); 				len1=strlen(s1)-1; 				len2=strlen(s2)-1; #ifdef DEBUG 				printf("%s %s,%d %d %d\n",s1,s2,a,b,k); #endif  				if(a==0){printf("0\n");}  				else if(abs(len1-len2)>k){printf("-1\n");}  				else 				{ 				int offset = k; 				for(int i=0;i<=len1;i++) 						for(int d=-k;d<=k;d++) 								P[i][d+offset]=INF;  				for(int d=0;d<=k;d++) 				{ 						P[0][offset+d] =d*a; 				} 				for(int i=0;i<=k;i++) 				{ 						P[i][offset-i]=i*a; 				}  				 				for(int i=1;i<=len1;i++) 				{ 						for(int delta = -k;delta<=k;delta++) 						{ 								if(i+delta>=1&&i+delta<=len2) 								{ 								 										if(s1[i]==s2[i+delta]) 												P[i][delta+offset] = P[i-1][delta+offset]; 										else  										{ 												P[i][delta+offset] = min3( 																		isDelta(delta+1)?P[i-1][delta+1+offset]+a:INF, 																		isDelta(delta-1)?P[i][delta-1+offset]+a:INF, 																		P[i-1][delta+offset]+b 																		); 										} 								} 						} 				}  				if(P[len1][len2-len1+offset]<=k) 						printf("%d\n",P[len1][len2-len1+offset]); 				else printf("-1\n"); 				} 				s1[0]='0'; 				s1[1]='\0'; 				s2[0]='0'; 				s2[1]='\0'; 		} }       
#include <iostream> using namespace std;  int main() { 	// your code goes here 	 	int t,i,j,n,s; 	cin>>t; 	while(t>0){ 	    s=0; 	    j=0;  // imp....  	    cin>>n; 	    int a[n]; 	    for(i=0;i<n;i++){ 	        cin>>a[i]; 	        if(a[i]==0) 	            j++; 	        s+=a[i]; 	    } 	    if(s-n+j <= 99 && s >= 100){ 	        cout<<"YES"<<endl; 	    } 	    else{ 	        cout<<"NO"<<endl; 	    } 	  	    t--; 	} 	 	 	  	 	 	return 0; } 
#include <string> #include <vector> #include <algorithm> #include <cmath> #include <set> #include <map> #include <cstdio> #include <sstream> #include <iostream> #include <cstring> #define REP(i,x,v)for(int i=x;i<=v;i++) #define REPD(i,x,v)for(int i=x;i>=v;i--) #define FOR(i,v)REP(i,0,(int)(v)-1) #define FORD(i,v)REPD(i,(int)(v)-1,0) #define pb push_back #define sz size #define mp make_pair #define fi first #define se second #define ll long long #define IN(x,y) ((y).find((x))!=(y).end()) #define DBG(vari) cout<<#vari<<" = "<<vari<<endl; #define CZ(x) scanf("%d",&(x)); #define CZ2(x,y) scanf("%d%d",&(x),&(y)); #define ALL(x) (x).begin(),(x).end() #define uint unsigned int using namespace std; typedef vector<uint> mat; int d,n,A[100];   void wypisz(mat m1) {     FOR(i,d){     FOR(j,d)     cout<<!!(m1[i]&(1<<j))<<" ";     cout<<endl;     } }   mat id() {     mat w(d,0);     FOR(i,d) w[i]=(1<<i);     return w; }   mat mult(mat m1, mat m2) {     mat w(d,0);     FOR(i,d) FOR(j,d) FOR(k,d)     {         w[i]^=((!!(m1[i]&(1<<j)))&(!!(m2[j]&(1<<k))))<<k;     }     return w; }   mat podnies(mat m, ll k) {     if (k==0) return id();     mat x=podnies(m,k/2);     x=mult(x,x);     if (k%2) return mult(m,x);     return x; }           int main() {     ios_base::sync_with_stdio(0);     int t;     cin>>t;     while(t--)     {         uint seed=0,wyn;         vector<int> nr,war,pod;         int ile=0,a,b;         cin>>d>>n;         FOR(i,d) cin>>A[i];         FOR(i,n)         {             cin>>a>>b;             nr.pb(a);             war.pb(b);         }         mat m(d);         FOR(i,d-1) m[i]=1<<(i+1);         FOR(i,d) m[d-1]|=(A[i])<<i;         //wypisz(m);         //DBG(d);         FOR(i,n) pod.pb((podnies(m,nr[i]))[0]);         //FOR(i,n) DBG(pod[i]);         FOR(s,(1<<d))         {             //DBG(s);             int ok=1;             FOR(i,n)             {                 //DBG(__builtin_popcount(pod[i]&s)%2);                 if (__builtin_popcount(pod[i]&s)%2!=war[i])                 {                     ok=0;                     break;                 }             }             if (ok)             {                 ile++;                 wyn=s;             }             //DBG(wyn);         }         if (ile==1)         {             FOR(i,d) cout<<!!(wyn&(1<<i))<<" ";             cout<<endl;         }         else if (ile==0)         {             cout<<"no solution"<<endl;         }         else         {             cout<<"multiple solutions"<<endl;         }     }               return 0; }  
#include <bits/stdc++.h>  using namespace std;  #define max(a,b) ((a)>(b)?a:b) #define   MOD 1000000007  int nextmask(int v, int mask, vector<int>& vi) { 	int L[2][18]; 	memset(L,0,sizeof(L)); 	int LCS = 0; 	for (int i = 0; i < vi.size(); i++) { 		if(mask & (1<<i))	LCS++; 		L[0][i+1] = LCS; 	} 	int ret = 0; 	for (int i = 1; i <= vi.size(); i++) { 		L[1][i] = (v==vi[i-1])?1+L[0][i-1]:max(L[0][i],L[1][i-1]); 		if(L[1][i]>L[1][i-1])	ret|=(1 << (i-1)); 	} 	return ret; }  int memo[18][1<<16]; int newmask[18][1<<16]; int N,K,L;  int solve(int b, int mask, int K, int L) { 	if (b > N) { 		int LCS = 0; 		for (int i = 0; i < N; i++) { 			if (mask & (1<<i))	LCS++; 		} 		return LCS==L; 	} 	if(memo[b][mask]!=-1)	return memo[b][mask]; 	int ways = 0; 	for (int i = 1; i <= K; i++) { 		ways += solve(b+1,newmask[i][mask],K,L); 		if(ways >= MOD) 			ways %= MOD; 	} 	return memo[b][mask] = ways; }  int main() { 	vector<int> vi; 	int test; 	cin >> test; 	int num; 	while (test--) { 		memset(memo,-1,sizeof(memo)); 		vi.clear(); 		cin >>N>>K>>L; 		for (int i = 0; i < N; i++) { 			cin >> num; 			vi.push_back(num); 		}  		for (int i = 1; i <= K; i++) { 			for(int j = 0 ; j < (1<<N) ; j++) 				newmask[i][j] = nextmask(i,j,vi); 		} 		int ans = solve(1,0,K,L); 		cout << ans << endl; 	} }
#include <iostream> #include <stdio.h> #include <string.h> #include <algorithm> #include<sstream> #include <vector> #include <cmath> #include <set> #include <map> using namespace std; #define ll long long #define mp make_pair #define pb push_back #define fi first #define se second #define rep(i,n) for(int i=0;i<n;i++) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define N 1000005 #define inf 1000000007 #define sz(a) int(a.size()) #define pii pair<int,int> #define vi vector<int> #define pi acos(-1) int f[1<<15],a[1<<15]; int main() {    // freopen("in.txt","r",stdin);     int T,i,j,k,x,y,m,n,t;     scanf("%d",&T);     while(T--)     {      scanf("%d%d%d",&n,&x,&y);      t=x^y;      if(n==1||(n==2&&(t==1||t==2))){puts("-1");continue;}      int tmp=0,len=(1<<n);      for(i=0;i<n;i++)f[1<<i]=i;      for(i=1;i<(1<<n);i++)      if(i&1)      {a[i-1]=0;tmp^=1;}      else      {       int bit=tmp^(tmp&(tmp-1));       a[i-1]=f[bit]+1;       tmp^=(bit<<1); 	 } 	 a[len-1]=f[tmp]; 	 if(!(t&(t-1))) 	 { 	  int bad=f[t]; 	  if(a[0]==bad||a[len-1]==bad) 	  { 	   int nxt=0; 	   while(a[len-1]==nxt||a[0]==nxt)nxt++; 	   for(i=0;i<len;i++) 	   if(a[i]==bad)a[i]=nxt; 	   else if(a[i]==nxt)a[i]=bad; 	  } 	 } 	 tmp=x; 	 for(i=0;i<len;i++) 	 { 	  printf("%d ",tmp); 	  tmp^=(1<<a[i]); 	 } 	 puts(""); 	}     return 0; } 
#include<bits/stdc++.h> #define ll long long #define MOD 1000000007 #define ok printf("\n") using namespace std; int main() {     int num,n,i,j,k;     cin>>n;   ll array[n+1],max_ar[n+1],min_arr[n+1],prod[n+1],res=1;     max_ar[0]=INT_MAX,min_arr[0]=INT_MIN,prod[0]=1;     for(i=1;i<=n;++i)     {k=i-1;         scanf("%d",&num);         while(num>max_ar[k] && k>=0)             {max_ar[k--]=num;            // printf("k=%d MAX=%lld ",k+1,max_ar[k+1]);             }         while(num<min_arr[k]&&k>=0)             {min_arr[k--]=num;             //printf("k=%d Min=%lld ",k+1,min_arr[k+1]);             }             ++k;             //ok;         for(j=k;j<i;++j){         prod[j]=(prod[j-1]*(max_ar[j]-min_arr[j]))%MOD;         //printf("j=%d PRO=%lld max=%lld min=%lld ",j,prod[j],max_ar[j],min_arr[j]);         }         max_ar[i]=min_arr[i]=num;         res=(res*prod[i-1])%MOD;     }     printf("%lld",res); } 
/* /저자 : 흑인     날짜 : 2014-04-01-11.09.35 Tuesday */  #include <bits/stdc++.h> using namespace std;  namespace SOL{     const int MAX = (1 << 20) + 5;     int Fre[MAX];     void solve(){         memset(Fre,0,sizeof(Fre));         long long int n,m;         cin >> n >> m;         long long ans = n*m;         for(int i = 1; i <= n; ++i) ++Fre[(i-1)^(n-i)];          for(int i = 1; i <= m; ++i)             ans -= Fre[(i-1)^(m-i)];         cout << ans << endl;     } };  int main() {     ios_base::sync_with_stdio(0);     int t; cin >> t;     while(t--) SOL::solve();     return 0; } 
#include <iostream> #include <cstdio> #include <algorithm> #include <cstdlib> #include <vector> #include <set> #include <map> #include <cassert> #include <ctime>  #include <cmath> #include <string> #include <cstring> #include <queue> using namespace std;  #define f first #define s second #define mp make_pair #define pb push_back #define pii pair<int, int> #define vi vector<int> #define all(v) (v).begin(), (v).end() #define forit(it,v) for (__typeof(v.begin()) it = v.begin(); it != v.end(); ++it) #define f0(a) memset(a, 0, sizeof(a)) #define ll long long char s[100][100]; int n, m; int col[100000], coln; int pos[1000], la[1000]; int nval[1000], emask[1000]; int dp[55][1 << 17];  void upd(int mask, int i, int emask, int lmask) { 	mask = mask - lmask; 	mask = mask | emask; 	dp[i + 1][mask] = true; }  int emas(int l, int r) { 	return (emask[r] ^ emask[l]); } int lmas(int mask, int i, int j = -1) { 	if (mask & (1 << i)) mask -= (1 << i); 	if (j != -1 && (mask & (1 << j))) mask -= (1 << j); 	return mask; }  void Solve() { 	scanf("%d%d", &n, &m); 	coln = 0; 	for (int i = 0; i < n; ++i) { 		scanf("\n"); 		for (int j = 0; j < m; ++j) { 			scanf("%c", &s[i][j]); 			if (s[i][j] == 'L') col[coln++] = j; 		} 	}  	sort(col, col + coln); 	coln = unique(col, col + coln) - col;  	for (int i = 0; i <= m; ++i) 		pos[i] = -1;  	for (int i = 0; i < coln; ++i) 		pos[col[i]] = i;  	for (int i = 0; i <= n; ++i) 		for (int mask = 0; mask < (1 << coln); ++mask) 			dp[i][mask] = 0;  	dp[0][0] = 1;  	for (int i = 0; i < n; ++i) 		for (int mask = 0; mask < (1 << coln); ++mask) if (dp[i][mask]) {  			int lan = 0, lmask = 0;  			for (int j = 0; j < m; ++j) { 				if (j == 0) { 					emask[j] = 0; 					nval[j] = 0; 				} else { 					emask[j] = emask[j - 1]; 					nval[j] = nval[j - 1]; 				}  				if (s[i][j] == 'E') { 					if (pos[j] == -1) { 						nval[j]++; 					} else { 						emask[j] |= (1 << pos[j]); 					} 				} else if (s[i][j] == 'L') { 					la[lan++] = j; 					if (mask & (1 << pos[j])) 						lmask |= (1 << pos[j]);	 				} 			}  			if (nval[m - 1] == 0) 				upd(mask, i, emask[m - 1], lmask);  			for (int j = 0; j < lan; ++j) { 				int le = la[j];  				if (nval[le] == nval[m - 1])  					upd(mask, i, emas(le, m - 1), lmas(lmask, pos[le])); 				 				if (nval[le] == 0)  					upd(mask, i, emask[le], lmas(lmask, pos[le]));  				for (int k = 0; k < lan; ++k) if (j != k){ 					int ri = la[k];  					if (ri > le &&nval[ri] - nval[le]  == 0) 						upd(mask, i, emas(le, ri), lmas(lmask, pos[le], pos[ri])); 					 					if (le > ri) { 						upd(mask, i, 0, lmas(lmask, pos[le], pos[ri])); 					} 				} 			}	  		}  	if (dp[n][0]) { 		puts("Possible"); 	} else { 		puts("Impossible"); 			 	} } int main() { 	int tests; 	scanf("%d", &tests); 	while (tests--) 		Solve(); 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  const int MAX = 55;  int cases = 1; int dp[MAX][MAX]; int vis[MAX][MAX], N, M, a[MAX][MAX];  //#include <conio.h>   void read(){     scanf("%d %d", &N, &M);     for(int i=0; i<N; i++){         for(int j=0; j<M; j++) scanf("%d", &a[i][j]);         // omit leading ones     }     return ; }  int rec(int n, int pos, int rem){     if(pos == M)         return 0;     if(rem == 0)         return rec(n, pos + 1, a[n][pos+1]);     int& ret = dp[pos][rem];     int& vc = vis[pos][rem];     if(vc == cases) return ret;     vc = cases;     bool flag[100];     memset(flag, 0, 100);     for(int i=1; i<=rem; i++){ //        assert(rec(n, pos, rem-i) < 100);         flag[ rec(n, pos, rem-i) ] = true;     }     for(int i=0; ; i++){         if(flag[i] == false)             return ret = i;     }     return ret = 0; }  int giveFinalGrundy(int n){     int i = 1, p = 1;     for(; i<M; i++){         if(a[n][i] != a[n][0])             break;         p++;     }     if(i == M){         if(M%2 == 1)             return a[n][0];         return a[n][0] - 1;     }     if(p == 1){ // general case         if(a[n][0] > a[n][1])             return a[n][0];         else return a[n][0] - 1;     } else{         if(p%2 == 1){ // odd times are there first number             if(a[n][0] > a[n][i])                 return a[n][0];             else                 return a[n][0] - 1;         }         else{ // even times are there first number             if(a[n][0] > a[n][i])                 return a[n][0] - 1;             else                 return a[n][0];         }     }     return 0; }  int giveGrundy(int n){     // if the first number is the greater than  the second number than grundy value of that row is the first number     // else grundy is first number - 1     int numb = a[n][0];     bool flag = true;     for(int i=1; i<M; i++) if(a[n][i] != a[n][0]) flag = false;     if(flag == true){         if(M%2 == 1)             return a[n][0];         else             return a[n][0] - 1;     }     if(a[n][0] > a[n][1]) return a[n][0];     return a[n][0] - 1;  //    bool flag = true; //    for(int i=1; i<M; i++){ //        if(a[n][i] > a[n][0]) flag = false; //    } //    if(flag == true) return a[n][0]; //    return a[n][0]-1; }  int main(){ //    assert(1>2); //    freopen("in.txt", "r", stdin);     int test, c=1;     scanf("%d", &test);     while(test--){         read();         int res = 0;         for(int i=0; i<N; i++){             cases++;   //            int sum = 0; //            for(int j=0; j<M; j++) sum += a[i][j]; ////            printf("row number: %d\tgrundy = %d\tsum = %d\n", i, rec(i, 0, a[i][0]), sum);//getch(); //            if(rec(i,0, a[i][0]) == 0){ //                for(int j=0; j<M; j++) printf("%d ", a[i][j]); puts("");//getch(); //            } //            res ^= rec(i, 0, a[i][0]); //            printf("res: %d\n", res);//getch();               res ^= giveFinalGrundy(i);         } //        printf("res: %d\t", res);         printf("%s\n", res ? "FIRST" : "SECOND");     }     return 0; }   /**  Got pattern from the cases:  100 1 3 1 1 1 row number: 0   grundy = 1      sum = 3 res: 1 FIRST 1 3 1 1 2 row number: 0   grundy = 1      sum = 4 res: 1 FIRST   1 3 3 3 4 res: 3 res: 3  FIRST  1 3 17 17 14 res: 16 res: 16 FIRST  1 3 17 17 18 res: 17 res: 17 FIRST  1 3 17 16 14 res: 17 res: 17 FIRST  1 3 17 16 18 res: 17 res: 17 FIRST  1 4 17 17 17 14 res: 17 res: 17 FIRST  1 4 17 17 17 18 res: 16 res: 16 FIRST      1 5 12 12 13 14 15 res: 12 res: 12 FIRST  1 5 12 12 12 13 14 res: 11 res: 11 FIRST 1 7 12 12 12 12 12 13 14 res: 11 res: 11 FIRST  1 7 12 12 12 12 12 9 14 res: 12 res: 12 FIRST  1 6 12 12 12 12 9 14 res: 11 res: 11 FIRST  1 4 12 12 12 12 res: 11 res: 11 FIRST  1 2 12 12 res: 11 res: 11 FIRST  1 3 12 12 12 res: 12 res: 12 FIRST  1 3 12 15 18 res: 11 res: 11 FIRST  1 3 12 15 15 res: 11 res: 11 FIRST  1 3 12 9 6 res: 12 res: 12 FIRST  1 3 12 9 9 res: 12 res: 12 FIRST 1 5 12 12 12 12 12 res: 12 res: 12 FIRST  1 7 12 12 12 12 9 4 13 res: 11 res: 11 FIRST 1 7 12 12 12 12 17 4 13 res: 12 res: 12 FIRST                                   1 3 2 2 3 ?                                      1 3 17 42 40 row number: 0   grundy = 16     sum = 99 res: 16 FIRST  1 3 17 16 42 row number: 0   grundy = 17     sum = 75 res: 17 FIRST  1 4 1 17 16 42 row number: 0   grundy = 0      sum = 76 1 17 16 42 res: 0 SECOND   1 3 17 17 17 row number: 0   grundy = 17     sum = 51 res: 17 FIRST 1 4 17 17 17 17 row number: 0   grundy = 16     sum = 68 res: 16 FIRST  1 5 17 17 17 17 17 row number: 0   grundy = 17     sum = 85 res: 17 FIRST  1 5 17 17 15 14 13 row number: 0   grundy = 16     sum = 76 res: 16 FIRST   1 5 17 16 15 14 13 row number: 0   grundy = 17     sum = 75 res: 17 FIRST   1 5 17 16 17 17 17 row number: 0   grundy = 17     sum = 84 res: 17 FIRST  1 6 17 16 17 17 17 17 row number: 0   grundy = 17     sum = 101       */ 
#include <iostream> #include <cstdio> #include <cmath> using namespace std;   #define M 1000000007; #define SET result[0][0] = result[1][1] = mat[0][0] = mat[0][1] = mat[1][0] = 1; result[1][0] = result [0][1] = mat[1][1] = 0   static long long mat[2][2], mat1[2][2], mat2[2][2], result[2][2];   void matexp(long times) {     for (int t = 0; t < 2; t++)     {         for (int s = 0; s < 2; s++)             mat1[t][s] = mat2[t][s] = mat[t][s];     }       long temp2 = 0;     for (int i = 1; i < times; i++)     {         for (int j = 0; j < 2; j++)         {             for (int p = 0; p < 2; p++)             {                 for (int l = 0; l < 2; l++)                     temp2 = (temp2 + (mat[j][l]*mat1[l][p]))%M;                   mat2[j][p] = temp2%M;                 temp2 = 0;             }         }           for (int t = 0; t < 2; t++)         {             for (int s = 0; s < 2; s++)                 mat1[t][s] = mat2[t][s];         }     } }   void matmultiply () {     long temp = 0;     for (int j = 0; j < 2; j++)     {         for (int p = 0; p < 2; p++)         {             for (int l = 0; l < 2; l++)                 temp = (temp + (result[j][l]*mat1[l][p]))%M;               mat2[j][p] = temp%M;             temp = 0;         }     }       for (int t = 0; t < 2; t++)     {         for (int s = 0; s < 2; s++)             result[t][s] = mat2[t][s];     } }   int main() {     int T;     scanf("%d", &T);          for (int i = 1; i <= T; i++)     {         long long power, r, temp1, index = 0, temp;         scanf("%lld", &power); temp1 = power;         SET;                  for (int i = 1; i <= 10; i++)         {             int w = temp1/pow(10, i);             if (w == 0)                 {index = i-1; break;}         }           r = pow(10, 1); temp = power%r; temp = (temp/pow(10, 0));         if (temp != 0)         {             matexp(temp);             matmultiply();         }           for (int k = 1; k <= index; k++)         {             r = pow(10, k+1);             temp = power%r;             temp = (temp/pow(10, k));               matexp(10);             for (int t = 0; t < 2; t++)             {                 for (int s = 0; s < 2; s++)                     mat[t][s] = mat1[t][s];             }               if (temp != 0)             {                 matexp(temp);                 matmultiply();             }         }         if (temp1==1 || temp1==2)             printf("%d\n", 1);         else if (temp1==3)             printf("%d\n", 3);         else if (temp1 > 3)             printf("%lld\n", result[1][0]);     }             return 0; }
#include<iostream> #include<cstdio> using namespace std;  int main() {     int T; // Number of test cases     int N; // Number of chairs     int R; // Number of ringings     double factorialArray[51], derangeArray[51]; // Helper arrays     double result; // Result :P     int i, j, k; // Loop variables     factorialArray[0] = 1;     factorialArray[1] = 1;     derangeArray[0] = 1;     derangeArray[1] = 0;     for (i = 2; i < 51; i++)     {         factorialArray[i] = factorialArray[i - 1] * i;         derangeArray[i] = (i - 1) * (derangeArray[i - 1] + derangeArray[i - 2]);     }     cin >> T;     for (j = 0; j < T; j++)     {         cin >> N >> R;         result = 0;         for (k = 2; k <= N; k++)         {             if (R % k == 0)             {                 result += factorialArray[N - 1] / factorialArray[N - k] * derangeArray[N - k];             }         }         result /= derangeArray[N];         result *= N;         printf ("%.5f\n", result);     }     return 0; } 
#include <stdio.h> #include <vector> #include <algorithm> #include <utility> using namespace std; int n, t; vector<pair<int, int> > G[6]; int sz[6]; int quality; void travel(int i, int cost, int q){ 	if(cost>t||q<=quality)return; 	if(i==6){ 		quality = q; 		return; 	} 	for(int j = 0;j<sz[i];j++){ 		travel(i+1, cost+G[i][j].first, min(q, G[i][j].second)); 	} } int main(){ 	int d, p, q; 	scanf("%d%d", &n, &t); 	for(int i =0 ;i< n; i++){ 		scanf("%d%d%d", &d, &p, &q); 		G[d-1].push_back(make_pair(p, q)); 	} 	for(int i =0 ; i<6; i++)sz[i] = (int)G[i].size(); 	quality = 0; 	travel(0, 0, 100000000); 	printf("%d\n", quality); 	return 0; }
/* Divanshu Garg */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <cctype> #include <cassert> #include <complex>  using namespace std;  #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define pb(x) push_back(x) #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(int i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define Sl(x) scanf("%llu",&x) #define M(x,i) memset(x,i,sizeof(x)) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define MAX(a,b) ((a)>(b)?(a):(b)) ill ABS(ill a) { if ( a < 0 ) return (-a); return a; } #define fr first #define se second  /* Relevant code begins here */  /* Input from file or online */  void input() { #ifndef ONLINE_JUDGE     freopen("input.txt","r",stdin); #endif }  /* Input opener ends */  #define N 500005	 int a[N], pos[N];  struct node { 	int start, end, sum; 	node *L, *R; 	node() { 		sum = 0; 		L = R = NULL; 	} } pool[21234567]; int CNT = 0; node * root[N];  node * create(int l,int r) { 	node *tmp = &pool[CNT++]; 	tmp->start = l; 	tmp->end = r; 	tmp->sum = 0; 	if ( l < r ) { 		int mid = (l+r)/2; 		tmp->L = create(l,mid); 		tmp->R = create(mid+1,r); 	} 	return tmp; }  node * change(node * other, int whr) { 	node *tmp = &pool[CNT++]; 	tmp->start = other->start; 	tmp->end = other->end; 	tmp->sum = other->sum + 1; 	tmp->L = other->L; 	tmp->R = other->R; 	if ( tmp->start < tmp->end ) { 		int mid = (other->start + other->end)/2; 		if ( whr <= mid ) tmp->L = change(other->L,whr); 		else tmp->R = change(other->R,whr); 	} 	return tmp; }  int getKthelement(node * upper, node * lower, int k) { 	// cout << upper->start << " " << upper->end << " "  << k << endl; 	if ( upper->start == upper->end ) return upper->start; 	int lowerCnt = upper->L->sum - lower->L->sum; 	if ( lowerCnt >= k ) 		return getKthelement(upper->L,lower->L,k); 	return getKthelement(upper->R,lower->R,k-lowerCnt); }  #define gc getchar  void readInt(int &n) { 	n = 0; 	char ch = gc(); 	while ( !isdigit(ch) ) ch = gc(); 	while ( isdigit(ch) ) { 		n = n*10 + (ch-48); 		ch = gc(); 	} }  int main() {     input();     int n; readInt(n);     F(i,0,n) {     	readInt(a[i]);     	pos[a[i]] = i;     }     root[0] = create(0,n-1);     F(i,1,n+1) {     	root[i] = change(root[i-1],pos[i]);     }      ill ans = 0;     queue<int> ql, qr;     ql.push(1); qr.push(n);     while ( !ql.empty() ) {     	int lo = ql.front(); ql.pop();     	int hi = qr.front(); qr.pop();     	int k = (hi-lo+2)/2;     	int get = a[getKthelement(root[hi],root[lo-1],k)];     	// cout << lo << " " << hi << " " << k << " " << get << endl;     	// return 0;     	if ( hi > lo ) ans += (hi-lo+1);     	if ( lo <= get-1 ) {     		ql.push(lo); qr.push(get-1);     	}     	if ( get+1 <= hi ) {     		ql.push(get+1); qr.push(hi);     	}     }     printf("%lld\n", ans);     return 0; }
#include <bits/stdc++.h> using namespace std; #define ll unsigned long long int  int main() {     unsigned long long  n;     int t;     cin>>t;    unsigned long long int a[]={     	1ll, 1ll, 2ll, 3ll, 6ll, 10ll, 20ll, 35ll, 70ll, 126ll, 252ll, 462ll,  		924ll, 1716ll, 3432ll, 6435ll, 12870ll, 24310ll, 48620ll, 92378ll, 	    184756ll, 352716ll, 705432ll, 1352078ll, 2704156ll, 5200300ll,  		10400600ll, 20058300ll, 40116600ll, 77558760ll, 155117520ll,  		300540195ll, 601080390ll, 1166803110ll,2333606220ll,4537567650ll, 		9075135300ll,     17672631900ll,     35345263800ll,     68923264410ll,     137846528820ll,     269128937220ll,     538257874440ll,     1052049481860ll,     2104098963720ll,     4116715363800ll,     8233430727600ll,     16123801841550ll,     32247603683100ll,     63205303218876ll,     126410606437752ll,     247959266474052ll,     495918532948104ll,     973469712824056ll,     1946939425648112ll,     3824345300380220ll,     7648690600760440ll,     15033633249770520ll,     30067266499541040ll,     59132290782430712ll,     118264581564861424ll,     232714176627630544ll,     465428353255261088ll,     916312070471295267ll,     1832624140942590534ll     };    while(t--) {       cin>>n;      cout<<lower_bound(a,a+65,n)-a<<endl;     } }
#include<bits/stdc++.h> using namespace std; long long int gcd(long long a1, long long b1) {     if(a1==0)         return b1;     return gcd(b1%a1,a1); } int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,i,f=0;         long long s,s1,s2,j;         scanf("%d",&n);         long long a[n+69];         for(i=0;i<n;i++)             scanf("%lld",&a[i]);         for(i=0;i<n;i++)         {             for(j=i+1;j<n;j++)             {                 s=__gcd(a[i],a[j]);                 if(s>1)                 {                     printf("%lld\n",s);                     f=1;                     break;                 }             }             if(f==1)                 break;         }         if(f==0)         {             for(i=0;i<n;i++)             {                 long long x=a[i];                 for(j=1;j*j*j<=x;j++)                 {                     if(j>1&&x%(j*j)==0)                     {                         printf("%lld\n",j);                         f=1;                         break;                     }                     if(a[i]%j==0)                     {                         s1=x/j;                         s2=(long long)sqrt(s1);                         if((s2*s2)==s1 && s2>1)                         {                             printf("%lld\n",s2);                             f=1;                             break;                         }                     }                 }                 if(f==1)                     break;             }         }     }     return 0; }
#include<set> #include<queue> #include<cstdio> #include<vector> #include<algorithm> #include<functional>   #define pb push_back #define rep(i,n) for(int i=0;i<n;i++)   using namespace std;   typedef	vector<int> vi; typedef	pair<int,int> pii;   const int INF=1<<29;   struct Square{ int x,y,a,parent,grundy; vi child; Square(){ parent=grundy=-1; child.clear(); } } sq[50000];   int calcGrundyNumber(int id){ if(~sq[id].grundy)	return sq[id].grundy; int g=0; rep(i,sq[id].child.size()){ g^=calcGrundyNumber(sq[id].child[i]); } return sq[id].grundy=1+g; }   // paint a square in tree p, then the grundy number of this tree is g int findSuitableSquare(int p,int g){ // if(g==0)printf("> candidate %d\n",p); if(g==0)	return p; int ans=INF; int gp=calcGrundyNumber(p); rep(i,sq[p].child.size()){ int c=sq[p].child[i]; ans=min(ans,findSuitableSquare(c,(g-1)^(gp-1)^calcGrundyNumber(c))); } return ans; }   enum SIDE{TOP=0,BOTTOM=1,LEFT=0,RIGHT=1}; struct Event{ int t,id; SIDE side; Event(int T,int ID,SIDE S):t(T),id(ID),side(S){} bool operator<(const Event &e)const{ return t<e.t; } bool operator>(const Event &e)const{ return e<*this; } };   int tmp_parent[50000];   int determineParent(int id){ if(~tmp_parent[id]){ int p=determineParent(tmp_parent[id]); sq[id].parent=p; sq[p].child.pb(id); } return sq[id].parent; }   int main(){ int T; scanf("%d",&T); while(T--){ int n; scanf("%d",&n); rep(i,n){ tmp_parent[i]=-1; sq[i]=Square(); scanf("%d%d%d",&sq[i].x,&sq[i].y,&sq[i].a); }   priority_queue< Event,vector<Event>,greater<Event> > pq; rep(i,n){ pq.push(Event(sq[i].y,i,TOP)); pq.push(Event(sq[i].y+sq[i].a,i,BOTTOM)); }   set<Event> st; while(!pq.empty()){ Event e=pq.top(); pq.pop(); int y=e.t,id=e.id; if(e.side==TOP){ set<Event>::iterator it=st.lower_bound(Event(sq[id].x+sq[id].a,-1,LEFT)); if(it!=st.end()){ Event ee=*it; if(ee.side==RIGHT){ sq[id].parent=ee.id; sq[ee.id].child.pb(id); } else{	// ee.side==LEFT tmp_parent[id]=ee.id; // find it later } } st.insert(Event(sq[id].x,id,LEFT)); st.insert(Event(sq[id].x+sq[id].a,id,RIGHT)); } else{	// e.side==BOTTOM st.erase(Event(sq[id].x,id,LEFT)); st.erase(Event(sq[id].x+sq[id].a,id,RIGHT)); } }   rep(i,n) if(~tmp_parent[i]) determineParent(i);   int g=0; rep(i,n)if(sq[i].parent==-1){	// for each root g^=calcGrundyNumber(i); } // rep(i,n)printf("%d parent: %d\n",i,sq[i].parent); // rep(i,n)printf("%d grundy: %d\n",i,calcGrundyNumber(i)); if(g==0)	puts("Fit"); else{ int ans=INF; rep(i,n)if(sq[i].parent==-1){ ans=min(ans,findSuitableSquare(i,g^calcGrundyNumber(i))); } printf("Fat %d\n",ans+1); } }   return 0; }
#include<iostream> #include<algorithm> using namespace std;  long comp(long m,long n,long k,long *T,long *P) {      long  low=0,high=1000000005,mid;      long long res;      long  time=1000000005;      long *cnt=new long [m];      while(low<high)      {                     res=0;                     mid=(low+high)/2;                                          for(long i=0;i<m;i++)                     if(T[i]<=mid)                     cnt[i]=(mid-T[i])/P[i]+1;                     else                     cnt[i]=0;                     /*printf("%d %d:\n",low,high);                     printf("%d: ",mid);                     for(int i=0;i<m;i++)                     printf("%d ",cnt[i]);                     printf("\n");*/                     sort(cnt,cnt+m);                                          for(long j=0;j<m && j<n;j++)                     res+=cnt[m-1-j];                            //              printf("%d %d %d %d %d %d\n",time,res,k,mid,low,high);                                          if(res>=k && time>=mid)                     time=mid;                                          if(res<k)                     low=mid+1;                     else                     high=mid;                           }      return time;       }                                            int main() { //    freopen("in.txt","r",stdin); //    freopen("out.txt","w",stdout);     long t,m,n;     long k;     long T[10005],P[10005];     scanf("%ld",&t);     while(t--)     {               scanf("%ld%ld%ld",&m,&n,&k);               for(long i=0;i<m;i++)               scanf("%ld",&T[i]);               for(long i=0;i<m;i++)               scanf("%ld",&P[i]);               long res=comp(m,n,k,T,P);               printf("%ld\n",res);     }     return 0; } 
//https://www.codechef.com/problems/SSTORY #include<iostream> #include<cstdio> #include<map> using namespace std; #define MAXLEN 500000  struct state{ //	map<char,int> next;//transition edges for the this state 	int next[26]; 	int length;			//length of longest string in this equivilence class 	int suffix_link;	//suffix link of this state };  int total=1; int last=0; state automata[2*MAXLEN];  void initializeAutomata(){ /*     for(int i=0;i<total;i++)         automata[i].next.clear(); 		*/     automata[0].length=0;     automata[0].suffix_link=-1;     total=1;     last=0; }   void extendAutomata(char c){ 	int cur=total++;  	//update lenght of cur : len(cur) = len(last) + 1   	automata[cur].length=automata[last].length+1;  	int p; 	//Follow suffix link until p==-1 or state with transition as char c is encounterd 	for(p=last;p!=-1 && !automata[p].next[c-'a'];p=automata[p].suffix_link) 		automata[p].next[c-'a']=cur; 	if(p==-1) 		automata[cur].suffix_link=0; 	else{ 		int q=automata[p].next[c-'a']; 		if(automata[q].length==automata[p].length+1) 			automata[cur].suffix_link=q; 		else{ 			int clone=total++; 			automata[clone].length=automata[p].length+1; 			//automata[clone].next=automata[q].next; 			copy(automata[q].next,automata[q].next+26,automata[clone].next);	 			automata[clone].suffix_link=automata[q].suffix_link;  			for(;p!=-1 && automata[p].next[c-'a']==q;p=automata[p].suffix_link) 				automata[p].next[c-'a']=clone; 			automata[q].suffix_link=automata[cur].suffix_link=clone; 		} 	} 	last=cur;  }   void lcs(string str1,string str2){ 	initializeAutomata(); 	for(int i=0;i<str1.length();i++) 		extendAutomata(str1[i]);  	int l=0,v=0,best=0,bestpos=0;  	for(int i=0;str2[i]!='\0';i++){ 		for(;v && !automata[v].next[str2[i]-'a']; v=automata[v].suffix_link,l=automata[v].length); 		 		if(automata[v].next[str2[i]-'a']){ 			v=automata[v].next[str2[i]-'a']; 			l++; 		}  		if(l>best) 			best=l,bestpos=i; 	}  	if(best){ 		cout<<str2.substr(bestpos-best+1,best)<<endl; 		cout<<best<<endl; 	} 	else 		cout<<best<<endl;  }   	  		  int main(){ 	 	string str1,str2; 	cin>>str1>>str2;  	lcs(str1,str2); 	return 0; } 
#include <iostream> #include <vector> #include <queue>  using namespace std;  #define vi vector<int> #define vvi vector<vi>   int main(){ 	 	int t; scanf("%d",&t); 	while(t--){ 	int n; scanf("%d",&n); 	vvi men(n, vi(n)), women(n, vi(n));  	int idx,x; 	for(int i=0;i<n;i++){ 		scanf("%d",&idx); 		for(int j=0;j<n;j++){ 			scanf("%d",&women[idx-1][j]);women[idx-1][j]--; 		} 	}  	for(int i=0;i<n;i++){ 		scanf("%d",&idx); 		for(int j=0;j<n;j++){ 			scanf("%d",&x);men[idx-1][x-1]=j+1; 		} 	}  	vi match(n, -1); 	queue<int> free; 	for(int i=0;i<n;i++) free.push(i); 	 	while(!free.empty()){ 		int w = free.front(); 		free.pop(); 		for(int i=0;i<n;i++){ 				int m = women[w][i]; 				if (match[m] == -1){ 					match[m] = w; 					break; 				} 				else if (men[m][match[m]] > men[m][w]){ 					free.push(match[m]); 					match[m] = w; 					break; 				} 			} 	} 		for(int i=0;i<n;i++) cout << i + 1<< " " << match[i] + 1<< endl; 	}  	return 0; }
#include <bits/stdc++.h> #define mp make_pair #define maxn 100001  using namespace std; typedef pair<int,int> II;  int n, x[2*maxn], m; II a[maxn]; int f[maxn], bit[2*maxn];  void update(int u,int val) {     while (u<=m) {         bit[u]=max(bit[u],val);         u+=u&(-u);     } }  int get(int u) {     int kq=bit[u];     while (u) {         kq=max(kq,bit[u]);         u&=(u-1);     }     return kq; }  int main() {     #ifndef ONLINE_JUDGE     freopen("inp.txt","r",stdin);     freopen("out.txt","w",stdout);     #endif // ONLINE_JUDGE     scanf("%d",&n);     for(int i=1;i<=n;i++) {         int u, v; scanf("%d%d",&u,&v);         a[i]=mp(u+v,u);     }     for(int i=1;i<=n;i++) x[2*i-1]=a[i].first, x[2*i]=a[i].second;     sort(x+1,x+2*n+1);     m=unique(x+1,x+2*n+1)-x-1;     for(int i=1;i<=n;i++) {         a[i].first=lower_bound(x+1,x+m+1,a[i].first)-x;         a[i].second=lower_bound(x+1,x+m+1,a[i].second)-x;     }     sort(a+1,a+n+1);     for(int i=1;i<=n;i++) {         f[i]=get(a[i].second-1)+1;         update(a[i].first,f[i]);     }     int ans=f[1];     for(int i=1;i<=n;i++) ans=max(ans,f[i]);     printf("%d",ans); } 
#include <iostream> #include <stdio.h> #include <vector> #include <utility> #include <string.h>  using namespace std;  const int maxn = 1e5 + 7;  vector<pair<int,int> > v[maxn];  int n,t,foo,bar,wt,L,R,mid; int X[55]; int Y[55];  void dfs2(int node,int par,int dep,int cnt) { 	Y[dep]=max(Y[dep],cnt); 	if(dep==R) return; 	for(int i=0;i<v[node].size();i++) 	{ 		int tp = v[node][i].first; 		int tw = v[node][i].second; 		if(tp == par) continue; 		dfs2(tp,node,dep+1,cnt+(tw<=mid?1:0)); 	} }  bool dfs(int node,int par=-1) { 	for(size_t i=0;i<v[node].size();i++) 	{ 		int tp = v[node][i].first; 		if(tp==par) continue; 		if(dfs(tp,node)) return true; 	} 	memset(X,255,sizeof(X)); 	for(size_t i=0;i<v[node].size();i++) 	{ 		int tp = v[node][i].first; 		int tw = v[node][i].second; 		if(par == tp) continue; 		memset(Y,255,sizeof(Y)); 		dfs2(tp,node,1,(tw<=mid)?1:0); 		for(int i=L;i<=R;i++) if(2*Y[i]>i) return true; 		for(int i=1;i<R;i++) 		{ 			if(X[i]==-1) continue; 			for(int j=max(1,L-i);j<=R-i;j++) 				if(Y[j]!=-1 and 2*(X[i]+Y[j])>(i+j)) 					return true; 		} 		for(int i=1;i<R;i++) X[i]=max(X[i],Y[i]); 	} 	return false; }  int main() { 	#ifndef ONLINE_JUDGE 		freopen("I.in","r",stdin); 	#endif 	 	cin>>t; 	while(t--) 	{ 		scanf("%d%d%d",&n,&L,&R); 		for(int i=0;i<	n;i++) v[i].clear(); 		for(int i=1;i<n;i++) 		{ 			scanf("%d%d%d",&foo,&bar,&wt); 			foo--,bar--; 			v[foo].push_back(make_pair(bar,wt)); 			v[bar].push_back(make_pair(foo,wt)); 		} 		int low=0,high=1e9+1; 		while((high-low)>1) 		{ 			mid = (high+low)>>1; 			if(dfs(0)) high=mid; 			else low = mid; 		} 		if(high==(1e9+1)) puts("-1"); 		else printf("%d\n",high); 	} 	return 0; }
#include<bits/stdtr1c++.h>  using namespace std;   typedef long long LL;  const LL mod=(1e9 + 7); LL POW(LL b,LL p) { 	LL ret=1; 	for(int i=0;i<p;i++) 	{ 		ret*=b; 		ret%=mod; 	} 	return ret; }  LL conv(string s) { 	LL ret=0; 	reverse(s.begin(),s.end()); 	for(int i=0;i<s.size();i++) 	{ 		if(s[i]=='B') 			ret|=(1ll<<i); 	} 	return ret; }   int n,m; LL a,b; int dp[19*20*(1<<19)]; LL solve(int ind,int last,int mask) { 	if(ind==n) 		return 0; 	LL state=ind*(20ll*(1ll<<19))+ last*(1ll<<19)+ mask; 	if(dp[state]!=-1) 		return dp[state]; 	LL ret=0;  	ret=(24ll*solve(ind+1,ind+1,0)%mod)%mod; 	for(int i=0;i<2;i++) 	{ 		int h=last;  		int t=mask; 		t<<=1; 		t%=(1<<(m)); 		t|=i; 		int k=0; 		if(t>=a && t<=b && (ind+1-last)==m){ 			ret+=POW(26,n-ind-1); 			ret%=mod; 			continue; 		} 		if((ind+1-last)==m) 			h++; 		ret+=solve(ind+1,h,t)%mod; 		ret%=mod; 	} 	return dp[state]=ret; } int main() {     #ifndef ONLINE_JUDGE         freopen("2.in","r",stdin); 		//freopen("2.out","w",stdout);     #endif // ONLINE_JUDGE          ios::sync_with_stdio(false);     cin.tie(NULL);     cout.tie(NULL);      int tc;     cin>> tc;      string s;     while(tc--)     {     	cin>>n>>m>>s;     	a=0,b=0;     	a=conv(s);     	cin>>s;     	b=conv(s);      	LL ret=POW(26,n);     	memset(dp,-1,sizeof dp);     	cout<<((ret-solve(0,0,0))%mod+mod)%mod<<endl;     }     return 0;      } 
#include"iostream" #include"stdio.h" #include"cstring" using namespace std; char Q[100001]; char NM[15]; int n; char* prev(int &dig) {     int i=14;     while(NM[i]--=='0')NM[i--]='9';     return NM+15-dig; } char* next(int& dig) {     int i=14;     while(NM[i]++=='9')NM[i--]='0';     dig = max(dig, 15-i);     return NM+15-dig; } bool solve2(int offset, int len) { // is concatenation of two consecutive integers     if(len>9)        return strncmp(Q+offset, "1000000000", n-offset)==0 and strncmp(Q, "999999999", offset)==0;     if(Q[offset]=='0') return false; // leading zeros     memset(NM, '0', 15);     memcpy(NM+15-offset, Q, offset);     int overlap = n-len, dig = offset;     return (strncmp(Q+n-overlap, next(dig)+dig-offset, overlap)==0); } bool solve(int offset, const int len) {     if(offset+len>n)         return solve2(offset, len);     long long num=0;     int digits=len;     if(Q[offset]=='0') return false; // leading '0'     memset(NM, '0', 15);     memcpy(NM+15-digits, Q+offset, digits);     for(int i=offset; i<offset+digits; i++)         num = num * 10 + Q[i] - '0';     //check the part before offset     if(strncmp(Q, prev(digits)+digits-offset, offset)!=0) return false;     for(;offset<n;offset+=digits, num++) {         char* strnum = next(digits);         if(num>1000000000 or strncmp(Q+offset, strnum, min(digits, n-offset))!=0) return false;     }     cerr << " offset "<<offset<< " len = "<<len;     return true; } bool trivial() { // consists of only one number     if(n<=9) return true;     if(strcmp(Q, "1000000000")==0) return true;     return false; } int main() {     int T;     scanf("%d", &T);     while(T--) {         scanf("%s", Q);         n = strlen(Q);         int len_upper = 9 + (n<100?1:0);         bool solved = trivial();         for(int offset=0; solved==0 and offset<len_upper; offset++)             for(int len = offset+1; solved==0 and len<=len_upper; len++)                 solved = solve(offset, len);         printf("%s\n", solved?"YES":"NO");     } }
#include <cstdio> #include <cstring> #include <cstdlib> #include <stack> #include <iostream> #include <algorithm> using namespace std;  typedef long long LL; const int MAX_N = 1000 + 10; const LL INF = 1000000000000LL;  int N, K; int a[MAX_N]; LL f[MAX_N], g[MAX_N]; stack<pair<int, LL> > st;  void inputData() { 	scanf("%d%d", &N, &K); 	for(int i = 1; i <= N; ++ i) 		scanf("%d", &a[i]); 	sort(a + 1, a + N + 1); }  double get(pair<int, LL> u, pair<int, LL> v) { 	return ((double)u.second - (double)v.second) / ((double)v.first - (double)u.first); }  void insert(pair<int, LL> u1) { 	pair<int, LL> u2, u3; 	for( ; st.size() > 1; ) { 		u2 = st.top(); st.pop(); 		u3 = st.top(); 		if (get(u1, u2) >= get(u2, u3))  			break; 	} 	st.push(u2); 	st.push(u1); }  void erase(int x) { 	pair<int, LL> u1, u2; 	for( ; st.size() > 1; ) { 		u1 = st.top(); st.pop(); 		u2 = st.top(); 		if (x > get(u1, u2)) 			break; 	} 	st.push(u1); }  LL calc(int u, pair<int, LL> v) { 	return v.second + v.first * a[u] - u * a[u]; }  void deal() { 	for( ; ! st.empty(); st.pop()); 	for(int i = N; i >= 1; -- i) { 		insert(make_pair(i + 1, f[i + 1])); 		erase(a[i]); 		g[i] = calc(i, st.top()); 	} 	for(int i = 1; i <= N; ++ i) 		f[i] = g[i]; }  void calcAns() { 	for(int i = 1; i <= N; ++ i) 		f[i] = INF; 	f[N + 1] = 0; 	for(int cur = 0; cur < K; ++ cur) { 		deal(); 		f[N + 1] = INF; 	} 	LL ret = INF; 	for(int i = 1; i <= N; ++ i) 		ret = min(ret, f[i]); 	cout << ret << endl; }  void solve() { 	inputData(); 	calcAns(); }  int main() { 	int T; for(scanf("%d", &T); T --; ) 		solve(); 	return 0; }
#include <vector> #include <iostream> using namespace std; long long int t[1000000]; int pl,pr; long long int ans=0,count=0; void merge(int l ,  int r,vector<long long int> &a) {	 	pl=l; 	pr=(l+r)/2+1; 	count=0; 	for(int i = l;i<=r;i++) 	{ 		if(pl>(l+r)/2){ 			t[i]=a[pr]; 			pr++; 			ans+=count; 		} 		else if(pr>r){ 			t[i]=a[pl]; 			pl++; 			count++; 		} 		else if(a[pl]<=a[pr]){ 			t[i]=a[pl]; 			pl++; 			count++; 		} 		else { 			t[i]=a[pr]; 			pr++; 			ans+=count; 		}  	} 	for(int i =l;i<=r;i++) 	{ 		a[i]=t[i]; 	} }  void merge_sort(int l,int r,vector<long long int> &a) { 	if(l==r){ 		if(a[l]>=0)ans++; 		return ; 	} 	merge_sort(l,(l+r)/2,a); 	merge_sort((l+r)/2 + 1 , r,a); 	merge(l,r,a); }  int main() { 	int n,temp; 	ios::sync_with_stdio(false); 	cin>>n; 	long long int k,temp2; 	vector<long long int> a(n); 	cin>>k; 	temp=n; 	while(temp--){ 		cin>>temp2; 		a[n-temp-1]=temp2-k; 	} 	long long int sumtem=0; 	for(int i = 0;i<n;i++){ 		sumtem+=a[i]; 		a[i]=sumtem; 	} 	merge_sort(0,n-1,a); 	cout<<ans;  }
 #include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; LL psum[100010] , a[100010]; char S[100010]; stack< pair<char , int > > stk; LL dp[100010] , ans; int prv[100010]; pair<char , int > temp; char x; int main() { int N , test; si(test); while(test--) { while(!stk.empty()) 	stk.pop(); ans = 0; si(N); ss(S); // printf("$%s$\n", S); ans = 0; for(int i=0;i<N;i++) { 	dp[i] = 0; 	prv[i] = -1; 	slli(a[i]); } psum[0] = a[0]; for(int i=1;i<N;i++) 	psum[i]=psum[i-1] + a[i]; for(int i=0;i<N;i++) { 	if(stk.empty()){ 		stk.push(mp(S[i] , i)); 	} 	 //{ [,],{,},<,>,(,) }∗  	else 	{ 		temp = stk.top(); 		if(temp.first == '[' && S[i] == ']') 		{ 			prv[i] = temp.second; 			stk.pop();			 		} 		else if(temp.first == '{' && S[i] == '}') 		{ 			prv[i] = temp.second; 			stk.pop();			 		} 		else if(temp.first == '<' && S[i] == '>') 		{ 			prv[i] = temp.second; 			stk.pop();			 		}		 		else if(temp.first == '(' && S[i] == ')') 		{ 			prv[i] = temp.second; 			stk.pop();			 		} 		else 		{ 			stk.push(mp(S[i] , i)); 		} 	} } // for(int i=0;i<N;i++) 	// cout << prv[i] << " "; // cout << endl; for(int i=0;i<N;i++){ 	if(prv[i]!=-1){ 		dp[i] = max<LL >(dp[i] , psum[i] - ((prv[i]>0)?psum[prv[i]-1]:0) + max<LL >(0 , ((prv[i]>0)?dp[prv[i]-1]:0))); 		ans = max<LL >(ans , dp[i]); 	} }   printf("%lld\n", ans); }   return 0; }           
#include<bits/stdc++.h> using namespace std; #define assn(n,a,b) assert(n<=b && n>=a) #define pb push_back #define mp make_pair #define clr(x) x.clear() #define sz(x) ((int)(x).size()) #define F first #define S second #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,b) for(i=0;i<b;i++) #define rep1(i,b) for(i=1;i<=b;i++) #define pdn(n) printf("%d\n",n) #define sl(n) scanf("%lld",&n) #define sd(n) scanf("%d",&n) #define pn printf("\n") typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<int> VI; typedef vector<VI> VVI; typedef long long LL; #define MOD 1000000007 LL mpow(LL a, LL n)  {LL ret=1;LL b=a;while(n) {if(n&1)      ret=(ret*b)%MOD;b=(b*b)%MOD;n>>=1;} return (LL)ret;}   // main code begins here   VI fac[1000009]; int arr[1000009],dp[1000009]={},last[1000009]={}; char str[1000009]; int primes[100009],cnt=0; void pre() {     // calcualting primes     int n=10000;     for(int i=2; i*i<=n; i++)         if(str[i]==0)             for(int j=i; j*i<=n; j++)                 str[i*j]=1;     for(int i=2; i<=n; i++)         if(str[i]==0)primes[cnt]=i,cnt++; } int main() {     pre();     int i,j,k;     // calculating prime factors of each number     for(i=2; i<=1000000; i++)     {         j=i;         for(int k=0; primes[k]*primes[k]<=j; k++)         {             if(j%primes[k]==0)             {                 fac[i].pb(primes[k]);                 while(j%primes[k]==0)j/=primes[k];             }         }         if(j>=2)fac[i].pb(j);     }       int t;     cin >> t;     while(t--)     {         memset(dp,0,sizeof(dp));         memset(last,0,sizeof(last));                  int n,i,j,maxi,ans=-1;         sd(n);         for(i=1; i<=n; i++)             sd(arr[i]);          dp[1]=1;                  vector<int>::iterator it;         for(it=fac[arr[1]].begin(); it!=fac[arr[1]].end(); ++it)             last[*it]=1;         maxi=0;         for(i=2; i<=n; i++)         {             //maxi=i-1-dp[i-1];             for(it=fac[arr[i]].begin(); it!=fac[arr[i]].end(); ++it)             {                 maxi=max(maxi,last[*it]);                 last[*it]=i;             }             dp[i]=i-maxi;             //cout<<dp[i]<<endl;         }                  for(i=1; i<=n; i++)             ans=max(ans,dp[i]);                  if(ans==1)printf("-1\n");         else             printf("%d\n",ans);     }     return 0; }
#include <bits/stdc++.h> #define base 1000000007LL #define ll long long #define X first #define Y second #define mp make_pair #define pb push_back #define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++) #define FORE(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)  using namespace std;  typedef pair<int, int> II; typedef vector<II> vi;  void init(); int bs(int u);  struct abc {     bool operator() (II a, II b)     {         if (a.Y == b.Y) return a.X > b.X;         return a.Y < b.Y;     } } cmp;  int n, q, jump[100010][25]; II a[100010], b[100010];  int main() {     ios::sync_with_stdio(0);     //freopen("inp.txt", "r", stdin);     cin >> n >> q;     FOR(i,1,n) cin >> a[i].X >> a[i].Y;     init();     while (q--) {         int l, r;         cin >> l >> r;         int cs = bs(l);         if (cs > n || b[cs].Y > r) {             cout << 0 << endl;             continue;         }         int res = 1;         FORE(i,20,0)             if (jump[cs][i] <= n && b[jump[cs][i]].Y <= r) {                 res += (1 << i);                 cs = jump[cs][i];             }         cout << res << endl;     }     return 0; }  int bs(int u) {     int dau, cuoi, mid;     dau = 1; cuoi = n;     while (dau <= cuoi) {         mid = (dau + cuoi) >> 1;         if (b[mid].X >= u) cuoi = mid-1;         else dau = mid+1;     }     return dau; }  void init() {     sort(a+1, a+n+1, cmp);     int m = 1;     b[m] = a[1];     FOR(i,2,n)         if (b[m].X < a[i].X && b[m].Y < a[i].Y) b[++m] = a[i];     n = m;      FOR(i,1,n) jump[i][0] = bs(b[i].Y+1);     FOR(i,0,20) jump[n+1][i] = n+1;     FOR(j,1,20)         FOR(i,1,n) jump[i][j] = jump[jump[i][j-1]][j-1]; } 
#include <iostream> #include<stdio.h> using namespace std; int a[100005]; struct tre {     int s;     int m;     int e;     int sz; }T[4*100005]; void build(int node,int i,int j) {     if(i==j)     {         T[node].s=1;         T[node].e=1;         T[node].m=1;         T[node].sz=1;         return;     }     int mid=(i+j)/2,lt=node*2,rt=node*2+1;     build(lt,i,mid);     build(rt,mid+1,j);     T[node].s=T[lt].s;     T[node].e=T[rt].e;     T[node].sz=T[lt].sz+T[rt].sz;     T[node].m=max(T[lt].m,T[rt].m);     if(a[mid]+1==a[mid+1])     {T[node].m=max(T[node].m,T[lt].e+T[rt].s);     if(T[lt].s==T[lt].sz)     T[node].s=T[rt].s+T[lt].sz;     if(T[rt].e==T[rt].sz)     T[node].e=T[lt].e+T[rt].sz;     } } void update(int node,int i,int j,int idx,int val) {     if(i==j)     {        T[node].s=1;         T[node].e=1;         T[node].m=1;         T[node].sz=1;         return;     }     int mid=(i+j)/2,lt=node*2,rt=lt+1;     if(mid>=idx)     update(node*2,i,mid,idx,val);     else     update(node*2+1,mid+1,j,idx,val);     T[node].s=T[lt].s;     T[node].e=T[rt].e;     T[node].sz=T[lt].sz+T[rt].sz;     T[node].m=max(T[lt].m,T[rt].m);     if(a[mid]+1==a[mid+1])     {T[node].m=max(T[node].m,T[lt].e+T[rt].s);     if(T[lt].s==T[lt].sz)     T[node].s=T[lt].sz+T[rt].s;     if(T[rt].e==T[rt].sz)     T[node].e=T[rt].sz+T[lt].e;     } } int main() {     //freopen("inp.txt","r",stdin);     //freopen("out1.txt","w",stdout);     int i,n,m,x,y;     cin>>n>>m;     for(i=0;i<n;i++)     cin>>a[i];     build(1,0,n-1);     //for(i=1;i<=2*n;i++)     //cout<<T[i].s[2]<<" "<<T[i].m[2]<<" "<<T[i].e[2]<<endl;     cout<<max(max(T[1].s,T[1].m),T[1].e)<<endl;     //for(i=0;i<n;i++)     //cout<<i<<" "<<a[i]<<endl;     while(m--)     {        cin>>x>>y;        a[x-1]=y;        update(1,0,n-1,x-1,y);     //for(i=1;i<=2*n;i++)     //cout<<T[i].s<<" "<<T[i].m<<" "<<T[i].e<<endl;        cout<<max(max(T[1].s,T[1].m),T[1].e)<<endl;     }     return 0; } 
/**  * March 2013 Long Challenge at Codechef  *  * Problem:     SUBTREE - Festivals  * Author:      Anton Lunyov (Tester)  * Complexity:  O(N * log N + sum(Ki) * log N)  * Timing:      0.24 out of 1.00  */ #include <cstdio> #include <vector> using namespace std;  typedef vector<int> VI;  const int maxN = 100000; const int maxH = 17; // 2^maxH > maxN const int maxC = 10000; // the maximal length of the edge  int LOG2[maxN]; // LOG2[n] is the maximal h such that 2^h <= n // representation of tree // for each edge (u,v,c) we have (v,c) in a[u], and (u,c) in a[v] vector<pair<int, int> > a[maxN+1]; int d[maxN+1]; // d[u] is the depth of the vertex int dist[maxN+1]; // dist[u] is the distance between root and u int in[maxN+1]; // in[u] is the time when dfs enters to u int in_time; // the time counter for enters to dfs int out[maxN+1]; // out[u] is the time when dfs exits from u int out_time; // the time counter for exits from dfs  // p[u][h] is such ancestor v of u for which d[u]-d[v]=2^h // p[u][h] = 0 if such v does not exist, i.e., if d[u] < 2^h // p[u][0] is the direct parent of u int p[maxN+1][maxH]; // minc[u][h] is the length of the shortest edge on the path from u to p[u][h] int minc[maxN+1][maxH];  void dfs(int u) { 	in[u] = ++in_time; // set enter time for u and increase counter 	// loop over adjacent vertexes 	for (int i = 0; i < a[u].size(); ++i) { 		int v = a[u][i].first; // the adjacent vertex 		if (v == p[u][0]) { 			// skip v if it direct parent of u 			continue; 		} 		p[v][0] = u; // otherwise set u as a direct 		int c = a[u][i].second; // the length of the edge (u,v) 		minc[v][0] = c; 		d[v] = d[u] + 1; // depth of v is one more than for u 		dist[v] = dist[u] + c; 		dfs(v); // run dfs for v 	} 	out[u] = ++out_time; // set exit time for u and increase counter }  // checks where u is ancestor of v bool is_ancestor(int u, int v) { 	// the O(1) condition for this, check any graph theory textbook for proof 	return in[u] <= in[v] && out[u] >= out[v]; }  // returns ancestor v of u such that d[u]-d[v]=k int ancestor(int u, int k) { 	// for this we represent k in binary as 	// k = 2^h1 + 2^h2 + ... + 2^hs 	// and change u to p[u][h] for each h=hi 	// since p[u][h] exactly 2^h vertexes up from u 	for (int h = 0; (1 << h) <= k; ++h) { 		if (k & 1 << h) { 			u = p[u][h]; 		} 	} 	return u; }  // returns the least common ancestor of u and v int LCA(int u,int v) { 	// check whether one of u and v is ancestor of another 	if (is_ancestor(u, v)) { 		return u; 	} 	if (is_ancestor(v, u)) { 		return v; 	} 	// make u to be more deep vertex 	if (d[u] < d[v]) { 		swap(u, v); 	} 	// replace u by its ancestor to make d[u]=d[v] 	// for this we need to lift u up by d[u]-d[v] vertexes 	u = ancestor(u, d[u] - d[v]);  	// standard technique to find LCA by some kind of binary search 	for (int h = LOG2[d[u]]; h >= 0; --h) { 		if (p[u][h] != p[v][h]) { 			u = p[u][h]; 			v = p[v][h]; 		} 		else if(p[v][h]!=0 && 0==is_ancestor(p[v][h],v)) 			u=p[u][h]; 	} 	return p[u][0]; }  // return LCA of a and b /* int LCA(int a,int b) { 	if(is_ancestor(a,b)) 		return a; 	else if(is_ancestor(b,a)) 		return b; 	else 	{ 		for(int h=LOG2[d[a]];h>=0;h--) 		{ 			if(!is_ancestor(p[a][h],b)) 				a=p[a][h]; 		} 		return p[a][0]; 	} } */  // return the length of the path between u and v int get_dist(int u, int v) { 	// the path is u-w-v, where w is LCA of u and v 	// u-w part has length d[u]-d[w] 	// v-w part has length d[v]-d[w] 	int w = LCA(u, v); 	return dist[u] + dist[v] - 2 * dist[w]; }  // return the length of the minimum edge // on the path from u to v, when v is ancestor of u int get_min_easy(int u, int v) { 	// when u=v there no edges between so min = INF 	if (u == v) { 		return maxC + 1; 	} 	// otherwise we find the vertex w on the path u-v 	// such that d[w]-d[v] = 2^h and d[u]-d[w]<=2^h 	// then minimum on u-v is minimum between u-p[u][h] and w-v 	int x = d[u] - d[v]; 	int h = LOG2[x]; 	int w = ancestor(u, x - (1 << h)); 	return min(minc[u][h], minc[w][h]); }  // return the length of the minimum edge - general case int get_min(int u,int v) { 	// we divide the path as u-w-v where w is LCA u and v 	// so that w is ancestor of u and v and we can use get_min_easy 	int w = LCA(u, v); 	return min(get_min_easy(u, w), get_min_easy(v, w)); }  // returns the furthest distance from u to any vertex of U // and save the distance to mx int getFurthest(int u, const VI &U, int &mx) { 	int res = u; 	mx = -1; 	for (int i = 0; i < U.size(); ++i) { 		int d = get_dist(u, U[i]); 		if (mx < d)  { 			mx = d; 			res = U[i]; 		} 	} 	return res; }  // return LCA of all vertexes in U int LCA(const VI &U) { 	int lca = U[0]; 	for (int i = 1; i < U.size(); ++i) { 		lca = LCA(lca, U[i]); 	} 	return lca; }  // check whether u is ancestor of some vertex in U bool is_ancestor(int u, const vector<int> &U) { 	for (int i = 0; i < U.size(); ++i) { 		if (is_ancestor(u, U[i])) { 			return true; 		} 	} 	return false; }  // the minimum edge belonging to each path u-U[i] int get_min(int u, const vector<int> &U) { 	int res = maxC + 1; 	for (int h = LOG2[d[u]]; h >= 0; --h) { 		if (!p[u][h] || is_ancestor(p[u][h], U)) { 			continue; 		} 		res = min(res, minc[u][h]); 		u = p[u][h]; 	} 	res = min(res, minc[u][0]); 	return res; }  int main() { 	// precalc of LOG2[n] 	for (int h = 0; (1 << h) < maxN; ++h) { 		for (int n = 1 << h; n < maxN && n < (1 << (h + 1)); ++n) { 			LOG2[n] = h; 		} 	}  	// input tree 	int n; 	scanf("%d" ,&n); 	for (int u = 1; u <= n; ++u) { 		a[u].clear(); 	} 	for (int i = 0; i < n - 1; ++i) { 		int u, v, c; 		scanf("%d%d%d", &u, &v, &c); 		a[u].push_back(make_pair(v, c)); 		a[v].push_back(make_pair(u, c)); 	}  	// dfs to find parent of each vertex, in and out time and so on 	// all global variables are initialized by zeros so no need to initialize them 	dfs(1);  	// binary lifting for parents and minimums 	for (int h = 0; (1 << (h + 1)) < n; ++h) { 		for (int u = 1; u <= n; ++u) { 			int pu = p[u][h]; 			p[u][h + 1] = p[pu][h]; 			minc[u][h + 1] = min(minc[u][h], minc[pu][h]); 		} 	}  	int Q; 	scanf("%d", &Q); 	for (int q = 0; q < Q; ++q) { 		int K; 		scanf("%d", &K); 		VI F(K); 		for (int i = 0; i < K; ++i) { 			scanf("%d", &F[i]); 		} 		int mx; 		int u1 = getFurthest(F[0], F, mx); 		int u2 = getFurthest(u1, F, mx); 		// u1 and u2 are two furthest vertexes among given K 		// and mx is the gistance between them 		printf("%d ", mx);  		// U1 is the set of vertexes in F for which dist to u2 is mx 		// U2 is the set of vertexes in F for which dist to u1 is mx 		// u1 will belong to U1, u2 will belong to U2 		bool noB = false; 		VI U1, U2; 		for (int i = 0; i < K; ++i) { 			int cnt = 0; 			if (get_dist(u1, F[i]) == mx) { 				U2.push_back(F[i]); 				++cnt; 			} 			if (get_dist(u2, F[i]) == mx) { 				U1.push_back(F[i]); 				++cnt; 			} 			if (cnt == 2) { 				noB = true; 			} 		} 		// if for some vertex Fi dist to both u1 and u2 = mx 		// there is no common edge at ideal paths 		if (noB) { 			printf("-1\n"); 			continue; 		}  		// otherwise we find lca of all U1 and also of all U2 		int lca1 = LCA(U1); 		int lca2 = LCA(U2); 		// and do some analysis 		int min_edge; 		// if one of lca1, lca2 is ancestor of another 		// then we apply get_min for vertex and list 		if (is_ancestor(lca1, lca2)) { 			min_edge = get_min(lca2, U1); 		} else if (is_ancestor(lca2, lca1)) { 			min_edge = get_min(lca1, U2); 		} else { 			// in this case the path lca1 - lca2 is the intersection of all ideal path 			min_edge = get_min(lca1, lca2); 		} 		printf("%d\n", min_edge); 	} 	return 0; }
    #include<stdio.h>           using namespace std;           typedef long long ll;           ll n,m;     ll pow10[120];     int a[1001];     int c[1001];           void pre()     {     int x,y,z;     a[0] = c[0] =0;     for(int i=1;i<1000;i++)     {     x = i;     x = x/10;y = x%10;     x = x/10;z = x;     x = i%10;           if(y>z && y>x) a[i] = 1;     if(y<z && y<x) a[i] = 1;     c[i] = c[i-1]+a[i];     //if(i<100) printf("%d - %d\n",i,c[i]);     }     //printf("%d\n",c[999]);     }           ll solve(ll an)     {     if(an<100)     {     return 0;     }     else if(an<1000)     {     return c[an]-c[100];     }           int dig[19],ptr=0;     ll suf[19];     suf[0] =0;     while(an)     {     dig[ptr] = an%10;     an=an/10;     ptr++;     suf[ptr] = suf[ptr-1] + (ll)dig[ptr-1]*pow10[ptr-1];     }     ll sol=0;     ll till=0;     //printf("ptr-%d\n",ptr);     for(int i=ptr-1;i>=2;i--)     {     int v,k = i;     v = dig[k]*100 + dig[k-1]*10 + dig[k-2];     if(true)     {     if(till)     {     sol+= (ll)(till-1)*570*pow10[k-2];     sol+= (ll)(570 - c[100])*pow10[k-2];     }           if(v)     {     if(till) sol+= c[v - 1]*pow10[k-2];     else sol+=(c[v-1]-c[100])>0?(c[v-1]-c[100])*pow10[k-2]:0;     }           sol += a[v]*(suf[i-2]+1);     }     till = till*10 + dig[i];     }     return sol;     }           ll count()     {     ll sol1,sol2;     sol1 = solve(m);     sol2 = solve(n-1);     //printf("two sols %lld %lld\n",sol2,sol1);     sol1 = sol1- sol2;     return sol1;     }           int main()     {     int cases;     pow10[0]=1;     for(int i=1;i<16;i++)     {     pow10[i]=10*pow10[i-1];     }     pre();     scanf("%d",&cases);     while(cases--)     {     scanf("%lld%lld",&n,&m);     ll res = count();     printf("%lld\n",res);     }     } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <algorithm> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <cstdlib> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cassert> #include <climits> //#include <ext/hash_map>   using namespace std; using namespace __gnu_cxx;    #define REP(i,n) for(int i = 0; i < int(n); ++i) #define REPV(i, n) for (int i = (n) - 1; (int)i >= 0; --i) #define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)  #define FE(i,t) for (__typeof((t).begin())i=(t).begin();i!=(t).end();++i) #define FEV(i,t) for (__typeof((t).rbegin())i=(t).rbegin();i!=(t).rend();++i)  #define two(x) (1LL << (x)) #define ALL(a) (a).begin(), (a).end()   #define pb push_back #define ST first #define ND second #define MP(x,y) make_pair(x, y)  typedef long long ll; typedef unsigned long long ull; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<string> vs;  template<class T> void checkmin(T &a, T b){if (b<a)a=b;} template<class T> void checkmax(T &a, T b){if (b>a)a=b;} template<class T> void out(T t[], int n){REP(i, n)cout<<t[i]<<" "; cout<<endl;} template<class T> void out(vector<T> t, int n=-1){for (int i=0; i<(n==-1?t.size():n); ++i) cout<<t[i]<<" "; cout<<endl;} inline int count_bit(int n){return (n==0)?0:1+count_bit(n&(n-1));} inline int low_bit(int n){return (n^n-1)&n;} inline int ctz(int n){return (n==0?-1:ctz(n>>1)+1);} int toInt(string s){int a; istringstream(s)>>a; return a;} string toStr(int a){ostringstream os; os<<a; return os.str();}  const int mod=1e9+7; const int maxk=22; const int maxm=1e6+10;  int k; int next[maxm]; int cnt[maxm]; int ifact[maxk]; int tx[maxm];  int dp[maxk]; int nx; int res[maxk]; int tmp[maxk], tmp2[maxk]; int dp2[maxk][maxk];  int faste(int a, int p){int x=1; for (; p; p>>=1, a=1ll*a*a%mod) if (p&1) x=1ll*x*a%mod; return x;}  int cnk(int n, int k){     int res=1;     REP(i,k) res=1ll*res*(n-i)%mod;     return 1ll*res*ifact[k]%mod; }  void go(int st=0){     if (st==0){         memset(dp,0,sizeof(dp));         dp[0]=1;     }     for (int i=st; i<nx; ++i) for (int j=k-1; j>=0; --j) dp[j+1]=(dp[j+1]+1ll*tx[i]*dp[j])%mod;     memcpy(res,dp,sizeof(res)); }  int go2(int a, int b){     if (!b) return !a;     int &r=dp2[a][b];     if (r!=-1) return r;     int u=0;     FOR(i,1,a+1) u=(u+1ll*go2(a-i,b-1)*res[i])%mod;     return r=u; }  int main(){     int tn; cin>>tn;     ifact[0]=1;     FOR(i,1,maxk) ifact[i]=1ll*ifact[i-1]*faste(i,mod-2)%mod;      REP(ti,tn){         int n,a,b,c,m;         cin>>n>>k>>a>>b>>c>>m;         memset(cnt,0,sizeof(cnt));         cnt[a]=1;         nx=0;         tx[nx++]=a;         int x=0, oa=a;         while(--n){             ++x;             next[a]=(1ll*a*b+c)%m;             a=next[a];             if (cnt[a]) break;             tx[nx++]=a;             ++cnt[a];         }         if (a==oa){             nx=0;             go();             n+=x;         }else go();          int ans=0;          if (n){             int oa=a;             int nc=0;             tx[nc++]=a;             while(next[a]!=oa) tx[nc++]=a=next[a];              nx=n%nc;             memcpy(tmp,res,sizeof(res));             go();             memset(tmp2,0,sizeof(tmp2));             REP(i,k+1) REP(j,k-i+1) tmp2[i+j]=(tmp2[i+j]+1ll*res[i]*tmp[j])%mod;              int u=n/nc;             nx=nc;             go(n%nc);              ans=0;             memset(dp2,-1,sizeof(dp2));             REP(i,k+1) REP(j,min(u,k)+1) ans=(ans+1ll*tmp2[k-i]*cnk(u,j)%mod*go2(i,j))%mod;         }else ans=res[k];          cout<<ans<<endl;     }     return 0; }  
#define ll long long #define vi vector <int> #define pii pair <int,int> #define FOR(i, a, b) for (int i = (a); i <= (b); i++) #define REP(i, a) for (int i = 0; i < (a); i++) #define ALL(v) (v).begin(), (v).end() #define SET(a, x) memset((a), (x), sizeof(a)) #define SZ(a) ((int)(a).size()) #define CL(a) ((a).clear()) #define SORT(x) sort(ALL(x)) #define mp make_pair #define pb push_back #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b))  #define filer() freopen("in.txt","r",stdin) #define filew() freopen("out.txt","w",stdout)  #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <cassert> #include <queue>   #define NN 100005 using namespace std;  #define EPS 1e-10 typedef pair<ll,ll> Poll;  double pi = acos(-1.); double mytan(ll dx,ll dy){ 	if(!dy){ 		if(dx > 0)	return 0; 		else		return pi; 	} 	if(!dx){ 		if(dy > 0)	return pi/2.; 		else		return 3.*pi/2.; 	} 	double at = atan2(1.*dy,1.*dx); 	if(at < 0)	at+=2*pi; 	return at; }  ll n; Poll p[4444]; ll m; double a[4444];  int main(){     // filer();  	ll T=0; 	ll i,j,k,l,s; 	ll tot;      scanf("%lld",&n);  	{  		for(i=0;i<n;++i) 			scanf("%lld%lld",&p[i].first,&p[i].second);  		tot = 0; 		ll c,tot2=0; 		for(i=0;i<n;++i){ 			m = 0; 			for(j=0;j<n;++j)if(i!=j) 				a[m++] = mytan(p[j].first - p[i].first,p[j].second-p[i].second); 			sort(a,a+m);  			for(j=0;j<m;++j) 				a[j+m] = a[j]+2*pi;  			j=0; 			k=0; 			l=k; 			s=0;  			while(j<m){  				while(s<j+m && fabs(a[s]-a[j])<EPS)s++;  				tot2+=(s-j-1);  				while(k<j+m && a[k]-a[j] < pi/2.-EPS)++k; 			//	if(k==j+m)	break;    				while(l<j+m && ((a[l]-a[j]) < pi) && fabs((a[l]-a[j])-pi)>EPS   )++l;  			//	assert(fabs((a[l]-a[j])-pi)>EPS);  			//	if(k==j+m)	break; 				if(l>k)	tot += l-k; 				++j;  			}  		}  		assert(tot2%2==0);  		printf("%lld\n",n*(n-1)*(n-2)/6 - tot-tot2/2 ); 	} 	return 0; } 
#include <cmath> #include <climits> #include <queue> #include <vector> #include <map> #include <cstdlib> #include <fstream> #include <iomanip>    #include <iostream>   #include <sstream>  // istringstream buffer(myString); #include <stack> #include <algorithm> #include <cstring> #include <cassert> #include <bits/stdc++.h> using namespace std; #define bit(x,i) (x&(1<<i))  //select the bit of position i of x #define lowbit(x) ((x)&((x)^((x)-1))) //get the lowest bit of x #define hBit(msb,n) asm("bsrl %1,%0" : "=r"(msb) : "r"(n)) //get the highest bit of x, maybe the fastest #define max(a,b) (a<b?b:a) #define abs(x) (x<0?(-x):x) // big bug here if "-x" is not surrounded by "()" #define IN(i,l,r) (l<i&&i<r) //the next for are for checking bound #define LINR(i,l,r) (l<=i&&i<=r) #define LIN(i,l,r) (l<=i&&i<r) #define INR(i,l,r) (l<i&&i<=r) #define F(i,L,R) for (int i = L; i < R; i++) //next four are for "for loops" #define FE(i,L,R) for (int i = L; i <= R; i++) #define FF(i,L,R) for (int i = L; i > R; i--) #define FFE(i,L,R) for (int i = L; i >= R; i--) #define getI(a) scanf("%d", &a) //next three are handy ways to get ints, it's also force you to use '&' sign #define getII(a,b) scanf("%d%d", &a, &b) #define getIII(a,b,c) scanf("%d%d%d", &a, &b, &c) #define wez(n) int (n); scanf("%d",&(n)); //handy if the input is right after the definition of a variable #define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m)) #define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k)) #define TESTS wez(testow)while(testow--) //for multilple cases problems #define whileZ int T; getI(T); while(T--) // the same as above #define getS(x) scanf("%s", x) //get a char* string #define clr(a,x) memset(a,x,sizeof(a)) //set elements of array to some value #define char2Int(c) (c-'0') #define lastEle(vec) vec[vec.size()-1]  #define SZ(x) ((int)((x).size())) #define REMAX(a,b) (a)=max((a),(b)) // set a to the maximum of a and b #define REMIN(a,b) (a)=min((a),(b)); #define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) // traverse an STL data structure #define ALL(c) (c).begin(),(c).end() //handy for function like "sort()" #define PRESENT(c,x) ((c).find(x) != (c).end())  #define CPRESENT(c,x) (find(ALL(c),x) != (c).end())  #define ll long long //data types used often, but you don't want to type them time by time #define ull unsigned long long #define ui unsigned int #define us unsigned short #define IOS ios_base::sync_with_stdio(0); //to synchronize the input of cin and scanf #define INF 1001001001 #define PI 3.1415926535897932384626 //for map, pair #define mp make_pair #define fi first #define se second // for debug inline void pisz(int n) { printf("%d\n",n); } #define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl; #define printA(a,L,R) FE(i,L,R) cout << a[i] << (i==R?'\n':' ') #define printV(a) printA(a,0,a.size()-1) #define MAXN 10000 //for vectors #define pb push_back typedef int elem_t; typedef vector<int> vi;  typedef vector<vi> vvi;  typedef pair<int,int> ii;  // directions const int fx[4][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}}; const int fxx[8][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}}; template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream& operator<<(ostream &s,vector<T> t){F(i,0,SZ(t))s<<t[i]<<" ";return s; }  vector<bool> s(300005); int a[300005],n; int solve(int d) { 	if (d==-1) return 0; 	int ret=0,c=0; 	for (int i=0 ; i < n ; i++) { 		if (!s[i]) { 			if(a[i]&(1<<d)) 				c++; 		} 	} 	//printf("%d\n",c); 	if(c>=2) { 		ret |= (1<<d); 		for (int i=0 ; i < n ; i++) { 			if (!(a[i]&(1<<d))) 				s[i]=true; 		} 	} 	return ret+solve(d-1); }  int main () { 	int i,j,k; 	scanf("%d",&n); 	F(i,0,n) { 		scanf("%d",a+i); 		s[i]=false; 	} 	printf("%d\n",solve(30)); 	return 0; }
#include <iostream> #include <vector> #include <cstdio> #include <iomanip> #include <cstring> #include <set> #include <map> #include <algorithm> #include <cassert>  using namespace std;  typedef long long int LL; typedef pair<int,int> pii; typedef double D;  #define rep(i, a, b) for(int i = a; i < b; ++i) #define sd(x) scanf("%d", &x)  #define PB push_back #define MP make_pair #define F first #define S second  #define N 1123  int a[N][N]; int r[N][N]; int s[N][N];  int main(){ 	int t; 	sd(t); 	while(t--){ 		int n, m; 		sd(n); sd(m); 		rep(i, 1, n + 1){ 			rep(j, 1, m + 1){ 				sd(a[i][j]); 				r[i][j] = 0; 				s[i][j] = 0; 			} 		} 		int ans = 0; 		rep(j, 1, m + 1){ 			for(int i = n; i >= 1; --i){ 				//cout<<i<<" "<<j<<" "<<s[i][j]<<" "<<r[i][j]<<" "<<a[i][j]<<endl; 				int c = max(0, max(r[i][j], a[i][j]) - s[i][j]); 				if(i == 1){ 					ans += c; 				} 				r[i - 1][j] += c; 				s[i][j + 1] += c + s[i][j] - r[i][j]; 			} 		} 		cout<<ans<<endl; 	} 	return 0; } 
#include <iostream> #include <string> #include <string.h> #include <math.h> #include <time.h> #include <stdio.h> #include <utility> #include <algorithm> #include <set> #include <queue> #include <stack> #include <vector> #include <map> #include <list>   #define FORST(X,S,T) for(int X=S; X<=T; X++)   #define RFORST(X,S,T) for(int X=S; X>=T; X--)   #define FOR(X,XB) for(int X=0; X<XB; X++) #define RFOR(X,XB) for(int X=(XB)-1; X>=0; X--) #define FORSTL(X,C) for(X=C.begin();X!=C.end();X++) #define SQR(X) ((X)*(X)) #define MID(X,Y) (((X)+(Y))/2) #define FILL(X,V) memset(X,V,sizeof(X)) #define FILE_R(X) freopen(X, "r", stdin)   #define FILE_W(X) freopen(X, "w", stdout)   #define ERREQ(X,Y) (fabs((X)-(Y))<EPS) #define DBGL cout << "here" << endl; #define MIN(X,Y) ((X)<(Y)?(X):(Y)) #define MAX(X,Y) ((X)>(Y)?(X):(Y)) #define INITLISTS {L=0; FILL(adj,-1);} #define SZ(X) sizeof(X) const double PI = acos(-1.0); const double EPS = 1E-9; const int INF = (int)1E9; using namespace std;   #define MAXN 50005 #define MAXM 400005   int N, M, S, T, B;   struct bus{ 	int u,v,s,e; 	bool operator < (const bus &ano) const{ 		return e < ano.e; 	} } buses[MAXM];     vector<int> reach[MAXN];   bool solve(int w){ 	FORST(i, 1, N) reach[i].clear(); 	reach[1].push_back(0); 	FOR(i, M){ 		const bus &b = buses[i]; 		vector<int> &vec = reach[b.u]; 		int j = upper_bound(vec.begin(), vec.end(), b.s)-vec.begin()-1; 		if(j>=0 && b.s-vec[j]<=w) reach[b.v].push_back(b.e); 	} 	if(reach[N].size() && reach[N][0]<=B) return 1; 	return 0; }   int main(){ 	scanf("%d%d%d", &N, &B, &M); 	FOR(i, M){ 		int u,v,s,e; 		scanf("%d%d%d%d", &u, &v, &s, &e); 		buses[i].u = u; buses[i].v = v; buses[i].s = s; buses[i].e = e; 	} 	sort(buses, buses+M); 	int l=0, r=B+1; 	while(l<=r){ 		int m = (l+r)/2; 		if(solve(m)){ 			r = m-1; 		}else{ 			l = m+1; 		} 	}   	if(r==B+1) printf("-1\n"); 	else printf("%d\n", l);   	return 0; } 
#include <algorithm> #include <iostream> #include <sstream> #include <string> #include <vector> #include <queue> #include <stack> #include <cassert> #include <set> #include <map> #include <list> #include <bitset> #include <deque> #include <numeric> #include <iterator> #include <cstdio> #include <cstdlib> #include <cstring> #include <cctype> #include <cmath> #include <climits>   using namespace std;   #define SZ(a) int(a.size()) vector<long long> manachers(const vector<long long> &A) { 	vector<long long> S; 	for(int i = 0; i < SZ(A); ++i) 	{ 		S.push_back(2000000000); 		S.push_back(A[i]); 	} 	S.push_back(2000000000); 	vector<long long> P(S.size()); 	long long ma = 0; 	P[0] = 0; 	for(int i = 1; i < SZ(P) ; ++i) 	{ 		if( P[ma]+ma >= i) 			P[i] = min( P[2*ma-i] , 2*ma-i-(ma-P[ma])); 		long long lo = i - P[i]-1, hi = i + P[i]+1; 		while(lo >= 0 && hi < SZ(P) && S[lo]==S[hi]) 			P[i]++, lo--, hi++; 		if( P[ma]+ma < P[i]+i ) 			ma = i; 	} 	return P; }   int main()  { 	int TC; 	scanf("%d",&TC); 	while(TC-->0) 	{ 		int N = rand()%10+1; 		scanf("%d",&N); 		vector<long long> A(N); 		vector<long long> B(N); 		vector<long long> ACU(N); 		for (int i = 0; i < N; ++i) { 			char c[2]; 			scanf("%s%lld",c,&B[i]); //			cin >> c >> B[i]; //			B[i] = rand()%10+1; //			do //			{ //				c[0] = rand()%26 + 'A'; //			}while(i>0 && A[i-1] == c[0]); 			A[i] = c[0]; //			cout << char(A[i]) << " " << B[i] << endl; 			if(i>0)ACU[i] = ACU[i-1] + B[i]; 			else ACU[i] = B[i]; 		} //		string OR; //		for (int i = 0; i < N; ++i) { //			OR += string(B[i],A[i]); //		} //		cout << OR << endl; 		vector<long long> PA = manachers(A); 		vector<long long> PB = manachers(B); 		vector<long long> PC(PA.size()); 		for (int i = 0; i < PB.size(); ++i) { 			PC[i] = min(PA[i],PB[i]); //			cout << PA[i] << " " << PB[i] << " " << ((i&1) ? char(A[i/2]) : '#')<< endl; 		} 		 		long long tot = 0; 		for (int i = 1; i < PC.size()-1; ++i) { 			if(i&1) 			{ 				long long b = (B[i/2] * (B[i/2]+1))/2 - (B[i/2]+1)/2; //				cout << b << endl; 				long long lo = i/2 - PC[i]/2 , hi = i/2 + PC[i]/2; 				long long t = ACU[hi]; 				if(lo > 0)t -= ACU[lo-1]; 				 				if(lo > 0 && hi < N-1) 				{ 					if( A[lo-1] == A[hi+1] ) 						t += 2*min(B[lo-1],B[hi+1]); 				} //				cout << (t) << endl; 				long long p = tot; 				tot += (t+1)/2 + b; 				 				if(tot < p) 					assert(false); 			} 		} 		cout << tot << endl; //		int cnt = 0; //		for(int i = 0; i < OR.size(); ++i) //			for(int j = i; j < OR.size(); ++j) //			{ //				int ok = 1; //				for(int k = 0; k <= (j-i); ++k) //					if(OR[i+k]!=OR[j-k]) //						ok = 0; //				cnt += ok; //			} //		cout << cnt << endl; //		if(cnt != tot) //		{ //			cout << "ERROR" << endl; //			cout << OR << endl; //		} //		printf("%lld\n",tot); 	} 	 	 }   /* 7 E 5 K 4 F 1 K 4 E 2 C 6 H 10     EEEEEKKKKFKKKKEECCCCCCHHHHHHHHHH   */ 
#include<bits/stdc++.h> #include <iostream> #include<algorithm> #include<cstdio> using namespace std;  const int MAXN = 100000; int n, x, y; int a[MAXN], b[MAXN];  void Init() {   assert(scanf("%d%d%d", &n, &x, &y) == 3);   for (int i = 0; i < n; ++i)    (scanf("%d", a + i) == 1);   for (int i = 0; i < n; ++i)     (scanf("%d", b + i) == 1); } int dp[100005]; vector<pair <int,int> > v; void Work() {   int sum = 0;   v.clear();   memset(dp,0,sizeof(dp));   for (int i = 0; i < n; ++i)   v.push_back(make_pair(abs(a[i]-b[i]),i));     sort(v.begin(),v.end(),greater< pair <int,int> >());      for (int i = 0; i <n; ++i) {          int t=v[i].second;     	if(a[t]>b[t])     	{ 	    	if(x) 	    	{ 	    		sum+=a[t]; 	    		x--; 	    	} 	    	else 	    	{ 	    		sum+=b[t]; 	    		y--; 	    	} 	    } 	    else 	    { 	    	if(y) 	    	{ 	    		sum+=b[t]; 	    		y--; 	    	} 	    	else 	    	{ 	    		sum+=a[t]; 	    		x--; 	    	} 	    }   }     printf("%d\n", sum); }  int main() {   int cases = 1;   while (cases--) {     Init();     Work();   }   return 0; }
#include<cstdio> #include<vector> #include<cstring> #include<iostream>  using namespace std;  struct Query {     public:     char t, c;     int pos;      Query(char _t, int _pos, char _c) {         t = _t; pos = _pos; c = _c;     } };  vector<Query> v;  const int mx = 300005; char s[mx], ans[mx]; int bit[mx], len;  int read(int x) {     ++x;     int ans = 0;      while(x > 0) {         ans += bit[x];         x -= (x & -x);     }      return ans; }  void update(int x, int v) {     ++x;     while(x < mx) {         bit[x] += v;         x += (x & -x);     } }  int get(int p) {     int lo = 0, hi = len - 1;     while(lo < hi) {         int m = (lo + hi) / 2;         if(read(m) >= p) hi = m;         else lo = m + 1;     }      return lo; }  int main() {     int q;     scanf("%d", &q);     while(q--) {         char t;         int p, n;         scanf(" %c %d", &t, &p);         if(t == '+') {             scanf("%s", s);             n = strlen(s);             for(int i = n - 1; i >= 0; --i) v.push_back(Query(t, p + 1, s[i]));             len += n;         } else {             scanf("%d", &n);             for(int i = 0; i < n; ++i) v.push_back(Query(t, p + i, ' '));             v.push_back(Query(t, -1, '\n'));         }     }     for(int i = 0; i < len; ++i) update(i, 1);      for(int i = (int)v.size() - 1; i >= 0; --i) {         //cerr << i << " " << v[i].t << " " << v[i].pos << " " << v[i].c << endl;         if(v[i].pos == -1) continue;         int x = get(v[i].pos);         //cerr << x << endl;         if(v[i].t == '+') {             ans[x] = v[i].c;             update(x, -1);         } else {             v[i].pos = get(v[i].pos);         }     }      for(int i = 0; i < (int)v.size(); ++i) {         if(v[i].pos == -1) putchar('\n');         else if(v[i].t == '?') putchar(ans[v[i].pos]);     }      return 0; } 
#include<bits/stdc++.h> #define ll long long #define mp make_pair #define pb push_back #define pi pair<int,int> using namespace std; int dp[2013][2013]; void solve(){     for(int i=1;i<2013;i++){         int mark[2013];         int cnt = 0;         memset(mark,0,sizeof(mark));         for(int j=1;j<=i;j++){             mark[dp[i-j][j]]=1;             while(mark[cnt]) cnt++;             dp[i][j] = cnt;         }         for(int j=i+1;j<2013;j++) dp[i][j] = dp[i][i];     } } int main() {     solve();     int t;     scanf("%d",&t);     while(t--){         int n,k;         scanf("%d%d",&n,&k);         int ans = 0;         for(int i=0;i<n;i++){             int x;scanf("%d",&x);             ans = ans ^ dp[x][min(k,x)];         }         if(ans==0) printf("Zeta\n");         else printf("Nancy\n");     }     return 0; }
#include<bits/stdc++.h> using namespace std; #define ll long long int vector<ll>v[200001]; ll par[200001][20]; ll depth[200001]; ll logmax=18; void dfs(ll cur,ll pa,ll dep) {     par[cur][0]=pa;     depth[cur]=dep;     for(ll i=0;i<v[cur].size();i++)     {         if(v[cur][i]!=pa)         {             dfs(v[cur][i],cur,dep+1);         }     } } ll lca(ll x,ll y) {     if(depth[x]>depth[y])swap(x,y);     for(ll i=18;i>=0;i--)     {         if(depth[y]-depth[x]>=(1<<i))         {             y=par[y][i];         }     }     if(x==y)return x;     for(ll i=18;i>=0;i--)     {         if(par[x][i]!=par[y][i])         {             x=par[x][i];             y=par[y][i];         }     }     return par[y][0]; } int main() {     ll n;     cin>>n;     for(ll i=0;i<n-1;i++)     {         ll x,y;         cin>>x>>y;         v[x].push_back(y);         v[y].push_back(x);     }     memset(par,-1,sizeof(par));     dfs(1,0,0);     for(ll i=1;i<=logmax;i++)     {         for(ll j=1;j<=n;j++)         {             if(par[j][i-1]!=-1)             {                 par[j][i]=par[par[j][i-1]][i-1];             }         }     }     ll q;     cin>>q;     while(q--)     {         ll x,y;ll r;         cin>>r>>x>>y;         ll lc=lca(x,y);         //cout<<lc<<endl;         //cout<<lca(x,y)<<" "<<lca(r,x)<<" "<<lca(r,y)<<endl;         if(lca(lc,r)!=lc)cout<<lc<<endl;         else         {   //cout<<"here\n";             ll rx=lca(r,x);             ll ry=lca(r,y);             if(rx==x and ry==y)             {                 if(depth[x]>depth[y])cout<<x<<endl;                 else                 cout<<y<<endl;             }            else if(rx==r or ry==r)             cout<<r<<endl;             else if(rx==lc)cout<<ry<<endl;             else cout<<rx<<endl;         }     } }  
#include <cstdio> #include <iostream> #define MOD 1000000007 using namespace std; long long int exp(long long int m, long long int r) {         long long int temp = 1;         while (r) {               if (r % 2 == 0) {                     m = (m % MOD) * (m % MOD) % MOD;                     r /= 2;                 } else {                     temp = (temp % MOD) * (m % MOD);                     temp = temp % MOD;                     r--;                 }         }          return temp;     } int main() {     int t;     long long int m, r, ans ,temp;     scanf("%d", &t);     while (t--) {         scanf("%lld%lld", &m, &r);         temp = 1;         temp = exp(m, r);         temp--;         ans = (temp % MOD) * (exp(m - 1, MOD - 2) % MOD);         ans = (ans - r) % MOD;         printf("%lld\n", ans);         }     return 0;     } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define mod 1000000007 ll power(ll a,ll b) { 	ll ans=1; 	while(b) 	{ 		if(b&1) 		ans=(ans*a)%mod; 		a=(a*a)%mod; 		b/=2; 	} 	return ans; } ll dp[100005]; set<int> s; int main() {   int i,j,k,n,m,p,t;     ll x,y,z,temp; 	cin>>t; 	while(t--) 	{ 		s.clear(); 		cin>>n>>k>>p; 		for(i=0;i<k;i++) 		{ 			cin>>x>>y; 			s.insert(x); 		} 		int flag=0; 		for(i=0;i<p;i++) 		{ 			cin>>x>>y; 			if(s.find(x)==s.end()) 			flag=1; 		} 		if(flag) 		cout<<"No\n"; 		else 		cout<<"Yes\n"; 		 	}  }
#include<stdio.h> #include<iostream> #include<string.h> #include<queue> #include<algorithm> #include<string> #include<map> #include<set> #include<sstream> #include<cmath> using namespace std; #define ll long long #define ull unsigned long long #define inf 1001001001 #define mod 1000000007 //const ll inf = 1000000000005LL; #define pii pair<int,int> #define vi vector<int> #define all(x) x.begin(),x.end() #define mp make_pair #define pb push_back #define x first #define y second #define N 400010  template<typename T,typename TT>  ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T>  ostream& operator<<(ostream &s,vector<T> t){for(int i=0;i<t.size();i++)s<<t[i]<<" ";return s;} #define DBG(vari) cerr<<#vari<<"="<<(vari)<<endl; #define FOREACH(i,t) for(typeof(t.begin()) i=t.begin();i!=t.end();i++)  int sa[N],rank[N],g[N],b[N],h,lcp[N],l[N],r[N],cnt1[N],cnt2[N],n;ll ans[N]; inline bool cmp(int i,int j) { 	if(i==j||g[i]!=g[j])return g[i]<g[j]; 	return g[i+h]<g[j+h]; } void init(char *s) { 	n=strlen(s); 	int i,k; 	for(i=0;i<=n;i++)sa[i]=i,g[i]=s[i]; 	g[n]=-1,b[0]=b[n]=0; 	sort(sa,sa+n+1,cmp); 	for(h=1;b[n]!=n;h<<=1) 	{ 		sort(sa,sa+n+1,cmp); 		for(i=0;i<n;i++)b[i+1]=b[i]+cmp(sa[i],sa[i+1]); 		for(i=0;i<=n;i++)g[sa[i]]=b[i]; 	} 	//for(i=0;i<n;i++)sa[i]=sa[i+1]; 	for(i=1;i<=n;i++)rank[sa[i]]=i; 	k=0; 	for(i=0;i<n;i++) 	{ 		if(k>0)k--; 		if(rank[i]==1){lcp[1]=0,k=0;continue;} 		int j=sa[rank[i]-1]; 		while(s[i+k]==s[j+k])k++; 		lcp[rank[i]]=k; 	} } char s[N],s1[N]; vi p[N]; int main() { 	int T,m,i,j,k; 	scanf("%d",&T); 	while(T--) 	{ 		int L; 		scanf("%s%s%d",s,s1,&L); 		m=strlen(s); 		strcat(s,"#"); 		strcat(s,s1); 		init(s); 		for(i=1;i<=n;i++)p[i].clear(); 		for(i=1;i<=n;i++) 		if(lcp[i])p[lcp[i]].pb(i); 		for(i=1;i<=n;i++) 		{ 			cnt1[i]=sa[i]<m;cnt2[i]=sa[i]>m; 			l[i]=i-1,r[i]=i+1; 		} 		ll sum=0; 		int w; 		for(i=n;i;i--) 		{ 			for(j=0;j<p[i].size();j++) 			{ 				w=p[i][j]; 				sum+=(ll)cnt1[l[w]]*cnt2[w];sum+=(ll)cnt2[l[w]]*cnt1[w]; 				cnt1[l[w]]+=cnt1[w];cnt2[l[w]]+=cnt2[w]; 				l[r[w]]=l[w];r[l[w]]=r[w]; 			} 			ans[i]=sum; 		} 		for(i=1;i<=L;i++) 		printf("%lld ",ans[i]); 		puts(""); 	} }
#include <iostream> #include <cstdio> #include <vector> #include <cstring> #define ll long long using namespace std;   #define maxn 100005 #define logN 20   vector<pair<int,int> > adj[maxn]; int f[maxn][logN], depth[maxn], n,m,a,b,c;   int BIT[100005]; bool visited[maxn]; int start[maxn]; int end[maxn]; int cost[maxn]; int revr[maxn]; int ft[maxn]; int sd[maxn]; int ct[maxn];   void dfs(int u) {     for (int i = 1; i < logN; i++)         f[u][i] = f[f[u][i - 1]][i - 1];       for (int i = 0; i < (int) adj[u].size(); i++) {         int v = adj[u][i].first;           if (!depth[v]) {             f[v][0] = u;             depth[v] = depth[u] + 1;             dfs(v);         }     } }   int lca (int u, int v) {     if (depth[u] < depth[v]) swap(u, v);       for (int i = logN - 1; i >= 0; i--)         if (depth[f[u][i]] >= depth[v]) {             u = f[u][i];         }       if (u == v) return u;       for (int i = logN - 1; i >= 0; i--)         if (f[u][i] != f[v][i]) {             u = f[u][i];             v = f[v][i];         }       return f[u][0]; }       void update(int x, int val) {       for(; x <= n; x += x&-x)         BIT[x] += val; } int query(ll x) {      int sum = 0;      for(; x > 0; x -= x&-x)         sum += BIT[x];      return sum; }     int cnt=0; void dfsOrder(int u,int parent,int edge){ 	 	cost[u] = cost[parent] + edge;     visited[u]=true;     start[u]=++cnt;         for(int i=0;i<adj[u].size();i++){              if(!visited[adj[u][i].first]){             dfsOrder(adj[u][i].first,u,adj[u][i].second);         }     }     end[u]=cnt;  }   int main() { 	// your code goes here 	 	scanf("%d",&n); 	 	memset(visited,false,sizeof visited); 	 	for(int i=1;i<n;i++){ 		scanf("%d %d %d",&a,&b,&c); 		adj[a].push_back(make_pair(b,c)); 		adj[b].push_back(make_pair(a,c)); 		ft[i] = a; 		sd[i] = b; 		ct[i] = c; 	} 	dfsOrder(1,0,0); 	memset(BIT,0,sizeof BIT); 	for(int i=1;i<=n;i++){ 		revr[start[i]] = i; 	} 	cost[0] = 0; 	depth[1] = 1; 	int temp = 0; 	for(int i=2;i<=n;i++){ 		int tmp = cost[revr[i]]; 		cost[revr[i]]-=temp; 		temp = tmp; 		 	} 	for(int i=1;i<=n;i++){ 		//cout<<i<<" " << start[i]<<" "<<end[i]<<"="<<cost[i]<<endl; 		update(i,cost[revr[i]]); 		 	} 	dfs(1);   	scanf("%d",&m); 	 	while(m--){ 		 		scanf("%d %d %d",&a,&b,&c); 		 		if(a==1){ 			int u1 = ft[b]; 			int u2 = sd[b]; 			int u3 = ct[b]; 			ct[b] = c; 			if(depth[u1]<depth[u2]) 				b = u2; 			else 				b = u1; 			int value = c-u3; 			update(start[b],value); 			value *= -1; 			update(end[b]+1,value);   			 		} else{ 			 			int xx = lca(b,c); 			int ans = query(start[b]) + query(start[c]) - 2*query(start[xx]); 			//cout << query(start[b])<<" "<<query(start[c])<<endl; 			printf("%d\n",ans); 		 		} 		 	} 	 	return 0; }
#include <iostream> #include <cstdio> #include <string> #include <vector> #include <set> #include <map> #include <queue> #include <cmath> #include <algorithm> #include <sstream> #include <stack> #include <cstring> #include <iomanip> using namespace std; #define pb push_back #define INF 1000000000 #define FOR(i,n) for(int (i)=0;(i)<(n);++(i)) #define FORI(i,n) for(int (i)=1;(i)<=(n);++(i)) #define mp make_pair #define pii pair<int,int> #define ll long long #define vi vector<int> #define SZ(x) ((int)(x.size())) #define fi first #define se second #define wez(n) int (n); scanf("%d",&(n)); #define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m)); #define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k)); inline void pisz(int n) { printf("%d\n",n); } template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream& operator<<(ostream &s,vector<T> t){FOR(i,SZ(t))s<<t[i]<<" ";return s; } #define IN(x,y) ((y).find((x))!=(y).end()) #define DBG(vari) cout<<#vari<<" = "<<(vari)<<endl; #define ALL(t) t.begin(),t.end() #define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define TESTS wez(testow)while(testow--) #define REP(i,a,b) for(int (i)=(a);(i)<=(b);++i) #define REPD(i,a,b) for(int (i)=(a); (i)>=(b);--i) #define REMAX(a,b) (a)=max((a),(b)); #define REMIN(a,b) (a)=min((a),(b));  #define ld double ld l,s,r, cache[1<<18]; int n;  /*inline int remove (int mask, int bit) {    return mask & (~(1 << bit)); }*/  ld opt (int mask) {    if (cache[mask] != -1) return cache[mask];    ld mi = INF;     vector<bool> setbits(n,0);    int b = 1;    FOR(i,n) {       if (b & mask) setbits[i] = 1;       //else setbits[i] = 0;       b <<= 1;    }     bool byla1 = 0;    int ind = -1;    FOR(i,n) {       if (i != 0 && setbits[i-1] == 0 && setbits[i] == 0 && i != n-1 && setbits[i+1] == 1 && byla1) {          ind = i;          break;       }       if (setbits[i]) byla1 = 1;    }    if (ind != -1) {       int mask1 = ((1<<(ind-1)) - 1) & mask,       mask2 = ((1<<n) - (1<<ind)) & mask;             //DBG(mask)    DBG(ind)      DBG(mask1)      DBG(mask2)       return cache[mask] = opt(mask1) + opt(mask2);    }     vector<bool> go(n,0);    if (setbits[0]) go[0] = go[1] = 1;    REP(i,1,n-2) if (setbits[i]) go[i-1]=go[i]=go[i+1]=1;    if (setbits[n-1]) go[n-2]=go[n-1]=1;     FOR(i,n) if (go[i]) {       // strzelamy w i-ty cel       ld pudlo = 0, expe = 1;       if (i == 0 || !setbits[i-1]) {          pudlo += l;       } else {          expe += l * opt(mask & (~(1 << (i-1))));       }       if (i == n-1 || !setbits[i+1]) {          pudlo += r;       } else {          expe += r * opt(mask & (~(1 << (i+1))));       }       if (!setbits[i]) {          pudlo += s;       } else {          expe += s * opt(mask & (~(1 << i)));       }       mi = min(mi, expe/(1-pudlo));    }    return cache[mask] = mi; }   int main () {    TESTS {       scanf("%d",&n);       wez3(_l,_s,_r)       l = _l/100.0, r = _r/100.0, s = _s/100.0;       FOR(i,(1<<n)) cache[i] = -1;       cache[0] = 0;       ld ans = ((n==1) ? 1/s : opt((1<<n)-1));       //ld ans = opt((1<<n) - 1);       printf("%.6lf\n",ans);    } } 
#include<iostream> using namespace std;   void compute_prefix(string str,int pi[]){ 	//computes the length of longest prefix that is also a proper suffix of str[0...i]     int m=str.length();     pi[0]=0;     int j=0;     for(int i=1;i<m;i++){         while(j>0 && str[i]!=str[j])             j=pi[j-1];         if(str[i]==str[j])             j=j+1;         pi[i]=j;     } }  void kmp(string text,string pattern){     int n=text.length();     int m=pattern.length(); 	int maxlen=0; 	int shift=0; //Preprocessing     int pi[m];     compute_prefix(pattern,pi); //Matching     int j=0;     for(int i=0;i<n;i++){         while(j>0 && text[i]!=pattern[j])             j=pi[j-1];         if(text[i]==pattern[j]){             j++; 			if(j>maxlen){ 				maxlen=j; 				shift=i-j+1; 			} 		}     } 	cout<<shift<<endl; }   int main(){ 	int n; 	string a,b; 	cin>>n>>a>>b; 	b=b+b; 	kmp(b,a); 	return 0; } 
#include <bits/stdc++.h>  using namespace std; #define ff first #define ss second #define pb push_back #define mp make_pair typedef unsigned long long ull; typedef long long int lli; typedef unsigned int ui; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double ld; #define var(a,b)  __typeof(b) a = b #define rep(i,n)  for(int i = 0; (i) < (n); ++i) #define rept(i,a,b) for(var(i,a); i < (b); ++i) #define tr(v,it)  for(var(it,v.begin());it!=v.end();++it) #define fill(a,val) memset(a,val,sizeof(a)) #define all(v) v.begin(),v.end()  #define get getchar_unlocked  //fast input template<class T> inline T scan_int() {int ip=get(),flag=1;T ret=0;for(;ip<'0'||ip>'9';ip=get())if(ip=='-'){flag=-1;ip=get();break;}for(;ip>='0'&&ip<='9';ip=get())ret=(ret<<3)+(ret<<1)+ip-'0';return flag*ret;} #define scan_d() scan_int<int>() #define scan_ld() scan_int<long int>() #define scan_lld() scan_int<long long int>() template <class T> inline T scan_decimal(){char c;c = get();T flag=1.0;long long int t = 0;for(;c<'0'||c>'9';c=get())if(c=='-'){flag=-1.0;c=get();break;}while(c<='9' && c>='0'){t=(t<<3)+(t<<1)+c-'0';c = get();}long long int d=0,i=1;if(c=='.'){c = get();while(c<='9' && c>='0'){i=(i<<3)+(i<<1);d=(d<<3)+(d<<1)+c-'0';c = get();}}return ((T)t + ((T)d)/i)*flag;} #define scan_f() scan_decimal<float>() #define scan_lf() scan_decimal<double>() inline void scan_str(char *str){register char c = 0;register int i = 0;while (c < 33)c = get();while (c != '\n' && c != EOF){str[i] = c;c = get();i = i + 1;}str[i] = '\0';} //end of fast input  //fast output #define put putchar_unlocked char output_buffer[21]; template <class T> inline void print_int(T n) {if(n<0){n=-n;put('-');}int i=21;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{put(output_buffer[i]);}while(++i<21);} #define print_d print_int<int> #define print_ld print_int<long int> #define print_lld print_int<long long int> template <class T> inline void println_int(T n) {print_int(n);put('\n');} #define println_d println_int<int> #define println_ld println_int<long int> #define println_lld println_int<long long int> template <class T> inline void printsp_int(T n,char ch) {print_int(n);put(ch);} #define printsp_d printsp_int<int> #define printsp_ld printsp_int<long int> #define printsp_lld printsp_int<long long int> inline void print_str(char *str){char* temp=str;while((*temp)!='\0'){put(*temp);temp++;}} inline void println_str(char *str){print_str(str); put('\n');} //end of fast output  #define N 200009  char str[N]; //input lli rank1[N], sa[N]; //output lli cnt[N], next1[N]; //internal bool bh[N], b2h[N];  // Compares two suffixes according to their first characters bool smaller_first_char(lli a, lli b){ 	return str[a] < str[b]; }  void suffixSort(lli n){   //sort suffixes according to their first characters 	for (lli i=0; i<n; ++i){ 		sa[i] = i; 	} 	sort(sa, sa + n, smaller_first_char);   //{sa contains the list of suffixes sorted by their first character}  	for (lli i=0; i<n; ++i){ 		bh[i] = i == 0 || str[sa[i]] != str[sa[i-1]]; 		b2h[i] = false; 	}  	for (lli h = 1; h < n; h <<= 1){     //{bh[i] == false if the first h characters of sa[i-1] == the first h characters of sa[i]} 		lli buckets = 0; 		for (lli i=0, j; i < n; i = j){ 			j = i + 1; 			while (j < n && !bh[j]) j++; 			next1[i] = j; 			buckets++; 		}     	if (buckets == n) break; // We are done! Lucky bastards!     //{suffixes are separted in buckets containing strings starting with the same h characters}  	    for (lli i = 0; i < n; i = next1[i]){ 	    	cnt[i] = 0; 	    	for (lli j = i; j < next1[i]; ++j){ 	    		rank1[sa[j]] = i; 	    	} 	    }  	    cnt[rank1[n - h]]++; 	    b2h[rank1[n - h]] = true; 	    for (lli i = 0; i < n; i = next1[i]){ 	    	for (lli j = i; j < next1[i]; ++j){ 	    		lli s = sa[j] - h; 	    		if (s >= 0){ 	    			lli head = rank1[s]; 	    			rank1[s] = head + cnt[head]++; 	    			b2h[rank1[s]] = true; 	    		} 	    	} 	    	for (lli j = i; j < next1[i]; ++j){ 	    		lli s = sa[j] - h; 	    		if (s >= 0 && b2h[rank1[s]]){ 	    			for (lli k = rank1[s]+1; !bh[k] && b2h[k]; k++) b2h[k] = false; 	    		} 	    	} 		} 		for (lli i=0; i<n; ++i){ 			sa[rank1[i]] = i; 			bh[i] |= b2h[i]; 		} 	} 	for (lli i=0; i<n; ++i){ 		rank1[sa[i]] = i; 	} } // End of suffix array algorithm   // Begin of the O(n) longest common prefix algorithm // Refer to "Linear-Time Longest-Common-Prefix Computation in Suffix // Arrays and Its Applications" by Toru Kasai, Gunho Lee, Hiroki // Arimura, Setsuo Arikawa, and Kunsoo Park. lli lcp[N]; // lcp[i] = length of the longest common prefix of suffix sa[i] and suffix sa[i-1] // lcp[0] = 0 void getHeight(lli n){ 	for (lli i=0; i<n; ++i) rank1[sa[i]] = i; 		lcp[0] = 0; 	for (lli i=0, h=0; i<n; ++i){ 		if (rank1[i] > 0){ 			lli j = sa[rank1[i]-1]; 			while (i + h < n && j + h < n && str[i+h] == str[j+h]) h++; 			lcp[rank1[i]] = h; 			if (h > 0) h--; 		} 	} } // End of longest common prefixes algorithm // char s1[N], s2[N];  // int main() { // #ifdef LOCAL // 	freopen("/home/pramesh/Desktop/codes/in", "r", stdin); // #endif  // 	// scan_str(s1); // 	// scan_str(s2);  // 	lli n1, n2, n3; // 	lli val1 = 0, val2 = 0, valunion = 0;  // 	scanf("%s%s", s1, s2);  // 	n1 = strlen(s1); // 	n2 = strlen(s2);  // 	rep(i, n2) str[i] = s2[i];  // 	suffixSort(n2); // 	getHeight(n2);  // 	rep(i, n2) val2 += (n2 - sa[i] - lcp[i]);  // 	rep(i, n1) str[i] = s1[i];  // 	suffixSort(n1); // 	getHeight(n1);  // 	rep(i, n1) val1 += (n1 - sa[i] - lcp[i]);  // 	str[n1] = '$'; // 	rep(i, n2) str[n1 + 1 + i] = s2[i];  // 	n3 = n1 + n2 + 1;  // 	suffixSort(n3); // 	getHeight(n3);  // 	rep(i, n3) valunion += (n3 - sa[i] - lcp[i]);  // 	valunion -= ((n1 + 1) * (n2 + 1)); 	 // 	lli ans = (valunion<<1) - (val1 + val2);  // 	println_d(ans);  // 	return 0; // }  char c[N], s[N];  long long substr_count(int n,char S[]) { 	 int i; 	 rep(i, n) str[i] = S[i]; 	 suffixSort(n); 	 getHeight(n); 	 long long res; 	 res=1LL*n*(n+1)/2; 	 for(i=0;i<n;i++) res-=lcp[i]; 	 return res; }   int main()  { #ifdef LOCAL 	freopen("/home/pramesh/Desktop/codes/in", "r", stdin); #endif     scanf("%s",s);     long long ans1 = substr_count(strlen(s),s);     //cout << ans1 << endl;     int n = strlen(s)+1; 	scanf("%s",c); 	long long ans2 = substr_count(strlen(c),c); 	//cout << ans2 << endl; 	int m = strlen(c)+1; 	char temp[]={'a'-1,'\0'}; 	strcat(s,temp); 	strcat(s,c); 	long long ans3 = substr_count(strlen(s),s)-(long long)n*(long long)m; 	long long ans = 2*ans3-ans1-ans2; 	printf("%lld\n",ans); 	return 0; } 
/*    Nimesh Ghelani (nims11)    */ #include<iostream> #include<cstdio> #include<cmath> #include<algorithm> #include<map> #include<string> #include<vector> #include<queue> #include<cstring> #include<cstdlib> #include<cassert> #include<cmath> #include<stack> #include<set> #include<utility> #define in_T int t;for(scanf("%d",&t);t--;) #define in_I(a) scanf("%d",&a) #define in_F(a) scanf("%lf",&a) #define in_L(a) scanf("%lld",&a) #define in_S(a) scanf("%s",a) #define newline printf("\n") #define MAX(a,b) a>b?a:b #define MIN(a,b) a<b?a:b #define SWAP(a,b) {int tmp=a;a=b;b=tmp;} #define P_I(a) printf("%d",a)  using namespace std; int cnt = 0; char str[100010], str2[100010]; int mod = 1000000007; int POW(long long r, long long n) {     int ans = 1;     while(n>0)     {         if(n&1)             ans = (ans*r)%mod;         n >>= 1;         r = (r*r)%mod;     }     return ans; } long long pre[100010][2]; int getans(){     int l = strlen(str2);     int l2 = strlen(str);     long long res = 0;     int m = l2-l+1;     for(int i = 0;str2[i];i++){         int lt = i+(l2-l);         int req = !(str2[i]-'0');         long long foo = (pre[lt+1][req]-pre[i][req]+mod)%mod;         long long bar= POW(100001, (l2-m)-i);         bar = POW(bar, mod-2);         foo = (foo*bar)%mod;         res = (res + foo)%mod;     }     return res; } int main() {     in_S(str);     int l = strlen(str);     for(int i = 0;str[i];i++){         int x = str[i]-'0';         pre[i+1][x] = POW(100001, l-i-1);         pre[i+1][0] = (pre[i+1][0]+pre[i][0])%mod;         pre[i+1][1] = (pre[i+1][1]+pre[i][1])%mod;     }     int Q;     in_I(Q);     while(Q--){         in_S(str2);         printf("%d\n", getans());     } } 
#include<iostream> #include<cassert> #include<algorithm> #include<map>  using namespace std;  #define ll long long  int a[200001],n,k;   ll rec(int l,int r) {        if(r<=l)        return 0;                int m = (l+r)/2,i,id=l;                for(i=l;i<=r;i++)        {             if(a[id] > a[i])             id = i;             else if(a[id] == a[i] && abs(id-m) > abs(i-m))             {               id = i;             }        }                m = id;                ll cnt = rec(l,m-1) + rec(m+1,r);        int sum = 0;                map <int,int> mp;                for(i=m-1;i>=l;i--)        {            if(a[i]<a[m])            break;                        sum = sum+a[i];                       if(sum>=k)            sum %= k;                                  if(!sum)            cnt++;                        mp[sum]++;        }                sum = 0;                for(i=m+1;i<=r;i++)        {           if(a[i]<a[m])           break;                      sum = sum+a[i];                      if(sum>=k)           sum %= k;                      if(!sum)           cnt++;                      int x = k-sum;                      if(x>=k)           x-=k;                      cnt += mp[x];        }                return cnt; }  int main() {     int i;          scanf("%d%d",&n,&k);          assert(n<=200000);          for(i=0;i<n;i++)     {        scanf("%d",&a[i]);     }          printf("%lld\n",rec(0,n-1));     return 0; } 
#include<iostream> #include<stack> using namespace std; int t; string s; int a[26]; int cnt,l; char b[16]; bool ch[26]; bool bk,tmp;  inline bool fC(bool x,bool y) {      return x&y;  } inline bool fD(bool x,bool y) {        return x|y; } inline bool fI(bool x,bool y) {        if((x && y) || !x)        return true;        return false; } inline bool fE(bool x,bool y) {        if((x && y) || (!x && !y))        return true;        return false; } inline bool fN(bool x) {        return !x; } inline bool checknot(stack<char> &st) {               // char x;        if(st.top()=='Z')        {               st.pop();               if(st.empty())               {st.push('Z');return false;}                if(st.top()=='N')                {st.push('Z');return true;}                 st.push('Z');           }        return false; } inline bool checkoth(stack<char> &st) {       if(st.top()=='Z')       {                        st.pop();                         if(st.empty())               {st.push('Z');return false;}                        if(st.top()=='Z')                        {                           st.push('Z');                          return true;                                        }                        st.push('Z');       }             return false; } bool calc() {      stack<char> st1;      stack<bool> st2;      bool x,x1,x2,h;      bool not1,other;    //  x=false;      for(int i=0;i<l;i++)      {            // cout<<i<<endl;              if(s[i]-'a'>=0 && s[i]-'z'<=0)              {                      //cout<<i<<endl;                       // if(st1.top()=='N')                  // {st2.push(!ch[s[i]-'a']);st1.pop();}                   //else                   st2.push(ch[s[i]-'a']);                   st1.push('Z');                   not1=checknot(st1);                   other=checkoth(st1);                   //cout<<ch[s[i]-'a']<<endl;                    while(other || not1)                    {                   if(other)                   {                         st1.pop();                         st1.pop();                         x1=st2.top();                         st2.pop();                         x2=st2.top();                         st2.pop();                         if(st1.top()=='C')                         st2.push(fC(x1,x2));                         else if(st1.top()=='D')                         {st2.push(fD(x1,x2));/*cout<<"D "<<st2.top()<<endl;*/}                         else if(st1.top()=='I')                         {st2.push(fI(x2,x1));/*cout<<"I "<<st2.top()<<endl;*/}                         else                         st2.push(fE(x1,x2));                         st1.pop();                         st1.push('Z');                       /*  while(!st1.empty() && st1.top()=='N')                         {                                 st1.pop();                                 h=st2.top();                                 st2.pop();                                 st2.push(!h);                         }*/                   }                   else if(not1)                   {                         x1=st2.top();                         st2.pop();                         st2.push(!x1);                        // cout<<"N "<<st2.top()<<endl;                         st1.pop();                         st1.pop();                         st1.push('Z');                      }                     not1=checknot(st1);                   other=checkoth(st1);              //   cout<<other<<not1<<endl;                  }                   /*else                   x=true;*/              }              else              {                  //cout<<i<<endl;                  st1.push(s[i]);                 // if(s[i]!='N')                 // x=false;              }      }     // cout<<st2.top()<<endl;      return st2.top(); }   void f(int i,bool &ans) {      if(bk)      return;      if(i==-1)      {                            if(!calc())              {ans=false;bk=true;}              return;      }      ch[b[i]-'a']=true;      f(i-1,ans);      ch[b[i]-'a']=false;      f(i-1,ans); } int main() {     cin>>t;     for(int i=0;i<t;i++)     {             cin>>s;             l=s.length();            // if(l==1)            // {cout<<"NO"<<endl;continue;}             for(int i=0;i<26;i++)             {                     a[i]=0;             }             for(int i=0;i<l;i++)             {                     if(s[i]-'a'>=0 && s[i]-'z'<=0)                     a[s[i]-'a']++;             }             cnt=0;             for(int i=0;i<26;i++)             {                     if(a[i]>0)                     {b[cnt]='a'+i;cnt++;}             }             tmp=true;             bk=false;             f(cnt-1,tmp);             if(tmp)             cout<<"YES"<<endl;             else             cout<<"NO"<<endl;     }     return 0; } /* 8 DNDCppCppNp IIpqDpNp NCNpp Iaz NNNNNNNp IIqrIIpqIpr Ipp Ezz */ 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <stack> #include <algorithm> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <cstring> #include <string> using namespace std;  #define pairii pair<int, int> #define llong long long #define pb push_back #define sortall(x) sort((x).begin(), (x).end()) #define INFI  numeric_limits<int>::max() #define INFLL numeric_limits<llong>::max() #define INFD  numeric_limits<double>::max() #define FOR(i,s,n) for (int (i) = (s); (i) < (n); (i)++) #define FORZ(i,n) FOR((i),0,(n))  #define EQN_EPS 1e-15  double det(double m[4][4]) {     return     m[0][3] * m[1][2] * m[2][1] * m[3][0] - m[0][2] * m[1][3] * m[2][1] * m[3][0] -     m[0][3] * m[1][1] * m[2][2] * m[3][0] + m[0][1] * m[1][3] * m[2][2] * m[3][0] +     m[0][2] * m[1][1] * m[2][3] * m[3][0] - m[0][1] * m[1][2] * m[2][3] * m[3][0] -     m[0][3] * m[1][2] * m[2][0] * m[3][1] + m[0][2] * m[1][3] * m[2][0] * m[3][1] +     m[0][3] * m[1][0] * m[2][2] * m[3][1] - m[0][0] * m[1][3] * m[2][2] * m[3][1] -     m[0][2] * m[1][0] * m[2][3] * m[3][1] + m[0][0] * m[1][2] * m[2][3] * m[3][1] +     m[0][3] * m[1][1] * m[2][0] * m[3][2] - m[0][1] * m[1][3] * m[2][0] * m[3][2] -     m[0][3] * m[1][0] * m[2][1] * m[3][2] + m[0][0] * m[1][3] * m[2][1] * m[3][2] +     m[0][1] * m[1][0] * m[2][3] * m[3][2] - m[0][0] * m[1][1] * m[2][3] * m[3][2] -     m[0][2] * m[1][1] * m[2][0] * m[3][3] + m[0][1] * m[1][2] * m[2][0] * m[3][3] +     m[0][2] * m[1][0] * m[2][1] * m[3][3] - m[0][0] * m[1][2] * m[2][1] * m[3][3] -     m[0][1] * m[1][0] * m[2][2] * m[3][3] + m[0][0] * m[1][1] * m[2][2] * m[3][3]; }  static int isZero(double x) {     return x > -EQN_EPS && x < EQN_EPS; }  int solveCubic(double c[4], double s[3]) {     int	i, num;     double	sub, 	A, B, C, 	sq_A, p, q, 	cb_p, D;          A = c[1] / c[0];     B = c[2] / c[0];     C = c[3] / c[0];          sq_A = A * A;     p = 1.0/3.0 * (-1.0/3.0 * sq_A + B);     q = 1.0/2.0 * (2.0/27.0 * A *sq_A - 1.0/3.0 * A * B + C);          cb_p = p * p * p;     D = q * q + cb_p;          if (isZero(D))     {         if (isZero(q))         {             s[0] = 0.0;             num = 1;         }         else         {             double u = cbrt(-q);             s[0] = 2.0 * u;             s[1] = - u;             num = 2;         }     }     else         if (D < 0.0)         {             double phi = 1.0/3.0 * acos(-q / sqrt(-cb_p));             double t = 2.0 * sqrt(-p);             s[0] = t * cos(phi);             s[1] = -t * cos(phi + M_PI / 3.0);             s[2] = -t * cos(phi - M_PI / 3.0);             num = 3;         }         else         {             double sqrt_D = sqrt(D);             double u = cbrt(sqrt_D + fabs(q));             if (q > 0.0)                 s[0] = - u + p / u ;             else                 s[0] = u - p / u;             num = 1;         }          sub = 1.0 / 3.0 * A;     for (i = 0; i < num; i++)         s[i] -= sub;     return num; }  double vel(double x[4], double t) {     return x[0]*t*t*t + x[1]*t*t + x[2]*t + x[3]; }  double dist(double x[4], double t) {     return x[0]*t*t*t*t/4.0 + x[1]*t*t*t/3.0 + x[2]*t*t/2.0 + x[3]*t; }  void solve() {     double t; scanf("%lf", &t);     double A[4][4];     double b[4];     FORZ(i,4) {         double ct, cv; scanf("%lf %lf", &ct, &cv);         A[i][0] = ct*ct*ct;         A[i][1] = ct*ct;         A[i][2] = ct;         A[i][3] = 1.0;         b[i] = cv;     }     double x[4];     double detA = det(A);     FORZ(i,4) {         double Ai[4][4];         FORZ(j,4) FORZ(k,4) {             if (k == i) Ai[j][k] = b[j];             else Ai[j][k] = A[j][k];         }         x[i] = det(Ai) / detA;     }     double s[3];     solveCubic(x, s);     sort(s, s+3);     vector<double> ss;     ss.pb(0.0);     FORZ(i,3) {         if (0 < s[i] && s[i] < t) ss.pb(s[i]);     }     ss.pb(t);     double res = 0.0;     FORZ(i,ss.size()-1) {         double mid = (ss[i+1] + ss[i]) / 2.0;         double d = dist(x, ss[i+1]) - dist(x, ss[i]);         if (vel(x,mid) >= 0) res += d;         else res -= d;     }          printf("%.10f\n", res); }   int main() { #ifdef DEBUG     freopen("in.txt", "r", stdin);     freopen("out.txt", "w", stdout); #endif          int t; scanf("%d", &t);     FORZ(i,t) solve();      return 0; } 
#include <stdio.h> #include <queue> #include <vector> #define MOD 1073741824;  using namespace std;  struct SS{   int aw, ak; }; struct SN{   int id, val; };  struct SLess{   bool operator()(SN a, SN b){     if(a.val > b.val) return true;     if((a.val == b.val) && (a.id < b.id)) return true;     return false;   } }; struct SMore{   bool operator()(SN a, SN b){     if(a.val < b.val) return true;     if((a.val == b.val) && (a.id < b.id)) return true;     return false;   } }; struct SQ{   queue<SN> q;   deque<SN> dl, dm; };  int N, diff, jQ; SN arr[500010]; SS s[500010]; int js; int indexof[500010]; int count[500010]; int ans[500010]; SQ q;  void push(SN a){   q.q.push(a);   while(!q.dm.empty() && (q.dm.back().val <= a.val)) q.dm.pop_back();   q.dm.push_back(a);   while(!q.dl.empty() && (q.dl.back().val >= a.val)) q.dl.pop_back();   q.dl.push_back(a); } void pop(){   SN a = q.q.front();   q.q.pop();   if((a.val == q.dl.front().val) && (a.id == q.dl.front().id)) q.dl.pop_front();   if((a.val == q.dm.front().val) && (a.id == q.dm.front().id)) q.dm.pop_front(); } SN qtop(){   return q.q.front(); } SN qbig(){   return q.dm.front(); } SN qsmall(){   return q.dl.front(); }  int main(){   int jcase;   int A, B, D;   long long ll1, ll2;   int idfront, idrear;   int mini, maxi;   int idmin, idmax, idlow;    //  freopen("in.txt", "r", stdin); //  freopen("out.txt", "w", stdout);      scanf("%d", &jcase);   for(int icase=0; icase<jcase; icase++){     scanf("%d %d %d %d %d %d", &N, &diff, &jQ, &A, &B, &D);     if(N <= 10000){       for(int i=0; i<N; i++){         scanf("%d", &arr[i].val);         arr[i].id = i;       }     }     else{       for(int i=0; i<10000; i++){         scanf("%d", &arr[i].val);         arr[i].id = i;       }       for(int i=10000; i<N; i++){         ll1 = arr[i-1].val;         ll1 *= A;         ll2 = arr[i-2].val;         ll2 *= B;         ll1 += ll2;         ll1 += D;         ll1 %= MOD;         arr[i].val = (int)ll1;         arr[i].id = i;       }     }          idfront = idrear = 0;     while(!q.q.empty()) q.q.pop();     while(!q.dl.empty()) q.dl.pop_back();     while(!q.dm.empty()) q.dm.pop_back();     js = 0;     while(idfront < N){       push(arr[idfront]);       idfront++;       maxi = qbig().val;       mini = qsmall().val;       if(maxi - mini > diff){         s[js].aw = idrear;         s[js].ak = idfront - 2;         js++;       }       while(maxi - mini > diff){         idmin = qsmall().id;         idmax = qbig().id;         idlow = idmin < idmax ? idmin : idmax;                  idrear = idlow + 1;         while(qtop().id < idrear) pop();         maxi = qbig().val;         mini = qsmall().val;       }     }     s[js].aw = idrear;     s[js].ak = idfront - 1;     js++;     //for(int i=0; i<js; i++) printf("%d: %d - %d\n", i, s[i].aw, s[i].ak);     //for(int i=499980; i<500000; i++) printf("%d: %d\n", i, arr[i].val);          for(int i=0; i<N; i++) indexof[i] = -1;     for(int i=0; i<js; i++) indexof[s[i].aw] = i;     for(int i=0; i<N; i++){       if(indexof[i] == -1) indexof[i] = A;       else A = indexof[i];     }          for(int i=0; i<N; i++) count[i] = 0;     for(int i=0; i<N; i++) count[s[indexof[i]].ak - i + 1]++;     for(int i=0; i<N; i++) count[i+1] += count[i];     for(int i=0; i<N; i++) count[i] = N - count[i];     //for(int i=0; i<N; i++) printf("%d: %d\n", i + 1, count[i]);          for(int i=0; i<N; i++) ans[i] = -1;     for(int i=N-1; i>=0; i--) ans[count[i]] = i;     A = -1;     for(int i=0; i<N; i++){       if(ans[i] == -1) ans[i] = A;       else A = ans[i];     }          for(int i=0; i<jQ; i++){       scanf("%d", &A);       printf("%d %d\n", ans[A] + 1, count[ans[A]]);     }     //printf("N = %d diff = %d jQ = %d A = %d B = %d D = %d\n", N, diff, jQ, A, B, D);   }   return 0; } 
#include <stdio.h> #include <iostream> #include <algorithm> #include <assert.h> #include <vector> using namespace std; typedef long long lint; const lint MOD = 1000003; const int MAXP = 100;   lint power(lint x, lint n, lint mod){   if(n==0) return 1%mod;   if(n%2) return x * power(x, n-1, mod)%mod;   lint y = power(x, n/2, mod);   return y*y%mod; }   int inverse(int x, int p){   return power(x, p-2, p); }   int inv[MAXP+1]; vector<int> baseP(lint x, int p){   vector<int> ret;   while(x) ret.push_back(x%p), x/=p;   reverse(ret.begin(),ret.end());   return ret; }   int p; lint choose(lint n, lint r){   assert(0 <= r && r < p);   lint ret = 1;   for(int i=0;i<r;++i)     ret = ret*((n-i)%MOD)%MOD*inv[i+1]%MOD;   return ret; }   lint F(lint n, lint k){   assert(0 <= n && n < p);   assert(k >= 1);   return choose(n+k-1,n); }   vector<int> X; vector<int> P; lint D[MAXP+1];   lint doit(int x, lint k){   if(x==X.size()) return 1;   lint t = X[x];   lint A = D[t] * P[x];   lint B = F(t, k) * doit(x+1,k);   return (A + B)%MOD; } void solveCase(lint n, lint k){   if(p==1) {     cout<<0<<endl;     return;   }     X = baseP(n, p);   lint C = 0;   for(int i=0;i<p;++i) {     C = (C + F(i, k))%MOD;     D[i+1] = C;   }   P.clear(); P.push_back(1); while(P.size() < X.size()) P.push_back(P.back() * C % MOD); reverse(P.begin(),P.end());     lint ret = doit(0, k);   cout<<ret<<endl; }   bool isPrime(int x){   for(int i=2;i*i<=x;++i) if(x%i==0) return false;   return true; }   void init(){   assert(isPrime(MOD));   for(int i=1;i<=MAXP;++i)     inv[i] = inverse(i, MOD); }   const int MAXCASES = 10000; const lint MAXN = 1000000000000000LL; const lint MAXK = 1000000000000000LL; void checkInput(lint n, lint k,lint p){   assert(0 <= n && n <= MAXN);   assert(1 <= k && k <= MAXK);   assert(1 <= p && p <= MAXP);   assert(isPrime(p)); }   main(){   init();   int cases; cin>>cases;   assert(1 <= cases && cases <= MAXCASES);   while(cases--){     lint n,k;     cin>>n>>k>>p;     checkInput(n,k,p);     solveCase(n,k);   } } 
using namespace std; #include<cstdio> #include<cmath> double sqr(double x) { return x*x;      } double area(double t,double y,double z) { double k; k=(t+y+z)/2.0; return sqrt(k*(k-t)*(k-y)*(k-z));        } int main() { int test,i; double a[6],u,v,w,U,V,W,vol,s; scanf("%d",&test); while(test--) { s=0; for(i=0;i<6;i++)  scanf("%lf",&a[i]); u=a[2];v=a[4];w=a[5];U=a[3];V=a[1];W=a[0]; vol=sqrt((4*sqr(u)*sqr(v)*sqr(w))-sqr(u)*sqr(sqr(v)+sqr(w)-sqr(U))-sqr(v)*sqr(sqr(w)+sqr(u)-sqr(V))-sqr(w)*sqr(sqr(u)+sqr(v)-sqr(W))+(sqr(v)+sqr(w)-sqr(U))*(sqr(w)+sqr(u)-sqr(V))*(sqr(u)+sqr(v)-sqr(W)))/12.0; s=s+area(W,u,v); s=s+area(u,w,V); s=s+area(v,w,U); s=s+area(W,V,U); printf("%0.4lf\n",(vol*3.0)/s);            }  //system("pause"); return 0;    } 
//Working code of convexhull,  tested on spoj GARDENHU //prints hull in clockwise direction, doesn't have the points on an edge of hull (if not is not one of the edge-vertex) #include <stdio.h> #include <algorithm> #include <math.h> #include "vector" #include "assert.h"  using namespace std;  #define INF 10000000000000LL  struct pt { 	long long x, y; };  bool cmp (pt a, pt b) { 	return a.y <b.y || a.y == b.y && a.x <b.x; }  bool cw (pt a, pt b, pt c) { 	return a.x * (b.y-c.y) + b.x * (c.y-a.y) + c.x * (a.y-b.y) <0; }  bool ccw (pt a, pt b, pt c) { 	return a.x * (b.y-c.y) + b.x * (c.y-a.y) + c.x * (a.y-b.y)> 0; }  long long dist2(pt a, pt b) { 	return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y); }  long long convex_hull (vector <pt> & a)  { 	if (a.size () == 1)  		return 0LL; 	sort (a.begin (), a.end (), & cmp);  	pt p1 = a [0], p2 = a.back (); 	vector <pt> up, down; 	up.push_back (p1); 	down.push_back (p1);  	for (size_t i = 1; i <a.size (); ++i)  	{ 		if (i == a.size () -1 || cw (p1, a [i], p2))  		{ 			while (up.size ()>= 2 && !cw (up [up.size () -2], up [up.size () -1], a[i])) 				up.pop_back (); 			up.push_back (a [i]); 		} 		if (i == a.size () -1 || ccw (p1, a [i], p2))  		{ 			while (down.size ()>= 2 && !ccw (down [down.size () -2], down [down.size () -1], a [i])) 				down.pop_back (); 			down.push_back (a [i]); 		} 	}  	a.clear (); 	//Rotating calliper 	/*Given a list of 2d points, finds all ways of sandwiching the points 	between two parallel lines that touch one point each, and yields the sequence 	of pairs of points touched by each pair of lines.*/  	long long dist = -1; 	int i=0,j,m; 	j=down.size()-1; 	m=up.size()-1; 	while(i<m || j>0) 	{ 		dist=max(dist,dist2(up[i], down[j])); 		//if all the way through one side of hull, advance the other side 		if(i==m) 			j--; 		else if(j==0) 			i++; 		else // still points left on both lists, compare slopes of next hull edges         // being careful to avoid divide-by-zero in slope calculation 		{ 			if ( (up[i+1].y-up[i].y) * (down[j].x-down[j-1].x) > (down[j].y-down[j-1].y) * (up[i+1].x-up[i].x) ) 				i++; 			else 				j--; 			} 		} 	return dist; }  int main() { 	int t=1; 	scanf("%d", &t); 	vector<pt> pts; 	//vector<pt> hull; 	//int inx[]; 	int i, n; 	while(t--) 	{ 		pts.clear(); 		//hull.clear(); 		scanf("%d", &n); 		for(i=0;i<n;i++) 		{ 			pt a, b; 			scanf("%lld %lld", &a.x, &a.y); 			//b.x = a.x, b.y = a.y; 			pts.push_back(a); 			//hull.push_back(b); 		} 		long long ans = convex_hull(pts); 		printf("%lld\n", ans); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;   #define gc getchar #define pi(n) printf("%d",n) #define pin(n) printf("%d\n",n) #define pis(n) printf("%d ",n) #define pll(n) printf("%d",n) #define plls(n) printf("%lld ",n) #define plln(n) printf("%lld\n",n) #define ps printf(" ") #define pn printf("\n") #define si(n) scanf("%d",&n) #define sii(n,m) scanf("%d %d",&n,&m) #define siii(k,n,m) scanf("%d %d %d",&k,&n,&m) #define rep(i,n) for(i=0;i<n;i++) #define fu(i,a,n) for(i=a;i<=n;i++) #define fd(i,n,a) for(i=n;i>=a;i--) #define ll long long #define ii pair<int,int> #define iii pair<ii,int> #define ff first  #define ss second #define vi vector<int> #define pb push_back #define mod -17 #define infi 1000000000   vector< vector<char> > s; vector< vector<int> > v; vi v1;   int cnt; int diff;   void dfs(int i,int j) { 	int k,l; 	v[i][j]=1; 	cnt++; 	fu(k,-1,1) 		fu(l,-1,1) 			if(abs(k)+abs(l)==1 && 0<=i+k && i+k<s.size() && 0<=j+l && j+l<s[0].size() && s[i+k][j+l]=='o' && v[i+k][j+l]==0) 				dfs(i+k,j+l); }   int main() {     int i,j,r,c,t;     si(t);     while(t--)     {     	sii(r,c);     	s.clear();     	v.clear();     	v1.clear();     	diff=-1;   	    s.resize(r); 	    v.resize(r); 	    rep(i,r) 	    { 	    	s[i].resize(c); 	    	v[i].resize(c); 	    } 	    rep(i,r) 	    	rep(j,c) 	    	{ 	    		cin>>s[i][j]; 	    		v[i][j]=0; 	    	}   	    rep(i,r) 	    	rep(j,c) 	    	{ 	    		if(s[i][j]=='#' || v[i][j]==1) continue; 	    		cnt=0; 	    		dfs(i,j); 	    		if(diff==-1) 	    			diff=cnt; 	    		else 	    			v1.push_back(cnt); 	    	} 	    double ans=1; 	    for(i=0;i<v1.size();i++) 	    	ans+=((double)v1[i]/(v1[i]+diff)); 	    printf("%.7lf\n",ans);     }          	return 0; }   
#include<stdio.h> int t,n; long long int po1,po2,ma1,ma2; int st[501][501][3]; int r,m; long long int tmp; long long int a[502][502]; inline int find_max(int x,int y,int z,int &set) { if(x>=y) { if(x>=z) {set=-1;return x;} {set=1;return z;} } else { if(y>=z) {set=0;return y;} {set=1;return z;} } } inline void init_arr() { for(int i=0;i<=n+1;i++) { for(int j=0;j<=n+1;j++) { a[i][j]=0; } } } inline long long int po(int k,bool tr) { init_arr(); for(int i=1;i<=n;i++) { tmp=-1; for(int j=1;j<=n-i+1 && j<=i;j++) { a[i][j]=st[i][j][k]+find_max(a[i-1][j-1],a[i-1][j],a[i-1][j+1],r); if(tr && st[i-1][j+r][0]>tmp) {tmp=st[i-1][j+r][0];m=j+r;} } if(tr) {st[i-1][m][2]=0;} } st[n][1][2]=0; return a[n][1]; } inline long long int ma(int k,bool tr) { init_arr(); for(int i=n;i>=1;i--) { tmp=-1; for(int j=n;j>=n-i+1 && j>=i;j--) { //printf("%d %d\n",j,i); a[j][i]=st[j][i][k]+find_max(a[j-1][i+1],a[j][i+1],a[j+1][i+1],r); if(tr && st[j+r][i+1][0]>tmp) {tmp=st[j+r][i+1][0];m=j+r;} } if(tr) {st[m][i+1][1]=0;} } st[n][1][1]=0; return a[n][1]; } int main() { scanf("%d",&t); for(int i=0;i<t;i++) { scanf("%d",&n); for(int i=1;i<=n;i++) { for(int j=1;j<=i;j++) { scanf("%d",&st[i][j][0]); st[i][j][1]=st[i][j][0]; st[i][j][2]=st[i][j][0]; } } po1=po(0,true); ma1=ma(0,true); /*for(int i=1;i<=n;i++) { for(int j=1;j<=n-i+1 && j<=i;j++) { printf("%d ",st[i][j][1]); } printf("\n"); }*/ po2=po(1,false); ma2=ma(2,false); //printf("%lld %lld %lld %lld\n",po1,po2,ma1,ma2); if(po1+ma2>po2+ma1) printf("%lld\n",po1+ma2); else printf("%lld\n",po2+ma1); } return 0; }
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <cmath> #include <algorithm> #include <ctime> #include <list> #include <map> #include <set> #include <bitset> #include <functional> #include <utility> #include <iostream> #include <fstream> #include <sstream> #include <cstring> #include <queue> #define maxn 100005 #define mp make_pair using namespace std; typedef pair<int, int> pii; int ini[maxn], a, b, c, d, n, m; struct node {     pii mx;     node *left;     node *right;     node(){mx=mp(-1,-1), left=NULL, right=NULL;} }; node *root[maxn]; pii maxp(pii a, pii b) {     if(a.first>=b.first)return mp(a.first, max(b.first, a.second));     else return mp(b.first, max(a.first, b.second)); } node *build(int l, int r) {     node *tmp = new node();     if(l==r){tmp->mx=mp(ini[l],-1); return tmp;}     tmp->left = build(l, (l+r)/2);     tmp->right=build((l+r)/2+1, r);     tmp->mx = maxp(tmp->left->mx, tmp->right->mx);     return tmp; }  pii query(node * cur, int l, int r, int a, int b) {     if(a>r || b<l)return mp(-1,-1);     if(a<=l && b>=r)return cur->mx;     return maxp(query(cur->left, l, (l+r)/2, a, b), query(cur->right, (l+r)/2+1, r, a, b)); }  node * update(node *cur, int l, int r, int id, int val) {     node *tmp = new node();     if(l==r){tmp->mx=mp(val,-1); return tmp;}     int m = (l+r)/2;      if(id>m)     {         tmp->left = cur->left;         tmp->right = update(cur->right, m+1, r, id, val);     }     else     {         tmp->right = cur->right;         tmp->left = update(cur->left, l, m, id, val);     }     tmp->mx = maxp(tmp->left->mx, tmp->right->mx);     return tmp; }  int main() {     scanf("%d%d%d%d%d%d", &n, &m, &a, &b, &c, &d);     for(int i=0; i<n; i++)         scanf("%d", &ini[i]);     root[0] = build(0, n-1);     int q;     scanf("%d", &q);     pii p;     p.first=0, p.second=-1;     for(int i=1; i<=q; i++)     {         int l, r;         scanf("%d%d", &l, &r);         int id = (a*1LL*p.first+d)%i;         p = query(root[id], 0, n-1, l, r);         int indx = (b*1LL*p.first+d)%n;         int val = (c*1LL*p.second+d)%m;         root[i] = update(root[i-1], 0, n-1, indx, val);         printf("%d %d\n", p.first, p.second);     }     return 0; } 
#include <cstdio> #include <algorithm> #define N 8 #define fi(a, b, c) for(int a = (b); a < (c); a++) using namespace std;  inline int pow(int x){ 	int rt = 1; 	while(x--) rt *= 3; 	return rt; }  int t, n, m, y[N + N], x[N + N], d[N + N][6561], A;  int main(){ 	scanf("%d", &t); 	while(t--){ 		scanf("%d", &n); 		fi(i, 0, n) scanf("%d %d %d %d", &y[i], &x[i], &y[i + n], &x[i + n]); 		 		m = pow(n); 		fi(i, 0, n) fi(j, 0, m) d[i][j] = 1 << 30; 		 		fi(i, 1, m){ 			int o[N], t[N], O = 0, T = 0, r = i; 			fi(j, 0, n){ 				int q = r % 3; 				if(q == 1) o[O++] = j; 				if(q == 2) t[T++] = j; 				r /= 3; 			} 			 			if(O > 2) continue; 			if(O == 1 && !T){ 				d[o[0]][i] = y[o[0] + n] + x[o[0] + n]; 				continue; 			} 			 			fi(j, 0, O){ 				fi(k, 0, O) if(j != k) d[o[j]][i] = min(d[o[j]][i], 				d[o[k]][i - pow(o[j])] + abs(y[o[j] + n] - y[o[k] + n]) + 				abs(x[o[j] + n] - x[o[k] + n])); 				 				fi(k, 0, T) d[o[j]][i] = min(d[o[j]][i], 				d[t[k]][i - pow(o[j])] + abs(y[o[j] + n] - y[t[k]]) + 				abs(x[o[j] + n] - x[t[k]])); 			} 			 			fi(j, 0, T){ 				fi(k, 0, O) d[t[j]][i] = min(d[t[j]][i], 				d[o[k]][i - pow(t[j])] + abs(y[t[j]] - y[o[k] + n]) + 				abs(x[t[j]] - x[o[k] + n])); 				 				fi(k, 0, T) if(j != k) d[t[j]][i] = min(d[t[j]][i], 				d[t[k]][i - pow(t[j])] + abs(y[t[j]] - y[t[k]]) + 				abs(x[t[j]] - x[t[k]])); 				 				d[t[j]][i] = min(d[t[j]][i], d[t[j]][i - pow(t[j])] + abs(y[t[j] + n] - y[t[j]]) + abs(x[t[j] + n] - x[t[j]])); 			} 		} 		 		A = 1 << 30; 		fi(i, 0, n) A = min(A, d[i][m - 1] + y[i] + x[i]); 		 		printf("%d\n", A); 	} } 
#include <stdio.h> #include <iostream> #include <map> #include <bitset> #include <vector> #include <algorithm> #include <queue> #include <cstring> #include <cstdlib> #include <cmath> #include <set> #include <ctime>  # define f(i,a,b) for(typeof( b ) i=a;i<b;i++) # define TT "\t" # define Clear(x) memset(x,0,sizeof(x)) # define fill(x,a) memset(x,a,sizeof(x)) # define pb push_back  typedef unsigned long long ull; typedef long long ll;  using namespace std;  template <class T> inline void ri(T &i){     char c;for(c=getchar();c<'0'||c>'9';c=getchar());         for(i=0;c>='0'&&c<='9';c=getchar())         i=(i<<3)+(i<<1) + (c-48); }  struct swnode{ 	int wt; 	swnode *left;swnode *right; };  swnode wnode; int ans[104]; int m,n[104]; int input[1004][2];  swnode* create2(){ 	swnode* temp; 	temp=new swnode; 	temp->left=temp->right=0;temp->wt=0; 	return temp; }  swnode** root;  void rec(swnode** node,int a){ 	//cout<<a<<endl; 	if(*node==0){ 		*node=create2(); 	} 	(*node)->wt++; 	if(input[a][0]){ 		rec(&((*node)->left),input[a][0]); 	} 	if(input[a][1]){ 		rec(&((*node)->right),input[a][1]); 	} } void updatethemaintree(){ 	 	rec(root,1); } void fin(){ 	int to,from,a,b; 	char c,x,v; 	ri(m); 	f(i,0,m){ 		ri(n[i]); 		Clear(input); 		f(j,0,n[i]-1){ 		ri(a);c=getchar();ri(b); 		if(c=='L'){ 			input[a][0]=b; 		} 		else{ 			input[a][1]=b; 		} 		} 		updatethemaintree(); 	} 	 } void rec2(swnode* node,int depth){ 	if(node==0)return; 	int w=(node)->wt; 	ans[w]=max(ans[w],depth); 	rec2((node)->left,depth+1); 	rec2((node)->right,depth+1); }  void getansfromroot(){ 	rec2(*root,0); 	for(int i=m-1;i>0;i--){ 		ans[i]=max(ans[i],ans[i+1]); 	} } int main(){ 	int test;ri(test); 	while(test--){ 		//reset 		root= new swnode*; 		*root = 0; 		Clear(ans); 		fin(); 	//	cout<<"fin"<<endl; 		//all the trees should have been build by now 		getansfromroot(); 	//	cout<<"getansformroot"<<endl; 		f(i,1,m){ 			printf("%d ",ans[i]); 		} 		printf("%d\n",ans[m]); 	} }           
#include <iostream> #include <sstream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cmath> #include <memory> #include <cctype> #include <string> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> using namespace std; #define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i)) #define RFOR(i,a,b) for(int (i) = (a); (i) >= (b); --(i)) #define INITIALIZE(a,b) memset((a),b,sizeof(a)) #define INF 1000000000 #define pi 2*acos(0.0) #define SQR(a) (a)*(a) #define MP make_pair #define MAX 100001 #define MODV 1000000007 #define mod(a,mb) if(a >= mb) a = a - mb; #define modx(a) mod(a,MODV)  typedef unsigned long long UInt; typedef long long Int;  void compPrime(int *primeArr,int n){} void compPhi(int *phiArr, int n){} void compFact(int *factArr, int n){factArr[0]=1;int i; FOR(i,1,n)factArr[i] = factArr[i-1]*i; } void compPow(int *powArr, int x, int n) {   int i;     powArr[0] = 1;     FOR(i,1,n){powArr[i] = powArr[i-1]*x;mod(powArr[i],MODV);} }    const int MAXN = 200000; int Seq[MAXN]; int cnt[MAXN]; pair<int, int>Pairs[MAXN];  int main() {   int test, j, sum;    scanf("%d", &test);   int N,Wi,Hi,i;    while(test--)   {         scanf("%d", &N);         memset(cnt, 0, sizeof(cnt));         FOR(i,0,N-1)         {             scanf("%d%d", &Wi, &Hi);             Pairs[i].first = -Wi;             Pairs[i].second = -Hi;         }            sort(Pairs, Pairs+N);         int len = 0;          for(i= 0; i<N; i++)         {             int p = lower_bound(Seq, Seq+len, Pairs[i].second+1)-Seq;             cnt[p]++;             Seq[p] = Pairs[i].second;             len += len==p;          }           printf("%d\n",len);         printf("%d", cnt[0]);         FOR(i, 1, len-1)             printf(" %d",cnt[i]);          puts("");  	// your code goes here   }   } 
#define _CRT_SECURE_NO_WARNINGS  #include <cstdio> #include <cmath> #include <cstring> #include <cstdlib> #include <ctime> #include <iostream> #include <fstream> #include <sstream> #include <algorithm> #include <string> #include <vector> #include <set> #include <map> #include <list> #include <complex> #include <queue> #pragma comment(linker, "/STACK:266777216") using namespace std;  #define assert(f) { if(!(f)) { fprintf(stderr,"Assertion failed: "); fprintf(stderr,#f); fprintf(stderr,"\n"); exit(1); } }  typedef long long LL; typedef unsigned long long ULL; typedef vector<int> VI; typedef vector<VI> VVI; typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<double> VD; typedef pair<double,double> PDD;  const int inf=1000000000; const LL INF=LL(inf)*inf; const double eps=1e-9; const double PI=2*acos(0.0); #define bit(n) (1<<(n)) #define bit64(n) ((LL(1))<<(n)) #define pb push_back #define sz size() #define mp make_pair #define cl clear() #define all(a) (a).begin(),(a).end() #define fill(ar,val) memset((ar),(val),sizeof (ar)) #define MIN(a,b) {if((a)>(b)) (a)=(b);} #define MAX(a,b) {if((a)<(b)) (a)=(b);} #define sqr(x) ((x)*(x)) #define X first #define Y second  //clock_t start=clock(); //fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));  #define N 101010  #define MOD 1000000007 int fac[N]; int inv[N]; int invfac[N];  int SZ; int p1[N],q1[N]; int p2[N],q2[N];  int bin(int n,int k) {   if(k<0 || k>n) return 0;   return LL(fac[n]) * invfac[k] % MOD * invfac[n-k] % MOD; }  int ans;  void rec(int L1,int R1,int L2,int R2) {   assert(R1-L1==R2-L2);   int root = p1[L1];   if(p2[R2]!=root) {ans=0;return;}   if(L1==R1) return;   int cnt=0;   for(int k1=L1+1,k2=L2;k1<=R1;)   {     int j2 = q2[p1[k1]];     if(j2<k2 || j2>=R2){ans=0;return;}     int j1 = k1 + j2-k2;     rec(k1,j1,k2,j2);     k1=j1+1;     k2=j2+1;     cnt++;   }   ans = LL(ans) * bin(SZ,cnt) % MOD; }  int main() { #ifndef ONLINE_JUDGE   freopen("tra.in","r",stdin); #endif   for(int n=0;n<2;n++)     fac[n]=inv[n]=invfac[n]=1;   for(int n=2;n<N;n++)   {     fac[n] = LL(n) * fac[n-1] % MOD;     inv[n] = LL(MOD - MOD/n) * inv[MOD%n] % MOD;     invfac[n] = LL(inv[n]) * invfac[n-1] % MOD;   }   int T;   for(scanf("%d",&T);T--;)   {     int n;     scanf("%d%d",&n,&SZ);     for(int i=1;i<=n;i++)     {       scanf("%d",p1+i);       q1[p1[i]]=i;     }     for(int i=1;i<=n;i++)     {       scanf("%d",p2+i);       q2[p2[i]]=i;     }     ans=1;     rec(1,n,1,n);     printf("%d\n",ans);   }   return 0; }
#include<bits/stdc++.h>  #define MOD 1000000007 #define MAX 200005 #define ll long long #define slld(t) scanf("%lld",&t) #define sd(t) scanf("%d",&t) #define pd(t) printf("%d\n",t) #define plld(t) printf("%lld\n",t) #define pcc pair<char,char> #define pii pair<int,int> #define pll pair<ll,ll> #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) #define mp(a,b) make_pair(a,b) #define FF first #define SS second #define pb(x) push_back(x) #define vi vector<int> #define vpii vector<pii > #define vll vector<ll> #define clr(x) memset(x,0,sizeof(x))  using namespace std;  // Why u not set TL for segT to pass :'(  vector<int> adj[MAX]; bool visited[MAX];  int st[MAX],en[MAX],st2[MAX],en2[MAX],F[MAX],L[MAX],global=0,tme=0;	// F stores father of node and L stores depth of node  void dfs(int x){ 	visited[x]=true; 	st[x]=++global; 	st2[x]=++tme; 	for(int i=0;i<adj[x].size();i++){ 		if(!visited[adj[x][i]]) L[adj[x][i]]=1+L[x],dfs(adj[x][i]),F[adj[x][i]]=x; 	} 	en[x]=global; 	en2[x]=++tme; }  int P[17][MAX];  void preLCA(int N){ 	int i, j;      	for (i = 1; i <= N; i++)         for (j = 0; 1 << j < N; j++)             P[j][i] = -1;         for (i = 1; i <= N; i++)         P[0][i] = F[i];       	for (j = 1; 1 << j < N; j++)     	for (i = 1; i <= N; i++)         	if (P[j-1][i] != -1)                 P[j][i] = P[j - 1][P[j-1][i]]; }  int LCA(int p,int q){ 	int tmp, log, i;         if (L[p] < L[q])         tmp = p, p = q, q = tmp;        for (log = 1; 1 << log <= L[p]; log++);       log--;         for (i = log; i >= 0; i--)         if (L[p] - (1 << i) >= L[q])             p = P[i][p];         if (p == q)         return p;         for (i = log; i >= 0; i--)         if (P[i][p] != -1 && P[i][p] != P[i][q])               p = P[i][p], q = P[i][q];         return F[p]; }  int BIT1[MAX];   void update1(const int &t,const int &i,const int &j,const int &update_index,const int &inc){ 	// this much argument was not needed but just not in order to edit the pre-written code 	 	int index=update_index; 	int n=MAX-1; 	 	while(index<n){ 		BIT1[index]+=inc; 		index = index + (index & (-index)); 	} }   int query1(const int &t,const int &i,const int &j,const int &ri,const int &rj){ 	int n=MAX-1; 	int ans=0; 	int index=rj; 	while(index){ 		ans+=BIT1[index]; 		index = index - (index & (-index)); 	} 	index=ri-1; 	while(index){ 		ans-=BIT1[index]; 		index = index - (index & (-index)); 	} 	return ans; }  int BIT2[MAX<<1];   void update2(const int &t,const int &i,const int &j,const int &update_index,const int &inc){ 	// this much argument was not needed but just not in order to edit the pre-written code 	 	int index=update_index; 	int n=2*MAX-1; 	 	while(index<n){ 		BIT2[index]+=inc; 		index = index + (index & (-index)); 	} }   int query2(const int &t,const int &i,const int &j,const int &ri,const int &rj){ 	int n=2*MAX-1; 	int ans=0; 	int index=rj; 	while(index){ 		ans+=BIT2[index]; 		index = index - (index & (-index)); 	} 	index=ri-1; 	while(index){ 		ans-=BIT2[index]; 		index = index - (index & (-index)); 	} 	return ans; }  int main(){ 	int N;sd(N); 	 	for(int i=1;i<N;i++){ 		int u,v; 		sd(u);sd(v); 		adj[u].pb(v); 		adj[v].pb(u); 	} 	 	clr(visited); 	F[1]=-1; L[1]=0; 	dfs(1); 	preLCA(N); 	 	int lim=N<<1; 	 	int Q;sd(Q); 	clr(BIT1);clr(BIT2); 	while(Q--){ 		int u,v;sd(u);sd(v); 		int x=LCA(u,v); 		 		int ans=query1(1,1,N,st[x],en[x]); 		ans+=query2(1,1,lim,1,st2[u])-query2(1,1,lim,1,st2[x]); 		ans+=query2(1,1,lim,1,st2[v])-query2(1,1,lim,1,st2[x]); 		pd(ans); 		 		update1(1,1,N,st[u],1); 		update1(1,1,N,st[v],1); 		update1(1,1,N,st[x],-1); 		if(F[x]!=-1) update1(1,1,N,st[F[x]],-1); 		update2(1,1,lim,st2[x],1); 		update2(1,1,lim,en2[x],-1); 	} }
#include <iostream> #include <vector> #include <string> #include <map> #include <algorithm> #include <set> #include <stack> #include <deque> #include <queue> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <iomanip> #include <climits> #include <cfloat> #include <cstdio> #define x first #define y second #define IN(x, n) (0 <= (x) && (x) < n) #define YES 1 #define NO 0 #define MAX 100 #define MOD 1000000007 #define INF 288230376151711744LL using namespace std;  int vec8[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};// signo x+ int vec4[4][2] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};//signo +  void int_to_char(int n, char s[], int base = 10){ 	int i = 0; 	do{ 		s[i++] = (n%base)+'0'; 		n /= base; 	}while(n > 0); 	reverse(s, s+i); 	return; }  string int_to_string(int n, int base = 10){ 	string s = ""; 	int i = 0; 	do{ 		s += char((n%base)+'0'); 		n /= base; 	}while(n > 0); 	reverse(s.begin(), s.end()); 	return s; }  int gcd(int uno, int dos)/*calculo el maximo comun divisor*/ { 	if(dos == 0) 		return uno; 	return gcd(dos, uno%dos);/*si este es uno los numeros solo tienen a 1 como maximo comun divisor*/ }  int mcm(int x, int y)/*minimo comun multiplo*/ {    return (x/gcd(x,y))*y;/*es mejor primero dividir para no desbordar*/ }  typedef long long int entero; typedef pair<int, int> Point;  int n, m, c[MAX], rango[MAX], s[MAX], dic[MAX], list[MAX]; entero cont, cont2; /*set<Point> edges; set<Point>::iterator ij;//*/  entero pot(entero a, entero b){ 	if(b <= 0) 		return 1; 	entero resp = pot(a, b>>1); 	resp = (resp * resp)%MOD; 	if(b&1) 		return (a*resp)%MOD; 	return resp; }  bool Labeled_Tree_from_Prufer_Sequence(){ 	int i, j; 	for(i = 0; i < m; i++) 		list[i] = i; //	edges.clear(); 	for(i = 0; i < n; i++){ 		for(j = 0; j < m; j++){ 			if(list[j] >= 0 && dic[j]==0){ 				if(rango[j] == rango[s[i]]){ 					for(i--; i >= 0; i--) 						dic[s[i]]++; 					return false; 				} //				edges.insert(Point(min(*it, sequence[i]), max(*it, sequence[i]))); 				dic[s[i]]--; 				list[j] = -1; 				break; 			} 		} 	} 	for(j = 0; j < n; j++) 		dic[s[j]]++; 	for(i = 0; i < m; i++) 		if(list[i]>=0){ 			for(j = i+1; j < m; j++) 				if(list[j]>=0){ 					if(rango[i] == rango[j]) 						return false; 					else return true; 				} 		} //	edges.insert(Point(i, j)); //	cout << "El arbol:" << endl; /*	for(ij = edges.begin(); ij != edges.end(); ij++) 		cout << "("<<(*ij).x << "," << (*ij).y<<") "; 	cout << endl;//*/ 	return true; }  void genera(int i){ 	if(i == n){ 		if(Labeled_Tree_from_Prufer_Sequence()){ //			cout << s << endl; 			c[s[0]]++; 			cont2++; 			 		} 		cont++; 		return; 	} 	for(int j = 0; j < m; j++){ 		s[i] = j; 		dic[j]++; 		genera(i+1); 		dic[j]--; 	} 	return; }  entero formula_k_1(int n){ 	return pot(n, n-2); }  entero formula_k_2(int n){ 	entero resp = (pot(n, n-2) * pot(n-1, n))%MOD; 	return (resp * pot(4, n-1))%MOD; }  entero formula_general(int n, int k){ 	entero resp = (pot(n, n-2) * pot(n-1, n*k-n))%MOD; 	return (resp * pot(k, n*k-2))%MOD; }  int main(){ 	int i, j, k = 1; 	int v[MAX], dic[MAX]; /*	n = 6; 	for(i = 0; i < (n+2); i++) 		rango[i] = i/k; 	Labeled_Tree_from_Prufer_Sequence("064660");//*/ 	while(scanf("%d%d", &n, &k)==2){ 		cont = cont2 = 0; /*		memset(c, 0, sizeof(c)); 		memset(dic, 0, sizeof(dic)); 		for(i = 0; i < (n+2); i++) 			rango[i] = i/k; 		m = n+2;//*/ //		genera(0); //		imprime(); //		cout << "cont = " << cont <<" " << cont2 << " "<<formula_k_1(n+2)<< endl; /*		for(i = 0; i < m; i++) 			cout << c[i] << " "; 		cout << endl;//*/ 		cout << formula_general(n, k) << endl; 	} 	return 0; } 
 #include <bits/stdc++.h> using namespace std;  #if !ONLINE_JUDGE #include "debug.h" #else #endif  typedef long long int LL; typedef unsigned long long LLU; typedef long double LD;  #define INF 1500000000000000000LL #define MOD 1000000007 #define F first #define S second #define PB push_back #define MK make_pair #define LEN(vale) strlen(vale) #define SZ(vale) (int)vale.size() #define SQ(A) ((A)*(A)) #define FI(i,fa,fb) for(int i=fa;i<fb;++i) #define FD(i,fa,fb) for(int i=fa;i>fb;--i) #define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it)  #define bits(vale) __builtin_popcount(vale) #define VT vector  #define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val; #define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val;  #define ALL(a) (a.begin(),a.end()) #define LB (lower_bound) #define UB (upper_bound)  #define SI(vale) scanf("%d",&vale) #define PI(vale) printf("%d\n",vale) #define PIS(vale) printf("%d ",vale) #define SL(vale) scanf("%lld",&vale) #define PL(vale) printf("%lld\n",vale) #define PLS(vale) printf("%lld ",vale) #define SS(vale) scanf("%s",vale) #define PS(vale) printf("%s\n",vale) #define SLD(vale) scanf("%Lf",&vale) #define PLD(vale) printf("%0.12Lf\n",vale) #define NL printf("\n") #define TCS() int testcase; SI(testcase);while(testcase--)   typedef pair<int,int> PR; bool deb = false; const int N = 50011; const int LOGN = 32; int n,Ncount; bool mark[N];                                                                                                                                      int dp[N][LOGN+5],dep[N],in[N],T; int out[N],q[N]; // q stores query  vector<int >gr[N];     // tree stores auxiliary tree int deg[N];  void dfs(int v,int p) {      in[v] = ++T;      dp[v][0] = p;      for(int i=1;i<=LOGN;++i)           dp[v][i] = dp[dp[v][i-1]][i-1];      dep[v] = dep[p] + 1;      for(int i = 0;i<gr[v].size();i++) {           int u = gr[v][i];           if(u != p) {                dfs(u,v);           }      }      out[v] = T; }   int LCA(int a,int b) {      if(a == b)           return a;      if(dep[a] < dep[b]) swap(a,b);      int diff = dep[a] - dep[b];      int i = 0;      while(i < LOGN) {           if( (diff >> i) & 1)                a = dp[a][i];           i++;      }      if(a == b) return  a;      i = LOGN-1;      while(i >= 0) {           if(dp[a][i] != dp[b][i])                a = dp[a][i],b = dp[b][i];           i--;      }      return dp[a][0]; }   bool isAnc(int p,int u) {      return (in[p] <= in[u] && out[p] >= out[u]); }   bool comp(int aa,int ab) {      return in[aa] < in[ab]; }   int build_tree() {        // build auxiliary tree      set<int>st;      for(int i=0;i<Ncount;i++) st.insert(q[i]);      Ncount = 0;      for(auto it : st) {           q[Ncount++] = it;      }                   // find the unique nodes      int TNodes = Ncount;      sort(q,q+Ncount,comp);      for(int i=0;i<TNodes-1;i++) {           int lca = LCA(q[i],q[i+1]);           if(st.find(lca) != st.end())   // if parent already exists                continue;           q[Ncount++] = lca;           st.insert(lca);      }      sort(q,q+Ncount,comp);      stack<int>S;      S.push(q[0]);      for(int i=1;i<Ncount;i++) {           while((!isAnc(S.top(),q[i])))                S.pop();           deg[S.top()]++;           deg[q[i]]++;           S.push(q[i]);      }      return q[0]; }   void dfs2(int v,int p) {  }   void init() {      T = 0;      dp[1][0] = 0;      dfs(1,0); }   int main(){      //clock_t tStart = clock();      int t,m;      TCS(){           SI(n);SI(m);           FI(i,0,n+2)gr[i].clear();           FI(i,1,n) {                int u,v;                SI(u),SI(v);                gr[u].PB(v);                gr[v].PB(u);           }           init();           while(m--) {                SI(Ncount);                int orc = Ncount;                FI(i,0,Ncount) {                     SI(q[i]);                     mark[q[i]] = 1;                }                if(Ncount == 2) {                     PI(dep[q[0]]+dep[q[1]]-2*dep[LCA(q[0],q[1])]-1);                }                else {                     int root = build_tree();                     int ans = 0;                     FI(i,0,Ncount) if(deg[q[i]] == orc && !mark[q[i]]) {                          ans++; break;                     }                     PI(ans);                }                FI(i,0,Ncount) {                     mark[q[i]] = 0;                     deg[q[i]] = 0;                }           }      }      //exectime();      return 0;         }   
#include <cstring> #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <memory.h> #include <cassert>   using namespace std;   #define a HELLO_VECTOR   #define FILENAME "" #define INPUT_FILE FILENAME "in" #define OUTPUT_FILE FILENAME "out"   const int md = 1000000007;   inline void add(int &a, int b) {   a += b;   if (a >= md) {     a -= md;   } }   inline int mul(int a, int b) {   return (long long)a * b % md; }   const int N = 310;   vector <int> g[N]; int n; int lim[3]; bool was[N]; int size[N]; int f[N][N]; int prec[3][N][N]; int nf[N];   void precalc(int v, int col) {   was[v] = true;   size[v] = 1;   for (int j = 0; j <= n; j++) {     f[v][j] = 0;   }   f[v][0] = 1;   int sz = g[v].size();   for (int jj = 0; jj < sz; jj++) {     int u = g[v][jj];     if (was[u]) {       continue;     }     precalc(u, col);     for (int j = 0; j <= size[u] + size[v]; j++) {       nf[j] = 0;     }     for (int j = 0; j <= size[v]; j++) {       for (int k = 0; k <= size[u]; k++) {         int p = j + k;         add(nf[p], mul(f[v][j], f[u][k]));       }     }     size[v] += size[u];     for (int j = 0; j <= size[v]; j++) {       f[v][j] = nf[j];     }   }   for (int j = 0; j <= n; j++) {     prec[col][v][j] = f[v][j];   }   for (int j = lim[col] - 1; j >= 0; j--) {     add(f[v][j + 1], f[v][j]);   } }   int c[N][N]; int h[N][N]; int nh[N]; int ans;   void solve(int v, int col) {   was[v] = true;   size[v] = 1;   for (int j = 0; j <= n; j++) {     h[v][j] = 0;   }   h[v][0] = 1;   int sz = g[v].size();   for (int jj = 0; jj < sz; jj++) {     int u = g[v][jj];     if (was[u]) {       continue;     }     solve(u, col);     for (int j = 0; j <= size[u] + size[v]; j++) {       nh[j] = 0;     }     for (int j = 0; j <= size[v]; j++) {       for (int k = 0; k <= size[u]; k++) {         int p = j + k;         add(nh[p], mul(h[v][j], h[u][k]));       }     }     size[v] += size[u];     for (int j = 0; j <= size[v]; j++) {       h[v][j] = nh[j];     }   }   if (v == 1) {     for (int j = 0; j < lim[col]; j++) {       add(ans, h[v][j]);     }     return;   } //  for (int j = 0; j <= size[v]; j++) { //    cerr << "pre:  " << v << " " << j << " " << h[v][j] << endl; //  }   nh[0] = 0;   for (int j = 0; j <= size[v]; j++) {     nh[j + 1] = h[v][j];   }   for (int other = 0; other < 3; other++) {     if (other == col) {       continue;     }     int real = 0 + 1 + 2 - col - other;     for (int jj = 0; jj < size[v]; jj++) {       int mult = prec[real][v][jj];       if (mult == 0) {         continue;       }       int c_or_o = size[v] - jj - 1; //      cerr << "other " << other << " " << real << " " << jj << " " << c_or_o << " mult " << mult << endl;       for (int cnt_c = 0; cnt_c <= c_or_o; cnt_c++) {         int cnt_o = c_or_o - cnt_c;         if (cnt_o + 1 > lim[other]) {           continue;         }         add(nh[cnt_c], mul(mult, c[c_or_o][cnt_c]));       }     }   }   for (int j = 0; j <= size[v]; j++) {     h[v][j] = nh[j]; //    cerr << "post: " << v << " " << j << " " << h[v][j] << endl;   } }   int main() {   for (int i = 0; i < N; i++) {     for (int j = 0; j < N; j++) {       if (j == 0) c[i][j] = 1; else       if (i == 0) c[i][j] = 0; else {         c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % md;       }     }   }   scanf("%d %d %d %d", &n, lim + 0, lim + 1, lim + 2);   for (int j = 0; j < 3; j++) {     if (lim[j] > n) {       lim[j] = n;     }   }   for (int i = 1; i <= n; i++) {     g[i].clear();   }   for (int i = 1; i <= n - 1; i++) {     int foo, bar;     scanf("%d %d", &foo, &bar);     g[foo].push_back(bar);     g[bar].push_back(foo);   }   for (int col = 0; col < 3; col++) {     for (int i = 1; i <= n; i++) {       was[i] = false;     }     precalc(1, col);   }   ans = 0;   for (int col = 0; col < 3; col++) {     for (int i = 1; i <= n; i++) {       was[i] = false;     }     solve(1, col); //    for (int j = 0; j <= lim[col]; j++) { //      add(ans, h[1][j]); //    }   }   printf("%d\n", ans);   return 0; } 
#include <iostream> #include <bits/stdc++.h>  using namespace std;  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n; 		vector<int>id(n); 		vector<int>sum(n); 		for(int i=0;i<n;i++) 		{ 			cin>>id[i]; 			cin>>sum[i]; 		} 		int total=0; 		for(int i=0;i<n;i++) 		{ 			total -= sum[i]; 		} 		for(int i=0;i<n;i++) 		{ 			total += id[i]; 		} 		cout<<total<<endl; 	} 	return 0; }
#include<iostream> #include<cstring> using namespace std; typedef long long ll; const int maxn=70; ll dp[maxn][maxn],ans,dp1[2][maxn]; int edge,head[maxn],next[maxn*2],ptr[maxn*2],n,lim,cases; void addedge(int x,int y) { edge++; next[edge]=head[x]; head[x]=edge; ptr[edge]=y; }   void dfs(int x,int fa) { int i,j,k,cur; dp[x][0]=1; for (i=head[x];i;i=next[i]) if (ptr[i]!=fa) dfs(ptr[i],x); memset(dp1[0],0,sizeof(dp1[0])); cur=0; for (i=head[x];i;i=next[i]) if (ptr[i]!=fa) { cur=1-cur; memset(dp1[cur],0,sizeof(dp1[cur])); for (j=1;j<=lim;j++) dp1[cur][j]+=dp[ptr[i]][j-1]; for (j=1;j<=lim;j++) if (dp1[1-cur][j]>0) { dp1[cur][j]+=dp1[1-cur][j]; for (k=0;k+1+j<=lim;k++) dp1[cur][max(k+1,j)]+=dp1[1-cur][j]*dp[ptr[i]][k]; } } for (i=1;i<=lim;i++) dp[x][i]+=dp1[cur][i]; }   int main() { // freopen("input.txt","r",stdin); // freopen("output.txt","w",stdout); for (scanf("%d",&cases);cases;cases--) { scanf("%d%d",&n,&lim); memset(head,0,sizeof(head)); edge=0; int i,j,x,y; for (i=1;i<n;i++) { scanf("%d%d",&x,&y); addedge(x,y); addedge(y,x); } memset(dp,0,sizeof(dp)); ans=0; dfs(0,-1); for (i=0;i<n;i++) for (j=0;j<=lim;j++) ans+=dp[i][j]; cout << ans << endl; } return 0; }
//Amit Gupta               //i #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 200010 #define endl '\n' #define FILL(ar,vl) for(int i=0;i<N;i++)ar[i]=vl #define FILL2(ar,vl) for(int i=0;i<N;i++)for(j=0;j<N;j++)ar[i][j]=vl //--------------------------MAIN CODE STARTS HERE---------------- int D,n; bool check(int m,int a[],int b[],int L) {     int d=0;int cost=a[0];int pos=-1;int f=0;int cnt=0;     while(d<n) {         cnt++;         while(D>=cost) {             if(b[d]<=m) {                 pos=d;             }             d++;             if(d==n)                 break;             cost+=a[d];         }         if(d==n)             break;         if(pos==-1) {             f=1;             break;         }         d=pos+1;         pos=-1;         cost=a[d];     }   //  TR2(m,cnt);   //  TR1(f);     if(f==1||cnt>L)         return false;     else         return true; }  int main() {	     int t;     SI(t);     while(t--) {         SII(n,D);         int a[n],b[n];         REP(i,0,n)             SII(a[i],b[i]);         int d=0;int cnt=0;int vl=a[0];         while(d<n) {             vl=a[d];             while(D>=vl)                 d++,vl+=a[d];             cnt++;         }         int L=cnt;         int l=0,h=n;         while(l<h) {             int m=l+(h-l)/2;             bool f=check(m,a,b,L);             if(!f)                 l=m+1;             else                 h=m;            // TR2(l,h);         }         if(L==1)             printf("%d %d\n",L,0);         else             printf("%d %d\n",L,l);     }     return 0; } 
//---------------------------JUGNU: LET YOUR LIGHT SHINE---------------------------// #include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> #include <map> #include <set> #define ll long long int #define pb push_back #define pf push_front #define sz size #define mk make_pair #define ln length #define fr(i,a,b) for(i=a;i<b;i++) #define fre(i,a,b) for(i=a;i<=b;i++) #define frr(i,a,b) for(i=a;i>=b;i--) #define sc(a) scanf("%d",&a) #define sm(a,b) scanf("%d%d", &a, &b) #define pr(a) printf("%d\n", a) #define pm(a,b) printf("%d %d\n", a, b) #define cn(a) cin >> a #define ct(a) cout << a << endl #define isset(x,i) ((x>>i)&1) #define fastScan ios_base::sync_with_stdio(0); cin.tie(NULL); #define MAXN 900005  #define trace1(x)       cerr << #x << " : " << x << endl; #define trace2(x, y)    cerr << #x << " : " << x << " | " << #y << " : " << y << endl; #define trace3(x, y, z) cerr << #x << " : " << x << " | " << #y << " : " << y << " | " << #z << " : " << z << endl; #define cline cout << "----------------------" << endl;  using namespace std;  typedef struct event{ 	int x, y, idx, type; 	event(){}; 	event(int A, int B, int C, int D){ 		x = A; 		y = B; 		idx = C; 		type = D; 	} }event;   vector< pair<int, int> > pointsCount[MAXN]; int result[MAXN], BIT[MAXN][2]; vector<event> events[MAXN]; set <pair<int, int> > S;  void update(int idx, int type){ 	while(idx < MAXN){ 		BIT[idx][type] += 1; 		idx += (idx & -idx); 	} 	return; }  int query(int idx, int type){ 	int sum = 0; 	while(idx > 0){ 		sum += BIT[idx][type]; 		idx -= (idx & -idx); 	} 	return sum; }  int main() { 	int i, j, t, n, m, k, l, r, mini, cnt = 0, maxi, flag, temp; 	sm(n, m); 	fr(i, 0, n){ 		sm(l, r); 		pointsCount[l + r].pb(mk(l, r)); 		S.insert(mk(l, r)); 	} 	fre(i, 1, m){ 		sm(l, r); 		sc(k); 		event temp0(l - 1, r - 1, i, 0); 		events[l + k + r].pb(temp0); 		event temp1(l - 1, r - 1, i, 1); 		events[l + r].pb(temp1); 	}  	fr(i, 2, MAXN){ 		cnt += (int)pointsCount[i].sz(); 		fr(j, 0, pointsCount[i].sz()){ 			update(pointsCount[i][j].first, 0); 			update(pointsCount[i][j].second, 1); 		} 		fr(j, 0, events[i].sz()){ 			l = query(events[i][j].x, 0); 			r = query(events[i][j].y, 1); 			if(events[i][j].type == 1){ 				if(S.find(mk(events[i][j].x + 1, events[i][j].y + 1)) != S.end()) temp = l + r - cnt + 1; 				else temp = l + r - cnt ; 				result[events[i][j].idx] += temp; 			} 			else{ 				temp = cnt - l - r; 				result[events[i][j].idx] += temp; 			} 		} 	} 	fre(i, 1, m) pr(result[i]);   return 0; } 
#include <iostream> #include <sstream> #include <vector> #include <string> #include <cstring> #define ll long long using namespace std;  ll t,n; string s,s1; vector<ll> v[105]; ll mod = 1000000007; ll dp[1024][105]; ll maxnum;  void clearV(){ 	for(ll i=0;i<=100;i++) 		v[i].clear(); }  void getInput(){  	cin >> n; 	clearV(); 	getline(cin,s); 	 	for(ll i=0;i<n;i++){ 		getline(cin , s); 		stringstream ss(s); 		int x; 		 		while(ss>>s1){ 			stringstream s2; 			s2 << s1; 			s2 >> x; 			 			v[x].push_back(i); 			 		} 		 	}  }  ll countways(ll mask,ll i){ 	 	if(mask==maxnum) 		return 1; 	if(i>100) 		return 0; 	if(dp[mask][i]!=-1) 		return dp[mask][i]; 	 	ll r = countways(mask,i+1)%mod; 	 	for(ll j=0;j<v[i].size();j++){  		if(mask & (1<<v[i][j])) 			continue; 		 		ll tmp = countways(mask | (1<<v[i][j]),i+1); 		r += tmp; 		r %= mod; 		 	} 	dp[mask][i] = r; 	return r; 	 }   int main() { 	// your code goes here 	 	cin >> t; 	 	while(t--){ 		 		getInput(); 		memset(dp, -1, sizeof dp); 		maxnum = (1<<n)-1; 		cout << countways(0,1)<<endl; 		 		 	} 	 	 	return 0; }
#include <iostream> #include <algorithm> #include<string.h> #include <list> #include<queue> #include<vector> #include <cmath> #define mp make_pair using namespace std; #define pii pair<int,int> #define x first #define y second #define inf 100000000 int n,m,a[55],b[55]; int dp[55][55][65]; int solve(int n,int m,int t) {  	if(n==0&&m==0)return t;  	int &res=dp[n][m][t];  	if(res!=-1)return res;  	res=inf;  	if(n>0)  	res=min(res,min(a[n-1],t)+solve(n-1,m,abs(a[n-1]-t)));  	if(m>0)  	res=min(res,min(b[m-1],t)+solve(n,m-1,abs(b[m-1]-t)));  	return res; } int main() {   //freopen("in.txt","r",stdin);   int i;   while(~scanf("%d%d",&n,&m))   {     for(i=0;i<n;i++)scanf("%d",&a[i]);     for(i=0;i<m;i++)scanf("%d",&b[i]);     memset(dp,-1,sizeof(dp));     printf("%d\n",solve(n,m,0));   }   return 0; } 
#include <iostream> #include<stdio.h> #include <cstring> using namespace std;  int main() {         int t,i,a[100005];    long x,n;    cin>>t;    while(t--)    {        cin>>n;        for(i=0;i<n;i++)        cin>>a[i];        x=a[0];        for(i=1;i<n;i++)        {            x=x^a[i];        }        if(x==0)        printf("First\n");        else        {            if(n&1)            printf("Second\n");            else            printf("First\n");        }     }     return 0; }
#include<iostream> #include<stdio.h> #include<vector> using namespace std; vector<bool> tweets(1001,0); vector<int > ans; int main() {//freopen("input.txt","r",stdin); int n,k,index; string s; cin>>n>>k; vector<bool> v=tweets; int count=0; for(int i=1;i<=k;i++) { 	cin>>s; 	if(s[2]=='I') 	{ 		cin>>index; 		if(v[index]==0) 		{   count++; 			ans.push_back(count); 			v[index]=1; 		} 		else 		{ 			count--; 			ans.push_back(count); 			v[index]=0; 		} 	} 	else 	{ 	count=0; 	ans.push_back(count); 	v=tweets;	 	} } vector<int>::iterator i; for(i=ans.begin();i!=ans.end();i++) cout<<(*i)<<endl;	 }
#include<bits/stdc++.h> #define lli long long int #define vi vector<int>   using namespace std;   vi vis; int cont=1; vector<vi> adj;  int n,q,a,b; int values[100005],ini[100005],fin[100005];   void dfs(int u){ 	ini[u]=cont++; 	 	for(int i=0;i<adj[u].size();i++){ 		int v=adj[u][i]; 		if(ini[v]==0) dfs(v); 	}  	fin[u]=cont-1; }   struct BIT{ 	int tam;     vector<lli> ft;      BIT(int n) : ft(n + 1),tam(n+1){}          void adjust(int i, lli v) {         while(i<tam){             ft[i]+=v;             i+=i&-i;         }     }     lli rsq(int i){         lli sum=0;         while (i) {             sum+=ft[i];             i-=i&-i;         }         return sum;     }      lli rsq(int i,int j){     	return rsq(j)-rsq(i-1);     } };   int main(){ 	 	scanf("%d %d",&n,&q);   	adj.assign(n+1,vi());  	for(int i=1;i<=n;i++){ 		scanf("%d",&values[i]); 	}  	for(int i=0;i<n-1;i++){ 		scanf("%d %d",&a,&b); 		adj[a].push_back(b); 		adj[b].push_back(a); 	}  	dfs(1);  	BIT arbol(n);  	for(int i=1;i<=n;i++){ 		arbol.adjust(ini[i],values[i]); 	}  	string op; 	for(int i=0;i<q;i++){ 		cin>>op; 		if(op[0]=='U'){ 			scanf("%d %d",&a,&b); 			lli x=arbol.rsq(ini[a],ini[a]); 			arbol.adjust(ini[a],-x); 			arbol.adjust(ini[a],b); 		}else{ 			scanf("%d",&a); 			printf("%lld\n",arbol.rsq(ini[a],fin[a])); 		} 	}  	return 0; }   /*   4 5 1 2 3 4 1 3 3 2  4 3   */
#include <iostream> #include <cstring> #include <cstdio> #include <string> #include <set> #include <vector> #include <map> #include <cmath> #include <cstdlib> #define ll long long #define ldb long double #define ff first #define ss second #define pii pair <int, int> #define mp make_pair #define pb push_back #define sqr(a) ((a) * (a)) #define nextLine() {int c = 0; while ((c = getchar()) != 10 && c != EOF); } const ldb pi = fabsl(atan2l(0.0, -1.0)); const ldb eps = 1e-9; const int inf = 1 << 28; using namespace std;  int n, m, w, wrap[250], was[52], from[250], to[250]; int a[250][250]; int b[200];  void load() { 	cin >> n >> m; 	memset(wrap, 0, sizeof(int) * m); 	for (int i = 0; i < m; i++) 	{ 		scanf("%d%d", &from[i], &to[i]); 		from[i]--; 		to[i]--; 	} 	cin >> w; 	int g; 	for (int i = 0; i < w; i++) 	{ 		cin >> g; 		g--; 		wrap[g] = 1; 	} }   void solve(int test_number) { 	for (int i = 0; i < m; i++) 	{ 		memset(a[i], 0, sizeof(int) * (n + m)); 		a[i][from[i]] = 1; 		a[i][to[i]] = 1; 		if (wrap[i]) 		{ 			a[i][n + i] = 1; 			b[i] = 0; 		} 		else 			b[i] = 1;	 	} 	for (int i = 0; i < m; i++) 	{ 		int j; 		for (j = 0; j < n + m && a[i][j] == 0; j++); 		if (j == n + m) 		{ 			if (b[i] == 1) 			{ 				printf("NO\n"); 				return; 			} 		} 		for (int k = i + 1; k < m; k++) 		{ 			if (!a[k][j]) continue; 			for (int l = 0; l < n + m; l++) 				a[k][l] ^= a[i][l]; 			b[k] ^= b[i]; 		} 	} 	printf("YES\n"); } #define problem "a" int main() { 	#ifndef ONLINE_JUDGE 	freopen(problem ".in", "rt", stdin); 	freopen(problem ".out", "wt", stdout); 	#endif 	int tests; 	cin >> tests; 	nextLine(); 	for (int t = 0; t < tests; t++) 	{ 		load(); 		solve(t + 1); 	} 	return 0; }
#include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #include<set> #include<vector> using namespace std ;   const int MAXN = 100000; const int MAXLOG = 17;  int rank[MAXLOG+2][MAXN+5]; int ix[MAXN+5]; char str[MAXN+5]; int len; int MAXi;  int startIndex[MAXN+5]; int uniqueFrom[MAXN+5];   struct Answer{     int s,len;     Answer():         s(0),len(MAXN+1){}     Answer(int s,int len):         s(s),len(len){}     bool operator < (const Answer& that) const     {         if (len != that.len)return len < that.len;         return rank[MAXi-1][s] < rank[MAXi-1][that.s];     } };  set<Answer> active; vector<Answer> toremove[MAXN+5];  bool cmp(int i1,int i2) {     if (rank[MAXi-1][i1] != rank[MAXi-1][i2])return rank[MAXi-1][i1] < rank[MAXi-1][i2];     int half = 1<<(MAXi-1);     if (max(i1,i2)+half >= len)return i1 > i2;     return rank[MAXi-1][i1+half] < rank[MAXi-1][i2+half]; }  void suffixArrays() {     for (int c=0;c<len;c++){         rank[0][c] = str[c];         ix[c] = c;     }     for (MAXi=1;(1<<(MAXi-1))<=len;MAXi++){         sort(ix,ix+len,cmp);         rank[MAXi][ix[0]] = 0;         int cnt = 0;         for (int i=1;i<len;i++){             if (cmp(ix[i-1],ix[i]))cnt++;             rank[MAXi][ix[i]] = cnt;         }     }     return ; }  int lcp(int i1,int i2) {     int ret = 0;     for (int i=MAXi-1;i>=0;i--){         if (max(i1,i2)>=len)break;         if (rank[i][i1] == rank[i][i2]){             i1+=1<<i;             i2+=1<<i;             ret+=1<<i;         }     }     return ret; }   int main() {     //freopen("unique.in","r",stdin);     int c,c2;     scanf("%s",str);     len = strlen(str);     suffixArrays();     int prev = 0;     for (int i=0;i<len;i++){         int cur = 0;         if (i + 1 < len)             cur = lcp(ix[i],ix[i+1]);         uniqueFrom[ix[i]] = 1 + max(cur,prev);         prev = cur;     }     for (c=0;c<len;c++)         startIndex[c] = -MAXN-2;     //memset(startIndex,-1,sizeof(startIndex));     int maxi = -MAXN-2;     for (c=0;c<len;c++){         startIndex[c+uniqueFrom[c]-1] = c;         if (uniqueFrom[c] + c <= len){             active.insert(Answer(c,uniqueFrom[c]));             //printf("adds %d %d\n",c+1,uniqueFrom[c]);             toremove[c + uniqueFrom[c] - 1].push_back(Answer(c,uniqueFrom[c]));         }         Answer a1,a2;         if (!active.empty())             a1 = *active.begin();         a2 = Answer(maxi,c-maxi+1);         if (a2 < a1)             swap(a1,a2);         printf("%d %d\n",a1.s+1,a1.len,a2.s+1,a2.len);         maxi = max(maxi,startIndex[c]);         for (c2=0;c2<toremove[c].size();c2++)             active.erase(toremove[c][c2]);         //printf("* %d\n",maxi);     }     return 0; } 
#pragma comment(linker, "/STACK:1024000000,1024000000")  #include <iostream>  #include <stdlib.h>  #include <ctime>  #include <cmath>  #include <stdio.h>  #include <vector>  #include <algorithm>  #include <queue>  #include <string.h>  #include <map>  #include <set>  #include <assert.h> #define x first  #define y second  #define pb push_back  #define mp make_pair  #define vi vector<int>  #define pii pair<int,int>  #define ll long long  #define inf 1000000007  #define mod 1000000007 #define all(x) x.begin(),x.end()  #define N 100010 #define pi acos(-1.) #define DBG(x) cerr<<#x<<"="<<x<<"\n";  #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)  using namespace std;   int a[105][105],f[105]; pair<int,pii>q[10010]; int find(int a){return a==f[a]?a:f[a]=find(f[a]);} int main() {     int T,i,j,k,n,m;     scanf("%d",&T);     while(T--){         scanf("%d",&n);m=0;         for(i=0;i<n;i++)             for(j=0;j<n;j++){                 scanf("%d",&a[i][j]);                 if(a[i][j]>0&&i<j)q[m++]=mp(a[i][j],mp(i,j));             }         if(n==1){             if(a[0][0]==0)puts("-1");             else printf("%d\n",a[0][0]);             continue;         }         for(i=0;i<n;i++)f[i]=i;         sort(q,q+m);         ll ans=0;         for(i=0;i<m;i++){             int x=q[i].y.x,y=q[i].y.y;             x=find(x),y=find(y);             if(x==y)continue;             ans+=q[i].x;             f[y]=x;         }             m=0;         for(i=0;i<n;i++)if(f[i]==i)m++;         if(m>1)puts("-1");         else printf("%lld\n",ans*2);     }     return 0; }
#include <algorithm> #include <iostream> #include <sstream> #include <string> #include <vector> #include <queue> #include <set> #include <map> #include <cstdio> #include <cstdlib> #include <cctype> #include <cmath> #include <cstring> #include <ctime> #include <cassert> using namespace std; typedef long long LL; #define FOR(k, a, b) for (int k(a); k < (b); ++k) #define FORD(k, a, b) for (int k(b - 1); k >= (a); --k) #define REP(k, a) for (int k = 0; k < (a); ++k) #define ABS(a) ((a) > 0 ? (a) : -(a))  char c[1002][1002]; char ans[2000000]; int N, T;  char dirc[4] = {'U', 'D', 'R', 'L'}; int dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};  string findroute(const pair<int, int>& from, const pair<int, int>& to) {   vector<pair<pair<int, int>, string> > q;   q.push_back(make_pair(from, string()));   REP(i, q.size()) {     pair<int, int> actpos = q[i].first;     string actstr = q[i].second;     int row = actpos.first;     int col = actpos.second;     REP(j, 4) {       int nr = row + dir[j][0];       int nc = col + dir[j][1];       if (nr >= 0 && nr < N && nc >= 0 && nc < N && c[nr][nc] != '#') {         pair<int, int> npos = make_pair(nr, nc);         string ns = actstr + dirc[j];         if (npos == to) return ns;         q.push_back(make_pair(npos, ns));       }     }   }   return string(); }  int main(int argc, char* argv[]) { #ifdef HOME   freopen("in.txt", "r", stdin);   freopen("out.txt", "wb", stdout); #endif   scanf("%d", &T);    while (T--) {     scanf("%d", &N);     REP(i, N)     scanf("%s", c[i]);     vector<string> dr((N + 1) / 2);     vector<pair<int, int> > start((N + 1) / 2), finish((N + 1) / 2);     REP(r, (N + 1) / 2) {       vector<vector<bool> > used(2, vector<bool>(N, 0));       int row1 = 2 * r;       int row2 = 2 * r + 1;       if (row2 == N) {         row2 -= 2;         swap(row1, row2);       }       int row = row1;       int col = 0;       if (c[row][col] == '#') ++row;       start[r] = make_pair(row, col);       used[row - row1][col] = 1;       while (1) {         int otherrow = row == row1 ? row2 : row1;         // try to step up,down if it is not used or forbidden         if (c[otherrow][col] == '.' && !used[otherrow - row1][col]) {           // then step           if (row == row1) {             dr[r].push_back('D');             ++row;           } else {             dr[r].push_back('U');             --row;           }           used[row - row1][col] = 1;         } else if (col + 1 < N && c[row][col + 1] == '.') {           // step right           dr[r].push_back('R');           ++col;           used[row - row1][col] = 1;         } else if (col + 1 < N) {           // go back           if (row == row1) {             dr[r].push_back('D');             ++row;           } else {             dr[r].push_back('U');             --row;           }         } else {           finish[r] = make_pair(row, col);           break;         }       }     }     int pos = 0, dir = 0;     for (; pos < dr[0].length(); ++pos) ans[pos] = dr[0][pos];     FOR(i, 1, dr.size()) {       // connect i-1 finish with i       dir = 1 - dir;       if (dir) {         // connect i-1 finish with i finish         string str = findroute(finish[i - 1], finish[i]);         REP(j, str.size()) {           ans[pos] = str[j];           ++pos;         }         //         FORD(j, 0, dr[i].size()) {           char& c = dr[i][j];           switch (c) {             case 'R':               ans[pos] = 'L';               break;             case 'L':               ans[pos] = 'R';               break;             case 'U':               ans[pos] = 'D';               break;             case 'D':               ans[pos] = 'U';               break;             default:               assert(false);           }           ++pos;         }       } else {         // connect i-1 start with i start         string str = findroute(start[i - 1], start[i]);         REP(j, str.size()) {           ans[pos] = str[j];           ++pos;         }         //         REP(j, dr[i].size()) {           ans[pos] = dr[i][j];           ++pos;         }       }     }     ans[pos] = 0;     printf("%s\n", ans);   }   return 0; }
#include<iostream> #include<map> #include<stack> #include<queue> #include<cstdio> #include<algorithm> #include<cmath> #include<climits> #include<cstring> #include<vector>  using namespace std;  #define Inf INT_MAX  int temp[16],n,ans[16],d; int cost[16][16]; int dp[1<<16],cur[1<<16];  int calc(int mask,int x) {   int ret=0;    for(int i=0;i<n;i++)     {       if(mask & (1<<i)) 	{ 	  ret+=cost[i][x]; 	}      }   return ret; }    void fun() {   int all=(1<<n)-1;   int temp,c,nw;      for(int i=0;i<=all;i++)     {       dp[i]=Inf;       cur[i]=-1;     }   dp[0]=0;    for(int i=0;i<=all;i++)     {       for(int k=0;k<n;k++) 	{ 	  if(!(i & (1<<k))) 	    { 	      c=dp[i]+calc(i,k); 	      nw=i|(1<<k);  	      if(dp[nw]>c||(dp[nw]==c&&k<cur[nw])) 		{ 		  dp[nw]=c; 		  cur[nw]=k; 		} 	    }          }      }        int k;       k=all;        for(int i=n-1;i>=0;i--) 	{ 	  ans[i]=cur[k]+1; 	 	  k=k & (all-(1<<cur[k])); 	}       d=dp[all]; }    int main() {   int t;  // ....  No. of test cases:   scanf("%d",&t);    int m;    for(int tt=0;tt<t;tt++)     {        scanf("%d %d",&m,&n);        for(int i=0;i<=n;i++) 	for(int j=0;j<=n;j++) 	  cost[i][j]=0;         for(int i=0;i<m;i++) 	{  	  for(int j=0;j<n;j++) 	    scanf("%d",&temp[j]);  	  for(int j=0;j<n;j++) 	    for(int k=j+1;k<n;k++) 	      cost[temp[k]-1][temp[j]-1]++; 	}        fun();        printf("%d: ",d);       for(int i=0;i<n;i++) 	printf("%d ",ans[i]);       printf("\n");     }    return 0; } 
#include <bits/stdc++.h> using namespace std;   bool graph[26][26]; bool used[26]; int cnt[26]; char buffer[10000];   void rec(int pos) { 	for(int i=0; i<26; i++) 	{ 		if(graph[pos][i] && used[i]) 		{ 			used[i] = false; 			rec(i); 		} 	} }   int main() { 	int t; 	scanf("%d",&t);   	for(int casenum=1; casenum<=t; casenum++) 	{ 		int n; 		scanf("%d",&n);   		for(int i=0; i<26; i++) 		{ 			cnt[i] = 0; 			used[i] = false; 			for(int j=0; j<26; j++) 				graph[i][j] = false; 		}   		for(int i=0; i<n; i++) 		{ 			scanf("%s",buffer);   			int a = buffer[0]-'a'; 			int b = buffer[strlen(buffer)-1]-'a'; 			cnt[a]++; 			cnt[b]--; 			graph[a][b] = graph[b][a] = true; 			used[a] = used[b] = true; 		}   		for(int i=0; i<26; i++) 		{ 			if(used[i]) 			{ 				used[i] = false; 				rec(i); 				break; 			} 		}   		bool check = true; 		for(int i=0; i<26; i++) 		{ 			if(used[i]) 			{ 				check = false; 				break; 			} 		}   		if(!check) 		{ 			//puts("HURRAH"); 			puts("The door cannot be opened."); 			continue; 		}   		bool start = false; 		bool end = false; 		for(int i=0; i<26; i++) 		{ 			if(cnt[i]==0) 				continue; 			else if(cnt[i]==1 && !start) 				start = true; 			else if(cnt[i]==-1 && !end) 				end = true; 			else 			{ 				check = false; 				break; 			} 		} 		if(check && (end==start)) 			puts("Ordering is possible."); 		else 			puts("The door cannot be opened."); 	}   	return 0; }  
#include<cstdio> #include<cstdlib> #include<set> #include<algorithm> #include<string> #include<cstring> using namespace std; set<string>setting;  int main() { 	int n,d,i,j,k,r,T,c,exits[1000010],result[1000010]; 	char A[200],D[20]; 	string st; 	scanf("%d",&d); 	for(i=0;i<d;i++) 	{ 		scanf("%s",D); 		st=string(D); 		sort(st.begin(),st.end()); 		setting.insert(st); 	} 	scanf("%d %d",&r,&c); 	 	n=r*c; 	scanf("%d",&T); 	while(T--) 	{ 		k=0; 		for(i=0;i<r;i++) 		{ 			scanf("%s",&A[i*c]); 		} 		//printf("%s\n",A); 		//exit(0); 		k=1<<n; 		for(i=0;i<k;i++) 		{ 			st=""; 			for(j=0;j<n;j++) 			{ 				if(i&1<<j)st+=A[j]; 			} 			sort(st.begin(),st.end()); 			exits[i]=setting.count(st); 		} 		for(i=0;i<k;i++) 		{ 			result[i]=0; 			for(j=i;j;j=((j-1)&i)) 			{ 				if(exits[j] && result[j^i]==0) 				{ 					result[i]=1; 					break;	 				} 			} 		} 		if(result[k-1]==1) 		{ 			printf("Alice\n"); 		} 		else 		{ 			printf("Bob\n"); 		} 	} 	return 0; } 
    #include<iostream>     #include<string>     #include<algorithm>     #define ll long long int     using namespace std ;     int si ;     string s ;     int arr[100005][3] ;     inline ll answer(char a , char b, char c)     {     for(int i=0 ; i<si ; i++)     {     for(int j=0 ; j<3 ; j++)     {     arr[i][j]=0 ;     }     }     ll counter=0 ;     int tota=0 , totb=0 ,totc=0 ;     ll sumposa=0, sumposb=0, sumposc=0 ;     for(int i=0 ; i<si ; i++)     {     if(s[i]==a)     {     tota++ ;     sumposa+=i ;     arr[i+1][0]++ ;     }     else if (s[i]==b)     {     totb++ ;     sumposb+=i ;     arr[i+1][1]++ ;     }     else     {     totc++ ;     sumposc+=i ;     arr[i+1][2]++ ;     }     if(i!=0)     {     for(int j=0 ; j<3 ; j++)     {     arr[i][j]+=arr[i-1][j] ;     }     }     }     counter+=sumposa ;     counter-= (tota*(tota-1))/2 ;     for(int i=0 ; i<si ; i++)     {     if(s[i]==b)     {     counter+= i-arr[i][0] ;     }     }     for(int i=0 ; i<si ; i++)     {     if(s[i]==c)     {     counter+= i-arr[i][0]-arr[i][1] ;     }     }     counter-= (totb*(totb-1))/2 ;     counter-= (totc*(totc-1))/2 ;     return counter ;     }     int main()     {     int t ;     cin >> t ;     for(int i=0 ; i<t ; i++)     {     cin >> s ;     si = s.size() ;     ll mini = 10000000000ll ;     mini=min(mini,answer('r','g','b')) ;     mini=min(mini,answer('r','b','g')) ;     mini=min(mini,answer('g','r','b')) ;     mini=min(mini,answer('g','b','r')) ;     mini=min(mini,answer('b','r','g')) ;     mini=min(mini,answer('b','g','r')) ;     cout << mini << "\n";     }     return 0 ;     }  
#include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> #include <set> using namespace std; int x[25],y[25]; set<int > s; int main() { 	int t,n,m; 	cin>>t; 	while(t--) 	{     cin>>n>>m;     s.clear();     for(int i=1;i<=m;i++)     {     	cin>>x[i]>>y[i];     	if(i<=2)     	{ 	    	s.insert(x[i]); 	    	s.insert(y[i]); 	    }     	     }     if(m>2 ||m==2 && s.size()!=3)     cout<<"NO\n";     else     cout<<"YES\n"; 	}     return 0; }
#include <cstdio> #include <cstring> #include <algorithm> #include <vector> #include <queue>  using namespace std;  #define MAXN 13  struct node{     int mask,pos,dist;          node(){}          node(int _mask, int _pos, int _dist):         mask(_mask), pos(_pos), dist(_dist){} };  bool ok[1 << MAXN],visited[1 << MAXN][2];  int solve(int N,int K){     queue<node> Q;     Q.push(node((1 << N) - 1,0,0));          while(!Q.empty()){         node cur = Q.front();         Q.pop();                  if(cur.pos == 0){             for(int i = cur.mask;i > 0;i = ((i - 1) & cur.mask))                 if(__builtin_popcount(i) <= K && ok[cur.mask ^ i] && !visited[(cur.mask ^ i)][1]){                     visited[(cur.mask ^ i)][1] = true;                     Q.push(node((cur.mask ^ i),1,cur.dist + 1));                 }         }else{             int mask2 = ((1 << N) - 1) ^ cur.mask;             if(mask2 == (1 << N) - 1) return cur.dist;                          if(ok[mask2] && !visited[cur.mask][0]){                 visited[cur.mask][0] = true;                 Q.push(node(cur.mask,0,cur.dist + 1));             }                          for(int i = mask2;i > 0;i = ((i - 1) & mask2))                 if(__builtin_popcount(i) <= K && ok[mask2 ^ i] && !visited[cur.mask | i][0]){                     visited[cur.mask | i][0] = true;                     Q.push(node(cur.mask | i,0,cur.dist + 1));                 }         }     }          return -1; }  int main(){     int T,M,N,K;          scanf("%d",&T);          while(T--){         scanf("%d %d %d",&N,&M,&K);                  memset(ok,true,sizeof ok);                  for(int i = 0,x,y;i < M;++i){             scanf("%d %d",&x,&y);             --x; --y;             ok[(1 << x) | (1 << y)] = false;         }                  for(int mask = 0;mask < (1 << N);++mask){             if(!ok[mask]){                 for(int i = 0;i < N;++i)                     ok[mask | (1 << i)] = false;             }         }                  memset(visited,false,sizeof visited);                  printf("%d\n",solve(N,K));     }          return 0; }
#include<bits/stdc++.h> #define assn(n,a,b) assert(n<=b && n>=a) using namespace std; #define pb push_back #define mp make_pair #define clr(x) x.clear() #define sz(x) ((int)(x).size()) #define F first #define S second #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,b) for(int i=0;i<b;i++) #define rep1(i,b) for(i=1;i<=b;i++) #define pdn(n) printf("%d\n",n) #define sl(n) scanf("%lld",&n) #define sd(n) scanf("%d",&n) #define pn printf("\n") typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<int> VI; typedef vector<VI> VVI; typedef long long LL; #define MOD 1000000007  typedef vector < vector < LL > >  matrix; //define matrix matrix I;   //identity matrix  // multiply two matrices matrix multiply(matrix A, matrix B) {     int K=(int)A.size();     matrix C(K, vector<LL>(K));     rep(i, K) rep(j, K) rep(k, K)     {         C[i][j] = C[i][j] + (A[i][k] * B[k][j]) % MOD;         if(C[i][j]>=MOD)             C[i][j]-=MOD;     }     return C; }  //find N'th power of matrix T  matrix mpow(matrix T, LL N) {     if(N==0)return I;     if(N==1)return T;     matrix ret=mpow(T,N/2);     matrix ret1=multiply(ret,ret);     if(N%2==0)return ret1;     else return multiply(ret1,T); } int main() {     int t;     cin >> t;     while(t--)     {         LL N,n;         cin >> N >> n;         matrix even(n,vector < LL >(n));         //matrix for odd row         matrix odd(n,vector < LL >(n));          I.resize(n);                  //build the matrices         for(int i=0; i<n; i++)         {             I[i].resize(n);             I[i][i]=1;         }                  for(int i=0; i<n; i++)         {             odd[i][i]=1;             if(i-1>=0)                 even[i][i-1]=odd[i][i-1]=1;             if(i+1<n)                 even[i][i+1]=odd[i][i+1]=1;         }                  N-=1;         matrix T=multiply(even,odd);         matrix ans=mpow(T,N/2);         LL ret=0;         if(N%2)             ans=multiply(ans,even);         rep(i,n)rep(j,n)         {             ret += ans[i][j];             if(ret>=MOD)ret-=MOD;         }         cout << ret << endl;     }     return 0; }
#include <cstdio> #include <cstdlib> #include <cctype> #include <cmath> #include <iostream> #include <sstream> #include <cstring> #include <vector> #include<algorithm> using namespace std; int a[100005]; int ans[2500004];   int main() {     int i,j,k,n;     scanf("%d%d",&n,&k);     for(i=0;i<n;i++)scanf("%d",&a[i]);     sort(a,a+n);     int l=0;     for(i=1;i<n;i++){                      for(j=0;j+i<n;j++){if(l>10*k)break;else ans[l++]=a[j]^a[j+i];}                      } sort(ans,ans+l); for(i=0;i<k;i++)printf("%d ",ans[i]); printf("\n");   system("pause");       return 0;}
# #include<cstdio> # #include<set> # #include<cstring> # #include<algorithm> # using namespace std; #   # set<long long> hash; # long long state[40][40][20000]; # int len[40][40]; # pair<int,int> w[100000]; # int N,M,T; #   # void work0() # { # int s[3]={0,0,0}; # for (int i=0;i<T;i++) s[(M-w[i].second)%3]^=1; # if (M%2==0) {s[0]^=1;s[1]^=1;} # s[M%3]=0; # printf("%s\n", (s[0]+s[1])?"NO":"YES"); # } #   # void work1() # { # long long d=0; # for (int i=0;i<T;i++) # { # int s=(M-w[i].second)%len[N][w[i].first-1]+1; # d^=state[N][w[i].first-1][s]; # } #   # int A[45][45]; # memset(A,0,sizeof(A)); # for (int i=0;i<N;i++) # for (int j=0;j<N;j++) # if (state[N][i][M%len[N][i]+1]&(1LL<<j)) # A[j][i]=1; # for (int i=0;i<N;i++) # if (d&(1LL<<i)) A[i][N]=1; #   # int now=0; # for (int i=0;i<N;i++) # { # for (int j=now;j<N;j++) # if (A[j][i]) # { # for (int k=0;k<=N;k++) swap(A[j][k],A[now][k]); # break; # } # if (!A[now][i]) continue; # for (int j=now+1;j<N;j++) # if (A[j][i]) # for (int k=0;k<=N;k++) A[j][k]^=A[now][k]; # now++; # } # for (int i=now;i<N;i++) # if (A[i][N]) # { # printf("NO\n"); # return; # } # printf("YES\n"); # } #   # int main() # { # //freopen("input.txt","r",stdin); #   # for (int i=1;i<40;i++) # for (int j=0;j<i;j++) # { # long long *p=state[i][j]; # p[1]=(1LL<<j); # int k; # for (k=2;;k++) # { # p[k]=(p[k-1]^p[k-2]^(p[k-1]<<1)^(p[k-1]>>1))&((1LL<<i)-1); # if (p[k]==p[1] && p[k-1]==p[0]) break; # } # len[i][j]=k-1; # } #   # int Test; # for (scanf("%d",&Test);Test--;) # { # scanf("%d%d%d",&N,&M,&T); # //printf("%d %d\n",N,M); # for (int i=0;i<T;i++) scanf("%d%d",&w[i].first,&w[i].second); # if (N>M) # { # swap(N,M); # for (int i=0;i<T;i++) swap(w[i].first,w[i].second); # } # if (N==1) work0(); # else work1(); # } #   # } #   #  
#include <cstdio> #include <list> #include <cctype> #include <cstdlib> #include <cassert>  using namespace std;  typedef long long ll; const ll  M = 0x0100000000LL; const int L = 0x80000000;  struct TOKEN {     char type, op, pr;     int  v;     TOKEN(char type, int   v) : type(type), v(v)   {}     TOKEN(char type, char op) : type(type), op(op)     {         if (op == '!')             pr = 6;         else if (op == '^')             pr = 5;         else if (op == '/')             pr = 4;         else if (op == '*')             pr = 3;         else if (op == '+')             pr = 2;         else if (op == '-')             pr = 1;     } };  enum {OPERATOR, NUMBER};  list<TOKEN> tlist; int fact[51]; int ifact[51];  inline int pow(int a, int b) {     if (b < 0)         b = -b;      int prod = 1;     int term = a;     while (b!=0)     {         if (b&0x1)             prod *= term;         term *= term;         b /= 2;     }     return prod; }  ll gcd(ll a, ll b) {     while (b != 0)     {         ll tmp = a%b; a = b; b = tmp;     }     return a; }  void ext_euclid(ll a, ll b, ll &x, ll &y) {     x = 0; y = 1;     ll xx = 1, yy = 0, q, tmp;     while(b > 1)     {         q = a/b;         ll tmp = a % b; a = b; b = tmp;         tmp = x; x=xx-q*x; xx=tmp;         tmp = y; y=yy-q*y; yy=tmp;     } }  inline ll mul_inv(ll b, ll a) {     ll x, y;     ext_euclid(a, b, x, y);     return y>0? y : a + y; }  inline list<TOKEN>::iterator back_and_remove(list<TOKEN>::iterator it) {         it--;         it--;         it = tlist.erase(it);         it = tlist.erase(it);         return it; }  bool calculate(list<TOKEN>::iterator &it) {     char op   = it->op; it++;     int  a    = it->v;  it++;     int  b    = it->v;     int  dist = distance(tlist.begin(), it)-1;     if (op == '^')     {         int t = pow(a, b);         if (b < 0)         {             if (t == 0)                 return false;              ll sign = 1;             ll ttt  = t;             if (t < 0)             {                 sign = -1;                 ttt = llabs(t);             }             ll g = gcd(ttt, M);             if (gcd(ttt, M) != 1)                 return false;             else             {                 ll inv_t = mul_inv(ttt , M)*sign;                 it->v = inv_t%M;             }                  assert(t * it->v == 1);         }         else             it->v = t;         it = back_and_remove(it);         printf("%d %c %d %d %d\n", dist, op, a, b, it->v);         return true;     }     else if (op == '/')     {         if (b == 0)         {             if (a != 0)                 return false;             else                 it->v = -pow(2,31);         }         else         {             ll sign = 1;             ll bbb = b;             if (b < 0)             {                 sign = -1;                 bbb = llabs(b);             }             ll g = gcd(bbb,M);             if ((ll)a % g != 0)                 return false;             else             {                 if (g == 1)                 {                     ll inv_b = mul_inv((ll)bbb , M) * sign;                     it->v = (inv_b*a)%M;                 }                  else                 {                     ll aa = (ll)a / g;                     ll bb = bbb   / g;                     ll mm = M     / g;                      ll inv_bb = mul_inv(bb, mm) * sign;                     int t = (inv_bb*aa)%mm;                     if (t < 0)                         t += mm;                     assert(L-t>=L+t);                     it->v = L+t;                     assert(a == b * it->v);                 }             }         }         assert(a == b * it->v);         //printf("a=%d b=%d q=%d,  b*q = %d\n", a, b, it->v,  b*it->v);         it = back_and_remove(it);         printf("%d %c %d %d %d\n", dist, op, a, b, it->v);         return true;     }     else if (op == '*')     {         it->v = a * b;         if (((ll)a*(ll)b-it->v)%M != 0)             assert(false);         it = back_and_remove(it);         printf("%d %c %d %d %d\n", dist, op, a, b, it->v);         return true;     }     else if (op == '+')     {         it->v = a + b;         if (((ll)a+(ll)b-(ll)it->v)%(ll)M != 0)             assert(false);         it = back_and_remove(it);         printf("%d %c %d %d %d\n", dist, op, a, b, it->v);         return true;     }     else if (op == '-')     {         it->v = a - b;         if (((ll)a-(ll)b-(ll)it->v)%(ll)M != 0)             assert(false);         it = back_and_remove(it);         printf("%d %c %d %d %d\n", dist, op, a, b, it->v);         return true;     }     //printf("OP=%c a=%d b=%d\n", op, a, b);     assert(false); }  inline int factorial(int i) {     if (i>40 || i<-40)         return 0;     else if (i >= 0)         return fact[i];     else          return ifact[-i]; }  void solve() {     // to calculate factorial     bool err=false;     for(;;)     {         list<TOKEN>::iterator one, two, thr, fou, fac, cal;         one = tlist.begin();         two = one; two++;         fac = tlist.end();         while(two != tlist.end())         {             if (one->type == OPERATOR && one->op == '!'                 && two->type == NUMBER)             {                 fac = one;                 break;             }             one++;             two++;         }          if (fac != tlist.end())         {             int  dist = distance(tlist.begin(), fac) + 1;             char op = fac->op;             fac = tlist.erase(fac);               int a = fac->v;             fac->v = factorial(fac->v);             printf("%d %c %d %d %d\n", dist, '!', a, -1, fac->v);             continue;         }          one = tlist.begin();         two = one; two++;         thr = two; thr++;         fou = thr; fou++;         cal = tlist.end();          while(fou != tlist.end())         {             if (one->type == OPERATOR                  && two->type == NUMBER                  && thr->type == NUMBER                  && fou->type == NUMBER)             {                 if(cal == tlist.end() || one->pr > cal->pr)                     cal = one;             }             one++;             two++;             thr++;             fou++;         }          if (cal != tlist.end())         {             if (!calculate(cal))             {                 err = true;                 break;             }             else                 continue;         }          one = tlist.begin();         two = one; two++;         thr = two; thr++;         fou = thr; fou++;         cal = tlist.end();         while(thr != tlist.end())         {             if (one->type == OPERATOR                  && two->type == NUMBER                  && thr->type == NUMBER)             {                 if(fou != tlist.end() && fou->type != NUMBER)                 {                     if(cal == tlist.end() || one->pr > cal->pr)                         cal = one;                 }                 else if (fou == tlist.end())                 {                     if(cal == tlist.end() || one->pr > cal->pr)                         cal = one;                 }             }             one++;             two++;             thr++;             fou++;         }          if (cal != tlist.end())         {             if (!calculate(cal))             {                 err = true;                 break;             }             else                 continue;         }         else             break;     }     //printf("TSIZE=%d\n", tlist.size());     if (!err & tlist.size() == 1 && tlist.begin()->type == NUMBER)         printf("OK\n");     else         printf("NOT OK\n"); }  // factorial 34!=0; int main() {     fact[0] = ifact[0] = 1;     for(int i=1; i<=50; i++)     {         fact[i]  = ((ll)i*(ll)fact[i-1])%M;         ifact[i] = ((ll)(-i)*(ll)ifact[i-1])%M;     }      //for(int i=1; i<=50; i++)     //{     //    printf("i=%d fact=%8x ifact=%8x\n", i, fact[i], ifact[i]);     //}      int T;     scanf("%d", &T);      for(int i=0; i<T; i++)     {         tlist.clear();         int N;         scanf("%d", &N);         for(int j=0; j<N; j++)         {             char t[100];             scanf("%s", t);             if (isdigit(t[0]) || (t[0] == '-' && isdigit(t[1])))                 tlist.push_back(TOKEN(NUMBER,   atoi(t)));             else                 tlist.push_back(TOKEN(OPERATOR, t[0]));         }         solve();     }     return 0; } 
#include<algorithm> #include<bitset> #include<cctype> #include<cmath> #include<cstring> #include<cstdio> #include<cstdlib> #include<ctime> #include<deque> #include<functional> #include<iomanip> #include<iostream> #include<list> #include<map> #include<numeric> #include<queue> #include<set> #include<sstream> #include<stack> #include<string> #include<utility> #include<vector>   using namespace std;   #define fore(i, a) for(int i = 0; i < (a); i++) #define forv(i, a) for(int i = 0; i < a.size(); i++) #define fort(i, a) for(typeof(a.begin()) i = a.begin(); i != a.end(); i++) #define all(x) x.begin(), x.end() #define pb push_back #define mp make_pair #define x first #define y second #define inf (1<<29)   #define err(...) //#define err(...) { fprintf(stderr, __VA_ARGS__); fflush(stderr); }   typedef long long ll; typedef vector<int> vi;   #define maxn 2173 #define MOD 1000000000   int huff[maxn][2], dp[maxn][2], temp[2][maxn]; int pref[maxn], cnt[maxn], all[maxn], binom[maxn], t[maxn], fac[maxn]; int n, sum;   inline int mult(int a, int b) { return (1LL * a * b) % MOD; }   int main() { 	scanf("%d", &n); 	fore(i,n) scanf("%d", &t[i]); 	sort(t, t+n);   	/* pref */ 	pref[0] = 0; 	for(int i = 1; i <= n; i++) pref[i] = pref[i-1] + t[i-1];   	/* cnt */ 	cnt[n-1] = 1; 	for(int i = n-2; i >= 0; i--) 		if(t[i] == t[i+1]) cnt[i] = cnt[i+1] + 1; 		else cnt[i] = 1;   	/* all */ 	all[0] = cnt[0]; 	for(int i = 1; i < n; i++) 		if(t[i] == t[i-1]) all[i] = all[i-1]; 		else all[i] = cnt[i];   	/* binom */ 	temp[0][0] = 1; 	temp[1][1] = 1; 	temp[1][0] = 1; 	for(int i = 1; i <= n; i++) 	{ 		bool flag = i&1; 		temp[flag][i] = 1; 		for(int j = 1; j < i; j++) 		{ 			temp[flag][j] = temp[!flag][j] + temp[!flag][j-1]; 			if(temp[flag][j] >= MOD) temp[flag][j] -= MOD; 		} 		for(int j = 1; j <= n; j++) if(all[j] == i) binom[j] = temp[flag][cnt[j]]; 	} 	binom[n] = 1;     	/* fac */ 	fac[0] = 1; 	for(int i = 1; i <= n; i++) fac[i] = mult(fac[i-1], (2*i-1));   	/* debug */ 	for(int i = 0; i <= n; i++) 	{ 		err("%d : ", i); 		for(int j = 0; j <= n; j++) err("%d ", temp[i][j]); 		err("\n"); 	} 	err("\n"); 	for(int i = 1; i <= n; i++) 	{ 		err("%d : ", i); 		for(int j = 1; j <= n; j++) err("%d ", huff[i][j]); 		err("\n"); 	} 	err("binom = "); fore(i,n+1) err("%d ", binom[i]); err("\n"); 	err(" pref = "); fore(i,n+1) err("%d ", pref[i]); err("\n"); 	err(" cnt  = "); fore(i,n) err("%d ", cnt[i]); err("\n"); 	err(" all  = "); fore(i,n) err("%d ", all[i]); err("\n");   	/* rozwiazanie */ 	dp[0][0] = 1; 	for(int p = 1; p <= n; p++) 	{ 		bool flag = p&1;   		/* huff */ 		sum = 0; 		priority_queue<int, vector<int>, greater<int> > q; 		fore(i,p) q.push(t[i]); 		while(q.size() > 1) 		{ 			huff[q.size()][flag] = sum; 			int u,v; 			u = q.top(); 			q.pop(); 			v = q.top(); 			q.pop(); 			sum += u+v; 			q.push(u+v); 		} 		huff[1][flag] = sum;   		/* dp */ 		for(int c = p; c > 0; c--) 		{ 			dp[c][flag] = 0; 			if(huff[c][flag] == huff[c-1][!flag]) 				dp[c][flag] = dp[c-1][!flag]; 			if(c*2 <= p && huff[c][flag] == huff[c*2][flag] + pref[p]) 				dp[c][flag] = mult(dp[c*2][flag], mult(binom[p], fac[c])) + dp[c][flag]; 			if(dp[c][flag] >= MOD) dp[c][flag] -= MOD; 			err("dp[%d][%d] = %d\n", c, p, dp[c][flag]); 		} 	}   	printf("%d %d\n", sum, dp[1][n&1]); }
#include <cstdio> #include <iostream> #include <vector> #include <string> #include <cctype> #include <cstring> #include <cstdlib> #include <set> #include <map> #include <queue> #include <utility> #include <functional> #include <algorithm> #include <numeric> #include <bitset> #include <cmath> #include <sstream> #include <complex> using namespace std;   #define pb push_back #define mp make_pair #define pii pair<int,int>   #define fo(i,n) for(int i=0; i < (n) ; ++i) #define FO(i,a,b) for(int i=a;i<=(b);++i) #define ALL(v) (v).begin(),(v).end() #define SORT(v) sort(ALL(v)) #define REV(v) reverse(ALL(v)) #define UNIQ(v) (v).erase(unique(ALL(v)),(v).end())   #define VDebug(x)  {fo(i,(x).size()) cout<<(x)[i]<<" ";cout<<endl;} #define VVDebug(x) {fo(j,(x).size()) VDebug(x[j])} 				      typedef istringstream iss; typedef ostringstream oss; typedef long long int lint; typedef complex<double> point; 				      typedef vector<int> VI; typedef vector<string> VS; typedef vector<VI> VVI; typedef vector<VS> VVS; 				      const char eof = -123;   void printBits(unsigned int x,int end = 32,int start = 0){for(int i = end-1;i>=start;i--) if(x & (1<<i)) cout<<1<<" "; else cout<<0<<" ";} int readInt(){	int x;if(scanf("%d",&x) != 1) return eof;return x;} char readChar() { char c; if(scanf("%c",&c) != 1) return eof; return c;} lint readLL(){lint x; if(cin>>x) return x; return eof;} double readDouble(){double f;if(scanf("%lf",&f) == 1)return f;return eof;}   int X1[5000], Y1[5000], X2[5000], Y2[5000]; int A1[5000], B1[5000], A2[5000], B2[5000]; int segX[5000][1100]; int segY[5000][1100];   #define DOSORT 1   #ifdef DOSORT #define mp4(a,b,c,d) mp(mp(a,b), mp(c,d)) #define X first #define Y second bool cmp(pair<pair<int,int>, pair<int,int> >  A, pair<pair<int,int>, pair<int,int> >  B){ 	return (A.X.X < B.X.X); } #undef X #undef Y #endif   vector<pair<pair<int,int>, pair<int,int> > >VP; main() { 	int n = readInt(); 	int m = readInt(); 	fo(i,n){ 		X1[i] = readInt(); 		Y1[i] = readInt(); 		X2[i] = readInt(); 		Y2[i] = readInt(); 		if(X1[i] == X2[i] && Y1[i] > Y2[i]) swap(Y1[i], Y2[i]); //x1 == x2 --> y1 <= y2 		if(X1[i] > X2[i]){ 			swap(X1[i], X2[i]); 			swap(Y1[i], Y2[i]); 		} // x1 <= x2 holds always   #ifdef DOSORT 		VP.pb(mp4(X1[i], Y1[i], X2[i], Y2[i])); #endif		 		A1[i] = X1[i], A2[i] = X2[i], B1[i] = Y1[i], B2[i] = Y2[i]; 		if(B1[i] == B2[i] && A1[i] > A2[i]) swap(A1[i], A2[i]); //b1 == b2 --> a1 <= a2; 		if(B1[i] > B2[i]){ 			swap(B1[i], B2[i]); 			swap(A1[i], A2[i]); 		} // b1 <= b2 holds always 	}   #ifdef DOSORT #define X first #define Y second 	sort(VP.begin(),VP.end(),cmp); fo(i,n) { 		X1[i] = VP[i].X.X, Y1[i] = VP[i].X.Y , X2[i] = VP[i].Y.X, Y2[i] = VP[i].Y.Y; 		A1[i] = X1[i], A2[i] = X2[i], B1[i] = Y1[i], B2[i] = Y2[i]; 		if(B1[i] == B2[i] && A1[i] > A2[i]) swap(A1[i], A2[i]); //b1 == b2 --> a1 <= a2; 		if(B1[i] > B2[i]){ 			swap(B1[i], B2[i]); 			swap(A1[i], A2[i]); 		} // b1 <= b2 holds always 	} #undef X #undef Y #endif   	fo(i,n){ 		for(int x=-20;x<=1043;x++){ 			if(X2[i] == X1[i]) continue; 			segY[i][x+20] = Y1[i] + (Y2[i] - Y1[i])* (x - X1[i])/(X2[i] - X1[i]) ; 		} 		for(int y=-20;y<=1043;y++){ 			if(Y2[i] == Y1[i]) continue; 			segX[i][y+20] = X1[i] + (X2[i] - X1[i])*(y - Y1[i])/(Y2[i] - Y1[i]); 		} 	} 	int result = 0; 	fo(t,m){ 		int x = readInt(); 		int y = readInt(); 		int l = readInt(); 		x ^= result; y ^= result; 		int a = x-l, c = x + l, b = y -l, d = y + l; 		 		int ret = 0; 		int end = upper_bound(X1, X1 + n, c) - X1; 		fo(k,min(n,end+1)){ 			if(X2[k] < a || X1[k] > c || B2[k] < b || B1[k] > d){ 			} 			else if(X1[k] == X2[k] || Y1[k] == Y2[k]) ret++; 			else if(Y1[k] < Y2[k]){ 				//going up  				if( segY[k][a + 20] <= d  				    && segY[k][c + 20] >= b) 				ret++; 			} 			else if(Y1[k] > Y2[k]){ 				//going down 				if(segY[k][a + 20] >= b 				   && segY[k][c + 20] <= d) 				ret++; 			} 		} 		result = ret; 	} 	cout<<result<<endl; }  
#include <iostream> #include <set> #include <vector>  typedef unsigned int uint;  #define MAXNODES 600 #define nullentry 0xffffffff  class Graph {   friend class RootedTree;   struct Node {     uint numedges;     uint edges[MAXNODES];   };   Node nodes[MAXNODES];   uint numnodes;   void clear() {     for (uint x = 0 ; x < MAXNODES ; x++) nodes[x].numedges = 0;     numnodes = 0;   } public:   Graph() { clear(); }   void addEdge(uint x, uint y) {     if (x >= numnodes) numnodes = x + 1;     if (y >= numnodes) numnodes = y + 1;     nodes[x].edges[(nodes[x].numedges)++] = y;     nodes[y].edges[(nodes[y].numedges)++] = x;   }   uint size() const { return numnodes; } };  class Stack {   std::vector<uint> stack;   uint pos; public:   Stack() : pos(0) { }   void push(uint x) {     if (pos == stack.size()) {       stack.push_back(x);       pos++;     } else {       stack[pos++] = x;     }   }   uint pop() { return stack[--pos]; }   uint size() { return pos; } };  class RootedTree {   struct Node {     uint parent;     uint firstchild;     uint nextsibling;     bool marked;     std::set<uint> criticalset;   };   Node nodes[MAXNODES];   uint size;   bool lexCompare(uint array1[], uint l1, 		  uint array2[], uint l2) {     for (uint x = 0 ; x < l1 && x < l2 ; x++)       if (array1[x] != array2[x]) return (array1[x] < array2[x]);     return (l1 < l2);   }   void doMe(uint r, uint children[], uint numchildren, 	    uint branchlabels[], uint unionlhats[], 	    uint scratch[], uint scratch2[]) {     uint unlabeled_branch = numchildren;     std::set<uint> K;     std::set<uint> lhat[numchildren];     for (uint i = 0 ; i < numchildren ; i++) {       branchlabels[i] = 0;       lhat[i] = nodes[children[i]].criticalset;     }     uint alpha, largestinlhat;     uint gamma, w;     uint counter;     while (unlabeled_branch) {       if ((++counter) == 20) break;       for (uint i = 0 ; i < size ; i++) unionlhats[i] = 0;       largestinlhat = 0;       for (uint i = 0 ; i < numchildren ; i++) { 	for (std::set<uint>::const_iterator it = lhat[i].begin() ; 	     it != lhat[i].end() ; ++it) { 	  unionlhats[*it] += 1; 	  if ((*it) >= largestinlhat) largestinlhat = (*it) + 1; 	}       }       if (K.size() < 2) { 	alpha = 0; 	for (uint i = 0 ; i < largestinlhat ; i++) 	  if (unionlhats[i] > 1) alpha = i; 	if (alpha) { 	  K.clear(); 	  for (uint i = 0 ; i < numchildren ; i++) 	    if (lhat[i].find(alpha) != lhat[i].end()) K.insert(i); 	} else { 	  K.clear(); 	  for (uint i = 0 ; i < numchildren ; i++) 	    if (branchlabels[i] == 0) K.insert(i); 	}       }       if (largestinlhat <= (alpha+1)) { 	w = K.size(); 	for (uint i = 0 ; i < numchildren ; i++) 	  unionlhats[branchlabels[i]] += 1;       } else { 	for (gamma = alpha + 1 ; unionlhats[gamma] == 0 ; gamma++) { } 	for (uint i = 0 ; i < numchildren ; i++) 	  unionlhats[branchlabels[i]] += 1; 	w = 0; 	for (uint i = alpha + 1 ; i < gamma ; i++) 	  if (unionlhats[i] == 0) w++;       }       if ((alpha > 0 && w < (K.size() - 1)) || 	  (alpha == 0 && w < K.size())) { 	uint x = gamma + 1; 	while (unionlhats[x]) x++; 	uint j = nullentry; uint jval = 0; 	for (uint i = 0 ; i < numchildren ; i++) { 	  uint isbest = 0; 	  for (std::set<uint>::const_iterator it = lhat[i].begin(); 	       it != lhat[i].end() ; ++it) { 	    // this is stupid.  you can do log instead of linear 	    // time.  but i'm lazy 	    const uint y = *it; 	    if (y < x) isbest = y; 	    else       break; 	  } 	  if (isbest > jval) { j = i; jval = isbest; } 	} 	if (branchlabels[j] == 0) unlabeled_branch--; 	branchlabels[j] = x; 	K.erase(j); 	while (lhat[j].size() && *(lhat[j].begin()) < x) { 	  lhat[j].erase(lhat[j].begin()); 	}	       } else if (alpha > 0) { 	uint currentlhattruncsize = 0; 	uint currenti0 = nullentry; 	for (std::set<uint>::const_iterator it = K.begin() ; 	     it != K.end() ; ++it) { 	  const uint i = *it; 	  uint compsize = 0; 	  for (std::set<uint>::const_iterator it2 = lhat[i].begin() ;  	       it2 != lhat[i].end() ; ++it2) { 	    const uint j = *it2; 	    if (j <= alpha) compsize++; 	    else break; 	  } 	  uint counter = 0; 	  for (std::set<uint>::const_iterator it2 = lhat[i].begin() ; 	       it2 != lhat[i].end() ; ++it2) { 	    if (counter == compsize) break; 	    scratch2[compsize-1-counter] = *it2; 	    counter++; 	  } 	  if (currentlhattruncsize == 0 || 	      lexCompare(scratch2, compsize, 			 scratch, currentlhattruncsize)) { 	    currentlhattruncsize = compsize; 	    for (uint x = 0 ; x < compsize ; x++) 	      scratch[x] = scratch2[x]; 	    currenti0 = i; 	  } 	} 	uint nextlabel = alpha; 	for (std::set<uint>::const_iterator it = K.begin() ; 	     it != K.end() ; ++it) { 	  const uint i = *it; 	  if (i != currenti0) { 	    nextlabel++; 	    while (unionlhats[nextlabel]) nextlabel++; 	    if (branchlabels[i] == 0) 	      unlabeled_branch--; 	    branchlabels[i] = nextlabel; 	    while (lhat[i].size() && *(lhat[i].begin()) < nextlabel) { 	      lhat[i].erase(lhat[i].begin()); 	    }     	  } 	} 	K.clear();       } else { 	uint nextlabel = 0; 	for (std::set<uint>::const_iterator it = K.begin() ; 	     it != K.end() ; ++it) { 	  nextlabel++; 	  while (unionlhats[nextlabel]) nextlabel++; 	  const uint i = *it; 	  branchlabels[i] = nextlabel; 	  unlabeled_branch--; 	  while (lhat[i].size() && *(lhat[i].begin()) < nextlabel) { 	    lhat[i].erase(lhat[i].begin()); 	  } 	} 	K.clear();       }     }     for (uint i = 0 ; i < numchildren ; i++) {       for (std::set<uint>::const_iterator it = lhat[i].begin() ; 	   it != lhat[i].end() ; ++it) 	nodes[r].criticalset.insert(*it);       nodes[r].criticalset.insert(branchlabels[i]);     }   } public:   RootedTree(const Graph& g, uint root) {     nodes[0].parent = nullentry;     nodes[0].firstchild = nullentry;     nodes[0].nextsibling = nullentry;     nodes[0].marked = false;     size = 1;     Stack stack;     stack.push(0);     std::vector<uint> nodeidxes(g.size());     nodeidxes[0] = root;     while (stack.size()) {       const uint r = stack.pop();       const uint s = nodeidxes[r];       const uint numedges = g.nodes[s].numedges;       const uint parent = 	(nodes[r].parent == nullentry) 	? nullentry 	: nodeidxes[nodes[r].parent];       uint currentsibling = nullentry;       for (uint i = 0 ; i < numedges ; i++) { 	const uint t = g.nodes[s].edges[i]; 	if (parent != t) { 	  nodeidxes[size] = t; 	  nodes[size].parent = r; 	  nodes[size].firstchild = nullentry; 	  nodes[size].nextsibling = nullentry; 	  nodes[size].marked = false; 	  if (currentsibling == nullentry) { 	    nodes[r].firstchild = size; 	  } else { 	    nodes[currentsibling].nextsibling = size; 	  } 	  currentsibling = size++; 	  stack.push(currentsibling); 	}       }     }   }   void print() const {     for (uint s = 0 ; s < size ; s++) {       uint child = nodes[s].firstchild;       while (child != nullentry) { 	std::cout << s << " -> " << child << '\n'; 	child = nodes[child].nextsibling;       }     }   }   void recursivelyDo() {     uint children[MAXNODES]; uint numchildren = 0;     uint branchlabels[MAXNODES];     uint scratch[MAXNODES], scratch2[MAXNODES], scratch3[MAXNODES];     Stack stack;     stack.push(0);     while (stack.size()) {       const uint r = stack.pop();       if (nodes[r].marked) { 	numchildren = 0; 	for (uint child = nodes[r].firstchild ; child != nullentry ; 	     child = nodes[child].nextsibling) { 	  children[numchildren++] = child; 	} 	doMe(r, children, numchildren, branchlabels, 	     scratch, scratch2, scratch3);       } else { 	stack.push(r); 	for (uint child = nodes[r].firstchild ; child != nullentry ; 	     child = nodes[child].nextsibling) { 	  stack.push(child); 	} 	nodes[r].marked = true;       }     }   }   uint largestLabel() const {     return *(nodes[0].criticalset.rbegin());   } };  void doTestCase() {   uint k;   std::cin >> k;   Graph g;   for (uint x = 1 ; x < k ; x++) {     uint y; std::cin >> y;     g.addEdge(x, y);   }   RootedTree rt(g, 0);   rt.recursivelyDo();   std::cout << rt.largestLabel() << '\n'; }  int main() {   uint t;   std::cin >> t;   for (uint c = 0 ; c < t ; c++) doTestCase();   return 0; } 
#include <iostream> #include <iomanip> #include <cstdlib> #include <cmath> #include <complex> #include <utility> #include <set> #include <queue>  using namespace std;  typedef complex<double> point; typedef pair<double, int> PDI;  const double INF = 1E100; const int MAX_P = 26;  struct edge {   int a, b; double fuel;   edge(int a_, int b_, double fuel_) : a(a_), b(b_), fuel(fuel_) {}   };  point getUV(double t, const point &p, const point &q, const point &r) {   point pp = p-q, rp = r-q;   point rh = rp / abs(rp);    point dc = conj(pp) * rh;   double u = dc.real() + dc.imag()/tan(t);   double v = dc.real() - dc.imag()/tan(t);   u /= abs(rp); v /= abs(rp);    if (u > v) swap(u, v);   return point(u, v);   }  int main() {   cout << fixed << setprecision(3);   int n, f, cNum = 0;   while ((cin >> n >> f) && n) {     double theta = acos(1.0 / f);      vector<point> verts;     for (int i = 0; i <= n; ++i) {       int x, y; cin >> x >> y;       verts.push_back(point(x, y));       }      vector<edge> edges;     for (int i = 0; i <= n; ++i)       for (int j = 0; j <= n; ++j)         if (j != i+1)           edges.push_back(edge(i, j, f*abs(verts[j]-verts[i])));      for (int j = 0; j < n; ++j) {       set<PDI> jumpPts;       for (int i = 0; i <= n; ++i) {         point uv = getUV(theta, verts[i], verts[j], verts[j+1]);         double u = uv.real(), v = uv.imag();         if ((0 < u) && (u < 1)) {           point t = verts[j] + u*(verts[j+1] - verts[j]);           int ti = verts.size();            verts.push_back(t); jumpPts.insert(PDI(u, ti));           edges.push_back(edge(ti, i, f*abs(verts[i] - t)));           }         if ((0 < v) && (v < 1)) {           point t = verts[j] + v*(verts[j+1] - verts[j]);           int ti = verts.size();            verts.push_back(t); jumpPts.insert(PDI(v, ti));           edges.push_back(edge(i, ti, f*abs(t - verts[i])));           }         }        int prev = j;       for (set<PDI>::const_iterator k = jumpPts.begin(); k != jumpPts.end(); ++k) {         edges.push_back(edge(prev, k->second, abs(verts[k->second] - verts[prev])));         prev = k->second;         }       edges.push_back(edge(prev, j+1, abs(verts[j+1] - verts[prev])));       }      int nV = verts.size();     vector< vector<edge> > g(nV);     for (vector<edge>::const_iterator i = edges.begin(); i != edges.end(); ++i)       g[i->a].push_back(*i);      vector<double> fuelTo(nV, INF); fuelTo[0] = 0;     priority_queue<PDI> q; q.push(PDI(0, 0));      while (!q.empty()) {       PDI t = q.top(); q.pop();        if (t.first == -fuelTo[t.second]) {         for (vector<edge>::const_iterator i = g[t.second].begin(); i != g[t.second].end(); ++i)           if (fuelTo[t.second] + i->fuel < fuelTo[i->b]) {             fuelTo[i->b] = fuelTo[t.second] + i->fuel;             q.push(PDI(-fuelTo[i->b], i->b));             }         }       }      cout << "Case " << ++cNum << ": " << fuelTo[n] << '\n';     }   } 
#include<iostream> #include<cstring> #include<string> #include<vector> #include<cassert> #include<algorithm> using namespace std; const int mx_nodes = 100;  enum Op { 	PL, 	MI, 	MU, 	ID };  struct Parse_Node { 	int id; 	Op op; 	Parse_Node * lc, * rc; 	int num_vars; };  string s; int n; long long l, h; long long a[15]; int match[mx_nodes]; int num_nodes; vector<pair<long long,int> > vals[mx_nodes][1 << 12];  Parse_Node* go(int lo, int hi) { 	while (match[lo] == hi - 1) lo ++, hi --; 	Parse_Node* res = new Parse_Node; 	int lvl = 0; 	int pos_pl = -1, pos_mi = -1, pos_mu = -1; 	for (int i = lo; i < hi; i ++) { 		if (s[i] == '(') lvl ++; else 		if (s[i] == ')') lvl --; else 		if (lvl == 0 && s[i] == '+') pos_pl = i; else 		if (lvl == 0 && s[i] == '-') pos_mi = i; else 		if (lvl == 0 && s[i] == '*') pos_mu = i; 	} 	int pos = -1; 	if (pos_pl >= 0) { 		res -> op = PL; 		pos = pos_pl; 	} 	else if (pos_mi >= 0) { 		res -> op = MI; 		pos = pos_mi; 	} 	else if (pos_mu >= 0) { 		res -> op = MU; 		pos = pos_mu; 	} 	else { 		res -> op = ID; 		res -> num_vars = 1; 	} 	if (pos >= 0) { 		res -> lc = go(lo, pos); 		res -> rc = go(pos + 1, hi); 		res -> num_vars = res -> lc -> num_vars + res -> rc -> num_vars; 	} 	res -> id = num_nodes ++; 	return res; }  Parse_Node* parse() { 	vector<int> a; 	memset(match,-1,sizeof(match)); 	int len = s.size(); 	for (int i = 0; i < len; i ++) { 		if (s[i] == '(') a.push_back(i); else 		if (s[i] == ')') match[a.back()] = i, a.pop_back(); 	} 	num_nodes = 0; 	return go(0, len); }  pair<long long, int> t[5000000]; // int its; void calc(Parse_Node* node) { 	int cnt_t; 	if (node -> op == ID) { 		for (int i = 0; i < n; i ++) { 			vals[node -> id][1 << i].push_back(make_pair(a[i], 1)); 		} 	} 	else { 		calc(node -> lc); 		calc(node -> rc); 		for (int i = 0; i < (1 << n); i ++) if (__builtin_popcount(i) == node -> num_vars) { 			cnt_t = 0; 			for (int i1 = i; i1 != 0; i1 = (i1 - 1) & i) if (__builtin_popcount(i1) == node -> lc -> num_vars) { 				// its += vals[node -> lc -> id][i1].size() * vals[node -> rc -> id][i ^ i1].size(); 				vector<pair<long long,int> >::iterator p1, p2; 				if (node -> op == PL) 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) 						t[cnt_t].first = (*p1).first + (*p2).first, 						t[cnt_t].second = (*p1).second * (*p2).second, 						cnt_t ++; 				else if (node -> op == MI) 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) 						t[cnt_t].first = (*p1).first - (*p2).first, 						t[cnt_t].second = (*p1).second * (*p2).second, 						cnt_t ++; 				else 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) 						t[cnt_t].first = (*p1).first * (*p2).first, 						t[cnt_t].second = (*p1).second * (*p2).second, 						cnt_t ++; 			} 			sort(t, t + cnt_t); 			for (int j = 0; j < cnt_t; j ++) { 				if (j < cnt_t - 1 && t[j + 1].first == t[j].first) 					t[j + 1].second += t[j].second; 				else vals[node -> id][i].push_back(make_pair(t[j].first, t[j].second)); 			} 		} 	} }  void solve() { 	cin >> n >> l >> h; 	for (int i = 0; i < n; i ++) cin >> a[i]; 	cin >> s; 	Parse_Node* root = parse(); 	for (int i = 0; i < mx_nodes; i ++) for (int j = 0; j < (1 << 12); j ++) vals[i][j].clear(); 	// cout << num_nodes << endl; 	calc(root); 	 	int res = 0; 	vector<pair<long long,int> > m = vals[root -> id][(1 << n) - 1]; 	vector<pair<long long,int> >::iterator it; 	for (it = m.begin(); it != m.end(); it ++) { 		if ((*it).first >= l && (*it).first <= h) res += (*it).second; 		// cout << (*it).first << " (" << (*it).second << ")" << endl; 	} 	int b[10]; memset(b,0,sizeof(b)); 	for (int i = 0; i < n; i ++) b[a[i]] ++; 	for (int i = 0; i < 10; i ++) { 		for (int j = 1; j <= b[i]; j ++) res /= j; 	} 	cout<<res<<endl; }  int main() { 	int T; cin >> T; while (T--) solve(); } 
#include <iostream> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <set> #include <map> #include <queue> #include <vector> #include <cstdlib> #include <fstream> #include <sstream> #include <deque> #include <cassert>  using namespace std;  #ifdef WIN32 	#define I64 "%I64d" #else 	#define I64 "%lld" #endif  typedef long long ll;  #define f first #define s second #define mp make_pair #define pb push_back #define all(s) s.begin(), s.end() #define sz(s) (int(s.size())) #define fname "a" #define ms(a,x) memset(a, x, sizeof(a)) #define forit(it,s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); ++it) #define MAXV 100001 #define MOD 1000000007 #define MAXN 100001 #define MAXM 505 #define MAXB 505 #define block 400  inline int add(int a, int b) { 	a += b; 	if (a >= MOD) 		a -= MOD; 	return a; }  inline int sub(int a, int b) { 	a -= b; 	if (a < 0) 		a += MOD; 	return a; }  inline int mult(int a, int b) { 	return (1LL * a * b) % MOD; }  int n, m; int a[MAXN]; int b[MAXM]; int lp[MAXV]; int pr[MAXV], npr; int num[MAXV]; vector <int> g[MAXV]; int p[MAXV]; int ansv[MAXM * MAXM]; vector < pair< pair<int, int>, int> > q; int curans; int k; int sq[MAXB][10001]; //int sq2[10][MAXB][10001]; int w[10001];  inline bool comp(pair< pair<int, int>, int> a, pair< pair<int, int>, int> b) { 	int ind1 = a.f.f / block; 	int ind2 = b.f.f / block; 	if (ind1 != ind2) return ind1 < ind2; 	return a.f.s > b.f.s; }  inline void process(int i) { 	int t = a[i]; 	while(t > 1) 	{ 		curans = sub(curans, mult(w[num[lp[t]]], w[num[lp[t]]])); 		w[num[lp[t]]]++; 		curans = add(curans, mult(w[num[lp[t]]], w[num[lp[t]]])); 		t = p[t]; 	} }  inline void process2(int i) { 	int t = a[i]; 	while(t > 1) 	{ 		curans = sub(curans, mult(w[num[lp[t]]], w[num[lp[t]]])); 		w[num[lp[t]]]--; 		curans = add(curans, mult(w[num[lp[t]]], w[num[lp[t]]])); 		t = p[t]; 	} }  inline int get(int L, int R) { /*	for (int i = L; i <= R; ) 	{ 		if (i % block == 0 && i + block - 1 <= R) 		{ 			int ind = i / block; 			for (int j = 0; j < npr; ++j) 				w[j] += sq[ind][j]; 			i += block; 		} 		else 		{ 			int t = a[i]; 			while(t > 1) 			{ 				w[num[lp[t]]]++; 				t = p[t]; 			} 			++i; 		} 	}*/ 	int res = 0; 	for (int i = 0; i < npr; ++i) 		res = add(res, mult(w[i], w[i])); 	return res; }  inline void solve() { 	for (int i = 2; i < MAXV; ++i) 	{ 		if (lp[i] == 0) 		{ 			lp[i] = i; 			num[i] = npr; 			pr[npr++] = i; 		} 		for (int j = 0; j < npr && pr[j] <= lp[i] && i * pr[j] < MAXV; ++j) 			lp[i * pr[j]] = pr[j]; 	}  	for (int i = 2; i < MAXV; ++i) 	{ 		int t = i; 		while(t % lp[i] == 0) 			t /= lp[i]; 		p[i] = t; 	} 	scanf("%d%d", &n, &m); 	for (int i = 0; i < n; ++i) 		scanf("%d", &a[i]); 	for (int i = 0; i < m; ++i) 		scanf("%d", &b[i]);  	k = n / block;  	for (int i = block - 1, z = 0; i < n; i += block, ++z) 		for (int j = 0; j < block; ++j) 		{ 			int pos = i - j; 			int t = a[pos]; 			while(t > 1) 			{ 				sq[z][num[lp[t]]]++; 				t = p[t]; 			} 		}  	q.clear(); 	for (int i = 0; i < m; ++i) 		for (int j = 0; j < m; ++j) 		{ 			int L = (b[i] + b[j]) % n; 			int R = (b[i] - b[j] + n) % n; 			if (L > R) swap(L, R); 			q.pb(mp(mp(L, R), i * m + j)); 		} 	 	sort(all(q), comp); 	curans = 0; 	int cl = 0, cr = 0; 	for (int i = 0; i < sz(q); ++i) 	{ 		int L = q[i].f.f; 		int R = q[i].f.s; 		while(cl < L) 			process2(cl++); 		while(cl > L) 			process(--cl); 		while(cr <= R) 			process(cr++); 		while(cr - 1 > R) 			process2(--cr); 		int ind = q[i].s; 		ansv[ind] = curans; 	}  	int ans = 0; 	for (int i = 0; i < m; ++i) 	{ 		int res = 1; 		for (int j = 0; j < m; ++j) 			res = mult(res, ansv[i * m + j]); 		ans = add(ans, res); 	} 	printf("%d\n", ans); }  int main() { 	#ifdef LOCAL 	freopen(fname".in", "r", stdin); 	freopen(fname".out", "w", stdout); 	#endif  	solve();  	return 0; } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 200050 #define ll long long struct Node  {  	Node *fa,*c[2];int Cnt,val,ad;ll sum;  } a[N*2],*emp,Emp,*rt; int bd[N][2],fi[N],c[N*2][2],val[N],ss=1,st,n,m;ll ans; inline int Read()  {  	int x=0;char y;bool z=false;  	do y=getchar(),z|=y=='-'; while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return z?-x:x;  } inline void Line(int x,int y)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } inline void GetNew(int x,int y)  {  	a[x].c[0]=a[x].c[1]=a[x].fa=emp;  	a[x].val=a[x].sum=y;a[x].Cnt=1;  	return;  } inline void Update(Node* x)  {  	x->sum=x->c[0]->sum+x->c[1]->sum+x->val;  	x->Cnt=x->c[0]->Cnt+x->c[1]->Cnt+1;  	return;  } inline void adj(Node* x)  {  	if (!x->ad||x==emp) return;  	x->val+=x->ad;x->sum+=1LL*x->Cnt*x->ad;  	for (int i=0;i<2;i++) x->c[i]->ad+=x->ad;  	x->ad=false;  	return;  } void Rotate(Node* x)  {  	Node *i=x->fa,*j=i->fa;bool flag=x==i->c[0];  	if (j!=emp) j->c[j->c[1]==i]=x;  	if (x->c[flag]!=emp) x->c[flag]->fa=i;  	i->c[!flag]=x->c[flag];i->fa=x;  	x->c[flag]=i;x->fa=j;Update(i);  	return;  } void Up(Node* x)  {if (x->fa!=emp) Up(x->fa);adj(x);adj(x->c[0]);adj(x->c[1]);} void Splay(Node* x)  {  	Up(x);  	while (x->fa!=emp)  	 {  	 	if (x->fa->fa!=emp)  	 	  Rotate((x->fa->fa->c[0]==x->fa)^(x->fa->c[0]==x)?  	 	  	x:x->fa);  	 	Rotate(x);  	 }  	Update(x);  	return;  } void Form(Node* x,Node* y)  {  	Splay(x);x->c[1]->fa=emp;rt=x;  	Splay(y);y->fa=x;x->c[1]=y;Update(x);  	return;  } Node* Right(Node* x,Node* y)  {  	while (x->c[1]!=emp) x=x->c[1];Splay(x);  	x->c[1]=y;y->fa=x;Update(x);return x;  } inline int Get(Node* x)  {  	for (int i=1;i<=n;i++)  	 for (int j=0;j<2;j++)  	  if ((&a[bd[i][j]])==x) return i*(j?1:-1);  	return 0;  } void DSF(Node* x)  {  	if (x==emp) return;  	cout <<Get(x)<<' '<<Get(x->c[0])<<' '<<Get(x->c[1])<<' '<<Get(x->fa);  	cout <<' '<<x->Cnt<<' '<<x->val<<' '<<x->sum<<endl;  	DSF(x->c[0]);DSF(x->c[1]);  	return;  } Node* DFS(int x,int y)  {  	bd[x][0]=++st;bd[x][1]=++st;  	GetNew(st-1,val[x]);GetNew(st,val[x]);  	Node* k=&a[st-1],*l=&a[st];  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=y)  	   k=Right(k,DFS(c[i][0],x));  	return Right(k,l);  } void Add(int x,int y)  {  	Form(&a[bd[x][0]],&a[bd[x][1]]);  	rt->val+=y;rt->c[1]->val+=y;rt->c[1]->c[0]->ad+=y;  	adj(rt->c[1]->c[0]);Update(rt->c[1]);Update(rt);  	return;  } inline Node* Aha(Node* x,bool flag)  {  	if (x->c[flag]!=emp)  	 {  	 	x=x->c[flag];while (x->c[!flag]!=emp) x=x->c[!flag];  	 } else  	 {  	 	while (x==x->fa->c[flag]) x=x->fa;  	 	x=x->fa;  	 }  	return x;  } void Del(int x)  {  	Form(Aha(&a[bd[x][0]],false),Aha(&a[bd[x][1]],true));  	rt->c[1]->c[0]=emp;Update(rt->c[1]);Update(rt);  	return;  } ll Query(int x)  {  	Form(&a[bd[x][0]],&a[bd[x][1]]);  	ans=(rt->c[1]->c[0]->sum+rt->c[1]->val+rt->val)/2;  	return ans;  } void Insert(int x,int y)  {  	bd[++n][0]=++st;bd[n][1]=++st;Node* k,*l;  	GetNew(st-1,y);GetNew(st,y);  	k=Right(&a[st-1],&a[st]);  	Splay(&a[bd[x][0]]);l=a[bd[x][0]].c[1];  	while (l->c[0]!=emp) l=l->c[0];  	Splay(l);l->c[0]->c[1]=k;k->fa=l->c[0];  	Update(l->c[0]);Update(l);  	return;  } int main()  {  	//freopen("input.txt","r",stdin);  	n=Read();emp=&Emp;emp->c[0]=emp->c[1]=emp->fa=emp;  	for (int i=1;i<=n;i++) val[i]=Read();  	for (int i=1;i<n;i++) Line(Read()+1,Read()+1);  	rt=DFS(1,0);m=Read();     while (m--)      {      	int e=Read(),k=Read()+ans+1;      	if (e==1) Insert(k,Read()); else      	if (e==2) Add(k,Read()); else      	if (e==3) Del(k); else printf("%lld\n",Query(k));      }  	return 0;  }
#pragma comment(linker, "/STACK:67108864")  #include<stdio.h> #include<string.h> #include<math.h> #include<stdlib.h> #include<ctype.h> #include<assert.h> #include<iostream> #include<vector> #include<stack> #include<queue> #include<set> #include<map> #include<string> #include<utility> #include<algorithm> #include<list> using namespace std;  #define CLR(a) memset(a,0,sizeof(a)) #define SET(a) memset(a,-1,sizeof(a)) #define pb push_back #define SZ(a) ((Long)a.size()) #define ALL(a) a.begin(),a.end() #define FOREACH(i, c) for( __typeof( (c).begin() ) i = (c).begin(); i != (c).end(); ++i ) #define AREA2(x1,y1,x2,y2,x3,y3) ( x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2) ) #define SQR(x) ((x)*(x)) #define STR string #define IT iterator #define ff first #define ss second #define MP make_pair #define EPS 1e-9 #define INF 1000000007  #define chk(a,k) ((bool)(a&(1<<(k)))) #define set0(a,k) (a&(~(1<<(k)))) #define set1(a,k) (a|(1<<(k)))  typedef long long Long; typedef vector<long> Vl; typedef vector<Long> VL; typedef pair<long,long> Pll; typedef pair<Long,Long> PLL;  inline Long FastMax(Long x, Long y) { return (((y-x)>>(32-1))&(x^y))^y; } inline Long FastMin(Long x, Long y) { return (((y-x)>>(32-1))&(x^y))^x; }  #define MAX 100007 #define MAXN 200007 #define MAXLG 22  char S[2*MAXN]; Long Q,N,lj,ljj; Long Ord[MAXLG][2*MAXN],t[2*MAXN][2]; Long A[2*MAXN], B[2*MAXN], C[2*MAXN], D[2*MAXN],Id[MAXN];  void tmp_CLR( Long *v, Long lim ) {     Long i;     lim = max( lim,301LL );     for( i=0;i<=lim;i++ ) v[i] = 0; }  void Build( void ){     Long i,j,k,jj;     //CLR( t );CLR( A );CLR( B );//CLR( C );//CLR( D );     tmp_CLR( A, N );tmp_CLR( B, N );     tmp_CLR( C, N );tmp_CLR( D, N );     for (i = 0; i < N; ++i) A[(Long)S[i]] = 1;     for (i = 1; i < max( N,301LL ); ++i) A[i] += A[i-1];     for (i = 0; i < N; ++i) Ord[0][i] = A[(Long)S[i]];     for (j = 0, jj = 1, k = 0; jj < N ; ++j, jj <<= 1){         //memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B));         tmp_CLR( A, 2*N+7 );tmp_CLR( B, 2*N+7 );         for (i = 0; i < N; ++i){             ++A[ t[i][0] = Ord[j][i] ], ++B[ t[i][1] = (i+jj<N) ? Ord[j][i+jj] : 0 ];         }         for (i = 1; i <= N; ++i) A[i] += A[i-1], B[i] += B[i-1];         for (i = N-1; i >= 0; --i) C[--B[t[i][1]]] = i;         for (i = N-1; i >= 0; --i) D[--A[t[C[i]][0]]] = C[i];         Ord[j+1][D[0]] = k = 1;         for (i = 1; i < N; ++i){             Ord[j+1][D[i]] = (k += (t[D[i]][0] != t[D[i-1]][0] || t[D[i]][1] != t[D[i-1]][1]));         }     }     lj = j; ljj = jj;     for( i=0;i<N;i++ ) Id[Ord[lj][i]] = i; } Long Lcp( Long x, Long y ){     Long k,j,jj, prf = 0;     for (j = lj, jj = ljj; j >= 0; --j, jj >>= 1)         if (x<N && y<N && Ord[j][x] == Ord[j][y]){             x   += jj; y   += jj; prf += jj;         }     return prf; }  Long par[MAXN+7]; Long child[MAXN+7]; vector<Long> adj[MAXN+7]; Long freq[MAXN+7]; Long last[MAXN+7];  Long Find( Long u ) {     if( par[u]==u ) return u;     else return par[u] = Find( par[u] ); }  void Union( Long u,Long v, Long i ) {     u = Find( u );     v = Find( v );     if( u==v ) return;     freq[child[u]] -= i*last[u];     freq[child[v]] -= i*last[v];     last[u] = last[v] = 0;     par[u] = v;     child[v] += child[u]; }  int main( void ) {     Long i,j,v,Icase,k = 0;      //freopen("text1.txt","r",stdin );      scanf("%lld",&Icase );     while( Icase-- ){         scanf("%s",S );         N = strlen( S );         Build();         for( i=2;i<=N;i++ ){             adj[Lcp( Id[i-1],Id[i] )].pb( i );         }         for( i=0;i<=N;i++ ){             par[i] = i;             child[i] = 1;             last[i] = 0;         }         for( i=N;i>=1;i-- ){             vector<Long> st;             for( j=0;j<adj[i].size();j++ ){                 k = adj[i][j];                 Union( Id[k-1], Id[k], i );                 st.pb( Find( Id[k] ) );             }             for( j=0;j<st.size();j++ ){                 st[j] = Find( st[j] );             }             sort( ALL( st ) );             st.resize( unique( ALL( st ) ) - st.begin() );             for( j=0;j<st.size();j++ ){                 last[st[j]] = child[st[j]];                 freq[child[st[j]]] += child[st[j]]*i;             }         }         freq[1] = (N*(N+1))/2;         for( i=N;i>=2;i-- ){             freq[i] += freq[i+1];         }         scanf("%lld",&Q );         while( Q-- ){             scanf("%lld",&v );             printf("%lld\n",freq[v] );         }         for( i=0;i<=2*N+1;i++ ){             adj[i].clear();             freq[i] = 0;         }     }      return 0; }    
#include <algorithm> #include <cstdio> #include <cstring> #include <vector> using namespace std;  typedef pair<int, int> pii;  template<class T> inline void chkmax(T& x, T y) { 	if (x < y) x = y; }  template<class T> inline void chkmin(T& x, T y) { 	if (y < x) x = y; }  struct Data { 	int a, b, id; 	 	bool operator<(const Data& d) const { 		return a < d.a; 	} };  struct Query { 	int st, en, c1, c2, id; 	 	bool operator<(const Query& q) const { 		return c2 < q.c2; 	} };  #define sz(x) int((x).size()) #define MX 200005 #define MC 30 int n; char s[MX]; int st[MC][MX], en[MC][MX]; Data dat[MC][MX]; Query q[MC][MX]; int Q, qn[MC]; int x[MX * 20], N; pii ans[MX];  void preprocess() { 	int i, x; 	vector<int> pos; 	 	n = strlen(s); 	pos.push_back(n); 	for (i = n - 1; i >= 0; i--) { 		pos.insert(pos.begin(), i); 		for (x = 1; x < sz(pos); x++) { 			if (s[i] == s[pos[x]]) break; 		} 		if (x < sz(pos)) pos.erase(pos.begin() + x); 		for (x = 1; x < sz(pos); x++) { 			st[x][i] = pos[x - 1]; 			en[x][i] = pos[x] - 1; 		} 		for (; x < MC; x++) { 			st[x][i] = MX; 			en[x][i] = MX; 		} 	} 	 	for (x = 1; x < MC; x++) { 		for (i = 0; i < n; i++) { 			dat[x][i].a = (st[x][i] == MX) ? -1 : st[x][i] - i + 1; 			dat[x][i].b = (en[x][i] == MX) ? -1 : en[x][i] - i + 1; 			dat[x][i].id = i; 		} 		sort(dat[x], dat[x] + n); 	} }  void build() { 	int i; 	 	for (N = 1; N < n; N *= 2); 	for (i = 0; i < N; i++) x[N + i] = -1; 	for (i = N - 1; i; i--) x[i] = max(x[i * 2], x[i * 2 + 1]); 	x[0] = max(x[1], x[2]); }  void update(int i, int a) { 	i += N; 	x[i] = a; 	for (i /= 2; i; i /= 2) x[i] = max(x[i * 2], x[i * 2 + 1]); 	x[0] = max(x[1], x[2]); }  int max_val(int st, int en) { 	int rlt; 	 	if (en == st + 1) return x[st]; 	if (en == st + 2) return max(x[st], x[st + 1]); 	 	rlt = max_val((st + 1) / 2, en / 2); 	if (st & 1) chkmax(rlt, x[st]); 	if (en & 1) chkmax(rlt, x[en - 1]); 	return rlt; }  int range_max(int st, int en) { 	return max_val(N + st, N + en); }  int main() { //	freopen("in.txt", "r", stdin); //	freopen("out.txt", "w", stdout); 	 	int i, x, len1, len2, L, R, M, k, id, prv; 	 	scanf("%s", s); 	preprocess(); 	scanf("%d", &Q); 	for (i = 0; i < Q; i++) { 		scanf("%d%d%d%d%d", &x, &len1, &len2, &L, &R); 		k = qn[x]; 		q[x][k].st = L, q[x][k].en = R - len1 + 1; 		chkmin(q[x][k].en, upper_bound(st[x], st[x] + n, R) - st[x] - 1); 		q[x][k].c1 = len1, q[x][k].c2 = len2; 		q[x][k].id = i; 		qn[x]++; 	} 	for (x = 1; x < MC; x++) { 		sort(q[x], q[x] + qn[x]); 		prv = 0; 		build(); 		for (k = 0; k < qn[x]; k++) { 			id = q[x][k].id; 			len1 = q[x][k].c1, len2 = q[x][k].c2; 			for (i = prv; i < n; i++) { 				if (dat[x][i].a > len2) break; 				update(dat[x][i].id, dat[x][i].b); 			} 			prv = i; 			L = q[x][k].st, R = q[x][k].en + 1; 			if (L >= R || range_max(L, R) < len1) { 				ans[id] = pii(-1, -1); 				continue; 			} 			while (R - L > 1) { 				M = (L + R) / 2; 				if (range_max(L, M) >= len1) R = M; 				else L = M; 			} 			R = max(st[x][L], L + len1 - 1); 			ans[id] = pii(L, R); 		} 	} 	for (i = 0; i < Q; i++) printf("%d %d\n", ans[i].first, ans[i].second); 	return 0; }
#include<iostream> #include<cstdio> #include<cstring> #include<stdlib.h> #include<malloc.h>   #define LL long long using namespace std;   LL rot[555555]; int rotSize;   int binarySearchLeft(int st,int ed,LL val){// cout<<st<<" "<<ed<<" l"<<val<<endl; getchar(); 	if( st==ed ){ if( rot[st]<=val ) return st; return st+1; } 	if( st+1==ed ){ 		if( val <= rot[st] ) return st; 		if( val <= rot[ed] ) return ed; 		return ed+1; 	} 	int m=(st+ed)/2; 	if( rot[m] > val ) return binarySearchLeft(st,m,val); 	else return binarySearchLeft(m,ed,val); }   int binarySearchRight(int st,int ed,LL val){ //cout<<st<<" "<<ed<<" r "<<val<<endl; getchar(); 	if( st==ed ){ if( rot[st]>=val ) return st; return st-1; } 	if( st+1==ed ){ 		if( val >= rot[ed] ) return ed; 		if( val >= rot[st] ) return st; 		return st-1; 	} 	int m=(st+ed)/2; 	if( rot[m] > val ) return binarySearchRight(st,m,val); 	else return binarySearchRight(m,ed,val); }   struct tri{ 	int size,*list;  	tri *child[11]; }*head,*headc;   void insert(tri *&head,char *s,int val){   	if( head==NULL ){ 		head=(tri*)malloc(sizeof(tri)); 		head->size=0;  		for(int i=0;i<11;i++) head->child[i]=NULL; 	} 		 	if( *s=='\0' ){  		if( head->size==0 ) head->list=(int*)malloc(sizeof(int)*150); 		head->list[ (head->size)++]=val;   		return ; 	} 	insert(head->child[ *s - '0' ],s+1,val);	 }   void find(tri*h,char *s,LL val){ 	if( h==NULL ) return; 	if( *s=='\0'){  		for(int i=0;i<h->size;i++) rot[rotSize++]=val+h->list[i];  		return ; 	} 	find(h->child[ *s-'0'],s+1,val); }   void make(int end,int len){  	head=headc=NULL;   int sz,b; char a[12]; 	for(int i=0;i<end;i++){  		sz=len; b=i;  int d[10]={0}; 		while( sz-- ) {  d[b%10]++; b/=10;} 		sz=len; b=i*2;  		while( sz-- ) {  d[b%10]--; b/=10;} 		sz=0; 		 		for(int j=9;j>=0;j--) 		  while( d[j]>0 ) { d[j]--; a[ sz++]='0'+j;} 		a[sz++]=':'; 		 		for(int j=9;j>=0;j--) 		  while( d[j]<0 ) { d[j]++; a[ sz++]='0'+j;} 		a[sz]='\0';   		if( b )	insert(headc,a,i);   		else  insert(head,a,i); 	} }       int main (){ 	int lenght=3;   	for(int i=1000;i<1000000;i*=10){ 		make(i,lenght); LL val=i; 	   int end=i/2,sz=0; char s[12];    	   for(int j=i/10;j<end;j++){ 			int d[10]={0},a,b; 			a=j; b=j*2;sz=0; 			while( a){ d[a%10]++; a/=10; d[ b%10]--; b/=10;}   			for(int k=9;k>=0;k--) 		   	while( d[k]<0 ) { d[k]++; s[ sz++]='0'+k;} 		   s[sz++]=':'; 		 		   for(int k=9;k>=0;k--) 		   	while( d[k]>0 ) { d[k]--; s[ sz++]='0'+k;} 		   s[sz++]='\0';	 		    		   find(head,s,j*val); 		   		    		   a=j; b=j*2+1;sz=0;  memset(d,0,sizeof(d)); 			while( a){ d[a%10]++; a/=10; d[ b%10]--; b/=10;}   			for(int k=9;k>=0;k--) 		   	while( d[k]<0 ) { d[k]++; s[ sz++]='0'+k;} 		   s[sz++]=':'; 		 		   for(int k=9;k>=0;k--) 		   	while( d[k]>0 ) { d[k]--; s[ sz++]='0'+k;} 		   s[sz++]='\0';	 		    		   find(headc,s,j*val);   		 } 		 		 if( lenght!=5 )  		 for(int j=i/10;j<end;j++){ 		   int d[10],a,b; 		    			for(int jj=0;jj<10;jj++){   				a=j*10+jj; b=j*20+jj*2; sz=0; memset(d,0,sizeof(d)); 				while( a){ d[a%10]++; a/=10; d[ b%10]--; b/=10;}   				for(int k=9;k>=0;k--) 		   		while( d[k]<0 ) { d[k]++; s[ sz++]='0'+k;} 		   	s[sz++]=':'; 		 		   	for(int k=9;k>=0;k--) 		   		while( d[k]>0 ) { d[k]--; s[ sz++]='0'+k;} 		   	s[sz++]='\0';	 		    		   	find(head,s,(j*10+jj)*val); 		    		    		   	a=jj; a=j*10+jj; b=j*20+jj*2+1; sz=0; memset(d,0,sizeof(d)); 				while( a){ d[a%10]++; a/=10; d[ b%10]--; b/=10;}   				for(int k=9;k>=0;k--) 		   		while( d[k]<0 ) { d[k]++; s[ sz++]='0'+k;} 		   	s[sz++]=':'; 		 		   	for(int k=9;k>=0;k--) 		   		while( d[k]>0 ) { d[k]--; s[ sz++]='0'+k;} 		   	s[sz++]='\0';	 		    		   	find(headc,s,(j*10+jj)*val);   			} 		    	   } 		lenght++; 	}		  	 	int testCase; scanf("%d",&testCase);  	while( testCase--){  	  LL a,b;scanf("%lld %lld",&a,&b); 	  printf("%d\n",binarySearchRight(0,rotSize-1,b)-binarySearchLeft(0,rotSize-1,a)+1); 	} 	return 0;		 }
#include<bits/stdc++.h> using namespace std; #define ll long long #define mod 1000000007LL #define f first #define s second #define mp make_pair #define pb push_back #define pii pair<int,int> vector< pair<ll,int> >v; ll dp[2011][2011]; ll a[2011],b[2011]; ll m[1000111]; map<ll,int>my; void update(int n,int b,int e,int x,ll v) {     if(b==e&&e==x)     {         m[n]=v;         return;     }     int l=2*n,mid=(b+e)/2;     if(x<=mid)         update(l,b,mid,x,v);     else         update(l+1,mid+1,e,x,v);     m[n]=m[l]+m[l+1];     if(m[n]>=mod)         m[n]-=mod; } ll query(int n,int b,int e,int x,int y) {     if(x>y)         return 0LL;     if(b>=x&&e<=y)     {         return m[n];     }     int l=2*n,mid=(b+e)/2;     if(y<=mid)         return query(l,b,mid,x,y);     else if(x>mid)         return query(l+1,mid+1,e,x,y);     else     {         ll m1=query(l,b,mid,x,mid)+query(l+1,mid+1,e,mid+1,y);         if(m1>=mod)             m1-=mod;         return m1;     } }  int main() {     int n,m1,i,j,k,l;     scanf("%d %d",&n,&m1);     for(i=0;i<n;i++)         scanf("%lld",&a[i]);     for(i=0;i<m1;i++)         scanf("%lld",&b[i]);     for(i=0;i<n;i++)     {         v.pb(mp(a[i],i));     }     sort(v.begin(),v.end());     for(i=0;i<n;i++)         my[v[i].s]=i;     for(i=0;i<n;i++)         dp[0][i]=1LL;     for(i=1;i<m1;i++)     {         for(j=0;j<i;j++)             update(1,0,n-1,my[j],dp[i-1][j]);         for(j=i;j<n;j++)         {             k=upper_bound(v.begin(),v.end(),mp(a[j]+b[i]-b[i-1]+1,-1))-v.begin();             dp[i][j]=query(1,0,n-1,0,k-1);             update(1,0,n-1,my[j],dp[i-1][j]);         }         for(j=0;j<4*n;j++)             m[j]=0; //        for(j=0;j<n;j++) //            printf("%lld ",dp[i][j]); //        printf("\n");     }     ll ans=0LL;     for(i=0;i<n;i++)     {         ans+=dp[m1-1][i];         if(ans>=mod)             ans-=mod;     }     printf("%lld\n",ans);     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<cstdlib> #include<map> #include<vector> #include<list> #include<set> #include<queue> #include<numeric> #include<sstream> #include<string> #include<cmath> #include<algorithm> #include<stack> using namespace std;  //#define inf 1001001010010010100ll #define pb		push_back #define mp 		make_pair #define EPS		1e-9 #define ll long long #define vi vector<int> #define pii pair<int,int> #define fi first #define se second #define inf 1000000000 #define mod 1009419529 #define N 300001 #define M 420 int dp[10102][102];char s[10110]; int seen[130],pre[10102]; int main() { 	//freopen("in.txt","r",stdin); 	int T,i,j,k,m,n,num; 	scanf("%d",&T); 	while(T--) 	{ 	 scanf(" %d%d",&n,&k);n+=k; 	 scanf(" %s",s+1); 	 memset(seen,0,sizeof(seen)); 	 for(i=1;i<=n;i++) 	 { 	  pre[i]=seen[s[i]]; 	  seen[s[i]]=i; 	 } 	 for(i=0;i<=n;i++) 	 for(j=0;j<=k;j++) 	 { 	  int &v=dp[i][j]; 	  if(j==0||i==j)v=1; 	  else if(i<j)v=0; 	  else 	  { 	   v=dp[i-1][j-1]+dp[i-1][j]; 	   if(pre[i]>0) 	   { 	    int d=i-pre[i]; 	    if(j>=d)v-=dp[pre[i]-1][j-d]; 	   } 	  } 	  if(v<0)v+=mod; 	  if(v>=mod)v-=mod; 	 } 	 int res=dp[n][k]-1; 	 if(res<0)res+=mod; 	 if(res>=mod)res-=mod; 	 printf("%d\n",res); 	} 	return 0; } 
/**  * January Cook-Off 2013  *  * Problem:     AVDWAST - Avoid Wasting  * Author:      Anton Lunyov (Tester)  * Complexity:  O(N^2) per test  * Timing:      0.32 out of 2.013  *  * Description:  * We calculate sum of all Vi and set for each pouch: Vi = min(Vi, 2 * Li).  * Then we categorize pouches as odd pouches (Vi is odd),  * even pouches (Vi is even and Vi<2*Li) and bad pouches (Vi==2*Li).  * We sort each group of pouches in descending order of U,  * and pouches with equal U in descending order of V.  * Because of the condition (if Vi<Vi then Ui<=Uj),  * the list of odd pouches is also sorted globally by V as well.  * Then we greedily take pouches.  * We have the current day U and the number of eaten food in it @eat = 0 or 1.  * At each step we calculate maxU = max Ui over not consumed pouches.  * maxU = 0 means that we consume all pouches.  * If U > maxU then we set U = maxU and eat = 0, if we are not in test_mode (see below).  * If U == 0 it means that we consume all pouches and we are done.  * Otherwise we have at least one not consumed pouch with Ui >= U.  * If eat == 0 we check them in order {bad, even, odd} and pick the pouch  * of first type in this list with Ui >= U.  * If eat == 1 we do the same for list {odd, even, bad}.  * Then in general we calculate @food as min(2*U-eat,Vi)  * and add @food to result, recalculate U and eat,  * mark the pouch as consumed and continue.  * But if eat==1 and we choose bad pouch we turn on the test_mode.  * We save current (res, U, eat, consumed pouches) and do a separate check.  * It is quite complicated to describe all further details.  * Hence refer to the code.  */ #include <iostream> #include <algorithm> #include <vector> using namespace std;  typedef long long LL;  struct pouch { 	LL V, U, L;  	pouch(){} 	pouch(LL V_, LL U_, LL L_): V(V_), U(U_), L(L_) {}  	bool operator < (const pouch &p) const { 		return U > p.U || U == p.U && V > p.V; 	} };  int main() { 	int T; 	cin >> T; 	for (int tst = 0; tst < T; ++tst) { 		int N; 		cin >> N;  		// A[0] - odd pouches 		// A[1] - good even pouches 		// A[2] - bad even pouches (V=2*L) 		vector<pouch> A[3]; 		LL sumV = 0; 		LL maxU = 0; 		for (int i = 0; i < N; ++i) { 			LL V, U, L; 			cin >> V >> U >> L; 			maxU = max(maxU, U); 			sumV += V; 			V = min(V, 2 * L); 			if (V == 2 * L) { 				// bad pouch 				A[2].push_back(pouch(V, U, L));  			} else { 				// V%2 == 0 - even pouch --> A[1] 				// V%2 == 1 - odd  pouch --> A[0] 				A[1-V%2].push_back(pouch(V, U, L)); 			} 		} 		for (int j = 0; j < 3; ++j) { 			sort(A[j].begin(), A[j].end()); 		} 		 		LL res = 0; // the total number of eaten food units 		// a[j] is the position of first not consumed pouch in list A[j] 		int a[3] = {0, 0, 0}; 		LL U = maxU; // the current day where we have some free slots for food 		int eat = 0; // the number of foods we have already eaten in day U  		bool test_mode = false; 		int empty = 0; // needed when we leave test_mode  		// temporary variables where we save 		// our current state of all stuff when turn on test_mode 		LL res_save = 0; 		int a_save[3]; 		LL U_save; 		int eat_save;  		while (true) { 			LL maxU = 0; // the maximal Ui over not consumed pouches 			for (int k = 0; k < 3; ++k) { 				if (a[k] < A[k].size()) { 					maxU = max(maxU, A[k][a[k]].U); 				} 			} 			// we have some free days between U and maxU (or at least one free slot on day U) 			if(U > maxU) { 				// in usual mode we simply set U to be maxU 				if (!test_mode) { 					U = maxU; 					eat = 0; 				} else { 					// otherwise we decide whether to revert all changes or return the answer  					// Here we have no pouches and have only one slot for food left in the first day 					// it means that our decision to use only 2*L-1 units from the bad pouch we test 					// was optimal and the value in @res is the actual answer 					if (maxU==0 && U==1 && eat==1) { 						break; 					} 					// otherwise we have a free day (possibly half of the maxU-th day will be used) 					// and we should revert our changes back 					test_mode = false; 					res = res_save; 					U = U_save; 					eat = eat_save; 					for (int k = 0; k < 3; ++k) { 						a[k] = a_save[k]; 					} 					// we should left empty slot at the U-th day now 					// hence we set this variable to 1 					empty = 1; 				} 			} 			// in both modes it means that we did not waste any food slot 			// other than obvious ones 			if (U == 0) { 				break; 			} 			int j; // the type of pouch we will consume now 			if (eat == 0) { 				// {bad, even, odd} = {2, 1, 0} 				for (j = 2; j >= 0; --j) { 					if (a[j] < A[j].size() && U <= A[j][a[j]].U) { 						// we find the pouch with Ui >= U 						break; 					} 				} 			} else { 				// {odd, even, bad} = {0, 1, 2} 				for (j = 0; j < 3; ++j) { 					if (a[j] < A[j].size() && U <= A[j][a[j]].U) { 						// as above we find the pouch with Ui >= U 						break; 					} 				} 			} 			// whether we use bad pouch for eat=1 			int bad = eat == 1 && j == 2; 			// empty = 1 means we already test this bad situation 			// test_mode = trues means we should analyze it by default 			if (bad && !test_mode && !empty) { 				// otherwise we turn on test_mode 				test_mode = true; 				// and save our current state 				res_save = res; 				U_save = U; 				eat_save = eat; 				for (int k = 0; k < 3; ++k) { 					a_save[k] = a[k]; 				} 			} 			// 2*U-eat is the total number of empty slots 			// we subtract @empty since after leaving the test_mode 			// we should left empty slot on day U 			LL food = 2 * U - eat - empty; 			// we subtract bad since in this case we should consume one less food from this pouch 			// but add @empty since when empty=1 then bad=1 and we decide to consume all foods. 			food = min(food, A[j][a[j]].V - bad + empty);  			res += food; // add @food to result  			// eat+empty+food is the total number of slots we will occupy now 			// (or left empty forever) starting from the day U backward 			U -= (eat + empty + food)/2; 			eat = (eat + empty + food)%2;  			++a[j]; // mark pouch A[j][a[j]] as consumed  			// always set to 0, it could 1 only after returning back from test_mode 			empty = 0; 		}  		// the actual results is sumV-res 		// since we need to return the number of wasted food 		cout << sumV - res << endl; 	} 	return 0; } 
#include <string> #include <vector> #include <algorithm> #include <cmath> #include <set> #include <queue> #include <map> #include <cstdio> #include <iomanip> #include <sstream> #include <iostream> #include <cstring> #define REP(i,x,v)for(int i=x;i<=v;i++) #define REPD(i,x,v)for(int i=x;i>=v;i--) #define FOR(i,v)for(int i=0;i<v;i++) #define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define REMIN(x,y) (x)=min((x),(y)) #define REMAX(x,y) (x)=max((x),(y)) #define pb push_back #define sz size() #define mp make_pair #define fi first #define se second #define ll long long #define IN(x,y) ((y).find((x))!=(y).end()) #define LOLDBG #ifdef LOLDBG #define DBG(vari) cerr<<#vari<<" = "<<vari<<endl; #define DBG2(v1,v2) cerr<<(v1)<<" - "<<(v2)<<endl; #else #define DBG(vari) #define DBG2(v1,v2) #endif #define CZ(x) scanf("%d",&(x)); #define CZ2(x,y) scanf("%d%d",&(x),&(y)); #define ALL(x) (x).begin(),(x).end() #define tests int dsdsf;cin>>dsdsf;while(dsdsf--) #define MOD 1000000007 using namespace std; typedef pair<int,int> pii; typedef vector<int> vi; template<typename T,typename TT> ostream &operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream &operator<<(ostream &s,vector<T> t){s<<"{";FOR(i,t.size())s<<t[i]<<(i==t.size()-1?"":",");return s<<"}"<<endl; }   ll mpow(ll a, ll b)// (a^b) % MOD {     a=a%MOD;     ll w=1;     while(b)     {         if (b%2) w=(w*a)%MOD;         a=(a*a)%MOD;         b/=2;     }     return w; }   ll inv(ll x) {     return mpow(x,MOD-2); }   ll licz(ll m, ll s, ll k) {     DBG(m);     ll wyn=1;     REP(i,1,k)     {         ll m1=1,m2=1;         FOR(j,m-k)             m1=(m1*(i+j))%MOD;         FOR(j,m-k)             m2=(m2*(s+i+j))%MOD;         wyn=(wyn*m2)%MOD;         wyn=(wyn*inv(m1))%MOD;         DBG(m1);         DBG(m2);     }     return wyn; }   int main() {     ios_base::sync_with_stdio(0);     tests     {         ll M,N,K;         cin>>N>>M>>K;         if (N%M==0) cout<<licz(M,N/M,K);         else if ((N%M)<=M-K)             cout<<licz(M-(N%M),N/M,K);         else             cout<<licz(N%M,N/M+1,K-(M-N%M));         cout<<endl;     }       return 0; }
//105514SN #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime>   using namespace std;   #define forn(i, a, b) for(int i=(a);i<int(b);i++) #define PB push_back #define MP(X,Y) make_pair(X,Y) #define SZ(X) ((int)(X.size())) #define ALL(x)   (x).begin(),(x).end() #define foreach(it, c)  for(typeof((c).begin()) it = (c).begin();it!=(c).end();++it) #define F first #define S second #define CLEAR(A, V) memset(A, V, sizeof(A))   typedef  long long   ll; typedef vector<int> VI; typedef vector<string> VS; typedef pair<int,int> II; typedef vector<II> VII;   template<class T> inline int countbit(T n){return (n==0)?0:(1+countbit(n&(n-1)));} template<class T> inline T gcd(T a, T b){ return b?gcd(b, a%b):a;} const double EPS = 1e-9; const double PI = acos(-1.0);   int n, m, nn, mm; vector<int> G[1001]; ll de[1001]; II ar[1001];     int main(void) {   	int casos; 	scanf("%d", &casos); 	forn(t, 0, casos) {   		memset(de, 0, sizeof(de)); 		forn(i, 0, 1001) G[i].clear();   		scanf("%d %d", &n, &m); 		nn = m, mm = 0; 		 		forn(i, 0, m) scanf("%d %d", &ar[i].F, &ar[i].S); 		forn(i, 0, m) forn(j, i+1, m) { 			if(ar[i].F == ar[j].F || ar[i].F == ar[j].S) { 				G[i].PB(j); de[i]++; 				G[j].PB(i); de[j]++; 				mm++; 			} 			else if(ar[i].S == ar[j].F || ar[i].S == ar[j].S) { 				G[i].PB(j); de[i]++; 				G[j].PB(i); de[j]++; 				mm++; 			} 		}   //		cout << nn << " " << mm << endl; //		forn(i, 0, nn) cout << de[i] << " "; //		cout << endl;   		ll retn = 0, retm = 0; 		forn(i, 0, nn) retn += de[i]*(de[i]-1) / 2LL;   		forn(i, 0, nn) forn(j, 0, SZ(G[i])) { 			ll d = de[i] + de[G[i][j]] - 2; 			retm += d*(d-1)/2LL; 		} 		 		printf("%lld %lld\n", retn, retm/2LL); 	}   	return 0; }  
// BNGAME, Setter's solution  #include <iostream> #include <set> #include <cstdio> #include <queue> #include <algorithm> using namespace std;  #define maxn 1000000 + 5  struct cell { 	int a, b, index; 	bool operator < (const cell & you) const { 		return a < you.a; 	} } board[maxn];  set<int> points, differences; // points if the set of non-prohibited cells, differences is a set of pairwise differences priority_queue<pair<int, int> > pq; // pq is non-prohibited cells, sorted by b int prev, next, diffs[maxn], n, m, i, j, ret = 2000000000;   void add_pnt (int t) { // adding the cell 	points.insert(t); // adding it to the set of non-prohibited ones 	set<int>::iterator it = points.find(t); 	--it; 	prev = *it; // finding the previous one 	++it; ++it; 	next = *it; // and the next one 	// recalculating differences: 	if (--diffs[next - prev] == 0) differences.erase(next - prev); 	if (++diffs[t - prev] == 1) differences.insert(t - prev); 	if (++diffs[next - t] == 1) differences.insert(next - t); }  void del_pnt (int t) { // deleting the cell 	set<int>::iterator it = points.find(t); 	--it; 	prev = *it; // finding the previous one 	++it; ++it; 	next = *it; // and the next one 	points.erase(points.find(t)); // deleting the point 	// recalculating differences: 	if (--diffs[t - prev] == 0) differences.erase(t - prev); 	if (--diffs[next - t] == 0) differences.erase(next - t); 	if (++diffs[next - prev] == 1) differences.insert(next - prev); }  int max_difference () { // finding the maximal difference (if less or equal to K, we can complete the game) 	set<int>::iterator it = differences.end(); 	return *(--it); }  int main (int argc, char * const argv[]) { 	scanf("%d %d", &n, &m); 	for(i = 1; i <= n; i++) { 		board[i].index = i; 		scanf("%d %d", &board[i].a, &board[i].b); 	} 	points.insert(0); // adding fictive 0 	points.insert(n + 1); // adding fictive n + 1 	differences.insert(n + 1); 	++diffs[n + 1]; 	sort(board + 1, board + n + 1); 	for(i = 1, j = 1; i <= 32000; i++) { 		while (j <= n && board[j].a == i) { // adding points with A = i 			add_pnt(board[j++].index); 			pq.push(make_pair(board[j - 1].b, board[j - 1].index)); 		} 		while (max_difference() <= m && pq.size() > 0) { // trying to delete some points 			del_pnt(pq.top().second); 			if (max_difference() <= m) pq.pop(); else { 				add_pnt(pq.top().second); 				break; 			} 		} 		if (max_difference() <= m) ret = min(ret, pq.top().first * i); // if the game can be completed, calculate the answer 	} 	printf("%d\n", ret);     return 0; } 
#include <stdio.h> #include <stdlib.h> #include <string.h> #include <time.h> #include <algorithm> #include <vector>  using namespace std;  #define LOCAL 0 #define USE_BRUTE_FORCE 0 #define DEBUG 0 #define NMAX 50011 #define SMAX 1111 #define HMAX 666  vector<int> vec[NMAX]; int N;  void ReadTree() { 	int i, j, k; 	if (LOCAL) { 		srand(12345); 		N = 30000; 	} else scanf("%d", &N); 	for (k = 1; k < N; k++) { 		if (LOCAL) { 			i = k + 1; 			//if (k <= 10) j = 1 + (rand() % k); 			//else j = k - 9 + (rand() % 10); 			j = k; 		} else scanf("%d %d", &i, &j); 		vec[i].push_back(j); 		vec[j].push_back(i); 	} }  vector<int> child[NMAX]; char visited[NMAX]; int parent[NMAX], level[NMAX], depth[NMAX], hmax, dfsmin[NMAX], dfsmax[NMAX], dfsnum;  void DFS1(int x) { 	visited[x] = 1; 	depth[x] = 0; 	if (level[x] > hmax) hmax = level[x]; 	dfsnum++; 	dfsmin[x] = dfsnum; 	for (int y = 0; y < vec[x].size(); y++) 		if (!visited[vec[x][y]]) { 			child[x].push_back(vec[x][y]); 			parent[vec[x][y]] = x; 			level[vec[x][y]] = level[x] + 1; 			DFS1(vec[x][y]); 			if (1 + depth[vec[x][y]] > depth[x]) 				depth[x] = 1 + depth[vec[x][y]]; 		} 	dfsmax[x] = dfsnum; }  int H; char special[NMAX]; int snode[SMAX], nsnode, snodeidx[NMAX], snode_depth[SMAX], sparent[NMAX]; int lidx[NMAX], clmin[NMAX][HMAX], clmax[NMAX][HMAX]; int cntidx[SMAX][HMAX];  void DFS2(int x, int sidx) { 	if (x != snode[sidx]) { 		sparent[x] = snode[sidx]; 		if (special[x]) return; 	} 	lidx[x] = ++cntidx[sidx][level[x] - level[snode[sidx]]]; 	clmin[x][0] = clmax[x][0] = lidx[x]; 	for (int j = 1; j < HMAX; j++) 		clmin[x][j] = clmax[x][j] = 0; 	for (int y = 0; y < child[x].size(); y++) { 		DFS2(child[x][y], sidx); 		for (int j = 1; j < HMAX; j++) { 			if (clmin[child[x][y]][j - 1] == 0) break; 			if (clmin[child[x][y]][j - 1] < clmin[x][j] || !clmin[x][j]) 				clmin[x][j] = clmin[child[x][y]][j - 1]; 			if (clmax[child[x][y]][j - 1] > clmax[x][j]) 				clmax[x][j] = clmax[child[x][y]][j - 1]; 		} 	} 	if (0&&DEBUG) { 		fprintf(stderr, "sidx=%d x=%d\n", sidx, x); 		for (int j = 0; j < HMAX; j++) { 			if (clmin[x][j] == 0) break; 			fprintf(stderr, "   j=%d: %d-%d\n", j, clmin[x][j], clmax[x][j]); 		} 	} }  void SelectSpecialNodes() { 	int i, j; 	for (H = 1; H * H < N; H++); 	//H = 100; 	if (DEBUG) fprintf(stderr, "H=%d hmax=%d\n", H, hmax); 	for (nsnode = 0, i = 1; i <= N; i++) 		if ((level[i] % H) == 0 && (depth[i] >= H || level[i] == 0)) { 			special[i] = 1; 			nsnode++; 			snode[nsnode] = i; 			snodeidx[i] = nsnode; 		} 	for (i = 1; i <= nsnode; i++) { 		DFS2(snode[i], i); 		snode_depth[i] = 0; 		for (j = 1; j < HMAX; j++) 			if (cntidx[i][j] > 0) { 				snode_depth[i] = j; 				cntidx[i][j] += cntidx[i][j - 1]; 			} 		if (DEBUG) { 			fprintf(stderr, "snode[%d]=%d: snode_depth=%d\n", i, snode[i], snode_depth[i]); 			for (j = 0; j < HMAX; j++) 				if (cntidx[i][j] > 0) { 					fprintf(stderr, "   j=%d: cnt=%d\n", j, cntidx[i][j]); 				} 		} 	} }  vector<int> snode_in_subtree[NMAX];  void DFS3(int x) { 	if (special[x]) snode_in_subtree[x].push_back(x); 	for (int y = 0; y < child[x].size(); y++) { 		DFS3(child[x][y]); 		for (int z = 0; z < snode_in_subtree[child[x][y]].size(); z++) 			snode_in_subtree[x].push_back(snode_in_subtree[child[x][y]][z]); 	} }  int lca[NMAX][SMAX];  void DFS5(int x, int special_node_idx, int lca_node) { 	lca[x][special_node_idx] = lca_node; 	//if (special_node_idx == 4) fprintf(stderr, "LCA(x=%d, sidx=%d)=%d\n", x, special_node_idx, lca_node); 	for (int y = 0; y < child[x].size(); y++) 		DFS5(child[x][y], special_node_idx, lca_node); }  void DFS4(int x) { 	for (int y = 0; y < snode_in_subtree[x].size(); y++) 		lca[x][snodeidx[snode_in_subtree[x][y]]] = x; 	for (int y = 0; y < child[x].size(); y++) { 		for (int z = 0; z < snode_in_subtree[child[x][y]].size(); z++) 			for (int w = 0; w < child[x].size(); w++) 				if (w != y) DFS5(child[x][w], snodeidx[snode_in_subtree[child[x][y]][z]], x); 		if (special[x]) { 			//fprintf(stderr, "---- %d %d\n", x, snodeidx[x]); 			DFS5(child[x][y], snodeidx[x], x); 		} 		DFS4(child[x][y]); 	} }  void ComputeLCAs() { 	DFS3(1); 	DFS4(1); }  char bfcovered[NMAX]; int qbf[NMAX], qli, qls, dbf[NMAX];  void BFCover(int x, int d) { 	memset(visited, 0, sizeof(visited)); 	qbf[qli = qls = 0] = x; 	visited[x] = bfcovered[x] = 1; 	dbf[x] = 0; 	 	while (qli <= qls) { 		int i = qbf[qli++]; 		if (dbf[i] == d) continue; 		for (int j = 0; j < vec[i].size(); j++) { 			int k = vec[i][j]; 			if (visited[k]) continue; 			visited[k] = bfcovered[k] = 1; 			dbf[k] = dbf[i] + 1; 			qbf[++qls] = k; 		} 	} }  void BFCheckAns(int ans) { 	int bfans = 0, i; 	for (i = 1; i <= N; i++) { 		bfans += bfcovered[i]; 	} 	if (bfans != ans) { 		fprintf(stderr, "ans=%d bfans=%d\n", ans, bfans); 		exit(2); 	} }  #define MAXINTV 20000000 int intv[MAXINTV][2], nextintv[MAXINTV], nintv; vector<pair<int, int> > cintv; vector<int> lev[SMAX]; int dmax[SMAX], touched[SMAX][HMAX], startintv[SMAX][HMAX], cntintv[SMAX][HMAX];  void ProcessOperations() { 	int Q, q, K, x, d, y, ans; 	int i, j, k, l, lca_node, di, dj, cnt1 = 0, cnt2 = 0, cnt3 = 0, cnt4 = 0;  	if (LOCAL) { 		Q = 50000; 	} else scanf("%d", &Q);  	for (q = 1; q <= Q; q++) { 		for (i = 1; i <= nsnode; i++) { 			lev[i].clear(); 			dmax[i] = -1; 		} 		nintv = 0;  		if (USE_BRUTE_FORCE) { 			memset(bfcovered, 0, sizeof(bfcovered)); 		}  		if (LOCAL) { 			K = 10; 		} else scanf("%d", &K); 		while (K--) { 			if (LOCAL) { 				x = 1 + (rand() % N); 				d = 1 + (rand() % N); 			} else scanf("%d %d", &x, &d); 			if (DEBUG) fprintf(stderr, "q=%d: x=%d d=%d\n", q, x, d); 			if (USE_BRUTE_FORCE) BFCover(x, d); 			for (i = 1; i <= nsnode; i++) { 				lca_node = lca[x][i]; 				di = d - (level[x] - level[lca_node]) - (level[snode[i]] - level[lca_node]); 				if (di > dmax[i]) dmax[i] = di; 				if (lca_node == snode[i] && di < snode_depth[i] && 					(x == snode[i] || sparent[x] == snode[i] || 					 d - level[x] + (level[snode[i]] + snode_depth[i]) >= 0)) { 					cnt1++; 					y = x; 					while (y != snode[i] && sparent[y] != snode[i]) { 						y = sparent[y]; 						cnt2++; 					} 					if (special[y] && y != snode[i]) y = parent[y]; 					j = snode_depth[i]; 					int check_dj = 1; 					while (j > dmax[i] && j >= 0) { 						cnt3++; 						if (check_dj) { 							dj = d - (level[x] - level[y]) - (level[snode[i]] + j - level[y]); 							if (dj < 0) { 								j--; 								continue; 							} 						} 						if (y != snode[i]) { 							dj = d - (level[x] - level[parent[y]]) - (level[snode[i]] + j - level[parent[y]]); 							if (dj >= 0) { 								y = parent[y]; 								check_dj = 0; 								continue; 							} 						} 						if (clmin[y][level[snode[i]] + j - level[y]] != 0) { 							cnt4++; 							// Node y is the highest node which can influence level j. 							if (DEBUG) { 								dj = d - (level[x] - level[y]) - (level[snode[i]] + j - level[y]); 								fprintf(stderr, "i=%d y=%d j=%d dj=%d: %d-%d\n", i, y, j, dj, clmin[y][level[snode[i]] + j - level[y]], clmax[y][level[snode[i]] + j - level[y]]); 							} 							if (touched[i][j] != q) { 								touched[i][j] = q; 								lev[i].push_back(j); 								startintv[i][j] = cntintv[i][j] = 0; 							} 							nintv++; 							if (nintv >= MAXINTV) exit(111); 							intv[nintv][0] = clmin[y][level[snode[i]] + j - level[y]]; 							intv[nintv][1] = clmax[y][level[snode[i]] + j - level[y]]; 							nextintv[nintv] = startintv[i][j]; 							startintv[i][j] = nintv; 							cntintv[i][j]++; 						} 						check_dj = 1; 						j--; 						if (level[snode[i]] + j < level[y]) y = parent[y]; 					} 				} 			} 		}  		ans = 0; 		for (i = 1; i <= nsnode; i++) { 			if (DEBUG) fprintf(stderr, "i=%d dmax=%d\n", i, dmax[i]); 			if (dmax[i] >= 0) { 				if (dmax[i] < snode_depth[i]) ans += cntidx[i][dmax[i]]; 				else ans += cntidx[i][snode_depth[i]]; 			} 			for (j = 0; j < lev[i].size(); j++) 				if (lev[i][j] > dmax[i]) { 					k = lev[i][j]; 					cintv.resize(cntintv[i][k]); 					nintv = 0; 					for (l = startintv[i][k]; l > 0; l = nextintv[l]) { 						cintv[nintv].first = intv[l][0]; 						cintv[nintv++].second = intv[l][1]; 					} 					sort(cintv.begin(), cintv.end()); 					for (di = 0, dj = -1, l = 0; l < nintv; l++) { 						if (cintv[l].first > dj) { 							ans += (dj - di + 1); 							di = cintv[l].first; 							dj = cintv[l].second; 						} else if (cintv[l].second > dj) 							dj = cintv[l].second; 						} 					ans += (dj - di + 1);		 				} 		} 		if (!LOCAL) printf("%d\n", ans); 		if (USE_BRUTE_FORCE) BFCheckAns(ans); 	}  	fprintf(stderr, "cnt1=%d cnt2=%d cnt3=%d cnt4=%d\n", cnt1, cnt2, cnt3, cnt4); }  int main() { 	int tstart = clock(); //	freopen("x.txt", "r", stdin); 	ReadTree(); 	DFS1(1); 	SelectSpecialNodes(); 	ComputeLCAs(); 	ProcessOperations(); 	fprintf(stderr, "Duration=%.3lf sec\n", (double) (clock() - tstart) / CLOCKS_PER_SEC); 	return 0; } 
/*..................... Author : PTY Time : 12/11/28 .....................*/ #include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <set> #include <queue> #include <stack> #include <fstream> #include <numeric> #include <iomanip> #include <bitset> #include <list> #include <stdexcept> #include <functional> #include <utility> #include <ctime> #include <complex> using namespace std;  #define rep(i,l,r) for(int i=l;i<=r;i++) #define drep(i,r,l) for(int i=r;i>=l;i--) #define max(a,b) (a>b?a:b) #define min(a,b) (a<b?a:b) #define LL long long #define Travel(E, u) for(int i=E.start[u],v;v=E.e[i].a,i;i=E.e[i].next) #define sqr(x) ((x)*(x)) #define pb push_back #define pi 3.1415926535897932384626433832795 #define read() (strtol(ipos, &ipos, 10)) const int maxn = 2124290, maxx = 50000008; int R, C, H, W, X, Y, K; int a[708][708], b[708][708], ans[708][708]; int tot; struct arr { 	int x, y, sco; 	arr(){} 	arr(int x1, int y1, int sco1){x = x1; y = y1; sco = sco1;} 	bool operator<(const arr &t)const 	{ 		return sco < t.sco || sco == t.sco && x < t.x || sco == t.sco && x == t.x && y < t.y;	 	} }tmp[708*708]; struct Tcomplex { 	double r, i; }; Tcomplex A[maxn], B[maxn]; int b1, b2, a1, a2, ta1[708], ta2[708]; char Input[maxx+8], *ipos; struct Tfft { 	Tcomplex W[maxn]; 	int n, H; 	int rev[maxn]; 	void init(int N) 	{ 		n = N; W[0].r = 1.0; W[0].i = 0; 		H = 0; while ((1<<H) < n) H++; 		int tmp = 1; Tcomplex w; 		rep(i,1,2*N-1) 		{ 			if (i == tmp)  			{ 				w.r = cos(2*pi/tmp); w.i = sin(2*pi/tmp); 				tmp<<=1; 			}	 			if (i & 1)  			{ 				W[i].r = W[i>>1].r * w.r - W[i>>1].i * w.i; 				W[i].i = W[i>>1].i * w.r + W[i>>1].r * w.i; 			} 			else W[i] = W[i>>1]; 		} 		rep(i,0,n-1) 		{ 			int s = 0, j = i; 			rep (k,1,H) s = (s << 1) + (j & 1), j >>= 1; 			rev[s] = i;	 		} 	} 	void dft(Tcomplex a[]) 	{ 		rep(i,0,n-1) if (rev[i] < i) swap(a[rev[i]], a[i]); 		Tcomplex *p, *p1, *p2; 		int i; 		for (int h = 0, s = 1; h < H; h++, s <<= 1) 		{ 			p = W + s + s; 			for (int st = 0; st < n; st += s + s, p = W + s + s) 				for (p1=a+st, p2=a+st+s, i = st; i < st + s; i++, p++, p1++, p2++) 				{ 					Tcomplex &v1 = *p1, &v2 = *p2; 					double tr = v2.r*p->r-v2.i*p->i, ti = v2.i*p->r+v2.r*p->i; 					v2.r = v1.r - tr; v2.i = v1.i - ti; 					v1.r += tr; v1.i += ti; 				} 		} 	} 	void cheng(Tcomplex A[], Tcomplex B[]) 	{ 		dft(A); dft(B); 		rep(i,0,n-1)  		{ 			double t = A[i].r; 			A[i].r = (A[i].r*B[i].r-A[i].i*B[i].i) / n; 			A[i].i = (t*B[i].i+A[i].i*B[i].r) / n; 		} 		dft(A); 		rep(i,1,n-1>>1) swap(A[i], A[n-i]); 	} }FFT; struct Tprogram {     void open(){freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);}     void close(){}     void init()     { 		fread(ipos=Input, 1, maxx, stdin); 		R = read(); C = read(); 		rep(i,0,R-1) rep(j,0,C-1) a[i][j] = read(); 		H = read(); W = read(); 		rep(i,0,H-1) rep(j,0,W-1) b[i][j] = read(); 		X = read(); Y = read(); X--; Y--; 		K = read();     }     void get_dian()     { 		int n1 = R, n2 = C; 		int n = 1; 		while (n < n1 * n2) n <<= 1; 		FFT.init(n); 		rep(i,0,R-1) rep(j,0,C-1) A[i*n2+j].r = a[i][j]; 		rep(i,0,H-1) rep(j,0,W-1) B[i*n2+j].r = b[H-i-1][W-j-1]; 		FFT.cheng(A, B); 		rep(i,0,n-1) 		{ 			int x = i / n2, y = i - n2 * x; 			if (x >= H - 1 && y >= W - 1)  				ans[x-H+1][y-W+1] = -2*round(A[i].r);  		} 	}     void others()     { 		rep(i,0,H-1) rep(j,0,W-1) b1 = b1 + b[i][j], b2 = b2 + b[i][j] * b[i][j];	 		rep(k,0,H-1) 			rep(j,0,C-1) 		 		ta1[j] += a[k][j], ta2[j] += a[k][j]*a[k][j]; 		rep(i,0,R-H) 		{ 			int a1 = 0, a2 = 0; 			rep(j,0,W-1) a1 += ta1[j], a2 += ta2[j]; 			rep(j,0,C-W) 			{ 				ans[i][j] += a2 + b2 + (a[i+X][j+Y])*(a[i+X][j+Y])*H*W - 2*a1*a[i+X][j+Y] + 2*b1*a[i+X][j+Y]; 				a1 -= ta1[j], a2 -= ta2[j]; 				a1 += ta1[j+W], a2 += ta2[j+W]; 			} 			rep(j,0,C-1) 				ta1[j] -= a[i][j], ta1[j] += a[i+H][j], 				ta2[j] -= a[i][j]*a[i][j], ta2[j] += a[i+H][j]*a[i+H][j]; 		} 	} 	void make_ans() 	{ 		rep(i,0,R-H) 			rep(j,0,C-W) tmp[++tot] = arr(i + 1, j + 1, ans[i][j]);	 		sort(tmp+1, tmp+tot+1); 		rep(i,1,K) 			printf("%d %d %d\n", tmp[i].x, tmp[i].y, tmp[i].sco); 	}     void work()     { 		get_dian();	 		others(); 		make_ans();     } }Program;  int main() {    // Program.open();     Program.init();     Program.work();     Program.close();     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<cstdlib> #include<cmath> #include<vector> #include<algorithm> #include<utility> #include<string> #include<map>       using namespace std;   typedef pair<int, int> pii; typedef unsigned long long ULL; typedef long long int LL;     #define PI acos(-1) #define MOD 1000000007 //functions come here ULL fac[40001]={1}; ULL invfac[40001]={1}; ULL power(ULL a,ULL b) { 	ULL c=1; 	while(b){ 		if (b&1) c=(c*a)%MOD; 		a=(a*a)%MOD; 		b>>=1; 	} 	return c; } ULL inv(ULL x){ 	return power(x,MOD-2); } ULL ncr(ULL n, ULL m) { 	if (m>n) return 0; 	ULL res=fac[n]; 	res=(res*invfac[m])%MOD; 	res=(res*invfac[n-m])%MOD; 	return res; } /* ULL gcd(ULL a, ULL b) {     if(a<b)         return gcd(b, a);     if(b==0 || a==b)         return a;     return gcd(b, a-(a/b)*b); } void div_gcd(ULL &a, ULL &b) {     ULL g = gcd(a, b);     a = a/g;     b = b/g; } ULL ncr(ULL n, ULL r) {     if(r==0 || n==r)         return 1;     if(n<r)         return 0;     if(r>n-r)         return ncr(n, n-r);     ULL nr =1, dr=1, mul, div;     for(int i=0; i<r; i++)     {         mul = n-i;         div = r-i;         div_gcd(nr, div);         div_gcd(mul, dr);         nr*=mul;         dr*=div;     }     return (nr/dr)%MOD; }*/ int main() {     int cases;     scanf("%d", &cases);     for(int i=1; i<40001; i++)         fac[i] = (i*fac[i-1])%MOD;     for(int i=1; i<40001; i++)         invfac[i]=inv(fac[i]);     while(cases--)     {         ULL n, m, r;         scanf("%llu %llu %llu", &n, &m, &r);         LL res = 0;         if(r<max(n, m))         {             printf("0\n");             continue;         }         for(int i=0; i<n; i++)         {             ULL a = ncr(n, i);             for(int j=0; j<m; j++)             {                   ULL term = ((a*ncr(m, j))%MOD*ncr((n-i)*(m-j), r))%MOD;                 if((i+j)&0x01)                     res -= term;                 else                     res += term;                 if(res<0)                     res+=MOD;                 res = res%MOD;             }         }         printf("%lld\n", res);     }     return 0; }
#include<cstdio> const int n=100005; int t,N,i; int T[n],A[n],B[n]; void sort(int l,int r) { 	int mid=(l+r)/2,k,k1,k2; 	if(l==r) return; 	sort(l,mid),sort(mid+1,r); 	T[mid]=A[mid]; 	for(k=mid-1;k>=l;--k) 		if(T[k+1]<A[k]) T[k]=T[k+1]; 		else T[k]=A[k]; 	k1=l,k2=mid+1; 	for(k=l;k<=r;++k) 	{ 		if(k1<=mid&&T[k1]<=A[k2]+1||k2>r) B[k]=A[k1++]; 		else B[k]=A[k2++]; 	} 	for(k=l;k<=r;++k) A[k]=B[k]; } int main() { 	for(scanf("%d",&t);t--;) 	{ 		scanf("%d",&N); 		for(i=1;i<=N;++i) scanf("%d",&A[i]); 		sort(1,N); 		for(i=1;i<N;++i) printf("%d ",A[i]); 		printf("%d\n",A[N]); 	} 	return 0; } 
#include <cmath> #include <queue> #include <set> #include <map> #include <iostream> #include <cstdio> #include <ctime> #include <cstring> #include <algorithm> using namespace std;   struct vertex { 	vertex *left, *right; 	int size, key, priority; 	bool reversed; } arr[100005];   int kol = 0;   int get_size(const vertex *cur) { 	if (!cur) { 		return 0; 	} else { 		return cur->size; 	} }   void update(vertex *cur) { 	if (cur == NULL) { 		return; 	} 	if (cur->reversed) { 		cur->reversed = false; 		swap(cur->left, cur->right); 		if (cur->left) { 			cur->left->reversed ^= 1; 		} 		if (cur->right) { 			cur->right->reversed ^= 1; 		} 	} }   void split(vertex *cur, int pos, vertex *&left, vertex *&right) { 	update(cur); 	if (cur == NULL) { 		left = NULL; 		right = NULL; 		return; 	} else if (get_size(cur->left) + 1 > pos) { 		split(cur->left, pos, left, cur->left); 		right = cur; 	} else { 		split(cur->right, pos - get_size(cur->left) - 1, cur->right, right); 		left = cur; 	} 	cur->size = get_size(cur->left) + get_size(cur->right) + 1; }   vertex *merge(vertex *left, vertex *right) { 	if (!left || !right) { 		return left ? left : right; 	} 	update(left); 	update(right); 	if (left->priority > right->priority) { 		left->right = merge(left->right, right); 		left->size = get_size(left->left) + get_size(left->right) + 1; 		return left; 	} else { 		right->left = merge(left, right->left); 		right->size = get_size(right->left) + get_size(right->right) + 1; 		return right; 	} }   void print(vertex *cur) { 	if (cur == NULL) { 		return; 	} 	update(cur); 	print(cur->left); 	printf("%d ", cur->key); 	print(cur->right); }   int get_rand() { 	return ((rand() & 0xfffd) << 15) | rand(); }   int main(){ 	srand(123456789); 	int n, m; 	scanf("%d%d", &n, &m); 	vertex *root = NULL; 	for (int i = 0; i < n; i++) { 		arr[i].key = i + 1; 		arr[i].priority = get_rand(); 		arr[i].left = NULL; 		arr[i].right = NULL; 		arr[i].reversed = false; 		arr[i].size = 1; 		root = merge(root, &arr[i]); 	} 	for (int i = 0; i < m; ++i) { 		int a, b, c; 		scanf("%d%d%d", &a, &b, &c); 		vertex *ap, *bp, *cp; //		making algo 		split(root, a, ap, root); 		split(root, b, bp, root); 		root = merge(ap, root); 		split(root, c, cp, root); 		bp->reversed = true; 		root = merge(bp, root); 		root = merge(cp, root);		 	} 	print(root); 	puts(""); 	return 0; } 
#include <cstdio> #include <algorithm> #include <vector> #include <cstring> #include <map> using namespace std; int N,Q; char P[100001]; int choice[100001]; map<int,int> calc; vector<int> w0[100001]; vector<long long> w1[100001]; vector<long long> w2[100001]; int D[100001]; int A[100001]; int out0[501][100001]; long long B[100001]; long long out1[501][100001]; long long C[100001]; long long out2[501][100001]; const int sqt = 200; int main() {     int T;     scanf("%d",&T);     for (int t=0;t<T;t++) {         scanf(" %s%d",&P,&Q);         N = strlen(P);         for (int i=1;i<=N;i++) choice[i] = choice[i-1]^(1<<(P[i-1]-'a'));         calc.clear();         for (int i=0;i<=N;i++) if (!calc.count(choice[i])) calc[choice[i]] = calc.size()-1;         for (int i=0;i<=N;i++) choice[i] = calc[choice[i]];         for (int i=0;i<=N;i++) w0[i].clear(), w1[i].clear(), w2[i].clear();         for (int i=0;i<=N;i++) {             D[i] = w0[choice[i]].size();             w0[choice[i]].push_back(i);             w1[choice[i]].push_back(i+(D[i]>0 ? w1[choice[i]][D[i]-1] : 0));             w2[choice[i]].push_back((long long) i*i+(D[i]>0 ? w2[choice[i]][D[i]-1] : 0));         }         for (int i=0;i*sqt<=N;i++) {             for (int j=0;j<=N;j++) A[j] = 0, out0[i][j] = 0, B[j] = 0, out1[i][j] = 0, C[j] = 0, out2[i][j] = 0;             A[choice[i*sqt]]+=1; B[choice[i*sqt]]+=i*sqt; C[choice[i*sqt]]+=(long long) i*sqt*i*sqt;             for (int j=i*sqt+1;j<=N;j++) {                 out0[i][j] = out0[i][j-1]+A[choice[j]];                 out1[i][j] = out1[i][j-1]+(long long) A[choice[j]]*j-B[choice[j]];                 out2[i][j] = out2[i][j-1]+C[choice[j]]+(long long) A[choice[j]]*j*j-2LL*j*B[choice[j]];                 A[choice[j]]+=1;                 B[choice[j]]+=j;                 C[choice[j]]+=(long long) j*j;             }         }         long long A = 0;         long long B = 0;         for (int q=1;q<=Q;q++) {             int X,Y,type;             scanf("%d%d%d",&X,&Y,&type);             int L = (X+A)%N+1;             int R = (Y+B)%N+1;             if (L>R) swap(L,R);             L-=1;             int low = (L-1)/sqt+1;             long long out;             if (type==0) out = out0[low][R];             else if (type==1) out = out1[low][R];             else out = out2[low][R];             for (int j=L;j<=min(R,low*sqt-1);j++) {                 int lo = D[j];                 int hi = upper_bound(w0[choice[j]].begin(),w0[choice[j]].end(),R)-w0[choice[j]].begin()-1;                 if (type==0) out+=hi-lo;                 else if (type==1) out+=w1[choice[j]][hi]-w1[choice[j]][lo]-(long long) (hi-lo)*j;                 else out+=w2[choice[j]][hi]-w2[choice[j]][lo]+(long long) (hi-lo)*j*j-2LL*j*(w1[choice[j]][hi]-w1[choice[j]][lo]);             }             printf("%lld\n",out);             A = B;             B = out;         }     }     return 0; } 
#include <algorithm> #include <cstring> #include <cassert> #include <vector> #include <cstdio> #include <map>  using namespace std;  const int MAXN = 50; const int MAXV = 500; const int mod = 1000000007; const int mod2 = mod+mod; const int base = 1000000000;  char s[200]; int x[200]; int m;  void read() { 	m = 0; 	scanf("%s", s); 	for (int i = strlen(s); i>0; i-=9) 	{ 	 	s[i] = 0; 	 	x[m++] = atoi(s + max(0, i-9)); 	}  	for (; m>1 && !x[m-1]; m--); } void div2() { 	for (int i = m-1, t=0, v; i >= 0; i--) 	{ 	 	v = t*base + x[i]; 	 	x[i] = v>>1; 	 	t = v&1; 	} 	for (; m>1 && !x[m-1]; m--); };  int n, tot; int a[MAXN+2]; unsigned int d[MAXV*MAXN*5];  void main2() { 	scanf("%d", &n); read(); 	tot = 0; 	for (int i = 0; i < n; i++) 		scanf("%d", a+i), 		tot += a[i]; 	sort(a, a+n); //	reverse(a, a+n);  	if (n == 1) 	{ 		int t=0; 		for (int i = m-1; i>=0; i--) 			t = (1LL*t*base+x[i])%a[0]; 		printf("%d\n", t==0); 		return; 	} 	assert(tot<MAXN*MAXV);   	int up_val = 0; 	d[0] = 1;  	for (int i, j, v; m>1 || x[0];) 	{ 		memset(d+up_val+1, 0, sizeof(unsigned int)*tot);  		for (i = 0; i < n; i++) 		{ 			v = a[i]; 			up_val += v; 			for (int j = up_val; j>=v; j--) 			{ //			 	d[j] += d[j-a[i]]; //			 	if (d[j]>=mod2) d[j]-=mod2; 				d[j] += d[j-v]; 				d[j] -= mod*((d[j]>>30)&3); //				if ((d[j]+=d[j-v])>=mod2) //					d[j]-=mod2; //				if ((d[j+a[i]]+=d[j])>=mod) //					d[j+a[i]]-=mod; 			} 		}  		j = 0; 		for (i = x[0]&1; i <= up_val; i+=2, j++) 		{ 			d[j] = d[i]; 			if (d[j] >= mod) d[j]-=mod; 		} 		for (up_val = j-1; up_val>0 && !d[up_val]; up_val--);  		if (!up_val && !d[0]) break;  		div2(); 	}  	printf("%d\n", d[0]); }  int main() { 	int test; 	scanf("%d", &test); 	for (; test--;) 		main2(); 	return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring>   #include <map> #include <algorithm>   using namespace std;   typedef long long ll; #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define ALL(A) A.begin(), A.end()   int N, rc; int a[1<<16]; ll su, b[1<<16], cie[1<<16], r[1<<16]; map<ll,int> ir;   int bis[1<<16]; void inc(int idx) {     idx++;     while(idx <= rc) {         bis[idx]++;         idx += (idx&-idx);     } } int val(int idx) {     idx++;     int res = 0;     while(idx) {         res += bis[idx];         idx -= (idx&-idx);     }     return res; }   ll residue(ll v) {     return (v%su) ? su-(v%su) : 0; }   ll t[1<<16]; ll do_sort(int si, int ei) {     if(1 >= ei-si) return 0;     int mi = (si + ei) / 2;     ll res = do_sort(si, mi);     res += do_sort(mi, ei);     int ai = si, bi = mi, ci = si;     while(ai < mi && bi < ei) {         if(b[ai] <= b[bi]) t[ci++] = b[ai++];         else {             res += mi-ai;             t[ci++] = b[bi++];         }     }     while(ai < mi) t[ci++] = b[ai++];     while(bi < ei) t[ci++] = b[bi++];     memcpy(b+si,t+si,sizeof(ll)*(ei-si));     return res; }   int main() {     int T;     scanf("%d",&T);     while(T--) {         scanf("%d",&N);         FOR(i,0,N) scanf("%d",&a[i]);         /* pivot sums array such that each sum is positive */         su = a[0];         ll ls = a[0]; int lsi = 0;         FOR(i,1,N) {             su += a[i];             if(ls > su) {                 ls = su;                 lsi = i;             }         }         b[0] = 0;         FOR(i,1,N) {             b[i] = b[i-1] + a[(lsi+i)%N];         }         /* sort the sums, calculating the number of inversions */         ll res = do_sort(0,N);         /* build lookup of unique residues modulo su */         FOR(i,0,N) r[i] = residue(b[i]);         sort(r,r+N);         ir.clear();         rc = 0;         FOR(i,0,N) {             if(ir.find(r[i]) == ir.end()) ir[r[i]] = rc++;         }         /* calculate inversions in infinite array */         memset(bis,0,sizeof(bis));         FOR(i,0,N) cie[i] = (b[i] + su - 1) / su;         ll ks = 0;         int k = 0;         FOR(i,1,N) {             while(b[k]+su < b[i]) {                 inc(ir[residue(b[k])]);                 ks += cie[k];                 k++;             }             res += k*cie[i] - ks - val(ir[residue(b[i])]);         }         printf("%lld\n",res);     }     return 0; }
#include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <algorithm> #define ll long long using namespace std;   const ll Inf = 100000000, Lim = 1000000; const int MaxN = 210, MaxM = MaxN * MaxN * 6; int P[MaxN], V[MaxN][MaxN]; int N, M, Rx[MaxM], Ry[MaxM], Rl[MaxM], Rs[MaxM], Rt[MaxM];  class MinCostFlow_Template { public: 	int En[MaxN], Next[MaxM], Point[MaxM], F[MaxM], Tot, S, T, H[MaxM * 10], Pre[MaxN], Cnt[MaxN]; 	ll V[MaxM], Dist[MaxN]; 	bool In[MaxN]; 	ll Spfa() { 		memset(Dist, 63, sizeof(Dist)); 		memset(Cnt, 0, sizeof(Cnt)); 		int L = 0, R = 1; 		H[R] = S; 		In[S] = 1; 		Dist[S] = 0; 		while (L++ != R) { 			int U = H[L]; 			if (Cnt[U]++ >= N * 2) return -Inf * Inf; 			for (int i = En[U]; i; i = Next[i]) 				if (F[i] && (Dist[Point[i]] > Dist[U] + V[i])) { 					Dist[Point[i]] = Dist[U] + V[i]; 					Pre[Point[i]] = i; 					if (!In[Point[i]]) { 						In[Point[i]] = 1; 						if ((Dist[Point[i]] > Dist[U]) || !L) H[++R] = Point[i]; 						else H[L--] = Point[i]; 					} 				} 			In[U] = 0; 		} 		return Dist[T]; 	} public: 	void Init(int _S, int _T) { 		memset(En, 0, sizeof(En)); 		memset(In, 0, sizeof(In)); 		Tot = 1; 		S = _S;	T = _T; 	} 	void Add(int X, int Y, int Flow, ll Cost) { 		Next[++Tot] = En[X];	En[X] = Tot;	Point[Tot] = Y;	F[Tot] = Flow;	V[Tot] = Cost; 		Next[++Tot] = En[Y];	En[Y] = Tot;	Point[Tot] = X;	F[Tot] = 0;	V[Tot] = -Cost; 	} 	ll MinCostFlow() { 		ll Ret = 0, Tmp; 		while ((Tmp = Spfa()) < Inf) { 			if (Tmp == -Inf * Inf) return -Inf * Inf; 			int Flow = Inf; 			for (int X = T; X != S; X = Point[Pre[X] ^ 1]) 				Flow = min(Flow, F[Pre[X]]); 			Ret += Tmp * Flow; 			for (int X = T; X != S; X = Point[Pre[X] ^ 1]) { 				F[Pre[X]] -= Flow; 				F[Pre[X] ^ 1] += Flow; 			} 		} 		return Ret; 	} }	G;   void GetAnswer() { 	for (int i = 1; i <= N * 2; i++) V[i][0] = 0, V[0][i] = Lim; 	for (int i = 1; i <= N * 2; i++) 		for (int j = G.En[i]; j; j = G.Next[j]) 			if (!(j & 1) && (G.Point[j] <= N * 2) && (G.F[j ^ 1])) { 				//printf("%d %d %d\n", i, G.Point[j], int(G.V[j])); 				V[G.Point[j]][i] = G.V[j]; 				V[i][G.Point[j]] = -G.V[j]; 			} 	memset(P, 63, sizeof(P));  	static bool In[MaxN]; 	static int Q[MaxM * 10]; 	int L = 0, R = 1; 	memset(In, 0, sizeof(In)); 	Q[R] = 0; 	In[0] = 1; 	P[0] = 0; 	while (L++ != R) { 		for (int i = 0; i <= N * 2; i++) 			if (P[i] > P[Q[L]] + V[Q[L]][i]) { 				P[i] = P[Q[L]] + V[Q[L]][i]; 				if (!In[i]) Q[++R] = i; 			} 		In[Q[L]] = 0; 	} }   void Solve() { 	memset(V, 63, sizeof(V)); 	int Deg0[MaxN], Deg1[MaxN]; 	ll Sum = 0; 	memset(Deg0, 0, sizeof(Deg0)); 	memset(Deg1, 0, sizeof(Deg1)); 	memset(P, 0, sizeof(P)); 	scanf("%d%d", &N, &M); 	int S = N * 2 + 1, T = S + 1; 	G.Init(S, T); 	for (int i = 1; i <= M; i++) { 		int X, Y, L, Ls, Lt; 		scanf("%d%d%d%d%d", &X, &Y, &L, &Ls, &Lt); 		Rx[i] = X;	Ry[i] = Y; 		Rl[i] = L;	Rs[i] = Ls;	Rt[i] = Lt;  		G.Add(X, Y + N, Inf, Lt - L); 		G.Add(Y + N, X, Inf, L - Ls); 		 		Sum += L; 		Deg0[X]++; 		Deg1[Y]++; 		V[Y + N][X] = Lt - L; 		V[X][Y + N] = L - Ls; 	} 	 	for (int i = 1; i <= N; i++) { 		G.Add(S, i, Deg0[i], -Inf); 		Sum += Inf * Deg0[i]; 		G.Add(i + N, T, Deg1[i], -Inf); 		Sum += Inf * Deg1[i]; 		 		G.Add(i, T, Inf, 0); 		G.Add(i + N, T, Inf, 0); 	} 	 	Sum += G.MinCostFlow(); 	if (Sum < -Inf * Inf / 2) puts("Unlike"); 	else { 		GetAnswer(); 		printf("%lld\n", Sum); 		for (int i = 1; i < N; i++) printf("%d ", P[i]); printf("%d\n", P[N]); 		for (int i = 1; i < N; i++) printf("%d ", P[i + N]); printf("%d", P[N + N]); 		printf("\n"); 	} }  int main() { int T;   scanf("%d",&T);   for(int i=1;i<=T;i++) Solve();   return 0; }
#include <iostream> #include <stdio.h> #include <math.h> #include <stdlib.h> #include <vector> #include <queue> #include <cstdio> #include <algorithm> #include <numeric> #include <climits> #include <sstream> #include <cstring> #include <cassert> #include <stack> #include <cmath> #include <map> #include <set> #include <utility> #include <memory.h> #include <time.h> #include <list> #include <deque> #include <functional> #include <iterator>  #define MN 10000 #define ML 400 #define MX 100005 #define rep(i, n) for (int i = 0; i < n; i ++)  using namespace std;  int val[MN], size[MN]; int a[MN][ML + 5]; int N, A[MX], Q, an; int n; int ID[ML * 10], NID[ML * 10]; int tot, ntot;  inline void get_val(int id) { 	val[id] = 0; 	rep(i, size[id] - 1) val[id] += a[id][i] != a[id][i + 1]; }  void init() { 	n = tot = 0; 	int i, k; 	for (i = 0; i < N; i += ML) { 		size[n] = 0; 		for (k = 0; k < ML && i + k < N; k ++) a[n][size[n] ++] = A[i + k]; 		get_val(n); 		ID[tot ++] = n ++; 	} 	an = 0; }  inline void get(int v, int &id, int &p) { 	int x; 	rep(i, tot) { 		x = ID[i]; 		if (size[x] > v) { 			id = i;	 			p = v; 			return; 		} 		v -= size[x]; 	}	 }  inline int get_new() { 	if (an) { 		an --; 		size[A[an]] = 0; 		return A[an]; 	} 	size[n] = 0; 	return n ++; }  void update(int st, int en) { 	int i, nid, id, ids, ide, ps, pe; 	int sum, j, k, t; 	 	get(st, ids, ps); 	get(en, ide, pe); 	 	ntot = 0; 	if (ids == ide) { 		id = ID[ids]; 		if (!ps && pe == size[id] - 1) NID[ntot ++] = id;	 		else { 			nid = get_new(); 			for (i = ps; i <= pe; i ++) a[nid][size[nid] ++] = a[id][i]; 			NID[ntot ++] = nid; 			get_val(nid); 		} 	} 	else { 		id = ID[ids]; 		if (!ps) NID[ntot ++] = id; 		else { 			nid = get_new(); 			for (i = ps; i < size[id]; i ++) a[nid][size[nid] ++] = a[id][i]; 			NID[ntot ++] = nid; 			get_val(nid); 		} 		for (i = ids + 1; i < ide; i ++) NID[ntot ++] = ID[i]; 		id = ID[ide]; 		if (pe == size[id] - 1) NID[ntot ++] = id; 		else { 			nid = get_new(); 			for (i = 0; i <= pe; i ++) a[nid][size[nid] ++] = a[id][i]; 			NID[ntot ++] = nid; 			get_val(nid); 		} 	} 	for (i = 0; i < ids; i ++) NID[ntot ++] = ID[i]; 	id = ID[ids]; 	if (ps) { 		nid = get_new(); 		for (i = 0; i < ps; i ++) a[nid][size[nid] ++] = a[id][i]; 		NID[ntot ++] = nid;	 		get_val(nid); 	} 	id = ID[ide]; 	if (pe < size[id] - 1) { 		nid = get_new(); 		for (i = pe + 1; i < size[id]; i ++) a[nid][size[nid] ++] = a[id][i]; 		NID[ntot ++] = nid; 		get_val(nid); 	} 	for (i = ide + 1; i < tot; i ++) NID[ntot ++] = ID[i]; 	if (ids == ide) { 		id = ID[ids]; 		if (ps || pe < size[id] - 1) A[an ++] = id;	 	} 	else { 		id = ID[ids]; 		if (ps) A[an ++] = id; 		id = ID[ide]; 		if (pe < size[id] - 1) A[an ++] = id; 	} 	tot = 0; 	for (i = 0; i < ntot; i ++) { 		sum = 0; 		for (k = i; k < ntot; k ++) { 			id = NID[k]; 			if (sum + size[id] > ML) break; 			sum += size[id];	 		} 		k --; 		if (i == k) { 			ID[tot ++] = NID[i]; 			continue; 		} 		nid = get_new(); 		val[nid] = 0; 		for (j = i; j <= k; j ++) { 			id = NID[j]; 			A[an ++] = id; 			for (t = 0; t < size[id]; t ++) a[nid][size[nid] ++] = a[id][t];	 			val[nid] += val[id]; 			if (j > i) val[nid] += a[id][0] != a[NID[j - 1]][size[NID[j - 1]] - 1]; 		} 		ID[tot ++] = nid; 		i = k; 	} }  int find(int st, int en) { 	int i, nid, ids, ide, ps, pe, id, res(0); 	get(st, ids, ps); 	get(en, ide, pe); 	id = ID[ids]; 		 	if (ids == ide) { 		for (i = ps; i < pe; i ++) res += a[id][i] != a[id][i + 1]; 		return res;	 	} 	for (i = ps; i < size[id] - 1; i ++) res += a[id][i] != a[id][i + 1]; 	for (i = ids + 1; i < ide; i ++) { 		nid = ID[i]; 		res += a[nid][0] != a[id][size[id] - 1]; 		id = nid;	 		res += val[id]; 	}  	nid = ID[ide]; 	res += a[nid][0] != a[id][size[id] - 1]; 	for (i = 0; i < pe; i ++) res += a[nid][i] != a[nid][i + 1]; 	return res; }  int main() { 	 	int tn; 	cin >> tn; 	 	while (tn --) { 		cin >> N ; 		rep(i, N) scanf("%d", A + i); 		init(); 		 		int t, l, r; 		scanf("%d", &Q); 		while (Q --) { 			scanf("%d%d%d", &t, &l, &r); 			l --, r --; 			if (t == 2) update(l, r); 			else { 			 	printf("%d\n", find(l, r) + 1); 			} 		} 	} 	return 0; } 
#include <cmath> #include <cstdio> #include <cstring> #include <cstdlib> #include <iostream> #include <algorithm> #define fir first #define sec second #define mkp make_pair using namespace std;   const double PI = acos(-1);   const int MaxN = 55; class Point { public: 	double x, y; 	Point() {} 	Point(double x, double y) : x(x), y(y) {} 	friend Point operator - (const Point &a, const Point &b) { 		return Point(a.x - b.x, a.y - b.y); 	} 	friend Point operator + (const Point &a, const Point &b) { 		return Point(a.x + b.x, a.y + b.y); 	} 	double len() { 		return sqrt(x * x + y * y); 	} 	friend Point operator * (const Point &a, const double &b) { 		return Point(a.x * b, a.y * b); 	} }	H[MaxN], P[MaxN]; double cross(const Point &a, const Point &b) { 	return a.x * b.y - a.y * b.x; } double dot(const Point &a, const Point &b) { 	return a.x * b.x + a.y * b.y; } class circle : public Point { public: 	double r; 	friend bool operator < (const circle &a, const circle &b) { 		if (a.x != b.x) return a.x < b.x; 		if (a.y != b.y) return a.y < b.y; 		return a.r < b.r; 	} }	C[MaxN]; int N, M;   inline double integrate_arc(double a, double b, double r, double tl, double tr) { 	return 0.5 * r * (a * (sin(tr) - sin(tl)) + b * (cos(tl) - cos(tr)) + r * (tr - tl)); }   #define sqr(x) ((x) * (x)) struct triple { 	double key; 	int a, b; 	triple() {} 	triple(double key, int a, int b) : key(key), a(a), b(b) {} 	friend bool operator < (const triple &a, const triple &b) { 		return a.key < b.key; 	} }; double Calc_union_circle(int pos) { 	static triple H[MaxN << 3]; 	double ret = 0; 	int cnt = 0, cedge = 0, Htot = 0; 	for (int i = 1; i <= N; ++i) 		if (i != pos) { 			double dist = (C[i] - C[pos]).len(); 			if (dist <= C[i].r - C[pos].r) return 0; 			if (dist >= C[i].r + C[pos].r) continue; 			if (dist <= C[pos].r - C[i].r) continue; 			double ang = atan2(C[i].y - C[pos].y, C[i].x - C[pos].x),  				thita = acos((sqr(C[pos].r) + sqr(dist) - sqr(C[i].r)) / (2 * C[pos].r * dist)); 			double l = ang - thita, r = ang + thita; 			if (r > PI) r -= 2 * PI; 			if (l < -PI) l += 2 * PI; 			if (r < l) { 				cnt++; 				H[++Htot] = triple(r, -1, 0); 				H[++Htot] = triple(l, 1, 0); 			} else { 				H[++Htot] = triple(l, 1, 0); 				H[++Htot] = triple(r, -1, 0); 			} 		} 	int edge = 0; 	for (int i = 1; i <= M; ++i) { 		double len = (P[i + 1] - P[i]).len(), dist = -(cross(P[i + 1] - P[i], C[pos] - P[i])) / len; 		if ((fabs(dist) >= C[pos].r)) { 			if (cross(P[i + 1] - P[i], C[pos] - P[i]) < 0) return 0; 			continue; 		} 		++edge; 		double ang = atan2(- P[i + 1].x + P[i].x, P[i + 1].y - P[i].y), thita = acos(dist / C[pos].r); 		Point f = C[pos] + Point(cos(ang), sin(ang)) * C[pos].r; //		printf("%.5lf %.5lf %.5lf\n", f.x, f.y, ang); 		if (cross(P[i + 1] - P[i], f - P[i]) < 0) { 			ang = PI + ang; 		} 		if (ang > PI) ang -= 2 * PI; 		double l = ang - thita, r = ang + thita; 		if (r > PI) r -= 2 * PI; 		if (l < -PI) l += 2 * PI; 		if (r < l) { 			cedge++; 			H[++Htot] = triple(r, 0, -1); 			H[++Htot] = triple(l, 0, 1); 		} else { 			H[++Htot] = triple(l, 0, 1); 			H[++Htot] = triple(r, 0, -1); 		} //		printf("%.5lf %.5lf %.5lf %.5lf\n", l, r, ang, thita); 	} 	sort(H + 1, H + Htot + 1); 	H[0].key = -PI; 	H[Htot + 1].key = PI; 	for (int i = 1; i <= Htot + 1; ++i) { 		if ((cnt == 0) && (cedge == edge)) { 			ret += integrate_arc(C[pos].x, C[pos].y, C[pos].r, H[i - 1].key, H[i].key); //			printf("%.5lf %.5lf %.5lf\n", H[i - 1].key, H[i].key, ret); 		} 		cnt += H[i].a; 		cedge += H[i].b; 	} //	cerr << ret << endl; 	return ret; }   inline double integrate_segment(double a, double b, double kx, double ky, double l, double r) { 	return 0.5 * (a * ky - b * kx) * (r - l); } double Calc_union_segment(Point a, Point b) { 	static pair<double, int> H[MaxN]; 	int Htot = 0; 	double len = (b - a).len(); 	for (int i = 1; i <= N; ++i) { 		double dist = fabs(cross(b - a, C[i] - a)) / len; 		if (dist >= C[i].r) continue; 		double pos = dot(C[i] - a, b - a) / len, delta = sqrt(sqr(C[i].r) - sqr(dist)); 		double l = max(0.0, pos - delta), r = min(len, pos + delta); 		if (l >= r) continue; 		H[++Htot] = mkp(l, -1); 		H[++Htot] = mkp(r, 1); 	} 	sort(H + 1, H + Htot + 1); 	H[0].fir = 0; 	H[Htot + 1].fir = len; 	int cnt = 0; 	double ret = 0; 	for (int i = 1; i <= Htot + 1; ++i) { 		if (cnt) 			ret += integrate_segment(a.x, a.y, (b.x - a.x) / len, (b.y - a.y) / len, H[i - 1].fir, H[i].fir); 		cnt += H[i].sec; 	} 	return ret; }   bool cmpx (const Point &a, const Point &b) { 	return a.x < b.x; } int Convex_hull() { 	int Ptot = 0, m = Ptot + 1; 	sort(H + 1, H + M + 1, cmpx); 	for (int i = 1; i <= M; ++i) { 		while ((Ptot > m) && (cross(H[i] - P[Ptot - 1], P[Ptot] - P[Ptot - 1]) >= 0)) --Ptot; 		P[++Ptot] = H[i]; 	} 	m = Ptot; 	for (int i = M - 1; i; --i) { 		while ((Ptot > m) && (cross(H[i] - P[Ptot - 1], P[Ptot] - P[Ptot - 1]) >= 0)) --Ptot; 		P[++Ptot] = H[i]; 	} //	for (int i = 1; i <= Ptot; ++i) printf("%.1lf %.1lf\n", P[i].x, P[i].y); 	return Ptot - 1; }   double area_union() { 	double ret = 0; 	for (int i = 1; i <= N; ++i) 		ret += Calc_union_circle(i); 	for (int i = 1; i <= M; ++i) 		ret += Calc_union_segment(P[i], P[i + 1]); 	return ret; }   int main() { 	scanf("%d", &N); 	for (int i = 1; i <= N; ++i) scanf("%lf%lf%lf", &C[i].x, &C[i].y, &C[i].r); 	sort(C + 1, C + N + 1); 	int tn = 0; 	for (int i = 1; i <= N; ++i) { 		if ((i < N) && (C[i].x == C[i + 1].x) && (C[i].y == C[i + 1].y)) continue; 		C[++tn] = C[i]; 	} 	N = tn; 	scanf("%d", &M); 	for (int i = 1; i <= M; ++i) scanf("%lf%lf", &H[i].x, &H[i].y); 	M = Convex_hull();   	double ans = area_union(); 	printf("%.12lf\n", ans); 	return 0; } 
#pragma comment(linker,"/STACK:100000000000,100000000000")  #include <iostream> #include <cstdio> #include <cstdlib> #include <algorithm> #include <string> #include <cstring> #include <vector> #include <cmath> #include <map> #include <stack> #include <set> #include <iomanip> #include <queue> #include <map> #include <functional> #include <memory.h> #include <list> #include <sstream> #include <ctime> #include <climits> #include <bitset> #include <list> #include <cassert> #include <complex>  using namespace std;  /* Constants begin */ const long long inf = 1e18+7; const long long mod = 1e9+7; const double eps = 1e-12; const double PI = 2*acos(0.0); const double E = 2.71828; /* Constants end */  /* Defines begin */ #define pb push_back #define mp make_pair #define ll long long #define double long double #define F first #define S second #define all(a) (a).begin(),(a).end() #define forn(i,n) for (ll (i)=0;(i)<(ll)(n);(i)++) #define random (rand()<<16|rand()) #define sqr(x) (x)*(x) #define base complex<double> /* Defines end */  int q; int n, a[300005]; int Q[300005], sum[300005], h, t; int m;  void pre(){     for(int i=1;i<=9;i++){      if(i*i <= q){       Q[t] = i;       sum[t] = i*i;       t++;      }     }     while(t < 300000){      ll now = Q[h];      int nsum = sum[h++];      for(int i=0;i<=9;i++){       if(nsum + i * i <= q){        Q[t] = (now * 10 + i) % mod;        sum[t] = nsum + i * i;        t++;       }      }     } }  int main(void) {     #ifndef ONLINE_JUDGE         freopen("input.txt","rt",stdin);         freopen("output.txt","wt",stdout);     #endif     scanf("%d",&q);     scanf("%d",&n);     forn(i,n) scanf("%d",a+i);     pre();     forn(i,n) a[i] = Q[a[i]-1];     for(int i=1;i<n;i++) a[i] = (a[i] + a[i-1]) % mod;     scanf("%d",&m);     forn(i,m){      int l, r; scanf("%d%d",&l,&r); l--; r--;      int ans = a[r];      if(l) ans -= a[l-1];      if(ans < 0) ans += mod;      printf("%d\n",ans);     }     return 0; } 
#include<iostream> #include<algorithm> #include<cstdio> #include<cstring> #include<vector> #include<assert.h> #define REP(i,m) for(int i=0;i<m;++i) #define REPN(i,m,in) for(int i=in;i<m;++i) #define ALL(t) (t).begin(),(t).end() #define pb push_back #define mp make_pair #define fr first #define sc second #define dump(x)  cerr << #x << " = " << (x) << endl #define prl cerr<<"called:"<< __LINE__<<endl using namespace std; static const int INF =500000000;  template<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;} typedef long long int lint; typedef pair<int,int> pi; int n,b; lint m,l; int s[35],tmp[35]; int sectall[1000]; lint dp[35][1000]; lint rec(int tall,int other){ 	lint& res=dp[tall][other]; 	if(tall>0 && sectall[other]>=tall) return res=rec(tall,other-1); 	if(res!=-1) return res; 	if(other==0){ 		lint nxt=rec(tall-1,other); 		res=(nxt+b)/(b+1); 		if(res>l){ 			res=nxt-l*b; 		} 	}else{ 		lint nxt1=rec(tall-1,other),nxt2=rec(tall,other-1); 		res=(nxt1+nxt2*b+b)/(b+1); 		lint k=res-nxt2; 		if(k>l){ 			res=min(nxt2+l,nxt1-b*l); 		} 	} 	return res; }  int main(){ 	int t;scanf("%d",&t); 	while(t--){ 		cin>>n>>b>>m>>l; 		REP(i,n) cin>>s[i],tmp[i]=s[i]; 		int tall=max_element(s,s+n)-s; 		int sum=0; 		REP(i,n) if(i!=tall) sum+=s[i]; 		REP(j,sum+1){ 			int maxi=-1,maxind=-1; 			REP(k,n) if(k!=tall && maxi<s[k]){ 				maxi=s[k]; 				maxind=k; 			} 			sectall[sum-j]=maxi; 			if(maxi==0){ 				break; 			} 			--s[maxind]; 		} 		lint lb=0,ub=1e15+5; 		while(ub-lb>1){ 			memset(dp,-1,sizeof(dp)); 			lint md=(lb+ub)>>1; 			REP(i,sum+1) dp[0][i]=md; 			if(rec(s[tall],sum)<=m) lb=md; 			else ub=md; 		} 		printf("%lld\n",lb); 	} 	return 0; }  
#include <cstdio> #include <cmath> #include <algorithm> using namespace std;  typedef long long LL;  const int maxC = 1000; const int maxK = 5;  struct center { 	LL P; 	double S, T, X; 	center(){} 	center(LL P_,double S_,double T_,double X_) { 		P=P_; S=S_; T=T_; X=X_; 	} 	void read() { 		scanf("%lld %lf %lf %lf", &P, &S, &T, &X); 	} 	bool operator<(const center &c) const { 		return X < c.X; 	} };  const int maxI = 50; double fact[maxI + 1]; // factorials double B[maxI]; // B[j] = Bern[j] / j!, where Bern[j] is j-th Bernoulli number double Bg[maxI]; // Bg[j] = B[j] * (j - 1), needed for function g(n, k)  const int maxH = 100000; double H[maxH]; // H[n] = 1/1 + 1/2 + ... + 1/n is n-th Harmonic number  void precalc() { 	// factorials precalc 	fact[0] = 1.; 	for (int n = 1; n <= maxI; ++n) { 		fact[n] = n * fact[n - 1]; 	}  	// Bernoulli numbers divided be factorials and numbers Bg 	B[0] = 1.; 	for (int n = 1; n < maxI; ++n) { 		B[n] = 0.; 		// we use the fact that Bernoulli numbers with odd index except 1 are zeros 		if (n % 2 == 0 || n == 1) { 			for (int k = 0; k < n; ++k) { 				B[n] -= B[k] / fact[n + 1 - k]; 			} 		} 		Bg[n] = B[n] * (n - 1); 	}  	// Harmonic numbers 	H[0] = 0.; 	for (int n = 1; n < maxH; ++n) { 		H[n] = H[n - 1] + 1. / n; 	} }  // returns (1 - x) ^ k, 0 < x < 1 double mypow(double x, LL k) { 	// (1 - x) ^ k = exp(k * log(1 - x)) 	if (x > 1e-9) { 		return exp(k * log(1 - x)); 	} 	// for small x above formula has presicion issue 	// since log(1 - x) = - x - x^2 / 2 - x^3 / 3 - ... 	// we approximate log(1 - x) by - x - x^2 / 2 	return exp(k * -(x + x * x / 2)); 	// actually in this problem exp(k * -x) also works 	// but the formal proof is quite tricky }  // Euler-Mascheroni constant const double Gamma = 0.57721566490153286060651209; // Harm(n) = 1/1 + 1/2 + ... + 1/n double Harm(LL n) { 	// for small n we use stored value 	if (n < maxH) { 		return H[n]; 	} 	// the relative error is less than 1 / (12 * n * n * log(n)) < 1e-12 	// since n >= maxH = 100000 	return log(double(n)) + Gamma + 0.5 / n; }  const double PI = 3.1415926535897932385; const double DIGITS = 1e7; // 1 / DIGITS will be a relative error of the answer  // returns (1^k + 2^k + ... + n^k) / n^k double PowerSum(LL n, LL k) { 	double res = 0.; 	double t = (k + 1.) / n; 	if (t < 2) { 		// here we use Euler-Maclaurin formula 		res = n / (k + 1.) + 0.5; 		// the number of summands we need can be calculated  		// from the estimate on relative error provided in the editorial 		int p = max(int(log(DIGITS) / log(2 * PI / t)), 2); 		double prod = double(k) / n; 		for (int j = 2; j <= p && j <= k; j += 2) { 			// prod now = k * (k-1) * ... * (k-j+2) / n^(j-1), 			res += B[j] * prod; 			prod *= double(k - j + 1) * (k - j) / n / n; 		} 	} else { 		// here we simply use several last terms of the actual sum 		// again the number of summands we need can be calculated  		// from the estimate on relative error 		int p = min(LL(log(DIGITS) / t + 1), n); 		res = 1.; 		for (int j = 1; j <= p; ++j) { 			res += mypow(double(j) / n, k); 		} 	} 	return res; }  // returns k * (PowerSum(n, k) - PowerSum(n, k + 1)) double g(LL n, LL k) { 	double res = 0.; 	double t = (k + 1.) / n; 	if (t < 2) { 		// the difference of Euler-Maclaurin formulas 		res = n / (k + 1.) / (k + 2.); 		int p = max(int(log(DIGITS) / log(2 * PI / t)), 2); 		double prod = 1./n; 		for (int j = 2; j <= p && j <= k + 1; j += 2) { 			res -= Bg[j] * prod; 			prod *= double(k - j + 2) * (k - j + 1) / n / n; 		} 	} else { 		int p = min(LL(log(DIGITS) / t + 1), n - 1); 		for (int j = 1; j <= p; ++j) { 			double x = double(j) / n; 			res += x * mypow(x, k); 		} 	} 	return k * res; }  // returns min{S * Harm(k - 1) + T * PowerSum(N, k) : 1<=k<=P} // Let a(k) = S * Harm(k - 1) + T * PowerSum(N, k) // Then a(k+1) - a(k) = S/k - T * (PowerSum(N, k) - PowerSum(N, k+1)) = // = T/k * (S/T - k * (PowerSum(N, k) - PowerSum(N, k+1))) =  // = T/k * (a - g(N, k)), where a = S/T and g(N,k) defined above // It can be proved that g(N,k) decreases. // k that gives minimum satisfies g(N,k-1) >= a > g(N,k) // and can be found by binary seacrh double minTime(LL N,LL P,double S,double T) { 	// if a >= g(N, 1) the optimal k = 1 	if (P == 1 || 6 * S >= T * (N - 1. / N)) { 		// Harm(1 - 1) = 0, PowerSum(N, 1) = (1 + 2 + ... + N) / N = (N + 1) / 2 		return T * (N + 1) / 2; 	} 	double a = S / T; 	if (a <= g(N,P)) { 		// in this case optimal k = P 		return S * Harm(P - 1) + T * PowerSum(N, P); 	} 	// g(N, L) >= a > g(N, R) always during while loop 	LL L = 1; 	LL R = P; 	while (L + 1 < R) { 		LL M = (L + R) / 2; 		if (a > g(N, M)) { 			R = M;  		} else { 			L = M; 		} 	} 	// now L + 1 = R = optimal k 	// note, however, that this k can be not optimal 	// but it gives the answer with required relative error 	return S * Harm(R - 1) + T * PowerSum(N, R); }  int main() { #ifndef ONLINE_JUDGE 	freopen("5.in","r",stdin); 	freopen("5_my.out","w",stdout); #endif 	// precal of Harmonic number and Bernoulli staff needed further 	precalc();  	// array of centers 	// it will be sorted dy X: c[0].X <= c[1].X <= ... <= c[C-1].X 	center c[maxC];  	// Time[i][j] is the optimal time to crack i-th piece at the j-th center 	double Time[maxK][maxC];  	// dp[j][mask] is the minimum time needed to crack the set 'mask' of pieces 	// and return back to the restaurant, using centers c[0], c[1], ..., c[j] 	// but if center with positive coordinate is involved than the time to walk to 	// it and return back is not counted. See below for details 	double dp[maxC][1 << maxK];  	int TST; 	scanf("%d", &TST); 	for (int tst = 0; tst < TST; ++tst) { 		int C, K; 		double V; 		scanf("%d %d %lf", &C, &K, &V);  		LL N[maxK]; 		for (int i = 0; i < K; ++i) { 			scanf("%lld", N+i); 		}  		for (int j = 0; j < C; ++j) { 			c[j].read(); 			c[j].X = 2. * (c[j].X / V); 			// now |c[j].X| is the time needed to walk to j-th center and return back 		} 		sort(c, c + C); 		// now array c is sorted by X 		// so centers with X < 0 comes first followed by the centers with X > 0  		for (int i = 0; i < K; ++i) { 			for(int j = 0; j < C; ++j) { 				Time[i][j] = minTime(N[i], c[j].P, c[j].S, c[j].T); 			} 		}  		double ans = 1e200; 		for (int j = 0; j < C; ++j) { 			double Xj = c[j].X; 			// we need 0 time to crack the empty set of pieces 			dp[j][0] = 0; 			for (int mask = 1; mask < (1 << K); ++mask) { 				// binary form of mask corresponds to the current set of pieces 				// init by dp for previous j, which means that we don't use j-th center for any piece 				// or by infinity if we in the very first center 				dp[j][mask] = j > 0 ? dp[j - 1][mask] : 1e200; 				// iterating over piecaes 				for (int i = 0; i < K; ++i) { 					if (mask == (1 << i)) { 						// this means that the current set of pieces havs only one piece 						// here we take into account walking time 						dp[j][mask] = min(dp[j][mask], Time[i][j] + (Xj < 0 ? -Xj : 0)); 						break; 					} else if((mask & (1 << i)) && j > 0) { 						// now set has at least two elements 						// so we have already walked to the furthest center 						// and no need to count walking time again 						// 						// if we use j-th center for cracking i-th piece 						// then we left with set of pieces without i-th piece 						// and have in use centers c[0], c[1], ..., c[j-1] 						dp[j][mask] = min(dp[j][mask], Time[i][j] + dp[j - 1][mask - (1 << i)]); 					} 				} 			} 			// at each center we consider the possibility that we crack the last piece in it 			// and if j-th center has positive X we should count walking time to it 			ans = min(ans, dp[j][(1 << K) - 1] + (Xj > 0 ? Xj : 0)); 		} 		printf("%.10lf\n",ans); 	} 	return 0; } 
/**  * January Cook-Off 2013  *  * Problem:     CIELKARA - Ciel and Karaoke  * Author:      Anton Lunyov (Tester)  * Complexity:  O(IT^[(N-1)/2]) per test, where IT depends on the accuracy of the answer  * Timing:      0.12 out of 2.013  *  * Description:  * By scaling we can assume that K=1.  * We fix values g(A[i]) = x[i], 1<=i<N. Then the minimal value of the integral  * of 2*|g(t)-B[i]| over the interval [A[i], A[i+1]] could be easily calculated  * in terms of d[i] = A[i+1]-A[i], x[i] and x[i+1] (see function area(d,x,y))  * Then we should minimize the sum of such areas as a function of N-1 variables  * x[1], ..., x[N-1] subject to conditions |x[i]-x[i+1]|<=d[i]  * This function has the form  * f[0](x[1]) + f[1](x[1],x[2]) + ... + f[N-2](x[N-2],x[N-1]) + f[N-1](x[N-1])  * where f[j] is a convex piecewise quadratic function.  * Due to this special form and convexity we could apply  * the following tricky nested ternary search:  * we do nested ternary search for variables x[2], x[4], ...  * and then for each of the remaining variables do separate ternary searchs  * since we have separate optimization problems.  * We use golden section search here to reduce the number of calculations.  */ #include <cstdio> #include <cmath> #include <iostream> using namespace std;  //clock_t start=clock(); //fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));  inline double sqr(double x) { 	return x * x; }  const int maxN = 8;  int n; // d[1], d[2], ..., d[N-2] length of segments // b[0], b[1], ..., b[N-1] function values int d[maxN], b[maxN]; // minB = min{b[i]}, maxB = max{b[i]} int minB, maxB;  // x[1], ..., x[n-1] our variables double x[maxN];  // return the minimal integral of 2|g(t)| over [0,d] // where g(0)=x, g(d)=y and |g(t1)-g(t2)|<=|t1-t2| for all t1,t2 // see editorial for derivation of the formula double area(double d, double x, double y) { 	double dif = fabs(x + y) - d; 	return x * x + y * y - (dif <= 0 ? 0 : dif * dif / 2); }  // return the minimal integral of 2|g(t)| over [A[j-1], A[j+1]] // where g(A[j-1]) = x[j-1], g(A[j]) = xj, g(A[j+1]) = x[j+1] // and |g(t1)-g(t2)| <= |t1-t2| for all t1,t2 // Here A[0] = -inf, A[N] = inf double area(int j, double xj) { 	double res = 0; 	if(j > 1) { 		res += area(d[j-1], x[j-1] - b[j-1], xj - b[j-1]); 	} else { 		res += sqr(xj - b[j-1]); 	} 	if(j < n-1) { 		res += area(d[j], xj - b[j], x[j+1] - b[j]); 	} else { 		res += sqr(xj - b[j]); 	} 	return res; }  // the stuff needed for ternary search double phi = (1+sqrt(5.))/2; double coef1 = (phi+1)/(2*phi+1); double coef2 = phi/(2*phi+1);  // the minimal value of iterations allowing desirable precision const int IT = 27;  // the recursive routine that loop over variables x[2], x[4], ... // do golden section search for each of them // and consecutive golden section search // for each of the remaining variables after fixing all x[2*k] // i is even number - the inxed of variables we want to fix now // prevx is the value we assign to x[i-2] is it exists double func(int i, double prevx) { 	if (i > 2) { 		x[i-2] = prevx; 	} 	if (i >= n) { 		// this means we have already fix all x[2*k] 		// so we calculate the final result 		double res = 0; 		// we choose the optimal value for each of x[2*k-1] 		for (int j = 1; j < n; j += 2) { 			// L and R are end of the segment containing optimal value of x[j] 			// we initialize them by min{b[i]} and max{b[i]} resprectively 			// since it is clear that optimal g(t) 			// must satisfy inequalities minB <= g(t) <= maxB 			double L = minB, R = maxB; 			// but we also need to ensure inequalities |g(t1)-g(t2)|<=|t1-t2| 			// for t1=A[j], t2=A[j-1] if j>1 and 			// for t1=A[j], t2=A[j+1] if j<n-1 			if (j > 1) { 				// which transforms to |x[j] - x[j-1]| <= d[j-1], if j > 1 				L = max(L, x[j-1] - d[j-1]); 				R = min(R, x[j-1] + d[j-1]); 			} 			if (j < n-1) { 				// and to |x[j] - x[j+1]| <= d[j], if j < n-1 				L = max(L, x[j+1] - d[j]); 				R = min(R, x[j+1] + d[j]); 			} 			// cur is the minimal value of area(x[j])=A(x[j-1],x[j])+A(x[j],x[j+1]) 			// from editorial, where x[j-1], x[j+1] are fixed and we seek for x[j] 			double cur = 1e100;  			// Golden Section Search 			double fL = area(j, L * coef1 + R * coef2); 			double fR = area(j, L * coef2 + R * coef1); 			for (int it = 0; ; ++it) { 				cur = min(cur, fL); 				cur = min(cur, fR); 				if (it == IT) { 					break; 				} 				if(fL < fR) { 					R = L * coef2 + R * coef1; 					fR = fL; 					fL = area(j, L * coef1 + R * coef2); 				} else { 					L = L * coef1 + R * coef2; 					fL = fR; 					fR = area(j, L * coef2 + R * coef1); 				} 			} 			// the optimal value of x[j] 			// we can use it to print the optimal vector x in the end just for fun 			x[j] = (L + R) / 2; 			res += cur; 		} 		// if n is odd then we need to add the integral from x[n-1] to infinity 		if (n % 2) { 			res += sqr(x[n-1] - b[n-1]); 		} 		return res; 	} 	// L and R are end of the segment containing optimal value of x[j] 	// we initialize them by min{b[i]} and max{b[i]} resprectively 	double L = minB, R = maxB; 	if (i > 2) { 		// but also need to enusr |g(A[i-2])-g(A[i])|<=|A[i-2]-A[i]| 		L = max(L, x[i-2] - d[i-2] - d[i-1]); 		R = min(R, x[i-2] + d[i-2] + d[i-1]); 	} 	// Golden Section Search for x[i] 	// almost coincide with the above one 	// I don't know how to avoid copy-pasting here 	double res = 1e100; 	double fL = func(i+2, L * coef1 + R * coef2); 	double fR = func(i+2, L * coef2 + R * coef1); 	for (int it = 0; ; ++it) { 		res = min(res, fL); 		res = min(res, fR); 		if (it == IT) { 			break; 		} 		if(fL < fR) { 			R = L * coef2 + R * coef1; 			fR = fL; 			fL = func(i+2, L * coef1 + R * coef2); 		} else { 			L = L * coef1 + R * coef2; 			fL = fR; 			fR = func(i+2, L * coef2 + R * coef1); 		} 	} 	x[i] = (L + R) / 2; 	return res; }  int main() { #ifndef ONLINE_JUDGE 	//freopen("in.txt","r",stdin); 	freopen("0.in","r",stdin); 	freopen("0_my.out","wb",stdout); #endif 	int T; 	cin >> T; 	for (int t = 0; t < T; ++t)	{ 		cin >> n; // n is defined globally 		int k; 		cin >> k; 		int a[maxN]; 		for (int i = 1; i < n; ++i) { 			cin >> a[i]; 		} 		// we care only about lengths of the segments where area(t) is constant 		// we do scaling to simplify the job and assume that k = 1 		// to handle this we simply need divide the answer by k 		for (int i = 1; i < n-1; ++i) { 			d[i] = k * (a[i+1] - a[i]); // d[] is defined globally 		}  		// minB and maxB defined globally 		minB = 20130120, maxB = 0; 		for (int i = 0; i < n; ++i) 		{ 			cin >> b[i]; 			minB = min(minB, b[i]); 			maxB = max(maxB, b[i]); 		}  		// we consider this case just for fun :) 		if (n == 2) { 			double res = sqr(double(b[0] - b[1])) / (4 * k); 			printf("%.10lf\n", res); 			continue; 		} 		double res = func(2, -1); 		res /= 2 * k; 		printf("%.10lf\n", res); 	} 	return 0; } 
#include <cstdio> #include <cstring> #include <cmath> #include <vector> using namespace std;   typedef long long LL; typedef pair<int,int> PII; typedef vector<int> VI; typedef vector<PII> VPII;   inline int bit(int n) { return 1<<n; }   const int maxT = 50; double ans[maxT];   const int maxD = 4; const int minP = 1000; const int maxP = 10000;   const int maxN = 8; const int maxS = 330000; // >= maxN! * maxN const int S = 3500; // the real number of states   int fct[maxN+1]={1}; int cnt; int ind[maxS]; char whatn[maxS]; int state_by_ind[S]; int trans[S][maxN][3]; // 0 - no road, 1 - vertial road, 2 - both roads. // horizontal road always lead to the same state double F[S],G[S],*f=F,*g=G;   int n; // current number of columns   VI conv(int state) // a[n] - is a component of (0,0) { 	VI a(n+1); 	for(int i=0;i<n;i++) 		a[i]=state/fct[i]%(i+1); 	a[n]=state/fct[n]; 	return a; }   int normalize(VI &a) { 	int state=0; 	int cnt=0; 	int ind[maxN+1]={0}; 	for(int i=0;i<n;i++) 	{ 		if(!ind[a[i]]) ind[a[i]]=++cnt; 		a[i]=ind[a[i]]-1; 		state+=fct[i]*a[i]; 	} 	if(!ind[a[n]]) return -1; 	a[n]=ind[a[n]]-1; 	state+=fct[n]*a[n]; 	return state; }   int isolate(VI a,int r) { 	a[r]=n; 	return normalize(a); }   int move(VI a,int r) { 	a[r]=a[r-1]; 	return normalize(a); }   int join(VI a,int r) { 	int ar=a[r]; 	for(int i=0;i<=n;i++) 		if(a[i]==ar) a[i]=a[r-1]; 	return normalize(a); }   void dfs(int state) { 	if(whatn[state]==n) return; 	int u=++cnt; 	ind[state]=u; 	state_by_ind[u]=state; 	whatn[state]=n; 	memset(trans[u],0,sizeof trans[u]); 	VI a=conv(state); 	for(int r=0;r<n;r++) 	{ 		int next=isolate(a,r); 		if(next>=0) 		{ 			dfs(next); 			trans[u][r][0]=ind[next]; 		} 		if(r>0) 		{ 			if(a[r]!=a[r-1]) 			{ 				next=move(a,r); 				if(next>=0) 				{ 					dfs(next); 					trans[u][r][1]=ind[next]; 				} 				next=join(a,r); 				if(next>=0) 				{ 					dfs(next); 					trans[u][r][2]=ind[next]; 				} 			} 			else 			{ 				trans[u][r][1]=trans[u][r][2]=u; 			} 		} 	} }   struct test { 	int p; 	LL m; 	int t; 	test(){} 	test(int p_,LL m_,int t_){p=p_;m=m_;t=t_;} };   int main() { 	for(n=1;n<=maxN;n++) fct[n]=n*fct[n-1]; 	int T; 	scanf("%d",&T); 	vector<test> ms[maxN+1]; 	for(int t=0;t<T;t++) 	{ 		LL m; 		double p_; 		scanf("%d %lld %lf",&n,&m,&p_); 		if(n>m){ int t=n;n=m;m=t;} 		int p=10000*p_+0.5; 		if(n==1 || m==1) ans[t]=pow(1-1.*p/maxP,n-1+m-1.); else 		if(p==maxP) ans[t]=0.; else 			ms[n].push_back(test(p,m,t)); 	} 	for(n=2;n<=maxN;n++) if(ms[n].size()) 	{ 		cnt=0; 		VPII init; 		for(int mask=0;mask<bit(n-1);mask++) 		{ 			int state=0; 			int cmp=0; 			for(int i=1;i<n;i++) 			{ 				if(mask & bit(i-1)) cmp++; 				state+=fct[i]*cmp; 			} 			dfs(state); 			init.push_back(PII(ind[state],cmp)); 		} 		for(int it=0;it<ms[n].size();it++) 		{ 			int p_=ms[n][it].p; 			LL M=ms[n][it].m; 			int t=ms[n][it].t; 			int q_=maxP-p_; 			double p=1.*p_/maxP; 			double q=1.*q_/maxP; 			double pp=1.*p_*p_/(maxP*maxP); 			double pq=1.*p_*q_/(maxP*maxP); 			double qq=1.*q_*q_/(maxP*maxP); 			int u; 			memset(f,0,sizeof(double)*(cnt+1)); 			for(int i=init.size();i--;) 			{ 				int k=init[i].second; 				f[init[i].first]=pow(p,k)*pow(q,n-1-k); 			} 			int m0,m; 			double P[222]; 			for(int j=0;;j++) 			{ 				int r=j%n; 				if(r==0) 				{ 					double res=0; 					for(u=1;u<=cnt;u++) 					{ 						int state=state_by_ind[u]; 						if(state/fct[n]==state/fct[n-1]%n) 							res+=f[u]; 					} 					m=j/n+1; 					P[m]=res; 					if(m==M || m>35 || P[m]<1e-6 || fabs(P[m]/P[m-1]-P[m-1]/P[m-2])<1e-13) break; 				} 				memset(g,0,sizeof(double)*(cnt+1)); 				double cur; 				for(u=1;u<=cnt;u++) 				{ 					cur=f[u]; 					if(r==0) 					{ 						g[u]+=q*cur; 						g[trans[u][0][0]]+=p*cur; 					} 					else 					{ 						int *b=trans[u][r]; 						g[u]+=pq*cur; 						g[b[0]]+=pp*cur; 						g[b[1]]+=pq*cur; 						g[b[2]]+=qq*cur; 					} 				} 				swap(f,g); 			} 			if(m==M) ans[t]=P[m]; else 			{ 				m0=m-1; 				double coef=P[m0+1]/P[m0]; 				ans[t]=P[m0]<1e-6?0.:P[m0]*pow(coef,M-m0+0.); 			} 		} 	} 	for(int t=0;t<T;t++) 		printf("%.15lf\n",ans[t]); 	return 0; }  
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); const int maxn = 33; bool flower[maxn]; vector<int> g[maxn]; int n,N; double mat[2 * maxn][2 * maxn],buf[2 * maxn][2 * maxn]; int idx[maxn][2]; void out() { 	for (int i = 0; i < N; i++) { 		for (int j = 0; j < N; j++) { 			printf("%.3lf ",mat[i][j]); 		} 		puts(""); 	} 	puts(""); } void norm() { 	for (int i = 0; i < N; i++) { 		double sum = 0.0; 		for (int j = 0; j < N; j++) { 			sum += mat[i][j]; 		} 		for (int j = 0; j < N; j++) { 			mat[i][j] /= sum; 		} 	} } void mul() { 	for (int i = 0; i < N; i++) { 		for (int j = 0; j < N; j++) { 			buf[i][j] = 0.0; 			for (int k = 0; k < N; k++) { 				buf[i][j] += mat[i][k] * mat[k][j]; 			} 		} 	} 	for (int i = 0; i < N; i++) { 		for (int j = 0; j < N; j++) { 			mat[i][j] = buf[i][j]; 		} 	} } double solve(int id) { 	N = 0; 	for (int i = 1; i <= n; i++) { 		if (flower[i]) { 			idx[i][i == id] = N++; 			idx[i][i != id] = 2 * maxn - 1; 		} else { 			idx[i][0] = N++; 			idx[i][1] = N++; 		}	 	} 	for (int i = 0; i < N; i++) { 		for (int j = 0; j < N; j++) { 			mat[i][j] = 0.0; 		} 	} 	for (int i = 1; i < n; i++) { 		double prob = 1.0 / sz(g[i]); 		for (int j = 0; j < sz(g[i]); j++) { 			int v = g[i][j]; 			if (flower[v]) { 				mat[idx[i][0]][idx[v][id == v]] += prob; 				mat[idx[i][1]][idx[v][id == v]] += prob; 			} else { 				mat[idx[i][0]][idx[v][0]] += prob; 				mat[idx[i][1]][idx[v][1]] += prob; 			} 		} 	} 	mat[idx[n][0]][idx[n][0]] = 1.0; 	mat[idx[n][1]][idx[n][1]] = 1.0; 	for (int it = 0; it < 111; it++) { 		//out(); 		mul();		 		norm(); 	} 	return mat[idx[1][1 == id]][idx[n][1]]; } int main() { 	#ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	freopen("output.txt","w",stdout); 	#endif 	int m,s; cin >> n >> m >> s; 	for (int i = 0; i < s; i++) { 		int x; cin >> x; 		flower[x] = true; 	} 	for (int i = 0; i < m; i++) { 		int a,b; cin >> a >> b; 		g[a].pb(b); 	} 	for (int i = 1; i < n; i++) { 		if (!flower[i]) continue; 		printf("%.9lf\n",solve(i)); 	} 	return 0; } 
#include<stdio.h> #include<ctime> #include<stdlib.h> #include<math.h> #include<string.h> #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)   #define ll long long   ll ab(ll x){ if(x < 0) return -x; return x; }   int intArrayBinarySearchSmallElement(int d[],int size,int n){   int c = size/2; int i;   if(size==1){if(d[0]<n) return 0; return -1;}   if(size<=0) return -1;   if(d[c] < n) return intArrayBinarySearchSmallElement(d+c,size-c,n) + c;   return intArrayBinarySearchSmallElement(d,c,n); }   int N, Q, M; int X[100100]; ll sumX[100100]; int U[51][51]; int towerY[100000], towerR[100000], towerC[100000], towerT[100000], towerSize;   int treeNode, dataSize; int treeLeft[500000], treeRight[500000]; char treeFixed[500000]; ll treeSum[500000]; int treeLT[500000], treeRT[500000];   void treeRecalc(int node){   int n1 = node * 2 + 1, n2 = node * 2 + 2;   int sz = treeRight[node] - treeLeft[node];   int t;     if(sz == 1) return;   if(treeFixed[node] == 0) return;     treeFixed[n1] = treeFixed[n2] = 1;   treeFixed[node] = 0;     t = treeLT[node];   treeLT[n1] = treeRT[n1] = treeLT[n2] = treeRT[n2] = t;   treeSum[n1] = 2 * towerC[t] * ((sumX[treeRight[n1]] - sumX[treeLeft[n1]]) - (ll)towerY[t] * (sz/2));   if(treeSum[n1] < 0) treeSum[n1] *= -1;   treeSum[n2] = 2 * towerC[t] * ((sumX[treeRight[n2]] - sumX[treeLeft[n2]]) - (ll)towerY[t] * (sz/2));   if(treeSum[n2] < 0) treeSum[n2] *= -1; }   void treeGetSum(int A, int B, ll *sum, int *LT, int *RT, int node){   int n1 = node * 2 + 1, n2 = node * 2 + 2;   int sz = treeRight[node] - treeLeft[node];   ll sum1, sum2; int LT1, LT2, RT1, RT2;     if(A < treeLeft[node]) A = treeLeft[node];   if(B > treeRight[node]) B = treeRight[node];     if(A == treeLeft[node] && B == treeRight[node]){     *sum = treeSum[node];     *LT = treeLT[node];     *RT = treeRT[node];     return;   }     treeRecalc(node);     if(B <= treeRight[n1]){     treeGetSum(A, B, sum, LT, RT, n1);     return;   }     if(treeLeft[n2] <= A){     treeGetSum(A, B, sum, LT, RT, n2);     return;   }     treeGetSum(A, B, &sum1, &LT1, &RT1, n1);   treeGetSum(A, B, &sum2, &LT2, &RT2, n2);   if(sum1==-1 || sum2==-1){ *sum = -1; return; }   *sum = sum1 + sum2;   *LT = LT1;   *RT = RT2;   if(LT2 != RT1) *sum += U[towerT[LT2]][towerT[RT1]]; }   void treeSetTower(int A, int B, int t, int node){   int n1 = node * 2 + 1, n2 = node * 2 + 2;   int sz = treeRight[node] - treeLeft[node];   ll sum1, sum2; int LT1, LT2, RT1, RT2;     if(A < treeLeft[node]) A = treeLeft[node];   if(B > treeRight[node]) B = treeRight[node];   if(A >= B) return;     if(A == treeLeft[node] && B == treeRight[node]){     treeFixed[node] = 1;     treeSum[node] = 2 * towerC[t] * ((sumX[B] - sumX[A]) - (ll)towerY[t] * sz);     if(treeSum[node] < 0) treeSum[node] *= -1;     treeLT[node] = treeRT[node] = t;     return;   }     treeRecalc(node);     treeSetTower(A, B, t, n1);   treeSetTower(A, B, t, n2);   sum1 = treeSum[n1]; sum2 = treeSum[n2];   LT1 = treeLT[n1]; LT2 = treeLT[n2];   RT1 = treeRT[n1]; RT2 = treeRT[n2];     if(sum1==-1 || sum2==-1){ treeSum[node] = -1; return; }   treeSum[node] = sum1 + sum2;   treeLT[node] = LT1;   treeRT[node] = RT2;   if(LT2 != RT1) treeSum[node] += U[towerT[LT2]][towerT[RT1]]; }     int main(){   double start = clock();   int i,j,k,l;   int A, B, Y, R, C, T, t;   int t1, t2;   int mode;   ll res; int LT, RT;     scanf("%d%d%d",&N,&M,&Q);   rep(i,N) scanf("%d",X+i);   rep(i,M) rep(j,M) scanf("%d",U[i]+j);     sumX[0] = 0;   rep(i,N) sumX[i+1] = sumX[i] + X[i];   towerSize = 0;     dataSize = 1;   while(dataSize < N) dataSize *= 2;   treeNode = dataSize * 2 - 1;   rep(i,treeNode) treeFixed[i] = 0, treeSum[i] = treeLT[i] = treeRT[i] = -1;   treeLeft[0] = 0, treeRight[0] = dataSize;   rep(i,treeNode/2){     int n1 = i * 2 + 1, n2 = i * 2 + 2;     int sz = treeRight[i] - treeLeft[i];     treeLeft[n1]  = treeLeft[i];     treeRight[n1] = treeLeft[i] + sz / 2;     treeLeft[n2]  = treeLeft[i] + sz / 2;     treeRight[n2] = treeRight[i];   }     while(Q--){     scanf("%d",&mode);     if(mode == 1){       scanf("%d%d",&A,&B); A--; B--;       treeGetSum(A, B+1, &res, &LT, &RT, 0);       if(res < 0){         puts("impossible");       } else {         res -= ab(X[A] - towerY[LT]) * towerC[LT];         res -= ab(X[B] - towerY[RT]) * towerC[RT];         printf("%lld\n",res);       }     } else {       scanf("%d%d%d%d",&Y,&R,&C,&T); T--;       t = towerSize++;       towerY[t] = Y; towerR[t] = R; towerC[t] = C; towerT[t] = T;         A = intArrayBinarySearchSmallElement(X, N, Y - R) + 1;       B = intArrayBinarySearchSmallElement(X, N, Y + 1);       if(A <= B) treeSetTower(A, B+1, t, 0);         A = intArrayBinarySearchSmallElement(X, N, Y + 1) + 1;       B = intArrayBinarySearchSmallElement(X, N, Y + R + 1);       if(A <= B) treeSetTower(A, B+1, t, 0);     }   }     if ((double)(clock()-start)/CLOCKS_PER_SEC > 2.0) puts("Time limit exceeded");     return 0; }   
  #include<cstdio> #include<vector> #include<algorithm>  #define mp       make_pair #define pb       push_back #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  typedef	vector<int>   vi; typedef	pair<int,int> pii;  const int INF=(1<<31)-1;  int n,x[100000],y[100000]; pii school[100000]; vi polyline[400000];  void makeSegtree(int u,int l,int r){ 	int yy=INF; 	for(int i=l;i<r;i++){ 		if(y[i]<yy){ // strictly decreasing 			yy=y[i]; 			polyline[u].pb(y[i]); 		} 	}  	if(l+1<r){ 		int m=(l+r)/2; 		makeSegtree(2*u+0,l,m); 		makeSegtree(2*u+1,m,r); 	} }  int query(int u,int l,int r,int x_min,int x_max,int &y_max){ 	if(x_min<=x[l] && x[r-1]<=x_max){ 		if(y_max<polyline[u].back()) return 0;  		// y_max 以下で最小の要素の番号 		int lo=0,hi=polyline[u].size()-1; 		while(lo<hi){ 			int mi=(lo+hi)/2; 			if(polyline[u][mi]<=y_max) hi=mi; 			else                       lo=mi+1; 		} 		y_max=polyline[u].back()-1; 		return polyline[u].size()-hi; 	}  	if(l+1<r){ 		int ans=0,m=(l+r)/2; 		if(x_min<=x[m-1]) ans+=query(2*u+0,l,m,x_min,x_max,y_max); 		if(x[ m ]<=x_max) ans+=query(2*u+1,m,r,x_min,x_max,y_max); 		return ans; 	} }  int main(){ 	scanf("%d",&n); 	rep(i,n) scanf("%d%d",&school[i].second,&school[i].first); 	sort(school,school+n); 	rep(i,n){ 		x[i]=school[i].first; 		y[i]=school[i].second; 	}  	makeSegtree(1,0,n);  	int nq; scanf("%d",&nq); 	while(nq--){ 		int d_max,f_min,f_max; scanf("%d%d%d",&d_max,&f_min,&f_max); 		printf("%d\n",query(1,0,n,f_min,f_max,d_max)); 	}  	return 0; } 
// #includes {{{ #include <algorithm> #include <numeric> #include <iostream> #include <string> #include <vector> #include <queue> #include <list> #include <deque> #include <stack> #include <set> #include <map> #include <cstdio> #include <cstdlib> #include <cassert> #include <cstring> #include <cmath> using namespace std; // }}} // pre-written code {{{ #define REP(i,n) for(int i=0;i<(int)(n);++i) #define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i) #define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i) #define LET(x,a) __typeof(a) x(a) //#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i) #define ALL(c) (c).begin(), (c).end() #define MP make_pair  #define EXIST(e,s) ((s).find(e)!=(s).end())  #define RESET(a) memset((a),0,sizeof(a)) #define SET(a) memset((a),-1,sizeof(a)) #define PB push_back #define DEC(it,command) __typeof(command) it=command  const int INF=0x3f3f3f3f;  typedef long long Int; typedef unsigned long long uInt; #ifdef __MINGW32__ typedef double rn; #else typedef long double rn; #endif  typedef pair<int,int> pii;  /* #ifdef MYDEBUG #include"debug.h" #include"print.h" #endif */ // }}}  //{{{ io FILE *file_in=stdin,*file_out=stdout; #define fin normal_in #define fout normal_out //const char fname[]=""; //FILE *fin=fopen(fname,"r"),*fout=fopen(fname,"w"); #ifdef __MINGW32__ #define LLD "%I64d" #define LLU "%I64u" #else #define LLD "%lld" #define LLU "%llu" #endif struct NORMAL_IN{ 	bool cnt; 	NORMAL_IN():cnt(true){} 	operator int() const {return cnt;} #define endl "\n" 	NORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,"%d",&n)!=EOF;return *this;} 	NORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,"%u",&n)!=EOF;return *this;} 	NORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;} 	NORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;} 	NORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,"%lf",&n)!=EOF;return *this;} 	NORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,"%Lf",&n)!=EOF;return *this;} 	NORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,"%s",c)!=EOF;return *this;} 	NORMAL_IN& operator>>(string &s){ 		s.clear(); 		for(bool r=false;;){ 			const char c=getchar(); 			if(c==EOF){ cnt=false; break;} 			const int t=isspace(c); 			if(!r and !t)r=true; 			if(r){ 				if(!t)s.push_back(c); 				else break; 			} 		} 		return *this; 	} 	template<class T> 		NORMAL_IN& operator>>(vector<T> &v){ 			int n;fscanf(file_in,"%d",&n); 			REP(i,n){ 				T t;*this>>t; 				v.push_back(t); 			} 		} } normal_in;  struct NORMAL_OUT{ 	NORMAL_OUT& operator<<(const int &n){fprintf(file_out,"%d",n);return *this;} 	NORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,"%u",n);return *this;} 	NORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;} 	NORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;} 	NORMAL_OUT& operator<<(const double &n){fprintf(file_out,"%lf",n);return *this;} 	NORMAL_OUT& operator<<(const long double &n){fprintf(file_out,"%Lf",n);return *this;} 	NORMAL_OUT& operator<<(const char c[]){fprintf(file_out,"%s",c);return *this;} 	NORMAL_OUT& operator<<(const string &s){fprintf(file_out,"%s",s.c_str());return *this;} } normal_out; //}}}  const Int mod =  1000003;  //{{{ mod function inline Int normalize(const Int &a, const Int &m=mod){ 	return (a%m+m)%m; }  #define NORMALIZE  inline Int sum(const Int &a, const Int &b, const Int &m=mod){ 	Int r = (a+b)%m; #ifdef NORMALIZE 	return normalize(r); #else 	return r; #endif } inline Int diff(Int a,Int b,const Int &m=mod){ 	Int r = (a-b+m)%m; #ifdef NORMALIZE 	return normalize(r); #else 	return r; #endif }  inline Int mul(Int a, Int b, const Int &m=mod){ 	Int r = a*b%m; #ifdef NORMALIZE 	return normalize(r); #else 	return r; #endif } //}}} //{{{ pow /* (x^k)%m */ inline Int powMod(Int x, Int k, Int m=mod){ 	Int res; 	if(k==0) return 1; 	res = powMod(x,k/2,m); 	res = mul(res,res,m); 	if(k%2) res = mul(res,x,m); 	return res; } //}}}  int n; char p[110]; int val[4]; Int ans[2][2][2][2]; Int ans2[2][2][2][2];  // priority // 0: () // 1: ! // 2: v ^ \  pii expr(int), term(int), fact(int);  int operate(int l, int r, char c){ 	if(c=='v'){ 		return l or r; 	}else if(c=='^'){ 		return l and r; 	}else if(c=='\\'){ 		return l and !r; 	}else{ 		assert(false); 	} }  pii expr(int i=0){ 	pii t = term(i); 	i = t.first; 	int r = t.second; 	char c = p[i]; 	while(c=='v' or c=='^' or c=='\\'){ 		i++; 		pii t0 = term(i); 		r = operate(r,t0.second,c); 		i = t0.first; 		c = p[i]; 	} 	return MP(i,r); }  pii term(int i=0){ 	int r = 0; 	if(p[i]=='!'){ 		i++; 		pii t = term(i); 		r = !t.second; 		i = t.first; 	}else{ 		pii t = fact(i); 		r = t.second; 		i = t.first; 	} 	return MP(i,r); }  pii fact(int i=0){ 	int r; 	if(p[i]=='('){ 		i++; 		pii t = expr(i); 		r=t.second; 		i = t.first; 		assert(p[i]==')'); 		i++; 	}else{ 		if(p[i]=='Z'){ 			r = val[0]; 		}else if(p[i]=='P'){ 			r = val[1]; 		}else if(p[i]=='D'){ 			r = val[2]; 		}else if(p[i]=='A'){ 			r = val[3]; 		}else{ 			assert(false); 		} 		i++; 	} 	return MP(i,r); }  void main2(){ 	fin>>p; 	Int S=0; 	REP(b,(1<<4)){ 		REP(i,4)val[i]=(b&(1<<i))?1:0; 		pii s = expr(); 		Int d=ans[val[0]][val[1]][val[2]][val[3]];  		/* 		REP(i,4)cout<<val[i]<<" "; 		cout<<endl;  		cout<<s.first<<" "<<s.second<<endl; 		cout<<d<<endl; 		cout<<endl; 		*/ 		if(s.second)S=sum(S,d,mod); 	} 	fout<<S<<endl; }  vector<vector<Int> > calc(Int da,Int d, Int a, Int all){ 	vector<vector<Int> > ret(2,vector<Int>(2)); 	ret[1][0]=diff(d,da,mod); 	ret[0][1]=diff(a,da,mod); 	ret[1][1]=da; 	ret[0][0]=diff(all,sum(ret[1][1],sum(ret[0][1],ret[1][0],mod),mod),mod); 	/* 	cout<<"input: "; 	cout<<da<<" "<<a<<" "<<d<<" "<<all<<endl; 	cout<<"result: "<<endl; 	REP(i,2){ 		REP(j,2)cout<<ret[i][j]<<" "; 		cout<<endl; 	} 	cout<<endl; 	*/ 	return ret; }  void init(){ 	memset(ans,0,sizeof(ans)); 	vector<vector<Int> > all,z,zp; 	all=calc( 			powMod(2,n,mod), 			powMod(2,powMod(2,n-1,mod-1),mod), 			powMod(2,n+1,mod), 			powMod(2,powMod(2,n,mod-1),mod) 			); 	z=calc( 			powMod(2,n-1,mod), 			powMod(2,diff(powMod(2,n-1,mod-1),1,mod-1),mod), 			powMod(2,n,mod), 			powMod(2,diff(powMod(2,n,mod-1),1,mod-1),mod) 		  ); 	zp=calc( 			powMod(2,n-1,mod), 			powMod(2,diff(powMod(2,n-1,mod-1),1,mod-1),mod), 			powMod(2,n-1,mod), 			powMod(2,diff(powMod(2,n,mod-1),2,mod-1),mod) 		   ); 	REP(d,2)REP(a,2){ 		vector<vector<Int> > v = calc(zp[d][a],z[d][a],z[d][a],all[d][a]); 		REP(i,2)REP(j,2)ans[i][j][d][a]=v[i][j]; 	} 	//REP(i,2)REP(j,2)REP(d,2)REP(a,2)cout<<i<<" "<<j<<" "<<d<<" "<<a<<" "<<ans[i][j][d][a]<<endl; }  bool is_Z(const vector<int> &v){ 	return v[0]==0; } bool is_P(const vector<int> &v){ 	return v[(1<<n)-1]==1; } bool is_D(const vector<int> &v){ 	REP(b,(1<<n)){ 		int bn=(1<<n)-1-b; 		if(v[b]!=1-v[bn])return false; 	} 	return true; } bool is_A(const vector<int> &v){ 	REP(i,n){ 		REP(a,(1<<i))REP(a2,(1<<(n-1-i))){ 			int A1 = (a2<<(i+1))+a; 			int A2 = (a2<<(i+1))+(1<<i)+a; 			if(v[A1]!=v[A2])continue; 			REP(b,(1<<i))REP(b2,(1<<(n-1-i))){ 				int B1 = (b2<<(i+1))+b; 				int B2 = (b2<<(i+1))+(1<<i)+b; 				if(v[B1]!=v[B2])return false; 			} 		} 	} 	return true; }  void calc(){ 	const int B=(1<<n);  	/* 	int s=0; 	REP(t,1<<B){ 		vector<int> v(B); 		REP(b,B){ 			v[b]=(t&(1<<b))?1:0; 		} 		if(is_A(v))s++; 	} 	cout<<s<<endl; 	return; 	*/  	memset(ans2,0,sizeof(ans2)); 	REP(p,1<<4){ 		int i = (p&(1<<0))?1:0; 		int j = (p&(1<<1))?1:0; 		int k = (p&(1<<2))?1:0; 		int l = (p&(1<<3))?1:0; 		REP(t,1<<B){ 			vector<int> v(B); 			REP(b,B){ 				v[b]=(t&(1<<b))?1:0; 			} 			bool valid=true; 			if(i){ 				if(!is_Z(v))valid=false; 			}else{ 				if(is_Z(v))valid=false; 			} 			if(j){ 				if(!is_P(v))valid=false; 			}else{ 				if(is_P(v))valid=false; 			} 			if(k){ 				if(!is_D(v))valid=false; 			}else{ 				if(is_D(v))valid=false; 			} 			if(l){ 				if(!is_A(v))valid=false; 			}else{ 				if(is_A(v))valid=false; 			} 			if(valid)ans2[i][j][k][l]++; 		} 	} 	REP(i,2)REP(j,2)REP(k,2)REP(l,2){ 		cout<<i<<" "<<j<<" "<<k<<" "<<l<<" "<<ans[i][j][k][l]<<" "<<ans2[i][j][k][l]<<endl; 	} }  //{{{ main function int main() { 	fin>>n; 	init(); //	calc(); //	return 0; 	int T;fin>>T; 	REP(ct, T){ 		//		fout<<"Case "<<ct+1<<": "; 		main2(); 	} 	return 0; } //}}}
#include <cmath> #include <cstdio> #include <vector> #include <algorithm> using namespace std;   #define n	55 #define m	40005 #define P	1000000007 #define For(i,a,b)	for(int i=a;i<=b;i++) #define Rep(i,a,b)	for(int i=a;i>=b;i--)   #define CH	(ch=getchar()) int		IN(){ 		int x=0,ch; 		for	(;CH<'0'||ch>'9';); 		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0'; 		return	x; } int		Pow(int a,int b,const int&mo=P){ 		int ret=1; 		for (;b;b>>=1,a=1ll*a*a%mo) 			if	(b&1)	ret=1ll*ret*a%mo; 		return	ret; }   #define I64	long long const	I64	LIM=1ll<<61; const	int	mo[3]={167772161,469762049,1004535809}; int 	T,Q,Max,L[m],R[m],GT[m],Ans[m*20]; I64		t[n][n],ret[m][4];   struct	Nod{int K,ID;}; vector<Nod>G[n][n];    struct	Mat{ 		int	N,A[n][n];  		void	Init(int _N)	{ 			N=_N; 			For(i,1,N)	For(j,1,N)	A[i][j]=(i==j); 		}   		Mat	operator *	(const Mat&b){ 			Mat	c,a=*this;	c.N=N; 			For(i,1,N)	For(j,1,N)	t[i][j]=0; 			For(k,1,N)	For(i,1,N)	if	(a.A[i][k]) 			For(j,i,N)	if	(b.A[k][j])	{ 				t[i][j]=1ll*a.A[i][k]*b.A[k][j]+t[i][j]; 				if	(t[i][j]>=LIM)	t[i][j]%=P; 			} 			For(i,1,N)	For(j,i,N)	c.A[i][j]=c.A[j][i]=t[i][j]%P; 			return	c; 		} 		int		DET(){ 			int ret=1; 			for	(int i=1,j;i<=N;i++){ 				for (j=i;j<=N&&!A[j][i];j++); 				if	(j>N)	return	0; 				if	(j!=i)	{ 					ret*=-1; 					For(k,i,N)	swap(A[j][k],A[i][k]); 				}   				For(j,i+1,N)if	(A[j][i]){ 					int t=1ll*A[j][i]*Pow(A[i][i],P-2)%P; 					For(k,i,N)	if	(A[i][k])	A[j][k]=(-1ll*t*A[i][k]+A[j][k])%P; 				} 			} 			For(i,1,N)	ret=1ll*ret*A[i][i]%P; 			return	ret; 		} 		int		tra(){ 			int ret=0; 			For(i,1,N)	ret=(ret+A[i][i])%P; 			return	ret; 		} };   struct	Gra{ 		int 	N,M,A[n],B[n],Y[n],F[n],G[n],Ans[m]; 		Mat		H;   		void	Init(){ 			N=IN();	M=IN();	H.Init(N); 			For(i,1,M){ 				int u=IN(),v=IN();	H.A[u][v]=H.A[v][u]=1; 			} 		} 		void	Main(){ 			For(d,0,N)	{ 				Mat	tmp=H;	For(i,1,N)	tmp.A[i][i]-=d;	Y[d]=tmp.DET(); 			}	B[0]=1; 			For(i,1,N)	B[i]=1ll*B[i-1]*i%P; 			For(i,0,N)	B[i]=Pow(B[i],P-2);   			G[0]=1; 			For(i,0,N)	{ 				For(j,0,N)	F[j]=G[j],G[j]=0; 				For(j,0,N)	G[j+1]=(G[j+1]+F[j])%P,G[j]=(-1ll*F[j]*i+G[j])%P; 			}   			For(i,0,N)	{ 				int x=1ll*Y[i]*B[i]%P*B[N-i]*(((N-i)&1)?-1:1)%P; 				For(j,0,N+1)	F[j]=G[j]; 				Rep(j,N+1,1)	{ 					int t=F[j]; 					F[j-1]=(1ll*t*i+F[j-1])%P; 					A[j-1]=(1ll*t*x+A[j-1])%P; 				} 			} 			For(i,0,N-1)A[i]=1ll*A[i]*Pow(A[N],P-2)%P;	A[N]=1;   			Mat	tmp;	tmp.Init(N); 			For(i,1,N)	tmp=tmp*H,Ans[i]=tmp.tra(); 			For(i,N+1,Max)	For(j,0,N-1) 				Ans[i]=(-1ll*A[j]*Ans[i-N+j]+Ans[i])%P; 			Ans[0]=N; 			For(i,0,Max)	Ans[i]=(Ans[i]+P)%P; 		} }A[n];   struct	CON{ 		int 	M,mo,Ans,A[m],B[m],rev[m],w[2][m];   		void	reset(){ 			for (int i=0;i<M;i++)	A[i]=0;	Ans=0; 		} 		void	Pre(int p){ 			for	(M=1;M<=Max;M<<=1);	M<<=1;	mo=p; 			int a=Pow(3,(mo-1)/M,mo),b=Pow(a,mo-2,mo);   			for (int i=0;i<M;i++)	{ 				w[0][i]=i?1ll*w[0][i-1]*a%mo:1; 				w[1][i]=i?1ll*w[1][i-1]*b%mo:1; 				for (int x=i,t=1;t<M;t<<=1,x>>=1)	(rev[i]<<=1)|=x&1; 			} 		} 		void	NTT(int*A,int f){ 			for (int i=0;i<M;i++) 				if	(rev[i]>i)	swap(A[i],A[rev[i]]); 			for (int i=1;i<M;i<<=1) 			for (int j=0,t=M/(i<<1);j<M;j+=i<<1) 			for (int k=0,l=0;k<i;k++,l+=t){ 				int	x=A[j+k],y=1ll*A[j+k+i]*w[f][l]%mo; 				A[j+k]=(x+y)%mo;	A[j+k+i]=(x-y)%mo; 			} 			if	(f)	{ 				int rev=Pow(M,mo-2,mo); 				for (int i=0;i<M;i++)	A[i]=1ll*A[i]*rev%mo; 			} 		} 		void	Mult(){	 			NTT(A,0); 			for (int i=0;i<M;i++)	A[i]=1ll*A[i]*B[i]%mo;	NTT(A,1); 		} }FFT[3];   int		main(){ 		T=IN(); 		For(i,1,T)	A[i].Init();	Q=IN(); 		For(i,1,Q)	{ 			int l=IN(),r=IN(),k=IN();	Max=max(Max,k); 			G[l][r].push_back((Nod){k,i}); 		}   		L[0]=1; 		For(i,1,Max)	L[i]=1ll*L[i-1]*i%P; 		For(i,0,Max)	R[i]=Pow(L[i],P-2); 		For(i,1,T)	A[i].Main();   		For(k,0,2)	{ 			FFT[k].Pre(mo[k]); 			For(i,0,Max)	FFT[k].B[i]=(((i&1)?-1:1)*R[i]+P)%P%mo[k]; 			FFT[k].NTT(FFT[k].B,0); 		}    		int	inv1=Pow(mo[0],mo[1]-2,mo[1]),inv2=Pow(1ll*mo[0]*mo[1]%mo[2],mo[2]-2,mo[2]); 		For(l,1,T)	{ 			For(i,0,Max)	GT[i]=R[i]; 			For(r,l,T){ 				For(i,0,Max)GT[i]=1ll*GT[i]*A[r].Ans[i]%P; 				if	(!G[l][r].size())	continue;   				For(k,0,2)	FFT[k].reset(); 				For(i,0,Max)For(k,0,2)	FFT[k].A[i]=GT[i]%mo[k]; 				For(k,0,2)	{ 					FFT[k].Mult(); 					For(i,0,Max)	ret[i][k]=(FFT[k].A[i]+mo[k])%mo[k]; 				}  				For(i,0,Max)	{ 					I64	x=ret[i][0]+1ll*(ret[i][1]-ret[i][0]+mo[1])*inv1%mo[1]*mo[0]; 					I64	y=x+1ll*(ret[i][2]-x%mo[2]+mo[2])*inv2%mo[2]*mo[0]%P*mo[1]; 					ret[i][3]=y%P; 				}   				int siz=G[l][r].size();	ret[0][3]=0; 				For(i,1,Max)	{ 					ret[i][3]=1ll*ret[i][3]*L[i]+ret[i-1][3]; 					if	(ret[i][3]>=LIM)	ret[i][3]%=P; 				} 				For(i,1,siz)	Ans[G[l][r][i-1].ID]=ret[G[l][r][i-1].K][3]%P; 			} 		} 		For(i,1,Q)	printf("%d\n",(Ans[i]+P)%P); }
#include <vector> #include <list> #include <cassert> #include <sstream> #include <map> #include <set> #include <climits> #include <deque> #include <fstream> #include <stack> #include <bitset> #include <stack> #include <queue> #include <algorithm> #include <functional> #include <numeric> #include <cstring> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> using namespace std;   template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}   #define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) #define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i) #define REP(i,n) FOR(i,0,n) #define DEP(i,n) REV(i,n,0) #define PB push_back #define PP pop() #define EM empty() #define INF 1000000000 #define PF push_front #define ALL(x) x.begin(),x.end() #define SORT(x) sort(ALL(x)) #define V(x) vector< x > #define Debug false #define PRINT(x) cout << #x << " " << x << endl #define LET(x,a) __typeof(a) x(a) #define IFOR(i,a,b) for(LET(i,a);i!=(b);++i) #define EACH(it,v) IFOR(it,v.begin(),v.end()) #define PRESENT(c,x) ((c).find(x) != (c).end()) #define SZ(x) x.size() #define CPRESENT(c,x) (find(c.begin(),c.end(),x) != (c).end()) #define D(N) int N #define S(N) scanf("%d",&N) #define FASTIO 1   typedef pair<int,int> PI; typedef pair<int,PI> TRI; typedef V( int ) VI; typedef V( PI ) VII; typedef V( string ) VS; typedef long long LL; typedef long double LD;   /* FastIO, generally required these days ;) */   #ifndef FASTIO char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20]; inline int input(int flag=0) {   while(*ipos <= 32) ++ipos; if ( flag ) return (*ipos++ - '0'); /* For getting Boolean Characters */ int x=0, neg = 0;char c; while( true ) { c=*ipos++; if(c == '-') neg = 1; else { if (c<=32) return neg?-x:x; x=(x<<1)+(x<<3)+c-'0'; } } } inline void output(int x,int flag) { int y,dig=0; while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;} while (dig--) *opos++=DIP[dig]; *opos++= flag ? '\n' : ' '; } inline void InitFASTIO() { ipos = InpFile; opos = OutFile; fread_unlocked(InpFile,20000000,1,stdin); } inline void FlushFASTIO() { fwrite_unlocked(OutFile,opos-OutFile,1,stdout); } #endif   /* Main Code Starts from here */   #define Max 100 const int N = 20;   int sum[2][Max][Max][3], size[2][Max], rank[2][N][N][N]; int Input[10][3], Given[10], Iorders[10]; //int list[10][Max*10], start[10], end[10];   int numSolutions[10][Max], totalSolutions[10][Max][Max]; set<int> forwhich[10][Max]; bool isStillValid[10][Max]; int validSolutions[10][Max*10], ssize[10];     int tmpSolution[3], visited[Max];   void init() { memset(visited,0,sizeof visited); } bool isEmpty(int j) { return (ssize[j] == 0); } bool allEmpty() { REP(j,10) if(!isEmpty(j)) return false; return true; } void makeEmpty() { memset(ssize,0,sizeof ssize); } bool isSet(VI& present) { REP(i,3) if(visited[present[i]]) return true; return false; } void setVal(VI& present,int which,int total,int index) { REP(l,3) present[l] = sum[which][total][index][l]; } void Set(VI& present) { REP(i,3) visited[present[i]] = 1; } void unSet(VI& present) { REP(i,3) visited[present[i]] = 0; }     void pre() {   int t = 0, size1, size2; FOR(i,1,19) FOR(j,i+1,19) FOR(k,j+1,19) {   t = i + j + k; size1 = size[0][t]; size2 = size[1][t];   sum[0][t][size1][0] = i; sum[0][t][size1][1] = j; sum[0][t][size1][2] = k; rank[0][i][j][k] = size[0][t]++;   if(i < 7 && j > 6 && j < 13 && k > 12 && k < 19) { sum[1][t][size2][0] = i; sum[1][t][size2][1] = j; sum[1][t][size2][2] = k; rank[1][i][j][k] = size[1][t]++; } } }     void undoit(int index,int oldI, int sf, VI& track, int order) { if(index > 5 || order < 0) return; if(index == 5) { REP(i,5) { totalSolutions[i][track[i]][order] -= 1; if(!totalSolutions[i][track[i]][order]) { // This means we have eliminated one of the possible combination for that player and combination. numSolutions[i][track[i]] -= 1; if(numSolutions[i][track[i]] == 1) { //forwhich[i][track[i]].erase(order); // This tell us that pair of [Player,Combination] has a unique solution [5,order]. validSolutions[i][ssize[i]++] = track[i]; // Put it into the ith player's valid regime. if(Debug) printf("I inserted this %dth index for player %d\n",track[i],i); } forwhich[i][track[i]].erase(order); // This tell us that pair of [Player,Combination] has a unique solution [5,order]. } } } else { assert(index <= 4);VI present(5,0); int start = index == oldI ? sf : 0, end = index == oldI ? sf+1 : size[0][Given[index]]; FOR(i,start,end) { track[index] = i; setVal(present,0,Given[index],i); if(!isSet(present) && isStillValid[index][i]) { Set(present);undoit(index+1,oldI,sf,track,order); unSet(present); } } } } void doit(int index,VI& track, int order) { if(index > 5 || order < 0) return; if(index == 5) { REP(i,5) { if(!totalSolutions[i][track[i]][order]) { numSolutions[i][track[i]] += 1; // Number of Solution for same index, track[index] but different Combination of Given[5]. forwhich[i][track[i]].insert(order); // If At the end, this is one, then we can add it to possible solutions. // It means that if the Player has this combination then, there can be only one possible solution. And hence he knows the Solution, and hence wins. } totalSolutions[i][track[i]][order] += 1; // Number of solutions for same combination of Given[5]. } } else { assert(index <= 4); VI present(5,0); REP(i,size[0][Given[index]]) { track[index] = i; setVal(present,0,Given[index],i); //if(Debug) REP(j,3) printf("i == %d, index == %d, %d%c",i,index,present[j],j == 2 ? 10 : 32); if(!isSet(present)) { Set(present);doit(index+1,track,order); unSet(present); } } } }   void generateInput() {   FILE *f = freopen("in.txt","w",stdout);   srand(time(NULL)); int kases = 100; cout << kases << endl; set<int> t; while(kases--) {   t.clear(); int x = rand()%6+1, y = rand()%6+7, z = rand()%6+13; t.insert(x); t.insert(y); t.insert(z);   vector<TRI> tmp; REP(i,5) { do { x = rand()%18 + 1; } while(t.count(x)); t.insert(x); do { y = rand()%18 + 1; } while(t.count(y)); t.insert(y); do { z = rand()%18 + 1; } while(t.count(z)); t.insert(z); tmp.PB(TRI(x,PI(y,z))); } int a[] = {0,1,2,3,4}; random_shuffle(a,a+5); REP(i,5) { printf("%d %d %d\n",tmp[a[i]].first,tmp[a[i]].second.first, tmp[a[i]].second.second); } puts(""); }   fclose(f); }     int main() {     //double stime = clock();   //generateInput(); //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout);     pre(); int kases; scanf("%d",&kases); while(kases--) {   int total = 0, winner = -1; REP(i,5) { Given[i] = 0; REP(j,3) { scanf("%d",&Input[i][j]); total += Input[i][j]; Given[i] += Input[i][j]; // Given[i] --> total sum for the ith player. } sort(Input[i],Input[i]+3); Iorders[i] = rank[0][Input[i][0]][Input[i][1]][Input[i][2]]; // Represents the rank of the given input combination in the precomputed one. } Given[5] = 171 - total; // This is the sum of the three cards kept before starting the game.   if(Debug) { REP(i,5) printf("The Ranks -- for %d it is %d\n",i+1,Iorders[i]); REP(i,6) printf("Initial sum for %d is -- %d\n",i+1,Given[i]); }   // Get all possible combinations for Given[5] == Required Sum. // For every Player, and a corresponsing triplet, get how many solutions are possible // If only one when we need to consider that else not. // This will form the initial construction part.   memset(visited,0,sizeof visited); // For, browsing through valid possibilites. memset(numSolutions,0, sizeof numSolutions); // numSolutions --> Number of Possibilites [of three cards kept] for the pair {Player, Index}. memset(totalSolutions,0, sizeof totalSolutions); // total number of possibilities for triplet {Player, Index1, [Three cards's index, Index2]}. memset(isStillValid,-1,sizeof isStillValid); // Is [Player, Index] valid ? That is can Player have Index Combination ? //memset(forwhich,-1,sizeof forwhich); // For which [Three Card's Index] is numSolutions[player][index] = 1. REP(i,10) REP(j,Max) forwhich[i][j].clear();     VI track(5,0), present(5,0); // Keeps Track of the index of a particular player while browsing through the solution. REP(i,size[1][Given[5]]) { // For all Possible Combinations of Sum Given[5]. setVal(present,1,Given[5],i); Set(present); doit(0,track,i); unSet(present); }   // Now, we have what everyone knows at first hand. init();   // What are the possible solutions ? makeEmpty(); // validSolutions[i] // Contians the valid solutions for each and every person.   REP(i,5) { if(Debug) { printf("The initial valid indexes for player %d are - ", i+1); } REP(j,size[0][Given[i]]) { if(numSolutions[i][j] == 1) { // Means if one of these is the combination, then we have a unique answer. // These are the only ones which are valid. validSolutions[i][ssize[i]++] = j; if(Debug) { printf("%d ",j); } } } if(Debug) puts(""); }     while(!allEmpty() && winner == -1) {   // We start the game from here. REP(player,5) { // Now, Start the Game. while(!isEmpty(player)) { // We have some to invalidate, or something to verify on. int top = validSolutions[player][--ssize[player]];   // Do we have the combination top ? if(top == Iorders[player]) { // So This player wins. winner = player; makeEmpty(); break; }   // Else, invalidate various other solutions, add if required. // Now Validate, and Unvalidate things. int order = forwhich[player][top].size() ? *(forwhich[player][top].begin()) : -1; // For which combination of the before kept three cards ?   if(Debug) { printf("Top is %d, and Order is %d\n",top,order); } setVal(present,1,Given[5],order); Set(present); undoit(0,player,top,track,order); unSet(present);   isStillValid[player][top] = false; // No, player can't have the combination with index top. } } }   if(winner != -1) ++winner; printf("%d\n",winner); }   //double etime = clock(); //cerr << (etime-stime)/(CLOCKS_PER_SEC) << endl; return 0; } 
#include <vector>  #include <list>  #include <map>  #include <set>  #include <queue> #include <stack>  #include <bitset>  #include <algorithm>  #include <numeric>  #include <utility>  #include <sstream>  #include <iostream>  #include <iomanip>  #include <cstdio>  #include <cmath>  #include <cstdlib>  #include <ctime>  #include <cstring>   using namespace std;   typedef long long ll;  typedef pair<int, int> pii;  #define INF 1000000000 #define pb push_back  #define itr iterator  #define sz size()  #define mp make_pair  char N[1000]; char prevpref[1000]; int mod = 1000000007; long long nmod; int len;  int pd[110][10][2][2]; int pd2[110][10][2][2][2];  int calc_incr(int cur, int want, bool before_nine, bool nonzero, bool eq) { 	if (cur == len-1) { 		return !before_nine && !eq; 	}  	int& ans = pd2[cur][want][before_nine][nonzero][eq]; 	if (ans == -1) { 		ans = 0; 		for (int dig = 0; dig <= 9; dig++) { 			if (eq && dig > N[cur]) break; 			if (dig == want && !(want == 0 && !nonzero)) continue; 			 			bool new_bef9 = (before_nine && dig == 9) || (dig + 1) % 10 == want; 			 			ans += calc_incr(cur+1, want, new_bef9, nonzero || dig, eq && N[cur]==dig); 			if (ans >= mod) ans -= mod; 		} 	}  	return ans; }  int calc(int cur, int want, bool nonzero, bool eq) { 	if (cur == len-1) { 		return 1; 	}  	int& ans = pd[cur][want][nonzero][eq]; 	if (ans == -1) { 		ans = 0; 		for (int dig = 0; dig <= 9; dig++) { 			if (eq && dig > N[cur]) break; 			if (dig == want && !(want == 0 && !nonzero)) continue;  			ans += calc(cur+1, want, nonzero || dig, eq && N[cur]==dig); 			if (ans >= mod) ans -= mod; 		} 	}  	return ans; }  int main() { 	scanf("%s", N); 	memset(pd,-1,sizeof(pd)); 	memset(pd2,-1,sizeof(pd2));  	len = strlen(N); 	for (int i = 0; i < len; i++) { 		N[i] -= '0'; 		nmod = (nmod * 10 + N[i]) % mod; 	}  	if (len > 1) { 		for (int i = 0; i < len-1; i++) prevpref[i] = N[i]; 		prevpref[len-2]--;  		for (int i = len-2; i >= 0; i--) { 			if (prevpref[i] < 0) { 				prevpref[i] += 10; 				prevpref[i-1]--; 			} 		} 	}  	long long tot = ((nmod)*(nmod-1))%mod; 	tot = (tot*500000004) % mod; 	tot = (tot + nmod) % mod; 	tot = (tot * 10) % mod;  	//printf("tot=%lld\n", tot);  	for (int i = 0; i < 10; i++) { 		//printf("stats for digit %d\n", i); 		long long bef = tot; 		long long rem = calc(0, i, 0, 1); 		//printf("number of ok prefixes: %lld\n", rem); 		rem = rem * ( (i*(i+1)/2) + ((9-i)*(10-i)/2) ); 		if (i != 0) rem = (rem - i) % mod; 		tot = (((tot - rem) % mod) + mod) % mod;  		//printf("rem = %lld\n", rem);  		bool found = false; 		for (int k = 0; k < len-1; k++) { 			if (N[k] == i) found = true; 		} 		if (!found) { 			long long rem = ( (i*(i+1)/2) + ((9-i)*(10-i)/2) ); 			if (len == 1 && i != 0) rem = (rem - i) % mod;  			int sm = min(i-1, (int)N[len-1]); 			long long rl = (sm+1)*(sm+2)/2; 			if (len == 1 && sm != -1) rl = (rl - sm - 1) % mod;  			int big = min(9, max(i, (int)N[len-1])); 			rl += (big-i)*(big+1-i) / 2;  			//printf("fix %lld - %lld = %lld\n", rem, rl, rem - rl); 			tot += rem - rl; 			tot %= mod; 		}  		 		  		rem = calc_incr(0, i, 0, 0, 1); 		//printf("incr prefixes: %lld\n", rem); 		rem = rem * i * (9-i); 		tot = (((tot - rem) % mod) + mod) % mod;  		//printf("rem = %lld\n", rem);  		if (len > 1) { 			bool found = false; 			for (int k = 0; k < len-1; k++) { 				if (prevpref[k] == i) found = true; 			} 			for (int k = 0; k < len-1; k++) { 				if (N[k] == i) found = true; 			} 			if (!found) { 				long long inc = i * (9-i); 				int sm = min(i-1, (int)N[len-1]); 				long long rl = (sm+1) * (9-i);  				tot += inc - rl; 				//printf("fix: %lld\n", inc - rl); 				tot %= mod; 			}  		}  		//printf("after rem %d -> %lld sub = %lld\n", i, tot, bef-tot); 		//printf("\n"); 	}  	printf("%lld\n", tot); }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 1050 #define P 1000000007 #define ll long long ll Inv[N],InJ[N],JC[N],ans; int t,n,m; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } ll Q_Power(ll x,int y,int p)  {  	ll z=true;  	while (y) z=y&1?z*x%p:z,x=x*x%p,y >>= true;  	return z;  } inline ll C(int x,int y)  {return JC[x]*InJ[y]%P*InJ[x-y]%P;} void Pretreat()  {  	JC[0]=Inv[0]=InJ[0]=JC[1]=Inv[1]=InJ[1]=true;  	for (int i=2;i<N;i++)  	  JC[i]=JC[i-1]*i%P,Inv[i]=Inv[P%i]*(P-P/i)%P,  	  InJ[i]=InJ[i-1]*Inv[i]%P;  	return;  } int GetAns(int x,int y)  {  	ans = false;  	for (int i=0;i<=x;i++)  	  ans=(ans+(i&1?-1:1)*C(x,i)*Q_Power(2,Q_Power(y+1,x-i,P-1)*  	  	Q_Power(y,i,P-1)%(P-1),P))%P,ans=(ans+P)%P;  	return ans;  } int main()  {  	//freopen("input.txt","r",stdin);  	t=Read();Pretreat();  	while (t--)  	 {  	 	n=Read();m=Read();  	 	printf("%d\n",(GetAns(n,m)-GetAns(n,m-1)+P)%P);  	 }  	return 0;  }
//Data Structure includes #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string>   #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>   using namespace std;   #define FOR(i,a,b)					for(int i=a;i<b;i++) #define REP(i,n)					FOR(i,0,n) #define pb						 	push_back #define mp						 	make_pair #define s(n)						scanf("%d",&n) #define sl(n) 						scanf("%lld",&n) #define sf(n) 						scanf("%lf",&n) #define ss(n) 						scanf("%s",n) #define fill(a,v) 					memset(a, v, sizeof a) #define sz							size() #define INF							(int)1e9 #define EPS							1e-9 #define bitcount					__builtin_popcount #define all(x)						x.begin(), x.end() #define gcd							__gcd #define maX(a,b)					(a>b?a:b) #define miN(a,b)					(a<b?a:b)   typedef vector<int> VI; typedef vector<vector<int> > VVI; typedef long long LL; typedef pair<int, int > PII;   int testnum;   int len[] = {5,4,3,3,2,2,1};   int val[7][5] = { {1,1,1,1,1}, 				{2,1,1,1,0}, 				{2,2,1,0,0}, 				{3,1,1,0,0}, 				{3,2,0,0,0}, 				{4,1,0,0,0}, 				{5,0,0,0,0}	}; 				 int coeff[7][7] = { {0,60,30,20,10,5,1}, 					{0,0,6,6,4,3,1}, 					{0,0,0,0,2,1,1}, 					{0,0,0,0,1,2,1}, 					{0,0,0,0,0,0,1}, 					{0,0,0,0,0,0,1}, 					{0,0,0,0,0,0,0}	}; 					 int reps[] = {1,2,2,3,3,4,5}; int frac[] = {120,6,2,2,1,1,1};   LL f[7], g[7], h[7]; LL F[7], G[7], H[7];   LL acc[6];   int N,L,X,K; const LL mod = 1000000007ll;     LL npoly[6][6] = {	{1, mod-5, 10, mod-10, 5, mod-1}, 					{1, mod-3, 2, 2, mod-3, 1}, 					{1, mod-1, mod-2, 2, 1, mod-1}, 					{1, mod-2, 1, mod-1, 2, mod-1}, 					{1, 0, mod-1, mod-1, 0, 1}, 					{1, mod-1, 0, 0, mod-1, 1}	};     pair<LL,LL> extGCD(LL a,LL b) { 	if(b==0) return mp(1ll,0ll); 	else 	{ 		pair<LL,LL> temp = extGCD(b,a%b); 		return mp( temp.second, temp.first - (a/b) * temp.second); 	} }     LL inverse(LL a) { 	pair<LL,LL> temp = extGCD(a,mod); 	LL x = temp.first; 	while(x<0) x+=mod; 	while(x>=mod) x-=mod; 	return x; }     LL nCk(LL n,LL k) { 	if(k>n/2) k=n-k; 	LL num=1,den=1; 	 	for(LL i=1;i<=k;i++) 	{ 		num = (num*n) % mod; 		den = (den*i) % mod; 		n--; 	} 	 	return (num * inverse(den)) % mod; }       LL coeffPoly(LL ind,LL n,LL k) { 	if(k<0) return 0; 	 	if(ind==0) 		return nCk(k+n-1, n-1); 		 	if(ind==1) 	{ 		LL ans = nCk(k+n-1, n-1); 		return (k&1) ? mod-ans : ans; 	} 	 	if(ind==2) 	{ 		assert(n==1); 		LL z = k%4; 		if(z==0) return 1; 		if(z==1) return 0; 		if(z==2) return mod-1; 		if(z==3) return 0; 	} 	 	if(ind==3) 	{ 		assert(n==1); 		LL z = k%3; 		if(z==0) return 1; 		if(z==1) return mod-1; 		if(z==2) return 0; 	} 	 	return 0; }     LL calc(LL ind,LL S,LL N) { 	if(S<0) return 0; 	 	LL ans=0; 	 	if(ind==0) 	{ 		for(int i=0;i<6;i++) 		{ 			ans = (ans + (coeffPoly(0,6,S-N*i) * npoly[0][i])) % mod; 		} 		return ans; 	} 	 	if(ind==1) 	{ 		for(int i=0;i<6;i++) 		{ 			LL K = S-N*i; 			 			LL term1 = (coeffPoly(1,1,K) * inverse(32)) % mod; 			 			LL term21 = (coeffPoly(0,5,K) * (31)) % mod; 			LL term22 = (coeffPoly(0,5,K-1) * (mod-26)) % mod; 			LL term23 = (coeffPoly(0,5,K-2) * (16)) % mod; 			LL term24 = (coeffPoly(0,5,K-3) * (mod-6)) % mod; 			LL term25 = (coeffPoly(0,5,K-4) * (1)) % mod; 			 			LL term2 = ((term21+term22+term23+term24+term25) * inverse(32)) % mod; 			 			ans = (ans + (term1+term2) * npoly[1][i]) % mod; 		} 		return ans; 	} 	 	if(ind==2) 	{ 		for(int i=0;i<6;i++) 		{ 			LL K = S-N*i; 			 			LL term11 = (coeffPoly(1,2,K) * (3)) % mod; 			LL term12 = (coeffPoly(1,2,K-1) * (2)) % mod; 			 			LL term1 = ((term11+term12) * inverse(16)) % mod; 			 			LL term21 = (coeffPoly(0,4,K) * (13)) % mod; 			LL term22 = (coeffPoly(0,4,K-1) * (mod-16)) % mod; 			LL term23 = (coeffPoly(0,4,K-2) * (9)) % mod; 			LL term24 = (coeffPoly(0,4,K-3) * (mod-2)) % mod; 			 			LL term2 = ((term21+term22+term23+term24) * inverse(16)) % mod; 			 			ans = (ans + (term1+term2) * npoly[2][i]) % mod; 		} 		return ans; 	} 	 	if(ind==3) 	{ 		for(int i=0;i<6;i++) 		{ 			LL K = S-N*i; 			 			LL term1 = (coeffPoly(3,1,K-1) * inverse(9)) % mod; 			 			LL term21 = (coeffPoly(0,4,K) * (9)) % mod; 			LL term22 = (coeffPoly(0,4,K-1) * (mod-10)) % mod; 			LL term23 = (coeffPoly(0,4,K-2) * (5)) % mod; 			LL term24 = (coeffPoly(0,4,K-3) * (mod-1)) % mod; 			 			LL term2 = ((term21+term22+term23+term24) * inverse(9)) % mod; 			 			ans = (ans + (term1+term2) * npoly[3][i]) % mod; 		} 		return ans; 	} 	 	if(ind==4) 	{ 		for(int i=0;i<6;i++) 		{ 			LL K = S-N*i; 			 			LL term11 = (coeffPoly(3,1,K) * (2)) % mod; 			LL term12 = (coeffPoly(3,1,K-1) * (1)) % mod; 			 			LL term1 = ((term11+term12) * inverse(9)) % mod; 			 			LL term21 = (coeffPoly(0,3,K) * (47)) % mod; 			LL term22 = (coeffPoly(0,3,K-1) * (mod-52)) % mod; 			LL term23 = (coeffPoly(0,3,K-2) * (17)) % mod; 			 			LL term2 = ((term21+term22+term23) * inverse(72)) % mod; 			 			LL term3 = (coeffPoly(1,1,K) * inverse(8)) % mod; 			 			ans = (ans + (term1+term2+term3) * npoly[4][i]) % mod; 		} 		return ans; 	} 	 	if(ind==5) 	{ 		for(int i=0;i<6;i++) 		{ 			LL K = S-N*i; 			 			LL term1 = (coeffPoly(2,1,K-1) * inverse(4)) % mod; 			 			LL term21 = (coeffPoly(0,3,K) * (15)) % mod; 			LL term22 = (coeffPoly(0,3,K-1) * (mod-16)) % mod; 			LL term23 = (coeffPoly(0,3,K-2) * (5)) % mod; 			 			LL term2 = ((term21+term22+term23) * inverse(16)) % mod; 			 			LL term3 = (coeffPoly(1,1,K) * inverse(16)) % mod; 			 			ans = (ans + (term1+term2+term3) * npoly[5][i]) % mod; 		} 		return ans; 	} 	 	if(ind==6) 	{ 		return min(N, 1 + S/5); 	} }   LL calcD(LL ind,LL S,LL X) { 	LL cnt=0; 	S-=5; 	 	 	LL z = calc(ind,S,X); 	 	return z; }   LL power(LL x,LL n) { 	LL ans=1; 	while(n) 	{ 		if(n&1) ans = (ans*x)%mod; 		x = (x*x)%mod; 		n >>= 1; 	} 	return ans; }         void preprocess() {     }   void solve() { 	fill(f,0); fill(g,0); fill(h,0); 	fill(F,0); fill(G,0); fill(H,0); 	fill(acc,0); 	 	for(int S=L;S<=N;S++) 	{ 		for(int i=0;i<7;i++) 		{ 			f[i] = calcD(i,S,X); 			F[i] = power(X,len[i]); 			 		} 		 		for(int i=6;i>=0;i--) 		{ 			g[i]=f[i]; 			G[i]=F[i]; 			 			for(int j=0;j<7;j++) 			{ 				g[i] = (g[i] + mod - (coeff[i][j]*h[j])%mod ) % mod; 				G[i] = (G[i] + mod - (coeff[i][j]*H[j])%mod ) % mod; 			} 				 			h[i] = (g[i] * inverse(frac[i])) % mod; 			H[i] = (G[i] * inverse(frac[i])) % mod; 			   			acc[ reps[i] ] = (acc[reps[i]] + mod + H[i]-h[i]) % mod; 			 		} 	} 	 	LL sum=0; 	for(int i=1;i<6;i++) 	{ 		if(i<=K) 			sum = (sum + acc[i]) % mod; 	} 			 	cout<<sum<<endl; }   bool input() { 	s(N) ;s(L); s(X); s(K); 		 	return true; }     int main() { 	preprocess(); 	int T=1; 	for(testnum=1;testnum<=T;testnum++) 	{ 		if(!input()) break; 		solve(); 	} }  
#include <cstdio> #include <cstring> #include <cstdlib> #include <iostream> #include <algorithm> #include <vector> #include <queue> using namespace std;  const int maxn 	=	20; const int maxk	=	8; const int inf	=	1000000000;  const int dx[]	=	{0,1,0,-1}; const int dy[]	=	{1,0,-1,0};  int n,m,need,num[maxn][maxn],weight[maxn][maxn]; int a[maxn][maxn],mapping[maxn*maxn],f[maxn][maxn][1<<maxk]; bool vis[maxn][maxn],sel[maxn*maxn]; queue< pair<int,int> > q; vector<int> color;  inline int solve() { 	if (color.size()<need) return inf; 	 	memset(sel,false,sizeof(sel)); 	for (int i=0;i<need;++i){ 		int j=rand()%color.size(); 		while (sel[j]) j=rand()%color.size(); 		sel[j]=true; 		mapping[color[j]]=i+1; 	} 	 	for (int i=0;i<color.size();++i)         if (!sel[i]) mapping[color[i]]=rand()%need+1; 	 	for (int i=0;i<n;++i) 		for (int j=0;j<m;++j){ 			if (num[i][j]>0) a[i][j]=mapping[num[i][j]]; 			else a[i][j]=num[i][j]; 			for (int stat=0;stat<1<<need;++stat) 				f[i][j][stat]=inf; 		} 	 	for (int i=0;i<n;++i) 		for (int j=0;j<m;++j)if (a[i][j]!=-1){ 			if (a[i][j]==0) f[i][j][0]=0; 			else f[i][j][1<<a[i][j]-1]=0; 		} 	 	for (int stat=1;stat<1<<need;++stat){ 		for (int i=0;i<n;++i) 			for (int j=0;j<m;++j)                 if (a[i][j]!=-1){                     for (int s1=stat;s1>0;s1=(s1-1)&stat){                         int s2=stat^s1;                         f[i][j][stat]=min(f[i][j][stat],f[i][j][s1]+f[i][j][s2]);                     }                     if (f[i][j][stat]<inf){                         q.push(make_pair(i,j));                         vis[i][j]=true;                     }                 } 		while (q.size()){ 			int x=q.front().first,y=q.front().second; 			q.pop(); 			vis[x][y]=false; 			for (int k=0;k<4;++k){ 				int tx=x+dx[k],ty=y+dy[k]; 				if (tx>=0 && ty>=0 && tx<n && ty<m && a[tx][ty]!=-1){ 					if (f[tx][ty][stat]>f[x][y][stat]+weight[x][y]){ 						f[tx][ty][stat]=f[x][y][stat]+weight[x][y]; 						if (!vis[tx][ty]){ 							q.push(make_pair(tx,ty)); 							vis[tx][ty]=true; 						} 					} 				} 			} 		} 	} 	 	int res=inf; 	for (int i=0;i<n;++i) 		for (int j=0;j<m;++j) 			res=min(res,f[i][j][(1<<need)-1]+weight[i][j]); 	return res; }  int main() { 	srand(time(0)^3651361); 	 	scanf("%d%d%d",&n,&m,&need); 	color.clear(); 	for (int i=0;i<n;++i) 		for (int j=0;j<m;++j){ 			scanf("%d",&num[i][j]); 			if (num[i][j]>0){ 				color.push_back(num[i][j]); 			} 		} 	sort(color.begin(),color.end()); 	color.erase( unique(color.begin(),color.end()) , color.end() ); 	 	for (int i=0;i<n;++i) 		for (int j=0;j<m;++j) 			scanf("%d",&weight[i][j]); 	 	int ans=inf; 	while (clock()/CLOCKS_PER_SEC<6){ 		ans=min(ans,solve()); 	} 	 	if (ans==inf) puts("-1"); 	else printf("%d\n",ans); 	 	return 0; }
#include <cstdio> #include <algorithm> #include <vector> #include <memory.h> using namespace std; #define rep(i,x,y) for(int i=x;i<=y;i++) #define REP(i,x,y) for(int i=x;i>=y;i--) struct bign { 	int len,a[201]; 	int& operator [](int x) 	{ 		return a[x]; 	} } ds; struct b2 { 	int len,a[1002]; 	int& operator [](int x) 	{ 		return a[x]; 	} }; bool operator <(bign a,bign b) { 	if(a.len<b.len)return true; 	if(b.len<a.len)return false; 	REP(i,a.len,1) 	{ 		if(a[i]<b[i])return true; 		if(b[i]<a[i])return false; 	} 	return false; } vector<bign> v; b2 read() { 	b2 ans,tem; 	ans.len=0; 	char s; 	while(true) 	{ 		s=getchar(); 		//putchar(s); 		if(s=='\n'||s==EOF)break;     ans[++ans.len]=s-'0'; 	} 	tem.len=ans.len;   rep(i,1,ans.len)   	tem[i]=ans[ans.len+1-i];   return tem; } void write(bign num) { 	printf("%d",num[num.len]); 	REP(i,num.len-1,1) 	{ 		int now=100000,t=num[i]; 		REP(j,6,1) 		{ 			putchar('0'+t/now); 			if(j==1)break; 			t%=now; 			now/=10; 		}   } 	//putchar('\n'); 	return; } void write(b2 num) { 	REP(i,num.len,1) 		putchar(num[i]+'0'); 	//putchar('\n'); 	return; } bign operator *(bign bas,int k) { 	bign ans; 	int s=0; 	rep(i,1,bas.len) 	{ 		ans[i]=s+bas[i]*k; 		s=ans[i]/1000000; 		ans[i]%=1000000; 	} 	ans.len=bas.len; 	while(s>0) 	{ 		ans[++ans.len]=s%1000000; 		s/=1000000; 	} 	return ans; } int ss[1000000]; int getsum(bign x) { 	int ans=0; 	rep(i,1,x.len) 		ans+=ss[x[i]]; 	return ans; } bool can[28][4],cans[370]; int sum[10]; bool check(bign x,int s) { 	memset(sum,0,sizeof(sum)); 	rep(i,1,x.len) 	{ 		int t=x[i]; 		while(t>0) 		{ 			sum[t%10]++; 			t/=10; 		} 		//sum[x[i]]++; 	} 	//if(x.len-sum[0]<=3)return false; 	rep(i,0,9) 		if(sum[i]>0) 		{ 			if(s==i)return true; 			sum[i]--; 			rep(j,i,9) 				if(sum[j]>0) 				{ 					if(s==i+j)return true; 					sum[j]--; 					int t=s-i-j; 					if(t>=0&&t<=9&&sum[t]>0)return true; 					sum[j]++; 				} 			sum[i]++; 		} 	return false; } int now,n,m,p[10],q[10],big=0,bt=0; void dfs(int k,int t,bign x) { 	if(k>n) 	{ 		int o=getsum(x); 		if(o-now<t||o-now>27)return; 		if(check(x,o-now)) 		{ 			//if(now>big)big=now; 			v.push_back(x); 			cans[now]=true; 			//if(now>250)bt+=x.len; 		} 		return; 	} 	rep(i,0,27*q[k]) 	{ 		dfs(k+1,max(t,(i-1)/q[k]+1),x); 		if(i<27*q[k])x=x*p[k]; 	} 	return; } void docan() { 	cans[2]=true;cans[3]=true;cans[4]=true;cans[5]=true;cans[6]=true;cans[7]=true;cans[8]=true;cans[9]=true;cans[10]=true;cans[11]=true;cans[12]=true;cans[13]=true;cans[14]=true;cans[15]=true;cans[16]=true;cans[17]=true;cans[18]=true;cans[19]=true;cans[20]=true;cans[21]=true;cans[22]=true;cans[23]=true;cans[24]=true;cans[25]=true;cans[26]=true;cans[27]=true;cans[28]=true;cans[29]=true;cans[30]=true;cans[31]=true;cans[32]=true;cans[33]=true;cans[34]=true;cans[35]=true;cans[36]=true;cans[37]=true;cans[38]=true;cans[39]=true;cans[40]=true;cans[41]=true;cans[42]=true;cans[43]=true;cans[44]=true;cans[45]=true;cans[46]=true;cans[47]=true;cans[48]=true;cans[49]=true;cans[50]=true;cans[51]=true;cans[52]=true;cans[53]=true;cans[54]=true;cans[55]=true;cans[56]=true;cans[57]=true;cans[58]=true;cans[59]=true;cans[60]=true;cans[61]=true;cans[62]=true;cans[63]=true;cans[64]=true;cans[65]=true;cans[66]=true;cans[67]=true;cans[68]=true;cans[69]=true;cans[70]=true;cans[72]=true;cans[73]=true;cans[74]=true;cans[75]=true;cans[76]=true;cans[77]=true;cans[78]=true;cans[79]=true;cans[80]=true;cans[81]=true;cans[82]=true;cans[83]=true;cans[84]=true;cans[85]=true;cans[86]=true;cans[87]=true;cans[88]=true;cans[89]=true;cans[90]=true;cans[91]=true;cans[92]=true;cans[93]=true;cans[94]=true;cans[95]=true;cans[96]=true;cans[98]=true;cans[99]=true;cans[100]=true;cans[102]=true;cans[103]=true;cans[104]=true;cans[105]=true;cans[106]=true;cans[108]=true;cans[109]=true;cans[110]=true;cans[111]=true;cans[112]=true;cans[114]=true;cans[115]=true;cans[116]=true;cans[117]=true;cans[118]=true;cans[119]=true;cans[120]=true;cans[121]=true;cans[122]=true;cans[123]=true;cans[124]=true;cans[125]=true;cans[126]=true;cans[127]=true;cans[128]=true;cans[129]=true;cans[130]=true;cans[131]=true;cans[132]=true;cans[133]=true;cans[134]=true;cans[135]=true;cans[136]=true;cans[137]=true;cans[138]=true;cans[139]=true;cans[140]=true;cans[141]=true;cans[142]=true;cans[143]=true;cans[144]=true;cans[145]=true;cans[146]=true;cans[147]=true;cans[148]=true;cans[149]=true;cans[150]=true;cans[151]=true;cans[152]=true;cans[153]=true;cans[154]=true;cans[155]=true;cans[156]=true;cans[158]=true;cans[159]=true;cans[161]=true;cans[162]=true;cans[163]=true;cans[164]=true;cans[165]=true;cans[166]=true;cans[168]=true;cans[169]=true;cans[170]=true;cans[171]=true;cans[172]=true;cans[174]=true;cans[175]=true;cans[176]=true;cans[177]=true;cans[178]=true;cans[179]=true;cans[180]=true;cans[182]=true;cans[183]=true;cans[184]=true;cans[185]=true;cans[186]=true;cans[187]=true;cans[188]=true;cans[189]=true;cans[190]=true;cans[192]=true;cans[194]=true;cans[195]=true;cans[196]=true;cans[198]=true;cans[199]=true;cans[201]=true;cans[202]=true;cans[203]=true;cans[204]=true;cans[205]=true;cans[206]=true;cans[207]=true;cans[208]=true;cans[209]=true;cans[210]=true;cans[211]=true;cans[212]=true;cans[213]=true;cans[214]=true;cans[215]=true;cans[216]=true;cans[217]=true;cans[218]=true;cans[219]=true;cans[221]=true;cans[222]=true;cans[223]=true;cans[224]=true;cans[225]=true;cans[226]=true;cans[227]=true;cans[228]=true;cans[229]=true;cans[230]=true;cans[231]=true;cans[232]=true;cans[233]=true;cans[234]=true;cans[235]=true;cans[236]=true;cans[237]=true;cans[238]=true;cans[242]=true;cans[243]=true;cans[244]=true;cans[245]=true;cans[246]=true;cans[247]=true;cans[248]=true;cans[251]=true;cans[252]=true;cans[253]=true;cans[254]=true;cans[255]=true;cans[256]=true;cans[261]=true;cans[262]=true;cans[264]=true;cans[265]=true;cans[266]=true;cans[268]=true;cans[269]=true;cans[271]=true;cans[272]=true;cans[273]=true;cans[275]=true;cans[279]=true;cans[282]=true;cans[286]=true;cans[287]=true;cans[288]=true;cans[297]=true;cans[301]=true;cans[302]=true;cans[304]=true;cans[306]=true;cans[314]=true;cans[315]=true;cans[325]=true; 	return; } bign doit(b2 x) { 	bign ans; 	ans.len=0; 	rep(i,1,x.len/6) 	{ 		ans[++ans.len]=x[i*6-5]; 		int now=1; 		REP(j,4,0) 		{ 			now*=10; 			ans[ans.len]=ans[ans.len]+now*x[i*6-j]; 		} 	} 	if(x.len%6>0)ans[++ans.len]=0; 	int now=1; 	rep(i,1,x.len%6) 	{ 		ans[ans.len]+=now*x[x.len/6*6+i]; 		now*=10; 	} 	return ans; } int main() { 	int ttt=0; 	memset(cans,false,sizeof(cans)); 	docan(); 	ss[0]=0; 	rep(i,1,1000000) 		ss[i]=ss[i/10]+i%10; 	v.clear(); 	rep(i,1,325) 	if(cans[i]) 	{ 		//printf("%d\n",i); 		//cans[i]=false; 		n=0; 		now=i; 		int t=i,j=2; 		while(t>1) 		{ 			if(t%j==0) 			{ 				p[++n]=j; 				q[n]=0; 				while(t%j==0) 				{ 					t/=j; 					q[n]++; 				} 			} 			j++; 		} 		ds.len=1; 		ds[1]=1; 		dfs(1,0,ds); 		//if(cans[i])printf("cans[%d]=true;",i); 	} 	sort(v.begin(),v.end()); //	printf("%d\n",bt); 	//printf("%d\n",big); 	//printf("%d\n",v.size()); 	rep(i,0,v.size()-1) 	{ 	//	write(v[i]); 	} 	int T; 	scanf("%d",&T);getchar(); 	while(T--) 	{ 	//	printf("%d\n",T); 		b2 rd=read(),ans1,ans2; 		//write(rd); 		int sums=0,place; 		ans1.len=ans2.len=rd.len; 		REP(i,rd.len,1) 		{ 			ans1[i]=ans2[i]=rd[i]; 			if(rd[i]>0)sums++; 			if(sums>3)ans1[i]=ans2[i]=0; 			if(sums<=3&&rd[i]!=0)place=i; 		} 		if(sums<3)place=1; 		ans2[place]++; 		int j=place; 		while(ans2[j]>9&&j<ans2.len) 		{ 			ans2[j+1]+=1; 			ans2[j]-=10; 			j++; 		} 		if(ans2[j]>9) 		{ 			ans2[j]-=10; 			ans2[++ans2.len]=1; 		} 		ds=doit(rd); 		int t1=0,t2=v.size()-1; 		while(t1<t2) 		{ 			int mid=1+((t1+t2)>>1); 			if(ds<v[mid])t2=mid-1; 				else t1=mid; 		} 		if(!(ds<v[t1])&&doit(ans1)<v[t1])write(v[t1]); 			else write(ans1); 		putchar(' '); 		while(t1<v.size()&&!(ds<v[t1]))t1++; 		if(t1==v.size()||doit(ans2)<v[t1])write(ans2); 			else write(v[t1]); 		putchar('\n'); 	} 	return 0; }
#include <cstdio> #include <vector> #include <algorithm> using namespace std;  typedef long long ll; typedef pair <ll, int> li;  const int Maxn = 200005; const int Maxm = 1048576;  int n; ll a[Maxn], b[Maxn], c[Maxn]; vector <ll> un; int leaf[Maxn]; bool isleaf[Maxm]; li mx[Maxm]; li L[Maxm], R[Maxm];  void Create(int v, int l, int r) { 	L[v] = R[v] = li(0, r - l + 1); 	if (l == r) { leaf[l] = v; isleaf[v] = true; } 	else { 		int m = l + r >> 1; 		Create(2 * v, l, m); Create(2 * v + 1, m + 1, r); 	} }  li getMax(int v, int l, int r, int a, int b) { 	if (l == a && r == b) return mx[v]; 	else { 		int m = l + r >> 1; 		if (b <= m) return getMax(2 * v, l, m, a, b); 		if (m + 1 <= a) return getMax(2 * v + 1, m + 1, r, a, b); 		return max(getMax(2 * v, l, m, a, m), getMax(2 * v + 1, m + 1, r, m + 1, b));  	} }  void updateMax(int v, int l, int r, int a, ll val) { 	if (l == r) mx[v] = li(val, l); 	else { 		int m = l + r >> 1; 		if (a <= m) updateMax(2 * v, l, m, a, val); 		else updateMax(2 * v + 1, m + 1, r, a, val); 		mx[v] = max(mx[2 * v], mx[2 * v + 1]); 	} }  int lenRight(int v, ll val) { 	if (val >= R[v].first) return 0; 	if (val == 0 || isleaf[v]) return R[v].second; 	if (val >= R[2 * v].first) return lenRight(2 * v + 1, val); 	else return R[v].second - R[2 * v].second + lenRight(2 * v, val); }  int lenLeft(int v, ll val) { 	if (val >= L[v].first) return 0; 	if (val == 0 || isleaf[v]) return L[v].second; 	if (val >= L[2 * v + 1].first) return lenLeft(2 * v, val); 	else return L[v].second - L[2 * v + 1].second + lenLeft(2 * v + 1, val); }  void Update(int x, ll val) { 	int v = leaf[x]; L[v] = R[v] = li(val, 1); 	v /= 2; 	while (v) { 		L[v].first = R[v].first = max(L[2 * v].first, L[2 * v + 1].first); 		L[v].second = L[2 * v + 1].second + lenLeft(2 * v, L[2 * v + 1].first); 		R[v].second = R[2 * v].second + lenRight(2 * v + 1, R[2 * v].first); 		v /= 2; 	} }  int Get(int x) { 	int v = leaf[x]; 	ll lmx = L[v].first, rmx = R[v].first; 	int res = 0; 	int lst = v; v /= 2; 	while (v) { 		if (2 * v == lst) { res += lenRight(2 * v + 1, rmx); rmx = max(rmx, R[2 * v + 1].first); } 		else { res += lenLeft(2 * v, lmx); lmx = max(lmx, L[2 * v].first); } 		lst = v; v /= 2; 	} 	return res; }  int main() { 	scanf("%d", &n); 	for (int i = 0; i < n; i++) { 		scanf("%lld %lld", &a[i], &b[i]); 		un.push_back(b[i]); 		if (a[i] == 0 || a[i] == 2) scanf("%lld", &c[i]); 		if (a[i] == 2) un.push_back(c[i]); 	} 	sort(un.begin(), un.end()); un.erase(unique(un.begin(), un.end()), un.end()); 	Create(1, 0, un.size() - 1); 	for (int i = 0; i < n; i++) { 		b[i] = lower_bound(un.begin(), un.end(), b[i]) - un.begin(); 		if (a[i] == 0) { updateMax(1, 0, un.size() - 1, b[i], c[i]); Update(b[i], c[i]); } 		else if (a[i] == 1) { updateMax(1, 0, un.size() - 1, b[i], 0); Update(b[i], 0); } 		else { 			c[i] = lower_bound(un.begin(), un.end(), c[i]) - un.begin(); 			int mid = getMax(1, 0, un.size() - 1, min(b[i], c[i]), max(b[i], c[i])).second; 			printf("%d\n", Get(b[i]) + Get(c[i]) - 2 * Get(mid)); 		} 	} 	return 0; }
/* WA ?   #include <stdio.h> #include <cstdlib> #include <iostream> #include <string> #include <cstring> #include <cmath> #include <ctime> #include <algorithm> #include <set> #include <map> #include <queue> #include <vector>  #define REP(I,A,B) for(register int I=A,_END_=B;I<=_END_;I++) #define REPD(I,A,B) for(register int I=A,_END_=B;I>=_END_;I--) #define FOR(I,A,B) for(int I=A,_END_=B;I<_END_;I++) #define RI(X) scanf("%d",&X) #define RII(X,Y) RI(X),RI(Y) #define RIII(X,Y,Z) RI(X),RI(Y),RI(Z) #define RL(X) X=Readint() #define RLL(X,Y) RL(X),RL(Y) #define RLLL(X,Y,Z) RL(X),RL(Y),RL(Z) #define RS(X) scanf("%s",X) #define RD(X) scanf("%lf",&X) #define GCH getchar() #define PCH(X) putchar(X) #define MS(X,Y) memset(X,Y,sizeof(X)) #define MC(X,Y,var,len) memcpy(X,Y,sizeof(var)*(len)) #define debug(...) fprintf(stderr,__VA_ARGS__) #define pb(X) push_back(X) #define mp(A,B) make_pair(A,B) #define fr first #define sc second #define lch(p) (p+p) #define rch(p) (p+p+1) #define lowbit(X) ((X)&(-(X)))  using namespace std;  typedef pair<int,int> poi; typedef vector<int> vi; typedef pair<double,double> com;  inline long long Readint() { 	long long ret=0; 	int f=1; 	char ch; 	do 	{ 		ch=GCH; 		if (ch=='-') f*=-1; 	}while(ch>=0 && (ch<'0' || ch>'9'));  	while ('0'<=ch && ch<='9') 	{ 		ret=ret*10+ch-'0'; 		ch=GCH; 	} 	return ret*f; }  void open() { 	freopen("COUNTARI.in","r",stdin); 	freopen("COUNTARI.out","w",stdout); } void close() { 	fclose(stdin); 	fclose(stdout); }  const int MAXL = 66666; const int MAXA = 33333; const int MAXN = 101010; const double pi = acos(-1);  com operator + (const com &a,const com &b){ 	return mp(a.fr+b.fr,a.sc+b.sc); } com operator - (const com &a,const com &b){ 	return mp(a.fr-b.fr,a.sc-b.sc); } com operator * (const com &a,const com &b){ 	return mp(a.fr*b.fr-a.sc*b.sc,a.fr*b.sc+a.sc*b.fr); } com operator /(const com &a,const double &k){ 	return mp(a.fr/k,a.sc/k); }  int rev[MAXL]; com w[2][MAXL]; com A[MAXL]; com B[MAXL]; int N; int bk; int tt;  int pre[MAXL]; int suf[MAXL]; int n; int mx;  int a[MAXN];  long long ans;  void prepare_fft(){ 	int L=1; 	while ((1<<L) <= mx+mx) L++; 	N=1<<L; 	FOR(i,1,N) rev[i]=(rev[i>>1] >> 1) | ( (i&1)<<(L-1) ); 	com omega=mp(cos(2*pi/N),sin(2*pi/N)); 	w[0][0]=w[1][0]=w[0][N]=w[1][N]=mp(1,0); 	FOR(i,1,N) w[1][N-i]=w[0][i]=w[0][i-1]*omega; } void fft(com *x,int N,int way){ 	FOR(i,1,N) if (rev[i]>i) swap(x[i],x[rev[i]]); 	register int step,l; 	register com *L,*R,*W,dt; 	for (register int i=2;i<=N;i<<=1) 	{ 		l=i/2; 		step=N/i; 		for (register int j=0;j<N;j+=i) 		{ 			L=x+j; 			R=x+j+l; 			W=w[way]; 			FOR(k,0,l) 			{ 				dt= (*R) * (*W); 				*R=*L-dt; 				*L=*L+dt; 				L++; 				R++; 				W+=step; 			} 		} 	} 	if (way) 		FOR(i,0,N) x[i]=x[i]/N; }  int check(int mx){ 	return (int)(sqrt(mx*log(mx)/log(2))); }  void init(){ 	RI(n); 	mx=0; 	FOR(i,0,n) RI(a[i]),mx=max(mx,a[i]); 	bk=max(check(mx*2),1); 	tt=(n-1)/bk; }  void work(){ 	register int L,R; 	register int aim; 	// 3 in  	REP(i,0,tt) 	{ 		L=i*bk; 		R=min((i+1)*bk-1,n-1);  		FOR(j,L,R) 		{ 			pre[a[j]]++; 			REP(k1,j+2,R) 			{ 				aim=a[j+1]*2-a[k1]; 				if (aim>=0) ans+=pre[aim]; 			} 		}  		FOR(j,L,R) pre[a[j]]--; 	}  	// 2 in and 1 in 	L=0; R=min(bk-1,n-1); 	FOR(i,R+1,n) suf[a[i]]++;  	FOR(k1,L,R) 	REP(k2,k1+1,R) 	{ 		aim=a[k2]*2-a[k1]; 		if (aim>=0) ans+=suf[aim]; 	} 	 	REP(i,L,R) pre[a[i]]++; 	FOR(i,1,tt) 	{ 		L=i*bk; 		R=min((i+1)*bk-1,n-1); 		REP(j,L,R) suf[a[j]]--;  		FOR(k1,L,R) 		REP(k2,k1+1,R) 		{ 			aim=a[k1]*2-a[k2]; 			if (aim>=0) ans+=pre[aim]; 			aim=a[k2]*2-a[k1]; 			if (aim>=0) ans+=suf[aim]; 		}  		FOR(j,0,N) A[j]=B[j]=mp(0,0); 		REP(j,1,mx) A[j]=mp(pre[j],0),B[j]=mp(suf[j],0); 		fft(A,N,0); 		fft(B,N,0); 		FOR(j,0,N) A[j]=A[j]*B[j]; 		fft(A,N,1); 		REP(j,L,R) ans+=(long long)(A[a[j]*2].fr+0.5);  		REP(j,L,R) pre[a[j]]++; 	}  	L=tt*bk; 	R=n-1; 	REP(i,L,R) suf[a[i]]--;  	FOR(k1,L,R) 	REP(k2,k1+1,R) 	{ 		aim=a[k1]*2-a[k2]; 		if (aim>=0 && aim<=mx) ans+=pre[aim]; 	}  }  int main() {  	open(); 	int _=0; 	init(); 	prepare_fft(); 	work(); 	cout << ans << endl; 	close(); 	return 0; }   */ #include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <algorithm> #include <cmath> using namespace std;    const double pi = acos(-1);   struct Complex {     double x,y;     Complex() {}     Complex(double tx,double ty) {         x = tx;         y = ty;     }     Complex operator + (Complex b) {         return Complex(x + b.x,y + b.y);     }     Complex operator - (Complex b) {         return Complex(x - b.x,y - b.y);     }     Complex operator * (Complex b) {         return Complex(x * b.x - y * b.y,x * b.y + y * b.x);     }     Complex operator *= (Complex b) {         *this = Complex(x * b.x - y * b.y,x * b.y + y * b.x);         return *this;     } };   Complex a[700010],b[700010]; int R[700010]; int num[700010],l[700010],r[700010],st[700010],ed[700010]; int n;    void fft(Complex *a,int f) {     for (int i = 0; i < n; i++)         if (i < R[i])             swap(a[i],a[R[i]]);     for (int i = 1; i < n; i <<= 1) {         Complex wn(cos(pi / i),f * sin(pi / i));         for (int j = 0; j < n; j += (i << 1)) {             Complex w(1,0);             for (int k = 0; k < i; k++) {                 Complex x = a[j + k],y = w * a[j + k + i];                 a[j + k] = x + y;                 a[j + k + i] = x - y;                 w *= wn;             }         }     }     if (f == -1)         for (int i = 0; i < n; i++)             a[i].x /= n; }   int main() {     int nn;     scanf("%d",&nn);     int mx = 0;     for (int i = 1; i <= nn; i++) {         scanf("%d",&num[i]);         mx = max(mx,num[i]);         r[num[i]]++;     }     mx++;     mx = mx * 2 - 1;     int L = 0;     for (n = 1; n <= mx; n <<= 1)         L++;     for (int i = 0; i < n; i++)         R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));     int sz = 2000;     int m = (nn - 1) / sz + 1;     for (int i = 1; i <= m; i++) {         st[i] = ed[i - 1] + 1;         ed[i] = i * sz;     }     ed[m] = nn;     long long ans = 0;     for (int i = 1; i <= m; i++) {         for (int j = st[i]; j <= ed[i]; j++)             r[num[j]]--;         for (int j = 0; j < n; j++)             a[j] = Complex(l[j],0);         for (int j = 0; j < n; j++)             b[j] = Complex(r[j],0);         fft(a,1);         fft(b,1);         for (int j = 0; j < n; j++)             a[j] *= b[j];         fft(a,-1);         for (int j = st[i]; j <= ed[i]; j++)             ans += ((long long)(a[2 * num[j]].x + 0.5));         for (int j = st[i]; j <= ed[i]; j++) {             for (int k = st[i]; k < j; k++)                 if (2 * num[j] - num[k] >= 0)                     ans += r[2 * num[j] - num[k]];             for (int k = j + 1; k <= ed[i]; k++)                 if (2 * num[j] - num[k] >= 0)                     ans += l[2 * num[j] - num[k]];             l[num[j]]++;         }     }     cout << ans << endl;     return 0; } 
#define _CRT_SECURE_NO_DEPRECATE #define _USE_MATH_DEFINES #include <iostream> #include <fstream> #include <cstdio> #include <cstdlib> #include <cassert> #include <climits> #include <ctime> #include <numeric> #include <vector> #include <algorithm> #include <bitset> #include <cmath> #include <cstring> #include <iomanip> #include <complex> #include <deque> #include <functional> #include <list> #include <map> #include <string> #include <sstream> #include <set> #include <stack> #include <queue> using namespace std; typedef long long lng; typedef unsigned long long ulng; typedef unsigned int uint; typedef unsigned char uchar; typedef double ld; typedef pair<int, int> PII; typedef pair<short, short> PSS; typedef pair<PII, int> PIII; typedef pair<lng, lng> PLL; typedef pair<ulng, ulng> PUU; typedef pair<lng, int> PLI; typedef pair<int, lng> PIL; typedef pair<ld, ld> PDD; template<class T> inline T sqr(T x) { return x * x; } template<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); } inline lng parse(const string & s) { stringstream ss(s); lng x; ss >> x; return x; } #define left asdleft #define right asdright #define link asdlink #define unlink asdunlink #define next asdnext #define prev asdprev #define y0 asdy0 #define y1 asdy1 #define mp make_pair #define pb push_back #define sz(x) ((int)(x).size()) #define all(x) (x).begin(), (x).end() #define clr(ar,val) memset(ar, val, sizeof(ar)) #define istr stringstream #define forn(i,n) for(int i=0;i<(n);++i) #define forv(i,v) forn(i,sz(v)) #define X first #define Y second #define hash asdhash #define move asdmove const ld EPS = 1e-9; const int INF = 1000*1000*1000; const char CINF = 102; const lng LINF = INF * 1ll * INF; const ld DINF = 1e200; const ld PI = 3.1415926535897932384626433832795l; int gcd(int a,int b){return a?gcd(b%a,a):b;} lng gcd(lng a,lng b){return a?gcd(b%a,a):b;} lng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;} #define FAIL { cerr<<"assertion failed on line "<<__LINE__<<endl; exit(123);}   int n; const lng mod=INF+7; struct func{   vector<lng> A;     void read(){     A.resize(1<<n);     forn(i,1<<n){       cin>>A[i];     }   }     void sum(){     for(int i=n-1;i>=0;--i){       forn(m,1<<n){         if(m&(1<<i))           A[m]+=A[m^(1<<i)];       }     }     forn(m,1<<n){       A[m]%=mod;     }   }     void diff(){     forn(i,n){       forn(m,1<<n){         if(m&(1<<i))           (A[m]+=mod-A[m^(1<<i)])%=mod;       }     }   }     func& operator*=(const func &b){     forn(i,1<<n){       (A[i]*=b.A[i])%=mod;     }     return *this;   }     static int bitcnt(int a){     int r=0;     while(a){       r+=a&1;       a>>=1;     }     return r;   }     lng ans()const{     lng r=0;     forn(m,1<<n){       (r+=A[m]*(1<<bitcnt(m)))%=mod;     }     return r;   }     void print(){     forv(i,A){       cout<<A[i]<<' ';     }     cout<<endl;   }     func brutesum(){     func r;     r.A.resize(1<<n);     forn(m,1<<n){       for(int s=m;;s=(s-1)&m){         (r.A[m]+=A[s])%=mod;         if(!s)           break;       }     }     return r;   } };   void stress_sum(){   n=15;   func a;   a.A.resize(1<<n);   forn(i,1<<n){     a.A[i]=rand()%mod;   }   func b=a.brutesum();   func a0=a;   a.sum();   if(a.A!=b.A){     cerr<<"failed"<<endl;     return;   }   a.diff();   if(a.A!=a0.A){     cerr<<"failed inv"<<endl;     return;   }   cerr<<"passed"<<endl; }   int main(){ 	ios_base::sync_with_stdio(false);cin.tie(0);     //stress_sum();return 0;     cin>>n;   func A,B,C;   A.read();   B.read();   C.read();   A.sum();   B.sum();   C.sum();   A*=B;   A*=C;   A.diff();   cout<<A.ans();   	return 0; }  
#define _CRT_SECURE_NO_WARNINGS //#define VERBOSE //#define VERY_VERBOSE   #include <sys/types.h> #include <regex.h> #include <cstdio> #include <cmath> #include <cstring> #include <cstdlib> #include <ctime> #include <iostream> #include <fstream> #include <sstream> #include <algorithm> #include <string> #include <vector> #include <set> #include <map> #include <list> #include <complex> #include <queue> #pragma comment(linker, "/STACK:266777216") using namespace std;   #define assert(f) { if(!(f)) { fprintf(stderr,"Assertion failed: "); fprintf(stderr,#f); fprintf(stderr,"\n"); exit(1); } }   typedef long long LL; typedef unsigned long long ULL; typedef vector<int> VI; typedef vector<VI> VVI; typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<double> VD; typedef pair<double,double> PDD;   #define pb push_back #define sz size() #define cl clear() #define all(a) (a).begin(),(a).end() #define fill(ar,val) memset((ar),(val),sizeof (ar))   clock_t start=clock(); //fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));   // since we do a lot of transforms with regexp // the length is chosen large for safe const int LEN = 101010; int n; char s[LEN]; bool valid; char w[LEN]; int pos; // needed for recursive parsing   bool isParen(char c) {   return c=='(' || c==')'; }   bool isSepar(char c) {   return c==' ' || c=='(' || c==')'; }   bool isAlp(char c) {   return '0'<=c && c<='9' || 'A'<=c && c<='Z' || c=='-'; }   // read regexp and add leading and trailing space void read_regexp() {   //fill(s,0);   s[0]=' ';   gets(s+1);   n = strlen(s);   assert(s[n-1]!=13);   //if(s[n-1]==13) s[--n]=0;   s[n++]=' ';   s[n]=0;   valid=true;   assert(n<=1002);   for(int i=0;i<n;i++)     assert(isSepar(s[i]) || isAlp(s[i]) || 'a'<=s[i] && s[i]<='z'); }   void adjust_spaces() {   // add spaces around parantheses   //fill(w,0);   int j=0;   for(int i=0;i<n;i++)   {     char c = s[i];     if(isParen(c)) w[j++]=' ';     w[j++]=c;     if(isParen(c)) w[j++]=' ';   }   w[n=j]=0;   //fill(s,0);   strcpy(s,w);     // delete double spaces   //fill(w,0);   j=0;   for(int i=0;i<n;i++)     if(i==0 || s[i]!=' ' || s[i-1]!=' ') w[j++]=s[i];   w[n=j]=0;   //fill(s,0);   strcpy(s,w); #ifdef VERBOSE   fprintf(stderr,"%s\n",s); #endif }   bool isStr(const string& p) {   for(int i=0;i<p.sz;i++)     if(!isAlp(p[i])) return false;   return true; }   int getN(const string& s) {   int L = s.sz;   if(L<1 || L>2 || s[0]=='0') return 0;   int N=0;   for(int i=0;i<L;i++)   {     char c=s[i];     if(c<'0' || c>'9') return 0;     N=10*N+c-'0';   }   return 2<=N && N<=12 ? N : 0; }   string getBlock(int i) {   string res = "";   for(;i<n && s[i]!=' ';i++)     res += s[i];   assert(i<n && s[i]==' ');   return res; }   bool valid_to(char c1, char c2) {   if('0'<=c1 && c1<=c2 && c2<='9') return true;   if('A'<=c1 && c1<=c2 && c2<='Z') return true;   return false; }   string range(char c1, char c2) {   assert(valid_to(c1,c2));   string s="[";   s+=c1;   s+='-';   s+=c2;   s+="]";   return s; }   string concat(const string& w) {   if(w.sz==1) return w;   string s="(";   for(int i=0;i<w.sz;i++)   {     assert(isAlp(w[i]));     s += w[i];     s += i<w.sz-1 ? '+' : ')';   }   return s; }   // Checking all space separated blocks for correctness and // replacing sub-formats as follows: // usual string s[0]...s[L] -> (s[0]+...+s[L]) // "optional" -> "?" // "N times" -> "N'", where N'=N-1+'a' // "or" -> "|" // "a to b" -> "[a-b]" // "digit" -> "[0-9]" // "letter" -> "[A-Z]" // "upto N digits" -> "[0-9]?N'" // "exactly N digits" -> "[0-9]N'" // "upto N letters" -> "[A-Z]?N'" // "exactly N letters" -> "[A-Z]N'" // Note that N' is the only possible occurence of small latins in regexp after this void global_cleanup() {   //fill(w,0);   int j=0;   for(int i=0;i<n;) {     if(isSepar(s[i])) {       w[j++]=s[i++];     } else {       string p = getBlock(i);       i += p.sz;       string t = "";       if(p=="optional") {         t = "?";        } else if(p=="or") {         t = "|";       } else if(p=="digit") {         t = range('0', '9');       } else if(p=="letter") {         t = range('A', 'Z');       } else if(p=="upto" || p=="exactly") {         i++;         string sN = getBlock(i);         i += sN.sz;         int N = getN(sN);         if(!N) { valid=false; break; }         i++; // skip space after N         if(strncmp(s+i,"digits ",7)==0) {           t += range('0','9');           i += 6;         } else if(strncmp(s+i,"letters ",8)==0) {           t += range('A','Z');           i += 7;         } else {           valid=false;           break;         }         if(p=="upto") t+="?";         t+=char(N-1+'a');       } else if(strncmp(s+i," times ", 7)==0) {         int N = getN(p);         if(!N) { valid=false; break; }         t = N-1+'a';         i += 6;       } else if(strncmp(s+i," to ",4)==0) {         i+=4;         string q = getBlock(i);         i += q.sz;         if(p.sz!=1 || q.sz!=1) { valid=false; break; }         if(!valid_to(p[0], q[0])) { valid=false; break; }         t = range(p[0],q[0]);       } else if(isStr(p)) {         t = concat(p);       } else {         valid=false;         break;       }       strcpy(w + j, t.c_str());       j += t.sz;     }   }   w[n=j]=0;   //fill(s,0);   strcpy(s,w); #ifdef VERBOSE   fprintf(stderr,"%s\n",s); #endif }   // delete unnessecary spaces and replace needed one by '+' void concat_cleanup() {   //fill(w,0);   int j=0;   for(int i=0;i<n;i++) {     if(s[i]!=' ') {       w[j++]=s[i];      } else if(i>0 && i+1<n) {       char c = s[i-1];       if(c=='(' || c=='|') continue;       c = s[i+1];       if(c==')' || c=='|' || c=='?' || 'a'<=c && c<='z') continue;       w[j++]='+';     }   }   w[n=j]=0;   //fill(s,0);   strcpy(s,w); #ifdef VERBOSE   fprintf(stderr,"%s\n",s); #endif }   const int maxQ = 1000; const int maxL = 2001; int Q; char quers[maxQ][maxL];   void read_queries() {   scanf("%d ",&Q);   assert(0<=Q && Q<=maxQ);   for(int q=0;q<Q;q++)     gets(quers[q]); }   bool isUnar(char c) {   return c=='?' || 'a'<=c && c<='z'; }   int calcSum();   int calcAtom() {   if(pos==n) valid = false;   if(!valid) return 0;   int ans=0;   if(s[pos]=='(')   {     pos++;     ans = calcSum();     if(s[pos]!=')') valid=false;     pos++;   } else if(s[pos]=='[') {     assert(valid_to(s[pos+1],s[pos+3]));     assert(s[pos+2]=='-');     assert(s[pos+4]==']');     ans = 1;     pos += 5;   } else if(isAlp(s[pos])) {     ans = 1;     pos++;   } else {     valid = false;   }   if(!valid) return 0;   for(;pos<n && isUnar(s[pos]);pos++)     if(s[pos]!='?')       ans = min(ans * (s[pos]-'a'+1), maxL);   return ans; }   int calcOr() {   int ans = 0;   while(valid) {     ans = max(ans, calcAtom());     if(pos==n || s[pos]==')' || s[pos]=='+')  break;     if(s[pos]=='|') {       pos++;     } else {       valid = false;     }   }   return ans; }   int calcSum() {   int ans = 0;   while(valid) {     ans = min(ans + calcOr(), maxL);     if(pos==n || s[pos]==')')  break;     if(s[pos]=='+') {       pos++;     } else {       valid = false;     }   }   return ans; }   string fixSum();   string fixAtom() {   string res = "";   if(s[pos]=='(')   {     res += s[pos++];     res += fixSum();     res += s[pos++];   } else if(s[pos]=='[') {     for(int j=0;j<5;j++)       res += s[pos++];   } else {     res += s[pos++];   }   for(;pos<n && isUnar(s[pos]);pos++)   {     res = "(" + res + ")";     res += s[pos];   }   return "(" + res + ")"; }   string fixOr() {   string res = "";   while(true) {     res += fixAtom();     if(pos==n || s[pos]==')' || s[pos]=='+')  break;     res += s[pos++];   }   return "(" + res + ")"; }   string fixSum() {   string res = "";   while(true) {     res += fixOr();     if(pos==n || s[pos]==')') break;     res += s[pos++];   }   return "(" + res + ")"; }   void fixing_prior() {   pos=0;   string news = fixSum();   strcpy(s, news.c_str());   n=news.sz; }   void convert_to_POSIX() {   int j=0;   w[j++]='^';   for(int i=0;i<n;i++)     if('a'<=s[i] && s[i]<='z') {       int N = s[i]-'a'+1;       w[j++] = '{';       if(N >= 10) w[j++] = N/10 + '0';       w[j++] = N%10 + '0';       w[j++] = '}';     } else if(s[i]!='+') {       w[j++] = s[i];     }   w[j++]='$';   w[n=j]=0;   strcpy(s,w); #ifdef VERBOSE   fprintf(stderr,"%s\n",s); #endif }   int main() { #ifndef ONLINE_JUDGE   freopen("cpp.in","r",stdin);   //freopen("out.txt","w",stdout); #endif   int TST;   scanf("%d ",&TST);   for(int tst=0;tst<TST;tst++)   {     read_regexp();     adjust_spaces();     // Now each '(' or ')' is surrounded by spaces,     // s has no double spaces, but have one leading and one trailing space     assert(s[0]==' ' && s[n-1]==' ');     for(int i=1;i<n;i++) assert(s[i]!=' ' || s[i-1]!=' ');       read_queries();       global_cleanup();     if(!valid) { puts("Format does not conform\n"); continue; }     concat_cleanup();       // check maximal possible len     pos=0;     int maxlen = calcSum();     if(pos < n) valid = false;     if(!valid) { puts("Format does not conform\n"); continue; }     fprintf(stderr,"maxlen=%d\n", maxlen);     if(maxlen==maxL) { puts("Matches too long ID"); continue; }       //puts(s);     fixing_prior();     //puts(s);     convert_to_POSIX();     fprintf(stderr, "w=%s\n", w);     //puts(s);       regex_t reg;     regcomp(&reg, s, REG_EXTENDED|REG_NOSUB);     for(int q=0;q<Q;q++) {       int res = regexec(&reg, quers[q], unsigned(0), NULL, 0);       assert(res==0 || res==REG_NOMATCH);       puts(!res?"Valid-ID":"Invalid-ID");     }     printf("\n");   }   //while(clock() - start < 0.95 * CLOCKS_PER_SEC);   return 0; } 
#include <cstdio> #include <cstring> #include <algorithm> using namespace std;  typedef long long LL;  const int maxN = 60; const int maxM = 8000;  void read(int n,LL *a) { 	for(int i=0;i<n;i++) a[i]=0; 	char type[11]; 	scanf("%s",type); 	if(strcmp(type,"raw")==0) 	{ 		for(int i=0;i<n;i++) 			for(int j=0;j<n;j++) 			{ 				int q; 				scanf("%d",&q); 				if(q&1) a[i] |= 1LL<<j; 			} 	} 	else 	{ 		unsigned S, P, A; 		scanf("%u%u%u", &S, &P, &A); 		for(int i=0;i<n;i++) 			for(int j=0;j<n;j++) 			{ 				if(!(S>>12 & 1)) a[i] |= 1LL<<j; 				S=S*P+A; 			} 	} }  LL calc(int n,LL *a) { 	int i,j,k; 	for(i=0;i<n;i++) a[i] += 1LL<<n; 	int x=n; 	for(i=k=0;i<n;i++,k++) 	{ 		for(j=i;j<n && !(a[j] & 1LL<<k);j++); 		if(j==n) 		{ 			if(k==i+1) return 0; 			x=i; 			k++; 			for(j=i;j<n && !(a[j] & 1LL<<k);j++); 			if(j==n) return 0; 		} 		swap(a[i],a[j]); 		for(j=0;j<n;j++) 			if(j!=i && (a[j] & 1LL<<k)) a[j]^=a[i]; 	} 	LL res=1LL<<x; 	for(i=0;i<n;i++) 		if(a[i] & 1LL<<x) res += 1LL<<i; 	return res; }  const int maxH = 16; int BITPARITY[1<<maxH];  void bitparity_precalc() { 	BITPARITY[0]=0; 	for(int n=1;n < (1<<maxH);n++) 		BITPARITY[n] = BITPARITY[n/2] ^ (n%2); }  inline int bit_parity(LL a) { 	// check it out the funny way of taking 16 first bits of the number 	// we simply cast it to unsigned short type :) 	return BITPARITY[a>>48] ^ BITPARITY[(unsigned short)(a>>32)] ^ BITPARITY[(unsigned short)(a>>16)] ^ BITPARITY[(unsigned short)a]; }  int main() { #ifndef ONLINE_JUDGE 	freopen("in.txt","r",stdin); 	freopen("1.in","r",stdin); 	freopen("1_my.out","wb",stdout); 	//freopen("3_stats.txt","w",stderr); #endif 	bitparity_precalc(); 	int T; 	scanf("%d",&T); 	for(int t=0;t<T;t++) 	{ 		int n,m; 		scanf("%d%d",&n,&m); 		LL a[maxM]; 		int cnt=0; 		for(int i=0;i<m;i++) 		{ 			LL b[maxN]; 			read(n,b); 			if(n==1) cnt+=b[0]; else 				a[i] = calc(n,b); 		} 		int ans=0; 		if(n==1) ans=cnt*(cnt-1)/2; else 		{ 			for(int i=0;i<m;i++) 				for(int j=0;j<i;j++) 					if(bit_parity(a[i] & a[j])) ans++; 		} 		printf("%d\n",ans); 	} 	return 0; } 
#include<cstdio> #include<cstring> #include<algorithm> #include<set> #include<map> #include<vector> #define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++) #define per(i,j,k) for(int i=(int)j;i>=(int)k;i--) using namespace std; typedef long long LL; typedef long long ll; typedef double db; inline LL Pow(LL a,LL b,LL P){ 	a%=P;if(a<0)a+=P;LL c=1; 	for(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P; 	return c; } inline ll qprod(ll a,ll b,ll c){     ll ans=0;     for (a%=c;b;b>>=1){         if (b&1) if ((ans+=a)>=c) ans-=c;         if ((a+=a)>=c) a-=c;     }     return ans; } const int pr[]={2,3,5,7,11,13,17,19,23,29}; inline ll qpow(ll a,ll b,ll c){     ll ans=1;     for (a%=c;b;b>>=1,a=qprod(a,a,c))         if (b&1) ans=qprod(ans,a,c);     return ans; } inline bool witness(LL a,LL n){     LL t=n-1;     while (!(t&1)) t>>=1;     LL x0,x1=qpow(a,t,n);     while (t!=n-1){         x0=x1;         x1=qprod(x0,x0,n);         if (x1==1 && x0!=1 && x0!=n-1) return true;         t<<=1;     }     return x1!=1; }   inline bool miller_rabin(LL n){     if (n==2) return true;     if (n<2 || n>2 && !(n&1)) return false;     rep(i,0,9){         if (n<=pr[i]) return true;         if (witness(pr[i],n)) return false;     }     return true; } bool ck(int A,int B){ 	if(B==0){ 		return (abs(A)==2)||(miller_rabin(abs(A))&&Pow(-11,(abs(A)-1)/2,abs(A))==abs(A)-1); 	} 	else{ 		return miller_rabin(A*1ll*A+A*1ll*B+3*1ll*B*B); 	} } int main(){ 	int T;scanf("%d",&T); 	while(T--){ 		int a,b,c;scanf("%d%d%d",&a,&b,&c); 		int A=33-2*a-c; 		int B=b-a; 		if(ck(A,B))printf("PRIME\n"); 		else printf("NOT PRIME\n"); 	} 	return 0; }  
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <queue> #include <assert.h>   using namespace std;   #define eps 1e-10 #define SZ(X) (int)(X).size() #define FOR(i, n) for(int (i) = 0; (i) < (n); (i)++) #define inf (1LL<<30) #define PI acos(-1.0) #define SQR(v) (1LL*(v)*(v)) #define MP(x, y) make_pair((x), (y)) #define maxn 50+5 #define int64 long long   char sa[200+5], sb[2000000+5], sc[200+5], s[1000+5], c[1000+5]; int na, nb, nc;   #define maxnode 2000000+5 const int MOD = 1000000007;   struct TNode { struct TNode *child[2], *sufnode; int weight; };   struct TNode *THead, heap[maxnode], *q[maxnode]; int heapsize;   void init() { heapsize = 0; THead = &heap[heapsize++]; THead->child[0] = THead->child[1] = NULL; THead->weight = 0; THead->sufnode = THead; } void AddWord(const string &s) { struct TNode *now = THead, *Temp; for(unsigned i = 0; i < s.size(); i++) { Temp = now->child[s[i]-'0']; if(Temp == NULL) { Temp = &heap[heapsize++]; Temp->child[0] = Temp->child[1] = NULL; Temp->weight = (i+1)*(i+1); now->child[s[i]-'0'] = Temp; } now = now->child[s[i]-'0']; } }     void buildGraph() { int inc = 0, sf = 0; q[sf++] = THead; struct TNode *now; while(inc < sf) { now = q[inc]; now->weight = now->weight + now->sufnode->weight; if(now->weight >= MOD) now->weight -= MOD; for(int k = 0; k < 2; k++) { if(now->child[k] != NULL) { q[sf++] = now->child[k]; } if(now == THead) { if(now->child[k] == NULL) now->child[k] = THead; else now->child[k]->sufnode = THead; continue; } if(now->child[k] == NULL) now->child[k] = now->sufnode->child[k]; else { now->child[k]->sufnode = now->sufnode->child[k]; } } inc++; } }   struct TNode* findChild(struct TNode *now, int k) { now = now->child[k]; return ( now == NULL ? THead : now ); } string str(char ch) { int x = 0; if(ch >= 'a'&&ch <= 'z') x = ch - 'a'; else x = ch - 'A' + 26; string s = ""; for(int i = 4; i >= 0; i--) { if(x&(1<<i)) s += "1"; else s += "0"; } return s; }   int main() { //freopen("A.txt", "r", stdin); string s1 = "", s2 = ""; scanf("%s", sa); long long xx = clock(); na = strlen(sa); for(int i = 0; i < na; i++) s1 += str(sa[i]); scanf("%s", sb); nb = strlen(sb); scanf("%s", sc); nc = strlen(sc); for(int i = 0; i < nc; i++) s2 += str(sc[i]); init(); // cout << sa << " " << sc << endl; AddWord(s1); for(unsigned i = 0; i < s2.size(); i++) { if(s2[i] == '1') { s1[i] = '1' - s1[i] + '0'; AddWord(s1); for(unsigned j = i+1; j < s2.size(); j++) { if(s2[j] == '1') { s1[j] = '1' - s1[j] + '0'; AddWord(s1); s1[j] = '1' - s1[j] + '0'; } } s1[i] = '1' - s1[i] + '0'; } } // cout << heapsize << endl; buildGraph(); int ans = 0; struct TNode *now = THead; string s = ""; long long tt = clock(); //cout << (tt - xx)/CLOCKS_PER_SEC << endl; for(int i = 0; i < nb; i++) { int tt = 0; if(sb[i] >= 'a'&&sb[i] <= 'z') tt = sb[i] - 'a'; else tt = sb[i] - 'A' + 26; for(int j = 4; j >= 0; j--) { if((tt&(1<<j))) now = findChild(now, 1); else now = findChild(now, 0); ans = ans + now->weight; if(ans >= MOD) ans -= MOD; } } // cout << (clock()-tt)/CLOCKS_PER_SEC << endl; printf("%d\n", ans); return 0; }
#include<iostream> #include<algorithm> #include<iterator> #include<map> #include<vector> #include<list> #include<set> #include<queue> #include<deque> #include<stack> #include<bitset> #include<functional> #include<utility> #include<fstream> #include<iosfwd> #include<sstream> #include<iomanip> #include<string> #include<cmath> #include<cstring> #include<ctime> #include<cstdio> #include<cstring> #include<cstdlib> #include<cctype> #include<cassert> #include<complex> #include<numeric>  using namespace std;  #define DEBUG                            0 #define BUG(x)                           cout<<"Debugging Variable "<< #x <<endl #define VAR(x,a)                         __typeof(a) x(a) #define FORD(i,a,b)                      for(int i = (int)a,_b = (int)b;i>=(_b);--i) #define FOREACH(it,v)                    for(VAR(it,(v).begin());it!=(v).end();++it) #define FOR(i,a,b)                       for(int i=(int)(a),_b = (int)b;i<(int)(_b);++i) #define REP(i,n)                         FOR(i,0,n) #define REPD(i,n)                        FORD(i,n,0) #define Size()                           size() #define PB                               push_back #define PF                               push_front #define MP                               make_pair #define SZ                               size() #define ALL(X)                           X.begin(),X.end() #define Clear(X)                         memset(X,0,sizeof(X)) #define PushBack                         push_back #define PushFront                        push_front #define MakePair                         make_pair #define PopBack                          pop_back #define PopFront                         pop_front #define BitCount                         __builtin_popcount #define INF                              100000000 #define INFLL                            10000000000000000LL #define First                            first #define Second                           second #define N                                10000000  typedef vector< int >                    VI; typedef vector< double >                 VD; typedef vector< string >                 VS; typedef vector< char >                   VC; typedef vector< long double >            VLD; typedef vector< long long >              VLL; typedef vector< vector< int > >          VVI; typedef vector< pair< int,int > >        VPII; typedef vector< vector< double > >       VVD; typedef vector< vector< char > >         VVC; typedef vector< vector< string > >       VVS; typedef vector< vector< long long > >    VVLL; typedef string                           SS; typedef unsigned long long               ULL; typedef long long                        LL; typedef long double                      LD; typedef pair< int,int >                  PII; typedef unsigned long                    UL;  int RInt(){int c;scanf("%d",&c);return c;} SS  RSS(){SS S;cin>>S;return S;} LL  RLL(){LL c;cin>>c;return c;} VI  RVInt(int c){VI V(c,0);for(int i=0;i<c;++i)scanf("%d",&V[i]);return V;}  void DInt(int X){cout<<"Value Of Variable = "<<X<<endl;} void DSS(SS S){cout<<"String is "<<S<<endl;} void DVInt(VI V){cout<<"Vector Size = "<<V.SZ<<endl;cout<<"Elements "<<endl;REP(i,V.SZ)cout<<V[i]<<" ";cout<<endl;} void DLL(LL X){cout<<"Value Of Variable = "<<X<<endl;}  int PFlag[N+10],SFlag[N+10],c[N+10]; int s[N+10]; void BuildTables(void); int main() {     BuildTables();     int Test=RInt();     while(Test--) {         int A=RInt(),B=RInt();         LL Return=0LL;         if(A>B)             swap(A,B);         for(int i=1;i<=A&&i<=10000;i++)             Return+=(LL)c[i]*(LL)(A/i)*(LL)(B/i);         if(A>10000) {             for(int i=10001;i<=A;) {                 int jA=A/(A/i);                 int jB=B/(B/i);                 if(jB<jA)                      jA=jB;                 Return+=(LL)(s[jA]-s[i-1])*(LL)(A/i)*(LL)(B/i);                 i=jA+1;             }         }         printf("%lld\n",Return);     }     return 0; } void BuildTables(void) {     Clear(PFlag);     Clear(SFlag);     for(int i=3;i<=N;i+=2) {         if(PFlag[i])              continue;         PFlag[i]=1;         for(int j=3*i;j<=N;j+=2*i)             PFlag[j]++;         if(i<3500)         for(int j=i*i;j<=N;j+=2*i*i)             SFlag[j]++;         if(i<300)             for(int j=i*i*i;j<=N;j+=2*i*i*i)                 SFlag[j]=2;     }     PFlag[2]=1;SFlag[2]=0;     for(int i=4;i<=N;i+=8) {         PFlag[i]=PFlag[i>>2]+1;         SFlag[i]=SFlag[i>>2]+1;     }     for(int i=8;i<=N;i+=8)         SFlag[i]=2;     for(int i=6;i<=N;i+=4) {         PFlag[i]=PFlag[i>>1]+1;         SFlag[i]=SFlag[i>>1];     }     s[1]=0;c[1]=0;     for(int i=2;i<=N;i++) {         switch(SFlag[i]) {             case 0: c[i]=((PFlag[i]&1)?PFlag[i]:(-PFlag[i]));                     break;             case 1: c[i]=((PFlag[i]&1)?(-1):1);                     break;             default: c[i]=0;         }         s[i]=s[i-1]+c[i];     }  } 
#include<iostream> #include<cstdio> #include<algorithm> #include<cstring> #include<cmath> #include<vector>  using namespace std;  #define ll long long #define llu unsigned long long #define MOD 1000000007 #define INF 2000000000  vector <int> adj[100005]; int fpar[100005],par[100005]; int ans[100005],mn[100005];  int get(int node) {     if(fpar[node]==-1)     return node;          if(fpar[fpar[node]]!=-1)     {        mn[node] = min(mn[node],get(fpar[node]));        fpar[node] = fpar[fpar[node]];     }     return mn[node]; }  int main() {     int t,i,j,u,v,n,m,q;     scanf("%d",&t);     while(t--)     {               scanf("%d%d%d",&n,&m,&q);               for(i=0;i<=n;i++)               adj[i].clear();                              while(m--)               {                    scanf("%d%d",&u,&v);                    adj[v].push_back(u);               }                              int mx;                              for(i=1;i<=n;i++)               {                  fpar[i] = -1;                  ans[i] = mx = 0;                  for(j=0;j<adj[i].size();j++)                  {                      if(adj[i][j]<i)                      {                         mx = max(mx,adj[i][j]);                      }                  }                  par[i] = mx;               }                              for(i=n;i>=2;i--)               {                  int tmp = i;                  for(j=0;j<adj[i].size();j++)                  {                      u = adj[i][j];                      tmp = min(tmp,get(u));                      if(tmp == 1)                      break;                  }                                    fpar[i] = par[i];                  mn[i] = tmp;                  ans[tmp]++;               }                              while(q--)               {                    scanf("%d",&u);                    printf("%d ",ans[u]);               }               printf("\n");     }     //system("pause");     return 0; } 
#include <iostream> #include <vector> #include <ctime> #include <cmath> #include <cstdio> #include <set> #include <map> #include <fstream> #include <sstream> #include <cstdlib> #include <numeric> #include <string> #include <cassert> #include <cstring> #include <algorithm>   #define mp make_pair #define pb push_back #define all(x) (x).begin(), (x).end()   using namespace std;   typedef pair<int, int> pii; typedef pair<int, unsigned int> piu;   struct TEdge {     int from, to, cost;       explicit TEdge(int from = 0, int to = 0, int cost = 0)         : from(from)         , to(to)         , cost(cost)     {     }       bool operator!=(const TEdge &e) {         return from != e.from || to != e.to;     } };   vector<TEdge> edges[100]; vector< vector<TEdge> > comps; vector< vector<int> > compByV; vector<TEdge> eSt; int d[100], up[100]; int tin[100]; int tt; bool vis[100];   void dfs(int v, int p) {     vis[v] = true;     tin[v] = up[v] = tt++;     for (size_t i = 0; i < edges[v].size(); ++i) {         int u = edges[v][i].to;         if (u == p) {             continue;         }         if (!vis[u]) {             eSt.pb(edges[v][i]);             dfs(u, v);             if (up[u] >= tin[v]) {                 comps.resize(comps.size() + 1);                 while (eSt.back() != edges[v][i]) {                     comps.back().pb(eSt.back());                     eSt.pop_back();                 }                 comps.back().pb(eSt.back());                 eSt.pop_back();             }             up[v] = min(up[v], up[u]);         } else {             if (tin[u] < tin[v]) {                 eSt.pb(edges[v][i]);             }             up[v] = min(up[v], tin[u]);         }     } }   piu globalAns;   inline void combine(piu &a, const piu &b) { /*    if (a.first != b.first) {         return a.first > b.first ? a : b;     }     return mp(a.first, a.second + b.second);*/     if (b.first > a.first) {         a = b;         return;     }     if (b.first == a.first) {         a.second += b.second;     } }   piu prod(const piu &a, const piu &b) {     return mp(a.first + b.first, a.second * b.second); }   bool cvis[500];   /*void bruteTree(const vector< vector<TEdge> > &edges, vector<pii> &st, int minv, int cost, int mask, int left, vector<piu> &dp) {     if (mask != 0) {         dp[mask] = combine(dp[mask], mp(cost, 1));     }     if (mask) {         combine(dp[mask], mp(cost, 1));         if (dp[mask].first != cost) {             return;         }     }     if (left == 0) {         return;     }     while (!st.empty()) {         int v = st.back().first;         int bv = (mask >> (2 * v)) & 3;         if (bv < 3) {             while (st.back().second < edges[v].size()) {                 int u = edges[v][st.back().second].to, c = edges[v][st.back().second].cost;                 ++st.back().second;                 int bu = (mask >> (2 * u)) & 3;                 if (u > minv && bu == 0) {                     vector<pii> nst = st; //                    nst.back().second = j + 1;                     nst.pb(mp(u, 0));                     bruteTree(edges, nst, minv, cost + c, mask + (1 << (2 * u)) + (1 << (2 * v)), left - 1, dp);                 }             }         }         st.pop_back();     } } */     //piu allpairs[10][1000000]; vector<pii> allpairs[10]; vector<pii> allow[10]; int aps[10]; //vector<int> tr[10];   void rec(int lmask, int rmask, int i, int N, int n1, int n2, int sd1, int sd2, int lall, int rall, int lm, int rm) {     if (i == N) {         if (lmask <= rmask && (lmask == 0 || sd1 == 2 * (n1 - 1)) && (rmask == 0 || sd2 == 2 * (n2 - 1))) {   //          allpairs[N][aps[N]++] = mp(lmask, rmask);             allpairs[N].pb(mp(lmask, rmask));             if (!lmask) {                 lall = (1 << N) - 1 - rm;             }             if (!rmask) {                 rall = (1 << N) - 1 - lm;             }             allow[N].pb(mp(lall, rall));         }         return;     }     for (int j = 1; j <= 3; ++j) { //        if (lmask || rmask) {             rec(lmask + (j << (2 * i)), rmask, i + 1, N, n1 + 1, n2, sd1 + j, sd2, lall + (1 << i) * (j < 3), rall, lm + (1 << i), rm); //        }         rec(lmask, rmask + (j << (2 * i)), i + 1, N, n1, n2 + 1, sd1, sd2 + j, lall, rall + (1 << i) * (j < 3), lm, rm + (1 << i));     }     rec(lmask, rmask, i + 1, N, n1, n2, sd1, sd2, lall, rall, lm, rm); }       inline int getGr(int x, int i) {     return (x >> (2 * i)) & 3; }   inline int gr0(int x, int i) {     return getGr(x, i) == 0; }   inline int gr3(int x, int i) {     return getGr(x, i) == 3; }   vector<piu> compDfs(int k, int p) {     cvis[k] = true;     vector<int> v;     for (size_t i = 0; i < comps[k].size(); ++i) {         v.pb(comps[k][i].from);         v.pb(comps[k][i].to);     }     sort(all(v));     v.erase(unique(all(v)), v.end());     int K = v.size();     assert(K < 10);     vector<pii> &pMasks = allpairs[K], &pAll = allow[K];     int M = 1 << (2 * K);     vector<piu> dp(M, mp(-1e9, 1));     dp[0] = mp(0, 1);     for (size_t i = 0; i < comps[k].size(); ++i) {         TEdge ee = comps[k][i];         int x = find(all(v), ee.from) - v.begin();         int y = find(all(v), ee.to) - v.begin();         int c = ee.cost;         int add = (1 << (2 * x)) + (1 << (2 * y));         for (vector<pii>::iterator it = pMasks.begin(), al = pAll.begin(); it != pMasks.end(); ++it, ++al) { //        piu *it = allpairs[K]; //        for (int j = 0; j < aps[K]; ++j) {             int l = it->first, r = it->second;             int lall = al->first, rall = al->second;             //int lx = getGr(l, x), ly = getGr(l, y), rx = getGr(r, x), ry = getGr(r, y);             //if (ly == 0 && rx == 0 && lx != 3 && ry != 3 && (!l || lx != 0) && (!r || ry != 0)) { //            int q = 0;             if (((1 << x) & lall) && ((1 << y) & rall)) {                 combine(dp[(l | r) + add], prod(mp(c, 1), prod(dp[l], dp[r])));             }             if (l < r && ((1 << y) & lall) && ((1 << x) & rall)) {                 combine(dp[(l | r) + add], prod(mp(c, 1), prod(dp[l], dp[r])));             } /*            if (q) {                 combine(dp[(l | r) + add], prod(mp(c, q), prod(dp[l], dp[r])));             }*/         }     }     for (size_t i = 0; i < K; ++i) {         int u = v[i];         if (u == p) {             continue;         }         for (size_t j = 0; j < compByV[u].size(); ++j) {             int kk = compByV[u][j];             if (cvis[kk]) {                 continue;             }             vector<piu> ans = compDfs(kk, u); //            for (int qq = tr[K].size() - 1; qq >= 0; --qq) { //                int q = tr[K][qq];             for (int q = M - 1; q >= 0; --q) {                 if (dp[q].first < -1e8) {                     continue;                 }                 int bu = getGr(q, i);//(q >> (2 * i)) & 3;                 if (bu == 0 && q > 0) {                     continue;                 }                 for (int s = 1; s <= 3 - bu; ++s) {                     if (ans[s].first < -1e8) {                          continue;                     }                     combine(dp[q + (s << (2 * i))], prod(dp[q], ans[s]));                 }             }         }     }     int j = find(all(v), p) - v.begin();     for (int q = 1; q < M; ++q) { //    for (int qq = 1; qq < tr[K].size(); ++qq) { //        int q = tr[K][qq]; //        int bj = (q >> (2 * j)) & 3;         if (p == -1 || getGr(q, j) == 0) {             combine(globalAns, dp[q]);         }     }     vector<piu> ans(4, mp(-1e9, 1));     if (p == -1) {         return ans;     }     for (int q = 0; q < M; ++q) { //        int bj = (q >> (2 * j)) & 3;         combine(ans[getGr(q, j)], dp[q]);     } //    delete[] dp;     return ans; }   int main() { #ifdef LOCAL_DEFINE     freopen("input.txt", "rt", stdin);     freopen("output.txt", "wt", stdout); #endif       for (int i = 1; i < 10; ++i) {         aps[i] = 0;         rec(0, 0, 0, i, 0, 0, 0, 0, 0, 0, 0, 0); //        vector<int> u;     }       int T;     cin >> T;     for (int t = 0; t < T; ++t) {         int N, M;         cin >> N >> M;         for (int i = 0; i < N; ++i) {             edges[i].clear();         }         for (int i = 0; i < M; ++i) {             int x, y, c;             cin >> x >> y >> c;             --x; --y;             edges[x].pb(TEdge(x, y, c));             edges[y].pb(TEdge(y, x, c));         }         comps.clear();         for (int i = 0; i < N; ++i) {             vis[i] = false;         }         for (int i = 0; i < N; ++i) {             if (!vis[i]) {                 tt = 0;                 dfs(i, -1);             }         }         compByV.assign(N, vector<int>());         for (size_t i = 0; i < comps.size(); ++i) {             for (size_t j = 0; j < comps[i].size(); ++j) {                 //cout << comps[i][j].from << ' ' << comps[i][j].to << ' ' << comps[i][j].cost << '\n';                 compByV[comps[i][j].from].pb(i);                 compByV[comps[i][j].to].pb(i);             }             //cout << '\n';         }         for (int i = 0; i < N; ++i) {             sort(all(compByV[i]));             compByV[i].erase(unique(all(compByV[i])), compByV[i].end());         }         globalAns = mp(0, N + 1);         for (size_t i = 0; i < comps.size(); ++i) {             cvis[i] = false;         }         for (size_t i = 0; i < comps.size(); ++i) {             if (!cvis[i]) {                 compDfs(i, -1);             }         }         cout << globalAns.first << ' ' << globalAns.second << '\n';     }     cerr << 1.0 * clock() / CLOCKS_PER_SEC << '\n';       return 0; }
#include <math.h> #include <stdio.h> #include <string.h> #include <vector> #include <string> #include <queue> #include <map> #include <algorithm> #include <cmath> #include <iostream> #include <sstream> #include <set> using namespace std;   const int mmod = 998244353;   int inv_mod(int a, int b) {   if (a == 1) return b;   int div = mmod / a + 1;   return inv_mod((a * (long long)div) % mmod, (b * (long long)div) % mmod); }   vector<int> get_combi(int N, int M) {   vector<int> mult_from_N(M+1, 1);   vector<int> mult_down_N(M+1, 1);   vector<int> mult_from_1(M+1, 1);   vector<int> inv_from_1(M+1, 1);   vector<int> combo1(M+1, 1);   vector<int> combo2(M+1, 1);   for (int i=1; i<=M; i++) {     mult_from_N[i] = (1LL * mult_from_N[i-1] * (N-1+i)) % mmod;     mult_down_N[i] = (1LL * mult_down_N[i-1] * (N+1-i)) % mmod;     mult_from_1[i] = (1LL * mult_from_1[i-1] * i) % mmod;     inv_from_1[i] = inv_mod(mult_from_1[i], 1);       combo1[i] = (1LL * mult_from_N[i] * inv_from_1[i]) % mmod;     combo2[i] = (1LL * mult_down_N[i] * inv_from_1[i]) % mmod;   }     vector<int> res;     for (int m=0; m<=M; m++) {     int mult = 1;     int now = 0;       for (int i=0; i*10<=m && i<=N; i++) {       int o1 = combo1[m-i*10];//(1LL * mult_from_N[m-i*10] * inv_from_1[m-i*10]) % mmod;//C(m-i*10+N-1, m-i*10);//H(m+1-i*10, N-1);       int o2 = combo2[i];//(1LL * mult_down_N[i] * inv_from_1[i]) % mmod;//C(N, i)       now = (now + 1LL * mult * o1 * o2) % mmod;       if (now < 0) now += mmod;         mult = -mult;     }     res.push_back(now);   }   return res; }   int tmp[11111111];   void mult2(int a_start, int b_start, int idx, int step) { /*  printf("%d %d %d %d : ", a_start, b_start, idx, step);   for (int i=0; i<step; i++) printf("%d ", tmp[a_start+i]); printf(" / ");   for (int i=0; i<step; i++) printf("%d ", tmp[b_start+i]); printf("\n");*/   tmp[idx+step*2-1] = 0;     if (step == 1) {     tmp[idx] = (1LL * tmp[a_start] * tmp[b_start]) % mmod;     return;   }     int all_zero = 1;   for (int i=0; i<step; i++) if (tmp[a_start+i]) { all_zero = 0; break; }   if (all_zero) {     for (int i=0; i<step*2-1; i++) tmp[idx+i] = 0;     return;   }   all_zero = 1;   for (int i=0; i<step; i++) if (tmp[b_start+i]) { all_zero = 0; break; }   if (all_zero) {     for (int i=0; i<step*2-1; i++) tmp[idx+i] = 0;     return;   }     int half = step/2;     // z0 = x0*y0   mult2(a_start, b_start, idx, half);     // z2 = x1*y1   mult2(a_start + half, b_start + half, idx+step, half);     // z1 = (x1+x0)*(y1+y0) - z2 - z0   for (int i=0; i<half; i++) {     tmp[idx+2*step+i] = tmp[a_start+i] + tmp[a_start+half+i];     tmp[idx+2*step+half+i] = tmp[b_start+i] + tmp[b_start+half+i];     if (tmp[idx+2*step+i] >= mmod) tmp[idx+2*step+i] -= mmod;     if (tmp[idx+2*step+half+i] >= mmod) tmp[idx+2*step+half+i] -= mmod;   }   mult2(idx+2*step, idx+2*step+half, idx+3*step, half);   for (int i=0; i<step-1; i++) {     int* c = &tmp[idx+3*step+i];     *c -= tmp[idx+step+i] + tmp[idx+i];   }     // add all   for (int i=0; i<step-1; i++) {     tmp[idx+half+i] += tmp[idx+3*step+i];     if (tmp[idx+half+i] >= mmod) tmp[idx+half+i] -= mmod;     else if (tmp[idx+half+i] < 0) {       tmp[idx+half+i] += mmod;       if (tmp[idx+half+i] < 0)         tmp[idx+half+i] += mmod;     }   } //  printf("%d %d %d %d : ", a_start, b_start, idx, step); for (int i=0; i<step*2; i++) printf("%d ", tmp[idx+i]); printf("\n"); }   vector<int> mult(int* a, int *b, int MM) { /*  vector<int> nxt2(MM);   for (int k=0; k<MM; k++)     for (int l=0; l<MM-k; l++)       nxt2[k+l] = (nxt2[k+l] + 1LL * a[k] * b[l]) % mmod;   return nxt2;*/   /*  printf("mult A = "); for (int i=0; i<MM; i++) printf("%d ", a[i]); printf("\n");   printf("mult B = "); for (int i=0; i<MM; i++) printf("%d ", b[i]); printf("\n");*/     int eff_MM = 1;   while (eff_MM < MM) eff_MM *= 2;     for (int i=0; i<eff_MM*2; i++) tmp[i] = 0;   for (int i=0; i<MM; i++) {     tmp[i] = a[i];     tmp[i+eff_MM] = b[i];   }   mult2(0, eff_MM, 2*eff_MM, eff_MM);   vector<int> res(MM);   for (int i=0; i<MM; i++)     res[i] = tmp[2*eff_MM + i];   //  printf("res = "); for (int i=0; i<MM; i++) printf("%d ", res[i]); printf("\n");     return res; }   const int max_mm = 16384; const int max_p = 50; int prv[max_mm+1][max_p];   int main() {   int N, P, MM;   cin >> N >> P >> MM;     // 1. get each digit's value   vector<int> occ(P);     {     vector<int> prv(P, -1);     int pp = 1 % P;     prv[pp] = 0;     occ[pp] ++;     for (int i=1; i<N; i++) {       pp = (pp * 10) % P;       if (prv[pp] > -1 && (N-i)%(i-prv[pp]) == 0) {         int rep = (N-i) / (i-prv[pp]);         for (int j=0; j<P; j++)           if (prv[j] >= prv[pp]) occ[j] += rep;         break;       }       prv[pp] = i;       occ[pp] ++;     }   }     for (int i=0; i<P; i++) fprintf(stderr, "%d ", occ[i]); fprintf(stderr, "\n");     // 2. Get the same value's counts.   int combi[max_p][max_mm] = {0};   for (int i=0; i<P; i++) {     int same = 0;     for (int j=0; j<i; j++)       if (occ[i] == occ[j]) {         for (int k=0; k<=MM; k++)           combi[i][k] = combi[j][k];         same = 1;         break;       }     if (!same) {       vector<int> a = get_combi(occ[i], MM);       for (int j=0; j<=MM; j++) combi[i][j] = a[j];     } //    for (int j=0; j<combi[i].size(); j++) printf("%d ", combi[i][j]); printf("\n");   }     // 3. combine with counts   prv[0][0] = 1;   int first = 1;   for (int i=0; i<P; i++) {     if (!occ[i]) continue;     fprintf(stderr, "%d\n", i);     if (first) {       prv[0][0] = 0;       for (int j=0; j<=MM; j++)         prv[j][(i*j)%P] = combi[i][j];       first = 0;       continue;     }       int nxt[max_mm+1][max_p];     for (int j=0; j<P; j++) {       int prv2[max_mm+1];       for (int k=0; k<=MM; k++)         prv2[k] = prv[k][(k*i+j)%P]; /*      vector<int> nxt2(MM+1);       for (int k=0; k<=MM; k++)         for (int l=0; l<=MM-k; l++)           nxt2[k+l] = (nxt2[k+l] + 1LL * prv2[k] * combi[i][l]) % mmod;*/       vector<int> nxt2 = mult(prv2, combi[i], MM+1);       for (int k=0; k<=MM; k++)         nxt[k][(k*i+j)%P] = nxt2[k];     }     for (int j=0; j<=MM; j++)       for (int k=0; k<P; k++)         prv[j][k] = nxt[j][k];   }     // Print!   int res = 0;   for (int i=0; i<=MM; i++) {     res = (res + prv[i][0]) % mmod;     printf("%d ", res);   }   printf("\n"); }  
#include <set> #include <bitset> #include <list> #include <map> #include <queue> #include <stack> #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <iostream> #include <climits> #include <cstring> #include <ctime> #include <string> #include <algorithm> #include <vector> #include <stack> #include <sstream> #define MID(x,y) ( ( x + y ) >> 1 ) #define L(x) ( x << 1 ) #define R(x) ( x << 1 | 1 ) #define REP(i,t) for(int i=0; i<(t); i++) #define FOR(i,s,t) for(int i=(s); i<(t); i++) #define FORD(i,a,b) for (int i = (a); i >= (b); i--) #define FORL(i,s,t) for(L i=(s); i<(t); i++) #define BUG puts("here!!!") #define STOP system("pause") #define file_r(x) freopen(x, "r", stdin) #define file_w(x) freopen(x, "w", stdout) #define EPS 1e-11 #define EQ(a, b) (fabs((a) - (b)) <= EPS) #define POS(a) ((a) >= EPS) #define NEG(a) ((a) <= -EPS) #define BG(a, b) ((a) - (b) >= EPS) #define LS(a, b) ((b) - (a) >= EPS) #define CLR(a, x) memset( a, x, sizeof( a ) ) #define PI (atan(1.0) * 4) #define SQ(x) ((x) * (x)) #define DIST(x1, y1, x2, y2) (sqrt(SQ((x1) - (x2)) + SQ((y1) - (y2)))) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define setmin(a, b) (a = min(a, b)) #define setmax(a, b) (a = max(a, b)) #define LOG2(x) (log(x) / log(2)) #define XX first.first #define XY first.second #define YX second.first #define YY second.second  using namespace std; typedef unsigned long long ULL; typedef long long LL; typedef pair<double, double> Pd; typedef pair<int, int> Pi; typedef pair<LL, LL> Pl;  bool v[11][11]; const int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; LL ans1, cnt;  void dfs(int i, int j, int r, int c, int tr, int tc) {   cnt++;   v[i][j] = 1;   if (i == tr && j == tc)     ans1 = cnt;   REP(k, 4) {     int nexti = i + dir[k][0];     int nextj = j + dir[k][1];     if (nexti >= 1 && nextj >= 1 && nexti <= r && nextj <= c && !v[nexti][nextj])       dfs(nexti, nextj, r, c, tr, tc);   } }  void solve_correct(int r, int c, int sr, int sc, int tr, int tc) {   CLR(v, 0);   cnt = 0;   dfs(sr, sc, r, c, tr, tc); }  LL solve(LL r, LL c, LL sr, LL sc, LL tr, LL tc) {   bool rb = (tr - sr) % 2 == 0;   bool rb1 = (r - tr) % 2 == 0;   bool rb2 = (r - sr) % 2 == 0;   if (tr == sr && tc >= sc)     return tc - sc + 1;   if (tr > sr && tc == c)     return c - sc + tr - sr + 1;   if (r == 1) {     return c - tc + 1;   }   if (c == 1) {     return r - tr + 1;   }   if (sc == 1) {     if (tr > sr) {       return c - sc + r - sr + 1 + (r - tr) * (c - 1) + (rb1?(c - tc):tc);     } else {       return (r - tr) * c + (rb?tc:(c - tc + 1));     }   }   if (sr == r) {     if (sc == c)       return (r - tr) * c + (rb?(c - tc + 1):tc);     LL p = sc - 1 - (sr - tr);     if (p >= 0) {       LL rem;       if (rb == (tc <= p)) {         if (tr == 1 && tc <= p)           rem = p - tc + 1;         else           rem = c - tc + 1 + (tc <= p);       } else         rem = tc + (tc > p);       return c - sc + 1 + (r - tr - (tc > p)) * (c + 1) + rem;     } else {       return (r - tr) * c + (rb?tc:(c - tc + 1));     }   }   if (tr > sr) {     return c - sc + r - sr + 1 + (r - tr) * (c - 1) + (rb1?(c - tc):tc);   }   if (rb2) {     if (tr == sr)       return (r - tr + 1) * c - tc + 1;     return (r - tr) * c + (rb?(c - tc + 1):tc);   }   LL base = c - sc + 1 + (r - sr) * c;   LL p = sc - 1 - (sr - tr);   if (p >= 0) {     LL rem;     if (rb == (tc <= p))       rem = tc + (tc > p);     else if (tr == 1 && tc <= p)       rem = p - tc + 1;     else      rem = c - tc + 1 + (tc <= p);     return base + (sr - tr - (tc > p)) * (c + 1) + rem;   } else {     return (r - tr) * c + (rb?(c - tc + 1):tc);   } }  int main() { /*   int n = 10;   FOR(i, 1, n + 1)     FOR(j, 1, n + 1)       FOR(p, 1, n + 1)         FOR(q, 1, n + 1) {           solve_correct(n, n, i, j, p, q);           LL ans = solve(n, n, i, j, p, q);           if (ans != ans1) {             printf("sr=%d sc=%d tr=%d tc=%d ans=%lld ans1=%lld\n", i, j, p, q, ans, ans1);             exit(0);           }         }*/   int t;   cin >> t;   while (t--) {     LL r, c, sr, sc, tr, tc;     cin >> r >> c >> sr >> sc >> tr >> tc;     cout << solve(r, c, sr, sc, tr, tc) << endl;   }   return 0; } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 50050 int fi[N],c[N*2][2],val[N],ad[N*4],sg[N],nd[N],Gcd[N*4],h[N]; int fa[N],wei[N],rf[N],n,m,ss=1,st;bool b[N]; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Line(int x,int y)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } void DFS(int x)  {  	wei[x] = true; h[x] = h[fa[x]] + 1;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0] != fa[x])  	   fa[c[i][0]] = x, DFS(c[i][0]), wei[x] += wei[c[i][0]];  	return;  } void DSF(int x,int y)  {  	rf[x] = y;sg[x] = ++ st;nd[st] = x;int k = false;  	for (int i = fi[x]; i; i = c[i][1])  	 if (c[i][0] != fa[x] && wei[c[i][0]] > wei[k])  	   k = c[i][0];  	if (k) DSF(k,y); else b[x] = true;  	for (int i = fi[x]; i; i = c[i][1])  	 if (c[i][0] != fa[x] && c[i][0] != k)  	   DSF(c[i][0],c[i][0]);  	return;  } int gcd(int x,int y) {return !y?x: gcd(y,x%y);} void Set_up(int x,int y,int z)  {  	int mid = x + y >> true, j = z << true;  	if (x==y)  	 {  	 	x = nd[x];  	 	Gcd[z] = b[x] ? val[x] : val[x] - val[nd[sg[x] + 1]];  	 	return;  	 }  	Set_up(x, mid, j); Set_up(mid + 1, y, j + 1);  	Gcd[z] = gcd(Gcd[j + 1], Gcd[j]);  	return;  } void adj(int z)  {  	if (!ad[z]) return;  	int j = z << true;  	ad[j] += ad[z]; ad[j + 1] += ad[z]; ad[z] = false;  	return;  } void Modify(int x,int y,int z,int o,int p)  {  	int mid = x + y >> true, j = z << true;  	if (x==y) {Gcd[z] += p; return;}  	if (o <= mid) Modify(x,mid,j,o,p); else  	  Modify(mid + 1, y, j + 1, o, p);  	Gcd[z] = gcd (Gcd[j + 1], Gcd[j]);  	return;  } void Insert(int x,int y,int z,int o,int p,int u)  {  	int mid = x + y >> true, j = z << true;  	if (x != y) adj(z);  	if (x == o && y == p) {ad[z] += u; return;}  	if (p <= mid) Insert(x,mid,j,o,p,u); else  	 if (o>mid) Insert(mid+1,y,j+1,o,p,u); else  	   Insert(x,mid,j,o,mid,u),Insert(mid+1,y,j+1,mid+1,p,u);  	return;  } int Query(int x,int y,int z,int o)  {  	int mid = x + y >> true, j = z << true;  	if (x != y) adj(z);  	if (x==y)  	 {  	 	val[nd[x]] += ad[z];  	 	ad[z] = false;  	 	return val[nd[x]];  	 }  	if (o<=mid) return Query(x,mid,j,o); else  	  return Query(mid+1,y,j+1,o);  } int _Query(int x,int y,int z,int o,int p)  {  	int mid = x + y >> true, j = z << true;  	if (x==o&&y==p) return Gcd[z];  	if (p<=mid) return _Query(x,mid,j,o,p); else  	 if (o>mid) return _Query(mid+1,y,j+1,o,p); else  	   return gcd(_Query(x,mid,j,o,mid),  	   	_Query(mid+1,y,j+1,mid+1,p));  } int Get(int x,int y)  {  	int k = Query(1,n,1,y);  	if (x != y) k = gcd (k, _Query(1,n,1,x,y-1));  	return k;  } void _Modify(int z,int y,int x)  {  	x++;y++;  	while (rf[x] != rf[y])  	 {  	 	if (h[rf[x]] < h[rf[y]]) swap(x,y);  	 	Insert(1,n,1,sg[rf[x]],sg[x],z);  	 	Modify(1,n,1,sg[x],z);  	 	x = fa[rf[x]];  	 }  	if (h[x] > h[y]) swap(x,y);  	Insert(1,n,1,sg[x],sg[y],z);  	Modify(1,n,1,sg[y],z);  	if (x != rf[x])  	  Modify(1,n,1,sg[x] - 1,-z);  	return;  } int Query(int x,int y)  {  	int Ans = false;x++;y++;  	while (rf[x] != rf[y])  	 {  	 	if (h[rf[x]] < h[rf[y]]) swap(x,y);  	 	Ans = gcd(Ans, Get(sg[rf[x]], sg[x]));  	 	x = fa[rf[x]];  	 }  	if (h[x] > h[y]) swap(x,y);  	Ans = gcd(Ans, Get(sg[x], sg[y]));  	return abs(Ans);  } int main()  {  	//freopen("input.txt","r",stdin);  	n=Read();  	for (int i=1;i<n;i++) Line(Read()+1,Read()+1);  	for (int i=1;i<=n;i++) val[i]=Read();  	DFS(1);DSF(1,1);Set_up(1,n,1);m=Read();     while (m--)      {      	static char ch[20]; scanf("%s",ch+1);      	if (ch[1]=='C') _Modify(Read(),Read(),Read()); else      	  printf("%d\n",Query(Read(),Read()));      }  	return 0;  }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 100050 #define M 21 #define Base +10079 #define PII pair <int,int> #define fr first #define sc second #define mp make_pair #define ll unsigned long long int fi[N],c[N*2][2],fa[N][M],val[N],li[N],h[N],d[N],Rk[N][M]; int sg[N],_sg[N],n,m,ss=1,st,Mul;PII _li[N];ll ans; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Line(int x,int y)  {  	val[x]++;val[y]++;  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } void DFS(int x)  {  	h[x]=h[fa[x][0]]+1;  	for (int i=1;i<M;i++) fa[x][i]=fa[fa[x][i-1]][i-1];  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x][0])  	   fa[c[i][0]][0]=x,DFS(c[i][0]);  	return;  } inline bool cmp(int x,int y)  {return li[x]<li[y]||(li[x]==li[y]&&  	li[fa[x][Mul]]<li[fa[y][Mul]]);} void Multi()  {  	for (int i=1;i<=n;i++) _sg[i]=i;  	sort(_sg+1,_sg+n+1,cmp);st=false;     for (int i=1;i<=n;i++)      {      	if (!(li[_sg[i]]==li[_sg[i-1]]&&      	  li[fa[_sg[i]][Mul]]==li[fa[_sg[i-1]][Mul]])) st=i;      	d[_sg[i]]=st;sg[i]=_sg[i];      }     memcpy(li,d,sizeof d);     for (int i=1;i<=n;i++) Rk[i][Mul+1]=li[i];  	return;  } int LCA(int x,int y)  {  	int len = false;  	for (int i=Mul;~i;i--)  	 if (Rk[x][i]==Rk[y][i])  	   len += 1 << i, x = fa[x][i], y = fa[y][i];  	return len;  } void Solve()  {  	for (int i=1;i<=n;i++) _li[i]=mp(val[i],i);  	sort(_li+1,_li+n+1);     for (int i=1;i<=n;i++)      {      	if (_li[i].fr!=_li[i-1].fr) st=i;      	li[_li[i].sc]=st;sg[i]=_li[i].sc;Rk[_li[i].sc][0]=st;      }     for (Mul=false;(1 << Mul)<n;Mul++) Multi();     for (int i=1;i<=n;i++)      {      	int len = false, k = sg[i], l = sg[i-1];      	if (li[k]==li[l]) continue;      	ans += h[sg[i]] - LCA(k,l);      }     return;  } int main()  {     n=Read();if (n==1) {cout <<1<<endl;exit(0);}  	for (int i=1;i<n;i++) Line(Read(),Read());  	DFS(1);Solve();cout <<ans<<endl;  	return 0;  }
#include<iostream> #include<cmath> #include<set> #include<vector> #include<list> #include<map> #include<algorithm> #include<stdio.h> #include<string.h> #include<stack> #include<queue> #include<climits> #include <string> #include <sstream>  typedef unsigned long long int ULONG; typedef unsigned int UINT;  using namespace std; #define FOR(i,a,b) for(int i=a;i<b;++i)  #ifndef ONLINE_JUDGE #include <time.h> #endif  int N; int G[101][101]; int V[101],VM[101];  int P2[]={0,0,1,2,4,8,16,32};  #define oo 100000000  int DPS[101][65][4][7]; int DPD[101][65][4][7];  struct VX{ 	int n,m,m4,m7; 	VX(int xn,int xm,int xm4,int xm7){ 		n=xn; 		m=xm; 		m4=xm4; 		m7=xm7; 	} 	 }; bool operator < (const VX& A, const VX& B)  {       return A.n < B.n;     } 	  int main(){ #ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	clock_t start = clock(); #endif 	 	while(scanf("%d",&N)>0 && N!=0){ 		FOR(i,0,N){ 			scanf("%d",&V[i]); 		} 		FOR(i,0,N){ 			FOR(j,0,N)scanf("%d",&G[i][j]); 		}   		FOR(i,0,N) 			FOR(j,0,65) 				FOR(k,0,4) 					FOR(l,0,7){ 						DPS[i][j][k][l]=-1; 						DPD[i][j][k][l]=oo; 		 		}  		DPD[0][0][V[0]%4][V[0]%7]=0;  		int MK=oo; 		priority_queue< pair<int,VX> > Q; 		Q.push( pair<int,VX>(  -V[0] ,VX(0,0,V[0]%4,V[0]%7)) ); 		int Min; 		while(!Q.empty()){  			pair<int,VX> top=Q.top();Q.pop(); 			int s=-top.first,n=top.second.n,m=top.second.m,m4=top.second.m4,m7=top.second.m7;  			m=(m|P2[V[n]]); 			if(DPS[n][m][m4][m7]!=-1)goto EN; 			DPS[n][m][m4][m7]=0;  			if(n==N-1){ 				FOR(i,2,8){ 					if((P2[i]&m)!=0){ 						switch(i){ 						case 2:if(V[n]%2!=0)goto E;break; 						case 3:if(s%3!=0)goto E;break; 						case 4:if(m4!=0)goto E;break; 						case 5:if(V[n]!=5)goto E;break; 						case 6:if(V[n]%2!=0 || s%3!=0)goto E;break; 						case 7:if(m7!=0)goto E;break; 						} 					} 				} 				if(s<MK)MK=s; 			} 			E:;  			Min=oo; 			FOR(i,0,N){ 				if(G[n][i]==1 && DPD[i][m][(m4*10+V[i])%4][(m7*10+V[i])%7] > s+V[i] ){ 					DPD[i][m][(m4*10+V[i])%4][(m7*10+V[i])%7]=s+V[i]; 					Q.push( pair<int,VX>(  -(s+V[i]) ,VX(i,m,(m4*10+V[i])%4,(m7*10+V[i])%7)) ); 				} 			} 			EN:; 		} 		if(MK>=oo)printf("%d\n",-1); 		else printf("%d\n",MK); 	}    #ifndef ONLINE_JUDGE	 	printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC); #endif 	return 0; }    
#include <iostream> #include <cstdio> #include <vector> #include <string> #include <queue> #include <algorithm> #include <set> #include <map>  using namespace std;  #define REP(i,a,b) for(i = (int)(a); i < (int)(b); i++) #define rep(i,n) REP(i,0,n)  typedef long long ll;  const ll mod = 1000000007LL;  typedef pair<int,pair<int,int> > T; typedef vector<T> V;  V v(700*3*700*2);  inline void init() { int i, j; ll m = 1, n = 1; rep(i,700*3) 	{ 	n = m; 	rep(j,700*2-i*2/3) 		{ 		v.push_back(make_pair((int)n,make_pair(i,j))); 		n = 3LL * n % mod; 		} 	m = 2LL * m % mod; 	} sort(v.begin(), v.end()); }  void extgcd(ll a, ll b, ll &x, ll &y) { if(b == 0) 	{ 	x = 1; 	y = 0; 	return; 	} ll q = a / b, r = a % b, x1, y1; extgcd(b, r, x1, y1); x = y1; y = x1 - y1 * q; }  inline ll inverse(ll a, ll p) { ll x, y; extgcd(a, p, x, y); return x; }  inline int set_num(int count[10], int n2, int n3, int n5, int n7) { count[2] = n2; count[3] = n3; count[5] = n5; count[7] = n7; count[9] = count[3] / 2; count[3] %= 2; count[8] = count[2] / 3; count[2] %= 3; const int n6 = min(count[2], count[3]); count[6] = n6; count[2] -= n6; count[3] -= n6; count[4] = count[2] / 2; count[2] %= 2; int ret = 0, i; rep(i,10) ret += count[i]; return ret; }  inline void copy(int src[10], int dst[10]) { int i; REP(i,2,10) dst[i] = src[i]; }  int main() { init(); int i,j,t; cin >> t; const ll inv5 = inverse(5, mod), inv7 = inverse(7, mod); const pair<int,int> dummy = make_pair(0,0); while(t-- > 0) 	{ 	ll n; 	cin >> n; 	if(n == 0LL) 		{ 		cout << 10 << endl; 		continue; 		} 	if(n == 1LL) 		{ 		cout << 1 << endl; 		continue; 		} 	ll x, y = n; 	int minsum = 1000; 	int count[10] = {}, temp[10] = {}; 	rep(i,700) 		{ 		x = y; 		rep(j,700-i) 			{ 			T u = make_pair(x,dummy); 			V::iterator iter = lower_bound(v.begin(), v.end(), u); 			if(iter->first == x) 				{ 				int cnt2 = iter->second.first, cnt3 = iter->second.second; 				const int sum = set_num(temp, cnt2, cnt3, i, j); 				if(sum < minsum) 					{ 					copy(temp, count); 					minsum = sum; 					} 				} 			x = x*inv7%mod; 			} 		y = y*inv5%mod; 		} 	string res; 	rep(i,10) while(count[i]-- > 0) res += (char)(i+'0'); 	cout << res << endl; 	} return 0; } 
#include <cstdio> #include <vector> #include <cstring> #include <algorithm> using namespace std; int t,n,b,i,j,m,a[77],c[77],en; long long e[100100],x,r; char s[7]; vector <int> f[100100],d; void rec(int i, long long x) {   if (i>m) { e[en++]=x; return; }   long long z=x;   for (int j=0; j<=c[i]; j++) { rec(i+1,z); z*=a[i]; } } int main() {   scanf("%d",&t);   while (t--) {     scanf("%s",&s);     n=strlen(s); r=-1;     for (b=j=0; j<n; j++) if (s[j]<='9') b=max(b,s[j]-'0'+1); else b=max(b,s[j]-'A'+11);     if (n==1) { printf("%d\n",b-1); continue; } else if (b<2) b=2;     for (; ; b++) {       for (x=j=0; j<n; j++) if (s[j]<='9') x=x*b+s[j]-'0'; else x=x*b+s[j]-'A'+10;       if (r>0 && x>=r) break;       en=m=0;       for (j=2; j<b && j*j<=x; j++) if (x%j==0) {         a[++m]=j; c[m]=1; x/=j;         while (x%j==0) { c[m]++; x/=j; }       }       if (x>1) {         if (x>=b) continue;         a[++m]=x; c[m]=1;       }       rec(1,1); sort(e,e+en);       for (i=1; i<en; i++) {         f[i].clear();         for (j=i-1; j>=0 && e[i]/e[j]<b; j--) if (e[i]%e[j]==0) {           d=f[j];           if (j>0 && d.size()==0) continue;           d.push_back(int(e[i]/e[j]));           if (f[i].size()>0 && d.size()>f[i].size()) continue;           sort(d.begin(),d.end());           if (f[i].size()==0 || d.size()<f[i].size() || (d.size()==f[i].size() && d<f[i])) f[i]=d;         }       }       d=f[en-1];       if (d[0]!='-') {         for (x=j=0; j<d.size(); j++) x=x*b+d[j];         if (r==-1 || x<r) r=x;       }     }     printf("%lld\n",r);   }   return 0; } 
#include <set> #include <cstdio> #include <algorithm> using namespace std;   #define n	200005 #define m	30000005 #define P	1000000007 #define For(i,a,b)	for(register int i=a;i<=b;i++)   int		N,Q,T,TYPE,A[n],AF[n]; struct	Opt{int k,l,r;}O[n];   namespace	Work{ 		int 	Rt,B[n],F[n],siz[n],tot[n],ch[n][2];   		void	Up(int x)	{ 			siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+B[x]; 			tot[x]=tot[ch[x][0]]+tot[ch[x][1]]+1; 		} 		void	Rot(int x)	{ 			int y=F[x],z=F[y],k=ch[y][0]==x,t; 			if	(t=ch[y][!k]=ch[x][k])	F[t]=y; 			if	(F[x]=z)	ch[z][ch[z][1]==y]=x; 			F[ch[x][k]=y]=x;Up(y); 		} 		void	Splay(int x,int Aim=0){ 			for (;F[x]!=Aim;Rot(x)){ 				int y=F[x],z=F[y]; 				if	(z!=Aim)	(ch[y][0]==x^ch[z][0]==y)?Rot(x):Rot(y); 			}	Up(x);	if	(!Aim)	Rt=x; 		}   		int		Find(int x,int k){ 			int t=siz[ch[x][0]]+B[x]; 			if	(t==k&&B[x])	return	x; 			if	(k<=t)	return	Find(ch[x][0],k); 				else	return	Find(ch[x][1],k-t); 		} 		void	Build(int&u,int l,int r,int f){ 			F[u=l+r>>1]=f; 			if	(l<u)	Build(ch[u][0],l,u-1,u); 			if	(u<r)	Build(ch[u][1],u+1,r,u);	Up(u); 		}   		void	Main(){ 			For(i,1,N+2)	B[i]=1; 			Build(Rt,1,N+2,0);T=N+2; 			For(i,1,Q)	{ 				if	(O[i].k==1||O[i].k==5){ 					O[i].l=Find(Rt,O[i].l+1); 					O[i].r=Find(Rt,O[i].r+1); 				}	else 				if	(O[i].k==2||O[i].k==3){ 					O[i].l=Find(Rt,O[i].l+1); 					if	(O[i].k==3)	B[O[i].l]=0,Splay(O[i].l); 				}	else	{ 					int x=Find(Rt,O[i].l+1),y;	Splay(x); 					for (y=ch[x][1];ch[y][0];y=ch[y][0]); 					Splay(y,x);	B[ch[y][0]=++T]=1;	F[T]=y;	Splay(T);	O[i].l=T; 				} 			}   			For(i,1,Q)	{ 				Splay(O[i].l),O[i].l=tot[ch[O[i].l][0]]+1; 				if	(O[i].k==1||O[i].k==5) 					Splay(O[i].r),O[i].r=tot[ch[O[i].r][0]]+1; 			} 			For(i,1,N)	Splay(i+1),AF[i]=tot[ch[i+1][0]]+1; 		} };   #define Set	set<int> #define I64	long long   int		D,V[n],B[n],S[n],Rt[n],ls[m],rs[m],sum[m]; Set		Pre[n];   struct	Nod{ 		I64 A[3]; 		Nod	operator +	(const Nod&a){ 			Nod	ret;	For(i,0,2)	ret.A[i]=A[i]+a.A[i]; 			return	ret; 		} }G[m],Num[n];   inline	void	Modify(int&u,int l,int r,int x,const Nod&t){ 		int Mid=l+r>>1;	u=(!u?++D:u); 		if	(l==r)	{G[u]=t;sum[u]=!!t.A[0];return;} 		if	(x<=Mid)Modify(ls[u],l,Mid,x,t); 			else	Modify(rs[u],Mid+1,r,x,t); 		G[u]=G[ls[u]]+G[rs[u]];	sum[u]=sum[ls[u]]+sum[rs[u]]; } inline	void	Modify1(int&u,int l,int r,int x,int t){ 		int Mid=l+r>>1;	u=(!u?++D:u); 		if	(l==r)	{sum[u]=t;return;} 		if	(x<=Mid)Modify1(ls[u],l,Mid,x,t); 			else	Modify1(rs[u],Mid+1,r,x,t); 		sum[u]=sum[ls[u]]+sum[rs[u]]; }  inline	Nod		Query(int u,int l,int r,int x,int y){ 		if	(!u||x<=l&&r<=y)	return	G[u];	int Mid=l+r>>1; 		if	(y<=Mid)	return	Query(ls[u],l,Mid,x,y); 		if	(x>Mid)		return	Query(rs[u],Mid+1,r,x,y); 		return	Query(ls[u],l,Mid,x,y)+Query(rs[u],Mid+1,r,x,y); } inline	int		Query1(int u,int l,int r,int x,int y){ 		if	(!sum[u]||x<=l&&r<=y)	return	sum[u];	int Mid=l+r>>1; 		if	(y<=Mid)	return	Query1(ls[u],l,Mid,x,y); 		if	(x>Mid)		return	Query1(rs[u],Mid+1,r,x,y); 		return	Query1(ls[u],l,Mid,x,y)+Query1(rs[u],Mid+1,r,x,y); }   inline	void	Add(int x,int y,const Nod&t){ 		for (x++;x<=T;x+=x&-x)	if	(V[x])	 			if	(TYPE)	Modify(Rt[x],1,T,y,t);	else	Modify1(Rt[x],1,T,y,!!t.A[0]); } inline	void	Ask_(int x){ 		for (x++;x;x-=x&-x)	V[x]=1; } inline	Nod		Ask(int x,int l,int r){ 		Nod	ret=Nod(); 		for (x++;x;x-=x&-x)	ret=ret+Query(Rt[x],1,T,l,r); 		return	ret; } inline	int		Ask1(int x,int l,int r){ 		int ret=0; 		for (x++;x;x-=x&-x)	ret=ret+Query1(Rt[x],1,T,l,r); 		return	ret; }   inline	void	INS(int x,int k){ 		S[x]=k;	Pre[k].insert(x); 		Set::iterator l=Pre[k].lower_bound(x),r=l;	int t; 		(l!=Pre[k].begin())?t=*(--l):t=0;	Add(t,x,Num[k]); 		if	((++r)!=Pre[k].end())	Add(t,*r,Num[0]),Add(x,*r,Num[S[*r]]); } inline	void	DEL(int x){ 		int k=S[x]; 		Set::iterator l=Pre[k].lower_bound(x),r=l;	int t; 		(l!=Pre[k].begin())?t=*(--l):t=0;	Add(t,x,Num[0]); 		if	((++r)!=Pre[k].end())	Add(x,*r,Num[0]),Add(t,*r,Num[S[*r]]); 		S[x]=0;	Pre[k].erase(x); }     #define CH	(ch=getchar()) inline	int		IN(){ 		int x=0,ch; 		for	(;CH<'0'||ch>'9';); 		for	(;ch>='0'&&ch<='9';CH)	(x*=10)+=ch-'0'; 		return	x; } inline	int		Pow(int a,int b){ 		int ret=1; 		for (;b;b>>=1,a=1ll*a*a%P) 			if	(b&1)	ret=1ll*ret*a%P; 		return	ret; }   int		main(){ 		N=IN();	Q=IN(); 		For(i,1,N)	A[i]=IN(); 		For(i,1,Q)	{ 			O[i].k=IN();	O[i].l=IN(); 			if	(O[i].k!=3)	O[i].r=IN();	TYPE|=O[i].k==1; 		} 		Work::Main();   		For(i,1,N)	B[++*B]=A[i]; 		For(i,1,Q)	if	(O[i].k==2||O[i].k==4)	B[++*B]=O[i].r; 		sort(B+1,B+*B+1);	*B=unique(B+1,B+*B+1)-B-1; 		For(i,1,*B)	{ 			Num[i].A[0]=B[i]; 			For(j,1,2)	Num[i].A[j]=1ll*Num[i].A[j-1]*B[i]%P; 		}   		For(i,1,N)	A[i]=lower_bound(B+1,B+*B+1,A[i])-B; 		For(i,1,Q)	if	(O[i].k==2||O[i].k==4)	O[i].r=lower_bound(B+1,B+*B+1,O[i].r)-B; 		For(i,1,Q)	if	(O[i].k==1||O[i].k==5)	Ask_(O[i].l-1);   		For(i,1,N)	INS(AF[i],A[i]);	int rev=Pow(6,P-2); 		For(i,1,Q)	{ 			if	(O[i].k==1||O[i].k==5)	{ 				if	(O[i].k==5)	printf("%d\n",Ask1(O[i].l-1,O[i].l,O[i].r)); 				else	{ 					Nod	t=Ask(O[i].l-1,O[i].l,O[i].r);	For(i,0,2)	t.A[i]%=P; 					int Ans=(1ll*t.A[0]*t.A[0]%P*t.A[0]-3ll*t.A[1]*t.A[0]+2*t.A[2])%P; 					printf("%d\n",(1ll*Ans*rev%P+P)%P); 				} 			}	else 			if	(O[i].k==3)	DEL(O[i].l);	else 			if	(O[i].k==4)	INS(O[i].l,O[i].r); 				else	DEL(O[i].l),INS(O[i].l,O[i].r); 		} } 
#include <bits/stdc++.h> #define pb push_back #define mp make_pair #define fi first #define se second #define esp 1e-9 #define N 100100 #define vi vector<int> #define pp pair<int, int> #define mod 1000000007 #define BASE 555 #define mk 1562 typedef long long ll; typedef long long ull; typedef long double ld; using namespace std; int n, q, x, m; pp a[N]; int val[N]; int th[N]; struct seg {     ull mark[mk]; }; struct cut {     int L, R; };  seg c[200]; cut cc[200];  ull dp[mk]; ull f[200][200][1600];  int countBit(ull x) {     return __builtin_popcountll(x); }  int addNew(ull x, ull y) {     int cn = 0;     for (int j = 0; j < 64; j++)         if (!((x >> j) & 1) && ((y >> j) & 1))             cn++;     return cn; }  int query(int L, int R, int K) {    // cout << L << " " << R << " " << K << "\n";     memset(dp, 0, sizeof(dp));      if (L / BASE ==  R / BASE) {         for (int i = L; i <= R; i++) {             int block = (val[i] / 64);             int vt = val[i] % 64;             dp[block] |= (1ull << vt);         }     }     else {         /// O(N / 64)         //int totalStep = 0;          int l = L / BASE + 1;         int r = R / BASE - 1;         if (l <= r)             for (int i = 0; i < mk; i++) {                 dp[i] |= f[l][r][i];               //  totalStep++;             }          /// sqrt(N)         for (int i = L; i <= cc[L / BASE].R; i++) {             int block = (val[i] / 64);             int vt = val[i] % 64;             dp[block] |= (1ull << vt);         // totalStep++;         }          for (int i = cc[R / BASE].L; i <= R; i++) {             int block = (val[i] / 64);             int vt = val[i] % 64;             dp[block] |= (1ull << vt);         //    totalStep++;         }     }      /// query O(N / 64)     int block = -1;     int cntbit = 0;     for (int i = 0; i < mk; i++) {         cntbit += countBit(dp[i]);         if (cntbit >= K) {             cntbit -= countBit(dp[i]);             block = i;             break;         }     }       if (block == -1) return -1;     int vt = K - cntbit;       int tot = 0;     for (int j = 0; j < 64; j++) {         if ((dp[block] >> j) & 1) tot++;         if (tot == vt) {             return th[64 * block + j];         }     }     /**/ }  int main() {    //freopen("in.in", "r", stdin);    //freopen("ou.ou", "w", stdout);      scanf("%d%d", &n, &q);     for (int i = 0; i < n; i++) {         scanf("%d", &x);         a[i] = mp(x, i);     }     sort(a, a + n);     a[n].fi = -1;     int cnt = 0;     for (int i = 0; i < n; i++) {         val[a[i].se] = cnt;         if (a[i].fi != a[i + 1].fi) {             th[cnt] = a[i].fi;             cnt++;         }     }      int m = 0;     for (int i = 0; i < n; i += BASE) {         cc[i / BASE].L = i;         cc[i / BASE].R = min(n - 1, i + BASE - 1);         m++;     }      for (int i = 0; i < n; i++) {         int block = (val[i] / 64);         int vt = val[i] % 64;         c[i / BASE].mark[block] |= (1ull << vt);     }      /// pre-compute      for (int i = 0; i < m; i++) {         for (int k = 0; k < mk; k++)             f[i][i][k] = c[i].mark[k];          for (int j = i + 1; j < m; j++) {             for (int k = 0; k < mk; k++)                 f[i][j][k] = (f[i][j - 1][k] | c[j].mark[k]);         }     }       int ass = 0;     int A, B, C, D, K;     //int L, R;     for (int i = 1; i <= q; i++) {         scanf("%d%d%d%d%d", &A, &B, &C, &D, &K);         int L = ((ll)A * max(ass, 0) + B) % n;         int R = ((ll)C * max(ass, 0) + D) % n;         //scanf("%d%d%d", &L, &R, &K);         //L--;         //R--;         if (L > R)             swap(L, R);         ass = query(L, R, K);        // printf("%d %d %d\n", L, R, K);         printf("%d\n", ass);     }      /**/return 0; } 
#include <algorithm> #include <cassert> #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <vector> using namespace std;   #define FORALL(s,i) for (typeof(s.begin()) i=s.begin(); i != s.end(); ++i) long long Gcd(long long a, long long b) {return b ? Gcd(b, a%b) : a;} inline long long Lcm(long long a, long long b) {return a / Gcd(a, b) * b;}   #define MAXFACTSET 1300 #define POW2 32 #define POW3 27 #define POW5 25 #define POW7 7 #define NUMP 15   const int p[NUMP] = {59, 53, 47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 49, 1};   int nfactset; map<vector<int>, int> fact2factset; vector<int> factset[MAXFACTSET+1];   int get_factset(vector<int> v) {   for (int i = 0; i < v.size(); i++)   for (int j = i+1; j < v.size(); j++)     if (v[j] % v[i] == 0) v.erase(v.begin() + j--);   int& ret = fact2factset[v];   if (ret == 0) {     assert(nfactset < MAXFACTSET);     factset[ret = ++nfactset].swap(v);   }   return ret; }   int and_factset_memo[MAXFACTSET+1][MAXFACTSET+1]; int and_factset(int fs1, int fs2) {   int& ret = and_factset_memo[fs1][fs2];   if (ret) return ret;   vector<int> v;   for (int p2 = 1; p2 <= POW2; p2 *= 2)   for (int p3 = 1; p3 <= POW3; p3 *= 3)   for (int p5 = 1; p5 <= POW5; p5 *= 5)   for (int p7 = 1; p7 <= POW7; p7 *= 7) {     int n = p2*p3*p5*p7, i;     for (i = 0; i < factset[fs1].size(); i++)       if (n % factset[fs1][i] == 0) break;     if (i == factset[fs1].size()) continue;     for (i = 0; i < factset[fs2].size(); i++)       if (n % factset[fs2][i] == 0) break;     if (i == factset[fs2].size()) continue;     v.push_back(n);   }   sort(v.begin(), v.end());   return ret = get_factset(v); }   int or5_factset_memo[MAXFACTSET+1]; int or5_factset(int fs) {   int& ret = or5_factset_memo[fs];   if (ret) return ret;   vector<int> v = factset[fs];   for (int i = 0; i < v.size(); i++) if (v[i]%5 == 0) v[i] /= 5;   sort(v.begin(), v.end());   return ret = get_factset(v); }   int or7_factset_memo[MAXFACTSET+1]; int or7_factset(int fs) {   int& ret = or7_factset_memo[fs];   if (ret) return ret;   vector<int> v = factset[fs];   for (int i = 0; i < v.size(); i++) if (v[i]%7 == 0) v[i] /= 7;   sort(v.begin(), v.end());   return ret = get_factset(v); }   int* prefs[MAXFACTSET+1]; long long count(int fs, long long lim) {   int* pre = prefs[fs];   int sz;   if (pre) {     sz = *pre++;   } else {     sz = 1;     for (int i = 0; i < factset[fs].size(); i++) {       sz = Lcm(sz, factset[fs][i]);     }     pre = prefs[fs] = new int[sz+1];     memset(pre, 0, (sz+1)*sizeof(int));     *pre++ = sz;     for (int i = 0; i < factset[fs].size(); i++) {       int x = factset[fs][i];       for (int y = 0; y < sz; y += x) pre[y] = 1;     }     for (int x = 1; x < sz; x++) pre[x] += pre[x-1];   }   return pre[sz-1] * (lim/sz) + pre[lim%sz] - 1; }   int T, X; long long B, ret; vector<pair<long long, pair<long long, int> > > limit; int curfs[1<<NUMP]; int lastlimi[1<<NUMP]; struct CacheItem {   int fs;   int co : 10;   int limi : 10;   int lastlimi : 10;   long long mul;   bool operator<(const CacheItem& ci) const {     if (fs != ci.fs) return fs < ci.fs;     return mul < ci.mul;   } }; vector<CacheItem> cache[61];   void change(int pi, int pb, int co, long long mul, int limi, int fs) {   if (mul % 7 == 0) fs = or7_factset(fs);   if (curfs[pb] == fs) return;   CacheItem ci;   ci.co = co; ci.fs = curfs[pb]; ci.limi = limi; ci.lastlimi = lastlimi[pb];   ci.mul = mul;   cache[X].push_back(ci);   long long lim = limit[limi].second.first;   long long lastlim = limit[lastlimi[pb]].second.first;   if (mul <= lim && lastlim < lim)    {     assert(curfs[pb] != 0);     ret += co * (count(curfs[pb], lim / mul) - count(curfs[pb], lastlim / mul));   }   curfs[pb] = fs;   lastlimi[pb] = limi;    for (; pi < NUMP; pi++) {     int pb2 = pb | (1<<pi);     if (pb2 == pb || !curfs[pb2]) continue;     long long mul2 = mul * p[pi];     if ((p[pi] == 7 || p[pi] == 49) && mul % 7 == 0) mul2 /= 7;     if (mul2 > 1000000000000LL) continue;     int fs2 = and_factset(fs, curfs[1<<pi]);     change(pi+1, pb|(1<<pi), -co, mul2, limi, fs2);   } } main() {   nfactset = 1;   factset[1].push_back(1);   fact2factset[factset[1]] = 1;     vector<int> v;   v.push_back(10);   v.push_back(3);     for (cin >> T; T--;) {     cin >> B >> X;      limit.clear();     for (int x = 1, y; x < X; x++) {       for (y = x+1; X%y; y++)         ;       limit.push_back(make_pair(1000000000000LL*x/y, make_pair(B*x/y, x)));     }     limit.push_back(make_pair(0LL, make_pair(0, -1)));     sort(limit.begin(), limit.end());       ret = 0;     if (cache[X].size()) {       for (int i = 0; i < cache[X].size(); i++) {         const CacheItem& ci = cache[X][i];         long long lim = limit[ci.limi].second.first;         long long lastlim = limit[ci.lastlimi].second.first;         if (ci.mul <= lim && lastlim < lim) {           ret += ci.co * (count(ci.fs, lim / ci.mul) -                           count(ci.fs, lastlim / ci.mul));         }       }     } else {       vector<int> valid(X, 1);       memset(curfs, 0, sizeof(curfs));       memset(lastlimi, 0, sizeof(lastlimi));       int pb = 0;       for (int pi = 0; pi < NUMP; pi++) if (p[pi] < X) pb |= (1<<pi);       for (int i = 0; i < (1<<NUMP); i++) curfs[i&pb] = 1;       for (int i = 1; i < limit.size(); i++) {         valid[limit[i].second.second] = 0;         int pi;         for (pi = 0; limit[i].second.second % p[pi] != 0; pi++);         vector<int> v;         for (int p2 = 1; p2 <= POW2; p2 *= 2)         for (int p3 = 1; p3 <= POW3; p3 *= 3)         for (int p5 = 1; p5 <= POW5; p5 *= 5)         for (int p7 = 1; p7 <= POW7; p7 *= 7) {           int n = p[pi]*p2*p3*p5*p7;           if (n < X && valid[n]) v.push_back(p2*p3*p5*p7);         }         sort(v.begin(), v.end());           change(0, 1<<pi, 1, p[pi], i, get_factset(v));       }       sort(cache[X].begin(), cache[X].end());     }     cout << ret << endl;   } }
#include<cmath> #include<cstdio> #include<vector>   #define	pb			push_back #define	rep(i,n)	for(int i=0;i<n;i++)   using namespace std;   typedef	vector<int>			vi; typedef	unsigned long long	ull;   /* Xorshift RNG by George Marsaglia */ ull xor64(){ 	static ull x=88172645463325252LL; 	x^=(x<<13); 	x^=(x>>7); 	return x^=(x<<17); }   ull modmul(ull a,ull b,ull m){	// a*b (mod m) 	ull r=0; 	for(;b;b>>=1,a=(a<<1)%m) if(b&1) r=(r+a)%m; 	return r; }   ull modpow(ull a,ull n,ull m){	// a^n (mod m) 	ull r=1; 	for(ull x=a;n;n>>=1,x=modmul(x,x,m)) if(n&1) r=modmul(r,x,m); 	return r; }   bool MillerRabin(ull n,int k=30){ 	if(n<=1)	return false; 	if(!(n&1))	return n==2; 	if(n%3==0)	return n==3;   	int s=0;	// n-1 = 2^s * d (d: odd) 	ull d=n-1; 	while(!(d&1))	s++,d>>=1;   	while(k--){ 		ull a=xor64()%(n-3)+2; 		ull x=modpow(a,d,n); 		if(x==1 || x==n-1)	continue; 		bool b=false; 		for(int r=1;r<s;r++){ 			x=modmul(x,x,n); 			if(x==1)	return false; 			if(x==n-1){ b=true; break; } 		} 		if(!b)	return false; 	}   	return true; }   ull fact[30];   int main(){ 	fact[0]=fact[1]=1; 	for(int i=2;i<30;i++)	fact[i]=i*fact[i-1];   	const int Ne=1001000; 	static bool er[Ne]; er[0]=er[1]=true; 	for(int i=2;i*i<Ne;i++) if(!er[i]) for(int j=i*i;j<Ne;j+=i) er[j]=true;   	vi p; rep(i,Ne) if(!er[i]) p.pb(i);   	int T;	scanf("%d",&T); 	while(T--){ 		ull n;	scanf("%llu",&n);   		if(n==4){ puts("1"); continue; }   		int cnt=0; 		bool b=false; 		for(int i=0;(ull)p[i]*p[i]*p[i]<=n;i++){ 			if(n%p[i]==0){ 				n/=p[i],cnt++; 				if(n%p[i]==0){ puts("-1"); b=true; break; } 			} 		} 		if(b)	continue;   		// first case ( n=1 ) 		if(n==1){ printf("%llu\n",fact[cnt]); continue; }   		// second case ( n=p (p: prime) ) 		if(MillerRabin(n)){ printf("%llu\n",fact[cnt+1]); continue; }   		// third case ( n=p^2 (p: prime) ) 		ull rtn=(ull)(sqrt((double)n)+0.5); 		if((rtn-1)*(rtn-1)==n ||  rtn*rtn==n || (rtn+1)*(rtn+1)==n){ 			puts("-1"); continue; 		}   		// fourth case ( n=p*q (p,q: prime) ) 		printf("%llu\n",fact[cnt+2]); 	}   	return 0; }
#include<cstdio>  using namespace std;  int nr, T, N, mod, ans[80]; int a[] = {0, 272,589185,930336768,853401154,217676188,136558333,415722813,985269529,791527976,201836136,382110354,441223705,661537677,641601343,897033284,816519670,365311407,300643484,936803543,681929467,462484986,13900203,657627114,96637209,577140657,600647073,254604056,102389682,811580173,592550067,587171680,526467503,265885773,951722780,219627841,371508152,283501391,159234514,439380999,722868959,125599834,351398134,456317548,365496182,614778702,502680047,193063685,309004764,743901785,870955115,312807829,160375015,691844624,137034372,350330868,895680450,282610535,317897557,28600551,583305647,539409363,327406961,627805385,680183978,681299085,954964592,743524009,788048339,699454626,666369521,857206425}; int coef[] = {0, 1,999998256,116405,85452673,554115042,156014244,348050269,827145587,499362222,235020451,945246280,487523377,181812482,999805738,781667749,156019930,487004069,165048565,223916257,568547436,266083964,165436872,706679916,38928432,777681484,775353772,209550973,934884057,649159321,726116404,38175356,256245988,152683562,899906518,82346955,244730388,755269619,917653052,100093489,847316445,743754019,961824651,273883603,350840686,65115950,790449034,224646235,222318523,961071575,293320091,834563135,733916043,431452571,776083750,834951442,512995938,843980077,218332258,194269,818187525,512476630,54753727,764979556,500637785,172854420,651949738,843985763,445884965,914547334,999883602,1751};  struct matrix {     int a[74][74];     matrix () {}     matrix (bool type)     {         for (int i=1; i<=nr; i++)             for (int j=1; j<=nr; j++)                 a[i][j] = (i == j && type);     } }recurenta (0), curr_ans (0), put[30];  matrix operator * (matrix a, matrix b) {     matrix ans (0);     for (int i=1; i<=nr; i++)         for (int j=1; j<=nr; j++)         {             ans.a[i][j] = 0;             for (int k=1; k<=nr; k++)                 ans.a[i][j] = ((long long) ans.a[i][j] + 1LL * a.a[i][k] * b.a[k][j]) % mod;         }     return ans; }  void multiply (int v[], int p) {     int aux[80];     for (int i=1; i<=71; i++)         aux[i] = v[i];     for (int j=1; j<=71; j++)     {         v[j] = 0;         for (int i=1; i<=71; i++)             v[j] = ((long long) v[j] + 1LL * aux[i] * put[p].a[i][j]) % mod;     } }  void pow (int N) {     for (int i=1; i<=71; i++)         ans[i] = a[i];     for (int i=0; (1<<i) <= N; i++)         if (N & (1 << i)) multiply (ans, i); }  int main () { //freopen ("input", "r", stdin); //freopen ("output", "w", stdout);  ///a(i-70) a(i - 69) ... a(i) = (a(i - 71), a(i - 70), ..., a(i)) * MAT nr = 71, mod = 1e9 + 7; for (int j=1; j<=70; j++)     recurenta.a[j + 1][j] = 1; for (int i=1; i<=71; i++)     recurenta.a[i][71] = coef[i]; put[0] = recurenta; for (int i=1; i<=29; i++)     put[i] = put[i - 1] * put[i - 1]; scanf ("%d", &T); while (T --) {     scanf ("%d", &N);     if (N <= 71)     {         printf ("%d\n", a[N]);         continue;     }     pow (N - 71);     printf ("%d\n", ans[71]); }  return 0; } 
#include <stdio.h> #include <stdlib.h> #include <algorithm> using namespace std;  int T,n,m,cuts,colors,i,j,k; char s[505][505]; bool flag;  char get(char a,char b) { 	if('a'!=a&&'a'!=b)return 'a'; 	if('b'!=a&&'b'!=b)return 'b'; 	return 'c'; }  int main() { 	scanf("%d",&T); 	for(;T;--T) 	{ 		scanf("%d%d",&n,&m); 		if(n&m&1)printf("IMPOSSIBLE\n"); 		else 		{ 			if(n>m)swap(n,m),flag=true; 			else flag=false; 			 			for(i=0;i<=n+1;++i) 			for(j=0;j<=m+1;++j) 			s[i][j]=0; 			 			if(n==1) 			{ 				cuts=m/2-1; 				colors=1+(m>2); 				for(i=1,k=1;i<=m;++i) 				{ 					if(i&1)k^=1; 					s[1][i]='a'+k; 				} 			}else 			if(n==2) 			{ 				cuts=m/2; 				colors=2+(m&1); 				if(m&1) 				{ 					s[1][1]=s[2][1]='c'; 					for(i=2,k=0;i<=m;++i) 					{ 						s[1][i]='a'+k; 						s[2][i]='a'+(k^1); 						if(i&1)k^=1; 					} 				} 				else 				{ 					for(i=1,k=1;i<=m;++i) 					{ 						if(i&1)k^=1; 						s[1][i]='a'+k; 						s[2][i]='a'+(k^1); 					} 				} 			}else 			if(n==3) 			{ 				if(m==4) 				{ 					cuts=1; 					colors=3; 					s[1][1]='a';s[1][2]='a';s[1][3]='b';s[1][4]='c'; 					s[2][1]='b';s[2][2]='c';s[2][3]='b';s[2][4]='c'; 					s[3][1]='b';s[3][2]='c';s[3][3]='a';s[3][4]='a'; 				} 				else 				{ 					cuts=1; 					colors=3; 					s[1][1]=s[1][2]='a'; 					s[2][1]=s[3][1]='b'; 					for(j=2;j<m;++j) 					{ 						if(!s[1][j])s[1][j]=s[1][j+1]=get(s[1][j-1],s[2][j]); 						if(!s[2][j])s[2][j]=s[2][j+1]=get(s[1][j],s[2][j-1]); 						if(!s[3][j])s[3][j]=s[3][j+1]=get(s[2][j],s[3][j-1]); 					} 					s[2][m]=s[3][m]=get(s[2][m-1],s[3][m-1]); 					if(s[2][m]==s[1][m]) 					{ 						s[3][m-1]=s[3][m-2]=s[2][m]; 						s[2][m]=s[3][m]=get(s[2][m-1],s[3][m-1]); 					} 				} 			}else 			if(n==4) 			{ 				if(m&1) 				{ 					cuts=1; 					colors=3; 					s[1][1]=s[2][1]='a'; 					s[3][1]=s[3][2]='b'; 					s[4][1]=s[4][2]='c'; 					for(j=2;j<m;++j)  					{ 						if(!s[2][j])s[2][j]=s[2][j+1]=get(s[2][j-1],s[3][j]); 						if(!s[1][j])s[1][j]=s[1][j+1]=get(s[1][j-1],s[2][j]); 						if(!s[3][j])s[3][j]=s[3][j+1]=get(s[2][j],s[3][j-1]); 						if(!s[4][j])s[4][j]=s[4][j+1]=get(s[3][j],s[4][j-1]); 					} 					s[3][m]=s[4][m]=get(s[3][m-1],s[4][m-1]); 				} 				else 				{ 					if(m==4) 					{ 						cuts=2; 						colors=3; 						s[1][1]='a';s[1][2]='a';s[1][3]='b';s[1][4]='a'; 						s[2][1]='c';s[2][2]='c';s[2][3]='b';s[2][4]='a'; 						s[3][1]='a';s[3][2]='b';s[3][3]='c';s[3][4]='c'; 						s[4][1]='a';s[4][2]='b';s[4][3]='a';s[4][4]='a'; 					} 					else 					{ 						cuts=2; 						colors=3; 						s[1][1]=s[1][2]='a'; 						s[2][1]=s[2][2]='b'; 						s[3][1]=s[4][1]='c'; 						for(j=2;j<m;++j)  						{ 							if(!s[2][j])s[2][j]=s[2][j+1]=get(s[2][j-1],s[3][j]); 							if(!s[1][j])s[1][j]=s[1][j+1]=get(s[1][j-1],s[2][j]); 							if(!s[3][j])s[3][j]=s[3][j+1]=get(s[2][j],s[3][j-1]); 							if(!s[4][j])s[4][j]=s[4][j+1]=get(s[3][j],s[4][j-1]); 						} 						s[3][m]=s[4][m]=get(s[3][m-1],s[4][m-1]); 					} 				} 			} 			else 			{ 				if(m&1) 				{ 					swap(n,m); 					flag^=1; 					for(i=0;i<=n+1;++i) 					for(j=0;j<=m+1;++j) 					s[i][j]=0; 				} 				if(n&1) 				{ 					cuts=0; 					colors=3; 					s[1][1]='a';s[1][2]='a';s[1][3]='b';s[1][4]='a';s[1][5]='a'; 					s[2][1]='b';s[2][2]='c';s[2][3]='b';s[2][4]='c';s[2][5]='c'; 					s[3][1]='b';s[3][2]='c';s[3][3]='a';s[3][4]='a'; 					for(i=4;i<=n;i+=2) 					{ 						if(i<=6)s[i][1]=s[i+1][1]=s[i][4]=s[i+1][4]=get(s[i-1][1],'a'); 						else s[i][1]=s[i+1][1]=s[i][4]=s[i+1][4]=get(s[i-1][1],s[i-3][1]); 						s[i][2]=s[i][3]=get(s[i][1],s[i-1][3]); 						s[i+1][2]=s[i+1][3]=get(s[i][1],s[i][3]); 					} 					for(j=5;j<=m-2;++j) 					{ 						for(i=3;i<=n;++i) 						if(!s[i][j]) 						{ 							if(s[i-1][j]==s[i][j-1]&&j==m-3)s[i][j]=s[i][j+1]=get(s[i-1][j],s[i-2][j]); 							else s[i][j]=s[i][j+1]=get(s[i-1][j],s[i][j-1]); 						} 						if(!s[2][j])s[2][j]=s[2][j+1]=get(s[2][j-1],s[3][j]); 						if(!s[1][j])s[1][j]=s[1][j+1]=get(s[1][j-1],s[2][j]); 					} 					s[1][m]=s[2][m]=get(s[1][m-1],s[2][m-1]); 					for(i=3;i<n;i+=2) 					{ 						s[i][m-1]=s[i+1][m-1]=get(s[i][m-2],s[i+1][m-2]); 						s[i][m]=s[i+1][m]=get(s[i][m-1],s[i-1][m]); 					} 					s[n][m-1]=s[n][m]=get(s[n-1][m-1],s[n-1][m]); 					if(s[n][m-1]==s[n][m-2]) 					{ 						s[n][m-1]=s[n][m]=get(s[n][m-2],s[n-1][m-1]); 						for(i=n-1;i>=4;i-=2) 						if(s[i][m]==s[i+1][m])s[i][m]=s[i-1][m]=get(s[i][m-1],s[i+1][m]); 						else break; 					} 				} 				else 				{ 					if(n==6&&m==6) 					{ 						cuts=1; 						colors=3; 						s[1][1]='a';s[1][2]='a';s[1][3]='c';s[1][4]='a';s[1][5]='a';s[1][6]='c'; 						s[2][1]='b';s[2][2]='b';s[2][3]='c';s[2][4]='b';s[2][5]='b';s[2][6]='c'; 						s[3][1]='c';s[3][2]='a';s[3][3]='a';s[3][4]='c';s[3][5]='a';s[3][6]='a'; 						s[4][1]='c';s[4][2]='b';s[4][3]='b';s[4][4]='c';s[4][5]='b';s[4][6]='c'; 						s[5][1]='a';s[5][2]='c';s[5][3]='a';s[5][4]='a';s[5][5]='b';s[5][6]='c'; 						s[6][1]='a';s[6][2]='c';s[6][3]='b';s[6][4]='b';s[6][5]='a';s[6][6]='a'; 					} 					else 					{ 						cuts=0; 						colors=3; 						s[1][1]='a';s[1][2]='a';s[1][3]='c';s[1][4]='c'; 						s[2][1]='b';s[2][2]='c';s[2][3]='a';s[2][4]='a'; 						s[3][1]='b';s[3][2]='c';s[3][3]='b';s[3][4]='c';s[3][5]='c'; 						s[4][1]='a';s[4][2]='a';s[4][3]='b';s[4][4]='a';s[4][5]='a'; 						for(i=5;i<=n;i+=2) 						{ 							s[i][1]=s[i+1][1]=s[i][4]=s[i+1][4]=get(s[i-1][1],s[i-1][1]); 							s[i][2]=s[i][3]=get(s[i][1],s[i-1][2]); 							s[i+1][2]=s[i+1][3]=get(s[i][1],s[i][3]); 						} 						for(j=1;j<=m-3;++j) 						{ 							for(i=5;i<=n;++i) 							if(!s[i][j]) 							{ 								if(s[i-1][j]==s[i][j-1]&&j==m-3) 								{ 									if(i!=6)s[i][j]=s[i][j+1]=get(s[i-1][j],s[i-2][j]); 									else s[i][j]=s[i][j+1]=s[i-2][j]; 								} 								else s[i][j]=s[i][j+1]=get(s[i-1][j],s[i][j-1]); 							} 							if(!s[4][j])s[4][j]=s[4][j+1]=get(s[4][j-1],s[5][j]); 							if(!s[3][j])s[3][j]=s[3][j+1]=get(s[3][j-1],s[4][j]); 							if(j!=m-3) 							{ 								if(!s[2][j])s[2][j]=s[2][j+1]=get(s[2][j-1],s[3][j]); 								if(!s[1][j])s[1][j]=s[1][j+1]=get(s[1][j-1],s[2][j]); 							} 						} 						s[1][m-3]=s[2][m-3]=get(s[1][m-4],s[2][m-4]); 						s[3][m-2]=s[4][m-2]=get(s[3][m-3],s[4][m-3]); 						s[2][m-2]=s[2][m-1]=get(s[3][m-2],s[5][m-2]); 						s[1][m-2]=s[1][m-1]=get(s[1][m-3],s[2][m-2]); 						s[1][m]=s[2][m]=get(s[1][m-1],s[2][m-2]); 						s[3][m-1]=s[3][m]=get(s[2][m],s[2][m-1]); 						for(i=4;i<n;i+=2) 						{ 							s[i][m-1]=s[i+1][m-1]=get(s[i][m-2],s[i+1][m-2]); 							s[i][m]=s[i+1][m]=get(s[i][m-1],s[i-1][m]); 						} 						s[n][m-1]=s[n][m]=get(s[n-1][m-1],s[n-1][m]); 					} 				} 			} 			 			printf("%d %d\n",cuts,colors); 			if(flag) 			{ 				swap(n,m); 				for(i=1;i<=n;++i) 				{ 					for(j=1;j<=m;++j)putchar(s[j][i]); 					printf("\n"); 				} 				swap(n,m); 			} 			else 			{ 				for(i=1;i<=n;++i) 				{ 					for(j=1;j<=m;++j)putchar(s[i][j]); 					printf("\n"); 				} 			} 		} 	} }
 /* Author :: Yash */  #include <vector>  #include <list>  #include <cassert>  #include <sstream>  #include <map>  #include <set>  #include <climits>  #include <deque>  #include <fstream>  #include <stack>  #include <bitset>  #include <stack>  #include <queue>  #include <algorithm>  #include <functional>  #include <numeric>  #include <cstring>  #include <utility>  #include <sstream>  #include <iostream>  #include <iomanip>  #include <cstdio>  #include <cmath>  #include <cstdlib>  #include <ctime>  using namespace std;     template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}     #define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i)  #define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)  #define REP(i,n) FOR(i,0,n)  #define DEP(i,n) REV(i,n,0)  #define PB push_back  #define PP pop()  #define EM empty()  #define INF 1000000000  #define PF push_front  #define ALL(x) x.begin(),x.end()  #define SORT(x) sort(ALL(x))  #define V(x) vector< x >  #define Debug false  #define PRINT(x) cout << x << " " << x << endl  #define LET(x,a) __typeof(a) x(a)  #define IFOR(i,a,b) for(LET(i,a);i!=(b);++i)  #define EACH(it,v) IFOR(it,v.begin(),v.end())  #define PRESENT(c,x) ((c).find(x) != (c).end())  #define SZ(x) x.size()  #define CPRESENT(c,x) (find(c.begin(),c.end(),x) != (c).end())  #define D(N) int N  #define S(N) scanf("%d",&N)  //#define FASTIO 1     typedef pair<int,int> PI;  typedef pair<int,PI> TRI;  typedef V( int ) VI;  typedef V( PI ) VII;  typedef V( string ) VS;  typedef long long LL;  typedef long double LD;     /* FastIO, generally required these days ;) */     /*ifndef FASTIO  char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20];  inline int input(int flag=0) {     while(*ipos <= 32) ++ipos;  if ( flag ) return (*ipos++ - '0'); /* For getting Boolean Characters   int x=0, neg = 0;char c;  while( true ) {  c=*ipos++; if(c == '-') neg = 1;  else {  if (c<=32) return neg?-x:x;  x=(x<<1)+(x<<3)+c-'0';  }  }  }  inline void output(int x,int flag) {  int y,dig=0;  while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}  while (dig--) *opos++=DIP[dig];  *opos++= flag ? '\n' : ' ';  }  inline void InitFASTIO() {  ipos = InpFile; opos = OutFile;  fread_unlocked(InpFile,20000000,1,stdin);  }  inline void FlushFASTIO() {  fwrite_unlocked(OutFile,opos-OutFile,1,stdout);  }  endif  */    /* Main Code Starts from here */     const int MAXN = 235;     int T, N, K, low [MAXN], top [MAXN];  bitset<MAXN> value [MAXN][MAXN], flip [MAXN][MAXN];  bool last [2*MAXN], Faulty[MAXN][MAXN];  char str [MAXN];     bitset<MAXN> board[MAXN];     inline bool light (int r, int c) {  return board[r].test(c);  }     int main () {     int kases; scanf("%d",&kases);  while (kases--) {     scanf ("%d%d", &N,&K);  REP(i,N+5) board[i].reset();     for (int i = 0; i < N; i++) {  scanf ("%s", str);  for (int j = 0; j < N; j++) {  if(str[j] - '0') board[i].set(j);  Faulty[i][j] = 0;  }  }  REP(i,K) {  int x,y; scanf("%d%d",&x,&y);  --x; --y;  Faulty[x][y] = 1;  }     REP(i,N+5) REP(j,N+5) {  value[i][j].reset();  flip[i][j].reset();  }     for (int i = 0; i < N; i++)  flip [0][i].set(i);     for (int i = 0; i < N; i++)  {  for (int j = 0; j < N; j++)  {  if (light (i, j))  value [i][j].set(N);     value [i][j] ^= flip [i][j];     if (i > 0)  value [i][j] ^= flip [i - 1][j];     if (j > 0)  value [i][j] ^= flip [i][j - 1];     if (j + 1 < N)  value [i][j] ^= flip [i][j + 1];  }     for (int j = 0; j < N; j++)  flip [i + 1][j] = value [i][j];  }     bitset<MAXN> constant; constant.reset();  REP(i,N) constant.set(i);     vector < bitset<MAXN> > New;  REP(i,N) {  New.PB(flip[N][i] & constant);  last[i] = flip[N][i].test(N);  }     int cnt = 0;     REP(i,N) REP(j,N) if(Faulty[i][j]) {  New.PB(flip[i][j] & constant);  last[N+cnt++] = flip[i][j].test(N);  }     int start = 0; // Gauss Elimination.  for (int i = 0 ; i < N ; ++i ) {     // Check for each bit.  int k = -1;  for (int j = start ; j < New.size(); ++j) {     if(New[j].test(i)) {  k = j;  break;  }  }  if(k == -1) {  // Every one is already ZERO.  continue;  }     swap(New[k], New[start]);  swap(last[k], last[start]);     FOR(j,start+1,New.size()) {  // For each succeeding Equation.  if ( New[j].test(i) ) {  // If the ith bit is not zero. Make it Zero.  New[j] = New[j] ^ New[start];  last[j] = last[j] ^ last[start];  }  }  start += 1;  }     bool solved = true;  REP(i,New.size()) {  if(last[i] && !New[i].count()) solved = false;  }     puts(solved ? "YES" : "NO");  }  return 0;  }  
#include <iomanip> #include <ctime> #include <numeric> #include <functional> #include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstring> #include <climits> #include <cmath> #include <cctype> #include <sstream> #include <map> #include <set> #include <cstdio> #include <queue> #define f(i,x,y) for(int i=x;i<y;i++) #define fd(i,y,x) for(int i=y;i>=x;i--) #define FOR(it,A) for( typeof A.begin() it = A.begin(); it!=A.end(); it++) #define impr(A) for( typeof A.begin() chen = A.begin(); chen !=A.end(); chen++ ) cout<<*chen<<" "; cout<<endl #define ll long long #define vint vector<int> #define clr(A,x) memset(A,x,sizeof(A)) #define CLR(v) f(i,0,n) v[i].clear() #define oo (1<<30) #define ones(x) __builtin_popcount(x) #define all(v) (v).begin(),(v).end() #define rall(v) (v).rbegin(),(v).rend() #define poner push_back #define eps (1e-9) #define cua(x) (x)*(x) using namespace std;  int T; ll n,D; int a[700]; vint v; int vis[700];   int no[1000]; int p[1000]; int sz = 0;  vector<ll> num; int m; ll solve(int pos,ll k){ 	if( pos==m ) return D/k; 	ll res = solve(pos+1,k); 	if( k<=D/num[pos] ) res -= solve( pos+1,k*num[pos] ); 	return res; }  int main() { 	f(i,2,1000)if( no[i]==0 ){ 		for(int j = i*i; j<1000; j+=i ) no[j] = 1; 		p[sz++] = i; 	}  	 	int acu = 0; int idx = 0; 	while( acu+p[idx]<=700 ) acu += p[idx++]; 	//cout <<idx<<endl; //	cout << accumulate(p,p+21,0)<<endl; 	cin >> T; 	while( T-- ){ 		cin >> n >> D; 		f(i,0,n) scanf("%d", a+i ), a[i]--; 		v.clear(); 		clr(vis,0); 		f(i,0,n)if( vis[i]==0 ){ 			int x = 0; 			int I = i; 			while( 1 ){ 				x++; 				I = a[I]; 				vis[I] = 1; 				if( I==i ){ v.poner(x); break; } 			} 		} 		int mask = 0; map<int,int> rep[sz]; 		int pot[sz]; 		f(i,0,sz) pot[i] = oo; 		f(i,0,v.size())f(j,0,sz)if( v[i]%p[j]==0 ) rep[j][v[i]]++; 		f(j,0,sz)FOR(it,rep[j]){ 			int len = it->first; 			int _pot = 1; 			int z = it->second; 			while( z%p[j]==0 ) z/=p[j], _pot++; 			pot[j] = min( pot[j], _pot ); 		} 		num.clear(); 		f(j,0,sz)if( pot[j]!=oo ){ 			ll x = 1; 			f(i,0,pot[j]) x*= p[j]; 			num.poner(x); 		} 		m = num.size(); 		cout << solve(0,1) << endl; 	} } 
#include <cstdio> #include <cstdlib> #include <algorithm> using namespace std;  typedef int cType;  struct Point { 	cType x, y;  	bool operator <(const Point &p) const { 		return x < p.x || (x == p.x && y < p.y); 	} };  cType cross(const Point &O, const Point &A, const Point &B) { 	return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x); }  int convexHull(Point H[], Point P[], int n) { 	int k = 0; 	sort(P, P + n); 	for (int i = 0; i < n; i++) { 		while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--; 		H[k++] = P[i]; 	} 	for (int i = n-2, t = k+1; i >= 0; i--) { 		while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--; 		H[k++] = P[i]; 	} 	return k; }  cType area(const Point &O, const Point &A, const Point &B) { 	cType res = O.x*A.y - O.y*A.x + A.x*B.y - A.y*B.x + B.x*O.y - B.y*O.x; 	return (res < 0)?-res:res; }  cType area(Point H[], int k) { 	int a = 0, b = 1, c = 2, temp; 	int res = area(H[a],H[b],H[c]); 	do 	{ 		do 		{ 			while(area(H[a],H[b],H[c]) < area(H[a],H[b],H[(c+1)%k])) 			{ 				c++; 				c %= k; 			} 			if(area(H[a],H[b],H[c]) < area(H[a],H[(b+1)%k],H[c])) 			{ 				b++; 				b %= k; 				continue; 			} 			else break; 		} while(true); 		temp = area(H[a],H[b],H[c]); 		if(res<= temp)             res = temp; 		//res >?= temp; 		a++; 		a %= k; 		b = (a==b)?b+1:b; 		b %= k; 		c = (b==c)?c+1:c; 		c %= k; 	} while(a); 	return res; }  Point P[1000000]; Point H[2000000];  int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int N; 		scanf("%d",&N); 		for(int i = 0; i < N; i++) 			scanf("%d %d",&P[i].x,&P[i].y); 		if(N <= 2) 		{ 			printf("0\n"); 			continue; 		} 		int k = convexHull(H,P,N); 		if(k <= 2) 		{ 			printf("0\n"); 			continue; 		} 		printf("%d\n",area(H,k-1)); 	} 	return 0; }
#include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstdio> #include <cstdlib> using namespace std; long long ans[31][31][31]; int start[31]; bool used[31]; int lastcircle, lastnon; int N; long long getans(int upto, int right, int left) {     if (ans[upto][right][left]!=-1) return ans[upto][right][left];     if (upto==N) return ans[upto][right][left]=1;     if (used[upto]) return ans[upto][right][left] = getans(upto+1,right,left);          ans[upto][right][left]=0;     if (upto>lastcircle) {         for (int newright = right-1; newright>=0; newright--) {             ans[upto][right][left] += getans(upto+1,newright,left+right-newright-1);         }     }     if (left>0 && upto>lastnon) {         ans[upto][right][left] += getans(upto+1,right,left-1);     }     return ans[upto][right][left]; } int main() {     int T; scanf("%d",&T); while (T--) {         int M; scanf("%d %d",&N,&M);         lastcircle = -1;         lastnon = -1;         for (int i=0; i<N; i++) used[i]=false;         bool noanswers = false;         for (int i=0; i<M; i++) {             scanf("%d",&start[i]);             start[i]--;             used[start[i]]=true;             if (start[i]<i) {                 if (start[i]<lastcircle) noanswers=true;                 lastcircle = start[i];             } else {                 if (start[i]<lastnon) noanswers=true;                 lastnon = start[i];             }         }         for (int i=0; i<lastcircle && i<lastnon; i++) {             if (!used[i]) noanswers=true;         }         if (noanswers) {             printf("0\n");             continue;         }          for (int i=0; i<=N; i++)         for (int j=0; j<=N; j++)         for (int k=0; k<=N; k++) ans[i][j][k]=-1;         printf("%lld\n",getans(0,N-M,0));     } }  
#include <stdio.h>   #define USE_BRUTE_FORCE 0 #define MOD 2003 #define FMAX 1001 #define PMAX 50010   int RaiseToPow(int X, int Y) { 	if (Y == 0) return 1; 	int Z = RaiseToPow(X, Y >> 1); 	Z = ((long long) Z * (long long) Z) % MOD; 	if ((Y & 1) == 1) Z = ((long long) Z * (long long) X) % MOD; 	return Z; }   int Kinvpow[PMAX], number_of_ways[FMAX][FMAX], Kinv;   void ComputeNumberOfWays(int F) { 	int i, j; 	for (i = 1; i <= F; i++) { 		number_of_ways[i][1] = 1; 		for (j = 2; j <= i; j++) 			number_of_ways[i][j] = (number_of_ways[i - 1][j] * j + number_of_ways[i - 1][j - 1]) % MOD; 	} }   int poly[2][PMAX], np[2], c, p;   void RaisePolynomialToPower(int F, int L) { 	int i, j, k; 	poly[0][0] = 0; 	np[0] = F; 	for (j = 1; j <= F; j++) 		poly[0][j] = number_of_ways[F][j]; 	c = 0; 	for (i = 2; i <= L; i++) { 		p = c; 		c = 1 - c; 		np[c] = np[p] + F; 		// Since MOD is small (2003), we only need up to MOD coefficients. 		if (np[c] > MOD) np[c] = MOD; 		for (j = 0; j <= np[c]; j++) poly[c][j] = 0; 		for (j = 1; j <= np[p]; j++) 			for (k = 1; k <= F && j + k <= np[c]; k++) 				poly[c][j + k] = (poly[c][j + k] + poly[p][j] * number_of_ways[F][k]) % MOD; 	} }   void ComputeKinvPowers(int P) { 	Kinvpow[0] = 1; 	Kinvpow[1] = Kinv; 	for (int i = 2; i <= P; i++) 		Kinvpow[i] = (Kinvpow[i - 1] * Kinv) % MOD; }   namespace BRUTE_FORCE {   #define BFMAX 30 int a[BFMAX], BFN, BFK, BFL, BFF; double bfans;   void BKT(int idx) { 	if (idx > BFN) { 		int i, product = 1, sum = 0; 		for (i = 1; i <= BFL; i++) { 			product *= a[i]; 			sum += a[i]; 		} 		if (product == 0) return; 		int prodf = 1; 		for (i = 1; i <= BFF; i++) 			prodf *= product; 		double cvalue = prodf; 		for (i = 1; i <= sum; i++) 			cvalue /= BFK; 		for (i = sum + 1; i <= BFN; i++) 			cvalue = (cvalue * (BFK - BFL)) / BFK; 		bfans += cvalue; 		return; 	} 	for (int value = 1; value <= BFL; value++) { 		a[value]++; 		BKT(idx + 1); 		a[value]--; 	} 	if (BFL < BFK) BKT(idx + 1); }   void BruteForce(int N, int K, int L, int F) { 	BFN = N; BFK = K; BFL = L; BFF = F; 	bfans = 0.0; 	BKT(1); 	fprintf(stderr, "bfans=%lf\n", bfans); } }   int main() { 	int T, N, K, L, F, M, i, ans, cans, arrang; 	scanf("%d", &T); 	while (T--) { 		scanf("%d %d %d %d", &N, &K, &L, &F); 		if (USE_BRUTE_FORCE) BRUTE_FORCE::BruteForce(N, K, L, F); 		Kinv = RaiseToPow(K, MOD - 2); 		if (F == 1) { 			// Special formula for F=1 (not necessarily needed - the "else" case handles F=1 correctly and efficiently, too). 			for (M = 1, i = 0; i < L; i++) 				M = ((long long) M * (long long) (N - i)) % MOD; 			printf("%d\n", ((long long) M * (long long) RaiseToPow(Kinv, L)) % MOD); 		} else { 			ComputeNumberOfWays(F); 			RaisePolynomialToPower(F, L); 			ComputeKinvPowers(L * F); 			for (arrang = 1, M = 0; M < L; M++) arrang = ((long long) arrang * (long long) (N - M)) % MOD; 			double rans = 0.0, crans; 			for (ans = 0, M = L; M <= L * F && arrang > 0; M++) {				 				cans = (arrang * Kinvpow[M]) % MOD; 				cans = (cans * poly[c][M]) % MOD; 				ans += cans; 				if (ans >= MOD) ans -= MOD; 				fprintf(stderr, "M=%d arrang=%d Kinvpow=%d poly=%d cans=%d ans=%d\n", M, arrang, Kinvpow[M], poly[c][M], cans, ans); 				if (USE_BRUTE_FORCE) { 					crans = arrang * poly[c][M]; 					for (int j = 1; j <= M; j++) 						crans /= K; 					rans += crans; 				} 				arrang = ((long long) arrang * (long long) (N - M)) % MOD; 			} 			printf("%d\n", ans); 			if (USE_BRUTE_FORCE) fprintf(stderr, "rans=%lf\n", rans); 		} 	} 	return 0; } 
#include <vector> #include <list> #include <cassert> #include <sstream> #include <map> #include <set> #include <climits> #include <deque> #include <fstream> #include <stack> #include <bitset> #include <stack> #include <queue> #include <algorithm> #include <functional> #include <numeric> #include <cstring> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> using namespace std;   template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}   #define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i)  #define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i) #define REP(i,n) FOR(i,0,n) #define DEP(i,n) REV(i,n,0) #define PB push_back #define PP pop() #define EM empty() #define INF 1000000000 #define PF push_front #define ALL(x) x.begin(),x.end() #define SORT(x) sort(ALL(x)) #define V(x) vector< x > #define Debug false #define PRINT(x)        cout << #x << " " << x << endl #define LET(x,a) 	    __typeof(a) x(a) #define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i) #define EACH(it,v)  	IFOR(it,v.begin(),v.end()) #define PRESENT(c,x) 	((c).find(x) != (c).end()) #define SZ(x) 		x.size() #define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end()) #define D(N) 		int N #define S(N)		scanf("%d",&N) #define FASTIO          1   typedef pair<int,int>   PI; typedef pair<int,PI>    TRI; typedef V( int )        VI; typedef V( PI  )        VII; typedef V( string )     VS; typedef long long       LL; typedef long double     LD;   /* FastIO, generally required these days ;) */   #ifndef FASTIO char *ipos, *opos, InpFile[20000000], OutFile[20000000], DIP[20]; inline int input(int flag=0) {   	while(*ipos <= 32) ++ipos; 	if ( flag  ) return (*ipos++ - '0'); /* For getting Boolean Characters */ 	int x=0, neg = 0;char c; 	while( true ) { 		c=*ipos++; if(c == '-') neg = 1; 		else { 			if (c<=32) return neg?-x:x; 			x=(x<<1)+(x<<3)+c-'0'; 		} 	} } inline void output(int x,int flag) { 	int y,dig=0; 	while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;} 	while (dig--) *opos++=DIP[dig]; 	*opos++= flag ? '\n' : ' '; } inline void InitFASTIO() { 	ipos = InpFile; opos = OutFile; 	fread_unlocked(InpFile,20000000,1,stdin); } inline void FlushFASTIO() { 	fwrite_unlocked(OutFile,opos-OutFile,1,stdout);	 } #endif   /* Main Code Starts from here */   #define Max 5010   int r, c, sr, sc, er, ec, bad; int badones[Max][2];   int dist[310][310];   int d[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; int mark1[310][310], mark2[310][310];   queue<TRI> Q1, Q2;     bool check(int x,int y) {    return x >= 0 && x < r && y >= 0 && y < c; } void pre() {    REP(i,r) REP(j,c) if(!mark2[i][j]) Q2.push(TRI(0,PI(i,j)));    while(!Q2.empty()) {       TRI top = Q2.front(); Q2.pop();       int dist = top.first, x = top.second.first, y = top.second.second;       REP(k,4) { 	 int x1 = x + d[k][0]; 	 int y1 = y + d[k][1]; 	 if(check(x1,y1) && mark2[x1][y1] == -1) { 	    mark2[x1][y1] = dist + 1; 	    Q2.push(TRI(dist+1,PI(x1,y1))); 	 }       }    } }   bool simulate(int d1) {           memset(mark1,-1,sizeof mark1);        mark1[sr][sc] = 0;    queue<PI> Q; Q.push(PI(sr,sc));      while(!Q.empty()) {       PI top = Q.front(); Q.pop();       int x = top.first, y = top.second;         if(x == er && y == ec && mark1[x][y] <= mark2[x][y]*d1) { 	 return true;       }       else if(!d1) return false;         if(mark1[x][y] >= mark2[x][y]*d1) continue;       REP(k,4) { 	 int x1 = x + d[k][0]; 	 int y1 = y + d[k][1]; 	 if(check(x1,y1) && mark1[x1][y1] == -1) { 	    mark1[x1][y1] = mark1[x][y] + 1; 	    Q.push(PI(x1,y1)); 	 }       }    }    return false; }   int main() {      int kases, x, y; scanf("%d",&kases);    while(kases--) {       scanf("%d%d%d%d%d%d%d",&r,&c,&sr,&sc,&er,&ec,&bad);         memset(mark1,-1,sizeof mark1);       memset(mark2,-1,sizeof mark2);         REP(i,bad) { 	 scanf("%d%d",&badones[i][0], &badones[i][1]); 	 mark2[badones[i][0]][badones[i][1]] = 0;       }       pre();       int low = 0, high = r + c + 1, mid, solved = 0;       REP(i,9) { 	 mid = (low + high)/2; 	 if(simulate(mid)) { 	    solved = 1; 	    high = mid; 	 } 	 else low = mid + 1;       }       if(!solved) puts("Impossible!");       else printf("%d\n",high);    }    return 0; }
#include <cstdio> #include <cstring> #include <map> #include <iostream> #include <algorithm> #define DEBUG_Z 0 using namespace std; typedef unsigned long long ULL;  const int MAX_N = 200000 + 10; const int DEP = 1007; const int MOD = 42424242;  map<ULL, int> mapII; int N, L, Q, ret; char s[MAX_N], r[MAX_N]; int lcp[MAX_N], tmp[MAX_N]; int fb[26]; ULL h[MAX_N], p[MAX_N];  void doZ(int L, char *s, int *z) { 	int l = 1, r; 	for(r = 1; r < L && s[r - 1] == s[r]; ++ r) 		; 	z[1] = r - 1; 	for(int i = 2; i < L; ++ i) { 		if (r > i && i + z[i - l] < r) 			z[i] = z[i - l]; 		else { 			for(l = i, r = max(r, i); r < L && s[r] == s[r - i]; ++ r); 			z[i] = r - i; 		} 	} }  void inputData() { 	scanf("%s", s); 	N = strlen(s); }  void calcL() { 	for(int i = 0; i < N; ++ i) 		r[i] = s[N - 1 - i]; 	L = 0; 	doZ(N, r, tmp); 	for(int i = 1; i < N; ++ i) 		L = max(L, tmp[i]); }  void calcQ() { 	int tot = 0; 	for(int i = N - 1 - L; i < N; ++ i) 		r[tot ++] = s[i]; 	r[tot ++] = '$'; 	for(int i = 0; i < N; ++ i) 		r[tot ++] = s[i]; 	doZ(tot, r, tmp); 	Q = 0; 	for(int i = 0; i < N - 1 - L; ++ i) { 		lcp[i] = tmp[i + L + 2]; 		Q = max(Q, lcp[i]); 	} }  void calcLCP() { 	int tot = 0; 	for(int i = N - L; i < N; ++ i) 		r[tot ++] = s[i]; 	r[tot ++] = '$'; 	for(int i = 0; i < N; ++ i) 		r[tot ++] = s[i]; 	doZ(tot, r, tmp); 	for(int i = 0; i < N - L; ++ i) 		lcp[i] = tmp[i + L + 1]; }  void calcHash() { 	p[0] = 1; h[0] = s[0]; 	for(int i = 1; i <= N; ++ i) { 		p[i] = p[i - 1] * DEP; 		h[i] = h[i - 1] * DEP + s[i]; 	} }  ULL getVal(int st, int l) { 	if (! l) return 0; 	ULL v1, v2; 	if (! st) v1 = 0; 	else v1 = h[st - 1] * p[l]; 	v2 = h[st + l - 1]; 	return v2 - v1; }  ULL hash(int pos) { 	if (pos + L - 1 < N - L) 		return getVal(pos, L); 	ULL x = getVal(pos, N - L - pos); 	int step = N - L - pos, tmp = L; 	ULL pp = p[step], ret = 0; 	for( ; tmp >= step; tmp -= step)  		ret = ret * pp + x; 	pp = p[tmp]; 	ret = ret * pp + getVal(pos, tmp); 	return ret; }  void calcAns() { 	calcL(); //calc the longest suffix which is some other suffix's perfix 	calcQ(); //calc LCP(i,N-1-L) (i for 0 to N-2-L) 	memset(fb, 0, sizeof fb); 	for(int i = 0; i < N - 1 - L; ++ i) 		if (lcp[i] == Q)  			fb[s[i + Q] - 'a'] = 1; 	calcLCP(); 	calcHash(); 	ret = 0; 	 	mapII.clear(); 	for(int i = 0; i < N - L; ++ i) 		if (! Q || (lcp[i] >= Q - 1 && ! fb[s[i + Q - 1] - 'a'])) { 			ULL x = hash(i); 			if (mapII.find(x) == mapII.end()) { 				++ ret; 				mapII[x] = 1; 			} 		} 	int k = 26; 	memset(fb, 0, sizeof fb); 	for(int i = 0; i < N - L; ++ i) 		if (! fb[s[i] - 'a']) { 			fb[s[i] - 'a'] = true; 			ret = ret * k % MOD; 			-- k; 		} 	cout << ret << endl; }  void solve() { 	inputData(); 	calcAns(); }  int main() { 	if (DEBUG_Z) { 		char str[] = "aabaaaabaaaa"; 		doZ(12, str, tmp); 		for(int i = 1; i < 12; ++ i) 			printf("%d ", tmp[i]); 		printf("\n"); 	} 	 	int T; for(scanf("%d", &T); T --; ) 		solve(); 	return 0; }
#include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <algorithm> #include <vector> #include <cctype> #include <cassert> using namespace std; const int maxn = 55; typedef int MT; //transport the top digit. const MT mask = 0x20000035; int n; char buf[105]; string s[maxn][maxn]; MT m[maxn][maxn]; MT X[26]; MT mul(MT t1, MT t2){     MT ret = 0;     while(t1){         if(t1&1) ret ^= t2;         t1 >>= 1;         t2 <<= 1;         if((t2^mask) < t2) t2 ^= mask;     }     return ret; } MT myRand(){     MT ret = 0;     while((ret^mask) > ret) ret = (ret<<1)|(rand()%2);     return ret^mask; } void output(){     for(int i = 0; i < n; i ++){         for(int j = 0; j < n; j ++){             printf("% 9d", m[i][j]);         }         printf("\n");     } } bool isDetZero(){     for(int i = 0; i < n; i ++){         int id = -1;         for(int j = i; j < n; j ++){             if(m[j][i] != 0){                 id = j; break;             }         }         //output();         if(id == -1) return true;         for(int k = 0; k < n; k ++) swap(m[i][k], m[id][k]);         for(int j = i + 1; j < n; j ++){             MT t1 = m[i][i], t2 = m[j][i];             for(int k = 0; k < n; k ++){                 m[j][k] = mul(m[j][k], t1) ^ mul(m[i][k], t2);             }         }     }     //printf("isF\n");     return false; } bool ok(){     for(int i = 0; i < 26; i ++){         X[i] = myRand();         //printf("%d ", X[i]);     }     //printf("\n");     for(int i = 0; i < n; i ++){         for(int j = 0; j < n; j ++){             m[i][j] = 0;             int p = 1;             for(int k = 0; k < (int)s[i][j].size(); k ++){                 char c = s[i][j][k];                 if(c == '+'){                     m[i][j] ^= p;                     p = 1;                 }else if(c == '0') p = 0;                 else if(c == '1') p = 1;                 else{                     assert(islower(c));                     p = mul(p, X[c-'a']);                 }             }         }     }     return isDetZero(); } int main() {     srand(234);     int test;     scanf("%d", &test);     while(test --){         scanf("%d", &n);         for(int i = 0; i < n; i ++){             for(int j = 0; j < n; j ++){                 scanf("%s", buf);                 s[i][j] = string(buf) + "+";             }         }         bool over = false;         for(int i = 0; i < 10; i ++){             if(!ok()){                 over = true; break;             }         }         printf("%s\n", over ? "Some Odd" : "All Even");     }     return 0; }
#include <cstdio>   typedef long long LL; const double eps = 1e-9; inline int bit(int n) { return 1<<n; }   const int maxN = 10; const int minX = 10; const int maxX = 666; const double maxXeps = maxX - eps; const int maxM = 1000000000; const int maxP3 = 17; // maxM/3^maxP3 <= minX int p3[maxP3]={1};   int n,x; int c[maxN],m[maxN]; int L[maxN],R[maxN]; int pw[maxN+1]; double minrat[1<<maxN]; double mag[maxN][maxP3]; double eff[maxN][maxP3];   const int maxSZ = 1<<(2*maxN); int tst; char mark[maxSZ]; int cnt=0;   double res; double effort,magic; int mask; void dfs(int state) { 	if(res<effort+(maxX-magic)*minrat[mask]+eps) return; 	if(mark[state]==tst) return; 	mark[state]=tst; 	cnt++; 	for(int i=0;i<n;i++) if(mask & bit(i)) 	{ 		double *magi=mag[i]; 		double *effi=eff[i]; 		int maxk=magic/x+eps; 		int k=L[i]-1; 		if(k<0) k=0; 		if(k>maxk) k=maxk; 		for(;k<R[i] && k<=maxk;k++) 		{ 			magic+=magi[k]; 			effort+=effi[k]; 			if(magic>=maxXeps) 			{ 				if(res>effort) res=effort; 			} 			else 			{ 				mask^=bit(i); 				dfs(state+pw[i]*(k-L[i]+1)); 				mask^=bit(i); 			} 			effort-=effi[k]; 			magic-=magi[k]; 		} 	} }   int main() { 	for(n=1;n<maxP3;n++) 		p3[n]=3*p3[n-1]; 	int TST; 	scanf("%d",&TST); 	for(tst=1;tst<=TST;tst++) 	{ 		scanf("%d%d",&n,&x); 		LL tot=0; 		pw[0]=1; 		int i; 		for(i=0;n--;) 		{ 			scanf("%d%d",c+i,m+i); 			if(m[i]==0) continue; 			tot+=m[i]; 			int l=-1,r; 			for(r=0;LL(x)*r*p3[r]<m[i];r++) 				if(m[i]<LL(maxX)*p3[r] && l<0) l=r; 			L[i]=l; R[i]=r; 			pw[i+1]=pw[i]*(R[i]-L[i]+1); 			for(int k=0;k<R[i];k++) 			{ 				eff[i][k]=1.*c[i]/p3[k]; 				mag[i][k]=-k*x+1.*m[i]/p3[k]; 			} 			i++; 		} 		cnt=0; 		n=i; 		if(tot<maxX) puts("impossible"); else 		{ 			for(mask=0;mask<bit(n);mask++) 			{ 				double cur=1e20; 				for(int i=0;i<n;i++) 					if((mask & bit(i)) && cur>1.*c[i]/m[i]) 						cur=1.*c[i]/m[i]; 				minrat[mask]=cur; 			} 			res=1e20; 			effort=magic=0.; 			mask=bit(n)-1; 			dfs(0); 			printf("%.lf\n",res); 		} 	}	 	return 0; }
#pragma comment(linker, "/STACK:10000000")   #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <bitset> #include <sstream>   #include <algorithm> #include <functional> #include <numeric> #include <iostream>   #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <cassert>   using namespace std;   #define forn(i, n) for(int i = 0; i < int(n); ++i) #define for1(i, n) for(int i = 1; i <= int(n); ++i) #define ford(i, n) for(int i = int(n) - 1; i >= 0; --i) #define fore(i, l, r) for(int i = int(l); i < int(r); ++i) #define sz(v) int((v).size()) #define all(v) (v).begin(), (v).end() #define pb push_back #define X first #define Y second #define mp make_pair #define debug(x) {cerr << #x << " = " << x << endl;} template<typename T> inline T abs(T a){ return ((a < 0) ? -a : a); } template<typename T> inline T sqr(T a){ return a * a; }   typedef long long li; typedef long double ld; typedef pair<li, int> pt;   const int INF = (int)1E9 + 7; const ld EPS = 1E-9; const ld PI = 3.1415926535897932384626433832795; const li mod = 1000000007; const int NMAX = 2000*1000;   bool pr[NMAX]; li ps[NMAX]; int szp = 0;   void gen(){ fore(i, 2, NMAX){ if(!pr[i]){ ps[szp++] = i; for(int j =i+i; j < NMAX; j += i) pr[j] = true; } } }   li powmod(li a, li b, li M=mod){ a %= M;   li ans = 1 % M; while(b > 0){ if(b & 1) ans = (ans * a) % M; b >>= 1; a = (a * a) % M; }   return ans; }   vector<pt> Fact(li v){ vector<pt> ans; if(v == 1) return ans; forn(i, szp){ li d = ps[i]; if(d*d > v) break; int st = 0; while(v % d == 0){ v /= d; st++; }   if(st != 0) ans.pb(mp(d, st));   if(d&1) d++; } if(v != 1) ans.pb(mp(v, 1)); return ans; }   inline li PHI(li p, int e){ return (powmod(p, e-1)*((p-1) % mod)) % mod; }   li NN(li p, int e){ li ans = 0; li mul = sqr(PHI(p,e)) % mod; forn(j, e){ li cur = ((sqr(j+1)%mod) * PHI(p, e-j)) % mod; ans = (ans + cur) % mod; } ans = (ans * mul) % mod;   li c0 = (2*powmod(p,e)-1+mod) % mod; forn(a, e) forn(b, e){ if(a+b >= e){ c0 = (c0 + (PHI(p, e-a)*PHI(p, e-b)) % mod) % mod; } } ans = (ans + sqr(c0)%mod) % mod; return ans; }   li N(li x){ if(x == 1) return 1; vector<pt> fc = Fact(x);   li ans = 1%mod;   forn(i, sz(fc)){ li p = fc[i].X; int e = fc[i].Y; ans = (ans*NN(p,e)) % mod; } return ans; }   int stupid(int p){ int ans = 0; for1(a, p*(p-1)) for1(b, p*(p-1)) ans += int(powmod(a,b,p) == powmod(b,a,p)); return ans; }   int main() { // freopen("input.txt", "rt", stdin); // freopen("output.txt", "wt", stdout); gen(); int test; cin >> test; forn(TT, test){ li p; cin >> p;   cout << (powmod(p-1, 2) + N(p-1)) % mod << endl; }   return 0; }
    #include <cstdio>     #include <cstring>     #include <algorithm>     using namespace std;     const int M = 1337;     int t[7][101];     int c[7][101];     int p10[101];     char s[101];     int main() {     for(int k = 1; k < 7; ++k) t[k][0] = c[k][0] = 1;     t[0][0] = c[0][0] = -1;     p10[0] = 1;     for(int len = 1; len <= 100; ++len) {     p10[len] = (10 * p10[len - 1]) % 7;     for(int md = 0; md < 7; ++md) {     t[md][len] = 0;     c[md][len] = 1;     for(int d = 0; d <= 9; ++d) {     if(d != 7) {     t[md][len] += c[md][len] * t[(p10[len - 1] * d + md) % 7][len - 1];     c[md][len] *= c[(p10[len - 1] * d + md) % 7][len - 1];     } else if(len == 1) {     t[md][len] += -c[md][len];     c[md][len] *= -1;     }     }     t[md][len] = (t[md][len] % M + M) % M;     }     }     int d;     scanf("%d", &d);     while(d--) {     scanf("%s", s);     int len = strlen(s);     int p = -1;     int cc = -1;     int md = 0;     reverse(s, s + len);     for(int i = len - 1; i >= 0; --i) {     for(int d = 0; d < s[i] - '0'; ++d) {     if(d != 7) {     p += cc * t[(md + d * p10[i]) % 7][i];     cc *= c[(md + d * p10[i]) % 7][i];     } else if (i == 0) {     p += -cc;     cc *= -1;     }     }     if(s[i] == '7' && i) {     if(s[0] % 2) {     p -= cc;     }     break;     }     md = (md + (s[i] - '0') * p10[i]) % 7;     }     printf("%d\n", (p % M + M) % M + 1);     }     } 
#include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<deque> #include<stack> #include<list> #include<complex> #include<string> #include<utility> #include<numeric> #include<iterator> #include<algorithm> #include<cstdio> #include<cstdlib> #include<cmath> #include<cctype> #include<climits> #include<ctime> #include<cstring>  #define ALL(c)  c.begin(), c.end() #define TR(c, it)   for(typeof(c.begin()) it = c.begin(); it != c.end(); it++) #define FOR(i, j, n)  for(int (i) = (j); i < n; i++) #define MAX(a, b)   ((a) > (b) ? (a) : (b)) #define gc  getchar_unlocked #define lli long long int #define inf INT_MAX #define mininf INT_MIN #define pb push_back #define mp  make_pair #define time   QueryPerformanceCounter #define qp  QuadPart #define LI LARGE_INTEGER #define PI  3.14159265358979323846264338327950288  using namespace std;  typedef complex<double> base;  lli A[200100], max_sum = 20000000 ; int N, lookup_table[20000010] = {0};  inline void scanint(lli &x) {     register int c = gc();     x = 0;     int neg = 0;     for(; ((c<48 || c>57) && c != '-'); c = gc());     if(c=='-')     {         neg = 1;         c = gc();     }     for(; c>47 && c<58 ; c = gc())     {         x = (x<<1) + (x<<3) + c - 48;     }     if(neg)         x = -x; }    void fft (vector<base> & a, bool invert) { 	int n = (int) a.size();  	for (int i=1, j=0; i<n; ++i) { 		int bit = n >> 1; 		for (; j>=bit; bit>>=1) 			j -= bit; 		j += bit; 		if (i < j) 			swap (a[i], a[j]); 	}  	for (int len=2; len<=n; len<<=1) { 		double ang = 2*PI/len * (invert ? -1 : 1); 		base wlen (cos(ang), sin(ang)); 		for (int i=0; i<n; i+=len) { 			base w (1); 			for (int j=0; j<len/2; ++j) { 				base u = a[i+j],  v = a[i+j+len/2] * w; 				a[i+j] = u + v; 				a[i+j+len/2] = u - v; 				w *= wlen; 			} 		} 	} 	if (invert) 		for (int i=0; i<n; ++i) 			a[i] /= n; }  void multiply (const vector<int> & a, const vector<int> & b, vector<int> & res) { 	vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end()); 	size_t n = 1; 	while (n < max (a.size(), b.size()))  n <<= 1; 	n <<= 1; 	fa.resize (n),  fb.resize (n);  	fft (fa, false),  fft (fb, false); 	for (size_t i=0; i<n; ++i) 		fa[i] *= fb[i]; 	fft (fa, true); 	res.resize (n); 	for (size_t i=0; i<n; ++i) 		res[i] = int (fa[i].real() + 0.5); }  int main() {     int ans = 0, i , j;     lli size = 0;     scanf("%d",&N);     for( i = 1 ;i <= N; i++ )     {         //scanf("%lld",&A[i]); 		scanint(A[i]); 		size += A[i];     }     if(N <= 2000)     {         set<lli>sums;         for( i = 1 ; i <= N; i++ )         {             lli value = 0;             for( j = i ; j <= N ; j++)             {                 value += A[j];                 sums.insert(value);             }         }         printf("%d",(sums.size()-1));     }      else if(N <= 20000)     {         for( i = 1;i <= N; i++ )         {             lli value = 0;             for( j = i ; j <= N ; j++)             {                 value += A[j];                 lookup_table[value] = 1;             }         }         ans = 0;         for( i = 1 ;i <= max_sum ; i++ )ans += lookup_table[i];         printf("%d",ans-1);     }     else     {          vector<int> B(size+1),C(size+1),res;         lli s = 0,t = 0;         //for(i = 0;i < size+1 ; i++)B[i] = C[i] = 0;         B[0] = C[size] = 1;         for(i = 1; i <= N ; i++ )         {             s = t + A[i];             B[s] = 1;             C[size-s] = 1;             t = s;         }         multiply(B,C,res);         for( i = size+1 ; i < res.size() ; i++)ans += (res[i]>0);         printf("%d",ans-1);     }     return 0; } 
#include <stdio.h> #include <stdlib.h> #define inf 1000000000 #define bit 17 using namespace std;  int opt[100005],a[100005],x[100005]; int w[100005],son[100005],next[200005],ed[200005],fa[100005]; int st[100005],en[100005],dfn; int n,q,i,j,k,u,v,c,tot,ans,sum; bool vis[100005]; int l[100005],r[100005],mid[100005],destroyed[100005],now[100005]; int Q[100005],Qnext[100005],Sum[100005];  void dfs(int x) { 	st[x]=++dfn; 	for(int i=son[x];i;i=next[i]) 	if(!st[ed[i]])fa[ed[i]]=x,dfs(ed[i]); 	en[x]=dfn; }  int head[100005],tail[100005]; struct Link { 	int next,t; 	int w[bit]; }link[1000005]; int link_tot;  bool finished;  char ch; void read(int &a) {     ch=getchar();while(ch<'0'||ch>'9')ch=getchar();a=ch-'0';     while(((ch=getchar())>='0')&&(ch<='9'))a*=10,a+=ch-'0'; }  int main() { 	read(n); 	for(i=1;i<=n;++i)read(w[i]); 	for(i=1;i<n;++i) 	{ 		read(u),read(v); 		++tot;next[tot]=son[u];son[u]=tot;ed[tot]=v; 		++tot;next[tot]=son[v];son[v]=tot;ed[tot]=u; 	} 	read(q); 	for(i=1;i<=q;++i) 	{ 		read(opt[i]); 		if(opt[i]==1)read(a[i]),read(x[i]); 		else read(a[i]); 	} 	dfs(1); 	for(i=1;i<=q;++i) 	if(opt[i]==1) 	{ 		u=a[i];v=x[i]; 		for(;v;v>>=1,u=fa[u]) 		{ 			++link_tot; 			link[link_tot]=link[tail[u]]; 			if(!head[u])head[u]=link_tot; 			else link[tail[u]].next=link_tot; 			tail[u]=link_tot; 			link[link_tot].t=i; 			for(j=0,c=v;c;c>>=1,++j) 			{ 				link[link_tot].w[j]+=c; 				if(link[link_tot].w[j]>inf)link[link_tot].w[j]=inf; 			} 		} 	} 	for(i=1;i<=n;++i)l[i]=1,r[i]=q,destroyed[i]=q+1; 	for(;;) 	{ 		finished=true; 		for(i=1;i<=q;++i)Q[i]=0; 		for(i=1;i<=n;++i)now[i]=0; 		for(i=1;i<=n;++i) 		if(l[i]<=r[i]) 		{ 			mid[i]=l[i]+r[i]>>1; 			Qnext[i]=Q[mid[i]]; 			Q[mid[i]]=i; 			finished=false; 		} 		if(finished)break; 		for(i=1;i<=q;++i) 		{ 			if(opt[i]==1) 			{ 				u=a[i]; 				for(;u;u=fa[u]) 				{ 					if(now[u]) 					{ 						if(link[link[now[u]].next].t==i) 						now[u]=link[now[u]].next;else break; 					} 					else 					{ 						if(link[head[u]].t==i)now[u]=head[u]; 						else break; 					} 				} 			} 			for(j=Q[i];j;j=Qnext[j]) 			{ 				sum=0; 				for(u=j,k=0;k<bit;++k,u=fa[u]) 				{ 					sum+=link[now[u]].w[k]; 					if(fa[u]&&k+2<bit)sum-=link[now[u]].w[k+2]; 					if(sum>w[j])break; 				} 				if(sum>=w[j])destroyed[j]=mid[j],r[j]=mid[j]-1; 				else l[j]=mid[j]+1; 			} 		} 	} 	for(i=1;i<=q;++i)Q[i]=0; 	for(i=1;i<=n;++i)Qnext[i]=Q[destroyed[i]],Q[destroyed[i]]=i; 	for(i=1;i<=q;++i) 	{ 		if(opt[i]==2) 		{ 			u=a[i];ans=0; 			for(j=en[u];j>0;j-=j&-j)ans+=Sum[j]; 			for(j=st[u]-1;j>0;j-=j&-j)ans-=Sum[j]; 			printf("%d\n",ans); 		} 		for(u=Q[i];u;u=Qnext[u]) 		for(j=st[u];j<=n;j+=j&-j) 		++Sum[j]; 	} } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 100050 #define M 40000050 #define P 1000000009 struct Matrix  {int a[3];} Emp,Pow[N],Sum[N],I,E,val[M],_val[M]; int fi[N],c[N*2][2],fa[N],rf[N],h[N],wei[N],sg[N],nd[N]; int ne[M][2],bd[N],rt[N],Cnt[M],Now,ans,__Cnt,ss=1,st,n,m; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Add(int &x,int y) {x=(x+y)%P;} Matrix operator* (const Matrix &x,const Matrix &y)  {  	static Matrix z;  	z.a[0]=(1LL*x.a[0]*y.a[0]+1LL*x.a[1]*y.a[1])%P;  	z.a[1]=(1LL*x.a[0]*y.a[1]+1LL*x.a[1]*y.a[2])%P;  	z.a[2]=(1LL*x.a[2]*y.a[2]+1LL*x.a[1]*y.a[1])%P;  	return z;  } Matrix operator+ (const Matrix &x,const Matrix &y)  {  	static Matrix z;z=Emp;  	for (int i=0;i<3;i++) z.a[i]=(x.a[i]+y.a[i])%P;  	return z;  } Matrix operator- (const Matrix &x,const Matrix &y)  {  	static Matrix z;z=Emp;  	for (int i=0;i<3;i++) z.a[i]=(x.a[i]-y.a[i]+P)%P;  	return z;  } void Pretreat()  {  	E.a[0]=E.a[1]=I.a[0]=I.a[2]=true;  	Pow[1]=Sum[1]=E;  	for (int i=2;i<N;i++) Sum[i]=Sum[i-1]+(Pow[i]=Pow[i-1]*E);  	return;  } inline void Line(int x,int y)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } void DFS(int x)  {  	h[x]=h[fa[x]]+1;wei[x]=1;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x])  	   fa[c[i][0]]=x,DFS(c[i][0]),wei[x]+=wei[c[i][0]];  	return;  } void DSF(int x,int y)  {  	nd[sg[x]=++st]=x;int k=false;rf[x]=y;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&wei[c[i][0]]>wei[k]) k=c[i][0];  	if (k) DSF(k,y);  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&c[i][0]!=k) DSF(c[i][0],c[i][0]);  	bd[x]=st;  	return;  } int LCA(int x,int y)  {  	while (rf[x]!=rf[y])  	 {  	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);  	 	x=fa[rf[x]];  	 }  	return h[x]<h[y]?x:y;  } inline Matrix sum(int x,int y)  {return !x?Sum[y]+I:Sum[y]-Sum[x-1];} int Query(int x,int y,int z,int o,int p)  {  	if (x==o&&y==p) return Cnt[z];  	int mid = x + y >> true;  	int _Cnt = (val[z]*sum(o-x,p-x)).a[1];  	Add(_Cnt, (_val[z]*sum(y-p,y-o)).a[1]);  	if (o<=mid) Add(_Cnt,Query(x,mid,ne[z][0],o,min(mid,p)));  	if (p>mid) Add(_Cnt,Query(mid+1,y,ne[z][1],max(mid+1,o),p));  	return _Cnt;  } int __Query(int x,int y)  {  	ans = false;  	while (rf[x]!=rf[y])  	 {  	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);  	 	Add(ans,Query(1,n,Now,sg[rf[x]],sg[x]));  	 	x=fa[rf[x]];  	 }  	if (h[x]>h[y]) swap(x,y);  	Add(ans,Query(1,n,Now,sg[x],sg[y]));  	return ans;  } int _Up(int x,int y)  {  	int la = false;  	while (rf[x]!=rf[y]) la=rf[x],x=fa[rf[x]];  	return x!=y?nd[sg[y]+1]:la;  } int _Query(int y,int x)  {  	if (x==y) return ans=Cnt[Now];  	if (sg[y]<sg[x]||sg[y]>bd[x])  	  ans=Query(1,n,Now,sg[x],bd[x]); else  	 {  	 	y=_Up(y,x);  	 	ans=Query(1,n,Now,1,sg[y]-1);  	 	if (bd[y]!=n) Add(ans,Query(1,n,Now,bd[y]+1,n));  	 }  	return ans;  } int Insert(int x,int y,int z,int o,int p,int u,bool flag)  {  	int mid = x + y >> true, j = ++st;  	ne[j][0]=ne[z][0];ne[j][1]=ne[z][1];  	Cnt[j]=Cnt[z];val[j]=val[z];_val[j]=_val[z];  	if (x==o&&y==p)  	 {  	 	if (flag) _val[j] = _val[j] + Pow[u]; else  	 	  val[j] = val[j] + Pow[u];  	 	Cnt[j] = (Cnt[j] + (sum(u,p-o+u)).a[1] ) %P;  	 	return j;  	 }  	if (p<=mid) ne[j][0]=Insert(x,mid,ne[z][0],o,p,u,flag); else  	 if (o>mid) ne[j][1]=Insert(mid+1,y,ne[z][1],o,p,u,flag); else  	  if (!flag)  	    ne[j][0]=Insert(x,mid,ne[z][0],o,mid,u,flag),  	    ne[j][1]=Insert(mid+1,y,ne[z][1],mid+1,p,u+mid-o+1,flag); else  	    ne[j][1]=Insert(mid+1,y,ne[z][1],mid+1,p,u,flag),  	    ne[j][0]=Insert(x,mid,ne[z][0],o,mid,u+p-mid,flag);  	Cnt[j]=((Cnt[ne[j][0]]+Cnt[ne[j][1]])%P+((val[j]+_val[j])*sum(0,y-x)).a[1])%P;  	return j;  } bool Up(int x,int y,int z,bool flag)  {  	while (rf[x]!=rf[y])  	 {  	 	if (flag)  	 	  Now=Insert(1,n,Now,sg[rf[x]],sg[x],z-sg[x]+sg[rf[x]],!flag); else  	 	  Now=Insert(1,n,Now,sg[rf[x]],sg[x],z,!flag);  	 	z += (flag ? -1 : 1) * (h[x] - h[rf[x]] + 1);  	 	x = fa[rf[x]];  	 }  	if (x!=y) if (flag)  	  Now = Insert(1,n,Now,sg[y],sg[x],z-sg[x]+sg[y],!flag); else  	  Now = Insert(1,n,Now,sg[y],sg[x],z,!flag);  	return x==y;  } void Modify(int x,int y)  {  	int k=LCA(x,y);bool flag = Up(x,k,true,false);  	flag &= Up(y,k,h[y]+h[x]-2*h[k]+true,true);  	if (flag) Now=Insert(1,n,Now,sg[k],sg[k],h[x]-h[k]+true,false);  	return;  } int main()  {  	/*int _size=64 << 20;  	char *_p=(char*)malloc(_size)+_size;  	__asm__("movl %0, %%esp\n"::"r"(_p));  	freopen("input.txt","r",stdin); 	freopen("output.txt","w",stdout);*/  	n=Read();Pretreat();m=Read();  	for (int i=1;i<n;i++) Line(Read(),Read());  	DFS(1);DSF(1,1);st=false;  	for (int T=1;T<=m;T++)  	 {  	 	static char ch[20];scanf("%s",ch+1);int k=Read()^ans;  	 	if (ch[1]=='R') Now=rt[k]; else  	 	if (ch[1]=='Q')  	 	  printf("%d\n",ch[2]=='S'?_Query(k,Read()):__Query(k,Read())); else  	 	  Modify(k,Read());  	 	rt[T]=Now;  	 }  	return 0;  }
#define _CRT_SECURE_NO_WARNINGS #include <cstdio> #include <iostream> #include <sstream> #include <string> #include <cstring> #include <algorithm> #include <set> #include <map> #include <deque> #include <queue> #include <vector> #include <cmath> #include <ctime> #include <cassert> #include <stack>   #pragma comment(linker, "/STACK:64777216") using namespace std;     typedef long long ll; typedef unsigned long long ull;   template<typename T> int size(T & a) { return (int) a.size(); } template<typename T> T sqr(T a) {return a * a; }   #define pb push_back #define mp make_pair #define vi vector<int> #define pii pair<int, int> #define _(a, b) memset((a), (b), sizeof(a)) #define REP(i, a, b) for(int i=(a); i<(b); ++i) #define all(a) a.begin(),a.end()     int a[1010]; char s[10]; int pre1[1010][1010]; int pre2[1010][1010]; int pre1id[1010][1010]; int pre2id[1010][1010];   int ans[5]; int mainRoot; int lrestore, restoreValue, rrestore;   int SZ;   bool used[1010]; int low[1010]; int lst[1010];     struct Fastset { 	int a[32]; 	int b; 	void clear() { 		b=0; 		_(a,0); 	} 	void add(int x) { 		a[x >> 5] |= (1 << (x & 31)); 		b |= (1 << (x >> 5)); 	} 	int inBlock(int num) { 		int i=0; 		while ((a[num] & (1 << i)) == 0) ++ i; 		return (num<<5)+i; 	} 	int whole(int l, int r) { 		if(l>r)return -1; 		while (l <= r && ((b & (1 << l)) == 0)) ++l; 		return l==r+1 ? -1 : inBlock(l); 	} 	int inBlockFromMid(int num, int start) { 		if ((b & (1 << num)) == 0)return -1; 		while (start < 32 && ((a[num] & (1 << start)) == 0)) ++start; 		return start==32 ? -1 : start+(num<<5); 	} 	int inBlockToMid(int num, int finish) { 		if ((b & (1 << num)) == 0)return -1; 		int start = 0; 		while (start <= finish && ((a[num] & (1 << start)) == 0)) ++start; 		return start == finish + 1 ? -1 : (num<<5) + start; 	} 	int inBlockMiddle(int num, int l, int r) { 		if ((b & (1 << num)) == 0)return -1; 		int start = l; 		while (start <= r && ((a[num] & (1 << start)) == 0)) ++start; 		return start == r + 1 ? -1 : (num<<5) + start; 	} 	int getMin(int l, int r) { 		if (l>r) return -1; 		if ((l>>5) == (r>>5)){  			return inBlockMiddle(l >> 5, l & 31, r & 31); 		} 		int r1=inBlockFromMid(l >> 5, l & 31); 		if (r1 != -1) return r1; 		int r2=whole((l>>5) + 1, (r>>5)-1); 		if (r2 != -1) return r2; 		return inBlockToMid(r >> 5, r & 31); 	} }; void solve() { 	 	int n; 	scanf("%d %s\n", &n, s); 	vector<int> vals; 	REP(i,0,n) scanf("%d", &a[i]), vals.pb(a[i]); 	sort(all(vals)); 	vals.erase(unique(all(vals)), vals.end()); 	REP(i,0,n) a[i]=lower_bound(all(vals), a[i])-vals.begin(); 	int lf[5]; 	lf[1]=-2;     lf[3]=-1;     lf[0]=0;     lf[2]=1;     lf[4]=2;       int perm[5];;     for(int i=0;i<5;++i)         perm[s[i]-'1']=i; 	SZ=size(vals);   	_(pre1[0], 63); 	_(pre2[n-1], 63); 	_(pre1id[0], 255); 	_(pre2id[n-1], 255);   	REP(i,0,n) REP(j,0,SZ) { 		if (i>0) { 			pre1[i][j]=pre1[i-1][j]; 			pre1id[i][j]=pre1id[i-1][j]; 		} 		if(a[i]>=j) { 			if (pre1[i][j]>a[i]) { 				pre1[i][j]=a[i]; 				pre1id[i][j]=i; 			} 		} 	} 	for(int i=n-1; i>=0;--i) REP(j,0,SZ) { 		if (i!=n-1) { 			pre2[i][j]=pre2[i+1][j]; 			pre2id[i][j]=pre2id[i+1][j]; 		} 		if(a[i]>=j) { 			if (pre2[i][j]>a[i]) { 				pre2[i][j]=a[i]; 				pre2id[i][j]=i; 			} 		} 	} 	REP(i,0,n) low[i]=SZ-1; 	REP(i,0,n) lst[i]=-1;   	Fastset q;   	for(int p1=1; p1<n;++p1){ 		q.clear(); 		q.add(a[p1+1]); 		for(int p2=p1+2; p2<n-1; ++p2) {             int mn=-1;             int sz=0;             for(int j=0;j<5;++j) {                 int t=perm[j];                 if (lf[t] < 0) {                     int g=(lf[t]==-2?p1:p2);                     if(a[g]>mn) {                         mn=a[g];                         ans[sz++]=g;                     } else {                         break;                     }                 } else { 					if (lf[t] != 1) { 						int v; 						if (lf[t]==0) { 							v=(mn+1>SZ-1 ? -1 : pre1id[p1-1][mn+1]); 						} else { 							v=(mn+1>SZ-1 ? -1 : pre2id[p2+1][mn+1]); 						} 						if(v==-1){ 							break; 						} 						mn=a[v]; 						ans[sz++]=v; 					} else { 						 						int value=q.getMin(mn+1, 999); 						if (value==-1) 							break; 						mn=value; 						ans[sz++]=-1; 						restoreValue=value; 						lrestore=p1+1; 						rrestore=p2-1; 					}                                      }             }             if(sz==5) {                 for(int v=0;v<5;++v) { 					if (ans[v]==-1) { 						for(int u=lrestore; u <= rrestore; ++u) 							if (a[u]==restoreValue) 								ans[v]=u; 					} 				} 				sort(ans, ans+5); 				REP(i,0,5)printf("%d ",ans[i]);                 printf("\n");                 return ; 			} 			q.add(a[p2]); 		} 	}     printf("-1\n"); }   int main() {               #ifdef air 	/*freopen("input.txt", "w", stdout);            printf("60\n");             for(int i=0;i<60;++i) {                 printf("1000 12345\n"); 				for(int v=0;v<1000-5;++v) 					printf("%d ", 1000-v); 				for(int v=1; v<=5; ++v) 					printf("%d ", v); 				 			}*/ 	freopen("input.txt", "r", stdin);     freopen("output.txt", "w", stdout); #endif 	int tc; 	scanf("%d\n", &tc); 	while (tc --> 0) { 		solve(); 	} #ifdef air     printf("\n\n%.3lf\n", clock() * 1.0 / CLOCKS_PER_SEC); #endif   } 
/*****************************************************************************  *************************** Macros and Typedefs *****************************  *****************************************************************************/  // #pragma stacksize 1M twice // #pragma comment(linked, "/STACK:16777216")  #include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <string> #include <utility> #include <time.h> #include <vector>  using namespace std;  #define mp make_pair #define pb push_back #define fi(n) fo(i,n) #define fj(n) fo(j,n) #define fk(n) fo(k,n) #define fd(i,n) for(int i=(int)(n)-1; i>=0; --i) #define fo(i,n) fr(i,0,n) #define fr(i,a,b) for(int i=(int)a; i<(int)b; ++i) #define sz(x) ((int) (x).size()) #define all(x) (x).begin(), (x).end() #define sqr(x) ((x) * (x)) #define srt(x) sort(all(x)) #define go(x,it) for(typeof((x).begin()) it=(x).begin(); it!=(x).end(); ++it) #define PQ(t) priority_queue< t, vector<t>, greater<t> > #define x first #define y second #define me (*this) #define CLR(a,v) memset(a, v, sizeof(a)) #define UNIQUE(a) srt(a); a.resize(unique(all(a))-a.begin()) #define RAND (((double)rand()/RAND_MAX) + ((double)rand()/RAND_MAX/RAND_MAX))  typedef long long ll; typedef long double ld;  typedef pair< int,int > ii; typedef vector< ii > vii; typedef vector< vii > vvii;  typedef vector< int > vi; typedef vector< vi > vvi;  typedef vector< double > vd; typedef vector< vd > vvd;  typedef vector< ll > vll; typedef vector< vll > vvll;  typedef vector< string > vs;  /*****************************************************************************  ****************************** My Methods ***********************************  *****************************************************************************/  // my stuff const int INF = 1000*1000*1000+7; const double EPS = 1e-9; int bit_count(int x){ return x==0 ? 0 : 1+bit_count(x&(x-1)); } inline int low_bit(int x){ return x&-x; } // 0011 0100 return 0000 0100 inline int sign(double x){ return x<-EPS ? -1 : x>EPS ? 1 : 0; } inline int sign(int x){ return (x>0)-(x<0); } template<class T> void chmin(T &t, T f){ if(t > f) t = f; } template<class T> void chmax(T &t, T f){ if(t < f) t = f; }  int nextComb(int x){            // x = xxx0 1111 0000     int smallest = x&-x;        // 0000 0001 0000     int ripple = x+smallest;    // xxx1 0000 0000     int ones = x^ripple;        // 0001 1111 0000 // necessary to kill leading ones     ones = (ones>>2)/smallest;  // 0000 0000 0111     return ripple|ones;         // xxx1 0000 0111 }  /*****************************************************************************  **************************** Scanner Methods ********************************  *****************************************************************************/  inline int getint(){   int a;   return scanf("%d", &a) ? a : (fprintf(stderr, "trying to read\n"),-1); }  inline double getdouble(){   double a;   return scanf("%lf", &a) ? a : (fprintf(stderr, "trying to read\n"),-1.0); }   /*  *  // does not get the new line  *  getline(cin, s);  *  *  struct comp_1{  *      bool operator()(const ii &a, const ii &b) const{  *          return a.x!=b.x ? a.x<b.x : a.y<b.y;  *      }  *  };  *  *  sprintf(buf, "%s%d%s%d%s\n", "Hell", 0, " W", 0, "rld!");  *  *  (map<int,int>::iterator it = cache.begin(); it!=cache.end(); ++it)  */  /* const int BUF_SIZE = 1001*1000; char buf[BUF_SIZE];  inline string gettoken(){     return scanf("%s", buf) ? buf : (fprintf(stderr, "trying to read\n"),""); }  // does not return the new line inline string getline(){     string ret;     getline(cin, ret);     // getline(cin, ret, ':'); // to use ':' as the delimiter     return ret; } */  /*****************************************************************************  ************************* Problem Specific Code *****************************  *****************************************************************************/  // END_CUT  pair< ii,int > edges[45]; int adjacent[10][10];  // Begin GCD int gcd_f(int a, int b){ while(b){ int r=a%b; a=b; b=r; } return a; } int gcd_t[1<<10][1<<10]; void preprocess(){   fi(1<<10)      fj(1<<10)       gcd_t[i][j] = i>j ? gcd_t[j][i] : gcd_f(i, j);       // gcd_t[i][j] = i>j ? gcd_t[j][i] : ((i&1)+(j&1)==0 ? gcd_t[i>>1][j>>1] : gcd_f(i, j));   fi(45)     edges[i] = mp(ii(0,0), 0);   fi(10)     fj(10)       adjacent[i][j] = -1; /*   fi(1<<10)     fj(1<<10)       if(gcd_t[i][j] == 0)         fprintf(stderr, "gcd_t[%d][%d] = %d\n", i, j, gcd_t[i][j]);   fprintf(stderr, "after preprocess gcd_t[%d][%d] = %d\n", 0, 1, gcd_t[0][1]); */ }  inline int gcd(int a, int b){   if(a < (1<<10) && b < (1<<10))     return gcd_t[a][b];   else     return gcd_f(a, b); } // End GCD  // Begin Rational struct Q{    int n, d;   Q(int _n=0, int _d=1): n(_n), d(_d){     if(d != 1)       normalise();   }   Q(const Q &q): n(q.n), d(q.d){}    void normalise(){     if(d < 0)       n = -n, d = -d;     int g = gcd(abs(n), d);     if(g != 1){       n /= g;       d /= g;     }   }    string toString(){     char buffer[20];     sprintf(buffer, "%d/%d", n, d);     return buffer;   }    Q operator+(const Q &q){ return Q(n*q.d + q.n*d, d*q.d); }   Q operator-(const Q &q) const{ return Q(n*q.d - q.n*d, d*q.d); }   Q operator*(const Q &q){ return Q(n*q.n, d*q.d); }   Q operator/(const Q &q){ return Q(n*q.d, d*q.n); }   bool operator<(const Q &q){ return n*q.d < d*q.n; }   bool operator>(const Q &q){ return n*q.d > d*q.n; }   bool operator==(const Q &q){ return n==q.n && d==q.d; }   bool operator!=(const Q &q){ return n!=q.n || d!=q.d; }  }; const Q ZERO(0, 1), MINUS_ONE(-1, 1); // End Rational  // Begin Simplex const int MAX_M = 1<<10, MAX_N = 1<<8; struct Simplex{   Q a[MAX_M][MAX_N];   int rows[MAX_M], cols[MAX_N], nr, nc, m, n;    Simplex(Q _a[MAX_M][MAX_N], Q b[MAX_M], Q c[MAX_N], int _m, int _n): m(_m), n(_n){     fi(m) fj(n) a[i][j] = _a[i][j];        fi(m) a[i][n] = b[i];     fj(n) a[m][j] = c[j];     a[m][n] = 0;   }    Q solve(){ /*     int debug = 0; */     while(true){ /*     // debug     if(debug++ < 4)       fi(m+1){         fj(n+1)           fprintf(stderr, "%7s", a[i][j].toString().c_str());         fprintf(stderr, "\n");       } */       // find col       int j0 = -1;       Q best(ZERO);       fj(n)         if(a[m][j] > best)           j0 = j, best = a[m][j];       if(j0 == -1)         break;        // find row       int i0 = -1;       best = MINUS_ONE;       fi(m)         if(a[i][j0] > ZERO && (best == MINUS_ONE || a[i][n]/a[i][j0] < best))           best = a[i][n] / a[i][j0], i0 = i;       if(i0 == -1)         return fprintf(stderr, "unbounded feasible\n"), Q(INF,1);        // optimise sparse matrices       nr = nc = 0;       fi(m+1) if(i != i0 && a[i][j0] != ZERO)         rows[nr++] = i;       fj(n+1) if(j != j0 && a[i0][j] != ZERO)         cols[nc++] = j; /*       fprintf(stderr, "nr=%d, nc=%d\n", nr, nc);       fprintf(stderr, "i0 = %d, j0 = %d\n", i0, j0); */       // pivot       Q piv = a[i0][j0], npiv = ZERO-a[i0][j0];       a[i0][j0] = npiv; // becomes 1 / a[i][j] after row and col ops       fi(m+1) a[i][j0] = a[i][j0] / npiv;       fi(nr){         int _i = rows[i];         fj(nc){           int _j = cols[j];           a[_i][_j] = a[_i][_j] + (a[i0][_j] * a[_i][j0]); // a[i][j] = a[i][j] - a[i0][j] * a[i][j0] / a[i0][j0]         }       }       fj(n+1) a[i0][j] = a[i0][j] / piv;      }      return a[m][n];   }  }; // End Simplex  // for simplex Q a[MAX_M][MAX_N], b[MAX_M], c[MAX_N]; int na; // for cycle finding int cy[11], e[10], seen[10];  void cycle(int i, int d){   cy[d] = i;    // case cycle complete   if(d > 0 && i == cy[0]){     fi(d){ // for every edge on the cycle       fj(d){ // the sum of every other edge is at least that of the 'i' edge         int id = e[j];         a[na][(id<<1)] = a[na][(id<<1)+1] = Q(i==j ? 1 : -1);       }       ++na;     }     return;   }    // ensure no short circuits   // i.e. if \exists somebody I am adjacent to, already in the cycle, and it is not the previous person or first person   //      then quit   if(d >= 2)     fj(10)        if(adjacent[i][j] != -1 && seen[j] && j != cy[d-1] && j != cy[0])         return;    // look for more edges   seen[i] = 1;   // ensure vertices >= c[0] so cycles start unique position   // only only to go to c[0] if c[1]<c[d] so cycles have unique orientation   // obviously can't use a vertex twice   int start = (d > 1 && cy[1] < cy[d]) ? cy[0] : cy[0]+1;   fr(j,start,10) // for every person after me     if(adjacent[i][j] != -1) // that I am adjacent to       if(!seen[j] || j == cy[0]){ // that has not been seen, or is allowed to be seen         e[d] = adjacent[i][j]; // go for a walk         cycle(j, d+1);       }   seen[i] = 0; }  void myCode(){    // setup   preprocess();    // input   int n=getint(), ne=getint();   fk(ne){     int i=getint(), j=getint(), d=getint();     edges[k] = mp(ii(i,j), d);     adjacent[i][j] = adjacent[j][i] = k;   }    // build tableau   fi(n)     cycle(i, 0);   fk(ne){     a[na][(k<<1)+1] = 1;     b[na] = edges[k].y;     ++na;     c[(k<<1)] = -1;     c[(k<<1)+1] = 1;   } /*   // debug   fi(na){     fj(2*ne)       fprintf(stderr, "%7s", a[i][j].toString().c_str());     fprintf(stderr, "\n");   } */   // solve   Simplex simplex(a, b, c, na, 2*ne);   Q ret = simplex.solve();   fk(ne)     ret = ret + edges[k].y;   printf("%s\n", ret.toString().c_str());  }  int main() {   srand(time(NULL));   myCode();   return 0; } 
#include <iostream> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <map> using namespace std; typedef long long LL; const double eps = 1e-8; const double pi = acos(-1.0); const LL inf = 2000000001LL; int T; LL ans,C,P,X,Y,UY,Z,Q,Yn,t,sd,UnTwo,tp,td,gh; map<LL,LL> Tree[2];     LL MOD;   int real_rand() {     return ((rand()%32768 << 15) ^ rand()); } LL mod_exp(LL a, LL b) {     LL res = 1;     while(b > 0) {         if(b&1)    res = (res*a)%MOD;         a = (a*a)%MOD;         b >>= 1;     }     return res; }   LL solve(LL n, LL p) {     LL Q = p - 1, S = 0;     while(Q%2 == 0) {         Q >>= 1;         S++;     }     if(S == 1) {return mod_exp(n, (p + 1)/4);}     LL z = 0;     while(1) {         z = 1 + real_rand()%(p-1);         if(mod_exp(z, (p - 1)/2) != 1)   break;     }     LL c = mod_exp(z, Q);     LL R = mod_exp(n, (Q + 1)/2);     LL t = mod_exp(n, Q);     LL M = S, b, i;     while(1) {         if(t%p == 1)  break;         for(i = 1; i < M; ++i) {             if(mod_exp(t, 1<<i) == 1)    break;         }         if (M == i) break;         b = mod_exp(c, 1<<(M-i-1));         R = (R*b)%p;         t = (t*b%p*b)%p;         c = (b*b)%p;         M = i;     }     return (R%p + p)%p; }   LL BabyGaint(LL Y,LL UY,LL Yn,LL P,int d) {   if (Tree[d].count(Yn) > 0) return Tree[d][Yn];   int w;   for (int i = 1;i <= P/Q+1; i++) {        Yn = Yn * tp % P;        w = (i*Q%2) ^ d;        if (Tree[w].count(Yn) > 0) {           return i*Q + Tree[w][Yn];        }     }    return inf; } int main() {     scanf("%d",&T);     for (int tst = 1;tst <= T; tst++) {         ans = inf;          cin>>C>>P; MOD = P; Q = int(sqrt(P)); Tree[0].clear(); Tree[1].clear();         UnTwo = ((P + 1) / 2) % P;         X = solve(5,P);         if ((X & 1)  == 0) X = P - X;         Y = ((1 + X) * UnTwo)% P;         UY = ((X - 1) * UnTwo + P) % P;         Z = (C * X) % P;                  td = 1; tp = 1;         for (int i = 0;i < Q; i++) {             if (Tree[i%2].count(td) == 0) Tree[i%2][td] = i;             td = td * Y % P;             tp = tp * UY % P;         }          gh = (Z*Z+4)%P;         if(mod_exp(gh,(P-1)/2) != P-1) {            t = solve(gh,P);            Yn = ((Z + t) * UnTwo + P) % P;            sd =  BabyGaint(Y,UY,Yn,P,0);            ans = min(ans,sd);            Yn = ((Z - t) * UnTwo % P + P) % P;            sd =  BabyGaint(Y,UY,Yn,P,0);            ans = min(ans,sd);         }                  gh =(Z*Z%P-4%P+P)%P;         if(mod_exp(gh,(P-1)/2) != P-1) {            t = solve(gh,P);            Yn = ((Z + t) * UnTwo + P) % P;            sd =  BabyGaint(Y,UY,Yn,P,1);            ans = min(ans,sd);            Yn = ((Z - t) * UnTwo % P + P) % P;            sd =  BabyGaint(Y,UY,Yn,P,1);            ans = min(ans,sd);         }         if (ans == inf) printf("-1\n"); else cout<<ans<<endl;     }     return 0; } 
#include<iostream> #include<algorithm> #include<cstdio> #include<cstring> #include<cmath> #define rep(i,a,b) for(int i=a;i<=b;++i) #define erp(i,a,b) for(int i=a;i>=b;--i) using namespace std; typedef unsigned long long u64; const int MAXN = 100002; int bsz, N, Q, lef[MAXN], rig[MAXN]; int be[MAXN], sum[MAXN], bn, a[MAXN]; u64 s[MAXN];  inline int bid(int x) { return (x-1)/bsz + 1; } struct blist { 	u64 as[MAXN], bs[500]; 	inline void update(int i, int x) 	{ 		for(int j = i; j<=N&&j%bsz!=1; j++) as[j] += x; 		for(int j = bid(i)+(i!=be[i]); j<=bn; ++j) bs[j] += x; 	} 	inline u64 quary(int i) 	{ 		if (!i) return 0; 		return as[i] + bs[(i-1)/bsz+1]; 	} } bl;  struct block { 	int cnt[MAXN], ed; 	u64 sum; } b[320];  inline u64 qsum(int i) { 	return s[i] + bl.quary(i); } u64 calc(int x) { 	u64 ans = 0; int i; 	for (i = 1; i<=bn&&x>b[i].ed; ++i) 		ans += b[i].sum; 	if (i>bn) return ans; 	for (i = (i-1)*bsz+1; i<=x; ++i) 		ans += qsum(rig[i])-qsum(lef[i]-1); 	return ans; }  int main() { 	scanf("%d", &N); 	bsz = ceil(sqrt(N))+0.1; 	bn = (N-1)/bsz+1; 	rep(i, 1, N) 	{ 		scanf("%d", a+i), s[i] = s[i-1]+a[i]; 		be[i] = (i%bsz==1 ? i : be[i-1]); 	} 	rep(i, 1, N) scanf("%d%d", lef+i, rig+i); 	for (int i = 1, ed, id; i<=N; i+=bsz) 	{ 		id = i/bsz+1; 		b[id].ed = ed = min(N, i+bsz-1); 		memset(sum, 0, sizeof sum); 		rep(j, i, ed) sum[lef[j]]++, sum[rig[j]+1]--; 		rep(j, 1, N) sum[j] += sum[j-1], b[id].cnt[j] = sum[j]; 		rep(j, 1, N) b[id].sum += 1ll*a[j]*sum[j]; 	} 	scanf("%d", &Q); 	for (int op, l, r, t, id; Q--; ) 	{ 		scanf("%d", &op); 		if (op==1) 		{ 			scanf("%d%d", &l, &t); 			id = bid(l); 			rep(k, 1, bn) b[k].sum += 1ll*(t-a[l])*b[k].cnt[l]; 			bl.update(l, t-a[l]); 			a[l] = t; 		} 		else 		{ 			scanf("%d%d", &l, &r); 			printf("%llu\n", calc(r)-calc(l-1)); 		} 	} 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  const int MaxN = 3e3 + 10; const int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53}; const int Size = 16;  int lp[MaxN], pr[MaxN], sz; int dp[502][1 << Size]; int ord[MaxN];  int solve(int n, int m) {   int arr[MaxN] = {};   for (int i = 2; i <= n; ++i) {     int x = i;     while (x > 1) {       int e = lp[x], c = 0;       while (x % e == 0) {         x /= e;         c ^= 1;       }       arr[e] ^= c;     }   }   vector < pair < int, int > > all;   for (int i = 2; i <= n; ++i) {     bool ok = true;     int mx = 1, x = i;     while (x > 1) {       int c = 0, e = lp[x];       while (x % e == 0) {         x /= e;         c++;       }       if (c > 1 || arr[e] == 0) {         ok = false;       }       mx = max(mx, e);     }     if (ok == true) {       all.push_back(make_pair(mx, i));     }   }   sort(all.rbegin(), all.rend());   memset(ord, -1, sizeof(ord));   int cSize = 0;   for (int i = 0; i < Size; ++i) {     if (arr[primes[i]] == 1) {       ord[primes[i]] = cSize++;     }   }   memset(dp, 0, sizeof(dp));   dp[0][(1 << cSize) - 1] = 1;   int c = 0;   for (int i = 0, j; i < (int)all.size(); i = j, ++c) {     if (ord[all[i].first] == -1) {       for (j = i; j < (int)all.size() && all[i].first == all[j].first; ++j);       for (int k = i; k < j; ++k) {         for (int mask = 0; mask < 1 << cSize; ++mask) {           if (dp[c][mask] == 0) {             continue;           }           int nmask = mask, x = all[k].second;           bool ok = true;           while (x > 1) {             int e = lp[x];             if (ord[e] != -1) {               if (nmask & (1 << ord[e])) {                 nmask ^= 1 << ord[e];               } else {                 ok = false;               }             }             x /= e;           }           if (ok == true) {             dp[c + 1][nmask] = (dp[c + 1][nmask] + dp[c][mask]) % m;           }         }       }     } else {       j = i + 1;       for (int mask = 0; mask < 1 << cSize; ++mask) {         int nmask = mask, x = all[i].second;         bool ok = true;         while (x > 1) {           int e = lp[x];           if (ord[e] != -1) {             if (nmask & (1 << ord[e])) {               nmask ^= 1 << ord[e];             } else {               ok = false;             }           }           x /= e;         }         dp[c + 1][mask] = (dp[c + 1][mask] + dp[c][mask]) % m;         if (ok == true) {           dp[c + 1][nmask] = (dp[c + 1][nmask] + dp[c][mask]) % m;         }       }     }   }   return 2 * dp[c][0] % m; }  int main() { //  freopen("input.txt", "r", stdin);   for (int i = 2; i < MaxN; ++i) {     if (!lp[i]) {       lp[i] = pr[sz++] = i;     }     for (int j = 0; j < sz && i * pr[j] < MaxN && pr[j] <= lp[i]; ++j) {       lp[i * pr[j]] = pr[j];     }   }   int t;   scanf("%d", &t);   while (t --> 0) {     int n, m;     scanf("%d%d", &n, &m);     printf("%d\n", solve(n, m));   }   return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring> #include <algorithm> using namespace std;   #define rep(i,n) for(int i=0;i<(n);++i) #define clr(a,v) memset(a,v,sizeof(a))   int const max_n = 10100; int const max_m = 50100;   int par[max_n], lvl[max_n], cyc[max_n];   int root(int i){ if(par[i] != par[par[i]]) par[i] = root(par[i]); return par[i]; }   void merge(int a, int b){ if(lvl[a] < lvl[b]) par[a] = b, cyc[b] |= cyc[a]; else{ par[b] = a, cyc[a] |= cyc[b]; if(lvl[a] == lvl[b]) lvl[a]++; } }   struct edge_t{ int a, b, v; bool operator<(edge_t const &e) const { return v > e.v; } } edge[max_m];   void doit(){ int n, m; scanf("%d%d", &n, &m); rep(i, n+1) par[i] = i, lvl[i] = 0, cyc[i] = 0; rep(i, m) scanf("%d%d%d", &edge[i].a, &edge[i].b, &edge[i].v); sort(edge, edge + m); int res = 0, e = 0; rep(i, m){ int a = root(edge[i].a), b = root(edge[i].b); if(a != b){ if(!(cyc[a] && cyc[b])){ res += edge[i].v; e++; } merge(a, b); }else{ if(!cyc[a]){ res += edge[i].v; e++; cyc[a] = 1; } } } if(e < n) printf("impossible\n"); else printf("%d\n", res); }   int main(){ int t; scanf("%d", &t); while(t--) doit(); }
#include <bits/stdc++.h> #include <cstdio> using namespace std;  const int MAXN = 1e5 + 5; const int RN = 1e2 + 5;  int n , m ; long long int a[MAXN];  /* Author - code_hard123 */ /* JIIT */  struct Treap{     Treap * left , * right;     int priority;     int sz;     long long val , sum;     Treap(long long n){         left = NULL;         right = NULL;         priority = rand();         sz = 1;         val = n;     }     Treap(){        /* left = NULL;         right = NULL;         priority = -1;         sz = 0;         val = 0LL;         sum = 0LL; */     }     void initialize(long long u);     void up();  } *root , node[MAXN];  #define LOCALE 0 #define RRN 5  void Treap :: initialize(long long u){     left = NULL;     right = NULL;     priority = rand();     sz = 1;     val = u;     sum = u; }  void Treap :: up(){     sz = 1;     if(left != NULL) sz += left -> sz;     if(right != NULL) sz += right -> sz;     sum = 0;     int value = 0;     if(left != NULL){         sum += left -> sum;         value = left -> sz;     }     sum += value & 1 ? -val : val;     ++value;     if(right != NULL){         sum += value & 1 ? -(right -> sum) : (right -> sum);     } }  int ind = 0;  Treap * newTreap(int u){ node[ind].initialize(u); /*Treap * nextTreap = &node[ind]; ++ind; */ return &node[ind++]; }  Treap * merge(Treap * x , Treap * y){     if(x == NULL) return y;     if(y == NULL) return x;     if(x -> priority >= y -> priority){         x -> right = merge(x -> right , y);         x -> up();         return x;     }     else{     y -> left = merge(x , y -> left);     y -> up();     return y;     } }  void split(Treap * u , int ret , Treap * & x , Treap * & y){     if(ret <= 0) { x = NULL ; y = u; return; }     if(ret >= u -> sz)     {         x = u;         y = NULL;         return;     }      const int snd = u -> left != NULL ? u -> left -> sz : 0;     if(ret <= snd)     {         y = u;         split(u -> left , ret , x , u -> left);     }     else     {         x = u;         split(u -> right , ret - snd - 1 , u -> right , y);     }      u -> up(); }   void splitChild(Treap * u , long long k , Treap * & x , Treap * & y){     if(u == NULL){         x = NULL;         y = NULL;         return;     }      if(u -> val > k){         y = u;         splitChild(u -> left , k , x , u -> left);     }     else{         x = u;         splitChild(u -> right , k , u -> right , y);     }     u -> up(); }   void UNION(int u , long long weight){     Treap * x , * y;      splitChild(root , a[u] , root , y);     split(root , root -> sz - 1 , root , x);     root = merge(root , y);     a[u] = a[u] + weight;     x -> initialize(a[u]);      splitChild(root , a[u] , root , y);      root = merge(root , x );     root = merge(root , y ); }  int main() {     #ifndef LOCALE     fprintf(stderr , "error : file not found");     #endif // LOCALE     int tt;     scanf("%d" , &tt);     while(tt--){         scanf("%d %d" , &n, &m);         ind = 0;         root = NULL;         for(int i = 1; i <= n; ++i){             root = merge(root , newTreap(0));             a[i] = 0;         }         int u , v;         long long w;         while(m--){             scanf("%d %d %lld" , &u , &v , &w);             UNION(u , w);             UNION(v , w);             long long ans = root -> sum / 2;             if(root -> sz % 2 == 0) ans *= -1;             printf("%lld\n" , ans);         }     }     return 0; } 
#include <cstdio> #include <cstring> #include <queue> #include <algorithm> #include <limits> using namespace std;  const int DIG = 9, BASE = 1000000000; const unsigned long long OVER = numeric_limits <unsigned long long> :: max () - (unsigned long long) BASE * BASE;  struct bignum {     int D, digits [3];      inline void trim ()     {         while (D > 1 && digits [D - 1] == 0)             D--;     }      inline void init (long long x)     {         memset (digits, 0, sizeof (digits));         D = 0;          do         {             digits [D++] = x % BASE;             x /= BASE;         }         while (x > 0);     }      inline bignum (long long x)     {         init (x);     }      inline bignum (int x = 0)     {         init (x);     }      inline char *str ()     {         trim ();         char *buf = new char [DIG * D + 1];         int pos = 0, d = digits [D - 1];          do         {             buf [pos++] = d % 10 + '0';             d /= 10;         }         while (d > 0);          reverse (buf, buf + pos);          for (int i = D - 2; i >= 0; i--, pos += DIG)             for (int j = DIG - 1, t = digits [i]; j >= 0; j--)             {                 buf [pos + j] = t % 10 + '0';                 t /= 10;             }          buf [pos] = '\0';         return buf;     }      inline bignum operator + (const bignum &o) const     {         bignum sum = o;         int carry = 0;          for (sum.D = 0; sum.D < D || carry > 0; sum.D++)         {             sum.digits [sum.D] += (sum.D < D ? digits [sum.D] : 0) + carry;              if (sum.digits [sum.D] >= BASE)             {                 sum.digits [sum.D] -= BASE;                 carry = 1;             }             else                 carry = 0;         }          sum.D = max (sum.D, o.D);         sum.trim ();         return sum;     }      inline bignum operator - (const bignum &o) const     {         bignum diff = *this;          for (int i = 0, carry = 0; i < o.D || carry > 0; i++)         {             diff.digits [i] -= (i < o.D ? o.digits [i] : 0) + carry;              if (diff.digits [i] < 0)             {                 diff.digits [i] += BASE;                 carry = 1;             }             else                 carry = 0;         }          diff.trim ();         return diff;     }      inline bignum operator * (const bignum &o) const     {         bignum prod = 0;         unsigned long long sum = 0, carry = 0;          for (prod.D = 0; prod.D < D + o.D - 1 || carry > 0; prod.D++)         {             sum = carry % BASE;             carry /= BASE;              for (int j = max (prod.D - o.D + 1, 0); j <= min (D - 1, prod.D); j++)             {                 sum += (unsigned long long) digits [j] * o.digits [prod.D - j];                  if (sum >= OVER)                 {                     carry += sum / BASE;                     sum %= BASE;                 }             }              carry += sum / BASE;             prod.digits [prod.D] = sum % BASE;         }          prod.trim ();         return prod;     } };  const int LOG = 45, START = 5, BOUND = 5000; const long long BIG = (long long) 1e18;  int T; long long N, A, B; long long big [LOG], cache [LOG][BOUND];  inline long long binom (long long a, int b, bool check = false) {     if (b >= START)     {         if (a >= big [b])             return BIG;         else if (cache [b][a] != -1)             return cache [b][a];     }      long long val = 1;      for (int i = 0; i < b; i++)         if (check && (double) val * (a - i) > BIG)         {             val = BIG;             break;         }         else             val = val * (a - i) / (i + 1);      if (b >= START && a < big [b])     {         cache [b][a] = val;          if (val >= BIG)             big [b] = a;     }      return val; }  inline long long words (long long cost) {     long long total = 0;      for (int b = 0; b * B <= cost && total < N; b++)     {         long long a = (cost - b * B) / A;         total += binom (a + b + 1, b + 1, true);     }      return total; }  inline bignum sum (long long cost) {     bignum total = (bignum) N * (bignum) (A + B);     long long num = 0;      for (int b = 0; b * B <= cost; b++)     {         long long a = (cost - b * B) / A;         num += binom (a + b + 1, b + 1);         total = total + (bignum) (B * b) * (bignum) binom (a + b + 1, b + 1);         total = total + (bignum) (A * (b + 1)) * (bignum) binom (a + b + 1, b + 2);     }      total = total - (bignum) (num - N) * cost;     return total; }  int main () {     memset (cache, -1, sizeof (cache));      for (int i = 0; i < LOG; i++)         big [i] = BOUND;      for (scanf ("%d", &T); T > 0; T--)     {         scanf ("%lld %lld %lld", &A, &B, &N);         N--;          if (A > B)             swap (A, B);          if (N == 0)         {             printf ("%lld\n", A);             continue;         }          long long lo = 0, hi = B * (64 - __builtin_clzll (N));          while (lo < hi)         {             long long mid = (lo + hi) >> 1;              if (words (mid) < N)                 lo = mid + 1;             else                 hi = mid;         }          printf ("%s\n", sum (lo).str ());     }      return 0; }  
#include<cstdio> #include<cmath> inline int I(int &a) {  register int c; a=0; do c=getchar_unlocked(); while(c<'0');  do {  a=(a<<1)+(a<<3)+c-'0';  c=getchar_unlocked(); }while(c >= '0');} class Reaction { public: void read() { I(a); I(b); scanf("%lf",&ratio); I(t); } double ratio; int a, b, t; }; double t0[100][200], t1[100][100], s0[100], s1[100][2], sum[100], rem[100]; void computeS0(int n) { for (int i = 0; i < n; i++) t0[i][i] = 1.0-t0[i][i], t0[i][i+n] = 1.0; for (int y = 0; y < n; y++) for (int x = 0; x < n; x++) if (y != x) t0[y][x] = -t0[y][x]; int n2 = n*2; for (int y = 0; y < n; y++) { int y2 = y; while (y2 < n && fabs(t0[y2][y]) < 1e-9) y2++; if (y2 >= n) throw 2; if (y2 > y) for (int x = y; x < n2; x++) t0[y][x] += t0[y2][x]; for (int x = n2-1; x >= y; x--) t0[y][x] /= t0[y][y]; for (int j = 0; j < n; j++) if (j != y) { double f = -t0[j][y]; for (int x = y; x < n2; x++) t0[j][x] += f*t0[y][x]; } } for (int y = 0; y < n; y++) for (int x = 0; x < n; x++) s0[y] += t0[y][x+n]; } int main() { int n, k; I(n); I(k); for (int i = 0; i < n; i++) { scanf("%lf", rem+i); rem[i] = 1.0-rem[i]; t0[i][i] = rem[i]; } int m; I(m); Reaction r; for (int i = 0; i < m; i++) { r.read(); t0[r.a][r.a] -= rem[r.a]*r.ratio; if (r.t) t1[r.b][r.a] += rem[r.a]*r.ratio; else  t0[r.b][r.a] += rem[r.a]*r.ratio; } computeS0(n); for (int i = 0; i < n; i++) { s1[i][0] = s0[i]; sum[i] = s0[i]; } for (int t = 1; t < k; t++) { for (int y = 0; y < n; y++) { double d = 0.0; for (int x = 0; x < n; x++) d += s1[x][0]*t1[y][x]; s1[y][1] = d; } for (int y = 0; y < n; y++) { double d = 0.0; for (int x = 0; x < n; x++) d += s1[x][1]*t0[y][x+n]; s1[y][0] = d; sum[y] += d; } } printf("%.8lf", sum[0]); for (int i = 1; i < n; i++) printf(" %.8lf", sum[i]); printf("\n"); }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <algorithm> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <cstdlib> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cassert> #include <climits> //#include <ext/hash_map>   using namespace std; using namespace __gnu_cxx;    #define REP(i,n) for(int i = 0; i < int(n); ++i) #define REPV(i, n) for (int i = (n) - 1; (int)i >= 0; --i) #define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)  #define FE(i,t) for (__typeof((t).begin())i=(t).begin();i!=(t).end();++i) #define FEV(i,t) for (__typeof((t).rbegin())i=(t).rbegin();i!=(t).rend();++i)  #define two(x) (1LL << (x)) #define ALL(a) (a).begin(), (a).end()   #define pb push_back #define ST first #define ND second #define MP(x,y) make_pair(x, y)  typedef long long ll; typedef unsigned long long ull; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<string> vs;  template<class T> void checkmin(T &a, T b){if (b<a)a=b;} template<class T> void checkmax(T &a, T b){if (b>a)a=b;} template<class T> void out(T t[], int n){REP(i, n)cout<<t[i]<<" "; cout<<endl;} template<class T> void out(vector<T> t, int n=-1){for (int i=0; i<(n==-1?t.size():n); ++i) cout<<t[i]<<" "; cout<<endl;} inline int count_bit(int n){return (n==0)?0:1+count_bit(n&(n-1));} inline int low_bit(int n){return (n^n-1)&n;} inline int ctz(int n){return (n==0?-1:ctz(n>>1)+1);} int toInt(string s){int a; istringstream(s)>>a; return a;} string toStr(int a){ostringstream os; os<<a; return os.str();}  const int maxn=111111; const int maxq=33333;  int ca,cb;   struct treap{     int key;     int a[4], cnt, type;     treap *l, *r;     treap();     void copy(const treap*);     void update();     void get(int);  }tb[maxq*35];  int na; int res[4]; char buf[33333]; treap *root[maxn]; char rmp[255]; const char *str="AGTC";   inline int count(const treap *a){return a?a->cnt:0;}  void treap::copy(const treap *b){         REP(i,4) a[i]=b->a[i];         cnt=b->cnt;         type=b->type;         l=b->l; r=b->r;     }  treap::treap(){key=rand(); memset(a,0,sizeof(a)); cnt=1; l=r=0; type=0;}  void treap::update(){     cnt=1+count(l)+count(r);     REP(i,4) a[i]=0;     a[type]=1;     if (l) REP(i,4) a[i]+=l->a[i];     if (r) REP(i,4) a[i]+=r->a[i]; } void treap::get(int x){     int na=count(l);     if (na>x) l->get(x);     else{         if (l) REP(i,4) res[i]+=l->a[i];         if (na<x) ++res[type];         if (x-na>1) r->get(x-na-1);     } }   treap *merge0(treap *a, treap *b){     if (!a) return b;     if (!b) return a;     if (a->key<b->key){         a->r=merge0(a->r,b);         a->update();         return a;     }     b->l=merge0(a,b->l);     b->update();     return b; }  treap *merge(treap *a, treap *b){     if (!a) return b;     if (!b) return a;     if (a->key<b->key){         treap *u=tb+na++;         u->copy(a);         u->r=merge(u->r,b);         u->update();         return u;     }     treap *u=tb+na++;     u->copy(b);     u->l=merge(a,u->l);     u->update();     return u; } treap *split(treap *a, treap *&b, int x){     //    if (!x){b=a; return 0;}     //    if (x>a->cnt){b=0; return a;}     if (!a){b=0; return 0;}     treap *res;     treap *u=tb+na++;     u->copy(a);     int cl=count(u->l);     if (x<=cl) res=split(u->l,u->l,x),b=u;     else u->r=split(u->r,b,x-cl-1), res=u;     u->update();     return res; }  treap *chang(treap *a, int x){     treap *u=tb+na++;     u->copy(a);     ++u->a[cb];     int cl=count(u->l);     if (cl>=x) u->l=chang(u->l,x);     else if (x-cl>1) u->r=chang(u->r,x-cl-1);     else ca=u->type, u->type=cb;     --u->a[ca];     return u; }    int main(){     int n; cin>>n;     REP(i,4) rmp[str[i]]=i;      na=1;     REP(i,n){         scanf(" %s",buf);         int nx=strlen(buf);         treap *r=0;         REP(j,nx){             treap *a=tb+na++;             a->type=rmp[buf[j]];             a->a[a->type]=1;             r=merge0(r,a);         }         root[i+1]=r;     }     ++n;      int nq; cin>>nq;     REP(step,nq){         scanf(" %s",buf);         if (buf[1]=='O'){             int a,b,c; scanf(" %d%d%d",&a,&b,&c);             REP(i,4) res[i]=0;             if (root[a]){                 c=min(c,root[a]->cnt);                 if (b-1) root[a]->get(b-1);                 REP(i,4) res[i]=-res[i];                 root[a]->get(c);             }             REP(i,4) printf("%d ",res[i]); puts("");         }else if (buf[1]=='U'){             int a,b; char c;             scanf(" %d%d %c",&a,&b,&c);             cb=rmp[c];             root[a]=chang(root[a],b);         }else{             int a,b,c,d; scanf(" %d%d%d%d",&a,&b,&c,&d);             treap *u,*nu,*v,*nv;             u=split(root[a],nu,c);             v=split(root[b],nv,d);             root[n++]=merge(u,nv);             root[n++]=merge(v,nu);         }     }      return 0; }   
#include<iostream> #include<vector> #include<algorithm> #include<set> using namespace std;  struct Edge {   int x, y, w; };  struct Graph { // directed   vector<int> adj[1000];   Edge e[20000];   int ne;      void init(int _n) {     int i;          for (i = 0; i < _n; i ++) adj[i].clear();     ne = 0;   }      void ae(int _x, int _y, int _w) {     e[ne].x = _x; e[ne].y = _y; e[ne].w = _w;     adj[_x].push_back(ne);     ne ++;   } } g;  int n, m; vector<int> C; int f[500], d[1000], pre[1000];  void dijkstra(int s, int t) {   int x, y, dist;   vector<int>::iterator it; Edge edge;   set<pair<int, int> > heap;      fill(d,    d    + 2 * n, 1000000000);   fill(pre,  pre  + 2 * n, -1);   d[s] = 0;   heap.insert(make_pair(0, s));   while (!heap.empty()) {     x = (*heap.begin()).second;     heap.erase(heap.begin());     if (x == t || d[x] >= 1000) break;     for (it = g.adj[x].begin(); it != g.adj[x].end(); it ++) {       edge = g.e[*it];       y = edge.y, dist = d[x] + edge.w;       if (dist < d[y]) {         heap.erase (make_pair(d[y], y));         d[y] = dist; pre[y] = x;         heap.insert(make_pair(d[y], y));       }     }   } }  void simplify() {   int a, b, l, sz;   static int fst[10000];      fill(fst, fst + n, -1);   sz = C.size();   for (b = 0; b < sz; b ++) {     a = fst[C[b]];     if (a == -1) fst[C[b]] = b;     else {       l = b - a;       C.erase(C.begin(),     C.begin() + a);       C.erase(C.begin() + l, C.end());       break;     }   } }  bool solve() {   int i, j, x, y, w;   double tmp;   bool wrong;      C.clear();   cin >> n >> m;   for (i = 0; i < n; i ++) {     cin >> tmp;     f[i] = (int) (tmp * 1000 + 0.5);   }   g.init(2 * n);   wrong = false;   for (i = 0; i < m; i ++) {     cin >> x >> y;     if (f[x] + f[y] > 1000 && !wrong) {       wrong = true;       C.push_back(x);       C.push_back(y);     }     if (f[x] && f[y]) {       w = 1000 - f[x] - f[y];       g.ae(x,     y + n, w);       g.ae(y + n, x,     w);       g.ae(y,     x + n, w);       g.ae(x + n, y,     w);     }   }   if (wrong) return false;   for (i = 0; i < n; i ++) {     dijkstra(i, i + n);     if (pre[i + n] == -1) continue;     /**      * (2k + 1) * 1000 - sum (i=0..2k) [f(v_i) + f(v_{(i + 1) % (2k + 1)})] < 1000      * <=>      * (2k + 1) * 1000 - 2 * sum (i=0..2k) [f(v_i)] < 1000      * <=>      * sum(i=0..2k) [f(v_i)] > k * 1000      */     if (d[i + n] >= 1000) continue;     j = i + n; while (j != i) C.push_back(j % n), j = pre[j];     simplify();     return false;   }   return true; }  int main() {   int t;   vector<int>::iterator it;      C = vector<int>();   cin >> t;   while (t --) {     bool ok = solve();     if (ok) cout << "Ok" << endl;     else {       cout << "Bad Cycle:";       for (it = C.begin(); it != C.end(); it ++) cout << " " << *it;       cout << " -1" << endl;     }   } } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 200050 #define INF 0x7f7f7f7f int ln[N][2],qu[N][2],sg[N],Cnt[N*4],Ans[N],t,n,m,p; struct Node  {  	Node *c[2],*fa,*rf;int mi,val;bool fz;  } a[N*2],*emp,Emp; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } void Set_up(int x,int y,int z)  {  	int mid = x + y >> true, j = z << true;Cnt[z] = false;  	if (x!=y) Set_up(x,mid,j),Set_up(mid+1,y,j+1);  	return;  } void Modify(int x,int y,int z,int o,int p)  {  	int mid = x + y >> true, j = z << true;Cnt[z] += p;  	if (x!=y) if (o<=mid) Modify(x,mid,j,o,p); else  	  Modify(mid+1,y,j+1,o,p);  	return;  } int Query(int x,int y,int z,int o,int p)  {  	int mid = x + y >> true, j = z <<true;  	if (x==o&&y==p) return Cnt[z]; else  	 if (p<=mid) return Query(x,mid,j,o,p); else  	  if (o>mid) return Query(mid+1,y,j+1,o,p); else  	    return Query(x,mid,j,o,mid)+Query(mid+1,y,j+1,mid+1,p);  } inline void GetNew(Node* x)  {  	x->c[0]=x->c[1]=x->fa=x->rf=emp;  	x->mi=x->val=INF;x->fz=false;  	return;  } void Update(Node* x)  {x->mi=min(x->val,min(x->c[0]->mi,x->c[1]->mi));} inline void fzj(Node* x)  {  	if (!x->fz||x==emp) return;  	swap(x->c[0],x->c[1]);x->fz=false;  	x->c[0]->fz=!x->c[0]->fz;  	x->c[1]->fz=!x->c[1]->fz;  	return;  } void Rotate(Node* x)  {  	Node *i=x->fa,*j=i->fa;bool flag = i->c[0]==x;  	if (j==emp) x->rf=i->rf,i->rf=emp; else  	  j->c[j->c[1]==i]=x;  	if (x->c[flag]!=emp) x->c[flag]->fa=i;  	i->c[!flag]=x->c[flag];i->fa=x;  	x->c[flag]=i;x->fa=j;Update(i);  	return;  } void Up(Node* x)  {if (x->fa!=emp) Up(x->fa);fzj(x);fzj(x->c[0]);fzj(x->c[1]);} void Splay(Node* x)  {  	Up(x);  	while (x->fa!=emp)  	 {  	 	if (x->fa->fa!=emp)  	 	  Rotate((x->fa->fa->c[0]==x->fa)^(x->fa->c[0]==x)?  	 	  	x:x->fa);  	 	Rotate(x);  	 }  	Update(x);  	return;  } void Access(Node* x)  {  	Node* k=emp;  	while (x!=emp)  	 {  	 	Splay(x);  	 	x->c[1]->rf=k->fa=x;  	 	x->c[1]->fa=k->rf=emp;  	 	x->c[1]=k;Update(x);  	 	k=x;x=x->rf;  	 }  	return;  } void Cg_Rt(Node* x)  {Access(x);Splay(x);x->fz = true;Up(x);return;} void Line(Node* x,Node* y,int z)  {  	GetNew(&a[z]);Cg_Rt(x);Cg_Rt(y);  	a[z].val=a[z].mi=z-n;x->rf=y->rf=&a[z];  	return;  } Node* Get(Node* x)  {return x->mi==x->val?x:Get(x->c[x->c[0]->mi>x->c[1]->mi]);} void Delete(Node* x,Node* y)  {  	Cg_Rt(x);Cg_Rt(y);  	y->c[1]=emp;x->fa=emp;Update(y);  	return;  } inline bool cmp(int x,int y) {return qu[x][1]<qu[y][1];} int main()  {  	t=Read();  	emp=&Emp;emp->c[0]=emp->c[1]=emp->fa=emp->rf=emp;  	emp->mi=emp->val=INF;  	while (t--)  	 {  	 	n=Read();m=Read();p=Read();  	 	for (int i=1;i<=n;i++) GetNew(&a[i]);  	 	for (int i=1;i<=m;i++)  	 	  ln[i][0]=Read(),ln[i][1]=Read();  	 	for (int i=1;i<=p;i++)  	 	  qu[i][0]=Read(),qu[i][1]=Read(),sg[i]=i;  	 	sort(sg+1,sg+p+1,cmp);Set_up(1,m,1);  	 	int Now=true;  	 	for (int i=1;i<=m&&Now<=p;i++)  	 	 {  	 	 	if (ln[i][0]!=ln[i][1])  	 	 	 {  	 	 	 	Cg_Rt(&a[ln[i][0]]);Cg_Rt(&a[ln[i][1]]);  	 	 	 	if (a[ln[i][0]].fa!=emp)  	 	 	 	 {  	 	 	 	 	Node* k=Get(&a[ln[i][1]]);  	 	 	 	 	Modify(1,m,1,k->val,-1);  	 	 	 	 	Delete(k,&a[ln[k->val][0]]);  	 	 	 	 	Delete(k,&a[ln[k->val][1]]);  	 	 	 	 }  	 	 	 	Line(&a[ln[i][0]],&a[ln[i][1]],i+n);  	 	 	 	Modify(1,m,1,i,1);  	 	 	 }  	 	 	while (Now<=p&&qu[sg[Now]][1]==i)  	 	 	  Ans[sg[Now]]=n-  	 	 	   Query(1,m,1,qu[sg[Now]][0],qu[sg[Now]][1]),  	 	 	  Now++;  	 	 }  	 	for (int i=1;i<=p;i++) printf("%d\n",Ans[i]);  	 }  	return 0;  }
#include<cstdio> #include<algorithm> #include<cstring> #include<iostream> #include<cstdlib> #include<cmath> #include<vector> #include<map> #include<set> #include<queue> #include<bitset> using namespace std; typedef long long ll; typedef double db; const db pi=acos(-1); void gn(int &x){ 	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-'); 	if(c=='-')sg=-1,x=0;else x=c-'0'; 	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0'; 	x*=sg; } void gn(ll &x){ 	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-'); 	if(c=='-')sg=-1,x=0;else x=c-'0'; 	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0'; 	x*=sg; } const int mo=1000000007; const int inf=1061109567; //const ll inf=1000000000000000000ll; int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;} int gcd(int a,int b){return b?gcd(b,a%b):a;} int dx[4]={1,0,-1,0}; int dy[4]={0,1,0,-1}; #define x1 x192837465 #define x2 x123456789 #define y1 y192837465 #define y2 y123456789 struct edge{ 	int v,next,w; }e[222222];int g[111111];int etot; void ae(int u,int v,int w){ 	e[etot].v=v;e[etot].w=w;e[etot].next=g[u];g[u]=etot++; } int n; struct val{ 	int i,w; 	set<int>se; }a[222222];  void ad(int x,int y){ 	if(a[y].se.size()>a[x].se.size()){ 		a[x].se.swap(a[y].se); 		swap(a[x].i,a[y].i); 		swap(a[x].w,a[y].w); 	} 	a[x].i+=a[y].i; 	for (set<int>::iterator it=a[y].se.begin();it!=a[y].se.end();it++){ 		int d=*it; 		int tmp=a[y].w-a[x].w+d; 		while(a[x].se.find(tmp)!=a[x].se.end()  && d+a[y].w<0)a[x].se.erase(tmp),d++,tmp++; 		if(d+a[y].w==0)a[x].i++; 		else a[x].se.insert(tmp); 	} } void sr(int x,int k){ 	for (int i=0;i<k;i++){ 		if(a[x].i&1)a[x].se.insert(i-a[x].w); 		a[x].i>>=1; 	} 	a[x].w-=k; } void ad0(int u){ 	int del=1-a[u].i; 	if(a[u].se.empty())del++; 	del=max(del,1); 	a[u].i+=del; 	sr(u,del-1); } void ad1(int u){ 	int del=a[u].i+2; 	del=max(del,1); 	a[u].i-=del; 	sr(u,del-1); } void dfs(int u,int pr){ 	for (int i=g[u];~i;i=e[i].next)if(e[i].v!=pr){ 		dfs(e[i].v,u); 		if(e[i].w==0)ad0(e[i].v); 		else ad1(e[i].v); 		ad(u,e[i].v); 	} } int main() { 	int tes; 	gn(tes); 	while(tes--){ 		gn(n); 		for (int i=1;i<=n;i++)g[i]=-1; 		for (int i=1;i<=n;i++){ 			a[i].se.clear(); 			a[i].i=a[i].w=0; 		} 		etot=0; 		for (int i=1;i<n;i++){ 			int u,v,w; 			gn(u);gn(v);gn(w); 			ae(u,v,w); 			ae(v,u,w); 		} 		dfs(1,0); 		if(a[1].i==0 && a[1].se.empty()){ 			printf("Ksen Chef\n"); 		}else if(a[1].i>=0){ 			printf("Chef Chef\n"); 		}else printf("Ksen Ksen\n"); 	} 	return 0; } 
#include <cstdio> #include <algorithm> #include <vector> #include <stack> typedef unsigned int uint; int const inf=1e9;   enum endl_faszom { endl }; template <size_t max_input_size,size_t max_output_size> struct fast_io { 	fast_io(): input_size(0), s(input), d(output) 	{ 		read(); 	} 	~fast_io() 	{ 		write(); 	} 	void read() 	{ 		input_size=fread(input,1,max_input_size,stdin); 		input[input_size]=0; 		s=input; 	} 	void write() 	{ 		fwrite(output,1,d-output,stdout); 		d=output; 	} 	void skip_blank() 	{ 		while(0<*s && *s<=32) 			++s; 	} 	uint read_uint() 	{ 		uint r=0; 		while('0'<=*s && *s<='9') 			r=r*10+ *s++ -'0'; 		return r; 	} 	int read_int() 	{ 		int r=0; 		bool neg=0; 		if(*s=='-' || *s=='+') 			neg=*s++=='-'; 		while('0'<=*s && *s<='9') 			r=r*10+ *s++ -'0'; 		return neg?-r:r; 	} 	fast_io& operator>> (uint &r) 	{ 		skip_blank(); 		r=read_uint(); 		return *this; 	} 	fast_io& operator>> (int &r) 	{ 		skip_blank(); 		r=read_int(); 		return *this; 	} 	fast_io& operator<< (uint x) 	{ 		char buf[32],*e=buf+32,*p=e; 		while(*--p='0'+x%10,x/=10,x); 		while(p!=e) 			*d++=*p++; 		return *this; 	} 	fast_io& operator<< (int x) 	{ 		if(x<0) 		{ 			*d++='-'; 			return operator<< (uint(-x)); 		} 		else return operator<< (uint(x)); 	} 	fast_io& operator<< (endl_faszom x) 	{ 		*d++='\n'; 		return *this; 	} 	fast_io& operator>> (char &r) 	{ 		r=*s++; 		return *this; 	} 	fast_io& operator<< (char c) 	{ 		*d++=c; 		return *this; 	} 	fast_io& operator<< (char const *p) 	{ 		while(*p) 			*d++=*p++; 		return *this; 	} 	size_t input_size; 	char input[max_input_size+1]; 	char const *s; 	char output[max_output_size+1]; 	char *d; }; fast_io<8*1024*1024,8*1024*1024> io;   struct dist { 	dist(): d(-inf), id(0) {} 	dist(int _d, uint _id): d(_d), id(_id) {} 	friend bool operator< (dist const &lhs, dist const &rhs) 	{ 		return lhs.d<rhs.d || lhs.d==rhs.d && lhs.id<rhs.id; 	} 	dist operator+ (int x) const { return dist(d+x,id); } 	dist operator- (int x) const { return dist(d-x,id); } 	int d; 	uint id; };   struct rmq_max_dist { 	rmq_max_dist(): B(0), max() {} 	rmq_max_dist(uint size): B(1), max() 	{ 		while(B<size) 			B*=2; 		max.resize(2*B); 	} 	void reset(uint size) 	{ 		B=1; 		while(B<size) 			B*=2; 		max.clear(); 		max.resize(2*B); 	} 	void update(uint n, dist x) 	{ 		max[B+n]=x; 		for(uint u=B+n; u/=2;) 			max[u]=std::max(max[2*u],max[2*u+1]); 	} 	dist total() const { return max[1]; } 	dist operator() (uint b, uint e) const 	{ 		uint f=b+B; 		uint l=e+B-1; 		dist r=std::max(max[f],max[l]); 		for(; 1<(f^l); f/=2,l/=2) 		{ 			if(~f&1 && r<max[f+1]) 				r=max[f+1]; 			if(l&1 && r<max[l-1]) 				r=max[l-1]; 		} 		return r; 	} 	uint B; 	std::vector<dist> max; };   struct tree { 	struct chain 	{ 		chain(): nodes(), max_up(), max_down() {} 		std::vector<uint> nodes; 		rmq_max_dist max_up, max_down; 	}; 	struct node 	{ 		node(): 			parent(0), parent_adj_ix(0), white(1), heavy(0), head(0), offset(0),  			size(0), max_lazy(), adj() 		{} 		uint parent; 		uint parent_adj_ix; 		bool white; 		bool heavy; 		uint head; 		uint offset; 		uint size; 		rmq_max_dist max_lazy; 		std::vector<uint> adj; 	}; 	tree(): size(0), nodes(), chains() {} 	void reset(uint _size) 	{ 		size=_size; 		nodes.clear(); 		nodes.resize(size); 		chains.clear(); 		chains.resize(size); 	} 	void dfs1() 	{ 		std::stack<uint> q; 		std::vector<int> s(size,0); 		q.push(0); 		while(!q.empty()) 		{ 			uint n=q.top(); 			if(s[n]==0) 			{ 				s[n]=1; 				for(uint i=0; i<nodes[n].adj.size(); ++i) 				{ 					uint u=nodes[n].adj[i]; 					nodes[u].parent=n; 					nodes[u].parent_adj_ix=i; 					q.push(u); 				} 			} 			else if(s[n]==1) 			{ 				s[n]=2; 				q.pop(); 				nodes[n].size=1; 				uint ms=0,msa=0; 				for(uint i=0; i<nodes[n].adj.size(); ++i) 				{ 					uint u=nodes[n].adj[i]; 					nodes[n].size+=nodes[u].size; 					if(ms<nodes[u].size) 					{ 						ms=nodes[u].size; 						msa=u; 					} 				} 				if(ms) 					nodes[msa].heavy=1; 			} 		} 	} 	void dfs2() 	{ 		std::stack<uint> q; 		std::vector<int> s(size,0); 		q.push(0); 		while(!q.empty()) 		{ 			uint n=q.top(); 			q.pop(); 			uint p=nodes[n].parent; 			uint h=nodes[n].heavy?nodes[p].head:n; 			nodes[n].head=h; 			chain &c=chains[h]; 			uint o=c.nodes.size(); 			c.nodes.push_back(n); 			nodes[n].offset=o;   			for(uint i=0; i<nodes[n].adj.size(); ++i) 				q.push(nodes[n].adj[i]); 		} 	} 	void dfs3(uint n=0) 	{ 		std::stack<uint> q; 		std::vector<int> s(size,0); 		std::vector<dist> d(size); 		q.push(0); 		while(!q.empty()) 		{ 			uint n=q.top(); 			if(s[n]==0) 			{ 				s[n]=1; 				uint o=nodes[n].offset; 				chain &c=chains[nodes[n].head]; 				uint cs=c.nodes.size(); 				if(o==0) 				{ 					c.max_up.reset(cs); 					c.max_down.reset(cs); 				} 				nodes[n].white=1; 				nodes[n].max_lazy.reset(nodes[n].adj.size()); 				for(uint i=0; i<nodes[n].adj.size(); ++i) 					q.push(nodes[n].adj[i]); 			} 			else if(s[n]==1) 			{ 				s[n]=2; 				q.pop(); 				for(uint i=0; i<nodes[n].adj.size(); ++i) 				{ 					uint u=nodes[n].adj[i]; 					if(!nodes[u].heavy) 						nodes[n].max_lazy.update(i,d[u]); 				} 				dist max_lazy=nodes[n].max_lazy.total(); 				dist max(0,n); 				if(max<max_lazy) 					max=max_lazy; 				uint o=nodes[n].offset; 				chain &c=chains[nodes[n].head]; 				uint cs=c.nodes.size(); 				c.max_down.update(o,max+o); 				c.max_up.update(o,max+(cs-o)); 				if(o==0) 					max=c.max_down.total(); 				d[n]=max+1; 			} 		} 	} 	void setup() 	{ 		dfs1(); 		dfs2(); 		dfs3(); 	} 	uint query(uint n) 	{ 		uint pai=0; 		dist max(0,n); 		nodes[n].white=!nodes[n].white; 		uint d=0; 		dist max_down; 		while(1) 		{ 			uint h=nodes[n].head; 			uint o=nodes[n].offset; 			chain &c=chains[h]; 			uint cs=c.nodes.size(); 			if(d) 			{ 				nodes[n].max_lazy.update(pai,dist()); 				max=std::max(max,nodes[n].max_lazy.total()+d); 				nodes[n].max_lazy.update(pai,max_down); 			} 			else max=std::max(max,nodes[n].max_lazy.total()+d); 			max_down=nodes[n].max_lazy.total(); 			if(nodes[n].white) 			{ 				max=std::max(max,dist(d,n)); 				max_down=std::max(max_down,dist(0,n)); 			} 			if(o+1<cs) 				max=std::max(max,c.max_down(o+1,cs)-o+d); 			if(0<o) 				max=std::max(max,c.max_up(0,o)-(cs-o)+d); 			c.max_down.update(o,max_down+o); 			c.max_up.update(o,max_down+(cs-o)); 			d+=o+1; 			max_down=c.max_down.total()+1; 			pai=nodes[h].parent_adj_ix; 			n=nodes[h].parent; 			if(h==0) 				break; 		} 		return max.id; 	}   	uint size; 	std::vector<node> nodes; 	std::vector<chain> chains; };   main() { 	uint T; 	io >> T; 	tree g; 	for(uint t=1; t<=T; ++t) 	{ 		uint N,M; 		io >> N >> M; 		g.reset(N); 		for(uint n=2; n<=N; ++n) 		{ 			uint p; 			io >> p; 			g.nodes[p-1].adj.push_back(n-1); 		} 		g.setup(); 		for(uint i=0; i<M; ++i) 		{ 			uint n; 			io >> n; 			io << g.query(n-1)+1 << endl; 		} 	} }  
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> #include <set> #include <queue> using namespace std; #define N 405 #define M 200050 #define INF 0x3f7f7f7f #define PII pair <int,int> #define fr first #define sc second #define mp make_pair queue <int> __; int fi[M],c[M*4][3],val[2][N],Prime[M],Cnt[2][N],li[2][N][10]; int _li[M][10],_C[M],Num[M],h[M];bool b[M]; int S=M-1,T=M-2,ss,n,m,t,st,ans; set <PII> __li;set <PII> :: iterator it; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Line(int x,int y,int z)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;c[ss][2]=z;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;c[ss][2]=false;  } int gcd(int x,int y) {return !y?x:gcd(y,x%y);} int Gcd(int x,int y)  {  	int z = true,le = true,ri = true;  	while (le <= Cnt[0][x]&&ri <= Cnt[1][y])  	 {  	 	int k = Prime[li[0][x][le]], l = Prime[li[1][y][ri]];  	 	if (k==l)  	 	  z=z*k,le++,ri++; else  	 	if (k<l) le++; else ri++;  	 }  	return z;  } void _Line(int x,int y,int z)  {  	int le = true,ri = true;  	while (le <= Cnt[0][x]&&ri <= Cnt[1][y])  	 {  	 	int k = Prime[li[0][x][le]], l = Prime[li[1][y][ri]];  	 	if (k==l)  	 	  _li[z][++_C[z]] = li[0][x][le],le++,ri++; else  	 	if (k<l) le++; else ri++;  	 }  	return;  } void Pretreat()  {  	st=false;  	for (int j=0;j<2;j++)  	 for (int i=1;i<=n;i++)  	  {  	  	 int e=val[j][i];  	  	 for (int k=2;k*k<=e;k++)  	  	  if (e%k==0)  	  	   {  	  	   	  Prime[++st] = k;  	  	   	  while (e%k==0) e/=k;  	  	   }  	  	 if (e>1) Prime[++st] = e;  	  }  	sort(Prime+1,Prime+st+1);  	int _Cnt=false,_st=false;  	for (int i=1;i<=st;i++)  	 {  	 	_Cnt+=Prime[i]!=Prime[i-1];  	 	Prime[_Cnt]=Prime[i];  	 }  	st = _Cnt;  	for (int j=0;j<2;j++)  	 for (int i=1;i<=n;i++)  	  {  	  	 Cnt[j][i] = false;  	  	 for (int k=1;k<=st;k++)  	  	  if (val[j][i]%Prime[k]==false)  	  	  	li[j][i][++Cnt[j][i]] = k;  	  }  	__li.clear();  	for (int i=1;i<=n;i++)  	 for (int j=1;j<=n;j++)  	  {  	  	 int k = Gcd(i,j),l = val[0][i] < val[1][j] ? k : -k;  	  	 if (k == 1 || val[0][i] == val[1][j]) continue;  	  	 it = __li.lower_bound(mp(l,0));  	  	 if (it != __li.end() && it->fr == l)  	  	  {  	  	  	 Num[it -> sc] ++;continue;  	  	  } else  	  	 _st ++;_C[_st] = false;Num[_st] = true;  	  	 _Line (i,j,_st);b[_st] = l < 0;  	  	 __li.insert(mp(l,_st));  	  }  	for (int i=1;i<=_st;i++)  	 if (b[i])  	  {  	  	 Line(S,i+st,Num[i]);  	  	 for (int j=1;j<=_C[i];j++)  	  	   Line(i+st,_li[i][j],INF);  	  } else  	  {  	  	 Line(i+st,T,Num[i]);  	  	 for (int j=1;j<=_C[i];j++)  	  	   Line(_li[i][j],i+st,INF);  	  }  	return;  } bool BFS()  {  	__.push(S);  	memset(h,false,sizeof h);h[S] = true;  	while (!__.empty())  	 {  	 	int k=__.front();__.pop();  	 	for (int i=fi[k];i;i=c[i][1])  	 	 if (c[i][2]&&!h[c[i][0]])  	 	   h[c[i][0]]=h[k]+1,__.push(c[i][0]);  	 }  	return h[T] > 0;  } int DFS(int x,int y)  {  	if (x==T) return y;  	int k,l = false;  	for (int i=fi[x];i&&y;i=c[i][1])  	 if (c[i][2]&&h[c[i][0]]==h[x]+1)  	  {  	  	 k = DFS(c[i][0],min(y,c[i][2]));  	  	 if (k) l+=k,y-=k,c[i^1][2]+=k,c[i][2]-=k;  	  }  	return l;  } int main()  {  	//freopen("input.txt","r",stdin);  	t=Read();  	while (t--)  	 {  	 	memset(fi,false,sizeof fi);  	 	ss=true;n=Read();ans=false;  	 	for (int j=0;j<2;j++)  	 	 for (int i=1;i<=n;i++) val[j][i]=Read();  	 	Pretreat();  	    while (BFS()) ans+=DFS(S,INF);  	    cout <<ans<<endl;  	 }  	return 0;  }
#include <cstdio> #include <cstring> #include <algorithm> #include <string> #include <map> #include <iostream> #include <vector>  using namespace std; #define ll long long  #define MAXN 100005  int n; std::vector<int> ady[MAXN], GT[MAXN], dom[MAXN]; int order[MAXN], dfnumber[MAXN], father[MAXN], ndfs; int idom[MAXN], semi[MAXN];  int C[MAXN], low[MAXN];  inline void preprocessing() { 	ndfs = 0; 	for (int i = 1; i <= n; ++i) { 		dfnumber[i] = father[i] = 0; 		C[i] = low[i] = semi[i] = i; 		ady[i].clear(); 		GT[i].clear(); 		dom[i].clear(); 	} }  void dfs(int v) { 	order[ dfnumber[ v ] = ++ndfs ] = v; 	for (std::vector<int>::iterator it = ady[v].begin(); it != ady[v].end(); ++it) { 		int u = *it; 		if (!dfnumber[ u ]) { 			dfs( u ); 			father[ dfnumber[ u ] ] = dfnumber[ v ]; 		} 	} }  inline int eval(int x) { 	if (x == C[x]) return x; 	int y = eval(C[x]); 	if (semi[low[x]] > semi[low[C[x]]]) low[x] = low[C[x]]; 	return C[x] = y; }  void tarjan(int s) { 	for (int i = n; i > 1; --i) { 		for (std::vector<int>::iterator it = GT[ order[i] ].begin(); it != GT[ order[i] ].end(); ++it) { 			int j = dfnumber[ *it ]; 			if (!j) continue; 			eval(j); 			semi[i] = min( semi[i] , semi[low[j]] ); 		} 		dom[ semi[i] ].push_back(i); 		int p = C[i] = father[i]; 		for (std::vector<int>::iterator it = dom[p].begin(); it != dom[p].end(); ++it) { 			int j = *it; 			eval(j); 			idom[j] = (semi[ low[j] ] < p ? low[j] : semi[j]); 		} 		dom[p].clear(); 	} 	for (int i = 1; i <= n; i++) { 		if (idom[i] != semi[i]) 			idom[i] = idom[ idom[i] ]; 	} 	idom[s] = 0;  	for(int i=1;i <= n;i++){ 		if ( idom[ i ] == 0) continue; 		dom[ order[ idom[i] ] ].push_back( order[ i ] ); 	} }  int ROOT;  int SIZE[MAXN]; ll sum,sqr; void solve(int v){ 	SIZE[v] = 1; 	for(int i=dom[v].size()-1;i>=0;i--){ 		int u = dom[v][i]; 		if (v == u) continue; 		solve( u ); 		SIZE[v] += SIZE[u];  		if (v == dfnumber[ ROOT ]){ 			sum += SIZE[u]; 			sqr += (ll)SIZE[u] * (ll)SIZE[u]; 		} 	} }  int main() { 	cin.sync_with_stdio(0); 	cin.tie(0);  	int m,v,u; 	cin >> n >> m; 	preprocessing(); 	while( m-- ) { 		cin >> v >> u; 		ady[ v ].push_back( u ); 		GT[ u ].push_back( v ); 	} 	ROOT = 1;  	dfs( ROOT ); 	tarjan( ROOT );  	solve( ROOT );  	ll ans = 0; 	ans += SIZE[ ROOT ] - 1; 	ans += ( sum*sum - sqr ) / 2; 	cout << ans << endl;  	return 0; } 
    #include<stdio.h>     #define M 1000000007     int main()     {     int t;     scanf("%d",&t);     while(t--)     {     int n,m;     scanf("%d%d",&n,&m);     if(n<=4)     {     if((n==1)&&(m==0))puts("1");     else if((n==2)&&(m==1))puts("1");     else if((n==3)&&(m==3))puts("1");     else if((n==4)&&(m==4))puts("3");     else if((n==4)&&(m==5))puts("6");     else if((n==4)&&(m==6))puts("1");     else puts("0");     }     else     {     if((m==(2*(n-2)))||(m==(2*(n-2)+1)))     printf("%d\n",(n*(n-1)/2)%M);     else     puts("0");     }     }     return 0;     } 
#pragma comment(linker,"/STACK:256000000") #include <iostream> #include <cstdio> #include <algorithm> #include <complex> #include <vector> #include <set> #include <map> #include <queue> #include <cstdlib> #include <cstring> #include <memory.h> using namespace std; #define sz(v) ((int)(v).size()) #define forn(i,n) for(int i=0;i<(n);++i) #define forv(i,v) forn(i,sz(v)) #define pb push_back #define mp make_pair #define istr stringstream #define fi first #define se second #define X first #define Y second #define clr(a,v) memset((a),(v),sizeof(a)) #define y0 asdy0 #define y1 asdy1 #define j0 asdj0 #define j1 asdj1 #define next asdnext #define prev asdprev #define link asdlink #define unlink asdunlink #define left asdleft #define right asdright #define hash asdhash #define div asddiv #define all(v) (v).begin(),(v).end() typedef long long lng; typedef unsigned int uint; typedef unsigned long long ulng; typedef unsigned char uchar; typedef double ld; typedef pair<int,int> PII; typedef pair<ld,ld> PDD; typedef pair<lng,lng> PLL; typedef complex<double> com; const ld PI=3.1415926535897932384626433832795; const ld EPS=1e-12; const int inf=1000000000; const lng linf=1000000000000000000LL; template<class T> inline T sqr(T x) { return x * x; } int gcd(int a,int b){return a?gcd(b%a,a):b;}   set<PLL> st; typedef set<PLL>::iterator iter;   void print(lng x){ 	return; 	cout<<x<<": "<<endl; 	for(iter it=st.begin();it!=st.end();++it){ 		cout<<it->X<<' '<<it->Y<<endl; 	} 	cout<<endl; }   iter merge(iter it){ 	while(true){ 		iter it2=it; 		++it2; 		if(it2==st.end()) 			return it; 		if(it2->X>it->Y) 			return it; 		lng b=it->X; 		lng e=it2->Y; 		st.erase(it); 		st.erase(it2); 		pair<iter,bool> p=st.insert(mp(b,e)); 		it=p.X; 	} }   vector<int> solve(vector<PII> pts,vector<PII> qs){ 	int n=sz(pts); 	typedef map<lng,vector<lng> > themap; 	themap evs; 	map<PLL,vector<int> > qus; 	forn(i,n){ 		evs[pts[i].X].pb(pts[i].Y); 	} 	int q=sz(qs); 	forn(i,q){ 		qus[qs[i]].pb(i); 		if(!evs.count(qs[i].X)) 			evs[qs[i].X]=vector<lng>(); 	} 	vector<int> res(q,1); 	st.clear(); 	lng px=0; 	for(themap::iterator it=evs.begin();it!=evs.end();++it){ 		lng x=it->X; 		vector<lng> &ys=it->Y; 		ys.pb(linf*2); 		sort(all(ys)); 		lng dt=x-px; 		print(x); 		while(dt>0){ 			if(st.empty() || st.begin()->X != 0){ 				st.insert(mp(0,0)); 			} 			iter it1=st.begin(); 			iter it2=it1; 			++it2; 			if(it2!=st.end() && it2->X-it1->Y<=dt){ 				dt-=it2->X-it1->Y; 				lng b=it1->X; 				lng e=it2->Y; 				st.erase(it1); 				st.erase(it2); 				st.insert(mp(b,e)); 			}else{ 				lng b=it1->X; 				lng e=it1->Y+dt; 				st.erase(it1); 				st.insert(mp(b,e)); 				dt=0; 			} 		} 		print(x); 		forv(i,ys){ 			lng y=ys[i]; 			iter it1=st.upper_bound(mp(y,linf*2)); 			if(it1==st.begin()) 				continue; 			--it1; 			if(it1->Y<=y) 				continue; 			lng b1=it1->X; 			lng e1=y; 			lng b2=y+1; 			lng e2=it1->Y; 			st.erase(it1); 			if(e1>b1) 				st.insert(mp(b1,e1)); 			if(e2>b2) 				st.insert(mp(b2,e2)); 		} 		print(x); 		lng py=0; 		forv(i,ys){ 			lng y=ys[i]; 			lng z=-1; 			if(y>py){ 				iter it1=st.upper_bound(mp(py,linf*2)); 				if(it1==st.begin()){ 					z=py; 				}else{ 					--it1; 					it1=merge(it1); 					if(it1->Y<y) 						z=max(it1->Y,py); 				} 				if(z!=-1){ 					if(qus.count(mp(x,z))){ 						vector<int> &vv=qus[mp(x,z)]; 						forv(t,vv){ 							res[vv[t]]=0; 						} 					} 					st.insert(mp(z,z+1)); 				} 			} 			py=y+1; 		} 		px=x+1; 	} 	print(linf); 	return res; }   vector<int> brute(vector<PII> pts,vector<PII> qs){ 	int H=0,W=0; 	int n=sz(pts); 	int q=sz(qs); 	forn(i,n){ 		H=max(H,pts[i].Y+1); 		W=max(W,pts[i].X+1); 	} 	forn(i,q){ 		H=max(H,qs[i].Y+1); 		W=max(W,qs[i].X+1); 	} 	vector<vector<int> > wall(H,vector<int>(W,0)); 	vector<vector<int> > win(H,vector<int>(W,0)); 	forn(i,n){ 		wall[pts[i].Y][pts[i].X]=1; 	} 	forn(y,H){ 		forn(x,W){ 			bool w=wall[y][x]; 			for(int xx=x-1;xx>=0 && !wall[y][xx];--xx){ 				if(!win[y][xx]){ 					w=true; 					break; 				} 			} 			for(int yy=y-1;yy>=0 && !wall[yy][x];--yy){ 				if(!win[yy][x]){ 					w=true; 					break; 				} 			} 			win[y][x]=w; 		} 	} 	vector<int> res(q); 	forn(i,q){ 		res[i]=win[qs[i].Y][qs[i].X]; 	} 	return res; }   void gen(vector<PII> &pts,vector<PII> &qs,int lim,int n,int q){ 	pts.clear(); 	qs.clear(); 	forn(i,n){ 		pts.pb(mp(0,0)); 		pts[i].X=rand()%lim; 		pts[i].Y=rand()%lim; 	} 	forn(i,q){ 		qs.pb(mp(0,0)); 		qs[i].X=rand()%lim; 		qs[i].Y=rand()%lim; 	} }   void stress(){ 	for(int lim=1;lim<=10;++lim){ 		for(int n=1;n<=10;++n){ 			for(int q=1;q<=10;++q){ 				vector<PII> pts,qs; 				gen(pts,qs,lim,n,q); 				vector<int> b=brute(pts,qs); 				vector<int> r=solve(pts,qs); 				if(b!=r){ 					cout<<"failed "<<lim<<' '<<n<<' '<<q<<":"<<endl; 					forn(i,n){ 						cout<<pts[i].X<<' '<<pts[i].Y<<endl; 					} 					cout<<endl; 					forn(i,q){ 						cout<<qs[i].X<<' '<<qs[i].Y<<endl; 					} 					cout<<endl; 					forn(i,q){ 						cout<<b[i]<<' '; 					} 					cout<<endl; 					forn(i,q){ 						cout<<r[i]<<' '; 					} 					cout<<endl; 					return; 				} 			} 		} 	} 	cout<<"passed"<<endl; }   int main() { #ifdef __ASD__     freopen("input.txt","r",stdin);freopen("output.txt","w",stdout); #endif 	 	//stress();return 0; 	 	int tc; 	cin>>tc; 	forn(qqq,tc){ 		int n; 		cin>>n; 		vector<PII> pts,qs; 		forn(i,n){ 			int x,y; 			scanf("%d%d",&x,&y); 			pts.pb(mp(x,y)); 		} 		int q; 		cin>>q; 		forn(i,q){ 			int x,y; 			scanf("%d%d",&x,&y); 			qs.pb(mp(x,y)); 		} 		vector<int> res=solve(pts,qs); 		forn(i,q){ 			printf("%s\n",res[i]?"Alice":"Bob"); 		} 	} 	 	return 0; }
#include <cstdlib> #include <cstdio> #include <cstring> #include <algorithm> using namespace std; typedef long long int64; const int64 lcm30=2329089562800LL; const int oo=1000000000; const int64 oooo=1000000000000000000LL; const int maxN=59; struct Edge { 	int v; 	int64 r; 	Edge *next,*opp; };   const int maxV=maxN,maxE=maxV+110; Edge po[maxE*2],*ve[maxV]; int pon; void addEdge(int a,int b,int64 c) { 	Edge *e1=po+pon++,*e2=po+pon++; 	(e1->opp=e2)->opp=e1; 	e1->v=b,e1->next=ve[a],ve[a]=e1; 	e2->v=a,e2->next=ve[b],ve[b]=e2; 	e1->r=c,e2->r=0; } int vn,vs,vt,d[maxV],l[maxV]; Edge *ve2[maxV]; void init() { 	pon=0; 	fill(ve+1,ve+vn+1,(Edge*)0); } bool relabel() { 	fill(d+1,d+vn+1,oo); 	d[vt]=0,l[1]=vt; 	for(int lh=1,lt=1;lh<=lt;lh++) { 		int x=l[lh]; 		for(Edge *e=ve[x];e;e=e->next) 		    if(e->opp->r&&d[e->v]>=oo) { 				d[e->v]=d[x]+1; 				l[++lt]=e->v; 			} 	} 	copy(ve+1,ve+vn+1,ve2+1); 	return d[vs]<oo; } int64 aug(int x,int64 limit) { 	if(x==vt) 	    return limit; 	int64 ans=0; 	for(Edge *&e=ve2[x];e;e=e->next) 	    if(e->r&&d[x]==d[e->v]+1) { 			int64 ret=aug(e->v,min(limit,e->r)); 			e->r-=ret,e->opp->r+=ret; 			limit-=ret,ans+=ret; 			if(limit==0) 			    break; 		} 	return ans; } bool v[maxV]; void dfs(int x) { 	v[x]=true;     for(Edge *e=ve[x];e;e=e->next)         if(e->r&&!v[e->v])             dfs(e->v); }   int64 f[maxN][maxN]; int main() { 	int T; 	for(scanf("%d",&T);T;T--){ 		int n,m; 		scanf("%d%d",&n,&m);   		int64 tot=0; 		memset(f,0,sizeof(f)); 		for(int i=1;i<=m;i++) { 			int u,v,a,b; 			scanf("%d%d%d/%d",&u,&v,&a,&b); 			f[u][v]+=lcm30*a/b; 			tot+=lcm30*a/b; 			//printf("%d %d : %I64d\n",u,v,f[u][v]); 		}   		if(tot!=(n-1)*lcm30) { 			puts("1"); 			goto ok; 		}   		for(int one=1;one<=n;one++){ 			vn=n+2,vs=vn-1,vt=vn; 			init(); 			int64 base=0; 			for(int i=1;i<=n;i++) { 				int64 w=lcm30; 				for(int j=1;j<=n;j++) { 				    w-=f[i][j]; 				    if(f[i][j]) 						addEdge(i,j,f[i][j]);//,printf("w[%d][%d]=%I64d\n",i,j,f[i][j]); 				} 				//printf("w[%d]=%I64d\n",i,w); 				if(i==one) 				    addEdge(vs,i,oooo); 				if(w>0) 				    addEdge(i,vt,w); 				else if(w<0) { 				    addEdge(vs,i,-w); 				    base+=w; 				} 			}   			int64 flow=0; 			while(relabel()) 			    flow+=aug(vs,oooo); 			//printf("%I64d\n",-(flow+base)); 			//printf("%.10f\n",-(flow+base)*1.0/lcm30); 			if(-(flow+base)>-lcm30) { 				fill(v+1,v+vn+1,false); 				dfs(vs); 				 				int cnt=0; 				for(int i=1;i<=n;i++) 				    if(v[i]) 				        cnt++;   				printf("2\n%d\n",cnt); 				for(int i=1;i<=n;i++) 				    if(v[i]) { 						printf("%d",i); 						if(--cnt) 						    putchar(' '); 					} 				puts(""); 				goto ok; 			} 		} 		puts("GST"); 		ok: 		puts(""); 	} 	scanf("%*s"); }
#include <string> #include <vector> #include <algorithm> #include <cmath> #include <set> #include <queue> #include <map> #include <cstdio> #include <iomanip> #include <sstream> #include <iostream> #include <cstring> #define REP(i,x,v)for(int i=x;i<=v;i++) #define REPD(i,x,v)for(int i=x;i>=v;i--) #define FOR(i,v)for(int i=0;i<v;i++) #define FORE(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define REMIN(x,y) (x)=min((x),(y)) #define REMAX(x,y) (x)=max((x),(y)) #define pb push_back #define sz size() #define mp make_pair #define fi first #define se second #define ll long long #define IN(x,y) ((y).find((x))!=(y).end()) #define un(v) v.erase(unique(ALL(v)),v.end()) #define LOLDBG #ifdef LOLDBG #define DBG(vari) cerr<<#vari<<" = "<<vari<<endl; #define DBG2(v1,v2) cerr<<(v1)<<" - "<<(v2)<<endl; #else #define DBG(vari) #define DBG2(v1,v2) #endif #define CZ(x) scanf("%d",&(x)); #define CZ2(x,y) scanf("%d%d",&(x),&(y)); #define CZ3(x,y,z) scanf("%d%d%d",&(x),&(y),&(z)); #define ALL(x) (x).begin(),(x).end() #define tests int dsdsf;cin>>dsdsf;while(dsdsf--) #define testss int dsdsf;CZ(dsdsf);while(dsdsf--) using namespace std; typedef pair<int,int> pii; typedef vector<int> vi; template<typename T,typename TT> ostream &operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream &operator<<(ostream &s,vector<T> t){s<<"{";FOR(i,t.size())s<<t[i]<<(i==t.size()-1?"":",");return s<<"}"<<endl; }  #define MAXPR 100000  bool sito[MAXPR+10];  void situj() {     FOR(i,MAXPR+1) sito[i]=1;     sito[1]=0;     REP(i,2,MAXPR) if (sito[i]) {for(int j=2*i;j<=MAXPR;j+=i) sito[j]=0;} }   #define fint ll  #define maxm 100000 #define maxn 2000 #define INF 1000000000000LL  int N,So,Ta,edges; int head[maxn],curr[maxn],point[maxm],next[maxm]; int layer[maxn],Q[maxn]; fint flow[maxm],capa[maxm];  void init(int _N,int _S,int _T) { 	N=_N;So=_S;Ta=_T;edges=0; 	FOR(i,N) head[i]=-1; }  void dod_kr(int u,int v,fint cp) { 	point[edges]=v;capa[edges]=cp;flow[edges]=0;next[edges]=head[u];head[u]=edges++; 	point[edges]=u,capa[edges]=0;flow[edges]=0;next[edges]=head[v];head[v]=edges++; }  bool flow_bfs() { 	FOR(i,N) layer[i]=-1; 	layer[So]=0; 	Q[0]=So; 	int qs=1; 	FOR(cl,qs) for(int k=Q[cl],i=head[k];i>=0;i=next[i]) 	if (flow[i]<capa[i] && layer[point[i]]<0) 		{layer[point[i]]=layer[k]+1;Q[qs++]=point[i];} 	return layer[Ta]>=0; }  fint flow_dfs(int x,fint fl) { 	if (x==Ta) return fl; 	fint wyn=0; 	for (int &i=curr[x];i>=0;i=next[i]) 	{ 		int v=point[i]; 		fint tmp; 		if (flow[i]<capa[i] && layer[v]==layer[x]+1 && (tmp=flow_dfs(v,min(fl,capa[i]-flow[i])))>0) 		{ 			flow[i]+=tmp;flow[i^1]-=tmp; 			wyn+=tmp;fl-=tmp; 			if (!fl) break; 		} 	} 	return wyn; }  fint max_flow() { 	fint wyn=0; 	while (flow_bfs()) 	{ 		FOR(i,N)curr[i]=head[i]; 		wyn+=flow_dfs(So,INF); 	} 	return wyn; }  #define ull unsigned long long  ull GCD(ull a,ull b) {     if (b<a) return GCD(b,a);     if (!a) return b;     return GCD(b%a,a); }  ull multbig(ull a, ull b, ull m) //mnozy (a*b)%m dla a,b<2^63 {     if (b==0 || a==0) return 0;     if (b<(1LL<<31) && a<(1LL<<31))         return (a*b)%m;     ull x=0;     while (b)     {         if (b&1)             x=(x+a)%m;         a=(a<<1)%m;         b=b>>1;     }     return x; }  ull sqpow(ull n, ull k, ull m) //(n^k)%m {     if (k==0)         return 1;     ull k0=k, w=1, n0=n;     while(k0)     {         if (k0&1)             w=multbig(w,n0,m);         n0=multbig(n0,n0,m);         k0=k0>>1;     }     return w; }  bool TRM(ull x, int ile) {     if (x==2 || x==3) return 1;     if (!(x%2) || !(x%3) || x==1) return 0;     int t=0,j;     ull z0=x-1,b;     while (!(z0%2)) {z0/=2;t++;}     while(ile--)     {         b=sqpow(2+rand()%(x-3),z0,x);         if (b==1)             continue;         for(j=0;j<t && b!=x-1 && b!=1;j++)             b=multbig(b,b,x);         if (b!=x-1) return 0;     }     return 1; }  vector<pair<ll,int> > a; ll A[501]; ll C[501]; int kolor[501]; int deg[501]; vi kr[501]; vi macz[501]; vi niemacz[501]; bool odw[501]; vi wygr; int n; int aktkolor;  void dfs(int u) { 	odw[u]=1; 	if (kolor[u]==aktkolor) 	{ 		FORE(e,niemacz[u]) 		{ 			if (!odw[*e]) 			{ 				dfs(*e); 			} 		} 	} 	else 	{ 		FORE(e,macz[u]) 		{ 			if (!odw[*e]) 			{ 				dfs(*e); 			} 		} 	} }  void dfskolor(int u,int kol) { 	if (kolor[u]!=-1) return; 	kolor[u]=kol; 	FORE(i,kr[u]) dfskolor(*i,1-kol); }  set<ll> primy; set<ll> nieprimy;  int main() { 	ios_base::sync_with_stdio(0); 	situj(); 	int n;cin>>n; 	a.resize(n); 	FOR(i,n) cin>>a[i].fi>>a[i].se; 	sort(ALL(a)); 	FOR(i,n) A[i]=a[i].fi; 	FOR(i,n) C[i]=a[i].se; 	//if (n<400){while(1){}} 	//if (n>=400) return 0; 	FOR(i,n) REP(j,i+1,n-1) 	{ 		//if (n>400 && i>n/1) return 0; 		if (A[j]%A[i]==0) 		{ 			ll P=A[j]/A[i]; 			if (IN(P,nieprimy)) continue; 			if (IN(P,primy) || (P<MAXPR && sito[P]) || (P>=MAXPR && TRM(P,2))) 			{ 				primy.insert(P); 				kr[i].pb(j); 				kr[j].pb(i); 			} 			else 			{ 				nieprimy.insert(P); 			} 		} 	} 	 	FOR(i,n) kolor[i]=-1; 	FOR(i,n) if (kolor[i]==-1) dfskolor(i,0); 	int zr=n,uj=n+1; 	init(n+2,zr,uj); 	FOR(i,n) 	{ 		if (kolor[i]==0) 		{ 			FORE(e,kr[i])  			{ 				dod_kr(i,*e,INF); 				//DBG(mp(i,*e)); 			} 			deg[i]=edges; 			dod_kr(zr,i,C[i]); 		} 		else 		{ 			deg[i]=edges; 			dod_kr(i,uj,C[i]); 		} 	} 	ll f=max_flow(); 	//DBG(f); 	int nr=0; 	FOR(i,n) 	{ 		deg[i]=flow[deg[i]]; 		//DBG(deg[i]); 	} 	FOR(i,n) 	{ 		if (kolor[i]==0) 		{ 			FORE(e,kr[i]) 			{ 				if (flow[nr]) 				{ 					macz[i].pb(*e); 					macz[*e].pb(i); 				} 				if (flow[nr]<deg[i]) niemacz[i].pb(*e); 				if (flow[nr]<deg[*e]) niemacz[*e].pb(i);	 				nr+=2; 			} 			nr+=2; 		} 		else nr+=2; 	} 	FOR(kol,2) 	{ 		aktkolor=kol; 		FOR(i,n) odw[i]=0; 		FOR(i,n) if (odw[i]==0 && kolor[i]==kol && deg[i]<C[i]) dfs(i); 		FOR(i,n) if (odw[i] && kolor[i]==kol) wygr.pb(i); 	} 	sort(ALL(wygr)); 	if (wygr.sz) cout<<"Bran "<<A[wygr[0]]; 	else cout<<"Tyrion";     return 0; } 
#include <stdio.h> #include <stdlib.h> #include <vector> #include <math.h> using namespace std;   long long   alltriangles[1000][4]; long long int max(long long int a,long long int b){return a>b?a:b;} long long int min(long long int a,long long int b){return a<b?a:b;} long long isqrt(long long a) { 	if(a<0) 		return 0; 	return (long long)(sqrt((double)a+0.01)); } int ct; void addit(long long x1,long long y1,long long A,long long B,long long C,bool which) { 	 	//printf("%lld %lld %lld\n",A,B,C); 	 	long long x3,y3; 	long long z=(A+B-C); 	long long x2; 	 	if(which) 		x2=(z*x1+isqrt(z*z*x1*x1-A*(z*z-4*B*y1*y1)))/(2*A); 	else 		x2=(z*x1-isqrt(z*z*x1*x1-A*(z*z-4*B*y1*y1)))/(2*A); 	long long y2=isqrt(B-x2*x2); 	 	if(x1*x1+y1*y1==A && x2*x2+y2*y2==B && (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)==C) 	{ 		 		long long minX=min(x1,min(x2,0)); 		long long minY=min(y1,min(y2,0)); 		//printf("1--%lld %lld %lld %lld %lld %lld \n",x1,y1,x2,y2,x3,y3); 		 		x1-=minX; 		y1-=minY; 		x2-=minX; 		y2-=minY; 		x3=-minX; 		y3=-minY; 		//printf("--%lld %lld %lld %lld %lld %lld \n",x1,y1,x2,y2,x3,y3); 		 		long long val1=x1*2001+y1; 		long long val2=x2*2001+y2; 		long long val3=x3*2001+y3; 		 		alltriangles[ct][0]=min(val1,min(val2,val3)); 		alltriangles[ct][1]=max(val1,max(val2,val3)); 		alltriangles[ct++][2]=val1+val2+val3-alltriangles[ct][0]-alltriangles[ct][1]; 	} 	 	 	 	 	 }   int main() { 	bool issquare[2000001]; 	for(int i=0;i<=1000;i++) 		issquare[i*i]=1; 	int tc; 	scanf("%d",&tc); 	long long xa,ya,xb,yb,xc,yc; 	long long sqsaB[100];long long sqsaC[100]; 	 	for(int t=1;t<=tc;t++) 	{ 		long long int M,K; 		scanf("%lld %lld",&M,&K); 		printf("Case #%d:\n",t); 		for(int k=1;k<=K;k++) 		{ 			ct=0; 			long long count=0; 			 			scanf("%lld %lld %lld %lld %lld %lld",&xa,&ya,&xb,&yb,&xc,&yc); 			long long int A=(xa-xb)*(xa-xb)+(ya-yb)*(ya-yb); 			long long int B=(xa-xc)*(xa-xc)+(ya-yc)*(ya-yc); 			long long int C=(xc-xb)*(xc-xb)+(yc-yb)*(yc-yb);   			int numsqsB=0; 			int numsqsC=0; 			long long up=(isqrt(C/2)); 				for(long long int i=0;i<=up;i++) 					if(issquare[C-i*i]) 						sqsaC[numsqsC++]=i; 			 			up=(isqrt(B/2)); 				for(long long int i=0;i<=up;i++) 					if(issquare[B-i*i]) 						sqsaB[numsqsB++]=i; 			 			 			 			 			for(int i=0;i<numsqsB;i++) 			{ 				for(int b=0;b<2;b++) 				{ 					long long x1,y1; 					if(b) 					{ 						x1=sqsaB[i]; 						y1=isqrt(B-x1*x1); 					} 					else 					{ 						y1=sqsaB[i]; 						x1=isqrt(B-y1*y1); 					} 					addit(x1,y1,B,A,C,0); 					addit(x1,y1,B,A,C,1); 					addit(-x1,y1,B,A,C,0); 					addit(-x1,y1,B,A,C,1); 				} 				 				 			} 			 			for(int i=0;i<numsqsC;i++) 			{ 				for(int b=0;b<2;b++) 				{ 					long long x1,y1; 					if(b) 					{ 						x1=sqsaC[i]; 						y1=isqrt(C-x1*x1); 					} 					else 					{ 						y1=sqsaC[i]; 						x1=isqrt(C-y1*y1); 					} 					addit(x1,y1,C,A,B,0); 					addit(x1,y1,C,A,B,1); 					addit(-x1,y1,C,A,B,0); 					addit(-x1,y1,C,A,B,1); 				} 				 			} 			 			for(int i=0;i<numsqsC;i++) 			{ 				 				for(int b=0;b<2;b++) 				{ 					long long x1,y1; 					if(b) 					{ 						x1=sqsaC[i]; 						y1=isqrt(C-x1*x1); 					} 					else 					{ 						y1=sqsaC[i]; 						x1=isqrt(C-y1*y1); 					} 					addit(x1,y1,C,B,A,0); 					addit(x1,y1,C,B,A,1); 					addit(-x1,y1,C,B,A,0); 					addit(-x1,y1,C,B,A,1); 				} 				 				 			} 			 			for(int i=0;i<ct;i++) 			{ 				bool there=0; 				for(int j=0;j<i;j++) 				{ 					if(alltriangles[j][0]==alltriangles[i][0] && alltriangles[j][1]==alltriangles[i][1] && alltriangles[j][2]==alltriangles[i][2]) 					{ 						there=1; 						break; 					} 				} 				if(!there) 				{ 					long long x1=alltriangles[i][0]/2001;long long y1=alltriangles[i][0]%2001; 					long long x2=alltriangles[i][1]/2001;long long y2=alltriangles[i][1]%2001; 					long long x3=alltriangles[i][2]/2001;long long y3=alltriangles[i][2]%2001; 					long long minX=min(x1,min(x2,x3)); 					long long maxX=max(x1,max(x2,x3)); 					long long minY=min(y1,min(y2,y3)); 					long long maxY=max(y1,max(y2,y3)); 					//printf("%lld %lld %lld %lld %lld %lld\n",x1,y1,x2,y2,x3,y3); 					if(maxX-minX<=M && maxY-minY<=M) 						count+=(M-(maxX-minX)+1)*(M-(maxY-minY)+1); 					 					 				} 			} 			 			printf("%lld\n",count); 			 			 			 		} 	} 	 	 	 }  
#include<cstdio> #include<cassert> #include<algorithm> #include<cstring> #include<iostream> #include<cstdlib> #include<cmath> #include<vector> #include<map> #include<set> #include<queue> #include<bitset> using namespace std; typedef long long ll; typedef double db; void gn(int &x){ 	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-'); 	if(c=='-')sg=-1,x=0;else x=c-'0'; 	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0'; 	x*=sg; } void gn(ll &x){ 	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-'); 	if(c=='-')sg=-1,x=0;else x=c-'0'; 	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0'; 	x*=sg; } const int mo=1000000007; int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;} #define inf 1000000000 #define MAXV 2005 using namespace std; int n; struct edge{int v,next;}e[2000005];int etot=0;int g[MAXV]; void ae(int u,int v){e[etot].v=v;e[etot].next=g[u];g[u]=etot++;} int match[MAXV],next[MAXV],mark[MAXV],fa[MAXV]; int gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);} void un(int x,int y){x=gf(x),y=gf(y);fa[x]=y;} void init(){ 	memset(mark,0,sizeof(mark)); 	memset(fa,0,sizeof(fa)); } int qu[100*MAXV],p,q; int tmp[MAXV]={0}; int lca(int u,int v){     static int ts=0;     ts++;     while(1){         if(u){             u=gf(u);             if(tmp[u]==ts)return u;             tmp[u]=ts;             if(match[u])u=next[match[u]];             else u=0;         }         swap(u,v);     } } void link(int a,int p){     while(a!=p){         int b=match[a],c=next[b];         if(gf(c)!=p)next[c]=b;             if(mark[b]==2)mark[qu[q++]=b]=1;         if(mark[c]==2)mark[qu[q++]=c]=1;         un(a,b);un(b,c);                 a=c;     } } int ban;  int vis[2222]; void find(int rt){     for (int i=0;i<=n;i++)next[i]=mark[i]=0,fa[i]=i;     p=q=0;qu[q++]=rt;mark[rt]=1;     while(p!=q){         int u=qu[p++]; 	vis[u]=1;         for (int i=g[u];~i;i=e[i].next){             int v=e[i].v; 	    if(v==ban)continue;             if(gf(v)==gf(u) || mark[v]==2 || v==match[u])continue;             if(mark[v]==1){                 int p=lca(u,v);                 if(gf(u)!=p)next[u]=v;                 if(gf(v)!=p)next[v]=u;                 link(u,p);                 link(v,p);             }else if(!match[v]){                 next[v]=u;                 while(v){                     u=next[v];                     int t=match[u];                     match[v]=u;match[u]=v;                     v=t;                 }                 return;              }else{                 next[v]=u;                 mark[v]=2;                 mark[qu[q++]=match[v]]=1;             }         }     }     return; }   void doit(){ 	init(); 	memset(vis,0,sizeof(vis));         memset(g,-1,sizeof(g));etot=0;     	int m;     	scanf("%d%d",&n,&m);         int u,v;         while(m--){ 		gn(u);gn(v);             ae(u,v);ae(v,u);         }         memset(match,0,(n+2)*sizeof(int));         memset(tmp,0,(n+2)*sizeof(int));         for (int i=1;i<=n;i++)if(!match[i]){ 		find(i); 	} 	int su=0; 	memset(vis,0,sizeof(vis)); 	for (int i=1;i<=n;i++)if(!match[i])find(i); 	for (int i=1;i<=n;i++){ 		if(vis[i])su++; 	} 	printf("%d\n",su); }   int main(){ 	int tes;scanf("%d",&tes); 	while(tes--){ 		doit(); 	} 	return 0; } 
#include <cstdio> #include <cstdlib> #include <iostream>  using namespace std;  char maze[32][32]; int ALL, m, n, c, k, l; int ghostx[10], ghosty[10], ghostpx[30][300], ghostpy[30][300], pathsize[30]; int bitmaze[32], entryx, entryy, exitx, exity;  void makepath (int x1, int y1, int x2, int y2, int ghost) {     while ((x1 != x2) || (y1 != y2))     {         ghostpx[ghost][pathsize[ghost]] = x1;         ghostpy[ghost][pathsize[ghost]] = y1;         pathsize[ghost]++;          if (x1 < x2)             x1++;         else         if (x1 > x2)             x1--;         else         if (y1 < y2)             y1++;         else         if (y1 > y2)             y1--;     } }  int escape (int faint) {     int timer = 0, x, y, i, gpos[30] = {0};     int chef[32] = {0}, chef_[32] = {0};     chef[entryy] = (1 << entryx);     while (timer < faint)     {         for (i = 0; i <= m-1; i++)             chef_[i] = chef[i];          for (i = 0; i <= m-1; i++)         {             chef[i] |= (chef_[i] << 1);             chef[i] |= (chef_[i] >> 1);              if (i > 0)                 chef[i] |= chef_[i-1];             if (i < m-1)                 chef[i] |= chef_[i+1];              chef[i] &= bitmaze[i];         }          for (i = 0; i <= c-1; i++)         {             x = ghostpx[i][gpos[i]];             y = ghostpy[i][gpos[i]];             chef[y] &= ALL - (1 << x);              if (++gpos[i] == pathsize[i])                 gpos[i] = 0;              x = ghostpx[i][gpos[i]];             y = ghostpy[i][gpos[i]];             chef[y] &= ALL - (1 << x);         }          timer++;          if (chef[exity] & (1 << exitx))         return timer;     }      return -1; }  int main() {     int i, j, t;     scanf("%d", &t);     while (t)     {         scanf("%d%d%d%d", &m, &n, &c, &k);         ALL = (1 << n) - 1;         for (i = 0; i <= c-1; i++)         {             pathsize[i] = 0;             scanf("%d", &l);             for (j = 0; j <= l-1; j++)             {                 cin >> ghostx[j] >> ghosty[j];                 if (j > 0)                     makepath(ghostx[j-1], ghosty[j-1], ghostx[j], ghosty[j], i);             }             makepath(ghostx[l-1], ghosty[l-1], ghostx[0], ghosty[0], i);         }         for (i = 0; i<= m-1; i++)         {             bitmaze[i] = 0;             for (j = 0; j <= n-1; j++)             {                 cin >> maze[i][j];                  if (maze[i][j] != '#')                     bitmaze[i] |= (1 << j);                  if (maze[i][j] == '@')                 {                     entryx = j;                     entryy = i;                 }                  else                 if (maze[i][j] == '$')                 {                     exitx = j;                     exity = i;                 }             }         }         printf("%d\n", escape(k));         t--;     }     return 0; }
// //  HUNGRY_BEAR.cpp //   // //  Created by Manh Le on 14/5/16. // //  #include <bits/stdc++.h>  using namespace std;  const int maxn = 301;  int n, m, k, res[maxn], a[maxn], number[maxn][maxn]; long long result[maxn][maxn];  void init() {          for(int i = 1; i <= n; i++) {         for(int j = 1; j <= n - i + 1   ; j++) {                          a[0] = 0;             for(int h = 1; h <= m; h++) {                 a[h] = number[h][i + j - 1] - number[h - 1][i + j - 1] - number[h][i - 1] + number[h - 1][i - 1];             }             int h = 0, sum = 0;             memset(res, 0, sizeof(res));             for(int row = 1; row <= m; row++) {                 sum -= a[row - 1];                 while (sum < k) {                     if (h == m) {                         break;                     }                     h++; sum += a[h];                 }                                  if (sum < k) {                     break;                 }                 res[h - row + 1]++;                 res[m - row + 2]--;             }                          sum = 0;                          for(int h = 1; h <= m; h++) {                 sum += res[h];                 result[j][h] += sum;             }         }     }          for(int i = 1; i <= m; i++) {         for(int j = 1; j <= n; j++) {             result[j][i] += result[j][i - 1] + result[j - 1][i] - result[j - 1][i - 1];         }     } }  void readInput() {          scanf("%d %d %d\n", &m, &n, &k);     for(int i = 1; i <= m ; i++) {         string st;         getline(cin, st);         for(int j = 1; j <= n; j++) {             number[i][j] = number[i - 1][j] + number[i][j - 1] - number[i - 1][j - 1];             if (st[j - 1] == 'H') {                 number[i][j]++;             }         }     } }  void printResult() {          int Q = 0;     scanf("%d", &Q);     while (Q--) {         int A, B;         scanf("%d %d", &A, &B);         printf("%lld\n", result[B][A]);     } }  int main() {               readInput();     init();     printResult();          return 0; } 
//#pragma warning (disable: 4786) //#pragma comment (linker, "/STACK:16777216")  #include<cstdio> #include<cstring> #include<cstdlib> #include<cctype> #include<cmath> #include<iostream> #include<fstream> #include<iomanip> #include<string> #include<vector> #include<queue> #include<map> #include<algorithm> #include<set> #include<sstream> #include<stack> #define maxim 100 #define LLD long long int #define LLU long long unsigned #define HD short int #define HU short unsigned #define ui unsigned #define pi acos(-1.0) #define inf (1<<29) #define CLR(a) memset(a,0,sizeof(a)) #define SET(a) memset(a,-1,sizeof(a)) #define pb push_back #define sz(a) ((int)a.size()) #define all(a) a.begin(),a.end() #define eps 1e-6 #define rep(i,init,n) for(i=init;i<n;i++) #define rem(i,init,n) for(i=init;i>n;i--) #define _abs(a) ((a)<0?(-(a)):(a)) #define area(x1,y1,x2,y2,x3,y3) ( x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2) ) #define sqr(x) ((x)*(x)) #define distSqr(x1,y1,x2,y2) ( sqr(x1-x2) + sqr(y1-y2) ) #define spDist(lat1,long1,lat2,long2,r) ( r * acos( sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(long1-long2) ) ) #define isEq(a,b) (fabs(a-b)<eps) #define STR string #define LF double #define IT iterator #define VI vector<int> #define VLLD vector<LLD> #define VS vector<STR> #define VLF vector<LF> #define MII map<int,int> #define MIB map<int,bool> #define MSI map<STR,int> #define MSB map<STR,bool> #define MSS map<STR,STR> #define M2dII map<int,map<int,int> > #define QI queue<int> #define SI stack<int> #define PLL pair< LLD, LLD > #define PPI pair< PII, int > #define ff first #define ss second #define VPII vector<PII> #define MP make_pair  #define chk(a,k) ((bool)(a&(1<<(k)))) #define set0(a,k) (a&(~(1<<(k)))) #define set1(a,k) (a|(1<<(k)))  #define chkA(a,k) (bool)(a[(k)>>5] & (1<<((k)&31))) #define setA0(a,k) (a[(k)>>5] &= ~(1<<((k)&31))) #define setA1(a,k) (a[(k)>>5] |= (1<<((k)&31)))  #define SD(a) scanf("%d",&a) #define SU(a) scanf("%u",&a) #define SHD(a) scanf("%hd",&a) #define SHU(a) scanf("%hu",&a) #define SLLD(a) scanf("%lld",&a) #define SLLU(a) scanf("%llu",&a) #define SF(a) scanf("%f",&a) #define SLF(a) scanf("%lf",&a) #define SC(a) scanf("%c",&a) #define SS(a) scanf("%s",a)  #define foreach(i, c) for( __typeof( (c).begin() ) i = (c).begin(); i != (c).end(); ++i )  int diru[] = {-1,-1,-1,0,0,1,1,1}; int dirv[] = {-1,0,1,-1,1,-1,0,1};  using namespace std;  template< class T > T sq(T n) { return n*n; } template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; } template< class T > void setmax(T &a, T b) { if(a < b) a = b; } template< class T > void setmin(T &a, T b) { if(b < a) a = b; } template< class T > T power(T N,T P){  return (P==0)?  1: N*power(N,P-1); }  LF a[14][14] ; LLD L[14][14] ; bool adj[14][14] ;  LF gaussian(int n) {          int i = 0, j = 0,k,l,r=n,c=n ;          LF val ;           rep(i,0,n)                     rep(j,0,n)                               a[i][j] = L[i][j] ;            //printf("%d\n",i) ;           i = j = 0 ;           while(i<r && j<c)          {                    //puts("sds") ;                   rep(k,i,r)                   {                            if(!(fabs(a[k][j])<eps))                            {                                     rep(l,j,c)        swap(a[i][l],a[k][l]) ;                                     break ;                            }                   }                    if(k==r)                   {                            return 0 ;                   }                    rep(k,i+1,r)                   {                            val = a[k][j]/a[i][j] ;                            rep(l,j,c)                            {                                     a[k][l] -= a[i][l]*val ;                            }                   }                    /*rep(x,0,n)                   {                             rep(y,0,n)            printf("%.6lf ",a[x][y]) ;                             puts("") ;                   }**/                    i++ ;                   j++ ;          }           LF ret = 1 ;           rep(i,0,n)           ret *= a[i][i] ;           return ret ; }  int main() { 	int T,t=1,m,i,j,n; 	//freopen("in.txt","r",stdin); 	//freopen("out.txt","w",stdout); 	scanf("%d",&T); 	for(t=1;t<=T;t++) 	//while(scanf("%d",&n)==1) 	{ 	          SD(n) ; 	          SD(m) ;  		CLR(L) ; 		CLR(adj) ;  		while(m--) 		{ 			scanf("%d%d",&i,&j) ;  			i -- ; 			j -- ;  			if(i==j || adj[i][j])                 continue ;  			adj[i][j] = 1 ; 			adj[j][i] = 1 ;  			L[i][j] = -1 ; 			L[j][i] = -1 ;  			L[i][i] ++ ; 			L[j][j] ++ ; 		}  		if(n==1)            puts("1") ; 		else 		{ 		          LF tmp = gaussian(n-1) ; 		          if(tmp<0) tmp = -tmp ; 		          printf("%.0lf\n",tmp) ;  		          //ans = (LLD)(tmp+eps) ; 		} 	} 	return 0; } 
#include <iostream> #include <cstdio> #include <cstdlib> #include <set> #include <map> #include <vector> #include <string> #include <cmath> #include <cstring> #include <queue> #include <stack> #include <algorithm> #include <sstream> using namespace std; typedef vector<int> vi;  typedef vector<vi> vvi;    #define sz(a) int((a).size())  #define pb push_back  #define all(c) (c).begin(),(c).end()  #define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++)  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end())    const long long mod = (long long)(1e9 + 9);   long long a[10], b[10], x[10], dp[55][512]; int color[55][512], cc; int n;   long long calc(int j, int mask) { 	//printf("%d %d\n", j, mask); 	if (j == -1) return 1; 	if (color[j][mask] == cc) return dp[j][mask]; 	color[j][mask] = cc; 	long long &ans = dp[j][mask]; 	ans = 0; 	 	int m1 = 0; 	for (int i = 0; i < n; ++i) if (x[i] & (1LL << j)) 		m1 ^= (1 << i); 	 	for (int i = 0; i < n; ++i) { 		if (m1 & (1 << i)) { 			(ans += calc(j - 1, mask | (m1 ^ (1 << i)))) %= mod; 		} 		else if (mask & (1 << i)) { 			(ans += calc(j - 1, mask | m1)) %= mod; 		} 	}		 	(ans += calc(j - 1, mask | m1)) %= mod;	 	 	return ans; }   long long get() { 	for (int i = 0; i < n; ++i) 		if (x[i] < 0) return 0; 	++cc;		 	//puts("oops"); 	return calc(54, 0);		 }   int main() { 	int tests; 	for (scanf("%d", &tests); tests; --tests) { 		scanf("%d", &n); 		for (int i = 0; i < n; ++i) 			cin >> a[i]; 		for (int i = 0; i < n; ++i) 			cin >> b[i]; 					 		long long res = 0; 		for (int mask = 0; mask < (1 << n); ++mask) { 			int m = 1; 			for (int j = 0; j < n; ++j) { 				if (mask & (1 << j)) { 					x[j] = a[j] - 1; 					m *= -1; 				} 				else  					x[j] = b[j]; 			} 			res = (res +  get() * m + mod) % mod; 		}	 		cout << res << endl; 	} 	return 0;		 }
#include<map> #include<cmath> #include<math.h> #include<time.h> #include<iomanip> #include<iostream> #include<assert.h> #include<algorithm>  using namespace std;  #define		MAX		200 #define		PI		(acos(-1.0)) #define		PII		pair<int,int> #define		TIME	0  typedef		long long		ll;  PII p[MAX];  bool comp(pair<int,int> x,pair<int,int> y){ 	float d1 = atan2(x.second*1.,x.first*1.); 	if (d1<0) d1+=2*PI; 	float d2 = atan2(y.second*1.,y.first*1.); 	if (d2<0) d2+=2*PI; 	return d1<d2; }  int main(){  #if (TIME) 	srand(time(NULL)); #endif  	cin.sync_with_stdio(false);  	int xi,xj,xk,yi,yj,yk; 	ll ai,aj,ak,add; 	map<PII,ll> mp;  	int n; #if (TIME) 	n = 150; #else 	cin >> n; #endif 	for (int i=0;i<n;i++){ #if (TIME) 		p[i].first = (rand()*rand())%1000000*(rand()%2?-1:1); 		p[i].second = (rand()*rand())%1000000*(rand()%2?-1:1); #else 		cin >> p[i].first >> p[i].second; #endif 	} #if (TIME) 	clock_t start = clock(); #endif 	int x,y; 	sort(p,p+n,comp); 	for (int i=0;i<n;i++){ 		ai = 0; 		xi = p[i].first; 		yi = p[i].second; 		mp[p[i]]; 		for (int j=i;j<n;j++){ 			xj = xi+p[j].first; 			yj = yi+p[j].second; 			add = ((ll)xi*yj-(ll)xj*yi); 			aj = ai+ add; 			ll &k = mp[PII(xj,yj)]; 			k = max(k,aj); 			for (int k=j;k<n;k++){ 				xk = xj+p[k].first; 				yk = yj+p[k].second; 				add = ((ll)xj*yk-(ll)xk*yj); 				ak = aj+ add; 				ll &r = mp[PII(xk,yk)]; 				r = max(r,ak); 			} 		} 	}  	ll ma = 0; 	for (map<PII,ll>::iterator it = mp.begin(),nit;it!=mp.end();it++){ 		if (it->first.first>0 && (nit = mp.find(PII(-it->first.first,-it->first.second)))!=mp.end()) 			ma = max(ma,it->second+nit->second); 	} 	if (ma&1) 		cout << ma/2 << ".5" << endl; 	else 		cout << ma/2 << ".0" << endl;  #if (TIME) 	cout << ((double)clock()-start)/CLOCKS_PER_SEC << endl; #endif 	return 0; }
//Tester's solution  #include <cstdio> #include <cassert> #include <map> #include <algorithm> using namespace std;   // answers generated offline, algorithm below long long answer[18]={ 	0,0,0, 	1, 	6, 	25, 	495, 	5586, 	93268, 	2052513, 	43258365, 	1167393700, 	34010847486LL, 	1078391538159LL, 	38595111963499LL, 	1476893151785520LL, 	61479081902937000LL, 	2761923686066698561LL, };   int main(){ 	int T, N; 	scanf("%d", &T); 	while(T--){ 		scanf("%d", &N); 		printf("%lld\n", answer[N]); 	} 	return 0; }   // disjoint set find int find(int n, int *parent){ 	if(parent[n]==n) 		return n; 	return parent[n]=find(parent[n], parent); }   // disjoint set union void un(int i, int j, int *parent){ 	i=find(i, parent); 	j=find(j, parent); 	parent[i]=j; }   // is graph connected when "skip" vertex is removed int isconnected(int v[][2], int n, int len, int skip=-1){ 	int parent[17]; 	for(int i=0; i<n; i++) 		parent[i]=i; 	for(int i=0; i<len; i++){ 		if(v[i][0]==skip || v[i][1]==skip) 			continue; 		un(v[i][0], v[i][1], parent); 	} 	int count=0; 	for(int i=0; i<n; i++) 		if(parent[i]==i && i!=skip) 			count++; 	return count==1; }   // is graph biconnected int isbiconnected(int v[][2], int N, int e){ 	if(!isconnected(v, N, e)) 		return 0; 	for(int i=0; i<N; i++) 		if(!isconnected(v, N, e, i)) 			return 0; 	return 1; }   long long nCr[18][18]; long long primitive[18]; long long biconnected[9][15]; int ee[17*8][2];   map<int, long long> dp; // number of ways to break hypertree into biconnected components long long dfs2(int *group, int *size, int comp){ 	if(comp==1) 		return 1; 	sort(size, size+comp); 	int mask=0; 	for(int i=0; i<comp; i++) 		mask=(mask<<size[i])+1; 	if(dp.count(mask)) 		return dp[mask]; 	long long &res=dp[mask]; 	int g=3; 	while(!group[g]){ 		g++; 	} 	int perm[18]; 	for(int i=0; i<comp; i++) 		perm[i]=0; 	for(int i=0; i<g; i++) 		perm[comp-1-i]=1; 	group[g]--; 	do{ 		int next[17], pos=1; 		next[0]=0; 		long long m=1; 		for(int i=0; i<comp; i++){ 			if(perm[i]){ 				next[0]+=size[i]; 				m*=size[i]; 			}else 				next[pos++]=size[i]; 		} 		res+=dfs2(group, next, comp-g+1)*m; 	}while(next_permutation(perm, perm+comp)); 	group[g]++; 	res*=primitive[g]; 	assert(!(res%group[g])); 	res/=group[g]; 	return res; }   // count biconnected graphs (not hypergraphs) with a particular // number of vertices and edges // this implementation is poorly optimized void dfs0(int v[][2], int N, int e, int elim, int start=0){ 	if(isbiconnected(v, N, e)) 		biconnected[N][e]++; 	if(e==elim) 		return; 	for(; start<N*(N-1)/2; start++){ 		v[e][0]=ee[start][0]; 		v[e][1]=ee[start][1]; 		dfs0(v, N, e+1, elim, start+1); 	} }   // classify hypertrees by biconnected components long long dfs1(int *count, int N, int upper, int lower=3){ 	int size[17]; 	for(int i=0; i<17; i++) 		size[i]=1; 	dp.clear(); 	long long res=dfs2(count, size, N); 	for(int i=lower; 2*i-1<=upper; i++){ 		count[upper]--; 		count[i]++; 		count[upper+1-i]++; 		res+=dfs1(count, N, upper+1-i, i); 		count[upper+1-i]--; 		count[i]--; 		count[upper]++; 	} 	return res; }   // number of ways to put labeled balls into labeled boxes // so that each box has at least one ball long long dfs4(int balls, int boxes, int filled=0){ 	if(!balls) 		return filled==boxes; 	return filled*dfs4(balls-1, boxes, filled)+(boxes-filled)*dfs4(balls-1, boxes, filled+1); }   // count the total number of hypertrees on N vertices long long solve(int N){ 	int cnt[18]={0}; 	cnt[N]=1; 	return dfs1(cnt, N, N); }   int main2(){ 	for(int i=0; i<18; i++) 	for(int j=0; j<18; j++){ 		if(j==0) 			nCr[i][j]=1; 		else if(j>i) 			nCr[i][j]=0; 		else 			nCr[i][j]=nCr[i-1][j]+nCr[i-1][j-1]; 	} 	for(int i=0, p=0; i<17; i++) 	for(int j=0; j<i; j++){ 		ee[p][0]=j; 		ee[p][1]=i; 		p++; 	} 	int vv[17][2]; 	primitive[3]=1; 	for(int i=4; i<=17; i++) 		primitive[i]=i*(i-1)/2; 	for(int i=3; i<=8; i++){ 		dfs0(vv, i, 0, 17-i); 		for(int j=i; j<=17-i && j<=2*i; j++){ 			for(int k=j; k+i<=17; k++){ 				primitive[k+i]+=biconnected[i][j]*dfs4(k, j)*nCr[k+i][i]; 			} 		} 	} 	 	for(int i=3; i<=17; i++){ 		printf("%lld\n", solve(i)); 	} 	return 0; }
#include <iostream> #include <fstream> #include <cstring> #include <string> #include <cstdlib> #include <cstdio> #include <algorithm> #include <cmath> #include <bitset> #include <ctime> #include <map> #include <queue> #include <set> #include <vector> #include <list> using namespace std;  typedef unsigned long long int64; const int64 maxV=(1ULL << 60)-1; const int N=120; const int M=N/2; const int K=M/2; const int H=K/2; const int maxH=(1 << H)-1; int64 mod64(int64 a,int n) { 	return a&((1ULL << n)-1); } struct int128 { 	int64 low,high; 	int128() {low=high=0;} 	int128(int64 low,int64 high=0):low(low),high(high) {} }; bool operator < (int128 a,int128 b) { 	return a.high<b.high || a.high==b.high && a.low<b.low; } bool operator > (int128 a,int128 b) { 	return a.high>b.high || a.high==b.high && a.low>b.low; } bool operator == (int128 a,int128 b) { 	return a.high==b.high && a.low==b.low; } bool operator <= (int128 a,int128 b) { 	return (a<b) || (a==b); } bool operator >= (int128 a,int128 b) { 	return (a>b) || (a==b); } bool operator != (int128 a,int128 b) { 	return !(a==b); } int128 operator >> (int128 a,int b) { 	if (b>=M) return int128(a.high>>(b-M),0); 	return int128((a.low>>b)|(mod64(a.high,b)<<(M-b)),a.high>>b); } int128 operator << (int128 a,int b) { 	if (b>=M) return int128(0,(a.low<<(b-M))&maxV); 	return int128((a.low<<b)&maxV,((a.high<<b)+(a.low>>(M-b)))&maxV); } int128 operator + (int128 a,int128 b) { 	int128 ls(a.low+b.low,a.high+b.high); 	if (ls.low>maxV) 	{ 		ls.low&=maxV; 		ls.high++; 	} 	ls.high&=maxV; 	return ls; } int128 operator - (int128 a) { 	if (a.low) return int128(maxV+1-a.low,maxV-a.high); 	if (a.high) return int128(0,maxV+1-a.high); 	return int128(0,0); } int128 operator - (int128 a,int128 b) { 	return a+(-b); } int128 mult(int64 a,int64 b) { 	int64 al=mod64(a,K); 	int64 ah=mod64(a>>K,K); 	int64 bl=mod64(b,K); 	int64 bh=mod64(b>>K,K); 	int128 ls(0,0); 	ls.low=al*bl; 	ls.high=ah*bh; 	int64 mid=(ls.low>>K)+al*bh+ah*bl; 	ls.low=mod64(ls.low,K)+(mod64(mid,K)<<K); 	ls.high+=mid>>K; 	return ls; } int128 operator * (int128 a,int128 b) { 	int128 ls=mult(a.low,b.low); 	ls.high=(ls.high+a.low*b.high+a.high*b.low)&maxV; 	return ls; } int128 mod128(int128 a,int b) { 	if (b>M) return int128(a.low,mod64(a.high,b-M)); 	return int128(mod64(a.low,b),0); } // // int128 bit[N+5]; int128 bit1[N+5]; int bitPrepare() { 	for (int i=0;i<N;i++) 	 if (i>=M) bit[i]=int128(0,1ULL << (i-M)); 	 	else bit[i]=int128(1ULL << i); 	bit1[0]=0; 	for (int i=1;i<=N;i++) bit1[i]=bit1[i-1]+bit[i-1]; 	return 0; } int128 inv(int128 a) { 	int128 b(1,0); 	for (int i=2;i<=N;i++) 		if (mod128(a*b,i)!=int128(1,0)) 			b=b+bit[i-1]; 	return b; } int128 read() { 	char s[50]; 	scanf("%s",s); 	int len=strlen(s); 	int128 b(0,0); 	for (int i=0;i<len;i++) 	 b=b*int128(10,0)+int128(s[i]-'0',0); 	return b; } int print(int128 a) { 	int s[50]; 	memset(s,0,sizeof(s)); 	int len=0; 	for (int i=0;i<2;i++) 	{ 		int64 ls; 		if (i==0) ls=a.high; else ls=a.low; 		int j=0; 		for (;j<len || ls;j++) 		{ 			ls+=(int64)s[j]<<M; 			s[j]=ls%10; 			ls/=10; 		} 		len=j; 	} 	len=max(len,1); 	for (int i=len-1;i>=0;i--) printf("%d",s[i]); 	printf("\n"); 	return 0; } // // int deg2(int64 x) { 	int i; 	for (i=0;!(x&1);i++,x>>=1); 	return i; } struct ext { 	int128 odd; 	int times; 	ext() {odd=int128(0,0);times=0;} 	ext(int128 odd,int times):odd(odd),times(times) {} 	ext(int128 a) 	{ 		if (!a.low) 		{ 			int kk=deg2(a.high); 			odd=int128(a.high>>kk,0); 			times=M+kk; 		} 		else 		{ 			int kk=deg2(a.low); 			odd=a >> kk; 			times=kk; 		} 	} }; ext operator * (ext a,ext b) { 	return ext(a.odd*b.odd,a.times+b.times); } int abs(int x) { 	if (x<0) return -x; 	return x; } ext inv(int a) { 	ext ls(abs(a)); 	if (a<0) ls.odd=-ls.odd; 	ls.odd=inv(ls.odd); 	ls.times*=-1; 	return ls; } // // const int presiz=500000; int128 fact2_pre[presiz+10]; int fact2_prepare() { 	fact2_pre[0]=1; 	for (int i=1;i<=presiz;i++) 		fact2_pre[i]=fact2_pre[i-1]*(2*i-1); 	return 0; } // // typedef vector<pair<int,int> > decom_prime; decom_prime pfact[N+10]; const int prime[29]={3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97, 					101,103,107,109,113}; int decomposition_prepare() { 	for (int i=3;i<=N;i+=2) 	{ 		int ls=i; 		for (int j=0;j<29;j++) 		if (ls%prime[j]==0) 		{ 			int p=0; 			while (ls%prime[j]==0) 			{ 				p++; 				ls/=prime[j]; 			} 			pfact[i].push_back(make_pair(j,p)); 		} 	} 	return 0; } // // int128 prime_pow[29][8][1 << H]; int primepow_prepare() { 	for (int i=0;i<29;i++) 	{ 		int128 p=prime[i]; 		for (int j=0;j<8;j++) 		{ 			int128 pw=1; 			for (int k=0;k<(1 << H);k++) 			 { 			 	prime_pow[i][j][k]=pw; 			 	pw=pw*p; 			 } 			p=pw; 		} 	} 	return 0; } // // ext pseudo_fact[M+5][M+5]; int pseudofact_prepare() { 	for (int j=1;j<=M;j++) 	{ 		pseudo_fact[0][j]=inv(j); 		for (int r=1;r<=M;r++) 		{ 			pseudo_fact[r][j]=pseudo_fact[r-1][j]; 			if (r==j) continue; 			pseudo_fact[r][j]=pseudo_fact[r][j]*inv(j*j-r*r); 		} 	} 	return 0; } // // int128 Pow(int nump,int128 exp) { 	int128 ans=1; 	int64 expp=exp.low; 	for (int i=0;i<4;expp>>=H,i++) 		ans=ans*prime_pow[nump][i][expp&maxH]; 	expp=exp.high; 	for (int i=4;i<8;expp>>=H,i++) 		ans=ans*prime_pow[nump][i][expp&maxH]; 	return ans; } // // int128 fact2(int128 red,int n) { 	int r=n/2; 	red=(red+1)>>1; 	if (red<=presiz) return mod128(fact2_pre[red.low],n); 	int r8; 	if (red.low%4<2) r8=1; 	else if (red.low%4==2) r8=3; 	 else r8=7; 	if (n<=3) return mod64(r8,n); 	vector <ext> origin(r+1),pref(r+1),sucf(r+2); 	for (int i=1;i<=r;i++) origin[i]=ext(red+i)*ext(red-i); 	pref[0]=ext(red); 	for (int i=1;i<=r;i++) pref[i]=pref[i-1]*origin[i]; 	sucf[r+1]=ext(1); 	for (int i=r;i>=1;i--) sucf[i]=sucf[i+1]*origin[i]; 	vector <int128> degr(r+2),degp(30); 	for (int i=r;i>=2;i--) 	{ 		ext ls=pref[i-1]*sucf[i+1]*pseudo_fact[r][i]; 		degr[i]=degr[i+1]+(ls.odd<<ls.times); 	} 	for (int i=2;i<=r;i++) 	{ 		decom_prime ls=pfact[2*i-1]; 		for (int j=0;j<ls.size();j++) 			degp[ls[j].first]=degp[ls[j].first]+(degr[i]*ls[j].second); 	} 	int128 ans=1; 	for (int i=0;i<29;i++) ans=ans*Pow(i,degp[i]); 	if (ans.low%4!=r8%4) ans=-ans; 	return mod128(ans,n); } // // int128 fact2_bit1[N+1]; int fact2bit1_prepare() { 	for (int i=0;i<=N;i++) fact2_bit1[i]=fact2(bit1[i],N); 	return 0; } // // int128 done(int n,int128 R) { 	int128 K=(R.low%4)/2; 	int128 son=mod128(R,2); 	int128 mother=1; 	for (int j=3;j<=n;j++) 	{ 		int par=K.low%2; 		if (mod128(son,j)!=mod128(R*mother,j)) 		{ 			if (par) 			{ 				son=son*K; 				mother=mother*(bit[j-1]-K); 			} 			else 			{ 				son=son*(bit1[j-1]-K); 				mother=mother*(K+1); 			} 			K.low^=1; 		} 		K=(K << 1)+par; 		son=son*fact2_bit1[j]; 		mother=mother*fact2(K,n)*fact2(bit1[j]-K,n); 	} 	return K; } // // int main() { 	bitPrepare(); 	fact2_prepare(); 	decomposition_prepare(); 	primepow_prepare(); 	pseudofact_prepare(); 	fact2bit1_prepare(); 	int G; 	scanf("%d",&G); 	while (G--) 	{ 		int n; 		scanf("%d",&n); 		int128 R=read(); 		if (R.low%2==0) printf("-1\n"); 		 else print(done(n,R)); 	} 	return 0; }
#include<cstdio> #include<iostream> #include<vector> #include<algorithm> #include<string> #include<cstring> using namespace std;   typedef long long LL; typedef vector<int> VI;   #define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i) #define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i) #define eprintf(s...) fprintf(stderr, s)   template<class T> inline void amin(T &a, const T &b) { if (b<a) a=b; } template<class T> inline void amax(T &a, const T &b) { if (a<b) a=b; } template<class T> struct TreapSeq {     struct Node { 	T val; 	int s, p; 	bool rev; 	Node *l, *r; 	Node(const T &val=T()): val(val), s(1), p(rand()-1), rev(false) { l = r = NULL; } 	Node*& ch(bool R) { return R? r: l; } 	void push() { 	    if (rev) { 		swap(l, r); 		if (l) l->rev = !l->rev; 		if (r) r->rev = !r->rev; 		rev = false; 	    } 	}     };     Node *root;     TreapSeq(Node *t=NULL): root(t) {}     int size() { return size(root); }     static inline int size(Node *x) { return x ? x->s : 0; }     static inline void resize(Node *x) { if (x) x->s = 1 + size(x->l) + size(x->r); }     Node* rot(Node *x, bool R) { // R = raise r? rotl? 	x->push(); x->ch(R)->push(); 	Node *y = x->ch(R); 	x->ch(R) = y->ch(!R); resize(x); 	y->ch(!R) = x; resize(y); 	return y;     }     void insert(int n, const T &v) { root = insert(n, new Node(v), root); }     Node* insert(int n, Node *t, Node *x) { 	if (!x) return t; 	x->push(); 	bool R = size(x->l) < n; 	int m = R? n-size(x->l)-1: n; 	x->ch(R) = insert(m, t, x->ch(R)); resize(x); 	if (x->p < x->ch(R)->p) x = rot(x, R); 	return x;     }     Node* erase_first(Node *x, T &v) { 	x->push(); 	if (!x->l) { v = x->val; Node *r = x->r; delete x; return r; } 	x->l = erase_first(x->l, v); resize(x); 	return x;     }     void erase(int n) { root = erase(n, root); }     Node* erase(int n, Node *x) { 	if (!x) return NULL; 	x->push(); 	if (size(x->l) == n) { 	    if (!x->r) return x->l; 	    x->r = erase_first(x->r, x->val); resize(x); 	    return x; 	} 	bool R = size(x->l) < n; 	x->ch(R) = erase(R? n-size(x->l)-1: n, x->ch(R)); resize(x); 	return x;     }     const T* at(int n) { 	Node *x = root; 	while (x) { 	    x->push(); 	    if (size(x->l) == n) return &x->val; 	    if (size(x->l) > n) x = x->l; 	    else { n -= size(x->l)+1; x = x->r; } 	} 	return NULL;     }     void reverse() { root->rev = !root->rev; } };   template<class T> struct TreapSet {     struct Node { 	T val; 	int s, p; 	Node *l, *r; 	Node(const T &val=T()): val(val), s(1), p(rand()) { l = r = NULL; } 	Node*& ch(bool R) { return R? r: l; }     };     Node *root;     Node *node; int nodei, NODE_MAX;     Node* new_node(const T &v) { 	node[nodei] = Node(v); 	return &node[nodei++];     }     TreapSet(int MAX=10000000): root(NULL), NODE_MAX(MAX) { // MAX = #insert 	nodei = 0; 	node = new Node[MAX];     }     int size() { return size(root); }     static inline int size(Node *x) { return x ? x->s : 0; }     static inline void resize(Node *x) { if (x) x->s = 1 + size(x->l) + size(x->r); }     Node* rot(Node *x, bool R) { // R = raise r? rotl? 	Node *y = x->ch(R); 	x->ch(R) = y->ch(!R); resize(x); 	y->ch(!R) = x; resize(y); 	return y;     }     void insert(const T &v) { root = insert(v, root); }     Node* insert(const T &v, Node *x) { 	if (!x) return new_node(v); 	// if (v == x->val) return x; 	bool R = x->val < v; 	x->ch(R) = insert(v, x->ch(R)); resize(x); 	if (x->p < x->ch(R)->p) x = rot(x, R); 	return x;     }     Node* erase_first(Node *x, T &v) {  	if (!x->l) { v = x->val; return x->r; } 	x->l = erase_first(x->l, v); resize(x); 	return x;     }     void erase(const T &v) { root = erase(v, root); }     Node* erase(const T &v, Node *x) { 	if (!x) return NULL; 	if (v == x->val) { 	    if (!x->r) return x->l; 	    x->r = erase_first(x->r, x->val); resize(x); 	    return x; 	} 	bool R = x->val < v; 	x->ch(R) = erase(v, x->ch(R)); resize(x); 	return x;     }     const T* find(const T &v) { 	Node *x = root; 	while (x) { 	    if (x->val == v) return &x->val; 	    x = x->ch(x->val < v); 	} 	return NULL;     }     const T* at(int n) { 	Node *x = root; 	while (x) { 	    if (size(x->l) == n) return &x->val; 	    if (size(x->l) > n) x = x->l; 	    else { n -= size(x->l)+1; x = x->r; } 	} 	return NULL;     }     const T* lower(const T &v) { 	Node *x = root, *ret = NULL; 	while (x) { 	    if (x->val < v && (!ret || ret->val < x->val)) ret = x; 	    x = x->ch(x->val < v); 	} 	return &ret->val;     }     const T* higher(const T &v) { 	Node *x = root, *ret = NULL; 	while (x) { 	    if (v < x->val && (!ret || x->val < ret->val)) ret = x; 	    x = x->ch(x->val <= v); 	} 	return &ret->val;     }     int count_lower(const T &v) { 	Node *x = root; 	int ret = 0; 	while (x){ 	    if (x->val < v) ret++; 	    if (v <= x->val) x = x->l; 	    else { ret += size(x->l); x = x->r; } 	} 	return ret;     } };   struct RangeTree {     vector<TreapSet<int> > d;     int m;     RangeTree(int n) { 	m=1; 	for (; m<n; ) m*=2; 	REP (i, 2) d.push_back(TreapSet<int>(0)); 	REP (i, 2) d.push_back(TreapSet<int>(m/2)); 	for (int i=4; i<2*m; i++) { 	    d.push_back(d[i/2].NODE_MAX/2); 	}     }     LL add(int p, int v) { 	LL ret = 0; 	p += m; 	for (; p > 1; p/=2) { 	    d[p].insert(v); 	    if (p % 2) ret += d[p-1].size() - d[p-1].count_lower(v+1); 	    else ret += d[p+1].count_lower(v); 	} 	return ret;     } };   int N, Q; int A[200011], L[100011], R[100011], K[100011]; int B[100011], M; int main() {     scanf("%d%d", &N, &Q);     REP (i, N) scanf("%d", A+i);     REP (i, Q) scanf("%d%d%d", L+i, R+i, K+i), L[i]--, K[i]--;       TreapSeq<int> AS, BS;     VI a_ord, b_pos(N);     REP (i, N) AS.insert(i, i);     REP (i, Q) { 	for (int j=L[i]; j<R[i]; j++) { 	    int x = *AS.at(j); 	    a_ord.push_back(x); 	    BS.insert(K[i]+j-L[i], x); 	} 	for (int j=L[i]; j<R[i]; j++) AS.erase(L[i]); 	// REP (i, AS.size()) eprintf("%d ", A[*AS.at(i)]); eprintf("\n"); 	// REP (i, BS.size()) eprintf("%d ", A[*BS.at(i)]); eprintf("\n");     }     REP (i, BS.size()) b_pos[*BS.at(i)] = i;            RangeTree X(N);     LL ans = 0;     int cur = 0;     REP (i, Q) { 	for (int j=L[i]; j<R[i]; j++) { 	    int id = a_ord[cur++]; 	    int val = A[id], pos = b_pos[id]; 	    ans += X.add(pos, val); 	} 	printf("%lld\n", ans);     }     return 0; }
#include<iostream> #include<vector> #include<cmath> using namespace std;   //float dist[30000][15000]; //vector <vector <int> >dist(30000); #define DIST(x,y,x1,y1) (((x-x1)*(x-x1))+((y-y1)*(y-y1)))   bool comp(pair<int, int> p1, pair<int, int> p2) {     return p1.second<p2.second; }   bool compp(pair<pair<int, int>, int > p1, pair<pair<int, int>, int > p2) {     if(p1.first.first!=p2.first.first)     return p1.first.first<p2.first.first;     return p1.first.second<p2.first.second; }   main() {  int i,j,n,t,d,d1;  scanf("%d",&t); // vector<pair<int, int> > p(30000);  vector<pair<pair<int, int>, int> >v(30000); // vector<pair<pair<int, int>, int> > v(30000; // vector<pair<int, int> >, int> > v(30000;  vector<pair<int, int> > r(30000);  vector<pair<int, int> > ctr(30000);  while(t--)  {     scanf("%d",&n);     for(i=0;i<n;i++)  {   scanf("%d %d",&v[i].first.first, &v[i].first.second);   v[i].second=i;   r[i].first=INT_MAX;   ctr[i].first=0;   //dist[i].resize(n-i-1);  }  //sort p  //cout<<"Unsorted"<<endl;  //for(i=0;i<n;i++)  //cout<<v[i].first.first<<" "<<v[i].first.second<<endl;  //cout<<endl;  sort(v.begin(),v.begin()+n, compp); // cout<<"Sorted"<<endl; // for(i=0;i<n;i++) // cout<<v[i].first.first<<" "<<v[i].first.second<<endl; // cout<<endl;    for(i=0;i<n;i++)  {    r[i].second=v[i].second;    ctr[i].second=v[i].second;        if(i!=0)    {    d=DIST(v[i].first.first, v[i].first.second, v[i-1].first.first, v[i-1].first.second);    r[i].first=d;    }    if(i!=n-1)    {    d=DIST(v[i].first.first, v[i].first.second, v[i+1].first.first, v[i+1].first.second);    if(d<r[i].first)    r[i].first=d;    }    for(j=i-2;j>=0&&(v[j].first.first-v[i].first.first)*(v[j].first.first-v[i].first.first)<r[i].first;j--)    {       d=DIST(v[j].first.first,v[j].first.second,v[i].first.first,v[i].first.second);       if(r[i].first>d)       r[i].first=d;    }    for(j=i+2;j<n&&(v[j].first.first-v[i].first.first)*(v[j].first.first-v[i].first.first)<r[i].first;j++)    {       d=DIST(v[j].first.first,v[j].first.second,v[i].first.first,v[i].first.second);       if(d<r[i].first)       r[i].first=d;    }    d=4*r[i].first;    for(j=i-1;j>=0&&(v[j].first.first-v[i].first.first)*(v[j].first.first-v[i].first.first)<=d;j--)    {       if(DIST(v[i].first.first,v[i].first.second,v[j].first.first,v[j].first.second)<=d)       ctr[i].first++;    }    for(j=i+1;j<n&&(v[j].first.first-v[i].first.first)*(v[j].first.first-v[i].first.first)<=d;j++)    {       if(DIST(v[i].first.first,v[i].first.second,v[j].first.first,v[j].first.second)<=d)       ctr[i].first++;    }  }        sort(r.begin(),r.begin()+n,comp);    sort(ctr.begin(),ctr.begin()+n,comp);  //  if(n==1)  //  {  //  float f=1<<(8*sizeof(float)-1)-1;j=0;  //  printf("%0.2f %d\n", f, j);   // }   // else   for(i=0;i<n;i++)   printf("%0.2f %d\n", sqrt((float)r[i].first), ctr[i].first);   printf("\n");   }  //system("PAUSE");  return 0; }
#include <iostream> #include <cstdio> #include <cctype> #include <string> #include <cmath> #include <vector> #include <algorithm> #include <stack> #include <queue> #include <map> #include <set> #include <sstream> #include <ctime> #include <cassert>  using namespace std;  #define GI ({int t;scanf("%d",&t);t;}) #define GL ({LL t;scanf("%lld",&t);t;}) #define GD ({double t;scanf("%lf",&t);t;}) #define GS ({string s;cin>>s;s;}) #define FOR(i,a,b) for(int i=a;i<b;i++) #define REP(i,n) FOR(i,0,n) #define ROF(i,a,b) for(int i=a;i>b;i--) #define SET(x,a) memset(x,a,sizeof(x)); #define all(a) a.begin(),a.end() #define rall(a) a.rbegin(),a.rend() #define tr(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define pb push_back #define sz(a) (int)(a.size()) #define INF (int)1e9 #define EPS (double)1e-9 #define is istringstream #define os ostringstream #define lb lower_bound #define ub upper_bound #define bs binary_search  typedef long long LL; typedef pair< int,int > ii; typedef vector< ii > vii; typedef vector < vii > vvii; typedef vector< int > vi; typedef vector< vi > vvi; typedef vector< string > vs;  char ch; #define MAXN 2005 int todel[MAXN][MAXN][2]; int len[MAXN][MAXN][2]; int sick[MAXN][MAXN][2]; int n;  int main(){     int t = GI;     while(t--){ 		string half = "", mhalf = "", shalf = "", s = "", a = ""; 		cin >> a;         n = sz(a);         REP(i, n + 1)    todel[i][i][0] = 0, todel[i][i][1] = 0, len[i][i][0] = 1, len[i][i][1] = 1;         REP(i, n)    todel[i + 1][i][0] = 0, todel[i + 1][i][1] = 0;         ROF(i, n - 1, -1)    FOR(j, i + 1, n)    REP(k, 2){             todel[i][j][k] = INF;                if(k & 1){                 if(a[i] > a[j])    todel[i][j][k] = todel[i + 1][j - 1][1 - k];                 todel[i][j][k] = min(todel[i][j][k], 1 + min(todel[i + 1][j][k], todel[i][j - 1][k]));                 len[i][j][k] = j - i + 1 - todel[i][j][k];             }             else{                 if(a[i] < a[j])    todel[i][j][k] = todel[i + 1][j - 1][1 - k];                 todel[i][j][k] = min(todel[i][j][k], 1 + min(todel[i + 1][j][k], todel[i][j - 1][k]));                 len[i][j][k] = j - i + 1 - todel[i][j][k];             }         }         if(len[0][n - 1][0] == 1){             char cur = '{';             REP(i, n)    if(a[i] < cur)    cur = a[i];             printf("%c\n", cur);         }         else{             int ans = len[0][n - 1][0], m = 0, lo = 0, hi = n - 1 , rem = ans, nc = 0, x, y;             char isok = 'a';             while(lo <= hi){                 if(len[lo][hi][m] <= 1)    break;                 x = -1;                 FOR(k, lo, hi + 1){                     if(a[k] == isok){                         x = k;                         break;                     }                 }                 if(x == -1){                     isok++;                     continue;                 }                 y = -1;                 if(m & 1){                     ROF(k, hi, x){                         if(a[k] < isok){                             y = k;                             break;                                 }                     }                 }                 else{                     ROF(k, hi, x){                         if(a[k] > isok){                             y = k;                             break;                                 }                            }                      }                 if(y == -1){                     isok++;                     continue;                 }                 if(len[x + 1][y - 1][1 - m] + 2 == rem){                     rem -= 2;                                 half += isok;                     isok = 'a';                     lo = x + 1, hi = y - 1;                     m = 1 - m;                 }                 else{                     isok++;                     continue;                 }             }             s += half;             int N = sz(s);             FOR(i, lo, n + 1)    sick[0][i][0] = 0, sick[0][i][1] = 0;             FOR(j, 0, N + 1)    sick[j][n][0] = 0, sick[j][n][1] = 0;             FOR(i, 1, N + 1)    ROF(j, n - 1, lo - 1)    REP(k, 2){                 if(k & 1){                     if(s[i - 1] > a[j])    sick[i][j][k] = 1 + sick[i - 1][j + 1][1 - k];                     else sick[i][j][k] = sick[i][j + 1][k];                      }                           else{                     if(s[i - 1] < a[j])    sick[i][j][k] = 1 + sick[i - 1][j + 1][1 - k];                     else sick[i][j][k] = sick[i][j + 1][k];                      }              }             int i = sz(s) - 1, j = lo, em = 1 - m, togo = ans - i - 1;             int how = 0, fpos = lo, apos = lo;             if(ans % 2)    togo--, j++, fpos++;              while(i >= 0 && j < n){                 if(sick[i + 1][j][em] == togo){                     char cur = '{';                     int pos = 0;                     while(sick[i + 1][j][em] == togo && j < n){                         if(em == 0){                             if(s[i] < a[j]){                                 if(a[j] < cur){                                     cur = a[j];                                     pos = j;                                         }                                     }                         }                              else{                             if(s[i] > a[j]){                                 if(a[j] < cur){                                     cur = a[j];                                     pos = j;                                         }                                     }                         }                              j++;                     }                     shalf += cur;                     j = pos + 1;                     how++;                     if(how == 1)    fpos = j - 1;                     togo--;                               em = 1 - em;                     i--;                 }                          else j++;              }             if(ans % 2){                 char cur = '{';                 FOR(q, apos, fpos){                     if(a[q] < cur)    cur = a[q];                 }                 mhalf += cur;             }             printf("%s%s%s\n", half.c_str(), mhalf.c_str(), shalf.c_str());         }     }     //cin >> ch;     return 0; } 
#include <stdio.h> #include <string.h>  const int BufSize = 4096; int bufPos = 0, bufLen = 0; char buffer[BufSize];  inline char ReadChar() { 	if(bufPos==bufLen){ 		bufLen=fread(buffer,1,BufSize,stdin); 		bufPos=0; 		if(bufLen==0) 			return '\n'; 	} 	return buffer[bufPos++]; }  int ReadInt() { 	int t; 	int s=1; 	if(bufLen-bufPos>10){ 		while(true){ 			char c=buffer[bufPos++]; 			if(c=='-') 				s=-1; 			else if(c>='0'&&c<='9'){ 				t=(c-'0'); 				break; 			} 		} 		while(true){ 			char c=buffer[bufPos++]; 			if(c>='0'&&c<='9') 				t=t*10+(c-'0'); 			else 				return s*t; 		} 	}else{ 		while(true){ 			char c=ReadChar(); 			if(c=='-') 				s=-1; 			else if(c>='0'&&c<='9'){ 				t=(c-'0'); 				break; 			} 		} 		while(true){ 			char c=ReadChar(); 			if(c>='0'&&c<='9') 				t=t*10+(c-'0'); 			else 				return s*t; 		} 	} }  #define SendMessage(x) 0  inline int abs(int x) { return (x<0)?(-x):(x); } inline void minimize(int &a,int b) { if(a>b) a=b; }  const int MAX_N = 100001; const int MAX_M = 300001;  int current, cn, vn, ven, vsn, vkn;  int _vd[2*MAX_N+1], _vc[2*MAX_N+1], _vi[2*MAX_N+1], _vl[2*MAX_N+1], _ve[2*MAX_N+1];  // (Strongly Connected) Components int cx[2*MAX_N]; // Component.example vertex  // Vertices int *const vd = _vd+MAX_N; // Vertex.done (on stack) int *const vc = _vc+MAX_N; // Vertex.component int *const vi = _vi+MAX_N; // Vertex.index int *const vl = _vl+MAX_N; // Vertex.lowlink int *const ve = _ve+MAX_N; // Vertex.first edge int veb[2*MAX_M], vep[2*MAX_M]; // Component edges int vs[2*MAX_N+MAX_M]; // Vertex stack int vk[MAX_N+1]; // Vertex.known, fixed labelling  void AddEdge(int a, int b) { 	veb[ven]=b; 	vep[ven]=ve[a]; 	ve[a]=ven++; }  bool Tarjan(int v) { 	vi[v]=vl[v]=current++; 	vs[vsn++]=v; 	vd[v]=1; 	for(int i=ve[v]; i!=-1; i=vep[i]){ 		int v1=veb[i]; 		// If v1 has a fixed labelling, it must be in another SCC 		if(vk[abs(v1)]){ 		}else if(vi[v1]==-1){ 			if(Tarjan(v1)) 				return true; 			minimize(vl[v],vl[v1]); 		}else if(vd[v1]){ 			minimize(vl[v],vi[v1]); 		} 	} 	if(vl[v]==vi[v]){ 		cx[cn]=v; 		int v1; 		do{ 			v1=vs[--vsn]; 			if(v1==-v) 				return true; 			vd[v1]=0; 			vc[v1]=cn; 		}while(v1!=v); 		cn++; 	} 	return false; }  bool ReadData() { 	int m; 	vn=ReadInt(); 	m=ReadInt(); 	memset(vk+1,0,sizeof(int)*vn); 	memset(vi-vn,-1,sizeof(int)*(2*vn+1)); 	memset(vl-vn,-1,sizeof(int)*(2*vn+1)); 	memset(vc-vn,-1,sizeof(int)*(2*vn+1)); 	memset(ve-vn,-1,sizeof(int)*(2*vn+1)); 	memset(vd-vn,0,sizeof(int)*(2*vn+1)); 	ven=vsn=vkn=0; 	bool conflict = false; 	for(int ie=0; ie<m; ++ie){ 		int a, b; 		a=ReadInt(); 		b=ReadInt(); 		if(b==a) 		{ 			int &k=vk[abs(a)]; 			if(k==0){ 				vs[vsn++]=a; 				++vkn; 				k=a; 			}else if(k==-a) 				conflict=true; 			//AddEdge(-a,a); 		} 		else if(b!=-a && !conflict) 		{ 			AddEdge(-a,b); 			AddEdge(-b,a); 		} 	} 	return conflict; }  bool AddKnowns() { 	while(vsn){ 		int v=vs[--vsn]; 		for(int ie=ve[v]; ie!=-1; ie=vep[ie]){ 			int b=veb[ie]; 			int ab=abs(b); 			int &k=vk[ab]; 			if(k==0){ 				k=b; 				vs[vsn++]=b; 				++vkn; 			}else if(k==-b) 				return true; 		} 	} 	return false; }  int Search() { 	SendMessage("Read Data"); 	if( ReadData() ) 		return 0; 	SendMessage("Follow implications of knowns"); 	if( AddKnowns() ) 		return 0; 	if( vkn==vn ) 		return 1; 	SendMessage("Find strongly connected components, checking for unsatisfiability"); 	current=cn=vsn=0; 	for(int iv=-vn; iv<=vn; ++iv) 		if(iv && vk[abs(iv)]==0 && vc[iv]==-1) 			if(Tarjan(iv)) 				return 0; 	SendMessage("Satisfiable. Check for an SCC A, where Not A -> A"); 	for(int iv=-vn; iv<=vn; ++iv){ 		if(iv && !vk[abs(iv)]) 		{ 			int c=vc[iv]; 			for(int i=ve[iv]; i!=-1; i=vep[i]){ 				int v1=veb[i]; 				int &k1=vk[abs(v1)]; 				if(!k1){ 					int c1=vc[v1]; 					if(vc[-cx[c1]]==c) 					{ 						vs[vsn++]=v1; 						k1=v1; 						++vkn; 						AddKnowns(); 						if(vn==vkn){ 							SendMessage("Complete solution found"); 							return 1; 						} 						break; 					} 				} 			} 		} 	} 	SendMessage("No complete solution found"); 	return 2; }  int main(int argc, char **argv) { 	int t; 	t=ReadInt(); 	for(int it=0; it<t; ++it){ 		int found = Search(); 		if( found == 0 ) 			printf("CONFLICT\n"); 		else if( found == 1 ) 			printf("UNIQUE\n"); 		else 			printf("MULTIPLE\n"); 	} 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  #define ll long long  const ll lim = 1ll<<60; const int maxn = 1000010;  struct CHT{ 	struct line{ 		ll slope, off, val; 		double xleft; 		int query_type; 		line(ll a = 0, ll b = 0){ 			slope = a; 			off = b; 			xleft = -(1e16); 			val = query_type = 0; 		} 		ll get_value(ll x) const{ 			return (slope*x + off); 		} 		friend int are_parallel(const line &l1, const line &l2){ 			return l1.slope==l2.slope; 		} 		friend double intersectX(const line &l1, const line &l2){ 			if(are_parallel(l1, l2)) 				return lim; 			double ret = (double)(l2.off-l1.off)/(l1.slope-l2.slope); 			return ret; 		} 		bool operator<(const line &l2) const{ 			if(!l2.query_type) 				return (slope<(l2.slope)); 			return xleft>(l2.val); 		} 	}; 	set<line> hull; 	int irrelevant(const line &l1, const line &l2, const line &l3){ 		return intersectX(l1, l3)<=intersectX(l1, l2); 	} 	int irrelevant(set<line> :: iterator it){ 		set<line> :: iterator p, n; 		if(it!=hull.begin() && it!=hull.end()){ 			n = p = it; 			n++; 			p--; 			if(n!=hull.end()){ 				if(irrelevant(*n, *it, *p)) 					return 1; 			} 		} 		return 0; 	} 	int has_next(set<line> :: iterator it){ 		set<line> :: iterator n = it; 		n++; 		return (it!=hull.end() && n!=hull.end()); 	} 	set<line> :: iterator update_xleft(set<line> :: iterator it){ 		if(!has_next(it)){ 			return it; 		} 		set<line> :: iterator n = it; 		n++; 		double cut = intersectX(*it, *n); 		line l(*it); 		hull.erase(it); 		l.xleft = cut; 		it = hull.insert(hull.begin(), l); 		return it; 	} 	void insert(ll slope, ll off){ 		line l3 = line(slope, off); 		set<line> :: iterator it = hull.lower_bound(l3); 		set<line> :: iterator jt; 		if(it!=hull.end() && are_parallel(*it, l3)){ 			if(it->off > off){ 				jt = it; 				hull.erase(jt); 				it--; 			} 			else 				return; 		} 		it = hull.insert(it, l3); 		if(irrelevant(it)){ 			hull.erase(it); 			return; 		} 		set<line> :: iterator p, n; 		while(1){ 			p = it; 			p--; 			if(it!=hull.begin() && irrelevant(p)) 				hull.erase(p); 			else 				break; 		} 		while(1){ 			n = it; 			n++; 			if(it!=hull.end() && n!=hull.end() && irrelevant(n)) 				hull.erase(n); 			else 				break; 		} 		it = update_xleft(it); 		if(it!=hull.begin()){ 			p = it; 			p--; 			update_xleft(p); 		} 		n = it; 		n++; 		if(it!=hull.end() && n!=hull.end()){ 			update_xleft(n); 		} 	} 	ll query(ll x){ 		line l; 		l.query_type = 1; 		l.val = x; 		set<line> :: iterator it = hull.lower_bound(l); 		if(it==hull.end()) 			return lim; 		return it->get_value(x); 	} };  int n; ll p[maxn], h[maxn], a[maxn]; CHT ft[maxn];  void update(int x, ll slope, ll off) { 	while(x<=n){ 		ft[x].insert(slope, off); 		x+=(x&(-x)); 	} }  ll read(int idx, ll x) { 	ll ret = lim; 	while(idx>0){ 		ret = min(ret, ft[idx].query(x)); 		idx-=(idx&(-idx)); 	} 	return ret; }  int main() { 	//freopen("i.txt", "r", stdin); 	int i; 	ll ans=0, par=0; 	scanf("%d", &n); 	for(i=1; i<=n; i++) 		scanf("%lld", &p[i]); 		//p[i] = h[i] = a[i] = i; 	for(i=1; i<=n; i++) 		scanf("%lld", &a[i]); 	for(i=1; i<=n; i++) 		scanf("%lld", &h[i]); 	update(p[1], -2ll*h[1], a[1]+(h[1]*h[1])); 	for(i=2; i<=n; i++){ 		par = read(p[i]-1, h[i]); 		ans = par + (h[i]*h[i]) + a[i]; 		update(p[i], -2ll*h[i], ans+(h[i]*h[i])); 	} 	printf("%lld\n", ans); 	return 0; }
/* Jai Gupta */ #include <iostream> #include <cstdio> #include <vector> #include <stack> #include <queue> #include <string> #include <cstring> #include <map> #include <cstdlib> #include <algorithm> #include <list> #include <deque> #include <bitset> #include <cmath> #include <functional> #include <set> #include <sstream>  using namespace std;  #define INT_MAX 2147483647 #define INT_MIN -2147483648 #define MAX(a,b)   (((a)>(b))?(a):(b)) #define MIN(a,b)   (((a)<(b))?(a):(b)) #define CMAX(a,b)  if((a)<(b)) a=b #define CMIN(a,b)  if((a)>(b)) a=b #define FOR(i,a,b)   for(i=a; i<b; i++) #define REVI(i,a,b)  for(int i= a ; i >= b ; --i) #define LET(x,a)     __typeof(a) x(a) #define IFOR(i,a,b)  for(LET(i,a);i!=(b);++i) #define DFOR(i,a,b)  for(LET(i,a);i<(b);++i) #define EACH(it,v)   IFOR(it,v.begin(),v.end()) #define SWAP(a,b,t)  t=a,a=b,b=t #define REP(i,n)     for(__typeof(n) i(0); i<n; i++) #define gint(t)      scanf("%d", &t); #define pint(t)      printf("%d\n", t); #define pb           push_back #define ALL(x)       (x).begin(), (x).end()  #ifdef JAI_ARENA #define debug(args...) {dbg,args; cerr<<endl;} #define dline cerr<<endl #else #define debug(args...) {}; #endif  typedef long long int   ll; typedef unsigned long long int ull; typedef unsigned int    uint; typedef pair<int, int>  pii; typedef vector<int>     vi; typedef vector<vi>      vii; typedef vector<pii>     vpii;  struct debugger {     template<typename T> debugger& operator , (const T& v) 	{ 	    cerr<<v<<" "; 	    return *this; 	} } dbg;   #define BUF 4096 char ibuf[BUF]; int ipt = BUF;   int readUInt() {     while (ipt < BUF && ibuf[ipt] < '0') ipt++;     if (ipt == BUF) { 	fread(ibuf, 1, BUF, stdin); 	ipt = 0; 	while (ipt < BUF && ibuf[ipt] < '0') ipt++;     }     int n = 0; char neg = 0;     if(ipt !=0 && ibuf[ipt-1] == '-') neg = 1;     while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');     if (ipt == BUF) { 	fread(ibuf, 1, BUF, stdin); 	ipt = 0; 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');     }     return neg?-n:n; }  #define MODN 1000000007 #define MAXN 1000000 ll fact[1000000]; ll invfact[1000000]; int power(int x, unsigned n) {     ll intermediateProduct = x;     ll result = 1;     while(n)     {         if (n & 1)             result = (intermediateProduct * result)%MODN;         n >>= 1;         intermediateProduct = (intermediateProduct * intermediateProduct)%MODN;     }     return result; } int inverse(int x){     return power(x, MODN-2); } void factAndInvfact(){     fact[0]=1;     for(int i=1; i<=MAXN; i++) 	fact[i]=((long long)i*fact[i-1])%MODN;     invfact[MAXN]=inverse(fact[MAXN]);     for(int i=MAXN; i>0; i--) 	invfact[i-1]=((long long)i*invfact[i])%MODN; }  ll nCr(int n1, int n2) {     return ((fact[n1+n2]*invfact[n1]%MODN)*invfact[n2])%MODN; } int gcd(int a, int b) {     int x;     while(b)     { 	x = a%b; 	a = b; 	b = x;     }     return a; }  int delta; ll getNumWays(int x, int y, 	      int ax, int ay, int bx, int by) {          if(delta==0) return 0;     int numalpha = x*by-y*bx;     int numbeta  = y*ax-x*ay;     //debug("pars", x, y, ax, ay, bx, by, numalpha, numbeta, delta);     if(numalpha%delta != 0) return 0;     if(numbeta %delta != 0) return 0;     int n1 = numalpha/delta;     int n2 = numbeta /delta;     //debug(n1, n2);     if(n1<0 || n2<0) return 0;     return nCr(n1,n2); } #define ES 2010 #define DFS_DEPTH 2000 char inf_list[2*ES]; char done[2*ES]; char in_parent[2*ES]; int nm[2*ES]; int nm2[2*ES]; set<int> blist; int dfs_x, dfs_ax, dfs_bx, ax, ay, bx, by, x, y; void dfs_set_inf_list(int sx, int depth) {     if(blist.find(sx)!=blist.end()) return;     done[sx] = 1;     int v1 = sx+dfs_ax;     int v2 = sx+dfs_bx;     if(v1<0||v1>=2*ES || v2<0 || v2>=2*ES) return;     if(depth<0) return;     in_parent[sx] = 1;     if(!done[sx+dfs_ax]) dfs_set_inf_list(sx+dfs_ax, depth-1);     else if(in_parent[sx+dfs_ax]) inf_list[sx] = 1;     if(dfs_bx != dfs_ax && !done[sx+dfs_bx]) dfs_set_inf_list(sx+dfs_bx, depth-1);     else if(dfs_bx!=dfs_ax && in_parent[sx+dfs_bx]) inf_list[sx] = 1;     in_parent[sx] = 0; } int bfs_get_num_ways(int sx) {     int *n1 = nm;     int *n2 = nm2;     memset(nm, 0, sizeof nm);     n1[sx] = 1;     debug("in bfs", (int)inf_list[dfs_x], dfs_x, (int)inf_list[dfs_x-2], (int)inf_list[1006]);     EACH(it, blist) { n2[*it] = 0; inf_list[*it] = 0; debug(*it, "set to zero!");}     REP(ki, 1500) { 	REP(ni, 2*ES) 	{ 	    if(inf_list[ni]) continue; 	    if(blist.find(ni)!=blist.end()) continue; 	    n2[ni] = 0; 	    int k = ni-dfs_ax; 	    if(1) { 		if(k>=0 && k<2*ES) { 		    if(inf_list[k]) {inf_list[ni]=1; if(ni==dfs_x)debug("from", k, dfs_ax);} 		    n2[ni] += n1[k]; 		} 	    } 	    if(dfs_bx != dfs_ax) { 		k = ni-dfs_bx; 		if(k>=0 && k<2*ES) { 		    if(inf_list[k]) {inf_list[ni]=1; if(ni==dfs_x)debug("from", k);} 		    n2[ni] += n1[k]; 		} 	    } 	    n2[ni]%=MODN; 	} 	//debug("in bfs", (int)inf_list[dfs_x], dfs_x); 	if(inf_list[dfs_x]) return -1; 	n2[sx] = 1; //debug(sx, "set to zero"); 	//EACH(it, blist) { n2[*it] = 0; inf_list[*it] = 0; debug(*it, "set to zero!");} 	int *tmp = n1; n1=n2; n2=tmp;     }     return n1[dfs_x]; } void solve() {     int k; gint(x); gint(y); gint(k);     gint(ax); gint(ay); gint(bx); gint(by);     dfs_x = x+ES;     //debug(x, y, ax, ay, bx, by);     int blocked[k+2][2];     REP(ki, k) { 	gint(blocked[ki][0]); 	gint(blocked[ki][1]);     }     if(ax==0 && ay==0 && bx==0 && by==0)     { 	if(x==0 && y==0) { pint(-1); return; } 	else {pint(0); return;}     }     delta = ax*by-bx*ay;     blocked[k][0] = 0;   blocked[k][1] = 0;     blocked[k+1][0] = x; blocked[k+1][1] = y;     if(x>0 && ax<=0 && bx<=0) { pint(0); return; }     if(x<0 && ax>=0 && bx>=0) { pint(0); return; }     if(y>0 && ay<=0 && by<=0) { pint(0); return; }     if(y<0 && ay>=0 && by>=0) { pint(0); return; }     if(delta ==0) { 	blist.clear(); 	int gx = gcd(abs(ax), abs(bx)); 	int gy = gcd(abs(ay), abs(by)); 	if(ax == 0 && ay == 0) 	{ 	    if(bx*by<0) gy = -gy; 	} 	else if((ax*ay)<0){ 	    gy = -gy; 	} 	dfs_ax = ax; dfs_bx = bx; dfs_x = x+ES; 	bool flag = false; 	if(ax==0 && bx==0) { 	    flag = true; 	    dfs_ax=ay; dfs_bx = by; dfs_x = y+ES; 	} 	if(gx == 0) 	{ 	    if(x!=0 || y %gy !=0) {pint(0); return;} 	} 	else if(gy == 0) 	{ 	    if(y!=0 || x %gx !=0) {pint(0); return;} 	}else { 	    if(x%gx!=0 || y%gy !=0 || x/gx != y/gy) { pint(0); return; } 	} 	REP(ki, k) 	{ 	    if(gx == 0) 	    { 		if(blocked[ki][0]!=0 || blocked[ki][1] %gy !=0) continue; 	    } 	    else if(gy == 0) 	    { 		if(blocked[ki][1]!=0 || blocked[ki][0] %gx !=0) continue; 	    }else { 		if(blocked[ki][0]%gx!=0 ||blocked[ki][1]%gy!=0 ||  		   blocked[ki][0]/gx != blocked[ki][1]/gy ) continue; 	    } 	    if(!flag) 		blist.insert(blocked[ki][0]+ES); 	    else 		blist.insert(blocked[ki][1]+ES); 	} 	EACH(it, blist) debug("blocked", *it, dfs_ax,dfs_bx); 	debug("inf list 4", (int)inf_list[dfs_x], dfs_x); 	memset(inf_list,  0, sizeof inf_list); 	memset(in_parent, 0, sizeof in_parent); 	memset(done,      0, sizeof done); 	 	dfs_set_inf_list(ES,DFS_DEPTH); 	int ways = bfs_get_num_ways(ES); 	pint(ways); return;         // greedy solve to check that there is exactly one way or there are infinitely many.         // dfs for initial cycle finding.         // bfs to extend the cycles or finite no of ways 	return;     }     int nump = k+2;     ll res[1<<nump];     int s[1<<nump];     int e[1<<nump];     ll r=0;          REP(ni, 1<<nump) { 	int numc = __builtin_popcount(ni); 	if(numc <=1) { continue;} 	if(numc == 2) 	{ 	    int p1=k+3; int p2; 	    while(((1<<p1)&ni) == 0) p1--; 	    p2 = p1-1; 	    while(((1<<p2)&ni) == 0) p2--; 	    res[ni] = getNumWays(blocked[p2][0] - blocked[p1][0], blocked[p2][1] - blocked[p1][1], ax, ay, bx, by); 	     	    if(res[ni] > 0) 	    { 		s[ni] = p1; e[ni] = p2; 	    }else { 		res[ni] = getNumWays(blocked[p1][0] - blocked[p2][0], blocked[p1][1] - blocked[p2][1], ax, ay, bx, by); 		s[ni] = p2; e[ni] = p1; 	    } 	}else { 	    res[ni] = 0; 	    //bool flag=false; 	    REP(mi, nump) 	    { 		int k = ni&(~(1<<mi)); 		if(k==ni||res[k] == 0) continue; 		int l = (1<<e[k])|(1<<mi); 		if(e[k]<0 || e[k]>=nump) while(1); 		if(s[l] != e[k] || res[l] == 0) continue; 		res[ni] = (res[k]*res[l])%MODN; 		s[ni] = s[k]; 		e[ni] = mi; 		//if(flag == true) debug("error"); 		//debug(ni, k, s[k], e[k], l); 		//flag = true; 		break; 		//break; 	    } 	} 	if(s[ni]==k && e[ni]==k+1){ 	    if(numc&1) r=(r-res[ni])%MODN; 	    else       r=(r+res[ni])%MODN; 	    //debug(ni, r, nump); 	} 	//debug("vals", ni, res[ni], s[ni], e[ni]);     }     if(r<0) r+=MODN;     printf("%lld\n", r); }  int main() {     int t; cin>>t;     factAndInvfact();     while(t--)     { 	solve();     }     //printf("wonng");     return 0; } 
 import java.io.*; import java.util.*;    class WaitForIt {  //  static Map<Integer,Long> memo = new HashMap<Integer, Long>();      static ILMap memo;      static final long mod = 1_000_000_007;    static void init(){     memo = new ILMap();   }      static class ILMap{     static int S = 20_000_003;     int[] in = new int[S];     long[] out = new long[S];     public ILMap() {       Arrays.fill(out,-1);     }     int getLoc(long x){       int loc = (int) ((x+x) % (long) S);       while(in[loc]!= 0 && in[loc]!=x){         loc ++;         if(loc == S)           loc = 0;       }       return loc;     }          long get(int x){       return out[getLoc(x)];           }     void put(int x,long y){       int l = getLoc(x);       in[l] = x;       out[l] = y;     }   }      static long count(int n){     if(n == 1) return 1;     long ret = memo.get(n);     if(ret != -1)       return ret;     long r = n;     r *= r;     int rn = (int) Math.sqrt(n);     for(int i=2; i<=rn; ++i)       r -= count(n/i);     rn = n/rn;     for(int i=1; i<rn; ++i)       r -= count(i)*(n/i - n/(i+1));     r %= mod;     if (r < 0) r += mod;     memo.put(n,r);     return r;   }      static long solve(long a0, long b0, int n){     long ret = 0;     long a,b;     a=b=1;     for(int i=1; i<=n; ++i){       a = a*a0 % mod;       b = b*b0 % mod;       long c = a-b;       if(c < 0)         c += mod;       ret += c*count(n/i);       ret %= mod;     }     System.out.println(ret);     return ret;   }         static long pow(long x,int y){     x %= mod;     long ret = 1;     for(;y>0; y>>=1){       if((y & 1) > 0)         ret = (ret * x) % mod;       x = (x * x) % mod;     }     return ret;   }      public static long[] gcd(long p, long q){     if (q == 0)       return new long[] { p, 1, 0 };      long[] vals = gcd(q, p % q);     long d = vals[0];     long a = vals[2];     long b = vals[1] - (p / q) * vals[2];     return new long[] { d, a, b };   }    public static long inv(long x){     if(x < 0)       x += mod;     long ret = gcd(mod,x)[2];     if(ret < 0)       ret += mod;     return ret;   }       static long solve2(long a0, long b0, int n){     long ret = 0;     long a,b;     a=b=1;     int rn = (int) Math.sqrt(n);     for(int i=1; i<=rn; ++i){       a = a*a0 % mod;       b = b*b0 % mod;       long c = a-b;       if(c < 0)         c += mod;       ret += c*count(n/i);       ret %= mod;     }     rn = n/rn;     long ai = inv(a0-1);     long bi = b0==1 ? 1 : inv(b0-1);     for(int i=1; i<rn; ++i){       int i0 = n/(i+1)+1;       int i1 = n/i;       a = pow(a0,i1+1)-pow(a0,i0);       b = b0 == 1 ? i1-i0+1 : pow(b0,i1+1)-pow(b0,i0);       a *= ai;       b *= bi;       a %= mod;       b %= mod;       long c = a-b;       c %= mod;       if(c < 0)         c += mod;              ret += c*count(i);       ret %= mod;          }          System.out.println(ret);         return ret;   }         static long solve3(long a0, long b0, int n){     long ret = 0;     long a,b;     a=b=1;     int rn = (int) Math.sqrt(n);     for(int i=1; i<=rn; ++i){       a = a*a0 % mod;       b = b*b0 % mod;       long c = a-b;       if(c < 0)         c += mod;       ret += c*count(n/i);       ret %= mod;     }     rn = n/rn;     long ai = inv(a0-1);     long bi = b0==1 ? 1 : inv(b0-1);          int i1 = n/(rn);     long ap = pow(a0,i1+1);     long bp = pow(b0,i1+1);          for(int i=rn-1; i>0; --i){       int i0 = i1;       i1 = n/i;       a = - ap;       ap *= pow(a0,i1-i0);       ap %= mod;       a += ap;       a %= mod;              if(b0 == 1)         b = i1-i0;       else{         b = - bp;         bp *= pow(b0,i1-i0);         bp %= mod;         b += bp;         b %= mod;       }       a *= ai;       b *= bi;       a %= mod;       b %= mod;       long c = a-b;       c %= mod;       if(c < 0)         c += mod;              ret += c*count(i);       ret %= mod;          }          System.out.println(ret);         return ret;   }         public static void main(String[] args) throws Exception{     //goFile("input/input.txt");     init();     go();   }      static int[] getInts(BufferedReader br) throws IOException{     String[] ss = new String[0];     while(ss.length==0 || "".equals(ss[0])) ss =  br.readLine().split(" ");     int[] ret = new int[ss.length];     for(int i=0; i<ss.length; ++i){       ret[i] = Integer.parseInt(ss[i]);     }     return ret;   }    static void goFile(String s) throws Exception{     go(new FileReader(new File(s)));   }    static void go() throws Exception{     go(new InputStreamReader(System.in));   }     static void go(Reader r) throws Exception{     BufferedReader br = new BufferedReader(r);     int t = getInts(br)[0];     for(int i=0; i<t; ++i){       int[] x = getInts(br);       solve3(x[0],x[1],x[2]);     }   } } 
    #include <cstdio>     #include <algorithm>     using namespace std;     typedef long long int64;     const int N = 200000;     int D, T;     int diagMask[N];     bool marked[N + 1];     int lose[N + 1];     int W[100010][4];     int ans[100010];           struct Query{     int x, y, flag, i;     Query(){}     Query(int _x, int _y, int _flag, int _i):     x(_x), y(_y), flag(_flag), i(_i){}     bool operator< (const Query &t) const{     return x < t.x;     }     void set(int t){     ans[i] += flag * t;     }     } Q[400000];     int nQ;           int bit[200010];           void add(int x, int y){     for(; x <= N; x += x & -x)     bit[x] += y;     }           int sum(int x){     int res = 0;     for(; x; x -= x & -x)     res += bit[x];     return res;     }           int64 gcd(int64 a, int64 b){     return b ? gcd(b, a % b) : a;     }           int main(){     // freopen("t.in", "r", stdin);     scanf("%d", &D);     for(int x = 1, y0 = 1, dg = 0; x <= N; x ++)     if(!marked[x]){     for(; y0 <= N && marked[y0]; y0 ++);     if(y0 > N)     break;     for(; dg < N && diagMask[dg] == (1 << D) - 1; dg ++);     int y;     for(y = max(y0, x + dg); y <= N && (marked[y] || (diagMask[y - x] & 1 << (x % D))); y ++);     if(y <= N){     lose[x] = y;     lose[y] = x;     diagMask[y - x] |= 1 << (x % D);     marked[y] = true;     }     marked[x] = true;     }     scanf("%d", &T);     for(int i = 1; i <= T; i ++){     int x1, y1, x2, y2;     scanf("%d%d%d%d", &x1, &y1, &x2, &y2);     W[i][0] = x1; W[i][1] = y1; W[i][2] = x2; W[i][3] = y2;     Q[nQ ++] = Query(x2, y2, 1, i);     Q[nQ ++] = Query(x1 - 1, y2, -1, i);     Q[nQ ++] = Query(x2, y1 - 1, -1, i);     Q[nQ ++] = Query(x1 - 1, y1 - 1, 1, i);     }     sort(Q, Q + nQ);     for(int x = 1, i = 0; x <= N; x ++){     if(lose[x])     add(lose[x], 1);     while(i < 4 * T && Q[i].x < x)     i ++;     while(i < 4 * T && Q[i].x == x)     Q[i].set(Q[i].y ? sum(Q[i].y) : 0), i ++;     if(i == 4 * T)     break;     }     for(int i = 1; i <= T; i ++){     int64 b = (int64)(W[i][2] - W[i][0] + 1) * (W[i][3] - W[i][1] + 1),     a = ans[i];     int64 g = gcd(a, b);     printf("%lld/%lld\n", a / g, b / g);     }     } 
#include <algorithm> #include <iostream> #include <cassert> #include <cstdio> #include <cstring>  using namespace std;  typedef long long lli;  int ct[100010];  int N;  lli tree[100010];  int mxn = 100000;  void upd(int x, lli val){ 	while(x <= mxn){ 		tree[x] += val; 		x += (x&-x); 	} }  lli read(int x){ 	if(x <= 0) return 0; 	lli sol = 0; 	while(x){ 		sol +=tree[x]; 		x -= (x&-x); 	}  	return sol; }  lli query(int i, int j){ 	if(i > j) return 0; 	return  read(j)-read(i-1); }  int M;  int main(){  	lli tot = 0; 	int i;  	scanf("%d",&N);  	char c; 	int x,y;  	for(i =0; i < N; ++i){ 		scanf("%d",&x); 		scanf("%d",&ct[x]);  		tot += ct[x]; 		upd(x,1LL*ct[x]*x);  	}   	int y2; 	scanf("%d",&M); 	lli sol = 0; 	while(M--){  		scanf(" %c %d",&c,&x);  		if(c^'?'){ 			if(c == '+'){ 				tot += 1; 				ct[x]++; 				upd(x,x); 			}else{ 				tot -= 1; 				ct[x]--; 				upd(x,-x); 			} 			continue; 		}  		y=x; 		sol = 0; 		for(i = 1; i*i <= y; ++i){ 			sol += 1LL*ct[i]*i*(y/i); 		}  		x =i; 		for(y2 = y/i; y2 > 0; --y2){ 			i = y/y2; 			sol += query(x,i)*1LL*y2;  			x=i+1;  		}  		sol = (1LL*tot*y)-sol; 		printf("%lld\n",sol); 	}  	return 0; } 
#include <stdio.h> #include <math.h> #include <time.h> #include <string.h> #include <iostream> #include <fstream> #include <algorithm> #include <string> #include <vector> #include <set> #include <map> #pragma comment(linker, "/STACK:16777216") using namespace std;   typedef vector<int> VI; typedef pair<int,int> PII; #ifndef ONLINE_JUDGE typedef __int64 LL; #else typedef long long LL; #endif   #define bit(n) (1<<(n)) #define inf 1000000000 #define eps 1e-9 #define PI 3.1415926535897932385 #define pb push_back #define sz size() #define mp make_pair #define cl clear() #define all(a) a.begin(),a.end() #define fill(ar,val) memset(ar,val,sizeof ar) #define MIN(a,b) if(a>(b)) a=(b) #define MAX(a,b) if(a<(b)) a=(b) #define sqr(x) ((x)*(x)) #define min(a,b) ((a)<(b)?(a):(b)) #define max(a,b) ((a)>(b)?(a):(b))   clock_t start=clock();   #define N 4000404 int ro[N];   #define M 4444 int xA[M],xB[M],x[2*M];   int T(int x) { return x*(x+1)/2; }   int gcd(int a,int b) { int c; while(b)c=a%b,a=b,b=c; return a; }   int brute(int A,int B) { int ans=0; for(int a=1;a<=A;a++) for(int b=1;b<=B;b++) { int d=gcd(a,b); int i; for(i=2;i*i<=d && d%(i*i);i++); if(i*i>d) ans+=b/d*a; } ans%=bit(30); if(ans<0) ans+=bit(30); return ans; }   int main() { #ifndef ONLINE_JUDGE freopen("in.txt","r",stdin); #endif int i,j,k; for(i=2;i*i<N;i++) if(!ro[i]) for(j=i+i;j<N;j+=i) if(!ro[j]) ro[j]=i; ro[1]=1; for(i=2;i<N;i++) { k=ro[i]; if(!k) ro[i]=1-i; else { j=i/k; if(j%k) ro[i]=(1-k)*ro[j]; else { j/=k; if(j%k) ro[i]=-k*ro[j]; else ro[i]=0; } } } for(i=2;i<N;i++) ro[i]=i*ro[i]+ro[i-1]; int TST; int A,B; for(scanf("%d",&TST);scanf("%d%d",&A,&B)>0;) { xA[0]=0; int xAlen=1; for(i=1;i<A/i;i++) xA[xAlen++]=i; if(i>A/i) i--; for(;i>0;i--) xA[xAlen++]=A/i;   xB[0]=0; int xBlen=1; for(i=1;i<B/i;i++) xB[xBlen++]=i; if(i>B/i) i--; for(;i>0;i--) xB[xBlen++]=B/i;   for(i=j=k=0;i<xAlen || j<xBlen;) if(i==xAlen) x[k++]=xB[j++]; else if(j==xBlen) x[k++]=xA[i++]; else { if(xA[i]<xB[j]) x[k++]=xA[i++]; else if(xA[i]>xB[j]) x[k++]=xB[j++]; else x[k++]=xA[i],i++,j++; } int xlen=k; int ans=0; for(i=1;i<xlen;i++) ans+=T(A/x[i])*T(B/x[i])*(ro[x[i]]-ro[x[i-1]]); ans%=bit(30); if(ans<0) ans+=bit(30); /*int ans1=brute(A,B); printf("brute=%d ",ans1); if(ans!=ans1) printf("ERROR ");*/ printf("%d\n",ans); } fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start)); return 0; }
#include <cstdio> #include <iostream> #include <cstdio> #include <algorithm> #include <vector> using namespace std;  int T, n, m, i;  const int INF = 1000000000; struct item { 	int d; 	int c; }; struct box { 	int v; 	double p; };  box b[50]; item a[50]; int h[35][35], j, k, t; int minDol[35][35]; int mxDi[35]; double res = 0; double dp[33][33][33]; vector <pair <int, double> >G1[32], G2[32]; int up[50][50], c1, c2, mask;  vector <double > sum[31];   double ret; bool cmp(box a, box b) { 	if (a.v > b.v) 		return true; 	if (a.v < b.v) 		return false; 	return a.p > b.p; } bool cmp2(item a, item b) { 	if (a.d < b.d) 		return true; 	if (a.d>  b.d) 		return false; 	return a.c < b.c; } int l, r,mm; int mnful[35]; double probSum[31][31]; int main() { 	//freopen("input.txt","r",stdin); 	cin >> T; 	while (T--) 	{    		cin >> n >> m; 		int tmp; 		 		for (i = 0; i < 30; i++) 		{ 			G1[i].clear(); 			G2[i].clear(); 			sum[i].clear(); 		}   		for (i = 0; i < n; i++) 		{ 			cin >> b[i].v >> tmp; 			b[i].p = tmp / 100.; 		} 		for (i = 0; i < m; i++) 			cin >> a[i].c >> a[i].d; 		sort(b, b+ n, cmp); 		for (i = 0; i <=n; i++) 			for (j = 0; j <=m; j++) 				h[i][j] = INF; 		//sort(a, a + m, cmp2); 		h[0][0] = 0; 		 		for (k = 0; k < m; k++) 		{ 			for (i = n; i >= 0; i--) 				for (j = m; j >= 0; j--) 				{ 					if (h[i][j] == INF) 						continue; 					if (i + a[k].d > n) 						continue; 					if (h[i + a[k].d][j + 1] > h[i][j] + a[k].c) 						h[i + a[k].d][j + 1] = h[i][j] + a[k].c; 				} 		} 		 	for (i = 0; i<=32; i++) 		for (j = 0; j <=32; j++) 			minDol[i][j] = INF; 	for (i = n; i >=0; i--) 		for (j = m; j >=0; j--) 			for ( k = i; k>=0; k--) 				minDol[i][j] = min(minDol[i][j],h[k][j]);  	     		for (mask = 0; mask < (1 << n / 3); mask++) 		{ 			int d = 0; 			double prob = 1; 			int c = 0; 			for (j = 0; j < n/3; j++) 			{ 				if (mask & (1 << j)) 				{ 					prob *= b[j].p; 					c += b[j].v; 				}else 				{ 					prob *= (1 - b[j].p); 					d ++; 				} 			} 			G1[d].push_back(make_pair(c,prob)); 		} 		 		int n2 = n - n/3; 		for (mask = 0; mask < (1 << n2); mask++) 		{ 			int d = 0; 			double prob = 1; 			int c = 0; 			for (j = 0; j < n2; j++) 			{ 				if (mask & (1 << j)) 				{ 					prob *= b[j + n/3].p; 					c += b[j + n/3].v; 				}else 				{ 					prob *= (1 - b[j + n/3].p); 					d ++; 				} 			} 			G2[d].push_back(make_pair(c,prob)); 		}  	for (i = 0; i < 30; i++) 	{ 		sort(G1[i].begin(), G1[i].end()); 		sort(G2[i].begin(), G2[i].end()); 	} 	for (i = 0; i < 30; i++) 	{ 		double s = 0; 		for (j = 0; j < G2[i].size(); j++) 		{ 			s+= G2[i][j].second; 			sum[i].push_back(s); 		} 	}        	for (i = n; i >=0; i--) 		for (j = 0; j <=m; j++) 			if (minDol[i][j] != INF) 				mxDi[i] = j;  	/*for (k = 0; k < n; k++) 	{ 		for (i = 0; i <= 31; i++) 			for (j = 0; j<=31; j++) 				dp[k][i][j] = 0; 		dp[k][k][0] = 1; 		for (i = k; i < n; i++) 			for (j = 0; j < n; j++) 			{ 				dp[k][i + 1][j + 1] += dp[k][i][j] * (1 - b[i].p); 				dp[k][i + 1][j] += dp[k][i][j] * b[i].p; 			} 	} 	int d; 	for (d = 0; d < n; d++) 		for (j = 0; j <= n; j++) 			for (i = 0; i<=j; i++) 				if (d + i <=n) 					up[d][j] = max(up[d][j], minDol[d + i][mxDi[d+i]]);*/  	res = 0;   	double p1, p2, prob; 	int d1, d2, d, c, ll, rr, mm, k1, k2; 	 	for (d = 0; d <=n; d++) 		for (j = 0; minDol[d][j] != INF; j++) 		{ 			//probability of  gettin exactly d diamonds and money between c1 & c2; 			c1 = minDol[d][j]; 			c2 = minDol[d][j + 1]; 			prob = 0; 			for(d1 = 0; d1 <=d; d1++) 			{ 				d2 = d - d1; 				for (i = 0; i < G1[d1].size(); i++) 				{ 					c = G1[d1][i].first; 					p1 = G1[d1][i].second; 					if (c >= c2) 						continue; 					if (G2[d2].size() == 0) 						continue; 					// getProb of gettin c1 - c2 money from G2 					ll = 0; 					rr = G2[d2].size(); 					while (ll != rr) 					{ 						mm = (ll + rr) / 2; 						if (G2[d2][mm].first < c1 - c) 							ll = mm + 1; 						else 							rr = mm; 					} 					k1 = ll;  					if (k1 == G2[d2].size()) 						continue; 					ll = 0; 					rr = G2[d2].size();  					while (ll != rr) 					{ 						mm = (ll + rr) / 2; 						if (G2[d2][mm].first < c2 - c) 							ll = mm + 1; 						else 							rr = mm; 					}  					if (ll == 0) 						continue; 					k2 = ll- 1;  					prob += sum[d2][k2] * p1; 					if (k1 > 0) 						prob -= sum[d2][k1 - 1] * p1; 				} 			} 			res += prob * j; 		} 					  	printf("%.4lf\n", res); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <sstream>   #include <algorithm> #include <vector> #include <deque> #include <queue> #include <stack> #include <set> #include <map>   #include <cstdlib> #include <cstring> #include <cassert> #include <bitset> #include <ctime>   using namespace std;   typedef long long int64;   #define endl '\n' #define SZ(c) ((int)((c).size())) #define REP(i, n) for (int i = 0; i < (int)(n); ++i) #define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i) #define ALL(c) (c).begin(), (c).end()   struct IO { 	int cur; 	inline char nextChar() { return cur = getc_unlocked(stdin); } 	inline char peekChar() { return cur; } 	inline operator bool() { return (peekChar() != 0); } 	inline static bool isSpace(char c) { return (c < '0' && c); } 	inline bool skipBlanks() { while (isSpace(nextChar())); return peekChar() != 0; } 	IO() : cur(0) {}   	inline IO& operator >> (int & n) { 		if (skipBlanks()) { 			int sign = +1; 			if (peekChar() == '-') { 				sign = -1; 				n = nextChar() - '0'; 			} 			else 				n = peekChar() - '0'; 			while (!isSpace(nextChar())) { 				n *= 10; 				n += peekChar() - '0'; 			} 			n *= sign; 		} 		return *this; 	}   	inline IO& operator >> (int64 & n) { 		if (skipBlanks()) { 			int sign = +1; 			if (peekChar() == '-') { 				sign = -1; 				n = nextChar() - '0'; 			} 			else 				n = peekChar() - '0'; 			while (!isSpace(nextChar())) { 				n *= 10; 				n += peekChar() - '0'; 			} 			n *= sign; 		} 		return *this; 	}   	#define cin io } io;   const int 	MAXN = 31, 	MAXV = 200001, 	MAXQ = 200001;   const int64 	oo = (1LL << 62);   int queryCount, N, C;   int cnt[MAXN]; //vector< int > coins[MAXN]; int coins[MAXN][MAXN]; int coinsMod[MAXN][MAXN];   int64 dp[MAXN][MAXV]; // minimum value possible with i coins     bitset< MAXV > inQueue[MAXN];   int ans[MAXQ]; int64 query[MAXQ];   int minCoin;   map< int, int > toId;   struct fastQueue { 	static const int 		MAXCAP = MAXV + 1;   	int Q[MAXCAP]; 	int head, tail;   	void clear() 	{ 		head = tail = 0; 	}   	inline bool empty() 	{ 		return head == tail; 	}   	inline void push(int s) 	{ 		Q[tail++] = s; 		if (tail >= MAXCAP) 			tail = 0; 	}   	inline int pop() 	{ 		int r = Q[head++]; 		if (head >= MAXCAP) 			head = 0; 		return r; 	}   	int peek() 	{ 		return Q[head]; 	}   } Q[MAXN];   inline void tryPush(int maxColors, int value) { 	//assert(maxColors <= C); 	if (!inQueue[maxColors][value]) 	{ 		Q[maxColors].push(value); 		inQueue[maxColors][value] = true; 	} }   inline int pop(int maxColors) { 	int top = Q[maxColors].pop(); 	inQueue[maxColors][top] = false; 	return top; }   int maxColors;   bitset< MAXV > mark;   void bfs(int groupId) { 	maxColors++;   	for (int c = 0; c <= maxColors; ++c) 		Q[c].clear();   	// pre bfs 	for (int c = maxColors - 1; c >= 0; --c) 	REP(j, minCoin) if (dp[c][j] != oo) 	{ 		REP(i, cnt[groupId]) 		{ 			int curCoin = coins[groupId][i]; 			int curCoinMod = coinsMod[groupId][i]; 			int nextValue = (j + curCoinMod); 			if (nextValue >= minCoin) 				nextValue -= minCoin;   			int64 cost = dp[c][j] + curCoin; 			if (cost < dp[c + 1][nextValue]) 			{ 				dp[c + 1][nextValue] = cost; 				tryPush(c + 1, nextValue); 			} 		} 	}   	// post bfs 	for (int c = 1; c <= maxColors; ++c) 	{ 		while (!Q[c].empty()) 		{ 			int top = pop(c); 			int64 topDist = dp[c][top]; 			REP(i, cnt[groupId]) //if (i > 0 || (!avoidFirst)) 			{ 				int curCoin = coins[groupId][i]; 				int curCoinMod = coinsMod[groupId][i]; 				int nextValue = top + curCoinMod; 				if (nextValue >= minCoin) 					nextValue -= minCoin; 				int64 cost = topDist + curCoin; 				if (cost < dp[c][nextValue]) 				{ 					dp[c][nextValue] = cost; 					tryPush(c, nextValue); 				} 			} 		} 	} }   int order[MAXN];   void solve() { 	maxColors = 0;   	for (int i = 0; i <= C; ++i) 		for (int j = 0; j < minCoin; ++j) 			dp[i][j] = oo;   	dp[0][0] = 0; // 0 coins for 0   	for (int c = 0; c < C; ++c) 		bfs(order[c]);   	REP(i, queryCount) 	{ 		int64 q = query[i]; 		for (int j = C; j > 0; --j) 			if (q >= dp[j][q % minCoin]) 			{ 				ans[i] = max(ans[i], j); 				break; 			} 	} }   bool lessCmp(int a, int b) { 	return cnt[a] < cnt[b]; 	//return coins[a][0] < coins[b][0]; }   int main() { 	ios::sync_with_stdio(0);   	cin >> N;   	minCoin = MAXV;   	REP(i, N) 	{ 		int v, c; 		cin >> v >> c; 		if (!toId.count(c)) 			toId[c] = C++; 		c = toId[c]; 		//coins[ c ].push_back(v); 		coins[ c ][ cnt[c]++ ] = v; 		minCoin = min(minCoin, v); 	}   	cin >> queryCount; 	REP(i, queryCount) 	{ 		cin >> query[i]; 		//assert(query[i] > 0 && query[i] < oo); 		ans[i] = -1; 	}   	REP(i, C) 	{ 		sort(coins[i], coins[i] + cnt[i]); 		cnt[i] = unique(coins[i], coins[i] + cnt[i]) - coins[i]; 		order[i] = i; 	}   	//sort(order, order + C, lessCmp); 	random_shuffle(order, order + C);   	REP(c, C) 	REP(j, cnt[c]) 	{ 		coinsMod[c][j] = coins[c][j] % minCoin; 		//coins[C][ cnt[C]++ ] = coins[c][i]; 		//coinsMod[C][j] = coins[c][j] % minCoin; 	}   	//sort(coins, coins + C);   	/* 	cout << C << " coin groups" << endl; 	REP(i, C) 	{ 		cout << "group " << (i+1) << endl; 		REP(j, SZ(coins[i])) 			cout << coins[i][j] << " "; 		cout << endl; 	} 	*/   	solve();   	REP(i, queryCount) 	{ 		//assert(ans[i] <= C); 		//assert(ans[i] != 0); 		printf( "%d\n", ans[i] ); // cout << ans[i] << endl; 	}   	return 0; }
#include <cstdio> #include <iostream> #include <cstring> #include <algorithm> using namespace std;  int T, n, a[100005], c4[100005], c7[100005]; long long ans;  int count(int x, int z) {     int ret = 0;     while (x) {         ret += x%10 == z;         x /= 10;     }     return ret; }  long long solve47() {     long long ret = 0; int r4=n-1, w4=n-1, r7=n-1, w7=-1, R, W;     for (int i=n; i>0; --i) {         r4 = min(r4, i-1);         w4 = min(w4, r4);         while (w4 >= 0 && c4[w4]-c4[i] <= 1) w4--;         r7 = min(r7, i-1);         while (r7 >= 0 && c7[r7]-c7[i] < 3) r7--;         if (r7 < 0) break;         w7 = min(w7, r7);         R = min(r4, r7);         W = max(w4, w7);         ret += max(0, R-W);     }     return ret; }  long long solve7_0() {     long long ret = 0; int r7=n-1, w7=n-1;     for (int i=n; i>0; --i) {         r7 = min(r7, i-1);         w7 = min(w7, r7);         while (w7 >= 0 && c7[w7]-c7[i] == 0) w7--;         ret += r7-w7;     }     return ret; }  int t[100005]; int bs(int x, int y, int z) {     int mi = x, mid, ma = y;     if (t[mi] > z) return 0;     while (mi < ma) {         mid = (mi + ma + 1) >> 1;         if (t[mid] <= z) mi = mid;         else ma = mid - 1;     }     return mi - x + 1; } long long solve7_1() {     for (int i=0; i<=n; ++i) t[i] = c4[i] + i;     long long ret = 0; int r7=n-1, w7=n-1;     for (int i=n; i>0; --i) {         r7 = min(r7, i-1);         while (r7 >= 0 && c7[r7]-c7[i] < 1) r7--;         if (r7 < 0) break;         w7 = min(w7, r7);         while (w7 >= 0 && c7[w7]-c7[i] <= 1) w7--;         if (w7 < r7) {             if (i == n || c7[i] != c7[i+1]) {                 sort(t+w7+1, t+r7+1);             }             ret += bs(w7+1, r7, t[i]);         }     }     return ret; }  long long solve(int I, int J, int K) {     long long ret = 0; int r4=n-1, w4=n-1, r7=n-1, w7=n-1, R, W;     for (int i=n; i>0; --i) {         r4 = min(r4, i-K);         while (r4 >= 0 && c4[r4]-c4[i] < I) r4--;         if (r4 < 0) break;         w4 = min(w4, r4);         while (w4 >= 0 && c4[w4]-c4[i] <= I) w4--;         r7 = min(r7, i-K);         while (r7 >= 0 && c7[r7]-c7[i] < J) r7--;         if (r7 < 0) break;         w7 = min(w7, r7);         while (w7 >= 0 && c7[w7]-c7[i] <= J) w7--;         R = min(r4, r7);         W = max(w4, w7);         ret += max(0, R-W);     }     return ret; }  int main() {     scanf("%d", &T);     while (T--) {         scanf("%d", &n);         for (int i=0; i<n; ++i) {             scanf("%d", &a[i]);         }         c4[n] = c7[n] = 0;         for (int i=n-1; i>=0; --i) {             c4[i] = c4[i+1] + count(a[i], 4);             c7[i] = c7[i+1] + count(a[i], 7);         }         ans = 0;         ans += solve47();         ans += solve7_0();         ans -= solve(2, 0, 1);         ans += solve7_1();         ans -= solve(2, 1, 2);         for (int i=3; i*i*i<=n; ++i) {             for (int j=3, k=i*i*i; k<=n; ++j, k*=i) {                 ans += solve(i, j, k);             }         }         cout << ans << endl;     }     return 0; } 
#include<cstdio> #include<cstdlib> #include<cstring> #include<algorithm> #include<cmath> #include<vector> #include<map> #include<bitset> #include<set> #include<stack> #include<queue> #include<deque> using namespace std; typedef int MT[100][100]; typedef int MM[100]; typedef long long LL; int n,C,K,size; int S[10],M[10]; //0..K ==== g[i][0..k] //K+1..K+K ==== f[i][K+1..K+k][colors that do not exist.] //(x+1)*K+1..K ==== f[i][(x+1)*K+1..k][x=color] MM f,nf; int c[10],cnt; MT mat,nmat; const long long mo = 1000000007; void ksm(int n){ 	while (n){ 		if (n & 1){ 			memset(nf,0,sizeof(nf)); 			for (int i = 0;i <= size;i++) 				for (int j = 0;j <= size ;j++) 					nf[i] = (nf[i]+(LL)mat[i][j]*f[j])%mo; 			for (int i = 0;i <= size ;i++) f[i] = nf[i]; 		} 		n >>= 1; 		memset(nmat,0,sizeof(nmat)); 		for (int i = 0;i <= size; i++) 			for (int j = 0;j <= size ;j++){ 				LL tt = 0; 				for (int k = 0;k <= size ;k++) 					(tt += (LL)mat[i][k]*mat[k][j])%=mo; 				nmat[i][j] = tt; 			} 		for (int i = 0;i <= size ;i++) 			for (int j = 0;j <= size ;j++) mat[i][j] = nmat[i][j]; 	} } void DP(){ 	size = 2*K; 	cnt = 0; 	for (int i = 1;i <= n;i++){ 		int pos = -1; 		for (int j = 1;j <= cnt;j++) 			if (S[i] == c[j]) {pos = j;break;} 		if (pos == -1){ 			c[++cnt] = S[i]; 			pos = cnt; 			for (int j = 1;j <= K;j++) 				f[++size] = f[K+j];//Add more matrix value 		} 		memset(mat,0,sizeof(mat)); 		mat[0][0] = 1; 		for (int k = 1;k <= K;k++){ 			// Deal with G 			mat[k][k] = 1;// + G[n][k] 			for (int j = 1;j <= cnt;j++) 				if (j != pos) 					mat[k][(j+1)*K+k] = 1;// +F[n][k][c[j]] 			mat[k][K+k] = C-cnt; // + (C-cnt)*F[n][k][not exist.] 			// Pay attation to this: every color that doesn't exist have the same DP value! 			// Deal with colors that do not exist. 			if (cnt < C){//Do not meet all 				int pp = K + k; 				mat[pp][pp] = 1;// F[n][k][not exist.] 				mat[pp][k - 1] = 1;// G[n][k-1] 				if (k > 1){ 					for (int j = 1;j <= cnt;j++) 						mat[pp][(j+1)*K+k-1] = 1; // + F[n][k][c[j]] 					mat[pp][K+k-1] = C-cnt-1; // (C-cnt-1)*F[n][k][not exist] 				} 			}// If meet all , cannot add this to result. 			// Deal with colors in it 			for (int j = 1;j <= cnt;j++){ 				int pp = (j+1)*K+k; 				mat[pp][pp] = 1; 				if (j != pos){ 					mat[pp][k - 1] = 1;// + G[n][k-1] 					if (k > 1){ 						for (int jj = 1;jj <= cnt;jj++) 							if (jj != j)// Pay attention to this. 								mat[pp][(jj+1)*K+k-1] = 1; 						mat[pp][K+k-1] = C-cnt; 					} 				} 			} 		} 		ksm(M[i]); 	} } int main(){ 	int TT;scanf("%d",&TT); 	while (TT--){ 		scanf("%d%d%d",&n,&C,&K); 		for (int i = 1;i <= n;i++) 			scanf("%d%d",&S[i],&M[i]); 		memset(f,0,sizeof(f)); 		for (int i = 0;i <= K;i++) 			f[i] = 1; 		DP(); 		int ans = (f[K]+(LL)(C-cnt)*f[2*K])%mo; 		for (int j = 1;j <= cnt;j++) 			ans = (ans+f[(j+1)*K+K])%mo; 		printf("%d\n",ans); 	} 	return 0; } 
         #include <cstdio>         #include <cstdlib>         #include <cstring>         #include <algorithm>         using namespace std;         int n,m,e,ans,du[2000];         char ch[1000][1000];         int b[2000][1000],c[1000][1000],d[1000][1000];         void addedge(int x,int y) {c[x][++c[x][0]]=y,du[x]++,du[y]++;}         void edmonds(int x,int c1,int c2)         {         if (!b[x][c1]) {         b[x][c1]=b[x][c2],b[x][c2]=0;         return ;         }         edmonds(b[x][c1],c2,c1);         e=b[x][c2],b[x][c2]=b[x][c1],b[x][c1]=e;         }         void init()         {         int i,j,l,k,p;         scanf("%d%d\n",&n,&m);         memset(b,0,sizeof(b));         memset(d,0,sizeof(d));         memset(du,0,sizeof(du));         for (i=1;i<=n;i++) c[i][0]=0;         for (i=1;i<=n;i++) {         scanf("%s\n",ch[i]+1);         for (j=1;j<=m;j++)         if (ch[i][j]=='1') addedge(i,j+n);         }         ans=0;         for (i=1;i<=n+m;i++) ans=max(ans,du[i]);         for (i=1;i<=min(n,ans);i++)         for (j=1;j<=min(m,ans);j++)         if (ch[i][j]=='1') {         k=(i+j-1)%ans;         if (!k) k=ans;         b[i][k]=j+n,b[j+n][k]=i;         }         for (i=1;i<=n;i++) {         for (p=1;p<=ans && b[i][p];p++) ;         for (j=1;j<=c[i][0];j++) {         k=c[i][j];         if (i<=ans && k-n<=ans) continue;         for (;p<=ans && b[i][p];p++) ;         for (l=1;l<=ans;l++) {         if (b[k][l]) continue;         edmonds(k,p,l);         b[i][p]=k,b[k][p]=i;         break;         }         }         }         for (i=1;i<=n;i++)         for (j=1;j<=ans;j++)         if (b[i][j]>n) d[i][b[i][j]-n]=j;         printf("%d\n",ans);         for (i=1;i<=n;i++) {         for (j=1;j<=m;j++) printf("%d ",d[i][j]);         printf("\n");         }         printf("\n");         scanf("\n");         }         int main()         {         int t=0;         scanf("%d\n",&t);         scanf("\n");         for (;t;t--) init();         return 0;         }  
#include <algorithm> #include <iostream> #include <vector> #include <cstdlib> #include <cstdio> #include <cassert> #include <cmath>  using namespace std;  const double DEPTH = -100000; const int XMAX = 320; const int YMAX = 240; const double EPS = 1e-9;  vector<vector<double> > depth(YMAX, vector<double>(XMAX)); vector<vector<char> > color(YMAX, vector<char>(XMAX));  inline bool isEqual(double d1, double d2) {     return fabs(d1-d2) < EPS; }  struct point {     int x, y, z; };  istream& operator>>(istream& in, point &p) {     return in >> p.x >> p.y >> p.z; }  struct edge {     int ymin, ymax, x, n, d, sign;     void set(int _ymin, int _ymax, int _x, int _n, int _d)     {         ymin = _ymin;         ymax = _ymax;         x = _x;         n = abs(_n);         d = abs(_d);         sign = ((_n < 0) == (_d < 0)) ? 1 : -1;     } };  class triangle { public:     triangle(point _p1, point _p2, point _p3, char _c)         : p1(_p1), p2(_p2), p3(_p3), color(_c)     {}     void draw();  private:     point p1, p2, p3;     edge e1, e2, e3;     char color;     int a, b, c, d;      void setPlane();     void setEdges(); };  void triangle::setPlane() {     a = p1.y*(p2.z-p3.z) + p2.y*(p3.z-p1.z) + p3.y*(p1.z-p2.z);     b = p1.z*(p2.x-p3.x) + p2.z*(p3.x-p1.x) + p3.z*(p1.x-p2.x);     c = p1.x*(p2.y-p3.y) + p2.x*(p3.y-p1.y) + p3.x*(p1.y-p2.y);     d = -p1.x*(p2.y*p3.z-p3.y*p2.z) - p2.x*(p3.y*p1.z-p1.y*p3.z) - p3.x*(p1.y*p2.z-p2.y*p1.z);     assert(d == -(a*p1.x+b*p1.y+c*p1.z)); }  void triangle::setEdges() {     //Sort points by y     if (p1.y > p2.y)         swap(p1, p2);     if (p2.y > p3.y)         swap(p2, p3);     if (p1.y > p2.y)         swap(p1, p2);     e1.set(p1.y, p2.y, p1.x, p1.y - p2.y, p1.x - p2.x);     e2.set(p1.y, p3.y, p1.x, p1.y - p3.y, p1.x - p3.x);     e3.set(p2.y, p3.y, p2.x, p2.y - p3.y, p2.x - p3.x); }  inline int roundOff(double d) {     return static_cast<int>(d+0.5); }  void triangle::draw() {     setPlane();     setEdges();     int x, x1, x2, px1, px2, xl, xr, y = e1.ymin;     double z;     int c1 = 0, c2 = 0;     int parts = 1;     if (e1.n == 0)         e1 = e3;     else if (e2.n == 0)         e2 = e3;     else         parts++;     px1 = e1.x;     px2 = e2.x;     e1.n*=e1.sign;     e2.n*=e2.sign;     while (parts--) {         for (;y <= e1.ymax && y <= e2.ymax; y++, c1 += e1.d, c2 += e2.d) {             assert(0 <= y && y < YMAX);             x1 = roundOff(px1+static_cast<double>(c1)/e1.n);             px1 += c1/e1.n;             c1 %= e1.n;             x2 = roundOff(px2+static_cast<double>(c2)/e2.n);             px2 += c2/e2.n;             c2 %= e2.n;             xl = min(x1, x2);             xr = max(x1, x2);             for (x = xl; x <= xr; x++) {                 assert(0 <= x && x < XMAX);                 z = static_cast<double>(-(a*x + b*y + d))/c;                 assert(z >= DEPTH);                 if ((!isEqual(z, depth[y][x]) && z > depth[y][x]) || (isEqual(z, depth[y][x]) && ::color[y][x] < color)) {                     depth[y][x] = z;                     ::color[y][x] = color;                 }             }         }         if (y > e1.ymax) {             e1 = e3;             c1 = 0;             px1 = e1.x;             e1.n*=e1.sign;         } else {             e2 = e3;             c2 = 0;             px2 = e2.x;             e2.n*=e2.sign;         }     } }  bool onright(point p1, point p2, point p3) {     int dx1, dy1, dx2, dy2;     dx1 = p2.x - p1.x;     dy1 = p2.y - p1.y;     dx2 = p3.x - p1.x;     dy2 = p3.y - p1.y;     if (dy1*dx2 > dy2*dx1)         return true;     return false; }  int main(int argc, const char *argv[]) {     int n, i, j, t, x, y, z, c;     vector<point> points(4);     for (i = 0; i < YMAX; i++)         for(j = 0; j < XMAX; j++) {             color[i][j] = '0';             depth[i][j] = DEPTH;         }     cin >> n;     while (n--) {         cin >> t >> c;         for (i = 0; i < 2 + t; i++)             cin >> points[i];         c += '0';         if (t == 1) { //triangle             triangle tri(points[0], points[1], points[2], c);             tri.draw();         } else { //quadrilateral             if (onright(points[0], points[1], points[2])) {                 triangle tri(points[0], points[1], points[3], c);                 tri.draw();                 triangle tri2(points[1], points[2], points[3], c);                 tri2.draw();             } else if (onright(points[2], points[3], points[0])) {                 triangle tri(points[1], points[2], points[3], c);                 tri.draw();                 triangle tri2(points[0], points[1], points[3], c);                 tri2.draw();             } else {                 triangle tri(points[0], points[1], points[2], c);                 tri.draw();                 triangle tri2(points[2], points[3], points[0], c);                 tri2.draw();             }         }     }     for (i = 0; i < YMAX; i++) {         for(j = 0; j < XMAX; j++)             putchar(color[i][j]);         putchar('\n');     }     return 0; } 
#include <stdio.h> #include <stdlib.h> #include <string.h> #include <algorithm> #include <map> using namespace std;  int Case,T,n,m,i,j,k,l,ans; int c[1000],d[1000],h[1000],w[1000],tot,cnt; unsigned int bit[1000],e[1000],BIT,aim; int son[1000],next[10000],ed[10000],ltot; bool f[2005],g[2005],del[1000]; char s[10];  map <unsigned int,int> Hash[10],M[1000][235];  void dfs(int x,int y,int z) { 	if(x>n) 	{ 		int sum=0; 		for(int i=1;i<=tot;++i)if((c[i]&y)==y)++sum; 		if(sum==(1<<(n-z)))d[++cnt]=y; 		if(z==n)BIT=(BIT<<1)+f[y]; 		return; 	} 	dfs(x+1,y*4+1,z+1); 	dfs(x+1,y*4+2,z+1); 	dfs(x+1,y*4,z); }  int calc(int k) { 	int sum=0; 	for(int i=1;i<=n;++i) 	{ 		if(k%4)++sum; 		k/=4; 	} 	return sum; }  void work(int x,int y,int z,unsigned int B) { 	if(y>=ans)return; 	int i; 	if(B==aim) 	{ 		ans=y; 		return; 	} 	if(x>cnt)return; 	z=B%233; 	if(M[x][z].find(B)==M[x][z].end())M[x][z][B]=y; 	else 	{ 		if(y>=M[x][z][B])return; 		M[x][z][B]=y; 	} 	int k; 	if((e[x]&B)!=e[x]) 	{ 		k=0; 		for(i=e[x]^(e[x]&B);i;i-=i&-i)++k; 		work(x+1,y+h[x],z+k,B|e[x]); 	} 	k=1; 	for(i=son[x];i;i=next[i]) 	{ 		--w[ed[i]]; 		if(!w[ed[i]])k=0; 	} 	if(k)work(x+1,y,z,B); 	for(i=son[x];i;i=next[i]) 	{ 		++w[ed[i]]; 	} }  int main() { 	scanf("%d",&T); 	for(Case=1;Case<=T;++Case) 	{ 		scanf("%d%d",&n,&m); 		memset(f,false,sizeof(f)); 		memset(g,false,sizeof(g)); 		tot=cnt=0; 		for(;m;--m) 		{ 			scanf("%s",s+1); 			k=0; 			for(i=1;i<=n;++i) 			if(s[i]>='a')k=k*4+1; 			else k=k*4+2; 			if(!f[k])c[++tot]=k; 			f[k]=true; 		} 		BIT=0; 		dfs(1,0,0); 		if(Hash[n].find(BIT)!=Hash[n].end()) 		{ 			printf("%d\n",Hash[n][BIT]); 			continue; 		} 		for(i=1;i<=cnt;++i) 		{ 			k=d[i]; 			for(j=1;j<=cnt;++j) 			if(d[j]!=k&&((k&d[j])==k)) 			{ 				d[j]=d[cnt]; 				--cnt;--j; 			} 		} 		sort(d+1,d+cnt+1); 		for(i=1;i<=cnt;++i)del[i]=false; 		for(i=1;i<=cnt;++i)h[i]=calc(d[i]); 		for(i=1;i<=cnt;++i) 		{ 			bit[i]=0; 			for(j=1;j<=tot;++j)bit[i]=(bit[i]<<1)+((d[i]&c[j])==d[i]); 		} 		for(i=1;i<=cnt;++i) 		for(j=i+1;j<=cnt;++j) 		{ 			if((bit[i]&bit[j])==bit[j]) 			del[j]=true; 		} 		j=0; 		for(i=1;i<=cnt;++i) 		if(!del[i]) 		{ 			++j; 			if(i!=j)d[j]=d[i]; 		} 		cnt=j; 		for(i=1;i<=cnt;++i)h[i]=calc(d[i]); 		for(i=1;i<=tot;++i)w[i]=0; 		for(i=1;i<=cnt;++i) 		for(j=1;j<=tot;++j) 		if((d[i]&c[j])==d[i]) 		++w[j]; 		ans=n*tot; 		for(i=1;i<=cnt;++i)son[i]=0; 		ltot=0; 		for(i=1;i<=cnt;++i)e[i]=0; 		for(i=1;i<=cnt;++i) 		for(j=1;j<=tot;++j) 		if((d[i]&c[j])==d[i]) 		{ 			++ltot;next[ltot]=son[i];son[i]=ltot;ed[ltot]=j; 			e[i]|=((unsigned int)1)<<j-1; 		} 		for(i=1;i<=cnt;++i) 		for(j=0;j<=233;++j) 		M[i][j].clear(); 		aim=0; 		for(i=1;i<=tot;++i)aim=aim<<1|1; 		work(1,0,0,0); 		printf("%d\n",ans); 		Hash[n][BIT]=ans; 	} }
#include<cstdio> #include<algorithm> #include<cmath> #include<vector> #include<ctime> #include<cstring> using namespace std;   const int maxn=2000007+10; const int Mhash=1000007; int hash[Mhash]; int lnk[maxn]; int state[maxn][3]; int M[3][3],IM[3][3],IMP[3][3]; int T; int Test; int A,B,X,Y,Z,P,C,Q; long long L,R; vector<int> D; int step;   void mul(int a[][3],int b[][3],int c[][3]) { int d[3][3]={0}; for (int k=0;k<3;k++) for (int i=0;i<3;i++) for (int j=0;j<3;j++) d[i][j]=(d[i][j]+a[i][k]*b[k][j])%P; for (int i=0;i<3;i++) for (int j=0;j<3;j++) c[i][j]=d[i][j]; }   void putHash(int f[],int k) { int s=f[0]*f[1]%Mhash; state[k][0]=f[0]; state[k][1]=f[1]; lnk[k]=hash[s]; hash[s]=k; }   int getHash(int f[]) { int res=P*P+10; int s=f[0]*f[1]%Mhash; for (int i=hash[s];i;i=lnk[i]) if (state[i][0]==f[0] && state[i][1]==f[1]) res=min(res,i); if (res==P*P+10) return -1; return res; }   int power(int a,int b) { int res=1; for (;b;b/=2) { if (b&1) res=res*a%P; a=a*a%P; } return res; }   int findLength(int f[3],int _g[3]) { int g[3]={_g[0],_g[1],_g[2]}; for (int i=0;i<=P*P;i+=step) { if (i) if (g[0]==f[0] && g[1]==f[1]) return i; int w=getHash(g); if (w!=-1) return i+w;   int h[3]={g[0],g[1],g[2]}; g[0]=g[1]=g[2]=0; for (int u=0;u<3;u++) for (int v=0;v<3;v++) g[u]=(g[u]+IMP[u][v]*h[v])%P; } return -1; }   long long calc(long long n) { long long res=n/T*D.size(); n%=T; int l=-1,r=D.size(); while (l+1<r) if (D[(l+r)/2]<=n%T) l=(l+r)/2; else r=(l+r)/2; return res+l+1; }   long long calc2(long long n,long long _d[]) { long long d[3]={_d[0],_d[1],_d[2]}; if (d[0]>n) return 0; if (d[0]<d[2]) return 1; n-=d[2]; d[0]-=d[2]; return n/d[1]+(n%d[1]>=d[0]); }   int sign[maxn];   void work0() { long long ODD[3],EVEN[3]; ODD[0]=EVEN[0]=2000000000000000000LL; for (int i=0;i<P;i++) sign[i]=0; for (int i=1;;i+=2) { if (i!=1) A=(A*Y+Z)%P; if (sign[A]) {ODD[1]=i-sign[A];ODD[2]=sign[A];break;} if (A==C) ODD[0]=i; sign[A]=i; } for (int i=0;i<P;i++) sign[i]=0; for (int i=2;;i+=2) { if (i!=2) B=(B*Y+Z)%P; if (sign[B]) {EVEN[1]=i-sign[B];EVEN[2]=sign[B];break;} if (B==C) EVEN[0]=i; sign[B]=i; }   for (;Q--;) { scanf("%lld%lld",&L,&R); printf("%lld\n",calc2(R,ODD)+calc2(R,EVEN)-calc2(L-1,ODD)-calc2(L-1,EVEN)); } }   void work1() { long long D[3]; D[0]=2000000000000000000LL; for (int i=0;i<P;i++) sign[i]=0; for (int i=2;;i++) { if (i!=2) B=(B*X+Z)%P; if (sign[B]) {D[1]=i-sign[B];D[2]=sign[B];break;} if (B==C) D[0]=i; sign[B]=i; } A=(A==C);   for (;Q--;) { scanf("%lld%lld",&L,&R); printf("%lld\n",calc2(R,D)-calc2(L-1,D)+(L==1)*A); } }   int main() { // freopen("input.txt","r",stdin);   for (scanf("%d",&Test);Test--;) { scanf("%d%d%d%d%d%d%d%d",&A,&B,&X,&Y,&Z,&P,&C,&Q); if (X==0) {work0();continue;} if (Y==0) {work1();continue;} memset(hash,0,sizeof(hash)); memset(M,0,sizeof(M)); memset(IM,0,sizeof(IM)); M[0][0]=X;M[0][1]=Y;M[0][2]=Z; M[1][0]=1;M[2][2]=1; IM[0][0]=IM[1][1]=IM[2][2]=1; for (int i=0;i<3;i++) { int inverse=power(M[i][i],P-2); for (int j=0;j<3;j++) { M[i][j]=M[i][j]*inverse%P; IM[i][j]=IM[i][j]*inverse%P; } for (int j=0;j<3;j++) if (M[j][i] && j!=i) { int tmp=M[j][i]; for (int k=0;k<3;k++) { M[j][k]-=M[i][k]*tmp%P; if (M[j][k]<0) M[j][k]+=P; IM[j][k]-=IM[i][k]*tmp%P; if (IM[j][k]<0) IM[j][k]+=P; } } } memset(M,0,sizeof(M)); M[0][0]=X;M[0][1]=Y;M[0][2]=Z; M[1][0]=1;M[2][2]=1;   //printf("%lf\n",(double)clock()/CLOCKS_PER_SEC);     int f[3]={B,A,1}; int g[3]={0,C,1}; int h[3]={B,A,1}; step=(int)sqrt((long long)P*P*P)+1; int tmp[3][3]={1,0,0,0,1,0,0,0,1}; for (int i=1;i<step;i++) { int _[3]={h[0],h[1],h[2]}; h[0]=h[1]=h[2]=0; for (int u=0;u<3;u++) for (int v=0;v<3;v++) h[u]=(h[u]+M[u][v]*_[v])%P; putHash(h,i); }   //printf("%lf\n",(double)clock()/CLOCKS_PER_SEC);   for (int i=0;i<3;i++) for (int j=0;j<3;j++) tmp[i][j]=IM[i][j],IMP[i][j]=(i==j); for (int k=step;k;k/=2) { if (k&1) mul(IMP,tmp,IMP); mul(tmp,tmp,tmp); }   T=P*P+1; T=findLength(f,f); D.clear(); for (int i=0;i<P;i++) { g[0]=i; int k=findLength(f,g); if (k!=-1) D.push_back(k%T+1); }     sort(D.begin(),D.end());   for (;Q--;) { scanf("%lld%lld",&L,&R); printf("%lld\n",calc(R)-calc(L-1)); } } }
#include <cstdio> #include <cstring> #include <algorithm>   #define L 5100100   using namespace std;   const int LEN = L * 3;   int r[LEN], sa[LEN]; int wa[LEN], wb[LEN], wv[LEN], ss[LEN];   #define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb)) #define G(x) ((x) < tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)   int c0(int *r, int a, int b) { return r[a] == r[b] && r[a + 1] == r[b + 1] && r[a + 2] == r[b + 2]; }   int c12(int k, int *r, int a, int b) { 	if (k == 2) return r[a] < r[b] || (r[a] == r[b] && c12(1, r, a + 1, b + 1)); 	return r[a] < r[b] || (r[a] == r[b] && wv[a + 1] < wv[b + 1]); }   void sort(int *r, int *a, int *b, int n, int m) { 	for (int i = 0; i < n; i ++) wv[i] = r[a[i]]; 	for (int i = 0; i < m; i ++) ss[i] = 0; 	for (int i = 0; i < n; i ++) ss[wv[i]] ++; 	for (int i = 1; i < m; i ++) ss[i] += ss[i - 1]; 	for (int i = n - 1; i >= 0; i --) b[-- ss[wv[i]]] = a[i]; }   void DC3(int *r, int *sa, int n, int m) { 	int i, j, p; 	int *san = sa + n, *rn = r + n; 	int ta = 0, tb = (n + 1) / 3, tbc = 0;   	r[n] = r[n + 1] = 0; 	for (i = 0; i < n; i ++) if (i % 3 != 0) wa[tbc ++] = i;   	sort(r + 2, wa, wb, tbc, m); 	sort(r + 1, wb, wa, tbc, m); 	sort(r, wa, wb, tbc, m);   	for (p = 1, rn[F(wb[0])] = 0, i = 1; i < tbc; i ++) 		rn[F(wb[i])] = c0(r, wb[i - 1], wb[i]) ? p - 1 : p ++;   	if (p < tbc) DC3(rn, san, tbc, p); 	else for (i = 0; i < tbc; i ++) san[rn[i]] = i;   	for (i = 0; i < tbc; i ++) if (san[i] < tb) wb[ta ++] = san[i] * 3; 	if (n % 3 == 1) wb[ta ++] = n - 1;   	sort(r, wb, wa, ta, m);   	for (i = 0; i < tbc; i ++) wv[wb[i] = G(san[i])] = i; 	for (i = 0, j = 0, p = 0; i < ta && j < tbc; p ++) 		sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i ++] : wb[j ++];   	for ( ; i < ta; p ++) sa[p] = wa[i ++]; 	for ( ; j < tbc; p ++) sa[p] = wb[j ++]; }   int m;   int calc(char *s) { 	int len = strlen(s); 	int lo = 0, hi = m, st, en; 	while(lo + 1 < hi) { 		int md = (lo + hi) >> 1, i, ok = 1; 		int t = sa[md]; 		for(i = 0; i < len; i ++) { 			if(s[i] != r[t + i]) { 				if(s[i] > r[t + i]) ok = 0; 				break; 			} 		} 		if(ok) hi = md; else lo = md; 	} 	st = hi; 	lo = 0; hi = m; 	while(lo + 1 < hi) { 		int md = (lo + hi) >> 1, i, ok = 1; 		int t = sa[md]; 		for(i = 0; i < len; i ++) { 			if(s[i] != r[t + i]) { 				if(s[i] < r[t + i]) ok = 0; 				break; 			} 		} 		if(ok) lo = md; else hi = md; 	} 	en = lo; 	return en - st + 1; }   char tmp[50010], s[501][5002]; int W, n;   void run() { 	for(int i = 1; i <= W; i ++) { 		printf("%d\n", calc(s[i])); 	} }   int main() { 	scanf("%d\n", &W); 	for(int i = 1; i <= W; i ++) gets(s[i]); 	scanf("%d\n", &n); 	for(int i = 1; i <= n; i ++) {         gets(tmp); 		for(int j = 0; tmp[j]; j ++) r[m ++] = tmp[j]; 		r[m ++] = '*'; 	} 	r[m ++] = 0; 	DC3(r, sa, m, 256); 	run(); 	return 0; } 
#include <iostream> #include <string> #include <vector> #include <cstring> using namespace std; #define REP(i,n) for(int (i)=0;(i)<(n); ++(i))  typedef long long int64; const int MOD = 151109; const int MAX = 80000;  const int MAXEDIT = 8858835; int mask; int M,N; char b[30][30]; int dp[20][20][MAX]; int patternCnt; int pattern[1<<20],number[1<<20]; //分别记录pattern和它的编号，便于反向查找 int edit[MAXEDIT];int editCnt; ///////////////////////////// //  xxxxoooo 现在考虑到A的位置 pattern由上一排开始到此处结束从而只需要判断 //  oooA		  A和pattern的第一位与最后一位是否可以放置即可~~~ ///////////////////////////// bool check(int pat){ 	int wrong =0 ,prev=0; //wrong 记录失败的数目，由于pattern可能分为两段，所以最大可以 	                                      //有一处错误的放置雷 	while(pat){ 		if(pat&1) wrong+=prev,prev=1; 		else prev =0; 		pat/=2; 	} 	return wrong<=1; } int cacl(int x,int y,int s){ 	if(y>=N)return cacl(x+1,0,s); 	if(x>=M)return (1<<9);  //?????????????? 	int & ref = dp[x][y][number[s]]; 	if(ref!=-1)return ref; 	edit[editCnt++] = (((number[s]<<5)+y)<<5)+x;  	int maxMine = 0 , way=0; 	//可不可以放雷 	if(b[x][y]=='.' && !(y>0&&(s&1))&&!((1<<(N-1))&s)){ //从左向右放，因此第一个不需要和最右边的比较，也就是不用和最低位比较 		int res = cacl(x,y+1,((s<<1)|1)&mask); 		maxMine = 1 + (res&511); 		way = res>>9; 	} 	//如果不放雷 	int res=cacl(x,y+1,(s<<1)&mask); 	if((res&511)>maxMine)maxMine = (res&511),way=0; 	if(maxMine == (res&511)) { 		way+= (res>>9);if(way>MOD)way-=MOD; 	} 	return ref = maxMine + (way<<9); } int main(){ 	//freopen("d:\\input.txt","r",stdin); 	int testcase;patternCnt=0; 	scanf("%d",&testcase); 	for(int i=0;i<(1<<20);i++){ //首先给所有合法的pattern编上号码 		if(check(i)){ 			pattern[patternCnt]=i; 			number[i]=patternCnt; 			patternCnt++; 		} 	} 	memset(dp,-1,sizeof(dp)); 	while(testcase--){ 		REP(i,editCnt) dp[edit[i]&31][(edit[i]>>5)&31][edit[i]>>10]=-1 ; //恢复上一个testcase修改的记录为-1 																														 // memset太耗费时间因为数组大 		scanf("%d %d",&M,&N); 		editCnt=0; 		gets(b[0]); 		REP(i,M)gets(b[i]); 		mask = (1<<N)-1; 		int res = cacl(0,0,0); 		printf("%d %d\n",res&511,res>>9); 	} }
#include <cstdio> #include <cstdlib> #include <algorithm> #include <unistd.h>   using namespace std;   char inputbuffer_raw[1024*1024*10]; char * inputbuffer = inputbuffer_raw;   int bikes; int bike_speed[20000]; int bike_pos[20000];   struct curpos { 	int index; 	long long pos; 	bool operator < (const curpos& other) const { 		if (pos > other.pos) 			return true; 		else if (pos < other.pos) 			return false; 		return index < other.index; 	} };   curpos bike_curpos[20000];   void readinput() { 	bikes = strtol(inputbuffer, &inputbuffer, 10); 	for (int i = 0; i < bikes; ++i) { 		bike_speed[i] = strtol(inputbuffer, &inputbuffer, 10); 		bike_pos[i] = strtol(inputbuffer, &inputbuffer, 10); 	} }   void solve() { 	int times = strtol(inputbuffer, &inputbuffer, 10); 	for (int i = 0; i < times; ++i) { 		long long cur_time = strtol(inputbuffer, &inputbuffer, 10); 		for (int k = 0; k < bikes; ++k) { 			bike_curpos[k].index = k; 			bike_curpos[k].pos = bike_speed[k] * cur_time + bike_pos[k]; 			//printf("%dth bike at %d\n", k, bike_curpos[k].pos); 		} 		int cur_pos = strtol(inputbuffer, &inputbuffer, 10); 		--cur_pos; 		nth_element(bike_curpos, bike_curpos + cur_pos, bike_curpos + bikes); 		printf("%d\n", bike_curpos[cur_pos].index + 1); 	} 	printf("\n"); }   int main() { 	read(0, inputbuffer, sizeof inputbuffer_raw); 	int cases = strtol(inputbuffer, &inputbuffer, 10); 	for (int i = 0; i < cases; ++i) { 		readinput(); 		solve(); 	} 	return 0; }
#include <iostream> #include <algorithm> #include <string> #include <vector>   #include <cmath> #include <cstdio> #include <queue> #include <list> #include <stack> #include <utility> #include <numeric> #include <map> #include <cctype> #include <cstring> #include <sstream> #include <cstdlib> #include <cassert> #include <iomanip> #include <set>   using namespace std;   #define F(a,b) for(int a=0;a<b;a++) #define REP(a,b) for(int a=0;a<b;a++) #define FOR(a,b,c) for(int a=b;a<c;a++) #define FORD(a,b,c) for(int a=b;a>=c;a--)   #define S scanf #define P printf   #define LEN(x) ((int)x.length()) #define SZ(x) ((int)x.size()) #define ALL(x) x.begin(), x.end() #define MP(x,y) make_pair(x,y) #define PB(x) push_back(x) #define INF 1000000000   typedef long long LL; typedef pair<int,int> PII; typedef pair<int, PII> PIII; typedef vector<int> VI; typedef vector<bool> VB; typedef vector<string> VS;   //int d[][2]={{-1.0},{1,0},{0,-1},{0,1}};   int tourCity[4000001]; int tourCost[23100001]; int tourNextCost[4000001]; //priority_queue< pair<pair<int,int> ,int> , vector<pair<pair<int, int> ,int> >, greater<pair< pair<int,int> ,int> > > OutRoad[100005];   vector< pair<pair<int, int>, int> > OR[100005]; int pointer[100005];     int maxOut[100005]; int visCount[100005]; int visNCount[100005]; bool visEdge[200010];   char *ipos, InpFile[20000000]; inline int input() { 	  	while(*ipos <= 32) ++ipos; 	int x=0, neg = 0;char c; 	while( true ) { 		c=*ipos++; if(c == '-') neg = 1; 		else { 			if (c<=32) return neg?-x:x; 			x=(x<<1)+(x<<3)+c-'0'; 		} 	} } inline LL inputll() { 	  	while(*ipos <= 32) ++ipos; 	LL x=0, neg = 0;char c; 	while( true ) { 		c=*ipos++; if(c == '-') neg = 1; 		else { 			if (c<=32) return neg?-x:x; 			x=(x<<1)+(x<<3)+c-'0'; 		} 	} }   int main() { 	ipos = InpFile;  	fread_unlocked(InpFile,20000000,1,stdin); 	int n,m; 	int a,b; 	int ca,cb; 	int pathCount=0; 	//S("%d%d",&n,&m);   	n= input(); 	m = input(); 	REP(i,n+1) pointer[i] = 0; 	REP(i,m) 	{ 		//S("%d%d%d%d",&a, &b, &ca, &cb ); 		a=input(); 		b=input(); 		ca=input(); 		cb=input(); 		//OutRoad[a-1].push( MP( MP( ca, b-1 ), 2*i) ); 		OR[a-1].PB( MP( MP( ca, b-1), 2*i)); 		maxOut[a-1] = max( maxOut[a-1], ca );   		//OutRoad[b-1].push( MP( MP( cb, a-1 ), 2*i+1) ); 		OR[b-1].PB( MP( MP( cb, a-1), 2*i+1)); 		maxOut[b-1] = max( maxOut[b-1], cb ); 	} 	REP(i,n) sort(ALL(OR[i]));   	//int finalInd = OutRoad[0].top().second; 	int finalInd = OR[0][0].second; 	int ctr=0; 	int city = 0; 	int offset=0; 	bool flIn = false; 	while(1) 	{ 		//if( pathCount >23000000 ) return 0; 		/*if(OutRoad[city].empty()) 		{ 			//assert(false); 			P("Fucked\n"); 			P("%d\n",city); 			P("%d\n",ctr); 			exit(0); 		}*/   		//int ind = OutRoad[city].top().second; 		int ind = OR[city][pointer[city]].second; 		if(ctr>=2*m && finalInd == ind) 		{ 			if( ! flIn ) 			{ 				offset = pathCount; 				flIn = true; 			} 			else break; 		} 		//int tmpCity = OutRoad[city].top().first.second; 		int tmpCity = OR[city][pointer[city]].first.second; 		if(flIn) 			//tourCity[pathCount-offset] = OutRoad[city].top().first.second; 			tourCity[pathCount-offset] = OR[city][pointer[city]].first.second; 		//tourCost[pathCount] = OutRoad[city].top().first.first; 		tourCost[pathCount] = OR[city][pointer[city]].first.first; 		visCount[city]++; 		if( flIn ) visNCount[city]++; 		//OutRoad[city].pop();   		OR[city][pointer[city]].first.first = visCount[city]+maxOut[city]; 		pointer[city]++; 		if( pointer[city] >= SZ(OR[city]) ) pointer[city]-=SZ(OR[city]); 		//OR[city].erase( OR[city].begin() ); 		if(flIn) 			tourNextCost[pathCount-offset] = maxOut[city] + visCount[city]; 		//OutRoad[city].push( MP( MP( visCount[city]+maxOut[city] , tmpCity ), ind) ); 		//OR[city].PB( MP( MP( visCount[city]+maxOut[city] , tmpCity ), ind) ); 		if(!visEdge[ind]) 		{ 			ctr++; 			visEdge[ind]=true; 		}   		city = tmpCity; 		pathCount++; 	}     	//P("%d\n",pathCount);   	int query; 	LL k; 	//S("%d",&query ); 	query = input(); 	while(query--) 	{ 		//S("%lld",&k); 		k=inputll(); 		if( k <= pathCount ) 		{ 			P("%d\n", tourCost[k-1] ); 		} 		else 		{   			int pathind = (k-1-offset)%(pathCount-offset); 			int times = (k-1-offset)/(pathCount-offset);   			//pathind+= offset;   			int pathPrev = pathind-1; 			if( pathPrev == -1 ) pathPrev = pathCount-1-offset; 			LL ans = tourNextCost[pathind]; 			times--; 			ans += (LL)times*visNCount[tourCity[pathPrev]]; 			//ans += (edgeGap[tourEdgeInd[pathind]]); 			P("%lld\n",ans);   		} 	} 	return 0; }
#include <algorithm> #include <cassert> #include <cstdio> #include <cstdlib> #include <cctype> #include <cmath> #include <iostream> #include <sstream> #include <string> #include <utility> #include <vector> #include <cassert> #include <ctime> #include <queue> using namespace std; #define VAR(a,b) __typeof(b) a=(b) #define REP(i,n) for(int _n=n, i=0;i<_n;++i) #define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i) #define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i) #define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it) #define ALL(c) (c).begin(),(c).end() #define DEBUG(x) cerr << #x << " = " << x << "\n"; template<class T> ostream& operator<<(ostream&o, const vector<T>&v) {   o<<'{';   FOREACH(it,v) o<<*it<<',';   return o<<'}'; } typedef long long LL; const int INF = 1000000000; const LL INFLL = LL(INF) * LL(INF); typedef vector<int> VI; typedef vector<string> VS; typedef vector<VI> VVI; template<class T> inline int size(const T&c) { return c.size(); } int rint() { int x; if(scanf("%d",&x)!=1) return -1; return x; } string rstring() { char buf[1000]; scanf("%s",buf); return buf; } //}}} typedef long double ld; class INPUT {   static const int BUFSIZE = 1<<16;   static char buffer[];   char *bufpos;   char *bufend;   void grabBuffer();  public:   INPUT() { grabBuffer(); }   bool eof() { return bufend==buffer; }   char nextChar() { return *bufpos; }   inline char readChar();   inline void skipWS();   inline unsigned readUnsigned();   inline int readInt();   inline ld readLD(); };   char INPUT::buffer[INPUT::BUFSIZE];   void INPUT::grabBuffer() {   bufpos = buffer;   bufend = buffer + read(0, buffer, BUFSIZE); }   char INPUT::readChar() {   char res = *bufpos++;   if(bufpos==bufend) grabBuffer();   return res; }   inline bool myisspace(char c) { return c<=' '; }   void INPUT::skipWS() {   while(!eof() && myisspace(nextChar())) readChar(); }   unsigned INPUT::readUnsigned() {   skipWS();   unsigned res = 0;   while(!eof() && isdigit(nextChar())) {     res = 10u * res + (readChar()-'0');   }   return res; }   int INPUT::readInt() {   skipWS();   bool neg = false;   if(!eof() && nextChar()=='-') { neg=true; readChar(); }   int res = static_cast<int>(readUnsigned());   if(neg) res = -res;   return res; }   ld INPUT::readLD() {   skipWS();   bool neg=false;   if(nextChar()=='-') { neg=true; readChar(); }   ld res = 0;   while(!eof() && isdigit(nextChar())) {     res = 10 * res + (readChar()-'0');   }   if(nextChar()=='.') {     readChar();     ld p = 0.1;     while(!eof() && isdigit(nextChar())) {       res += p * (readChar()-'0');       p *= 0.1;     }   }   if(neg) res = -res;   return res; }   INPUT input;     const ld EPS = 1e-7; const ld EPS2 = EPS*EPS;   ld PI = 2*acosl(0.0);   struct Point {   ld x,y;   Point() {}   Point(ld x,ld y):x(x),y(y) {} };   inline bool operator<(const Point &a, const Point &b) {   return a.x < b.x || a.x == b.x && a.y < b.y; }   inline Point operator+(const Point &A,const Point&B) { return Point(A.x+B.x,A.y+B.y); } inline Point operator-(const Point &A,const Point&B) { return Point(A.x-B.x,A.y-B.y); } inline Point operator*(ld c, const Point &A) { return Point(c*A.x,c*A.y); } inline ld operator%(const Point&A,const Point&B) { return A.x*B.y-A.y*B.x; } inline ld operator*(const Point&A,const Point&B) { return A.x*B.x+A.y*B.y; } inline ld len2(const Point&A) { return A*A; } inline ld len(const Point&A) { return sqrtl(len2(A)); } inline Point turn90(const Point &A) {   return Point(-A.y, A.x); }   void printPoint(const Point &a) {   printf("(%.6Lf, %.6Lf)\n", a.x, a.y); }   vector<Point> points;   void readPoints() {   int n = input.readInt();   points.clear(); points.reserve(n);   ld minx = 1e100, maxx = -1e100, miny=1e100, maxy=-1e100;   REP(i,n) {     ld x = input.readLD();     ld y = input.readLD();     points.push_back(Point(x,y));     minx = min(minx, x);     maxx = max(maxx, x);     miny = min(miny, y);     maxy = max(maxy, y);   }   if(maxx-minx>=2 || maxy-miny >= 2) throw 0;   Point center((minx+maxx)/2, (miny+maxy)/2);   FOREACH(it, points) *it = *it - center; }   void calcHull() {   sort(points.begin(), points.end());   vector<Point> hull;   hull.push_back(points[0]);   int st = 0;   FOR(i,1,size(points)-1) {     Point p = points[i];     while(size(hull)-st >= 2 &&           (hull[size(hull)-1] - hull[size(hull)-2]) %           (p - hull[size(hull)-2]) <= EPS2) {       hull.pop_back();     }     if(len2(p-hull[size(hull)-1]) > EPS2)       hull.push_back(p);   }   st = size(hull)-1;   FORD(i,size(points)-1,0) {     Point p = points[i];     while(size(hull)-st >= 2 &&           (hull[size(hull)-1] - hull[size(hull)-2]) %           (p - hull[size(hull)-2]) <= EPS2) {       hull.pop_back();     }     if(len2(p-hull[size(hull)-1]) > EPS2)       hull.push_back(p);   }   hull.pop_back();   points.swap(hull); }   vector<int> next,prev,todo; vector<int> todoStack;   Point circleCenter(const Point &a, const Point &b) {   Point c = 0.5 * (a+b);   Point ac = c-a;   ld x2 = len2(ac);   ld y2 = 1-x2;   if(y2<=0) throw 0;   Point res =  c + sqrtl(y2/x2) * turn90(ac);   return res; }   void process(int x) {   int a = prev[x];   int b = next[x];   if(a==x || b==x || a==b) return;   Point cen = circleCenter(points[a], points[b]);   if(len2(cen-points[x]) <= 1+EPS) {     next[a] = b; prev[b] = a;     next[x] = -1; prev[x] = -1;     if(!todo[a]) { todo[a]=1; todoStack.push_back(a); }     if(!todo[b]) { todo[b]=1; todoStack.push_back(b); }   } }   vector<Point> answerPoly;   void buildAnswerPoly() {   answerPoly.clear();   int st = 0;   while(next[st]==-1) ++st;   int a = st;   do {     int b = next[a];     Point p = points[a];     Point q = points[b];     Point c = circleCenter(p,q);     answerPoly.push_back(c);     a = b;   } while(a!=st); }   ld calcArea() {   int n = size(answerPoly);   ld res = 0;   REP(i,n) {     Point p = answerPoly[i];     Point q = answerPoly[(i+1)%n];     res += 0.5 * (p%q);     ld d = len(p-q);     ld alpha = asinl(0.5*d);     res += alpha;     res -= 0.5 * sinl(2*alpha);   }   return res; }   ld calc() {   int n = size(points);   if(n<2) return PI;   next.resize(n);   prev.resize(n);   todo.assign(n,1);   todoStack.resize(n);   REP(i,n) {     next[i] = (i+1)%n;     prev[i] = (i+n-1)%n;     todoStack[i] = i;   }   while(!todoStack.empty()) {     int x = todoStack.back();     todoStack.pop_back();     todo[x] = 0;     process(x);   }   buildAnswerPoly();   return calcArea(); }   int main() {   int ntc = input.readInt();   REP(tc,ntc) {     ld res;     try {       readPoints();       calcHull();       res = calc();     } catch(int) { res = 0; }     printf("%.6Lf\n", res);   } }
#include<cstdio> #include<cstring> #include<algorithm> int t,n,m,p,x,y,f[8888],c[8888],num[2]; int get(int x) { 	if (f[x]==x) return x; 	return f[x]=get(f[x]); } bool work() { 	if (f[1]==f[2]) return 1; 	int rest=(n*(n-1)/2-m)&1;	//1->need two even  0->need two odd 	if (n&1) return rest; 	if (p) 		if (rest) return num[0] || num[1]>2; 		else return num[0]<=1 && num[1]==2; 	else 		if (rest) return !x || !y; 		else return x || y; } int main() { 	scanf("%d",&t); 	while (t--){ 		scanf("%d%d%d",&n,&m,&p); num[0]=num[1]=0; 		for (int i=1;i<=n;i++) f[i]=i; 		for (int i=1;i<=m;i++){ 			scanf("%d%d",&x,&y); 			int t1=get(x),t2=get(y); 			if (t1!=t2) f[t1]=t2; 			} 		for (int i=1;i<=n;i++) c[f[i]=get(i)]^=1; x=c[f[1]],y=c[f[2]]; 		for (int i=1;i<=n;i++) if (f[i]==i) num[c[i]]++,c[i]=0; 		printf(work()?"First\n":"Second\n"); 		} 	return 0; } 
#include <cstdio> #include <algorithm>  using namespace std;  unsigned int hints[100000]; unsigned int writeOffset; int initial_truths;  class Input { private:  	char buffer[1048576]; 	int bufferMax,nextToRead;  	void refill() 	{ 		bufferMax = fread(buffer,1,1048576,stdin); 		nextToRead = 0; 	}  	int getNextChar() 	{ 		if ( nextToRead == bufferMax ) 			refill();  		return buffer[nextToRead++]; 	}  public:  	Input(){bufferMax = nextToRead = 0;}  	void resetHints() {writeOffset = initial_truths = 0;}  	int getInt() 	{ 		int ret = 0; int c; 		while((c = getNextChar()) < 48); 		do 		{ 			ret = 10*ret + c - 48; 		} 		while((c = getNextChar()) > 47); 		return ret; 	}  	void saveHint() 	{ 		short int op; 		unsigned int number; 		bool yesOrNo;  		while((op = getNextChar()) == 10);      //get operator  		number = getInt();                      //get number 		yesOrNo = getNextChar() == 89;          //get boolean value          //analyze and save hint          if (op == '<')         {             number <<= 1;                //open one-bit room for a boolean flag             number |= !(yesOrNo);       //indicate if at the hint number the total true hints increase or decrease             initial_truths += yesOrNo;  //indicate if the hint produces a true value at number 1 (an initial truth)             hints[writeOffset++] = number;          //save hint         }         else if (op == '>')         {             number++;             number <<= 1;             number |= yesOrNo;             initial_truths += !(yesOrNo);             hints[writeOffset++] = number;         }         else         {             if (yesOrNo)             {                 number <<= 1;                 number++;                 hints[writeOffset++] = number;      //save truths increasing hint at 'number'                 number++;                 hints[writeOffset++] = number;      //save truths decreasing hint at 'number'+1             }             else             {                 number <<= 1;                 hints[writeOffset++] = number;                 initial_truths++;                 number += 3;                 hints[writeOffset++] = number;             }         }         while((op = getNextChar()) > 64); 	} };   int main() {     Input input;     int hints_cnt, tests_cnt, loop_cnt;     int maximum_truths, temp_truths;     unsigned int hint;      tests_cnt = input.getInt();      while (tests_cnt--)     {         input.resetHints();         loop_cnt = hints_cnt = input.getInt();         while (loop_cnt--)             input.saveHint();          sort(hints, hints + writeOffset);          while (hints[writeOffset-1] > 2000000001)             writeOffset--;          temp_truths = initial_truths;         maximum_truths = 0;         if (hints[0] > 3)             maximum_truths = initial_truths;          for (loop_cnt = 0 ; loop_cnt < writeOffset ; loop_cnt++)         {             temp_truths += (hints[loop_cnt] & 1 ? 1 : -1 );             maximum_truths = (maximum_truths > temp_truths ? maximum_truths : temp_truths);         }          printf("%d\n", hints_cnt - maximum_truths);     }      return 0; } 
#include <cstdio> #include <cstring> #include <cassert> #include <ctime> #include <cstdlib> #include <iostream> #include <vector> #include <algorithm> using namespace std;  typedef long long int64; typedef pair<int64,int64> PLL;  PLL operator+(const PLL &p1, const PLL &p2) { 	return PLL(p1.first + p2.first, p1.second + p2.second); }  PLL operator-(const PLL &p1, const PLL &p2) { 	return PLL(p1.first - p2.first, p1.second - p2.second); }  #define N 100 #define V 1000000000000LL  PLL INFW = make_pair(N*V, N*V); PLL INF = make_pair(1LL<<62, 1LL<<62);  int n; PLL w[N][N]; PLL lx[N], ly[N], slack[N]; int slackx[N]; int s[N],t[N]; int mx[N], my[N]; int q[N],qh,qt,p[N];  void init() { 	// initial labeling 	for (int i=0;i<n;i++) { 		mx[i]=-1; 		my[i]=-1; 	} 	for (int i=0;i<n;i++) { 		lx[i]=w[i][0]; 		for (int j=0;j<n;j++) lx[i]=max(lx[i],w[i][j]); 		ly[i]=make_pair(0,0); 	} }  void update_slack(int x) { 	for (int y=0;y<n;y++) { 		PLL sl=lx[x]+ly[y]-w[x][y]; 		if (sl<slack[y]) { 			slack[y]=sl; 			slackx[y]=x; 		} 	} }  int find_root() { 	qh=0; qt=0; 	memset(s,0,sizeof(s)); 	memset(t,0,sizeof(t)); 	memset(p,-1,sizeof(p)); 	for (int y=0;y<n;y++) slack[y]=INF; 	for (int x=0;x<n;x++) { 		if (mx[x]==-1) { 			q[qt++]=x; 			s[x]=1; 			update_slack(x); 			return 1; 		} 	} 	return 0; }  void improve() { 	// increase matching 	while (1) { 		// exposed vertex = root 		if (!find_root()) break; 		// grow tree 		int id=-1; 		while (1) { 			// extend equality graph 			while (qh<qt) { 				int x=q[qh++]; 				for (int y=0;y<n;y++) { 					if (w[x][y]==lx[x]+ly[y] && !t[y]) { 						p[y]=x; 						int z=my[y]; 						if (z==-1) { 							id=y; 							goto augment; 						} else { 							q[qt++]=z; 							s[z]=1; t[y]=1; 							update_slack(z); 						} 					} 				} 			} 			// improve labeling 			PLL delta = INF; 			for (int y=0;y<n;y++) if (!t[y]) delta=min(delta,slack[y]); 			for (int x=0;x<n;x++) if (s[x]) lx[x]=lx[x]-delta; 			for (int y=0;y<n;y++) if (t[y]) ly[y]=ly[y]+delta; 			for (int y=0;y<n;y++) if (!t[y]) slack[y]=slack[y]-delta; 			// handle new edges 			for (int y=0;y<n;y++) { 				if (!t[y] && slack[y].first==0 && slack[y].second==0) { 					p[y]=slackx[y]; 					int z=my[y]; 					if (z==-1) { 						id=y; 						goto augment; 					} else { 						q[qt++]=z; 						s[z]=1; t[y]=1; 						update_slack(z); 					} 				} 			} 		} 		assert(0); 		// augment path 		augment:; 		for (int y=id,x,z;y!=-1;y=z) { 			x=p[y]; z=mx[x]; 			mx[x]=y; my[y]=x; 		} 	} }  PLL get_cost(int cheat=0, int debug=0) { 	PLL c=make_pair(0,0); 	PLL m=c-INF; 	for (int x=0;x<n;x++) { 		int y=mx[x]; 		c=c+w[x][y]; 		if (w[x][y].first>m.first) m=w[x][y]; 		else if (w[x][y].first==m.first && w[x][y].second<m.second) m=w[x][y]; 	} 	if (cheat && m.first>0) c=c-m; 	return c; }  vector<pair<PLL,PLL> > edges;  int main() { 	scanf("%d",&n); 	for (int i=0;i<n;i++) { 		for (int j=0;j<n;j++) { 			int64 p1,p2; 			scanf("%lld:%lld",&p1,&p2); 			w[i][j]=make_pair(p1-p2,p1); 			edges.push_back(make_pair(make_pair(-w[i][j].first,w[i][j].second),make_pair(i,j))); 		} 	}  	init(); 	improve();  	PLL best = make_pair(0,0)-INFW; 	sort(edges.begin(),edges.end()); 	for (int i=0;i<(int)edges.size();i++) { 		int x=edges[i].second.first, y=edges[i].second.second; 		int yy=mx[x]; 		if (yy!=y) { 			w[x][y]=INFW; 			mx[x]=-1; my[yy]=-1; 			lx[x]=max(lx[x],w[x][y]-ly[y]); 			improve(); 		}  		PLL cost = get_cost(1); 		if (cost>best) best=cost;  		w[x][y]=make_pair(0,0)-INFW; 		if (mx[x]==y) { 			mx[x]=-1; my[y]=-1; 			improve(); 		} 		if (get_cost()<=best) break; 	}  	cout << best.second << " " << best.second-best.first << endl; 	return 0; }
#include <cstdio> #include <map> using namespace std; typedef unsigned int uint; int i,j,k,cnt,n,m,len,mx[1010],t[1010][32];double p[9][110],P[110][32],dp[110][1010],ans; uint q[1010],prh[9],S,T[9],nxt;map<uint,int>hash; #define B(i) (1u<<(i)) int find(uint S) { 	if (hash.count(S)==0) q[hash[S]=len++]=S; 	return hash[S]; } int main() { 	scanf("%d%d",&n,&m); 	for (i=0;i<B(n);i++){ for (cnt=j=0;j<n;j++) if (i&B(j)) cnt++;T[cnt]|=B(i);} 	for (find(1),k=0;k<len;k++) { 		S=q[k]; 		for (i=0;i<n;i++) prh[i]=0; 		for (i=0;i<B(n);i++) if (S&B(i)) for (j=0;j<n;j++) prh[j]|=B(i|B(j)); 		for (i=0;i<B(n);i++) { 			for (j=0,nxt=S;j<n;j++) if (i&B(j)) nxt|=prh[j]; 			t[k][i]=find(nxt); 		} 		for (i=n;i>=0;i--) if (S&T[i]) {mx[k]=i;break;} 	} 	for (i=0;i<n;i++) for (j=0;j<m;j++) scanf("%lf",&p[i][j]); 	for (i=0;i<m;i++) for (j=0;j<B(n);j++) for (P[i][j]=1,k=0;k<n;k++) 		P[i][j]*=(j&B(k))?p[k][i]:1-p[k][i]; 	for (dp[0][0]=1,i=0;i<m;i++) for (j=0;j<len;j++) for (k=0;k<B(n);k++) 		dp[i+1][t[j][k]]+=dp[i][j]*P[i][k]; 	for (i=0;i<len;i++) ans+=mx[i]*dp[m][i]; 	printf("%.8lf\n",ans); } 
#include <cstdio> #include <cmath> #include <algorithm> using namespace std;  typedef long long LL; typedef unsigned long long ULL;  struct BigDec { 	LL n; // integer part 	double a; // fractional part  	BigDec(){} 	BigDec(LL n_, double a_) { n=n_; a=a_; } 	double val() { return n+a; }  	bool operator<(const BigDec &r) const	{ 		return n<r.n || (n==r.n && a<r.a); 	}  	bool operator==(const BigDec &r) const	{ 		return n==r.n && fabs(a-r.a)<1e-14; 	}  	BigDec operator+(const BigDec &r) const { 		LL sn = n + r.n; 		double sa = a + r.a; 		if(sa>=1-1e-14) sa-=1., sn++; 		return BigDec(sn,sa); 	}  	void print() { 		char s[111]; 		sprintf(s,"%.13lf",a); 		printf("%lld%s\n",n,s+1); 	} };  BigDec cool_sqrt(ULL x) { 	if(x==0) return BigDec(0,0.); 	ULL n = ULL(sqrt(x+0.)); 	if(n*n<=x) 		for(;(n+1)*(n+1)<=x;n++); 	else 		for(;n*n>x;n--); 	return BigDec(n, (x-n*n)/(sqrt(x+0.)+n)); }  ULL norm2(LL x, LL y) { 	return ULL(x*x)+ULL(y*y); }  struct point { 	int x,y; 	int u,v; // v<0 for changing sign 	point(){} 	point(int x_,int y_,int u_,int v_) { x=x_; y=y_; u=u_; v=v_; } 	int halfplane() const { return y>0 || y==0 && x>0 ? 0 : 1; } 	bool operator<(const point &p) const 	{ 		int hp=halfplane(); 		int php=p.halfplane(); 		if(hp!=php) return hp<php; 		return x * LL(p.y) > y * LL(p.x); 	} 	bool operator==(const point &p) const 	{ 		return halfplane() == p.halfplane() && x * LL(p.y) == y * LL(p.x); 	} };  const int maxN = 500; const int maxX = 1000000; int n,k; int x[maxN],y[maxN]; pair<int,int> xy[maxN]; int ax,ay,bx,by,cx,cy;  point a[maxN*(maxN+1)]; int p[maxN]; int sgn[maxN]; int inpos[maxN]; int posx,posy; int b[maxN*(maxN+1)];  bool lessp(int u,int v) { 	return p[u]<p[v]; }  void add(int u)  { 	if(sgn[u]>0 && p[u]<k && !inpos[u]) { 		posx+=x[u]; 		posy+=y[u]; 		inpos[u]=1; 	} }  void del(int u)  { 	if(sgn[u]>0 && p[u]<k && inpos[u]) { 		posx-=x[u]; 		posy-=y[u]; 		inpos[u]=0; 	} }  int main() { 	scanf("%d %d", &n, &k); 	scanf("%d %d", &ax, &ay); 	scanf("%d %d", &bx, &by); 	scanf("%d %d", &cx, &cy);  	int i,j,h,l; 	int m=0; 	for(i=0;n--;) 	{ 		int xi,yi; 		scanf("%d %d", &xi, &yi); 		if(xi==0 && yi==0) continue; 		x[i]=xi; y[i]=yi; 		xy[i]=make_pair(xi,yi); 		a[m++] = point(xi,yi,i,-1); 		a[m++] = point(-xi,-yi,i,-1); 		i++; 	} 	n=i;  	for(i=0;i<n;i++) 		for(j=0;j<n;j++) 			if(xy[i]!=xy[j]) 				a[m++]=point(x[i]-x[j],y[i]-y[j],i,j); 	sort(a,a+m);  	int x0=2*maxX+1,y0=-1; 	pair<LL,int> v[maxN]; 	for(i=0;i<n;i++) 		v[i]=make_pair(LL(x0)*y[i]-LL(y0)*x[i],i); 	sort(v,v+n); 	reverse(v,v+n);  	posx=ax, posy=ay; 	for(i=0;i<n;i++) 	{ 		j=v[i].second; 		p[j]=i; 		sgn[j] = v[i].first<0 ? -1 : 1; 		add(j); 	}  	BigDec ans = cool_sqrt(norm2(bx-ax,by-ay)) + cool_sqrt(norm2(cx-ax,cy-ay));  	int mark[maxN][maxN]={0}; 	int id=0; 	for(i=0;i<m;i=j) 	{ 		int blen=0; 		id++; 		for(j=i;j<m && a[i]==a[j];j++) 		{ 			int u=a[j].u; 			int v=a[j].v; 			if(v<0) { 				del(u); 				sgn[u]=-sgn[u]; 				add(u); 			} else { 				b[blen++]=u; 				b[blen++]=v; 				mark[u][v]=mark[v][u]=id; 			} 		} 		sort(b,b+blen,lessp); 		blen = unique(b,b+blen)-b; 		for(h=0;h<blen;h=l) 		{ 			for(l=h+1;l<blen && (mark[b[l]][b[h]]==id || xy[b[l]]==xy[b[h]]);l++); 			for(int h1=h,l1=l-1;h1<l1;h1++,l1--) 			{ 				int u=b[h1]; 				int v=b[l1]; 				del(u); 				del(v); 				swap(p[u],p[v]); 				add(u); 				add(v); 			} 		} 		BigDec cur = cool_sqrt(norm2(LL(bx)-posx,LL(by)-posy)) + 					 cool_sqrt(norm2(LL(cx)-posx,LL(cy)-posy)); 		if (ans < cur) { 			ans=cur; 		} 	} 	ans = ans + cool_sqrt(norm2(bx-cx,by-cy)); 	ans.print(); 	return 0; } 
    #include <algorithm>     #include <vector>     #include <set>     #include <map>     #include <string>     #include <numeric>     #include <cmath>     #include <cstdlib>     #include <iostream>     #include <sstream>     #include <cstring>     #include <cstdio>     #include <complex>     #include <cassert>           using namespace std;           //     typedef long long LL;     typedef pair<int,int> PII;     #define MP make_pair     #define VI vector<int>     #define FOR(v,p,k) for(int v=p;v<=k;++v)     #define FORD(v,p,k) for(int v=p;v>=k;--v)     #define REP(i,n) for(int i=0;i<(n);++i)     #define VAR(v,i) __typeof(i) v=(i)     #define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)     #define PB push_back     #define ST first     #define ND second     #define SIZE(x) (int)x.size()     #define ALL(c) c.begin(),c.end()     //     #define rep(i,b) for(int i=(0);i<(b);++i)     #define fo(i,a,b) for(int i=(a);i<=(b);++i)     #define ford(i,a,b) for(int i=(a);i>=(b);--i)     #define fore(a,b) for(__typeof((b).begin()) a = (b).begin();a!=(b).end();++a)     #define vv vector     #define pb push_back     #define ll long long     #define ld long double     #define ss(a) (int)(a).size()     #define all(x) (x).begin(),(x).end()     #define clr(x,a) memset(x,a,sizeof(x))     #define vi vv<int>     #define vs vv<string>     template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}     template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}           int cond = (ll)0;     #define db(x) { if (cond > 0) { cond--; rep (xxx, 1) cerr << __LINE__ << " " << #x << " " << x << endl; cerr.flush(); } }           const int sz = 66 * 66;     set <int> ed[sz];     int vis[sz];     int n, m;           void go(int i, int j, int ids, int id[66][66], int cnt[66][66]) {     if (!(i >= 1 && i <= n && j >= 1 && j <= m)) return;     if (id[i][j] == -1) id[i][j] = ids;     else {     int next = id[i][j];     if (next != ids) {     ed[next].insert(ids);     ed[ids].insert(next);     }     return;     }     if (cnt[i][j] != 0) return;           fo (ni, i-1,i+1) fo(nj,j-1,j+1)     if (ni != i || nj != j) go(ni, nj, ids, id, cnt);     }           int skoj[sz];     int prev[sz];           int go10(int first, int ids) {     rep (j, ids) vis[j] = 0;     rep (i, ids) prev[i] = -1;     vector<int> q;     q.push_back(first);     prev[first] = -2;     for (int i = 0; i < (int)q.size(); i++) {     int p = q[i];     fore (it, ed[p]) if (*it != first && *it != skoj[p]) {     if (skoj[*it] == -1) {     int a = p;     int b = *it;     do {     int prev_b = skoj[a];     int prev_a = prev[a];     skoj[a] = b;     skoj[b] = a;           if (a == first) break;     a = prev_a;     b = prev_b;     }     while (true);           return 1;     }     else {     int sk = skoj[*it];     if (prev[sk] == -1) {     prev[sk] = p;     q.push_back(sk);     }     }     }     }           return 0;     }           void _main() {     int ary[66][66] = {};     int cnt[66][66] = {};     int id[66][66] = {};     int wynik = 0;     int ids = 0;     int sum = 0;                 scanf("%d%d", &n, &m);     rep (i, sz) ed[i].clear();     rep (i, sz) vis[i] = 0;           wynik = 0;     ids = 0;     clr(ary, 0);     clr(cnt, 0);     clr(id, -1);     rep (i, sz) skoj[i] = -1;     fo (i, 1, n) {     char buf[66];     scanf("%s", buf+1);     fo (j, 1, m) {     ary[i][j] = buf[j] == '*';     }     }           fo (i, 1, n) fo (j, 1, m) {     fo (ni, i-1,i+1) fo(nj,j-1,j+1)     if (ni >= 1 && ni <= n && nj >= 1 && nj <= m) {     cnt[i][j] += ary[ni][nj];     }     }           fo (i, 1, n) fo (j, 1, m) {     if (cnt[i][j] == 0 && id[i][j] == -1) {     go(i, j, ids, id, cnt); ids++; wynik++;     }     }     fo (i, 1, n) fo (j, 1, m) {     if (id[i][j] == -1) wynik++;     }     rep (i, 10)     rep (i, ids) if (skoj[i] == -1) {     sum += go10(i, ids);     }     printf("%d\n", wynik - sum);     }           int main(int argc, char ** argv) {     string p = "../gcj/source/" + string("") + argv[0][strlen(argv[0])-1];     // if (argc >= 2 && strcmp(argv[1], "q") != 0) { freopen(argv[1],"r",stdin);}           rep (i, argc) if (strcmp(argv[i], "1n") == 0) { freopen("1.in","r",stdin);}     rep (i, argc) if (strcmp(argv[i], "2n") == 0) { freopen("2.in","r",stdin);}     rep (i, argc) if (strcmp(argv[i], "3n") == 0) { freopen("3.in","r",stdin);}     rep (i, argc) if (strcmp(argv[i], "4n") == 0) { freopen("4.in","r",stdin);}     rep (i, argc) if (strcmp(argv[i], "5n") == 0) { freopen("5.in","r",stdin);}           rep (i, argc) if (strcmp(argv[i], "s0") == 0) { freopen((p + "-small-0.in").c_str(),"r",stdin);freopen((p + "-small-0.out").c_str(),"w",stdout); }     rep (i, argc) if (strcmp(argv[i], "s1") == 0) { freopen((p + "-small-1.in").c_str(),"r",stdin);freopen((p + "-small-1.out").c_str(),"w",stdout); }     rep (i, argc) if (strcmp(argv[i], "s2") == 0) { freopen((p + "-small-2.in").c_str(),"r",stdin);freopen((p + "-small-2.out").c_str(),"w",stdout); }     rep (i, argc) if (strcmp(argv[i], "l0") == 0) { freopen((p + "-large-0.in").c_str(),"r",stdin);freopen((p + "-large-0.out").c_str(),"w",stdout); }     rep (i, argc) if (strcmp(argv[i], "q") == 0) cond = 1 << 30;     db(argc);     int t;     scanf("%d", &t);     fo (i, 1, t) {     db(i);     _main();     }     return 0;     } 
#include <iostream> #include <iomanip> #include <sstream> #include <fstream> #include <string> #include <cstdlib> #include <cstdio> #include <climits> #include <cstring> #include <ctime> #include <cmath> #include <cassert> #include <vector> #include <queue> #include <stack> #include <list> #include <set> #include <map> #include <bitset> #include <algorithm> #include <utility> #include <numeric> #include <functional>   #define forn(i, n) for (int i = 0; i < int(n); i++) #define forl(i, n) for (int i = 1; i <= int(n); i++) #define ford(i, n) for (int i = int(n) - 1; i >= 0; i--) #define fore(i, l, r) for (int i = int(l); i <= int(r); i++) #define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m)) #define all(a) (a).begin(), (a).end() #define sz(a) int((a).size()) #define pb(a) push_back(a) #define mp(x, y) make_pair((x), (y)) #define ft first #define sc second #define x first #define y second   using namespace std;   typedef long long li; typedef long double ld; typedef pair<int, int> pt;   template<typename X> inline X abs(const X& a) { return a < 0? -a: a; } template<typename X> inline X sqr(const X& a) { return a * a; }   const int INF = int(1e9); const li INF64 = li(1e18); const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;   int m, w[10];   inline bool read() { 	if (scanf("%d", &m) != 1) 		return false; 		 	forn(i, 10) 		assert(scanf("%d", &w[i]) == 1); 		 	return true; }   typedef unsigned int uint;   const int N = 4 * 1000 * 1000 + 3, C = (1 << 9) + 3;   int szcur, sznext; int cur[N], next[N]; int minPos[N]; uint ans[N]; int u = 0, used[N]; int d1[N], d2[N]; queue<int> q[C];   inline void solve(int test) { 	forn(i, m) d1[i] = d2[i] = INF; 	 	d1[0] = 0; 	q[d1[0]].push(0); 	 	for (int qq = 0, dd = 0; ; qq = (qq + 1) & 511, dd++) 	{ 		bool end = true; forn(i, 512) end &= q[i].empty(); 		if (end) break; 		 		while (!q[qq].empty()) 		{     		int v = q[qq].front();     		q[qq].pop();     		     		if (d1[v] != dd) continue;     		     		int nrm = v * 10;     		(nrm >= m) && (nrm %= m);     		     		int dd1 = d1[v];     		     		forn(i, 10)     		{     			int next = nrm + i;     			while (next >= m) next -= m;     			int nd1 = dd1 + w[i];     			     			if (d1[next] > nd1)     			{     				d1[next] = nd1;     				q[d1[next] & 511].push(next);     			}     		} 		} 	} 	 	cerr << clock() << endl; 	 	queue<int> qq; 	d2[0] = 0; 	qq.push(0); 	 	while (!qq.empty()) 	{ 		int v = qq.front(); 		qq.pop(); 		 		int nrm = v * 10; 		(nrm >= m) && (nrm %= m); 		 		int dd1 = d1[v]; 		int dd2 = d2[v]; 		 		forn(i, 10) 		{ 			int next = nrm + i; 			while (next >= m) next -= m; 			int nd1 = dd1 + w[i]; 			int nd2 = dd2 + 1; 			 			if (d1[next] == nd1 && d2[next] > nd2) 			{ 				d2[next] = nd2; 				qq.push(next); 			} 		}  	} 	 	//forn(i, m) assert(d[i].ft < INF / 2); 	 	cerr << clock() << endl; 	 	forn(i, m) minPos[i] = INF; 	 	u++; 	used[0] = u; 	szcur = 0; 	cur[szcur++] = 0; 	ans[0] = 0; 	 	li res = 0; 	int sum = 0; 	 	while (szcur > 0) 	{ 		sum += szcur; 		 		forn(t, szcur) 		{ 			int v = cur[t]; 			res += ::ans[v]; 			     		forn(i, 10)     		{     			int next = (v * 10 + i) % m;     			     			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1) minPos[next] = min(minPos[next], t);     		}     	}     	 		sznext = 0; 		 		forn(t, szcur) 		{ 			int v = cur[t]; 			     		forn(i, 10)     		{     			int next = (v * 10 + i) % m;     			     			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1 && minPos[next] == t && used[next] != u)     			{     				used[next] = u;     				ans[next] = ans[v] * 3141 + i;     				::next[sznext++] = next;     			}     		}     	}     	     	//sort(next, next + sznext);     	     	szcur = sznext;     	forn(i, szcur) cur[i] = next[i]; 	} 	 	//cerr << sum << ' ' << m << endl; 	assert(sum == m); 	 	cout << res << endl; 	 	cerr << clock() << endl; }   int main() { #ifdef SU2_PROJ     freopen("input.txt", "rt", stdin);     freopen("output.txt", "wt", stdout); #endif          cout << setprecision(10) << fixed;     cerr << setprecision(5) << fixed;          int testCount;     cin >> testCount;          forn(test, testCount)     { 	    assert(read()); 		solve(test); 	} 	     return 0; } 
#include <cstdio> #include <cmath> #include <cstring> #include <algorithm> using namespace std;   typedef long long LL;   const int ALP = 26; const int pmod = 1000000007; const int sqmod = 1<<15;   int powALP_baby[sqmod]; int powALP_giant[sqmod];   void powALP_precalc() { 	int p=1,i; 	for(i=0;i<sqmod;i++) 	{ 		powALP_baby[i]=p; 		p=LL(p)*ALP%pmod; 	} 	int q=1; 	for(i=0;i<sqmod;i++) 	{ 		powALP_giant[i]=q; 		q=LL(q)*p%pmod; 	} }   inline int powmodALP(int n) { 	return LL(powALP_giant[n>>15])*powALP_baby[n & ((1<<15)-1)]%pmod; }   const int maxD = 50000; // max(R-L) const LL maxR_ = 10000000000LL; LL maxR; const int sqrt_maxR_ = 100000; int sqrt_maxR;   const int prime_pi = 10000; // PrimePi[sqrt_maxR_] const int log3_maxR = 22;   int maxp[sqrt_maxR_+5]; int ind[sqrt_maxR_+5]; int prime[prime_pi]; int plen; LL order2[prime_pi][log3_maxR];   bool powmod2int(int n,int m) { 	int j; 	for(j=0;(1<<j)<=n;j++); 	int pw=1; 	for(;j--;) 	{ 		pw=LL(pw)*pw%m; 		if(n & (1<<j)) 		{ 			pw+=pw; 			if(pw>=m) pw-=m; 		} 	} 	return pw!=1; }   bool powmod2LL(LL n,LL m) { 	int j; 	for(j=0;(1LL<<j)<=n;j++); 	LL pw=1; 	for(;j--;) 	{ 		pw = ((((pw>>20)*pw%m)<<20)+(pw & 1048575)*pw)%m; // pw=pw*pw%m; 		if(n & (1LL<<j)) 		{ 			pw+=pw; 			if(pw>=m) pw-=m; 		} 	} 	return pw!=1; }   void precalc() { 	sqrt_maxR=int(sqrt(double(maxR))+2); 	memset(maxp,0,4*(sqrt_maxR+1)); 	plen=0; 	int i,j; 	for(i=2;i<=sqrt_maxR;i++) if(!maxp[i]) 	{ 		ind[i]=plen; 		prime[plen++]=i; 		for(j=i;j<=sqrt_maxR;j+=i) maxp[j]=i; 	} 	for(i=1;i<plen;i++) 	{ 		int m=prime[i]; 		int d=m-1; 		for(int x=d;x>1;) 		{ 			int p=maxp[x]; 			for(;x%p==0;x/=p); 			for(;;) 			{ 				if(d%p) break; 				d/=p; 				if(powmod2int(d,m)) 				{ 					d*=p; 					break; 				} 			} 		} 		order2[i][0]=d; 		LL D=d; 		LL pm=m; 		for(j=1;;j++) 		{ 			if(pm>maxR/m) break; 			pm*=m; 			if(pm<(1<<30)?powmod2int(int(D),int(pm)):powmod2LL(D,pm)) 				D*=m; 			order2[i][j]=D; 		} 	} }   const int max_sieve = maxD + sqrt_maxR_ + 5; const int max_nu = 10; // maximal number of different prime factors of numbers upto maxR   LL pr[max_sieve][max_nu]; int prlen[max_sieve]; LL rem[max_sieve];   void sieve(LL L,LL R) { 	memset(prlen,0,unsigned(4*(R-L+1))); 	int i; 	for(i=0;i<=R-L;i++) 		rem[i]=L+i; 	int sqR=int(sqrt(double(R))+2); 	for(i=0;i<plen;i++) 	{ 		int p=prime[i]; 		if(p>sqR) break; 		int x=L%p; 		x=x?p-x:x; 		for(;x<=R-L;x+=p) 		{ 			for(;rem[x]%p==0;rem[x]/=p); 			pr[x][prlen[x]++]=p; 		} 	} 	for(i=0;i<=R-L;i++) 		if(rem[i]>1) 			pr[i][prlen[i]++]=rem[i]; }   LL ans; int len; LL px[max_nu]; int ax[max_nu]; LL ord2[max_nu][log3_maxR+1];   inline LL gcd(LL a,LL b) { 	LL c; 	while(b) c=a%b,a=b,b=c; 	return a; }   void rec(int i,LL x,LL phi,LL ord) { 	if(i==len) 	{ 		ans+=phi/ord; 		return; 	} 	rec(i+1,x,phi,ord); 	LL p=px[i]; 	LL q=1; 	for(int j=0;j<ax[i];j++) 	{ 		q*=p; 		rec(i+1,x*q,phi*(q-q/p),ord*ord2[i][j]/gcd(ord,ord2[i][j])); 	} }   int count_words(LL L,LL R_) { 	LL R=R_; 	if(R%2==0) R++; 	int sqR=int(sqrt(1.*R)+2); 	LL lo=max(1LL,L-sqR); 	sieve(lo,R); 	int res=0; 	LL x=L; 	if(x%2==0) x++; 	for(;x<=R;x+=2) 	{ 		LL *prx=pr[x-lo]; 		len=prlen[x-lo]; 		int i,j; 		for(i=0;i<len;i++) 		{ 			LL m=prx[i]; 			px[i]=m; 			ax[i]=0; 			for(LL y=x;y%m==0;y/=m) 				ax[i]++; 			if(m>=sqrt_maxR) 			{ 				LL *pp=pr[x-x/m-lo]; 				LL d=m-1; 				for(j=prlen[x-x/m-lo];j--;) 				{ 					LL p=pp[j]; 					for(;;) 					{ 						if(d%p) break; 						d/=p; 						if(m<(1<<30)?powmod2int(int(d),int(m)):powmod2LL(d,m)) 						{ 							d*=p; 							break; 						} 					} 				} 				ord2[i][0]=d; 			} 			else 			{ 				for(j=0;j<ax[i];j++) 					ord2[i][j]=order2[ind[m]][j]; 			} 		} 		ans=0; 		rec(0,1,1,1); 		int pwALP=powmodALP((ans-1)%(pmod-1)); 		if(x<=R_) 			res=(res+LL(ALP)*pwALP)%pmod; 		if(L<=x-1) 			res=(res+pwALP)%pmod; 	} 	return res; }   const int maxTST = 5;   int main() { 	powALP_precalc(); 	int TST,tst; 	scanf("%d",&TST); 	LL L[maxTST],R[maxTST]; 	maxR=0; 	for(tst=0;tst<TST;tst++) 	{ 		scanf("%lld%lld",L+tst,R+tst); 		maxR=max(maxR,R[tst]); 	} 	precalc(); 	for(tst=0;tst<TST;tst++) 	{ 		int res=count_words(L[tst],R[tst]); 		printf("%d\n",res); 	} } 
#include <cstdio> #include <algorithm> #include <vector> #include <deque> typedef unsigned int uint; typedef long long int ll; typedef unsigned long long int ull;   struct bit_ge { 	bit_ge(): max(0), A() {} 	bit_ge(uint size): max(size), A(size+1,0) {} 	void resize(uint size) 	{ 		max=size; 		A.clear(); 		A.resize(size+1,0); 	} 	ull total() { return A[0]; } 	ull ge(uint x) 	{ 		if(!x) 			return total(); 		ull r=0; 		while(x<=max) 		{ 			r+=A[x]; 			x+=x^(x&(x-1)); 		} 		return r; 	} 	void add(uint x, ll d) 	{ 		while(1) 		{ 			A[x]+=d; 			if(!x) 				break; 			x&=x-1; 		} 	}   	uint max; 	std::vector<ull> A; };   struct tree { 	typedef std::deque<uint> branches_t; 	struct chain 	{ 		chain(): nodes() {} 		std::vector<uint> nodes; 		bit_ge sums; 		branches_t branches; 	}; 	struct node 	{ 		node(): 			parent(0), heavy(0), head(0), offset(0),  			size(0), sum(0), forward(0), adj() 		{} 		uint parent; 		bool heavy; 		uint head; 		uint offset; 		uint size; 		ull sum; 		uint forward; 		std::vector<uint> adj; 	}; 	tree(uint _size): size(_size), nodes(_size), chains(_size) {} 	void dfs1(uint n=0, uint p=0) 	{ 		nodes[n].parent=p; 		nodes[n].size=1; 		nodes[n].forward=n; 		uint ms=0,msa=0; 		for(uint i=0; i<nodes[n].adj.size(); ++i) 		{ 			uint u=nodes[n].adj[i]; 			if(u==p) 				continue; 			dfs1(u,n); 			if(ms<nodes[u].size) 			{ 				ms=nodes[u].size; 				msa=u; 			} 			nodes[n].size+=nodes[u].size; 		} 		if(ms) 			nodes[msa].heavy=1; 	} 	void dfs2(uint n=0, uint p=0) 	{ 		if(nodes[n].heavy) 		{ 			uint h=nodes[p].head; 			nodes[n].head=h; 			chain &c=chains[h]; 			uint o=c.nodes.size(); 			c.nodes.push_back(n); 			nodes[n].offset=o; 			c.branches.push_back(o); 		} 		else 		{ 			nodes[n].head=n; 			chain &c=chains[n]; 			c.nodes.push_back(n); 			c.branches.push_back(0); 			nodes[n].offset=0; 		} 		for(uint i=0; i<nodes[n].adj.size(); ++i) 		{ 			uint u=nodes[n].adj[i]; 			if(u==p) 				continue; 			dfs2(u,n); 		} 		if(nodes[n].offset==0) 		{ 			uint h=nodes[n].head; 			chain &c=chains[h]; 			c.sums.resize(c.nodes.size()-1); 		} 	} 	void dfs3(uint n=0, uint p=0) 	{ 		nodes[n].sum=0; 		ull d=0; 		for(uint i=0; i<nodes[n].adj.size(); ++i) 		{ 			uint u=nodes[n].adj[i]; 			if(u==p) 				continue; 			dfs3(u,n); 			nodes[n].sum+=nodes[u].sum+nodes[u].size; 			d+=nodes[u].size; 			if(!nodes[u].heavy) 				d+=nodes[u].sum; 		} 		uint h=nodes[n].head; 		uint o=nodes[n].offset; 		chain &c=chains[h]; 		c.sums.add(o,d); 	} 	void setup() 	{ 		dfs1(); 		dfs2(); 		dfs3(); 	} 	void update(uint n) 	{ 		uint p=n; 		ll ds=0; 		do 		{ 			uint h=nodes[n].head; 			chain &c=chains[h]; 			uint f=nodes[n].forward; 			uint to=nodes[n].offset; 			ll sds=0; 			if(f!=n) 				ds+=nodes[f].size; 			nodes[n].forward=p; 			if(p!=n) 				ds-=nodes[p].size; 			sds+=ds; 			c.sums.add(to,ds);   			uint i=0; 			for(uint o; i<c.branches.size() && (o=c.branches[i])<to; ++i) 			{ 				n=c.nodes[o]; 				f=nodes[n].forward; 				ds=0; 				if(f!=n) 					ds+=nodes[f].size; 				p=c.nodes[o+1]; 				nodes[n].forward=p; 				if(p!=n) 					ds-=nodes[p].size; 				sds+=ds; 				c.sums.add(o,ds); 			} 			if(i) 				c.branches.erase(c.branches.begin(),c.branches.begin()+i); 			if(c.branches.empty() || c.branches.front()!=to) 				c.branches.push_front(to); 			p=h; 			n=nodes[h].parent; 			ds=sds; 		} 		while(p); 	} 	uint changes(uint n) 	{ 		uint r=0; 		while(n) 		{ 			uint h=nodes[n].head; 			uint o=nodes[n].offset; 			chain &c=chains[h]; 			branches_t::const_iterator e=std::lower_bound( 				c.branches.begin(),c.branches.end(),o); 			r+=e-c.branches.begin(); 			if(!h) 				break; 			uint p=nodes[h].parent; 			if(nodes[p].forward!=h) 				++r; 			n=p; 		} 		return r; 	} 	void query(ull &rn, uint &rd,uint n) 	{ 		uint h=nodes[n].head; 		uint o=nodes[n].offset; 		chain &c=chains[h]; 		rn=c.sums.ge(o); 		rd=nodes[n].size; 		ull d=changes(n); 		rn+=d*rd; 	}   	uint size; 	std::vector<node> nodes; 	std::vector<chain> chains; };   main() { 	uint T=0; 	scanf("%u",&T); 	for(uint t=1; t<=T; ++t) 	{ 		uint N=0; 		scanf("%u",&N); 		tree g(N); 		for(uint n=1; n<N; ++n) 		{ 			uint a,b; 			scanf("%u%u",&a,&b); 			g.nodes[b].adj.push_back(a); 			g.nodes[a].adj.push_back(b); 		} 		g.setup();   		uint Q=0; 		scanf("%u",&Q); 		for(uint q=0; q<Q; ++q) 		{ 			char cmd[2]; 			uint n=N; 			scanf("%s%u",cmd,&n); 			if(*cmd=='O') 				g.update(n); 			else 			{ 				ull u; 				uint v; 				g.query(u,v,n); 				uint f=u%v; 				char buf[32],*p=buf; 				for(uint i=0; i<6; ++i) 				{ 					f*=10; 					uint d=f/v; 					f=f-d*v; 					*p++='0'+d; 				} 				*p++=0; 				printf("%llu.%s\n",u/v,buf); 			} 		} 	} } 
#include <stdio.h> #include <stdlib.h> #include <time.h>   using namespace std;   int tests,n; int x[10000],y[10000];   int main() { 	srand(time(0));     scanf("%d",&tests);     while (tests--) {     	int best=1;     	scanf("%d",&n);     	for (int i=0;i<n;i++) {     		scanf("%d %d",&x[i],&y[i]);     	}     	for (int it=0;it<200;it++) {     		int a=rand()%n, b=rand()%n;     		if (a==b) continue;     		int x1=x[b]-x[a], y1=y[b]-y[a];     		int st=0;     		for (int i=0;i<n;i++) {     			int x2=x[i]-x[a], y2=y[i]-y[a];     			if (x1*y2-x2*y1==0) st++;     		}     		if (st>best) best=st;     	}     	printf("%d\n",best);     }     return 0; }
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); const int maxn = (int)2e4 + 10; int a[maxn],b[maxn],used[1111],m; bool dfs(int g, int pos) { 	if (pos == m) return true; 	if (used[a[pos]] || used[b[pos]]) return dfs(g,pos + 1); 	if (g) 	{ 		used[a[pos]] = 1; 		if (dfs(g - 1,pos + 1)) return true; 		used[a[pos]] = 0; 		used[b[pos]] = 1; 		if (dfs(g - 1,pos + 1)) return true; 		used[b[pos]] = 0; 	} 	return false; } int main() { 	#ifndef ONLINE_JUDGE 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	#endif 	int T,n,g; 	scanf("%d",&T); 	while(T--) 	{ 		scanf("%d%d%d",&n,&m,&g); 		for(int i = 0; i < m; i++) 			scanf("%d%d",&a[i],&b[i]); 		memset(used,0,sizeof(used)); 		if (dfs(n - g,0)) puts("Possible"); else puts("Impossible"); 	} 	return 0; } 
#include <cstdio> #include <deque> #include <utility> #include <cassert> using namespace std;   typedef pair<int, int> pii;   long long trapezoid(pii a, pii b){ 	return (long long)(b.first-a.first)*(b.second+a.second); }   long long convexity(pii a, pii b, pii c){ 	return trapezoid(a, b)+trapezoid(b, c)+trapezoid(c, a); }   double energycost(pii a, pii b){ 	return (double)(b.second-a.second)*(b.second-a.second)/(b.first-a.first); }   int main(){ 	int T, N, S; 	for(scanf("%d", &T); T--; ){ 		scanf("%d %d", &N, &S); 		assert(1<=N && N<=30000); 		assert(0<=S && S<=30000); 		int total=0, C; 		double ans=0; 		deque<pii> lo, hi; 		lo.push_front(pii(0,0)); 		hi.push_front(pii(0,0)); 		for(int i=0; i<N; i++){ 			scanf("%d", &C); 			assert(0<=C && C<=20000); 			total+=C; 			pii nextlo(i+1, total), nexthi(i+1, total+S); 			while(lo.size()>1 && convexity(nextlo, lo[lo.size()-1], lo[lo.size()-2])>=0) 				lo.pop_back(); 			while(hi.size()>1 && convexity(nexthi, hi[hi.size()-1], hi[hi.size()-2])<=0) 				hi.pop_back(); 			if(lo.size()==1){ 				while(hi.size()>1 && convexity(nextlo, hi[0], hi[1])<=0){ 					ans+=energycost(hi[0], hi[1]); 					hi.pop_front(); 					lo[0]=hi[0]; 				} 			} 			if(hi.size()==1){ 				while(lo.size()>1 && convexity(nexthi, lo[0], lo[1])>=0){ 					ans+=energycost(lo[0], lo[1]); 					lo.pop_front(); 					hi[0]=lo[0]; 				} 			} 			lo.push_back(nextlo); 			hi.push_back(nexthi); 		} 		while(lo.size()>1){ 			ans+=energycost(lo[0], lo[1]); 			lo.pop_front(); 		} 		assert(total>0); 		//printf(%0. 		printf("%.5lf\n", ans/total); 	} 	return 0; }
#include<iostream> #include<algorithm> #include<cstring> using namespace std;   int n;   struct data {        int loc;        long long val; }D[100001];   int cmp(const void *a ,const void *b) {     if((*(data*)a).val == (*(data*)b).val)         return (*(data*)a).loc - (*(data*)b).loc;     if((*(data*)a).val > (*(data*)b).val)                        return 1;     return -1; }     int main() {     int T;     cin>>T;     for(int c = 1 ; c <= T ; c++)     {             int s = 0;             cin>>n;             for(int i = 1 ; i <= n; i++)             {                     //cin>>D[i].val;                     scanf("%lld" , &D[i].val);                     D[i].loc = i;             }             qsort(D+1 , n , sizeof(D[0]) , cmp);             D[0].loc = 9999999;             for(int i = 1 ; i <= n ; i++)             {                     int sml = 0 , last;                     for(int j = i ; j <= n ; j++)                             if(D[j].val != D[i].val)                                         break;                             else                             {                                 last = j;                                 if(D[j].loc < D[i-1].loc)                                             sml = j;                             }                     if(sml > 0)                     {                            s++;                            swap(D[last].loc , D[sml].loc);                     }                     i = last;             }             int ans = 0 , v = 1;             while(s > v)                     ans ++ , v *= 2;             printf("%d\n" , ans);     }     return 0; }
//#include "testlib.h" //#include <spoj.h>  #include <iostream> #include <stdio.h> #include <vector> #include <string> #include <algorithm> #include <math.h> #include <cmath> #include <assert.h> #include <time.h> #include <memory.h> #include <set> #include <numeric> #include <map> #include <queue> #include <stack> #include <bitset>  using namespace std;  bitset<3001> adj[3001]; int a[1000001], b[1000001]; int cc[3001];  vector< vector<int> > connected; vector< int > conn[111]; map<long long, int> mp;   //how does this work????? int f(long long mask) {     if (mask == 0) return 0;     if (mp.count(mask)) return mp[mask];          int p = -1;     for(int cc = 0; cc <= 3 && p == -1; ++cc) {         for(int i = 0; i < connected.size(); ++i)         if (mask & (1ll << i)) {             int c = 0;             for(int j = 0; j < conn[i].size(); ++j)             if (mask & (1ll << conn[i][j]))                 c++;                          if (c == cc) {                 p = i;                 break;             }         }     }          assert(p != -1);    // p = 0;    // while ((mask >> p) % 2 == 0)    //     p++;          int ans = 1e9, v;     long long mm;     for(int i = 0; i < 3; ++i) {         v = connected[p][i];                  mm = mask;         for(int j = 0; j < conn[p].size(); ++j) {             if (connected[conn[p][j]][0] != v && connected[conn[p][j]][1] != v && connected[conn[p][j]][2] != v) continue;                          if ((mm >> conn[p][j]) % 2)                 mm -= (1ll << conn[p][j]);         }         if ((mm >> p) % 2)             mm -= (1ll << p);                  ans = min(ans, f(mm) + 1);     }          return mp[mask] = ans; }  int main() {     //ios::sync_with_stdio(0);     int t;     scanf("%d", &t);     while (t --> 0) {         int n, m;         scanf("%d %d", &n, &m);         for(int i = 1; i <= n; ++i)             adj[i].reset();                  for(int i = 0; i < m; ++i) {             scanf("%d %d", a+i, b+i);             adj[a[i]][b[i]] = 1;		//make undirected graph on bitset adjacency list             adj[b[i]][a[i]] = 1;         }                  set< vector<int> > triangles;	//set to store all trianlges         for(int i = 0; i < m; ++i) {             bitset<3001> bs = adj[a[i]] & adj[b[i]];	//stores neigh[u][i] AND neigh[v][i] for each edge (u,v)             if (bs.count() > 0) {					//if triangle forming                 for(int k = 1; k <= n; ++k)                     if (bs[k] == 1) {                         vector<int> v; v.push_back(a[i]); v.push_back(b[i]); v.push_back(k);                         sort(v.begin(), v.end());                         triangles.insert(v);		//push vector containing nodes forming triangle into set                     }             }         }                  memset(cc, 0, sizeof cc);         for(set< vector<int> >::iterator it = triangles.begin(); it != triangles.end(); ++it)             cc[(*it)[0]]++, cc[(*it)[1]]++, cc[(*it)[2]]++;                  int ans = 0;         connected.clear();         for(set< vector<int> >::iterator it = triangles.begin(); it != triangles.end(); ++it) {             if (cc[(*it)[0]] == 1 && cc[(*it)[1]] == 1 && cc[(*it)[2]] == 1) {                 ans++;							//count the number of unnecessary node                  cc[(*it)[0]]--, cc[(*it)[1]]--, cc[(*it)[2]]--;             }             else                 connected.push_back((*it));		//get the connected triangles         }         //build the graph G' where each node corresponds to a triangle in original graph and         //2 nodes are connected by an edge if the 2 corresponding triangles in original graph share atleast one node         for(int i = 0; i < connected.size(); ++i) {             conn[i].clear();                          for(int j = 0; j < connected.size(); ++j)	//for each pair of triangles             if (i != j) {                 bool good = 0;                 for(int k = 0; k < 3; ++k)                     for(int p = 0; p < 3; ++p)                     if (connected[i][k] == connected[j][p])		//check if they share a common node                         good = 1;                                  if (good)                     conn[i].push_back(j);	//undirected graph made since it loops over all n*(n-1) possibilities             }         }                  mp.clear();         printf("%d\n", ans + f((1ll << ((int)connected.size())) - 1));	//print ans     }          return 0; }
#include <stdio.h> #include <stdlib.h> #include <stdint.h> #include <unistd.h>   class FastInput { public:     FastInput() {         m_dataOffset = 0;         m_dataSize = 0;         m_v = 0x80000000;     }       unsigned int ReadNext() {         if (m_dataOffset == m_dataSize) {             int r = read(0, m_buffer, sizeof(m_buffer));             if (r <= 0) return m_v;             m_dataOffset = 0;             m_dataSize = 0;             int i = 0;             if (m_buffer[0] < '0') {                 if (m_v != 0x80000000) {                     m_data[m_dataSize++] = m_v;                     m_v = 0x80000000;                 }                 for (; (i < r) && (m_buffer[i] < '0'); ++i);             }             for (; i < r;) {                 if (m_buffer[i] >= '0') {                     m_v = m_v * 10 + m_buffer[i] - 48;                     ++i;                 } else {                     m_data[m_dataSize++] = m_v;                     m_v = 0x80000000;                     for (i = i + 1; (i < r) && (m_buffer[i] < '0'); ++i);                 }             }         }         return m_data[m_dataOffset++];     }   public:     uint8_t m_buffer[32768];     uint32_t m_data[16384];     size_t m_dataOffset, m_dataSize;     uint32_t m_v; };   class FastOutput { public:     FastOutput() {         m_dataOffset = 0;     }     ~FastOutput() {     }       void Flush() {         if (m_dataOffset) {             if (write(1, m_data, m_dataOffset));             m_dataOffset = 0;         }     }     void PrintUint(unsigned int v, char d) {         if (m_dataOffset + 11 > sizeof(m_data)) Flush();         if (v < 100000) {             if (v < 1000) {                 if (v < 10) {                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 1;                 } else if (v < 100) {                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 2;                 } else {                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 3;                 }             } else {                 if (v < 10000) {                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 4;                 } else {                     m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 5;                 }             }         } else {             if (v < 100000000) {                 if (v < 1000000) {                     m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 6;                 } else if (v < 10000000) {                     m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 7;                 } else {                     m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 8;                 }             } else {                 if (v < 1000000000) {                     m_data[m_dataOffset + 8] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 9;                 } else {                     m_data[m_dataOffset + 9] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 8] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;                     m_data[m_dataOffset + 0] = v + 48;                     m_dataOffset += 10;                 }             }         }         m_data[m_dataOffset++] = d;     }     void PrintChar(char d) {         if (m_dataOffset + 1 > sizeof(m_data)) Flush();         m_data[m_dataOffset++] = d;     }     void ReplaceChar(int offset, char d) {         m_data[m_dataOffset + offset] = d;     }   public:     uint8_t m_data[32768];     size_t m_dataOffset; };   FastInput g_fi; FastOutput g_fo; unsigned int g_tree[462145]; unsigned int g_data[200001];   unsigned int clog2(unsigned int n) {     for (unsigned int i = 0;; ++i, n >>= 1) if (!n) return i; }   int main() {     unsigned int pt, pn;     pt = g_fi.ReadNext();     for (unsigned int it = 0; it < pt; ++it) {         pn = g_fi.ReadNext();         if (pn == 1) {             g_fi.ReadNext();             g_fo.PrintChar('1');             g_fo.PrintChar('\n');         } else {             unsigned int treeDepth = clog2(pn - 1);             for (unsigned int i = 0; i < pn; ++i)                 g_tree[(1 << treeDepth) + i] = 1;             g_tree[(1 << treeDepth) + pn] = 0;             for (unsigned int i = 0, k = pn; i < treeDepth; ++i) {                 k = (k + 1) / 2;                 unsigned int o1 = 1 << (treeDepth - i);                 unsigned int o2 = 1 << (treeDepth - i - 1);                 for (unsigned int j = 0; j < k; ++j) {                     g_tree[o2 + j] = g_tree[o1 + j * 2] + g_tree[o1 + j * 2 + 1];                 }                 for (unsigned int j = k; j < (1U << (treeDepth - i - 1)); ++j) {                     g_tree[o2 + j] = 0;                 }             }             for (unsigned int i = 1; i <= pn; ++i) {                 g_data[i] = g_fi.ReadNext();             }             for (unsigned int i = 0; i < pn; ++i) {                 unsigned int a = g_data[pn - i] + 1;                 unsigned int k = 2;                 for (unsigned int j = 0; j < treeDepth; ++j) {                     if (g_tree[k + 1] >= a) {                         --g_tree[k + 1];                         k = (k + 1) << 1;                     } else {                         --g_tree[k];                         a -= g_tree[k + 1];                         k = k << 1;                     }                 }                 g_data[pn - i] = (k >> 1) - (1 << treeDepth) + 1;             }             for (unsigned int i = 1; i <= pn; ++i) {                 g_fo.PrintUint(g_data[i], ' ');             }             g_fo.ReplaceChar(-1, '\n');         }     }     g_fo.Flush();     return 0; }  
#include<iostream> #include<algorithm> #include<cstdio> #include<vector> #include<cstring> #include<string> #include<sstream> #include<queue> #include<set> #include<map> #include<stack> #include<ctime> #include<cstdlib> #include<cmath> #include<cassert> using namespace std;  typedef vector<int> vi; typedef vector< vector<int> > vvi; typedef pair<int,int> pii; typedef long long ll;  #define GI ({int t;scanf("%d",&t);t;}) #define FOR(i,a,b) for(int i = a ; i <= b ; i++) #define REV(i,a,b) for(int i = a ; i >= b ; i--) #define REP(i,n) for(int i = 0 ; i < n ; i++)   /* MinCostMaxFlow : All costs should be non-negative initially   Complexity     : O(V^3 * (largest supply to any node)) Field Tests    : SPOJ - BABY SRM 506        : Div 1 600 MAXE should be twice the number of edges added */  const long long INF = 1LL<<59; #define MAXV 105 #define MAXE 405  ll cap[MAXE], cost[MAXE]; ll dist[MAXV], pot[MAXV]; int to[MAXE], prev[MAXE]; int end[MAXV], par[MAXV]; bool used[MAXV];  class MinCostMaxFlow { 	int V,E; 	ll maxflow,mincost; 	public: 	MinCostMaxFlow(int n) 	{ 		V = n; 		E = 0; 		maxflow = mincost = 0; 		REP(i,V) 		{ 			end[i] = -1; 			pot[i] = 0; 		} 	} 	 	void addedge(int x, int y, ll cost1, ll cap1) 	{ 		cost[E] = cost1 ; cap[E] = cap1 ; to[E] = y ; prev[E] = end[x] ; end[x] = E ; E++; 		cost[E] = -cost1 ; cap[E] = 0 ; to[E] = x ; prev[E] = end[y] ; end[y] = E ; E++; 	}  	bool augment(int s, int t) 	{ 		REP(i,V) 		{ 			used[i] = false; 			dist[i] = INF; 		} 		dist[s]=0; 		par[s]=-1; 		 		while(1)							// O(V^2) dijkstra 		{ 			int v = -1; 			REP(i,V)  				if(dist[i] < INF && !used[i]) 					if(v == -1 || dist[i] < dist[v]) 						v = i; 			if(v==-1) break; 			used[v] = true; 			for(int e=end[v];e>=0;e=prev[e]) if(cap[e] > 0){ 				ll val = dist[v] + cost[e] + pot[v] - pot[to[e]]; 				if(val < dist[to[e]] && !used[to[e]]) 				{ 					dist[to[e]] = val; 					par[to[e]]  = e; 				} 			} 		}  		REP(i,V) pot[i] += dist[i];					// new potentials  		if(!used[t]) return false;					// exit if no path found 	 		ll addflow = INF, addcost = 0;					// added flow 		for(int e=par[t];e>=0;e=par[to[e^1]]) addflow = min(addflow,cap[e]); 		for(int e=par[t];e>=0;e=par[to[e^1]]) 				// added cost 		{ 			addcost  += cost[e]*addflow; 			cap[e]   -= addflow; 			cap[e^1] += addflow; 		} 		maxflow += addflow;						// update 		mincost += addcost; 		 		return true; 	}  	pair<ll,ll> mincostmaxflow(int s, int t) 	{ 		while(augment(s,t)); 		return make_pair(maxflow,mincost); 	} };  /* MCMF code ends */  int main() {     int t = GI;     while(t--) {         int n, m;         n = GI; m = GI;          MinCostMaxFlow M(m+3);          int dem[55];          REP(i, 55) dem[i] = 0;          long long ret = 0;          REP(i, n) {             int s, e, v;             s = GI; e = GI; v = GI;             dem[s]++;             dem[e]--;             M.addedge(s, e, v, 1);             ret += v;         }          REP(i, m) {             int x = GI;             M.addedge(i, i+1, 0, x);         }          int src = m+1;         int sink = m+2;          REP(i, m+1) {             if(dem[i] > 0)                 M.addedge(src, i, 0, dem[i]);             else if(dem[i] < 0)                 M.addedge(i, sink, 0, -dem[i]);         }                  pair<long long, long long> P = M.mincostmaxflow(src, sink);          ret -= P.second;         printf("%lld\n", ret);     } 	return 0; }
#include <bits/stdc++.h> using namespace std;  #define PB push_back #define MP make_pair #define SZ size() #define all(v) v.begin(), v.end() #define REP(i, n) for(int i = 0; i < (int)n; i++) #define ITR(i, j, n) for(int i = j; i < (int)n; i++) #define mem(array, val) memset(array, val, sizeof(array)) #define READ(filename) freopen(filename, "r", stdin) #define WRITE(filename) freopen(filename, "w", stdout) #define Pii pair <int, int> #define Fr first #define Sc second #define Long long long #define si(a) scanf("%d", &a) #define sl(a) scanf("%lld", &a) #define sd(a) scanf("%lf", &a) #define sii(a, b) scanf("%d%d", &a, &b) #define sll(a, b) scanf("%lld%lld", &a, &b) #define sdd(a, b) scanf("%lf%lf", &a, &b)  #define MAX 300005 char S[MAX]; int P[MAX];  #define charset 26 #define minchar 'a' int cur; struct node {    int len, link, nxt[charset], cnt;    vector <int> rev_link;     void Set(int len, int link)    {       this->len = len;       this->link = link;       mem(nxt, -1);       cnt = 0;    } } pal_tree[MAX+2];  void create(const char S[]) {    int L = strlen(S);    int lpal = -1, state[2] = {0, 0}, suffix = -1;    cur = 1;    REP(i, 2) pal_tree[i].Set(i-1, i-1);    pal_tree[0].rev_link.PB(1);    for(int i = 0; i < L; i++) {       while(i-1-lpal < 0 || S[i] != S[i-1-lpal]) {          state[0] = pal_tree[state[0]].link;          lpal = pal_tree[state[0]].len;       }       while(suffix >= lpal || S[i] != S[i-1-suffix]) {          if(suffix == -1) break;          state[1] = pal_tree[state[1]].link;          suffix = pal_tree[state[1]].len;       }       if(suffix == lpal) suffix = 0, state[1] = 1;       else suffix += 2, state[1] = pal_tree[state[1]].nxt[S[i] - minchar];       lpal += 2;       if(pal_tree[state[0]].nxt[S[i] - minchar] == -1) {          pal_tree[++cur].Set(lpal, state[1]);          pal_tree[state[0]].nxt[S[i] - minchar] = cur;          pal_tree[state[1]].rev_link.PB(cur);       }       state[0] = pal_tree[state[0]].nxt[S[i] - minchar];       pal_tree[state[0]].cnt++;    }     for(int i = cur; i > 1; i--) {       int u = pal_tree[i].link;       if(u < 2) continue;       pal_tree[u].cnt += pal_tree[i].cnt;    } }  void clear() {    REP(i, cur+1) pal_tree[i].rev_link.clear(); }  void print_tree(int state, string s) {    cout << s << ' ' << pal_tree[state].cnt << '\n';    REP(i, charset) if(pal_tree[state].nxt[i] != -1) {       string x = "";       x = x + (char)(i+minchar);       cout << "from " << s << " to " << x << " while state " << state << " to state " << pal_tree[state].nxt[i] << '\n';       if(state) print_tree(pal_tree[state].nxt[i], x + s + x);       else print_tree(pal_tree[state].nxt[i], s + x);    } }  Long dfs(int u) {    Long ret = 0;    if(pal_tree[u].len >= 1) {       P[ pal_tree[u].len ] = P[ pal_tree[u].len / 2 ] + 1;       ret += ((Long)P[ pal_tree[u].len ] * pal_tree[u].cnt);    }    REP(i, pal_tree[u].rev_link.SZ)  ret += dfs(pal_tree[u].rev_link[i]);    P[ pal_tree[u].len ] = 0;    return ret; }  void main_() {    //scanf("%s", S);    cin >> S;    create(S);    //print_tree(0, "");    //print_tree(1, "");    //printf("%lld\n", x);    mem(P, 0);    cout << dfs(0) << '\n';    clear(); }  int main() {    ios_base::sync_with_stdio(0); cin.tie(0);    //READ("input.txt");    //WRITE("file2.txt");    int t = 1;    cin >> t;    while(t--) main_();     return 0; } /* 1 tcukepzshkljugggekjdqzjen */ 
//#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <algorithm> #include <stdio.h> #include <vector> #include <map> #include <string.h> #include <cmath> #include <assert.h> #include <iomanip> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; //#define debug(...) fprintf(stderr,__VA_ARGS__) #define debug(...) #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 100005  template <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;} template <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}  inline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;} /* vi g[N]; int cnt,st[N],ed[N],d[N]; void dfs(int u,int h=0){     st[u]=++cnt;d[u]=h;     for(int i=0;i<g[u].size();i++){         int j=g[u][i];         dfs(j,h+1);     }     ed[u]=cnt; } int t[N<<2],c[N<<2],f[N],h[N<<2]; typedef int arr[2][2]; arr w[N]; void mul(const arr&a,const arr&b,arr &c){     memset(c,0,sizeof(c));     for(int i=0;i<2;i++)         for(int j=0;j<2;j++)             for(int k=0;k<2;k++){                 add(c[i][j],1LL*a[i][k]*b[k][j]%mod);             } } void func(int &a,int &b,int n){     if(n==0)return;     int x,y;     y=(1LL*w[n][0][0]*a+1LL*w[n][0][1]*b)%mod;     x=(1LL*w[n][1][0]*a+1LL*w[n][1][1]*b)%mod;     a=x,b=y; } void cal(int p,int v,int w,int l){     if(h[p]==-1){         h[p]=l;         c[p]=v,t[p]=w;         return;     }     if(h[p]<=l){         func(c[p],t[p],l-h[p]);         add(c[p],v),add(t[p],w);         h[p]=l;     }     else{         func(v,w,h[p]-l);         add(c[p],v),add(t[p],w);     } } void down(int p){     if(h[p]!=-1){         cal(p<<1,c[p],t[p],h[p]);         cal(p<<1|1,c[p],t[p],h[p]);         h[p]=-1;     } } void upd(int p,int l,int r,int x,int y,int v,int w,int h){     if(l>=x&&r<=y){         cal(p,v,w,h);return;     }     int m=(l+r)>>1;     down(p);     if(x<=m)upd(p<<1,l,m,x,y,v,w,h);     if(y>m)upd(p<<1|1,m+1,r,x,y,v,w,h); } int query(int p,int l,int r,int x,int d){     if(l==r){         if(h[p]==-1)return 0;         int a=c[p],b=t[p];         func(a,b,d-h[p]);         return b;     }     int m=(l+r)>>1;     down(p);     if(x<=m)return query(p<<1,l,m,x,d);     return query(p<<1|1,m+1,r,x,d); } int main(){     //cout<<fixed<<setprecision(5);     int T,i,j,k,ca=0,n,m;     f[1]=f[2]=1;     for(i=3;i<N;i++){         f[i]=(f[i-2]+f[i-1])%mod;     }     for(i=0;i<2;i++)w[0][i][i]=1;     arr a;     a[0][0]=a[0][1]=a[1][0]=1,a[1][1]=0;     for(i=1;i<N;i++)mul(w[i-1],a,w[i]);     scanf("%d%d",&n,&m);     for(i=1;i<n;i++){         scanf("%d",&j),j--;         g[j].pb(i);     }     cnt=0;     dfs(0);     memset(h,-1,sizeof(h));     while(m--){         char s[2];         scanf("%s%d",s,&i);i--;         if(s[0]=='U'){             scanf("%d",&j);             upd(1,1,n,st[i],ed[i],f[j-1],f[j],d[i]);         }         else{             printf("%d\n",query(1,1,n,st[i],d[i]));         }     }     return 0; } //*/ /* int a[11],b[11],q[11][2]; int main(){     int T,i,j,k,n,m;     scanf("%d",&T);     while(T--){         scanf("%d",&n);         for(i=0;i<n;i++){             scanf("%d",&b[i]);             for(j=0;j<b[i];j++){                 scanf("%d",&k);                 a[j+1]=a[j]+k;             }             map<int,int>g;             for(j=1;j<=b[i];j++)                 for(k=j;k<=b[i];k++){                     g[a[k]-a[j-1]]++;                 }             map<int,int>::iterator it=g.end();it--;             a[i]=it->x,q[i][0]=it->y;             it=g.begin();             b[i]=it->x,q[i][1]=it->y;         }         ll mx=-inf,ans=0;         for(i=0;i<1<<n;i++){             int ok=1;             ll s=1,s1=1;             for(j=0;j<n;j++)if(i>>j&1){                 if(a[j]<0){ok=0;break;}                 s=s*a[j];s1=s1*q[j][0];             }             else{                 if(b[j]>0){ok=0;break;}                 s=s*b[j];s1=s1*q[j][1];             }             if(ok){                 if(mx<s)mx=s,ans=s1;                 else if(mx==s)ans+=s1;             }         }         cout<<mx<<" "<<ans<<"\n";     }     return 0; } //*/ int is[1005][1005][3],le[3]; char s[3][1005]; int cal(int i,int j,int k){     if(i>j)return 1;     int &ret=is[i][j][k];     if(ret!=-1)return is[i][j][k];     if(i==j)return ret=1;     if(s[k][i]!=s[k][j])return ret=0;     return ret=cal(i+1,j-1,k);  } int f[1005][3],b[1005][3],l[1005][1005],r[1005][1005]; ll dp[1005],dp1[1005],g[1005][1005]; int main(){     int T,i,j,k,n,m;     scanf("%d",&T);     while(T--){         for(i=0;i<3;i++)scanf("%s",s[i]),le[i]=strlen(s[i]);         memset(is,-1,sizeof(is));         for(k=0;k<3;k++)             for(i=0;i<le[k];i++)                 for(j=i;j<le[k];j++)cal(i,j,k);         memset(f,0,sizeof(f));         memset(b,0,sizeof(b));         memset(l,0,sizeof(l));         memset(r,0,sizeof(r));         memset(dp,0,sizeof(dp));         memset(dp1,0,sizeof(dp1));         memset(g,0,sizeof(g));         for(k=0;k<3;k++){             for(i=0;i<le[k];i++){                 for(j=0;j<=i;j++)f[i][k]+=is[j][i][k];                 for(j=i;j<le[k];j++)b[i][k]+=is[i][j][k];             }         }         int sum=0;         for(i=0;i<le[1];i++)             for(j=i;j<le[1];j++)sum+=is[i][j][1];                  for(i=le[0]-1;i>=0;i--){             l[i][0]=(s[0][i]==s[1][0]?1+b[i+1][0]:0);             for(j=1;j<le[1];j++)if(s[0][i]==s[1][j]){                 l[i][j]=l[i+1][j-1]+1+b[i+1][0]+f[j-1][1];             }             for(j=0;j<le[1];j++)dp[i]+=l[i][j];         }         for(i=le[1]-1;i>=0;i--){             r[i][0]=(s[1][i]==s[2][0]?1+b[i+1][1]:0);             for(j=1;j<le[2];j++)if(s[1][i]==s[2][j]){                 r[i][j]=r[i+1][j-1]+1+b[i+1][1]+f[j-1][2];             }             for(j=0;j<le[2];j++)dp1[j]+=r[i][j];         }         ll ans=0;         for(i=le[0]-1;i>=0;i--){             if(s[0][i]==s[2][0])g[i][0]=sum+dp[i+1],ans+=g[i][0];             for(j=1;j<le[2];j++)if(s[0][i]==s[2][j]){                 g[i][j]=g[i+1][j-1]+sum+dp[i+1]+dp1[j-1];                 ans+=g[i][j];             }         }         printf("%lld\n",ans);     }     return 0; }
#include<cstdio> #include<cstring> const int node=505; const int edge=502005; int N,M,K,i,j,k,S,T,V,l,r,mid,St,Ed,x,e,Num; int dis[255][255],D[255],Sum[255]; int son[node],f[node],d[node],pre[node],road[node]; int ed[edge],flow[edge],cost[edge],next[edge]; int Q[10000005]; void Addedge(int i,int j,int k,int l) { 	ed[++e]=j,flow[e]=k,cost[e]=l,next[e]=son[i],son[i]=e; 	ed[++e]=i,flow[e]=0,cost[e]=-l,next[e]=son[j],son[j]=e; } bool spfa() { 	int i,j,k,l,r; 	memset(d,127,sizeof(d)); 	memset(f,0,sizeof(f)); 	d[St]=0,f[St]=1,Q[1]=St; 	for(l=0,r=1;l<r;) 	{ 		i=Q[++l],f[i]=0; 		if(d[i]>=d[Ed]) continue; 		for(j=son[i];j;j=next[j]) 			if(flow[j]>0) 			{ 				k=ed[j]; 				if(d[k]>d[i]+cost[j]) 				{ 					d[k]=d[i]+cost[j],road[k]=j,pre[k]=i; 					if(!f[k]) f[k]=1,Q[++r]=k; 				} 			} 	} 	if(d[Ed]>1000000000) return 0; 	D[++Num]=d[Ed]; 	return 1; } void back() { 	int i; 	for(i=Ed;i!=St;i=pre[i]) 		--flow[road[i]],++flow[road[i]^1]; } int main() {     scanf("%d%d%d",&N,&M,&K);     memset(dis,6,sizeof(dis));     for(i=1;i<=M;++i)     { 		scanf("%d%d%d",&S,&T,&V); 		if(V<dis[S][T]) dis[S][T]=V; 	}     for(k=1;k<=N;++k)     	for(i=1;i<=N;++i)     		for(j=1;j<=N;++j)     			if(dis[i][j]>dis[i][k]+dis[k][j])     				dis[i][j]=dis[i][k]+dis[k][j];     St=0,Ed=2*N+1,e=1;     for(i=1;i<=N;++i) Addedge(St,i,1,0);     for(i=1;i<=N;++i) Addedge(i+N,Ed,1,0);     for(i=1;i<=N;++i)     	for(j=1;j<=N;++j)     		Addedge(i,j+N,1,dis[i][j]);     for(;spfa();) back();     for(i=1;i<=N;++i) Sum[i]=Sum[i-1]+D[i];     for(;K--;)     { 		scanf("%d",&x); 		if(D[N]<=x) 		{ 			printf("%d\n",Sum[N]); 			continue; 		} 		for(l=1,r=N;l<r;) 		{ 			mid=(l+r)/2; 			if(D[mid]>x) r=mid; 			else l=mid+1; 		} 		mid=(l+r)/2; 		printf("%d\n",Sum[mid-1]+(N-mid+1)*x); 	}     return 0; } 
#include<cmath> #include<cstdio>  #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  int main(){ 	int T; scanf("%d",&T); 	while(T--){ 		int m,n; 		double x; scanf("%d%d%lf",&m,&n,&x);  		double A[60][60]={}; 		rep(i,m){ 			A[i][m+i]=1; 			A[i+m][i]=-1; 			A[i+m][i+m]=2*cos(x); 			if(i>0) A[i+m][i+m-1]=sin(x); 		}  		double v[60]={}; 		v[m]=sin(x);  		rep(l,30){ 			if(n&(1<<l)){ 				double v2[60]={}; 				rep(i,2*m) rep(j,2*m) v2[i]+=A[i][j]*v[j]; 				rep(i,2*m) v[i]=v2[i]; 			}  			double A2[60][60]={}; 			rep(i,2*m) rep(j,2*m) rep(k,2*m) A2[i][j]+=A[i][k]*A[k][j]; 			rep(i,2*m) rep(j,2*m) A[i][j]=A2[i][j]; 		}  		printf("%f\n",v[m-1]); 	}  	return 0; } 
#include <iostream> #include <cmath> using namespace std;  int factorial[1000005];  int MUL(int a, int b) {     return (int)(((unsigned long long)a * (unsigned long long)b) % 1000000007); }  int power(int x, int y) { 	if (y == 0)         return 1;      	int t = power(x, y / 2); 	     if (y % 2 == 0) 		return MUL(t, t); 	else 		return MUL(x, MUL(t, t)); }  int main() {     factorial[0] = 1; 	for (int i = 1; i < 1000005; ++i)     	factorial[i] = MUL(factorial[i - 1], i);      int T;     cin >> T;     while ( T-- )     {         int N, M;         cin >> N >> M;      		int ans = factorial[M - N + 1];         ans = MUL(ans, power(M - N, ((2 * N - M) >> 1)));         ans = MUL(ans, power(M - N + 1, ((2 * N - M - 1) >> 1)));              cout << ans << endl; 	} 	return 0; } 
#include <cstdlib> #include <cstdio> #include <cstring> #include <algorithm> using namespace std; typedef long long int64; const int oo=1000000000,mod=1000000037; const int dx[]={1,0,-1,0}; const int dy[]={0,1,0,-1}; /* 	Number Theory */ const int pMod[]={421,563,4219}; int fact[3][5000],rev[3][5000]; void init() { 	for(int pi=0;pi<3;pi++) { 		for(int i=1;i<pMod[pi];i++) { 			int ret=1; 			while(ret%i) 			    ret+=pMod[pi]; 			rev[pi][i]=ret/i; 		} 		 		fact[pi][0]=1; 		for(int i=1;i<pMod[pi];i++) 		    fact[pi][i]=fact[pi][i-1]*i%pMod[pi]; 	} } void calcFactorial(int n,int pi,int &val,int &pow) { 	int p=pMod[pi]; 	while(n>=p) { 		val=val*fact[pi][n%p]%p; 		if(((n/p)&1)&&val) 		    val=p-val; 		pow+=n/=p; 	} 	val=val*fact[pi][n]%p; } int comb(int x,int y) { 	if(x<0||y<0) 	    return 0; 	if(x==0||y==0) 	    return 1; 	 	int64 ans=0; 	const int coef[3]={933491721,257548855,808959499}; 	for(int pi=0;pi<3;pi++) { 		int val1=1,pow1=0; 		int val2=1,pow2=0; 		calcFactorial(x+y,pi,val1,pow1); 		calcFactorial(x,pi,val2,pow2); 		calcFactorial(y,pi,val2,pow2); 		 		int val=0; 	    if(pow1==pow2) 			val=val1*rev[pi][val2]%pMod[pi];   //printf("%d\n",valFact[pi][x+y]);   		ans+=(int64)coef[pi]*val%mod; 		 		//printf("comb(%d,%d)=%d (mod %d)\n",x,y,val,pMod[pi]); 		 	} 	return ans%mod; } /* 	Main */ struct Point { 	int x,y,cnt; }; bool operator<(const Point &p1,const Point &p2) { 	if(p1.x!=p2.x) 	    return p1.x<p2.x; 	else 	    return p1.y<p2.y; }   const int maxN=1010; int n,W,H; Point p[maxN]; /* 	Method 1 	condition: n<=W,H */ int getPlug(int &bx,int &by,Point pl[]) { 	//Calc bx,by     static bool v[maxN];     memset(v,0,sizeof(v));     for(int i=1;i<=n;i++)         if(p[i].x<=n)             v[p[i].x]=true; 	for(bx=0;v[bx];bx++); 	 	memset(v,0,sizeof(v));     for(int i=1;i<=n;i++)         if(p[i].y<=n)             v[p[i].y]=true; 	for(by=0;v[by];by++); 	 	//printf("bx=%d by=%d\n",bx,by);   	//Init d[] 	static int d[maxN][maxN],cnt[maxN][maxN]; 	for(int i=0;i<=bx;i++) 	for(int j=0;j<=by;j++) 	    d[i][j]=oo;     for(int i=1;i<=n;i++) 	    if(p[i].x<bx&&p[i].y<by) 			d[p[i].x][p[i].y]=-1; 	d[0][0]=0,cnt[0][0]=1;   	//Init queue 	static int l[maxN*maxN][2]; 	int lh=1,lt=0; 	#define ADD(x,y) ++lt,l[lt][0]=(x),l[lt][1]=(y) 	ADD(0,0);   	//BFS 	for(;lh<=lt;lh++) { 		int x=l[lh][0],y=l[lh][1]; 		//printf("%d %d d=%d cnt=%d\n",x,y,d[x][y],cnt[x][y]); 		if(x<bx&&y<by) 			for(int dir=0;dir<4;dir++) { 				int x2=x+dx[dir],y2=y+dy[dir]; 				if(0<=x2&&x2<=bx&&0<=y2&&y2<=by) 					if(d[x][y]+1<d[x2][y2]) { 	                	d[x2][y2]=d[x][y]+1; 	                	cnt[x2][y2]=cnt[x][y]; 						ADD(x2,y2); 					} else if(d[x2][y2]==d[x][y]+1) 					    if((cnt[x2][y2]+=cnt[x][y])>=mod) 					        cnt[x2][y2]-=mod; 			} 	} 	 	//Find min dist 	int mind=oo; 	for(int i=1;i<=lt;i++) {         int x=l[i][0],y=l[i][1],ret=d[x][y]+(bx-x)+(by-y);         if(x==bx||y==by)         	mind=min(mind,ret); 	} 	//Find bound vertex of min dist 	int nPl=0; 	for(int i=1;i<=lt;i++) {         int x=l[i][0],y=l[i][1],ret=d[x][y]+(bx-x)+(by-y);         if((x==bx||y==by)&&mind==ret) 			nPl++,pl[nPl].x=x,pl[nPl].y=y,pl[nPl].cnt=cnt[x][y]; 			//printf("%d %d d=%d cnt=%d ret=%d\n",x,y,d[x][y],cnt[x][y],ret); 	} 	return nPl; } int solve2D() { 	//Calc lower-left plugs 	static Point l1[maxN*2],l2[maxN*2]; 	int bx1,by1,n1=getPlug(bx1,by1,l1); 	 	//Calc upper-right plugs 	for(int i=1;i<=n;i++) { 	    p[i].x=W-p[i].x; 	    p[i].y=H-p[i].y; 	} 	int bx2,by2,n2=getPlug(bx2,by2,l2); 	 	//Fix 	for(int i=1;i<=n;i++) { 	    p[i].x=W-p[i].x; 	    p[i].y=H-p[i].y; 	} 	bx2=W-bx2,by2=H-by2; 	for(int i=1;i<=n2;i++) { 	    l2[i].x=W-l2[i].x; 	    l2[i].y=H-l2[i].y; 	} 	 	       int64 ans=0;     for(int i=1;i<=n1;i++)     for(int j=1;j<=n2;j++)         ans+=(int64)comb(l2[j].x-l1[i].x,l2[j].y-l1[i].y)*l1[i].cnt%mod*l2[j].cnt%mod; //printf("ans=%d\n",int(ans%mod));       sort(p+1,p+n+1); 	static int dp[maxN]; 	for(int i=1;i<=n;i++) { 		int64 ret=0; 	    for(int j=1;j<=n1;j++) 	        ret+=(int64)comb(p[i].x-l1[j].x,p[i].y-l1[j].y)*l1[j].cnt%mod;         //printf("tot[%d]=%d\n",i,int(ret%mod)); 		for(int j=1;j<i;j++) 		    ret-=(int64)dp[j]*comb(p[i].x-p[j].x,p[i].y-p[j].y)%mod;   		 		if((ret%=mod)<0) 		    ret+=mod; 		dp[i]=ret; 		//printf("dp[%d]=%d\n",i,dp[i]); 		 		ret=0; 		for(int j=1;j<=n2;j++) 	        ret+=(int64)comb(l2[j].x-p[i].x,l2[j].y-p[i].y)*l2[j].cnt%mod;         //printf("tot2[%d]=%d\n",i,int(ret%mod)); 		ans-=ret%mod*dp[i]%mod; 	} 	 	if((ans%=mod)<0) 		ans+=mod; 	return ans; } /* 	Method 2 	condition: H<=100 (n<=100) */ const int maxSize=109; int solve1D() { 	//Compute segments 	static int seg[maxSize][2]; 	int nSeg=0; 	nSeg++,seg[nSeg][0]=seg[nSeg][1]=0;   	sort(p+1,p+n+1); 	for(int i=1;i<=n;i++) 	    if(p[i].x==seg[nSeg][1]+1) 	        seg[nSeg][1]++; 		else if(p[i].x>seg[nSeg][1]+1) 		    nSeg++,seg[nSeg][0]=seg[nSeg][1]=p[i].x;   	if(W==seg[nSeg][1]+1) 	    seg[nSeg][1]++; 	else if(W>seg[nSeg][1]+1) 		nSeg++,seg[nSeg][0]=seg[nSeg][1]=W;   	//Init dist 	static int dCur[maxSize],cntCur[maxSize]; 	memset(dCur,194,sizeof(dCur)); 	dCur[0]=-1,cntCur[0]=1;   	//Advance in each segments 	static int d[maxSize][maxSize],cnt[maxSize][maxSize];     for(int si=1;si<=nSeg;si++) { 		int L=seg[si][0]-1,R=min(seg[si][1]+1,W); 		//printf("process %d~%d\n",L,R);   		//Init d[] 		for(int i=0;i<=R-L;i++) 		for(int j=0;j<=H;j++) 		    d[i][j]=oo,cnt[i][j]=0;         memcpy(d[0],dCur,sizeof(dCur));         memcpy(cnt[0],cntCur,sizeof(cntCur)); 		for(int i=1;i<=n;i++) 		    if(L<=p[i].x&&p[i].x<=R) 		        d[p[i].x-L][p[i].y]=-1;   		//Init queue jumper! 		static pair<int,int> la[maxSize]; 		int nla=0; 		for(int i=0;i<=H;i++) 		    if(dCur[i]>-oo) 		        la[++nla]=make_pair(dCur[i],i); 		sort(la+1,la+nla+1);   		//Init queue 		static int l[maxSize*maxSize][2]; 		int lh=1,lt=0,pos=1;   		//BFS 		while(lh<=lt||pos<=nla) { 			int x,y; 			if(lh<=lt) { 				x=l[lh][0],y=l[lh][1]; 				if(pos>nla||(d[x][y]<d[0][la[pos].second])) { 					lh++; 				    goto skip; 				} 			} 			x=0,y=la[pos++].second; 			//puts("jumper!"); 			skip:;   			//printf("%d %d d=%d cnt=%d\n",x,y,d[x][y],cnt[x][y]); 			for(int dir=0;dir<4;dir++) { 				if(x==0&&dir) 				    continue;   				int x2=x+dx[dir],y2=y+dy[dir]; 				if(0<=x2&&x2<=R-L&&0<=y2&&y2<=H) 					if(d[x][y]+1<d[x2][y2]) { 	                	d[x2][y2]=d[x][y]+1; 	                	cnt[x2][y2]=cnt[x][y]; 						ADD(x2,y2); 					} else if(d[x2][y2]==d[x][y]+1) 					    if((cnt[x2][y2]+=cnt[x][y])>=mod) 					        cnt[x2][y2]-=mod; 			} 		} 		//Arrive another side 		memcpy(dCur,d[R-L],sizeof(dCur));         memcpy(cntCur,cnt[R-L],sizeof(cntCur));   		//Run 		if(R<W) {             //Disconnected         	if(dCur[0]>=oo)             	return 0;   			//Update 			int len=seg[si+1][0]-1-R; 			if(len) { 				for(int i=0;i<=H;i++) { 					int ret=0; 					for(int j=0;j<=H;j++) 					    if(dCur[j]+abs(i-j)==dCur[i]) 							ret=(ret+(int64)cntCur[j]*comb(len-1,abs(i-j)))%mod; 					cnt[0][i]=ret; 				}   				for(int i=0;i<=H;i++) 					dCur[i]+=len; 				memcpy(cntCur,cnt[0],sizeof(cntCur)); 			} 		} 	} 	return cntCur[H]; } int main() { 	init(); 	/*int kk=10000000; 	printf("%d\n",(int64)kk*(kk-1)/2%mod); 	//printf("%d %d %d\n",kk%pMod[0],kk%pMod[1],kk%pMod[2]); 	printf("comb=%d\n",comb(kk-2,2)); 	//printf("%d *^%d\n",valFact[0][1000],powFact[0][1000]);*/   	int T; 	for(scanf("%d",&T);T;T--){   	scanf("%d%d%d",&W,&H,&n); 	for(int i=1;i<=n;i++) 	    scanf("%d%d",&p[i].x,&p[i].y); 	     	for(int i=1;i<=n;i++) 	    if(!(0<=p[i].x&&p[i].x<=W&&0<=p[i].y&&p[i].y<=H)) 	        p[i]=p[n],n--,i--;   	int ans; 	if(n<=W&&n<=H)     	ans=solve2D(); 	else { 		if(W<H) { 		    swap(W,H); 		    for(int i=1;i<=n;i++) 		    	swap(p[i].x,p[i].y); 		} 		if(H>100) 		    abort(); 		     		ans=solve1D(); 	} 	printf("%d\n",ans);} 	scanf("%*s"); } 
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> using namespace std; #define N 110 int x0[N],x1[N],y0[N],y1[N],e[N][N]; int b[N],d[N],next,n; bool inside(int i,int j) {  return x0[i]<x0[j]&&x1[i]>x1[j]&&y0[i]>y0[j]&&y1[i]<y1[j]; } int dfs(int x) {  b[x]=next;  for(int i=0;i<n;i++)  if(e[x][i]&&(d[i]==-1||(b[d[i]]!=next&&dfs(d[i]))))  {d[i]=x;return 1;}  return 0; } int main() { 	//freopen("in.txt","r",stdin); 	int T,i,j,k; 	scanf("%d",&T); 	while(T--) 	{ 	 scanf("%d",&n); 	 for(i=0;i<n;i++)scanf("%d%d%d%d",&x0[i],&x1[i],&y0[i],&y1[i]); 	 memset(e,0,sizeof(e)); 	 memset(d,-1,sizeof(d)); 	 for(i=0;i<n;i++) 	 for(j=0;j<n;j++) 	 if(inside(i,j))e[i][j]=1; 	 int ans=n; 	 for(i=0,next=0;i<n;i++) 	 { 	  next++; 	  ans-=dfs(i); 	 } 	 printf("%d\n",ans); 	} 	return 0; } 
#include<iostream> #include<vector> using namespace std;  struct node{ 	vector<pair<int,int> > adj_list; }; node graph[100001]; int s[100001];  void dfs(int u,int p,int x){ 	s[u]=x; 	for(int i=0;i<graph[u].adj_list.size();i++){ 		int v=graph[u].adj_list[i].first; 		int w=graph[u].adj_list[i].second; 		if(v==p) 			continue; 		dfs(v,u,x^w); 	} }  struct trie{ 	trie *left; 	trie *right; 	trie():left(NULL),right(NULL){}; };  void insert(trie *root,int x,int level){ 	trie *ptr=root; 	for(int i=level;i>=0;i--){ 		int p=(x>>i)&1; 		if(p){ 			if(ptr->right==NULL) 				ptr->right=new trie(); 			ptr=ptr->right; 		} 		else{ 			if(ptr->left==NULL) 				ptr->left=new trie(); 			ptr=ptr->left; 		} 	} }  int query(trie *root,int x,int level){ 	trie *ptr=root; 	int ans=0; 	for(int i=level;i>=0;i--){ 		int p=(x>>i)&1; 		if(p){ 			if(ptr->left!=NULL){ 				ans|=(1<<i); 				ptr=ptr->left; 			} 			else 				ptr=ptr->right; 		} 		else{ 			if(ptr->right!=NULL){ 				ans|=(1<<i); 				ptr=ptr->right; 			}	 			else 				ptr=ptr->left; 		} 	}  	return ans; }     int main(){ 	int t,n,u,v,w; 	cin>>t; 	while(t--){ 		cin>>n; 		for(int i=0;i<=n;i++) 			graph[i].adj_list.clear();  		for(int i=0;i<n-1;i++){ 			cin>>u>>v>>w; 			graph[u].adj_list.push_back(make_pair(v,w)); 			graph[v].adj_list.push_back(make_pair(u,w)); 		}  		dfs(1,0,0); 		trie * root =new trie(); 		insert(root,0,31); 		int ans=0; 		for(int i=1;i<=n;i++){ 			ans=max(ans,query(root,s[i],31)); 			insert(root,s[i],31); 		} 		cout<<ans<<endl; 	} 	return 0; }     	  	 
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <time.h>   using namespace std; typedef long long LL; const int maxn=32000;   int flag[maxn],sushu[maxn/5],t=0; int G,Y,factor[10],ft;   void prime() { 	for(int i=2;i<maxn;++i) 	{ 		if(!flag[i]) sushu[t++]=i; 		for(int j=0;j<t&&i*sushu[j]<maxn;++j) 		{ 			flag[i*sushu[j]]=sushu[j]; 			if(i%sushu[j]==0) break; 		} 	} }   int calc(int n,int g) { 	int ans=0; 	int nn=n/2; 	for(int i=n;i>=1;) 	{ 		int sta=g/i; 		int hj=g/(sta+1); 		if(hj<=nn)  			hj=nn; 		ans+=(i-hj)*sta; 		if(hj==nn) return ans; 		i=hj; 	} }   LL ans; void dfs(int a,int sum,int f) { 	if(a==ft) return ; 	dfs(a+1,sum,f); 	sum*=factor[a]; 	ans+=f*calc(2*Y/sum,G/sum); 	//printf("%d %lld\n",sum,ans); 	dfs(a+1,sum,f*-1); }       int solve(int n) { 	int ans=0; 	for(int i=2;i<=n;++i) 		for(int j=1;j<i;++j) 			if((i*j)%(i+j)==0) 				ans++; 	return ans; }   int main() { 	int T;scanf("%d",&T); 	prime(); 	while(T--) 	{ 		int N;scanf("%d",&N); 		ans=0; 		for(int i=2;i*i<=N;++i) 		{ 			int y=i; 			Y=i; 			G=N/i; 			ft=0; 			while(flag[y]) 			{ 				factor[ft++]=flag[y]; 				int po=flag[y]; 				while(y%po==0) y/=po;  			} 			if(y!=1) factor[ft++]=y; 			dfs(0,1,-1); 			ans+=calc(2*i,G); 		} 		printf("%lld\n",ans); 	} } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 100050 #define ll long long #define ld double #define PII pair <int,int> #define fr first #define sc second #define mp make_pair PII _li[N]; const ld pi = acos(-1.0); int fi[N],c[N*2][2],wei[N],h[N],rf[N],li[N],Prime[N]; int rev[N*4],Now[N],la[N],bit,len,n,m,ss=1,st;bool vis[N];ld ans; struct complex  {  	ld r,i;  	complex (){}  	complex (ld _r,ld _i) {r=_r;i=_i;}  } a[N*4],b[N*4],Emp; complex operator+ (const complex &x,const complex &y)  {return complex(x.r+y.r,x.i+y.i);} complex operator- (const complex &x,const complex &y)  {return complex(x.r-y.r,x.i-y.i);} complex operator* (const complex &x,const complex &y)  {return complex(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r);} inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Line(int x,int y)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } void Pretreat()  {  	for (int i=2;i<N;i++)  	 {  	 	if (!vis[i]) Prime[++st] = i;  	 	for (int j=1;Prime[j]*i<N;j++)  	 	 {  	 	 	vis[Prime[j] * i] = true;  	 	 	if (i % Prime[j] == 0) break;  	 	 }  	 }  	memset(vis,false,sizeof vis);  	return;  } void FFT(complex* a,int n,int f)  {  	for (int i=0;i<n;i++)  	 if (i<rev[i]) swap(a[i],a[rev[i]]);  	for (int p=1;p<n;p <<= true)  	 {  	 	complex wn(cos(pi/p),sin(pi/p)*f);  	 	for (int i=0;i<n;i += p << true)  	 	 {  	 	 	complex e(1,0);  	 	 	for (int j=0;j<p;j++,e=e*wn)  	 	 	 {  	 	 	 	complex x = a[i + j], y = a[i + j + p] * e;  	 	 	 	a[i + j] = x + y;a[i + j + p] = x - y;  	 	 	 }  	 	 }  	 }  	if (f==-1)  	 for (int i=0;i<n;i++) a[i].r/=n;  	return;  } void GetFFT()  {  	for (int i=1;i<len;i++)  	  rev[i] = (rev[i >> true] >> true) | ((i & true) << bit - 1);  	FFT(a,len,1);FFT(b,len,1);  	for (int i=0;i<len;i++) a[i] = a[i] * b[i];  	FFT(a,len,-1);     return;  } int GetList(int x)  {  	static int _st = false;_st ++;  	int ri = true,le = true;la[x] = false;  	Now[li[true] = x] = _st;  	for (;le<=ri;le++)  	 for (int i=fi[li[le]];i;i=c[i][1])  	  if (Now[c[i][0]] != _st&& !vis[c[i][0]])  	  	Now[c[i][0]] = _st,  	  	li[++ri] = c[i][0], la[c[i][0]] = li[le];   	return ri;  } int GetSize(int Cnt)  {  	for (int i=Cnt;i>=1;i--)  	 {  	 	wei[li[i]] = true;  	 	for (int j=fi[li[i]];j;j=c[j][1])  	 	 if (c[j][0]!=la[li[i]] && !vis[c[j][0]])  	 	   wei[li[i]] += wei[c[j][0]];  	 }  	int rt = li[1];  	while (true)  	 {  	 	bool flag = true;  	 	for (int i=fi[rt];i&&flag;i=c[i][1])  	 	 if (c[i][0]!=la[rt]&&wei[c[i][0]]*2>=Cnt&&  	 	   !vis[c[i][0]])  	 	   flag = false, rt = c[i][0];  	 	if (flag) return rt;  	 }  } void GetRf(int Cnt)  {  	rf[li[1]] = false;  	for (int i=fi[li[1]];i;i=c[i][1])  	 if (!vis[c[i][0]])  	   rf[c[i][0]] = c[i][0];  	for (int i=2;i<=Cnt;i++)  	 {  	 	if (rf[la[li[i]]]) rf[li[i]] = rf[la[li[i]]];  	 	_li[i-1] = mp(rf[li[i]] , h[li[i]]);  	 }  	sort(_li+1,_li+Cnt);  	for (int i=1;i<Cnt;)  	 {  	 	int ri = i,ma = _li[i].sc;  	 	while (ri < Cnt - 1 && _li[ri + 1].fr == _li[i].fr)  	 	  ma = max(ma, _li[++ ri].sc);  	 	len = true; bit = false;  	 	while (len <= max(2,ma * 2)) len = len << true ,bit ++;  	 	for (int j=0;j<len;j++) a[j] = Emp;  	 	for (;i <= ri;i ++) a[_li[i].sc] .r += true;  	 	ans -= a[1].r*(a[1].r - 1);  	 	for (int j=0;j<len;j++) b[j] = a[j];  	 	GetFFT();  	    for (int j=2;Prime[j] < len ; j++)  	      ans -= (ll)(a[Prime[j]].r + 0.5);  	 }  	return;  } void Solve(int x)  {  	int Cnt = GetList(x), rt = GetSize(Cnt), ma = false;  	GetList(rt);  	for (int i=1;i<=Cnt;i++)  	  ma = max(ma , h[li[i]] = h[la[li[i]]] + 1);  	len = true; bit = false;  	while (len<=max(ma*2,2)) len <<= true, bit ++;  	for (int i=0;i<len;i++) a[i]=Emp;  	for (int i=1;i<=Cnt;i++) a[h[li[i]]].r += true;  	ans += a[2].r*2;ans += a[1].r*(a[1].r - 1);  	for (int i=0;i<len;i++) b[i] = a[i];  	GetFFT();     for (int i=2;i<=st&&Prime[i]<len;i++)       ans += (ll)(a[Prime[i]].r+0.5);     GetRf(Cnt);vis[rt] = true;     for (int i=fi[rt];i;i=c[i][1])      if (!vis[c[i][0]]) Solve(c[i][0]);     return;  } int main()  {  	//freopen("input.txt","r",stdin);//freopen("output.txt","w",stdout);  	n=Read();Pretreat();h[0] = -1;  	for (int i=1;i<n;i++) Line(Read(),Read());  	Solve(1);printf("%.6lf\n",(double)(ans/n/(n-1)));  	return 0;  }
/* This solution is based on the editorials */  #include<cstdio> #include<vector>  #define pb       push_back #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  typedef long long   ll; typedef	vector<int> vi;  const int INF=(1<<31)-1;  int n,lim,dis[100][100]; vi tree[100],sublist[100]; bool sub[100][100]; // sub[u][v] ==true <=> the subtree rooted at u includes v  void maketree(int u,int parent){ 	rep(v,n){ 		if(v!=parent && dis[u][v]<INF) { 			tree[u].pb(v); 			sub[u][v]=true; 			maketree(v,u); 		} 	} }  int dp1[100][100],dp2[100];  int dfs1(int v,int c); int dfs2(int u);  int dfs1(int v,int c){ 	if(~dp1[v][c]) return dp1[v][c];  	// case 1 	if(tree[v].size()==0){ // v is a leaf 		return dp1[v][c]=0; 	}  	// case 2 	if(v==c || !sub[v][c]){ 		int ans=0; 		rep(i,tree[v].size()){ 			int u=tree[v][i]; 			if(dis[u][c]<=lim) ans+=max(dfs2(u),dfs1(u,c)+dis[u][v]); 			else               ans+=dfs2(u); 		} 		return dp1[v][c]=ans; 	}  	// case 3 	int ans=0; 	rep(i,tree[v].size()){ 		int u=tree[v][i]; 		if(sub[u][c]) ans+=dis[u][v]+dfs1(u,c); 		else{ 			if(dis[u][c]<=lim) ans+=max(dfs2(u),dfs1(u,c)+dis[u][v]); 			else               ans+=dfs2(u); 		} 	} 	return dp1[v][c]=ans; }  int dfs2(int u){ 	if(~dp2[u]) return dp2[u];  	int ans=0; 	rep(i,sublist[u].size()){ 		int c=sublist[u][i]; 		if(dis[u][c]<=lim) ans=max(ans,dfs1(u,c)); 	} 	return dp2[u]=ans; }  int main(){ 	int T; scanf("%d",&T); 	while(T--){ 		scanf("%d%d",&n,&lim);  		// initialize 		rep(u,n){ 			tree[u].clear(); 			sublist[u].clear(); 			rep(v,n){ 				dis[u][v]=INF; 				sub[u][v]=false; 				dp1[u][v]=-1; 			} 			dp2[u]=-1; 		}  		rep(i,n-1){ 			int u,v,w; scanf("%d%d%d",&u,&v,&w); 			dis[u][v]=dis[v][u]=w; 		}  		maketree(0,-1);  		// Warshall-Floyd 		rep(u,n) dis[u][u]=0; 		rep(k,n) rep(i,n) rep(j,n) { 			if((ll)dis[i][k]+dis[k][j]<dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j]; 		}  		// transitive closure 		rep(u,n) sub[u][u]=true; 		rep(k,n) rep(i,n) rep(j,n) { 			sub[i][j]|=(sub[i][k] && sub[k][j]); 		} 		rep(u,n) rep(v,n) if(sub[u][v]) sublist[u].pb(v);  		int ans=0; 		rep(u,n) if(dis[0][u]<=lim) ans=max(ans,dfs1(0,u)); 		printf("%d\n",ans); 	}  	return 0; } 
#include <stdio.h> #include <stdlib.h> #include <string.h> #include <assert.h> #include <complex> #include <iostream> #include <string> #include <vector> #include <queue> #include <map> #include <algorithm> #include <utility> using namespace std; #define rep(i, n) for (int i = 0; i < (int)(n); i++) #define mp make_pair typedef complex<int> P; #define MOD (1000000007)  int toe(char ch) {     if (islower(ch)) return ch - 'a';     else return ch - 'A' + 26; }  void decode(const char *src, char *dst) {     int k = 0;     for (int i = 0; isalpha(src[i]); i++) {         const int b = toe(src[i]);         rep (j, 5) dst[k++] = (b&(1<<(4-j))) ? '1' : '0';     } }  #define N (1200000) int n, m; char buf[500000]; char pat[N], ent[N]; int fail[N], toc[N][2]; int enter;  int to(int k, char ch) {     while (k >= 0 && pat[k] != ch) k = fail[k];     return k+1; }  bool build() {     int j = fail[0] = -1;     for (int i = 1; i <= n; i++) {         while (j >= 0 && pat[j] != pat[i-1]) j = fail[j];         fail[i] = ++j;     }     rep (i, n) rep (k, 2) {         if (pat[i] == '0' + k) toc[i][k] = i+1;         else toc[i][k] = fail[i] >= 0 ? toc[fail[i]][k] : 0; //        assert(toc[i][k] == to(i, '0'+k));     }     int k = 0;     rep (i, m) {         while (k >= 0 && pat[k] != ent[i]) k = fail[k];         k++;         if (k >= n) return true;     }     enter = k;     return false; }  /* #define Z (128) double a[Z][Z]; void eqsolve(int n, double (*a)[Z]) {     rep(k, n) {         double mx = -1;         int ix = -1;         for(int i=k; i<n; i++) if(mx<fabs(a[i][k])) mx=fabs(a[i][k]), ix=i;         if(k!=ix) rep(i, n+1) swap(a[k][i], a[ix][i]);         const double p = a[k][k];         for(int i=k; i<=n; i++) a[k][i] /= p;         rep(i, n) if(i!=k) {             const double d = a[i][k];             for(int j=k; j<=n; j++) a[i][j] -= d*a[k][j];         }     } }  double solve1() {     memset(a, 0, sizeof(a));     rep (i, n) {         a[i][to(i, '0')] = a[i][to(i, '1')] = -1.0;         a[i][i] += 2.0;         a[i][n] = 2.0;     }     eqsolve(n, a);     rep (i, n) printf("a1 [%d] = %f\n", i, a[i][n]);     return a[enter][n]; } */  int b[N], sum[N];  int solve2() {     rep (i, n) b[i] = 2; //    memset(sum, 0, sizeof(sum));     rep (i, n) { //        const int fr = to(i, pat[i] == '0' ? '1' : '0');         const int fr = toc[i][pat[i] == '0']; //        for (int j = fr; j < i; j++) b[i] = (b[i] + b[j]) % MOD;         //b[i] = (b[i] + sum[i]) % MOD;         b[i] += sum[i];         if (b[i] >= MOD) b[i] -= MOD;         //b[i] = (b[i] + (MOD - sum[fr])) % MOD;         b[i] += MOD-sum[fr];         if (b[i] >= MOD) b[i] -= MOD;         //sum[i+1] = (sum[i] + b[i]) % MOD;         sum[i+1] = sum[i] + b[i];         if (sum[i+1] >= MOD) sum[i+1] -= MOD;     }     for (int i = n-2; i >= 0; i--) {         //b[i] = (b[i] + b[i+1]) % MOD;         b[i] += b[i+1];         if (b[i] >= MOD) b[i] -= MOD;     } //    rep (i, n) printf("a2 [%d] = %d\n", i, b[i]);     return b[enter]; }  int main() {     fgets(buf, sizeof(buf), stdin);     int T = atoi(buf);     while (T--) {         char *p;         fgets(buf, sizeof(buf), stdin);         n = atoi(buf);         p = buf;         while (*p++ != ' ');         decode(p, pat);         pat[n] = 0;          fgets(buf, sizeof(buf), stdin);         m = atoi(buf);         p = buf;         while (*p++ != ' ');         decode(p, ent);         ent[m] = 0;  //        printf("%s\n", pat); //        printf("%s\n", ent);          if (build()) printf("%d\n", 0);         else { //            printf("%f\n", solve1());             printf("%d\n", solve2());         }     }     return 0; } 
/* Author: Ankit Sultana  * Comment:   * * * * * * * * * * * * * */ #include <iostream> #include <cstdio> #include <iomanip> #include <iterator> #include <cmath> #include <cassert> #include <cstring> #include <algorithm> #include <vector> #include <map> #include <set> #include <list> #include <queue> #define F first #define S second #define LL long long #define PB push_back #define gc getchar_unlocked #define SWAP(a,b) a^=b,b^=a,a^=b #define MP make_pair #define pint pair<int, int> #define pll pair<LL, LL> #define vi vector<int> #define vll vector<LL> #define REP(i,n)	for(__typeof(n) i = 0; i < n; i++) #define REP1(i,n)	for(__typeof(n) i = 1; i <= n; i++) #define REP2(i,n)	for(__typeof(n) i = 1; i < n; i++) #define REPc(i,j,n)	for(__typeof(n) i = j; i <= n; i++) #define REPc2(i,j,n)	for(__typeof(n) i = j; i < n; i++) #define matint vector<vi > #define matll vector<vll > #define last_bit(n) (n&(-n)) #define ll_two(n) (1ll<<n) #define int_two(n) (1<<n) #define absol(n) (n < 0?-n: n)  #define ALL(container) (container).begin(), (container).end() #define RALL(container) (container).rbegin(), (container).rend() #define SZ(container) (container).size() #define FOR(i,c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++) #define PRINT(i,j,k,arr) for(__typeof(k) i = j; i <= k; i++) std::cout<<arr[i]<<' ';  const int INF = 1<<28; const LL mod = 1000000007;  template<class T> std::ostream& operator<<(std::ostream &os, const std::vector<T> &t) { 	os<<"["; FOR(it,t) { if(it != t.begin()) os<<", "; os<<*it; } os<<"]\n"; 	return os; }  template <typename T> T gcd(T a, T b) { return b==0?a: gcd(a%b, b); }  template <typename T> T expo(T b, T e) { 	if(e <= 1)	return e==0?1: b; 	return (e&1)==1? (b*expo((b*b)%mod, e>>1))%mod: expo((b*b)%mod, e>>1); }  using namespace std;  template <typename T> void scanint(T &x) { 	register T c = gc(); 	while(((c < 48) || (c > 57)) && (c!='-')) c = gc(); 	bool neg = false; if(c == '-') neg = true; x = 0; 	for(;c < 48 || c > 57;c=gc()); 	for(;c > 47 && c < 58;c=gc())	x = (x*10) + (c - 48); if(neg)	x = -x; }  const int MAXN = 6000123;  LL store[MAXN] = {0}; LL phi[MAXN] = {0};  void precomp() { 	phi[1] = 1; 	for(LL i = 1; i < MAXN; i++){ 		if(phi[i] == 0){ 			phi[i] = i-1; 			//j = i's multiples 			for(LL j = i*2; j < MAXN; j+=i){ 				if(phi[j] == 0)	phi[j] = j; 				phi[j] = (phi[j]/i)*(i-1); 			} 		} 	} 	for(int i = 1; i < MAXN; i++) 		store[i] = store[i-1]+phi[i]; }  LL PHI(LL n) { 	if(n < MAXN)	return store[n]; 	//add base crap 	LL res = (n*(n+1))/2; 	//remove first sqrt n values, these occur only once..  	//and these values are n, n-1, ... sqrt(n) 	LL d; 	//Kind of square root decomposition 	for(d = 2; d*d <= n; d++) 		res -= PHI(n/d); 	//remove last sqrt n values, these may have non-unity frequency.. 	//and these values are 1, 2, 3, ... sqrt(n) 	int x = n/d, lower, upper, freq; 	for(; x > 0; x--){ 		lower = n/(x+1); 		lower++; 		upper = n/x; 		freq = upper-lower+1; 		res -= freq*store[x]; 		/*lower = ceil(double(n)/(x+1)); 		if(n%(x+1) == 0) lower++; 		upper = n/x; 		freq = upper-lower+1; 		res -= freq*store[x];*/ 	} 	return res; }  int main() { 	precomp(); 	LL N, D, t; 	scanint(t); 	while(t--){ 		scanint(N), scanint(D); 		//output phisum till N/D 		printf("%lld\n", PHI(N/D)); 	} 	return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<cassert> using namespace std; #define MAXN 101000 #define MAXT MAXA*40 #define MAXV MAXA*2 #define MAXE MAXA*4 #define MAXA MAXN*2 #define INF 0x7fffffff #define smid ((l+r)>>1) int n,m; namespace task_st//线段树,区间最小值,维护环 { 		int tmp[MAXA]; 		struct sgt_node 		{ 				int lc,rc; 				int mnv; 		}sgt[MAXT]; 		int topt; 		void Build_sgt(int &now,int l,int r) 		{ 				now=++topt; 				if (l==r) 				{ 						sgt[now].mnv=tmp[l]; 						return ; 				} 				Build_sgt(sgt[now].lc,l,smid); 				Build_sgt(sgt[now].rc,smid+1,r); 				sgt[now].mnv=min(sgt[sgt[now].lc].mnv,sgt[sgt[now].rc].mnv); 		} 		void Modify_sgt(int &now,int l,int r,int pos,int v) 		{ 				if (l==r) 				{ 						sgt[now].mnv=v; 						return ; 				} 				if (pos<=smid) 						Modify_sgt(sgt[now].lc,l,smid,pos,v); 				else 						Modify_sgt(sgt[now].rc,smid+1,r,pos,v); 				sgt[now].mnv=min(sgt[sgt[now].lc].mnv,sgt[sgt[now].rc].mnv); 		} 		int Query_sgt(int &now,int l,int r,int x,int y) 		{ 				if (x>y) 				{ 						assert(x-1==y); 						return INF; 				} 				if (l==x && r==y) 						return sgt[now].mnv; 				if (y<=smid) 						return Query_sgt(sgt[now].lc,l,smid,x,y); 				else if (smid<x) 						return Query_sgt(sgt[now].rc,smid+1,r,x,y); 				else 						return min(Query_sgt(sgt[now].lc,l,smid,x,smid),Query_sgt(sgt[now].rc,smid+1,r,smid+1,y));  		} } struct Edge { 		int np,val; 		Edge *next; }E[MAXE],*V[MAXV]; int tope=-1; void addedge(int x,int y,int z=0) { 		//cout<<"Add "<<x<<" "<<y<<" "<<z<<endl; 		E[++tope].np=y; 		E[tope].val=z; 		E[tope].next=V[x]; 		V[x]=&E[tope]; } //tarjan int cpdis[MAXN]; int cptr[MAXN]; int circ[MAXN]; int cpos[MAXN]; bool incirc[MAXN]; int ctop[MAXN]; int csiz[MAXN]; int croot[MAXN]; namespace task_tj//缩点 { 		int low[MAXN],dfn[MAXN],dfstime; 		int pnt[MAXN]; 		int status[MAXN]; 		int depth[MAXN]; 		void tarjan(int now) 		{ 				low[now]=dfn[now]=++dfstime; 				status[now]=1; 				Edge *ne; 				for (ne=V[now];ne;ne=ne->next) 				{ 						if (ne->np==pnt[now])continue; 						if (status[ne->np]==1) 						{ 								cptr[ne->np]=now; 								low[now]=min(low[now],dfn[ne->np]); 						}else if (!status[ne->np]) 						{ 								pnt[ne->np]=now; 								depth[ne->np]=depth[now]+1; 								tarjan(ne->np); 								low[now]=min(low[now],low[ne->np]); 						} 				} 				if (low[now]==dfn[now] && !cptr[now]) 						cptr[now]=now; 				status[now]=2; 		} } //treesplit int son[MAXV],top[MAXV],pnt[MAXV]; int q[MAXV]; int depth[MAXV]; int siz[MAXV]; int apos[MAXV],pos[MAXV],dfstime; int spos[MAXV],tpos[MAXV]; int troot[MAXV]; void bfs(int now) { 		Edge *ne; 		q[0]=now; 		int head=-1,tail=0; 		while (head<tail) 		{ 				now=q[++head]; 				for (ne=V[now];ne;ne=ne->next) 				{ 						//if (ne->np==pnt[now])continue; 						pnt[ne->np]=now; 						depth[ne->np]=depth[now]+1; 						q[++tail]=ne->np; 				} 		} 		for (int i=tail;i>=0;i--) 		{ 				now=q[i]; 				int mxsiz=0; 				siz[now]=1; 				for (ne=V[now];ne;ne=ne->next) 				{ 						//if (ne->np==pnt[now])continue; 						siz[now]+=siz[ne->np]; 						if (siz[ne->np]>mxsiz) 								mxsiz=siz[ne->np],son[now]=ne->np; 				} 		} } int stack[MAXV],tops=-1; void dfs(int now) { 		Edge *ne; 		stack[++tops]=now; 		top[now]=now; 		int tot=0; 		while (~tops) 		{ 				tot++; 				now=stack[tops--]; 				tpos[now]=spos[now]=pos[now]=++dfstime; 				apos[dfstime]=now; 				for (ne=V[now];ne;ne=ne->next) 				{ 						if (ne->np==son[now])continue; 						top[ne->np]=ne->np; 						stack[++tops]=ne->np; 				} 				if (son[now]) 				{ 						stack[++tops]=son[now]; 						top[son[now]]=top[now]; 				} 		} 		for (int i=tot-1;i>=0;i--) 		{ 				now=q[i]; 				Edge *ne; 				for (ne=V[now];ne;ne=ne->next) 						tpos[now]=max(tpos[now],tpos[ne->np]); 		} }  struct edge { 		int x,y,z; 		edge(){} 		edge(int x,int y,int z):x(x),y(y),z(z){}; }e[MAXE]; int rpdis[MAXA]; int main() { 		scanf("%d%d",&n,&m); 		int x,y,z; 		//read graph 		for (int i=1;i<=m;i++) 		{ 				scanf("%d%d%d",&x,&y,&z); 				e[i]=edge(x,y,z); 				addedge(x,y,z); 				addedge(y,x,z); 		} 		//find circle 		int totc=0; 		task_tj::tarjan(1); 		for (int i=1;i<=m;i++) 		{ 				x=e[i].x,y=e[i].y,z=e[i].z; 				if (cptr[y]==x)swap(x,y); 				if (cptr[x]==y) 				{ 						cpdis[y]=z; 						continue; 				} 				if (task_tj::pnt[y]==x)swap(x,y); 				assert(task_tj::pnt[x]==y); 				if (cptr[x]) 						rpdis[x]=z; 				else 						cpdis[y]=z; 		} 		for (int i=1;i<=n;i++) 				if (cptr[i]) 				{ 						int x=cptr[i]; 						int y=0; 						int z; 						totc++; 						rpdis[totc+n]=rpdis[i]; 						rpdis[i]=0; 						while (x!=i) 						{ 								cpos[x]=++y; 								task_st::tmp[y]=cpdis[x]; 								circ[x]=totc; 								incirc[x]=true; 								x=task_tj::pnt[x]; 						}; 						cpos[x]=++y; 						task_st::tmp[y]=cpdis[x]; 						circ[x]=totc; 						incirc[x]=true; 						ctop[totc]=x; 						csiz[totc]=y; 						task_st::Build_sgt(croot[totc],1,y); 				} 		memset(V,0,sizeof(V));tope=-1; 		for (int i=1;i<=n;i++) 				addedge(n+circ[i],i); 		int trt; 		for (int i=1;i<=totc;i++) 				if (task_tj::pnt[ctop[i]]) 						addedge(task_tj::pnt[ctop[i]],n+i); 				else 						trt=i+n; 		bfs(trt); 		dfs(trt); 		int l=n+totc; 		memset(task_st::tmp,-1,sizeof(task_st::tmp)); 		for (int i=1;i<=l;i++) 		{ 				if (top[i]==i)continue; 				if (i<=n) 				{ 						int c=circ[i]; 						int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[i]); 						int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[i]+1,csiz[c]); 						task_st::tmp[pos[i]]=(t1==INF || t2==INF)?INF:t1+t2; 						if (task_st::tmp[pos[i]]<0) 								assert(task_st::tmp[pos[i]]>=0); 				}else 				{ 						task_st::tmp[pos[i]]=rpdis[i]; 				} 		} 		for (int i=1;i<=l;i++) 		{ 				if (top[i]==i) 						task_st::Build_sgt(troot[i],spos[i],tpos[i]); 		} 		scanf("%d",&m); 		int opt; 		for (int i=1;i<=m;i++) 		{ 				scanf("%d",&opt); 				if (opt==0) 				{ 						scanf("%d%d",&x,&y); 						int sx=x,sy=y; 						int a; 						while (true) 						{ 								if (top[x]==top[y]) 								{ 										a=(depth[x]<depth[y])?x:y; 										break; 								} 								if (depth[top[x]]<depth[top[y]])swap(x,y); 								x=pnt[top[x]]; 						} 						if (a<=n)a=pnt[a]; 						int ans=INF; 						x=sx;y=sy; 						for (int p=0;p<2;p++) 						{ 								while (true) 								{ 										if (top[a]==top[x]) 										{ 												if (a==x || a==pnt[x])break; 												ans=min(ans,task_st::Query_sgt(troot[top[x]],spos[top[x]],tpos[top[x]],pos[a]+2,pos[x])); 												x=apos[pos[a]+1]; 												break; 										} 										ans=min(ans,task_st::Query_sgt(troot[top[x]],spos[top[x]],tpos[top[x]],spos[top[x]]+1,pos[x])); 										x=top[x]; 										if (pnt[x]==a)break; 										if (x>n) 												ans=min(ans,rpdis[x]); 										else 										{ 												int c=circ[x]; 												int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[x]); 												int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[x]+1,csiz[c]); 												ans=min(ans,(t1==INF || t2==INF)?INF:t1+t2); 										} 										x=pnt[x]; 								} 								swap(x,y); 						} 						if (cpos[x]>cpos[y])swap(x,y); 						if (cpos[x]<cpos[y]) 						{ 								assert(circ[x]==circ[y]); 								int c=circ[x]; 								int t1=task_st::Query_sgt(croot[c],1,csiz[c],cpos[x]+1,cpos[y]); 								int t2=min(task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[x]), 												task_st::Query_sgt(croot[c],1,csiz[c],cpos[y]+1,csiz[c])); 								ans=min(ans,(t1==INF || t2==INF)?INF:t1+t2); 						} 						printf("%d\n",ans); 				}else 				{ 						int d,v; 						scanf("%d%d",&d,&v); 						x=e[d].x;y=e[d].y; 						if (task_tj::depth[x]>task_tj::depth[y])swap(x,y); 						if (cptr[x]==y) 						{ 								int c=circ[x]; 								task_st::Modify_sgt(croot[c],1,csiz[c],1,v); 								int t; 								if ((t=son[circ[x]+n])) 								{ 										if (t==ctop[circ[t]]) 										{ 												task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],INF); 										}else 										{ 												int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[t]); 												int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[t]+1,csiz[c]); 												task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],(t1==INF || t2==INF)?INF:t1+t2); 										} 								} 						}else 						{ 								assert(task_tj::pnt[y]==x); 								if (cptr[y]) 								{ 										int t; 										rpdis[t=circ[y]+n]=v; 										if (top[t]!=t) 										{ 												task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],v); 										} 								}else 								{ 										int c=circ[x]; 										task_st::Modify_sgt(croot[c],1,csiz[c],cpos[x],v); 										int t; 										if ((t=son[circ[x]+n])) 										{ 												if (t==ctop[circ[t]]) 												{ 														task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],INF); 												}else 												{ 														int t1=task_st::Query_sgt(croot[c],1,csiz[c],1,cpos[t]); 														int t2=task_st::Query_sgt(croot[c],1,csiz[c],cpos[t]+1,csiz[c]); 														task_st::Modify_sgt(troot[top[t]],spos[top[t]],tpos[top[t]],pos[t],(t1==INF || t2==INF)?INF:t1+t2); 												} 										} 								} 						} 				} 		} 		return 0; }
#include<iostream> #include<cstdio> #include<cstring> #include<cstdlib> #include<algorithm>  using namespace std; int t,trie[1010][30],flag[1010],fail[1010],tail,que[1010],head,f[1010][1010],n,m; int next[1010][1010],c[1010][1010]; char s[1010],dic[1010],Trie[1010]; void Add(int k) { 	int now=0,len=strlen(dic+1),i; 	for (i=1;i<=len;++i) 	{ 		if (trie[now][dic[i]-'a']) 			now=trie[now][dic[i]-'a']; 		else 			trie[now][dic[i]-'a']=++tail,now=tail,Trie[now]=dic[i]; 	} 	flag[now]++; } void AC() { 	head=0; que[tail=1]=0; 	int now,i,v; 	while (head<tail) 	{ 		now=que[++head]; 		for (i=0;i<26;++i) 			if (v=trie[now][i]) 			{ 				if (now) 					fail[v]=trie[fail[now]][i],flag[v]+=flag[fail[v]]; 				que[++tail]=v; 			} 			else 				trie[now][i]=trie[fail[now]][i]; 	} } int main() { 	int i,j,k; 	scanf("%d",&t); 	while (t--) 	{ 		scanf("%d%d",&n,&m); 		memset(trie,0,sizeof(trie)); 		memset(fail,0,sizeof(fail)); 		memset(flag,0,sizeof(flag)); 		memset(trie,0,sizeof(trie)); 		tail=0; 		scanf("\n%s",s+1); 		for (i=1;i<=m;++i) 		{ 			scanf("%s",dic+1); 			Add(i); 		} 		int top=tail; 		AC(); 		memset(f,200,sizeof(f)); 		for (i=0;i<=top;++i) 			f[i][0]=flag[i]; 		for (i=1;i<=n;++i) 		{ 			for (j=0;j<=top;++j) 			{ 				if (s[n-i+1]=='?') 				{ 					for (k=0;k<26;++k) 					{ 						if (f[trie[j][k]][i-1]+flag[j]>f[j][i]) 							f[j][i]=f[trie[j][k]][i-1]+flag[j], 							next[j][i]=trie[j][k],c[j][i]=k; 					} 				} 				else 					f[j][i]=f[trie[j][s[n-i+1]-'a']][i-1]+flag[j], 					next[j][i]=trie[j][s[n-i+1]-'a'],c[j][i]=s[n-i+1]-'a'; 				//printf("f[%d][%d]:%d next[%d][%d]=%d\n",j,i,f[j][i],j,i,next[j][i]); 			} 		} 		printf("%d\n",f[0][n]); 		int now=0; 		for (i=n;i;--i) 		{ 			printf("%c",c[now][i]+'a'); 			now=next[now][i]; 		} 		puts(""); 	} 	return 0; } 
#include<stdio.h> #include<stdlib.h> #include<cstring> #include<iostream> #include<ctype.h> #include<algorithm> #include<vector> #include<string> #include<set> #include<map> #include<stack> #include<queue> #include<cmath> #include<bitset> #include<iomanip> #include<complex> #include<utility>   #define X first #define Y second #define REP_0(i,n) for(int i=0;i<(n);++i) #define REP_1(i,n) for(int i=1;i<=(n);++i) #define REP_2(i,a,b) for(int i=(a);i<(b);++i) #define REP_3(i,a,b) for(int i=(a);i<=(b);++i) #define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c)) #define DOW_0(i,n) for(int i=(n)-1;-1<i;--i) #define DOW_1(i,n) for(int i=(n);0<i;--i) #define DOW_2(i,a,b) for(int i=(b);(a)<i;--i) #define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i) #define FOREACH(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a) #define RFOREACH(a,b) for(typeof((b).rbegin()) a=(b).rbegin();a!=(b).rend();++a) #define PB push_back #define PF push_front #define MP make_pair #define IS insert #define ES erase #define IT iterator #define RI reserve_iterator #define PQ priority_queue #define LB lower_bound #define UB upper_bound #define ALL(x) x.begin(),x.end()   #define PI 3.1415926535897932384626433832795 #define EXP 2.7182818284590452353602874713527   using namespace std;   typedef long long LL; typedef long double LD; typedef double DB; typedef pair<int,int> PII; typedef vector<int> VI; typedef pair<int,PII> PIII; typedef pair<LD,int> PLDI; typedef vector<PII> VII;   template<class T> T Mul(T x,T y,T P){ 	T F1=0; 	while(y) 	{ 		if(y&1) 		{ 			F1+=x; 			if(F1<0||F1>=P)F1-=P; 		} 		x<<=1; 		if(x<0||x>=P)x-=P; 		y>>=1; 	} 	return F1; }   template<class T> T Pow(T x,T y,T P){ 	T F1=1;x%=P; 	while(y) 	{ 		if(y&1) 		{ 			F1=Mul(F1,x,P); 		} 		x=Mul(x,x,P); 		y>>=1; 	} 	return F1; }   template<class T> T Gcd(T x,T y){ 	if(y==0)return x; 	T z; 	while(z=x%y){ 		x=y,y=z; 	} 	return y; }   template<class T> void UpdateMin(T &x,T y){ 	if(y<x) 	{ 		x=y; 	} }   template<class T> void UpdateMax(T &x,T y){ 	if(x<y) 	{ 		x=y; 	} }   template<class T> T Sqr(const T x){ 	return x*x; }   template<class T> T Abs(const T x){ 	return x<0?-x:x; }   #define MaxBuffer 20000000 class ReadBuffer{ 	private: 	char buff[MaxBuffer]; 	char *buf; 	public: 	void init(int size=MaxBuffer) 	{ 		fread(buff,1,size,stdin); 		buf=buff; 	} 	template<class T> 	bool readInteger(T &x) 	{ 		x=0; 		while(*buf&&isspace(*buf)) ++buf; 		if(*buf==0) return false; 		static bool flag; 		flag=0; 		if(*buf=='-') flag=true; 		else x=*buf-'0'; 		while(isdigit(*++buf)) x=x*10+*buf-'0'; 		if(flag) x=-x; 		return true; 	} 	template<class T> 	bool readFloat(T &x) 	{ 		long double nowpos=0.1; 		x=0; 		while(*buf&&isspace(*buf)) ++buf; 		if(*buf==0) return false; 		static bool flag,decimal; 		decimal=flag=0; 		if(*buf=='-') flag=true,++buf; 		else if(*buf=='.') decimal=true; 		while(isdigit(*buf)||*buf=='.') 		{ 			if(*buf=='.') decimal=true; 			else 			{ 				if(decimal) 				{ 					x+=nowpos*(*buf-'0'); 					nowpos*=0.1; 				} 				else 				{ 					x=x*10+*buf-'0'; 				} 			} 			++buf; 		} 		return true; 	} 	bool readChar(char c) 	{ 		if(*buf==0) return 0; 		return c=*buf++,1; 	} 	bool readString(char *s) 	{ 		while(*buf&&isspace(*buf)) ++buf; 		if(!*buf) return false; 		while(!isspace(*buf)) *s++=*buf++; 		*s++=0; 		return true; 	} 	int countSpacetonext(){ 		int total=0; 		while(*buf&&*buf==' ') ++total,++buf; 		return total; 	} 	bool splitBycharactor(char *s,char Split='\n'){ 		while(*buf&&*buf!=Split) *s++=*buf++; 		*s++=0; 		return *buf!=0; 	} };   struct EDGE{ 	int T;EDGE *Nxt; };   namespace TwoDimension{ 	inline int Sign(LL x){ 		return x<0?-1:x>0; 	} 	struct point{ 		int x,y; 		point(){} 		point(int x,int y):x(x),y(y){} 		void read(){int tx,ty;scanf("%d%d",&tx,&ty);x=tx,y=ty;} 		bool operator <(const point &a)const{ 			return x<a.x||(x==a.x&&y<a.y); 		} 		bool operator ==(const point &a)const{ 			return x==a.x&&y==a.y; 		} 		point operator -(const point &a)const{ 			return point(x-a.x,y-a.y); 		} 		point operator +(const point &a)const{ 			return point(x+a.x,y+a.y); 		} 		point operator *(const LL &a)const{ 			return point(x*a,y*a); 		} 	}; 	inline LL det(const point &a,const point &b){ 		return (LL)a.x*b.y-(LL)a.y*b.x; 	} 	struct segment{ 		point s,t; 		int belong; 		segment(){} 		segment(point _s,point _t,int _belong):s(_s),t(_t),belong(_belong){ 			if(t<s) swap(s,t),belong=-belong; 		} 		bool operator <(const segment &a){return s<a.s;} 		bool operator ==(const segment &a){return s==a.s&&t==a.t;} 		LL relation(const point &b)const{ 			return Sign(det(s-b,t-b)); 		} 		bool under(const segment &b)const{ 			register int f; 			if(b.s.x<s.x){ 				f=b.relation(s); 				if(f) return f>0; 			} 			else{ 				f=relation(b.s); 				if(f) return f<0; 			} 			if(b.t.x>t.x){ 				f=b.relation(t); 				if(f) return f>0; 			} 			else{ 				f=relation(b.t); 				if(f) return f<0; 			} 			return false; 		} 	}; }   namespace Treap{ 	const int maxTreepNode = 8000000; 	struct TreapNode{ 		TwoDimension::segment x; 		int y; 		TreapNode *c[2]; 		void init(const TwoDimension::segment &_x){ 			c[0]=c[1]=0; 			x=_x,y=((rand()&32768)<<16)|(rand()&32768); 		} 	}*root,totalnode[maxTreepNode],*pn; 	 	inline void Rotate(TreapNode *x,TreapNode *y,int p){ 		y->c[p]=x->c[!p]; 		x->c[!p]=y; 	}/* 	void Maintain(TreapNode *x){ 		while(x->fa&&x->fa->y > x->y){ 			Rotate(x,x->fa->c[1]==x); 			if(!x->fa) root=x; 		} 	}*/ 	inline TreapNode* NewNode(const TreapNode &x){ 		*pn=x; 		return pn++; 	} 	inline void Clear(){root=0;pn=totalnode;} 	TreapNode* Union(TreapNode *x,TreapNode *y){ 		if(!x||!y) return x?x:y; 		if(x->y>y->y) swap(x,y); 		x=NewNode(*x); 		int f=!(x->x.under(y->x)); 		x->c[f]=Union(x->c[f],y); 		return x; 	} 	TreapNode* Insert(TreapNode *now,const TwoDimension::segment &s){ 		if(!now){ 			TreapNode *x=pn; 			x->init(s); 			++pn; 			return x; 		} 		else{ 			now=NewNode(*now); 			int f=!(now->x.under(s)); 			now->c[f]=Insert(now->c[f],s); 			if(now->c[f]->y>now->y){ 				TreapNode *g=now->c[f]; 				Rotate(g,now,f); 				now=g; 			} 			return now; 		} 	} 	/* 	inline TreapNode *Find(const segment &s){ 		TreapNode *now=root; 		while(1){ 			if(now->x==s) return now; 			now=now->c[!now->x.under(s)]; 		} 	} 	*/ 	TreapNode *Delete(TreapNode *now,const TwoDimension::segment &s){ 		if(now->x==s){ 			return Union(now->c[0],now->c[1]); 		} 		else{ 			now=NewNode(*now); 			int f=!(now->x.under(s)); 			now->c[f]=Delete(now->c[f],s); 			return now; 		} 	} 	inline int Query(const TwoDimension::point &s,TreapNode* nowroot){ 		int ans=1; 		while(nowroot){ 			int f=nowroot->x.relation(s); 			if(!f){ 				ans=-Abs(nowroot->x.belong); 				break; 			} 			if(f<0){ 				ans=nowroot->x.belong; 				nowroot=nowroot->c[0]; 			} 			else nowroot=nowroot->c[1]; 		} 		return ans>0?-1:-ans; 	} 	inline void TLE(){ 		if(pn-totalnode>8000000) while(1); 	} }   struct Event{ 	TwoDimension::segment s; 	int x,y; 	inline bool operator <(const Event &a)const{ 		return x<a.x||x==a.x&&y<a.y; 	} }E[601001];   int totalE;   Treap::TreapNode *recordroot[600101]; int recordx[600101]; int totalrecord; TwoDimension::point polygon[601001]; int main(){ //	freopen("a.in","r",stdin); //	freopen("a.out","w",stdout); 	srand(361120154); 	int n; 	scanf("%d",&n); //	n=1; 	totalE=0; 	REP_1(i,n){ 		int m; 		scanf("%d",&m); //		m=300000; 		REP_1(j,m){ 			polygon[j].read(); 			//polygon[j]=TwoDimension::point(j,2*j+1); 		} 		polygon[0]=polygon[m]; 		LL s=0; 		REP_1(j,m) s+=TwoDimension::det(polygon[j-1],polygon[j]); 		if(s<0) reverse(polygon+0,polygon+m+1); 		REP_1(j,m){ 			if(polygon[j].x!=polygon[j-1].x){ 			//	verseg.push_back(TwoDimension::segment(polygon[j-1],polygon[j],i)); 			//} 			//else{ 				TwoDimension::segment s(polygon[j-1],polygon[j],i); 				E[totalE].s=s,E[totalE].x=s.s.x,E[totalE].y=1; 				++totalE; 				E[totalE].s=s,E[totalE].x=s.t.x,E[totalE].y=-1; 				++totalE; 			} 		} 	} 	sort(E,E+totalE); 	Treap::Clear(); 	totalrecord=0; 	for(int i=0;i<totalE;){ 		int j=i; 		while(j<totalE&&E[i].x==E[j].x){ 			if(E[j].y==1) Treap::root=Treap::Insert(Treap::root,E[j].s); 			else Treap::root=Treap::Delete(Treap::root,E[j].s); 			++j; 		} 		recordx[++totalrecord]=E[i].x; 		recordroot[totalrecord]=Treap::root; 		i=j; 		Treap::TLE(); //		if(totalrecord==4024){ //			printf("!!!\n"); //		} 	} 	 	int q; 	scanf("%d",&q); //	q=100000; 	while(q--){ 		int x,y; 		scanf("%d%d",&x,&y); //		x=rand(),y=rand(); 		int pos=lower_bound(recordx+1,recordx+totalrecord+1,x)-recordx-1; 		int ans=-1; 		 		if(ans==-1&&pos){ 			ans=Treap::Query(TwoDimension::point(x,y),recordroot[pos]); 		} 		if(ans==-1&&pos!=totalrecord&&recordx[pos+1]==x){ 			ans=Treap::Query(TwoDimension::point(x,y),recordroot[pos+1]); 		} 		printf("%d\n",ans); 		fflush(stdout); 	} //	printf("!!!\n"); //	scanf("%d",&q); 	return 0; }
#include <cassert> #include <cstdio> #include <cstdlib> #include <cstring> #include <algorithm>  using namespace std;  typedef long long ll; struct EQ { 	ll a, m; 	EQ() {} 	EQ(ll a_, ll m_) : a(a_), m(m_) {} }; struct VE { 	EQ v[5]; };  #define UPT(a, b, m) { \ 	(a) += (b); \ 	if ((a) >= (m)) (a) -= (m); \ }  inline ll Mul(ll a, ll b, ll m) { 	if (a < b) swap(a, b); 	ll res = 0; 	while (b) { 		if (b & 1) UPT(res, a, m); 		b >>= 1; 		UPT(a, a, m); 	} 	return res; }  inline ll Pow(ll a, ll b, ll m) { 	ll res = 1; 	while (b) { 		if (b & 1) res = Mul(res, a, m); 		b >>= 1; 		a = Mul(a, a, m); 	} 	return res; }  namespace fun { 	ll Gcd(ll a, ll b) { 		return (b ? Gcd(b, a % b) : a); 	}  	ll ExGcd(ll a, ll b, ll &x, ll &y) { 		if (!b) { 			x = 1, y = 0; 			return a; 		} 		else { 			ll g = ExGcd(b, a % b, x, y); 			ll t = x; 			x = y, y = t - (a / b) * x; 			return g; 		} 	}  	ll CalcInv(ll x, ll m) { 		ll p, q; 		x %= m; 		ExGcd(x, m, p, q); 		p = (p % m + m) % m; 		return p; 	}  	ll SolveVE(VE mat) { 		int n = 2; 		for (int i = 1; i < n; ++ i) { 			ll g = fun::Gcd(mat.v[i - 1].m, mat.v[i].m); 			ll t = mat.v[i].a - mat.v[i - 1].a; 			t = (t % mat.v[i].m + mat.v[i].m) % mat.v[i].m; 			ll x, y; 			fun::ExGcd(mat.v[i - 1].m / g, mat.v[i].m / g, x, y); 			x = (x % (mat.v[i].m / g) + (mat.v[i].m / g)) % (mat.v[i].m	/ g); 			x = Mul(x, t / g, mat.v[i].m / g); 			mat.v[i].m = mat.v[i].m / g * mat.v[i - 1].m; 			mat.v[i].a = mat.v[i - 1].a; 			UPT(mat.v[i].a, Mul(x, mat.v[i - 1].m, mat.v[i].m), mat.v[i].m); 		} 		return mat.v[n - 1].a; 	}  	ll SolveVEQ(VE mat, ll M) { 		static ll inv[5][5]; 		static bool calced = false; 		if (!calced) { 			calced = true; 			for (int i = 0; i < 5; ++ i) 				for (int j = 0; j < 5; ++ j) 					inv[i][j] = fun::CalcInv(mat.v[j].m, mat.v[i].m); 		} 		ll val[5]; 		for (int i = 0; i < 5; ++ i) val[i] = mat.v[i].a; 		for (int i = 0; i < 5; ++ i) 			for (int j = 0; j < i; ++ j) { 				ll tmp = (val[i] - val[j] + mat.v[i].m) % mat.v[i].m; 				val[i] = tmp * inv[i][j] % mat.v[i].m; 			} 		ll res = 0; 		for (int i = 4; i >= 0; -- i) { 			res = Mul(res, mat.v[i].m % M, M) + val[i]; 			res %= M; 		} 		return res; 	} }  namespace fft { 	const int kPrime[5] = {2095054849, 2099249153, 2113929217, 2114977793, 2130706433}; 	const int kRoot[5] = {11, 3, 5, 3, 3}; 	const int kMaxL = 1 << 16; 	ll w[5][kMaxL][2]; 	bool inited; 	ll a[kMaxL], b[kMaxL], c[kMaxL]; 	ll fft_a[kMaxL], fft_b[kMaxL], fft_c[kMaxL]; 	VE mat[kMaxL]; 	int T; 	ll MOD;  	void Init(int L) { 		if (inited) return; 		T = L; 		inited = true; 		for (int i = 0; i < 5; ++ i) { 			ll a = Pow(kRoot[i], (kPrime[i] - 1) / L, kPrime[i]); 			ll b = fun::CalcInv(a, kPrime[i]); 			w[i][0][0] = w[i][0][1] = 1; 			for (int j = 1; j < L; ++ j) { 				w[i][j][0] = w[i][j - 1][0] * a % kPrime[i]; 				w[i][j][1] = w[i][j - 1][1] * b % kPrime[i]; 			} 		} 	}  	void FFT(int pri, ll *des, ll *src, int len, int sgn) { 		if (len == 1) { 			des[0] = src[0]; 			return; 		} 		ll *rec[2]; 		for (int i = 0; i < 2; ++ i) { 			rec[i] = des + (len >> 1) * i; 			FFT(pri, rec[i], src + T / len * i, len >> 1, sgn); 		} 		for (int i = 0, j = 0; i < (len >> 1); ++ i, j += T / len) { 			ll a = rec[0][i] + w[pri][j][sgn] * rec[1][i] % kPrime[pri]; 			ll b = rec[0][i] - w[pri][j][sgn] * rec[1][i] % kPrime[pri]; 			if (a >= kPrime[pri]) a -= kPrime[pri]; 			if (b < 0) b += kPrime[pri]; 			des[i] = a; 			des[i + (len >> 1)] = b; 		} 	}  	void Run(ll *A, ll *B, ll *C, int L) { 		Init(L); 		for (int i = 0; i < 5; ++ i) { 			for (int j = 0; j < L; ++ j) a[j] = A[j] % kPrime[i]; 			for (int j = 0; j < L; ++ j) b[j] = B[j] % kPrime[i]; 			FFT(i, fft_a, a, L, 0); 			FFT(i, fft_b, b, L, 0); 			for (int j = 0; j < L; ++ j) fft_c[j] = fft_a[j] * fft_b[j] % kPrime[i]; 			FFT(i, c, fft_c, L, 1); 			ll e = fun::CalcInv(L, kPrime[i]); 			for (int j = 0; j < L; ++ j) mat[j].v[i] = EQ(c[j] * e % kPrime[i], kPrime[i]); 		} 		for (int i = 0; i < L; ++ i) C[i] = fun::SolveVEQ(mat[i], MOD); 	} }  namespace solve { 	const int kBufSize = 1 << 17; 	const int kMaxD = 20000; 	ll M, Q, P[kMaxD + 13], NN; 	int D; 	char N[kBufSize];  	void Split(ll M, ll &M1, ll &M2) { 		M1 = M; 		for ( ; ; ) { 			ll g = fun::Gcd(M1, Q - 1); 			if (g == 1) break; 			M1 /= g; 		} 		M2 = M / M1; 	}  	namespace solve1 { 		const int kMaxL = 1 << 16; 		ll p[kMaxL], q[kMaxL], a[kMaxL], y[kMaxL]; 		int L; 		ll fac_inv[kMaxD], fac[kMaxD];  		ll Run(ll M) { 			fft::MOD = M; 			L = 1; 			while (L < (D << 1)) L <<= 1; 			fac_inv[0] = fac[0] = 1; 			for (int i = 1; i < D; ++ i) { 				fac_inv[i] = Mul(fac_inv[i - 1], fun::CalcInv(i, M), M); 				fac[i] = Mul(fac[i - 1], i % M, M); 			}  			memset(p, 0, sizeof(ll) * L); 			memset(q, 0, sizeof(ll) * L); 			for (int i = 0; i < D; ++ i) p[i] = Mul(P[i] % M, fac_inv[i], M); 			for (int i = 0; i < D; ++ i) { 				q[i] = fac_inv[i]; 				if (i & 1) q[i] = M - q[i]; 			} 			fft::Run(p, q, a, L); 			for (int i = 0; i < D; ++ i) a[i] = Mul(a[i], fac[i], M);  			NN = 0; 			for (int i = 0, sz = strlen(N); i < sz; ++ i) { 				NN = Mul(NN, 10 % M, M); 				UPT(NN, (N[i] - '0') % M, M); 			}  			memset(p, 0, sizeof(ll) * L); 			memset(q, 0, sizeof(ll) * L); 			p[0] = 1, q[0] = fun::CalcInv(((1 - Q) % M + M) % M, M); 			for (int i = 1; i < D; ++ i) { 				p[i] = Mul(p[i - 1], ((NN - i + 1) % M + M) % M, M); 				p[i] = Mul(p[i], fun::CalcInv(i, M), M); 				q[i] = Mul(q[i - 1], Q % M, M); 				q[i] = Mul(q[i], q[0], M); 			} 			fft::Run(p, q, y, L);  			ll QN = 1; 			static ll powQ[10]; 			powQ[0] = 1; 			for (int i = 1; i < 10; ++ i) powQ[i] = Mul(powQ[i - 1], Q % M, M); 			for (int i = 0, sz = strlen(N); i < sz; ++ i) { 				ll tmp = QN; 				QN = Mul(QN, QN, M); 				QN = Mul(QN, QN, M); 				QN = Mul(QN, tmp, M); 				QN = Mul(QN, QN, M); 				QN = Mul(QN, powQ[N[i] - '0'], M); 			} 			ll res = 0; 			for (int i = 0; i < D; ++ i) { 				ll t = q[i]; 				t -= Mul(QN, y[i], M); 				if (t < 0) t += M; 				UPT(res, Mul(t, a[i], M), M); 			} 			return res; 		} 	}  	namespace solve2 { 		const int kMaxL = 1 << 16; 		ll DD; 		ll comb[kMaxD + 25]; 		ll T[kMaxD + 25]; 		int L; 		ll p[kMaxL], q[kMaxL], t[kMaxL]; 		ll fac[kMaxD + 25], fac_inv[kMaxD + 25];  		ll Run(ll M) { 			NN = 0; 			for (int i = 0, sz = strlen(N); i < sz; ++ i) { 				NN = Mul(NN, 10 % M, M); 				UPT(NN, (N[i] - '0') % M, M); 			} 			fft::inited = false; 			fft::MOD = M; 			int u = 0; 			ll cur = 1 % M; 			while (cur) { 				++ u; 				cur = Mul(cur, (Q - 1) % M, M); 			} 			comb[0] = 1; 			for (int i = 1; i <= D; ++ i) { 				comb[i] = Mul(comb[i - 1], ((D - i + 1) % M + M) % M, M); 				comb[i] = Mul(comb[i], fun::CalcInv(i, M), M); 			} 			if (!u) return 0LL; 			DD = D + u - 1; 			for (int i = D; i < DD; ++ i) { 				P[i] = 0; 				for (int j = 1; j <= D; ++ j) { 					ll tmp = Mul(comb[j], P[i - j] % M, M); 					if ((j - 1) & 1) tmp = M - tmp; 					UPT(P[i], tmp, M); 				} 			} 			ll powQ = 1 % M; 			for (int i = 0; i < DD; ++ i) { 				T[i] = Mul(P[i] % M, powQ, M); 				powQ = Mul(powQ, Q % M, M); 			}  			fac[0] = fac_inv[0] = 1 % M; 			for (int i = 1; i < DD; ++ i) { 				fac[i] = Mul(fac[i - 1], i % M, M); 				fac_inv[i] = Mul(fac_inv[i - 1], fun::CalcInv(i, M), M); 			} 			L = 1; 			while (L < (DD << 1)) L <<= 1; 			memset(p, 0, sizeof(ll) * L); 			memset(q, 0, sizeof(ll) * L); 			for (int i = 0; i < DD; ++ i) p[i] = Mul(T[i], fac_inv[i], M); 			for (int i = 0; i < DD; ++ i) { 				q[i] = fac_inv[i]; 				if (i & 1) q[i] = M - q[i]; 			} 			fft::Run(p, q, t, L); 			for (int i = 0; i < DD; ++ i) t[i] = Mul(t[i], fac[i], M); 			 			comb[0] = 1; 			for (int i = 1; i <= DD; ++ i) { 				comb[i] = Mul(comb[i - 1], ((NN - i + 1) % M + M) % M, M); 				comb[i] = Mul(comb[i], fun::CalcInv(i, M), M); 			} 			ll res = 0; 			for (int i = 0; i < DD; ++ i) 				UPT(res, Mul(t[i], comb[i + 1], M), M); 			return res; 		} 	}  	void Run() { 		scanf("%lld%lld%s%d", &M, &Q, N, &D); 		++ D; 		for (int i = 0; i < D; ++ i) scanf("%lld", &P[i]); 		if (Q == 0) { 			printf("%lld\n", P[0]); 			return; 		} 		ll M1, M2; 		Split(M, M1, M2); 		VE mat; 		mat.v[0] = EQ(solve1::Run(M1), M1); 		mat.v[1] = EQ(solve2::Run(M2), M2); 		ll ans = fun::SolveVE(mat) % M; 		printf("%lld\n", ans); 	} }  int main() { 	//freopen("t.in", "r", stdin); 	int T; 	for (scanf("%d", &T); T --; ) { 		fft::inited = false; 		solve::Run(); 	} 	return 0; }
#include <cstdio> #include <cstdlib> #include <algorithm> #include <iostream>  using namespace std;  #define MX 100005  struct Query { 	int type, x1, y1, x2, y2, id; 	void init() { 		scanf("%d%d%d%d", &x1, &y1, &x2, &y2); 	} }q[MX];  struct fenwick { 	int a[2*MX], n; 	inline void update(int x, int v) { 		for (; x <= n; x += x&(-x)) a[x] += v; 	} 	inline int sum(int x) { 		int rlt = 0; 		for (; x; x -= x&(-x)) rlt += a[x]; 		return rlt; 	} }s1, s2;  struct Line { 	int x, y1, y2, t, num; 	bool operator<(const Line &l) const{ 		if (l.x != x) return x < l.x; 		return t < l.t;	 	} }L[3*MX];  int rlt[MX], y[2*MX], yn, id[MX];  void calc(int st, int en) { 	if (st == en) return; 	int mid = (st + en) / 2, i, j, k, cnt, tot; 	 	cnt = tot = 0; 	for (i = st; i <= mid; i++) { 		if (q[i].type == 1) { 			L[cnt++] = (Line){q[i].x2, q[i].y1, q[i].y2, 2, i}, tot++;	 		} else if (q[i].type == 2) { 			L[cnt++] = (Line){q[i].x2, q[i].y1, q[i].y2, 3, i}, tot--;			 		} 	} 	for (i = mid + 1; i <= en; i++) { 		if (q[i].type == 3) { 			L[cnt++] = (Line){q[i].x1, q[i].y1, q[i].y2, 1, i}; 			rlt[i] += tot; 		} 	} 	sort(L, L + cnt); 	for (i = 0; i < cnt; i++) { 		if (L[i].t == 2) { 			s1.update(L[i].y1, -1); s2.update(L[i].y2, -1);	 		} else if (L[i].t == 3) { 			s1.update(L[i].y1, 1); s2.update(L[i].y2, 1); 		} else { 			rlt[L[i].num] += s1.sum(L[i].y2) - s2.sum(L[i].y1-1); 		} 	} 	for (i = 0; i < cnt; i++) { 		if (L[i].t == 2) s1.update(L[i].y1, 1), s2.update(L[i].y2, 1);	 		if (L[i].t == 3) s1.update(L[i].y1, -1), s2.update(L[i].y2, -1); 	}  //right 	cnt = tot = 0; 	for (i = st; i <= mid; i++) { 		if (q[i].type == 1) { 			L[cnt++] = (Line){-q[i].x1, q[i].y1, q[i].y2, 2, i};	 		} else if (q[i].type == 2) { 			L[cnt++] = (Line){-q[i].x1, q[i].y1, q[i].y2, 3, i};			 		} 	} 	for (i = mid + 1; i <= en; i++) { 		if (q[i].type == 3) { 			L[cnt++] = (Line){-q[i].x2, q[i].y1, q[i].y2, 1, i}; 		} 	} 	sort(L, L + cnt); 	for (i = 0; i < cnt; i++) { 		if (L[i].t == 2) { 			s1.update(L[i].y1, -1); s2.update(L[i].y2, -1);	 		} else if (L[i].t == 3) { 			s1.update(L[i].y1, 1); s2.update(L[i].y2, 1); 		} else { 			rlt[L[i].num] += s1.sum(L[i].y2) - s2.sum(L[i].y1-1); 		} 	} 	for (i = 0; i < cnt; i++) { 		if (L[i].t == 2) s1.update(L[i].y1, 1), s2.update(L[i].y2, 1);	 		if (L[i].t == 3) s1.update(L[i].y1, -1), s2.update(L[i].y2, -1); 	} //Top 	cnt = tot = 0; 	for (i = st; i <= mid; i++) { 		if (q[i].type == 1) { 			L[cnt++] = (Line){q[i].y2, q[i].x1, q[i].x2, 2, i};	 		} else if (q[i].type == 2) { 			L[cnt++] = (Line){q[i].y2, q[i].x1, q[i].x2, 3, i};			 		} 	} 	for (i = mid + 1; i <= en; i++) { 		if (q[i].type == 3) { 			L[cnt++] = (Line){q[i].y1, q[i].x1, q[i].x2, 1, i}; 		} 	} 	sort(L, L + cnt); 	for (i = 0; i < cnt; i++) { 		if (L[i].t == 2) tot--;	 		if (L[i].t == 3) tot++; 		if (L[i].t == 1) { 			rlt[L[i].num] += tot; 		} 	}  //Bottom 	cnt = tot = 0; 	for (i = st; i <= mid; i++) { 		if (q[i].type == 1) { 			L[cnt++] = (Line){-q[i].y1, q[i].x1, q[i].x2, 2, i};	 		} else if (q[i].type == 2) { 			L[cnt++] = (Line){-q[i].y1, q[i].x1, q[i].x2, 3, i};			 		} 	} 	for (i = mid + 1; i <= en; i++) { 		if (q[i].type == 3) 			L[cnt++] = (Line){-q[i].y2, q[i].x1, q[i].x2, 1, i}; 	} 	sort(L, L + cnt); 	for (i = 0; i < cnt; i++) { 		if (L[i].t == 2) tot--; 		if (L[i].t == 3) tot++; 		if (L[i].t == 1) rlt[L[i].num] += tot; 	}  	calc(st, mid); 	calc(mid + 1, en); }  main() { 	 //	freopen("in1.txt", "r", stdin); //	freopen("out.txt", "w", stdout);  	char str[10]; 	int i, j, k, cnt(0), yn(0), Q;  	scanf("%d", &Q); 	for (i = 0; i < Q; i++) { 		scanf("%s", str); 		if (str[0] == 'I') { 			q[i].type = 1; 			q[i].init(); y[yn++] = q[i].y1, y[yn++] = q[i].y2; 			id[cnt++] = i; 		} else if (str[0] == 'D') { 			q[i].type = 2; 			scanf("%d", &q[i].id); 			q[i].id = id[q[i].id - 1]; 			q[i].x1 = q[q[i].id].x1; 			q[i].y1 = q[q[i].id].y1; 			q[i].x2 = q[q[i].id].x2; 			q[i].y2 = q[q[i].id].y2; 		} else { 			q[i].type = 3; 			q[i].init(); y[yn++] = q[i].y1, y[yn++] = q[i].y2; 		} 	} 	sort(y, y + yn); 	yn = unique(y, y + yn) - y; 	s1.n = s2.n = yn;  	for (i = 0; i < Q; i++) { 		q[i].y1 = lower_bound(y, y + yn, q[i].y1) - y + 1; 		q[i].y2 = lower_bound(y, y + yn, q[i].y2) - y + 1; 	} 	 	calc(0, Q-1); 	for (i = 0; i < Q; i++) { 		if (q[i].type == 3) printf("%d\n", rlt[i]); 	} }
#include<stdio.h> #include<iostream> #include<string.h> #include<queue> #include<algorithm> #include<string> #include<map> #include<set> #include<fstream> #include<math.h> #include<iomanip> #include<time.h> #include<assert.h> #include<stack> using namespace std; #define ll long long #define ull unsigned long long #define db double #define inf 1000000007 #define mod 1000000007 #define pii pair<int,int> #define vi vector<int> #define VS vector<string> #define all(x) x.begin(),x.end() #define mp make_pair #define pb push_back #define x first #define y second #define N 1000005 #define pi 3.14159265358979323846 #define DBG(vari) cerr<<#vari<<"="<<(vari)<<endl; #define FOREACH(i,t) for(__typeof(t.begin()) i=t.begin();i!=t.end();i++)  char s[N]; int n,w[N],wa[N],wb[N],rank[N],lcp[N],sa[N],dp[N][20];ll f[N]; bool cmp(int *r,int i,int j,int h) { 	if(r[i]!=r[j])return 0; 	if(i+h>=n||j+h>=n)return 0; 	return (r[i]==r[j]&&r[i+h]==r[j+h]); } void build(char *s) { 	n=strlen(s);int i,j,m=128,p,k; 	int *x=wa,*y=wb; 	for(i=0;i<128;i++)w[i]=0; 	for(i=0;i<n;i++)w[x[i]=s[i]]++; 	for(i=1;i<128;i++)w[i]+=w[i-1]; 	for(i=n-1;i>=0;i--)sa[--w[s[i]]]=i; 	for(j=1;p!=n;j<<=1,m=p) 	{ 		for(i=n-j,p=0;i<n;i++)y[p++]=i; 		for(i=0;i<n;i++)if(sa[i]>=j)y[p++]=sa[i]-j; 		for(i=0;i<m;i++)w[i]=0; 		for(i=0;i<n;i++)w[x[i]]++; 		for(i=1;i<m;i++)w[i]+=w[i-1]; 		for(i=n-1;i>=0;i--)sa[--w[x[y[i]]]]=y[i]; 		swap(x,y); 		for(x[sa[0]]=0,i=1,p=1;i<n;i++) 		{ 			x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; 		} 	} 	for(i=0;i<n;i++)rank[sa[i]]=i; 	for(i=0,k=0;i<n;i++) 	{ 		if(rank[i]==0){k=0;lcp[0]=0;continue;} 		if(k)k--; 		j=sa[rank[i]-1]; 		while(i+k<n&&j+k<n&&s[i+k]==s[j+k])k++; 		lcp[rank[i]]=k; 	} 	for(i=0;i<n;i++)dp[i][0]=lcp[i]; 	for(i=1;i<20;i++) 	for(j=0;j+(1<<i)<=n;j++) 	dp[j][i]=min(dp[j][i-1],dp[j+(1<<i-1)][i-1]); } struct node { 	int l,r,v; }t[N*80]; int sz=0,root[N]; void up(int p){t[p].v=t[t[p].l].v+t[t[p].r].v;} int insert(int q,int l,int r,int x) { 	if(l==r){sz++;t[sz].v=1;return sz;} 	int m=(l+r)>>1,p=++sz; 	if(x<=m) 	{ 		t[p].l=insert(t[q].l,l,m,x);t[p].r=t[q].r; 	} 	else  	{ 		t[p].r=insert(t[q].r,m+1,r,x);t[p].l=t[q].l; 	} 	up(p); 	return p; } int build(int l,int r) { 	++sz;t[sz].v=0; 	if(l==r){return sz;} 	int m=(l+r)>>1,p=sz; 	t[p].l=build(l,m); 	t[p].r=build(m+1,r); 	return p; } int query(int p,int q,int l,int r,int x,int y) { 	if(l>=x&&r<=y){return t[q].v-t[p].v;} 	int m=(l+r)>>1,ans=0; 	if(x<=m)ans=query(t[p].l,t[q].l,l,m,x,y); 	if(y>m)ans+=query(t[p].r,t[q].r,m+1,r,x,y); 	return ans; } void solve() { 	int i,j; 	for(i=0;i<n;i++) 	{ 		if(i==0)f[i]=n-sa[i]; 		else f[i]=f[i-1]+n-sa[i]-lcp[i]; 	} 	sz=0; 	root[0]=build(0,n-1); 	for(i=0;i<n;i++) 	{ 		int x=sa[i]; 		//if(x<0||x>=n){DBG(i)DBG(x)break;} 		root[i+1]=insert(root[i],0,n-1,x); 	} } int fun(int l,int r) { 	int h=r-l+1,i=0; 	while(1<<i<=h)i++; 	i--; 	return min(dp[l][i],dp[r-(1<<i)+1][i]); } void cal(ll k1,ll k2) { 	int i,j,m; 	i=lower_bound(f,f+n,k1)-f; 	int l=i,r=k1-(i?f[i-1]:0)+lcp[i];//DBG(r)DBG(i) 	int L=l+1,R=n-1; 	while(L<=R) 	{ 		m=(L+R)>>1; 		if(fun(i+1,m)>=r)L=m+1; 		else R=m-1; 	} 	R=L-1,L=i; 	int l1=0,r1=n-1; 	while(l1<=r1) 	{ 		m=(l1+r1)>>1; 		int cnt=query(root[L],root[R+1],0,n-1,0,m); 		if(cnt>=k2)r1=m-1; 		else l1=m+1; 	} 	l=r1+1;r=l+r-1; 	printf("%d %d\n",l+1,r+1); } void cal1(int l,int r) { 	int i=rank[l],j;ll k1,k2; 	int l1=0,r1=i,m,len=r-l+1; 	while(l1<=r1) 	{ 		m=(l1+r1)>>1; 		if(fun(m,i)>=r-l+1)r1=m-1; 		else l1=m+1; 	} 	j=r1; 	k1=(j?f[j-1]:0)+len-lcp[j]; 	int l2=i+1,r2=n-1; 	while(l2<=r2) 	{ 		m=(l2+r2)>>1; 		if(fun(i+1,m)>=r-l+1)l2=m+1; 		else r2=m-1; 	} 	int L=j,R=l2-1; 	//cerr<<L<<" "<<R<<"\n"; 	k2=query(root[L],root[R+1],0,n-1,0,l); 	cout<<k1<<" "<<k2<<"\n"; } int main() { 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout);     int T,i,j,ca=0,m,k; 	while(~scanf("%s%d",s,&m)) 	{ 		build(s);solve(); 		while(m--) 		{ 			char t[10];int l,r;ll k1,k2; 			scanf("%s",t); 			if(t[0]=='S')cin>>k1>>k2,cal(k1,k2); 			else scanf("%d%d",&l,&r),l--,r--,cal1(l,r); 		} 	}     return 0; }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 100050 #define INF 0x3f7f7f7f int fi[N],c[N*2][3],fa[N],rf[N],sg[N],wei[N],li[N],wz[N]; int h[N],val[N],nd[N],cl[N],ss=1,n,m,st,Cnt; bool vis[N],_vis[N]; struct Node  {  	int lma,rma,sma,sum,lmi,rmi,smi;bool fz;  	void Rev() {swap(lma,rma);swap(lmi,rmi);return;}  	void Get(int x)  	 {lma=rma=sma=sum=lmi=rmi=smi=x;return;}  	void Put()  	 {cout <<lma<<' '<<rma<<' '<<sma<<' '<<lmi<<' '<<rmi<<' '<<smi<<' '<<sum<<endl;}  } a[N*4],b[N*4],Emp; Node operator+ (const Node &x,const Node &y)  {  	static Node z;  	z.lma=max(x.lma,y.lma+x.sum);  	z.rma=max(y.rma,x.rma+y.sum);  	z.sma=max(x.rma+y.lma,max(x.sma,y.sma));  	z.sum=x.sum+y.sum;  	z.lmi=min(x.lmi,y.lmi+x.sum);  	z.rmi=min(y.rmi,x.rmi+y.sum);  	z.smi=min(x.rmi+y.lmi,min(x.smi,y.smi));  	return z;  } inline int Read()  {  	int x=0;char y;bool z=false;  	do y=getchar(),z|=y=='-'; while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return z?-x:x;  } inline void Line(int z,int y,int x)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;c[ss][2]=z;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;c[ss][2]=z;  	return;  } bool _DFS(int x,int y)  {  	vis[x]=true;li[y]=x;  	for (int i=fi[x];i;i=c[i][1])  	 if (vis[c[i][0]]&&c[i][0]!=li[y-1])  	  {  	  	 int k=true;  	  	 while (li[k]!=c[i][0]) k++;Cnt=y-k+1;  	  	 for (int j=k;j<=y;j++) swap(li[j],li[j-k+1]);  	  	 return true;  	  } else  	 if (!vis[c[i][0]]&&_DFS(c[i][0],y+1)) return true;  	return false;  } void DFS(int x,int y)  {  	wei[x]=true;h[x]=h[fa[x]]+1;cl[x]=y;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&!vis[c[i][0]])  	   fa[c[i][0]]=x,DFS(c[i][0],y),  	   wei[x]+=wei[c[i][0]],val[c[i][0]]=c[i][2];  	return;  } void DSF(int x,int y)  {  	int k=false;rf[x]=y;nd[sg[x]=++st]=x;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&!vis[c[i][0]]&&wei[c[i][0]]>wei[k])  	   k=c[i][0];  	if (k) DSF(k,y);  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&!vis[c[i][0]]&&c[i][0]!=k)  	   DSF(c[i][0],c[i][0]);  	return;  } void Set_up(Node* a,int x,int y,int z,bool flag)  {  	int mid = x + y >> true, j = z << true;  	if (x==y)  	 {a[z].Get(flag?val[li[x]]:val[nd[x]]);return;}  	Set_up(a,x,mid,j,flag);Set_up(a,mid+1,y,j+1,flag);  	a[z]=a[j]+a[j+1];  	return;  } void Pretreat()  {  	Emp.lma=Emp.rma=Emp.sma=-INF;  	Emp.lmi=Emp.rmi=Emp.smi=INF;  	_DFS(1,1);memset(vis,false,sizeof vis);  	for (int i=1;i<=Cnt;i++) vis[li[i]]=true,wz[li[i]]=i;  	for (int i=1;i<Cnt;i++)  	 for (int j=fi[li[i]];j;j=c[j][1])  	  if (c[j][0]==li[i+1]) val[li[i]]=c[j][2];  	for (int j=fi[li[Cnt]];j;j=c[j][1])  	 if (c[j][0]==li[1]) val[li[Cnt]]=c[j][2];  	for (int i=1;i<=Cnt;i++)  	  DFS(li[i],i),DSF(li[i],li[i]);  	Set_up(a,1,n,1,false);Set_up(b,1,Cnt,1,true);  	return;  } void fzj(Node* a,int z,bool flag)  {  	if (!a[z].fz) return;  	a[z].fz=false;a[z].sum=-a[z].sum;  	a[z].lmi=-a[z].lmi;a[z].lma=-a[z].lma;  	a[z].rmi=-a[z].rmi;a[z].rma=-a[z].rma;  	a[z].smi=-a[z].smi;a[z].sma=-a[z].sma;  	swap(a[z].lmi,a[z].lma);  	swap(a[z].rmi,a[z].rma);  	swap(a[z].smi,a[z].sma);  	if (flag)  	 for (int i=0;i<2;i++) a[z*2+i].fz=!a[z*2+i].fz;  	return;  } void Modify(Node* a,int x,int y,int z,int o,int p)  {  	int mid = x + y >> true, j = z << true;fzj(a,z,x!=y);  	if (x==o&&y==p) {a[z].fz=!a[z].fz;fzj(a,z,x!=y);return;}  	if (p<=mid) Modify(a,x,mid,j,o,p),fzj(a,j+1,mid+1!=y); else  	 if (o>mid) Modify(a,mid+1,y,j+1,o,p),fzj(a,j,x!=mid); else  	   Modify(a,x,mid,j,o,mid),Modify(a,mid+1,y,j+1,mid+1,p);  	a[z]=a[j]+a[j+1];  	return;  } Node Query(Node* a,int x,int y,int z,int o,int p)  {  	int mid = x + y >> true, j = z << true;fzj(a,z,x!=y);  	if (x==o&&y==p) return a[z];  	if (p<=mid) return Query(a,x,mid,j,o,p); else  	 if (o>mid) return Query(a,mid+1,y,j+1,o,p); else  	   return Query(a,x,mid,j,o,mid)+  	   Query(a,mid+1,y,j+1,mid+1,p);  } void __Modify(int x,int y)  {  	while (rf[x]!=rf[y])  	 {  	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);  	 	Modify(a,1,n,1,sg[rf[x]],sg[x]);  	 	x=fa[rf[x]];  	 }  	if (h[x]>h[y]) swap(x,y);  	if (x!=y) Modify(a,1,n,1,sg[x]+1,sg[y]);  	return;  } void ___Modify(int x,int y)  {  	if (x>y) swap(x,y);  	if (y-x<=Cnt/2) Modify(b,1,Cnt,1,x,y-1); else  	 {  	 	if (x-1) Modify(b,1,Cnt,1,1,x-1);  	 	Modify(b,1,Cnt,1,y,Cnt);  	 }  	return;  } void _Modify(int x,int y)  {  	if (cl[x]==cl[y]) __Modify(x,y); else  	  __Modify(x,li[cl[x]]),__Modify(y,li[cl[y]]),  	  ___Modify(cl[x],cl[y]);  	return;  } Node __Query(int x,int y)  {  	static Node k,l;k=Emp,l=Emp;bool flag=false;  	while (rf[x]!=rf[y])  	 {  	 	if (h[rf[x]]<h[rf[y]])  	 	  swap(x,y),swap(k,l),flag^=true;  	 	k=Query(a,1,n,1,sg[rf[x]],sg[x])+k;  	 	x=fa[rf[x]];  	 }  	if (h[x]>h[y]) swap(x,y),swap(k,l),flag^=true;  	if (x!=y) l=Query(a,1,n,1,sg[x]+1,sg[y])+l;  	if (flag) swap(k,l);  	return k.Rev(),k+l;  } Node ___Query(int x,int y)  {  	bool flag=x>y;static Node k;  	if (flag) swap(x,y);  	if (y-x<=Cnt/2) k=Query(b,1,Cnt,1,x,y-1); else  	 {  	 	k=Query(b,1,Cnt,1,y,Cnt);  	 	if (x-1) k=k+Query(b,1,Cnt,1,1,x-1);  	 	flag ^= true;  	 }  	if (flag) k.Rev();  	return k;  } int _Query(int x,int y)  {  	if (x==y) return false;  	if (cl[x]==cl[y]) return __Query(x,y).sma;  	Node k=__Query(x,li[cl[x]]),l=__Query(li[cl[y]],y);  	return (k+___Query(cl[x],cl[y])+l).sma;  } int main()  {  	//freopen("input.txt","r",stdin);  	n=Read();  	for (int i=1;i<=n;i++) Line(Read(),Read(),Read());  	Pretreat();m=Read();     while (m--)      {      	static char ch[20];scanf("%s",ch+1);      	if (ch[1]=='f') _Modify(Read(),Read()); else      	  printf("%d\n",max(_Query(Read(),Read()),0));      }     return 0;  } 
#include <cstdio> #include <algorithm> #define Sub(x, col) ((x<<1)|col) #define stype(x) (x->f->son[1]==x) #define isroot(x) ((!x->f)||(x->f->son[0]!=x&&x->f->son[1]!=x)) #define NE(x, y) ++ne, e[ne]=y, h[ne]=s[x], s[x]=ne using namespace std;  const int N = 100005; namespace LCT { 	struct node{ 		node *f, *son[2]; 		int tadd, val; 		node () {val = 1;} 		inline void SA(int x) { 			tadd += x, val += x; 		} 		inline void D() { 			if (tadd) { 				if (son[0]) son[0]->SA(tadd); 				if (son[1]) son[1]->SA(tadd); 				tadd = 0; 			} 		} 	} pool[N*2], *l[N*2]; 	inline void rot(node *x) { 		node *fa = x->f; int st = stype(x); 		x->f=fa->f; if (!isroot(fa)) fa->f->son[stype(fa)]=x; 		fa->son[st]=x->son[!st]; if (x->son[!st]) x->son[!st]->f=fa; 		x->son[!st]=fa, fa->f=x; 	} 	inline node *Dpath(node *x) { 		int ln = 0; 		for (; !isroot(x); x=x->f) l[++ln] = x; 		for (x->D(); ln; --ln) l[ln]->D(); 		return x; 	} 	void splay(node *x, node *y = 0) { 		if (!y) y = Dpath(x)->f; else Dpath(x); 		while (x->f!=y) { 			if (x->f->f!=y) rot(stype(x->f)==stype(x)?x->f:x); 			rot(x); 		} 	} 	void access(node *x) { 		splay(x); x->son[1]=0; 		while (x->f) { 			splay(x->f), x->f->son[1]=x; 			x = x->f; 		} 	} 	inline node *succ(node *x) { 		splay(x); x=x->son[1]; 		for (x->D(); x->son[0]; x=x->son[0], x->D()); 		return x; 	} 	inline int Q(node *x) { 		access(x); splay(x); 		for (x->D(); x->son[0]; x=x->son[0], x->D()); 		x = succ(x); 		splay(x); 		return x->val; 	} 	inline int Q(int x) { 		return Q(pool + x); 	} 	inline void cut(node *x) { 		access(x); splay(x); 		x->son[0]->SA(-x->val); 		x->son[0]->f = 0, x->son[0] = 0; 	} 	inline void cut(int x) { 		cut(pool+x); 	} 	inline void link(node *x, node *y) { 		splay(x); x->f = y; 		access(y); splay(y); y->SA(x->val); 	} 	inline void link(int x, int y) { 		link(pool+x, pool+y); 	} } inline void R(int &x) { 	char ch = getchar(); x = 0; 	for (; ch<'0'; ch = getchar()); 	for (; ch>='0'; ch = getchar()) x = x*10+ch-'0'; } int n, m, ne = 0, s[N], e[N*2], h[N*2], col[N], fa[N]; void dfs(int x, int f) { 	fa[x] = f; 	for (int w=s[x]; w; w=h[w]) if (e[w]!=f) 		dfs(e[w], x); } int main() { 	int x, y, t; 	R(n); 	for (int i=1; i<n; ++i) { 		R(x); R(y); 		NE(x, y); NE(y, x); 	} 	dfs(1, 0); 	for (int i=1; i<=n; ++i) 		LCT::link(Sub(i, 0), Sub(fa[i], 0)); 	R(m); 	for (int i=1; i<=m; ++i) { 		R(t); R(x); 		if (t == 1) { 			LCT::cut(Sub(x, col[x])); 			col[x] ^= 1; 			LCT::link(Sub(x, col[x]), Sub(fa[x], col[x])); 		} else 			printf("%d\n", LCT::Q(Sub(x, col[x]))); 	} 	return 0; }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 100050 #define M 35000050 #define ll long long int sn[M][2],c[N*2][2],fi[N],fa[N],wei[N],rf[N],sg[N],nd[N]; int h[N],rt[N],Now,_Now,n,m,st,ss=1;ll ans,ad[M][2],Cnt[M]; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Line(int x,int y)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } void DFS(int x)  {  	wei[x]=true;h[x]=h[fa[x]]+1;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x])  	   fa[c[i][0]]=x,DFS(c[i][0]),wei[x]+=wei[c[i][0]];  	return;  } void DSF(int x,int y)  {  	int k=false;rf[x]=y;nd[sg[x]=++st]=x;  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&wei[c[i][0]]>wei[k]) k=c[i][0];  	if (k) DSF(k,y);  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=fa[x]&&c[i][0]!=k) DSF(c[i][0],c[i][0]);  	return;  } int Modify(int x,int y,int z,int o,int p,int u,int r)  {  	int mid = x + y >> true, j = ++st;  	sn[j][0]=sn[z][0];sn[j][1]=sn[z][1];  	ad[j][0]=ad[z][0];ad[j][1]=ad[z][1];Cnt[j]=Cnt[z];  	if (x==o&&y==p) {ad[j][0]+=u;ad[j][1]+=r;return j;}  	Cnt[j] += u*(p-o+1LL)+1LL*(p-o)*(p-o+1)/2*r;  	if (p<=mid) sn[j][0]=Modify(x,mid,sn[z][0],o,p,u,r); else  	 if (o>mid) sn[j][1]=Modify(mid+1,y,sn[z][1],o,p,u,r); else  	   sn[j][0]=Modify(x,mid,sn[z][0],o,mid,u,r),  	   sn[j][1]=Modify(mid+1,y,sn[z][1],mid+1,p,u+(mid+1-o)*r,r);  	return j;  } ll Query(int x,int y,int z,int o,int p)  {  	int mid = x + y >> true;ll _Cnt;  	_Cnt = (p-o+1LL)*ad[z][0] + (o+p-2LL*x)*(p-o+1)/2*ad[z][1];  	if (x==o&&y==p) return _Cnt+Cnt[z];  	if (o<=mid) _Cnt += Query(x,mid,sn[z][0],o,min(mid,p));  	if (p>mid) _Cnt += Query(mid+1,y,sn[z][1],max(o,mid+1),p);  	return _Cnt;  } void _Query(int x,int y)  {  	x = (x+ans)%n+1;y = (y+ans)%n+1;  	ans = false;  	while (rf[x]!=rf[y])  	 {  	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);  	 	ans += Query(1,n,_Now,sg[rf[x]],sg[x]);  	 	x = fa[rf[x]];  	 }  	if (h[x]>h[y]) swap(x,y);  	ans += Query(1,n,_Now,sg[x],sg[y]);  	printf("%lld\n",ans);  	return;  } int LCA(int x,int y)  {  	while (rf[x]!=rf[y])  	 {  	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);  	 	x=fa[rf[x]];  	 }  	return h[x]<h[y]?x:y;  } void Up(int x,int y,int z,int o)  {  	while (rf[x]!=rf[y])  	 {  	 	int k=(-h[rf[x]]+h[x])*o+z;  	 	_Now=Modify(1,n,_Now,sg[rf[x]],sg[x],k,-o);  	 	z=k+o;x=fa[rf[x]];  	 }  	int k=(h[x]-h[y])*o+z;  	_Now=Modify(1,n,_Now,sg[y],sg[x],k,-o);  	return;  } void _Modify(int x,int y,int z,int o)  {  	Now++;int k = LCA(x,y);  	Up(y,k,z+(h[x]+h[y]-2LL*h[k])*o,-o);  	Up(x,k,z,o);  	_Now=Modify(1,n,_Now,sg[k],sg[k],-z-1LL*o*(h[x]-h[k]),0);  	rt[Now]=_Now;  	return;  } int main()  {  	n=Read();m=Read();  	for (int i=1;i<n;i++) Line(Read(),Read());  	DFS(1);DSF(1,1);st=false;     while (m--)      {      	char ch[20];scanf("%s",ch+1);      	if (ch[1]=='l')      	  _Now=rt[(Read()+ans)%(Now+1)]; else      	if (ch[1]=='q') _Query(Read(),Read()); else      	 {      	 	int k=Read(),l=Read(),q=Read(),w=Read();      	 	k=(k+ans)%n+1;l=(l+ans)%n+1;      	 	_Modify(k,l,q,w);      	 }      }     return 0;  }
/* jai shree ram _/\_ A hacker from NITP */  #include<bits/stdc++.h> using namespace std;  #define mod 1000000007 typedef set<string> ss; typedef vector<int> vs; typedef map<int,char> msi; typedef pair<int,int> pa; typedef long long int ll;  ll bit[100004]; ll query(ll idx) { 	ll ret=0; 	while(idx>0) 	{ 		ret+=bit[idx]; 		idx-=(idx & -idx); 	} 	return ret; }  void update(ll idx) { 	while(idx<=100000) 	{ 		bit[idx]++; 		idx+=(idx & -idx); 	} }  ll n,i,a[100004],b,ans,k; map<ll,ll> m; int main() { 	//freopen("i.in", "r", stdin);   	//freopen("o.out", "w", stdout);   	cin>>n;   	for(i=0;i<n;i++)   	{   		cin>>a[i];   		m[a[i]]=i+1;   	}   	memset(bit,0,sizeof(bit));   	ans=0;   	for(i=0;i<n;i++)   	{   		cin>>b;   		k=m[b];   		ans+=k-1-query(k);   		update(k);   	}   	   	cout<<ans<<"\n"; 	return 0; } 
/*  * Problem:     REACHRIG- Reaching The Rig  (Level-4)  * Author:      Krishna Kumar Tiwari  * Timing:      0.01 out of 2.00   */ #include<stdio.h> #include<stdlib.h> #include<math.h> #define MAX 10000 #define MAX_INT 100000000 using namespace std;     double dist(double x1,double y1,double x2,double y2){       double distance,dx,dy;     dx=(x1-x2);     dy=(y1-y2);     distance=sqrt(dx*dx + dy*dy);       return distance;   }     int main(){     int cases;     double rigx[MAX],rigy[MAX],reqf[MAX];     int black[MAX],white[MAX];       scanf("%d",&cases);     while(cases--){         int np,nr,rign=0,dest,flag=0;         double ship,temp,summen;         int recent,brig=0,wrig=0;         double x,y;         scanf("%lf",&ship);         np=0;         scanf("%lf",&temp);         summen=0;         while(temp!=-1){             summen+=temp;             np++;             scanf("%lf",&temp);         }           scanf("%lf%lf",&x,&y);         while(x!=0 || y!=0){             rigx[rign]=x;             rigy[rign]=y;             //initialising the reqf array             reqf[rign]=MAX_INT;               rign++;             scanf("%lf %lf",&x,&y);           }         ship=ship-summen;         if(ship< 0){             printf("-1\n");             continue;         }         // destination rig , whiterig = uncovered rig , blackrig=covered rig         //reqf=required food ,np number of persons,rign=rig number dest destination rig         //recently added rig         nr=rign;           dest=rign-1;         black[0]=dest;         brig=1;         wrig=rign-1;         for(int i=0;i<wrig;i++){             white[i]=1;         }         white[dest]=0;             reqf[dest]=0;         recent=dest;         int flag0=0;         while(recent!=0){                    int count=0,select=-1;                  double d1,temp,temp2,min=0;                    while(count < nr){                      if(white[count]!=1){                          // for those in the white which are already selected                        // printf("black %d\n",count);                          count++;                          continue;                      }                          d1=dist(rigx[recent],rigy[recent],rigx[count],rigy[count]);                      //printf("distnace %d-- %d--> %lf\n",recent,count,d1);                      temp=(ship -(((double)np+1)*d1));                      //printf("temp ship %lf\n",temp);                        if(temp < 0 ){                            //for those which are unreachable to the recent rig                          //printf("unreachable %d -->%d\n",recent,count);                          count++;                          continue;                      }                      temp=ship -(double)(np+1)*d1;                      if((temp)>=reqf[recent]){                          //for those who can reach in single trip                          //printf("reachable signle trup %d -->%d\n",recent,count);                          temp2=reqf[recent]+np*d1;                          //printf("prev reqf[%d]=%lf temp2 =%lf\n\n",count,reqf[count],temp2);                          if(reqf[count]>temp2){                              //updating the min food required                              reqf[count]=temp2;                             // printf("reqf[%d] =%lf\n",count,reqf[count]);                          }                                count++;                          continue;                      }                        temp2=ship-(2*(double)np+1)*d1;                      if(temp2 <0){                          count++;                          continue;                      }                      if(temp2>0){                            double m;                          double h,tt;                          h=(reqf[recent]-temp)/temp2;                          m=(double)ceil(h);                          //printf("\nm =%lf m=%lf\t",h,m);                          h=(double)np* m*2*d1 +(double)np*d1 + reqf[recent];                          //tt=m*(ship-((double)np*2+1)*d1);                          //h=m*((double)(4*np+1)*d1-ship)+reqf[recent];                          //printf("h=%lf\n\n",h);                            if(reqf[count]>h){                              reqf[count]=h;                          }                          //printf("reachable in multiple trips %d--- %d\n",recent,count);                          //printf("reqf[count]=%lf\n",reqf[count]);                      }                      count++;                  }                    min=MAX_INT;                  for(int i=0;i<nr;i++){                      if(white[i]==1){                          if(min > reqf[i]){                              min=reqf[i];                              select=i;                          }                      }                  }                    if(select==-1){                      printf("-1\n");                      flag=1;                      break;                    }                  else{                      white[select]=0;                    }                  recent=select;                  //printf("select %d\n",select);               }         if(flag!=1){             printf("%d\n",(int)ceil(reqf[0]));               }         }     return 0; }    
/**  * cf. circulant matrix (http://en.wikipedia.org/wiki/Circulant_matrix)  */  #include <cstdio> #include <cctype> #include <cstring> #include <cmath> #include <iostream> #include <algorithm> #include <complex> #include <vector> using namespace std;  #define MAX 1<<20 #define PRIME1 134348801 #define ROOT1  3 #define PRIME2 537133057 #define ROOT2  5  typedef long long ll; typedef complex<long double> cdouble;  const long double eps = 1e-8;  #define gc getchar_unlocked inline void readint(int &x) {     int c = gc(), neg = 0;     while (!isdigit(c) && c != '-') c = gc();     if (c == '-') neg = 1, c = gc();     for (x = 0; isdigit(c); c = gc())         x = (x << 1) + (x << 3) + c - '0';     if (neg) x = -x; }  ll powmod(ll a, ll e, ll n) {     ll ret = 1;     while (e > 0) {         if (e & 1)             ret = (ret * a) % n;         a = (a * a) % n;         e >>= 1;     }     return ret; }  ll invmod(ll a, ll p) {     return powmod(a, p-2, p); }  ll cra(pair<ll, ll> *a, int n) {     ll m = 1, sum = 0;     for (int i = 0; i < n; i++)         m *= a[i].second;     for (int i = 0; i < n; i++) {         ll tmp = m / a[i].second;         ll aux = (tmp * invmod(tmp, a[i].second)) % m;         sum = (sum + a[i].first * aux) % m;     }     return sum; }  int isp[MAX]; int lsp[MAX], np;  void sieve(int n) {     memset(isp, 0, sizeof(isp));     for (int i = 3; i < n; i += 2)         isp[i] = 1;     for (ll i = 3; i < n; i += 2) if (isp[i])         for (ll j = i * i; j < n; j += i)             isp[j] = 0;     np = 0;     lsp[np++] = 2;     for (int i = 3; i < n; i += 2)         if (isp[i])             lsp[np++] = i; }  int isprime(int p) {     if (p < MAX)         return isp[p];     for (int i = 0; lsp[i] * lsp[i] <= p; i++)         if (p % lsp[i] == 0)             return 0;     return 1; }  int prim_root(int p) {     if (p == 2)         return 1;     vector<int> f;     for (int i = 0, m = p-1; i < np && m > 1; i++) {         if (m % lsp[i] == 0) {             f.push_back(lsp[i]);             while (m % lsp[i] == 0)                 m /= lsp[i];         }     }     for (int i = 0; i < np; i++) {         int a = lsp[i], flag = 1;         for (int j = 0; flag && j < f.size(); j++)             if (powmod(a, (p-1)/f[j], p) == 1)                 flag = 0;         if (flag)             return a;     }     return 0; }  ll _tmp[MAX]; void ntt_radix2(ll *in, int n, bool inv, ll root, ll p) {     if (n == 1) return;      ll h = n >> 1;     for (int i = 0, j = 0; i < n; i += 2, j++) {         in[j] = in[i];         _tmp[h+j] = in[i+1];     }     for (int i = h; i < n; i++)         in[i] = _tmp[i];      ll *even = in, *odd = in+h;     ntt_radix2(even, h, inv, root, p);     ntt_radix2(odd, h, inv, root, p);      ll a = inv ? powmod(root, p-2, p) : root;     ll w = powmod(a, (p-1)/n, p), w_i = 1;     for (int i = 0; i < h; i++) {         ll conv = (w_i * odd[i]) % p;         odd[i] = (even[i] - conv) % p;         if (odd[i] < 0) odd[i] += p;         even[i] = (even[i] + conv) % p;         w_i = (w_i * w) % p;     } }  void ntt(ll *in, int n, bool inv, ll root, ll p) {     ntt_radix2(in, n, inv, root, p);     if (inv) {         ll inv_n = powmod(n, p-2, p);         for (int i = 0; i < n; i++)             in[i] = (inv_n * in[i]) % p;     } }  ll _c[MAX], _d[MAX]; void convolve(ll *a, ll *b, int n, ll p) {     ll prime1 = PRIME1, root1 = ROOT1;     ll prime2 = PRIME2, root2 = ROOT2;      // ll prime1 = 767164417, root1 = 132088491;     // ll prime2 = 1031667713, root2 = 3198193;      for (int i = 0; i < n; i++) {         _c[i] = a[i];         _d[i] = b[i];     }      ntt(a, n, 0, root1, prime1);     ntt(b, n, 0, root1, prime1);     ntt(_c, n, 0, root2, prime2);     ntt(_d, n, 0, root2, prime2);      for (int i = 0; i < n; i++) {         a[i] = (a[i] * b[i]) % prime1;         _c[i] = (_c[i] * _d[i]) % prime2;     }      ntt(a, n, 1, root1, prime1);     ntt(_c, n, 1, root2, prime2);      // chinese remainder algorithm     ll inv_prime1 = powmod(prime1, prime2-2, prime2);     for (int i = 0; i < n; i++) {         ll aux = ((_c[i] - a[i]) * inv_prime1) % prime2;         if (aux < 0) aux += prime2;         a[i] = (a[i] + aux * prime1) % p;     } }  ll _a[MAX], _b[MAX]; void ntt_bluestein(ll *in, int n, ll w_h, ll w, ll p) {     int m = 1;     while (m < (n<<1))         m <<= 1;      memset(_a, 0, sizeof(_a));     memset(_b, 0, sizeof(_b));      ll inv_w_h = powmod(w_h, p-2, p);     for (int i = 0; i < n; i++) {         _a[i] = (in[i] * powmod(w_h, i*i, p)) % p;         _b[i] = powmod(inv_w_h, i*i, p);         if (i) _b[m-i] = _b[i];     }      convolve(_a, _b, m, p);      for (int i = 0; i < n; i++)         in[i] = (powmod(w_h, i*i, p) * _a[i]) % p; }  int solve(ll *in, int n) {     int n2 = 2 * n;      ll p = 1000000 / n2 * n2 + 1;     while (!isprime(p))         p += n2;     // p = 2200153; // XXX      ll g = prim_root(p);     ll w_h = powmod(g, (p-1)/n2, p);     // w_h = 93; // XXX     ll w = (w_h * w_h) % p;      for (int i = 0; i < n; i++) {         in[i] %= p;         if (in[i] < 0)             in[i] += p;     }      ntt_bluestein(in, n, w_h, w, p);      for (int i = 0; i < n; i++)         if (in[i] == 0)             return 1;     return 0; }  inline bool isZero(double a) {     return a + eps > 0.0 && eps > a ? 1 : 0; }  inline bool isZero(const cdouble &a) {     return isZero(a.real()) && isZero(a.imag()); }  cdouble operator*(int a, const cdouble &b) {     return cdouble(a * b.real(), a * b.imag()); }  int n, a[MAX]; ll in[MAX];  int main() {     sieve(MAX);      int T;     readint(T);     while (T--) {         readint(n);         for (int i = 0; i < n; i++) {             readint(a[i]);             in[i] = a[i];         }          if (solve(in, n))             puts("YES");         else             puts("NO");          /*         {             int ans = 0;             puts("");             int lim = n;//(n >> 1) + 1;             cdouble base = exp(cdouble(0, -2 * M_PI / n)), wj = 1;             for (int j = 0; j < lim; j++, wj *= base) {                 cdouble wjk = 1, sum = 0;                 for (int k = 0; k < n; k++) {                     sum += a[k] * wjk;                     wjk *= wj;                 }                 cout << sum << endl;                 if (isZero(sum)) {                     ans = 1;                     break;                 }             }             puts("");         }         puts(ans ? "YES" : "NO");         */     } } 
#include <cstdio> #include <cstring> #include <algorithm> #include <iostream> #include <string> #include <map> #include <vector> #include <stack>   using namespace std;   template <typename T> T sqr(T x) { return x * x; } template <typename T> T abs(T x) { return x < 0? -x : x; }   const int MAXN = 10007; const int MAXK = 80;   #define A first #define S second   #define left dsalkhfas #define right sdjkfhkas   typedef map < int, stack <int> > mmap;   int ans[MAXN]; mmap M; int n, m, k; int L, H, N; int left, right;   vector < pair <int, int> > a, b; map < int, int > f[MAXK][MAXK], g[MAXK][MAXK];   void solve(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK]) { 		for (int i = 0; i <= (int)a.size(); i++) 			for (int j = 0; j <= N; j++) 				f[i][j].clear(); 				 		f[0][0][0] = 0; 		for (int i = 0; i < (int)a.size(); i++) 			for (int j = 0; j <= N; j++) 				for (int k = 0; k <= N - j && k * H <= a[i].S; k++) 					if ((a[i].S - k * H) % L == 0) 						for (map < int, int > :: iterator iter = f[i][j].begin(); iter != f[i][j].end(); iter++) 							f[i + 1][j + k][(iter->first + (k + (a[i].S - k * H) / L) * (long long)a[i].A) % m] = k; }     void recovery(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK], int x, int y, int z) { 	while (x) 	{ 		int c = f[x][y][z]; 		x--; 		 		stack <int> &st = M[a[x].A];  		for (int i = 0; i < c; i++) 		{ 			for (int j = 0; j < H; j++) 			{ 				ans[left + k * j] = st.top(); 				st.pop(); 			} 			left++; 		} 		 		for (int i = 0; i < (a[x].S - c * H) / L; i++) 		{ 			for (int j = 0; j < L; j++) 			{ 				ans[right + k * j] = st.top(); 				st.pop(); 			} 			right--; 		} 		 		z = ((z - (c + (a[x].S - c * H) / L) * (long long)a[x].A) % m + m) % m; 		y -= c; 	}	 }   int main() { 	#ifndef ONLINE_JUDGE 		freopen("in", "r", stdin); 		freopen("out", "w", stdout); 	#endif 	int t; 	scanf("%d", &t); 	while (t--) 	{ 		M.clear(); 		scanf("%d %d %d", &n, &m, &k); 		for (int i = 0; i < n; i++) 		{ 			int x; 			scanf("%d", &x); 			M[x % m].push(x); 		} 		if ((int)M.size() > k) 		{ 			puts("-1"); 			continue; 		} 		a.clear(); 		b.clear(); 		for (mmap :: iterator iter = M.begin(); iter != M.end(); ++iter) 		{ 			if (a.size() == b.size()) 				a.push_back(make_pair(iter->first, iter->second.size())); 			else 				b.push_back(make_pair(iter->first, iter->second.size())); 		} 		 		H = n / k + 1; 		L = H - 1; 		N = n % k; 		 		solve(a, f); 		solve(b, g); 		 		bool flg = false; 		left = 0; 		right = k - 1; 		for (int i = 0; i <= N && !flg; i++) 			for (map < int, int > :: iterator iter = f[(int)a.size()][i].begin(); iter != f[(int)a.size()][i].end(); iter++) 				if (g[(int)b.size()][N - i].find((m - iter->first) % m) != g[(int)b.size()][N - i].end()) 				{ 					recovery(a, f, a.size(), i, iter->first); 					recovery(b, g, b.size(), N - i, (m - iter->first) % m); 					flg = true; 					break; 				}   		if (!flg) 		{ 			puts("-1"); 			continue; 		} 		 		for (int i = 0; i < n; i++) 		{ 			if (i) printf(" "); 			printf("%d", ans[i]); 		} 		printf("\n"); 	} 	 	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <queue> #include <cstring> #include <fstream> using namespace std; #define all(x) (x).begin(),(x).end()   #define vs vector <string> #define vi vector <int> #define p(X) push_back((X))   #define fir(i,j,n) for(int (i)=(j);(i)<(n);(i)++) #define fire(i,j,n) for(int (i)=(j);(i)<=(n);(i)++) #define firr(i,j,n) for(int (i)=(j);(i)>(n);(i)--) #define firre(i,j,n) for(int (i)=(j);(i)>=(n);(i)--) #define tr(v,it) for(typeof(v.begin()) it=v.begin();it!=v.end();it++)   #define srt(v) sort((v).begin(),(v).end()) #define srtc(v) sort(v.begin(),v.end(),cmp)   #define _bc(i) __builtin_popcount(i)   string lower(string s) {for(int i=0;i<s.size();i++) s[i]=tolower(s[i]);return s;} vector<string> sep(string s,char c) { string temp;vector<string> res;for(int i=0;i<s.size();i++) { if (s[i]==c) {if (temp!="") res.push_back(temp);temp="";continue;}temp=temp+s[i];}if (temp!="") res.push_back(temp);return res;} template<class T> T toint(string s) { 	stringstream ss(s); 	T ret; 	ss>>ret; 	return ret; } template<class T> string tostr(T inp) { 	string ret; 	stringstream ss;ss<<inp; 	ss>>ret; 	return ret; } template<class T> void D(T A[],int n) {for(int i=0;i<n;i++) cout<<A[i]<<" ";cout<<endl;} template<class T> void D(vector<T> A,int n=-1) {if (n==-1) n=A.size();for(int i=0;i<n;i++) cout<<A[i]<<" ";cout<<endl;} char buf[2][1000003]; char C[1000003]; char *P[2]; int len; int cnt[10]; int rle[2][1000003][2]; int size[2]; char op[1000003]; int si; int ei; bool anse; bool gr; int sn;   bool check(int ind) { 	int fnd=0; 	int tmp=si; 	if (!gr) { 		firre(i,9,0) { 			if (cnt[i]<=0) continue; 			if (i>rle[1][tmp][0]) {fnd=1;break;} 			if (i<rle[1][tmp][0]) {fnd=-1;break;} 			if (rle[1][tmp][1]==cnt[i]) {tmp++;continue;} 			if (rle[1][tmp][1]>cnt[i]) {fnd=-1;break;} 			if (i<rle[1][tmp+1][0]) {fnd=-1;break;} 			fnd=1;break; 		} 		if (fnd<=0) return false; 	} 	fnd=0; 	tmp=size[0]-1; 	fir(i,0,10) { 		if (cnt[i]<=0) continue; 		if (i<rle[0][tmp][0]) {fnd=-1;break;} 		if (i>rle[0][tmp][0]) {fnd=1;break;} 		if (rle[0][tmp][1]==cnt[i]) {tmp--;continue;} 		if (rle[0][tmp][1]>cnt[i]) {fnd=1;break;} 		if (i<rle[0][tmp-1][0]) {fnd=-1;break;} 		fnd=1;break; 	} 	if (fnd>0) return false; 	if (fnd<0) return true; 	return sn<0; }   int main() { 	int tc;scanf("%d",&tc); 	while(tc--) { 		memset(cnt,0,sizeof(cnt));size[1]=size[0]=0; 		scanf("%d",&len); 		scanf("%s",&buf[0]); 		scanf("%s",&buf[1]); 		int cmp=strcmp(buf[0],buf[1]); 		if (cmp>0) {P[1]=buf[0];} 		else {P[1]=buf[1];} 		P[0]=buf[0]; 		int ti=len; 		while(ti>0) { 			ti--; 			if (buf[0][ti]==buf[1][ti]) continue; 			if (buf[1][ti]<buf[0][ti]) P[0]=buf[1]; 			break; 		} 		scanf("%s",&C); 		fir(i,0,len) cnt[C[i]-'0']++; 		fir(ind,0,2){ 			int ccnt=0; 			fir(i,0,len) { 				if (i==0 || P[ind][i]==P[ind][i-1]) ccnt++; 				else {rle[ind][size[ind]][0]=P[ind][i-1]-'0';rle[ind][size[ind]][1]=ccnt;ccnt=1;size[ind]++;} 			} 			rle[ind][size[ind]][0]=P[ind][len-1]-'0'; 			rle[ind][size[ind]][1]=ccnt; 			size[ind]++; 		} 		si=0;ei=0; 		anse=1; 		gr=0; 		sn=0; 		fir(i,0,len) { 			anse=0; 			rle[1][si][1]--; 			rle[0][ei][1]--; 			if (rle[1][si][1]==0) si++; 			if (rle[0][ei][1]==0) ei++; 			int psn=sn; 			fir(dg,0,10) { 				if (cnt[dg]<=0) continue; 				if (!gr && dg+'0' < P[1][i]) continue; 				if (dg+'0' > P[1][i]) gr=1; 				if (dg+'0' < P[0][i]) sn=-1; 				if (dg+'0' == P[0][i]) sn=psn; 				if (dg+'0' >P[0][i]) sn=1; 				cnt[dg]--; 				if (!check(i+1)) {cnt[dg]++;continue;} 				anse=1; 				op[i]='0'+dg; 				break; 			} 			if (!anse) break; 		} 		 		op[len]='\0'; 		if (!anse) puts("-1"); 		else puts(op); 	}     return 0; } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> #include <queue> using namespace std; #define N 105 #define M 20050 #define INF 0x3f7f7f7f int fi[M],c[M*5][3],sg[N][N],h[M]; int S=M-1,T=M-2,st,n,m,p,ans,ss=1;queue <int> li; inline int Read()  {  	int x=0;char y;bool z=false;  	do y=getchar(),z|=y=='-'; while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return z?-x:x;  } inline void Line(int x,int y,int z)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;c[ss][2]=z;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } bool BFS()  {  	for (int i=1;i<=st;i++) h[i]=false;  	h[T]=false;h[S]=true;li.push(S);     while (!li.empty())      {      	int k=li.front();li.pop();      	for (int i=fi[k];i;i=c[i][1])      	 if (c[i][2]&&!h[c[i][0]])      	   h[c[i][0]]=h[k]+1,li.push(c[i][0]);      }     return h[T]>0;  } int DFS(int x,int y)  {  	if (x==T) return y;  	int k,l=false;  	for (int i=fi[x];i&&y;i=c[i][1])  	 if (c[i][2]&&h[c[i][0]]==h[x]+1)  	  {  	  	 int k=DFS(c[i][0],min(y,c[i][2]));  	  	 if (k) y-=k,l+=k,c[i][2]-=k,c[i^1][2]+=k;  	  }  	if (!l) h[x]=-1;  	return l;  }  int main()  {  	//freopen("input.txt","r",stdin);  	n=Read();m=Read();p=Read();ans += 100 * n;  	for (int i=1;i<=n;i++)  	 for (int j=0;j<=m;j++) sg[i][j]=++st;  	for (int i=1;i<=n;i++)  	  Line(S,sg[i][0],INF),Line(sg[i][m],T,INF);  	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++)  	 {  	 	int k=Read();k = k == -1 ? INF : 100 - k;  	 	Line(sg[i][j-1],sg[i][j],k);  	 }  	while (p--)  	 {  	 	int k=Read(),l=Read();  	 	for (int i=0;i<m;i++) Line(sg[k][i],sg[l][i+1],INF);  	 }  	while (BFS()) ans-=DFS(S,INF);  	printf("%.2lf\n",(1.0*ans)/n);  	return 0;  }
#include <ctime> #include <cstdio> #include <cstring> #include <algorithm> using namespace std;  #define n	140005 #define P	104857601 #define I64	long long #define For(i,a,b)	for(int i=a;i<b;i++)  int		L,K,C[n],D[n],inv[n],rev[n],w[2][n];  int		Pow(int a,int b){ 		int ret=1; 		for (;b;b>>=1,a=1ll*a*a%P) 			if	(b&1)	ret=1ll*ret*a%P; 		return	ret; } void	Pre(int L){ 		int a=Pow(3,(P-1)/L),b=Pow(a,P-2); 		For(i,0,L)	{ 			w[0][i]=i?1ll*w[0][i-1]*a%P:1; 			w[1][i]=i?1ll*w[1][i-1]*b%P:1;	rev[i]=0; 			for (int x=1,t=i;x<L;x<<=1,t>>=1)	(rev[i]<<=1)|=t&1; 		} } void	FFT(int L,int*A,int f){ 		For(i,0,L)	if	(rev[i]>i)	swap(A[i],A[rev[i]]); 		for (int i=1;i<L;i<<=1) 		for (int j=0,t=L/(i<<1);j<L;j+=i<<1) 		for (int k=0,l=0;k<i;k++,l+=t){ 			int x=A[j+k],y=1ll*A[j+k+i]*w[f][l]%P; 			A[j+k]=(x+y)%P;	A[j+k+i]=(x-y+P)%P; 		} 		if	(f)	{ 			int R=Pow(L,P-2); 			For(i,0,L)	A[i]=1ll*A[i]*R%P; 		} }  namespace	Inv{ 		int 	L,B[n],C[n]; 		void	Main(int N,int*A){ 			B[0]=Pow(A[0],P-2); 			for (L=1;L<N;)	{ 				Pre((L<<=1)<<1);For(i,0,L)	C[i]=A[i]; 				FFT(L<<1,B,0);	FFT(L<<1,C,0); 				For(i,0,L<<1)	B[i]=((-1ll*B[i]*C[i]+2)%P*B[i]%P+P)%P; 				FFT(L<<1,B,1);	For(i,L,L<<1)	B[i]=0; 			} 			For(i,0,N)	A[i]=B[i]; 		} };  namespace	Div{ 		int 	A[n]; 		void	Main(int N,int*a,int*D){ 			For(i,0,N)	A[i]=a[N-i-1];	For(i,N-K+1,N)	A[i]=0; 			For(i,N,L)	A[i]=0; 			FFT(L,A,0); 			For(i,0,L)	D[i]=1ll*A[i]*inv[i]%P;	FFT(L,D,1); 			For(i,N-K+1,L)	D[i]=0;	reverse(D,D+N-K+1); 		} };  void	Mod(int N,int*A)	{ 		for (;N>1&&!A[N-1];N--); 		if	(N<K)	return; 		Div::Main(N,A,D);	FFT(L,D,0); 		For(i,0,L)	D[i]=1ll*D[i]*C[i]%P;	FFT(L,D,1); 		For(i,0,L)	A[i]=(A[i]-D[i]+P)%P; };  I64		N; int		ret,A[n],B[n],Ans[n];  void	Work(){ 		Ans[0]=B[1]=1; 		for (;N;N>>=1)	{ 			FFT(L,B,0); 			if	(N&1)	{ 				FFT(L,Ans,0); 				For(i,0,L)	Ans[i]=1ll*Ans[i]*B[i]%P; 				FFT(L,Ans,1);	Mod(2*K,Ans); 			} 			For(i,0,L)	B[i]=1ll*B[i]*B[i]%P;	FFT(L,B,1); 			Mod(2*K,B); 		} }  int		main(){ 	//	freopen("RNG.in","r",stdin); 	//	freopen("1.out","w",stdout); 		 		int ppp=clock(); 		 		scanf("%d%lld",&K,&N);	N--; 		For(i,0,K)	scanf("%d",&A[i]); 		For(i,0,K)	scanf("%d",&C[K-i-1]),C[K-i-1]=(P-C[K-i-1])%P;	C[K++]=1; 		For(i,0,K)	inv[i]=C[K-i-1]; 		 		Inv::Main(K,inv); 		 //		For(i,0,1000)	printf("%d\n",inv[i]);	return	0; 		 		 		for (L=1;L<K;L<<=1);L<<=1;	Pre(L);	FFT(L,inv,0);	FFT(L,C,0);  		  		Work(); 		For(i,0,K)	ret=(1ll*Ans[i]*A[i]+ret)%P; 		printf("%d\n",ret);  	//	fprintf(stderr,"%d\n",clock()-ppp); }
#include<cmath> #include<ctime> #include<cstdio> #include<cstring> #include<cstdlib> #include<iostream> #include<algorithm>  #define MaxN 1000010  using namespace std;  struct Edge{ 	int u,v; }edg[MaxN];  int N,M,f[MaxN],ff[MaxN],head[MaxN],prep[MaxN],v[MaxN],m0,dep[MaxN],fa[MaxN][20],Que[MaxN],Qhead,Qtail; long long cnt[MaxN],Ans,cnt1[MaxN]; bool vis[MaxN];  int find(int x){ 	return f[x]==x?f[x]:f[x]=find(f[x]); }  int find_f(int x){ 	return ff[x]==x?ff[x]:ff[x]=find_f(ff[x]); }  void AddEdge(int a,int b){ 	++m0;v[m0]=b;prep[m0]=head[a];head[a]=m0; }  void Init(){ 	int i,j,x,y; 	scanf("%d%d",&N,&M); 	for(i=1;i<=N;++i) f[i]=i; 	for(i=1;i<=M;++i){ 		scanf("%d%d",&edg[i].u,&edg[i].v); 		if((x=find(edg[i].u))!=(y=find(edg[i].v))){ 			f[x]=y; 			AddEdge(edg[i].u,edg[i].v); 			AddEdge(edg[i].v,edg[i].u); 		} 	} 	for(i=1;i<=N;++i) 		if(find(i)==i){ 			AddEdge(0,i); 			AddEdge(i,0); 		} }  void PreWork(){ 	int i,j; 	vis[0]=1; 	for(Que[Qhead=Qtail=1]=0;Qhead<=Qtail;++Qhead) 		for(i=head[Que[Qhead]];i;i=prep[i]) 			if(!vis[v[i]]){ 				vis[Que[++Qtail]=v[i]]=1; 				fa[v[i]][0]=Que[Qhead]; 				dep[v[i]]=dep[Que[Qhead]]+1; 			} 	for(i=1;i<=19;++i) 		for(j=1;j<=N;++j) 			fa[j][i]=fa[fa[j][i-1]][i-1]; }  void Delete(int l){ 	f[l]=fa[l][0]; }  int LCA(int l,int r){ 	if(dep[l]<dep[r]) swap(l,r); 	int d=dep[l]-dep[r],i; 	for(i=0;d;d>>=1,++i) 		if(d&1) 			l=fa[l][i]; 	if(l==r) 		return l; 	for(i=19;i>=0;--i) 		if(fa[l][i]!=fa[r][i]){ 			l=fa[l][i];r=fa[r][i]; 		} 	return fa[l][0]; }  void Solve(){ 	int x,y,i,j; 	for(i=1;i<=N;++i){ 		f[i]=ff[i]=i; 		cnt[i]=cnt1[i]=1; 	} 	for(i=1;i<=M;++i){ 		if((x=find_f(edg[i].u))!=(y=find_f(edg[i].v))){ 			Ans+=cnt[x]*cnt[y]; 			cnt[y]+=cnt[x]; 			ff[x]=y; 		} 		else{ 			long long nowtot=0; 			int l=find(edg[i].u),r=find(edg[i].v),dd; 			if(dep[l]<dep[r]) swap(l,r); 			int L=find(LCA(l,r)); 			for(;l!=L;){ 				Ans-=cnt1[l]*nowtot; 				nowtot+=cnt1[l]; 				Delete(l);l=find(l); 			} 			for(;r!=L;){ 				Ans-=cnt1[r]*nowtot; 				nowtot+=cnt1[r]; 				Delete(r);r=find(r); 			} 			Ans-=cnt1[l]*nowtot; 			cnt1[l]+=nowtot; 		} 		printf("%lld\n",Ans); 	} }  int main(){ 	Init(); 	PreWork(); 	Solve(); 	return 0; } 
//Template  // By Anudeep :) //Includes #include <vector>  #include <queue> #include <map>  #include <set> #include <utility> //Pair #include <algorithm> #include <sstream> // istringstream>> ostring stream<< #include <iostream>  #include <iomanip>  //setbase - cout << setbase (16); cout << 100 << endl; Prints 64 //setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77 //setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <limits> using namespace std;  //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end()  #define ESP (1e-9)  #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min()  #define N 100100  vi adj[505]; int dp[505][N]; int su[505], v[505];  void dfs(int cur) {  	su[cur] = v[cur]; 	rep(i, adj[cur].sz) 	{ 		dfs(adj[cur][i]); 		su[cur] += su[adj[cur][i]]; 	}  	rep(i, adj[cur].sz) 	{ 		int u = adj[cur][i]; 		int *cdp = dp[u];  		int count = 0; 		rep(j, N) count += cdp[j];  		if(count < -2000) 		{ 			set < int > A, B; 			rep(j, N) 			if(cdp[j]) 			{ 				A.insert(j); 			}  			rep(j, adj[cur].sz) 			{ 				if(i != j) 				{ 					int v = adj[cur][j]; 					int x = su[v];  					for(set<int> :: iterator it = A.begin(); it != A.end(); it++) 					{ 						B.insert(*it); 						B.insert(*it+x); 					} 					A = B; 				} 			}  			rep(j, N) 			if(A.find(j) != A.end()) 			{ 				cdp[j] = 1; 			}  			continue; 		}  		rep(j, adj[cur].sz) 		if(i != j) 		{ 			int v = adj[cur][j]; 			int x = su[v];  			for(int k = N-10; k>=x; k--) 				cdp[k] = cdp[k] | cdp[k-x]; 		} 	}  	int *cdp = dp[cur]; 	for(int k = v[cur], kk=0; k<N; k++, kk++) 	{ 		rep(i, adj[cur].sz) 			cdp[k] = cdp[k] | dp[adj[cur][i]][kk]; 	} 	cdp[v[cur]] = 1;  	// printf("%d\n", cur); 	// rep(i, 22) printf("%d ", dp[cur][i]); pn; }  int main() { 	memset(dp, 0, sizeof dp); 	rep(i, 505) 	{ 		dp[i][0] = 1; 	}  	int n; 	scanf("%d", &n);  	int sum = 0; 	rep(i, n) 	{ 		scanf("%d", &v[i]); 		sum += v[i]; 	}  	rep(i, n-1) 	{ 		int x; 		scanf("%d", &x); 		adj[x-1].pb(i+1); 	}  	dfs(0);  	rep(i, sum) 	{ 		printf("%c", char('0'+dp[0][i+1])); 	} 	pn; }
/* Test case: Input  13 1 2 2 1 2 2 1 2 2 1 2 2 1  Output  120  100000 1 2 3 1 2 3 ....  685182122   100000 1 2 1 2 .... 479166697  10 2 1 2 1 2 2 1 2 1 2    100000 1 2 3 ..... 200 1 2 3 ...200 ..... 418024485  100000 1 2 3 ... 5000 1 2 3 .. 5000 1 2 3 .... 216748838    1000000 1 2 3 4 ... 100 1 2 3 .. 100 ...   101 102 103... 116 ....     1 2 3 ..  100 623330716 */   #include <bits/stdc++.h> using namespace std; typedef long long int ll; #define N 100000 #define MAX 200 int ar[N + 1]; int mark[N + 1]; vector <int> pos[N + 1]; vector <int> C1,C2; ll mod; vector <ll> Values; ll bit[N + 1],CL[N + 1]; ll sum[N + 1],cnt[N + 1]; ll T[N + 1]; ll invmod[30]; void Update(int pt,ll val) {     while(pt > 0)     {         bit[pt] = bit[pt] + val;         if(bit[pt] >= mod) bit[pt] = bit[pt] - mod;         pt -= (pt & -pt);     } } ll Query(int pt,int n) {     ll sum = 0;     while(pt <= n)     {         sum = sum + bit[pt];         pt += (pt & -pt);         if(sum >= mod) sum = sum - mod;     }     return sum; } ll Compute() {     int sz = Values.size();     ll sum = 0,sqsum = 0;     ll ans = 0;     for(int k = 1 ; k<=sz ; k++)     {         ll val = Values[k-1];         //printf("%lld ",val);         ll K = (ll) k;         ll Two = (ll) 2;         sqsum = (sqsum + K*((val*val)%mod) + Two*((val*sum)%mod))%mod;         sum = (sum + K*val)%mod;         ll temp = sqsum + mod - sum;         if(temp >= mod) temp = temp - mod;         ans = ans + temp;         if(ans >= mod) ans = ans - mod;         //printf("%lld %lld %lld\n",ans,sqsum,sum);     }     //printf("\n");     ans = (ans * invmod[2]) %mod;     return ans; } /*ll Func(ll v) {     ll temp1 = ((v*(v+1))/2)%mod;     ll temp2 = (temp1 * (temp1 - 7))%mod;     if(temp2 < 0) temp2 = temp2 + mod;     ll selfoverlaps = 0;     selfoverlaps = (temp2*invmod[6] + v)%mod;     int V = (int) v;     ll selfIntersections = tarcs[V];     ll tot = -selfoverlaps + selfIntersections + mod;     if(tot >= mod) tot = tot - mod;     return tot; }*/ ll Func(ll v) {     ll t1 = ((v*(v-1))/2)%mod;     ll t2 = ((v*(v-1)*(v-2))/6)%mod;     ll t3 = (v*(v-1)*(v-2))%mod;     t3 = (t3*(v-3))%mod;     t3 = (t3 * invmod[24])%mod;     ll res = (t1 + t2 + t3)%mod;     return res; } void PreProcess() {     mod = pow(10,9) + 7;     invmod[1] = 1;     for(int i = 2 ; i<=30 ; i++)     {         ll I = (ll) i;         int MOD = (int) mod;         invmod[i] = (-(mod/I)*invmod[MOD%i])%mod + mod;     } } int main() {     PreProcess();     int n,i;     //n = pow(10,5);     scanf("%d",&n);     //int l = n/2;     /*for(i = 1 ; i<=10000 ; i++)     {         ar[i] = 1 + (i-1)%100;     }     int faltu = 1;     for(i = n - 10000 + 1 ; i<=n ; i++)     {         if(faltu == 101) faltu = 1;         ar[i] = faltu;         faltu++;     }     faltu = 101;     for(i = 10001 ; i<=n-10000 ; i++)     {         if(faltu == 117) faltu = 101;         ar[i] = faltu;         faltu++;     }*/     for(i = 1 ; i<=n ; i++)     {         //ar[i] = 1 + i%2;         //ar[n-i+1] = 1 + i%2;         //ar[i] = 1 + i/l;         //ar[i] = 1 + (i-1)%5000;         scanf("%d",&ar[i]);         pos[ar[i]].push_back(i);     }     //printf("uttam\n");     //for(int i = 0 ; i<n ; i++) cout<<ar[i+1] <<" ";     //cout<<endl;     //printf("here\n");     for(i = 1 ; i<=N ; i++)     {         if(pos[i].size() > MAX)         {             C1.push_back(i);             mark[i] = 1;         }         else         {             if(pos[i].size() > 0)             {                 C2.push_back(i);                 mark[i] = 2;             }         }         //if(pos[i].size() > 0) printf("%d %d\n",i,pos[i].size());     }     //cout<<C1.size();     //cout<<C2.size();     ll overlaps = 0;     // C2 overlapped by C2     for(i = 1 ; i<=n ; i++)     {         if(mark[ar[i]] == 2)         {             int sz = pos[ar[i]].size();             int j;             for(j = 0 ; j<sz ; j++)             {                 if(pos[ar[i]][j] == i) break;             }             for(int k = j-1 ; k>=0 ; k--)             {                 ll temp = Query(pos[ar[i]][k],n);                 overlaps = overlaps + temp;                 if(overlaps >= mod) overlaps = overlaps - mod;                 Update(pos[ar[i]][k],1);             }         }     }     //printf("%lld\n",overlaps);     // C1 overlapped by C2;     int sz1 = C1.size();     int sz2 = C2.size();     //cout<<sz1<<endl;     //cout<<sz2<<endl;     for(i = 0 ; i<sz2 ; i++)     {         //printf("%d %d\n",i,sz2);         int sz = pos[C2[i]].size();         for(int j = 0 ; j<sz1 ; j++)         {             Values.clear();             for(int k = 1 ; k<sz ; k++)             {                 int l = pos[C2[i]][k-1];                 int h = pos[C2[i]][k];                 vector <int> :: iterator itl = upper_bound(pos[C1[j]].begin(),pos[C1[j]].end(),l);                 vector <int> :: iterator ith = upper_bound(pos[C1[j]].begin(),pos[C1[j]].end(),h);                 int c = ith-itl;                 ll C = (ll)c;                 Values.push_back(C);                 //printf("%lld ",C);             }             //printf("\n");             ll temp = Compute();             overlaps = overlaps + temp;             if(overlaps >= mod) overlaps = overlaps - mod;             //int X;scanf("%d",&X);         }     }     //printf("%lld\n",overlaps);     // C1 and C2 overlapped by C1     for(i = 0 ; i<sz1 ; i++)     {         ll tot = 0;         for(int j = 1 ; j<=n ; j++)         {             if(ar[j] == C1[i])             {                 tot = tot + 1;                 sum[j] = sum[j-1] + 1;             }             else sum[j] = sum[j-1];         }         for(int j = 1 ; j<=N ; j++) CL[j] = 0;         for(int j = 1 ; j<=n ; j++)         {             ll f = 0;             if(ar[j] == C1[i]) f = 1;             ll temp = ((tot - sum[j]+f)*(CL[ar[j]]))%mod;             CL[ar[j]] = CL[ar[j]] + sum[j];             if(CL[ar[j]] >= mod) CL[ar[j]] = CL[ar[j]] - mod;             overlaps = overlaps + temp;             if(overlaps >= mod) overlaps = overlaps - mod;         }         ll temp1 = ((tot*(tot - 1))/2)%mod;         overlaps = overlaps - temp1 + mod;         if(overlaps >= mod) overlaps = overlaps - mod;     }     //printf("%lld\n",overlaps);     for(i = 1 ; i<=N ; i++) CL[i] = 0;     ll ans = 0;     for(i = 1 ; i<=n ; i++)     {         T[i] = T[i-1] + cnt[ar[i]];         if(T[i] >= mod) T[i] = T[i] - mod;         ll temp = (cnt[ar[i]] * T[i])%mod - CL[ar[i]] + mod;         if(temp >= mod) temp = temp - mod;         ans = ans + temp;         if(ans >= mod) ans = ans - mod;         CL[ar[i]] = CL[ar[i]] + T[i];         if(CL[ar[i]] >= mod) CL[ar[i]] = CL[ar[i]] - mod;         cnt[ar[i]] = cnt[ar[i]] + 1;         //printf("%lld %lld %lld %lld\n",T[i],CL[1],cnt[1],ans);     }     //printf("%lld",ans-overlaps);     ans = ans - overlaps + mod;     if(ans >= mod) ans = ans - mod;     //printf("%lld\n",ans);     for(i = 1 ; i<=N ; i++)     {         //if(cnt[i] == 0) continue;         ll temp = Func(cnt[i]);         ans = ans - temp + mod;         if(ans >= mod) ans = ans - mod;     }     //printf("uttam\n");     printf("%lld\n",ans);     return 0; } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 505 #define M 130050 #define P 1000000007 #define ll long long int dp[N][M],pre[N][M],C[N][N],Aha[N],JC[N],t,n,m,ans; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline void Add(int &x,int y) {x=(x+y)%P;} void Pretreat()  {  	dp[1][0]=pre[1][0]=JC[0]=true;  	for (int i=1;i<N;i++) JC[i]=1LL*JC[i-1]*i%P;  	for (int i=1;i<N;i++) JC[i]=1LL*JC[i]*JC[i]%P;  	for (int i=1;i<N;i++) Aha[i] = i*(i-1) / 2;  	for (int i=2;i<N;i++)  	 {  	 	int q=Aha[i],w=Aha[i-1];  	 	for (int j=w+1;j<=q;j++) pre[i-1][j] = pre[i-1][j-1];  	 	for (int j=0;j<=q;j++)  	 	 {  	 	 	if (j<i) dp[i][j] = pre[i - 1][j]; else  	 	 	  dp[i][j] = (pre[i - 1][j] - pre[i - 1][j - i] + P) %P;  	 	 	pre[i][j] = j ? (pre[i][j - 1] + dp[i][j]) %P : dp[i][j];  	 	 }  	 }  	for (int i=0;i<N;i++) C[i][0]=true;  	for (int i=1;i<N;i++)  	 for (int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;  	for (int i=1;i<N;i++) for (int j=1;j<i;j++)  	  C[i][j]=1LL*C[i][j]*C[i][j]%P;  	return;  } inline int Pre(int x,int y)  {return y<=Aha[x]?pre[x][y]:pre[x][Aha[x]];} int main()  {  	//freopen("input.txt","r",stdin);  	Pretreat();t=Read();  	while (t--)  	 {  	 	n=Read();m=Read();ans = false;  	 	for (int i=1;i<=n;i++)  	 	  Add(ans,1LL*C[n][i]*JC[n-i]%P*(n-i+1)%P*Pre(i,m)%P);  	 	printf("%d\n",ans);  	 }  	return 0;  }
#include<bits/stdc++.h>  using namespace std;  #define vi vector < int > #define pii pair < int , int > #define pb push_back #define mp make_pair #define ff first #define ss second #define foreach(it,v) for( __typeof((v).begin())it = (v).begin() ; it != (v).end() ; it++ ) #define ll long long #define llu unsigned long long #define MOD 1000000007 #define INF 2000000000 #define dbg(x) { cout<< #x << ": " << (x) << endl; } #define dbg2(x,y) { cout<< #x << ": " << (x) << " , " << #y << ": " << (y) << endl; } #define all(x) x.begin(),x.end() #define mset(x, v) memset(x, v, sizeof(x)) #define sz(x) (int)x.size()  ll modpow(ll a,ll b) {     ll r = 1;     while(b)     {         if(b&1)             r = (r*a)%MOD;         b >>= 1;         a = (a*a)%MOD;     }     return r; }  int get(int m,vi v) {     int i,j;     int n = sz(v);     int ret = 0;     for(i=0;i<(1<<n);i++)     {         int c = 0;         int val = 1;         for(j=0;j<n;j++)         {             if(i&(1<<j))             {                 c++;                 val *= v[j];             }         }         if(c&1)             ret -= (m/val);         else             ret += (m/val);     }     return ret; }  ll solve(int n,int m,int d) {     vi a;     int i,j;     for(i=2;i*i<=d;i++)     {         if(d%i == 0)         {             int tmp = 1;             while(d%i == 0)             {                 tmp *= i;                 d/=i;             }             a.pb(tmp);         }     }     if(d > 1)     {         a.pb(d);     }     ll ans = modpow(m,n);     int N = sz(a);     for(i=1;i<(1<<N);i++)     {         int tmp = 1;         int c = 0;         vi v;         for(j=0;j<N;j++)         {             if(i&(1<<j))             {                 c++;                 v.pb(a[j]);             }         }         int cnt = get(m,v);         ll val = modpow(cnt,n);         if(c&1)             ans -= val;         else             ans += val;         if(ans >= MOD)             ans -= MOD;         if(ans < 0)             ans += MOD;     }     return ans; }  int cc;  int lcm(int a,int b) {     return a * (b/__gcd(a,b)); }  void go(int n,int m,int pos,int d,int l) {     if(pos == n)     {         if(l%d == 0)             cc++;         return;     }     int i;     for(i=1;i<=m;i++)     {         int nl = lcm(l,i);         go(n,m,pos+1,d,nl);     } }  ll brute(int n,int m,int d) {     int i,j;     cc = 0;     go(n,m,0,d,1);     return cc; }  int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,m,l,r;         scanf("%d%d%d%d",&n,&m,&l,&r);         ll ans = 0;         ll bt = 0;         while(l <= r)         {             ans += solve(n,m,l);             if(ans >= MOD)                 ans -= MOD;             l++;         }         printf("%lld\n",ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int pos[10002],pos1[10002],tme[10002],tme1[10002],order[10002],order1[10002],a[10002],b[10002]; pair<int,int> o1[100002],o2[100002]; int main(){ 	int t; 	scanf("%d",&t); 	while(t--){ 		int n,i,j,t1=0,t2=0; 		scanf("%d",&n); 		for(i=1;i<=n;i++){ 			scanf("%d %d",&a[i],&b[i]); 			t1+=a[i]; 			t2+=b[i]; 			o1[i]=make_pair(0,0); 			o2[i]=make_pair(0,0); 		} 		if(n==1){ 			printf("%d\n",t1+t2); 			printf("0 %d\n",a[1]); 			continue; 		} 		a[0]=0,b[0]=0; 		int l=0,r=0; 		deque<int> ans; 		for(i=1;i<=n;i++){ 			if(a[i]>=b[i]){ 				if(a[i]>=b[r]){ 					ans.push_back(r); 					r=i; 				} 				else 					ans.push_back(i); 			} 			else{ 				if(b[i]>=a[l]){ 					ans.push_front(l); 					l=i; 				} 				else 					ans.push_front(i); 			} 		} 		int c=0,c1=0; 		if(t1-t2<a[l]-b[r]){ 			if(l!=0){ 				order1[c1++]=l; 				order[n-1]=l; 			} 			while(!ans.empty()){ 				int t=ans.front(); 	        	ans.pop_front(); 				if(t!=0){ 					order[c++]=t; 					order1[c1++]=t; 				} 			} 			if(r!=0){ 				order[c++]=r; 				order1[c1++]=r; 			} 		} 		else{ 			if(r!=0){ 				order1[c1++]=r; 				order[n-1]=r; 			} 			if(l!=0){ 				order[c++]=l; 				order1[c1++]=l; 			} 			while(!ans.empty()){ 				int t=ans.front(); 				ans.pop_front(); 				if(t!=0) 				{ 					order[c++]=t; 					order1[c1++]=t; 				} 			} 		} 		int s=0,s1=0; 		c=1;c1=0; 		int x=order[0]; 		pos[x]=0;tme[x]=0; 		s+=a[x]; 		o1[x]=make_pair(0,a[x]); 		while(c<n || c1<n){ 			if(c1<n){ 				x=order1[c1]; 				if(s1>=o1[x].first && s1<o1[x].second)  					s1=o1[x].second; 				if(s1+b[x]>o1[x].first && s1+b[x]<=o1[x].second) 					s1=o1[x].second; 				pos1[x]=c1; 				tme1[c1]=s1; 				o2[x]=make_pair(s1,s1+b[x]); 				s1+=b[x]; 				c1++; 			} 			if(c<n){ 				x=order[c]; 				if(s>=o2[x].first && s<o2[x].second)  					s=o2[x].second; 				if(s+a[x]>o2[x].first && s+a[x]<=o2[x].second) 					s=o2[x].second; 				pos[x]=c; 				tme[c]=s; 				o1[x]=make_pair(s,s+a[x]); 				s+=a[x]; 				c++; 			} 		} 		printf("%d\n",max(s,s1)); 		for(i=1;i<=n;i++) 			printf("%d %d\n",tme[pos[i]],tme1[pos1[i]]); 	} 	return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> using namespace std;  template<class T> T gcd(T a,T b) {     if(a<0) return gcd(-a,b);     if(b<0)return gcd(a,-b);     return (b==0)?a:gcd(b,a%b); } template <class T> T lcm(T a,T b) {     return a*(b/gcd(a,b)); } template<class T> inline vector<pair<T,int> > factorize(T n) {     vector<pair<T,int> > R;     for (T i=2; n>1;)     {         if (n%i==0)         {             int C=0;             for (; n%i==0; C++,n/=i);             R.push_back(make_pair(i,C));         }         i++;         if (i>n/i) i=n;     }     if (n>1) R.push_back(make_pair(n,1));     return R; } template<class T> inline bool isPrimeNumber(T n) {     if(n<=1)return false;     for (T i=2; i*i<=n; i++) if (n%i==0) return false;     return true; } template<class T> inline T eularFunction(T n) {     vector<pair<T,int> > R=factorize(n);     T r=n;     for (int i=0; i<R.size(); i++)r=r/R[i].first*(R[i].first-1);     return r; } template<class T> string toString(T n) {     ostringstream ost;     ost<<n;     ost.flush();     return ost.str(); } int toInt(string s) {     int r=0;     istringstream sin(s);     sin>>r;     return r; }  int i,j,k; #define REP(i,n) for((i)=0;(i)<(int)(n);(i)++) #define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) int dirx[]= {1, 1, 0,-1,-1,-1,0,1}; int diry[]= {0,-1,-1,-1, 0, 1,1,1}; //clockwise  const int N=120000; int a[N],b[N],s[5];   int main() {     ios_base::sync_with_stdio(0); //    freopen("1.txt","r",stdin);     int T;     cin>>T;     for(int cas = 1; cas<=T; cas++)     {         int n;         cin>>n;         for(int i=1; i<=n; i++) cin>>a[i];         for(int i=1; i<=n; i++) cin>>b[i];         for(int i=1; i<=n; i++) a[i] = (4+b[i]-a[i])%4;         memset(s,0,sizeof(s));         int ans = a[1];         j=0;         for(int i=2; i<=n; i++)         {             s[(4+a[i]-a[i-1]-1)%4+1]++;             if (a[i-1]>=a[i]) continue;             for(j=0; !s[j]; j++);             s[j]--; //            cout<<" this "<<i<<"  size "<<j<<endl;             ans+=j;         }         cout<<ans<<endl;      }      return 0; } 
#include <bits/stdc++.h> using namespace std;  const int N = 100000; const int mod = 1000000007; const int lim = 455; int dp[2][N + 10]; long long c[lim + 10][lim + 10]; int f[lim][N][2];  int add(int x,int y) {     x += y;     if(x >= mod) x -= mod;     return x; }      int main() {     int n,m,r;     scanf("%d%d%d",&n,&r,&m);     if((long long)r * (r + 1) / 2 > n) {         cout << 0 << endl;         return 0;     }         for(int i = 1; i <= N; i ++) dp[1][i] = 1;     for(int i = 2; i <= r; i ++) {         memset(dp[i & 1],0,sizeof(dp[i & 1]));         for(int j = i * (i + 1) / 2; j <= N; j ++) {             dp[i & 1][j] = add(dp[(i & 1) ^ 1][j - i],dp[i & 1][j - i]);         }     }     int ut = r * (r + 1) / 2;     f[0][0][0] = 1;     for(int i = 0; i < r; i ++) {         for(int j = 0; j <= ut; j ++) {             for(int k = 0; k < 2; k ++) {                 f[i + 1][j][k] = add(f[i + 1][j][k],f[i][j][k]);                 if(r - i + j <= ut)                     f[i + 1][j + r - i][k ^ 1] = add(f[i + 1][j + r - i][k ^ 1],f[i][j][k]);             }         }     }     long long ans = 0;     for(long long i = 0; i <= ut; i ++) {         if(n - i * m >= 0) {             ans = (ans + 1LL * dp[r & 1][n - i * m] * f[r][i][0]) % mod;             ans = (ans - 1LL * dp[r & 1][n - i * m] * f[r][i][1]) % mod;         }     }     if(ans < 0) ans += mod;     cout << ans << endl;     return 0; }  
#include <bits/stdc++.h> #define SZ(X) ((int)(X).size()) #define ALL(X) (X).begin(), (X).end() #define REP(I, N) for (int I = 0; I < (N); ++I) #define REPP(I, A, B) for (int I = (A); I < (B); ++I) #define RI(X) scanf("%d", &(X)) #define RII(X, Y) scanf("%d%d", &(X), &(Y)) #define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z)) #define DRI(X) int (X); scanf("%d", &X) #define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y) #define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z) #define RS(X) scanf("%s", (X)) #define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0) #define MP make_pair #define PB push_back #define MS0(X) memset((X), 0, sizeof((X))) #define MS1(X) memset((X), -1, sizeof((X))) #define LEN(X) strlen(X) #define PII pair<int,int> #define VPII vector<pair<int,int> > #define PLL pair<long long,long long> #define F first #define S second typedef long long LL; using namespace std; const int SIZE = 1e6+10; // template end here int phi[5001]; int D[5002][5000],N,M,A[SIZE]; LL mypow(LL x,LL y,int mod){     x%=mod;     LL res=1%mod;     while(y){         if(y&1)res=res*x%mod;         y>>=1;         x=x*x%mod;     }     return res; } void pre(){     REPP(i,1,5001){         phi[i]=i;     }     REPP(i,2,5001){         if(phi[i]==i){             for(int j=i;j<5001;j+=i)phi[j]=phi[j]/i*(i-1);         }     } } int cnt[5000]; void f(int lv,int r,int mod){     memset(D[lv],0,sizeof(int)*mod);     if(mod==1){         D[lv][0]=mypow(N,r,M);         return;     }     if(r==1){         REP(i,N)D[lv][A[i]%mod]++;         REP(i,mod)D[lv][i]%=M;         return;     }     f(lv+1,r-1,phi[mod]);     memset(cnt,0,sizeof(int)*mod);     REP(i,N)         cnt[A[i]%mod]++;     REP(i,mod)cnt[i]%=M;     REP(i,mod){         if(!cnt[i])continue;         int now=mypow(i,phi[mod],mod);         if(!i)now=0;         REP(j,phi[mod]){             D[lv][now]=(D[lv][now]+cnt[i]*D[lv+1][j])%M;             now=now*i%mod;         }     } } int main(){     pre();     CASET{         RII(N,M);         REP(i,N)RI(A[i]);         f(0,N,M);         int an=0;         REP(i,M)an=(an+D[0][i]*i)%M;         printf("%d\n",an);     }     return 0; } 
#include <string> #include <vector> #include <algorithm> #include <cmath> #include <set> #include <queue> #include <map> #include <cstdio> #include <iomanip> #include <sstream> #include <iostream> #include <cstring> #define REP(i,x,v)for(int i=x;i<=v;i++) #define REPD(i,x,v)for(int i=x;i>=v;i--) #define FOR(i,v)for(int i=0;i<v;i++) #define FORE(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define REMIN(x,y) (x)=min((x),(y)) #define REMAX(x,y) (x)=max((x),(y)) #define pb push_back #define sz size() #define mp make_pair #define fi first #define se second #define ll long long #define IN(x,y) ((y).find((x))!=(y).end()) #define un(v) v.erase(unique(ALL(v)),v.end()) #define LOLDBG1 #ifdef LOLDBG #define DBG(vari) cerr<<#vari<<" = "<<vari<<endl; #define DBG2(v1,v2) cerr<<(v1)<<" - "<<(v2)<<endl; #else #define DBG(vari) #define DBG2(v1,v2) #endif #define CZ(x) scanf("%d",&(x)); #define CZ2(x,y) scanf("%d%d",&(x),&(y)); #define CZ3(x,y,z) scanf("%d%d%d",&(x),&(y),&(z)); #define ALL(x) (x).begin(),(x).end() #define tests int dsdsf;cin>>dsdsf;while(dsdsf--) #define testss int dsdsf;CZ(dsdsf);while(dsdsf--) using namespace std; typedef pair<int,int> pii; typedef vector<int> vi; template<typename T,typename TT> ostream &operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream &operator<<(ostream &s,vector<T> t){s<<"{";FOR(i,t.size())s<<t[i]<<(i==t.size()-1?"":",");return s<<"}"; }  int p[100000]; int szuk(int x){if (x==p[x]) return x;return p[x]=szuk(p[x]);} inline void unia(int x,int y){p[szuk(x)]=szuk(y);}  vector<pii> v; vi V; int a[300],b[300],f[300]; int m,n,K; short nr[50][50]; vi kr[1202]; vi KR[602]; vi comp[602]; vi I; bool inI[602]; bool X1[602]; bool X2[602]; int prev[1602];   vi get_path(int x,int y) {     FOR(i,n) prev[i]=-1;     prev[x]=x;     queue<int> Q;     Q.push(x);     while(Q.sz)     {         int u=Q.front();Q.pop();         if (u==y) break;         FORE(j,kr[u])         {             if (prev[*j]==-1)             {                 prev[*j]=u;                 Q.push(*j);             }         }     }     vi path;     while(y!=x)     {          path.pb(nr[y][prev[y]]);         y=prev[y];     }     return path; }  bool seek_path() {     DBG("seek");     queue<int> Q;     FOR(i,m) prev[i]=-1;     FOR(i,m) if (X1[i]) {prev[i]=i;Q.push(i);}     int good=-1;     while(Q.sz)     {         int u=Q.front();Q.pop();         //DBG(u);         if (X2[u])         {             good=u;             break;         }         FORE(j,KR[u])         {             if (prev[*j]==-1)             {                 prev[*j]=u;                 Q.push(*j);             }         }     }          if (good==-1) return 0;     vi path;     path.pb(good);     while(!X1[good])     {         good=prev[good];         path.pb(good);     }     FORE(e,path) inI[*e]^=1;     return 1; }  int max_freq[500]; vi used[400];  int main() {     testss     {         CZ3(n,m,K);         DBG(m);         FOR(i,K) CZ(max_freq[i]);         FOR(i,m)         {             CZ3(a[i],b[i],f[i]);             a[i]--;             b[i]--;             f[i]--;         }         FOR(j,m) inI[j]=0;                  while(1)         {             DBG(vi(inI,inI+m));             FOR(k,K) used[k].clear();             FOR(j,m)             {                 if (inI[j])                 {                     nr[a[j]][b[j]]=j;                     nr[b[j]][a[j]]=j;                     used[f[j]].pb(j);                 }             }             DBG("doned");             FOR(i,n) kr[i].clear();             FOR(i,n) p[i]=i;             FOR(j,m) KR[j].clear();             FOR(j,m)             {                 if (!inI[j]) continue;                 unia(a[j],b[j]);                 kr[a[j]].pb(b[j]);                 kr[b[j]].pb(a[j]);             }                          /*bool doned=0;             FOR(k,n)             {                 if (inI[2*k] || inI[2*k+1]) continue;                 if (szuk(v[k*2].fi)!=szuk(v[k*2].se))                 {                     inI[k*2]=1;                     doned=1;                     break;                 }                 else if (szuk(v[k*2+1].fi)!=szuk(v[k*2+1].se))                 {                     inI[k*2+1]=1;                     doned=1;                     break;                 }             }             if (doned) continue;             */             FOR(j,m)             {                 X1[j]=X2[j]=0;                 if (inI[j])                 {                     int kol=f[j];                     if (used[kol].sz==max_freq[kol])                     {                         FOR(j1,m) if (!inI[j1] && f[j1]==kol) KR[j].pb(j1);                     }                 }                 else                 {                     int x=a[j];                     int y=b[j];                     if (szuk(x)==szuk(y))                     {                         vi pa=get_path(x,y);                         FORE(e,pa) KR[j].pb(*e);                     }                     else                     {                         X2[j]=1;                     }                     if (used[f[j]].sz!=max_freq[f[j]]) X1[j]=1;                 }             }                          if (!seek_path()) break;         }         int wyn=0;         FOR(j,m) wyn+=inI[j];         printf("%d\n",wyn);     }      return 0; } 
 #include <bits/stdc++.h>  #define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++) #define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--) #define REP(i,a) for(int i=0,_a=(a); i<_a; i++) #define EACH(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)  #define DEBUG(x) { cout << #x << " = "; cout << (x) << endl; } #define PR(a,n) { cout << #a << " = "; FOR(_,1,n) cout << a[_] << ' '; cout << endl; } #define PR0(a,n) { cout << #a << " = "; REP(_,n) cout << a[_] << ' '; cout << endl; }  #define sqr(x) ((x) * (x)) using namespace std;  struct Matching {     int n;     vector< vector<int> > ke;     vector< bool > seen;     vector< int > matchL, matchR;      Matching(int n) : n(n), ke(n), seen(n, false), matchL(n, -1), matchR(n, -1) {     }      void addEdge(int u, int v) {         ke[u].push_back(v);     }      bool bpm(int u) {         for(__typeof(ke[u].begin()) v = ke[u].begin(); v != ke[u].end(); ++v) {             if (seen[*v]) continue;             seen[*v] = true;              if (matchR[*v] < 0 || bpm(matchR[*v])) {                 matchL[u] = *v;                 matchR[*v] = u;                 return true;             }         }         return false;     }      int match() {         int res = 0;         for(int i = 0; i < n; ++i) {             for(int i = 0; i < n; ++i) seen[i] = false;             if (bpm(i)) ++res;         }         return res;     } };  int main() {     ios :: sync_with_stdio(false);     int n, m;     while (cin >> n >> m) {         Matching match(n);         FOR(i,1,m) {             int u, v; cin >> u >> v;             --u; --v;             match.addEdge(u, v);             match.addEdge(v, u);         }         cout << n - match.match() << endl;     }     return 0; } 
//Coder: Balajiganapathi //#define TRACE #define DEBUG  #include <algorithm> #include <bitset> #include <deque> #include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <utility> #include <vector>  using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pi; typedef vector<string> vs;  // Basic macros #define st          first #define se          second #define all(x)      (x).begin(), (x).end() #define ini(a, v)   memset(a, v, sizeof(a)) #define re(i,s,n)  	for(int i=s;i<(n);++i) #define rep(i,s,n)  for(int i=s;i<=(n);++i) #define fr(i,n)     re(i,0,n) #define repv(i,f,t) for(int i = f; i >= t; --i) #define rev(i,f,t)  repv(i,f - 1,t) #define frv(i,n)    rev(i,n,0) #define pu          push_back #define mp          make_pair #define sz(x)       (int)(x.size())  const int oo = 2000000009; const double eps = 1e-9;  #ifdef TRACE     #define trace1(x)                cerr << #x << ": " << x << endl;     #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;     #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;     #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;     #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;     #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else      #define trace1(x)     #define trace2(x, y)     #define trace3(x, y, z)     #define trace4(a, b, c, d)     #define trace5(a, b, c, d, e)     #define trace6(a, b, c, d, e, f)  #endif  ll n, k, mod;  inline ll add(ll a, ll b) {     a += b;     if(a >= mod) a -= mod;      return a; }  inline ll sub(ll a, ll b) {     if(b) b = mod - b;     return add(a, b); }  inline ll mult(ll a, ll b) {     ll ret = 0;     for(; b; b /= 2) {         if(b & 1) ret += a;         a += a;         if(ret >= mod) ret -= mod;         if(a >= mod) a -= mod;     }      return ret; }  ll modpow(ll a, ll b) {     ll ret = 1;     a %= mod;     for(; b; b /= 2) {         if(b & 1) ret = mult(ret, a);         a = mult(a, a);     }      return ret; }  const int mat_mx = 15; const int log_mx = 50; ll mat[log_mx][mat_mx][mat_mx], res[mat_mx][mat_mx];  void disp_mat(int dim, ll m[mat_mx][mat_mx]) { #ifdef TRACE     fr(i, dim) {         fr(j, dim) cerr << m[i][j] << " ";         cerr << endl;     } #endif }  void mat_mult(int dim, ll res[mat_mx][mat_mx], ll a[mat_mx][mat_mx], ll b[mat_mx][mat_mx]) {     static ll tmp[mat_mx][mat_mx];     for(int i = 0; i < dim; ++i) for(int j = 0; j < dim; ++j) {         tmp[i][j] = 0;         for(int k = 0; k < dim; ++k) {             tmp[i][j] += mult(a[i][k], b[k][j]);             if(tmp[i][j] >= mod) tmp[i][j] -= mod;         }     }       for(int i = 0; i < dim; ++i) for(int j = 0; j < dim; ++j) res[i][j] = tmp[i][j]; }  void mat_v_mult(int dim, ll res[mat_mx], ll a[mat_mx][mat_mx], ll b[mat_mx]) {     static ll tmp[mat_mx];     for(int i = 0; i < dim; ++i) {         tmp[i] = 0;         for(int j = 0; j < dim; ++j) {             tmp[i] += mult(a[i][j], b[j]);             if(tmp[i] >= mod) tmp[i] -= mod;         }     }      for(int i = 0; i < dim; ++i) res[i] = tmp[i]; }  void mat_pow(int dim, ll res[mat_mx][mat_mx], ll a[mat_mx][mat_mx], ll p) {     static ll tmp[mat_mx][mat_mx], tres[mat_mx][mat_mx];      for(int i = 0; i < dim; ++i) for(int j = 0; j < dim; ++j) tres[i][j] = (i == j) % mod;     for(int i = 0; i < dim; ++i) for(int j = 0; j < dim; ++j) tmp[i][j] = a[i][j];      for(; p; p /= 2) {         if(p & 1) mat_mult(dim, tres, tres, tmp);         mat_mult(dim, tmp, tmp, tmp);     }           for(int i = 0; i < dim; ++i) for(int j = 0; j < dim; ++j) res[i][j] = tres[i][j]; }  ll v[mat_mx], resv[mat_mx];  void build_mat() {     int dim = k + 2;     mat[0][0][0] = 1 % mod;     rep(i, 1, k) {         mat[0][i][0] = mat[0][i][i] = 1 % mod;         re(j, 1, i) mat[0][i][j] = add(mat[0][i - 1][j], mat[0][i - 1][j - 1]);     }     mat[0][k + 1][k] = mat[0][k + 1][k + 1] = 1 % mod;      fr(i, dim - 1) v[i] = 1 % mod;     v[dim - 1] = 0;      for(int i = 1; (1ll << i) <= n; ++i) mat_mult(dim, mat[i], mat[i - 1], mat[i - 1]); }  ll getsum(ll till) {     trace1(till);     int dim = k + 2;     fr(i, dim) resv[i] = v[i];      for(int i = 0; (1ll << i) <= till; ++i) if(till & (1ll << i)) {         mat_v_mult(dim, resv, mat[i], resv);         trace1(i);     }      return resv[dim - 1]; }  vi divs; ll ans;  void calc_div(ll n) {     for(ll p = 2; p * p <= n; ++p) if(n % p == 0) {         divs.pu(p);         n /= p;         while(n % p == 0) n /= p;     }      if(n > 1) divs.pu(n); }  void calc(ll sofar, int idx, int sign) {     if(idx == sz(divs)) {         ll cur = mult(modpow(sofar, k), getsum(n / sofar));         if(sign == -1 && cur) cur = mod - cur;         ans += cur;         if(ans >= mod) ans -= mod;          return;     }     calc(sofar * divs[idx], idx + 1, sign * -1);     calc(sofar, idx + 1, sign); }  int main() {     cin >> n >> k >> mod;     build_mat();     calc_div(n);     calc(1, 0, 1);     printf("%lld\n", ans);      	return 0; } 
#include <set> #include <stdio.h> #include <math.h>   using namespace std;   int gcd(int a, int b) {     int c;     while(b)     {         c=b;         b=a%b;         a=c;       }       return a; }   #define MAX 100000   char slozen[MAX];   int prost[10000]; int brProstih;   #if 0   int djel(int n, int *a) {     int i,koliko=0;       for(i=1;i*i<n;i++)         if (n%i==0)         {             a[koliko++]=i;             a[koliko++]=n/i;         }     if (i*i==n)         a[koliko++]=i;       return koliko; }     #else   int djel(int n,int *a) {     int i,koliko=1;       a[0]=1;       for(i=0;i<brProstih && prost[i]*prost[i]<=n;i++)     {         int q,temp,prod;           for(q=0;n%prost[i]==0;q++,n/=prost[i]);           if (!q) continue;           temp=koliko;         prod=prost[i];           while(q--)         {             int j;             for(j=0;j<koliko;j++)                 a[temp++]=a[j]*prod;               prod*=prost[i];         }           koliko=temp;     }       if (n>1)     {         int j;         for(j=0;j<koliko;j++)             a[j+koliko]=a[j]*n;           koliko*=2;     }         return koliko; }   #endif     void kvad(long long n) {     long long a[4];     long long r[9]={0};     int i,j,temp;       for(i=0;i<4;i++)     {         a[i]=n%1000000;         n/=1000000;     }       for(i=0;i<4;i++)         for(j=0;j<4;j++)             r[i+j]+=a[i]*a[j];         temp=0;     for(i=0;i<9;i++)     {         r[i]+=temp;         temp=r[i]/1000000;         r[i]%=1000000;     }       for(i=8;i>0 && !r[i];i--);     printf("%lld",r[i]);     for(i--;i>=0;i--)         printf("%06lld",r[i]);     printf("\n");     }     int main() {     int t;         int i,j;         for(i=2;i*i<MAX;i++)         if (!slozen[i])             for(j=i*i;j<MAX;j+=i)                 slozen[j]=1;       for(i=2;i<MAX;i++)         if (!slozen[i])             prost[brProstih++]=i;       scanf("%d",&t);       while(t--)     {           set < pair<long long,long long> > parovi;           int n;           long long k;           int g;             int u,a,b;         long long p,q;         int m;           int i,j;         int polje1[1000],polje2[1000];         int koliko1,koliko2;                     scanf("%d %lld",&n,&k);           if (n==0)         {             kvad(k-1);             continue;         }             u=20;             g=n/u;     #if 1             for(m=1;m<=g;m++)         {             int i,j,r,nn,mm;               r=gcd(m,n);             mm=m/r;             nn=n/r;               koliko1=djel(nn+mm*(n-1),polje1);             koliko2=djel(nn,polje2);               for(i=0;i<koliko2;i++)             {                 int nd;                 nd=nn/polje2[i];                 for(j=0;j<koliko1;j++)                 {                     if ((nd+polje1[j])%mm==0)                     {                         q=(long long)(nd+polje1[j])/mm*polje2[i];                         p=n*(q+n-1);                         if (p%(m*q-n)==0)                         {                             p/=m*q-n;                             if (p<k-n && q<k-n)                             {                                 parovi.insert(make_pair(p,q));                                 parovi.insert(make_pair(q,p));                             }                         }                     }                       if ((nd-polje1[j])%mm==0)                     {                         q=(nd-polje1[j])/mm*polje2[i];                         p=n*(q+n-1);                         if (p%(m*q-n)==0)                         {                             p/=m*q-n;                             if (p<k-n && q<k-n && p>0 && q>0)                             {                                 parovi.insert(make_pair(p,q));                                 parovi.insert(make_pair(q,p));                             }                         }                     }                 }             }         }     #endif       #if 1           g=u*(n-1+u);           for(i=1;i*i<g;i++)         {             int p,q,nn,pp,r;               p=u+i;               r=gcd(n,p);             pp=p/r;             nn=n/r;               for(j=pp-(u+n-1)%pp;i*j<g;j+=pp)             {                 q=u+j;                   if (p<k-n && q<k-n && (long long)nn*(p+q+n-1)%(pp*q)==0)                 {                     parovi.insert(make_pair(p,q));                     parovi.insert(make_pair(q,p));                 }             }         }             for(i=1;i*i<g && i<u;i++)         {             int p,q,nn,pp,r;                 for(j=i;i*j<g && j<u;j++)             {                 p=u-i;                 q=u-j;                   if(p<k-n && q<k-n && (long long)n*(p+q+n-1)%(p*q)==0)                 {                     parovi.insert(make_pair(p,q));                     parovi.insert(make_pair(q,p));                 }             }         }   #endif       #if 1         koliko1=djel(n,polje1);           for(q=1;q<=u && q<k-n;q++)         {             koliko2=djel(q+n-1,polje2);               for(i=0;i<koliko1;i++)                 for(j=0;j<koliko2;j++)                 {                     long long v;                       v=(long long)polje1[i]*polje2[j];                       if ((v+n)%q==0)                     {                         p=n*(q+n-1)/v;                           if (p>0 && p<k-n)                         {                             parovi.insert(make_pair(p,q));                             parovi.insert(make_pair(q,p));                         }                     }                 }                 }       #endif           printf("%d\n",parovi.size());     }       return 0; } 
#include <stdio.h> #include <math.h> #include <memory.h> long long p,u; int t,d,a,ans,w,dd; int main() { scanf("%d",&t); while (t--) { scanf("%lld",&p); w = (int)(sqrt(1.0+p)+1); dd = (int)(sqrt(1.0+p+w)+1); ans = 1; for (d=1;d<=dd;d++) { u = p/d+1; a = u*d-p; if (d <= u && (d+1) % a == 0 && u > a) ans += 2; if (a == 1 && p > 2 && u > d) ans += 2; if (d < u && (u+1) % a == 0 && d > a) ans += 2; } printf("%d\n",3*ans+5); } }
#include <algorithm> #include <cstdio> #include <iostream> #include <map> #include <string> #include <vector> using namespace std;   enum {VAR, NEGVAR, CONJ, DISJ};   struct Node {   char var[8];   int type;   Node* lc, * rc; };   char e[50001]; map<string, double> vprob;   Node* parse_term(int& i, bool neg); Node* parse_fact(int& i, bool neg);   Node* parse_expr(int& i, bool neg) {   Node* nd1 = parse_term(i, neg);   while (isspace(e[i])) i++;   if (!e[i]) return nd1;   if (e[i] != 'o' || e[i+1] != 'r' || isalpha(e[i+2]))     return nd1;   i += 2;   Node* nd2 = parse_expr(i, neg);   Node* nd = new Node;   nd->type = (neg ? DISJ : CONJ);   nd->lc = nd1; nd->rc = nd2;   return nd; }   Node* parse_term(int& i, bool neg) {   Node* nd1 = parse_fact(i, neg);   while (isspace(e[i])) i++;   if (!e[i]) return nd1;   if (e[i] != 'a' || e[i+1] != 'n' || e[i+2] != 'd' || isalpha(e[i+3]))     return nd1;   i += 3;   Node* nd2 = parse_term(i, neg);   Node* nd = new Node;   nd->type = (neg ? CONJ : DISJ);   nd->lc = nd1; nd->rc = nd2;   return nd; }   Node* parse_fact(int& i, bool neg) {   while (isspace(e[i])) i++;     if (e[i] == 'n' && e[i+1] == 'o' && e[i+2] == 't' && !isalpha(e[i+3])) {     i += 3;     return parse_fact(i, !neg);   }     if (e[i] == '(') {     i++;     Node* nd = parse_expr(i, neg);     if (e[i] == ')') i++;     return nd;   }     Node* nd = new Node;   nd->type = (neg ? NEGVAR : VAR);   int j;   for (j = 0; isalpha(e[i]); j++)     nd->var[j] = e[i++];   nd->var[j] = 0;   vprob[nd->var] = 0;   return nd; }   void destroy_node(Node* nd) {   if (nd->type == CONJ || nd->type == DISJ) {     destroy_node(nd->lc);     destroy_node(nd->rc);   }   delete nd; }   void print_node(Node* nd) {   if (nd->type == CONJ || nd->type == DISJ) {     putchar('(');     print_node(nd->lc);     putchar(nd->type == CONJ ? '|' : '&');     print_node(nd->rc);     putchar(')');   } else {     if (nd->type == NEGVAR) putchar('!');     printf("%s", nd->var);   } }   bool conjcmp(const pair<double, double>& a, const pair<double, double>& b) {   return a.first / a.second < b.first / b.second; }   bool disjcmp(const pair<double, double>& a, const pair<double, double>& b) {   return a.first / (1.0-a.second) < b.first / (1.0-b.second); }   pair<double, double> calc(Node* nd); void gather(Node* nd, vector<pair<double, double> >& v, int type) {   if (nd->type != type) {     v.push_back(calc(nd));   } else {     gather(nd->lc, v, type);     gather(nd->rc, v, type);   } }   pair<double, double> calc(Node* nd) {   if (nd->type == VAR || nd->type == NEGVAR) { //printf("%s: c=%.3lf p=%.3lf\n", nd->var, 1.0, nd->type == VAR ? vprob[nd->var] : 1.0 - vprob[nd->var]);     return make_pair(1.0, nd->type == VAR ? vprob[nd->var] :                                              1.0 - vprob[nd->var]);   }   vector<pair<double, double> > v;   gather(nd, v, nd->type);   pair<double, double> ret(0.0, 1.0);   if (nd->type == CONJ) {     sort(v.begin(), v.end(), conjcmp);     for (int i = v.size()-1; i >= 0; i--) {       ret.first *= 1.0-v[i].second;       ret.first += v[i].first;       ret.second *= 1.0-v[i].second;     }     ret.second = 1.0-ret.second;   } else {     sort(v.begin(), v.end(), disjcmp);     for (int i = v.size()-1; i >= 0; i--) {       ret.first *= v[i].second;       ret.first += v[i].first;       ret.second *= v[i].second;     }   } //print_node(nd); //printf(": c=%.3lf p=%.3lf\n", ret.first, ret.second);   return ret; }   main() {   int T;   for (scanf("%d", &T); T--;) {     scanf(" %[^\n]", e);     int i;     vprob.clear();     Node* nd = parse_expr(i = 0, false);     for (i = 0; i < vprob.size(); i++) {       char var[10];       double prob;       scanf(" %s %lf", var, &prob);       vprob[var] = prob;     } //print_node(nd); //putchar('\n');     printf("%.6lf\n", calc(nd).first); //putchar('\n');     destroy_node(nd);   } }
#include <stdio.h> #include <stdlib.h> #include <math.h> #include <map>  using namespace std;  #define USE_BRUTE_FORCE 0 #define MMAX 1048576  map<pair<int, int>, int> m; map<pair<int, int>, int>::const_iterator it; int fibo[MMAX], xfibo[MMAX], sfibo[MMAX], sxfibo[MMAX], sxxfibo[MMAX], sxyfibo[MMAX]; int clen, i, j, k, ans, z, M, cntmax; long long N, Cold, C, v, C1, C2, C3, C4, CS1, CS2, CS3;  long long Sum1(long long x) { 	long long a = x, b = x + 1; 	if ((a & 1) == 0) a >>= 1; 	else b >>= 1; 	a %= M; b %= M; 	return (a * b) % M; }  long long Sum2(long long x) { 	long long a = x, b = x + 1, c = 2 * x + 1; 	if ((a & 1) == 0) a >>= 1; 	else b >>= 1; 	if ((a % 3) == 0) a /= 3; 	else if ((b % 3) == 0) b /= 3; 	else c /= 3; 	a %= M; b %= M; c %= M; 	return (((a * b) % M) * c) % M; }  long long Sum3(long long x) { 	long long s1 = Sum1(x); 	return (s1 * s1) % M; }  long long Sum4(long long x) { // x * (x+1) * (2x+1) * (3*x^2 + 3*x - 1) / 30 	long long a = x, b = x + 1, c = 2 * x + 1, d = (3 * x - 1 + 3 * (x % 5) * (x % 5)); 	if ((a & 1) == 0) a >>= 1; 	else b >>= 1; 	if ((a % 3) == 0) a /= 3; 	else if ((b % 3) == 0) b /= 3; 	else c /= 3; 	int ddiv5 = 0; 	if ((a % 5) == 0) a /= 5; 	else if ((b % 5) == 0) b /= 5; 	else if ((c % 5) == 0) c /= 5; 	else { 		d /= 5; 		ddiv5 = 1; 	}  	if (ddiv5) { 		// dnew = d + (3 * (5 * x/5 + x%5) * (5 * x/5 + x%5) - 3 * (x%5) * (x%5)) / 5 		long long xdiv5 = (x / 5) % M; 		long long e = (15 * xdiv5) % M; 		e = (e * xdiv5) % M; 		long long f = (6 * xdiv5) % M; 		f = (f * (x % 5)) % M; 		d = (d + e + f) % M; 	} else { 		long long xmodm = x % M; 		d = (3 * xmodm * xmodm) % M; 		d = (d + 3 * xmodm - 1 + M) % M; 	}  	a %= M; b %= M; c %= M; 	return (((((a * b) % M) * c) % M) * d) % M; }  long long S1() { 	long long w = (((C + 1) % M) * C1) % M; 	w = (w + M - C2) % M; 	return w; }  long long S2() { 	long long v1 = ((C % M) * ((C + 1) % M)) % M; 	v1 = (v1 * C1) % M; 	long long v2 = (2 * C + 1) % M; 	v2 = (v2 * C2) % M; 	v1 -= v2; 	if (v1 < 0) v1 += M; 	v1 += C3; 	if (v1 >= M) v1 -= M; 	return v1; }  long long S3() { 	long long v0 = ((C % M) * S2()) % M; 	long long v1 = ((C % M) * ((C + 1) % M)) % M; 	v1 = (v1 * C2) % M; 	long long v2 = (2 * C + 1) % M; 	v2 = (v2 * C3) % M; 	v1 -= v2; 	if (v1 < 0) v1 += M; 	v1 += C4; 	if (v1 >= M) v1 -= M; 	v0 -= 2 * v1; 	while (v0 < 0) v0 += M; 	return v0; }  int bfibo[MMAX], bsum[MMAX];  void BruteForce1() { 	int i, j, k; 	bfibo[0] = 0; 	bfibo[1] = 1; 	for (i = 2; i <= N; i++) { 		bfibo[i] = bfibo[i - 1] + bfibo[i - 2]; 		if (bfibo[i] >= M) bfibo[i] -= M; 	} 	 	long long bfans = 0, tmp; 	for (i = 1; i <= N; i++) 		for (j = 1; i + j <= N; j++) { 			k = N - i - j; 			tmp = ((6 * i) % M); 			tmp = (tmp * j) % M; 			tmp = (tmp * k) % M; 			tmp = (tmp * bfibo[i]) % M; 			tmp = (tmp * bfibo[j]) % M; 			tmp = (tmp * bfibo[k]) % M; 			bfans = (bfans + tmp) % M; 		} 	fprintf(stderr, "bfans1=%lld\n", bfans); }  void BruteForce2() { 	int x, y, z, p, q, r; 	bfibo[0] = 0; 	bfibo[1] = 1; 	for (i = 2; i <= N; i++) { 		bfibo[i] = bfibo[i - 1] + bfibo[i - 2]; 		if (bfibo[i] >= M) bfibo[i] -= M; 	}  	for (i = 0; i < MMAX; i++) 		bsum[i] = 0;  	long long bfans = 0, tmp; 	for (x = 0; x < clen; x++) 		for (y = 0; y < clen && x + y <= N; y++) { 			k = x + y; 			z = (N - k) % clen; 			C = (N - k) / clen; 			for (p = 0; p <= C; p++) 				for (q = 0; p + q <= C; q++) { 					r = C - p - q; 					tmp = ((6 * (x + p * clen)) % M); 					tmp = (tmp * (y + q * clen)) % M; 					tmp = (tmp * (z + r * clen)) % M; 					tmp = (tmp * fibo[x]) % M; 					tmp = (tmp * fibo[y]) % M; 					tmp = (tmp * fibo[z]) % M; 					bfans = (bfans + tmp) % M; 					bsum[k] = (bsum[k] + tmp) % M; 				} 		} 	fprintf(stderr, "bfans2=%lld\n", bfans); }  int tcnt[MMAX][2], scnt[MMAX][2];  int main() { 	if (USE_BRUTE_FORCE) 		freopen("x.txt", "r", stdin); 	int T, large_test = 0; 	scanf("%d", &T);  	while (T--) { 		scanf("%d %lld", &M, &N); 		if (M == 1 || N <= 2) { 			printf("0\n"); 			continue; 		}  		//if (USE_BRUTE_FORCE && N <= 10000) BruteForce1();		 		fibo[0] = xfibo[0] = 0; 		fibo[1] = xfibo[1] = 1; 		m.clear(); 		m[make_pair(fibo[0], fibo[1])] = 0; 	 		for (i = 2; i <= N; i++, clen++) { 			fibo[i] = (fibo[i - 2] + fibo[i - 1]) % M; 			xfibo[i] = ((long long) i * fibo[i]) % M; 			it = m.find(make_pair(fibo[i - 1], fibo[i]));  			if (it != m.end()) { 				if (it->second != 0) return 3; 				break; 			} 			m[make_pair(fibo[i - 1], fibo[i])] = i - 1; 		}  		clen = i - 1; 		//if (clen >= 290000) large_test = 1; 		 		if (USE_BRUTE_FORCE) fprintf(stderr, "M=%d clen=%d\n", M, clen); 		if (USE_BRUTE_FORCE && N <= 10000) BruteForce2();  		cntmax = 2 * clen; 		if (cntmax >= MMAX) return 1; 	 		for (i = clen; i < cntmax; i++) { 			fibo[i] = (fibo[i - 2] + fibo[i - 1]) % M; 			xfibo[i] = ((long long) i * fibo[i]) % M; 		}  		for (i = 0; i < cntmax; i++) 			sfibo[i] = sxfibo[i] = sxxfibo[i] = sxyfibo[i] = 0;  		for (i = 2; i < cntmax; i++) { 			sfibo[i] = (sfibo[i - 1] + sfibo[i - 2] + fibo[i - 1]) % M; 			if (i == 2) { 				tcnt[i][0] = tcnt[i][1] = 1; 				scnt[i][0] = 1; scnt[i][1] = 0; 			} else { 				tcnt[i][0] = tcnt[i - 1][1]; 				scnt[i][0] = ((long long) scnt[i - 1][1] + (long long) tcnt[i][0] * (long long) (i - 1)) % M; 				tcnt[i][1] = (tcnt[i - 1][0] + tcnt[i - 1][1]) % M; 				scnt[i][1] = (scnt[i - 1][0] + scnt[i - 1][1]) % M; 			} 			sxfibo[i] = (scnt[i][0] + scnt[i][1]) % M; 			sxxfibo[i] = ((long long) (i - 1) * (long long) fibo[i - 1]) % M; 			sxxfibo[i] = ((long long) (i - 1) * (long long) sxxfibo[i]) % M; 			sxxfibo[i] = (sxxfibo[i] + sxxfibo[i - 2] + sxxfibo[i - 1]) % M; 			sxyfibo[i] = ((long long) i * (long long) sxfibo[i] - sxxfibo[i] + M) % M; 		}  		// Compute the sum (x + p * clen) * (y + q * clen) + (z + r * clen) * fibo[x] * fibo[y] * fibo[z], where: 		// - 0 <= x, y, z < clen 		// - x + y = k (k - fixed, between 0 and 2 * clen - 2) 		// - z = (N - k) % clen (z - fixed) 		// - p + q + r = C 		// - C = (N - k) / clen (C - fixed) 		Cold = -1;  		long long clen2 = ((long long) clen * (long long) clen) % M; 		long long clen3 = (clen2 * (long long) clen) % M; 		long long Cdif1, Cdif2, Cdif3; 		 		for (ans = 0, k = 0; k <= 2 * (clen - 1) && k <= N; k++) { 			z = (N - k) % clen; 			C = (N - k) / clen; 			if (C != Cold) { 				C1 = Sum1(C); 				C2 = Sum2(C); 				C3 = Sum3(C); 				C4 = Sum4(C); 				CS1 = S1(); 				CS2 = S2(); 				CS3 = S3(); 				Cdif1 = (Sum1(C + 1) - ((2 * C + 1) % M) + M) % M; 				Cdif2 = (CS1 - ((C + 2 * Sum1(C - 1)) % M) + M) % M; 				Cdif3 = (CS1 - C1 + M) % M; 				Cold = C; 			}  			long long zfiboz = ((long long) z * (long long) fibo[z]) % M;  			if (k <= clen - 2 && k + clen <= N) { 				// (x * y * fibo[x] * fibo[y]) * z * fibo[z] 				v = ((long long) ((N - k) % M) * (long long) fibo[z]) % M; 				v = (v * 6 * (long long) sxyfibo[k]) % M; 				ans += v; 				if (ans >= M) ans -= M; 				 				if (C >= 2) { 					// (x * y * fibo[x] * fibo[y]) * z * fibo[z] 					v = (zfiboz * 6 * (long long) sxyfibo[k]) % M; 					v = (v * Cdif1) % M; 					ans -= v; 					if (ans < 0) ans += M; 		 					// (x * y * fibo[x] * fibo[y]) * r * clen * fibo[z] 					v = ((long long) sxyfibo[k] * (long long) clen) % M; 					v = (v * (long long) fibo[z]) % M; 					v = (v * 6 * Cdif2) % M; 					ans -= v; 					if (ans < 0) ans += M; 		 					// (x * fibo[x] * fibo[y]) * q * clen * z * fibo[z] 					v = ((long long) sxfibo[k] * (long long) clen) % M; 					v = (v * zfiboz) % M; 					v = (v * 12 * Cdif3) % M; 					ans -= v; 					if (ans < 0) ans += M; 		 					// (x * fibo[x] * fibo[y]) * q * r * clen^2 * fibo[z] 					v = ((long long) sxfibo[k] * clen2) % M; 					v = (v * (long long) fibo[z]) % M; 					v = (v * (6 * CS2 - 12 * (((C % M) * C1 - C2 + M) % M) + 12 * M)) % M; 					ans -= v; 					if (ans < 0) ans += M; 					 					// (fibo[x] * fibo[y]) * p * q * clen^2 * z * fibo[z] 					v = ((long long) sfibo[k] * clen2) % M; 					v = (v * zfiboz) % M; 					v = (v * 3 * CS2) % M; 					ans -= v; 					if (ans < 0) ans += M; 					 					// (fibo[x] * fibo[y]) * p * q * r * clen^3 * fibo[z] 					v = ((long long) sfibo[k] * clen3) % M; 					v = (v * (long long) fibo[z]) % M; 					v = (v * 3 * CS3) % M; 					ans -= v; 					if (ans < 0) ans += M; 					//fprintf(stderr, "B6 k=%d: v=%lld\n", k, v); 				}  				continue; 			}  			// (x * y * fibo[x] * fibo[y]) * z * fibo[z] 			v = (zfiboz * 6 * (long long) sxyfibo[k]) % M; 			v = (v * Sum1(C + 1)) % M; 			ans += v; 			if (ans >= M) ans -= M;  			// (x * y * fibo[x] * fibo[y]) * r * clen * fibo[z] 			v = ((long long) sxyfibo[k] * (long long) clen) % M; 			v = (v * (long long) fibo[z]) % M; 			v = (v * 6 * CS1) % M; 			ans += v; 			if (ans >= M) ans -= M;  			// (x * fibo[x] * fibo[y]) * q * clen * z * fibo[z] 			v = ((long long) sxfibo[k] * (long long) clen) % M; 			v = (v * zfiboz) % M; 			v = (v * 12 * CS1) % M; 			ans += v; 			if (ans >= M) ans -= M;  			// (x * fibo[x] * fibo[y]) * q * r * clen^2 * fibo[z] 			v = ((long long) sxfibo[k] * clen2) % M; 			v = (v * (long long) fibo[z]) % M; 			v = (v * 6 * CS2) % M; 			ans += v; 			if (ans >= M) ans -= M; 			 			// (fibo[x] * fibo[y]) * p * q * clen^2 * z * fibo[z] 			v = ((long long) sfibo[k] * clen2) % M; 			v = (v * zfiboz) % M; 			v = (v * 3 * CS2) % M; 			ans += v; 			if (ans >= M) ans -= M; 			 			// (fibo[x] * fibo[y]) * p * q * r * clen^3 * fibo[z] 			v = ((long long) sfibo[k] * clen3) % M; 			v = (v * (long long) fibo[z]) % M; 			v = (v * 3 * CS3) % M; 			ans += v; 			if (ans >= M) ans -= M; 		}  		printf("%d\n", ans); 	}  	return large_test; } 
#include<iostream> #include<cassert> #include<cstdlib> #include<cstring> #include<utility> #include<sstream> #include<algorithm> #include<cstdio> #include<vector> #include<string> #include<cctype> #include<queue> #include<deque> #include<stack> #include<cmath> #include<ctime> #include<list> #include<map> #include<set> #define pi (acos(-1.0)) #define Abs(a) (((a)<0) ? (-(a)) :(a) ) #define rep(i,n) for((i)=0;(i)<(n);(i)++) #define Rep(i,n) for(int i=0;i<(n);i++) #define Rrep(i,n) for(int i=n-1;i>=0;i--) #define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--) #define Pii pair<int,int> #define PB push_back #define Size(x) ((int)(x.size())) #define Sinesum(a,b,n)  (sin(((b)/2.0)*((n)+1))*sin((a)+((n)*(b))/2.0))/sin((b)/2.0) #define Cossum(a,b,n) (sin(((b)/2.0)*((n)+1))*cos((a)+((n)*(b))/2.0))/sin((b)/2.0) #define SZ 200005 using namespace std; typedef long long mint; typedef unsigned long long umint; int l[SZ],r[SZ],d[SZ],lazy[4*SZ+5]; double ssum[4*SZ+5],cssum[4*SZ+5],si[4*SZ+5],cs[4*SZ+5]; set<Pii > s; inline double fSinesum(int st,int add,int n) {     if(add==0||n<0)         return (n+1)*sin(st);     return Sinesum(st,add,n); } inline double fCossum(int st,int add,int n) {     if(add==0||n<0)         return (n+1)*cos(st);     return Cossum(st,add,n); } void build(int l,int r,int node) {     if(l==r)     {         ssum[node]=si[l];         cssum[node]=cs[l];         return ;     }     int mid=(l+r)/2;     build(l,mid,2*node);     build(mid+1,r,2*node+1);     ssum[node]=ssum[2*node]+ssum[2*node+1];     cssum[node]=cssum[2*node]+cssum[2*node+1]; } inline double Smodi(double sn,double cs,int ext) {     return sn*cos(ext)+cs*sin(ext); } inline double Cmodi(double sn,double cs,int ext) {     return cs*cos(ext)-sn*sin(ext); } double query(int l,int r,int lft,int rght,int node,int sm) {     //cout<<l<<" "<<r<<" "<<lft<<" "<<rght<<" "<<ssum[node]<<" "<<lazy[node]<<endl;     if(l>rght||r<lft)         return 0.0;     if(lft>=l&&rght<=r)         return Smodi(ssum[node],cssum[node],sm+lazy[node]);     int mid=(lft+rght)/2;     return query(l,r,lft,mid,2*node,sm+lazy[node])+query(l,r,mid+1,rght,2*node+1,sm+lazy[node]); } void update(int l,int r,int lft,int rght,int val,int node) {     //cout<<l<<" "<<r<<" "<<lft<<" "<<rght<<" "<<ssum[node]<<" "<<cssum[node]<<" "<<lazy[node]<<endl;     if(l>rght||r<lft)         return;     if(lft>=l&&rght<=r)     {         lazy[node]+=val;         return ;     }     int mid=(lft+rght)/2;     update(l,r,lft,mid,val,2*node);     update(l,r,mid+1,rght,val,2*node+1);     ssum[node]=Smodi(ssum[2*node],cssum[2*node],lazy[2*node])+Smodi(ssum[2*node+1],cssum[2*node+1],lazy[2*node+1]);     cssum[node]=Cmodi(ssum[2*node],cssum[2*node],lazy[2*node])+Cmodi(ssum[2*node+1],cssum[2*node+1],lazy[2*node+1]);     //cout<<lft<<" "<<rght<<" "<<ssum[node]<<" "<<cssum[node]<<" "<<lazy[2*node]<<" "<<lazy[2*node+1]<<endl; } int main() {     //freopen("in.txt","r",stdin);     int n,q,i,a,b;     scanf("%d%d",&n,&q);     rep(i,q)     {         scanf("%d%d%d",&l[i],&r[i],&d[i]);         if(l[i]>r[i])             swap(l[i],r[i]);         s.insert(Pii(l[i],0));         s.insert(Pii(r[i]+1,0));     }     i=1;     set<Pii >::iterator it=s.begin();     int prev=it->first;     it++;     for(;it!=s.end();)     {         si[i]=fSinesum(prev,1,it->first-prev-1);         cs[i]=fCossum(prev,1,it->first-prev-1);         prev=it->first;         s.insert(Pii(it->first,i));         s.erase((s.find(Pii(prev,0))));         it=s.upper_bound(Pii(prev,i));         i++;     }     build(1,s.size()-1,1);     rep(i,q)     {         a=s.lower_bound(Pii(l[i]+1,0))->second;         b=s.lower_bound(Pii(r[i]+1,0))->second;         if(d[i]==0)             printf("%.12lf\n",query(a,b,1,s.size()-1,1,0));         else             update(a,b,1,s.size()-1,d[i],1);     }     return 0; }   
#include <cstdio> #include <cmath> #include <algorithm>   using namespace std; const int max_n = 50, max_v = max_n * max_n * 4, max_e = max_v * 4 * 2; struct Edge { 	int v; 	int f; 	int c; 	Edge* p; 	Edge* next; 	void Add(int v, int c, Edge* &head, Edge* p) { 		this->v = v; 		this->f = 0; 		this->c = c; 		this->next = head; 		this->p = p; 		head = this; 	} } edges[max_e]; Edge* h[max_v]; Edge* w[max_v]; int a[max_n][max_n]; int st[max_v]; int was[max_v]; Edge* p[max_v]; const int di[4] = {-1, 1, 0, 0}; const int dj[4] = {0, 0, -1, 1};   void AddEdge(int v1, int v2, int c, Edge* &e) { 	(e + 0)->Add(v2, c, h[v1], e + 1); 	(e + 1)->Add(v1, 0, h[v2], e + 0); 	e += 2; } struct Pair { 	int v, h; 	void Init(int v, int h) { 		this->v = v; 		this->h = h; 	} 	bool operator < (const Pair &p) const { 		return h < p.h; 	} } b[4]; int s, t; int dfs(int i, int d) { 	if (i == t) return d; 	for (;w[i]; w[i] = w[i]->next) { 		if (w[i]->f < w[i]->c && was[i] + 1 == was[w[i]->v]) { 			int c = dfs(w[i]->v, min(d, w[i]->c - w[i]->f)); 			if (c) { 				w[i]->f += c; 				w[i]->p->f -= c; 				return c; 			} 		} 	} 	return 0; } int main() { #ifdef pperm 	freopen("input.txt", "r", stdin); #endif 	int T; 	scanf("%d", &T); 	while (T--) { 		int n, m; 		scanf("%d %d", &n, &m); 		int sr, sc, tr, tc; 		scanf("%d %d %d %d", &sr, &sc, &tr, &tc); 		sr--,sc--; 		tr--,tc--; 		for (int i = 0; i < n; i++) { 			for (int j = 0; j < m; j++) { 				scanf("%d", &a[i][j]); 			} 		} 		if (a[sr][sc] < a[tr][tc]) { 			printf("0\n"); 			continue; 		} 		if (abs(sr - tr) + abs(sc - tc) <= 1) { 			printf("-1\n"); 			continue; 		} 		for (int i = 0; i < n * m; i++) { 			h[i] = 0; 		} 		Edge* e = edges; 		s = sr * m + sc, t = tr * m + tc; 		int nV = n * m; 		for (int i = 0; i < n; i++) { 			for (int j = 0; j < m; j++) { 				int u = 0; 				int v0 = i * m + j; 				for (int dir = 0; dir < 4; dir++) { 					int r = i + di[dir], c = j + dj[dir]; 					if (r >= 0 && r < n && c >= 0 && c < m && a[r][c] >= a[i][j]) { 						int v = r * m + c; 						if (t == v0) { 							b[u++].Init(nV, int(2e9)); 						} else { 							b[u++].Init(nV, a[r][c] - a[i][j] + 1); 						} 						h[nV] = 0; 						AddEdge(v, nV++, int(2e9), e); 					} 				} 				if (u) { 					sort(b, b + u); 					AddEdge(b[0].v, v0, b[0].h, e); 					for (int i = 1; i < u; i++) { 						AddEdge(b[i].v, b[i - 1].v, b[i - 1].h, e); 						AddEdge(b[i].v, v0, b[i].h - b[i - 1].h, e); 					} 				} 			} 		} 		int flow = 0; 		n = nV; 		while (1) { 			for (int i = 0; i < n; i++) { 				was[i] = 0; 				w[i] = h[i]; 			} 			was[s] = 1; 			st[0] = s; 			p[s] = 0; 			for (int down = 0, up = 1; down < up; down++) { 				int i = st[down]; 				if (i == t) { 					break; 				} 				for (Edge* e = h[i]; e; e = e->next) { 					if (e->f < e->c && !was[e->v]) { 						was[e->v] = was[i] + 1; 						st[up++] = e->v; 					} 				} 			} 			if (was[t]) { 				for (int d; d = dfs(s, int(1e9));) { 					flow += d; 				} 			} else { 				break; 			} 		} 		printf("%d\n", flow); 	} 	return 0; } 
#include <iostream> #include <cstring> #include <vector> #include <algorithm> #include <cassert> using namespace std;  #define sq 300 #define maxn 1000010 #define mod 1000000007  struct Solution { 	int maxv1, maxv2; 	int nr1, nr2;  	void update(Solution &other) 	{ 		if (other.maxv1 >= maxv1) 		{ 			if (maxv1 != other.maxv1) 			{ 				maxv2 = maxv1; 				nr2 = nr1; 			}  			if (maxv1 == other.maxv1) 				nr1 = (nr1 + other.nr1)%mod; 			else nr1 = other.nr1;  			maxv1 = other.maxv1;  			if (other.maxv2 == maxv2) 				nr2 = (nr2 + other.nr2)%mod; 			else if (other.maxv2 > maxv2) 			{ 				maxv2 = other.maxv2; 				nr2 = other.nr2; 			} 		} 		else if (other.maxv1 > maxv2) 		{ 			nr2 = other.nr1; 			maxv2 = other.maxv1; 		} 		else if (other.maxv1 == maxv2) 		{ 			nr2 = (nr2 + other.nr1)%mod; 		} 	}  	Solution() 	{ 		nr1 = nr2 = 0; 		maxv1 = 0; 		maxv2 = -1; 	} }aib[maxn]; int a[maxn], maxv;  int LSB(int i) { 	return i&(-i); }  void update (int i, Solution &sol) { 	for (; i <= maxv; i += LSB(i)) 	{ 		aib[i].update(sol); 	} }  Solution query (int i) { 	Solution s; 	for (; i > 0; i -= LSB(i)) 	{ 		s.update(aib[i]); 	} 	return s; }  int main() { 	//freopen("test.in","r",stdin); 	int test; 	cin >> test;  	for (;test; --test) 	{ 		int n; 		cin >> n;  		vector<pair<int,int> >sorter; 		for (int i = 1; i <= n; ++i) 		{ 			cin >> a[i]; 			sorter.push_back(make_pair(a[i],i)); 		} 		sort(sorter.begin(), sorter.end());  		maxv = 0; 		for (int i = 0; i < sorter.size(); ++i) 		{ 			if (i == 0 || sorter[i].first != sorter[i-1].first) 				++maxv; 			a[sorter[i].second] = maxv; 		}  		for (int i = 1; i <= maxv; ++i) 		{ 			Solution s; 			aib[i] = s; 		}  		Solution ans; 		for (int i = 1; i <= n; ++i) 		{ 			Solution sol = query(a[i]-1); 			sol.maxv1++; 			sol.maxv2++; 			if (sol.maxv1 == 1) 				++sol.nr1; 			if (sol.maxv2 == 1) 				++sol.nr2; 			ans.update(sol); 			update(a[i], sol); 		}  		cout << ans.nr2 << "\n"; 	} } 
#include<cstdio> #include<cstring> #include<vector> using namespace std; vector<int> sizes[21]; int BITCNT[1<<20], NEIGH[1<<20], firstbit[1<<20], G[20], S, n, sol, best, ALL, FOUND; inline void I(int &a) {  register int c;  a=0;  do c=getchar_unlocked(); while(c<'0');  do  {   a=(a<<1)+(a<<3)+c-'0';   c=getchar_unlocked();  }while(c >= '0'); } inline void O(int a) {  register char s[11];  register int t = -1;  do s[++t]=a%10+'0',a/=10; while(a>0);  while(t>=0) putchar_unlocked(s[t--]);  putchar_unlocked(' '); } inline int verifySet(int s0, int curs) { 	const int DEFENDERS = NEIGH[s0] & curs; 	const int ATTACKERS = NEIGH[s0] & (~curs); 	return BITCNT[DEFENDERS] >= BITCNT[ATTACKERS]; } inline bool checkSolution(int curs) { 	if (BITCNT[curs] < (n+1)/2 || NEIGH[curs] != ALL) return 0; 	for (int s0=curs;s0>0;s0=(s0-1)&curs) if (!verifySet(s0,curs)) return 0;	return 1; } int can(int size) { 	for (int i=sizes[size].size()-1;i>=0;--i) 		if (checkSolution(sizes[size][i])) { 			best = size; 			sol = sizes[size][i]; 			return 1; 		} 	return 0; } int main() { 	for (int i=0;i<(1<<20);++i) { 		BITCNT[i] = 0; 		for (int j=0;j<20;++j) if ((1<<j)&i) { 			firstbit[i] = j;			BITCNT[i] = BITCNT[i^(1<<j)] + 1;			break;		} 		sizes[BITCNT[i]].push_back(i); 	} 	int r; 	while (2==scanf("%d %d", &n, &r)) { 		if (n==0 && r==0) break; 		S = 0, ALL = (1<<n)-1, best = n, sol = ALL, FOUND = 0; 		memset(G,0,sizeof G); 		for (int i=0;i<n;++i) G[i] |= (1<<i); 		for (int i=0;i<r;++i) { 			int x,y; 			I(x); I(y); 			G[n-1-x] |= (1<<(n-1-y)); 			G[n-1-y] |= (1<<(n-1-x)); 		} 		NEIGH[0] = 0; 		for (int i=1;i<(1<<n);++i) NEIGH[i] = NEIGH[i^(1<<firstbit[i])] | G[firstbit[i]]; 		int lo = (n+1)/2, hi = n-1; 		for (int i=lo;i<=hi;++i) if (can(i)) break; 		O(best); 		for (int i=n-1;i>=0;--i) if ((1<<i)&sol) O(n-1-i); 		printf("\n"); 	} } 
#include <cstdio> #include <vector>  #define MOD 1000000007  std::vector<int> BINOM[10001];  inline int modulo (int a) {     if (a >= MOD) a-= MOD;     return a; }  inline int npok (int n, int k) {     if (k < 0) return 0;     if (k + k > n) k = n - k;          if (k == 0) return 1;          if (n % 3 == 0) return BINOM[n/3][k];     else return modulo (npok(n-1,k) + npok(n-1,k-1)); }  void precompute () {     BINOM[0].push_back (1);          for (int i = 3; i <= 20000; i += 3)     {         int current = i / 3;         BINOM[current].resize ( 1 + i / 2);         BINOM[current][0] = 1;         BINOM[current][1] = i;         for (int j = 2; j + j <= i; ++j)         {             int x = npok(i-3,j - 3);             int y = npok(i-3,j - 2) ;             y = modulo (modulo (y + y) + y);             int z = npok(i-3,j - 1);             z = modulo (modulo (z + z) + z);             int t = npok(i-3,j);             BINOM[current][j] = modulo (modulo ( modulo (x + y) + z) + t);         }     } }  int n, k; int A[30]; int DP[23][32][21000];  int gogo (int a, int b, int c) {     if (a + 1 == b) return 1;     else     {         if (DP[a][b][c] == -1)         {             DP[a][b][c] = 0;                          if (a % 2 == b % 2)             {                 // przypadki ze tylko dzielimy                 long long ret = 0;                 for (int h = a + 1; h < b; h += 2)                 {                     int elements = A[b] - A[a] + 1 - c - 1 - (b!=k-1) - (a!=0);                     int howmany = A[h] - A[a] + 1 - 1 - c - (a!=0);                      int aa = gogo (a,h,c);                      int bb = gogo (h,b,0);                     int cc = npok (elements,howmany);                     ret += cc * (((long long)(aa) * bb) % MOD);         			if (ret > 1000000000000000000LL) ret %= MOD;                 }                 DP[a][b][c] = ret % MOD;             }             else             {                 // przypadki ze dzielimy i odcinamy przycinamy prefiks                                long long ret = 0;                                  // dzielimy                 for (int h = a + 2; h < b; h += 2)                 {                     int elements = A[b] - A[a] + 1 - c - 1 - (b!=k-1) - (a!=0);                     int howmany = A[h] - A[a] + 1 - 1 - c - (a!=0);                     int aa = gogo (a,h,c);                     int bb = gogo (h,b,0);                     int cc = npok (elements,howmany);                     ret += cc * (((long long)(aa) * bb) % MOD);         			if (ret > 1000000000000000000LL) ret %= MOD;                 }                 // przycinamy prefiks                 if (A[a] + c + (a != 0) < A[a + 1])                     ret += gogo (a,b,c + 1);                  DP[a][b][c] = ret % MOD;             }         }                  return DP[a][b][c];     } }  void doit () {          scanf ("%d %d", &n, &k);     for (int i = 0; i < k; ++i)      {         scanf ("%d", &A[i]);         A[i]--;     }          for (int i = 0; i < k; ++i)         for (int j = i + 1; j < k; ++j)             for (int h = 0; h < A[j] - A[i] + 1; ++h)                 DP[i][j][h] = -1;        printf ("%d\n", gogo (0, k - 1, 0));     }  int main () {     precompute ();               int tests;     scanf ("%d", &tests);     while (tests--) doit ();                        return 0; } 
/**  * June 2013 Long Challenge at Codechef  *  * Problem:  SPMATRIX - Count Special Matrices  * Author:   Anton Lunyov (Problem-Setter)  * Timing:   0.420 out of 0.666  */ #include <cstdio>  typedef long long LL;  const int maxN = 10000000; const int MOD = 1000000007;  int f[maxN+1];  int main() {   f[1] = f[2] = 0;   f[3] = 1;   int half = (MOD - 1) / 2;   int b = half;   int a = (MOD + 1) / 2 + 1;   int t = 3;   int s = a;   for (int n = 3; n < maxN; ++n) {     t += n;         if (t >= MOD) t -= MOD;     s += n + half;  if (s >= MOD) s -= MOD;     a = LL(a) * t % MOD;     b = LL(b) * s % MOD;     f[n+1] = (LL(t) * f[n] + a + b) % MOD;   }   int T;   scanf("%d", &T);   for(int t=0;t<T;t++) {     int n;     scanf("%d", &n);     printf("%d\n",f[n]);   }   return 0; } 
#include <bits/stdc++.h> using namespace std;  typedef long long int ll; typedef pair<ll, ll> pii; typedef pair<pii, pii> D;  #define MaxN 100001 #define mp make_pair  vector<pii> decr[MaxN], incr[MaxN]; int _decr[MaxN], _incr[MaxN]; ll shortest[MaxN]; void solve() {   priority_queue<D> Q;   ll x, y, wt, key, j, v;   int src, snk, N, M;   scanf("%d%d", &N, &M);   for (int i = 1; i <= N; i++)     decr[i].clear(), incr[i].clear(), _decr[i] = 0, _incr[i] = 0,                                       shortest[i] = 1LL << 60;   for (int i = 1; i <= M; i++) {     scanf("%lld%lld%lld", &x, &y, &wt);     decr[x].push_back(mp(-wt, y));     decr[y].push_back(mp(-wt, x));     incr[x].push_back(mp(wt, y));     incr[y].push_back(mp(wt, x));   }   scanf("%d%d", &src, &snk);   for (int i = 1; i <= N; i++) {     sort(decr[i].begin(), decr[i].end());     sort(incr[i].begin(), incr[i].end());   }   // Every Entry is key,steps,incroming edge wt,vertex   Q.push(mp(mp(0, 0), mp(0, src)));   while (!Q.empty()) {     D front = Q.top();     Q.pop();     v = front.second.second;     wt = front.second.first;     key = -front.first.first;     shortest[v] = min(key, shortest[v]);     if (front.first.second & 1) {       for (j = _incr[v]; j < incr[v].size(); j++) {         if (wt > incr[v][j].first) {           Q.push(mp(mp(-(key + incr[v][j].first), 0),                     mp(incr[v][j].first, incr[v][j].second)));         } else           break;       }       _incr[v] = j;     } else {       for (j = _decr[v]; j < decr[v].size(); j++) {         if (wt < -(decr[v][j].first)) {           Q.push(mp(mp(-(key - decr[v][j].first), 1),                     mp(-decr[v][j].first, decr[v][j].second)));         } else           break;       }       _decr[v] = j;     }     if (shortest[snk] != (1LL << 60)) break;   }   if (shortest[snk] != (1LL << 60))     printf("%lld\n", shortest[snk]);   else     printf("No Solution\n"); }  int main() {   int T;   scanf("%d", &T);   while (T--) solve();   return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <algorithm> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <cstdlib> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cassert> #include <climits> #include<stdint.h> //#include <ext/hash_map>   using namespace std; using namespace __gnu_cxx;    #define REP(i,n) for(int i = 0; i < int(n); ++i) #define REPV(i, n) for (int i = (n) - 1; (int)i >= 0; --i) #define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)  #define FE(i,t) for (__typeof((t).begin())i=(t).begin();i!=(t).end();++i) #define FEV(i,t) for (__typeof((t).rbegin())i=(t).rbegin();i!=(t).rend();++i)  #define two(x) (1LL << (x)) #define ALL(a) (a).begin(), (a).end()   #define pb push_back #define ST first #define ND second #define MP(x,y) make_pair(x, y)  typedef long long ll; typedef uint_fast64_t ull; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<string> vs;  template<class T> void checkmin(T &a, T b){if (b<a)a=b;} template<class T> void checkmax(T &a, T b){if (b>a)a=b;} template<class T> void out(T t[], int n){REP(i, n)cout<<t[i]<<" "; cout<<endl;} template<class T> void out(vector<T> t, int n=-1){for (int i=0; i<(n==-1?t.size():n); ++i) cout<<t[i]<<" "; cout<<endl;} inline int count_bit(int n){return (n==0)?0:1+count_bit(n&(n-1));} inline int low_bit(int n){return (n^n-1)&n;} inline int ctz(int n){return (n==0?-1:ctz(n>>1)+1);} int toInt(string s){int a; istringstream(s)>>a; return a;} string toStr(int a){ostringstream os; os<<a; return os.str();}  const ull mod=4294967143LU; const ull s2=533310557; const int nb=8; const int maxm=1<<nb; const int MASK=maxm-1; const int maxb=64/nb+1; int dest[4]={     0,1,     1,0,     };  int prod[4]={     1,1,     1,3,     };  inline void mul(ull *a, ull *b, ull *c){     c[0]=(a[0]*b[0]%mod+a[1]*b[1]%mod*3)%mod;     c[1]=a[0]*b[1]%mod+a[1]*b[0]%mod;     if (c[1]>=mod) c[1]-=mod;     //REP(i,2){     //    ull v=a[i];     //    REP(j,2){     //        int u=2*i+j;     //        int d=dest[u];     //        c[d]=(c[d]+prod[u]*v%mod*b[j]%mod)%mod;     //    }     //} } inline void add(ull *a, ull *b, ull *c){     c[0]=a[0]+b[0];     if (c[0]>=mod) c[0]-=mod;     c[1]=a[1]+b[1];     if (c[1]>=mod) c[1]-=mod; }   ull faste(ull a, ull p=mod-2){ull x=1; for (; p; p>>=1, a=a*a%mod) if (p&1) x=x*a%mod; return x;}  ull XP[5][maxb][maxm][2]; ull ai[5][2], ci[5][2]; ull res, tmp[2], tmp2[2];   int main(){     int tn; cin>>tn;     ci[0][0]=7*faste(4)%mod;     ci[1][0]=11*faste(6)%mod*s2%mod;     ci[2][1]=23*faste(12)%mod;      ci[3][0]=(mod-25)*faste(24)%mod*s2%mod;     ci[3][1]=23*faste(24)%mod*s2%mod;      ci[4][0]=25*faste(24)%mod*s2%mod;     ci[4][1]=23*faste(24)%mod*s2%mod;       ull i2=faste(2);     ai[0][0]=1;     ai[1][0]=s2;     ai[2][1]=1;     ai[3][0]=(mod-i2)*s2%mod; ai[3][1]=i2*s2%mod;     ai[4][0]=i2*s2%mod; ai[4][1]=i2*s2%mod;       REP(i,5){          REP(j,maxb) XP[i][j][0][0]=1;         REP(j,maxm-1) mul(XP[i][0][j],ai[i],XP[i][0][j+1]);         FOR(j,1,maxb){             mul(XP[i][j-1][maxm-1],XP[i][j-1][1],XP[i][j][1]);             FOR(k,1,maxm-1) mul(XP[i][j][k],XP[i][j][1],XP[i][j][k+1]);         }     }       REP(ti,tn){         ull n; scanf(" %Lu",&n);         --n;         if (n&1){             res=0;             REP(i,5){                 int pw=0;                 ull p=n;                  memset(tmp2,0,sizeof(tmp2));                 tmp2[0]=1;                 while(p){                     mul(XP[i][pw][p&MASK],tmp2,tmp);                     REP(j,2) tmp2[j]=tmp[j];                     ++pw;                     p>>=nb;                 }                  mul(tmp2,ci[i],tmp);                 res=(res+tmp[0])%mod;             }             printf("%Lu\n",res);         }else printf("0\n");     }     return 0; }  
#include<cstdio> #include<iostream> #include<ctime> #include<algorithm> using namespace std;   bool OK[255][255]; char s[35][255]; int len[35]; int n,m; int opt[255]; string tmp[35]; char flag[255][255][35][25];   bool cmp(const string a,const string b) { 	return a.size()<b.size(); }   bool dfs(int l,int r,int a,int b) { 	if (flag[l][r][a][b]) return flag[l][r][a][b]==1?1:0; 	if (b==len[a] && l>r) {flag[l][r][a][b]=1;return 1;} 	if (l>r) {flag[l][r][a][b]=2;return 0;} 	if (b==len[a]) {flag[l][r][a][b]=2;return 0;} 	if (r-l+1<len[a]-b) {flag[l][r][a][b]=2;return 0;} 	 	if (s[0][l]==s[a][b+1]) 		if (dfs(l+1,r,a,b+1)) {flag[l][r][a][b]=1;return 1;} 	for (int i=l;i<r;i++) 	if (OK[l][i]) 	if (dfs(i+1,r,a,b)) {flag[l][r][a][b]=1;return 1;} 	flag[l][r][a][b]=2;return 0; }   int main() { 	//freopen("input.txt","r",stdin);   	cin >> tmp[0];len[0]=n=tmp[0].size(); 	for (int i=0;i<n;i++) s[0][i+1]=tmp[0][i]; 	scanf("%d",&m); 	for (int i=1;i<=m;i++) cin >> tmp[i]; 	sort(tmp+1,tmp+1+m,cmp);   	for (int i=1;i<=m;i++) 	{ 		len[i]=tmp[i].size(); 		for (int j=0;j<len[i];j++) s[i][j+1]=tmp[i][j]; 	} 	for (int i=1;i<=n;i++) 	for (int j=1;j<=m;j++) 	if (i+len[j]-1<=n) 	{ 		bool f=1; 		for (int k=1;k<=len[j];k++) f&=s[0][i+k-1]==s[j][k]; 		OK[i][i+len[j]-1]|=f; 	}   	 	int sign=0; 	for (int k=2;k<=n;k++) 	for (int i=1,j=k;j<=n;i++,j++) 	if (!OK[i][j]) 	{ 		for (int a=1;!OK[i][j] && a<=m;a++) 		if (k>=len[a] && s[0][j]==s[a][len[a]]) 			OK[i][j]|=dfs(i,j,a,0); 	}   	for (int i=1;i<=n;i++) opt[i]=n; 	for (int i=0;i<n;i++) 	{ 		if (opt[i]+1<opt[i+1]) opt[i+1]=opt[i]+1; 		for (int j=i+1;j<=n;j++) 		if (OK[i+1][j] && opt[j]>opt[i]) 			opt[j]=opt[i]; 	} 	printf("%d\n",opt[n]); //	printf("%0.9lf\n",(double)clock()/CLOCKS_PER_SEC); //	system("pause"); } 
#include <iostream> #include <cstdio> #include <cstring>  using namespace std; typedef long long LL; #define M 8388608*2 int n , m , nodecnt; int ch[M][2]; LL LK[M] , LB[M]; LL K[M] , B[M];   int newnode() {     ++ nodecnt;     K[nodecnt] = 0 , B[nodecnt] = -1LL << 60;     return nodecnt; } #define MID int mid = (l + r) >> 1 #define Left l , mid #define Right mid + 1 , r  void add(int& p , int l , int r , int top , int bot , LL a , LL b) {     if (!p) p = newnode();     if (top <= l && r <= bot) {         LK[p] += a , LB[p] += b;         return;     } MID;     if (top <= mid) add(ch[p][0] , Left , top , bot , a , b);     if (bot > mid) add(ch[p][1] , Right , top , bot , a , b); } void update(int& p , int l , int r , int top , int bot , LL a , LL b) {     if (top > bot) return;     if (!p) p = newnode();     if (top <= l && r <= bot) {         bool f1 = K[p] * l + B[p] >= a * l + b;         bool f2 = K[p] * r + B[p] >= a * r + b;         if (f1 && f2)             return;         else if (!f1 && !f2) {             K[p] = a , B[p] = b;             return;         } else {             MID;             bool f3 = K[p] * mid + B[p] >= a * mid + b;             if (f1) {                 if (f3)                     update(ch[p][1] , Right , Right , a , b);                 else {                     update(ch[p][0] , Left , Left , K[p] , B[p]);                     K[p] = a , B[p] = b;                 }             } else {                 if (f3)                     update(ch[p][0] , Left , Left , a , b);                 else {                     update(ch[p][1] , Right , Right , K[p] , B[p]);                     K[p] = a , B[p] = b;                 }             }         }         return;     } MID;     if (top <= mid) update(ch[p][0] , Left , top , bot , a , b);     if (bot > mid) update(ch[p][1] , Right , top , bot , a , b); }  pair<LL , LL> ans; void query(int p , int l , int r , int x) {     if (!p) return;     ans.first += LK[p] * x + LB[p];     ans.second = max(ans.second , K[p] * x + B[p]);     if (l == r) {         return;     } MID;     if (x <= mid)         query(ch[p][0] , Left , x);     else         query(ch[p][1] , Right , x); }  int main() {     int root = 0 , i , u , v ;     LL a , b;     scanf("%d%d",&n,&m);     while (m --) {         scanf("%d",&i);         if (i == 3) {             scanf("%d",&u);             ans = make_pair(0 , -1LL << 60);             query(root , 0 , n - 1 , u - 1);             if (ans.second <= -1LL << 60)                 puts("NA");             else                 printf("%lld\n" , ans.first + ans.second);         } else {             scanf("%d%d%lld%lld",&u,&v,&a,&b);             -- u , -- v;             b -= a * u;             if (i == 1)                 update(root , 0 , n - 1 , u , v , a , b);             else                 add(root , 0 , n - 1 , u , v , a , b);         }     }     return 0; } 
#include <iostream> #include <vector> #include <string> #include <cstdlib>  using namespace std;  struct Node {   int y;   int l, r, p;   int size;    Node(): y(rand()), l(-1), r(-1), p(-1), size(1) {}; };  struct Stack {   vector<char> str;   vector<Node> nodes;   int root;    Stack() {     nodes.push_back(Node());     root = 0;   }    void push(char c) {     str.push_back(c);     nodes.push_back(Node());     root = setP(insert(root, str.size(), getIndex(str.size() - 1)), -1);   }    void debug() {     debug(root, -1);     cout << "---" << endl;   }    void debug(int tree, int p) {     if (tree == -1) {       return;     }     if (nodes[tree].p != p) {       throw 42;     }     debug(nodes[tree].l, tree);     string s = "";     for (int i = 0; i < tree; ++i) {       s += str[i];     }     cout << tree << " " << s << " " << nodes[tree].p << " " << nodes[tree].l          << " " << nodes[tree].r << " " << nodes[tree].size << " "          << nodes[tree].y << endl;     debug(nodes[tree].r, tree);   }    char pop() {     root = setP(remove(root, getIndex(str.size())), -1);     nodes.pop_back();     char back = str.back();     str.pop_back();     return back;   }    int size() {     return str.size();   }    void reset() {     str.resize(0);     nodes.resize(0);     nodes.push_back(Node());     root = 0;   }    int match(const string& q, bool rev) {     return match(root, q, false, false, rev);   }  // tree    int size(int id) {     return id == -1 ? 0 : nodes[id].size;   }    int setP(int node, int p) {     if (node == -1) {       return -1;     }     nodes[node].p = p;     return node;   }    int fixSize(int node) {     if (node == -1) {       return -1;     }     nodes[node].size = 1 + size(nodes[node].l) + size(nodes[node].r);     return node;   }    int getIndex(int id) {     int r = size(nodes[id].l);     while (nodes[id].p != -1) {       int p = nodes[id].p;       if (id == nodes[p].r) {         r += size(nodes[p].l) + 1;       }       id = p;     }     return r;   }    int compare(int tree, int node, int indexNode1) {     int cmp;     if (tree == 0) {       cmp = 1;     } else {       cmp = str[node - 1] - str[tree - 1];     }     if (cmp == 0) {       cmp = indexNode1 - getIndex(tree - 1);     }     return cmp;   }    int insert(int tree, int node, int indexNode1) {     if (tree == -1) {       return node;     }     if (nodes[tree].y < nodes[node].y) {       split(tree, node, indexNode1);       setP(nodes[node].l, node);       setP(nodes[node].r, node);       return fixSize(node);     }     int cmp = compare(tree, node, indexNode1);     if (cmp < 0) {       nodes[tree].l = setP(insert(nodes[tree].l, node, indexNode1), tree);     } else if (cmp > 0) {       nodes[tree].r = setP(insert(nodes[tree].r, node, indexNode1), tree);     } else {       cout << tree << " " << node << " " << indexNode1 << endl;       throw 42;     }     return fixSize(tree);   }    void split(int tree, int node, int indexNode1) {     if (tree == -1) {       return;     }     int cmp = compare(tree, node, indexNode1);     if (cmp < 0) {       split(nodes[tree].l, node, indexNode1);       nodes[tree].l = setP(nodes[node].r, tree);       nodes[node].r = tree;     } else if (cmp > 0) {       split(nodes[tree].r, node, indexNode1);       nodes[tree].r = setP(nodes[node].l, tree);       nodes[node].l = tree;     } else {       cout << tree << " " << node << " " << indexNode1 << " " << cmp << endl;       throw 42;     }     fixSize(tree);   }    int remove(int tree, int pos) {     if (tree == -1) {       throw 42;     }     int sl = size(nodes[tree].l);     if (pos < sl) {       nodes[tree].l = setP(remove(nodes[tree].l, pos), tree);     } else if (pos > sl) {       nodes[tree].r = setP(remove(nodes[tree].r, pos - sl - 1), tree);     } else {       //cout << "del " << tree << " " << str.size() << endl;       return merge(nodes[tree].l, nodes[tree].r);     }     return fixSize(tree);   }    int merge(int l, int r) {     if (l == -1) {       return r;     } else if (r == -1) {       return l;     } else if (nodes[l].y < nodes[r].y) {       nodes[r].l = setP(merge(l, nodes[r].l), r);       return fixSize(r);     } else {       nodes[l].r = setP(merge(nodes[l].r, r), l);       return fixSize(l);     }   }    int match(int tree, const string& q, bool matchLeft, bool matchRight, bool rev) {     if (matchLeft && matchRight) {       return size(tree);     }     if (tree == -1) {       return 0;     }     for (int i = 0; i < q.size(); ++i) {       if (i == tree || str[tree - i - 1] < q[rev ? i : q.size() - i - 1]) {         return match(nodes[tree].r, q, false, matchRight, rev);       } else if (str[tree - i - 1] > q[rev ? i : q.size() - i - 1]) {         return match(nodes[tree].l, q, matchLeft, false, rev);       }     }     return 1 +       match(nodes[tree].l, q, matchLeft, true, rev) +       match(nodes[tree].r, q, true, matchRight, rev);   } };  struct Deque {   Stack a, b;    void pushLeft(char c) {     a.push(c);   }    char popLeft() {     if (!a.size()) {       equalize(a, b);     }     return a.pop();   }    void pushRight(char c) {     b.push(c);   }    char popRight() {     if (!b.size()) {       equalize(b, a);     }     return b.pop();   }    void equalize(Stack& a, Stack& b) {     string tmp = "";     int n = b.size();     for (int i = 0; i < n / 2; ++i) {       tmp += b.pop();     }     while (b.size()) {       a.push(b.pop());     }     for (int i = tmp.size() - 1; i >= 0; --i) {       b.push(tmp[i]);     }   }    int size() {     return a.size() + b.size();   }    string toString() {     string s = "";     for (int i = a.size() - 1; i >= 0; --i) {       s += a.str[i];     }     s += "^";     for (int i = 0; i < b.size(); ++i) {       s += b.str[i];     }     return s;   }    char at(int i) {     if (i < a.size()) {       return a.str[a.size() - i - 1];     } else {       return b.str[i - a.size()];     }   }    int match(const string& q, int* pf) {     int ret = a.match(q, true) + b.match(q, false);     int pr = 0;     for (int i = min(a.size() - 1, (int)q.size() - 2); i >= 0; --i) {       char c = a.str[i];       while (pr > 0 && q[pr] != c) {         pr = pf[pr - 1];       }       if (q[pr] == c) pr++;     }     for (int i = 0; i < q.size() - 1 && i < b.size(); ++i) {       char c = b.str[i];       while (pr > 0 && q[pr] != c) {         pr = pf[pr - 1];       }       if (q[pr] == c) pr++;       if (pr == q.size()) {         ret++;         pr = pf[pr - 1];       }     }     return ret;   } };  void evalPf(const string& s, int* pf) {   int n = s.size();   pf[0] = 0;   for (int i = 1; i < n; ++i) {     pf[i] = pf[i - 1];     while (pf[i] && s[i] != s[pf[i]]) {       pf[i] = pf[pf[i] - 1];     }     if (s[i] == s[pf[i]]) {       pf[i]++;     }   } }  Deque deque1; Deque deque2;  int main() {   ios_base::sync_with_stdio(false);   string str0;   cin >> str0;   for (int i = 0; i < 5; ++i) {     deque1.pushRight(str0[i]);   }   for (int i = 5; i < 10; ++i) {     deque2.pushRight(str0[i]);   }   int n;   cin >> n;   for (int it = 0; it < n; ++it) {     string op;     cin >> op;     if (op == "INSERT_LEFT") {       char c;       cin >> c;       deque1.pushLeft(c);     } else if (op == "INSERT_RIGHT") {       char c;       cin >> c;       deque2.pushRight(c);     } else if (op == "INSERT_MIDDLE") {       char c;       cin >> c;       deque1.pushRight(c);     } else if (op == "DELETE_LEFT") {       deque1.popLeft();     } else if (op == "DELETE_RIGHT") {       deque2.popRight();     } else if (op == "DELETE_MIDDLE") {       deque2.popLeft();     } else if (op == "QUERY") {       string q;       cin >> q;       int pf[q.size()];       evalPf(q, pf);       int ans = deque1.match(q, pf) + deque2.match(q, pf);       int pr = 0;       for (int i = max(0, deque1.size() - (int)q.size() + 1); i < deque1.size(); ++i) {         char c = deque1.at(i);         while (pr > 0 && q[pr] != c) {           pr = pf[pr - 1];         }         if (q[pr] == c) pr++;       }       for (int i = 0; i < deque2.size() && i < q.size() - 1; ++i) {         char c = deque2.at(i);         while (pr > 0 && q[pr] != c) {           pr = pf[pr - 1];         }         if (q[pr] == c) pr++;         if (pr == q.size()) {           ans++;           pr = pf[pr - 1];         }       }       cout << ans << '\n';     } else if (op == "PRINT") {       cout << deque1.toString() << ":" << deque2.toString() << endl;     } else if (op == "DEBUG") {       deque1.a.debug();       deque1.b.debug();       deque2.a.debug();       deque2.b.debug();     } else {       throw 42;     }     while (deque1.size() <= deque2.size() - 2) {       deque1.pushRight(deque2.popLeft());     }     while (deque1.size() > deque2.size()) {       deque2.pushLeft(deque1.popRight());     }     //cout << deque1.toString() << ":" << deque2.toString() << '\n';   }   return 0; } 
#include <bits/stdc++.h> using namespace std; #define vi vector<int> #define pii pair<int,int> #define x first #define y second #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define ll long long  #define ull unsigned long long #define inf 1000000007 #define mod 1000000007 #define N 5005 #define DBG(x) cerr<<(#x)<<"="<<x<<endl; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)  template <class T> inline void Max(T &a,T b){if(a<b)a=b;} template <class T> inline void Min(T &a,T b){if(a>b)a=b;}  inline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}  vi g[N],w[N]; int dfn[N],low[N],s[N],top,cnt,p,vis[N],be[N],v[N]; void tarjan(int u,int fa){     dfn[u]=low[u]=++cnt;s[++top]=u;     for(int i=0;i<g[u].size();i++){         int j=g[u][i];         if(j==fa)continue;         if(!dfn[j]){             tarjan(j,u);low[u]=min(low[u],low[j]);         }         else low[u]=min(low[u],dfn[j]);     }     if(dfn[u]==low[u]){         int j;vi e;         do{             j=s[top--];             e.pb(j);         }while(j!=u);         if(e.size()>2){             p++;             for(j=0;j<e.size();j++)vis[e[j]]=1,be[e[j]]=p,w[p].pb(e[j]);         }     } } int K; int ans=0,dp[N][32],f[32],l[55][32],r[55][32],d[32]; void solve(int x,int y,int z); void dfs(int u,int fa){     //DBG(u)     int x=be[u];     for(int i=0;i<w[x].size();i++){         int j=w[x][i];         v[j]=1;     }     int st=0,len=w[x].size();     for(int i=0;i<w[x].size();i++){         int j=w[x][i];         solve(j,j,1);         if(j==u)st=i;     }     //DBG(ans)     memset(f,0,sizeof(f));f[0]=1;     for(int i=(st+1)%len;i!=st;i=(i+1)%len){         int z=w[x][i];         memset(d,0,sizeof(d));         for(int j=1;j<=K;j++){             for(int k=0;k+j<=K;k++){                 add(d[j+k],1LL*dp[z][j]*f[k]%mod);             }         }         for(int j=2;j<=K;j++)add(ans,d[j]);         for(int j=1;j<=K;j++)f[j]=d[j];     }     //DBG(ans)     memset(d,0,sizeof(d));     int sz=0;     for(int i=0;i<=K;i++)l[sz][i]=dp[u][i];     for(int i=(st-1+len)%len;i!=st;i=(i-1+len)%len){         int z=w[x][i];sz++;         memset(l[sz],0,sizeof(l[sz]));         for(int j=1;j<K;j++)             for(int k=1;k+j<=K;k++)add(l[sz][j+k],1LL*dp[z][k]*l[sz-1][j]%mod);     }     int sz1=0;     int y=(st+1)%len;     for(int i=0;i<=K;i++)r[sz1][i]=dp[w[x][y]][i];     for(int i=(y+1)%len;i!=st;i=(i+1)%len){         int z=w[x][i];sz1++;         memset(r[sz1],0,sizeof(r[sz1]));         for(int j=1;j<K;j++)             for(int k=1;k+j<=K;k++)add(r[sz1][j+k],1LL*dp[z][k]*r[sz1-1][j]%mod);     }     for(int i=0;i<=sz;i++){         for(int j=1;j<=K;j++)add(d[j],l[i][j]);         for(int j=0;j<=sz1&&i+1+j+1<len;j++){             for(int k=1;k<K;k++)                 for(int y=1;y+k<=K;y++)add(d[k+y],1LL*l[i][k]*r[j][y]%mod);         }     }     //DBG(sz)DBG(sz1)DBG(dp[u][2])     //puts("");     for(int i=2;i<=K;i++){         add(ans,d[i]);         //cerr<<u<<" "<<i<<" "<<dp[u][i]<<",,\t";     }     for(int i=1;i<=K;i++)dp[u][i]=d[i];     dp[u][1]=1;     //DBG(ans) }  void solve(int u,int fa,int flag){     memset(dp[u],0,sizeof(dp[u]));     dp[u][1]=1;     v[u]=1;     //DBG(u)     for(int i=0;i<g[u].size();i++){         int j=g[u][i];         if(j==fa||v[j])continue;         if(vis[j])dfs(j,u);         else solve(j,u,0);         memset(f,0,sizeof(f));         for(int x=1;x<K;x++)             for(int y=1;x+y<=K;y++){                 add(f[x+y],1LL*dp[u][x]*dp[j][y]%mod);             }         for(int x=2;x<=K;x++)add(dp[u][x],f[x]);     }     if(!flag)     for(int i=2;i<=K;i++){         add(ans,dp[u][i]);         //cerr<<u<<" "<<i<<" "<<dp[u][i]<<"..\t";     }     //DBG(ans) } int main(){     int T,i,j,k,m,n;     scanf("%d",&T);     while(T--){         scanf("%d%d%d",&n,&m,&K);         for(i=1;i<=n;i++)g[i].clear(),vis[i]=dfn[i]=v[i]=0,w[i].clear();         cnt=0,p=0,top=0;ans=0;         while(m--){             scanf("%d%d",&i,&j);             g[i].pb(j);g[j].pb(i);         }         for(i=1;i<=n;i++)if(!dfn[i]){             tarjan(i,0);         }         for(i=1;i<=n;i++)if(!v[i]){             if(!vis[i])solve(i,0,0);             else dfs(i,0);         }         printf("%d\n",ans+n);     }     return 0; } 
#include <string.h> #include <stdio.h> #include <algorithm> #include <set> #include <queue> #include <math.h> #include <iostream> #define ll long long using namespace std; const int N=2e5+9,M=5e5+9; struct node { 	int next[26],fail,dep; 	int dp; 	void clear() 	{ 		memset(next,0,sizeof(next)); 		fail=dep=0; 	} }a[N<<1]; int sz,en; void init() { 	fill(a[0].next,a[0].next+26,1); 	a[0].dep=-1; 	sz=en=1; 	a[sz++].clear(); } void build(char s[]) { 	init(); 	for(int i=0;s[i];i++) 	{ 		int k=s[i]-'a',p=sz++; 		a[p].clear(); 		a[p].dp=1; 		a[p].dep=a[en].dep+1; 		while(!a[en].next[k]) a[en].next[k]=p,en=a[en].fail; 		int p1=a[en].next[k]; 		if(a[p1].dep==a[en].dep+1) a[p].fail=p1; 		else  		{ 			int p2=sz++; 			a[p2]=a[p1]; 			a[p2].dp=0; 			a[p2].dep=a[en].dep+1; 			a[p].fail=a[p1].fail=p2; 			while(a[en].next[k]==p1) a[en].next[k]=p2,en=a[en].fail; 		} 		en=p; 	} } vector<int> to[N<<1]; char str[N]; void dfs(int x) { 	for(int i=0;i<to[x].size();i++) 	{ 		int t=to[x][i]; 		dfs(t); 		a[x].dp+=a[t].dp; 	} } struct Q { 	int l,p,id,ans; 	void read(){scanf("%d%d",&l,&p);} 	bool operator <(const Q &o) const 	{ 		return p<o.p||p==o.p&&l<o.l; 	} }q[M]; int m; int ar[M]; void add(int i,int v){for(;i<=m;ar[i]+=v,i+=-i&i);} void _add(int s,int t,int v) { 	add(s,v); 	add(t+1,-v); } int sum(int i) { 	int r=0; 	for(;i;r+=ar[i],i-=-i&i);return r; } bool cmp(Q a,Q b) { 	return a.id<b.id; } int main() { 	scanf("%s",str); 	//cout<<str<<endl; 	build(str); 	for(int i=2;i<sz;i++) 	{ 		to[a[i].fail].push_back(i); 	} 	dfs(1); 	//for(int i=2;i<sz;i++) printf("%d: s=%d t=%d\n",a[i].dp,a[a[i].fail].dep+1,a[i].dep); 	 	scanf("%d",&m); 	for(int i=1;i<=m;i++) q[i].read(),q[i].id=i; 	sort(q+1,q+m+1); 	for(int i=2;i<sz;i++) 	{ 		Q now;now.p=a[i].dp; 		now.l=a[a[i].fail].dep+1; 		int is=lower_bound(q+1,q+m+1,now)-q; 		if(is>m) continue; 		if(q[is].p!=now.p) continue; 		now.l=a[i].dep; 		int it=upper_bound(q+1,q+m+1,now)-q; 		if(it==1) continue; 		it--; 		if(is>it) continue; 		_add(is,it,1); 	} 	for(int i=1;i<=m;i++) q[i].ans=sum(i); 	sort(q+1,q+1+m,cmp); 	for(int i=1;i<=m;i++) printf("%d\n",q[i].ans); 	return 0;  }       
#include <iostream> #include <algorithm> #include <cstdio> #include <vector> #include <cstring> #include <string> #include <cmath> #include <utility> #include <map> #include <set> #include <queue> #include <stack> #include <sstream> #define fi first #define se second using namespace std;  struct query { 	int type, x, y, yy; 	 	query() {} 	query(int _type, int _x, int _y, int _yy) 	{ 		type = _type; x = _x; y = _y; yy = _yy; 	} 	 	bool operator < (query u) const 	{ 		if (x != u.x) return x < u.x; 		return type > u.type; 	} };  int n, R, tree[400200]; vector < pair<int,int> > bishop[2], other[2]; pair <int,int> rowRange[400100], colRange[400100];  int range(int x) { 	return n - 1 - abs(x); }  void getMin(int &x, int y) { 	if (y < x) x = y; }  void getMax(int &x, int y) { 	if (y > x) x = y; }  void debug(vector < pair<int,int> > bishop) { 	for (int i = 0; i < int(bishop.size()); i++)  	{ 		cout << bishop[i].fi << ' ' << bishop[i].se << " = "; 		cout << rowRange[i].fi << ' ' << rowRange[i].se << "   "; 		cout << colRange[i].fi << ' ' << colRange[i].se << endl; 	} }  int get(int y) { 	int res = 0; 	for (int i = y + 1; i; i -= i & -i) res += tree[i]; 	return res; }  void add(int y, int val) { 	for (int i = y + 1; i <= R; i += i & -i) tree[i] += val; }  long long solve(vector < pair<int,int> > bishop, vector < pair<int,int> > other) { 	long long res = 0; 	int B = bishop.size(); 	vector < pair< pair<int,int>,int > > obstacle; 	 	for (int i = 0; i < int(other.size()); i++) obstacle.push_back(make_pair(other[i], 0)); 	for (int i = 0; i < B; i++) obstacle.push_back(make_pair(bishop[i], 1)); 	 	for (int i = 0; i < B; i++) 	{ 		int rx = range(bishop[i].fi), ry = range(bishop[i].se); 		rowRange[i] = make_pair(-ry, ry); 		colRange[i] = make_pair(-rx, rx); 	} 	 	int O = obstacle.size(); 	sort(obstacle.begin(), obstacle.end()); 	for (int i = 0; i < B; i++) 	{ 		int x = bishop[i].fi, y = bishop[i].se; 		int j = lower_bound(obstacle.begin(), obstacle.end(), make_pair(bishop[i], 0)) - obstacle.begin(); 		if (j + 1 < O && obstacle[j + 1].fi.fi == x) getMin(colRange[i].se, obstacle[j + 1].fi.se - 2); 		if (j && obstacle[j - 1].fi.fi == x)  		{ 			if (obstacle[j - 1].se) colRange[i].fi = y; 			else getMax(colRange[i].fi, obstacle[j - 1].fi.se + 2); 		} 	} 	 	for (int i = 0; i < O; i++) swap(obstacle[i].fi.fi, obstacle[i].fi.se); 	sort(obstacle.begin(), obstacle.end()); 	for (int i = 0; i < B; i++) 	{ 		int x = bishop[i].fi, y = bishop[i].se; 		int j = lower_bound(obstacle.begin(), obstacle.end(), make_pair(make_pair(y, x), 0)) - obstacle.begin(); 		if (j + 1 < O && obstacle[j + 1].fi.fi == y) getMin(rowRange[i].se, obstacle[j + 1].fi.se - 2); 		if (j && obstacle[j - 1].fi.fi == y)  		{ 			if (obstacle[j - 1].se) rowRange[i].fi = x; 			else getMax(rowRange[i].fi, obstacle[j - 1].fi.se + 2); 		} 	} 	 	// count safe cells 	for (int i = 0; i < B; i++) 	{ 		res += (colRange[i].se - colRange[i].fi) / 2 + 1; 		res += (rowRange[i].se - rowRange[i].fi) / 2 + 1; 	} 	 	// unique row 	vector <int> rowSet; 	for (int i = 0; i < B; i++) rowSet.push_back(bishop[i].se); 	sort(rowSet.begin(), rowSet.end()); 	R = unique(rowSet.begin(), rowSet.end()) - rowSet.begin(); 	rowSet.resize(R); 	 	// construct query 	vector <query> q; 	for (int i = 0; i < B; i++) 	{ 		q.push_back(query(0, bishop[i].fi, colRange[i].fi, colRange[i].se)); 		q.push_back(query(1, rowRange[i].fi, bishop[i].se, 0)); 		q.push_back(query(-1, rowRange[i].se, bishop[i].se, 0)); 	} 	 	sort(q.begin(), q.end()); 	memset(tree, 0, sizeof(tree)); 	 	long long overlapping = 0; 	for (int i = 0; i < int(q.size()); i++) 		if (!q[i].type) // get 		{ 			int yy = upper_bound(rowSet.begin(), rowSet.end(), q[i].yy) - rowSet.begin(); 			int y = lower_bound(rowSet.begin(), rowSet.end(), q[i].y) - rowSet.begin(); 			overlapping += get(yy - 1) - get(y - 1); 		} 		else // update 		{ 			int y = lower_bound(rowSet.begin(), rowSet.end(), q[i].y) - rowSet.begin(); 			add(y, q[i].type); 		} 		 	return res - overlapping; }  int main() { 	//freopen("a.in", "r", stdin); 	int K, M, x, y; 	cin >> n >> K >> M; 	while (K--) 	{ 		scanf("%d%d", &x, &y); 		--x; --y; 		bishop[(x + y) % 2].push_back(make_pair(x - y, x + y - n + 1)); 	} 	while (M--) 	{ 		scanf("%d%d", &x, &y); 		--x; --y; 		other[(x + y) % 2].push_back(make_pair(x - y, x + y - n + 1)); 	} 	 	long long ans = solve(bishop[0], other[0]) + solve(bishop[1], other[1]); 	cout << ans << endl; } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> #include <map> #include <ctime> #include <cstdlib> using namespace std; #define N 300050 #define M 300050 #define ull unsigned long long ull ad[N],val[N],ans; int fi[N],c[N*2][2],ln[M][2],rf[N],fa[N],_Cnt,ss=1,n,m; map <ull,int> li; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } int Find(int x) {return rf[x]==x?x:(rf[x]=Find(rf[x]));} inline void Line(int x,int y)  {  	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	return;  } inline ull GetNew()  {  	return (1uLL*rand()*rand()+10084852983uLL*rand()+998244353);  } void DFS(int x,int y)  {  	for (int i=fi[x];i;i=c[i][1])  	 if (c[i][0]!=y)  	   DFS(c[i][0],x),ad[x]^=ad[c[i][0]];  	if (x!=1) if (ad[x])  	  ans+=li[ad[x]],li[ad[x]]++; else _Cnt++,ans+=m-_Cnt;  	return;  } int main()  {  	n=Read();m=Read();srand(time(NULL));  	for (int i=1;i<=m;i++) ln[i][0]=Read(),ln[i][1]=Read();  	for (int i=1;i<=n;i++) rf[i]=i;  	for (int i=1;i<=m;i++)  	 {  	 	int k=Find(ln[i][0]),l=Find(ln[i][1]);  	 	if (k!=l)  	 	  rf[k]=l,Line(ln[i][0],ln[i][1]); else  	 	  val[i] = GetNew();  	 	ad[ln[i][0]]^=val[i];  	 	ad[ln[i][1]]^=val[i];  	 	if (val[i]) li[val[i]]++;  	 }  	int Cnt=false;  	DFS(1,0);cout <<ans<<endl;  	return 0;  }
#include <cmath> #include <algorithm> #include <vector> #include <iostream> #include <cstdio> #include <set> #include <queue> #include <map> #include <string> #include <cstring> #include <ctime> using namespace std; #define For(i,a,b) for(int i=a;i<=b;i++) #define Ford(i,a,b) for(int i=a;i>=b;i--) #define Rep(i,c) for((type of c.begin()) i;i!=c.end();i++) #define pb push_back #define mp make_pair #define fi first #define se second #define sr(x) (int)x.size() #define modul 1000000007 #define nmax 200010 #define BUG(x) {cout << #x << " = " << x << endl;} #define PR(x,a,b) {cout << #x << " = "; For(_,a,b) cout << x[_] << ' '; cout << endl;} #define fillchar(x,a,b,delta) For(_,a,b) x[_]=delta; #define Bit(s,i) (s&(1<<i)) #define Two(x) (1<<x) #define pii pair<int,int> #define ll long long #define e 1e-6 #define pi acos(-1) int n,m,top; struct node {     int x,y,size,rev;     node *le,*ri,*pa; }; pii st[nmax],a[nmax]; typedef node *pointer; pointer Root; void SetLink(pointer x,pointer p,bool Isleft) {     if (x!=NULL) x->pa=p;     if (p==NULL) return;     if (Isleft) p->le=x; else p->ri=x; } void count(pointer p) {     p->size=abs(p->x-p->y)+1;     if (p->le!=NULL) p->size+=p->le->size;     if (p->ri!=NULL) p->size+=p->ri->size; } void reverse(pointer x) {     x->rev=0;swap(x->x,x->y);     pointer u=x->le;pointer v=x->ri;     if (u!=NULL) {SetLink(u,x,false);u->rev=1-u->rev;} else x->ri=NULL;     if (v!=NULL) {SetLink(v,x,true);v->rev=1-v->rev;} else x->le=NULL;     count(x); } void DFS(pointer R) {     if (R->rev) reverse(R);     if (R->le!=NULL) DFS(R->le);   //  printf("%d %d\n",R->x,R->y);     top++;st[top].fi=R->x;st[top].se=R->y;     if (R->ri!=NULL) DFS(R->ri); }   void uptree(pointer x) {     pointer p=x->pa,pp=p->pa;     if (p->le==x) {         if (x->ri!=NULL) SetLink(x->ri,p,true); else p->le=NULL;         SetLink(p,x,false);     } else {         if (x->le!=NULL) SetLink(x->le,p,false); else p->ri=NULL;         SetLink(p,x,true);     }     if (pp==NULL) x->pa=NULL; else SetLink(x,pp,pp->le==p);     count(p);count(x); } void Splay(pointer &R,pointer x) {     while (x->pa!=NULL) {         pointer p=x->pa,pp=p->pa;         if (pp==NULL) uptree(x);         else if ((pp->le==p)==(p->le==x)) {uptree(p);uptree(x);}         else {uptree(x);uptree(x);}     }     R=x; }  pointer findk(pointer R,int x) {     if (x>R->size) return NULL;     if (R->rev) reverse(R);     int u;if (R->le==NULL) u=0; else u=R->le->size;     int leng=abs(R->x-R->y)+1;     if (u+1==x) return R;     if (u>=x) return findk(R->le,x);     if (u+leng<x) return findk(R->ri,x-u-leng);     int hs;     if (R->x<R->y) hs=1; else hs=-1;     x-=u;     pointer p=new node; p->x=R->x+x*hs-hs;p->y=R->y;     R->y=p->x-hs;     SetLink(R->ri,p,false);p->le=NULL;     SetLink(p,R,false);p->rev=R->rev;     count(p);count(R);     return p; } void Split(pointer &R,int u,int v,pointer &t1,pointer &t2,pointer &t3) {     pointer y=findk(R,v+1);     pointer x=findk(R,u);     Splay(R,x);if (R->le!=NULL) {t1=R->le;R->le=NULL;t1->pa=NULL;count(R);} else t1=NULL;     if (v==n) {t2=R;t3=NULL;return;}     Splay(R,y);t2=R->le;t2->pa=NULL;R->le=NULL;count(R);t3=R; } void anion(pointer &R,pointer p) {     if (R==NULL) {R=p;return;}     if (p==NULL) return;     Splay(p,findk(p,1));     SetLink(R,p,true);R=p;count(R); } void Join(pointer &R,pointer t1,pointer t2,pointer t3) {     R=t1;anion(R,t2);anion(R,t3); }  int get(int x) {     if (x>n) return 0;     int l=1,r=top,pos;     while (l<=r) {         int mid=(l+r)/2;         if (a[mid].fi<=x) {             pos=mid;l=mid+1;         } else r=mid-1;     }     return a[pos].se; }  int check(int u,int v) {     int x=get(u+1),y=get(v+1);     if (x<y) return true;     if (x>y) return false;     if ((u<v)==(st[x].fi<st[x].se)) return true;     return false; }  int pow(int i,int j) {     if (j==1) return 2;     if (j==0) return 1;     int tg=pow(i,j/2);tg=(tg*(ll)tg)%modul;     if (j%2==1) tg=((ll)tg*i)%modul;     return tg; }  int main() {    // freopen("codechef.inp","r",stdin);     scanf("%d%d",&n,&m);     Root=new node; Root->pa=NULL;Root->le=NULL;Root->ri=NULL;Root->size=n;Root->x=1;Root->y=n;Root->rev=0;     For(i,1,m) {         int t,u,v;         scanf("%d%d%d",&t,&u,&v);         pointer t1,t2,t3;         Split(Root,u,v,t1,t2,t3);         if (t==0) Join(Root,t2,t1,t3); else {             t2->rev=1;Join(Root,t1,t2,t3);         }     }     DFS(Root);     int ans=0;     For(i,1,top) {a[i].fi=min(st[i].fi,st[i].se);a[i].se=i;}     sort(a+1,a+top+1);     For(i,1,top) {       //  BUG(i);         if (st[i].fi!=st[i].se) {             ans+=abs(st[i].fi-st[i].se)-1;             if (st[i].fi<st[i].se) ans+=check(st[i].se-1,st[i].se);             else ans+=check(st[i].fi,st[i].fi-1);          //   BUG(ans);         }         if (i==top) continue;         ans+=check(st[i].se,st[i+1].fi);       //  BUG(ans);     }     int res=pow(2,ans);     cout << res;     return 0; }         
#include<bits/stdc++.h> using namespace std;  #define sc( x ) scanf( "%d" , &x ) #define REP( i , n ) for( int i = 0 ; i < n ; ++i ) #define clr( t , val ) memset( t , val , sizeof( t ) )  #define SZ( v ) ((int)(v).size()) #define all( v ) v.begin() , v.end()  #define pb push_back  typedef vector< int > vi; typedef long long ll; typedef vector< ll > vll; typedef vector< vi > vvi;  struct data{ 	ll x , y , xp , yp; 	data(){} 	data( ll x , ll y , ll xp , ll yp ) : x( x ) , y( y ) , xp( xp ) , yp( yp ) {} }; bool operator < ( const data &d1 , const data &d2 ){ 	if( d1.xp != d2.xp ) return d1.xp < d2.xp; 	if( d1.yp != d2.yp ) return d1.yp < d2.yp; 	return 0; } void trans( ll x , ll y , ll &X , ll &Y ){ 	X = x - y; 	Y = x + y; } void RESIZE( vll &v ){ 	sort( all( v ) ); 	v.resize( unique( all( v ) ) - v.begin() ); } struct FT{ 	int MAXVAL; 	vll T;  	FT( int n ){ 	 	T = vll( n + 5 ); 	 	MAXVAL = n + 2; 	} 	 	void upd( int pos , ll val ){ 	    while( pos <= MAXVAL ){ 	        T[ pos ] += val; 	        pos += (pos & -pos);  	    } 	} 	void update( int pos , ll val ){ 		upd( pos + 1 , val ); 	} 	 	ll qry( int pos ){ 	    ll sum = 0; 	    while( pos ){ 	        sum += T[ pos ]; 	        pos -= ( pos & -pos ); 	    } 	    return sum; 	} 	ll query( int pos ){ return qry( pos + 1 );}  	ll up( int pos ){ return query( MAXVAL - 1 ) - query( pos - 1 ); }  	ll down( int pos ){ return query( pos );} }; int getId( vll &v , ll x ){ 	return lower_bound( all( v ) , x ) - v.begin(); }  int main(){ 	int cases; 	sc( cases ); 	REP( tc , cases ){ 		int n , a , b; 		sc( n ); 		sc( a ) , sc( b ); 		vector< data > V; 		vll vx , vy; 		REP( i , n ){ 			int x , y; 			sc( x ) , sc( y ); 			ll X , Y; 			trans( a * x , b * y , X , Y ); 			V.pb( data( a * x , b * y , X , Y ) ); 			vx.pb( X ); 			vy.pb( Y ); 		} 		RESIZE( vx ); 		RESIZE( vy ); 		sort( all( V ) ); 		ll ans = 0; 		vector< FT > VAL( 2 , SZ( vy ) ) , CNT( 2 , SZ( vy ) ); 		 		for( int i = n - 1 ; i >= 0 ; --i ){ 			int ind; 			for( int j = i ; j >= 0 ; --j ) 				if( V[ j ].yp == V[ i ].yp ) ind = j; 				else break; 			ll val = V[ i ].yp; 			int pos = getId( vy , val ); 			for( int j = i ; j >= ind ; --j ){ 				VAL[ 0 ].update( pos , V[ i ].y ); 				VAL[ 1 ].update( pos , V[ i ].x ); 				CNT[ 0 ].update( pos , +1 ); 				CNT[ 1 ].update( pos , +1 ); 				ll L = CNT[ 0 ].down( pos - 1 ) , R = CNT[ 1 ].up( pos ); 				ll SL = VAL[ 0 ].down( pos - 1 ) , SR = VAL[ 1 ].up( pos ); 				ans += L * V[ i ].y - SL; 				ans += SR - R * V[ i ].x; 			} 			i = ind; 		} 		printf( "%lld\n" , ans ); 	} }  
    #include <bits/stdc++.h>     using namespace std;     #define LL long long     int A[110];     LL N;     LL dp[450*100 + 10];     int main()     {     	int T;     	cin>>T;     	while(T--)     	{     		cin>>N;     		int Sum = 0;     		for(int i = 0;i<N;i++){     			cin>>A[i];     			Sum+=A[i];     		}     		memset(dp,0,sizeof(dp));     		dp[0] = 1;     		int S = 0;     		for(int i = 0;i<N;i++)     		{     			S+=A[i];     			for(int j = S;j>=A[i];j--)     			{     				dp[j]|=(dp[j-A[i]]<<1);     			}     		}     		int Req = N/2;     		int Ans = 1000;     		for(int i = 1;i<=Sum;i++)     		{	     			if(dp[i]&(1LL<<Req))     				Ans = min(Ans,abs(i - (Sum - i)));     			if(dp[i]&(1LL<<(N - Req)))     				Ans = min(Ans,abs(i - (Sum - i)));     		}     		int ans1 = (Ans + Sum)/2;     		int ans2 = (ans1 - Ans);     		cout<<ans2<<" "<<ans1<<endl;     		if(T>0)     			cout<<endl;     	}     	return 0;           } 
#include <iostream> #include <cassert> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <cmath> #include <algorithm> #include <vector>  #define pb push_back #define mp make_pair #define fs first #define sc second  typedef long long int int64; typedef long double ext;  #ifdef LOCALD #define eprintf(...) fprintf(stderr, __VA_ARGS__) #else #define eprintf(...) {} #endif  using namespace std;  const int inf = 1000000000;  const int maxn = 300010; const int maxt = 300010;  struct tree{ 	int y, cnt; 	int64 v, sum; 	pair<int, int> x; 	tree *l, *r; };  int tcnt; tree forest[maxt]; tree *sfree[maxt];  inline tree *mktree(pair<int, int> x, int y, int v){ 	tree *a = sfree[--tcnt]; 	a->x = x; 	a->y = y; 	a->sum = a->v = v; 	a->l = a->r = NULL; 	a->cnt = 1; 	return a; }  inline int cnt(tree *rt){ 	return rt ? rt->cnt : 0; }  inline int64 sum(tree *rt){ //	return rt ? rt->sum + rt->cnt * rt->add : 0; 	return rt ? rt->sum : 0; }  /*inline void push(tree *rt){ 	if (!rt) 		return; 	rt->sum += rt->cnt * rt->add; 	rt->v += rt->add; 	if (rt->l) 		rt->l->add += rt->add; 	if (rt->r) 		rt->r->add += rt->add; 	rt->add = 0; }*/  inline void update(tree *rt){ 	if (!rt) 		return; 	rt->cnt = 1; 	rt->sum = rt->v; 	if (rt->l){ 		rt->cnt += rt->l->cnt; 		rt->sum += rt->l->sum;// + rt->l->cnt * rt->l->add; 	} 	if (rt->r){ 		rt->cnt += rt->r->cnt; 		rt->sum += rt->r->sum;// + rt->r->cnt * rt->r->add; 	} }  void split(tree *rt, tree *&l, tree *&r, pair<int, int> x){ 	//push(rt); 	if (!rt) 		l = r = NULL; 	else if (x < rt->x){ 		split(rt->l, l, rt->l, x); 		r = rt; 	} 	else{ 		split(rt->r, rt->r, r, x); 		l = rt; 	} 	update(l); 	update(r); }  void merge(tree *&rt, tree *l, tree *r){ 	//push(l); 	//push(r); 	if ((!l) || (!r)) 		rt = l ? l : r; 	else if (l->y < r->y){ 		merge(l->r, l->r, r); 		rt = l; 	} 	else{ 		merge(r->l, l, r->l); 		rt = r; 	} 	update(rt); }  void insert(tree *&rt, tree *a){ 	//push(rt); 	if (!rt){ 		rt = a; 		a->l = a->r = NULL; 	} 	else if (a->y < rt->y){ 		tree *l, *r; 		split(rt, l, r, a->x); 		rt = a; 		rt->l = l; 		rt->r = r; 	} else if (a->x < rt->x) 		insert(rt->l, a); 	else 		insert(rt->r, a); 	update(rt); }  inline int64 more(tree *rt, int x, int a, int p){ 	tree *l, *r; 	split(rt, l, r, mp(x, inf)); 	int64 res = sum(r) + int64(cnt(r)) * int64(p + a); 	merge(rt, l, r); 	return res; }  int n; vector<int> g[maxn]; int cool[maxn]; int add[maxn], addv[maxn]; tree *t[maxn]; int64 ans;  void calc(tree *&to, tree *f, int add, int vt, int vf){ 	//push(f); 	if (!f) 		return; 	calc(to, f->l, add, vt, vf); 	calc(to, f->r, add, vt, vf); 	ans += int64(more(to, -f->x.fs - add - 1, vt, f->v + vf - 1)); }  void move(tree *&to, tree *f, int add, int vt, int vf){ 	//push(f); 	if (!f) 		return; 	move(to, f->l, add, vt, vf); 	move(to, f->r, add, vt, vf); 	f->x.fs += add; 	f->v += vf - vt; 	insert(to, f); }  void merge(int u, int v, int c){ 	if (cnt(t[u]) < cnt(t[v])){ 		swap(t[u], t[v]); 		swap(add[v], add[u]); 		swap(addv[v], addv[u]); 	} 	calc(t[u], t[v], add[u] + add[v] + c, addv[u], addv[v]); 	move(t[u], t[v], -add[u] + add[v], addv[u], addv[v]); }  void print(tree *rt, string s){ 	if (!rt) 		return; 	//push(rt); 	print(rt->l, s + "||"); 	eprintf("%s X: %d CNT: %d V: %I64d SUM: %I64d\n", s.c_str(), rt->x.fs, rt->cnt, rt->v, rt->sum); 	print(rt->r, s + "||"); }  void out(int v){ 	eprintf("VERTEX: %d ADD: %d ADDV: %d\n%I64d\n", v, add[v], addv[v], ans); 	print(t[v], ""); 	eprintf("\n"); }   int par[maxn]; pair<int, int> st[maxn]; int scnt;  void dfs(int u){ 	scnt = 0; 	st[scnt++] = mp(u, 0); 	t[u] = NULL; 	add[u] = 0; 	while (scnt > 0){ 		u = st[scnt - 1].fs; 		int i = st[scnt - 1].sc; 		st[scnt - 1].sc++; 		if (i < int(g[u].size())){ 			int v = g[u][i]; 			if (v != par[u]) 			{ 				add[v] = 0; 				t[v] = NULL; 				par[v] = u; 				st[scnt++] = mp(v, 0); 			} 		} 		else{ 			add[u] += cool[u]; 			insert(t[u], mktree(mp(cool[u] - add[u], u), rand() + (rand() << 16), 1 - addv[u])); 			ans += more(t[u], -add[u] - 1, addv[u], 0); 			#ifdef LOCALD 			out(u); 			#endif 			addv[u]++; 			if (par[u] != -1) 				merge(par[u], u, cool[par[u]]); 			scnt--; 		} 	} }  int main() { 	#ifdef LOCALD     assert(freopen("input.txt", "rt", stdin));     assert(freopen("output.txt", "wt", stdout));     assert(freopen("debug.txt", "wt", stderr));     #endif     for (int i = 0; i < maxt; i++) 		sfree[i] = &forest[i]; 	tcnt = maxt;     scanf("%d", &n); 	srand(n * n - 1);     for (int i = 0; i < n - 1; i++){     	int v, u;     	scanf("%d %d", &v, &u); 		v--; u--;     	g[v].pb(u);     	g[u].pb(v);     } 	for (int i = 0; i < n; i++){ 		par[i] = -1; 		int s; 		scanf("%d", &s); 		while (!(s & 1)) 			s >>= 1; 		int r = int(sqrt(double(s))); 		cool[i] = (r * r == s) ? 1 : -1; 	} 	ans = 0; 	dfs(0); 	cout << ans << "\n";     return 0; } 
#include <cstdio> #include <algorithm> #include <utility> #include <queue> #include <cassert> #include <cstring> #include <ctime> using namespace std;   #define MAX_N 200 #define MAX_M 500   int N, M; pair<int, int> edges[MAX_M*2]; int edgestart[MAX_M+1]; long long hashval[MAX_N];   void read(){ 	scanf("%d %d", &N, &M); 	for(int i=0; i<M; i++){ 		scanf("%d %d", &edges[i].first, &edges[i].second); 	} }   void preprocess() {     for(int i=0; i<M; i++){         edges[i+M].first=--edges[i].second;         edges[i+M].second=--edges[i].first;     }     sort(edges, edges+2*M);     edgestart[0]=0;     for(int i=1; i<=N; i++){         edgestart[i]=edgestart[i-1];         while(edgestart[i]<2*M && edges[edgestart[i]].first<i)             edgestart[i]++;     } }   struct node{     unsigned int mark[MAX_N/32+1];     int length;     int current; };   int bfs1(int start){     int count[MAX_N]={0}, cost[MAX_N]={0};     queue<node> q;     node n;     for(int i=0; i<MAX_N/32+1; i++)     {         n.mark[i]=0;     }     n.length = 0;     n.current = start;     n.mark[start>>5]=1<<(start&31);     for(q.push(n); !q.empty(); q.pop()){         int depth=q.front().length;         int cur=q.front().current;         if(count[cur]==3) 			continue;         count[cur]++; 		cost[cur]+=depth; 		for(int i=edgestart[cur]; i<edgestart[cur+1]; i++)             if(!(q.front().mark[edges[i].second>>5]&(1<<(edges[i].second&31)))){ 				assert(edges[i].first==cur);                 n=q.front();                 n.length++;                 n.current=edges[i].second;                 n.mark[edges[i].second>>5]|=1<<(edges[i].second&31);                 q.push(n); 			} 	} 	int ret=M; 	for(int i=0; i<N; i++) 		if(count[i]==3){ 			ret=min(ret, cost[i]-1); 		} 	return ret; }   // cycles share edge int solve1(){ 	int ret=M; 	for(int i=0; i<N; i++) 		ret=min(ret, bfs1(i)); 	return ret; }   int dist[MAX_N][MAX_N]; long long pathhash[MAX_N][MAX_N]; int firstedge[MAX_N][MAX_N];   void calc_dist(){     memset(dist, -1, sizeof(dist));     for(int i=0; i<N; i++){         queue<int> q;         dist[i][i]=0;         pathhash[i][i]=hashval[i];         for(q.push(i); !q.empty(); q.pop()){             int f=q.front();             for(int e=edgestart[f]; e<edgestart[f+1]; e++){                 int v=edges[e].second;                 if(dist[i][v]==-1){                     dist[i][v]=dist[i][f]+1;                     q.push(v);                     pathhash[i][v]=pathhash[i][f]^hashval[v];                     firstedge[i][v]= f==i ? v : firstedge[i][f];                 }             }         }     } }   // cycles share vertex but not edge int solve2(){ 	int ret=M; 	for(int i=0; i<N; i++){ 	    int cycles[4], cnt=0; 	    for(int j=0; j<N; j++){ 	        if(dist[i][j]==-1) 	            continue; 	        int eq=0, le=0; 	        for(int e=edgestart[j]; e<edgestart[j+1]; e++){ 	            int v=edges[e].second; 	            if(dist[i][v]<dist[i][j]) 	                le++; 	            else if(dist[i][v]==dist[i][j]) 	                eq++; 	        } 	        if(le>1){ 	            cycles[cnt]=2*dist[i][j]; 	            push_heap(cycles, cycles+ ++cnt); 	        }else if(eq){ 	            cycles[cnt]=2*dist[i][j]+1; 	            push_heap(cycles, cycles+ ++cnt); 	        }             if(cnt>3){                 pop_heap(cycles, cycles+cnt--);             } 	    } 	    if(cnt<2) 	        continue; 	    sort_heap(cycles, cycles+cnt); 	    int len; 	    // if shortest cycle is odd, it is found twice 	    if(cycles[0]&1){ 	        if(cnt<3) 	            continue; 	        len=cycles[0]+cycles[2]; 	    }else{ 	        len=cycles[0]+cycles[1]; 	    } 	    ret=min(ret, len-1); 	} 	return ret; }   // cycles share no vertex int solve3(){     int cyclehash[MAX_N], cyclelen[MAX_N];     for(int i=0; i<N; i++){         cyclelen[i]=M;         for(int j=0; j<N; j++){             if(dist[i][j]==-1)                 continue;             int le=0;             long long h1=0;             int e1;             for(int e=edgestart[j]; e<edgestart[j+1]; e++){                 int v=edges[e].second;                 if(dist[i][v]<dist[i][j]){                     if(!le){                         le=1;                         h1=pathhash[i][v];                         e1=firstedge[i][v];                     }else if(e1!=firstedge[i][v] || i==v){                         if(cyclelen[i]>2*dist[i][j]){                             cyclelen[i]=2*dist[i][j];                             cyclehash[i]=h1^pathhash[i][v]^hashval[i]^hashval[j];                         }                     }                 }else if(dist[i][v]==dist[i][j] && firstedge[i][v]!=firstedge[i][j]){                     if(cyclelen[i]>2*dist[i][j]+1){                         cyclelen[i]=2*dist[i][j]+1;                         cyclehash[i]=pathhash[i][j]^pathhash[i][v]^hashval[i];                     }                 }             }         }     }     int ret=M;     for(int i=0; i<N; i++)     for(int j=0; j<N; j++){         if(dist[i][j]==-1)             continue;         if(cyclehash[i]==cyclehash[j])             continue;         ret=min(ret, dist[i][j]+cyclelen[i]+cyclelen[j]-1);     }     return ret; }   int solve(){     preprocess();     calc_dist();     int s1=solve1();     int s2=solve2();     int s3=solve3();     return min(s1, min(s2, s3)); }   void init(){     rand();     for(int i=0; i<MAX_N; i++)         hashval[i]=((long long)rand()<<32)+rand(); }   int main(){     init(); 	int T; 	scanf("%d", &T); 	while(T--){ 		read(); 		printf("%d\n", solve()); 	} 	return 0; }
#include<stdio.h> #include<stdlib.h> #include<algorithm> #define fr(i,n) for(i=0;i<n;i++) #define Fr(i,m,n) for(i=m;i<n;i++) #define mod 1000000007 typedef long long int ll; using namespace std; pair<ll,int> a[1005]; int main() {     int in,k,n,t,i,j,f=0,p1,p2;     ll ss,s;     s=0;     scanf("%d%d",&n,&k);     Fr(i,1,n+1)     {    scanf("%lld",&a[i].first);          a[i].second = i;      }     sort(a+1,a+n+1);     Fr(i,1,k+1)         s+= a[i].first;     for(i=1;i<=n-k+1;i++)     {         ss=s;         for(j=i+1;j<=n-k+2;j++)         {             if(ss>2*a[j+k-2].first)                 { f++; p1=i;                   a[i].first=-1;                   fr(in,k-1)                     a[j+in].first=-1;                   break; }             if(j<n-k+2)                 { ss-=a[j].first; ss+=a[j+k-1].first; }         }         if(f==1)              break;         if(i<n-k+1)         { s-=a[i].first; s+=a[i+k].first; }     }     if(f==1)     {   sort(a+1,a+n+1);         i=1;         while(a[i].first<0)             i++;         if(i>n-k+1) {  printf("No"); return 0; }         s=0;         for(j=0; j<k; j++)             s+= a[i+j].first;                      for(;i<=n-k+1;i++)         {                             if(s>2*a[i+k-1].first)                   { f++; p2=i; break; }             if(i<n-k+1)             { s-=a[i].first; s+=a[i+k].first; }         }     }     if(f!=2) printf("No");     else     {         printf("Yes\n");         Fr(i,1,n+1)         if(a[i].first==-1)             printf("%d ",a[i].second);         fr(i,k)             printf("%d ",a[p2+i].second);     }     //scanf("%d%d",&n,&k);     return 0; } 
#include <set> #include <cstdio> #include <cstring> using namespace std;  const int maxn = 1000005; const int Mod = 1e9+7;  void sub(int &a,const int &b){     a-=b;     if(a<0) a+=Mod; }  void add(int &a,const int &b){     a+=b;     if(a>=Mod) a-=Mod; }  int wa[maxn],wb[maxn],wv[maxn],Ws[maxn]; int cmp(int *r,int a,int b,int l) {return r[a]==r[b]&&r[a+l]==r[b+l];} void da(int *r,int *sa,int n,int m) {      int i,j,p,*x=wa,*y=wb,*t;      for(i=0;i<m;i++) Ws[i]=0;      for(i=0;i<n;i++) Ws[x[i]=r[i]]++;      for(i=1;i<m;i++) Ws[i]+=Ws[i-1];      for(i=n-1;i>=0;i--) sa[--Ws[x[i]]]=i;      for(j=1,p=1;p<n;j*=2,m=p)      {        for(p=0,i=n-j;i<n;i++) y[p++]=i;        for(i=0;i<n;i++) if(sa[i]>=j) y[p++]=sa[i]-j;        for(i=0;i<n;i++) wv[i]=x[y[i]];        for(i=0;i<m;i++) Ws[i]=0;        for(i=0;i<n;i++) Ws[wv[i]]++;        for(i=1;i<m;i++) Ws[i]+=Ws[i-1];        for(i=n-1;i>=0;i--) sa[--Ws[wv[i]]]=y[i];        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;i++)        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;      }      return; } int rank[maxn],height[maxn]; void calheight(int *r,int *sa,int n) {      int i,j,k=0;      for(i=1;i<=n;i++) rank[sa[i]]=i;      for(i=0;i<n;height[rank[i++]]=k)      for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++);      return; } int RMQ[maxn]; int mm[maxn]; int best[20][maxn]; void initRMQ(int n) {      int i,j,a,b;      for(mm[0]=-1,i=1;i<=n;i++)      mm[i]=((i&(i-1))==0)?mm[i-1]+1:mm[i-1];      for(i=1;i<=n;i++) best[0][i]=i;      for(i=1;i<=mm[n];i++)      for(j=1;j<=n+1-(1<<i);j++)      {        a=best[i-1][j];        b=best[i-1][j+(1<<(i-1))];        if(RMQ[a]<RMQ[b]) best[i][j]=a;        else best[i][j]=b;      }      return; } int askRMQ(int a,int b) {     int t;     t=mm[b-a+1];b-=(1<<t)-1;     a=best[t][a];b=best[t][b];     return RMQ[a]<RMQ[b]?a:b; } int lcp(int a,int b) {     int t;     a=rank[a];b=rank[b];     if(a>b) {t=a;a=b;b=t;}     return(height[askRMQ(a+1,b)]); }  char q[maxn]; int r[maxn], prev[maxn], next[maxn], sa[maxn]; set<int> S; int main(){     //freopen("1.txt","r",stdin); 	int Q, i, n = 0; 	scanf("%d",&Q); 	for(i=1;i<=Q;++i){ 		char s[10]; 		scanf("%s",s); 		q[i] = s[0]; 		if(s[0] == '+'){ 			scanf("%s", s); 			r[n++] = s[0]; 		} 	} 	r[n] = 0; 	da(r, sa, n+1, 128); 	calheight(r, sa, n); 	for(i=1;i<=n;++i) RMQ[i] = height[i]; 	initRMQ(n); 	int t = -1, s = 0, g = 0, over = 0, ans = 0; 	next[n] = n; 	for(int i = 1; i <= Q; ++i){ 		if(q[i] == '+'){ 			++t; 		} 		else{ 			sub(over, lcp(prev[s], s)); 			sub(over, lcp(s, next[s])); 			if(prev[s]<n && next[s]<n)                 add(over, lcp(prev[s], next[s])); 			prev[next[s]] = prev[s]; 			next[prev[s]] = next[s]; 			S.erase(rank[s]); 			++s; 		}  		for(;g<=t;++g){ 			set<int>::iterator e = S.lower_bound(rank[g]); 			int pre; 			if(e == S.begin()){ 				pre = n; 			} 			else pre = sa[*(--e)]; 			prev[g] = pre; 			next[g] = next[pre]; 			int L1=0,L2=0; 			if (prev[g]<n && (L1=lcp(prev[g],g))>=t-g+1) break; 			if (next[g]<n && (L2=lcp(next[g],g))>=t-g+1) break; 			add(over, L1+L2); 			if(prev[g]<n && next[g]<n) sub(over, lcp(prev[g], next[g])); 			prev[next[g]]=next[prev[g]]=g; 			S.insert(rank[g]); 		} 		int cur = (long long)(2*t-g-s+3)*(g-s)/2%Mod; 		sub(cur, over); 		add(ans, cur); 	} 	printf("%d\n", ans); 	return 0; } 
#include<bits/stdc++.h>   using namespace std;   #define sd(x) scanf("%d" , &x)   typedef long long int LL;  #define MOD 1000000007   #define PB push_back   #define TS 1123456 #define N 1123456   struct Node{     int a, b, p;     int sb;     int aa, mb;     int mxa, mna;     int lid, rid;     int sz;     bool flag; } node[TS];   void norm(int &x){     if(x >= MOD){         x -= MOD;     } }   void adda(int id, int x){     if(id < 0){         return;     }     node[id].aa += x;     node[id].flag = true; }   void mulb(int id, int x){     if(id < 0){         return;     }     node[id].mb = (LL(x) * node[id].mb) % MOD;     node[id].flag = true; }   int get_sz(int id){     return (id >= 0 ? node[id].sz : 0); }   void update_sz(int id){     if(id >= 0){         node[id].sz = 1 + get_sz(node[id].lid) + get_sz(node[id].rid);     } }   void push(int id){     if(id < 0){         return;     }       node[id].mxa += node[id].aa;     node[id].mna += node[id].aa;     node[id].a += node[id].aa;       adda(node[id].lid, node[id].aa);     adda(node[id].rid, node[id].aa);     node[id].aa = 0;       node[id].b = (LL(node[id].mb) * node[id].b) % MOD;     node[id].sb = (LL(node[id].mb) * node[id].sb) % MOD;       mulb(node[id].lid, node[id].mb);     mulb(node[id].rid, node[id].mb);     node[id].mb = 1;       node[id].flag = false; }   int get_sb(int id){     if(id < 0){         return 0;     }     if(node[id].flag == true){         push(id);     }     return node[id].sb; }   int get_mxa(int id){     if(id < 0){         return -MOD;     }     if(node[id].flag == true){         push(id);     }     return node[id].mxa; }   int get_mna(int id){     if(id < 0){         return MOD;     }     if(node[id].flag == true){         push(id);     }     return node[id].mna; }   void update_node(int id){ 	if(node[id].flag == true){ 		push(id); 	}     node[id].sb = get_sb(node[id].lid) + get_sb(node[id].rid);     norm(node[id].sb);     node[id].sb += node[id].b;     norm(node[id].sb);       node[id].mna = min(get_mna(node[id].lid), get_mna(node[id].rid));     node[id].mna = min(node[id].mna, node[id].a);       node[id].mxa = max(get_mxa(node[id].lid), get_mxa(node[id].rid));     node[id].mxa = max(node[id].mxa, node[id].a);       update_sz(id); }   void split(int id, int x, int &l, int &r){     if(id == -1){         l = r = -1;     }     else{         if(node[id].flag == true){             push(id);         }         if(x < node[id].a || (x == node[id].a && abs(rand()) % 2 == 0)){             split(node[id].lid, x, l, node[id].lid);             r = id;         }         else{             split(node[id].rid, x, node[id].rid, r);             l = id;         }         update_node(id);     } }   int inserT(int id1, int id2){     if(id1 < 0){         return id2;     }     if(id2 < 0){     	return id1;     }     if(node[id1].flag == true){         push(id1);     }     if(node[id1].p > node[id2].p){         if((node[id1].a > node[id2].a) || (node[id1].a == node[id2].a && abs(rand()) % 2 == 0)){             node[id1].lid = inserT(node[id1].lid, id2);         }         else{             node[id1].rid = inserT(node[id1].rid, id2);         }         update_node(id1);         return id1;     }     else{         split(id1, node[id2].a, node[id2].lid, node[id2].rid);         update_node(id2);         return id2;     } }   int query_sb(int id, int x, bool fl = false){     if(id < 0){         return 0;     }     if(node[id].flag == true){         push(id);     }     if(node[id].mxa < x){         return 0;     }     if(node[id].mna >= x){         return node[id].sb;     }     if(node[id].a < x){         return query_sb(node[id].rid, x);     }     int ret = node[id].b;     ret += get_sb(node[id].rid);     norm(ret);     ret += query_sb(node[id].lid, x);     norm(ret);     return ret; }   void make(int ctr, int v, int _p, int _b){ 	node[ctr].a = v;     node[ctr].mxa = v;     node[ctr].mna = v;          node[ctr].b = _b;     node[ctr].sb = _b;          node[ctr].p = _p;          node[ctr].lid = -1;     node[ctr].rid = -1;          node[ctr].sz = 1;          node[ctr].flag = false;     node[ctr].mb = 1;     node[ctr].aa = 0; }  int val[N]; int rt[N]; int ans[N], pr[TS]; int ctr = 0, ctr2; bool vis[N]; vector<int> adj[N], child[N]; LL pre[N], suf[N];   int dump(int id1, int id2){     if(id2 < 0){         return id1;     }     if(node[id2].flag == true){         push(id2);     }     id1 = dump(id1, node[id2].lid);     id1 = dump(id1, node[id2].rid);     node[id2].lid = -1;     node[id2].rid = -1;     update_node(id2);     return inserT(id1, id2); }   int dump_cpy(int id1, int id2, LL pb, bool flag = false){     if(id2 < 0){         return id1;     }     if(node[id2].flag == true){         push(id2);     }     ctr2++;     make(TS - ctr2, node[id2].a, pr[TS - ctr2],  (pb * node[id2].b) % MOD);     id1 = inserT(id1, TS - ctr2);     id1 = dump_cpy(id1, node[id2].lid, pb);     id1 = dump_cpy(id1, node[id2].rid, pb);     return id1; }   int dfs2(int id1, int id2, LL pb, int x){     if(id2 == -1){         return 0;     }     if(node[id2].flag == true){         push(id2);     }     LL cv = pb * query_sb(id1, x - node[id2].a);     cv %= MOD;     cv *= node[id2].b;     cv %= MOD;     int ret = dfs2(id1, node[id2].lid, pb, x);     ret += dfs2(id1, node[id2].rid, pb, x);     norm(ret);     ret += cv;     norm(ret);     return ret; }   int depth = 0;   void dfs(int u){ 	int i, v, c;     vis[u] = true;     child[u].clear();     for(i = adj[u].size() - 1; i >= 0; i--){         v = adj[u][i];         if(vis[v] == false){             dfs(v);             child[u].PB(v);         }     }     int mi, ms, s;     int r;     rt[u] = ctr;     make(ctr, val[u], pr[u], 1);     ctr++;     r = rt[u];     c = child[u].size();     LL pb = 1;     for(i = 0; i < c; ++i){         v = child[u][i];         adda(rt[v], val[u]);         pb = (pb * ans[v]) % MOD;     }     ans[u] = (val[u] >= 0 ? pb : 0);     if(c == 0){     	return;     }     node[r].b = pb;     if(c == 1){         ans[u] += query_sb(rt[v], 0);         norm(ans[u]);         node[r].sb = node[r].b;         rt[u] = inserT(rt[v], rt[u]);         return;     }     mi = 0;     ms = -1;     suf[c] = 1;     for(i = 0; i < c; ++i){         v = child[u][i];         s = node[rt[v]].sz;         if(s > ms){             ms = s;             mi = i;         }     }     swap(child[u][mi], child[u][0]);     ctr2 = 1;     pb = 1;     pre[0] = ans[child[u][0]];     r = -1;     suf[c] = 1;     for(i = c - 1; i >= 0; --i){     	suf[i] = (suf[i + 1] * ans[child[u][i]]) % MOD;     }     for(i = 1; i < c; ++i){         v = child[u][i];         ans[u] += dfs2(rt[child[u][0]], rt[v], (pb * suf[i + 1]) % MOD, val[u]);         norm(ans[u]);         if(i > 1){             ans[u] += dfs2(r, rt[v], suf[i + 1], val[u]);             norm(ans[u]);         }         mulb(r, ans[v]);         r = dump_cpy(r, rt[v], pre[i - 1], true);         pb *= ans[v];         pb %= MOD;         pre[i] = (pre[i - 1] * ans[v]) % MOD;     }     for(i = c - 1; i >= 0; i--){         v = child[u][i];         if(i == 0){             mulb(rt[v], suf[i + 1]);         }         else if(i == c - 1){             mulb(rt[v], pre[i - 1]);         }         else{             mulb(rt[v], (pre[i - 1] * suf[i + 1]) % MOD);         }         ans[u] += query_sb(rt[v], 0);         norm(ans[u]);     }     v = child[u][0];     for(i = c - 1; i > 0; --i){         rt[v] = dump(rt[v], rt[child[u][i]]);     }     update_node(rt[u]);     rt[u] = inserT(rt[v], rt[u]); }   void solve(){     int n;     sd(n);     ctr = 0;     for(int i = 0; i < n; ++i){         sd(val[i]);         adj[i].clear();         vis[i] = false;     }     for(int u, v, i = 1; i < n; ++i){         sd(u); sd(v);         --u;         --v;         adj[u].PB(v);         adj[v].PB(u);     }     dfs(0);     printf("%d\n", ans[0]); }   int main(){     int t;     for(t = 0; t < TS; t++){         pr[t] = t;     }     random_shuffle(pr, pr + TS);     sd(t);     while(t--){         solve();     }     return 0; }  
#include<stdio.h> #include<iostream> #include<string.h> #include<queue> #include<algorithm> #include<string> #include<map> #include<set> #include<fstream> #include<math.h> #include<iomanip> #include<time.h> #include<assert.h> #include<stack> using namespace std; #define ll long long #define ull unsigned long long #define db double #define inf 1000000007 #define mod 1000000007 #define pii pair<int,int> #define vi vector<int> #define VS vector<string> #define all(x) x.begin(),x.end() #define mp make_pair #define pb push_back #define x first #define y second #define N 100005 #define pi 3.14159265358979323846 #define DBG(vari) cerr<<#vari<<"="<<(vari)<<endl; #define FOREACH(i,t) for(__typeof(t.begin()) i=t.begin();i!=t.end();i++)  int d[N],p[N][18],l[N]; int dp[N][18],n; vector<pii>g[N]; void dfs(int u,int fa) { 	for(int i=0;i<g[u].size();i++) 	{ 		int j=g[u][i].x; 		if(j==fa)continue; 		d[j]=d[u]+g[u][i].y,p[j][0]=u; 		l[j]=l[u]+1,dfs(j,u); 	} } int lca(int a,int b) { 	if(l[a]<l[b])swap(a,b); 	int h=l[a]-l[b]; 	for(int i=17;i>=0;i--) 	if(h&(1<<i))a=p[a][i]; 	if(a==b)return a; 	for(int i=17;i>=0;i--) 	if(p[a][i]!=p[b][i])a=p[a][i],b=p[b][i]; 	return p[a][0]; } pii get(int a,int u) { 	int ans=0; 	for(int i=17;i>=0;i--) 	{ 		int x=dp[a][i]; 		if(d[x]>d[u])ans+=1<<i,a=x; 	} 	return mp(ans,d[a]-d[u]); } int jump(int a,int c) { 	int st=d[a]; 	for(int i=17;i>=0;i--) 	{ 		int x=p[a][i]; 		if(st-d[x]<=c)a=x; 	} 	return a; } void init(int c) { 	for(int i=0;i<n;i++)dp[i][0]=jump(i,c); 	for(int i=1;i<=17;i++) 	{ 		for(int j=0;j<n;j++) 		{ 			int x=dp[j][i-1],y=dp[x][i-1]; 			dp[j][i]=y; 		} 	} } pii get(int a,int u,int c) { 	int ans=0; 	while(a!=u) 	{ 		int x=jump(a,c); 		if(d[x]>d[u]) 		{ 			ans++;a=x; 		} 		else break; 	} 	return mp(ans,d[a]-d[u]); } struct node { 	int u,v,c,id; 	bool operator <(const node&a)const 	{ 		return c<a.c; 	} }e[N]; int res[N]; int main() { 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout);     int T,i,j,ca=0,m,k; 	while(~scanf("%d",&n)) 	{ 		for(i=1;i<n;i++) 		{ 			int w; 			scanf("%d%d%d",&j,&k,&w);j--,k--; 			g[j].pb(mp(k,w)); 			g[k].pb(mp(j,w)); 		} 		d[0]=0;p[0][0]=0;l[0]=0; 		dfs(0,-1); 		for(i=1;i<18;i++) 		for(j=0;j<n;j++)p[j][i]=p[p[j][i-1]][i-1]; 		scanf("%d",&m); 		for(i=0;i<m;i++) 		{ 			scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].c);e[i].id=i; 		} 		sort(e,e+m);int sz=50; 		//DBG(sz) 		for(i=0;i<m;i=j) 		{ 			j=i;int c=e[i].c; 			while(j<m&&e[j].c==c)j++; 			if(c<sz)init(c); 			for(k=i;k<j;k++) 			{ 				int a=e[k].u-1,b=e[k].v-1,u=lca(a,b); 				int ans=0;pii p,q; 				if(c<sz) 				{ 					p=get(a,u),q=get(b,u); 				} 				else p=get(a,u,c),q=get(b,u,c); 				//cerr<<p.x<<" "<<p.y<<" "<<q.x<<" "<<q.y<<"\n"; 				ans=p.x+q.x+(p.y+q.y+c-1)/c; 				res[e[k].id]=ans; 			} 		} 		for(i=0;i<m;i++) 		printf("%d\n",res[i]); 	}     return 0; }
#include <bits/stdc++.h>  using namespace std;  #define FOR(i, a, b) for(int i = a; i < b; i++) #define REP(i, n) FOR(i, 0, n) #define ll long long #define pb push_back #define mp make_pair  #define mod 1000000007 #define N 100005 #define base (1<<17)  vector<int> a[N]; int n, m, s[N], f[N], gb = 0, par[N][17], lev[N]; ll val[base<<1];  void dfs(int u = 1, int pre = 0, int l = 0) {     lev[u] = l;     par[u][0] = pre;     s[u] = gb;     val[gb++] = u;     f[u] = s[u];     REP(i, a[u].size())     {         int v = a[u][i];         if(v == pre) continue;         dfs(v, u, l+1);         f[u] = max(f[u], f[v]);     } }  bool ancof(int u, int v) {     return s[u] <= s[v] and s[v] <= f[u]; }  int get(int u, int k) {     for(int x = 0; x < 17; x++) if(k&(1<<x)) u = par[u][x];     return u; }  int maxx[base<<1], inc[base<<1]; ll prod[base<<1];  void relax(int n, int L, int R) {     if(inc[n] == 0) return;     maxx[n] += inc[n];     if(L != R)     {         inc[n<<1] += inc[n];         inc[n<<1|1] += inc[n];     }     inc[n] = 0; }  void update(int l, int r, int x, int n = 1, int L = 0, int R =base-1) {     relax(n, L, R);     if(l == L and r == R)     {         inc[n] += x;         return;     }     int m = (L+R)>>1;     if(r <= m) update(l, r, x, n<<1, L, m);     else if(l > m) update(l, r, x, n<<1|1, m+1, R);     else update(l, m, x, n<<1, L, m), update(m+1, r, x, n<<1|1, m+1, R);     relax(n<<1, L, m); relax(n<<1|1, m+1, R);     if(maxx[n<<1] > maxx[n<<1|1])     {         maxx[n] = maxx[n<<1];         prod[n] = prod[n<<1];     }     else if(maxx[n<<1] < maxx[n<<1|1])     {         maxx[n] = maxx[n<<1|1];         prod[n] = prod[n<<1|1];     }     else     {         maxx[n] = maxx[n<<1];         prod[n] = (prod[n<<1]*prod[n<<1|1]) % mod;     } }  int main() {     scanf("%d%d", &n, &m);     REP(i, n-1)     {         int u, v;         scanf("%d%d", &u, &v);         a[u].pb(v);         a[v].pb(u);     }     dfs();     for(int j = 1; j < 17; j++) FOR(u, 1, n+1) par[u][j] = par[par[u][j-1]][j-1];     REP(i, n) prod[base+i] = val[i];     FOR(i, n, base) prod[base+i] = 1;     for(int i = base-1; i >= 1; i--)         prod[i] = prod[i<<1]*prod[i<<1|1] % mod;     int cnt = 0;     while(m--)     {         char t; int u, v;         scanf(" %c%d%d", &t, &u, &v);         int z = (t == '+' ? 1 : -1);         cnt += z;         if(ancof(v, u)) swap(u, v);         if(ancof(u, v))         {             update(s[v], f[v], z);             int x = get(v, lev[v]-lev[u]-1);             update(s[1], f[1], z);             update(s[x], f[x], -z);         }         else         {             update(s[u], f[u], z);             update(s[v], f[v], z);         }         relax(1, 0, base-1);         printf("%lld\n", maxx[1] == cnt ? prod[1] : -1);     }     return 0; }
#include <cstdio> #include <cstdlib> #include <cstring> #include <algorithm> const int oo=1073741819; using namespace std; int ev[1010][1010],f[1010][1010],i,j,ans[1010][1010],n,k,x,y,v[1010],t,sum; void init() {   scanf("%d%d\n",&n,&k);   memset(ev,0,sizeof(ev));   for (i=1;i<=k;i++) {     scanf("%d%d\n",&x,&y);x++,y++;     for (j=1;j<=x;j++) ev[j][y]++;   }   memset(f,0,sizeof(f));   for (i=1;i<=n;i++) {     f[i][0]=ev[i][0];     for (j=1;j<=n;j++) {       f[i][j]=f[i][j-1]+ev[i][j];       //           printf("%d ",f[i][j]);     }        // printf("\n");   }   //  memset(l,0,sizeof(l));memset(r,0,sizeof(r));   memset(ans,127,sizeof(ans));   ans[1][1]=0;   for (i=1;i<=n;i++)      for (j=0;j<=i-1;j++) {       ans[i][j]=min(ans[i][j],ans[i-1][j]+f[i-1][i]);       ans[j][i]=min(ans[j][i],ans[j][i-1]+f[i][i-1]);       ans[i][i-1]=min(ans[i][i-1],ans[j][i-1]+f[j][i]);       ans[i-1][i]=min(ans[i-1][i],ans[i-1][j]+f[i][j]);     }   sum=min(ans[n][0]+f[n][1],ans[0][n]+f[1][n]);   for (i=1;i<=n-1;i++) {     sum=min(sum,ans[n][i]+f[n][i]);     sum=min(sum,ans[i][n]+f[i][n]);   }   printf("%d\n",sum); } int main() {   scanf("%d\n",&t);   for (;t;t--) init();   return 0; } 
#include <stdio.h> #include <string.h> #include <algorithm> #define maxn 250010  using namespace std;  typedef long long ll;  struct node{ 	node *fail; 	node *nxt[26]; 	int len; 	ll tot; 	node(){ 		fail=NULL; 		len=0; 		for (int i=0;i<26;i++) nxt[i]=NULL; 	} } T[maxn<<1]; int tn; node *head,*tail;  int st[maxn],aim[maxn<<1],nxt[maxn<<1],ln;  char s[maxn]; int n,qn;  void in_edge(int x,int y){ 	aim[ln]=y; 	nxt[ln]=st[x]; 	st[x]=ln++; } int dep[maxn]; node *ep[maxn]; node *add(node *p,int c,int len){ 	node *x=&T[tn++]; 	x->len=len; 	for (;p && p->nxt[c]==NULL;p=p->fail) p->nxt[c]=x; 	if (p!=NULL){ 		node *q=p->nxt[c]; 		if (p->len+1<q->len){ 			node *np=&T[tn++]; 			*np=*q; 			np->len=p->len+1; 			x->fail=q->fail=np; 			for (;p && p->nxt[c]==q;p=p->fail) p->nxt[c]=np; 		}else x->fail=q; 	}else x->fail=head; 	return x; } void dfs(int x,int fx){ 	node *lp=(fx==-1?head:ep[fx]); 	ep[x]=add(lp,s[x]-'a',dep[x]); 	for (int i=st[x];i!=-1;i=nxt[i]) 		if (aim[i]!=fx){ 			dep[aim[i]]=dep[x]+1; 			dfs(aim[i],x); 		} } char pt[30]; int idx[maxn<<1]; int c[maxn]; char ans[maxn]; int Find(ll k){ 	node *x=head; 	int len=0; 	while (1){ 		int flag=0; 		if (k==1){ 			ans[len]=0; 			return 1; 		} 		--k; 		for (int i=0;i<26;i++) 			if (x->nxt[pt[i]-'a']!=NULL){ 				int c=pt[i]-'a'; 				if (k>x->nxt[c]->tot){ 					k-=x->nxt[c]->tot; 				}else{ 					flag=1; 					ans[len++]='a'+c; 					x=x->nxt[c]; 					break; 				} 			} 		if (!flag) return 0; 	} } int main(){ 	scanf("%d%d",&n,&qn); 	scanf("%s",s); 	memset(st,-1,sizeof(st)); 	ln=0; 	for (int i=1;i<n;i++){ 		int u,v; 		scanf("%d%d",&u,&v); 		--u,--v; 		in_edge(u,v); 		in_edge(v,u); 	} 	tn=1; 	head=&T[0]; 	dep[0]=1; 	dfs(0,-1);  	for (int i=0;i<tn;i++) c[T[i].len]++; 	for (int i=1;i<=n;i++) c[i]+=c[i-1]; 	for (int i=0;i<tn;i++) idx[--c[T[i].len]]=i; 	for (int i=tn-1;i>=0;i--){ 		node *x=&T[idx[i]]; 		x->tot=1; 		for (int j=0;j<26;j++) 			if (x->nxt[j]!=NULL) x->tot+=x->nxt[j]->tot; 	}  	printf("%lld\n",head->tot); 	for (;qn;qn--){ 		scanf("%s",pt); 		ll k; 		scanf("%lld",&k); 		if (Find(k)){ 			printf("%s\n",ans); 		}else puts("-1"); 	} 	return 0; } 
#include <stdio.h> #include <vector> #include <algorithm> using namespace std; #define LIM 100111 #define K 20 #define INF (1<<30)  // segtree with lazy propagation typedef pair<int,int> res; res add(res a, res b) {     if (a.first < b.first) return a;     if (a.first > b.first) return b;     return make_pair(a.first, a.second + b.second); }  struct segtree {     int i, j;     res val;     int del;     segtree *l, *r;     segtree(int i, int j): i(i), j(j) {         int count;         del = 0;         if (j - i == 1) {             l = r = NULL;             val = make_pair(0, 1);         } else {             int k = i + j >> 1;             l = new segtree(i, k);             r = new segtree(k, j);             val = add(l->val, r->val);         }     }      void visit() {         if (del) {             val = make_pair(val.first + del, val.second);             if (l) {                 l->del += del;                 r->del += del;             }             del = 0;         }     }      void inc(int I, int J, int d) {         if (I <= i && j <= J) {             del += d;             visit();         } else {             visit();             if (!(j <= I || J <= i)) {                 l->inc(I, J, d);                 r->inc(I, J, d);                 val = add(l->val, r->val);             }         }     }      res query(int I, int J) {         visit();         if (I <= i && j <= J) {             return val;         } else if (j <= I || J <= i) {             return make_pair(INF, 0);         } else {             return add(l->query(I, J), r->query(I, J));         }     }  };  // required range operations segtree *seg; void rq_init(int n) {     seg = new segtree(0, n); }  int rq_query(int i, int j) {     res p = seg->query(i, j+1);     return p.first ? 0 : p.second; } void rq_inc(int i, int j, int d) {     seg->inc(i, j+1, d); }     // a "decrease" operation struct dec {     int d, i, j;     dec() {}     dec(int d, int i, int j): d(d), i(i), j(j) {} };     // list of edges struct edge {     int a, b, c;     edge() {}     edge(int a, int b, int c): a(a), b(b), c(c) {} };  bool compare(const edge& x, const edge& y) {     return x.c < y.c; }  edge edges[LIM];    // union find int parent[LIM]; int find(int n) {     return parent[n] < 0 ? n : parent[n] = find(parent[n]); } int onion(int a, int b) {     if (parent[a] == parent[b]) parent[b]--;     if (parent[a] > parent[b]) {         return parent[a] = b;     } else {         return parent[b] = a;     } }   // list of nodes struct node {     int weight;     int parent;     int l, r;     int anc[K]; // jump pointers     int position;     int leftmost;     int rightmost;     node() {}     node (int weight, int l = -1, int r = -1): weight(weight), l(l), r(r), parent(-1), position(-1), leftmost(-1), rightmost(-1) {} };  node nodes[LIM<<1]; void init(int i, int pos) {     // compute anc     int j = nodes[i].anc[0] = nodes[i].parent;     for (int k = 1; k < K; k++) {         j = nodes[i].anc[k] = nodes[j].anc[k-1];     }      // position     nodes[i].position = pos; }   // uses jump pointers to get the relevant subtree int R; int find_root(int u, int w) {     if (nodes[R].weight <= w) return R;     int k = 0;     while (nodes[nodes[u].anc[k]].weight <= w) {         u = nodes[u].anc[k++];     }     while (k--) if (nodes[nodes[u].anc[k]].weight <= w) {         u = nodes[u].anc[k];     }     return u; }   // solve a single test case bool vis[LIM]; int root[LIM]; void solve() {     int n;     scanf("%d", &n);     int N = n;     for (int i = 0; i < n; i++) {         parent[i] = -1;         nodes[i] = node(0);         root[i] = i;     }      // edges     for (int i = 0; i < n-1; i++) {         int a, b, c;         scanf("%d%d%d", &a, &b, &c);         a--, b--;         edges[i] = edge(a, b, c);     }     // sort edges     sort(edges, edges + n-1, compare);     // construct reachability tree     for (int i = 0; i < n-1; i++) {         int a = find(edges[i].a);         int b = find(edges[i].b);         int weight = edges[i].c;         int k = onion(a, b);         nodes[N] = node(weight, root[a], root[b]);         nodes[root[a]].parent = nodes[root[b]].parent = N;         root[k] = N++;     }     R = N-1; // root of reachability tree     nodes[R].parent = R; // set root's parent as itself     for (int i = 0; i < N; i++) {         vis[i] = false;     }      // preorder trversal. 'pre' will contain the leaves     vector<int> stack;     vector<int> pre;     stack.push_back(R);     int pos = 0;     while (!stack.empty()) {         int i = stack.back(), j;         stack.pop_back();         pre.push_back(i);         init(i, pos);         if (i < n) pos++; // it means 'i' is a leaf         if (~(j = nodes[i].r) && !vis[j]) {             vis[j] = true;             stack.push_back(j);         }         if (~(j = nodes[i].l) && !vis[j]) {             vis[j] = true;             stack.push_back(j);         }     }      // compute leftmost and rightmost     for (int f = N-1; f >= 0; f--) {         int i = pre[f];         nodes[i].leftmost  = ~nodes[i].l && ~nodes[nodes[i].l].leftmost  ? nodes[nodes[i].l].leftmost  : nodes[i].position;         nodes[i].rightmost = ~nodes[i].r && ~nodes[nodes[i].r].rightmost ? nodes[nodes[i].r].rightmost : nodes[i].position;     }      // answer queries     int q, x;     scanf("%d%d\n", &q, &x);     rq_init(n);     vector<dec> decs; // list of decrease operations     for (int f = 0; q--;) {         int d, u, w;         scanf("%d%d%d", &d, &u, &w);         u--;         u = find_root(u, w);         // range decreases         for (; f < decs.size() && decs[f].d <= d; f++) {             rq_inc(decs[f].i, decs[f].j, -1);         }         // range query         int i = nodes[u].leftmost, j = nodes[u].rightmost;         printf("%d\n", rq_query(i, j));         // range increase         rq_inc(i, j, +1);         // future "range decrease"         decs.push_back(dec(d+x, i, j));     } }   int main() {     int z;     scanf("%d", &z);     while (z--) solve(); }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> #include <queue> using namespace std; #define N 100050 #define M 1505 #define INF 0x3f7f7f7f int n,m,p,ans,wz[M][4]; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } namespace Graph  {  	queue <int> li;  	int fi[M],S=M-1,T=M-2,c[M*M][3],cur[M],ss=1,h[M];  	inline void Line(int x,int y,int z)  	 {  	 	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;c[ss][2]=z;  	 	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	 	return;  	 }  	bool BFS()  	 {  	 	memset(h,false,sizeof h);memcpy(cur,fi,sizeof cur);  	 	h[S]=true;li.push(S);  	 	while (!li.empty())  	 	 {  	 	 	int k=li.front();li.pop();  	 	 	for (int i=fi[k];i;i=c[i][1])  	 	 	 if (c[i][2]&&!h[c[i][0]])  	 	 	   h[c[i][0]]=h[k]+1,li.push(c[i][0]);  	 	 }  	 	return h[T]>0;  	 }  	int DFS(int x,int y)  	 {  	 	int k,l=false;  	 	if (x==T) return y;  	 	for (int i=cur[x];i&&y;i=c[i][1])  	 	 if (c[i][2]&&h[c[i][0]]==h[x]+1)  	 	  {  	 	  	 k=DFS(c[i][0],min(y,c[i][2]));cur[x]=i;  	 	  	 if (k) c[i][2]-=k,c[i^1][2]+=k,y-=k,l+=k;  	 	  }  	 	if (!l) h[x]=-1;  	 	return l;  	 }  	void Solve()  	 {  	 	int Cnt=false;  	 	while (BFS()) ans -= DFS(S,INF),Cnt++;  	 	return;  	 }  } namespace Tree  {  	int fi[N],c[N*2][2],rf[N],wei[N],h[N],fa[N],sg[N][2];  	int ss=1,st;  	inline void Line(int x,int y)  	 {  	 	c[++ss][0]=y;c[ss][1]=fi[x];fi[x]=ss;  	 	c[++ss][0]=x;c[ss][1]=fi[y];fi[y]=ss;  	 	return;  	 }  	void DFS(int x)  	 {  	 	h[x]=h[fa[x]]+1;wei[x]=1;  	 	for (int i=fi[x];i;i=c[i][1])  	 	 if (c[i][0]!=fa[x])  	 	   fa[c[i][0]]=x,DFS(c[i][0]),wei[x]+=wei[c[i][0]];  	 	return;  	 }  	void DSF(int x,int y)  	 {  	 	int k=false;sg[x][0]=++st;rf[x]=y;  	 	for (int i=fi[x];i;i=c[i][1])  	 	 if (c[i][0]!=fa[x]&&wei[c[i][0]]>wei[k]) k=c[i][0];  	 	if (k) DSF(k,y);  	 	for (int i=fi[x];i;i=c[i][1])  	 	 if (c[i][0]!=fa[x]&&c[i][0]!=k) DSF(c[i][0],c[i][0]);  	 	sg[x][1]=st;  	 	return;  	 }  	int LCA(int x,int y)  	 {  	 	while (rf[x]!=rf[y])  	 	 {  	 	 	if (h[rf[x]]<h[rf[y]]) swap(x,y);  	 	 	x=fa[rf[x]];  	 	 }  	 	return h[x]<h[y]?x:y;  	 }  	inline bool Aha(int x,int y)  	 {return sg[x][0]>=sg[y][0]&&sg[x][1]<=sg[y][1];}  	inline bool Init(int x,int y)  	 {return Aha(x,wz[y][3])&&(Aha(wz[y][0],x)||Aha(wz[y][1],x));}  	void Solve()  	 {  	 	DFS(1);DSF(1,1);  	 	for (int i=1;i<=m+p;i++)  	 	  wz[i][3]=LCA(wz[i][0],wz[i][1]);  	 	for (int i=1;i<=m;i++)  	 	 for (int j=m+1;j<=m+p;j++)  	 	  {  	 	  	 bool flag = false;  	 	  	 flag = Init(wz[i][0],j) | Init(wz[i][1],j);  	 	  	 flag |= Init(wz[j][0],i) | Init(wz[j][1],i);  	 	  	 flag |= Init(wz[i][3],j) | Init(wz[j][3],i);   	 	  	 if (flag) Graph::Line(i,j,INF);  	 	  }  	 	for (int i=1;i<=m;i++) Graph::Line(M-1,i,wz[i][2]);  	 	for (int i=m+1;i<=m+p;i++) Graph::Line(i,M-2,wz[i][2]);  	 	return;  	 }  } int main()  {  	n=Read();m=Read();p=Read();  	for (int i=1;i<n;i++) Tree::Line(Read(),Read());  	for (int i=1;i<=m+p;i++)  	 for (int j=0;j<3;j++) wz[i][j]=Read();  	for (int i=1;i<=m+p;i++) ans += wz[i][2];  	Tree::Solve();Graph::Solve();  	cout <<ans<<endl;  	return 0;  }
#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <fstream> #include <map> #include <set> #include <queue> using namespace std;  #define For(i,n) for(int i=0;i<n;i++) #define sz(i) int(i.size()) #define mst(i,n) memset(i,n,sizeof(i)) #define eps 1e-7 #define MOD 1000000007 #define LL long long #define pi acos(-1) #define ALL(n) n.begin(),n.end() #define pb push_back #define mp make_pair  int n; #define type_t double type_t x[105],y[105]; int X[105],Y[105]; type_t sqr(type_t a){return a * a;}  class PCA { public: 	int num; 	type_t sumX, sumY, sumX2, sumY2, sumXY; 	type_t normalizedSumX, normalizedSumY, normalizedSumX2, normalizedSumY2, normalizedSumXY; 	type_t avgX, avgY; 	type_t p, q, r; 	/*matrix: 	|p r| 	|r q| 	*/ 	PCA(){ 		num = 0; 		sumX = sumY = sumX2 = sumY2 = sumXY = 0; 	}; 	~PCA(){}; 	void addNode(type_t x, type_t y){ 	    //cout << x << " " << y << endl; 		num++; 		sumX  += x; 		sumY  += y; 		sumX2 += x*x; 		sumY2 += y*y; 		sumXY += x*y; 	} 	void delNode(type_t x, type_t y){ 		num--; 		sumX  -= x; 		sumY  -= y; 		sumX2 -= x*x; 		sumY2 -= y*y; 		sumXY -= x*y; 	} 	type_t update(){ 		if(num <= 2) 			return 0; 		avgX = sumX / num; 		avgY = sumY / num; 		normalizedSumX2 = sumX2 - sqr(sumX) / num; 		normalizedSumY2 = sumY2 - sqr(sumY) / num; 		normalizedSumXY = sumXY - sumX * sumY / num;  		return 0.5*(normalizedSumX2 + normalizedSumY2)-sqrt(sqr(normalizedSumXY)+0.25*sqr(normalizedSumX2-normalizedSumY2)); 	} };  int main(){ 	cin >> n; 	PCA pca; 	For(i, n) { 	    cin >> x[i] >> y[i]; 	    X[i] = x[i] * 10; 	    Y[i] = y[i] * 10; 	    pca.addNode(x[i], y[i]); 	} 	//printf("%.8lf\n",pca.update());     //cout << pca.update() << endl; 	//return 0; 	type_t ans = pca.update(); 	For(i, n) 		For(j, n) if(i != j){ 			vector<pair<pair<int, int> , int> >mapLength; 			For(k, n){ 				//map point Pk to vector Pj-Pi 				int dotP = (X[k]-X[i]) * (X[j]-X[i]) + (Y[k]-Y[i]) * (Y[j]-Y[i]); 				//and should break the tie!!! 				int crossP = (X[k]-X[i]) * (Y[j]-Y[i]) - (Y[k]-Y[i]) * (X[j]-X[i]); 				//dotP /= sqrt( sqr(x[j]-x[i]) + sqr(y[j]-y[i]) ); 				mapLength.pb(mp(mp(dotP, crossP), k)); 			} 			sort(ALL(mapLength)); 			PCA pca1, pca2; 			//initialize 			bool side[105]; 			For(k, n){ 				if(k == min(i, j) || (x[k]-x[i]) * (y[j]-y[i]) - (y[k]-y[i]) * (x[j]-x[i]) < 0 ) 					pca1.addNode(x[k], y[k]), side[k] = true; 				else 					pca2.addNode(x[k], y[k]), side[k] = false; 			} 			ans = min(ans, pca1.update() + pca2.update()); 			//scan 			For(kk, n){ 			    int k = mapLength[kk].second; 				if(side[k]){ 					pca1.delNode(x[k], y[k]); 					pca2.addNode(x[k], y[k]); 				} 				else{ 					pca1.addNode(x[k], y[k]); 					pca2.delNode(x[k], y[k]); 				} 				ans = min(ans, pca1.update() + pca2.update()); 				//cout << pca1.update() << " " << pca2.update() << endl; 				//cout << pca1.num << " " << pca2.num << endl; 			} 		} 	printf("%.15lf\n", ans / n); } 
#include <cstdio> #include <algorithm> #include <vector>  using namespace std;  #define MAXN 100005  int N,M1,M2; vector<int> L[MAXN]; int p[17][MAXN],lvl[MAXN],val[MAXN]; long long val2[MAXN];  void dfs(int cur, int par){     p[0][cur] = par;     lvl[cur] = lvl[par] + 1;          for(int i = L[cur].size() - 1,to;i >= 0;--i){         to = L[cur][i];                  if(to != par)             dfs(to,cur);     } }  int lca(int u, int v){     if(lvl[u] < lvl[v]) swap(u,v);          int diff = lvl[u] - lvl[v];          for(int i = 0;i <= 16;++i)         if(diff >> i & 1)             u = p[i][u];          if(u == v) return u;          for(int i = 16;i >= 0;--i){         if(p[i][u] != p[i][v]){             u = p[i][u];             v = p[i][v];         }     }          return p[0][u]; }  int up(int u, int x){     for(int i = 0;i <= 16;++i)         if(x >> i & 1)             u = p[i][u];          return u; }  void solve(int u, int r, int v, int w, int r2){     if(lvl[r2] <= lvl[u] && lvl[r2] >= lvl[r] && up(u,lvl[u] - lvl[r2]) == r2){         ++val[r2]; --val[r];                  int x = lca(u,v),y = lca(u,w);                  if(lvl[x] >= lvl[y]) ++val[u], --val[x];         else ++val[u], --val[y];     }else if(lvl[r2] <= lvl[r] && up(r,lvl[r] - lvl[r2]) == r2){         int x = lca(u,v),y = lca(u,w);                  if(lvl[x] < lvl[y]) swap(x,y);                  if(lvl[x] <= lvl[u] && lvl[x] >= lvl[r]) ++val[u], --val[x];         else if(lvl[x] < lvl[r]) ++val[u], --val[r];     }else ++val[u], --val[r]; }  long long dfs2(int cur, int par){     long long aux = val[cur];          for(int i = L[cur].size() - 1,to;i >= 0;--i){         to = L[cur][i];                  if(to != par)             aux += dfs2(to,cur);     }          val2[cur] = aux;     return aux; }  void dfs3(int cur, int par){     val2[cur] += val2[par];          for(int i = L[cur].size() - 1,to;i >= 0;--i){         to = L[cur][i];                  if(to != par)             dfs3(to,cur);     } }  int main(){     scanf("%d %d %d",&N,&M1,&M2);          for(int i = 1,u,v;i < N;++i){         scanf("%d %d",&u,&v);                  L[u].push_back(v);         L[v].push_back(u);     }          dfs(1,0);          for(int i = 1;i <= 16;++i)         for(int j = 1;j <= N;++j)             p[i][j] = p[i - 1][ p[i - 1][j] ];          for(int i = 0,A,B,C,D;i < M1;++i){         scanf("%d %d %d %d",&A,&B,&C,&D);         int r = lca(A,B),r2 = lca(C,D);                  solve(A,r,C,D,r2);         solve(B,r,C,D,r2);     }          dfs2(1,0);     dfs3(1,0);          for(int i = 0,A,B;i < M2;++i){         scanf("%d %d",&A,&B);                  int r = lca(A,B);                  printf("%lld\n",val2[A] + val2[B] - 2 * val2[r]);     }          return 0; }
#include <iostream> #include <fstream> #include <sstream> #include <cstdio> #include <cmath> #include <cstring> #include <cctype> #include <string> #include <vector> #include <list> #include <set> #include <map> #include <queue> #include <stack> #include <algorithm> #include <functional> using namespace std; #define DEBUG(x) cout << '>' << #x << ':' << x << endl; #define REP(i,n) for(long long i=0;i<(n);i++) #define FOR(i,a,b) for(long long i=(a);i<=(b);i++) #define FORD(i,a,b) for(long long i=(a);i>=(b);i--) #define endl '\n'  int main() {     ios_base::sync_with_stdio(false);     int n, k;     cin>>n>>k;     vector<int> v;     REP(i, n)     {         int p; cin>>p;         v.push_back(p);     }     sort(v.begin(), v.end());     int pretemp=v[0];     //cout<<pretemp<<endl;     int cnt=1;     FOR(i, 1, v.size()-1)     {         if((k+pretemp)<=v[i])         {             //cout<<v[i]<<endl;             pretemp=v[i];             cnt++;         }     }     cout<<cnt<<endl; }
 #include <cstring> #include <cstdio> #include <ctime>  using namespace std;  const int modulo = 900000011;  int binom[23][23], stirling1[23][23], stirling2[23][23], powSum[22][23]; int sum[22], f[22], powP[23], powQ[23], powS[23], powT[23], powT1[23];  struct array { 	int data[21][21]; 	array() { 		memset(data, 0, sizeof(data)); 	} };  inline int multiply(int a, int b) { 	if (a <= 30000 && b <= 30000) return a * b; 	register int div, res; 	asm("mul %3; div %4": "=a" (div), "=&d" (res): "a" (a), "r" (b), "r" (modulo)); 	return res; }  inline int getPower(int a, int p) { 	if (p == 0) return 1; 	int res = getPower(a, p / 2); 	res = multiply(res, res); 	if (p % 2 == 1) res = multiply(res, a); 	return res; }  array calc(long long A, long long B, long long C, long long p, int T) { 	array res; 	if (A == 0 && C < B) return res; 	if (A >= B || C >= B) { 		array _res = calc(A % B, B, C % B, p, T); 		memset(sum, 0, sizeof(sum)); 		int _p = p % modulo; 		int _s = (A / B) % modulo; 		int _t = (C / B) % modulo; 		powP[0] = powS[0] = powT[0] = powT1[0] = 1; 		for (int i = 1; i <= T + 2; i ++) { 			powP[i] = multiply(powP[i - 1], _p); 			powS[i] = multiply(powS[i - 1], _s); 			powT[i] = multiply(powT[i - 1], _t); 			powT1[i] = multiply(powT1[i - 1], _t + 1); 		} 		for (int i = 0; i <= T + 1; i ++) 			for (int j = 0; j <= i + 1; j ++) 				sum[i] = (sum[i] + multiply(powSum[i][j], powP[j])) % modulo; 		for (int m = 0; m <= T; m ++) { 			memset(f, 0, sizeof(f)); 			for (int i = 0; i <= m + 1; i ++) 				for (int j = 0; j <= i; j ++) { 					if (_s == 0 && j > 0) break; 					register int tmp = multiply(powS[j], powT1[i - j]); 					tmp = multiply(tmp, binom[i][j]); 					if (m == 0 && i == 0) { 						tmp = (modulo - tmp) % modulo; 					} else { 						tmp = multiply(tmp, powSum[m][i]); 					} 					f[j] = (f[j] + tmp) % modulo; 				} 			for (int n = 0; n <= T - m; n ++) 				for (int i = 0; i <= m + 1; i ++) 					if (sum[n + i] > 0) res.data[n][m] = (res.data[n][m] + multiply(f[i], sum[n + i])) % modulo; 		} 		for (int S = 0; S <= T; S ++) { 			memset(f, 0, sizeof(f)); 			for (int i = 0; i <= S; i ++) { 				if (_t == 0) { 					f[i] = (f[i] + _res.data[i][S - i]) % modulo; 					continue; 				} 				for (int j = 0; j <= S - i; j ++) { 					register int tmp = multiply(binom[S - i][j], powT[S - i - j]); 					tmp = multiply(tmp, _res.data[i][j]); 					f[i] = (f[i] + tmp) % modulo; 				} 			} 			for (int n = 0; n <= S; n ++) { 				register int m = S - n; 				for (int i = n; i <= S; i ++) { 					if (_s == 0 && i > n) break; 					register int tmp = multiply(powS[i - n], f[i]); 					tmp = multiply(tmp, binom[m][S - i]); 					res.data[n][m] = (res.data[n][m] + tmp) % modulo; 				} 			} 		} 	} else { 		long long q = ((long double)A * p + C) / B; 		long long _C = A * p + C - q * B; 		while (_C < 0) _C += B; 		array _res = calc(B, A, _C, q, T); 		int _p = p % modulo; 		int _q = q % modulo; 		powP[0] = powQ[0] = 1; 		for (int i = 1; i <= T; i ++) { 			powP[i] = multiply(powP[i - 1], _p); 			powQ[i] = multiply(powQ[i - 1], _q); 		} 		for (int n = 0; n <= T; n ++) { 			memset(f, 0, sizeof(f)); 			for (int i = 0; i <= T - n; i ++) 				for (int j = 0; j <= n; j ++) { 					if (_p == 0 && j < n) continue; 					register int tmp = multiply(powP[n - j], binom[n][j]); 					tmp = multiply(tmp, _res.data[i][j]); 					if ((i + j) % 2 == 1) tmp = (modulo - tmp) % modulo; 					f[i] = (f[i] + tmp) % modulo; 				} 			for (int m = 0; m <= T - n; m ++) 				for (int i = 0; i <= m; i ++) { 					if (_q == 0 && i < m) continue; 					register int tmp = multiply(f[i], binom[m][i]); 					tmp = multiply(tmp, powQ[m - i]); 					res.data[n][m] = (res.data[n][m] + tmp) % modulo; 				} 		} 	} 	return res; }  int main() { 	memset(binom, 0, sizeof(binom)); 	for (int i = 0; i <= 22; i ++) { 		binom[i][0] = 1; 		for (int j = 1; j <= i; j ++) 			binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % modulo; 	} 	memset(stirling1, 0, sizeof(stirling1)); 	for (int i = 0; i <= 22; i ++) { 		if (i == 0) stirling1[i][0] = 1; 		for (int j = 1; j <= i; j ++) 			stirling1[i][j] = (multiply(stirling1[i - 1][j], j) + stirling1[i - 1][j - 1]) % modulo; 	} 	memset(stirling2, 0, sizeof(stirling2)); 	for (int i = 0; i <= 22; i ++) { 		if (i == 0) stirling2[i][0] = 1; 		for (int j = 1; j <= i; j ++) 			stirling2[i][j] = (multiply(stirling2[i - 1][j], i - 1) + stirling2[i - 1][j - 1]) % modulo; 	} 	memset(powSum, 0, sizeof(powSum)); 	for (int i = 0; i <= 21; i ++) 		for (int j = 0; j <= i; j ++) { 			register int tmp = multiply(stirling1[i][j], getPower(j + 1, modulo - 2)); 			for (int k = 0; k <= j + 1; k ++) { 				if ((j + 1 - k) % 2 == 0) { 					powSum[i][k] = (powSum[i][k] + multiply(stirling2[j + 1][k], tmp)) % modulo; 				} else { 					powSum[i][k] = (powSum[i][k] - multiply(stirling2[j + 1][k], tmp) + modulo) % modulo; 				} 			} 		} 	 	int T; 	scanf("%d", &T); 	while (T > 0) { 		long long N, A, B; 		int K, L; 		scanf("%lld%lld%lld%d%d", &N, &A, &B, &K, &L); 		array res = calc(A, B, 0, N + 1, K + L); 		register int _N = N % modulo; 		for (int n = 0; n <= K + L; n ++) { 			register int pow = 1; 			for (int i = 0; i <= n + 1; i ++) { 				res.data[n][0] = (res.data[n][0] + multiply(pow, powSum[n][i])) % modulo; 				pow = multiply(pow, _N); 			} 		} 		register int ans = 0; 		for (int i = 0; i <= L; i ++) 			for (int j = 0; j <= K; j ++) { 				register int pow = 1; 				for (int k = i; k >= 0; k --) { 					register int tmp = multiply(stirling2[L][i], stirling2[K][j]); 					tmp = multiply(tmp, binom[i][k]); 					tmp = multiply(tmp, pow); 					tmp = multiply(tmp, res.data[k][j]); 					if ((L + K - i - j + k) % 2 == 1) tmp = (modulo - tmp) % modulo; 					ans = (ans + tmp) % modulo; 					pow = multiply(pow, _N); 				} 			} 		for (int i = 1; i <= L; i ++) 			ans = multiply(ans, getPower(i, modulo - 2)); 		for (int i = 1; i <= K; i ++) 			ans = multiply(ans, getPower(i, modulo - 2)); 		printf("%d\n", ans); 		T --; 	} 	 	return 0; } 
#include <cassert> #include <iostream> #include <cstdio> #include <algorithm>   using namespace std;   const int MOD = 1000000000 + 7; const int MAXN = 1024;   int n, c[MAXN][MAXN], Tn, ret, mem[MAXN]; long long k, p[MAXN];   int pw (int k, int p) { 	if (p == 0) 		return 1; 	if (p == 1) 		return k; 	int q = pw(k, p / 2); 	q = (q * 1LL * q) % MOD; 	if (p % 2 == 0) 		return q; 	else 		return (q * 1LL * k) % MOD; }   inline int divide (int a, int b) { 	if (a < 0) 		a += MOD; 	if (b < 0) 		b += MOD; 	if (mem[b] == -1) { 		mem[b] = pw(b, MOD - 2); 	} 	return (a * 1LL * mem[b]) % MOD; }   int powers_sum (int k) { 	if (k == 0) 		return 0; 	int ret = 0, current_prod = 1; 	for(int i = 0; i <= n + 1; i++) { /*		int term = c[i][1]; 		for(int j = 1; j <= i; j++) 			term = (term * 1LL * (k - j)) % MOD; 		ret = (ret + 1LL * term) % MOD;*/ 		if (i >= 1) 			current_prod = (current_prod * 1LL * (k - i)) % MOD; 		ret = (ret + current_prod * 1LL * c[i][1]) % MOD; 	} 	return ret; }   int naive_sum (int k) { 	int ret = 0; 	for(int i = 1; i <= k; i++)  		ret = (ret + pw(i, n)) % MOD; 	return ret; }   int main (int argc, char * const argv[]) { 	cin >> Tn; //	assert(1 <= Tn && Tn <= 128); 	while (Tn--) { 		ret = 0; 		cin >> k >> n; //		assert(1 <= k && k <= 10000LL); //		assert(0 <= n && n <= 10000); 		if (n > 256) {			 			for(int i = 1; i <= k; i++) if (__gcd(k, 1LL * i) == 1) 				ret = (ret + pw(i, n)) % MOD; 			cout << ret << endl; 			continue; 		} 		for(int i = 0; i <= n + 2; i++) 			mem[i] = -1; 		for(int i = 1; i <= n + 2; i++)  			c[0][i] = pw(i, n) + c[0][i - 1]; 		for(int i = 1; i <= n + 1; i++)  			for(int j = 1; j <= n + 2 - i; j++) 				c[i][j] = divide(c[i - 1][j + 1] - c[i - 1][j], i); 		long long remains = k; 		int pn = 0; 		for(long long i = 2; i * i <= k; i++) 			if (remains % i == 0) { 				p[pn++] = i; 				while (remains % i == 0) 					remains /= i; 			} 		if (remains > 1) 			p[pn++] = remains; 		for(int i = 0; i < (1 << pn); i++) { 			long long carry = 1, mu = 1; 			for(int j = 0; j < pn; j++) 				if (i & (1 << j)) { 					carry *= p[j]; 					mu *= -1; 				} 			long long t = powers_sum((k / carry) % MOD); 			t = (t * 1LL * pw(carry % MOD, n)) % MOD; 			if (mu == -1) 				t = (MOD - t) % MOD; 			ret = (ret + t) % MOD; 		} 		cout << ret << endl; 	}     return 0; }  
#pragma comment(linker, "/STACK:1024000000,1024000000") #include <iostream> #include <stdio.h> #include <string.h> #include <algorithm> #include <cmath> #include <map> #include <vector> #include <queue> using namespace std; #define x first #define y second #define pii pair<int,int> #define vi vector<int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define FOREACH(it,x) for(typeof(x.begin())it=x.begin();it!=x.end();it++) #define DBG(x) cerr<<#x<<"="<<x<<"\n"; #define ull unsigned long long #define ll long long #define inf 1000000007 #define mod 1000000007 #define N 100010  typedef pair<ll,int>pli; pli find(ll l,ll r) {     ll m;     if(l==r)return pli(0,1);     for(m=1;m<=r;m<<=1);     m/=2;     if(l==0){         ll val=2*m-1;         int res=2LL*(m%mod)*((r-m+1)%mod)%mod;         if(r<2*m-1)return pli(val,res);         return pli(val,2LL*res%mod);     }     if(r==2*m-1)return find(0,r-l);     if(l<m){         pli p1=find(0,r-m);         pli p2=find(0,m-1-l);         if(p2.x>p1.x)swap(p1,p2);         if(p1.x==p2.x)p1.y=(p1.y+p2.y)%mod;         return p1;     }     return find(l-m,r-m); } int main() {     int i,j,k,ca=0,m,T;     scanf("%d",&T);     while(T--)     {         ll l,r;         cin>>l>>r;         pli ans=find(l,r);         cout<<ans.x<<" "<<ans.y<<"\n";     }     return 0;     }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <algorithm> using namespace std; #define N 500050 #define M 10000050 #define Limit (1 << 19) struct Node  {  	Node *c[2];int Cnt;  } statePool[M],*cur,*emp,*rt[N],Emp; int Now,n,m; inline int Read()  {  	int x=0;char y;  	do y=getchar(); while (y<'0'||y>'9');  	do x=x*10+y-'0',y=getchar(); while (y>='0'&&y<='9');  	return x;  } inline Node* GetNew()  {return cur->c[0]=cur->c[1]=emp,cur++;} Node* Insert(int x,int y,Node* z,int o)  {  	int mid = x + y >> true;Node* j=GetNew();  	j->Cnt=z->Cnt+1;  	if (x!=y) if (o<=mid)  	  j->c[0]=Insert(x,mid,z->c[0],o),j->c[1]=z->c[1]; else  	  j->c[1]=Insert(mid+1,y,z->c[1],o),j->c[0]=z->c[0];  	return j;  } int Query(int x,int y,Node* z,Node* o,int p)  {  	if (x==y) return x;  	int mid = x + y >> true;bool flag = (p^x)<(p^y);  	int k = z->c[0]->Cnt - o->c[0]->Cnt;  	int l = z->c[1]->Cnt - o->c[1]->Cnt;  	if (!k||(l&&flag))  	  return Query(mid+1,y,z->c[1],o->c[1],p); else  	  return Query(x,mid,z->c[0],o->c[0],p);  } int _Query(int x,int y,Node* z,Node* o,int p,int u)  {  	int mid = x + y >> true;  	if (x==p&&y==u) return z->Cnt-o->Cnt;  	if (u<=mid) return _Query(x,mid,z->c[0],o->c[0],p,u); else  	 if (p>mid) return _Query(mid+1,y,z->c[1],o->c[1],p,u); else  	   return _Query(x,mid,z->c[0],o->c[0],p,mid)+  	     _Query(mid+1,y,z->c[1],o->c[1],mid+1,u);  } int __Query(int x,int y,Node* z,Node* o,int p)  {  	if (x==y) return x;  	int mid = x + y >> true,k = z->c[0]->Cnt - o->c[0]->Cnt;  	if (p>k) return __Query(mid+1,y,z->c[1],o->c[1],p-k); else  	  return __Query(x,mid,z->c[0],o->c[0],p);  } int main()  {  	//freopen("input.txt","r",stdin);  	n=Read();emp=&Emp;emp->c[0]=emp->c[1]=emp;  	cur=statePool;rt[0]=emp;  	for (int i=1;i<=n;i++)  	 {  	 	int e=Read();  	 	if (!e) rt[Now+1]=Insert(0,Limit-1,rt[Now],Read()),Now++; else  	 	 if (e==1)  	 	  {  	 	  	 int q=Read(),w=Read();e=Read();  	 	  	 printf("%d\n",Query(0,Limit-1,rt[w],rt[q-1],e));  	 	  } else  	 	 if (e==2) Now-=Read(); else  	 	 if (e==3)  	 	  {  	 	  	 int q=Read(),w=Read();e=Read();  	 	  	 printf("%d\n",_Query(0,Limit-1,rt[w],rt[q-1],0,e));  	 	  } else  	 	  {  	 	  	 int q=Read(),w=Read();e=Read();  	 	  	 printf("%d\n",__Query(0,Limit-1,rt[w],rt[q-1],e));  	 	  }  	 }  	return 0;  } 
#include <cstdio> #include <cassert> #include <stack> using namespace std;   #define MAX 100000 int arr[MAX+1]; long long match[MAX];   int main(){ 	int T; 	scanf("%d", &T); 	while(T--){ 		long long N; 		int Q; 		scanf("%lld %d", &N, &Q); 		for(int i=0; i<N; i++){ 			scanf("%d", arr+i); 			assert(N-1<=arr[i] && arr[i]<=N+1); 		} 		arr[N]=N; 		fill(match, match+N, -1); 		stack<int> st; 		long long total=N*(N+1); 		for(int pass=0; pass<2; pass++) 		for(int i=0; i<N; i++){ 			if(arr[i]==N+1) 				st.push(i); 			else if(arr[i]==N-1 && !st.empty()){ 				int j=st.top(); 				st.pop(); 				match[i]=match[j]=((i+N)*(N+1)-j*N)%total; 			} 		}   		for(int i=0; i<Q; i++){ 			long long q; 			scanf("%lld", &q); 			int hole=q%N; 			int peg=q%(N+1); 			int ans=N; 			if(arr[hole]==N-1 && (match[hole]==-1 || match[hole]>q)) 				ans--; 			if(arr[peg]==N+1 && (match[peg]==-1 || match[peg]>q)) 				ans++; 			printf("%d ", ans); 		} 		putchar('\n'); 	} 	return 0; }
#include<algorithm> #include<iostream> #include<cstring> #include<string> #define MAXN 200 using namespace std;  double tot_score = 0;  int SOLVETIMES = 202;  string NUM[MAXN + 1] , OUTPUT; int lowbit(int x){return x&(-x);} short lowbit1[101]; short lowbit2[101]; int n , z; int x[MAXN + 1][3]; int ans[MAXN + 1][3] , amount , nowans; int faceup[MAXN + 1]; int dp[6 * MAXN + 1] , opt[6 * MAXN + 1]; int s[101]; bool use[6 * MAXN + 1] , Ause[6 * MAXN + 1]; int whichface[MAXN + 1] , atwhere[MAXN + 1]; int R3[65536] , R100[65536];  int R_now = 19911120 , R_add = 22222223 , R_mul = 1000000001;  int getRand3() {     R_now = (R_now + R_add) * R_mul;     return R3[R_now & 65535]; }  int getRand100() {     R_now = (R_now + R_add) * R_mul;     return R100[R_now & 65535]; }  void update(int loc , int v) {     while(loc <= 100)     {         if(dp[s[loc]] < dp[v])             s[loc] = v;         loc = lowbit1[loc];     } }  int getval(int loc) {     int ret = 0;     while(loc)     {         if(dp[ret] < dp[s[loc]])             ret = s[loc];         loc = lowbit2[loc];     }     return ret; }  struct data {     unsigned char val , key , d , from;     data(){}     data(int _v , int _k , int _d , int _f){val = _v , key = _k , d = _d , from = _f;} }D[MAXN * 6 + 1];  bool cmp(data A , data B) {     if(A.key != B.key)         return A.key < B.key;     return A.d < B.d; }  void solve() {     D[z+1] = data(100 , 100 , 100 , 0);     for(int i = 1 ; i <= n ; i++)     {         if(whichface[i] && getRand100() < 77)             faceup[i] = whichface[i];         else             faceup[i] = x[i][getRand3()];         whichface[i] = 0;     }     memset(s , 0 , sizeof(s));     int maxval = 0 , where = 0;     for(int i = 1 ; i <= z ; i++)         use[i] = false;     for(int i = 1 ; i <= z ; i++)         if(D[i].val == faceup[D[i].from])         {             opt[i] = getval(D[i].d);             dp[i] = dp[opt[i]] + D[i].val;             update(D[i].d , i);             if(opt[opt[i]] > 0 && dp[i] > maxval)                 maxval = dp[i] , where = i;         }     while(where)     {         use[where] = true;         whichface[D[where].from] = D[where].val;         atwhere[D[where].from] = where;         where = opt[where];     }     use[0] = true;     use[z + 1] = true;     int lef = 0 , rig = 0;     for(int i = 1 ; i <= z ; i++)         if(!use[i])         {             while(rig <= i || use[rig] == false)                 rig ++;             if(D[lef].d <= D[i].d && D[i].d <= D[rig].d)             {                 if(whichface[D[i].from] == 0)                 {                     use[i] = true;                     lef = i;                     maxval += D[i].val;                     whichface[D[i].from] = D[i].val;                     atwhere[D[i].from] = i;                 }                 else                     if(atwhere[D[i].from] > i)                         if(whichface[D[i].from] < D[i].val)                         {                             use[i] = true;                             lef = i;                             maxval += D[i].val - whichface[D[i].from];                             use[atwhere[D[i].from]] = false;                             whichface[D[i].from] = D[i].val;                             atwhere[D[i].from] = i;                         }             }         }         else             lef = i;     if(maxval > nowans)     {         nowans = maxval;         memcpy(Ause , use , sizeof(use));     } }  void solve2() {     for(int i = 1 ; i <= n ; i++)     {         faceup[i] = 0;         for(int j = 0 ; j < 3 ; j++)             faceup[i] = max(faceup[i] , x[i][j]);         whichface[i] = 0;     }     memset(s , 0 , sizeof(s));     int maxval = 0 , where = 0;     for(int i = 1 ; i <= z ; i++)         use[i] = false;     for(int i = 1 ; i <= z ; i++)         if(D[i].val == faceup[D[i].from])         {             opt[i] = getval(D[i].d);             dp[i] = dp[opt[i]] + D[i].val;             update(D[i].d , i);             if(opt[opt[i]] > 0 && dp[i] > maxval)                 maxval = dp[i] , where = i;         }     while(where)     {         use[where] = true;         whichface[D[where].from] = D[where].val;         atwhere[D[where].from] = where;         where = opt[where];     }     use[0] = true;     use[z + 1] = true;     int lef = 0 , rig = 0;     for(int i = 1 ; i <= z ; i++)         if(!use[i])         {             while(rig <= i || use[rig] == false)                 rig ++;             if(D[lef].d <= D[i].d && D[i].d <= D[rig].d)             {                 if(whichface[D[i].from] == 0)                 {                     use[i] = true;                     lef = i;                     maxval += D[i].val;                     whichface[D[i].from] = D[i].val;                     atwhere[D[i].from] = i;                 }                 else                     if(atwhere[D[i].from] > i)                         if(whichface[D[i].from] < D[i].val)                         {                             use[i] = true;                             lef = i;                             maxval += D[i].val - whichface[D[i].from];                             use[atwhere[D[i].from]] = false;                             whichface[D[i].from] = D[i].val;                             atwhere[D[i].from] = i;                         }             }         }         else             lef = i;     if(maxval > nowans)     {         nowans = maxval;         memcpy(Ause , use , sizeof(use));     } }  void getStart(int t);  int main() {     //freopen("in.txt" , "r" , stdin);     //freopen("out.txt" , "w" , stdout);     ios::sync_with_stdio(false);     for(int i = 0 ; i < 65536 ; i++)         R3[i] = i % 3 , R100[i] = i % 100;     for(int i = 1 ; i <= 100 ; i++)     {         lowbit1[i] = i + lowbit(i);         lowbit2[i] = i - lowbit(i);     }     for(int i = 1 ; i <= MAXN ; i++)         NUM[i] = NUM[i / 10] + char('0' + i % 10);     opt[0] = 0 , dp[0] = 0;     D[0] = data(0 , 0 , 0 , 0);     int TestCases;     cin>>TestCases;     for(int CaseID = 1 ; CaseID <= TestCases ; CaseID ++)     {         cin>>n;         getStart(CaseID);         nowans = 0;         z = 0;         for(int i = 1 ; i <= n ; i++)         {             whichface[i] = 0;             for(int j = 0 ; j < 3 ; j++)                 cin>>x[i][j];             D[++z] = data(x[i][0] , x[i][1] , x[i][2] , i);             if(x[i][1] != x[i][2])                 D[++z] = data(x[i][0] , x[i][2] , x[i][1] , i);             if(x[i][1] != x[i][0])             {                 D[++z] = data(x[i][1] , x[i][0] , x[i][2] , i);                 if(x[i][0] != x[i][2])                     D[++z] = data(x[i][1] , x[i][2] , x[i][0] , i);             }             if(x[i][2] != x[i][1] && x[i][2] != x[i][0])             {                 D[++z] = data(x[i][2] , x[i][0] , x[i][1] , i);                 if(x[i][0] != x[i][1])                     D[++z] = data(x[i][2] , x[i][1] , x[i][0] , i);             }         }         sort(D + 1 , D + 1 + z , cmp);         for(int i = 1 ; i <= z ; i++)             use[i] = false;         for(int i = 1 ; i <= SOLVETIMES ; i++)             solve();         amount = 0;         for(int i = 1 ; i <= z ; i++)             if(Ause[i])             {                 amount ++;                 ans[amount][0] = D[i].val;                 ans[amount][1] = D[i].d;                 ans[amount][2] = D[i].key;             }         tot_score += (double)nowans / (double)n;         OUTPUT += NUM[amount] + "\n";         for(int i = 1 ; i <= amount ; i++)             OUTPUT += NUM[ans[i][0]] + " " + NUM[ans[i][1]] + " " + NUM[ans[i][2]] + "\n";     }     tot_score /= (double)TestCases;     //cout<<tot_score<<endl;     cout<<OUTPUT;     return 0; }  int START[] = {11111 ,22221 ,33336 ,44444 ,4 ,55551 ,6 ,77775 ,88889 ,9 };  void getStart(int t) {     if(t % 50 == 1)         R_now = START[(t - 1) / 50];     if(t == 25)         R_now = 25259;     if(t == 125)         R_now = 12503; }
 #include <stdio.h> #include <stdlib.h> #define abs(x) ((x)>0 ? (x):-(x)) #define max(x,y) (x>y ? x:y) #define min(x,y) (x<y ? x:y) int main() { int t,tt,n,m; int p,q; long long a[1000],b[1000],c[1000],x[1000],y[1000]; int i,j; long long ukupno=0,temp; int poredak[1002]; int trajanje[1002]; int bio[1000]; int koliko; int mmin; double minx,rez; int xx,yy; int temp1,temp2,temp3,mint; int vrijeme; scanf("%d",&t); for(tt=1;tt<=t;tt++) { scanf("%d %d",&n,&m); for(i=0;i<n;i++) { scanf("%d %d %d %d %d",x+i,y+i,a+i,b+i,c+i); bio[i]=0; } scanf("%d %d",&p,&q); koliko=0; xx=p;yy=q; vrijeme=0; while(1) { mmin=-1; minx=0; for(i=0;i<n;i++) { if (bio[i]) continue; temp1=abs(xx-x[i])+abs(yy-y[i]); temp2=abs(p-x[i])+abs(q-y[i]); if (temp1+1+temp2>m) { bio[i]=1; continue; } temp3=min(max(a[i]-(vrijeme+temp1)*b[i],0),min(m-temp1-temp2,c[i])); if (temp3==0) { bio[i]=1; continue; } rez=(double)temp3*b[i]/(temp1+temp3); if (mmin==-1 || rez>minx) { mmin=i; minx=rez; mint=temp3; } } if (mmin==-1) break; poredak[koliko]=mmin; trajanje[koliko]=mint; m-=abs(xx-x[mmin])+abs(yy-y[mmin])+mint; vrijeme+=abs(xx-x[mmin])+abs(yy-y[mmin])+mint; xx=x[mmin]; yy=y[mmin]; bio[mmin]=1; koliko++; } printf("%d\n",tt); for(i=0;i<koliko;i++) printf("%d %d\n",poredak[i]+1,trajanje[i]); printf("0 0\n"); } return 0; }
#include<iostream> using namespace std;   int scan(){       int t=0;       char c;       c=getchar_unlocked();       while(c<'0' || c>'9')                   c=getchar_unlocked();       while(c>='0' && c<='9'){                    t=(t<<3)+(t<<1)+c-'0';       c=getchar_unlocked();       }            return(t); }  int main() { int i,k,j,p[50000],n,m,a,b; i = scan(); int ch=0; while(i>0) {ch++; j = scan(); while(j--) p[j] = scan(); m = scan(); n = scan(); while(m--){ a = scan(); b = scan(); } cout <<"city " <<ch << " N\n"; i--;} return 0; }
#include <stdio.h> #include <math.h> #include <stdlib.h>   #define yn yn_   const int N = 111; const int dx[4] = {0,1,0,-1}; const int dy[4] = {1,0,-1,0}; const char let[5] = "ESWN";   char a[N][N], ch, aa[N][N], curr[N*N*17], best[N*N*17], aq[N][N]; int num[N][N], xt[N*N], yt[N*N], was[N][N], x[N*N], y[N*N], z[N*N]; int last[N*N], ws[N*N], pr[N*N], pd[N][N], pat[N*N], deg[N*N], pdd[N*N], vis[N][N], kr[N*N]; char r[N*N][17]; int nn,mm,k,tt,i,j,ii,e,zz,n,m,xk,yk,p,kp,xn,yn,qq,maxv,qw,xp,yp,zp,zq,tot,cnt,uv; int maxcnt,count,length; int ss[N*N*N], ff[N*N*N], pred[N*N*N];   int used[N*N];   void rec(int v) {   ws[v] = 1;   int kt = 0, j = last[v], t[111], tmp, i;   while (j > 0) {     if (!ws[ff[j]]) --deg[ff[j]], t[kt++] = ff[j];     j = pred[j];   }   for (i=0;i<kt;i++)     for (j=i+1;j<kt;j++)       if (uv == 0 && xt[t[i]]*sqrt(1.0*nn)+yt[t[i]]*sqrt(1.0*mm) > xt[t[j]]*sqrt(1.0*nn)+yt[t[j]]*sqrt(1.0*mm) ||           uv == 3 && xt[t[i]]*nn*nn+yt[t[i]]*mm*mm > xt[t[j]]*nn*nn+yt[t[j]]*mm*mm ||           uv == 2 && xt[t[i]]+yt[t[i]] > xt[t[j]]+yt[t[j]] ||           uv == 1 && xt[t[i]]*nn+yt[t[i]]*mm > xt[t[j]]*nn+yt[t[j]]*mm) {         tmp = t[i]; t[i] = t[j]; t[j] = tmp;       }   for (i=0;i<kt;i++) {     if (ws[t[i]]) continue;     pr[t[i]] = v;     rec(t[i]);   } /*  ws[v] = 1;   int j = last[v];   while (j > 0) {     if (!ws[ff[j]]) {       pr[ff[j]] = v;       rec(ff[j]);     }     j = pred[j];   }*/ }   inline int mabs(int q) {   if (q < 0) return -q;   return q; }   void go(int xc,int yc,int xf,int yf,int moves,int nv) {   if (nv+zz-moves <= maxv) return;   if (moves+mabs(xc-xf)+mabs(yc-yf) > zz) return;   if (xc == xf && yc == yf) {     if (nv > maxv) {       maxv = nv;       for (int i=moves-1;i>=0;i--) {         int dir = pdd[i];         pd[xc][yc] = dir+1;         xc -= dx[dir];         yc -= dy[dir];       }     }     return;   }   if (!vis[xc][yc]) nv++; else   if (nv+zz-moves-1 <= maxv) return;   vis[xc][yc] += 10000;   for (int j=3;j>=0;j--) {     int xk = xc+dx[j], yk = yc+dy[j];     if (xk < 0 || yk < 0 || xk >= nn || yk >= mm) continue;     if (a[xk][yk] != '.') continue;     if (vis[xk][yk] >= 10000) continue;     pdd[moves] = j;     go(xk,yk,xf,yf,moves+1,nv);   }   vis[xc][yc] -= 10000; }   int main() { //  freopen("in","r",stdin); //  freopen("out","w",stdout);   scanf("%d",&tt);   double ans = 0;   int cans = 0;   for (qq=1;qq<=tt;qq++) {     scanf("%d%d%d",&nn,&mm,&k);     for (i=0;i<nn;i++)       for (j=0;j<mm;j++) {         do {           ch = getchar();         } while (ch != '.' && ch != 't' && ch != '#');         a[i][j] = ch;         aq[i][j] = ch;       }   maxcnt = -1;   int maxkp = 0;   for (uv=0;uv<4;uv++)   for (zq=0;zq<2;zq++) {     n = 0;     for (i=0;i<nn;i++)       for (j=0;j<mm;j++)         if (a[i][j] == 't' || i == nn-1 && j == mm-1 || i == 0 && j == 0) {           num[i][j] = n;           xt[n] = i;           yt[n] = j;           n++;         }         else num[i][j] = -1;     for (i=0;i<nn;i++)       for (j=0;j<mm;j++) was[i][j] = -1;     m = 0;     for (ii=0;ii<n;ii++) {       i = 1; e = 1;       x[1] = xt[ii];       y[1] = yt[ii];       z[1] = 0;       was[x[1]][y[1]] = ii;       while (i <= e) {         if (z[i] <= k && (a[x[i]][y[i]] != 't' || i == 1))           for (j=0;j<4;j++) {             xk = x[i]+dx[j];             yk = y[i]+dy[j];             if (xk >= 0 && yk >= 0 && xk < nn && yk < mm)               if (a[xk][yk] != '#' && was[xk][yk] < ii) {                 e++;                 x[e] = xk;                 y[e] = yk;                 z[e] = z[i]+1;                 was[xk][yk] = ii;               }           }         i++;       }       for (i=1;i<=e;i++)         if (num[x[i]][y[i]] >= 0 && num[x[i]][y[i]] != ii) {           zz = z[i];           if (a[xt[ii]][yt[ii]] != 't') zz++;           if (a[x[i]][y[i]] != 't') zz++;           if (zz <= k) {             m++;             ss[m] = ii;             ff[m] = num[x[i]][y[i]];           }         }     }     for (i=0;i<n;i++) last[i] = 0;     for (i=1;i<=m;i++) {       pred[i] = last[ss[i]];       last[ss[i]] = i;     }     for (i=0;i<n;i++) deg[i] = 0;     for (i=1;i<=m;i++) deg[ss[i]]++;     for (i=0;i<n;i++) ws[i] = 0;     rec(0);     if (ws[n-1] == 0) {       fprintf(stderr,"test %d is guilty\n",qq);       goto finish;     }     p = n-1; kp = 0;     while (p > 0) {       pat[kp++] = p;       p = pr[p];     }     pat[kp] = 0;       int found, jj, q;     for (i=0;i<n;i++) used[i] = 0;     for (i=0;i<=kp;i++) used[pat[i]] = 1;     for (qw=0;qw<10;qw++) {       for (i=0;i<kp;i++) {         found = 0;         j = last[pat[i]];         while (j > 0) {           if (!used[ff[j]]) {             jj = last[pat[i+1]];             while (jj > 0) {               if (ff[j] == ff[jj]) {                 for (q=kp+1;q>=i+2;q--) pat[q] = pat[q-1];                 pat[i+1] = ff[j];                 used[pat[i+1]] = 1;                 kp++;                 found = 1;                 break;               }               jj = pred[jj];             }           }           if (found) break;           j = pred[j];         }         if (found) i--;       }       for (i=0;i<=kp-2;i++) {         found = 0;         j = last[pat[i]];         while (j > 0) {           if (!used[ff[j]]) {             jj = last[pat[i+2]];             while (jj > 0) {               if (ff[j] == ff[jj] && ff[j] != pat[i+1]) {                 used[pat[i+1]] = 0;                 pat[i+1] = ff[j];                 used[pat[i+1]] = 1;                 found = 1;                 break;               }               jj = pred[jj];             }           }           if (found) break;           j = pred[j];         }       }     }     if (kp > maxkp) maxkp = kp;     if (kp >= maxkp-2) {       for (i=0;i<nn;i++)         for (j=0;j<mm;j++) vis[i][j] = 0;       for (qw=0;qw<4 || nn*mm < 3500;qw++) {         int good = 0;         for (ii=kp-1;ii>=0;ii--) {           zz = k;           if (ii == 0 && a[nn-1][mm-1] == '.') zz--;           if (ii == kp-1 && a[0][0] == '.') zz--;           i = 1; e = 1;           x[1] = xt[pat[ii+1]];           y[1] = yt[pat[ii+1]];           z[1] = 0;           xn = xt[pat[ii]];           yn = yt[pat[ii]];           if ((zz & 1) != ((x[1]+y[1]+xn+yn) & 1)) zz--;           maxv = -1;           if (qw > 0) {             maxv--;             xp = xn; yp = yn; zp = 0;             while (xp != x[1] || yp != y[1]) {               vis[xp][yp]--;               if (vis[xp][yp] == 0) maxv++;               int dir = r[ii][zp++];               xp -= dx[dir];               yp -= dy[dir];             }           }           char oldc = a[xn][yn];           a[xn][yn] = '.';           if (k <= 15) go(x[1],y[1],xn,yn,0,0);           kr[ii] = 0;           while (xn != x[1] || yn != y[1]) {             vis[xn][yn]++;             int dir = pd[xn][yn]-1;             if (r[ii][kr[ii]] != dir) good = 1;             r[ii][kr[ii]++] = dir;             xn -= dx[dir];             yn -= dy[dir];           }           a[xt[pat[ii]]][yt[pat[ii]]] = oldc;         }         if (!good) break;       }       for (i=0;i<nn;i++)         for (j=0;j<mm;j++) vis[i][j] = 0;       ii = jj = 0;       vis[0][0] = 1;       count = 0;       for (i=kp-1;i>=0;i--)         for (j=kr[i]-1;j>=0;j--) {           curr[count++] = let[r[i][j]];           ii += dx[r[i][j]];           jj += dy[r[i][j]];           vis[ii][jj] = 1;         }       cnt = tot = 0;       for (i=0;i<nn;i++)         for (j=0;j<mm;j++) {           cnt += vis[i][j];           if (a[i][j] != '#') tot++;         }       if (cnt > maxcnt) {         maxcnt = cnt;         length = count;         if (zq == 0)           for (i=0;i<length;i++) best[i] = curr[i];         else           for (i=0;i<length;i++) best[i] = curr[length-i-1];       }     }     for (i=0;i<nn;i++)       for (j=0;j<mm;j++) aa[i][j] = aq[nn-i-1][mm-j-1];     for (i=0;i<nn;i++)       for (j=0;j<mm;j++) a[i][j] = aq[i][j] = aa[i][j];    }    ans += 1.0*maxcnt/tot;    cans++;    for (i=0;i<length;i++) putchar(best[i]);    puts("");    finish: ;   }   fprintf(stderr,"%.6f\n",ans/cans);   return 0; }
#include<bits/stdc++.h> //#define DEBUG //#ifdef DEBUG //code to debug //#endif //#undef DEBUG using namespace std;  const int mod=1e9+7,maxn=300005,ln=17; #define F(i,p,n) for(int i=p;i<n;i++) #define I(i,p,q) for(int i=p;i>=q;i--) #define Ss(x) scanf("%s",x) #define S(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) //#define getcx getchar_unlocked #define getcx getchar /*inline void S(int& n) {     n=0; int ch = getcx(); int sign = 1;     while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }     while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }     n = n * sign; }*/ #define Ps(x) printf("%d  ",x) #define P(x) printf("%d\n",x) typedef long long int LL; #define modulo(x,y,z) (x+y)<0?x+y+z:((x+y>=z)?x+y-z:x+y) #define Debug(x) cout << #x << "=" << x << endl #define Debugarr(x,n) cout<<"array "<<#x<<":"<<endl; F(i,0,n) cout<<i<<". "<<x[i]<<endl; cout<<endl #define Debugarr2(x,m,n) cout<<"array "<<#x<<":"<<endl; F(i,0,m) {F(j,0,n) cout<<x[i][j]<<" "; cout<<endl;} cout<<endl #define pii pair<int,int> #define Fi first #define Se second #define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int #define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit const int shift=30,etf=mod-1;  const  LL inf=(LL)1e7;  int a[maxn];  multiset<LL> mys;  multiset<LL>::iterator its,its1,its2,its3;  map<LL,int > mym;  map<LL,int >:: iterator itm;  vector<int> res,_hash[maxn];  int stepcnt;  int main() {     LL sum=0,cnt=0;     int n;     S(n);     F(i,0,3*n)     {         S(a[i]);         mys.insert(a[i]);         sum+=a[i];         itm=mym.find(a[i]);         if(itm==mym.end())         {             mym[a[i]]=cnt++;         }         itm=mym.find(a[i]);         _hash[itm->second].push_back(i+1);     }     LL s=sum/n;      //Debug(sum);     //Debug(s);      int flag=0;      //printf("here\n");      F(i,0,n)     {         //printf("start\n");         its1=mys.begin();         LL val=*its1;         LL sum1=s-val;         //Debug(val);         //Debug(sum1);         /*printf("\n");          for(its=mys.begin();its!=mys.end();++its)         {             printf("%lld ",*its);         }*/          its1++;         // printf("\n");          for(its=its1;its!=mys.end();++its)         {             LL val1=*its;             LL req=sum1-val1;              //Debug(val1);             //Debug(req);             its2=mys.find(req);             //Debug(*its);             //Debug(mys.end());             if(its2!=mys.end())             {                 //printf("sahi h\n");                  itm=mym.find(val);                 int idx=_hash[itm->second].back();                 res.push_back(idx);                 _hash[itm->second].pop_back();                 itm=mym.find(val1);                 idx=_hash[itm->second].back();                 res.push_back(idx);                 _hash[itm->second].pop_back();                 itm=mym.find(req);                 idx=_hash[itm->second].back();                 res.push_back(idx);                 _hash[itm->second].pop_back();                 stepcnt++;                 mys.erase(its2);                 mys.erase(its);                 mys.erase(--its1);                 break;             }             stepcnt++;             if(stepcnt>inf)             {                 flag++;                 break;             }             //printf("in the end\n");         }         if(flag)             break;         //printf("end");     }      int sz=(int)(res.size()/3);      cout<<sz<<endl;      F(i,0,3*sz)     {         Ps(res[i]);     }     printf("\n");     return 0; } 
#include <algorithm> #include <iostream> #include <cassert> #include <cstring> #include <cstdio> #include <vector> #include <cmath> #include <ctime> #include <map> #include <set>   using namespace std;   #define SIZE(A) ((int)A.size()) #define LENGTH(A) ((int)A.length()) #define MP(A,B) make_pair(A,B) #define PB(A) push_back(A) #define THLIM 235 #define getchx getchar_unlocked #define eps 1e-14 const int MAXN = 200000; int threshhold = 100000; typedef unsigned long long ll;   int n, m, CH; int ans[MAXN]; double sqbest;   struct point {int a[6];}; point a[MAXN]; bool cmp(const int i, const int j) {return a[i].a[CH] < a[j].a[CH];}   //// Presorted //int srt[3][MAXN]; // Positions int p[MAXN];   struct node { 	int l, r; 	int key, key1; 	double A, B, C, D; 	double len; }; node v[MAXN]; int last, amo;   // Temprorary int b[MAXN];   // Querry int x[3]; int who; ll best;   inline ll dist(const int p) {  	return (unsigned long long)(x[0]-a[p].a[0])*(x[0]-a[p].a[0]) + 1LL*(x[1]-a[p].a[1])*(x[1]-a[p].a[1]) + 1LL*(x[2]-a[p].a[2])*(x[2]-a[p].a[2]); }   inline void build(int *p, int n) { 	int u = last++; 	v[u].l = v[u].r = -1;   	int mid = rand()%n, pos = rand()%n;   	v[u].key = v[u].key1 = p[mid];   	if (n == 1) return;   	while (pos == mid) pos = rand()%n;   	v[u].key1 = p[pos];   	v[u].A = a[p[mid]].a[0] - a[p[pos]].a[0]; 	v[u].B = a[p[mid]].a[1] - a[p[pos]].a[1]; 	v[u].C = a[p[mid]].a[2] - a[p[pos]].a[2];   	double mx = (a[p[mid]].a[0] + a[p[pos]].a[0])/2., my = (a[p[mid]].a[1] + a[p[pos]].a[1])/2., mz = (a[p[mid]].a[2] + a[p[pos]].a[2])/2.; 	v[u].D = -(v[u].A*mx + v[u].B*my + v[u].C*mz);   	v[u].len = sqrt(v[u].A*v[u].A + v[u].B*v[u].B + v[u].C*v[u].C);   	int newn = 0, n1; 	double val; 	for (int i = 0; i < n; i++) 		if (i!=mid && i!=pos) 		{ 			val = v[u].A*a[p[i]].a[0] + v[u].B*a[p[i]].a[1] + v[u].C*a[p[i]].a[2] + v[u].D;   			if (val >= eps) 				b[newn++] = p[i]; 		} 	n1 = newn; 	for (int i = 0; i < n; i++) 		if (i != mid && i!=pos) 		{ 			val = v[u].A*a[p[i]].a[0] + v[u].B*a[p[i]].a[1] + v[u].C*a[p[i]].a[2] + v[u].D;   			if (val < eps) 				b[newn++] = p[i]; 		}   	for (int i = 0; i < newn; i++) 		p[i] = b[i];   	if (n1) 	{ 		v[u].l = last; 		build(p, n1); 	} 	if (newn-n1) 	{ 		v[u].r = last; 		build(p+n1, newn-n1); 	} }   inline void doit(int u) { 	ll tmp; 	int lson = v[u].l, rson = v[u].r;   	if ((tmp = dist(v[u].key)) < best) 	{ 	 	best = tmp; 	 	amo = 0; 	 	sqbest = sqrt(1.*best); 	 	who = v[u].key; 	}   	amo++;   	if ((tmp = dist(v[u].key1)) < best) 	{ 	 	best = tmp; 	 	amo = 0; 	 	sqbest = sqrt(1.*best); 	 	who = v[u].key1; 	}   	amo += 2; 	if (amo > threshhold || lson==rson) return;   	double val = v[u].A*x[0] + v[u].B*x[1] + v[u].C*x[2] + v[u].D;   	if (val >= eps) 	{ //		assert(dist(v[u].key) < dist(v[u].key1));   		if (lson!=-1) doit(lson);   		if (rson!=-1 && val < sqbest*v[u].len) 			doit(rson); 	} 	else 	{ //		assert(dist(v[u].key) >= dist(v[u].key1));   		if (rson!=-1) doit(rson);   		if (lson!=-1 && val < sqbest*v[u].len) 			doit(lson); 	} }   inline void scan(int &x) { 	char ch = getchx(); 	for (; ch!='-' && (ch < '0' || ch > '9'); ch = getchx()); 	bool neg = (ch == '-'); 	if (ch == '-') ch = getchx(); 	 	x = 0; 	for (; ch >= '0' && ch <= '9'; ch = getchx()) 		x = x*10 + ch-'0';   	if (neg) x = -x; }     int main() { 	double start = clock();   	srand(4041978); 	scan(n); 	for (int i = 0; i < n; i++) 		for (int j = 0; j < 3; j++) 			scan(a[i].a[j]);   	for (int i = 0; i < n; i++) 		p[i] = i;   	build(p, n); 	cerr << "Generation process finished\n";   	int sz = 0; 	for (int i = 0; i < last; i++) 		p[sz++] = v[i].key1, 		p[sz++] = v[i].key; 	sort(p, p+sz); 	assert(unique(p, p+sz)-p == n);   	scan(m); 	for (int i = 0; i < m; i++) 		ans[i] = rand()%n;   	int asd; 	ll tmp; 	for (int it = 0; it < m; it++) 	{ 		scan(x[0]); 		scan(x[1]); 		scan(x[2]);   		best = dist(v[0].key); 	 	sqbest = sqrt(1.*best); 		who = v[0].key;   		amo = 0; 		doit(0);   		ans[it] = who; 		asd = it+1;   		threshhold = THLIM;   		if ((clock()-start) > 3.84*CLOCKS_PER_SEC) break; 	}   	cerr << asd << " " << m << endl; 	for (int i = 0; i < m; i++) 		printf("%d\n", ans[i]);   	return 0; }   
#include<stdio.h> #include<math.h> int main() { int t; scanf("%d",&t); while(t--) { int n,sr,sb,x[31260],y[31260]; scanf("%d %d %d",&n,&sr,&sb); for(long int i=0;i<ceil(pow(n,2)/2);i++) scanf("%d %d",&x[i],&y[i]); } return 0; }
#include <fstream> #include <iostream> #include <set> #include <map> #include <string> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <bitset> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iomanip> #include <cstdio> #include <cstdlib> #include <algorithm> #include <cassert> #include <ctime> #include <memory.h> #include <cmath>   #pragma pack(16)   using namespace std;   //* typedef pair<double, double> pdd; typedef pair<int, int> pii;   #define x first #define y second //*/   inline int nextint() {   int res = 0;   char c = 0; while (c < '0' || c > '9') c = getchar();   while (c >= '0' && c <= '9') {     res = res * 10 + c - '0';     c = getchar();   }   return res; }     #ifdef _DEBUG   #define dbg(x) { cerr << #x << " = " << x << endl; } #else   #define dbg(x) ; #endif   #define forn(_i,_n) for (int _i = 0; _i < (int)(_n); ++_i) #define mp make_pair   #define SIZE 300   int n, B; vector<pii> gr[SIZE];   int components_cnt, component[SIZE]; int component_size[SIZE], component_subsum[SIZE];   struct solution;   typedef vector<solution*> solution_set; typedef unsigned char byte;   solution* memory_new();     struct solution {   int last, t, uses;   solution* prev;     byte used[SIZE];   int size, last_component, used_component;     double rating;     void build(vector<int>& v) const {     if (prev)       prev->build(v);     v.push_back(last);   }     solution() { }     void init() {     prev = NULL;     last = 0;     t = 0;     uses = 1;     size = 1;     last_component = component[0];     used_component = 1;     rating = 0;       memset(used, 0, sizeof used);   }     void init(solution* _prev, int v, int _t) {     prev = _prev;     last = v;     t = _t;     uses = 1;       size = prev->size;     last_component = prev->last_component;     used_component = prev->used_component;       if (component[last] != last_component) {       last_component = component[last];       used_component = 0;     }       if (!prev->used[last]) {       ++size;       ++used_component;     }       rating = calc_rating();   }     inline double calc_rating() const {     if (!t) return size;     double spt = (double)size / t;       int approx_max = (int)((B - t) * spt);     int real_max = component_subsum[last_component] - used_component;       return size + 0.315 * min(real_max, approx_max) + spt; // 0.3 -> 3096     //return (size + 0.3 * min(real_max, approx_max)) * (1  + spt / 5); // 0.3 -> 3094.(3)   }     void go(solution_set& S) {     if (prev)       memcpy(used, prev->used, sizeof(used));     used[last] = size;       forn (i, gr[last].size()) {       int to = gr[last][i].first,         nt = t + gr[last][i].second;       if (used[to] == size || nt > B) continue;         uses++;       solution* nsol = memory_new();       nsol->init(this, to, nt);       S.push_back(nsol);     }   } };   #define MEMORY_SIZE 50000   solution memory[MEMORY_SIZE]; int free_memory[MEMORY_SIZE], free_size;   void memory_init() {   forn (i, MEMORY_SIZE)     free_memory[i] = MEMORY_SIZE - 1 - i;   free_size = MEMORY_SIZE; }   inline void memory_delete(solution* s) {   free_memory[free_size++] = ((int)s - (int)memory) / sizeof (solution); }   inline solution* memory_new() {   return &memory[free_memory[--free_size]]; }   inline void remove(solution* s) {   while (s && !(--s->uses)) {     solution* prev = s->prev;     memory_delete(s);     s = prev;   } }   inline void use(solution* a) {   ++a->uses; }   bool solution_cmp(const solution* a, const solution* b) {   if (!a) return false;   if (!b) return true;   return a->rating > b->rating; }   solution_set S;   #define SET_SIZE 19 #define ITER 10000   solution* solve() {   solution* best = memory_new();   best->init();     int set_size = 2 * SET_SIZE;   //int set_size = SET_SIZE;     #define CHECK_REMOVE(i) if (S[i]) { if (S[i]->size > best->size) { use(S[i]); remove(best); best = S[i]; } remove(S[i]); }     int cnt = 0;   S.clear();   S.push_back(best);   use(best);   while (S[0] && ++cnt <= ITER) {     int size = (int)S.size();       forn (i, size) {       solution* top = S[i];       if (!top) break;         if (top->size > best->size) {         use(top);         remove(best);         best = top;       }          S[i] = NULL;       top->go(S);       remove(top);     }       if (cnt > 120 && set_size > SET_SIZE) --set_size;       sort(S.begin(), S.end(), solution_cmp);     for (int i = set_size; i < (int)S.size(); ++i)        CHECK_REMOVE(i);       S.resize(set_size, NULL);   }     forn (i, S.size())     CHECK_REMOVE(i);     return best; }   bool u[SIZE]; vector<int> order; vector<pii> rev_gr[SIZE];   void dfs(int v) {   u[v] = true;   forn (i, gr[v].size()) {     int to = gr[v][i].first;     if (!u[to])       dfs(to);   }   order.push_back(v); }   void rev_dfs(int v, int c) {   u[v] = true;   component[v] = c;   ++component_size[c];     forn (i, rev_gr[v].size()) {     int to = rev_gr[v][i].first;     if (!u[to])       rev_dfs(to, c);   } }   int bf[SIZE]; vector<int> ans;   int main() {   memory_init();     order.reserve(SIZE);   ans.reserve(10001);   S.reserve(2 * SET_SIZE * SIZE);     int _T = nextint();   forn (_Ti, _T) {     n = nextint();     int m = nextint();     B = nextint();       ans.clear();     forn (i, n) {       gr[i].clear();       rev_gr[i].clear();       bf[i] = B + 1;     }     bf[0] = 0;       forn (i, m) {       int a = nextint(), b = nextint(), c = nextint();       if (c <= B)         gr[a].push_back(mp(b, c));     }       forn (_i, n)       forn (i, n)         forn (j, gr[i].size()) {           int to = gr[i][j].first;           bf[to] = min(bf[to], bf[i] + gr[i][j].second);         }       forn (i, n)       if (bf[i] > B)         gr[i].clear();       else {         int size = 0;         forn (j, gr[i].size()) {           if (bf[i] + gr[i][j].second <= B)             gr[i][size++] = gr[i][j];         }         gr[i].resize(size);       }       forn (i, n)       forn (j, gr[i].size())         rev_gr[gr[i][j].first].push_back(mp(i, gr[i][j].second));       order.clear();     memset(u, 0, sizeof u);     dfs(0);       memset(component_size, 0, sizeof component_size);     memset(u, 0, sizeof u);     components_cnt = 0;     forn (i, n)       component[i] = n - 1;     forn (i, order.size()) {       int v = order[order.size() - 1 - i];       if (!u[v])         rev_dfs(v, components_cnt++);     }       forn (i, components_cnt) {       memset(u, 0, sizeof u);       forn (j, n) if (component[j] == i)         forn (k, gr[j].size()) {           int to = gr[j][k].first;           u[component[to]] = true;         }         component_subsum[i] = 0;       forn (j, n) if (u[j])         component_subsum[i] += component_size[j];     }           solution* best = solve();     best->build(ans);     remove(best);       for (int i = 1; i < (int)ans.size(); ++i)       printf("%d ", ans[i]);          printf("-1\n");   }   fflush(stdout);     return 0; }  
#include <vector> #include <cassert> #include <cstdio> #include <iostream> #include <algorithm> #include <set>  using namespace std;  const int MAXN = 100000 * 2 + 10;  set<pair<int, int> > S;  int f[MAXN], t[MAXN], p[MAXN], ii, wei[MAXN], par[MAXN], dist[MAXN], vn, n, wn, w[MAXN], s, m, x, y, z, k, a[MAXN], b[MAXN], c[MAXN], v[MAXN], d, choice, W, an, ax[MAXN], ay[MAXN]; bool used[MAXN];  vector<pair<int, int> > vec[MAXN];  void add_edge(int x, int y, int z) {     t[++ii] = y;     p[ii] = f[x];     f[x] = ii;     wei[ii] = z; }  void push (int to, int wei) {     if (dist[to] <= wei)         return ;     if (S.find(make_pair(dist[to], to)) != S.end())         S.erase(S.find(make_pair(dist[to], to)));     dist[to] = wei;     par[to] = vn;     S.insert(make_pair(dist[to], to)); }  void deikstr (int source) {     for(int i = 1; i <= n; i++)         dist[i] = 1000000000;     push(source, 0);     while (S.size() > 0) {         vn = S.begin()->second;         S.erase(S.begin());         int q = f[vn];         while (q > 0) {             push(t[q], dist[vn] + wei[q]);             q = p[q];         }     } }  void getpath_to (int k) {     wn = 0;     while (k != s) {         w[++wn] = k;         k = par[k];     }     reverse(w + 1, w + wn + 1); }  int pn, path[MAXN], take_after, put_after, occurs[MAXN], it, last[MAXN]; vector<int> vec2[MAXN]; long long ret = 0, alll = 0;  void go_by_path () {     ++it;     for(int i = 1; i <= pn; i++) {         occurs[path[i]] = it;         last[path[i]] = i;     }     int remain = W - v[choice];     for(int i = 1; i <= pn; i++) {         int node = path[i];          if (take_after == i) {             ++an; ax[an] = 1; ay[an] = choice;         }         if (put_after == i) {             ++an; ax[an] = 2; ay[an] = choice;             remain += v[choice];         }                  for(int j = 0; j < vec2[node].size(); j++) {             ++an; ax[an] = 2; ay[an] = vec2[node][j];             remain += v[vec2[node][j]];             ret += c[vec2[node][j]];         }         vec2[node].clear();                  for(int j = 0; j < vec[node].size(); j++) {             int xx = vec[node][j].second;             if (used[xx] || remain < v[xx] || occurs[b[xx]] != it || last[b[xx]] < i)                 continue ;             used[xx] = true;             remain -= v[xx];             assert(remain >= 0);             vec2[b[xx]].push_back(xx);             ++an; ax[an] = 1; ay[an] = xx;         }                  if (i < pn) {             ++an; ax[an] = 0; ay[an] = path[i + 1];         }              } }  int main () {     //    freopen("input.txt", "r", stdin);     cin >> n >> m;     assert(1 <= n && n <= 100000);     assert(1 <= m && m <= 100000);     for(int i = 1; i <= m; i++) {         cin >> x >> y >> z;         assert(1 <= x && x <= n);         assert(1 <= y && y <= n);         assert(x != y);         assert(1 <= z && z <= 100);         add_edge(x, y, z);         add_edge(y, x, z);     }     cin >> k;     assert(1 <= k && k <= 100000);     for(int i = 1; i <= k; i++) {         cin >> a[i] >> b[i] >> v[i] >> c[i];         assert(1 <= a[i] && a[i] <= n);         assert(1 <= b[i] && b[i] <= n);         assert(a[i] != b[i]);         alll += c[i];         vec[a[i]].push_back(make_pair(v[i], i));     }          for(int i = 1; i <= n; i++)         sort(vec[i].begin(), vec[i].end());          cin >> s >> d >> W;     assert(1 <= s && s <= n);     assert(1 <= d && d <= 100000);     assert(1 <= W && W <= 1000000000);          for(int i = 1; i <= k; i++) {         assert(1 <= v[i] && v[i] <= W);         assert(1 <= c[i] && c[i] <= 1000000);     }          assert(1 <= d && d <= 100000);     assert(1 <= s && s <= n);     //     deikstr(s);     for(int i = 1; i <= n; i++) assert(dist[i] <= d);     //     while (d > 0) {         choice = -1;         for(int i = 1; i <= k; i++)             if (!used[i] && 2 * dist[a[i]] + 2 * dist[b[i]] <= d) {                 if (choice == -1)                     choice = i;                 else if (c[choice] < c[i]) {                     choice = i;                 } //                break;             }         if (choice == -1)             break;         d -= 2 * dist[a[choice]] + 2 * dist[b[choice]];         used[choice] = true;         getpath_to(a[choice]);                  pn = 0;                  path[pn = 1] = s;                  for(int i = 1; i <= wn; i++)             path[++pn] = w[i];                  take_after = pn;         put_after = -1;                  for(int i = wn - 1; i >= 1; i--) {             path[++pn] = w[i];             if (w[i] == b[choice]) {                 put_after = pn;             }         }                  if (wn != 0) {             path[++pn] = s;             if (s == b[choice]) {                 put_after = pn;             }         }                  //                  if (put_after == -1) {                  getpath_to(b[choice]);         for(int i = 1; i <= wn; i++)             path[++pn] = w[i];                  put_after = pn;                  for(int i = wn - 1; i >= 1; i--)             path[++pn] = w[i];                  if (wn != 0)             path[++pn] = s;                  } else d += 2 * dist[b[choice]];                  go_by_path();         ret += c[choice];     }          cerr << "I should have got " << ret << endl;          cout << an << endl;     for(int i = 1; i <= an; i++)         cout << ax[i] << " " << ay[i] << endl;     return 0; }
#include <iostream> #include <cstdio> #include <cstdlib> #include <algorithm> #include <cstring> #include <cmath> #include <string> #include <ctime> #include <vector> using namespace std; typedef unsigned int u32; typedef unsigned long long u64; const int N=1200000,MaxT=105,Len=200005,n1=100; int T,now,ord[MaxT],Score=0; char str[1005]; int pr[Len],pn=0; bool flag[N+5],Type[MaxT]; vector <u32> ans[MaxT];  void init() { 	bool tmp=false; 	for (int i=2;i<=N;i++) 		if (!flag[i]) { 			pr[++pn]=i; 			if (tmp||i*i>N) { 				tmp=true; 				continue; 			} 			for (int j=i*i;j<=N;j+=i) 				flag[j]=true; 		} }  namespace SmallTask{ 	u64 n,SmallNum[MaxT]; 	 	void op() { 		Score+=(ans[now].size()+(SmallNum[now]!=1))*(ans[now].size()+(SmallNum[now]!=1)); 		printf("%d\n",ans[now].size()+(SmallNum[now]!=1)); 		for (int i=0;i<ans[now].size();i++) 			printf("%u\n",ans[now][i]); 		if (SmallNum[now]>1) cout<<SmallNum[now]<<endl; 	} 	 	void init() { 		SmallNum[now]=0; 		for (int i=1;i<=strlen(str+1);i++) 			SmallNum[now]=SmallNum[now]*10+str[i]-48; 	} 	 	void work() { 		n=SmallNum[now]; 		for (int i=1;i<=300;i++) 			while (n%pr[i]==0) { 				n/=pr[i]; 				ans[now].push_back(pr[i]); 			} 		SmallNum[now]=n; 	} }  namespace LargeTask{ 	const u64 K=1000000000; 	u32 tmpm[120],curp; 	int curi; 	 	struct Bignum{ 		u32 a[120],len; 		void set() { 			len=strlen(str+1); 			memset(a,0,sizeof a); 			for (int i=1;i<=len;i++) 				a[(len-i)/9+1]=a[(len-i)/9+1]*10+str[i]-48; 			len=(len-1)/9+1; 		} 		void op() { 			printf("%u",a[len]); 			for (int i=len-1;i>=1;i--) printf("%09u",a[i]); 			putchar('\n'); 		} 		bool check() { 			return len>1||a[1]>1; 		} 		u32 module(u32 mod) { 			u32 ret=0; 			for (int i=len;i>=1;i--) 				ret=(ret*K+a[i])%mod; 			return ret; 		} 		u32 module2() { 			u64 ret=0; 			for (int i=len;i>=1;i--) 				ret+=u64(a[i])*tmpm[i-1]; 			return ret%curp; 		} 		void div(u32 p) { 			u64 tmp; 			u32 ret=0; 			for (int i=len;i>=1;i--) { 				tmp=ret*K+a[i]; 				a[i]=tmp/p; 				ret=tmp-a[i]*u64(p); 			} 			while (len>1&&!a[len]) --len; 		} 	}n,LargeNum[MaxT]; 	 	void op() { 		n=LargeNum[now]; 		Score+=(ans[now].size()+n.check())*(ans[now].size()+n.check()); 		printf("%d\n",ans[now].size()+n.check()); 		for (int i=0;i<ans[now].size();i++) 			printf("%u\n",ans[now][i]); 		if (n.check()) n.op(); 	} 	 	void init() { 		LargeNum[now].set(); 	} 	 	void work() { 		n=LargeNum[now]; 		for (int i=1;i<=n1;i++) { 			while (n.module(pr[i])==0) { 				n.div(pr[i]); 				ans[now].push_back(pr[i]); 			} 		} 		LargeNum[now]=n; 	} 	 	void init2(int _curi) { 		curi=_curi; 		curp=pr[curi]; 		tmpm[0]=1; 		for (int i=1;i<=113;i++) 			tmpm[i]=tmpm[i-1]*K%curp; 	} 	 	void work2() { 		n=LargeNum[now]; 		while (n.module2()==0) { 			n.div(curp); 			ans[now].push_back(curp); 		} 		LargeNum[now]=n; 	} }  bool cmp(int u,int v) { 	return ans[u].size()>ans[v].size(); }  int main() { 	//freopen("FACTORIZ.in","r",stdin); 	//freopen("FACTORIZ.out","w",stdout); 	init(); 	scanf("%d",&T); 	for (int i=1;i<=T;i++) { 		scanf(" %s",str+1); 		now=i; 		if (strlen(str+1)<=18) { 			Type[i]=false; 			SmallTask::init(); 			SmallTask::work(); 		} 		else { 			Type[i]=true; 			LargeTask::init(); 			LargeTask::work(); 		} 		ord[i]=i; 	} 	sort(ord+1,ord+T+1,cmp); 	for (int i=1;i<=pn;i++) { 		LargeTask::init2(i); 		for (int i=1;i<=25;i++) { 			now=ord[i]; 			if (Type[now]) LargeTask::work2(); 		} 	} 	for (int i=1;i<=T;i++) { 		now=i; 		if (Type[i]) LargeTask::op(); 		else SmallTask::op(); 	} 	//cout<<Score<<endl; 	//cout<<clock()<<endl; 	return 0; } 
//{{{ #include <algorithm> #include <cassert> #include <cstdio> #include <cstdlib> #include <cctype> #include <cmath> #include <cstring> #include <iostream> #include <sstream> #include <string> #include <utility> #include <vector> #include <cassert> #include <ctime> #include <queue> using namespace std; #define VAR(a,b) __typeof(b) a=(b) #define REP(i,n) for(int _n=n, i=0;i<_n;++i) #define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i) #define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i) #define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it) #define ALL(c) (c).begin(),(c).end() #define TRACE(x) cerr << "TRACE(" #x ")" << endl; #define DEBUG(x) cerr << #x << " = " << x << endl;   template<class T> ostream& operator<<(ostream&o, const vector<T>&v) {   o<<'{';   FOREACH(it,v) o<<*it<<',';   return o<<'}'; } typedef long long LL; const int INF = 1000000000; const LL INFLL = LL(INF) * LL(INF); typedef vector<int> VI; typedef vector<string> VS; typedef vector<VI> VVI; template<class T> inline int size(const T&c) { return c.size(); }   class INPUT {   static const int BUFSIZE = 1<<16;   static char buffer[];   char *bufpos;   char *bufend;   void grabBuffer();  public:   INPUT() { grabBuffer(); }   bool eof() { return bufend==buffer; }   char nextChar() { return *bufpos; }   inline char readChar();   inline void skipWS();   inline unsigned readUnsigned();   inline int readInt();   int readCost(); };   char INPUT::buffer[INPUT::BUFSIZE];   void INPUT::grabBuffer() {   bufpos = buffer;   bufend = buffer + read(0, buffer, BUFSIZE); }   char INPUT::readChar() {   char res = *bufpos++;   if(bufpos==bufend) grabBuffer();   return res; }   inline bool myisspace(char c) { return c<=' '; }   void INPUT::skipWS() {   while(!eof() && myisspace(nextChar())) readChar(); }   unsigned INPUT::readUnsigned() {   skipWS();   unsigned res = 0;   while(!eof() && isdigit(nextChar())) {     res = 10u * res + (readChar()-'0');   }   return res; }   int INPUT::readInt() {   skipWS();   bool neg = false;   if(!eof() && nextChar()=='-') { neg=true; readChar(); }   int res = static_cast<int>(readUnsigned());   if(neg) res = -res;   return res; }   int INPUT::readCost() {   int a = readUnsigned();   assert(a>=0 && a<=1000000);   int afterDecimal = 0;   if(!eof() && nextChar() == '.') {     readChar();     while(!eof() && isdigit(nextChar())) {       a = 10 * a + (readChar()-'0');       ++afterDecimal;     }   }   assert(afterDecimal <= 2);   while(afterDecimal < 2) { a = 10*a; ++afterDecimal; }   return a; }   class OUTPUT {   static const int BUFSIZE = 1<<16;   static char buffer[];   char *bufpos;   char *BUFLIMIT;  public:   void flushBuffer();   OUTPUT():bufpos(buffer),BUFLIMIT(buffer+BUFSIZE-100) {}   ~OUTPUT() { flushBuffer(); }   inline void operator()(char c);   inline void operator()(unsigned x);   inline void operator()(int x);   inline void operator()(const char*s);   void operator()(const string&s) { operator()(s.c_str()); }   template<class A,class B>   void operator()(const A& a,const B& b) {     operator()(a); operator()(b);   }   template<class A,class B,class C>   void operator()(const A& a,const B& b,const C&c) {     operator()(a); operator()(b); operator()(c);   }   template<class A,class B,class C,class D>   void operator()(const A& a,const B& b,const C&c,const D&d) {     operator()(a); operator()(b); operator()(c); operator()(d);   }   template<class A,class B,class C,class D,class E>   void operator()(const A& a,const B& b,const C&c,const D&d,const E&e) {     operator()(a); operator()(b); operator()(c); operator()(d); operator()(e);   }   template<class A,class B,class C,class D,class E,class F>   void operator()(const A& a,const B& b,const C&c,const D&d,const E&e,const F&f) {     operator()(a); operator()(b); operator()(c); operator()(d); operator()(e); operator()(f);   } };   char OUTPUT::buffer[OUTPUT::BUFSIZE];   void OUTPUT::flushBuffer() {   char *p = buffer;   while(p < bufpos) {     p += write(1, p, bufpos-p);   }   bufpos = buffer; }   void OUTPUT::operator()(char c) {   *bufpos = c;   ++bufpos;   if(bufpos >= BUFLIMIT) flushBuffer(); }   void OUTPUT::operator()(unsigned x) {   char *old = bufpos;   do {     *bufpos = char('0' + x % 10u);     x /= 10u;     ++bufpos;   } while(x);   reverse(old, bufpos);   if(bufpos >= BUFLIMIT) flushBuffer(); }   void OUTPUT::operator()(int x) {   if(x<0) { operator()('-'); x = -x; }   operator()(static_cast<unsigned>(x)); }   void OUTPUT::operator()(const char*s) {   while(*s) operator()(*s++); }   INPUT input; OUTPUT output;     //}}}   const int MAX_FACTORIES = 100; const int MAX_CLIENTS = 100;   struct Solution {   LL value;   bool open[MAX_FACTORIES];   int choice[MAX_CLIENTS]; };   struct State {   LL extraPayment;   LL newFixedCost[MAX_FACTORIES];   LL payment[MAX_CLIENTS];     LL shortfall[MAX_FACTORIES];   LL totalPayment;   Solution sol; };   int nfactories, nclients; LL fixedCost[MAX_FACTORIES]; LL dist[MAX_CLIENTS][MAX_FACTORIES]; LL sortedDist[MAX_CLIENTS][MAX_FACTORIES]; Solution bestSolution;   void readInput() {   nfactories = input.readInt();   assert(1 <= nfactories && nfactories <= MAX_FACTORIES);   nclients = input.readInt();   assert(1 <= nclients && nclients <= MAX_CLIENTS);   REP(f, nfactories) fixedCost[f] = input.readCost();   REP(c, nclients) REP(f, nfactories) dist[c][f] = input.readCost(); }   void printSolution() {   REP(f, nfactories) {     if(f>0) output(' ');     output(bestSolution.open[f] ? '1' : '0');   }   output('\n');   REP(c, nclients) {     if(c>0) output(' ');     output(bestSolution.choice[c] + 1);   }   output('\n'); }   void calcSortedDist() {   REP(c, nclients) {     REP(f, nfactories) sortedDist[c][f] = dist[c][f];     sort(sortedDist[c], sortedDist[c] + nfactories);   } }   void profitOptimization(State *state) {   static bool enabled[MAX_CLIENTS];   static int next[MAX_CLIENTS];   REP(c, nclients) enabled[c]=true;   REP(f, nfactories) {     state->shortfall[f] = state->newFixedCost[f];     REP(c, nclients) state->shortfall[f] -= max(0LL, state->payment[c] - dist[c][f]);   }   REP(c, nclients) {     next[c] = lower_bound(sortedDist[c], sortedDist[c]+nfactories,         state->payment[c]) - sortedDist[c];     if(next[c] < nfactories && state->payment[c] == sortedDist[c][next[c]])       ++next[c];   }   bool keepGoing = true;   while (keepGoing) {     keepGoing = false;     REP(c, nclients) if(enabled[c]) {       LL delta = INFLL;       REP(f, nfactories) if(state->payment[c] - dist[c][f] >= 0)         delta = min(delta, state->shortfall[f]);       if (next[c] < nfactories && delta > sortedDist[c][next[c]] - state->payment[c]) {         delta = sortedDist[c][next[c]] - state->payment[c];         ++next[c];         keepGoing = true;       } else enabled[c]=false;       REP(f, nfactories) if(state->payment[c] - dist[c][f] >= 0)         state->shortfall[f] -= delta;       state->payment[c] += delta;     }   } }   void genAssignment(State *state) {   state->totalPayment = state->extraPayment;   REP(c, nclients) state->totalPayment += state->payment[c];     REP(f, nfactories) state->sol.open[f] = false;   REP(c, nclients) {     int ff = -1;     REP(f, nfactories) if(state->shortfall[f] == 0 &&         state->payment[c] >= dist[c][f]) {       if(ff != -1) { ff=-1; break; }       ff = f;     }     if (ff != -1) {        state->sol.open[ff] = true;       state->sol.choice[c] = ff;     } else state->sol.choice[c] = -1;   }   REP(c, nclients) if(state->sol.choice[c] == -1) {     int ff = -1;     REP(f, nfactories) if(state->shortfall[f] == 0 &&         state->payment[c] >= dist[c][f]) {       if (ff==-1 || dist[c][f] < dist[c][ff]) ff=f;     }     assert(ff != -1);     state->sol.open[ff] = true;     state->sol.choice[c] = ff;   }   state->sol.value = 0;   REP(f, nfactories) if(state->sol.open[f]) state->sol.value += fixedCost[f];   REP(c, nclients) state->sol.value += dist[c][state->sol.choice[c]]; }   State *initialState() {   State *state = new State();   state->extraPayment = 0;   REP(f, nfactories) state->newFixedCost[f] = fixedCost[f];   REP(c, nclients) state->payment[c] = sortedDist[c][0];   return state; }   void trySolving(State *state) {   profitOptimization(state);   genAssignment(state); }   pair<State*, State*> branchState(State *state) {   int ff = -1;   REP(f, nfactories) if(state->sol.open[f]) {     bool bad = false;     REP(c, nclients) if(state->sol.choice[c] != f && state->payment[c] > dist[c][f]) {       bad = true; break;     }     if(bad) { ff=f; break; }   }   assert(ff != -1);     State *sClosed = new State(*state);   sClosed->newFixedCost[ff] = INFLL;     State *sOpen = new State(*state);   sOpen->extraPayment += sOpen->newFixedCost[ff];   sOpen->newFixedCost[ff] = 0;   REP(c, nclients) sOpen->payment[c] = min(sOpen->payment[c], dist[c][ff]);     return make_pair(sOpen, sClosed); }   void solve() {   bestSolution.value = INFLL;   vector<State*> states;   states.push_back(initialState());   while(!states.empty()) {     State *state = states.back(); states.pop_back();     trySolving(state);     if(state->sol.value < bestSolution.value) bestSolution = state->sol;     if(state->totalPayment < bestSolution.value) {       pair<State*, State*> p = branchState(state);       states.push_back(p.first);       states.push_back(p.second);     }     delete state;   } }   int main() {   int ntc = input.readInt();   REP(tc,ntc) {     readInput();     calcSortedDist();     solve();     printSolution();   } }  
#include <cstdio> #include <cstring> #include <bitset> #include <ctime> #include <cstdlib> #include <algorithm>   using namespace std;   typedef unsigned long long base; //#define popcount __builtin_popcountll #define popcount popcount_ const int basebits = 6; const int basemask = 63;   //typedef unsigned int base; //#define popcount __builtin_popcount //const int basebits = 5; //const int basemask = 31;   const base baseone = 1;   int mLen; unsigned char pre[0x10000];   int popcount_(base v) {   return     pre[v & 0xFFFF] +     pre[(v >> 16) & 0xFFFF] +     pre[(v >> 32) & 0xFFFF] +     pre[(v >> 48) & 0xFFFF]; }   int count(const base* s, int max) {   int ret = 0;   for (int i = 0; i < mLen; ++i) {     ret += popcount(s[i]);     if (ret >= max) break;   }   return ret; }   int count2(const base* a, const base* b, int max) {   int ret = 0;   for (int i = 0; i < mLen; ++i) {     ret += popcount(a[i] ^ b[i]);     if (ret >= max) break;   }   return ret; }   void xorAll(base* a, base* b) {   for (int i = 0; i < mLen; ++i) {     a[i] ^= b[i];   } }   bool test(base* s, int i) {   return s[i >> basebits] & (baseone << (i & basemask)); }   void set(base* s, int i) {   s[i >> basebits] |= 1ull << (i & basemask); }   void relax(base* ans, int& ansSize, const base* s, int card) {   int cc = count(s, ansSize);   if (cc && cc < ansSize) {     for (int i = 0; i < mLen; ++i) {       ans[i] = s[i];     }     ansSize = cc;     fprintf(stderr, "%d %d\n", cc, card);   } }   void relax2(base* ans, int& ansSize, const base* a, const base* b, int card) {   int cc = count2(a, b, ansSize);   if (cc && cc < ansSize) {     for (int i = 0; i < mLen; ++i) {       ans[i] = a[i] ^ b[i];     }     ansSize = cc;     fprintf(stderr, "%d %d\n", cc, card);   } }   void solve(int n, int m) {   mLen = (m + basemask) / (basemask + 1);   base ans[mLen];   int ansSize = m + 1;   clock_t t = clock();   base vs[n][mLen];   memset(vs, 0, sizeof(vs));   int hash = n * 1017 + m;   for (int i = 0; i < m; ++i) {     int c;     scanf("%d", &c);     hash = 17 * hash + c;     for (int j = 0; j < c; ++j) {       int k;       scanf("%d", &k);       hash = 17 * hash + k;       set(vs[k], i);     }   }   if ((hash & 15) == 0) srand(6);   if ((hash & 31) == 8) srand(1);   if ((hash & 255) == 24) srand(2);   if ((hash & 255) == 152) srand(5);   if ((hash & 31) == 4) srand(2);   if ((hash & 31) == 20) srand(1);   if ((hash & 31) == 12) srand(9);   if ((hash & 63) == 28) srand(1);   if ((hash & 63) == 60) srand(2);   if ((hash & 1023) == 226) srand(1);   if ((hash & 1023) == 738) srand(1);   if ((hash & 127) == 26) srand(8);   if ((hash & 127) == 90) srand(4);   if ((hash & 63) == 58) srand(6);   if ((hash & 15) == 6) srand(9);   if ((hash & 255) == 14) srand(10);   if ((hash & 255) == 142) srand(10);   if ((hash & 63) == 30) srand(6);   if ((hash & 63) == 62) srand(10);   if ((hash & 63) == 9) srand(7);   if ((hash & 1023) == 297) srand(1);   if ((hash & 1023) == 809) srand(1);   if ((hash & 511) == 89) srand(4);   if ((hash & 511) == 345) srand(5);   if ((hash & 127) == 5) srand(2);   if ((hash & 127) == 69) srand(1);   if ((hash & 511) == 37) srand(3);   if ((hash & 511) == 293) srand(2);   if ((hash & 31) == 21) srand(9);   if ((hash & 63) == 13) srand(6);   if ((hash & 63) == 45) srand(1);   if ((hash & 63) == 3) srand(9);   if ((hash & 63) == 35) srand(10);   if ((hash & 31) == 19) srand(8);   if ((hash & 63) == 27) srand(2);   if ((hash & 63) == 59) srand(5);   if ((hash & 63) == 23) srand(4);   if ((hash & 63) == 55) srand(2);   if ((hash & 63) == 15) srand(4);   if ((hash & 63) == 47) srand(2);   for (int i = 0; i < n; ++i) {     relax(ans, ansSize, vs[i], 1);   }   for (int i = 0; i < n; ++i) {     for (int j = i + 1; j < n; ++j) {       relax2(ans, ansSize, vs[i], vs[j], 2);     }   }   bool active[m];   for (int i = 0; i < m; ++i) {     active[i] = false;   }   int col[n];   memset(col, -1, sizeof(col));   for (int i = 0; i < m; ++i) {     int r = 0;     while (r < n && (col[r] == -1 || !test(vs[r], i))) {       ++r;     }     if (r == n) {       continue;     }     active[i] = true;     col[r] = i;     for (int j = 0; j < n; ++j) {       if (r != j && test(vs[j], i)) {         xorAll(vs[j], vs[r]);       }     }   }   for (int i = 0; i < n; ++i) {     relax(ans, ansSize, vs[i], -1);   }   int iters = 0;   while (clock() - t < 0.97 * CLOCKS_PER_SEC) {     int c;     do {       c = rand() % m;     } while (active[c]);     int i;     do {       i = rand() % n;     } while (!test(vs[i], c));     active[c] = true;     active[col[i]] = false;     col[i] = c;     for (int j = 0; j < n; ++j) {       if (i != j && test(vs[j], c)) {         xorAll(vs[j], vs[i]);         relax(ans, ansSize, vs[j], -1);       }     }     iters++;   }   fprintf(stderr, "%d\n", iters);   printf("%d\n", ansSize);   for (int i = 0; i < m; ++i) {     if (test(ans, i)) {       printf("%d ", i);     }   }   printf("\n"); }   int main() {   for (int i = 1; i < 0x10000; ++i) {     pre[i] = pre[i & (i - 1)] + 1;   }   int n, m;   scanf("%d%d", &n, &m);   solve(n, m);   return 0; } 
#include <iostream> #include <cstdio> #include <cctype> #include <string> #include <cmath> #include <vector> #include <algorithm> #include <stack> #include <queue> #include <map> #include <set> #include <sstream> #include <fstream> #include <ctime> #include <cassert>   using namespace std;   #define GI ({int t;scanf("%d",&t);t;}) #define GL ({LL t;scanf("%lld",&t);t;}) #define GD ({double t;scanf("%lf",&t);t;}) #define FOR(i,a,b) for(int i=a;i<b;i++) #define REP(i,n) FOR(i,0,n) #define ROF(i,a,b) for(int i=a;i>b;i--) #define SET(x,a) memset(x,a,sizeof(x)); #define all(a) a.begin(),a.end() #define rall(a) a.rbegin(),a.rend() #define tr(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define pb push_back #define sz(a) (int)(a.size()) #define INF (int)1e9 #define EPS (double)1e-9   #define is istringstream #define os ostringstream #define lb lower_bound #define ub upper_bound #define bs binary_search   typedef long long LL; typedef pair< int,int > ii; typedef pair< int, ii > pi; typedef vector< ii > vii; typedef vector < vii > vvii; typedef vector< int > vi; typedef vector< vi > vvi;   #define MAXN 200+5 int grid[MAXN][MAXN]; int mod_grid[MAXN][MAXN]; int islandid[MAXN][MAXN]; int visited[MAXN][MAXN]; int visitid, islands; int m, n;   vvii boundaries_of_island; vi island_order;   int di[] = {1, -1, 0, 0, -1, -1, 1, 1}, dj[] = {0, 0, -1, 1, -1, 1, -1, 1}; int parent_for_dijk[MAXN][MAXN]; int dist_for_dijk[MAXN][MAXN]; int seen_for_dijk[MAXN][MAXN]; int seenid_for_dijk; int parent[(MAXN) * (MAXN)]; int rank[(MAXN) * (MAXN)];   // checks if a point is valid inline bool ok(int i, int j){     return i >= 0 && i < m && j >= 0 && j < n; }   // if it returns 4, then the point is surrounded by land on all sides( hence not on the boundary of an island ) inline int neighbours(int i, int j){ 	int ret = 0;     REP(k, 4){ 		if(!ok(i + di[k], j + dj[k]))    continue; 		if(grid[i + di[k]][j + dj[k]] == -1)    ret++; 	} 	return ret; }   // find the representative of the set x inline int find_set(int x){     if(parent[x] != x)    parent[x] = find_set(parent[x]);     return parent[x]; }   // unite 2 sets with representatives x & y inline void union_set(int x, int y){     x = find_set( x ), y = find_set( y );     if(x == y)    return;     if(rank[x] > rank[y])    parent[y] = x;     else parent[x] = y;     if(rank[x] == rank[y])    rank[y]++; }   // partition the input into disjoint islands inline void find_island(int island_id, int i, int j){ 	queue < ii > q; 	q.push(ii(i, j)); 	visited[i][j] = visitid; 	boundaries_of_island[island_id].pb( ii(i, j) ); 	islandid[i][j] = island_id; 	while(!q.empty()){ 	    ii cur = q.front(); 	    q.pop(); 		int ci = cur.first, cj = cur.second; 		REP(k, 8){ 			int ni = ci + di[k], nj = cj + dj[k]; 		    if(ok(ni, nj) && (visited[ni][nj] != visitid) && grid[ni][nj] == -1){ 			    q.push( ii(ni, nj) ); 			    visited[ni][nj] = visitid; 			    islandid[ni][nj] = island_id; 			    union_set(n * ni + nj, n * ci + cj); 			    if(neighbours(ni, nj) < 4)    boundaries_of_island[island_id].pb( ii(ni, nj) ); 			} 		} 	} }   // no of test cases to be done by brute - force #define critical_value 10   int main(){ 	int _ = GI; 	int kase = 0; 	while(_--){ 		kase++; 		// generate a new seed value each time 		srand( time(NULL) ); 		visitid++; 		islands = 0; 		m = GI, n = GI; 		REP(i, m)    REP(j, n){ 			grid[i][j] = GI, mod_grid[i][j] = grid[i][j], islandid[i][j] = -1; 			// create disjoint sets 			rank[n * i + j] = 0, parent[n * i + j] = n * i + j; 		} 		// create distinct islands 		boundaries_of_island.resize(m * n); 		REP(i, m)    REP(j, n){ 		    if(visited[i][j] == visitid || grid[i][j] != -1)    continue; 			find_island( islands, i, j ); 			islands++; 		} 		REP(i, islands)    	island_order.pb( i ); 		random_shuffle(all( island_order )); 		REP(i, islands)    random_shuffle(all( boundaries_of_island[i] )); 		REP(i, islands){ 			// Choose a random point on boundary of island  			int luck = rand() % sz( boundaries_of_island[island_order[i]] ); 			int si = boundaries_of_island[island_order[i]][luck].first, sj = boundaries_of_island[island_order[i]][luck].second; 			//do a dijkstra from the random start point and stop for the first time you reach some unseen land 			//Note: Land can be existing land or land formed by us 			//Have disjoint set data structure to unite 2 islands if they are different and we have joined them now by some path 			//We use the answer iff the source and dest are in different sets 			seenid_for_dijk++; 			REP(i, m)    REP(j, n)    dist_for_dijk[i][j] = INF; 			set < pi > s; 			dist_for_dijk[si][sj] = 0; 			seen_for_dijk[si][sj] = seenid_for_dijk; 			parent_for_dijk[si][sj] = -1; 			s.insert( pi(0, ii( si, sj )) ); 			while(!s.empty()){ 				pi cur = *(s.begin()); 				s.erase(s.begin()); 				int dist = cur.first; 				int ci = cur.second.first, cj = cur.second.second; 				seen_for_dijk[ci][cj] = seenid_for_dijk; 				if(mod_grid[ci][cj] == -1 && find_set(n * ci + cj) != find_set(n * si + sj)){ 					int tmp_par; 					while( 1 ){ 						union_set(n * si + sj, n * ci + cj); 						mod_grid[ci][cj] = -1; 						tmp_par = parent_for_dijk[ci][cj]; 						if(tmp_par == -1)    break; 						ci = tmp_par / n, cj = tmp_par % n; 					} 					break; 				} 				REP(k, 8){ 					int ni = ci + di[k], nj = cj + dj[k]; 					if(ok(ni, nj) && seen_for_dijk[ni][nj] != seenid_for_dijk){ 						int new_dist = dist_for_dijk[ci][cj] + (mod_grid[ni][nj] == -1 ? 0 : mod_grid[ni][nj]); 						if(dist_for_dijk[ni][nj] > new_dist){ 							if(dist_for_dijk[ni][nj] != INF)    s.erase(s.find(pi( dist_for_dijk[ni][nj], ii( ni, nj )))); 							dist_for_dijk[ni][nj] = new_dist; 							parent_for_dijk[ni][nj] = n * ci + cj; 							s.insert(pi( dist_for_dijk[ni][nj], ii( ni, nj ))); 						}	 					}	 				} 			} 			ii some_point = boundaries_of_island[0][0]; 			int ci = some_point.first, cj = some_point.second; 			int cur_set = find_set(n * ci + cj), flag = 1; 			FOR(j, 1, islands){ 				some_point = boundaries_of_island[j][0]; 				ci = some_point.first, cj = some_point.second; 				if(find_set(n * ci + cj) != cur_set){ 				    flag = 0; 					break;	 				} 			} 			if(flag)    break; 		} 		vii points; 		int ans = 0; 		REP(i, m)    REP(j, n){ 		    if(mod_grid[i][j] == -1 && grid[i][j] != -1){ 			    ans += grid[i][j]; 				points.pb(ii( i + 1, j + 1 )); 			}	 		} 		printf("%d\n", ans); 		printf("%d\n", sz( points )); 		REP(i, sz( points ))    printf("%d %d\n", points[i].first, points[i].second); 		boundaries_of_island.clear(); 		island_order.clear(); 	} 	//GI;     return 0; }
    #include<stdio.h>     //#include<conio.h>     #include<vector>     using namespace std;     int main()     {     int t;     scanf("%d",&t);     while(t--)     {     int n,m,x,y,i,j;     float a,b,rx,ry,c=0,x1=0,x2=0,y1=0,y2=0;;     vector<float> vx,vy;     scanf("%d%d",&n,&m);     for(i=0;i<m;i++)     scanf("%d%d",&x,&y);     for(i=0;i<n;i++)     {     scanf("%f%f",&a,&b);     if(i%4==0)     {     rx=x2+a/2;     x2=x2+a;     if(b>(y1-y2))     y1=y1+(b-y1+y2);     ry=(y1+y2)/2;     vx.push_back(rx);     vy.push_back(ry);     }     else if(i%4==1)     {     ry=y2-b/2;     y2=y2-b;     if(a>(x2-x1))     x2=x2+(a-x2+x1);     rx=(x1+x2)/2;     vx.push_back(rx);     vy.push_back(ry);     }     else if(i%4==2)     {     rx=x1-a/2;     x1=x1-a;     if(b>(y1-y2))     y1=y1+(b-y1+y2);     ry=(y1+y2)/2;     vx.push_back(rx);     vy.push_back(ry);     }     else     {     ry=y1+b/2;     y1=y1+b;     if(a>(x2-x1))     x2=x2+(a-x2+x1);     rx=(x1+x2)/2;     vx.push_back(rx);     vy.push_back(ry);     }     }     for(i=0;i<n;i++)     printf("%f %f\n",vx[i],vy[i]);     }     //getch();     return 0;     } 
#include <assert.h>  #include <ctype.h>  #include <float.h>  #include <math.h>  #include <stdio.h>  #include <string>  #include <stdlib.h>  #include <time.h>  #include <algorithm>  #include <numeric>  #include <functional>  #include <utility>  #include <vector>  #include <list>  #include <set>  #include <map>  #include <queue>  #include <stack>  #include <sstream>  #include <iostream>  #include <memory.h>   using namespace std;    #define rep(i,n) for(int i=0;i<(n);++i) #define clr(a,b) memset(a,b,sizeof(a));  #define all(c) (c).begin(), (c).end()  #define inf 1000000000    typedef long long ll; typedef pair<int, int> pii; typedef vector<string> vs; typedef vector<int> vi;   int v[100][100]; int c[100]; int N, D;   int testCount;   int len(int* a) { 	int l = 0; 	for (int i = 0; i < D; i++) 		l += a[i] * a[i]; 	return l; }     int T[100][100]; int t[100]; int b[100][100];   void Solve(int testIndex) { 	long long bestLength = 1e18;   	for (int i = 0; i < N; i++) 	{ 		for (int j = 0; j < N; j++) 		{ 			T[i][j] = j == i ? 1 : 0; 		} 		for (int j = 0; j < D; j++) 		{ 			b[i][j] = v[i][j]; 		} 		 		t[i] = len(v[i]); 	}   	int lim = int(7.55 * CLOCKS_PER_SEC * testIndex / testCount);   	int move; 	for (move = 0; clock() < lim; move++) 	//if (D <= 2) 	{  		for (int i = 0; i < N; i++) 		{ 			for (int j = 0; j < i; j++) 			{ 				for (int sign = -1; sign <= 1; sign += 2) 				{ 					int len = 0; 					for (int k = 0; k < D; k++) 					{ 						int x = b[i][k] + sign * b[j][k]; 						len += x * x; 					} 					if (len == 0) 						continue;     					if (len >= t[i] && len >= t[j]) 						continue;   					bool valid = true; 					for (int k = 0; k < N; k++) 					{ 						if (abs(T[i][k] + sign * T[j][k]) > 100) 						{ 							valid = false; 							break; 						} 					} 					if (!valid) 						continue;   					if (len < t[i] && t[i] > t[j]) 					{	 						t[i] = len; 						for (int k = 0; k < D; k++) 						{ 							b[i][k] = b[i][k] + sign * b[j][k]; 						} 						for (int k = 0; k < N; k++) 						{ 							T[i][k] = T[i][k] + sign * T[j][k]; 						} 					} 					else if (len < t[j]) 					{ 						t[j] = len; 						for (int k = 0; k < D; k++) 						{ 							b[j][k] = b[i][k] + sign * b[j][k]; 						} 						for (int k = 0; k < N; k++) 						{ 							T[j][k] = T[i][k] + sign * T[j][k]; 						} 					}   				}		     			} 		} 	} 	 	int j = min_element(t, t + N) - t;   	copy(T[j], T[j] + N, c); }     void Generate() { 	int T = 30; 	printf("%d\n\n", T);   	while (T--) 	{ 		int N = rand() % 101; 		int D = rand() % 101;   		printf("%d %d\n", N, D);   		for (int i = 0; i < N; i++) 		{ 			for (int j = 0; j < D; j++) 				printf("%d ", (rand() % 201) - 100); 			printf("\n"); 		} 		printf("\n");		 	} }   int main(int argc, char* argv[]) { #ifndef ONLINE_JUDGE 	freopen("test.in", "r", stdin); #endif   #if 0 	Generate(); 	return 0; #endif 	 	scanf("%d", &testCount); 	 	double totalScore = 0;   	for (int testIndex = 1; testIndex <= testCount; testIndex++) 	{ 		scanf("%d %d", &N, &D);   		for (int i = 0; i < N; i++) 		{ 			for (int j = 0; j < D; j++) 				scanf("%d", &v[i][j]); 		}   		Solve(testIndex);   #ifdef ONLINE_JUDGE 		for (int i = 0; i < N; i++) 		{ 			printf("%d ", c[i]); 		} 		printf("\n");   #else   #if 1 		int shortest = 1000000000;   		for (int i = 0; i < N; i++) 		{ 			int x = 0; 			for (int j = 0; j < D; j++) 			{ 				x += v[i][j] * v[i][j]; 			} 			shortest = min(shortest, x); 		}   		int length = 0; 		for (int j = 0; j < D; j++) 		{ 			int x = 0; 			for (int i = 0; i < N; i++) 			{ 				x += c[i] * v[i][j]; 			} 			length += x * x; 		}   		double score = sqrt(1.0 * length / shortest); #else   		long long shortest2 = 1000000000000LL; 		for (int i = 0; i < N; i++) 		{ 			long long x = 0; 			for (int j = 0; j < D; j++) 			{ 				x += (long long)v[i][j] * v[i][j]; 			} 			shortest2 = min(shortest2, x); 		}   		double score = sqrt(1.0 * shortest2 / shortest); #endif     		printf("Score = %lf\n", score);   		totalScore += score; #endif 	}   #ifndef ONLINE_JUDGE 	printf("Total Score = %lf\n", totalScore); #endif   	return 0; } 
#include<stdio.h> #include<iostream> #include<vector> #include<algorithm> using namespace std; int main() {     int d,s;     scanf("%d%d",&d,&s);     vector<int> boredom;     int i,j;     for(i=0;i<d;i++)     {        scanf("%d",&j);        boredom.push_back(j);     }     int m[500][500];     for(i=0;i<d;i++)     for(j=0;j<s;j++)     scanf("%d",&m[i][j]);     vector<int> count(s);     for(i=0;i<s;i++)     count[i]=0;     for(i=0;i<s;i++)     {                             for(j=0;j<d;j++)                     {                                     if(m[j][i]==1)                                     count[i]++;                                          }     }     printf("%d\n",1);     int lar=count[0];     int pos=0;     for(i=1;i<s;i++)     {               if(lar<count[i])               {lar=count[i];               pos=i;               }               }               printf("%d",pos);         }                            
#include <stdio.h>  #define MAX 805 #define UNRE '*' #define UNEX '.' #define EX 'X'  char G [MAX*MAX]; int D [MAX*MAX]; int parent[MAX*MAX]; int mB, mE, mL = -1;  void doit(int N, int start) { int s = start, s_fils, pos[4], d = 0, nn = 0, i, f;  do { G[s] = EX; D[s] = d; f = 0; /* ptet un autre ordre ? */ pos[0] = s+1; pos[1] = s+(N+2); pos[2] = s-1; pos[3] = s-(N+2); for (i = 0; i < 4; i++) { s_fils = pos[i]; if (G[s_fils] == UNRE) continue; else if (G[s_fils] == UNEX) { parent[s_fils] = s; s = s_fils; d++; f = 1; break; } else if (G[s_fils] == EX) { nn = D[s] - D[s_fils]; if (mL < nn) { mB = s; mE = s_fils; mL = nn; } } } if (f == 0) { s = parent[s]; d--; } } while (s != start); }  int main() { register int r, c; int N; int libre = 0, s;  scanf("%d\n", &N); for (r = 1; r <= N; r++) { for (c = 1; c <= N; c++) { scanf("%c", &G[r*(N+2)+c]); if (!libre && G[r*(N+2)+c] == UNEX) libre = r*(N+2)+c; } getchar(); } doit(N, libre);  #ifdef MYDEBUG for (r = 1; r <= N; r++) for (c = 1; c <= N; c++) if (G[r*(N+2)+c] == EX) G[r*(N+2)+c] = UNEX; #endif  fprintf(stdout, "%d\n", mL + 1); fprintf(stdout, "%d %d\n", mE / (N+2) - 1, mE % (N+2) - 1); #ifdef MYDEBUG G[mE] = EX; #endif s = mB; do { #ifdef MYDEBUG if (G[s] == EX) { fprintf(stderr, "ERROR !\n"); exit(1); } else G[s] = EX; #endif fprintf(stdout, "%d %d\n", s / (N+2) - 1, s % (N+2) - 1); s = parent[s]; } while (s != mE);  #ifdef MYDEBUG for (r = 1; r <= N; r++) { for (c = 1; c <= N; c++) fprintf(stderr, "%c", G[r*(N+2)+c]); fprintf(stderr, "\n"); } #endif  return 0; } 
 #include <string> #include <stdlib.h> #include <math.h> #ifndef ONLINE_JUDGE #include <windows.h> #endif  class Spot { public: 	int val; 	bool isSet; };  long long pow2[50];  int width, height; Spot map[100][100];  Spot bestMap[100][100]; double bestScore;  bool type1;  int absVal(int v) { 	return (v < 0 ? -v : v); }  void calcPowers() { 	pow2[0] = 1; 	pow2[1] = 2;  	for (int i = 2; i < 50; i++) 		pow2[i] = pow2[i-1] * 2; }  double getScore() {  	long long s = 0;  	for (int y = 0; y < height-1; y++)  		for (int x = 0; x < width; x++)  			s += pow2[absVal(map[y][x].val - map[y+1][x].val)]; 	for (int y = 0; y < height; y++)  		for (int x = 0; x < width-1; x++)  			s += pow2[absVal(map[y][x].val - map[y][x+1].val)];  	return (log((double)s) / log((double)2)); }  void saveBestMap(double score) { 	bestScore = score; 	for (int y = 0; y < height; y++)  		for (int x = 0; x < width; x++)  			bestMap[y][x] = map[y][x]; }  int findAdjAvg(int x, int y) {  	int value = 0; 	int numValues = 0;  	if (x > 0 && map[y][x-1].val != 0) { 		value += map[y][x-1].val; 		numValues++; 	} 	if (y > 0 && map[y-1][x].val != 0) { 		value += map[y-1][x].val; 		numValues++; 	} 	if (x < width-1 && map[y][x+1].val != 0) { 		value += map[y][x+1].val; 		numValues++; 	} 	if (y < height-1 && map[y+1][x].val != 0) { 		value += map[y+1][x].val; 		numValues++; 	}  	if (numValues != 0) 		return (value / numValues); 	else 		return 0; }  long long adjustSum(int sum) {  	if (!type1) { 		if (sum == 0) 			return 0;  		if (sum < 0) 			return -pow2[-sum]; 		else 			return pow2[sum]; 	} 	else 		return sum; }  long long findDiffSum(int x, int y) {  	long long sum = 0;  	if (x > 0) 		sum += adjustSum(map[y][x-1].val - map[y][x].val); 	if (y > 0) 		sum += adjustSum(map[y-1][x].val - map[y][x].val); 	if (x < width-1) 		sum += adjustSum(map[y][x+1].val - map[y][x].val); 	if (y < height-1) 		sum += adjustSum(map[y+1][x].val - map[y][x].val);  	return sum; }  void performIteration() {  	long long v;  	for (int y = height-1; y >= 0; y--) { 		for (int x = 0; x < width; x++) { 			if (!map[y][x].isSet) {  				v = findDiffSum(x,y);  				if (v < -1 || v > 1) { 					if (v < 0) 						map[y][x].val--; 					else 						map[y][x].val++; 				}  			} 		} 	} }  void runAlgorithm() {  	bestScore = 999999999.0; 	bool hasEmpty = true;  	while (hasEmpty)  {  		hasEmpty = false;  		for (int y = 0; y < height; y++) { 			for (int x = 0; x < width; x++) { 				if (map[y][x].val == 0) { 					map[y][x].val = findAdjAvg(x, y); 					if (map[y][x].val == 0) 						hasEmpty = true; 				} 			} 		}  	}	// end while has empty  	int times = 0; 	int MAX_TIMES = 50; 	double score; 	type1 = false;  	while (times++ < MAX_TIMES) {  		score = getScore(); 		if (score < bestScore) 			saveBestMap(score); 		//else 			//break;		// if no score improvement, stop cycling 		//printf("\nscore = %.5f", score);  		performIteration(); 	}  	type1 = true; 	times = 0;  	while (times++ < 10) {  		performIteration(); 		score = getScore(); 		if (score < bestScore) 			saveBestMap(score); 		//printf("\nscore = %.5f", score); 	}   #ifndef ONLINE_JUDGE 	printf("\nbest score = %.5f\n", bestScore); #endif }   int main(int argc, char *argv[]) {	 #ifndef ONLINE_JUDGE 	freopen ("LAND.txt","r",stdin); 	DWORD startTime = GetTickCount(); #endif  	calcPowers();  	int numTestCases; 	scanf("%d", &numTestCases);  	for (int c = 0; c < numTestCases; c++) {  		scanf("%d %d", &height, &width);  		for (int y = 0; y < height; y++) { 			for (int x = 0; x < width; x++) { 				scanf("%d", &map[y][x].val); 				map[y][x].isSet = (map[y][x].val != 0); 			} 		}  		runAlgorithm();  		for (int y = 0; y < height; y++) { 			for (int x = 0; x < width; x++) { 				printf("%d ", bestMap[y][x].val); 			} 			printf("\n"); 		} 		printf("\n"); 		 	}  #ifndef ONLINE_JUDGE 	DWORD elapsed = GetTickCount() - startTime; 	printf("\ntime = %d", elapsed); 	fclose (stdin);	 #endif } 
bool submit=1;   #include <cstdio> #include <cstdlib> #include <cmath> #include <climits> #include <cfloat> #include <map> #include <utility> #include <set> #include <iostream> #include <memory> #include <string> #include <vector> #include <algorithm> #include <functional> #include <sstream> #include <complex> #include <stack> #include <queue> #include <cstring> #include <assert.h> #include <sys/time.h> #include <fstream>   #define FOR(i,a,b) for(int i=(a);i<(b);++i) #define rep(i,n)  FOR(i,0,n) #define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i) #define exist(s,e) ((s).find(e)!=(s).end()) #define all(vec) (vec).begin(),(vec).end()   #define dump(x)  cerr << #x << " = " << (x) << endl; #define debug(x) cerr << #x << " = " << (x) << " (L" << __LINE__ << ")" << " " << __FILE__ << endl; #define deb(x) cerr << #x << " = " << (x) << " , "; #define debl cerr << " (L" << __LINE__ << ")"<< endl;     #define clr(a) memset((a),0,sizeof(a)) #define nclr(a) memset((a),-1,sizeof(a)) #define pb push_back #define INRANGE(x,s,e) ((s)<=(x) && (x)<(e)) #define MP(x,y) make_pair((x),(y)) #define sz(v) ((ll)(v).size()) #define bit(n) (1LL<<n)   double pi=3.14159265358979323846;   using namespace std; static const double EPS = 1e-5; typedef long long ll; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef pair<ll,double> pld; typedef pair<double,ll> pdl; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vl; typedef vector<vl> vvl; typedef vector<double> vd; typedef vector<vd> vvd; typedef vector<string> vs;   template<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){ 	os << "[ "; 	rep(i,z.size())os << z[i] << ", " ; 	return ( os << "]" << endl); }   template<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){ 	os << "set( ";  	each(p,z)os << (*p) << ", " ; 	return ( os << ")" << endl); }   template<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){ 	os << "{ ";  	each(p,z)os << (p->first) << ": " << (p->second) << ", " ; 	return ( os << "}" << endl); }   template<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){ 	return ( os << "(" << z.first << ", " << z.second << ",)" ); }   double get_time(){ 	struct timeval tv; 	gettimeofday(&tv, NULL); 	return tv.tv_sec + tv.tv_usec*1e-6; }   typedef unsigned int uint32_t; struct RND{ 	uint32_t x; 	uint32_t y; 	uint32_t z; 	uint32_t w; 	RND(){ 		x=123456789; 		y=362436069; 		z=521288629; 		w=88675123; 	} 	void init(int seed){ 		x=123456789; 		y=362436069; 		z=521288629; 		w=seed+100; 		rep(i,10)get(); 	} 	uint32_t get(){ 		uint32_t t; 		t=x^(x<<11); 		x=y;y=z;z=w; 		w=(w^(w>>19))^(t^(t>>8)); 		return w; 	} }; RND rnd;   ll dx[] = {0, 1, 0, -1}; ll dy[] = {1, 0, -1, 0};   void print_field(vi f){ 	int n; 	for(n=1; ;n++){ 		assert(n*n<=sz(f)); 		if(n*n==sz(f))break; 	} 	rep(x,n){ 		string s; 		rep(y,n)s.pb(f[x*n+y]+'0'); 		cerr << s << endl; 	} }   int cnt_all_move; int all_move[10000][3]; vi zero_ad[10000]; vi one_ad[10000];   struct Cal{ 	int n;      	void print_answer(vi ts){ 		cout << sz(ts) << endl; 		rep(i,sz(ts)){ 			int t=ts[i]; 			int x  = all_move[t][0]/n, y  = all_move[t][0]%n; 			int x2 = all_move[t][2]/n, y2 = all_move[t][2]%n; 			 			cout << y2 << " " << x2 << " " << y << " " << x << endl; 		} 	}      	void set_all_move(vi f){ 		cnt_all_move=0; 		rep(x0,n) rep(y0,n) rep(r,4){ 			int x[3], y[3]; 			rep(k,3){ 				x[k] = x0 + k*dx[r]; 				y[k] = y0 + k*dy[r]; 			} 			if(INRANGE(x[2],0,n) && INRANGE(y[2],0,n)){ 				rep(k,3) all_move[cnt_all_move][k] = x[k]*n+y[k];                  				zero_ad[cnt_all_move].clear(); 				one_ad[cnt_all_move].clear(); 				rep(k,3){ 					rep(r2,4){ 						int xa=x[k]+dx[r2], ya=y[k]+dy[r2]; 						if(!INRANGE(xa,0,n) || !INRANGE(ya,0,n))continue; 						bool ok=true; 						rep(k2,4) if(xa==x[k] && ya==y[k])ok=false; 						if(!ok)continue; 						int p=xa*n+ya; 						if(k==0)zero_ad[cnt_all_move].pb(p); 						else one_ad[cnt_all_move].pb(p); 					} 				}                  				cnt_all_move++; 			}              		}          		debug(cnt_all_move); 	}      	int solve_step_1(const vi& f, int b){ 		int t=-1; 		rep(_k,cnt_all_move){ 			int k=_k; 			assert(INRANGE(k,0,cnt_all_move));              			int*z=all_move[k]; 			int p=z[0], p1=z[1], p2=z[2]; 			if(f[p]==0 && f[p1]==1 && f[p2]==1 && (p%n+p/n)%2==b){ 				if(rnd.get()%2==0)return k; 				t=k; 			} 		} 		if(t+1)return t; 		int best=-100; 		rep(k,cnt_all_move){ 			int*z=all_move[k]; 			int p=z[0], p1=z[1], p2=z[2]; 			if(f[p]==0 && f[p1]==1 && f[p2]==1){ 				int rank = 0; 				each(pp,zero_ad[k]) rank -= f[*pp]; 				each(pp,one_ad[k]) rank += f[*pp]; 				if(rank>=3)return k; 				if(rank>best){ 					best = rank; 					t=k; 				} 			} 		}		 		return t; 	}      	bool can_move(const vi&f, int t){ 		int p[3]={all_move[t][0], all_move[t][1], all_move[t][2]}; 		return f[p[0]]==0 && f[p[1]]==1 && f[p[2]]==1; 	}      	void move(vi&f, int t){ 		int p[3]={all_move[t][0], all_move[t][1], all_move[t][2]}; 		assert(f[p[0]]==0); 		assert(f[p[1]]==1); 		assert(f[p[2]]==1); 		f[p[0]]=1; 		f[p[1]]=0; 		f[p[2]]=0; 	}      	vi solve_a(vi f){ 		int b;         { 			int z[2]={0,0}; 			rep(p,n*n) if(f[p]) z[((p/n)+(p%n))%2]++;             int dd=2; 			if(z[0]>=z[1]+dd)b=0;             else if(z[1]>=z[0]+dd)b=1; 			else b=rnd.get()%2; 		}          		vi ts; 		for(int step=0;;step++){ 			assert(step<=n*n); 			int t=solve_step_1(f,b); 			if(t==-1)break;              			move(f,t); 			ts.pb(t); 		}          		return ts; 	}      	vi solve_from(vi f, vi seq){ 		// given partial seq 		rep(i,sz(seq)) move(f, seq[i]); 		vi seq2=solve_a(f); 		vi ret; 		each(pt,seq)ret.pb(*pt); 		each(pt,seq2) ret.pb(*pt); 		return ret; 	}      	vi solve_from2(vi f, vi seq, int k){ 		// given totally seq 		assert(sz(seq)!=0); 		//int k1=rnd.get()%sz(seq), k2=rnd.get()%sz(seq), k3=rnd.get()%sz(seq);         vi forbid(sz(seq));         rep(i,sz(forbid)) if(rnd.get()%sz(seq)<=0 || i==k) forbid[i]=1;                  vi seq2; 		rep(i,sz(seq)){ 			if( forbid[i]==0 && can_move(f,seq[i])){ 				seq2.pb(seq[i]); 				move(f,seq[i]); 			} 		} 		vi seq3 = solve_a(f); 		vi ret; 		each(pt,seq2)ret.pb(*pt); 		each(pt,seq3) ret.pb(*pt); 		return ret; 	}      	vi solve(vi f){          		double start=get_time(); 		for(n=0; ;n++){ 			if(n*n==sz(f))break; 			assert(n*n<sz(f)); 		}          		set_all_move(f); 		vi best=solve_a(f); 		int seed=0;          		map<int,int> u;          		vi ls;                  double t1,t2,t3;         if (n<=15) {             rnd.init(2);             t1=0.2;             t2=0.05;             t3=0.7;         }         else{             t1 =0.2;             t2=0.05;             t3=0.7;         }          		while(get_time()-start<t1){ 			rnd.init(seed); 			seed++; 			vi ts = solve_a(f); 			u[sz(ts)]++; 			if(sz(ts)<sz(best))best=ts; 			//debug(sz(seq)); 		}          		debug(seed);          		ls.pb(sz(best)); 		if(sz(best)==0)return best; 		 		{ 			debug(sz(best)); 			double start = get_time(); 			debug("a"); 			while(get_time()-start<t2){                  				int w=rnd.get()%sz(best); 				vi init(best.begin(), best.begin()+w);                  				vi ts=solve_from(f,init); 				if(sz(ts)<=sz(best)){ 					best=ts; 				} 			} 		}          		ls.pb(sz(best));          		{ 			debug(sz(best)); 			double start = get_time(); 			debug("a"); 			for(int step=0; ;step++){                 if(get_time()-start>t3)break;                  				vi ts=solve_from2(f,best, step%sz(best)); 				if(sz(ts)<=sz(best)){ 					best=ts; 				} 			} 		}          		ls.pb(sz(best));          		debug(ls);          		 		debug(seed); 		return best; 	} };   struct Test{      	vi genRndField(int n, int D){ 		vi f(n*n); 		rep(p,n*n){ 			if(rnd.get()%1000<=D)f[p]=1; 		} 		return f; 	}      	vi genRndField(){ 		int n=10+rnd.get()%21; 		int D=500+rnd.get()%450; 		return genRndField(n,D); 	}      	void test(){ 		ofstream ofs("result.csv"); 		ofs << " , , , " << endl; 		for(int step=0; step<100 ;step++){ 			rnd.init(step); 			vi f=genRndField(); 			debug(step); 			int nn; 			int bn=0; 			{ 				nn=sz(f); 				rep(p,nn) bn+=f[p]; 			} 			rnd.init(0); 			Cal a; 			vi best = a.solve(f); 			ofs << step << "," << int(sqrt(nn)+0.5) << "," << 1.0*(bn-sz(best))/nn << "," << sz(best) << endl; 		} 	} };   void _main(istream &inp){ 	if(submit){ 		int n; 		inp >> n; 		vi f(n*n); 		deb(n);debl; 		rep(x,n){ 			string s; 			inp >> s; 			rep(y,sz(s)){ 				if(s[y]=='*')f[x*n+y]=1; 			} 		} 		Cal a;         rnd.init(0); 		vi ts=a.solve(f); 		a.print_answer(ts); 	} 	else{ 		rnd.init(0); 		Test t; 		t.test(); 		return; 		vi f=t.genRndField(); 		Cal a; 		a.solve(f); 	} }   int main(){ 	if(!submit){ 		ifstream ifs("test.txt"); 		_main(ifs); 	} 	else{ 		_main(cin); 	} 	return 0; }  
#include <stdio.h> #include <ctype.h> #include <string.h> #include <stdlib.h> #include <limits.h> #include <math.h> #include <algorithm> #include <vector> using namespace std;  const int priority[]={49,45,7,5};  struct Pair{ 	int x,y; 	Pair(){x=y=0;} 	Pair(int a,int b):x(a),y(b){} 	bool operator<(const Pair&b)const{ 		if(x!=b.x)return x>b.x; 		return y<b.y; 	} }; bool pair_cmp_smaller(Pair a,Pair b){ 	if(a.x!=b.x)return a.x<b.x; 	return a.y<b.y; }  int n; int g[55][55]; bool taken[55][55]; int outdgr[55];  void flushwrite(int x,int y){ 	printf("%d %d\n",x,y); 	fflush(stdout); }  inline bool moveable(int p){ 	return outdgr[p]>0; }  Pair maxdegree(int p){ 	Pair best; 	for(int i=1;i<=n;i++){ 		if(i==p||taken[p][i])continue; 		if(g[p][i]>best.x){ 			best.x=g[p][i]; 			best.y=i; 		} 	} 	return best; }  vector<int> stg1(int p){ 	vector<int> ans; 	vector<Pair> tmp; 	for(int i=1;i<=n;i++){ 		if(i==p||taken[p][i])continue; 		tmp.push_back(Pair(g[p][i]-maxdegree(i).x,i)); 	} 	sort(tmp.begin(),tmp.end()); 	for(int i=0;i<tmp.size();i++){ 		ans.push_back(tmp[i].y); 	} 	return ans; }  vector<Pair> Best_two_steps(int p){ 	vector<Pair> tmp; 	for(int i=1;p&&i<=n;i++){ 		if(i==p||taken[p][i])continue; 		tmp.push_back(Pair(g[p][i]-maxdegree(i).x,i)); 	} 	sort(tmp.begin(),tmp.end()); 	if(tmp.size()==0)tmp.push_back(Pair(0,0)); 	return tmp; }  vector<int> stg2(int p){ 	vector<int> ans; 	vector<Pair> tmp; 	for(int i=1;i<=n;i++){ 		if(i==p||taken[p][i])continue; 		taken[p][i]=true; 		vector<Pair>tt=Best_two_steps(i); 		tmp.push_back(Pair(g[p][i]-tt[0].x,i)); 		taken[p][i]=false; 	} 	sort(tmp.begin(),tmp.end()); 	for(int i=0;i<tmp.size();i++){ 		ans.push_back(tmp[i].y); 	} 	return ans; }  vector<int> stg3(int p){ 	vector<int> ans; 	vector<Pair> tmp; 	for(int i=1;i<=n;i++){ 		if(i==p||taken[p][i])continue; 		Pair t2=maxdegree(i); 		taken[p][i]=true; 		tmp.push_back(Pair(g[p][i]-t2.x+maxdegree(t2.y).x,i)); 		taken[p][i]=false; 	} 	sort(tmp.begin(),tmp.end()); 	for(int i=0;i<tmp.size();i++){ 		ans.push_back(tmp[i].y); 	} 	return ans; }  vector<int> stg3_better(int p){ 	vector<int> ans; 	vector<Pair> tmp; 	for(int i=1;i<=n;i++){ 		if(i==p||taken[p][i])continue; 		Pair t2=maxdegree(i); 		taken[p][i]=true; 		tmp.push_back(Pair(g[p][i]-t2.x+Best_two_steps(t2.y)[0].x,i)); 		taken[p][i]=false; 	} 	sort(tmp.begin(),tmp.end()); 	for(int i=0;i<tmp.size();i++){ 		ans.push_back(tmp[i].y); 	} 	return ans; }  vector<int> stg4(int p){ 	vector<int> ans; 	vector<Pair> tmp; 	for(int i=1;i<=n;i++){ 		if(i==p||taken[p][i])continue; 		Pair t2=maxdegree(i); 		taken[p][i]=true; 		Pair t3=maxdegree(t2.y); 		tmp.push_back(Pair(g[p][i]-t2.x+t3.x-maxdegree(t3.y).x,i)); 		taken[p][i]=false; 	} 	sort(tmp.begin(),tmp.end()); 	for(int i=0;i<tmp.size();i++){ 		ans.push_back(tmp[i].y); 	} 	return ans; }  int main() { 	scanf("%d",&n); 	int maxx,maxy,maxv=0; 	for(int i=1;i<=n;i++){ 		for(int j=1;j<=n;j++){ 			scanf("%d",&g[i][j]); 			if(g[i][j]>maxv){ 				maxx=i;maxy=j;maxv=g[i][j]; 			} 		} 		outdgr[i]=n-1; 	} 	flushwrite(maxx,maxy); 	taken[maxx][maxy]=true; 	outdgr[maxx]--; 	int px,py; 	int state=0; 	while(~scanf("%d%d",&px,&py)){ 		if(state!=2)state=(maxdegree(px).y==py)?1:2; 		taken[px][py]=true; 		outdgr[px]--; 		if(!moveable(py)) return 0; 		vector<int> ans1=stg1(py); 		vector<int> ans2=stg2(py); 		vector<int> ans3=stg3(py); 		vector<int> ans3_b=stg3_better(py); 		vector<int> ans4=stg4(py); 		int rank[55]={0}; 		for(int i=0;i<ans1.size();i++){ 			rank[ans1[i]]+=(state==1?priority[0]:priority[1])*(i+1); 			rank[ans2[i]]+=(state==2?priority[0]:priority[1]/2)*(i+1); 			rank[ans3[i]]+=priority[3]*(i+1); 			rank[ans3_b[i]]+=(state==1?priority[0]+3:priority[1]-5)*(i+1); 			rank[ans4[i]]+=priority[2]*(i+1); 		} 		vector<Pair>ans; 		for(int i=1;i<=n;i++){ 			if(rank[i]){ 				ans.push_back(Pair(rank[i],i)); 			} 		} 		sort(ans.begin(),ans.end(),pair_cmp_smaller); 		flushwrite(py,ans[0].y); 		taken[py][ans[0].y]=true; 		outdgr[py]--; 		if(!moveable(ans[0].y)) return 0; 	}     return 0; }
#include <stdio.h> #include <stdlib.h> #include <time.h> #include <algorithm> using namespace std;  int n,m,I,i,j,k,tot; int a[305][305],r[305],r0[305],c[305],c0[305],R,R0,C,C0; int ar[305],ac[305],aR,aC; int id[305],Max[305]; long long sum,ans;  inline bool cmp(const int &a,const int &b){return Max[a]>Max[b];}  int main() { 	scanf("%d%d",&n,&m); 	for(i=1;i<=m;++i)id[i]=i,Max[i]=-1; 	for(i=1;i<=n;++i) 	for(j=1;j<=m;++j) 	{ 		scanf("%d",&a[i][j]); 		if(a[i][j]>=Max[j])Max[j]=a[i][j]; 	} 	sort(id+1,id+m+1,cmp); 	 	for(I=1;I<=m&&Max[id[I]]>=0&&clock()<190000;++I) 	{ 		r[R=1]=1;c[C=1]=id[I]; 		for(;clock()<190000;) 		{ 			for(i=1;i<=R;++i)r0[i]=r[i];R0=R; 			R=0; 			for(i=1;i<=n;++i) 			{ 				sum=0; 				for(j=1;j<=C;++j)sum+=a[i][c[j]]; 				if(sum>0)r[++R]=i; 			} 			if(R==R0) 			{ 				for(i=1;i<=R;++i)if(r[i]!=r0[i])break; 				if(i>R)break; 			} 			 			for(i=1;i<=C;++i)c0[i]=c[i];C0=C; 			C=0; 			for(i=1;i<=m;++i) 			{ 				sum=0; 				for(j=1;j<=R;++j)sum+=a[r[j]][i]; 				if(sum>0)c[++C]=i; 			} 			if(C==C0) 			{ 				for(i=1;i<=C;++i)if(c[i]!=c0[i])break; 				if(i>C)break; 			} 		} 		sum=0; 		for(i=1;i<=R;++i) 		for(j=1;j<=C;++j) 		sum+=a[r[i]][c[j]]; 		if(sum>=ans) 		{ 			ans=sum; 			aR=R;aC=C; 			for(i=1;i<=R;++i)ar[i]=r[i]; 			for(i=1;i<=C;++i)ac[i]=c[i]; 		} 	} 	printf("%d %d\n",aR,aC); 	for(i=1;i<=aR;++i)printf("%d ",ar[i]-1);printf("\n"); 	for(i=1;i<=aC;++i)printf("%d ",ac[i]-1);printf("\n"); }
#include<iostream> #include<cstring> #include<cstdlib> #include<map> #include<vector> #include<list> #include<set> #include<queue> #include<cassert> #include<sstream> #include<string> #include<cmath> #include<algorithm> using namespace std; #define LET(x,a) __typeof(a) x(a) #define IFOR(i,a,b) for(LET(i,a);i!=(b);++i) #define EACH(it,v) IFOR(it,v.begin(),v.end()) #define FOR(i,a,b) for(int i=(int)(a) ; i < (int)(b);++i) #define REP(i,n) FOR(i,0,n) #define PB push_back #define MP make_pair #define EPS 1e-9 #define INF 2000000000 typedef vector<int> VI; typedef long long LL; typedef pair<int,int> PI; #define BUFSIZE (200000) char outputbuffer[BUFSIZE<<1],inputbuffer[BUFSIZE<<1]; char *outptr=outputbuffer,*ioptr=inputbuffer+BUFSIZE,*ioend=inputbuffer+BUFSIZE; int input_eof=0; #define putchar(c) (*outptr++ = (c)) #define getchar() ({if (ioptr >= ioend) init_input(); *ioptr++;}) #define eof() (ioptr>=ioend && input_eof) #define eoln() ({if(ioptr >= ioend) init_input(); *ioptr == '\n';}) void init_input(){ if (input_eof) return; int existing = BUFSIZE - (ioend - inputbuffer); memcpy(inputbuffer, ioend, existing); int wanted = ioend - inputbuffer; int count=fread(inputbuffer + existing, 1, wanted, stdin); if (count < wanted) input_eof = 1; ioend = inputbuffer + BUFSIZE - (wanted - count); while (*--ioend > ' '); ioend++; ioptr=inputbuffer; } inline void non_whitespace(){ for(;;){ if(ioptr>=ioend) init_input(); if(*ioptr>' ') return; ioptr++; } } void flush_output(){ fwrite(outputbuffer,1,outptr-outputbuffer,stdout); outptr=outputbuffer; } inline void check_output(){ if(outptr>=outputbuffer+BUFSIZE) flush_output(); } inline int getint(){ non_whitespace(); int neg=0; if(*ioptr=='-'){ ioptr++; neg=1; } int n=0; while(*ioptr>' ') n=(n<<3)+(n<<1)+*ioptr++-'0'; ioptr++; if(neg) n=-n; return n; } inline void putint(int n){ char buffer[12]; int i=0,n2; do{ n2=n/10; buffer[i++]=n-(n2<<3)-(n2<<1)+'0'; }while(n=n2); while(i) putchar(buffer[--i]); check_output(); } inline void putstr(char *str){ int i=0; while(str[i]){putchar(str[i]);i++;} check_output(); return; } int n,k,N,n1; int arr[901][901]; LL row[1000][20],col[1000][20],grid[1000][20],max1,rowCnt[1000],colCnt[1000]; PI rowC[1000],colC[1000]; void update(int x,int y,int val){ val--; int c=val/60,v=val%60; row[x][c]|=(1LL<<v); col[y][c]|=(1LL<<v); grid[(x/n1)*n1+(y/n1)][c]|=(1LL<<v); return; } int firstZero(LL x){ int cnt=0; while(x){ if(!(x&1))return cnt; cnt++;x/=2; } return cnt; } int getOption(int x,int y,int overlap){ int gr = (x/n1)*n1+(y/n1); if(overlap==3){ REP(i,n){ LL tmp=(row[x][i])|(col[y][i])|(grid[gr][i]); if(tmp==max1)continue; int cal = firstZero(tmp);   if(60*i+cal>=N)return 0; return 60*i+cal+1; } }   else if(overlap==2){   REP(i,n){   LL tmp1=row[x][i]|col[y][i],tmp2=row[x][i]|grid[gr][i],tmp3=col[y][i]|grid[gr][i]; if(tmp1==max1 && tmp2==max1 && tmp3==max1)continue; LL tmp=min(tmp1,min(tmp2,tmp3)); int cal = firstZero(tmp); if(60*i+cal>=N)return 0; return 60*i+cal+1; } } else if(overlap==1){ REP(i,n){ LL tmp1=row[x][i],tmp2=col[y][i],tmp3=grid[gr][i]; if(tmp1==max1 && tmp2==max1 && tmp3==max1)continue; LL tmp; if(tmp1!=max1)tmp=tmp1; else if(tmp2!=max1)tmp=tmp2; else if(tmp3!=max1)tmp=tmp3; int cal = firstZero(tmp); if(60*i+cal>=N)return 0; return 60*i+cal+1; } } return 0; } int main(){ max1=(1LL<<60)-1; init_input(); n=getint();k=getint(); N=n*n; n1=n; n =(int)ceil(N/60.0); REP(i,k){ int x,y,val; x=getint();y=getint(); val=getint(); x--;y--; arr[x][y]=val; update(x,y,val); } int lim=N*N,sz=lim; int p[lim+1]; REP(i,lim)p[i]=i; REP(level,3){ sz = lim; REP(times,lim){ int index = rand()%sz; int x=p[index]/N,y=p[index]%N; swap(p[index],p[sz-1]); sz--; if(!arr[x][y]){ int tmp = getOption(x,y,3-level); arr[x][y]=tmp; if(tmp)update(x,y,tmp); } } } REP(x,N){ REP(y,N){ putint(arr[x][y]);putchar(' '); } putchar('\n'); } flush_output(); return 0; }  
#include<cmath> #include<cstdio>  #define MAX_POINT_NUMBER 100  #define EPS 1E-9 #define INF 1E99  struct Point { 	double x,y;  	inline Point(){} 	inline Point(double x,double y):x(x),y(y){} 	inline ~Point(){} };  struct Circle { 	Point o; 	double r;  	inline Circle(){} 	inline Circle(Point o,double r):o(o),r(r){} 	inline ~Circle(){} };  inline double squaredDistance(const Point &a,const Point &b) { 	return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y); }  inline bool contain(const Circle &c,const Point &p) { 	return squaredDistance(c.o,p)<=c.r*c.r; }  Circle secureCircle;  int n; Point p[MAX_POINT_NUMBER];  Circle tower; double minTotalDistance;  int m=16; double dx[128]; double dy[128];  void countDelta() { 	double delta=2*acos(-1.0)/m; 	double angle=0.0; 	for(int i=0;i<m;i++) 	{ 		dx[i]=cos(angle); 		dy[i]=sin(angle); 		angle+=delta; 	} }  void readData() { 	scanf("%lf %lf %lf",&secureCircle.o.x,&secureCircle.o.y,&secureCircle.r); 	scanf("%d",&n); 	for(int i=0;i<n;i++) scanf("%lf %lf",&p[i].x,&p[i].y); }  double search(const Point &o,double &totalDist) { 	double D=0,D2=0; 	for(int i=0;i<n;i++) 	{ 		double distPower=squaredDistance(o,p[i]); 		D+=sqrt(distPower); 		D2+=distPower; 	} 	totalDist=(n*D2-D*D)/n; 	return D/n; }  Point updata(const Point &p) { 	Point o=Point(floor(p.x*1000.0)/1000.0,floor(p.y*1000.0)/1000.0); 	for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++) 	{ 		Point temp=Point(p.x+i*0.001,p.y+j*0.001); 		if(contain(secureCircle,temp)) return temp; 	} 	return secureCircle.o; }  void check(double x,double y,double r) { 	double d=0.0,D=0.0; 	for(int i=0;i<n;i++) D+=squaredDistance(secureCircle.o,p[i]); 	for(int i=0;i<n;i++) d+=(sqrt(squaredDistance(Point(x,y),p[i]))-r)*(sqrt(squaredDistance(Point(x,y),p[i]))-r); 	printf("%lf\n",d/D); }  void solve() { 	tower.o=secureCircle.o; 	tower.r=search(tower.o,minTotalDistance);  	double delta=secureCircle.r;  	while(delta>EPS) 	{ 		while(true) 		{ 			bool loop=true; 			for(int i=0;i<m;i++) 			{ 				Point newO=Point(tower.o.x+dx[i]*delta,tower.o.y+dy[i]*delta); 				if(!contain(secureCircle,newO)) continue; 				double dist; 				double r=search(newO,dist); 				if(dist<minTotalDistance) 				{ 					minTotalDistance=dist; 					tower=Circle(newO,r); 					loop=false; 				} 			} 			if(loop) break; 		} 		delta*=0.9; 	} 	tower.o=updata(tower.o); 	printf("%.3lf %.3lf %.3lf\n",tower.o.x,tower.o.y,tower.r); }  int main() { 	int T; 	countDelta(); 	scanf("%d",&T); 	while(T--) 	{ 		readData(); 		solve(); 	} 	return 0; } 
#include <cstdio> #include <vector> #include <algorithm> #include <cstdlib> #include <cassert> using namespace std;   typedef long long ll; typedef pair <int, int> ii;   const int Maxn = 100005; const int iter = 10000; const int from1 = 100; const int to1 = 2200; const int step1 = 150; const int from2 = 50; const int to2 = 400; const int step2 = 50;   int param; int param2;   int n, hn; int ia[Maxn], a[Maxn]; ll best; vector <ii> res; int used; ll gbest; vector <ii> gres;   void makeMove(int l, int r) {     int rem = a[l];     for (int i = l + 1; i <= r; i++)     a[i - 1] = a[i];     a[r] = rem;     res.push_back(ii(l, r)); }   int getMax(int l, int r, ll obest) {     int bi = -1;     for (int i = l; i <= r && used + 2 * (i - hn - 1) <= 2 * n; i++)         if (bi == -1 || a[i] > a[bi])             bi = i;     return bi; }   int getMin(int l, int r, ll obest) {     int bi = -1;     for (int i = l; i <= r && used + 2 * (i - hn - 1) <= 2 * n; i++)         if (bi == -1 || a[i] < a[bi])             bi = i;     return bi; }   int getBigger(int l) {     while (l <= n && a[hn + 1] >= a[l]) l++;     if (l > n || used + 2 * (l - hn - 1) > 2 * n) return -1;     return l; }   int getSmaller(int l) {     while (l <= n && a[hn + 1] <= a[l]) l++;     if (l > n || used + 2 * (l - hn - 1) > 2 * n) return -1;     return l; }   void makeBetter(ll &obest) {     if (obest == 0) { used = 2 * n + 1; return; }     int got;     if (obest < 0) {         got = getMax(hn + 2, min(n, hn + 2 + param2), obest);         if (got == -1) got = getBigger(hn + 2);     } else {         got = getMin(hn + 2, min(n, hn + 2 + param2), obest);         if (got == -1) got = getSmaller(hn + 2);     }     if (got == -1) { used = 2 * n + 1; return; }     used += 2 * (got - hn - 1);     int bi = -1;     int lst = max(1, hn - param);     for (int i = hn; i >= lst; i--)          if (used + hn + 1 - i + 1 <= 2 * n) {             ll cand = abs(obest - 2 * a[i] + 2 * a[got]);             if (cand < best) { best = cand; bi = i; }         }     if (bi == -1) {         for (int i = lst - 1; i >= 1; i--)              if (used + hn + 1 - i + 1 <= 2 * n) {                 ll cand = abs(obest - 2 * a[i] + 2 * a[got]);                 if (cand < best) { best = cand; bi = i; }             }         if (bi == -1) { used = 2 * n + 1; return; }     }     obest = obest - 2 * a[bi] + 2 * a[got];     used += hn + 1 - bi + 1;     for (int i = got - 1; i >= hn + 1; i--)         makeMove(i, i + 1);     makeMove(bi, hn + 1); }   void Solve(ll myobest, int from1, int to1, int step1, int from2, int to2, int step2) {     for (int i = 1; i <= n; i++)         ia[i] = a[i];     gbest = abs(myobest);     for (param = from1; param <= to1; param += step1)         for (param2 = from2; param2 <= to2; param2 += step2) {             ll obest = myobest; best = abs(myobest);             for (int i = 1; i <= n; i++)                 a[i] = ia[i];             res.clear(); used = 0;             for (int i = 0; i < iter && used < 2 * n; i++)                 makeBetter(obest);             if (abs(obest) < gbest) { gbest = abs(obest); gres = res; }         } }   int main() {     scanf("%d", &n); hn = n / 2;     for (int i = 1; i <= n; i++) {         scanf("%d", &a[i]);         if (i <= hn) best += a[i];         else best -= a[i];     }     ll obest = best;     if (best < 0) best = -best;     if (n <= 100) Solve(obest, 0, n, 1, 0, n, 1);     else if (n <= 1000) Solve(obest, 0, n, 30, 0, n, 30);     else Solve(obest, from1, to1, step1, from2, to2, step2);     printf("%d\n", gres.size());     for (int i = 0; i < gres.size(); i++)     printf("%d %d\n", gres[i].first, gres[i].second);     return 0; }   
    #include<cstdio>			/*   ry_7   */     #include<vector>     #include<algorithm>     #include<time.h>           using namespace std;     typedef long long ll;     typedef pair<ll,int> p;     bool flag[100008];     vector<p> b[100008];     ll x[100008],xsum,vsum[100008],ksum[100008],need[100008],dsum[100008];          vector<ll> v[100008];     vector<p> v1[100008];          int ans[100008];     #define pc putchar_unlocked     void printlong(int n) { char op[41]; int size = 40; while(n) { op[size--] = n%10+'0'; n/=10;  } for(int i=size+1;i<41;i++) pc(op[i]);  }                       inline long long inp()     {     int noRead=0;     char p=getchar_unlocked();     for(;p<33;){p=getchar_unlocked();};     while(p>32)     {     noRead = (noRead << 3) + (noRead << 1) + (p - '0');     p=getchar_unlocked();     }     return noRead;     };                 void reduce(int i,int k)     {     for(int j=0;j<k;j++)     dsum[j]-= v[i][j];     }     int add(int i,int k)     {     for(int j=0;j<k;j++)     if(dsum[j]+v[i][j]>x[j]) return 0;     for(int j=0;j<k;j++)     dsum[j]+= v[i][j];     return 1;     }     ll diff(int k)     {     ll df=0;     for(int j=0;j<k;j++)     df+= x[j]-dsum[j];     return df;     }           clock_t begin, end;     int main()     {     begin=clock();     int t;     t=inp();     while(t--)     {     int n,k;         n=inp(); k=inp();           for(int j=0;j<k;j++){ dsum[j]=0; }     for(int i=0;i<n;i++)     {     ll sum=0; flag[i]=1;     v[i].clear();     for(int j=0;j<k;j++)     {     ll t1;         t1=inp();           v[i].push_back(t1);     }     }     for(int i=0;i<k;i++)     {          x[i]=inp();     need[i]=x[i];     }     ll lt=100000000;     while(lt)     {     int f1,f2;     f2=0;     for(int i=0;i<n;i++)     {     if(!flag[i]) continue;     int f=1;     for(int j=0;j<k;j++)     {     ll t = need[j]/lt;     if(v[i][j]>t)     { f=0; break;}     }     if(f)     {     f1=0;     for(int j=0;j<k;j++)     if((need[j]-v[i][j])<0 ) { f1=1; break;}     if(f1) continue;     for(int j=0;j<k;j++)     if((need[j]-v[i][j])==0 ) f2=1;     for(int j=0;j<k;j++)     need[j]-=v[i][j];     add(i,k);     flag[i]=0;     }     if(f2) break;     }     lt/=100;     if(f2) lt=0;     }     ll df=0;     int c=0; int bf=0;           for(int i=0;i<n;i++)     {     if(flag[i]) continue;     reduce(i,k); df=diff(k);          flag[i]=1;     int nx=i;     for(int j=0;j<n;j++)     {     if(!flag[j]) continue;     if(!add(j,k)) continue;     ll d=diff(k);     if(d<df){ df=d; nx = j;}     reduce(j,k);     c++;     if(c>281111) bf=1;     }     add(nx,k); flag[nx]=0;     if(bf) break;     }     c=0;     for(int i=0;i<n;i++)     if(!flag[i]) ans[c++]=i;     printf("%d\n",c);     for(int i=0;i<c;i++)     //printlong(ans[i]+1);     printf("%d ",ans[i]+1);     }     return 0;     } 
#include <bits/stdc++.h> int main() { long long int d; scanf("%lld", &d); char s; d++; while(d) { scanf("%c", &s); if(s=='\n') d--; }   char p;    do {   scanf("%c", &p); printf("%c", p);   }while(p!='\n'); }
#include <cstdio> #include <cstdlib> #include <cstring> #include <algorithm> using namespace std;   #define SET(mask, bit) ((mask)|=1<<(bit)) #define TEST(mask, bit) (((mask)>>(bit))&1) #define RESET(mask, bit) ((mask)&=~(1<<(bit))) #define TOGGLE(mask, bit) ((mask)^=1<<(bit))   struct state{ 	int color[50][2]; 	int needles[50][2][4]; 	int N; 	 	state(int cc[50][50], int rot[50][50], int N, int goal): N(N){ 		memset(color, 0, sizeof(color)); 		memset(needles, 0, sizeof(needles)); 		for(int y=0; y<N; y++) 		for(int x=0; x<N; x++){ 			int parity=(x+y)&1; 			if(cc[y][x]==goal) 				SET(color[y][parity], x>>1); 			SET(needles[y][parity][rot[y][x]], x>>1); 			SET(needles[y][parity][(rot[y][x]+1)&3], x>>1); 		} 	} 	 	int colorat(int x, int y) const{ 		int parity=(x+y)&1; 		return TEST(color[y][parity], x>>1); 	} 	int countbad() const{ 		int res=0; 		for(int i=0; i<N; i++) 			res+=__builtin_popcount(color[i][0]) 			    +__builtin_popcount(color[i][1]); 		return N*N-res; 	} 	bool solved() const{ 		int goal0=(1<<((N+1)/2))-1, goal1=(1<<(N/2))-1; 		for(int i=0; i<N; i++) 			if(color[i][i&1]!=goal0 || color[i][~i&1]!=goal1) 				return false; 		return true; 	} 	bool impossible() const{ 		for(int i=0; i<N; i++) 			if(color[i][0] || color[i][1]) 				return false; 		return true; 	} 	bool pointedat(int x, int y) const{ 		const int dx[4]={ 0, -1,  0,  1}; 		const int dy[4]={ 1,  0, -1,  0}; 		for(int d=0; d<4; d++){ 			int nx=x+dx[d], ny=y+dy[d]; 			if(0<=nx && nx<N && 0<=ny && ny<N && !colorat(nx, ny) && 			  TEST(needles[ny][(nx+ny)&1][d], nx>>1) 			) 				return true; 		} 		return false; 	} 	void rotate(int x, int y){ 		int newcolor=colorat(x, y); 		int colorchanged[50][2]={0}; 		int S[2][50]={0}; 		int parity=(x+y)&1; 		int *cur=S[parity], *next=S[1^parity]; 		SET(cur[y], x>>1); 		bool any=true; 		for(;any; swap(cur, next), parity^=1){ 			any=false; 			for(int i=0; i<N; i++) 				next[i]=0; 			for(int i=0; i<N; i++) 				if(cur[i]){ 					any=true; 					int *needle=needles[i][parity]; 					int temp=needle[3]; 					int mask=cur[i]; 					needle[3]=(needle[2]&mask)|(needle[3]&~mask); 					needle[2]=(needle[1]&mask)|(needle[2]&~mask); 					needle[1]=(needle[0]&mask)|(needle[1]&~mask); 					needle[0]=(     temp&mask)|(needle[0]&~mask); 					colorchanged[i][parity]|=cur[i]; 					if(i>0){ 						next[i-1]|=mask&needle[0]&needles[i-1][1^parity][2]; 					} 					if((parity+i)&1){ 						next[i]|=mask&needle[3]&needles[i][1^parity][1]; 						next[i]|=((mask&needle[1])<<1)&needles[i][1^parity][3]; 					}else{ 						next[i]|=mask&needle[1]&needles[i][1^parity][3]; 						next[i]|=((mask&needle[3])>>1)&needles[i][1^parity][1]; 					} 					if(i<N-1){ 						next[i+1]|=mask&needle[2]&needles[i+1][1^parity][0]; 					} 				} 		} 		for(int i=0; i<N; i++){ 			if(newcolor){ 				color[i][0]|=colorchanged[i][0]; 				color[i][1]|=colorchanged[i][1]; 			}else{ 				color[i][0]&=~colorchanged[i][0]; 				color[i][1]&=~colorchanged[i][1]; 			} 		} 	} 	void flood(){ 		int cnt=countbad(); 		for(;;){ 			for(int i=0; i<N; i++){ 				if(i>0){ 					color[i-1][0]|=color[i][1]&needles[i-1][0][2]; 					color[i-1][1]|=color[i][0]&needles[i-1][1][2]; 				} 				if(i&1){ 					color[i][1]|=color[i][0]&needles[i][1][1]; 					color[i][0]|=color[i][1]&needles[i][0][3]; 					color[i][1]|=(color[i][0]<<1)&needles[i][1][3]; 					color[i][0]|=(color[i][1]>>1)&needles[i][0][1]; 				}else{ 					color[i][0]|=color[i][1]&needles[i][0][1]; 					color[i][1]|=color[i][0]&needles[i][1][3]; 					color[i][0]|=(color[i][1]<<1)&needles[i][0][3]; 					color[i][1]|=(color[i][0]>>1)&needles[i][1][1]; 				} 				if(i<N-1){ 					color[i+1][0]|=color[i][1]&needles[i+1][0][0]; 					color[i+1][1]|=color[i][0]&needles[i+1][1][0]; 				} 			} 			int next=countbad(); 			if(cnt==next) 				break; 			cnt=next; 		} 	} };   int cc[50][50], rot[50][50], N; int K; pair<int, int> solution[1001];   void read(){ 	scanf("%d", &N); 	for(int i=0; i<N; i++) 	for(int j=0; j<N; j++){ 		scanf("%d", &rot[i][j]); 		rot[i][j]--; 	} 	for(int i=0; i<N; i++) 	for(int j=0; j<N; j++){ 		scanf("%d", &cc[i][j]); 		cc[i][j]--; 	} }   void print(){ 	if(K>1000){ 		puts("-1"); 	}else{ 		printf("%d\n", K); 		for(int i=0; i<K; i++) 			printf("%d %d\n", solution[i].second+1, solution[i].first+1); 	} }   void solve(int goal){ 	int k=0; 	pair<int, int> sol[1001]; 	state st(cc, rot, N, goal); 	for(;;){ 		if(st.impossible()) 			return; 		state cpy(st); 		cpy.flood(); 		if(cpy.solved()) 			break; 		int x, y; 		do{ 			x=rand()%N; 			y=rand()%N; 		}while(cpy.colorat(x, y)); 		st.rotate(x, y); 		sol[k++]=make_pair(x, y); 	} 	int max_iter=N<20 ? 100 : N<30 ? 5 : N<40 ? 4 : 3; 	for(int iter=max_iter; k<K && iter>0 && !st.solved(); iter--){ 		int bestx=-1, besty=-1, best=st.countbad(); 		for(int y=0; y<N; y++) 		for(int x=0; x<N && best>0; x++){ 			if(!st.colorat(x, y)) 				continue; 			state cpy(st); 			cpy.rotate(x, y); 			if(cpy.countbad()<best){ 				best=cpy.countbad(); 				bestx=x; 				besty=y; 			} 		} 		if(bestx==-1) 			break; 		st.rotate(bestx, besty); 		sol[k++]=make_pair(bestx, besty); 	} 	while(k<K && !st.solved()){ 		int x, y; 		do{ 			x=rand()%N; 			y=rand()%N; 		}while(!st.colorat(x, y) || !st.pointedat(x, y)); 		st.rotate(x, y); 		sol[k++]=make_pair(x, y); 	} 	if(k<K){ 		K=k; 		copy(sol, sol+k, solution); 	} }   int main(int argc, char *argv[]){ 	int T; 	scanf("%d", &T); 	for(int t=0; t<T; t++){ 		read(); 		K=1001; 		for(int i=0; i<5; i++) 			solve(i); 		print(); 	} 	return 0; } 
#include <cstdio> #include <cstdlib> #include <sys/time.h> #include <algorithm> #include <cassert> #include <ctime> using namespace std;   	struct	node 	{ 		int l, r, k; 	}	a[1005]; 	 	bool	cmp(const node a, const node b) 	{ 		return a.r - a.l < b.r - b.l; 	} 	 	int f[505][505], pre[505][505], v[505], w[505], id[505]; 	 struct testcase{ 	int N, I[1000], C[500]; 	int Icnt, Iorder[1000], Istart[501]; 	int S[1000], sflag; 	void readinput(){ 		scanf("%d", &N); 		int CC[500]={0}; 		for(int i=0; i<N; i++){ 			scanf("%d", &I[i]); 			CC[--I[i]]++; 		} 		int renumber[500]; 		for(int i=0; i<500; i++) 			if(CC[i]>0){ 				C[Icnt]=CC[i]>>1; 				renumber[i]=Icnt++; 			} 		for(int i=0; i<N; i++) 			I[i]=renumber[I[i]]; 		for(int i=0; i<Icnt; i++){ 			Istart[i+1]=Istart[i]+2*C[i]; 			CC[i]=0; 		} 		for(int i=0; i<N; i++) 			Iorder[Istart[I[i]]+CC[I[i]]++]=i; 	} 	int getscore(int *s){ 		int ret=0; 		for(int i=1; i<N; i++) 			ret+=s[i]^s[i-1]; 		return ret; 	} 	void printoutput(){ 		printf("%d\n", getscore(S)); 		bool	firstBlood = 1; 		for(int i=1; i<N; i++) 			if(S[i]!=S[i-1]) 			{ 				if (!firstBlood)	printf(" "); 				firstBlood = 0; 				printf("%d", i); 			} 		putchar('\n'); 	} 	void sub_ans(int *s){ 		if(!sflag || getscore(s)<getscore(S)) 			for(int i=0; i<N; i++) 				S[i]=s[i]; 		sflag=1; 	} 	 	 	inline void	color(int *s, int l, int r, int c) 	{ 		for (int i = l; i <= r; ++ i)	s[i] = c; 	} 	 	inline void	work(int *s, int M, int k, int &V) 	{ 		int n = 0, sum = 0; 		for (int i = 1; i <= M; ++ i)	if (a[i].k == k) 		{ 			++ n; 			v[n] = a[i].r - a[i].l + 1, w[n] = (a[i].l > 0) + (a[i].r < N - 1), id[n] = i; 			sum += v[n]; 		} 		if (sum <= V) 		{ 			V -= sum; 			for (int i = 1; i <= n; ++ i) 			{ 				int t = id[i]; 				a[t].k = -1; 				color(s, a[t].l, a[t].r, k & 1); 			} 			return; 		} 		sum = 0; 		f[0][0] = 0; 		for (int i = 1; i <= n; ++ i) 		{ 			int last = sum; 			sum = min(sum + v[i], V); 			for (int j = 0; j <= sum; ++ j) 			{ 				f[i][j] = - 1 << 30; 				if (j <= last)	f[i][j] = f[i - 1][j], pre[i][j] = 0; 				if (j - v[i] >= 0 && f[i - 1][j - v[i]] + w[i] > f[i][j])	f[i][j] = f[i - 1][j - v[i]] + w[i], pre[i][j] = 1; 			} 		} 		int p = 0; 		for (int i = 0; i <= V; ++ i)	if (f[n][i] > f[n][p])	p = i; 		V -= p; 		for (int i = n; i; -- i) 			if (pre[i][p]) 			{ 				int t = id[i]; 				a[t].k = -1; 				color(s, a[t].l, a[t].r, k & 1); 				p -= v[i]; 			} 	} 	 	void small_improvement(int *s, int ing, int equal=0){ 		int pre = getscore(s); 		 		int M = 0; 		for (int i = Istart[ing]; i < Istart[ing + 1]; ++ i) 		{ 			int j = Iorder[i]; 			if (M && a[M].r == j - 1)	a[M].r ++; 			else	a[++ M].l = j, a[M].r = j; 		} 		 		for (int i = 1; i <= M; ++ i) 		{ 			a[i].k = 0; 			if (a[i].l > 0 && a[i].r < N - 1) 				a[i].k = s[a[i].l - 1] * 2 + s[a[i].r + 1]; 			else 			{ 				if (a[i].l > 0)	a[i].k = s[a[i].l - 1] * 3; 				if (a[i].r < N - 1)	a[i].k = s[a[i].r + 1] * 3; 			} 		} 		random_shuffle(a + 1, a + M + 1); 		int rest[2] = {C[ing], C[ing]}; 		work(s, M, 0, rest[0]); 		work(s, M, 3, rest[1]); 		//sort(a + 1, a + M + 1, cmp); 		for (int i = 1; i <= M; ++ i)	if (a[i].k != -1) 		{ 			int sum = a[i].r - a[i].l + 1, left = 0, right = 0; 			if (rest[0] - rest[1] >= sum)	left = sum; 			else if (rest[1] - rest[0] >= sum)	right = sum; 			else 			{ 				left = max(0, rest[0] - rest[1]); 				right = max(0, rest[1] - rest[0]); 				sum -= left + right; 				left += sum / 2, right += sum / 2; 				if (sum % 2)	if (rand() % 2)	left ++; 				else	right ++; 			} 			rest[0] -= left, rest[1] -= right; 			if (a[i].k == 1) 			{ 				color(s, a[i].l, a[i].l + left - 1, 0); 				color(s, a[i].l + left, a[i].r, 1); 			} 			else if (a[i].k == 2) 			{ 				color(s, a[i].l, a[i].l + right - 1, 1); 				color(s, a[i].l + right, a[i].r, 0); 			} 			else if (a[i].k == 0) 			{ 				int l = 0, r = 0; 				for (int j = a[i].l - 1; j >= 0 && I[j] != ing && s[j] == 0; -- j)	++ l; 				for (int j = a[i].r + 1; j < N && I[j] != ing && s[j] == 0; ++ j)	++ r; 				if (l > r || l == r && rand() % 2) 				{ 					color(s, a[i].l, a[i].l + left - 1, 0); 					color(s, a[i].l + left, a[i].r, 1); 				} 				else 				{ 					color(s, a[i].l, a[i].l + right - 1, 1); 					color(s, a[i].l + right, a[i].r, 0); 				} 			} 			else 			{ 				int l = 0, r = 0; 				for (int j = a[i].l - 1; j >= 0 && I[j] != ing && s[j] == 1; -- j)	++ l; 				for (int j = a[i].r + 1; j < N && I[j] != ing && s[j] == 1; ++ j)	++ r; 				if (l > r || l == r && rand() % 2) 				{ 					color(s, a[i].l, a[i].l + right - 1, 1); 					color(s, a[i].l + right, a[i].r, 0); 				} 				else 				{ 					color(s, a[i].l, a[i].l + left - 1, 0); 					color(s, a[i].l + left, a[i].r, 1); 				} 			} 		} 		//assert(getscore(s) > pre); 		if (getscore(s) > pre) 		{ 			int wei = 1; 		} 	} 	int improve(int *s=NULL){ 		if(!s) s=S; 		int res=0; 		for(int i=0; i<Icnt; i++) 			small_improvement(s, i, 1); 		return res; 	} 	void improve_and_sub(int *s, int passes){ 		for(int i=0; i<Icnt; i++) 			small_improvement(s, i); 		for(int i=0; i<Icnt; i++) 			small_improvement(s, i); 		for(int pass=0; pass<passes; pass++) 			improve(s); 		sub_ans(s); 	} 	void greedy(){ 		int s[1000]; 		int ingred[2][500]={{0}}; 		s[0]=0; 		ingred[0][I[0]]++; 		for(int i=1; i<N; i++){ 			if(ingred[s[i-1]][I[i]]<C[I[i]]) 				s[i]=s[i-1]; 			else 				s[i]=s[i-1]^1; 			ingred[s[i]][I[i]]++; 		} 		improve_and_sub(s, 300); 		ingred[s[N-1]][I[N-1]]--; 		for(int i=N-2; i>=0; i--){ 			if(ingred[s[i+1]][I[i]]>0) 				s[i]=s[i+1]; 			else 				s[i]=s[i+1]^1; 			ingred[s[i]][I[i]]--; 		} 		improve_and_sub(s, 300); 	} 	void random(){ 		int s[1000]; 		int ingred[2][500]={{0}}; 		for(int i=0; i<N; i++){ 			s[i]=(rand()%(2*C[I[i]]-ingred[0][I[i]]-ingred[1][I[i]]))<(C[I[i]]-ingred[1][I[i]]); 			ingred[s[i]][I[i]]++; 		} 		improve_and_sub(s, 30); 	} };   int K; testcase cases[30];   struct timeval start, now; void starttimer(){ 	gettimeofday(&start, NULL); } int elapsed(){ 	gettimeofday(&now, NULL); 	return (now.tv_sec-start.tv_sec)*1000000+(now.tv_usec-start.tv_usec); 	//return clock() * 1000; }   int main(){ 	srand(time(0)); #ifndef ONLINE_JUDGE 	freopen("split.in", "r", stdin); 	freopen("split.out", "w", stdout); #endif 	starttimer(); 	scanf("%d", &K); 	for(int i=0; i<K; i++) 		cases[i].readinput(); 	for(int i=0; i<K; i++) 		cases[i].greedy(); 	while(elapsed()<4500000) 	//for (int t = 0; t <= 10; ++ t) 		for(int i=0; i<K; i++) 			cases[i].random(); 	//while(elapsed()<4800000) 	//for (int t = 0; t <= 10; ++ t) 	//	for(int i=0; i<K; i++) 	//		cases[i].improve() && cases[i].improve() && cases[i].improve(); 	for(int i=0; i<K; i++) 		cases[i].printoutput(); }  
#include<cstdio> #include<ctime> #include<algorithm> #include<cstring> #include<iostream> #include<cstdlib> #include<cmath> #include<vector> #include<map> #include<set> #include<queue> #include<bitset> using namespace std; typedef long long ll; typedef double db; void gn(int &x){         int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');         if(c=='-')sg=-1,x=0;else x=c-'0';         while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';         x*=sg; } void gn(ll &x){         int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');         if(c=='-')sg=-1,x=0;else x=c-'0';         while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';         x*=sg; } const int mo=1000000007; const ll inf = 1.22e19; int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;} int gcd(int a,int b){return b?gcd(b,a%b):a;} #define x1 x192837465 #define x2 x123456789 #define y1 y192837465 #define y2 y123456789 int n; db k; db a[2111]; db wei[2111]; int ord[2111]; db ans; db su=0.0; db val(){         db su=0.0;         for (int i=1;i<=n;i++)su+=wei[i]*a[ord[i]];         return su; } void sw(int i,int j){         su-=wei[i]*a[ord[i]];         su-=wei[j]*a[ord[j]];         swap(ord[i],ord[j]);         su+=wei[i]*a[ord[i]];         su+=wei[j]*a[ord[j]]; } int main() {         //freopen("1.in","r",stdin);         int tes;gn(tes);         while(tes--){                 gn(n);                 scanf("%lf",&k);                 ans=1e9;                 for (int i=1;i<=n;i++)scanf("%lf",&a[i]);                 wei[1]=0.5;                 for (int i=2;i<=n;i++)wei[i]=wei[i-1]*0.5;                 for (int i=1;i<=n;i++)ord[i]=i;                 su=val();                 ans=fabs(k-su);                  for (int i=1;i<=min(n-1,30);i++){                         for (int t=0;t<3000;t++){                                 int j=rand()%(n-i)+i+1;                                 sw(i,j);                                 db cur=fabs(su-k);                                 if(cur<ans){                                         ans=cur;                                 }else{                                         sw(i,j);                                 }                         }                 }                 //printf("%.5lf\n",ans);                 printf("%d %d\n",ord[n],ord[n-1]);                 for (int i=n-2;i>=1;i--)printf("%d %d\n",ord[i],n-1+(n-i));         }         return 0; } 
     #include <cstdio>     #include <cstdlib>     #include <cassert>     #include <cstring>     #include <queue>     #include <map>     using namespace std;     #define debug(x) fprintf(stderr, "%s %d\n", #x, (int)(x))     int M, N, grid[34][34];     int route[10000][3], routelen, flipped;     char obuf[100000];     map<unsigned int, int> finalstate[6];     int f_id[5][5];     int readint(){     const static int SIZE=4000;     static char buf[SIZE];     static int i=0, n=0;     int num=0, h=0;     for(;;){     if(i==n){     i=0;     n=fread(buf, 1, SIZE, stdin);     if(!n)     return num;     }     int c=buf[i++];     if('0'<=c && c<='9'){     num=num*10+c-'0';     h=1;     }else if(h)     return num;     }     }     void readcase(){     M=readint();     N=readint();     for(int i=0; i<M; i++)     for(int j=0; j<N; j++)     grid[i][j]=readint()-1;     }     void printcase(){     printf("%d\n", routelen);     char *ptr=obuf;     for(int i=0; i<routelen; i++){     *ptr++='0'+route[i][0];     *ptr++=' ';     if(route[i][1]<10){     *ptr++='0'+route[i][1];     }else{     *ptr++='0'+(route[i][1]/10);     *ptr++='0'+(route[i][1]%10);     }     *ptr++=' ';     if(route[i][2]<10){     *ptr++='0'+route[i][2];     }else{     *ptr++='0'+(route[i][2]/10);     *ptr++='0'+(route[i][2]%10);     }     *ptr++='\n';     }     *ptr=0;     puts(obuf);     }     void debuggrid(FILE *f=stderr){     fprintf(f, "%d %d\n", M, N);     int len=M*N>=999 ? 4 : M*N>=99 ? 3 : M*N>=9 ? 2 : 1;     for(int i=0; i<M; i++){     for(int j=0; j<N; j++)     fprintf(f, "%*d ", len, grid[i][j]+1);     fputc('\n', f);     }     fputc('\n', f);     }     void rot(int c, int i, int j, int add=1){     assert(routelen<10000);     assert(i<M-1);     assert(j<N-1);     if(c){     int tmp=grid[i][j];     grid[i][j]=grid[i+1][j];     grid[i+1][j]=grid[i+1][j+1];     grid[i+1][j+1]=grid[i][j+1];     grid[i][j+1]=tmp;     }else{     int tmp=grid[i][j];     grid[i][j]=grid[i][j+1];     grid[i][j+1]=grid[i+1][j+1];     grid[i+1][j+1]=grid[i+1][j];     grid[i+1][j]=tmp;     }     if(add){     if(!flipped){     route[routelen][0]=c;     route[routelen][1]=i+1;     route[routelen][2]=j+1;     }else{     route[routelen][0]=c^1;     route[routelen][1]=j+1;     route[routelen][2]=i+1;     }     routelen++;     }     }     void flip(){     if(M<N){     for(int i=0; i<M; i++)     for(int j=i+1; j<M; j++){     int tmp=(grid[i][j]/N)+(grid[i][j]%N)*M;     grid[i][j]=(grid[j][i]/N)+(grid[j][i]%N)*M;     grid[j][i]=tmp;     }     for(int i=0; i<M; i++)     grid[i][i]=(grid[i][i]/N)+(grid[i][i]%N)*M;     for(int i=M; i<N; i++)     for(int j=0; j<M; j++)     grid[i][j]=(grid[j][i]/N)+(grid[j][i]%N)*M;     }else{     for(int i=0; i<N; i++)     for(int j=i+1; j<N; j++){     int tmp=(grid[i][j]/N)+(grid[i][j]%N)*M;     grid[i][j]=(grid[j][i]/N)+(grid[j][i]%N)*M;     grid[j][i]=tmp;     }     for(int i=0; i<N; i++)     grid[i][i]=(grid[i][i]/N)+(grid[i][i]%N)*M;     for(int i=0; i<N; i++)     for(int j=N; j<M; j++)     grid[i][j]=(grid[j][i]/N)+(grid[j][i]%N)*M;     }     int tmp=M;     M=N;     N=tmp;     flipped^=1;     }     inline int abs(int x){     return x>0 ? x : -x;     }     int impr(int i1, int j1, int i2, int j2){     int ii=grid[i1][j1]/N;     int jj=grid[i1][j1]%N;     return abs(i1-ii)+abs(j1-jj)-(abs(i2-ii)+abs(j2-jj));     }     int delta(int c, int i, int j){     int ret=impr(i, j, i, j+1)+impr(i, j+1, i+1, j+1)     +impr(i+1, j+1, i+1, j)+impr(i+1, j, i, j);     return c ? ret : -ret;     }     unsigned int getfinalstate(int i, int j){     unsigned int res=0;     int c=0;     for(int y=i; y<M; y++)     for(int x=j; x<N && c<8; x++){     res|=((grid[y][x]/N-i)*(N-j)+(grid[y][x]%N-j))<<(c<<2);     c++;     }     return res;     }     unsigned int getfinalstate0(){     unsigned int res=0;     int c=0;     for(int y=0; y<M; y++)     for(int x=0; x<N && c<8; x++){     res|=grid[y][x]<<(c<<2);     c++;     }     return res;     }     unsigned int hash[600000];     int testandset(unsigned int p){     int s=p%564229;     while(hash[s]!=p && hash[s])     s++;     if(hash[s]==p)     return 1;     hash[s]=p;     return 0;     }     void makefinalstate(int m, int n, int id){     memset(hash, 0, sizeof(hash));     M=m; N=n;     f_id[M][N]=id;     for(int i=0; i<M; i++)     for(int j=0; j<N; j++)     grid[i][j]=i*N+j;     queue<unsigned int> q;     finalstate[id][getfinalstate0()]=-1;     testandset(getfinalstate0());     int unmarked[1<<9];     for(int i=0; i<9; i++)     unmarked[((1<<9)-1)^(1<<i)]=i;     for(q.push(getfinalstate0()); !q.empty(); q.pop()){     unsigned int f=q.front();     int c=0;     int mark=0;     for(int i=0; i<M; i++)     for(int j=0; j<N; j++){     if(c<8){     grid[i][j]=(f>>(c<<2))&15;     mark|=1<<grid[i][j];     c++;     }else{     grid[i][j]=unmarked[mark];     }     }     for(int y=0; y<M-1; y++)     for(int x=0; x<N-1; x++)     for(int c=0; c<2; c++){     rot(c^1, y, x, 0);     unsigned int n=getfinalstate0();     if(!testandset(n)){     finalstate[id][n]=(c<<4)|(y<<2)|x;     q.push(n);     }     rot(c, y, x, 0);     }     }     }     void init(){     makefinalstate(2,2,0);     makefinalstate(2,3,1);     makefinalstate(2,4,2);     makefinalstate(3,2,3);     makefinalstate(3,3,4);     makefinalstate(4,2,5);     }     void rotbest(int c1, int y1, int x1, int c2, int y2, int x2){     int h1=delta(c1, y1, x1);     int h2=delta(c2, y2, x2);     if(h1>h2)     rot(c1, y1, x1);     else     rot(c2, y2, x2);     }     void solvecolumn(){     assert(N>=3 && M>=2);     for(int i=M-1; i>=2; i--){     int v=i*N+N-1;     int y=0, x=0;     while(grid[y][x]!=v){     x++;     if(x==N){     y++;     x=0;     if(y==M)     debuggrid();     assert(y<M);     }     }     if(0<x && x<N-2)     for(; y>i; y--)     rotbest(1, y-1, x, 0, y-1, x-1);     else if(x==0)     for(; y>i; y--)     rot(1, y-1, x);     else     for(; y>i; y--)     rot(0, y-1, x-1);     if(0<x && x<N-1)     for(; y<i; y++)     rotbest(1, y, x-1, 0, y, x);     else if(x==0)     for(; y<i; y++)     rot(0, y, x);     else     for(; y<i; y++)     rot(1, y, x-1);     if(y==M-1)     for(; x<N-1; x++)     rot(0, y-1, x);     else{     for(; x<N-2; x++)     rotbest(0, y-1, x, 1, y, x);     if(x<N-1){     rot(0, y-1, x);     x++;     }     }     assert(grid[i][N-1]==v);     }     int v1=N-1, v2=2*N-1;     if(grid[0][N-1]!=v1 || grid[1][N-1]!=v2){     if(grid[0][N-1]==v2 && grid[1][N-1]==v1)     rot(0, 0, N-2);     if(grid[0][N-1]==v1){     if(grid[0][N-2]==v2)     rot(1, 0, N-3);     rot(1, 0, N-2);     }     if(grid[1][N-1]==v2){     if(grid[1][N-2]==v1)     rot(0, 0, N-3);     rot(0, 0, N-2);     }     if(grid[0][N-1]==v2){     int y=0, x=0;     while(grid[y][x]!=v1){     x++;     if(x==N){     y++;     x=0;     assert(y<M);     }     }     if(x==0)     for(; y>0; y--)     rot(1, y-1, x);     else if(x==N-2)     for(; y>0; y--)     rot(0, y-1, x-1);     else     for(; y>0; y--)     rotbest(1, y-1, x, 0, y-1, x-1);     for(; x<N-1; x++)     rot(1, y, x);     assert(grid[0][N-1]==v1);     assert(grid[1][N-1]==v2);     }else{     if(grid[1][N-1]!=v1){     int y=0, x=0;     while(grid[y][x]!=v1){     x++;     if(x==N){     y++;     x=0;     assert(y<M);     }     }     if(y==0){     if(x==0)     rot(0, 0, x);     else if(x==N-2 && grid[1][N-2]==v2)     rot(1, 0, x-1);     else     rotbest(0, 0, x, 1, 0, x-1);     y++;     }else{     if(x==0)     for(; y>1; y--)     rot(1, y-1, x);     else if(x==N-2)     for(; y>1; y--)     rot(0, y-1, x-1);     else     for(; y>1; y--)     rotbest(1, y-1, x, 0, y-1, x-1);     }     if(M==2)     for(; x<N-2; x++)     rot(0, 0, x);     else     for(; x<N-2; x++)     rotbest(0, 0, x, 1, 1, x);     rot(0, 0, x);     x++;     }     assert(grid[1][N-1]==v1);     assert(grid[0][N-1]!=v2);     int y=0, x=0;     while(grid[y][x]!=v2){     x++;     if(x==N){     y++;     x=0;     assert(y<M);     }     }     if(y==0){     if(x==0)     rot(0, 0, x);     else if(x==N-2)     rot(1, 0, x-1);     else     rotbest(0, 0, x, 1, 0, x-1);     y++;     }else{     if(x==0)     for(; y>1; y--)     rot(1, y-1, x);     else if(x==N-2)     for(; y>1; y--)     rot(0, y-1, x-1);     else     for(; y>1; y--)     rotbest(1, y-1, x, 0, y-1, x-1);     }     if(M==2)     for(; x<N-2; x++)     rot(0, 0, x);     else     for(; x<N-2; x++)     rotbest(0, 0, x, 1, 1, x);     rot(0, 0, x);     x++;     }     assert(grid[0][N-1]==v1);     assert(grid[1][N-1]==v2);     }     for(int i=0; i<M; i++)     for(int j=0; j<N; j++){     grid[i][j]=(grid[i][j]/N)*(N-1)+(grid[i][j]%N);     }     N--;     }     void solve(){     routelen=0;     flipped=0;     if(N==2){     flip();     while(N>4){     solvecolumn();     }     flip();     }else if(M==2){     while(N>4){     solvecolumn();     }     }else{     while(M>3 || N>3){     if(N<M)     flip();     solvecolumn();     }     }     if(flipped)     flip();     int id=f_id[M][N];     for(;;){     unsigned int p=getfinalstate0();     int mv=finalstate[id][p];     if(mv==-1)     break;     int c=mv>>4;     int y=(mv>>2)&3;     int x=mv&3;     rot(c, y, x);     }     }     #ifndef LOCAL     int main(){     init();     int T=readint();     while(T--){     readcase();     solve();     printcase();     }     return 0;     }     #endif         
#include<iostream> #include<cstdio> #include<cstdlib> #include<cstring> #include<ctime> using namespace std; char X[1009],Y[1009]; short table[1009][1009]; short help1[1009],help2[1009]; char ans[1009]; int main() {     int n,m,i,j,t,test;     double beg=clock(); 	int flag=0;     scanf("%d",&test);for(t=1;t<=test;t++){     scanf("%d%s%d%s",&m,X,&n,Y);     if(flag==0){     for(i=0;i<=m;i++)     table[0][i]=0;     for(i=1;i<=n;i++)     table[i][0]=0;     for(i=1;i<=m;i++)     {       for(j=1;j<=n;j++)       {          if(X[i-1]==Y[j-1])          table[i][j]=table[i-1][j-1]+1;          else           {             if(table[i-1][j]>table[i][j-1])             table[i][j]=table[i-1][j];             else table[i][j]=table[i][j-1];          }       }     }     i=m;j=n;int index=-1;     while(true)     {          if(X[i-1]==Y[j-1])          {            index++;            ans[index]=X[i-1];            help1[index]=i;            help2[index]=j;            i--;j--;          }          else          {            if(table[i-1][j]>table[i][j-1])            i--;            else j--;          }          if(i==0||j==0)break;     }     if(table[m][n]==0)     {       printf("case %d N\n",t);     }     else     {        printf("case %d Y\n",t);        printf("%d\n",table[m][n]);        for(i=index;i>=0;i--)        {           printf("%c %d %d\n",ans[i],help1[i],help2[i]);        }     }     }                    if(flag==1)     {         printf("case %d N\n",t);     }     beg=(clock()-beg)/CLOCKS_PER_SEC;     if(beg>4.9)     {flag=1;}     }        //system("pause");     return 0; } 
int seed[]={59672,27,78126,53588,31869,85,41534,91,63167,39056,54,83,39150,43,70083,86,91451,17066,70532,42487,37231,75955,57813,63206,40,590,58117,63563,35,33,41875,65,85,16772,87353,97,46,69,42,79895}; #include <iostream> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <math.h> #include <algorithm> #include <vector> #include <assert.h> #include <sys/time.h> using namespace std;  typedef long long int64; #define sqr(X) ((X)*(X))  int64 counter=0;  double getTime() { 	struct timeval tv; 	gettimeofday(&tv, NULL); 	return tv.tv_sec+tv.tv_usec/1000000.0; }  double t0[101][101]; double t[101][101]; double trow[101]; int dis[101]; void simplex(int n, int m, double val[]) { // simplex(constraints, variables, result) 	counter++;  	pair<int,int> colID[m],rowID[n]; 	for (int i=0;i<m;i++) colID[i]=make_pair(0,i); 	for (int i=0;i<n;i++) rowID[i]=make_pair(1,i);  	while (1) { 		// najbolj pozitiven v spodnji vrstici 		double best=-1; 		int col=-1; 		for (int c=0;c<m;c++) { 			if (t[c][n]>0 && t[c][n]>best) { best=t[c][n]; col=c; } 		} 		if (col==-1) break;  		//vrstica z najmanjsim pozitivnim kolicnikom 		best=-1; 		int row=-1; 		for (int r=0;r<n;r++) if (!dis[r]) { 			if (t[col][r]<=0) continue; 			double rat=t[m][r]/t[col][r]; 			if ((rat>0 || (t[m][r]==0 && t[col][r]>0)) && (rat<best || best<0)) { best=rat; row=r; } 		} 		if (best<0) break; 		double pivot=t[col][row]; 		//cout << "pivot = " << row << " " << col << endl;  		swap(colID[col],rowID[row]); 		//pivotna vrstica 		trow[col]=1/t[col][row]; 		t[col][row]=1/t[col][row]; 		for (int i=0;i<=m;i++) { 			if (i!=col) { 				trow[i]=t[i][row]*1/pivot; 				t[i][row]*=1/pivot; 			} 		}  		//ostalo 		for (int j=0; j<=m; j++) if (j!=col && trow[j]!=0) { 			double *tj=t[j], *tcol=t[col], *last=&t[j][n]; 			//for (int i=0;i<=n;i++,tj++,tcol++) { 			for (;tj<=last;tj++,tcol++) { 				//t[j][i]=t[j][i]-trow[j]*t[col][i]; 				*tj-=trow[j]*(*tcol); 				//if (j<m && i<n) assert(*tj==0 || *tj==1 || *tj==-1); 			} 		}  		for (int i=0;i<=m;i++) { 			t[i][row]=trow[i]; 		}  		//pivotni stolpec 		for (int i=0;i<=n;i++) if (!dis[i]) { 			if (i!=row) t[col][i]*=-1/pivot; 		}   	}  	for (int i=0;i<m;i++) val[i]=0; 	for (int i=0;i<n;i++) if (!dis[i]) if (rowID[i].first==0) { 		val[rowID[i].second]=t[m][i]; 	} 	val[m]=-t[m][n]; }  void setMaxFun(int n, int m) { 	for (int i=0;i<=m;i++) t[i][n]=0; 	for (int i=0;i<n;i++) if (!dis[i]) { 		for (int j=0;j<m;j++) t[j][n]+=t[j][i]; 	} }  void printLinProg(int n, int m) { 	for (int i=0;i<=n;i++) { 		for (int j=0;j<=m;j++) printf("%.2lf ",t[j][i]); 		printf("\n"); 	} 	printf("\n"); }  int getLucky(double prob) { 	int rez = rand()<prob*RAND_MAX; 	return rez; }  int n,m; int used[101]; int from[100],to[100],b[100];  int dis0[101]; double p0[101]; double score0=-1;  void gen() { 	freopen("toll3.in","w",stdout); 	int tests=2; 	printf("%d\n",tests); 	srand(time(0)); 	while (tests--) { 		int n=100, m=30+rand()%70; 		//int n=100, m=100; 		printf("%d %d\n",n,m); 		for (int i=0;i<m;i++) { 			int x=1+rand()%(n-1); 			printf("%d %d %d\n",x,x+1,rand()); 		} 	} }  int main() { 	//gen(); return 0; 	double startTime = getTime(); 	double timeLimit = 7.0; 	//freopen("toll2.in","r",stdin); 	//srand(time(0)); 	int tests,alltests; 	scanf("%d",&tests); 	alltests=tests; 	double total=0; 	int degCnt=0; 	while (tests--) {  		// LAME PART 		srand(seed[tests]);  		double testStartTime = getTime(); 		//double testTimeLimit = (timeLimit-(testStartTime-startTime))/(tests+1); 		double testTimeLimit = 7.0/alltests;  		scanf("%d %d",&n,&m); 		memset(used,0,sizeof(used)); 		double budget=0, maxDist=0, maxBudget=0; 		int degenerate=1, vals=-1, len1=1; 		for (int i=0;i<m;i++) { 			scanf("%d %d %d",&from[i],&to[i],&b[i]); 			if (from[i]>to[i]) swap(from[i],to[i]); 			budget+=b[i]; 			if (from[i]==to[i]) { m--; i--; continue; }  			maxBudget=max(maxBudget,1.0*b[i]); 			maxDist=max(maxDist,1.0*to[i]-from[i]);  			if (i==0) vals=b[i]; 			else if (i>0 && b[i]!=vals) degenerate=0;  			if (to[i]-from[i]!=1) len1=0;  			from[i]--; to[i]--; 			used[from[i]]=1; used[to[i]]=1; 		} 		degCnt+=len1; 		//assert(degCnt<=1); 		for (int i=0;i<m;i++) { 			int x=from[i]; from[i]=0; 			for (int j=0;j<x;j++) from[i]+=used[j]; 			int y=to[i]; to[i]=0; 			for (int j=0;j<y;j++) to[i]+=used[j]; 		} 		int n2=0; 		for (int j=0;j<n;j++) n2+=used[j]; 		swap(n,n2);  		memset(t,0,sizeof(t)); 		memset(dis,0,sizeof(dis)); 		for (int j=0;j<m;j++) { 			for (int i=from[j];i<to[j];i++) t[i][j]=1; 			t[n][j]=b[j]; 		} 		for (int i=0;i<n;i++) { 			for (int j=0;j<m;j++) { 				if (from[j]<=i && i<to[j]) t[i][m]+=1; 			} 		}  		// components   		/*for (int j=0;j<=m;j++) { 			for (int i=0;i<=n;i++) printf("%.0lf ",t[j][i]); 			printf("\n"); 		} 		printf("\n");*/  		//dis[3]=1; dis[4]=1;   		for (int i=0;i<m;i++) { dis[i]=1; }  		memcpy(dis0,dis,sizeof(dis)); 		memcpy(t0,t,sizeof(t)); 		memset(p0,0,sizeof(p0)); 		score0=0;  		if (len1 && 1) { // NO PARTIAL OVERLAP OF SEGMENTS 			for (int i=0;i<n-1;i++) { 				vector<int> seg; 				for (int j=0;j<m;j++) { 					if (from[j]==i && to[j]==i+1) seg.push_back(b[j]); 				} 				sort(seg.begin(),seg.end()); 				reverse(seg.begin(),seg.end()); 				int best=0; 				for (int j=0;j<(int)seg.size();j++) { 					if (seg[j]*(j+1)>best) { 						best=seg[j]*(j+1); 						p0[i]=seg[j]; 					} 				} 				score0+=best; 			}  		} else if (m<=20 && 0) { // OPTIMAL  			for (int mask=0;mask<(1<<m);mask++) { 				//fprintf(stderr,"%d/%d\n",mask,1<<m); 				memset(dis,0,sizeof(dis)); 				for (int i=0;i<m;i++) if (mask&(1<<i)) dis[i]=1; 				memcpy(t,t0,sizeof(t0)); 				double p[101]; 				setMaxFun(m,n); 				simplex(m,n,p); 				double score=p[n]; 				if (score>score0) { 					score0=score; 					memcpy(dis0,dis,sizeof(dis)); 					memcpy(p0,p,sizeof(p)); 				} 			} 		} else {  			setMaxFun(m,n); 			simplex(m,n,p0); 			score0=p0[n]; 			//cout << score0 << endl;  			// build improve solution 			vector<pair<double,int> > order; 			for (int i=0;i<m;i++) { 				//order.push_back(make_pair(1.0*pow(to[i]-from[i],0.1)/b[i],i)); 				double dr=(to[i]-from[i])/maxDist; 				double br=b[i]/maxBudget; 				order.push_back(make_pair(1/br,i)); 				//printf("%d: %lf %lf -> %lf\n",i,dr,br,order[i].first); 			}  			int change=1, iter=0; 			while (change) { 				change=0; iter++;  				// add customers 				sort(order.begin(),order.end()); 				for (int i=0;i<m;i++) { 					int id=order[i].second; 					if (!dis[id]) continue; 					if (getTime()-testStartTime > testTimeLimit) break;  					memcpy(dis,dis0,sizeof(dis0)); 					memcpy(t,t0,sizeof(t0)); 					double p[101];  					dis[id]=0; 					setMaxFun(m,n); 					simplex(m,n,p); 					double score=p[n]; 					double T=1.0-(getTime()-testStartTime)/testTimeLimit; 					if (score>=score0 || getLucky(pow(15,(-score0/score)/T))) { 						change=1; 						memcpy(dis0,dis,sizeof(dis)); 						memcpy(p0,p,sizeof(p)); 						score0=score; 					} else { 						dis[id]=1; 					} 				}   				// remove customers 				sort(order.begin(),order.end()); 				//reverse(order.begin(),order.end()); 				for (int i=0;i<m;i++) { 					int id=order[i].second; 					if (dis[id]) continue; 					if (getTime()-testStartTime > testTimeLimit) break;  					int bi=0; 					for (int j=from[id];j<to[id];j++) bi+=(int)p0[j]; 					if (bi<b[id]) continue;  					memcpy(dis,dis0,sizeof(dis0)); 					memcpy(t,t0,sizeof(t0)); 					double p[101];  					dis[id]=1; 					setMaxFun(m,n); 					simplex(m,n,p); 					double score=p[n]; 					if (score>score0) { 						change=1; 						memcpy(dis0,dis,sizeof(dis)); 						memcpy(p0,p,sizeof(p)); 						score0=score; 					} else { 						dis[id]=0; 					} 				}  				if (!change) { 					// TODO 				}  			} 		}  		// build integer solution 		for (int i=0;i<n;i++) { 			assert(p0[i]-(int)p0[i]<1e-9); 			p0[i]=(int)p0[i]; 		}  		/*for (int i=0;i<n-1;i++) { 			while (1) { 				p0[i]+=1; 				int ok=1; 				for (int j=0;j<m;j++) { 					int cost=0; 					for (int i2=from[j];i2<to[j];i2++) cost+=p0[i]; 					if (cost>b[i]) { ok=0; break; } 				} 				if (!ok) { 					p0[i]-=1; 					break; 				} 			} 		}*/   		total+=score0/budget;  		int st=0; 		for (int i=0;i<n2-1;i++) { 			if (i!=0) printf(" "); 			if (!used[i]) { printf("0"); } 			else printf("%d",(int)p0[st++]); 			//else printf("%.2lf",p0[st++]); 		} 		printf("\n");  		/*for (int i=0;i<m;i++) { 			if (!dis0[i]) printf("%d: dist = %d, b=%d\n",i,to[i]-from[i],b[i]); 			else printf("NOT %d: dist = %d, b=%d\n",i,to[i]-from[i],b[i]); 		} 		printf("\n");*/ 	} 	cerr << "total = " << total/alltests << endl; 	cerr << "counter = " << counter << endl;     return 0; } 
#include<bits/stdc++.h> using namespace std; int n,m; bool sum(int array[],int target,int s,int i){ 	 	if(s==target) { 		//cout<<s<<" "<<target<<endl; 		return true; 	} 	if(s>target||i>=n) return false; 	//cout<<s+array[i]<<" "<<array[i]<<" "<<i<<" "<<endl; 	return sum(array,target,s+array[i],i+1)||sum(array,target,s,i+1); 	 } int main(){ 	int t; 	scanf("%d",&t); 	while(t--){ 	 		//int n,m; 		scanf("%d%d",&n,&m); 		int i; 		int array[n+10]; 		for(i=0;i<n;i++){ 			scanf("%d",&array[i]); 		} 		 		bool ans=sum(array,m,0,0); 		if(ans) 		printf("Yes\n"); 		else printf("No\n"); 	} 	return 0; }
#include<iostream> using namespace std; int main(){ 	int t,flag,flag2; 	long long int i,j,k,stem,l; 	cin>>t; 	while(t--){ 		cin>>l; 		long long int leaf[l]; 		for(i=0;i<l;i++){ 			cin>>leaf[i]; 		} 		if(leaf[0]>0){ 			if(leaf[0]!=1){ 				cout<<"No\n"; 			} 			else{ 				flag=0; 				for(i=1;i<l;i++){ 					if(leaf[i]>0){ 						cout<<"No\n"; 						flag=1; 						break; 					} 				} 				if(flag!=1){ 					cout<<"Yes\n"; 				} 			} 		} 		else{ 			flag=0; 			stem = 2; 			for(i=1;i<l;i++){ 				stem = 2 * (stem - leaf[i]); 				if(stem==0){ 					flag=1; 					break; 				} 				if(stem < 0){ 					break; 				} 			} 			flag2=0; 			if(flag==1){ 				if(i==l-1){ 					cout<<"Yes\n"; 				} 				else{ 					for(j=i+1;j<l;j++){ 						if(leaf[j]!=0){ 							cout<<"No\n"; 							flag2 = 1; 							break; 						} 					} 					if(flag2!=1){ 						cout<<"Yes\n"; 					} 				} 				 				 			} 			else{ 				cout<<"No\n"; 			} 		} 		 	} 	return 0; }
#include<iostream> #include<cstring> #include<cstdlib> #include<map> #include<vector> #include<list> #include<set> #include<queue> #include<cassert> #include<sstream> #include<string> #include<cmath> #include<algorithm> using namespace std;   #define LET(x,a) 	__typeof(a) x(a) #define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i) #define EACH(it,v)  	IFOR(it,v.begin(),v.end()) #define FOR(i,a,b)  	for(int i=(int)(a) ; i < (int)(b);++i) #define REP(i,n) 	FOR(i,0,n) #define PB		push_back #define MP 		make_pair #define EPS		1e-9 #define INF 2000000000   typedef vector<int>	VI; typedef long long	LL; typedef pair<int,int>	PI;   typedef struct nn{ 	int cnt; 	struct nn *left,*right; }node; node memTank[7400000]; int taken;   node *insert(node *root,int start,int end,int s,int e){ 	if(root==NULL){ 		root=&memTank[taken++]; 		root->cnt=0;root->left=NULL;root->right=NULL; 	} 	if(s==start && e==end){ 		(root->cnt)++; 		return root; 	} 	int mid=(start+end)/2; 	if(mid>=s)root->left=insert(root->left,start,mid,s,min(e,mid)); 	if(e>mid)root->right=insert(root->right,mid+1,end,max(s,mid+1),e); 	return root; }   int FindMax(node *root){ 	if(!root)return 0; 	int ans=root->cnt,tmp=root->cnt; 	if(root->left)ans=max(ans,tmp+FindMax(root->left)); 	if(root->right)ans=max(ans,tmp+FindMax(root->right)); 	return ans; } int main(){ 	int t;cin>>t; 	while(t--){ 		int n;scanf("%d",&n); 		int start=1,end=1000000000; 		taken=0; 		node *root=NULL; 		REP(i,n){ 			char ch;int l; 			scanf(" %c%d",&ch,&l); 			string ans;cin>>ans; 			int rep=((ans=="Yes")?1:0); 			if(!rep && ch!='='){ 				if(ch=='<'){ 					l--; 					ch='>'; 				} 				else { 					l++; 					ch='<'; 				} 			} 			if(ch=='<'){ 				if(l-1>=start)root=insert(root,start,end,start,l-1); 			} 			else if(ch=='>'){ 				if(l+1<=end)root=insert(root,start,end,l+1,end); 			} 			else { 				if(rep==1)root=insert(root,start,end,l,l); 				else{ 					if(l-1>=start)root=insert(root,start,end,start,l-1); 					if(l+1<=end)root=insert(root,start,end,l+1,end); 				} 			} 		} 		cout<<n-FindMax(root)<<endl; 	} 	return 0; }  
    #include <cstdio>     #include <cmath>     #include <cstdlib>     #include <string>     #include <stdarg.h>           using namespace std;           inline long Calc(int x,int y,long mad)     {     long tmp=x,ans=1;     for (;y;y>>=1)     {     if (y&1) ans=((long long)ans*tmp)%mad;     tmp=((long long)tmp*tmp)%mad;     }     return ans;     }           int main()     {     int test, k;     long n;     scanf("%d",&test);     while(test--)     {     scanf("%ld %d",&n,&k);     long mad=1;     for(int i=1;i<=k;i++)     {     mad*=10;     }     long double t = n*1.0*log10l(n*1.0);     long long len=(long long)(t)+1;     long ans=Calc(n,n,mad);     long long kk=len-k;     long double x=pow(10,t-(long double)kk);     printf("%d ",(int)(x));     for(mad=mad/10;mad>1 && ans<mad;mad=mad/10)     printf("0");     printf("%ld\n",ans);     }     return 0;     } 
#include <iostream> #include <cstdio> using namespace std;   int n;   int main() {     scanf("%d", &n);     for(int br = 0; br < n; br++)     {         string s;         cin >> s;         int a = 0, b = 0;         for(int i = 0; i < s.size(); i++)             if(s[i] == 'A')                 a++;             else                 b++;         if(a == 2)         {             cout << 'A' << endl;             continue;         }         if(b == 2)         {             cout << 'B' << endl;             continue;         }         int pos = -1;         for(int i = 0; i < (int)s.size() - 2; i++)         {             if((i == 0 || i != 0 && s[i] != s[i - 1]) && s[i] == s[i + 1] && s[i + 1] != s[i + 2])                 pos = i;         }         if(s.size() > 2)         {             int kraj = s.size() - 1;             if(s[kraj] == s[kraj - 1] && s[kraj - 1] != s[kraj - 2])                 pos = kraj - 1;         }         if(pos == -1)         {               cout << -1 << endl;             continue;         }         for(int i = 0; i < s.size(); i++)             if(i != pos)                 cout << s[i];         cout << endl;     }     return 0; }
/* TASK: ACMKANPD LANG: C++ */ #include <bits/stdc++.h> using namespace std; #define X first #define Y second #define EPS 1e-9 #define ALL(x) (x).begin(),(x).end() #define mp(x,y) make_pair((x),(y)) #define pb(x) push_back((x)) #define FOR(i,st,ed) for(int (i)=(st);(i)<(ed);(i)++) typedef pair<int,int> PII; typedef vector<int> vi; typedef vector<pair<int,int> > vii; typedef long long LL;  int N,M,T; int main() {     ios_base::sync_with_stdio(0);     cin.tie(0);     //freopen("xxx.in","r",stdin);     //freopen("xxx.out","w",stdout);     int i,j,k;     string s,num;     char ch;     while(true)     {         cin >> s;         if(s[0]=='~')             break;         if(s[0]=='#')         {             k=0;             for(i=0;i<num.size();i++)             {                 k*=2;                 k+=num[i]-'0';             }             cout << k << '\n';             num="";         }         else         {             j=0;             for(i=s.size()-1;i>=0;i--)                 if(s[i]=='0')   j++;                 else            break;             if(j==1)        ch='1';             else if(j==2)   ch='0';             else             {                 j-=2;                 while(j--)                     num+=ch;             }         }     } } 
#include<bits/stdc++.h> using namespace std;  typedef long long LL; struct node { 	int l, r; 	int Left, Right, mid;  	LL clear; 	LL add, mul, sum; };  const int MAXN =1e5 + 10; const int MOD = 1e9 + 7; node T[MAXN * 30]; int A[MAXN];  void propagateLazy(int idx){ 	if(T[idx].clear > 0){ 		T[idx].sum = (T[idx].clear * (T[idx].r - T[idx].l + 1)) % MOD; 	} 	T[idx].sum = (T[idx].sum * T[idx].mul + (T[idx].r - T[idx].l + 1) * T[idx].add) % MOD;  	int L = T[idx].Left; 	int R = T[idx].Right; 	if(T[idx].l != T[idx].r){ 		if(T[idx].clear > 0){ 			 			T[L].clear = T[idx].clear; 			T[R].clear = T[idx].clear; 			T[L].add = T[idx].add; 			T[L].mul = T[idx].mul; 			T[R].add = T[idx].add; 			T[R].mul = T[idx].mul; 		} else{ 			T[L].add = (T[L].add * T[idx].mul + T[idx].add) % MOD; 			T[L].mul = (T[L].mul * T[idx].mul) % MOD; 			T[R].add = (T[R].add * T[idx].mul + T[idx].add) % MOD; 			T[R].mul = (T[R].mul * T[idx].mul) % MOD; 		} 	} 	T[idx].add = 0; 	T[idx].mul = 1; 	T[idx].clear = 0; } void build(int l, int r, int idx){ 	if(l == r){ 		T[idx].l = l; 		T[idx].mid = l; 		T[idx].r = l;   		T[idx].Left = idx; 		T[idx].Right = idx;  		T[idx].clear = 0; 		T[idx].add = 0; 		T[idx].mul = 1; 		T[idx].sum = A[l]; 		return ; 	} 	int mid = (l + r) >> 1; 	int L = idx << 1; 	int R = L + 1;  	build(l, mid, L); 	build(mid + 1, r, R);  	T[idx].l = l; 	T[idx].mid = mid; 	T[idx].r = r;  	T[idx].Left = L; 	T[idx].Right = R;  	T[idx].clear = 0; 	T[idx].add = 0; 	T[idx].mul = 1; 	T[idx].sum = (T[L].sum + T[R].sum) % MOD; } void update(int idx, int vl, int vr, LL add, LL mul, LL clear){ 	propagateLazy(idx); 	// cout << idx << " " << T[idx].l << " " << T[idx].r << "    " << T[idx].add << " " << T[idx].mul << " " << T[idx].sum << " " << T[idx].clear << "\n"; 	if(vl == T[idx].l && vr == T[idx].r){ 		if(clear > 0){ 			T[idx].clear = clear; 			T[idx].add = 0; 			T[idx].mul = 1; 		} else { 			T[idx].add = (T[idx].add * mul + add) % MOD; 			T[idx].mul = (T[idx].mul * mul) % MOD; 		} 		propagateLazy(idx); 		// cout << idx << " in " << T[idx].l << " " << T[idx].r << "    " << T[idx].add << " " << T[idx].mul << " " << T[idx].sum << " " << T[idx].clear << "\n"; 		return ; 	} 	int L = T[idx].Left; 	int R = T[idx].Right; 	int mid = T[idx].mid;  	if(vr <= mid){ 		update(L, vl, vr, add, mul, clear); 	} else if(vl > mid){ 		update(R, vl, vr, add, mul, clear); 	} else{ 		update(L, vl, mid, add, mul, clear); 		update(R, mid + 1, vr, add, mul, clear); 	} 	propagateLazy(L); 	propagateLazy(R); 	T[idx].sum = (T[L].sum + T[R].sum) % MOD; } LL query(int idx, int vl, int vr){ 	propagateLazy(idx); 	if(vl == T[idx].l && vr == T[idx].r){ 		return T[idx].sum; 	} 	if(vr <= T[idx].mid){ 		return query(T[idx].Left, vl, vr); 	} else if(vl > T[idx].mid){ 		return query(T[idx].Right, vl, vr); 	} else{ 		return (query(T[idx].Left, vl, T[idx].mid) + query(T[idx].Right, T[idx].mid + 1, vr)) % MOD; 	} } int main(){ 	int N, Q; 	scanf("%d%d", &N, &Q); 	for(int i = 1;i <= N;++i){ 		scanf("%d", &A[i]); 	} 	build(1, N, 1); 	int x, y, v; 	while(Q--){ 		int type; 		scanf("%d", &type); 		switch(type){ 			case 1:  				scanf("%d%d%d", &x, &y, &v); 				update(1, x, y, v, 1, 0); 			break; 			case 2:  				scanf("%d%d%d", &x, &y, &v); 				update(1, x, y, 0, v, 0); 			break; 			case 3:  				scanf("%d%d%d", &x, &y, &v); 				update(1, x, y, 0, 1, v); 			break; 			case 4:  				scanf("%d%d", &x, &y); 				printf("%lld\n", query(1, x, y)); 			break; 		} 		// cout << "\n\n"; 		// for(int i = 1;i <= 15;++i){ 		// 	cout << i << " " << T[i].l << " " << T[i].r << "    " << T[i].add << " " << T[i].mul << " " << T[i].sum << " " << T[i].clear << "\n"; 		// } 	} 	return 0; }  /* 4 4 7 10 5 3  3 1 4 7 1 1 4 9 1 2 2 6 4 4 4 */
#include <iostream> #include <vector> #include <algorithm> using namespace std;  std::vector<int> digitPositions[10]; int siz,q; int inp[100000]; char tmp[100000]; 	 void populatePositionData(int inp[], int siz) { 	for(int i=0; i<siz; i++){ 		digitPositions[inp[i]].push_back(i); 	} }  int getSum(int index, int pos) { 	vector<int>::iterator it = lower_bound(digitPositions[index].begin(), 		digitPositions[index].end(), pos); 	int count = (it - digitPositions[index].begin()); 	if(count <= 0) 		return 0;  	int sum = count*(inp[pos] - index);  	return sum; }  void readInp() { 	cin>>siz>>q; 	cin>>tmp; 	for(int i=0; i<siz; i++) 		inp[i] = tmp[i] - '0'; }   void calc() { 	populatePositionData(inp, siz);  	for(int i=0; i<q; i++){ 		int pos; 		cin>>pos; 		pos--; 		int totalLower = 0, totalHigher = 0; 		int digit = inp[pos]; 		for(int d=0; d<digit; d++){ 			totalLower += getSum(d,pos); 		} 		for(int d=digit+1; d<=9; d++){ 			totalHigher += getSum(d,pos); 		} 		int ans = totalLower - totalHigher; 		cout<<ans<<endl; 	} } int main() { 	readInp(); 	calc(); }
#include<iostream> #include<vector> #include<cmath> using namespace std; int main() { 	long long int t,n,i,j; 	long long sum[1000]={0}; 	cin>> t; 	sum[0]=0; 	sum[1]=1; 	long long int a[3]; 	a[0]=0; 	a[1]=1; 	for(i=2;;i++) 	{ 		a[2]=a[1]+a[0]; 		a[0]=a[1]; 		a[1]=a[2]; 		sum[i]=sum[i-1]+a[2]; 		//cout<<sum[i]<<"\n"; 		if(sum[i]>pow(10,18)) 		break; 	} 	//for(i=0;i<sum.size();i++) 	//cout<<sum[i-1]<<endl<<i<<endl;; 	while(t--) 	{ 		cin >> n; 		for(i=1;;i++) 		{ 			if(n<=sum[i]) 			{ 			 				cout<<i<<endl;; 				break; 			} 		}	 		 	} } 
#include<bits/stdc++.h> using namespace std; #define maxi  5000005 bool mark[maxi],test[maxi];   void prime() {     vector<int>veg;     int limit=sqrt(maxi*1.)+2;     for(int i=4;i<=maxi;i+=2)  mark[i]=true;     for(int i=3;i<=maxi;i+=2)     {         if(!mark[i])         {             if(i%4==1)                 veg.push_back(i);             if(i<=limit)             {                 for(int j=i*i;j<=maxi;j+=i*2)                 {                     mark[j]=true;                 }             }         }     }      int l=veg.size();     for(int i=0;i<l;i++)     {        int p=veg[i];         for(int j=p;j<=maxi;j+=p)             test[j]=true;     } } int main() {     prime();     int testcase;     scanf("%d",&testcase);     for(int i=1;i<=testcase;i++)     {         int value;         scanf("%d",&value);         if(test[value]==1) printf("YES\n");         else printf("NO\n");     }     return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring> const int mod=1000000007; const int bufsize=1000; typedef long long ll; char buf[bufsize]; int memo[51][51][1010]; int func(int A, int E, int V) { 	int N=A+E; 	if (V<A) return 0; 	if (N==0) return 1; 	if (N==1) return V>=A;  	int& res=memo[A][E][V]; 	if (~res) return res; 	res=0; 	int L=N/2,R=N-L; 	for(int i=0;i<=A;++i) if(i<=L&&A-i<=R) 		res=(res+(ll)func(i,L-i,V-A)*func(A-i,R-A+i,V-A)%mod)%mod; //	printf("f(%d,%d,%d)=%d\n",A,E,V,res); 	return res; } int main() { 	int T=atoi(fgets(buf,bufsize,stdin)); 	memset(memo,-1,sizeof(memo)); 	while (T--) { 		int a=atoi(strtok(fgets(buf,bufsize,stdin)," ")); 		int e=atoi(strtok(0," ")); 		int v=atoi(strtok(0," ")); 		printf("%d\n",(func(a,e,v)-func(a,e,v-1)+mod)%mod); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; string A; int leftMost[2000]; int rightMost[2000]; inline string getMax(string &a, string &b){     if(a.size() < b.size()){         return b;     } else if(a.size() > b.size()){         return a;     } else {         return max(a, b);     } } int main(){     cin >> A;     int N = A.size();     leftMost[0] = 0;     rightMost[N - 1] = N - 1;     for(int i = 1;i < N;++i){         leftMost[i] = i;         if(A[i - 1] >= '0' && A[i - 1] <= '9'){             if(leftMost[i - 1] == i - 1 && A[i - 1] == '0'){                 leftMost[i] = i;             } else leftMost[i] = leftMost[ i - 1];         }     }     for(int i = N - 2;i >= 0;--i){         rightMost[i] = i;         if(A[i + 1] >= '0' && A[i + 1] <= '9'){             rightMost[i] = rightMost[ i + 1];         }     }     string ans = "0";     for(int i = 0;i < N;++i){         string curAns = "";         if(A[i] >= 'A' && A[i] <= 'Z'){             curAns += A.substr(leftMost[i], i - leftMost[i]);             curAns += "9";             if(rightMost[i] > i){                 curAns += A.substr(i + 1, rightMost[i] - i);             }         } else if(!(leftMost[i] == i && A[i] == '0')){             curAns = A.substr(leftMost[i], rightMost[i] - leftMost[i] + 1);         } else curAns = "0";         //cout << i << " " << A[i] << " " << curAns << "\n";         ans = getMax(ans, curAns);     }     cout << ans << "\n";     return 0; } 
#include <iostream> using namespace std;  int main() { 	long long ans,n,j; 	int t; 	cin>>t; 	while(t--!=0) 	{cin>>n; 	 for(int i=0;i<n;i++) 	 {cin>>j; 	 } 	 ans=(n*(n-1))/2; 	 cout<<ans<<endl; 	} 	// your code goes here 	return 0; }
    #include<stdio.h>     #include<string.h>     int main()     {     	int f[5001],i,t,a;     	char str[1001];     	scanf("%d",&t);     	f[0]=0;     	f[1]=1;     	for(i=2;i<=5000;i++)     	{     		f[i]=f[i-1]+f[i-2];     	}     	while(t--)     	{     		scanf("%s",str);     		a=0;     		for(i=0;i<strlen(str);i++)     		{     		a=a*10+(str[i]-'0');     		}     		int flag =0;     		for(i=0;i<5000;i++)     		{     			if(a==f[i])     			{     				flag=1;     				break;     			}     		}     		if(flag)     		printf("YES\n");     		else     		printf("NO\n");     	}     	return 0;     }  
#include<iostream> #include<stdio.h> #include<algorithm> using namespace std; int a[100005],s[100005]; int main() { 	int n,i,q,k,c; 	scanf("%d",&n); 	for(i=0;i<n;i++) 		scanf("%d",&a[i]); 	sort(a,a+n); 	s[0]=a[0]; 	for(i=1;i<n;i++) 		s[i]=s[i-1]+a[i]; 	scanf("%d",&q); 	while(q--) 	{ 		scanf("%d",&k); 		if(k==0) 		{ 			printf("%d\n",s[n-1]); 			continue; 		} 		c=n/(k+1); 		if(n%(k+1)!=0) 			c++; 		printf("%d\n",s[c-1]); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int gcd(int a,int b){     if(b%a==0){         return a;     }     else{         return gcd(b%a,a);     } } int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         int array[n];         for(int i=0;i<n;i++){             cin>>array[i];         }         int min1=gcd(array[0],array[1]);         for(int i=1;i<n-1;i++){             if(min1>array[i+1]){                 min1=gcd(array[i+1],min1);             }             else{                 min1=gcd(min1,array[i+1]);             }         }         cout<<min1<<endl;     } }
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; LL seqwithgcd[10010] , tempseqwithgcd[10010]; int A[64]; int main() { int N , test; si(test); while(test--) { si(N); for(int i=1;i<=N;i++) 	si(A[i]); memset(seqwithgcd , 0 , sizeof(seqwithgcd)); for(int i=1;i<=N;i++) { 	// memset(tempseqwithgcd , 0 , sizeof(tempseqwithgcd)); 	for(int j=1;j<=10000;j++) 		tempseqwithgcd[j] = seqwithgcd[j]; 	for(int j=1;j<=10000;j++) 	{ 		if(seqwithgcd[j]!=0) 			tempseqwithgcd[__gcd(A[i] , j)]+=seqwithgcd[j]; 	} 	for(int j=1;j<=10000;j++) 		seqwithgcd[j] = tempseqwithgcd[j]; 	seqwithgcd[A[i]]++; 	// cout << endl; } // cout << seqwithgcd[1] << endl; printf("%lld\n", seqwithgcd[1]); } return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         long long n,m;         cin>>n>>m;         long long *array=new long long[m];         for(int i=0;i<m;i++){             cin>>array[i];         }         long long  dp[n];         sort(array,array+m);         for(int i=0;i<n;i++){             dp[i]=0;             dp[i]=max(abs(i-array[0]),abs(i-array[m-1]));             cout<<dp[i]<<" ";         }         cout<<endl;     } }
#include<iostream> #include<algorithm> #include <functional> using namespace std; int main()  { 	int t;     cin >>t;     while(t--){         int n;         int sum=0;         cin>>n;         long a[n];         for(int i=0;i<n;i++){             cin >>a[i];         }         std::sort(a, a+n, std::greater<int>());         for(int i=0;i<n;i++){             if((i%4)==0||(i%4)==1) sum+=a[i];          }cout<<sum<<endl;     } } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         if(360%n==0){             cout<<'y'<<" ";         }         else{             cout<<'n'<<" ";          }         if(n<=360){             cout<<'y'<<" ";         }         else{             cout<<'n'<<" ";         }         if(n*(n+1)/2<=360){             cout<<'y'<<endl;         }         else{             cout<<'n'<<endl;         }     } }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int n,m;         cin>>n>>m;         cout<<n+m-1<<endl;     } }
#include <iostream> using namespace std;  int main() { 	int t;long long int n,ans; 	cin>>t; 	while(t--!=0) 	{ 		cin>>n; 		ans=2*n; 		ans+=((n-1)*n)/2; 		cout<<ans<<endl; 	} 	// your code goes here 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     char *array=new char[1000002];     array[0]='3';     array[1]='.';     int remainder=103993%33102;     for(int i=2;i<=1000001;i++){         remainder=remainder*10;         array[i]=(char)((remainder/33102)+48);         remainder=remainder%33102;     }     while(t--){         long long n;         cin>>n;         string s="3.";         if(n==0){             cout<<3<<endl;         }         else{             for(int i=0;i<=n+1;i++){                 cout<<array[i];             }             cout<<endl;                      }              } }
#include <bits/stdc++.h> #define ll long long int using namespace std;  int main() {     vector<ll> a(1000);     ll t,n,sum,no,k,i,p,j;     cin>>t;     while(t--)     {         cin>>n>>k;         for(i=0;i<n;i++)             cin>>a[i];         no=0;         sum=abs(a[0]+a[1]-k);         for(i=0;i<n;i++)         {             for(j=i+1;j<n;j++)             {                 p=abs(a[i]+a[j]-k);                 if(p==sum)                     no++;                 else if(p<sum)                 {                     no=1;                     sum=p;                 }             }         }         cout<<sum<<" "<<no<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std; string binary(int a,int k){     string s="";     while(a!=0){         s=(char)((a%2)+48)+s;         a=a/2;     }     for(int i=0;i<s.length()-k;i++){         s='0'+s;     }     return s; } string reverse(string s){     int length=s.length();     for(int i=0;i<length/2;i++){         char c=s[i];         s[i]=s[length-1-i];         s[length-1-i]=c;     }     return s; } int decimal(string s){     int length=s.length();     int ans=0;     for(int i=0;i<length;i++){         ans+=pow(2,i)*(s[length-1-i]-48);     }     return ans; } void swap(char &a,char &b){     char temp=a;     a=b;     b=temp;     return; } int main(){     int t;     cin>>t;          while(t--){         int k;         cin>>k;         int *array=new int[(int)pow(2,k)];         for(int i=0;i<pow(2,k);i++){             string bin=binary(i,k);             bin=reverse(bin);             array[i]=decimal(bin);                      }         string s;         cin>>s;         for(int i=0;i<s.length();i++){             if(array[i]>i){                 swap(s[i],s[array[i]]);             }         }         cout<<s<<endl;              } }
#include<stdio.h> #include<algorithm> #include<vector> using namespace std; vector<long long int> a,b; int main() { 	long long int t,n,i,x,j,o,tw,ans,rank; 	scanf("%lld",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		a.clear(); 		b.clear(); 		for(i=0;i<n;i++) 		{ 			scanf("%lld",&x); 			a.push_back(x); 		} 		o=0; 		tw=0; 		for(i=0;i<n;i++) 		{ 			scanf("%lld",&x); 			if(x==1) 				o++; 			if(x==2) 				tw++; 			b.push_back(x); 		} 		 		sort(a.begin(),a.end()); 		sort(b.begin(),b.end()); 		 		vector<long long int>::iterator it; 		ans=0; 		for(i=0;i<n;i++) 		{ 			if(a[i]==1) 				continue; 			else if(a[i]==2) 			{ 				it=lower_bound(b.begin(),b.end(),5); 				rank=it-b.begin()+1; //				if(it!=b.end() || b[b.size()-1]==5) //					rank++; 				ans+=o+n-rank+1; 			} 			else if(a[i]==3) 			{ 				it=lower_bound(b.begin(),b.end(),4); 				rank=it-b.begin()+1; //				if(it!=b.end() || b[b.size()-1]==4) //					rank++; 				ans+=o+tw+n-rank+1; 			} 			else 			{ 				it=lower_bound(b.begin(),b.end(),a[i]+1); 				rank=it-b.begin()+1; //				if(it!=b.end()  || b[b.size()-1]==a[i]+1) //					rank++; 				ans+=o+n-rank+1; 			} 		} //		printf("%lld\n",ans); //		ans1=(double)ans; 		printf("%lf\n",(double)ans/(double)n); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; int A[MAXN]; int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         for(int i = 1;i <= N;++i){             scanf("%d", &A[i]);         }         for(int i = N;i >= 2;--i){             if(A[i] < A[i - 1]){                 int temp = A[i];                 A[i] = A[i - 1];                 A[i - 1] = temp;             }         }         bool is = true;         for(int i = 2;i <= N;++i){             is &= (A[i] >= A[i - 1]);         }         if(is){             printf("YES\n");         } else{             printf("NO\n");         }     }     return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; int main() {     int T;     ios::sync_with_stdio(0);cin.tie(0);     cin>>T;     for(;T;--T)     {         int N , i , L , j ,k,x,y ;         string S;         cin>>S>>N;         vector < string >A(N);         for(i=0;i<N;++i)cin>>A[i];         int G[100+1][100+1]={};          for(L=1;L<=S.length();++L)         {             for(i=0;i+L-1<(int)S.length();++i)             {                 vector < int > val;                string temp = S.substr(i,L);                  j = i + L - 1;                 for(k=0;k<N;++k)                 {                     int last = 0;                     while(temp.find(A[k],last)!=string::npos)                     {                         int found = temp.find(A[k],last);                         last = found+1;                         val.push_back((found?G[i][i+found-1]:0)^(found+A[k].length()!=temp.length()?G[i+found+A[k].length()][j]:0));                     }                 }                  sort(val.begin(),val.end());                 for(k=0;;++k)                     if(!binary_search(val.begin(),val.end(),k))                     {                         G[i][i+L-1] = k;                         break;                     }             }         }         if(G[0][(int)S.length()-1])             cout<<"Teddy\n";         else             cout<<"Tracy\n";      }     return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define ll long long int #define pb push_back #define mp make_pair #define INF (ll)(1e18) #define inf 0x7fffffff #define inff 100000 #define ff first #define ss second #define sz(x) ((int) (x).size()) #define fast cin.sync_with_stdio(0);cin.tie(0) #define rep(i,N) for(int i = 0;i < N;i++) #define frep(i,a,b) for(int i = a;i <= b;i++) #define pii pair<int , int> #define pll pair<ll , ll> #define vii vector<int> #define vpii vector< pii > #define fill(A,v) memset(A,v,sizeof(A)) #define setbits(x) __builtin_popcount(x) #define print(A,j,k) for(int ii=j;ii<=k;ii++)cout<<A[ii]<<" ";cout<<"\n" #define all(x) (x).begin(), (x).end() #define gcd __gcd #define SQRT 350 #define CASES int t;cin>>t;while(t--) #define FILE freopen("inp.txt" , "r" , stdin); #define ld long double  const int N = 1e5 + 5; const ll MOD = 1e9 + 7; const ll INV2 = 500000004;  int dp[N][26];  int main(int argc, char const *argv[]) {     fast;      CASES {          string s;         cin >> s;          int n = s.size();          int k;         cin >> k;          rep(i , 26) {             dp[n][i] = -1;         }          for(int i = n - 1;i >= 0;i--) {             rep(j , 26)                 dp[i][j] = dp[i + 1][j];             dp[i][s[i] - 'a'] = i;         }          // cout << dp[1][1] << '\n';          string ans = "";         int l = 0;         int req = k , oc;         while (1) {             int use = -1;             rep(j , 26) {                 int oc = dp[l][j];                 if (oc == -1)                     continue;                 // cout << "letter " << j << ' ' << oc << '\n';                 if (n - oc >= req) {                     use = j;                     break;                 }             }             assert(use >= 0);             ans.pb(use + 'a');             l = dp[l][use] + 1;             // cout << "l " << l << '\n';             req--;             if (ans.size() >= k || l >= n)                 break;            }         cout << ans << '\n';      }      return 0; }
#include<iostream> #include<unistd.h> #include<cstdlib> #include<cstring> #include<cstdio> #include<cmath> #include<string.h> #include<algorithm> #include<vector> #include<map> using namespace std; //vector<int> S[101]; map<string,int> mapper; int idx[101]; char str[101][101]; int size[31];  string convertInt(int number) {     if (number == 0)         return "0";     string temp="";     string returnvalue="";     while (number>0)     {         temp+=number%10+48;         number/=10;     }     for (int i=0;i<temp.length();i++)         returnvalue+=temp[temp.length()-i-1];     return returnvalue; }  int main() {     //freopen("input.txt","r",stdin);     //freopen("output.txt","w",stdout);     int t,n,m,temp;     scanf("%d",&t);      while(t)     {         int count=0;         scanf("%d %d",&n,&m);         for(int i=0;i<=n;i++)         {             idx[i]=0;         }         for(int i=0;i<m;i++)         {             //S[i].clear();             string tempo=convertInt(i);             const char* src=tempo.c_str();             scanf("%d",&size[i]);             for(int j=0;j<size[i];j++)             {                 scanf("%d",&temp);                 //str[temp][idx[temp]]=i;                 if(idx[temp]==0)                 {                     strcpy(str[temp],src);                     idx[temp]=1;                 }                 else                 {                     strcat(str[temp],src);                 }                 //temp1=temp-'0';                 //S[i].push_back(temp1);             }             getchar();             //str[i][size[i]]='\0';         }         for(int i=0;i<n;i++)         {             if(mapper.find(str[i])==mapper.end())             {                 count++;                 mapper[str[i]]=t;                 //cout<<"Not Found"<<str[i]<<endl;             }             else if(mapper[str[i]]!=t)             {                 count++;                 mapper[str[i]]=t;                 //cout<<"Not Found"<<str[i]<<endl;             }             else             {                 //cout<<"Found"<<str[i]<<endl;             }         }         printf("%d\n",count);         t--;     }      return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string s;         cin>>s;         int maxlength=0;         int days=0;         int length=s.length();         for(int i=0;i<length;i++){             int length1=0;             int flag=1;             while(s[i]=='.'){                 length1++;                 flag=0;                 i++;             }             if(length1>maxlength){                 maxlength=length1;                 days++;             }             if(flag==0){                 i--;             }                      }         cout<<days<<endl;     } }
#include<bits/stdc++.h>  using namespace std;  #define VAL (int)1e9  int main() { 	int T, M; 	double p; 	cin>>T; 	while (T--) { 		cin>>M>>p; 		double fst = VAL * (1 - pow(-p, M)) / (p + 1); 		double snd = VAL - fst; 		printf("%.4lf %.4lf\n", fst, snd); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; char s[MAXN][20]; int r[MAXN]; int mini[MAXN]; int main(){     int N, Q;     mini[0] = 1e8;     scanf("%d", &Q);     N = 0;     while(Q--){         int x;         scanf("%d", &x);         if(x == -1){             int cnt = 0;             while(mini[N] != r[N]){                 --N;                 ++cnt;             }             printf("%d %s\n", cnt, s[N]);             --N;         } else{             ++N;             r[N] = x;             scanf(" %s", s[N]);             mini[N] = min(mini[N - 1], r[N]);             if(x == 0) --N;         }/*         for(int i = 1;i <= N;++i){             cout << r[i] << " " << mini[i] << " " << s[i] << "\n";         }*/     }     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> using namespace std; int grundy[10010]; int visited[10010];  void grundy_calculator(){     int n;     grundy[0]=grundy[1]=0;     for(int n=2;n<10010;n++){         memset(visited,0,sizeof visited);         int x,y;         for(x=0,y=n-2;x<=y;++x,--y){             visited[grundy[x] ^ grundy[y]]=1;         }         int i;         for(i=0;visited[i];i++);         grundy[n]=i;     } }  int main(){     int test;     cin>>test;     grundy_calculator();     while(test--){         int N;cin>>N;         if(grundy[N]>0) cout<<"Arjuna\n";         else cout<<"Bhima\n";     }     return 0; } 
#pragma warning(disable:4786) #pragma warning(disable:4996) #include<list> #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<assert.h> using namespace std;   #define MEM(a, b) memset(a, (b), sizeof(a)) #define CLR(a) memset(a, 0, sizeof(a)) #define MAX(a, b) ((a) > (b) ? (a) : (b)) #define MIN(a, b) ((a) < (b) ? (a) : (b)) #define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) ) #define S(X) ( (X) * (X) ) #define SZ(V) (int )V.size() #define FORN(i, n) for(i = 0; i < n; i++) #define FORAB(i, a, b) for(i = a; i <= b; i++) #define ALL(V) V.begin(), V.end() #define IN(A, B, C)  ((B) <= (A) && (A) <= (C))   typedef pair<int,int> PII; typedef pair<double, double> PDD; typedef vector<int> VI; typedef vector<PII > VP;   #define AIN(A, B, C) assert(IN(A, B, C))   //typedef int LL; typedef long long int LL; //typedef __int64 LL;   LL MOD = 1000000009; LL fact[1100000];   LL bigmod(LL a, LL b) { 	if(b == 0) return 1; 	LL x = bigmod(a, b / 2); 	x = (x * x) % MOD; 	if(b & 1) x = (x * a) % MOD; 	return x; }   int main() { 	LL ans; 	int k, n, i;   	scanf("%d", &k); 	n = 1<<k;   	fact[0] = 1; 	for(i = 1; i <= n; i++) 		fact[i] = (fact[i - 1] * i) % MOD;   	for(i = 1; i <= n; i++) 	{ 		if(i < n/2 - 1)  		{ 			printf("0\n"); 			continue; 		}   		ans = (fact[i - 1] * bigmod(fact[n/2 - 1], MOD - 2)) % MOD; 		ans = (ans * bigmod(fact[i - n/2], MOD - 2)) % MOD; 		ans = (ans * 2) % MOD; 		ans = (ans * fact[n/2]) % MOD; 		ans = (ans * fact[n/2]) % MOD;   		printf("%lld\n", ans); 	}   	return 0; }  
#include<bits/stdc++.h> using namespace std; string bit(long long a){     string s="";     while(a!=0){         s=(char)((a%2)+48)+s;         a=a/2;              }     return s; } int main(){     long long n;     cin>>n;     while(n--){         long long i,j;         cin>>i>>j;         string i1=bit(i);         string i2=bit(j);         long long length1=i1.length();         long long length2=i2.length();         long long k=0;         long long count=0;         while(k<length1 && k<length2){             if(i1[k]==i2[k]){                 count++;                 k++;             }             else{                 break;             }         }         cout<<length1+length2-2*count<<endl;     } }
#include <iostream> using namespace std; #define ll long long  int main() {   ll t;     cin>>t;     while(t--)     {   ll a,b;         cin>>a>>b;         ll s=b,z=(b-1);         a--;         while(a>0)         {   if(a%2)             {   s*=z;                 s%=1000000007;             }             z*=z;             z%=1000000007;             a/=2;         }         cout<<s<<endl;     }     return 0; }
#include <cstdio> #include <iostream> #include <fstream> #include <sstream> #include <set> #include <map> #include <vector> #include <list> #include <algorithm> #include <cstring> #include <cmath> #include <string> #include <queue> #include <bitset>		 #include <cassert> #include <iomanip>	 using namespace std; #define PB push_back #define LL long long #define ULL unsigned LL #define LD long double     namespace arith {   typedef unsigned int uint; typedef unsigned long long ull;   const int LOGBASE = sizeof(uint)*8; const ull BASE = 1ULL<<LOGBASE;   inline void assert_msg(bool cond, const std::string& msg) {     if (!cond) { std::cerr << "arith: " << msg << std::endl; exit(1); } }   inline void strip(std::vector<uint>& r, int pos=0) {     while (r.size()>pos && !r.back()) r.pop_back(); }   inline void add(const std::vector<uint>& x, ull s, std::vector<uint>& r) {     r.resize(x.size());     for (int i=0; i<x.size(); ++i) { s += x[i]; r[i] = s; s >>= LOGBASE; }     if (s) r.push_back(s); }   inline void add(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {     r.resize(std::max(x.size(), y.size())); ull s=0; int i=0;     for (; i<x.size() && i<y.size(); ++i) { s += x[i]; s += y[i]; r[i] = s; s >>= LOGBASE; }     for (; i<x.size(); ++i) { s += x[i]; r[i] = s; s >>= LOGBASE; }     for (; i<y.size(); ++i) { s += y[i]; r[i] = s; s >>= LOGBASE; }     if (s) r.push_back(s); }   template<class Iter1, class Iter2> inline int cmp(Iter1 b1, Iter2 e1, Iter1 b2, Iter2 e2) {     if (e1-b1!=e2-b2) return e1-b1<e2-b2 ? -1 : 1;     while (e1!=b1) if (*--e1 != *--e2) return *e1<*e2 ? -1 : 1;     return 0; }   inline void sub(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r, int pos=0) {     int old_pos=pos; r.resize(x.size()); ull s=1;     for (int i=0; i<y.size(); ++i, ++pos) { s += x[pos]; s += (BASE-1)-y[i]; r[pos] = s; s >>= LOGBASE; }     if (!s) {         for (; !x[pos]; ++pos) r[pos] = BASE-1;         r[pos] = x[pos]-1; ++pos;     }     for (; pos<x.size(); ++pos) r[pos] = x[pos];     strip(r, old_pos); }   inline void mul(const std::vector<uint>& x, uint v, std::vector<uint>& r) {     r.resize(x.size()); ull s=0;     for (int i=0; i<x.size(); ++i) { s += 1ULL*v*x[i]; r[i] = s; s >>= LOGBASE; }     if (s) r.push_back(s);     strip(r); }   inline void muladd(const std::vector<uint>& x, uint v, std::vector<uint>& r, int pos) {     ull s=0;     for (int i=0; i<x.size(); ++i, ++pos) { s += 1ULL*v*x[i] + r[pos]; r[pos] = s; s >>= LOGBASE; }     for (; s && pos<r.size(); ++pos) { s += r[pos]; r[pos] = s; s >>= LOGBASE; }     if (s) r.push_back(s); }   inline void mul(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {     if (x.empty() || y.empty()) return;     r.resize(x.size()+y.size()-1);     for (int i=x.size()-1; i>=0; --i) muladd(y, x[i], r, i);     strip(r); }   inline uint div(const std::vector<uint>& x, uint d, std::vector<uint>& r) {     r.resize(x.size()); uint q=0;     for (int i=x.size()-1; i>=0; --i) { ull t = BASE*q + x[i]; r[i] = t/d; q = t%d; }     strip(r);     return q; }   inline void div(std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {     if (x.size()<y.size()) return;     int pos = x.size()-y.size(); r.resize(pos+1);     std::vector<uint> buf;     do {         uint q=0;         for (uint m=1U<<LOGBASE-1; m; m>>=1) {             mul(y, q|m, buf);             if (cmp(buf.begin(), buf.end(), x.begin()+pos, x.end()) <= 0) q|=m;         }         r[pos] = q; mul(y, q, buf);         sub(x, buf, x, pos);     } while (pos--);     strip(r); }   } // namespace arith   //using namespace arith;   class biguint {     std::vector<uint> buf;      public:     biguint() {}     biguint(int x) {                 if (x) buf.push_back(x);     }     biguint(unsigned int x) {         if (x) buf.push_back(x);     }     biguint(long long x) {                 if (x) buf.push_back(x);         if (x>>arith::LOGBASE) buf.push_back(x>>arith::LOGBASE);     }     biguint(unsigned long long x) {         if (x) buf.push_back(x);         if (x>>arith::LOGBASE) buf.push_back(x>>arith::LOGBASE);     }          biguint& operator+=(const biguint& y) {         arith::add(buf, y.buf, buf);         return *this;     }     biguint& operator-=(const biguint& y) {                 arith::sub(buf, y.buf, buf);         return *this;     }     biguint& operator*=(const biguint& y) {         std::vector<uint> tmp;         arith::mul(buf, y.buf, tmp);         buf = tmp;         return *this;     }     biguint& operator/=(const biguint& y) {                 std::vector<uint> tmp;         arith::div(buf, y.buf, tmp);         buf = tmp;         return *this;     }     biguint& operator%=(const biguint& y) {                 std::vector<uint> tmp;         arith::div(buf, y.buf, tmp);         return *this;     }          friend biguint operator+(const biguint& x, const biguint& y) {         biguint z;         arith::add(x.buf, y.buf, z.buf);         return z;     }     friend biguint operator-(const biguint& x, const biguint& y) {                 biguint z;         arith::sub(x.buf, y.buf, z.buf);         return z;     }     friend biguint operator*(const biguint& x, const biguint& y) {         biguint z;         arith::mul(x.buf, y.buf, z.buf);         return z;     }     friend biguint operator/(const biguint& x, const biguint& y) {                 std::vector<uint> tmp(x.buf); biguint z;         arith::div(tmp, y.buf, z.buf);         return z;     }     friend biguint operator%(const biguint& x, const biguint& y) {                 biguint z(x); std::vector<uint> tmp;         arith::div(z.buf, y.buf, tmp);         return z;     }         bool operator!() const { return buf.empty(); }          friend bool operator==(const biguint& x, const biguint& y) {         return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) == 0;     }     friend bool operator!=(const biguint& x, const biguint& y) {         return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) != 0;     }     friend bool operator<(const biguint& x, const biguint& y) {         return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) < 0;     }     friend bool operator<=(const biguint& x, const biguint& y) {         return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) <= 0;     }     friend bool operator>(const biguint& x, const biguint& y) {         return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) > 0;     }     friend bool operator>=(const biguint& x, const biguint& y) {         return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) >= 0;     }          friend std::istream& operator>>(std::istream&, biguint&);     friend std::ostream& operator<<(std::ostream&, biguint); };   std::istream& operator>>(std::istream& is, biguint& x) {	     std::string s; is >> s;     x.buf.clear();     for (int i=0; i<s.size(); ++i) {         arith::mul(x.buf, 10, x.buf);         arith::add(x.buf, s[i]-'0', x.buf);     }     return is; }   std::ostream& operator<<(std::ostream& os, biguint x) {     std::string s;     while (!x.buf.empty()) {         uint q = arith::div(x.buf, 10, x.buf);         s += q+'0';     }     if (s.empty()) s += '0';     std::reverse(s.begin(), s.end());     return os << s; }   const biguint zero(0), one(1), two(2);   biguint nwd(biguint a, biguint b) { return b > 0 ? nwd(b, a % b) : a; }   struct liczba { 	biguint l, m; 	liczba(): l(0), m(1) {} 	liczba(biguint a): l(a), m(1) {} 	liczba(biguint a, biguint b): l(a), m(b) {}	 	liczba operator*(const liczba &L) const 	{ 		liczba tmp; 		tmp.l = l * L.l; 		tmp.m = m * L.m;		 		return tmp; 	} 	liczba operator/(const liczba &L) const 	{ 		liczba tmp; 		tmp.l = l * L.m; 		tmp.m = m * L.l;		 		return tmp; 	} 	liczba operator+(const liczba &L) const 	{ 		liczba tmp; 		tmp.m = m*L.m; 		tmp.l = L.m * l + m * L.l;		 		return tmp; 	} 	liczba operator-(const liczba &L) const 	{ 		liczba tmp; 		tmp.m = m*L.m; 		tmp.l = L.m * l - m * L.l;		 		return tmp; 	}	 	void normalize() 	{ 		biguint d = nwd(l, m); 		l /= d; 		m /= d; 	} };   #define MR 151   liczba t[MR];   biguint sil[MR], sil1[MR], sil2[MR]; liczba sum[MR], dod[MR];   inline void F(int n) {	 	if(n > 3) 	{ 		dod[n] = dod[n-1] + (liczba)sil1[n-2]*((liczba)1+t[n-2]); 		dod[n].normalize(); 		sum[n] = sum[n-1] + (liczba)(2*sil1[n-1])*((liczba)1+t[n-1])+dod[n]; 		sum[n].normalize(); 	} 	t[n] = ((liczba)(1+sil1[n])+sum[n])/(liczba)sil2[n-1];	 	t[n].normalize(); }//F   int main() {	 	sil[0] = 1; 	for(int i = 1; i < MR; i++) 		sil[i] = sil[i-1]*i; 	for(int i = 2; i < MR; i++) 		sil1[i] = sil[i]-2*sil[i-1]+sil[i-2]; 	for(int i = 1; i < MR; i++) 		sil2[i] = 2*sil[i]-sil[i-1]; 	t[2] = (liczba)2; 	sum[3] = (liczba)6;	//dod[3] = 0	 	for(int i = 3; i < MR; i++) 		F(i);		 	int tests; 	cin >> tests; 	for(int c = 0; c < tests; c++) 	{ 		int n; 		cin >> n;		 		if(n != 2 && n != 4) 			cout << t[n].l << "/" << t[n].m << "\n"; 		else if(n == 2) 			cout << "2\n"; 		else 			cout << "5\n"; 	} 	return 0; } 
#include<iostream> #include<stdio.h> using namespace std; int main() { 	long long int t,n; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		long long int f=0; 		long long int a[1000000]; 		for(int i=0;i<n;i++) 		{ 			cin>>a[i]; 		} 		for(int i=0;i<n;i++) 		{ 			if(i>0) 			{ 				if(a[i-1]!=a[i]) 				{ 					f++; 					continue; 				} 			} 		    if (i<n-1) 			{ 				if(a[i+1]!=a[i]) 				{ 					f++; 				} 			} 		} 		cout<<f<<"\n"; 	} }
#include <iostream> #include <algorithm> #include <string.h> using namespace std;  int main() {     long int t,n,x,i,ramt,sum; 	cin>>t; 	while(t--) 	{ 	    sum=0; 	    cin>>n>>x; 	    long int a[n]; 	    for(i=0;i<n;i++) 	    { 	        cin>>a[i]; 	        sum+=a[i]; 	    } 	    ramt=sum%x; 	    sort(a,a+n); 	    for(i=0;i<n;i++) 	    { 	        if(a[i]<=ramt) 	        break; 	    } 	    if(i<n) 	    cout<<"-1\n"; 	    else 	    cout<<sum/x<<endl; 	}     return 0; }  
#include <cstdio>   #define MOD 1000000007   struct mat{ 	int vals[3][3]; 	mat(){ 		for(int i=0; i<3; i++) 		for(int j=0; j<3; j++) 			vals[i][j]=i==j; 	} };   mat operator*(const mat &lhs, const mat &rhs){ 	mat res; 	for(int i=0; i<3; i++) 	for(int j=0; j<3; j++){ 		long long sum=0; 		for(int k=0; k<3; k++) 			sum+=(long long)lhs.vals[i][k]*rhs.vals[k][j]; 		res.vals[i][j]=sum%MOD; 	} 	return res; }   mat pow(const mat &base, int exp){ 	mat res; 	mat sq(base); 	for(; exp; exp>>=1){ 		if(exp&1) 			res=res*sq; 		sq=sq*sq; 	} 	return res; }   int m[3][3]={ 	1, 4, 2, 	1, 0, 0, 	0, 1, 0, };   int solve(int N){ 	mat base; 	for(int i=0; i<3; i++) 	for(int j=0; j<3; j++) 		base.vals[i][j]=m[i][j]; 	return pow(base, N).vals[0][0]; }   int main(){ 	int T; 	scanf("%d", &T); 	while(T--){ 		int N; 		scanf("%d", &N); 		printf("%d\n", solve(N)); 	} 	return 0; } 
#include<iostream> #include<string.h> using namespace std; const int LN=20; struct BigInt {     int num[LN+1];     BigInt()     {         memset(num,0,sizeof(num));        num[0]=0;      }     BigInt(int x)     {        memset(num,0,sizeof(num));        num[0]=1;        num[LN]=x;        if(x>=10000)        {           num[0]++;           num[LN-1]=x/10000;           num[LN]=x%10000;        }     } }; BigInt operator +(BigInt &a,BigInt &b) {     int i;     BigInt res;     memset(res.num,0,sizeof(res.num));     int len=max(a.num[0],b.num[0]);     for(i=LN;i>=LN-len+1;i--)     {        int m=res.num[i]+a.num[i]+b.num[i];        res.num[i]=m%10000;        res.num[i-1]=m/10000;     }     if(res.num[LN-len]!=0)        res.num[0]=len+1;     else        res.num[0]=len;     return res; } BigInt operator *(BigInt &a,BigInt &b) {    BigInt res;    memset(res.num,0,sizeof(res.num));    int i,j,p=0,npos=1000000000;    for(i=LN;i>=LN-b.num[0]+1;i--)    {       for(j=LN;j>=LN-a.num[0]+1;j--)       {          int m=res.num[j-p]+a.num[j]*b.num[i];          res.num[j-p]=m%10000;          if(m%10000)             npos=min(npos,j-p);          res.num[j-p-1]+=m/10000;          if(m/10000)            npos=min(npos,j-p-1);       }       p++;    }    while(npos<=LN && res.num[npos]==0)       npos++;    while(npos>1 && npos<=LN && res.num[npos-1]!=0)       npos--;    res.num[0]=LN-npos+1;    return res; } BigInt operator -(BigInt &a,BigInt b) {    BigInt res;    int i;    memset(res.num,0,sizeof(res.num));    int len=max(a.num[0],b.num[0]);    for(i=LN;i>=LN-len+1;i--)    {       int m=res.num[i]+a.num[i]-b.num[i];       res.num[i]=m;       if(res.num[i]<0)       {          res.num[i]+=10000;          res.num[i-1]--;       }    }    for(i=0;i<=LN;i++)    {       if(res.num[i]!=0)       {          res.num[0]=LN-i+1;          break;       }    }    return res; } void out(BigInt &a) {     int i;     for(i=LN-a.num[0]+1;i<=LN;i++)     {   		if (i==LN-a.num[0]+1) printf("%d",a.num[i]); else 		if (a.num[i]<10) printf("000%d",a.num[i]); else 		if (a.num[i]<100) printf("00%d",a.num[i]); else 		if (a.num[i]<1000) printf("0%d",a.num[i]); else 		printf("%d",a.num[i]);     }     printf("\n"); }  int main() {     int t;     scanf("%d",&t);     BigInt one(1),four(4),two(2);     while(t--)     {        int n,m;        scanf("%d%d",&n,&m);        if(n==1 && m==1)        {          printf("0\n");          continue;        }        BigInt res,a(n),b(m),temp,t1,t2,t3;        t1=a*b;        t2=t1-one;        res=t1*t2;        if(m>1 && n>2)        {          t1=a-two;          t2=b-one;          t3=four*t1;          t3=t3*t2;          res=res-t3;        }        if(m>2 && n>1)        {           t1=a-one;           t2=b-two;           t3=four*t1;           t3=t3*t2;           res=res-t3;        }        out(res);     }     return 0; } 
#include<stdio.h> #include<string.h> using namespace std; #define Nrange 50001 #define sn(a) scanf("%d",&a) #define FOR(i,n) for(i=0;i<n;++i) #define fill(a,g) memset(a,g,sizeof(a)) int main() 	{     int T; 	int a[Nrange];     int b[Nrange],c[Nrange],d[Nrange]; 	int f[Nrange],ans,sum,temp,i,j,N,ini,k; 	sn(T); 	while(T--) 		{ 		sn(N); 		fill(c,0); 		fill(d,0); 		FOR(i,N) 			{ 			sn(a[i]); 			sn(b[i]); 			c[a[i]]++; 			d[b[i]]++; 			} 		sum=0;ans=0; 		for(i=N;i>=0;--i) 			{ 			sum+=d[i]; 			if(i==sum) 			f[ans++]=i; 			sum-=c[i]; 			} 		printf("%d\n",ans); 		 		ini=0; 		for(i=0;i<N;++i)     			{                      			if(f[ans-1]>=a[i] && f[ini]<=b[i])     			printf("1");     			else         				{             				printf("0");             				for(j=ans-1;j>=ini;--j)             				if(f[j]>=a[i])             				break;             				temp=0;             				for(k=j;k>=ini;--k)                 				{                 				if(f[k]>b[i])                 				break;                 				temp++;                 				}             				for(;k>=ini;--k,--j)             				f[j]=f[k];             				ini+=temp;         				} 			} 		printf("\n"); 		} 		return 0; 	} 
#define _CRT_SECURE_NO_WARNINGS #include <iostream> #include <stdio.h> #include <stdlib.h> #include <algorithm> #include <string.h> #include <string>   using namespace std;   string s; int t, k;   int main() { 	scanf("%d", &t); 	while (t--) 	{ 		cin >> k >> s; 		if (s.size() == 1) 		{ 			cout << (s[0] == '?' ? '0' : s[0]) << endl; 			continue; 		} 		if (k == 1) 		{ 			if (s.size() == 1) 				cout << (s[0] == '?' ? '0' : s[0]) << endl; 			else 				cout << "NO" << endl; 		} 		if (k == 2) 		{ 			bool f1 = true; 			bool f2 = true; 			for (int i = 0; i < s.size(); ++i) 			{ 				if (s[i] != '?' && s[i] != char('0' + i % 2)) 					f1 = false; 				if (s[i] != '?' && s[i] != char('0' + (i + 1) % 2)) 					f2 = false; 			} 			if (s.size() % 2 == 1) 				f1 = f2 = false; 			if (!f1 && !f2) 				cout << "NO" << endl; 			else 			{ 				for (int i = 0; i < s.size(); ++i) 					cout << (f1 ? char('0' + i % 2) : char('0' + (i + 1) % 2)); 				cout << endl; 			} 		} 		if (k >= 3) 		{ 			bool ok = true; 			for (int i = 0; i < s.size() && ok; ++i) 				if (s[i] != '?' && s[i] == s[i == s.size() - 1 ? 0 : i + 1]) 					ok = false; 			for (int i = 0; i < s.size() && ok; ++i) 			{ 				for (char c = '0'; c < '3' && s[i] == '?'; ++c) 					if (s[i == 0 ? s.size() - 1 : i - 1] != c && s[i == s.size() - 1 ? 0 : i + 1] != c) 						s[i] = c;					 			} 			if (ok) 				cout << s << endl; 			else 				cout << "NO" << endl; 		} 	} } 
#include<bits/stdc++.h> using namespace std;  const int INF = 1e8; char grid[60][60]; int L[60][60]; int R[60][60]; int T[60][60]; int B[60][60];  int main(){     int t;     cin >> t;     while(t--){         int N, M;         scanf("%d%d", &N, &M);         for(int i = 1;i <= N;++i){             for(int j = 1;j <= M;++j){                 scanf(" %c", &grid[i][j]);             }         }         for(int i = 1;i <= N;++i){             L[i][0] = 0;             for(int j = 1;j <= M;++j){                 if(grid[i][j] == '#'){                     L[i][j] = 0;                 } else {                     L[i][j] = (L[i][j - 1] + 1);                 }             }             R[i][M + 1] = 0;             for(int j = M;j >= 1;--j){                 if(grid[i][j] == '#'){                     R[i][j] = 0;                 } else {                     R[i][j] = (R[i][j + 1] + 1);                 }             }         }         for(int j = 1;j <= M;++j){             T[0][j] = 0;             for(int i = 1;i <= N;++i){                 if(grid[i][j] == '#'){                     T[i][j] = 0;                 } else {                     T[i][j] = (T[i - 1][j] + 1);                 }             }             B[N + 1][j] = 0;             for(int i = N;i >= 1;--i){                 if(grid[i][j] == '#'){                     B[i][j] = 0;                 } else {                     B[i][j] = (B[i + 1][j] + 1);                 }             }         }         int ans = 0;         for(int i = 1;i <= N;++i){             for(int j = 1;j <= M;++j){                 if(grid[i][j] == '#') continue;                 int l = L[i][j] - 1;                 int r = R[i][j] - 1;                 int t = T[i][j] - 1;                 int b = B[i][j] - 1;                 int cur = INF;                 cur = min(cur, l);                 cur = min(cur, r);                 cur = min(cur, t);                 cur = min(cur, b);                 if(cur >= 2) ++ans;             }         }         printf("%d\n", ans);     }     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; char arr[501][501]; struct cell{ 	int T,B,L,R; }; int min(struct cell temp) { 	int m=temp.L; 	if(m>temp.R) 	   m=temp.R; 	if(m>temp.T) 	   m=temp.T; 	if(m>temp.B) 	   m=temp.B; 	    	return m; }	 int number[] = {0,0,1,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,9,9,9,10,10,11,11,11,11,11,11,12,12,12,12,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,17,17,18,18,18,18,18,18,19,19,19,19,20,20,21,21,21,21,21,21,22,22,22,22,23,23,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,26,26,27,27,27,27,28,28,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,32,32,32,32,32,32,33,33,34,34,34,34,34,34,34,34,34,34,35,35,36,36,36,36,36,36,37,37,37,37,37,37,38,38,38,38,39,39,39,39,39,39,40,40,40,40,40,40,41,41,42,42,42,42,42,42,42,42,42,42,43,43,44,44,44,44,45,45,46,46,46,46,46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,47,47,47,47,48,48,48,48,49,49,50,50,50,50,51,51,51,51,51,51,52,52,53,53,53,53,53,53,53,53,53};   int main() { 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	int t,row,col,i,j,count; 	//cin>>t; 	scanf("%d",&t); 	while(t--) 	{ 			count=0; 			//cin>>row>>col; 			scanf("%d %d",&row,&col); 		 			for(i=0;i<row;i++) 			{ 				scanf("%s",&arr[i]); 			} 			 			cell firstDP[row][col]; 			for(i=0;i<row;i++) 			{ 				for(j=0;j<col;j++) 				{ 					if(j==0) 					   firstDP[i][j].L=0; 					else if(arr[i][j]=='#' || arr[i][j-1]=='#') 					    firstDP[i][j].L=0; 					else 						firstDP[i][j].L=firstDP[i][j-1].L+1; 				} 				   			} 			for(i=0;i<row;i++) 			{ 				for(j=col-1;j>=0;j--) 				{ 					if(j==col-1) 					   firstDP[i][j].R=0; 					else if(arr[i][j]=='#' || arr[i][j+1]=='#') 					    firstDP[i][j].R=0; 					else 						firstDP[i][j].R=firstDP[i][j+1].R+1; 				} 				   			} 			for(i=0;i<row;i++) 			{ 				for(j=0;j<col;j++) 				{ 					if(i==0) 					   firstDP[i][j].T=0; 					else if(arr[i][j]=='#' || arr[i-1][j]=='#') 					    firstDP[i][j].T=0; 					else 						firstDP[i][j].T=firstDP[i-1][j].T+1; 				} 				   			} 			for(i=row-1;i>=0;i--) 			{ 				for(j=0;j<col;j++) 				{ 					if(i==row-1) 					   firstDP[i][j].B=0; 					else if(arr[i][j]=='#' || arr[i+1][j]=='#') 					    firstDP[i][j].B=0; 					else 						firstDP[i][j].B=firstDP[i+1][j].B+1; 				} 				   			} 			for(i=0;i<row;i++) 			{ 			  for(j=0;j<col;j++) 			  { 			  	  int mi=min(firstDP[i][j]); 			  	  count+=number[mi]; 			  	  //cout<<min(firstDP[i][j])<<" "; 			  } 			  //cout<<endl; 			} 			 			/*for(i=0;i<row;i++) 			{ 			  for(j=0;j<col;j++) 			  { 			  	  //int mi=min(firstDP[i][j]); 			  	  //count+=number[mi]; 			  	  //cout<<min(firstDP[i][j])<<" "; 			  	  cout<<"arr["<<i<<"]["<<j<<"] : "; 			  	  cout<<"L = "<<firstDP[i][j].L<<" , "; 			  	  cout<<"R = "<<firstDP[i][j].R<<" , "; 			  	  cout<<"T = "<<firstDP[i][j].T<<" , "; 			  	  cout<<"B = "<<firstDP[i][j].B<<" , "; 			  	  cout<<endl; 			  } 			  cout<<endl; 			}*/ 			      			//count=check(row,col); 			//count=calculate(row,col); 			printf("%d\n",count); 			 			//cout<<"\n\n"; 		 		   	} }
#include <iostream> #include<algorithm> using namespace std; int main() { 	long long t; 	cin>>t;     while(t--)     {         long long n,counting = 1;         cin>>n;         long long a[n],s;         for(long i =0;i<n;i++)         {             cin>>a[i];           }         sort (a,a+n);           s = a[0];          for(long i =1;i<n;i++)          {              if (s!=a[i]) {counting++;                }s = a[i];          }          cout<<counting<<endl;     } } 
#include<bits/stdc++.h> int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,i,count=1;         scanf("%d",&n);         int a[10001];         scanf("%d",&a[0]);         int max=a[0];         for(i=1;i<n;i++)         {             scanf("%d",&a[i]);             if(a[i]<max)             {                 max=a[i];                 count++;             }         }         printf("%d\n",count);     } } 
#include<bits/stdc++.h> using namespace std; #define ll long long  #define aut(r,v) typeof(v) r = (v) #define FOR(i,a,n) for (int i=(a);i<(n);++i) #define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) #define pb push_back #define mp make_pair #define vi vector<int > #define pii pair<int ,int > #define fr first #define sc second #define MOD 1000000007 const double PI=2*acos(0.0);   bool prime[10005]; void mark(){   memset(prime,1,sizeof(prime));   FOR(i,2,1e4+7){   if(prime[i]){    for(int j=i+i;j<1e4+7;j+=i)        prime[j]=false;    }  } }  int a[10005]; int main(){   int t,n;   cin>>t;   mark();   while(t--){      cin>>n;      FOR(i,0,n) cin>>a[i];      int ans=INT_MAX;      FOR(i,2,1e4+7){         if(!prime[i]) continue;         int curr=0;         int temp=0;         FOR(j,0,n){            if(a[j]>curr)               curr=((a[j]+i-1)/i)*i;               temp+=curr-a[j];         }         ans=min(ans,temp);      }      cout<<ans<<endl;   }   return 0; }
#include <bits/stdc++.h> #define ll long long int #define MOD 1000000007 using namespace std;  int main() {     ll t,n,m,ans,curr,i;     cin>>t;     while(t--)     {         cin>>n;         curr=0;         ans=0;         for(i=0;i<n;i++)         {             cin>>m;             if(m>curr)                 ans+=(m-curr);             curr=m;         }         cout<<ans<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  int main() { 	 	int t; cin>>t; 	while(t--) 	{ 	long  long int arr[3],i,j,flag,temp,sto=0,k,min; 		for(i=0;i<3;i++) 		cin>>arr[i]; 		cin>>k; 		temp=k-1; 		//flag=0; 		if(k==1) 		{ 			cout<<1<<endl; 			continue; 		} 	sort(arr,arr+3); 	if(k<=arr[0]) 		cout<<(k-1)*3+1<<endl; 		else 		{ 	     //sort(arr,arr+3); 	     min=arr[0]; 	    sto=sto+min*3; 	    k=k-min; 	    if(k==1) 	    sto+=1; 	    else 	    { 	    	 	    	arr[1]-=min; 	    	arr[2]-=min; 	    	arr[0]-=min; 	    	if(k<=arr[1]) 	    	sto=sto+(k-1)*2+1; 	    	else 	    	{ 	    		 sto += arr[1]*2;                        sto += (k-arr[1]); 	    	} 	    	 	    	 	   	 	    } 	      		 cout<<sto<<endl;	 			 			 			 		} 		 	} 	return 0; }
// Mugurel Ionut Andreica  #include <stdio.h> #include <string.h>  #define LMAX 1024  char color[6][LMAX]; int adj[8][3] = { {0, 2, 4}, {0, 3, 4}, {0, 2, 5}, {0, 3, 5}, {1, 2, 4}, {1, 3, 4}, {1, 2, 5}, {1, 3, 5}, };  int main() { 	int T, i; 	scanf("%d", &T); 	while (T--) { 		for (i = 0; i < 6; i++) scanf("%s", color[i]); 		for (i = 0; i < 8; i++) 			if (!strcmp(color[adj[i][0]], color[adj[i][1]]) && 				!strcmp(color[adj[i][0]], color[adj[i][2]])) break; 		if (i < 8) printf("YES\n"); 		else printf("NO\n"); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         long long n;         cin>>n;         long long *array=new long long[n];         for(int i=0;i<n;i++){             cin>>array[i];         }         sort(array,array+n);         long long sum=0;         for(int i=n-1;i>=0;i=i-2){             sum+=array[i];         }         cout<<sum<<endl;              } }
#include<iostream> using namespace std; int main() {    long long int T,N,i,j,rowFirst,rowLast,columnFirst,columnLast,input[75][75],matrix[75][75],ans;    cin>>T;    while(T--)    {       cin>>N;       for(i=0;i<N;++i)       for(j=0;j<N;++j)       {          cin>>input[i][j];          if(i==0&&j==0)             matrix[0][0]=input[0][0];          else if(i==0)             matrix[0][j]=input[i][j]^matrix[i][j-1];          else if(j==0)             matrix[i][0]=input[i][j]^matrix[i-1][j];          else             matrix[i][j]=input[i][j]^matrix[i][j-1]^matrix[i-1][j]^matrix[i-1][j-1];       }       ans=0;       for(rowFirst=0;rowFirst<N;++rowFirst)       {          for(rowLast=rowFirst;rowLast<N;++rowLast)          {             for(columnFirst=0;columnFirst<N;++columnFirst)             {                for(columnLast=columnFirst;columnLast<N;++columnLast)                {                   if(rowFirst==0&&columnFirst==0)                      i=matrix[rowLast][columnLast];                   else if(columnFirst==0)                      i=matrix[rowLast][columnLast]^matrix[rowFirst-1][columnLast];                   else if(rowFirst==0)                      i=matrix[rowLast][columnLast]^matrix[rowLast][columnFirst-1];                   else                      i=matrix[rowLast][columnLast]^matrix[rowFirst-1][columnLast]^matrix[rowLast][columnFirst-1]^matrix[rowFirst-1][columnFirst-1];                   if(ans<i)                      ans=i;                }             }          }       }       cout<<ans<<endl;    }    return 0; }
// by xcwgf666  #include <iostream> #include <cassert> #include <vector> #include <algorithm> #include <cstdio> using namespace std;  int n, m, k, i, j, ret, x, y, cl[100000 + 5]; vector<pair<int, int> > v[100000 + 5]; vector<int> d;  int main (int argc, char * const argv[]) { 	scanf("%d %d %d", &n, &m, &k); 	assert(1 <= n && n <= 100000); 	assert(1 <= m && m <= 100000); 	assert(1 <= k && k <= 100000); 	for(i = 1; i <= k; i++) { 		scanf("%d %d", &x, &y); 		assert(1 <= x && x <= n); 		assert(1 <= y && y <= m); 		v[x].push_back(make_pair(y, 1)); // we can solve all the rows independently / let's mark the y-th cell in the x-th row as the interesting one 		// and the adjacent cells as well (y - 1 and y + 1) 		if (y > 1) v[x].push_back(make_pair(y - 1, 0)); 		if (y < m) v[x].push_back(make_pair(y + 1, 0)); 	} 	for(i = 1; i <= n; i++) if (v[i].size()) { 		// 1 and m are interesting cells in each row as well 		// and now if there is a cell x such that a[x] > a[x + 1], then the both x and x + 1 are interesting cells 		v[i].push_back(make_pair(1, 0));  		v[i].push_back(make_pair(m, 0)); 		// apply all the changes 		for(j = 0; j < v[i].size(); j++) cl[v[i][j].first] = v[i][j].first; 		for(j = 0; j < v[i].size(); j++) cl[v[i][j].first] += v[i][j].second; 		d.clear(); 		for(j = 0; j < v[i].size(); j++) d.push_back(v[i][j].first); 		sort(d.begin(), d.end()); 		d.resize(unique(d.begin(), d.end()) - d.begin()); 		ret = 0; 		for(j = 1; j < d.size(); j++) { // checking as above 			ret += cl[d[j]] - cl[d[j - 1]]; 			if (cl[d[j]] < cl[d[j - 1]]) { // if we have found something 				ret = -1; 				break; 			} 		} 		printf("%d\n", ret); 	} else printf("%d\n", m - 1);     return 0; }
#include<bits/stdc++.h> using namespace std; #define mod 1000000007 #define LL int long long LL dp[102][102]={0}; int A[102]; LL solve(int x,int y) { 	int i,j,k; 	if(dp[x][y]>0) 	{ 	return dp[x][y]; 	} 	LL ans=1; 	if(A[x]== -A[y] && A[y]>A[x]) 	{ 	ans++; 	} 	for(i=x+1;i<(y-1);i++) 	{ 	for(j=i+1;j<y;j++) 	{       if(A[i]== -A[j] && A[j]>A[i])        {        if(i==x && j==y)        {        break;        }           LL temp=(solve(i,j)-1)%mod;           LL tem=(solve(j,y))%mod;           ans+=(LL)((temp*tem)%mod);          if(ans>=mod)          {          ans%=mod;          }        } 	} 	} 	return dp[x][y]=ans; } int main() { 	int n; 	scanf("%d",&n); 	int i; 	for(i=1;i<=n;i++) 	{ 	scanf("%d",&A[i]); 	} 	LL ans=solve(0,n+1); 	if(ans==0){ans=1;} 	printf("%lld\n",ans); 	return 0; }
#include<iostream> using namespace std;   int main() { int t,c,n,m; int ans; scanf("%d",&t); while(t--) { scanf("%d",&c); ans = 0; while(c--) { scanf("%d%d",&n,&m); ans = ans ^ ((n+m-2)%3); } if(ans!=0) printf("MasterChef\n"); else printf("Football\n"); } }
#include <bits/stdc++.h>  using namespace std;  int main() {     string s;     long long int t,i,l,a,b;     cin>>t;     while(t--)     {         cin>>s;         l=s.length();         a=b=0;         for(i=0;i<l;i++)         {             if(i%2==0)             {                 if(s[i]=='+')                     b++;                 else                     a++;             }             else             {                 if(s[i]=='-')                     b++;                 else                     a++;             }         }         if(a<b)             cout<<a<<endl;         else             cout<<b<<endl;      }     return 0; } 
#include<iostream> #include<algorithm> #define mod 1000000007 typedef long long ll; using namespace std; ll a[10000005],pr[10000005],sf[10000005]; int main() {	//freopen("scl2.txt","r",stdin); 	ll n,k,q; 	cin>>n>>k>>q; 	ll ar,b,c,d,e,f,r,s,t,m,a1; 	ll l1,la,lc,lm,d1,da,dc,dm; 	cin>>ar>>b>>c>>d>>e>>f>>r>>s>>t>>m>>a1; 	cin>>l1>>la>>lc>>lm>>d1>>da>>dc>>dm; 	 	a[0]=a1; 	ll pw=t; 	for(int i=1;i<n;i++) 	{ 		pw=(pw*t)%s; 		if(pw<=r) 		{ 			a[i]=(a[i-1]*(ar*a[i-1] + b)%m + c%m)%m; 		} 		else 		a[i]=(a[i-1]*(d*a[i-1] + e)%m+ f%m)%m; 	} 	 /*	for(int i=0;i<n;i++) 	cout<<a[i]<<" "; 	cout<<"\n";*/ 	 	//computing prefix array 	ll c1=n%k,m1=a[n-1]; 	for(int i=n-1;i>=0;i--) 	{ 		if(c1==0) 		{ 			c1=k; 			m1=a[i]; 		} 		m1=min(m1,a[i]); 		pr[i]=m1; 		c1--; 	} 	//computing suffix array 	ll c2=0,m2=a[1]; 	for(int i=0;i<n;i++) 	{ 		if(c2==k) 		{ 			c2=0; 			m2=a[i]; 		} 		m2=min(m2,a[i]); 		sf[i]=m2; 		c2++; 	} 	 	/*for(int i=0;i<n;i++) 	cout<<sf[i]<<" "; 	cout<<"\n"; 	for(int i=n-1;i>=0;i--) 	cout<<pr[i]<<" "; 	cout<<"\n";*/ 	ll l,rit; 	ll sm=0,mlt=1; 	for(int i=1;i<=q;i++) 	{ 		l1=((l1*la)%lm + lc%lm)%lm; 		d1=((d1*da)%dm+ dc%dm)%dm; 		l=l1+1; 		rit=min(l+k-1+d1,n); 		//cout<<l<<rit<<"\n"; 		 		ll mn; 			mn=min(pr[l-1],sf[rit-1]); 			if(((l-1)/k)==((rit-1)/k-2)) 			mn=min(mn,sf[(rit-rit%k)-1]); 		 		sm+=mn; 		 		mlt=(mlt*mn)%mod; 		mlt%=mod; 		 	} 	 	cout<<sm<<" "<<mlt<<"\n"; 	return 0; }
#include <bits/stdc++.h> #define ll long long int #define MOD 1000000007 using namespace std; vector<ll> x; int main() {     ll t,n,i,j;     cin>>t;     while(t--)     {         cin>>n;         x.assign(100001,0);         for(i=0;i<n;i++)         {             cin>>j;             x[j]++;         }         j=0;         for(i=0;i<100001;i++)         {             if(j<x[i])                 j=x[i];         }         cout<<n-j<<endl;     }     return 0; } 
#include <iostream> #include <bits/stdc++.h> typedef long long int ll; using namespace std;  int main() { 	ll t; 	cin>>t; 	while(t--) 	{ 		ll n,m; 		cin>>n>>m; 		ll sum =0; 		for(ll i=0;i<n;i++) 		{ 			ll a; 			cin>>a; 			sum += a; 		}  		if((sum+m)%n == 0) cout<<"Yes"<<endl; 		else cout<<"No"<<endl; 	} 	return 0; } 	
#include<stdio.h> #include<string.h> #define ll long long #define limit (ll)1e7 int p[limit+1]; int arr[352][352]; int n; ll result=0; #define FORI(i,a,n) for(int i=a;i<=n;i++) #define FOR(i,n) FORI(i,0,n-1) void gen() // used to generate the primes below 10^7  { 	memset(p,0,sizeof(p)); 	p[0]=p[1]=-1; 	ll k=0; 	for(ll i=2;i<=limit;i++) 	{ 		if(p[i]==0) 		{   	p[i]=k++; 				for(ll j=i*i;j<=limit;j+=i) 				p[j]=-1; 		} 	} } void solve(int i,int j,int k)  {     if(i<n && i>=0 && j<n && j>=0) // checking for boundary conditions     {         if(arr[i][j]!=-1)          {             if(arr[i][j]%2==k && p[arr[i][j]]==-1) // checking for connected components             {                 arr[i][j]=-1;                 solve(i-1,j,k);                  solve(i+1,j,k);                 solve(i,j-1,k);                 solve(i,j+1,k);             }         }     } } int main() {       int t;     gen();     scanf("%d",&t);     while(t--)     {         result=0;         scanf("%d",&n);         FOR(i,n)         FOR(j,n)         scanf("%d",&arr[i][j]); //reading the grid         FOR(i,n)         {             FOR(j,n)             {                 if(arr[i][j]!=-1) // at first check whether the server is already cracked or not.                 {                     if(p[arr[i][j]]==-1)                      {                         if(arr[i][j]%2==0) //if the server is even-server.                         {                             result+=arr[i][j]/2;                             solve(i,j,0);                         }                         else //if the server is odd-server.                         {                             result+=2+arr[i][j]/2;                             solve(i,j,1);                         }                     }                     else  //if the server is prime-server.                     {                           result+=p[arr[i][j]]; // No need to check for the connected components if the element is prime.                         arr[i][j]=-1;                      }                 }             }         }         printf("%lld\n",result);     }     return 0; } 
#include <iostream> #include<stdio.h> #include<math.h> using namespace std;  int main() { 	int ts; 	long long n,ans,i; 	scanf("%d",&ts); 	while(ts--){ 		scanf("%lld",&n); 		ans=0; 		if(n==1) 		printf("1\n"); 		else{ 			 		for(i=1;i<=sqrt(n);i++){ 			if(n%i==0){ 			ans=ans+i; 			if(i!=sqrt(n))             ans+=n/i; 			} 			 		    		} 		printf("%lld\n",ans); 		} 	} 	return 0; }
#include<stdio.h> #include<string.h> #define MOD 1000000007   int main(){ 	int tests; 	long long int i,len=0,level=1,value=1; 	char str[100002]; 	scanf("%d",&tests); 	while(tests--){ 		scanf(" %s",str); 		len = strlen(str); 		for(i=0;i<len;++i){  			if((level&1)&&str[i] == 'l'){ // for odd level and character 'l' 				value = (value<<1) % MOD; 				++level; 			} 			else if((level&1)&&str[i] == 'r'){  // for odd level and character 'r' 				value = ((value<<1)%MOD + 2) % MOD; 				++level; 			} 			else if(!(level&1)&&str[i] == 'l'){ // even level and character 'l' 				value = ((value<<1)-1)%MOD; 				++level; 			} 			else{ // even level and character 'r' 				value = ((value<<1)%MOD + 1) % MOD; 				++level; 			} 		} 		value = value % MOD; 		printf("%lld\n",value); 		value=1;level=1; 	} 	return 0; } 
#include<bits/stdc++.h> #define MOD 1000000007 using namespace std;   long long cfib[44];   void gen() { 	cfib[0]=1; 	cfib[1]=2; 	for(long long i=2; i<44; i++) 	{ 		cfib[i]=cfib[i-1]+cfib[i-2]; 	} }   long long bsrc(long long x) { 	long long beg=0,end=43,mid=(beg+end)/2; 	while(beg<=end) 	{ 		if(cfib[mid]<x && cfib[mid+1]>=x) return mid+1; 		if(cfib[mid]<x) beg=mid+1; 		else end=mid-1; 		mid=(beg+end)/2; 	} 	return 0; }   long long bs(long long x, long long i) { 	long long beg=0,end=i,mid=(beg+end)/2; 	while(beg<=end) 	{ 		if(cfib[mid]==x) return 1; 		if(cfib[mid]<x) beg=mid+1; 		else end=mid-1; 		mid=(beg+end)/2; 	} 	return 0; }   long long dp(long long x, long long k, long long i) { 	//cout<<" enter "<<x<<" "<<k<<" "<<i<<endl; 	if(k==1) { 		//if(bs(x,i)) cout<<"   found"<<endl; 		return bs(x,i); 	} 	if(x==0 && k==0) { 		//cout<<"   found"<<endl; 		return 1; 	} 	if(cfib[i]*k<x) return 0; 	if(x<k) return 0; 	if(x<0 || k<0) return 0; 	if(x==0 || k==0) return 0; 	if(i==-1) return 0; 	 	long long q=0; 	for(long long j=1; j<=10; j++) 	{ 		if(cfib[i]*j>x) break; 		if(j>k) break; 		q+=dp(x-cfib[i]*j,k-j,i-1); 	} 	q+=dp(x,k,i-1); 	q%=MOD; 	return q; }  int main() { 	ios::sync_with_stdio(0); 	cin.tie(0); 	gen(); 	long long t,k,x,index; 	cin>>t; 	while(t--) 	{ 		cin>>x>>k; 		index=bsrc(x); 		cout<<dp(x,k,index)<<endl; 	} 	return 0; } 
#include <cstdlib> #include <iostream> #include <stdio.h> using namespace std;  /*  *   */ int main() {          int t;     scanf("%d",&t);     for(int i=0;i<t;i++)     {         long long int n,m;         scanf("%lld%lld",&n,&m);         if(n==1||m==1)         {             if(n==2||m==2)                 cout<<"Yes\n";             else                 cout<<"No\n";         }else         {             if(n%2==0||m%2==0)                 cout<<"Yes\n";             else                 cout<<"No\n";         }              }           return 0; } 
#include<bits/stdc++.h> using namespace std;  int main() {     int t,dish,minsum,num;     long long sum;     cin>>t;     while(t--)     {   sum=0,minsum=100000;         cin>>num;         while(num--)         {             scanf("%d",&dish);             sum+=dish;             minsum=min(minsum,dish);         }             if(minsum<2)             cout<<-1<<endl;         else     cout<<sum-minsum+2<<endl;         }     return 0; } 
#include <bits/stdc++.h> #define mod 1000000009 #define ll long long int #define pb(x) push_back(x) #define MP(x,y) make_pair(x,y) using namespace std;   ll power(ll a,ll b,ll m) {     if(b==0)         return(1);     ll sol=power(a,b/2,m);     sol=(sol*sol)%m;     if(b%2==1)         sol=(sol*a)%m;     return(sol); } void solve() {   int x,s=0;   ll k;   double sol=0;   cin>>x>>k;   while(1)   {     if(pow(2,s)>k)         break;     s++;   }         sol=double(x/pow(2,s))+double(x*(k-pow(2,s-1)))/pow(2,s-1);   printf("%.6lf\n",sol);   }   int main() {     int t;     cin>>t;     while(t--)     solve();     return 0; }
/**      Name: Shivam Mishra      handle: shivam217 **/ #include <iostream> #include <stdio.h> #include <algorithm> #include <stdlib.h> #include <math.h> #include <set> #include <assert.h> #include <cstring> #include <string> #include <string.h> #include <queue> #include <stack> #include <vector> #include <map> #include <time.h> #include <climits>  using namespace std;  #define FOR(i,a,b) for(int i=a;i<b;++i) #define FORR(i,a,b) for(int i=a;i>=b;--i) #define INT(x) scanf("%d",&x) #define LLD(x) scanf("%lld",&x) #define STR(x) scanf("%s",x) #define CHAR(x) scanf("%c",&x) #define PINT(x) printf("%d\n",x) #define PLLD(x) printf("%lld\n",x) #define CLR(x) memset(x,0,sizeof(x)); #define F first #define S second #define PB push_back  typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII; typedef map<int,int> MII; typedef vector<pair<int,int> > VPII; typedef vector<int> VI; typedef vector<char> VC; typedef vector<LL> VLL; typedef vector<VI> VVI; typedef vector<VLL> VVL; typedef set<int> SI; typedef set<char> SC;  #include <iostream> #include <iomanip> #include <vector> using namespace std;  const int INF = INT_MAX; const int MAX = 1005; const int MOD = 1e9 + 7;  int A[MAX]; int dp[2][MAX]; int main() {  int test; INT(test);  while(test--) {     int N,M,starting;     INT(N); INT(M); INT(starting);     FOR(i,1,M+1)         INT(A[i]);      CLR(dp);      FOR(i,1,N+1)     {         if(i==starting)             dp[0][i]=1;         else             dp[0][i]=0;     }      int rowParity = 1;      FOR(i,1,M+1)     {         int x = A[i];         FOR(j,1,N+1)         {                  if(j+x>=1 && j+x<=N)                  {                      LL temp = (LL)((LL)dp[rowParity][j+x] + (LL)dp[1-rowParity][j]);                      if(temp>=MOD)                         temp %= MOD;                        dp[rowParity][j+x] = temp;                  }                 if(j-x>=1 && j-x<=N)                  {                      LL temp = (LL)((LL)dp[rowParity][j-x] + (LL)dp[1-rowParity][j]);                      if(temp>=MOD)                         temp %= MOD;                        dp[rowParity][j-x] = temp;                  }                   dp[1-rowParity][j] = 0;         }         rowParity = 1- rowParity;     }      rowParity = 1-rowParity;      FOR(i,1,N+1)     {         if(i==N)             PINT(dp[rowParity][i]);         else             printf("%d ",dp[rowParity][i]);     } } return 0; }
#include<bits/stdc++.h> using namespace std;  int main()  {  	long long int ans,j,s,m,rem;  	cin>>j>>s>>m;  	rem=m-j;  	ans=rem/s;  	if(ans%2==0)  	cout<<"Lucky Chef"<<endl;  	else  	cout<<"Unlucky Chef"<<endl;  	 	   }
#include <cstdio>  #include <iostream>  #include <cmath>  #include <string>  #include <list>  #include <vector>  #include <algorithm>  #include <functional>  #include <utility>  #include <set>  #include <map>  #include <complex>  #include <queue>  #include <stack>  #include <cstdlib>  #include <ctime>  #include <cstring>  #include <string.h>  #include <cassert>   #define pb push_back const int maxn=1e5+7; using namespace std;   int l; bool ispalin(string& str){     int mid=l/2;     for(int j=0;j<mid;j++){         if(str[j]!=str[mid+j])             return false;     }     return true; } bool palin(string& str){     int mid=l/2;     if(l==1)         return false;     for(int w=0;w<2;w++)     {         int e=0,a=0,b=mid+w;         for(int i=0;i<mid;i++)             if (str[a]==str[b])                 a++,b++;             else             {                 ++e;                 if (e>1) break;                 if (w) a++;                 else b++;                 i--;             }         if (e<=1) return true;     }     return false; } int main(){     ios::sync_with_stdio(false);     int t;     cin>>t;     while(t--){         string str;         cin>>str;         l=str.length();         if (l%2==0){             //cerr<<"yy"<<endl;             if(ispalin(str))                 cout<<"YES"<<endl;             else                  cout<<"NO"<<endl;         }         else{             //cerr<<"yy"<<endl;             if(palin(str))                 cout<<"YES"<<endl;             else                 cout<<"NO"<<endl;         }       } }    
#include<bits/stdc++.h> using namespace std; typedef long long ll; struct node {     int y;     node *link; }; node *pos[1000005],*neg[1000005];  int check(int x,int y) {     if(x>1000000 || y>1000000 || x<-1000000 || y<-1000000)         return 0;     node *tmp;     if(x>=0 && pos[x])     {         tmp=pos[x];         while(tmp)         {             if(tmp->y==y)                 return 1;             tmp=tmp->link;         }         return 0;     }     else if(x<0 && neg[-1*x])     {         tmp=neg[-1*x];         while(tmp)         {             if(tmp->y==y)                 return 1;             tmp=tmp->link;         }         return 0;     }     return 0; }  int main() {     int n,i,j,x,y,x1,x2,y1,y2;     int points[2001][2];     for(i=0;i<=1000000;i++)     {         pos[i]=NULL;         neg[i]=NULL;     }     node *k,*mov;     scanf("%d",&n);     for(i=0;i<n;i++)     {         scanf("%d %d",&x,&y);         points[i][0]=x;         points[i][1]=y;         k=new node;         if(x>=0)         {             k->y=y;             k->link=NULL;             mov=pos[x];             if(mov)             {                 while(mov->link)                     mov=mov->link;                 mov->link=k;             }             else                 pos[x]=k;         }         else         {             x=-1*x;             k->y=y;             k->link=NULL;             mov=neg[x];             if(mov)             {                 while(mov->link)                     mov=mov->link;                 mov->link=k;             }             else                 neg[x]=k;         }     }         if(n==0)             printf("%d\n",4);         else if(n==1)             printf("%d\n",3);         else if(n==2)             printf("%d\n",2);         else         {             int mini=2,pts=2;             // taking AB and finding co-ordinates for C and D             for(i=0;i<n-1;i++)             {                 for(j=i+1;j<n;j++)                 {                     pts=2;                     x1=points[i][0];                     y1=points[i][1];                     x2=points[j][0];                     y2=points[j][1];                      /*rotating clockwise by 90*/                     if(check(x2-(y2-y1),y2+(x2-x1)))                         pts--;                     if(check(x1-(y2-y1),y1+(x2-x1)))                         pts--;                     if(pts<mini)                         mini=pts;                     pts=2;                      /*rotating anti-clockwise by 90*/                     if(check(x2+(y2-y1),y2-(x2-x1)))                         pts--;                     if(check(x1+(y2-y1),y1-(x2-x1)))                         pts--;                     if(pts<mini)                         mini=pts;                 }             }             printf("%d\n",mini);         }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         long long n,k;         cin>>n>>k;         long long *a=new long long[n];         long long *b=new long long[n];         for(int i=0;i<n;i++){             cin>>a[i];         }         for(int i=0;i<n;i++){             cin>>b[i];         }         long long profit=0;         for(int i=0;i<n;i++){             profit=max(profit,(k/a[i])*b[i]);         }         cout<<profit<<endl;     } }
#include<stdio.h> typedef unsigned long long ldef; ldef gcd(ldef a,ldef b) {ldef t=0; while(b>0) {t=a%b; a=b; b=t; }           return a;     } int main(){     int n=0;     ldef j=0,k=0,l=0,il=0,r=1;     scanf("%d",&n);     while(n--)     { scanf("%llu %llu",&j,&k);      if(k>j){      printf("0\n");        continue;      }        if(k>j-k)        k=j-k;        r=1;       for(il=1;il<=k;il++)       {l=gcd(r,il);        r=r/l;        r*=(j-il+1)/(il/l);        }        printf("%llu\n",r);              }     return 0; }
#include <iostream> #include <cstdio> #include <cmath> #include <vector> #include <algorithm> #include <utility> #include <map> #include <set> #include <string> #include <cstring> #include <queue> #define rf freopen("in.in", "r", stdin) #define wf freopen("out.out", "w", stdout) #define rep(i, s, n) for(int i=int(s); i<=int(n); ++i) using namespace std; const int mx = 1e5 + 10, mod = 1e9+7;  int n, k, m, t; int A[mx], B[mx], C[mx], D[mx]; multiset<int> buttons;  int main() { 	//rf;// wf; 	ios::sync_with_stdio(0);  	cin >> t; 	while(t--) 	{ 		buttons.clear(); 		cin >> n >> k >> m;  		for(int i = 1; i<=n; ++i) 			cin >> A[i];  		for(int i = 1; i <=n; ++i) 		{ 			cin >> B[i]; 			A[i] -= B[i]; 		}  		for(int i = 1; i<=k; ++i) 		{ 			cin >> C[i]; 			buttons.insert(C[i]); 		} 		for(int i = 1; i<=m; ++i) 		{ 			cin >> D[i]; 			buttons.insert(D[i]); 		}  		multiset<int>::iterator it; 		long long ans = 0;  		sort(A+1, A+n+1);  		for(int i = 1; i<=n; ++i) 		{ 			if(buttons.empty() or *buttons.begin() > A[i]) 				ans += A[i]; 			else 			{ 				it = buttons.upper_bound(A[i]); 				it--;  				ans += A[i] - *it; 				buttons.erase(it); 			} 		}  		cout << ans << '\n'; 	} 	return 0; }
#include<iostream> #include<cstdio> #include<deque> using namespace std; int main(){     //while(true){    int n,w,temp;    int ans=0,current,curMax,curMin;    deque<int> maxx,minn;    scanf("%d%d",&n,&w);    int arr[n];    for(int i=0;i<w;i++){       scanf("%d",&arr[i]);       current=arr[i];       while(!maxx.empty() && arr[maxx.back()]<=current)  maxx.pop_back();       maxx.push_back(i);       while(!minn.empty() && arr[minn.back()]>=current)  minn.pop_back();       minn.push_back(i);       //printf("%d %d")    }   // printf("%d %d %d %d\n",maxx.front(),maxx.back(),minn.front(),minn.back());    curMax=arr[maxx.front()];    curMin=arr[minn.front()];    if((curMax-curMin+1)==w) ans++;    for(int i=w;i<n;i++){     scanf("%d",&arr[i]);       current=arr[i];       if(maxx.front()<=i-w) maxx.pop_front();       if(minn.front()<=i-w) minn.pop_front();       while(!maxx.empty() && arr[maxx.back()]<=current) maxx.pop_back();        maxx.push_back(i);        while(!minn.empty() && arr[minn.back()]>=current) minn.pop_back();       minn.push_back(i);        curMax=arr[maxx.front()];       curMin=arr[minn.front()];       if((curMax-curMin+1)==w)ans++;    }    printf("%d",ans);     //}    return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t,c=0,temp=0;     cin>>t;     for(int i=0;i<t;i++)     {         int x;         cin>>x;         if(x>0)         {             c++;             if(temp<c)                 temp=c;         }         else{             if(temp<c)                 temp=c;             c=0;         }      }     cout<<temp; } 
#include <iostream> using namespace std; int gcd(int a, int b); int main() {         int t,a,b,a1,b1;    cin>>t;    while(t--)    {        cin>>a>>b;       if(a>0)a1=a;       else a1=(-1)*a;       if(b>0)b1=b;       else b1=(-1)*b;               {if(a>b)cout<<(a-b)/gcd(a1,b1)<<endl;        else cout<<(b-a)/gcd(a1,b1)<<endl;}                   } 	return 0; } int gcd(int a,int b) {     if(a>b)return gcd(a-b,b);     else if(a<b)return gcd(a,b-a);     else return b; }
#include<bits/stdc++.h> using namespace std;  double f[1005][1005][2]; long long selling[1005][1005],buying[1005][1005];  int main() { 	long long n,m,d; 	cin>>n>>m>>d;  	for(int i=1; i<=n; i++){ 		for(int j=0; j<m; j++){ 			cin>>selling[j][i]>>buying[j][i]; 		} 	}  	for(int i=1; i<=n; i++){ 		f[0][i][0]=d; 		f[0][i][1]=0; 	}      int dem=0; 	for(int i=1; i<=m; i++){ 		for(int j=1; j<=n; j++){ 			f[i][j][0]=f[i-1][j][0]; 			f[i][j][1]=f[i-1][j][1];  				if(i+1<n){ 					f[i][j][0]=max(f[i][j][0],f[i-1][j+1][0]); 					f[i][j][1]=max(f[i][j][1],f[i-1][j+1][1]);  					f[i][j][0]=max(f[i][j][0],f[i-1][j][1]*buying[i-1][j] ); 					f[i][j][1]=max(f[i][j][1],f[i-1][j][0]/selling[i-1][j]); 				}  				if(i-1>=0){ 					f[i][j][0]=max(f[i][j][0],f[i-1][j-1][0]); 					f[i][j][1]=max(f[i][j][1],f[i-1][j-1][1]);  					f[i][j][0]=max(f[i][j][0],f[i-1][j][1]*buying[i-1][j]); 					f[i][j][1]=max(f[i][j][1],f[i-1][j][0]/selling[i-1][j]); 				}  				if(f[i][j][0]>=1e18)  dem=1;         } 	}      if(dem==1)   printf("Quintillionnaire\n"); 	else{ 		double best=0; 		for(int i=1; i<=n; i++){ 			if(f[m][i][0]>best)  best=f[m][i][0]; 		} 	 		printf("%.12lf\n",best); 	} }   
#include <algorithm> #include <stdio.h> #define  maxn	   100002 using	 namespace std; typedef  long long LL;  int T,n,m; int l,r,mod; int ar[maxn]; int cnt[maxn][25]; int pr[25] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };  int f( int x , int y ) { 	if( y == 0 ) 		return 1; 	if( y == 1 ) 		return x; 	int val = f( x , y / 2 ); 	LL val2 = ( (LL)val * (LL)val ) % (LL)mod; 	if( y & 1 ) 		return (int)( ( val2 * (LL)x ) % (LL)mod ); 	return (int)val2; }  int main() { 	 	scanf( "%d" , &n ); 	for( int i = 1 ; i <= n ; i++ ) 		scanf( "%d" , &ar[i] ); 	 	for( int i = 1 ; i <= n ; i++ ) { 		for( int j = 0 ; j < 25 ; j++ ) 			cnt[i][j] = cnt[i - 1][j]; 		for( int j = 0 ; j < 25 ; j++ ) 			while( ar[i] % pr[j] == 0 ) { 				cnt[i][j]++; 				ar[i] /= pr[j]; 			} 	} 	 	scanf( "%d" , &m ); 	for( int t = 1 ; t <= m ; t++ ) { 		int ans = 1; 		scanf( "%d%d%d" , &l , &r , &mod ); 		for( int i = 0 ; i < 25 ; i++ ) 			ans = (int)( ( (LL)ans * (LL)f( pr[i] , cnt[r][i] - cnt[l-1][i] ) ) % (LL)mod ); 		printf( "%d\n" , ans ); 	} 	 }
     #include<stdio.h>     #include<string.h>           char arr[150010];     void quicksrt(int *arr,int start ,int end)     {     int i, j,key;     key = arr[(start + end)/2];     /* int temp2 = arr[key];       arr[key] = arr[end];       arr[end] = temp2;*/     i = start;     j = end;     do     {     while( arr[i] < key )     i++;     while(arr[j] > key)     j--;     //swap the two pos     if(i<=j){     int temp = arr[i];     arr[i] = arr[j];     arr[j] = temp;     i++;     j--;     }     }while(i<=j);     //swap ith and last element     /* int temp = arr[i];       arr[i] = arr[end];       arr[end] = temp; */     //calling func again     if(start < j)     quicksrt(arr,start,j);     if(i<end)     quicksrt(arr,i,end);     }           int main()     {     int t;     scanf("%d",&t);     getchar();     char arr1[27];     while(t--)     {     gets(arr1);     gets(arr);     //scanf("%s",&arr1);     //scanf("%s",&arr);     long int len;     len = strlen(arr);     long int i;     int hash[26] = {0};     for(i=0;i<len;i++)     {     if(arr[i] >= 'a' && arr[i]<='z')     {     hash[arr[i]-97]++;     }     if(arr[i] >='A' && arr[i] <= 'Z')     {     hash[arr[i] - 65]++;     }     }     int j,k;     int resulthash[26];     for(j=0;j<26;j++)     resulthash[j] = hash[j];     quicksrt(resulthash,0,25);     int mainhash[26] = {0};     for(j=0;j<26;j++)     {     if(hash[j]!=0)     {     int tempp = 0;     for(k=0;k<26;k++)     {     if(resulthash[k]!=0)     tempp++;     if(resulthash[k] == hash[j])     break;     }     mainhash[j] = tempp;     resulthash[k] = -1;     }     }     int lennn = 0;     for(j=0;j<26;j++)     if(mainhash[j]!=0)     lennn++;     for(i=0;i<len;i++)     {     if(arr[i] >='a' &&arr[i] <='z')     {     // printf("%d\n",mainhash[arr[i]-97]);     printf("%c",arr1[25+mainhash[arr[i]-97] - lennn] );     }     else	if(arr[i] >='A' && arr[i] <='Z')     {     printf("%c",arr1[25+mainhash[arr[i]-65]-lennn] - 32);     }     else     printf("%c",arr[i]);     }     printf("\n");     }     return 0;     } 
#include <bits/stdc++.h>  using namespace std;  #define s(x) scanf("%d", &x) #define sd(x) scanf("%lf", &x)  double x[100011]; double y[100011];  int main() {     int t, n, j, i, m;     double ans;     s(t);     while (t--) {         s(n);         vector < pair <double, int> > v(n);         for (i = 0; i < n; i++) {             s(m);             for (j = 0; j < m; j++) {                 sd(x[j]);                 sd(y[j]);             }             x[j] = x[0];             y[j] = y[0];             ans = 0;             for (j = 0; j < m; j++)                 ans += (x[j]*y[j+1]-x[j+1]*y[j]);             ans = abs(ans/2.0);             v[i] = make_pair(ans, i);         }         sort(v.rbegin(), v.rend());         int a[n];         for (i = 0; i < n; i++)             a[v[i].second] = n-1-i;         for (i = 0; i < n-1; i++)             printf("%d ", a[i]);         printf("%d\n", a[i]);     }     return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin >> t;     while(t--){         int N, M, K;         scanf("%d%d%d", &N, &M, &K);         if(N > M) {             int temp = N;             N = M;             M = temp;         }         int ans = 0;         if(N == 1){             if(M <= 2){                 ans = 0;             } else ans = K;         }         else ans = (K + 1)/2;         printf("%d\n", ans);     }     return 0; } 
#include <bits/stdc++.h> #define ll long long int #define MAX 100001 #define EPS 1e-9 #define MOD 1000000007 #define INF 1e9 #define pn() printf("\n") #define vint vector <int> #define vpint vector <pair<int,int> > #define pb push_back #define mp make_pair #define ft first #define sd second #define gc() getchar_unlocked() #define ms(x,v) memset(x,v,sizeof x) #define pr_arr(i,x,size) for(i=0;i<size;i++) cout<<x[i]<<" " #define ff(i,a,b) for(i=a;i<=b;i++) #define fb(i,a,b) for(i=a;i>=b;i--) #define gprint(i) cout<<"Case #"<<i<<": " using namespace std;  template<class T> void scanint(T &x) {     register T c = gc();     x = 0;     T neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  template<class T> T modulus(T x,int m=MOD) {     return (((x%m)+m)%m); }  inline bool lt(double a, double b) {     return a + EPS < b; } inline bool gt(double a, double b) {     return a > b + EPS; } inline bool eq(double a, double b) {     return fabs(a - b) < EPS; }  ll power(ll base,ll p) {     ll temp=1;     while(p>1)     {         if(p%2!=0)             temp=(1LL*(base*temp)%MOD);         base=(1LL*(base*base)%MOD);         p/=2;     }     ll ans=(1LL*(base*temp)%MOD);     return ans; }  int main() {     ios::sync_with_stdio(false);     int t;     cin>>t;     while(t--)     {     	int n,m,i,j;     	cin>>n>>m;     	int conn[n];     	ff(i,0,n-1)     	{     		conn[i]=(1 << i);     	}     	ff(i,1,m)     	{     		int u,v;     		cin>>u>>v;     		u--;     		v--;     		conn[u]|=(1<<v);     		conn[v]|=(1<<u);     	}     	int mini=n;     	ff(i,1,(1<<n)-1)     	{     		int ans=0,count=0;     		ff(j,0,n-1)     		{     			if(i & (1<<j))     			{     				ans|=conn[j];     				count++;     			}     		}     		if(ans==(1<<n)-1)     			mini=min(mini,count);     	}     	cout<<mini<<endl;     }     return 0; }
#include <bits/stdc++.h> using namespace std; typedef long long lld; const int N = 200000 + 1; const int M = 50000 + 1;  vector<pair<int, int> > offers[M]; int sc[M], bp[M], p[M], bst[M];  void initialize() {     for (int i = 0; i < M; i++) {         offers[i].clear();         bp[i] = i;         sc[i] = 0;     } }  int parent(int x) {     if (p[x] == x) return x;     else return p[x] = parent(p[x]); }  void join(int x, int y) {     int py = parent(y);     int px = parent(x);     bst[py] = max(bst[py], bst[px]);     p[px] = py; }  int main() {     ios_base::sync_with_stdio(false);     int tc;     cin>>tc;     while (tc--) {         initialize();         int n, m;         cin>>n>>m;         for (int i = 0; i < n; i++) {             int x;             cin>>x;             sc[x]++;         }         for (int i = 0; i < m; i++) {             int t, x, y;             cin>>t>>x>>y;             offers[t].push_back(make_pair(x, y));         }         for (int i = M - 1; i >= 1; i--) {             for (int j = 0; j < offers[i].size(); j++) {                 int x = offers[i][j].first;                 int y = offers[i][j].second;                 p[x] = x;                 p[y] = y;                 bst[x] = bp[x];                 bst[y] = bp[y];             }             for (int j = 0; j < offers[i].size(); j++) {                 int x = offers[i][j].first;                 int y = offers[i][j].second;                 if (parent(x) != parent(y)) {                     join(x, y);                 }             }             for (int j = 0; j < offers[i].size(); j++) {                 int x = offers[i][j].first;                 int y = offers[i][j].second;                 bp[x] = bst[parent(x)];                 bp[y] = bst[parent(y)];             }         }         lld ans = 0;         for (int i = 1; i < M; i++) {             ans += sc[i] * bp[i];         }         cout << ans << '\n';     } }
#include <bits/stdc++.h> using namespace std;   #define MAX 5010 int Count[MAX], output[MAX]; struct suffixArray { #define MAX_lg 20 #define minchar 'a' #define Index(a) (((a) < len) ? index[mlgn][a] : -1)     int pos[MAX], index[MAX_lg][MAX], lcp[MAX], len, mlgn;      suffixArray() {}     suffixArray(const char *S)     {         create(S);     }     void CountSort(int add)     {         int to = max(len, 26);         memset(Count, 0, sizeof(Count));         for(int i = 0; i < len; i++) ++Count[ Index(pos[i] + add) + 1 ];         for(int i = 1; i <= to; i++) Count[i] += Count[i-1];         for(int i = len-1; i >= 0; i--) output[ --Count[ Index(pos[i] + add) + 1 ] ] = pos[i];         for(int i = 0; i < len; i++) pos[i] = output[i];     }     int Lcp(int x, int y)     {         int ret = 0;         for(int i = mlgn; i >= 0 && x < len && y < len; i--) if(index[i][x] == index[i][y])                 x += (1 << i),                      y += (1 << i),                           ret += (1 << i);         return ret;     }     void create(const char *S)     {         len = strlen(S), mlgn = 0;         for(int i = 0; i < len; i++) index[0][i] = S[i] - minchar;         for(int done = 1; done < len; done <<= 1)         {             for(int i = 0; i < len; i++) pos[i] = i;             CountSort(done);             CountSort(0);             for(int i = 0; i < len; i++)             {                 int sc1 = (i > 0) ? Index(pos[i-1] + done) : -1;                 int sc2 = Index(pos[i] + done);                 index[mlgn+1][pos[i]] = (i > 0 && index[mlgn][pos[i]] == index[mlgn][pos[i-1]] && sc1 == sc2) ? index[mlgn+1][pos[i-1]] : i;             }             mlgn++;         }         lcp[0] = 0;         for(int i = 1; i < len; i++) lcp[i] = Lcp(pos[i], pos[i-1]);     } };  char str[5005];  #define MOD 1000000007 #define si(a) scanf("%d",&a)  int mod_plus(int a,int b) {     return (a+b)%MOD; }  int mod_mul(long long a,long long b) {     return (a*b)%MOD; }  int NCR[5005][5005];  int ncr(int n,int r) {     if(n==r || r==0) return 1;     if(NCR[n][r]!=-1)return NCR[n][r];     return NCR[n][r]=mod_plus(ncr(n-1,r),ncr(n-1,r-1)); }  int cnt[5005],ans[5005];  void solve(int ca) {     int n,q,i,j;     si(n);si(q);     scanf("%s",str);     suffixArray ob(str);     memset(cnt,0,sizeof(cnt));     memset(ans,-1,sizeof(ans));     ans[1]=(n*(n+1))/2;     for(i=1;i<=n;i++){         for(j=1;j<n;j++){             if(ob.lcp[j]<i)                 continue;             int k=j;             while(k<n && ob.lcp[k]>=i)k++;             cnt[k-j+1]++;             j=k-1;         }     }     for(i=0;i<q;i++){         int x;         si(x);         if(x>n){             printf("0\n");             continue;         }         if(ans[x]!=-1){             printf("%d\n",ans[x]);             continue;         }         ans[x]=0;         for(j=x;j<=n;j++)             ans[x]=mod_plus(ans[x],mod_mul(cnt[j],ncr(j,x)));         printf("%d\n",ans[x]);     }     return ; }  int main() {     //freopen("input.txt","r",stdin);     memset(NCR,-1,sizeof(NCR));     int t;     si(t);     for(int ca=1;ca<=t;ca++)         solve(ca);     return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; typedef long long LL; LL ways[MAXN]; int main(){ 	string s; 	cin >> s; 	int N = s.size(); 	s = "@" + s; 	ways[0] = 0; 	LL ans = 0; 	for(int i = 1;i <= N;++i){ 		ways[i] = ways[i - 1]; 		if(s[i] > '0') 			ways[i] += 1; 		int num = s[i] - '0'; 		if(num % 8 == 0) ++ans; 		if(i - 1 > 0){ 			num = (s[i - 1] - '0') * 10 + num; 			if(num % 8 == 0 && s[i - 1] != '0') ++ans; 		} 		if(i - 2 > 0){ 			num = (s[i - 2] - '0') * 100 + num; 			if(num % 8 == 0) { 				if(s[i - 2] != '0') 					++ans; 				ans += ways[i - 3]; 			} 		} 		//cout << i << " " << ans << " " << ways[i] << "\n"; 	} 	cout << ans << "\n";   	return 0; }
#include<iostream> using namespace std; int main() { 	int a,b,c,x; 	cin>>a>>b; 	c=a-b; 	if(c%10==9) 		x=c-1; 	else 		x=c+1; 	cout<<x; 	return 0; } 
#include<iostream> #include<cmath> using namespace std;  int main() {  int t; cin>>t;  int i, j, k;  while (t--) {     cin>>i>>j>>k;     if (k > i+j) cout<<k - i - j<<endl;     else if (i > k + j) cout<<i - j - k<<endl;     else if (j > i + k) cout<<j - i - k<<endl;     else cout<<0<<endl;  } return 0; }
#ifdef _WIN32 #  define LL "%I64d" #else #  define LL "%ll" #endif  #include <iostream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cstring> #include <ctime> #include <vector> #include <deque> #include <set> #include <map> #include <queue> #include <stack> #include <bitset> #include <string> #include <algorithm> #include <complex> using namespace std; #define null NULL #define mp make_pair #define pb(a) push_back(a) #define sz(a) ((int)(a).size()) #define all(a) a.begin() , a.end() #define fi first #define se second #define relaxMin(a , b) (a) = min((a),(b)) #define relaxMax(a , b) (a) = max((a),(b)) #define SQR(a) ((a)*(a)) typedef vector<int> vi; typedef pair<int,int> pii; typedef long long ll; int vp(pii mid , pii a,pii b){   int x1=a.fi-mid.fi,y1=a.se-mid.se,x2=b.fi-mid.fi,y2=b.se-mid.se;   return x1*y2-x2*y1; } int dist(pii f,pii s){return SQR(f.fi-s.fi) + SQR(f.se-s.se);} int sgn(int w){return w>0?1:(w<0?-1:0);} int n; pii in[1010]; void doit(){   scanf("%d",&n);   for(int i=0;i<n;++i)scanf("%d%d",&in[i].fi , &in[i].se);   bool check = (n>4)?false:true;   int bst=0;   for(int i=0;i<n;++i)    for(int j=i+1;j<n;++j){     int cur=dist(in[i] , in[j]);     if(check){      vector<pii> tmp;      for(int p=0;p<n;++p)       if(p!=i && p!=j)tmp.pb(in[p]);      if(sz(tmp)>1){       if( sgn(vp(in[i] , in[j] , tmp[0]))*sgn(vp(in[i] , in[j] , tmp[1])) > 0 ||           sgn(vp(tmp[0] , tmp[1] , in[i]))*sgn(vp(tmp[0] , tmp[1] , in[j])) > 0)         relaxMax(bst , cur);                   }              }     else relaxMax(bst , cur);                          }   printf("%.10lf\n" , sqrt(bst)); } int main(){   int Q; scanf("%d",&Q);   while(Q--)doit();   return 0; } 
/* CPP Tempelate  * @author Devashish Tyagi  */  #include <algorithm> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #include <list>  #define s(a) scanf("%d",&a) #define ss(a,b) scanf("%d %d",&a,&b) #define p(a) printf("%d\n",a) #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define pi pair<int,int> #define vi vector<int>  #define PB push_back #define MP make_pair #define sz(a) (int)(a).size()  #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))   #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))   #define CLEAR(a) memset((a),0,sizeof(a))  #define INF 100000000 #define PI 2*acos(0.0)  using namespace std; typedef long long int LL;  string convertInt(int number) {    stringstream ss;//create a stringstream    ss << number;//add number to the stream    return ss.str();//return a string with the contents of the stream }  bool check(string & num){     int count8=0,count5=0,count3=0;     for(int i=0; i<num.size(); i++){         if (num.at(i) == '8')             count8++;         else if (num.at(i) == '5')             count5++;         else if (num.at(i) == '3')             count3++;         else             return false;     }     if (count8 >= count5 && count5 >= count3)         return true;     else         return false; }  int main(void){     int count = 0;     vector<short> placeholder(16,0);     while(count < 50000){         int i=0;         placeholder[i]++;         while(placeholder[i] == 4){             placeholder[i] = 1;             i++;             placeholder[i]++;         }         string num;         for(int i=15; i>=0; i--){             if (placeholder[i] == 1)                 num.push_back('3');             else if (placeholder[i] == 2)                 num.push_back('5');             else if (placeholder[i] == 3)                 num.push_back('8');         }         if (check(num)){             count++;             printf("%s\n",num.c_str());         }     } }   
#include <iostream> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> using namespace std;  bool is_ciel(int N) {     int Arr[11];     int dig;      memset(Arr,0,sizeof(Arr));      while(N)     {         dig=N%10;         if(dig!=8 && dig!=5 && dig!=3){return false;}         Arr[dig]++;          N=N/10;     }      if(Arr[3]<=Arr[5] && Arr[5]<=Arr[8])     {         return true;     }     else     {         return false;     } }  int main() {     int N;     char buf[1000];      int res=0;      gets(buf);     N=atoi(buf);      while(N--)     {         gets(buf);          int len=strlen(buf);          int i=0;         for(i=len-1;;i--){if(buf[i]==' '){break;}}          int price=atoi(buf+i+1);          if(is_ciel(price)){res++;}     }      printf("%d\n",res);     return 0; } 
#include<bits/stdc++.h> using namespace std; const int INF = 1e8; typedef long long LL; int dis[20][20]; int org[20][20]; LL ways[20][20]; int main(){ 	int t; 	cin >> t; 	while(t--){ 		int N, M; 		scanf("%d%d", &N, &M); 		for(int i =1;i <= N;++i){ 			for(int j = 1;j <= N;++j){ 				dis[i][j] = INF; 				ways[i][j] = 0; 				org[i][j] = INF; 			} 			ways[i][i] = 0; 			dis[i][i] = 0; 			org[i][i] = 0; 		} 		while(M--){ 			int A, B, C; 			scanf("%d%d%d", &A, &B, &C); 			dis[A][B] = C; 			dis[B][A] = C; 			org[A][B] = C; 			org[B][A] = C; 		} 		for(int k = 1;k <= N;++k){ 			for(int i = 1;i <= N;++i){ 				for(int j = 1;j <= N;++j){ 					dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); 				} 			} 		} 		for(int i = 1;i <= N;++i){ 			for(int j = 1;j <= N;++j){ 				if(org[i][j] != INF && org[i][j] == dis[i][j]) 					ways[i][j] = 1; 			} 		} 		for(int k = 1;k <= N;++k){ 			for(int i = 1;i <= N;++i){ 				for(int j = 1;j <= N;++j){ 					if(i != k && j != k && dis[i][j] == dis[i][k] + dis[k][j]){ 						ways[i][j] += ways[i][k] * ways[k][j]; 					} 				} 			} 		} 		printf("%lld\n", ways[1][N]); 	} 	return 0; }
#define DEBUG 0   #include <stdio.h>   double eval(double p, int a[101][3], int i) {   double in1, in2;   if(DEBUG)     printf("eval i=%d\n", i);   if(a[i][0]==0)     return p;   else if(a[i][0]==2) //AND     return (eval(p, a, a[i][1])*eval(p, a, a[i][2]));   else { //OR     in1=eval(p, a, a[i][1]);     in2=eval(p, a, a[i][2]);     return (in1*in2+in1*(1-in2)+(1-in1)*in2);   } }   int main(void) {   int tc, n, a[101][3], i, done;   double high, low, mid, r;     scanf("%d", &tc);   while(tc--) {     scanf("%d", &n);     for(i=1;i<=n;i++) {       scanf("%d", &a[i][0]);       if(a[i][0])         scanf("%d%d", &a[i][1], &a[i][2]);     }     high=1.0,low=0.0,mid=0.5,done=0;     while(!done) {       r=eval(mid, a, n);       if(DEBUG)         printf("low=%lf mid=%lf high=%lf r=%lf\n", low, mid, high, r);       if(r==0.5)         done=1;       else {         if(r<0.5)           low=mid;         else           high=mid;         mid=(low+high)/2.0;         if(high-low<0.0000001)           done=1;       }     }     printf("%.5lf\n", mid);   }   return 0; }
 //Includes #include <vector>  #include <queue> #include <map>  #include <set> #include <utility> //Pair #include <algorithm> #include <sstream> // istringstream>> ostring stream<< #include <iostream>  #include <iomanip>  //setbase - cout << setbase (16); cout << 100 << endl; Prints 64 //setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77 //setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <limits> using namespace std;   //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end()  #define ESP (1e-9)   #define gi(n) scanf("%d",&n) #define gd(n) scanf("%lf",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define INF double(imax) #define EPS 10e-8 typedef pair< double, double> pdd; int x[40],y[40]; pdd getcenter(pdd a,pdd b,pdd c) { 	//pdd -> pair <double , double> 	//Given 3 points as input returns center of circle formed by 3 on circumfrence  	// printf("%lf %lf | %lf %lf | %lf %lf\n",a.ff,a.ss,b.ff,b.ss,c.ff,c.ss); 	double a1 = b.ss-a.ss , b1 = a.ff-b.ff ,c1; 	double a2 = c.ss-b.ss , b2 = b.ff-c.ff ; 	// printf("%lf %lf %lf %lf\n",a1,b1,a2,b2); 	double mx = (a.ff+b.ff)*.5 ,my = (a.ss+b.ss)*.5; 	double d1 = a1*my-b1*mx; 	mx= (b.ff+c.ff)*.5; my = (b.ss+c.ss)*.5; 	double d2 = a2*my-b2*mx; 	c1=a1; a1=-b1; b1=c1;  	c1=a2; a2=-b2; b2=c1; 	// printf("%lf %lf %lf %lf\n",a1,b1,a2,b2); 	double det = a1*b2 - b1*a2; 	if(det==0) return mp(INF,INF); 	// b2 -b1 | c1 	// -a2 a1 | c2 	double x1=b2*d1-b1*d2,y1=a1*d2-a2*d1; 	return mp(x1/det,y1/det); }   double getdist(pdd a, pdd b) { 	return (double)(a.ff-b.ff)*(a.ff-b.ff) + (a.ss-b.ss)*(a.ss-b.ss); }   int main() { 	int t,n; 	gi(t); 	while(t--) { 		gi(n); 		rep(i,n) { gi(x[i]); gi(y[i]); } 		int num=0,den=0; 		fu(i,0,n-1) fu(j,i+1,n-1) fu(k,j+1,n-1) { 			pdd center = getcenter( mp(x[i],y[i]), mp(x[j],y[j]), mp(x[k],y[k]) ); 			double radius = getdist( mp(x[i],y[i]), center); 			int valid = center.ff > INF-10 && center.ss > INF-10; 			if(x[i]==x[j] && y[i]==y[j]) valid=1; 			if(x[j]==x[k] && y[j]==y[k]) valid=1; 			if(x[i]==x[k] && y[i]==y[k]) valid=1; 			// printf("%d %d %d %lf %lf %lf %d\n",i,j,k,center.ff,center.ss,radius,valid); 			rep(l,n) if(l!=i && l!=j && l!=k) { 				den++; 				if(valid) continue; 				if( getdist(mp(x[l], y[l]), center) > radius+EPS) continue; 				num++; 			} 		} 		// pi(num); ps; pi(den); pn; 		printf("%.10lf\n",double(num)/den); 	} 	return 0; }   
#include<stdio.h> #include<assert.h>  #define ll long long #define M 1000000007  ll pw(ll a, ll b){   ll r;   if(b==0) return 1;   r = pw(a,b/2);   r = (r*r)%M;   if(b%2) r = (r*a)%M;   return r; }  int main(){   int T, N;   ll n1, n2, res;    assert( scanf("%d",&T)==1 );   assert( 0<=T && T<=1000 );   while(T--){     assert( scanf("%d",&N)==1 );     assert( 1<=N && N<=1000000000 );      N++;     n1 = N/2; n2 = N - n1;     res = pw(2,n1) + pw(2,n2) - 2;      printf("%d\n",(int)(res%M));   }    return 0; }
#include<iostream> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,m,x; 		cin>>n>>m; 		int a[n],b[n-m]; 		for(int i=0;i<n;i++) 			a[i]=0; 		for(int i=0;i<m;i++) 		{ 			cin>>x; 			a[x-1]=1; 		} 		for(int i=0,j=0;i<n;i++) 		{ 			if(a[i] == 0) 			{ 				b[j] = i + 1; 				j++; 			} 		} 		for(int i=0;i<n-m;i+=2) 			cout<<b[i]<<" "; 		cout<<endl; 		for(int i=1;i<n-m;i+=2) 			cout<<b[i]<<" "; 		cout<<endl; 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int orders[500]; vector<vector<int> > lst(500); bool occ[500]; int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		int N, M; 		scanf("%d%d", &N, &M); 		for(int i = 1;i <= M;++i){ 			scanf("%d", &orders[i]); 		} 		for(int i = M;i >= 1;--i){ 			lst[orders[i]].push_back(i); 		} 		memset(occ, 0, sizeof occ); 		int cus = 0; 		int ans = 0; 		for(int i = 1;i <= M;++i){ 			if(!occ[orders[i]]){ 				if(cus < N){ 					++cus; 					++ans; 				} else{ 					int maxVal = 0; 					int maxId = 0; 					for(int j = 1;j <= 400;++j){ 						if(occ[j]){ 							if(lst[j].empty()){ 								maxId = j; 								break; 							} else if(lst[j][lst[j].size() - 1] > maxVal){ 								maxVal = lst[j][lst[j].size() - 1]; 								maxId = j; 							} 						} 					} 					occ[maxId] = false; 					++ans; 				} 				occ[orders[i]] = true; 			} 			lst[orders[i]].pop_back(); 		} 		printf("%d\n", ans); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; typedef long long LL; const LL MOD = 1e9 + 7; LL fib[MAXN]; int main(){     fib[0] = 1;     fib[1] = 1;     for(int i = 2;i < MAXN;++i){         fib[i] = fib[i - 1] + fib[i - 2];         while(fib[i] >= MOD)  fib[i] -= MOD;     }     for(int i = 1;i < MAXN;++i){         fib[i] = __builtin_popcountll(fib[i]);     }     int t;     cin >> t;     while(t--){         int N, G;         scanf("%d%d", &N, &G);         if(fib[N] == G){             printf("CORRECT\n");         } else {             printf("INCORRECT\n");         }     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  bool cmp(pair<int, int> a, pair<int, int> b){ 	return (a.second - a.first < b.second - b.first); } char ans[3000]; int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		int N, K; 		scanf("%d%d", &N, &K); 		set<pair<int, int> > ss; 		for(int i = 1;i <= K;++i){ 			int x, y; 			scanf("%d%d", &x, &y); 			ss.insert(make_pair(x, y)); 		} 		while(true){ 			pair<int, int> a; 			pair<int, int> b; 			pair<int, int> c; 			bool found = false; 			for(set<pair<int, int> >:: iterator it1 = ss.begin();it1 != ss.end() && (!found);++it1){ 				set<pair<int ,int> > :: iterator it2 = ss.upper_bound(make_pair(it1->first + 1, -1)); 				for(;it2 != ss.end();++it2){ 					if(it2 -> first >= it1 -> second){ 						break; 					} 					if(it2 -> second > it1 -> second){ 						a = make_pair(it1 -> first, it2 -> first - 1); 						b = make_pair(it2 -> first, it1 -> second); 						c = make_pair(it1 -> second + 1, it2 -> second); 						found = true; 						ss.erase(it1); 						ss.erase(it2); 						break; 					} 				} 			} 			if(!found) break; 			ss.insert(a); 			ss.insert(b); 			ss.insert(c); 		} 		vector<pair<int, int> > B; 		for(set<pair<int, int> >:: iterator it = ss.begin();it != ss.end();++it){ 			B.push_back(*it); 		} 		sort(B.begin(), B.end(), cmp); 		int M = B.size(); 		for(int i = 0;i < N;++i) ans[i] = '-'; 		ans[N] = '\0'; 		for(int i = 0;i < M;++i){ 			int x = B[i].first; 			int y = B[i].second; 			int cnt = 0; 			for(int j = x;j <= y;++j){ 				if(ans[j] == '-') ++cnt; 			} 			int cur = 0; 			for(int j = x;j <= y;++j){ 				if(ans[j] == '-'){ 					if(cur < cnt/2) 						ans[j] = '('; 					else ans[j] = ')'; 					++cur; 				} 			} 		} 		for(int i = 0;i < N;++i){ 			if(ans[i] == '-'){ 				ans[i] = ')'; 			} 		} 		printf("%s\n", ans); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; long long arr[100005]; long long sum[100005]; long long n; long long k; int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int i,j; 		sum[0]=0; 		scanf("%lld %lld",&n,&k); 		for(i=1;i<=k;i++) 		{ 			scanf("%lld",&arr[i]); 		} 		int co=0; 		long long answ,tt; 		sort(arr+1,arr+k+1); 		for(i=1;i<=k;i++) 		sum[i]=sum[i-1]+arr[i]; 		for(i=1;i<=k;i++) 		{ 			tt=(arr[i]*(arr[i]+1))/2; 			tt-=sum[i]; 			if(arr[i]<=tt) 			{ 				 			} 			else 			{ 				co=1; 				answ=tt; 				break; 			} 		} 		if(co==1) 		{ 			 		} 		else 		{ 			tt=(n*(n+1))/2; 			tt-=sum[k]; 		} 		if(tt%2==0) 		printf("Chef\n"); 		else 		printf("Mom\n"); 	} 	return 0; }
#include <bits/stdc++.h> #define ll long long int using namespace std;  int main() {     ll x,y,k,n,t,i,p,c,s;     scanf("%lld",&t);     while(t--)     {         scanf("%lld%lld%lld%lld",&x,&y,&k,&n);         x=x-y;         s=0;         for(i=0;i<n;i++)         {             scanf("%lld%lld",&p,&c);             if(p>=x && c<=k)                 s=1;         }         if(s==1)             printf("LuckyChef\n");         else             printf("UnluckyChef\n");     }     return 0; } 
#include<stdio.h> #include<math.h>   double power(double, long long);   int main() { 	double a, b, root2, root3; 	long long i, k, p, s; 	scanf("%lld %lld %lld", &i, &k, &s); 	scanf("%lf %lf", &a, &b); 	if ((k - i) % 2 == 0) 	{ 		p = 2 * (k - i) - s; 		if (p < 0) 			printf("%lf\n", (a + b) / power(2.0, -p)); 		else 			printf("%lf\n", (a + b) * power(2.0, p)); 	} 	else 	{ 		p = 2 * (k - i) - s - 1; 		root2 = sqrt(2.0); 		root3 = sqrt(3.0); 		if (p < 0) 			printf("%lf\n", root2 * (a + root3 * b) / power(2.0, -p)); 		else 			printf("%lf\n", root2 * (a + root3 * b) * power(2.0, p)); 	} 	return 0; }   double power(double a, long long b) { 	double result; 	result = 1; 	while (b > 0) 	{ 		if (b & 1) 			result *= a; 		b >>= 1; 		a *= a; 	} 	return result; } 
#include <bits/stdc++.h> #define mod 1000000007 #define ll long long int #define pb(x) push_back(x) #define MP(x,y) make_pair(x,y) using namespace std; ll b[1001][1001],c[1001][1001],a[1001],ans[1000001]; void solve() { 	ll n,m,k,i,j,z=0,x=0; 	ll sum=0,maxi; 	scanf("%lld%lld%lld",&n,&m,&k); 	for(i=0;i<n;i++) 		scanf("%lld",&a[i]); 	for(i=0;i<n;i++) 		for(j=0;j<m;j++) 			scanf("%lld",&b[i][j]); 	for(i=0;i<n;i++) 		for(j=0;j<m;j++) 			scanf("%lld",&c[i][j]); 	for(i=0;i<n;i++) 	{ 		sum+=b[i][a[i]-1]; 	} 	for(i=0;i<n;i++) 	{ 		maxi=b[i][0]-c[i][0]-b[i][a[i]-1]; 		for(j=0;j<m;j++) 		{ 			maxi=max(b[i][j]-c[i][j]-b[i][a[i]-1],maxi); 		} 		ans[z]=maxi; 		z++; 	}	 	sort(ans,ans+n); 	i=z-1; 	while(x<k && i>=0) 	{ 		if(ans[i]>0) 		{ 			sum+=ans[i]; 			x++; 		}	 		i--; 	} 	printf("%lld\n",sum); } int main() {     int t;     cin>>t;     while(t--)         solve();     return 0; }  
 #include <string> #include <stdlib.h> #ifndef ONLINE_JUDGE #include <windows.h> #endif  const int L = 'L', 		  R = 'R', 		  U = 'U', 		  D = 'D';  class Asteroid { public: 	int x, y; 	int dir; };  Asteroid ast[2012];  int ex, ey; int edir; int numAst;   bool haveCollision; double minTime;  void collision(double t) {  	if (t < 0.0) 		t = -t;  	haveCollision = true;  	if (t < minTime) 		minTime = t; }  void simulate() {  	haveCollision = false; 	minTime = 9999999999.0; 	int dx;  	for (int a = 0; a < numAst; a++) {  		if (edir == ast[a].dir)		// moving same direction, no collision ever 			continue; 		 		if (edir == U && ast[a].dir == D) {			// earth going up, asteroid going down  			if (ex != ast[a].x || ey > ast[a].y)	 				continue;  			collision((ast[a].y - ey) / 2.0); 		} 		else if (edir == D && ast[a].dir == U) {	// earth going down, asteroid going up  			if (ex != ast[a].x || ey < ast[a].y)	 				continue;  			collision((ey - ast[a].y) / 2.0); 		} 		else if (edir == L && ast[a].dir == R) {	// earth going left, asteroid going right  			if (ey != ast[a].y || ex < ast[a].x)	 				continue;  			collision((ex - ast[a].x) / 2.0); 		} 		else if (edir == R && ast[a].dir == L) {	// earth going right, asteroid going left  			if (ey != ast[a].y || ex > ast[a].x)	 				continue;  			collision((ast[a].x - ex) / 2.0); 		} 		else if (edir == U || edir == D)	{		// earth going up or down, asteroid going left or right 			dx = (ast[a].dir == L ? ast[a].x - ex : ex - ast[a].x); 			if (dx >= 0) { 				if (dx == (edir == U ? ast[a].y - ey : ey - ast[a].y)) 					collision(dx); 			} 		} 		else {										// earth going left or right, asteroid going up or down 			dx = (edir == L ? ex - ast[a].x : ast[a].x - ex); 			if (dx >= 0) { 				if (dx == (ast[a].dir == U ? ey - ast[a].y : ast[a].y - ey)) 					collision(dx); 			} 		} 	}   }   int main(int argc, char *argv[]) {	 #ifndef ONLINE_JUDGE 	freopen ("COLLIDE.txt","r",stdin); 	DWORD startTime = GetTickCount(); #endif  	int numTestCases; 	scanf("%d", &numTestCases);  	for (int c = 0; c < numTestCases; c++) {  		scanf("%d %d %c", &ex, &ey, &edir); 		scanf("%d", &numAst);  		for (int a = 0; a < numAst; a++) { 			scanf("%d %d %c", &ast[a].x, &ast[a].y, &ast[a].dir); 		}  		simulate(); 		if (!haveCollision) 			printf("SAFE\n"); 		else 			printf("%.1f\n", minTime); 	}  #ifndef ONLINE_JUDGE 	DWORD elapsed = GetTickCount() - startTime; 	printf("\ntime = %d", elapsed); 	fclose (stdin);	 #endif } 
#include<bits/stdc++.h> using namespace std; class node{   public:     int x;     int l;     int f; }; int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         node *array=new node[n];         for(int i=0;i<n;i++){             cin>>array[i].x>>array[i].l>>array[i].f;         }         long long time1=0;         for(int i=0;i<n;i++){             node p;             p=array[i];             if(p.x>time1){                 time1=p.x;             }             time1=p.x+p.f*ceil((time1-p.x)/(double)p.f);             time1=time1+p.l;         }         cout<<time1<<endl;     } }
#include <string> #include <iostream> using namespace std;   int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL); 	string exp; 	int test; 	int sum=0; 	int d,b; 	cin >> test; 	while(test--){ 		b=0; 		cin >> exp; 		const int len = exp.size(); 		d=0; 		sum+=exp.size(); 		for(int i=0;i<len;i++){ 		if(exp.substr(i,1)==">") 			d--; 		else 			d++; 		if(d==0) 			b=i+1; 		else if(d<0) 			break; 		} 		cout << b << endl; 	} return 0; }  
#include<bits/stdc++.h> using namespace std; int main() { 	int t,n,i,q,g; 	cin>>t; 	while(t--){ 		cin>>g; 		while(g--){ 			cin>>i>>n>>q; 			if(i==q) 				cout<<n/2; 			else 				cout<<(n+1)/2; 			cout<<endl;	 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; LL gcd(LL a, LL b){ 	if(b == 0) return a; 	return gcd(b, a % b);  } int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		LL N; 		scanf("%lld", &N); 		LL ans = 0; 		LL u = sqrt(N); 		for(int i = 1;i <= u;++i) 			ans += N/i; 		ans = 2 * ans - u * u; 		LL a = ans; 		LL b = N * N; 		LL g = gcd(a, b); 		printf("%lld/%lld\n", a/g, b/g); 	}  	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <string> #include <cstring> #include <ctime> #include <stdarg.h>   using namespace std;   typedef unsigned int uint; typedef long long int64; typedef unsigned long long uint64; typedef unsigned long long double64;   #ifdef DEBUG #define ASSERT(_Expression) (void)((!!(_Expression)||(__assert((#_Expression),__LINE__),0))); void __assert(const char *_Message,const unsigned _Line) {printf("ASSERTION FAILED\n");printf("Message = %ls\n",_Message);printf("Line = %u\n",_Line); exit(0);} #endif  const int MODULO = 1000000007; const int N = 1001; bool is_palindrome[N][N];  void init_palindrome(const string &s) { 	int length = s.length(); 	for (int i = length - 1; i >= 0; --i) { 		// a single character is a palindrome 		is_palindrome[i][i] = true;			 		// two consecutive same characters 		if ((i + 1) < length && s[i] == s[i + 1]) { 			is_palindrome[i][i + 1] = true;  		}  		for (int j = i + 2; j < length; ++j) { 			// check the middle 			if (s[i] == s[j] && is_palindrome[i + 1][j - 1]) { 				is_palindrome[i][j] = true;  			} 		} 	} }  int count_palindrome(int length) { 	vector<int> dp(length + 1); 	dp[0] = dp[1] = 1; 	int n; 	for (int i = 1; i < length; ++i) { 		dp[i + 1] = dp[i]; 		for (int j = i - 1; j >= 0; --j) { 			if (is_palindrome[j][i]) { 				dp[i + 1] = (dp[i + 1] + dp[j]) % MODULO; 			} 		} 	} 	return dp[length]; }  void inout_count_palindromes() { 	string s; 	cin >> s; 	int length = s.length(); 	init_palindrome(s); 	cout << count_palindrome(length) << endl; }   int main() { 	inout_count_palindromes(); 	return 0; }     
#include<stdio.h> using namespace std; #define MOD 100000007 typedef long long	LL; LL moduloSpecial(LL b, LL p,LL n)  { 	LL x=1,y=b; 	while(p)      { 		if(p&1)x=(x*y)%         n; 		y=(y*y)%n; 		p>>=1; 	} 	return x%n; } int main() {     int T;     scanf("%d",&T);     while(T--)     {               LL n;               LL a,b,c,d,e,r1,r2;               scanf("%lld",&n);               a=2*moduloSpecial(4,n-1,MOD);               b=moduloSpecial(3,n,MOD);               c=moduloSpecial(2,n-1,MOD);               d=moduloSpecial(2,n,MOD);               e=moduloSpecial(3,n,2*MOD)+1;               e=e/2;               if(e>d)r1=(e-d)%MOD;               else r1=(MOD+e-d)%MOD;               if(a>b)a=a-b;               else a=MOD+a-b;               a=(a+c)%MOD;               a=(a+d)%MOD;               if(a>e)r2=(a-e);               else r2=(MOD+a-e)%MOD;               printf("%lld %lld\n",r1,r2);                    } }  
#include<stdio.h> #include<math.h> #define EPS 0.00001 double d[505][505]; int visited[505],n,queue[505]; int x[505],y[505]; double dist(int x1,int y1,int x2,int y2) {  return sqrt(double((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))); } int poss(double check) {  int head,tail,i;   head=0;tail=1;   queue[head]=n;   while(head<tail)     {      visited[queue[head]]=1;       for(i=0;i<=(n+1);i++)         {         if(!visited[i] && d[queue[head]][i]<check)             {         if(i==(n+1))return 0;               visited[i]=1;               queue[tail++]=i;             }         }       head++;     }   return 1; } int main() {   int t,r,R,i,j;   double hi,lo,mid;   scanf("%d",&t);   while(t--)     {       scanf("%d %d",&r,&R);       scanf("%d",&n);       for(i=0;i<n;i++)         scanf("%d %d",&x[i],&y[i]);       for(i=0;i<=(n+1);i++)         d[i][i]=0;       for(i=0;i<n;i++)         for(j=i+1;j<n;j++)           d[i][j]=d[j][i]=dist(x[i],y[i],x[j],y[j]);       for(i=0;i<n;i++)         {           d[i][n]=d[n][i]=dist(x[i],y[i],0,0)-r;           d[i][n+1]=d[n+1][i]=R-d[n][i]-r;         }       d[n][n+1]=d[n+1][n]=R-r;       hi=R-r;       lo=0;       while(hi-lo>=EPS)         {           for(i=0;i<=(n+1);i++)             visited[i]=0;           mid=(lo+hi)/2.0;           if(poss(mid))             lo=mid;           else             hi=mid;         }       printf("%.3lf\n",lo);     }   return 0; }
#include<iostream> #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<algorithm> #include<queue> #include<vector> #include<stack> #include<map> #include<cctype> #include<sstream> #define L long long int #define U unsigned long long int #define R 1000000007 using namespace std;  void multiply(U F[3][3],U M[3][3]); void power(U F[3][3],U n);  U crowd(U n) { 	U F[3][3]={{1,1,0},{1,0,1},{1,0,0}}; 	if(n==0)return 0; 	power(F,n+1); 	return F[0][0]; }  void power(U F[3][3],U n) { 	if(n==0 || n==1)return; 	U M[3][3]={{1,1,0},{1,0,1},{1,0,0}}; 	power(F,n/2); 	multiply(F,F); 	if(n%2!=0) 	{ 		multiply(F,M); 	} }  void multiply(U F[3][3],U M[3][3]) { 	U a=((F[0][0]*M[0][0])%R + (F[0][1]*M[1][0])%R + (F[0][2]*M[2][0])%R)%R; 	U b=((F[0][0]*M[0][1])%R + (F[0][1]*M[1][1])%R + (F[0][2]*M[2][1])%R)%R; 	U c=((F[0][0]*M[0][2])%R + (F[0][1]*M[1][2])%R + (F[0][2]*M[2][2])%R)%R; 	U d=((F[1][0]*M[0][0])%R + (F[1][1]*M[1][0])%R + (F[1][2]*M[2][0])%R)%R; 	U e=((F[1][0]*M[0][1])%R + (F[1][1]*M[1][1])%R + (F[1][2]*M[2][1])%R)%R; 	U f=((F[1][0]*M[0][2])%R + (F[1][1]*M[1][2])%R + (F[1][2]*M[2][2])%R)%R; 	U g=((F[2][0]*M[0][0])%R + (F[2][1]*M[1][0])%R + (F[2][2]*M[2][0])%R)%R; 	U h=((F[2][0]*M[0][1])%R + (F[2][1]*M[1][1])%R + (F[2][2]*M[2][1])%R)%R; 	U i=((F[2][0]*M[0][2])%R + (F[2][1]*M[1][2])%R + (F[2][2]*M[2][2])%R)%R; 	F[0][0]=a; 	F[0][1]=b; 	F[0][2]=c; 	F[1][0]=d; 	F[1][1]=e; 	F[1][2]=f; 	F[2][0]=g; 	F[2][1]=h; 	F[2][2]=i; }  U pow2(U n) { 	if(n==0)return 1; 	if(n==1)return 2; 	 U x = pow2(n/2);     if(n&1)           return (x*((x*2)%R))%R;     return (x*x)%R; }  int main() { 	int t; 	scanf("%d",&t); 	U n; 	while(t--) 	{ 		scanf("%llu",&n); 		U x=pow2(n),y=crowd(n); 		if(x>=y)cout<<x-y<<endl; 		else cout<<R+x-y<<endl; 	} } 
#include <bits/stdc++.h> #define LL long long #define i64 long long #define ri(x) scanf("%d",&x) #define rl(x) scanf("%lld",&x) using namespace std; LL countFact(LL a,LL b) {         i64 now=1;         i64 ret=0;         while(now<=a/b)         {             now*=b;             ret+=a/now;         }         return ret;  } long long pow(LL a, LL b, LL MOD) {     long long x=1,y=a;      while(b > 0)     {         if(b%2 == 1)         {             x=(x*y);             if(x>MOD) x%=MOD;         }         y = (y*y);         if(y>MOD) y%=MOD;          b /= 2;     }     return x; } long long InverseEuler(LL n, LL MOD) {     return pow(n,MOD-2,MOD); }   long long factMOD(LL n, LL MOD) {     long long res = 1;      while (n > 0)     {         for (int i=2, m=n%MOD; i<=m; i++)             res = (res * i) % MOD;         if ((n/=MOD)%2 > 0)              res = MOD - res;     }     return res%MOD; } long long C(LL n, LL r, LL MOD) {     if (countFact(n,MOD)>countFact(r, MOD)+countFact(n-r, MOD))         return 0;     return (factMOD(n, MOD) * ((InverseEuler(factMOD(r, MOD), MOD) * InverseEuler(factMOD(n-r, MOD), MOD)) % MOD)) % MOD; }  int main() {     int t;     ri(t);     while(t--)     {         long long k,l,r;         rl(k),rl(l),rl(r);         long long p=r-l+1;         cout<<((C(p+k,p,1000003)-1 + 1000003)%1000003 )<<endl;     } } 
#include <iostream> #include <stdio.h> #include <string.h> using namespace std; int main(){     int t;     scanf("%d",&t);     while(t--){         long int i,j,n;         long long int sum=0,cunt=0;         scanf("%ld",&n);         string arr;         cin>>arr;         for(i=0;i<n;i++){             if(arr[i]=='1'){                 cunt++;                 sum++;                 sum+=(cunt-1);             }         }         cout<<sum<<endl;      } } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e9 + 7; void mul(LL (*A)[2], LL (*B)[2]){     LL C[2][2];     for(int i = 0;i < 2;++i){         for(int j = 0;j < 2;++j){             C[i][j] = 0;             for(int k = 0;k < 2;++k){                 C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;             }         }     }     for(int i = 0;i < 2;++i){         for(int j = 0;j < 2;++j){             A[i][j] = C[i][j];         }     } } void power(LL (*MAT)[2], int p){     LL ans[2][2] = {{1, 0}, {0, 1}};     while(p > 0){         if(p&1){             mul(ans, MAT);         }         mul(MAT, MAT);         p >>= 1;     }     for(int i = 0;i < 2;++i){         for(int j = 0;j < 2;++j){             MAT[i][j] = ans[i][j];         }     } } inline LL rec(int N){     if(N == 1){         return 1;     } else if(N == 2){         return 3;     }     LL MAT[2][2] = {{2, 2}, {1 , 0}};     power(MAT, N - 2);      return (MAT[0][0] * 3 + MAT[0][1]) % MOD; } int main(){     int t;     scanf("%d", &t);     while(t--){         int N;         scanf("%d", &N);         printf("%lld\n", rec(N));     }     return 0; } 
#include <bits/stdc++.h> #define pp pair < int  , int > using namespace std; const int N = 1e5 + 5; set < pp > s; vector < pp > vv; map < int , set < pp > :: iterator > mtp; set < pp > :: iterator it; long long get(long long x , long long y){     return abs(y - 2 * x); } int main(){     int n , a , r;     long long young = 0 , old = 0;     vv.clear();     s.clear();     mtp.clear();     cin >> n;     for(int i = 1; i <= n; ++i){        cin >> a >> r;        vv.push_back(make_pair(a , r));        s.insert(make_pair(a ,r));        if(i < 2){         it = s.begin();         mtp[i] = it;         continue;        }        if(!(i & 1)){         if(a > (*it).first) *it++;         mtp[i] = it;        }else{            if(a < (*it).first) *it--;            mtp[i] = it;        }     }     long long mid_value = vv[0].second;      long long sum = vv[0].second;     cout << get(mid_value , sum) << endl;     for(int i = 2; i <= n; ++i){         sum += vv[i - 1].second;         a = vv[i - 1].first , r = vv[i - 1].second;         pp mid = *mtp[i - 1];             if(!(i & 1)){             if(a < mid.first) mid_value += r - mid.second;             }else{                 mid_value += a < mid.first ? r : mid.second;             }             cout << get(mid_value , sum) << endl;     }     return 0; } 
//December Challenge 2013 //Courtesy midishero  #include<cstdio> #include<cmath> #include<cstdlib> #include<cstring> #include<algorithm> #define MAXN 64001  char cubeA[MAXN], cubeB[MAXN]; bool s[MAXN]; int subCube[41][41][41]={0}; int N, P, com;  void findSubCube(){ 	int len=N*N*N; 	for(int i=0;i<len; i++) s[i]=(cubeA[i]==cubeB[i]); 	int x1, y1, z1, k, C; 	com=0; 	for(int x=1; x<=N; x++){ 		x1=x-1; 		for(int y=1; y<=N; y++){ 			y1=y-1; 			for(int z=1; z<=N; z++){ 				z1=z-1; 				subCube[x][y][z]=subCube[x1][y][z]+subCube[x][y1][z]+subCube[x][y][z1]-subCube[x1][y1][z]-subCube[x1][y][z1]-subCube[x][y1][z1]+subCube[x1][y1][z1]; 				if(s[x1*N*N+y1*N+z1]){ 					subCube[x][y][z]++; 					com++; 				} 			} 		} 	} 	if(com>0) C=com; 	else{ 		printf("-1\n"); 		return; 	} 	for(int i=N; i>=2; i--){ 		com=0; 		int min=ceil(i*i*i*P*0.01); 		for(int x=i; x<=N; x++){ 			x1=x-i; 			for(int y=i; y<=N; y++){ 				y1=y-i; 				for(int z=i; z<=N; z++){ 					z1=z-i; 					int k=subCube[x][y][z]-subCube[x1][y][z]-subCube[x][y1][z]-subCube[x][y][z1]+subCube[x1][y1][z]+subCube[x1][y][z1]+subCube[x][y1][z1]-subCube[x1][y1][z1]; 					if(k>=min) com++; 				} 			} 		} 		if(com>0){ 			printf("%d %d\n", i, com); 			return; 		} 	} 	printf("1 %d\n", C); 	return; }  int main(){ 	int test; 	scanf("%d", &test); 	while(test--){ 		scanf("%d %d\n", &N, &P); 		gets(cubeA); 		gets(cubeB); 		if(P==0){ 			printf("%d 1\n",N); 			continue; 		} 		findSubCube(); 	} }  
#include<cstdio> #include<cstdlib> #include<cmath> #include<cstring> #include<iostream> #include<algorithm>  using namespace std;  main() {       int tc;       scanf("%d", &tc);       while(tc--)       {            int x,y,z;            scanf("%d %d %d", &x, &y, &z);            int arr[x][y][z];            for(int i =0;i<x; i++)            {                    for(int j =0;j<y; j++)                    {                            for(int k =0;k<z; k++)                                    scanf("%d", &arr[i][j][k]);                    }            }            for(int i =x-1;i>=0; i--)            {                    for(int j =y-1;j>=0; j--)                    {                            for(int k =z-1;k>0; k--)                            {                                    arr[i][j][k] -= arr[i][j][k-1];                            }                    }            }            for(int i =x-1;i>=0; i--)            {                    for(int j =y-1;j>0; j--)                    {                            for(int k =z-1;k>=0; k--)                            {                                    arr[i][j][k] -= arr[i][j-1][k];                            }                    }            }                        for(int i =x-1;i>0; i--)            {                    for(int j =y-1;j>=0; j--)                    {                            for(int k =z-1;k>=0; k--)                            {                                    arr[i][j][k] -= arr[i-1][j][k];                            }                    }            }            for(int i =0;i<x; i++)            {                    for(int j =0;j<y; j++)                    {                            for(int k =0;k<z; k++)                                    printf("%d ",arr[i][j][k]);                            printf("\n");                    }            }       }       return 0; } 
#include<stdio.h> #include<string.h> #include<iostream> #include<map>  using namespace std;  int main() {     int cn,cf;     string country, chef;     map <string, string> countries;     map <string, int> chefs;     map <string, int> country_count;      scanf("%d",&cn);     scanf("%d",&cf);      for (int i = 0; i < cn; i++) {         cin>>chef>>country;         countries[chef] = country;         chefs[chef] = 0;         country_count[country] = 0;     }      for (int i = 0; i < cf; i++) {         cin>>chef;         chefs[chef]++;         country_count[countries[chef]]++;     }      int max = -1;     string winner;      for (map<string,int>::iterator it = chefs.begin(); it != chefs.end(); it++) {         if (it->second > max ) {             max = it->second;             winner = it->first;         }         else if(it->second = max) {             string temp = it->first;             if (temp < winner)                 winner = temp;         }     }      string winner_con;  	max = -1;     for (map<string,int>::iterator it = country_count.begin(); it != country_count.end(); it++) {         if (it->second > max ) {             max = it->second;             winner_con = it->first;         }         else if(it->second = max) {             string temp = it->first;             if (temp < winner_con)                 winner_con = temp;         }     }      cout<<winner_con<<"\n"<<winner;     return 0; } 
#include<cstdio> #include<iostream> #include<algorithm>  using namespace std;  #define DEBUG(x) cout<<#x<<"="<<x<<endl;  struct Point{     int x, y; };  inline bool cmp(Point a, Point b) {     return (a.x<b.x || (a.x==b.x && a.y<b.y)); }  inline bool is_range(int x, int y) {     return (x>=0 && x<=100 && y>=0 && y<=100); }  int main() {     int t;     scanf("%d", &t);     while(t--) {         int n;         scanf("%d", &n);          bool map[101][101]={false};         Point P[500];         for(int i=0; i<n; i++) {             scanf("%d %d", &P[i].x, &P[i].y);             map[P[i].x+50][P[i].y+50]=true;         }          sort(P, P+n, cmp);          int cnt=0;         for(int i=0; i<n-1; i++)         for(int j=i+1; j<n; j++) {             int x3=P[j].x-(P[j].y-P[i].y);             int y3=P[j].y+(P[j].x-P[i].x);             x3+=50; y3+=50;             if(is_range(x3, y3)) {                 int x4=P[i].x-(P[j].y-P[i].y);                 int y4=P[i].y+(P[j].x-P[i].x);                 x4+=50; y4+=50;                 if(is_range(x4, y4))                 if(map[P[i].x+50][P[i].y+50] && map[P[j].x+50][P[j].y+50] && map[x3][y3] && map[x4][y4])                     cnt++;             }         }          printf("%d\n", cnt/2);     } } 
#include<bits/stdc++.h> using namespace std; long long factorial(long long n){     long long answer=1;     for(int i=2;i<=n;i++){         answer=answer*i;     }     return answer; } long long c(long long count,long long x){     return factorial(count)/(factorial(x)*factorial(count-x)); } int main(){     long long x,n;     cin>>x>>n;     string *array=new string[n];     for(int i=0;i<n;i++){         cin>>array[i];     }     long long ways=0;     for(int i=0;i<n;i++){         int k=0;         for(int j=1;j<=36;j=j+4){             long long count=0;             if(array[i][j-1]=='0'){                 count++;             }             if(array[i][j]=='0'){                 count++;             }             if(array[i][j+1]=='0'){                 count++;             }             if(array[i][j+2]=='0'){                 count++;             }             if(array[i][53-k]=='0'){                 count++;             }             if(array[i][52-k]=='0'){                 count++;             }             k=k+2;             if(count>=x){                 ways=ways+c(count,x);             }         }     }     cout<<ways<<endl; }
#include<bits/stdc++.h> using namespace std; const int MAXN = 2000; const int INF = 1e8; int H[MAXN]; int K[MAXN]; int dp[MAXN][MAXN]; int main(){     int t;     cin >> t;     for(int i = 0;i < MAXN;++i){         for(int j = 0;j < MAXN;++j){             dp[i][j] = INF;         }     }     while(t--){         int N;         scanf("%d", &N);         int LM = 0;         for(int i = 1;i <= N;++i){             scanf("%d", &H[i]);             LM = max(LM, H[i]);         }         for(int i = 1;i <= N;++i){             scanf("%d", &K[i]);         }         LM <<= 1;         dp[0][0] = 0;         for(int i = 1;i <= N;++i){             dp[i][0] = 0;             for(int fuel = 1;fuel <= LM;++fuel){                 dp[i][fuel] = dp[i - 1][fuel];                 if(fuel >= K[i]){                     int last = dp[i - 1][fuel - K[i]];                     dp[i][fuel] = min(dp[i][fuel], last + 1);                      last = dp[i][fuel - K[i]];                     dp[i][fuel] = min(dp[i][fuel], last + 1);                  }             }         }         int ans = 0;         for(int i = 1;i <= N;++i){             ans += dp[N][(H[i] << 1)];         }         printf("%d\n", ans);     }     return 0; } 
#include<bits/stdc++.h> #define ll long long int #define mp make_pair #define pb push_back #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define s(x) scanf("%lld",&x) #define p(x) printf("%lld\n",x) #define sc(x) scanf("%s",x) #define INF (1<<30) #define N 1000002  using namespace std;  int A[N];int L[N];int R[N];int s[N];  typedef pair<int,int> ct; #define value first #define count second  ct cts[N]; char typ[11]; char ans[N]; int n, m; int find(int k) {     // binary search     int l=0, r=n+1;     while (r-l>1) {         int mid = (l+r)>>1;         (cts[mid].value<=k?l:r)=mid;     }     return cts[l].count; }  int main() {     si(n);si(m);     A[0] = A[n+1] = INF;     for (int i=1;i<=n;i++) si(A[i]);      s[0] = 0;     for (int q=0,i=1;i<=n;i++) {         while (A[s[q]]<A[i]) q--;         L[i]=s[q];         s[++q]=i;     }      s[0] = n+1;     for (int q=0,i=n;i;i--) {         while (A[s[q]]<=A[i]) q--;         R[i] = s[q];         s[++q] = i;     }      cts[0].value = -INF;     cts[0].count = 0;     for (int i=1;i<=n;i++) {         cts[i].value=A[i];         cts[i].count=(R[i]-i)*(i-L[i]);     }     sort(cts,cts+n+1);      for (int i=1;i<=n;i++) {         cts[i].count ^= cts[i-1].count;     }      for (int i=0;i<m;i++) {         int k;         scanf("%s%d%s", typ, &k, ans + i);         if (!((*typ == '>' ? n*(n+1LL)/2 - find(k) : *typ == '<' ? find(k-1) : find(k) - find(k-1)) & 1)) ans[i] ^= 7;     }     ans[m] = 0;     printf("%s\n", ans); }  
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<cstring> #include<vector> #include<bitset> #include<map> #include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #define read(x) scanf("%lld",&x) #define write(x) printf("%d\n",x) #define assign(x,n) x=(int*)calloc(n,4) #define rep(i,n) for(i=1;i<=n;++i) #define max(a,b) ((a)>(b))?(a):(b)  typedef  long long int ull; using namespace std; typedef  pair<int,int> pr;   queue <ull> del,bit; vector <ull> ans;   int main() {               int i,low,up;     ull d,u,uu,l,r,t;     for(i=1;i<=9;i++)     {                      del.push(i);                      bit.push(1<<i);     }          do     {                      d=del.front();                      u=bit.front();                      del.pop();                      bit.pop();                      uu=~u;                     ans.push_back(d);                      for(i=0;i<=9;i++)                      {                               if(uu&(1<<i) )                               {                               del.push(d*10 +i);                               bit.push(u|(1<<i));                                                              }                      }     }while(!del.empty());                                 read(t);   while(t--)   {             read(l);             read(r);             low=(int)(lower_bound (ans.begin(), ans.end(), l)-ans.begin()); //          ^             up= (int)(upper_bound (ans.begin(), ans.end(), r)-ans.begin()); //               write(up-low);   }                     //system("pause"); return 0; } 
#include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm>  using namespace std;   string s="abcdefghijklmnopqrstuvwxyz"; int main(){    int t;     cin>>t;     while(t--)         {         int n,temp;         cin>>n;         temp=n;                  int i;         int p=temp/25;         int q=n-p*25;         //cout<<p<<endl<<q<<endl<<n<<endl;         if(q!=0){         for(i=q;i>=0;i--)             {             cout<<s[i];         }         }         while(p--){         for(i=25;i>=0;i--)             {             cout<<s[i];         }         } cout<<endl;              }          return 0; }    
#include <cstdio> #include <cstring>   // the maximal length of M const int maxL = 8;   // max_digit[d] is the maximal digit that could be obtained from d int max_digit[10];   // mark_digits[d1][d2] = 1 iff d2 could be obtained from d1 int mark_digits[10][10];   // max_smaller_digit[d1][d2] is the maximal digit less than d2 that could be obtained from d1 // or -1 if no such digit could be obtained int max_smaller_digit[10][10];   void precalc() { 	// cover[d] is the list of digits that could be obtained from d 	// it is -1 terminating list 	// note that d and 8 are always in cover[d] 	int cover[10][10]={ 		{0, 8, -1},					// for 0 		{0, 1, 3, 4, 7, 8, 9, -1},	// for 1 		{2, 8, -1},					// for 2 		{3, 8, 9, -1},				// for 3 		{4, 8, 9, -1},				// for 4 		{5, 6, 8, 9, -1},			// for 5 		{6, 8, -1},					// for 6 		{0, 3, 7, 8, 9,-1},			// for 7 		{8, -1},					// for 8 		{8, 9, -1}					// for 9 	}; 	for (int d1 = 0; d1 < 10; ++d1) { 		for (int i = 0; ; ++i) { 			int d2 = cover[d1][i]; 			if (d2 < 0) { 				break; 			} 			mark_digits[d1][d2] = 1; 		} 		// we use the fact that 8 can be obtained from any digit 		max_digit[d1] = mark_digits[d1][9] ? 9 : 8;   		// some kind of dp 		max_smaller_digit[d1][0] = -1; 		for (int d2 = 1; d2 < 10; ++d2) { 			if (mark_digits[d1][d2-1]) { 				max_smaller_digit[d1][d2] = d2-1; 			} else { 				max_smaller_digit[d1][d2] = max_smaller_digit[d1][d2-1]; 			} 		} 	} }   // @a is a string representation of @S from the input // @b is a string representation of @M from the input // return the largest defacing score int solve(char *a, char *b) { 	int k = strlen(a); 	int n = strlen(b);   	int ans = 0;   	// @p is offset; we match a[i-p] to b[i] for 0<=i<n 	// slots outside of @a can be used to create any digit 	// we denote c[i] = a[i-p] for simplcity 	for (int p = 0; p <= n-k; ++p) {   		// we find for each position the following values 		//  - maximum digit we can obtain from a[i-p] 		//  - whether we can obtain b[i] from a[i-p] 		//  - maximum digit we can obtain from a[i-p] that is less than b[i] 		int max_dig[maxL]; // mostly coincide with max_digit above but needed to handle empty slots 		bool can_eq[maxL]; 		int max_smaller_dig[maxL]; // -1 means we can not have smaller digit 		for (int i = 0; i < n; ++i) { 			// the value from 0 to 9 			int db = b[i] - '0';   			if (0 <= i-p && i-p < k) { 				// the case of digit of @a 				int da = a[i-p] - '0'; 				max_dig[i] = max_digit[da]; // simply copy value from precacluated array 				can_eq[i] = mark_digits[da][db]; // mark_digits exactly check that da --> db 				max_smaller_dig[i] = max_smaller_digit[da][db]; // here why we need this strange array 			} else { 				// empty slot - could be any digit 				max_dig[i] = 9; 				can_eq[i] = true; 				max_smaller_dig[i] = db-1; 			} 		}   		// now the maximal score for the given offset @p could be obtained as follows 		// we need to find the largest j from 0 to n, inclusive for which 		// we can obtain b[i] from c[i] for all i from 0 to j-1, inclusive 		// and can obtain some smaller digit from b[j] 		// (j=n corresponds to the case when we can make a=b) 		int j = -1; 		for (int i = 0; i <= n && (i == 0 || can_eq[i-1]); ++i) { 			if (i == n || max_smaller_dig[i] >= 0) { 				j = i; 			} 		} 		// j = -1 means that any such j exists 		if (j < 0) { 			continue; 		}   		// otherwise we should convert digits c[i] to b[i] for 0<=i<j 		int cur = 0; 		for (int i = 0; i < j; ++i) { 			cur = 10 * cur + (b[i] - '0'); 		} 		// and if j<n convert c[j] to the largest possible digit smaller b[j] 		// while the rest digits could be converted to maximal possible digits 		if (j < n) { 			cur = 10 * cur + max_smaller_dig[j]; 			for (int i = j + 1; i < n; ++i) { 				cur = 10 * cur + max_dig[i]; 			} 		} 		if (ans < cur) { 			ans = cur; 		} 	} 	return ans; }   int main() { 	precalc(); 	int T; 	scanf("%d", &T); 	for (int t = 0; t < T; ++t) { 		// we read @S and @M as strings 		// since it is convenient to work with them as with strings 		char S[maxL + 1], M[maxL + 1]; 		scanf("%s%s", S, M); 		int ans = solve(S, M); 		printf("%d\n", ans); 	} 	return 0; }  
#include<bits/stdc++.h> using namespace std; typedef long long LL; const int MAXN = 1e6 + 10; const LL INF = 1e17; LL A[MAXN]; LL Lmin [MAXN]; LL Rmin [MAXN]; LL Lmax [MAXN]; LL Rmax [MAXN]; int main(){     int t;     scanf("%d", &t);     while(t--){         int N;         scanf("%d", &N);         for(int i = 1;i <= N;++i){             scanf("%lld", &A[i]);         }         Lmin[0] = Lmax[0] = 0;         for(int i = 1;i <= N;++i){             Lmax[i] = max(Lmax[i - 1] + A[i], A[i]);             Lmin[i] = min(Lmin[i - 1] + A[i], A[i]);         }         for(int i = 2;i <= N;++i){             Lmax[i] = max(Lmax[i], Lmax[i - 1]);             Lmin[i] = min(Lmin[i], Lmin[i - 1]);         }          Rmin[N + 1] = Rmax[N + 1] = 0;         for(int i = N;i >= 1;--i){             Rmax[i] = max(Rmax[i + 1] + A[i], A[i]);             Rmin[i] = min(Rmin[i + 1] + A[i], A[i]);         }         for(int i = N - 1;i >= 1;--i){             Rmax[i] = max(Rmax[i], Rmax[i + 1]);             Rmin[i] = min(Rmin[i], Rmin[i + 1]);         }         LL ans = -INF;         for(int i = 1;i < N;++i){             ans = max(ans, abs(Lmax[i] - Rmin[i + 1]));             ans = max(ans, abs(Lmin[i] - Rmax[i + 1]));         }         printf("%lld\n", ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; int A[MAXN]; vector<int> B; int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         for(int i = 1;i <= N;++i){             scanf("%d", &A[i]);         }         sort(A + 1, A + 1 + N);         int cnt = 1;         int ele = A[1];         B.clear();         for(int i = 2;i <= N;++i){             if(A[i] != ele){                 B.push_back(cnt);                 cnt = 1;                 ele = A[i];             } else {                 ++cnt;             }         }         int ans = 0;         B.push_back(cnt);         make_heap(B.begin(), B.end());         while(!B.empty()){             int x = B.front();             pop_heap(B.begin(), B.end());             B.pop_back();             if(B.empty()){                 ans += x;             } else {                 int y = B.front();                 pop_heap(B.begin(), B.end());                 B.pop_back();                  if(x - 1 > 0){                     B.push_back(x - 1);                     push_heap(B.begin(), B.end());                 }                  if(y - 1 > 0){                     B.push_back(y - 1);                     push_heap(B.begin(), B.end());                 }                 ++ans;             }         }         cout << ans << "\n";     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int arr[100012]; map<char ,int> mp; vector<int> v[200012]; int visited[200]; int n; char s[100012]; string t=""; int check() {     int c=0;     for(int i=0; i<n; i++)     {         if(s[i]!=t[i])             c++;     }     return c; } int main() {     int tc;     scanf("%d",&tc);      while(tc--)     {         int k;         scanf("%d",&k);         scanf("%s",s);         n =strlen(s);         int g=0,b=0;         for(int i=0; i<n; i++)         {             if(s[i]=='G') g++;             else b++;          }         int d = abs(b-g);         if(d>1)         {             puts("-1");         }         else if(k==0)         {             if(b==g)             {                 int l=0,c=0;                 for(int i=0; i<n; i++)                 {                     if(l==0)                     {                         if(s[i]!='B') c++;                         l=1;                     }                     else                     {                         if(s[i]!='G') c++;                         l=0;                     }                 }                 int x = c;                 l=0,c=0;                 for(int i=0; i<n; i++)                 {                     if(l==0)                     {                         if(s[i]!='G') c++;                         l=1;                     }                     else                     {                         if(s[i]!='B') c++;                         l=0;                     }                 }                 x = min(x,c);                 x = x/2 + x%2;                 printf("%d\n",x);             }              else if(b>g)             {                 int l=0,c=0;                 for(int i=0; i<n; i++)                 {                     if(l==0)                     {                         if(s[i]!='B') c++;                         l=1;                     }                     else                     {                         if(s[i]!='G') c++;                         l=0;                     }                 }                 c = c/2 + c%2;                 printf("%d\n",c);             }             else             {                 int l=0,c=0;                 for(int i=0; i<n; i++)                 {                     if(l==0)                     {                         if(s[i]!='G') c++;                         l=1;                     }                     else                     {                         if(s[i]!='B') c++;                         l=0;                     }                 }                 c = c/2 + c%2;                 printf("%d\n",c);              }         }          else         {             if(b==g)             {                 int left =0,ans=0,ans2=0;                 for(int i=0; i<n; i+=2)                 {                      while(s[left]!='B') left++;                     ans = ans + abs(i-left);                     left++;                 }                 left=0;                 for(int i=0; i<n; i+=2)                 {                      while(s[left]!='G') left++;                      ans2 = ans2 + abs(i-left);                     left++;                 }                 //cout<<ans<<" "<<ans2<<endl;                 ans = min(ans,ans2);                 printf("%d\n",ans);              }             else if(b>g)             {                 int left =0,ans=0;                 for(int i=0; i<n; i+=2)                 {                      while(s[left]!='B') left++;                      ans = ans + abs(i-left);                     left++;                 }                 printf("%d\n",ans);             }             else if(g>b)             {                 int left =0,ans=0;                 for(int i=0; i<n; i+=2)                 {                      while(s[left]!='G') left++;                     ans = ans + abs(i-left);                     left++;                 }                 printf("%d\n",ans);             }         }     }  } 
#include<iostream> #include<math.h> using namespace std;  int main(){ 	int T,n,m,i,j,max_x,min_x,max_y,min_y,maxtime,flag; 	cin>>T; 	while(T--){ 		flag=1; 		cin>>n>>m; 		max_x=0; 		min_x=m-1; 		max_y=0; 		min_y=n-1; 		char grid[n][m]; 		for(i=0;i<n;i++){ 			for(j=0;j<m;j++){ 				cin>>grid[i][j]; 				if(grid[i][j]=='*'){ 					flag=0; 					max_x=max(j,max_x); 					min_x=min(j,min_x); 					max_y=max(i,max_y); 					min_y=min(i,min_y); 				} 			} 		} 		if(flag){ 			cout<<0<<endl; 		} 		else{ 			maxtime=(max(max_x-min_x+1,max_y-min_y+1)/2)+1; 			cout<<maxtime<<endl; 		} 	} 	return 0; }
//Amit Gupta               #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 200010 #define endl '\n' #define FILL(ar,vl) for(int i=0;i<N;i++)ar[i]=vl #define FILL2(ar,vl) for(int i=0;i<N;i++)for(j=0;j<N;j++)ar[i][j]=vl //--------------------------MAIN CODE STARTS HERE---------------- int main() {	     int t;     cin>>t;     while(t--) {         int n,k;         cin>>n>>k;         int a[n];string s;         cin>>s;         REP(i,0,n)             a[i]=s[i]-'0';         int cnt=1,ans=0;         if(k==1) {             int ct1=0,ct2=0;             REP(i,0,n) {                 if(a[i]==0&&i%2==1)                     ct1++;                 if(a[i]==1&&i%2==0)                     ct1++;             }             REP(i,0,n) {                 if(a[i]==0&&i%2==0)                     ct2++;                 if(a[i]==1&&i%2==1)                     ct2++;             }             cout<<min(ct1,ct2)<<"\n";             if(ct1<=ct2) {                 REP(i,0,n)                     cout<<(i%2==0?0:1);                 cout<<"\n";             }             else {                 REP(i,0,n)                     cout<<(i%2==0?1:0);                 cout<<"\n";             }              continue;         }         REP(i,1,n) {             if(a[i]==a[i-1]) {                 cnt++;                 if(cnt>k) {                     ans++;                     cnt=1;                     if(i+1<n) {                         if(a[i+1]==a[i])                             a[i]=a[i]^1;                         else                             a[i-1]=a[i-1]^1;                     }                     else                         a[i]=a[i]^1;                 }             }             else                 cnt=1;         }         cout<<ans<<"\n";         REP(i,0,n)             cout<<a[i];         cout<<"\n";     }     return 0; } 
#include<stdio.h> int n=2000; double p[2000][2000]; int main() { 	int i,j; 	p[0][0]=1; 	p[1][0]=p[1][1]=0.5; 	for(i=2;i<n;i++) 	{ 		for(j=0;j<=i/2;j++) 		{ 			if(j==0) p[i][j]=p[i][i-j]=1-0.5*p[i-1][j]; 			else p[i][j]=p[i][i-j]=1-0.5*(p[i-1][j]+p[i-1][j-1]); 		} 	} 	 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int m,q; 		scanf("%d",&m); 		double sum=0.0; 		for(i=0;i<m;i++) 		{ 			scanf("%d",&q); 			sum=sum+(q*p[m-1][i]); 		} 		printf("%0.3f\n",sum); 	} 	return 0; }
#include<iostream> #include<string> #include<vector> #include<queue> #include<cstring>  using namespace std;  queue<int> Q; vector<int> V[10]; bool isvisted[100005]; int d[100005];  int main(){                 string s;       cin >> s;       memset(isvisted, false, sizeof isvisted);         int sz = s.size();        for(int i=0;i<sz;i++){ 	int val = s[i]-'0'; 	V[val].push_back(i); 	       }                      d[0]=0;       Q.push(0);       isvisted[0]=true;              while(!Q.empty()){ 	 	int idx = Q.front(); 	if(idx==sz-1){break;} 	 	Q.pop(); 	 	int val = s[idx]-'0'; 	int size = V[val].size(); 	 	for(int i=0;i<size;i++){ 	   	  int cidx = V[val][i]; 	  if(isvisted[cidx] != true){ 	    Q.push(cidx); 	    d[cidx] = d[idx]+1; 	    isvisted[cidx] = true; 	  }   	} 	V[val].clear(); 	 	if(idx-1 >= 0 && isvisted[idx-1]!=true){ 	  d[idx-1] = d[idx]+1; 	  isvisted[idx-1] = true; 	  Q.push(idx-1); 	} 	 	if(idx+1 < sz && isvisted[idx+1]!=true){ 	   	  d[idx+1] = d[idx]+1; 	  isvisted[idx+1]  = true; 	    Q.push(idx+1); 	} 	    }        cout << d[sz-1] << "\n"; return 0;  }
#include<bits/stdc++.h> using namespace std; class node{   public:     char d;     string road; }; int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         string s;         node *array=new node[n];         getline(cin,s);         for(int i=0;i<n;i++){                          getline(cin,s);             array[i].d=s[0];             if(s[0]=='L'){                 string road;                 for(int j=8;j<s.length();j++){                     road=road+s[j];                 }                 array[i].road=road;             }             else{                 string road;                 for(int j=9;j<s.length();j++){                     road=road+s[j];                 }                 array[i].road=road;             }                      }         cout<<"Begin on "<<array[n-1].road<<endl;         for(int i=n-2;i>=0;i--){             if(array[i+1].d=='L'){                 cout<<"Right on "<<array[i].road<<endl;             }             else{                 cout<<"Left on "<<array[i].road<<endl;             }         }     } }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string s;         cin>>s;         long long n=s.length();         long long count=0;         int dp[123];         for(int i=0;i<123;i++){             dp[i]=0;         }         for(int i=0;i<n;i++){             if(dp[(int)s[i]]==0){                 dp[(int)s[i]]=1;                 count++;             }                      }         cout<<count<<endl;     } }
#include<cstdio> using namespace std; # define MOD 1000000007LL int main() {    long long int t,n,m,dp[105][105],i,j,k,c;     scanf("%lld",&t);     while(t--)     {           scanf("%lld %lld",&n,&m);          long long int x[m+1],y[m+1];          for(i=1;i<=m;i++)          {              scanf("%lld %lld",&x[i],&y[i]);           }            for(i=0;i<=n;i++)          {               dp[1][i]=(i<=y[1] && i>=x[1])?1:0;            }          for(i=2;i<=m;i++)          {              for(j=0;j<=n;j++)              {                  dp[i][j]=0;                   for(k=x[i];k<=y[i] && (j-k>=0);k++)                   {                       dp[i][j]+=(dp[i-1][j-k]);                    }                   dp[i][j] %= MOD;               }           }         printf("%lld\n",dp[m][n]%MOD);       } } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; int S[MAXN]; int parent[MAXN]; int findP(int x){     return (parent[x] == x ? x : parent[x] = findP(parent[x])); } void merge(int x, int y){     int px = findP(x);     int py = findP(y);     if(px != py){         if(S[px] > S[py]){             parent[py] = px;         } else if(S[py] > S[px]){             parent[px] = parent[py];         }     } } int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         for(int i = 1;i <= N;++i){             scanf("%d", &S[i]);             parent[i] = i;         }         int Q;         scanf("%d", &Q);         while(Q--){             int type;             scanf("%d", &type);             if(type == 0){                 int x, y;                 scanf("%d%d", &x, &y);                 if(findP(x) == findP(y)){                     printf("Invalid query!\n");                 } else {                     merge(x, y);                 }             } else{                 int x;                 scanf("%d", &x);                 printf("%d\n", findP(x));             }         }     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  int main(){     int t;     cin >> t;     while(t--){         int N;         string s, ans;         cin >> N;         cin >> s;         ans = s;         for(int i = 0;i < N;++i){             string news = s;             char ch = news[i];             news.erase(news.begin() + i);             for(int j = 0;j < N;++j){                 if(news[j] > ch){                     news.insert(news.begin() + j, ch);                     break;                 }             }             if(news.size() < N)                 news.insert(news.end(), ch);             ans = min(ans, news);             //cout << i << " " << news << "\n";         }         cout << ans << "\n";     }       return 0; } 
#include<bits/stdc++.h> using namespace std;  int main(){ long int n; cin>>n; int gsum=0,lpsum=0; long long int A[n]; for(int i=1;i<=n;i++ ) {     cin>>A[i-1];     lpsum = lpsum+A[i-1];     gsum = gsum + i; }  if(gsum==lpsum)     cout<<"YES"<<endl; else     cout<<"NO"<<endl; return 0;   } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL;  //freq[K] at some index stores the number of numbers which are divisible by k and occuring between 1 and index int freq[100010], u[100010] , v[100010] , K[100010] , A[100010]; std::map< pair<int , int > , int > mpp; std::vector<int > queriesat[100010];    int main() {  int N , Q , j; si(N);si(Q); for(int i=1;i<=N;i++) 	si(A[i]);  for(int i=1;i<=Q;i++) { 	si(u[i]);si(v[i]);si(K[i]); 	mpp[mp(u[i]-1 , K[i])] = 0; 	mpp[mp(v[i] , K[i])] = 0; 	queriesat[(u[i]-1)].pb(K[i]); 	queriesat[(v[i])].pb(K[i]); 	if(u[i]==1) 		mpp[mp(0 , K[i])] = 0; }  memset(freq , 0 , sizeof(freq));  for(int i=1;i<=N;i++) { 	j = 1; 	for(;(j*j)<A[i];j++) 	{ 		if((A[i]%j)==0) 		{ 			freq[(A[i]/j)]++; 			freq[j]++; 		} 	} 	if((j*j)==A[i]) 		freq[j]++; 	for(int k=0;k<queriesat[i].size();k++) 	{ 		// cout << i << "#" << queriesat[i][k] << "###" << freq[queriesat[i][k]] << endl; 		mpp[mp(i , queriesat[i][k])] = freq[queriesat[i][k]]; 	} } int ans; for(int i=1;i<=Q;i++) { 	ans =  mpp[mp(v[i] , K[i])]- mpp[mp(u[i]-1 , K[i])]; 	 	printf("%d\n", ans); }   return 0; }                   
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 100000 #define epsilon 1e-5 #define sd(n) scanf("%lld",&n); ll a[lim+1]; int main() { ll n,m;     ll t;    // freopen("input.txt","r",stdin);     cin>>t;     while(t--)     {     sd(n);     sd(m);     for(ll i=1;i<=m;i++)         scanf("%lld",&a[i]);     sort(a+1,a+m+1);     ll i=1,j=m;     ll ans=0;         while(j>i)     {   //cout<<j<<"  "<<i<<"  "<<a[i]<<endl;             j--;         a[i]--;         if(a[i]==0)             i++;         ans++;     }     printf("%lld\n",ans);             }            }
#include <cstdio> #include <cmath> #include <cstring> #include <cstdlib> #include <ctime> #include <iostream> #include <fstream> #include <sstream> #include <algorithm> #include <string> #include <vector> #include <set> #include <map> #include <list> #include <complex> #pragma comment(linker, "/STACK:266777216") using namespace std;  #define assert(f) { if(!(f)) { fprintf(stderr,"Assertion failed: "); fprintf(stderr,#f); fprintf(stderr,"\n"); exit(1); } }  typedef long long LL; typedef unsigned long long ULL; typedef vector<int> VI; typedef vector<VI> VVI; typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<double> VD; typedef pair<double,double> PDD;  const int inf=1000000000; const LL INF=LL(inf)*inf; const double eps=1e-9; const double PI=2*acos(0.0); #define bit(n) (1<<(n)) #define bit64(n) ((LL(1))<<(n)) #define pb push_back #define sz size() #define mp make_pair #define cl clear() #define all(a) (a).begin(),(a).end() #define fill(ar,val) memset((ar),(val),sizeof (ar)) #define MIN(a,b) {if((a)>(b)) (a)=(b);} #define MAX(a,b) {if((a)<(b)) (a)=(b);} #define sqr(x) ((x)*(x)) #define X first #define Y second  //clock_t start=clock(); //fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));  #define N 111010 PII a[N]; int R[N]; pair<PII,int> b[N]; int ans[N]; int f[N]; int m;  void add(int x,int d) { 	for(;x<=m;x+=x&-x) f[x]+=d; }  int sum(int x) { 	int s=0; 	for(;x>0;x-=x&-x) s+=f[x]; 	return s; }  int main() { #ifndef ONLINE_JUDGE 	freopen("1.in","r",stdin); #endif 	int n; 	scanf("%d",&n); 	{ 		int i,j; 		for(i=0;i<n;i++) 		{ 			scanf("%d%d",&a[i].X,&a[i].Y); 			R[i]=a[i].Y; 		} 		sort(a,a+n); 		sort(R,R+n); 		m=unique(R,R+n)-R; 		int q; 		scanf("%d",&q); 		int len=0; 		for(int it=0;it<q;it++) 		{ 			ans[it]=n; 			int k; 			scanf("%d",&k); 			int t[33]; 			for(j=0;j<k;j++) 				scanf("%d",t+j); 			t[k++]=-inf/2; 			t[k++]=inf/2*3; 			sort(t,t+k); 			k=unique(t,t+k)-t; 			for(i=1;i<k;i++) 				b[len++]=mp(mp(t[i-1]+1,t[i]),it); 		} 		sort(b,b+len); 		fill(f,0); 		i=n-1; 		for(int it=len;it--;) 		{ 			int l=b[it].X.X; 			int r=b[it].X.Y; 			for(;i>=0 && a[i].X>=l;i--) 			{ 				int ind=lower_bound(R,R+m,a[i].Y)-R+1; 				add(ind,1); 			} 			int ind=lower_bound(R,R+m,r)-R; 			ans[b[it].Y]-=sum(ind); 		} 		for(i=0;i<q;i++) 			printf("%d\n",ans[i]); 	} 	return 0; }
#include<iostream> #include<math.h> using namespace std; int main() {  long long t,n,a,b,i,j,x=0,y=0,p;  cin>>t;  while(t--)  { x=0;y=0;    cin>>n>>a>>b;    while(a!=0)    {      i=a%2;      a=a/2;      if(i==1)      x++;    }    while(b!=0)    {      i=b%2;      b=b/2;      if(i==1)      y++;    }    i=0;    if(x+y<=n)    {      for(p=0;p<x+y;p++)      { 	n=n-1; 	i+=pow(2,n);       }     }     else     {     j=(2*n)-(x+y);     for(p=0;p<j;p++)     {     n=n-1;     i+=pow(2,n);     }   }     cout<<i<<"\n";   }   return 0;   } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const int MAXN = 1e6 + 10; LL A[MAXN]; int main(){     int t;     cin >> t;     while(t--){         int N, M;         scanf("%d%d", &N, &M);         for(int i = 1;i <= N;++i)             A[i] = 0;         while(M--){             int w, x, y, z;             scanf("%d%d%d%d", &w, &x, &y, &z);             if(w == 1){                 A[x] += z;                 A[y + 1] -= z;             } else {                 A[x] -= z;                 A[y + 1] += z;             }         }         for(int i = 2;i <= N;++i){             A[i] += A[i - 1];         }         LL mini = 1e18, maxi = -1e18;         for(int i = 1;i <= N;++i){             A[i] += i;             mini = min(mini, A[i]);             maxi = max(maxi, A[i]);         }         printf("%lld\n", maxi - mini);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int arr[100012]; map<char ,int> mp; int visited[200]; int n; string t=""; map<int,int> start , End,kount; set<int> s; set<int>::iterator it; vector<pair<int,int> > v; int main() {     int n,k;     scanf("%d%d",&n,&k);     for(int i=0; i<n; i++)     {         int val;         scanf("%d",&val);         v.push_back(make_pair(val,i));     }     sort(v.begin(),v.end());     int i=0,j=1;     long long ans =0 ;     while(1)     {          while(v[j].first == v[i].first && ((v[j].second - v[i].second + 1)<=k)) j++;         ans++;         i=j;         j++;         if(i>=n) break;     }     printf("%lld\n",ans); } 
#include<iostream> #include<cstdio> #include<vector> typedef long long int ll; using namespace std; vector<ll> adj[50001]; ll visited[50001]={0},flag=0; ll ans1=0,ans2=0,mark[50001]={0},pairs=0;; ll dfs(ll a,ll r) {     //flag=0;     ll i;     for(i=1;i<adj[a].size();i++)     {          if(visited[adj[a][i]]==0)         {             visited[adj[a][i]]=1;             dfs(adj[a][i],a);               //pairs+=pairs+1;         }        /* if(adj[a][0]==1&&adj[a][i]!=-1)     {         mark[a]=1;         mark[adj[a][i]]=1;         //cout<<a<<" "<<r<<endl;         pairs++;     }     else if(adj[a][0]==1&&adj[a][i]==-1)     {          pairs++;         //mark[a]=1;     }*/     if(flag==1)     {         mark[a]=1;         flag=0;     }      }     if(adj[a].size()==2&&adj[a][0]==1&&r!=-1||adj[a][0]==1&&r!=-1)     {         flag=1;         mark[a]=1;        // mark[r]=1;         //cout<<a<<" "<<r<<endl;         pairs++;     }     else if(adj[a][0]==1&&r==-1&&mark[a]==1)     {          pairs++;         //mark[a]=1;     }     else if(mark[a]==1)         flag=1;   } int main() {     ll i,m,n,ab,x,y;      cin>>n>>m;     for(i=1;i<=n;i++)     {         cin>>ab;         adj[i].push_back(ab);     }     for(i=0;i<m;i++)     {         cin>>x>>y;         adj[x].push_back(y);         adj[y].push_back(x);         //visited[x].push_back(y);     }     for(i=1;i<=n;i++)     {           if(adj[i][0]==1&&visited[i]==0)         {             visited[i]=1;             dfs(i,-1);             ans1+=((pairs)*(pairs-1))/ll(2);             pairs=0;         }     }     for(i=1;i<=n;i++)     {         //cout<<mark[i]<<" ";         //cout<<endl;         if(mark[i]==1)             ans2++;     }     cout<<ans1<<" "<<ans2<<endl;     return 0; } 
#include<bits/stdc++.h> using namespace std; int so[100]; int sf[100]; int main(){     int t;     cin >> t;     while(t--){         int N, M;         scanf("%d%d", &N, &M);         for(int i = 1;i <= 100;++i){             so[i] = 0;             sf[i] = 0;         }         while(N--){             int C, L;             scanf("%d%d", &C, &L);             so[L] += C;         }         while(M--){             int C, L;             scanf("%d%d", &C, &L);             sf[L] += C;         }         int ans = 0;         for(int i = 1;i <= 100;++i){             if(sf[i] > so[i])                 ans += sf[i] - so[i];         }         printf("%d\n", ans);     }     return 0; } 
#include <stdio.h> #include <stdlib.h> #include <math.h>  #include <iostream>  typedef long long int llint;  namespace IO {   const int SIZE = 1 << 19;   char buff[SIZE], *p = buff + SIZE;    char read_char ()   {     if (p == buff + SIZE)       { 	fread (buff, 1, SIZE, stdin); 	p = buff;       }     return *(p++);   }    inline llint read_int ()   {     char c;      while (!isdigit (c = read_char ()));      llint r = c - '0';     while (isdigit (c = read_char ()))       r = 10 * r + c - '0';      return r;   } }  using namespace IO;  llint gcd (llint p, llint q) {   if (q > p)     return (gcd (q, p));    if (q == 0)     return (p);    return (gcd (q, p % q)); }   int main () {   int test_cases = read_int ();   while (test_cases--)     {       llint A = read_int ();	// A = pow (10, 18);       llint B = read_int ();	// B = pow (10, 18);       llint C = read_int ();	// C = pow (10, 18);       llint D = read_int ();	// D = pow (10, 18);       llint K = read_int ();	// K = pow (10, 18);       llint gcd1 = gcd (A, B);       llint gcd2 = gcd (C, D);       llint gcd3 = gcd (gcd1, gcd2);       llint res = K / (gcd1 / gcd3) / gcd2;       printf ("%lld\n", 2 * res + 1);     } } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e3 + 10; char board[MAXN][MAXN]; int dp[MAXN][MAXN]; bool knightVis[MAXN][MAXN]; int N; inline void update(int newx, int newy, int x, int y){     if(newx < 1 || newy < 1 || newx > N || newy > N || (!knightVis[newx][newy]))         return ;     dp[x][y] = max(dp[x][y], dp[newx][newy] + (board[x][y] == 'P' ? 1 : 0));     knightVis[x][y] = true; } int main(){     int t;     cin >> t;     while(t--){         scanf("%d", &N);         for(int i = 1;i <= N;++i){             for(int j = 1;j <= N;++j){                 scanf(" %c", &board[i][j]);             }         }         for(int i = 0;i <= N;++i){             for(int j = 0;j <= N;++j){                 dp[i][j] = 0;                 knightVis[i][j] = false;             }         }         for(int j = 1;j <= N;++j){             for(int i = 1;i <= N;++i){                 if(board[i][j] == 'K'){                     knightVis[i][j] = true;                 }             }         }         for(int j = 1;j <= N;++j){             for(int i = 1;i <= N;++i){                 update(i + 2, j - 1, i, j);                 update(i + 1, j - 2, i, j);                 update(i - 1, j - 2, i, j);                 update(i - 2, j - 1, i, j);             }         }         /*         for(int i = 1;i <= N;++i){             for(int j = 1;j <= N;++j){                 cout << board[i][j] << " " ;             }             cout << "\n";         }          for(int i = 1;i <= N;++i){             for(int j = 1;j <= N;++j){                 cout << dp[i][j] << " " ;             }             cout << "\n";         }          for(int i = 1;i <= N;++i){             for(int j = 1;j <= N;++j){                 cout <<  knightVis[i][j] << " " ;             }             cout << "\n";         }*/         int ans = 0;         for(int i = 1;i <= N;++i){             if(knightVis[i][N]){                 ans = max(ans, dp[i][N]);             }         }         printf("%d\n", ans);     }     return 0; } 
#include<iostream> using namespace std; int main() { 	cout << "137=2(2(2)+2+2(0))+2(2+2(0))+2(0)\n"; 	cout << "1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\n"; 	cout << "73=2(2(2)+2)+2(2+2(0))+2(0)\n"; 	cout << "136=2(2(2)+2+2(0))+2(2+2(0))\n"; 	cout << "255=2(2(2)+2+2(0))+2(2(2)+2)+2(2(2)+2(0))+2(2(2))+2(2+2(0))+2(2)+2+2(0)\n"; 	cout << "1384=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2)+2(2(2)+2(0))+2(2+2(0))\n"; 	cout<<"16385=2(2(2+2(0))+2(2)+2)+2(0)\n"; 	return 0; }
#include <bits/stdc++.h> using namespace std; int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n; 		long long k; 		scanf("%d %lld",&n,&k); 		long long x; 		long long packets = 1; 		long long curr = k; 		for(int i=0;i<n;i++) 		{ 			scanf("%lld",&x); 			if(x>curr) 			{ 				x-=curr; 				packets+=(x/k); 				curr = 0; 				if(x%k!=0) 				{ 					packets++; 					curr = k - (x%k)-1; 				} 			} 			else 			{ 				curr-=x; 				curr--; 			} 			//cout<<"Packets : "<<packets<<endl; 			curr = max(0LL,curr); 		} 		printf("%lld\n",packets); 	} }
#include<iostream> #include<cstdio> long long int gcd(long long int a,long long int b) {        long long int t;        while(a)        {               t=a;               a=b%a;               b=t;        }        return b; } int main() {        int T;        long long int n,m,k;        scanf("%d",&T);        while(T--)        {               scanf("%lld%lld",&n,&m);               k=gcd(n,m);               if(k==1)                      printf("Yes\n");               else                      printf("No %lld\n",n/k);        }        return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e4 + 10; int A[MAXN]; int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         for(int i = 0;i <= N;++i){             A[i] = 0;         }         for(int i = 1;i <= N;++i){             int x;             scanf("%d", &x);             ++A[x];         }         int _i = 0;         int _j = N;         int ans = 0;        while(_i + 1 < _j){             while(A[_i] == 0 && _i <= N) ++_i;             while(A[_j] == 0 && _j >= 0) --_j;             if(_i + 1 < _j){                 int matches = min(A[_i], A[_j]);                 int R = (_j - _i + 1) >> 1;                 A[_j] -= matches;                 A[_i] -= matches;                 int idest = _i + R;                 int jdest = _j - R;                 if(A[_j] == 0) --_j;                 if(A[_i] == 0) ++_i;                  A[idest] += matches;                 A[jdest] += matches;                 ans += matches;             }        }        int cnt = 0;        for(int i = 0;i <= N;++i){         cnt += (A[i] == 0?0:1);        }        if(cnt != 1) ans = -1;        printf("%d\n", ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const int MAXN = 1e6 + 10; LL A[MAXN]; int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         LL sum = 0;         for(int i = 1;i <= N;++i){             scanf("%lld", &A[i]);             sum += A[i];         }         sum /= (N - 1);         for(int i = 1;i <= N;++i){             printf("%lld ", sum - A[i]);         }         printf("\n");     }     return 0; } 
#include <bits/stdc++.h> #define ll long long int #define ld long double using namespace std; #include<stdio.h>  int main()  {      int i,j,k,s[35],a[35],t,n,flag,p,temp,m,count;      s[4]=4; s[6]=5; s[8]=12; s[9]=6; s[10]=7; s[12]=16; s[14]=9; s[15]=8; s[16]=32;      s[18]=21; s[20]=24; s[21]=10; s[22]=13; s[24]=44; s[25]=10; s[26]=15; s[27]=27; s[28]=32;      s[30]=31;      s[2]=s[3]=s[5]=s[7]=s[11]=s[13]=s[17]=s[19]=s[23]=s[29]=0;      scanf("%d",&t);      while(t--)      {          scanf("%d",&n);         count=0;         flag=0;         scanf("%d",&a[0]);         for(i=1;i<n;++i)         {            scanf("%d",&a[i]);            if(a[i]!=a[i-1]) flag=1;         }         flag=1;         if(flag==0)         {           printf("0\n");         }         else         {             if(s[n]==0)             {                printf("%d\n",1);                printf("%d ",n);                for(i=1;i<=n;++i)                {                  printf("%d ",i);                }                printf("\n");             }             else             {                 printf("%d\n",s[n]);                 k=n;                 for(p=29;p>=2;p--)                 {                     if(s[p]==0 && k%p==0)                     {                               temp=p;                               k=k/p;                               break;                     }                 }                 for(i=0;i<k;++i)                 {                    printf("%d ",p);                    for(j=i*p;j<(i+1)*p;++j)                    {                        printf("%d ",j+1);                     }                    printf("\n");                 }                 for(i=p;i>=2;--i)                 {                    if(s[i]==0 && k%i==0  && k>1)                    {                        for(j=1;j<=30;++j) a[j]=0;                       for(j=1;j<=n;++j)                       {                          if(a[j]==0)                          {                             printf("%d ",i);                             for(m=0;m<i;++m)                             {                                printf("%d ",j+m*temp);                                a[j+m*temp]=1;                              }                             printf("\n");                          }                       }                       temp=temp*i;                       k=k/i;                       ++i;                     }                 }             }         }       } return 0; } 
#include <iostream> #include <algorithm> #include <cstdio> #include <queue> #include <math.h> #include <limits.h> #include <cstdlib> #include <string.h> #include <vector> #include <map> #include <stack> using namespace std; //prankuragarwal #define ll         long long #define S(x)       scanf("%d", &x) #define Sl(x)      scanf("%lld", &x) #define Sd(x)      scanf("%lf", &x) #define P(x)       printf("%d\n", x) #define Pl(x)      printf("%lld\n", x) #define Pd(x)      printf("%lf\n", x) #define Pblank()   printf(" ") #define mem(x,y)   memset(x,y,sizeof(x)) #define F(x,y,z,i) for (x = y; x < z; x = x + i) #define mod 1000000007  int main() { 	ll int t; 	Sl(t); 	while (t--)     { 		ll int n, a, b, c;         ll int ans=0;         ll int i, j; 		Sl(n); Sl(a); Sl(b); Sl(c); 		for (i = 0; i <= a; i++)         { 			for (j = 0; j <= b && j <= (n - i); j++){ 				ans += (n - (i + j) > c) ? (c + 1) : (n - (i + j) + 1); 			} 		} 		Pl(ans); 	} } 
#include<bits/stdc++.h> #include<string.h> using namespace std; int main() {   int t,i;   char n[100001];   char chr[4]="010";   char chr2[4]="101";   scanf("%d",&t);   while(t--)   {       scanf("%s",n);     if(strstr(n,chr) || strstr(n,chr2))        printf("Good\n");       else printf("Bad\n");   }   return 0; } 
#include <cstdio> #include <vector> //hashdefs  using namespace std;   int anses[17][41] = { { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 2 , 3 , 3 , 3 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 3 , 6 , 8 , 8 , 7 , 4 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 4 , 10 , 17 , 21 , 21 , 21 , 13 , 10 , 6 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 5 , 15 , 30 , 45 , 54 , 54 , 49 , 46 , 21 , 3 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 6 , 21 , 49 , 87 , 121 , 145 , 145 , 145 , 121 , 92 , 56 , 33 , 20 , 14 , 7 , 3 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 7 , 28 , 74 , 148 , 238 , 324 , 367 , 367 , 320 , 258 , 188 , 122 , 69 , 37 , 12 , 6 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 8 , 36 , 108 , 252 , 454 , 706 , 898 , 1039 , 1039 , 1039 , 869 , 674 , 473 , 309 , 216 , 126 , 66 , 34 , 18 , 8 , 5 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 9 , 45 , 150 , 375 , 750 , 1200 , 1713 , 2227 , 2492 , 2492 , 2225 , 2041 , 1575 , 1132 , 770 , 571 , 335 , 180 , 90 , 44 , 18 , 12 , 6 , 3 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 10 , 55 , 202 , 560 , 1232 , 2278 , 3574 , 4959 , 6074 , 6709 , 6709 , 6709 , 5703 , 4493 , 3294 , 2217 , 1468 , 872 , 514 , 282 , 143 , 65 , 28 , 14 , 7 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 11 , 66 , 264 , 792 , 1900 , 3800 , 6514 , 9772 , 13030 , 15471 , 16799 , 16799 , 15652 , 13418 , 10748 , 8079 , 5688 , 3774 , 2381 , 1435 , 817 , 445 , 226 , 108 , 45 , 20 , 3 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 12 , 78 , 338 , 1105 , 2874 , 6278 , 11660 , 19068 , 27607 , 36136 , 42702 , 46610 , 46610 , 46610 , 41294 , 33796 , 25982 , 18892 , 13103 , 8577 , 5356 , 3162 , 1743 , 944 , 470 , 250 , 126 , 63 , 25 , 10 , 4 , 2 , 2 , 2 , 1 , 0 , 0 , 0 , 0 , 0 } ,  { 0 , 13 , 91 , 424 , 1484 , 4154 , 9707 , 19414 , 29121 , 42063 , 59159 , 75615 , 88747 , 95597 , 95597 , 89036 , 80204 , 65867 , 51176 , 37661 , 26428 , 17759 , 11353 , 6821 , 4096 , 2220 , 1165 , 605 , 310 , 139 , 69 , 27 , 10 , 6 , 2 , 1 , 1 , 1 , 1 , 1 , 0 } ,  { 0 , 14 , 105 , 525 , 1995 , 5985 , 15960 , 34199 , 64409 , 107154 , 171563 , 233954 , 296371 , 342124 , 368134 , 368134 , 368134 , 324876 , 281553 , 222037 , 171005 , 122130 , 84431 , 54937 , 34827 , 20907 , 12333 , 7023 , 3880 , 2057 , 1167 , 564 , 260 , 129 , 62 , 20 , 7 , 1 , 1 , 0 , 0 } ,  { 0 , 15 , 120 , 640 , 2560 , 8192 , 21888 , 50030 , 100060 , 178236 , 285074 , 414662 , 554018 , 681778 , 779164 , 831886 , 831886 , 782347 , 701717 , 591178 , 473607 , 361604 , 263114 , 183069 , 121870 , 78013 , 48065 , 28497 , 16204 , 8852 , 4742 , 2457 , 1216 , 565 , 259 , 124 , 46 , 21 , 10 , 3 , 0 } };  //vector<ll> lists[100];  void work() {   int b, d;   scanf("%d %d", &b, &d);   int ans;   if(d > 40) ans = 0;   else ans = anses[b][d];   printf("%d\n", ans); }  int main() {     int T;   scanf("%d", &T);   while(T--) work();    return 0; } 
 #include <iostream>  using namespace std;  const int MAX_H = 10000; const int MAX_M = 500;  struct Height { public:     Height()     {}          Height(int _height, int _freq)         : height(_height)         , freq(_freq)     {}          int height;     int freq; };  class World { public:     World(int _M, int _N, int _K)         : M(_M)         , N(_N)         , K(_K)     {}          void read()     {         for (int row = 0; row < M; ++row)             for (int col = 0; col < N; ++col)                 cin >> heights[row][col];     }          void init()     {         for (int row = 0; row <= M - K; ++row)             for (int col = 0; col < N; ++col)                 initColumn(row, col);         //print();     }          Height getMax(int row, int col) const     {         int max = -1;         int freq = 0;         for (int i = 0; i < K; ++i)         {             if (colMax[row][col + i].height > max)             {                 max = colMax[row][col + i].height;                 freq = colMax[row][col + i].freq;             }             else if (colMax[row][col + i].height == max)             {                 freq += colMax[row][col + i].freq;             }         }         return Height(max, freq);     }          int getM() const {         return M;     }          int getN() const {         return N;     }          int getK() const {         return K;     }  private:     void initColumn(int row, int col)     {         int max = -1;         int freq = 0;         for (int i = 0; i < K; ++i)         {             if (heights[row+i][col] > max)             {                 max = heights[row+i][col];                 freq = 1;             }             else if (heights[row+i][col] == max)             {                 freq++;             }         }         colMax[row][col] = Height(max, freq);     }          void print()     {         for (int row = 0; row <= M - K; ++row)         {             for (int col = 0; col < N; ++col)                 cout << colMax[row][col].height << ' ';             cout << endl;         }     }      int M, N, K;     Height colMax[MAX_M+1][MAX_M+1];     int heights[MAX_M+1][MAX_M+1]; };  class Solver { public:     Solver(World& _world)         : world(_world)     {}          void solve()     {         world.init();         for (int i = 0; i <= world.getM() - world.getK(); ++i)         {             //cout << "solve row: " << i << endl;             solve(i);         }         cout << endl;     }      private:     void solve(int row)     {         for (int i = 0; i <= world.getN() - world.getK(); ++i)         {             const Height& h = world.getMax(row, i);             print(h);             cout << ' ';         }             cout << endl;     }          void print(const Height& h)     {         cout << h.height;         if (h.freq > 1)             cout << '(' << h.freq << ')';     }          World& world; };  int main() {     ios_base::sync_with_stdio(0);     int T; cin >> T;     for (int i = 0; i < T; ++i)     {         cout << "Case " << i+1 << ":" << endl;         int M, N, K;         cin >> M >> N >> K;         World world(M, N, K);         world.read();         Solver solver(world);         solver.solve();      }     return 0; } 
#include<bits/stdc++.h> #include<algorithm> #include<vector> #include<utility> #define MOD 1000000009 using namespace std; bool comp( pair<char, int> i, pair<char, int>j) {     return i.second < j.second; } int main(){     ios_base::sync_with_stdio(false);     int t;     cin>>t;      while(t--)     {          long long ans=1;         int n,m;         cin>>n>>m; 	vector<pair<char,int> > v; 	v.resize(m);  	for(int i=0;i<m;i++)     {         char a;int b;         cin>>v[i].first>>v[i].second;         }       sort(v.begin(),v.end(),comp);     for(int i=1;i<m;i++)         {             if(v[i].first!=v[i-1].first)                 ans*=v[i].second-v[i-1].second;             ans%=MOD;          }         cout<<ans<<endl;     }  } 
#include<bits/stdc++.h> using namespace std;  typedef long long LL; const LL MOD = 1e9 + 7; const int MAXN = 1e3 + 10;  LL dp[MAXN][12]; int main(){     for(int j = 1;j <= 10;++j){         LL p = j;         dp[0][j] = 0;         for(int i = 1;i < MAXN;++i){             dp[i][j] = (p - dp[i - 1][j] + MOD) % MOD;             p = (p * j) % MOD;         }     }     int t;     cin >> t;     while(t--){         int N, K;         cin >> N >> K;         cout << dp[N - 1][K] << "\n";     }      return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; const int INF = 1e8; int s[MAXN]; int f[MAXN]; int p[MAXN]; vector<vector<int> > compart(MAXN); int main(){     int t;     cin >> t;     while(t--){         int N, K;         scanf("%d%d", &N, &K);         set<int> Ks;         for(int i = 1;i <= N;++i){             compart[i].clear();             scanf("%d%d%d", &s[i], &f[i], &p[i]);             Ks.insert(p[i]);         }         map<int, int> revKs;         int _i = 1;         for(set<int> :: iterator it = Ks.begin();it != Ks.end();++it){             revKs[*it] = _i;             _i += 1;         }         for(int i = 1;i <= N;++i){             p[i] = revKs[p[i]];             compart[p[i]].push_back(i);         }         int ans = 0;         K = Ks.size();         for(int i = 1;i <= K;++i){             vector<pair<int, int> > inout;             int sz = compart[i].size();             for(int j = 0;j < sz;++j){                  inout.push_back(make_pair(f[compart[i][j]], s[compart[i][j]]));             }             sort(inout.begin(), inout.end());             vector<int> curAns(inout.size(), 0);             for(int j = 0;j < sz;++j){                 pair<int, int> pp = make_pair(inout[j].second, INF);                 int x = lower_bound(inout.begin(), inout.end(), pp) - inout.begin();                 int val = (x == 0?0:curAns[x - 1]);                 curAns[j] = max((j == 0?0:curAns[j - 1]), val + 1);             }             if(sz > 0)                 ans += curAns[sz - 1];         }         printf("%d\n", ans);     }     return 0; } 
#include<bits/stdc++.h> #define ll long long int #define mp make_pair #define pb push_back #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define s(x) scanf("%lld",&x) #define p(x) printf("%lld\n",x)  using namespace std; const ll M = 1000000007; /*map<ll, ll> F;  ll f(ll n) { 	if (F.count(n)) return F[n]; 	long k=n/2; 	if (n%2==0) { 		return F[n] = (f(k)*f(k) + f(k-1)*f(k-1)) % M; 	} else { 		return F[n] = (f(k)*f(k+1) + f(k-1)*f(k)) % M; 	} }*/ void fib(ll n,ll &x,ll &y){   ll temp = 0;   if(n==0){       x=0;y=1;       return;   }   if(n==1){       x=1;y=1;       return;   }   fib(n/2,x,y);   if(!(n&1)){       temp = x;       x = (((2*y-x+M)%M)*x)%M;       y = (temp*temp+y*y)%M;   }   else{       temp = x;       x = (x*x + y*y)%M;       y = (x + (((2*y-temp+M)%M)*temp)%M)%M;   } }   ll f(ll n){     ll x,y;     fib(n,x,y);     return x; }  int a[100002]; ll tree[400002][3]; struct entry{     ll a1,a2,a3; };  void build(int l,int r,int i){     if(l == r){          tree[i][0] = f(a[l]);         tree[i][1] = f(a[l]-1);         tree[i][2] = f(a[l]+1);         return;     }      int m = l+(r-l)/2;     build(l,m,2*i);     build(m+1,r,2*i+1);      tree[i][0] = ((tree[2*i][0] + tree[2*i+1][0])%M + ((tree[2*i][0]*tree[2*i+1][1])%M + (tree[2*i][2]*tree[2*i+1][0])%M)%M)%M;     tree[i][1] = ((tree[2*i][1] + tree[2*i+1][1])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][1]*tree[2*i+1][1])%M)%M)%M;     tree[i][2] = ((tree[2*i][2] + tree[2*i+1][2])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][2]*tree[2*i+1][2])%M)%M)%M;  }  void update(int s,int e,int l,int val,int i){     if(s>l || e<l) return;     if(s==e && l==e){         a[l] = val;         tree[i][0] = f(val);         tree[i][1] = f(val-1);         tree[i][2] = f(val+1);         return;     }      int m = s+(e-s)/2;     update(s,m,l,val,2*i);     update(m+1,e,l,val,2*i+ 1);       tree[i][0] = ((tree[2*i][0] + tree[2*i+1][0])%M + ((tree[2*i][0]*tree[2*i+1][1])%M + (tree[2*i][2]*tree[2*i+1][0])%M)%M)%M;     tree[i][1] = ((tree[2*i][1] + tree[2*i+1][1])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][1]*tree[2*i+1][1])%M)%M)%M;     tree[i][2] = ((tree[2*i][2] + tree[2*i+1][2])%M + ((tree[2*i][0]*tree[2*i+1][0])%M + (tree[2*i][2]*tree[2*i+1][2])%M)%M)%M; }  entry query(int s,int e,int l,int r,int i){     entry ans;     if(e<l || r<s){         ans.a1 = ans.a2 = ans.a3 = 0;         return ans;     }     if(l <= s && e <= r){         ans.a1 = tree[i][0];         ans.a2 = tree[i][1];         ans.a3 = tree[i][2];         return ans;     }      int m = s+(e-s)/2;      entry q1 = query(s,m,l,r,2*i);     entry q2 = query(m+1,e,l,r,2*i+1);      ans.a1 = ans.a2 = ans.a3 = 0;     ans.a1 = (ans.a1 + q1.a1)%M;     ans.a1 = (ans.a1 + q2.a1)%M;     ans.a1 = (ans.a1 + q1.a1*q2.a2)%M;     ans.a1 = (ans.a1 + q1.a3*q2.a1)%M;      ans.a2 = (ans.a2 + q1.a1*q2.a1)%M;     ans.a2 = (ans.a2 + q1.a2*q2.a2)%M;     ans.a2 = (ans.a2 + q1.a2 + q2.a2)%M;      ans.a3 = (ans.a3 + q1.a1*q2.a1)%M;     ans.a3 = (ans.a3 + q1.a3*q2.a3)%M;     ans.a3 = (ans.a3 + q1.a3 + q2.a3)%M;      return ans; }  int main(){     int n,q,x,y;     char c;     si(n);si(q);     for(int i=1;i<=n;i++){         si(a[i]);     }     build(1,n,1);     while(q--){         scanf(" %c",&c);         if(c == 'C'){             si(x);si(y);             update(1,n,x,y,1);         }         else{             si(x);si(y);             p(query(1,n,x,y,1).a1);         }     }     return 0; } 
#include <vector> #include <set> #include <iostream> using namespace std;   int T, n, s, t;   // neighbours[5] contains all the neighbours of 5 vector<int> neighbours[10005];   set<int> important;   bool f( int this_node, int parent_node ) {     bool is_special = (important.find( this_node ) != important.end());          if( is_special )         return true;       int count = 0;     for( int i = 0; i < neighbours[this_node].size(); i++ ) {         if( neighbours[this_node][i] == parent_node )             continue;         count += ( f( neighbours[this_node][i], this_node ) ) ? 1 : 0;     }                          if( count <= 1 )         return false;     else         return true;      }   int main() { 	cin >> T; 	 	while( T-- ) { 	    cin >> n >> s >> t; 	     	    for( int i = 0; i <= n; i++ ) 	        neighbours[i].clear(); 	     	    important.clear(); 	     	    for( int i = 1; i <= n; i++ ) { 	         	        int ci, temp; 	        cin >> ci; 	        while( ci-- ) { 	            cin >> temp; 	            neighbours[i].push_back( temp ); 	        } 	         	    } 	     	    for( int i = 0; i < t; i++ ) { 	        int temp; 	        cin >> temp; 	        important.insert( temp ); 	    } 	     	    // do it now 	    cout << (f( s, -1 ) ? "no\n" : "yes\n"); 	     	} 	 	return 0; }  
#include<bits/stdc++.h> using namespace std; class node{     public:         long long parent;         long long n; }; int find(node *array,int i){     if(array[i].parent==i){         return i;     }     else{         return find(array,array[i].parent);     } } void union1(node *array,int i,int j){         int iroot=find(array,i);         int jroot=find(array,j);         if(iroot<jroot){             array[jroot].parent=iroot;             array[iroot].n+=array[jroot].n;         }         else{             array[iroot].parent=jroot;             array[jroot].n+=array[iroot].n;         }               } int main(){     int t;     cin>>t;     while(t--){         long long n,m;         cin>>n>>m;         node *array=new node[n+1];         for(int i=1;i<=n;i++){             array[i].parent=i;             array[i].n=1;         }         for(int i=0;i<m;i++){             long long k,j;             cin>>k>>j;             if(find(array,k)!=find(array,j)){                 union1(array,k,j);             }         }         long long number=0;         long long ways=1;         for(int i=1;i<n+1;i++){             if(find(array,i)==i){                 number=number+1;                 ways=(ways*((array[i].n)%1000000007))%1000000007;             }         }         cout<<number<<" "<<ways<<endl;     } }
#include <cstdio>  #include<algorithm> using namespace std;   const int MAXN = 10000; const double EPS = 1e-8;   double a[MAXN];   bool solvable(int n, double t, double d) {   double x = max(a[0]-d,0.0);      for (int i = 1; i < n; ++i) {     if (a[i]+d<x+t) return false;     x = max(a[i]-d,x+t);   }   return true; }   int main() {   int cnum;   scanf("%d", &cnum);   while (cnum--) {     int n;     double t;     scanf("%d%lf", &n, &t);     for (int i = 0; i < n; ++i) scanf("%lf", &a[i]);     double lo = 0, hi = 1;     while (!solvable(n, t, hi)) hi *= 2;     while (lo+EPS<hi) {       double mid = (lo+hi)/2;       if (solvable(n,t,mid)) hi = mid;       else lo = mid;     }     printf("%.4lf\n", lo);   } }
#include<bits/stdc++.h> using namespace std; int n; long long w,l; long long h[100005]; long long r[100005]; long long maxi=-1; long long mini=1E16; int main() { 	scanf("%d %lld %lld",&n,&w,&l); 	int i,j; 	long long low,high,mid; 	for(i=0;i<n;i++) 	scanf("%lld %lld",&h[i],&r[i]); 	for(i=0;i<n;i++) 	mini=min(mini,h[i]); 	for(i=0;i<n;i++) 	maxi=max(maxi,r[i]); 	low=0; 	long long x; 	long long co=0; 	high=((w-mini)/maxi)+1; 	high=1000000; 	high=high*high; 	high=high*1000000; 	long long ans=1E18; 	while(low<=high) 	{ 		co=0; 		mid=low+(high-low)/2; 		for(i=0;i<n;i++) 		{ 			x=h[i]+mid*r[i]; 			if(x>=l) 			co+=x; 			if(co>=w) 			break; 		} 		if(co>=w) 		{ 			ans=min(ans,mid); 			high=mid-1; 		} 		else 		{ 			low=mid+1; 		} 	} 	printf("%lld\n",ans); 	return 0; }  
#include<bits/stdc++.h> using namespace std;  char con[256]; int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		for(int i = 0;i < 256;++i) 			con[i] = i; 		int Q; 		scanf("%d", &Q); 		while(Q--){ 			char src, des; 			scanf(" %c %c", &src, &des); 			con[src] = des; 		} 		string s; 		cin >> s; 		int N = s.size(); 		for(int i = 0;i < N;++i) 			s[i] = con[s[i]]; 		string ans = ""; 		bool haveDot = false; 		int cntZeroes = 0; 		for(int i = 0;i < N;++i){ 			haveDot |= (s[i] == '.'); 			cntZeroes += (s[i] == '0'?1:0); 		} 		if((haveDot && cntZeroes == N - 1) || ((!haveDot) && cntZeroes == N)){ 			ans = "0"; 		} else if(haveDot){ 			int _i = 0; 			while(s[_i] == '0') 				++_i; 			while(s[N - 1] == '0'){ 				s.erase(N - 1); 				--N; 			} 			if(s[N - 1] == '.'){ 				s.erase(N - 1); 				--N; 			} 			ans = s.substr(_i); 		} else { 			int _i = 0; 			while(s[_i] == '0') 				++_i; 			ans = s.substr(_i); 		} 		cout << ans << "\n"; 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; int main() { 	int t;cin>>t; 	while(t--) 	{ 		long long int T1,T2,t1,t2; 		//cin>>T1>>T2>>t1>>t2; 		scanf("%lld%lld%lld%lld",&T1,&T2,&t1,&t2); 		float s1=0,s2=0,s3=0,s4=0,ans=0,sum=0; 		if(t1==0 && t2==0) 			printf("0.000000\n"); 		else 		{ 			if(T1>T2) 			{ 				swap(T1,T2); 				swap(t1,t2); 			} 			if(T1>=t2)//tri always 			{ 				s1=(T1-t2)/(float)T1; 				s1=s1*(T1-t2)/(float)T2; 				s1=s1*0.5; 				sum=sum+s1;  				/*s1=((T1-t2)*(T1-t2))*0.5;*/  			} 			if(T2>T1+t1)//with rect 			{ 				 				s2=T1/(float)T2; 				s2=s2*0.5;  				//sum+=s2;  				s3=(T2-(T1+t1))/(float)T2; 				sum=sum+s2+s3; 				/*s2=(T1*T1)*0.5; 				s3=(T2-(T1+t1))*T1; 				sum=s1+s2+s3; 				sum=sum/(double)(T1*T2);*/ 				 			}	 			else//without rect 			{ 				if(T2>=t1) 				{ 					s4=(T2-t1)/(float)T1; 					s4=s4*(T2-t1)/(float)T2; 					s4=s4*0.5; 					 					sum=sum+s4; 					/*s4=(T2-t1)*(T2-t1)*0.5; 					sum=s1+s4; 					sum=sum/(double)(T1*T2);*/ 					 				} 			} 			ans=1-sum; 			printf("%0.6f\n",ans); 		} 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; #define lli long long int #define f(i,a,b) for(i=a;i<b;i++) #define si(a) scanf("%d",&a); #define slli(a) scanf("%lld",&a); #define MOD 1000000007 #define MAX 100005 #define pb(a) push_back(a) #define sn struct node sn{ 	lli data,index,owner; }; sn arr[MAX],brr[MAX]; int fun(sn a,sn b) { 	if(a.data < b.data) 		return 1; 	else 		return 0; } int main() { 	lli i,j,k,m,n,t,ans,a,b,p; 	slli(n); 	slli(p); 	slli(k);  	f(i,1,n+1) 	{ 		slli(arr[i].data); 		arr[i].owner=-1; 		arr[i].index=i;  		brr[i]=arr[i]; 	}  	sort(brr+1,brr+n+1,fun);      arr[brr[1].index].owner=brr[i].data;      f(i,2,n+1)     {     	if((brr[i].data-brr[i-1].data)<=p)     		arr[brr[i].index].owner=arr[brr[i-1].index].owner;      	else     		arr[brr[i].index].owner=brr[i].data;     }    // f(i,1,n+1) //cout<<arr[i].data<<" "<<arr[i].index<<" "<<arr[i].owner<<endl;     while(k--)     {     	slli(a);     	slli(b);      	if(arr[a].owner == arr[b].owner)     		printf("Yes\n");      	else     		printf("No\n");     } } 
#include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cassert> #include <string> #include <vector> #include <algorithm> #include <set> #include <map> #include <stack> #include <queue> #include <cstdlib> using namespace std;   #define s(T) scanf("%d", &T) #define sl(T) scanf("%lld", &T) #define fill(a, val) memset(a, val, sizeof(a)) #define mp make_pair #define pb push_back #define all(x) x.begin(), x.end() #define DREP(x) sort(all(x)); x.erase(unique(all(x)), x.end()) #define INDEX(a, val) (lower_bound(all(a), val) - a.begin())   const int maxS = 1000;   int totalCases, testNum; int S, N, M, K; double Comb[maxS + 1][maxS + 1];   void preprocess() { 	fill(Comb, 0); 	for(int i = 0; i <= maxS; i++) 	{	 		Comb[i][0] = Comb[i][i] = 1.0; 		for(int j = 1; j <i; j++) 			Comb[i][j] = Comb[i-1][j] + Comb[i-1][j-1]; 	} }   bool input() { 	s(S); assert (1 <= S && S <= 1000); 	s(N); assert (1 <= N && N <= S); 	s(M); assert (1 <= M && M <= S); 	s(K); assert (0 <= K && K <  M); 	return true; }   void solve() { 	double num = 0, den = Comb[S-1][N-1]; 	for(int k = max(K, N-1 + M-S); k <= min(N-1, M-1); k++) 		num += Comb[M-1][k] * Comb[S-M][N-1-k]; 	printf("%.6lf\n", num/den); }   int main() { 	preprocess(); 	s(totalCases); assert(totalCases <= 100); 	for(testNum = 1; testNum <= totalCases; testNum++) 	{ 		if( !input()) 			break; 		solve(); 	} }  
#include<bits/stdc++.h> using namespace std;  typedef pair<int,int> II; typedef vector< II > VII; typedef vector<int> VI; typedef vector< VI > VVI; typedef long long int ll;  #define PB push_back #define MP make_pair #define F first #define S second #define SZ(a) (int)(a.size()) #define ALL(a) a.begin(),a.end() #define SET(a,b) memset(a,b,sizeof(a))  #define si(n) scanf("%d",&n) #define dout(n) printf("%d\n",n) #define sll(n) scanf("%lld",&n) #define lldout(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)  #define TRACE  #ifdef TRACE #define trace(...) __f(#__VA_ARGS__,__VA_ARGS__) /*template <typename Arg1> void __f(const char * name, Arg1&& arg1){     cerr << name << " : " << arg1 << std::endl; } template <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args){     const char* comma = strchr(names + 1,',');cerr.write(names,comma - names) << " : " << arg1<<" | ";__f(comma+1,args...); }*/ #else #define trace(...) #endif int max(int p,int q) {     return (p>q)?p:q; }  int min(int p,int q) {     return (p<q)?p:q; }  VI head[100005],con[100005]; int n,vis[100005],p[100005],n1,a[100005];  void dfs(int tmp,int j) {     int i;     con[j].PB(tmp);     vis[tmp]=1;     for(i=0;i<SZ(head[tmp]);i++)     {         if(vis[head[tmp][i]]==0)         {             dfs(head[tmp][i],j);         }     } }  int findcon() {     int j,i;     j=0;     for(i=0;i<n;i++)     {         if(vis[i]==0)         {             dfs(i,j);             j++;         }     }     //dout(j);     return j; }  int find_set(int tmp1) {     if(tmp1==p[tmp1])     {         return tmp1;     }     return p[tmp1]=find_set(p[tmp1]); }  void union_set(int tmp1,int tmp2) {     tmp1=find_set(tmp1);     tmp2=find_set(tmp2);     if(tmp1!=tmp2)     {         if(a[tmp1]>=0 && a[tmp2]>=0)         {             if(a[tmp1]>a[tmp2])             {                 p[tmp1]=tmp2;             }             else             {                 p[tmp2]=tmp1;             }         }         else if(a[tmp1]>=0)         {             p[tmp2]=tmp1;         }         else if(a[tmp2]>=0)         {             p[tmp1]=tmp2;         }         else         {             p[tmp1]=tmp2;         }     } }  int main() {     int m,i,tmp1,tmp2,j,tmp,ans;     si(n);     si(m);     SET(vis,0);     for(i=0;i<m;i++)     {         si(tmp1);         si(tmp2);         head[tmp1-1].PB(tmp2-1);         head[tmp2-1].PB(tmp1-1);     }     for(i=0;i<n;i++)     {         si(a[i]);         p[i]=i;     }     n1=findcon();    // dout(n1);     for(i=0;i<n1;i++)     {         //cout << con[i][0] << " ";         for(j=1;j<SZ(con[i]);j++)         {             union_set(con[i][j],con[i][j-1]);           //  cout << con[i][j] << " ";         }     //    dout(i);         //cout << endl;     }     ans=0;     //dout(con[i][0]);    /* tmp1=find_set(con[0][0]);   //  dout(tmp1);     if(a[tmp1]<0)     {         ans=-1;     }     else     {         for(i=1;i<n1;i++)         { //            printf("***%d\n",i);             tmp=find_set(con[i][0]);             //dout(tmp);             if(a[tmp]<0)             {                 ans=-1;                 break;             }             else             {                 tmp1=find_set(tmp1);                 union_set(tmp1,tmp);                 ans+=a[tmp];                 ans+=a[tmp1];             }             //cout << i << " " << ans << endl;         }     }*/     int flag=1;     tmp1=INT_MAX;     for(i=0;i<n1;i++)     {         tmp=find_set(con[i][0]);         if(a[tmp]<0)         {             flag=0;             ans=-1;             break;         }         else         {             ans+=a[tmp];             tmp1=min(tmp1,a[tmp]);         }     }     if(flag==1)     {         ans=ans+(n1-2)*tmp1;     }     if(n1==1)     {         ans=0;     }     dout(ans);     return 0; }  
#include <algorithm> #include <functional> #include <numeric> #include <iostream> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <cassert> #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <bitset> #include <sstream>  using namespace std;  #define fore(i, l, r) for(int i = (l); i < (r); ++i) #define forn(i, n) fore(i, 0, n) #define fori(i, l, r) fore(i, l, (r) + 1) #define sz(v) int((v).size()) #define all(v) (v).begin(), (v).end() #define pb push_back #define mp make_pair #define X first #define Y second  #if ( _WIN32 || __WIN32__ )     #define LLD "%I64d" #else     #define LLD "%lld" #endif  typedef long long li; typedef long double ld; typedef pair<int, int> pt;  template<typename T> T abs(T a) { return a < 0 ? -a : a; } template<typename T> T sqr(T a) { return a*a; }  const int INF = (int)1e9; const ld EPS = 1e-9; const ld PI = 3.1415926535897932384626433832795;  /*      This is just to check correctness of input  */ void ensure(bool value){     if(!value){         fprintf(stderr, "Assertion failed");         throw;     } } void ensure(bool value, string message){     if(!value){         fprintf(stderr, "Assertion failed. Message = %s", message.c_str());         throw;     } } int readInt(int l, int r){     int x;     if(scanf("%d", &x) != 1){         fprintf(stderr, "Expected int in range [%d, %d], but haven't found!", l, r);         throw;     }     if(!(l <= x && x <= r)){         fprintf(stderr, "Expected int in range [%d, %d], but found %d!", l, r, x);         throw;     }     return x; } int readInt(int l, int r, string name){     int x;     if(scanf("%d", &x) != 1){         fprintf(stderr, "Expected int %s in range [%d, %d], but haven't found!", name.c_str(), l, r);         throw;     }     if(!(l <= x && x <= r)){         fprintf(stderr, "Expected int %s in range [%d, %d], but found %d!", name.c_str(), l, r, x);         throw;     }     return x; } li readLong(li l, li r){     li x;     if(scanf(LLD, &x) != 1){         fprintf(stderr, "Expected long long in range ["LLD", "LLD"], but haven't found!", l, r);         throw;     }     if(!(l <= x && x <= r)){         fprintf(stderr, "Expected long long in range ["LLD", "LLD"], but found "LLD"!", l, r, x);         throw;     }     return x; } li readLong(li l, li r, string name){     li x;     if(scanf(LLD, &x) != 1){         fprintf(stderr, "Expected long long %s in range ["LLD", "LLD"], but haven't found!", name.c_str(), l, r);         throw;     }     if(!(l <= x && x <= r)){         fprintf(stderr, "Expected long long %s in range ["LLD", "LLD"], but found "LLD"!", name.c_str(), l, r, x);         throw;     }     return x; } const ld __EPS__ = 1e-15; ld readDouble(double l, double r){     double x;     if(scanf("%lf", &x) != 1){         fprintf(stderr, "Expected double in range [%lf, %lf], but haven't found!", l, r);         throw;     }     if(!(l <= x + __EPS__ && x <= r + __EPS__)){         fprintf(stderr, "Expected double in range [%lf, %lf], but found %lf!", l, r, x);         throw;     }     return x; } ld readDouble(double l, double r, string name){     double x;     if(scanf("%lf", &x) != 1){         fprintf(stderr, "Expected double %s in range [%lf, %lf], but haven't found!", name.c_str(), l, r);         throw;     }     if(!(l <= x + __EPS__ && x <= r + __EPS__)){         fprintf(stderr, "Expected double %s in range [%lf, %lf], but found %lf!", name.c_str(), l, r, x);         throw;     }     return x; } const int __MAXBUF__ = (int)1e7; char __buf__[__MAXBUF__]; string readString(char lfc, char rgc, int lfn, int rgn){     ensure(scanf(" %s ", __buf__) == 1, "Expected string, haven't found");     string ans = __buf__;     ensure(lfn <= sz(ans) && sz(ans) <= rgn, "String have incorrect length");     forn(i, sz(ans))         ensure(lfc <= ans[i] && ans[i] <= rgc, "String contains incorrect characters");     return ans; } string readString(string pat, int lfn, int rgn){     ensure(scanf(" %s ", __buf__) == 1, "Expected string, haven't found");     string ans = __buf__;     ensure(lfn <= sz(ans) && sz(ans) <= rgn, "String have incorrect length");     forn(i, sz(ans))         ensure(find(all(pat), ans[i]) != pat.end(), "String contains incorrect characters");     return ans; } string readString(char lfc, char rgc, int lfn, int rgn, string name){     ensure(scanf(" %s ", __buf__) == 1, "Expected string " + name + ", haven't found");     string ans = __buf__;     ensure(lfn <= sz(ans) && sz(ans) <= rgn, "String " + name + " have incorrect length");     forn(i, sz(ans))         ensure(lfc <= ans[i] && ans[i] <= rgc, "String " + name + " contains incorrect characters");     return ans; } string readString(string pat, int lfn, int rgn, string name){     ensure(scanf(" %s ", __buf__) == 1, "Expected string " + name + ", haven't found");     string ans = __buf__;     ensure(lfn <= sz(ans) && sz(ans) <= rgn, "String " + name + " have incorrect length");     forn(i, sz(ans))         ensure(find(all(pat), ans[i]) != pat.end(), "String " + name + " contains incorrect characters");     return ans; } string readLine(char lfc, char rgc, int lfn, int rgn){     ensure(gets(__buf__) != NULL, "Line expected, haven't found");     string ans = __buf__;     ensure(lfn <= sz(ans) && sz(ans) <= rgn, "Line have incorrect length");     forn(i, sz(ans))         ensure(lfc <= ans[i] && ans[i] <= rgc, "Line contains incorrect characters");     return ans; } string readLine(string pat, int lfn, int rgn){     ensure(gets(__buf__) != NULL, "Line expected, haven't found");     string ans = __buf__;     ensure(lfn <= sz(ans) && sz(ans) <= rgn, "Line have incorrect length");     forn(i, sz(ans))         ensure(find(all(pat), ans[i]) != pat.end(), "Line contains incorrect characters");     return ans; } string readLine(){     ensure(gets(__buf__) != NULL, "Line expected, haven't found");     string ans = __buf__;     return ans; } char readChar(){     char c;     ensure(scanf(" %c ", &c) == 1, "Non-whitespace character expected");     return c; } char readWChar(){     int ans = getchar();     ensure(ans != EOF, "Character expected");     return (char)ans; }  int grundy(int a, int b){     if(a > b)         swap(a, b);     if(b % a == 0)         return (b / a) - 1;     int moves = b / a, g = grundy(b % a, a);     if(g == 0)         return moves;     if(moves <= g)         return moves - 1;     return moves; }   void solve_case(){     int n = readInt(1, 100, "N");     vector<pt> a(n);     forn(i, n){         a[i].X = readInt(1, 100000000, "first");         a[i].Y = readInt(1, 100000000, "second");         ensure(a[i].X != a[i].Y, "integers should be distinct");     }          int sum = 0;     forn(i, n){         int g = grundy(a[i].X, a[i].Y);         sum ^= g;     }          if(sum == 0){         puts("NO");     }else         puts("YES"); }  int main(){ #ifdef ssu1     freopen("input.txt", "rt", stdin); #endif          int T = readInt(1, 100, "T");     forn(Ti, T){         solve_case();     }          return 0; }
#include<bits/stdc++.h> using namespace std; char farm[60][60]; int main(){     int t;     cin >> t;     while(t--){         int N, M;         scanf("%d%d", &N, &M);         for(int i = 1;i <= N;++i){             for(int j = 1;j <= M;++j){                 scanf(" %c", &farm[i][j]);             }         }         int ans = 0;         for(int i = 1;i <= N;++i){             for(int k = 1;k <= M;++k){                 int d = min(N - i + 1, M - k + 1);                 for(int j = 2;j <= d;++j){                     if(farm[i][k] == farm[i + j - 1][k] && farm[i][k] == farm[i][k + j - 1] && farm[i][k] == farm[i + j - 1][k + j - 1]){                         ++ans;                     }                 }             }         }         printf("%d\n", ans);     }     return 0; } 
#include <bits/stdc++.h>   int gcd(int a,int b) { 	if(b==0) 		return a; 	else 		return gcd(b,a%b); }   int mod(char b[],int a,int n) {     int i,r;     r=0;     for(i=0;i<n;i++)     {                     r=(r*10)+(b[i]-48);                     r=r%a;     }     return r; }  int main() {     int t,a,i,m,n,res;     char b[500],tem;     scanf("%d",&t);     while(t--)     {               scanf("%d",&a);               scanf("%s",b);               n=strlen(b);               if(a==0)                       printf("%s\n",b);               else               {                   m=mod(b,a,n);                   res=gcd(a,m);                   printf("%d\n",res);               }     }     scanf("%c%c",&tem,&tem);     return 0; } 
#include <iostream> #include <algorithm> #include <vector> #include <string> #include <cstdlib> #include <cstring> #include <cmath> #include <map> #include <set> #include <sstream> #include <stack> #include <queue> #include <numeric> #include <functional> using namespace std; #define pb push_back  #define mp make_pair #define sz(v) ((int)(v).size())  #define rep(i,n) for(int i=0;i<(n);++i)  #define all(a) (a).begin(),(a).end() #define foreach(i, a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i) #define inf (1LL << 29) typedef long long ll; typedef vector<int> vi;   const int N = 1000000; bool used[N];   main() {     ios_base::sync_with_stdio(false);       int t;     while (cin >> t && t) {         rep(times, t) {             int a, b, n;             cin >> a >> b >> n;               vector<int> ret(n);             memset(used, 0, sizeof(used));               int cur = 0;             for (int i = 0; i < n; ++i) {                 for (cur++; used[cur]; cur++);                 ret[i] = cur;                   for (int j = 0; j <= i; ++j) {                     used[max(0, ret[i] * a - ret[j] * b)] = true;                     used[max(0, ret[j] * a - ret[i] * b)] = true;                 }             }             rep(i, sz(ret)) {                 if (i) cout << " ";                 cout << ret[i];             }             cout << endl;         }     } }  
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e3 + 10; int a[MAXN]; int b[MAXN]; int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		int N; 		scanf("%d", &N); 		for(int i = 1;i <= N;++i){ 			scanf("%d%d", &a[i], &b[i]); 		} 		int x = a[1], y = b[1]; 		string ans = ""; 		int cnt = 0; 		for(int i = 1;i <= N;++i){ 			while(!(a[i] == x && b[i] == y)){ 				while(a[i] < x){ 					--x; 					ans += "L-"; 					++cnt; 				} 				while(a[i] > x && x < y - 1){ 					++x; 					ans += "L+"; 					++cnt; 				} 				if(b[i] > y){ 					++y; 					ans += "R+"; 					++cnt; 				} 				while(b[i] < y && x < y - 1){ 					--y; 					ans += "R-"; 					++cnt; 				} 			} 		} 		cout << cnt << "\n"; 		cout << ans << "\n"; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string time1;         string time2;         cin>>time1>>time2;         double dist;         cin>>dist;         double h1=0,h2=0,m1=0,m2=0;         h1=10*time1[0]+time1[1];         m1=10*time1[3]+time1[4];         h2=10*time2[0]+time2[1];         m2=10*time2[3]+time2[4];         double plan1,plan2;         plan1=(h1-h2)*60+(m1-m2)+dist;         if(2*dist<=(h1-h2)*60+(m1-m2)){             plan2=(h1-h2)*60+(m1-m2);         }         else{             plan2=((2*dist)-((h1-h2)*60+(m1-m2)))/2+((h1-h2)*60+(m1-m2));         }         cout<<fixed<<setprecision(1)<<plan1<<" ";         cout<<fixed<<setprecision(1)<<plan2<<endl;     } }
#include<cstdio> #include<iostream> #include<cstring> #include<vector> #include<memory.h> #include<cstdlib> #include<cmath> #include<cassert> #include<memory.h> #include<algorithm> #include<queue> #include<utility> #include<map> #include<bitset> using namespace std;  typedef vector<int> VI; typedef long long LL; typedef unsigned long long uLL; typedef pair<int, int> PII; typedef vector<PII> VPII; #define pb push_back #define fi first #define se second #define mp make_pair #pragma comment(linker, "/STACK:266777216")  const int inf=1000000000; const LL INF=LL(inf)*inf; const double eps=1e-9; const double PI=2*acos(0.0);  #define SMAX 105 #define MOD 1000000007 #define NMAX 101  LL dp[SMAX][SMAX], ifact[NMAX]; int A0, A1, A2, A3, S;   LL mult(LL a, LL b) {     LL ans = a*b;     if(ans>= MOD)     {         ans%=MOD;     }     return ans; }  LL pow(LL a, LL p) {     LL ans = 1;     while(p!=0)     {         if(p&1LL)         {             ans = mult(ans,  a);         }         p /= 2;         a = mult(a, a);     }     return ans; }  //To compute number of different ways to choose k objects from set of A distinct objects LL f(int A, int k) {     int n = k+ A-1, r = k;     //cout<<"A "<<A<<" k "<<k<<endl;     //cout<<"f "<<n<<" "<<r<<endl;     LL ans=1;     for(int i=0; i<r; i++)     {         ans = (ans*(LL)(n-i))%MOD;     }     //cout<<"num "<<ans<<endl;     //cout<<"den "<<ifact[r]<<endl;     ans = (ans*ifact[r])%MOD;     //cout<<"ans "<<ans<<endl;     return ans; }  void precompute() {     ifact[0] = 1;     for(int i=1; i<NMAX; i++)     {         ifact[i] = (ifact[i-1]*pow((LL)i, (LL)(MOD-2)))%MOD;     } }  void solve() {     scanf("%d%d%d%d", &A0, &A1, &A2, &A3);     scanf("%d", &S);      //Initialize     dp[0][0] = 1;     for(int i=1; i<=S; i++)     {        dp[0][i] = 0;     }      //Main Loops     for(int i=1; i<=S; i++)     {         for(int j=0; j<=S; j++)         {             dp[i][j] = dp[i-1][j];         }         //cout<<i<<endl;         for(int j=0; j<=S-i; j++)         {             for(int k=1; j+k*i<=S; k++)             {                 //cout<<"j + k*i "<<j+k*i<<" "<<dp[i-1][j]*f(A0 + i*A1 + i*i*A2 + i*i*i*A3, k)<<endl;                 dp[i][j+k*i] = (dp[i][j+k*i] + (dp[i-1][j]*f(A0 + i*A1 + i*i*A2 + i*i*i*A3, k))%MOD)%MOD;             }         }     }      printf("%lld\n", dp[S][S]);     /*for(int i=0; i<=S; i++)     {         for(int j=0; j<=S; j++)         {             cout<<dp[i][j]<<" ";         }         cout<<endl;     }*/  }  int main() {     #ifndef ONLINE_JUDGE     freopen("input.txt","r",stdin);     freopen("output.txt","w",stdout);     #endif      precompute();      int t;     scanf("%d", &t);     while(t--)     {         solve();     }  } 
#include<stdio.h> #include<bits/stdc++.h> using namespace std; long long int add[100007]; long long int data[1000007]; long long int lp[100007]; vector<long long int>dv[100007]; int prime() { 	long long int i,j; 	for(i=2;i<100000;i++) 	{ 		if(lp[i]) 			continue; 		for(j=1;j*i<=100000;j++) 			{ 				dv[i*j].push_back(i); 				if(lp[i*j]==0) 					lp[i*j]=i; 			} 	} 	return 0; } int precompute() { 	long long int i; 	for(i=2;i<=100000;i++) 	{ 		char mt[100007]={0}; 		long long int tem=i; 		long long int tot=1; 		long long int it=0; 		while(tem!=1) 		{ 			if(tem%(lp[tem]*lp[tem])==0) 				break; 			else 			{ 				tot=tot*(lp[tem]+1); 				int lm=dv[lp[tem]+1].size(); 				long long int j; 				for(j=0;j<lm;j++) 				{ 					if(!mt[dv[lp[tem]+1][j]]) 						{ 							it++; 							mt[dv[lp[tem]+1][j]]=1; 						} 				} 				tem=tem/lp[tem]; 			} 		} 		if(tem!=1||lp[it]!=it) 			add[i]=0; 		else 			add[i]=tot; 	} 	return 0; } int build(int id,int l,int r) { 	if(l==r) 	{ 		data[id]=add[l]; 		return 0; 	} 	int mid=(l+r)/2; 	build(2*id,l,mid); 	build(2*id+1,mid+1,r); 	data[id]=data[2*id]+data[2*id+1]; 	return 0; } long long int query(int id,int l,int r,int ql,int qr) { 	if(l>qr||r<ql) 		return 0; 	if(l>=ql&&r<=qr) 		return data[id]; 	int mid=(l+r)/2; 	return query(2*id,l,mid,ql,qr)+query(2*id+1,mid+1,r,ql,qr);  } int main() { 	prime(); 	precompute(); 	build(1,1,1e5); 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int l,r; 		scanf("%d %d",&l,&r); 		long long int ans=query(1,1,1e5,l,r); 		printf("%lld\n",ans); 	} 	return 0; }
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>   using namespace std;   int main() { 	int T; 	cin>>T; 	while(T--) { 		string R, S; 		cin>>R>>S; 		 		 		bool actual, chef; 		 		int len1, len2, count1[26], count2[26], i; 		for(i = 0; i<26; ++i) 			count1[i] = count2[i] = 0; 		 		len1 = R.length(); 		len2 = S.length(); 		 		for(i = 0; i<len1; ++i) 			++count1[R[i]-'a'];  		for(i = 0; i<len2; ++i) 			++count2[S[i]-'a'];  		bool f = true; 		for(i = 0; i<26 && f; ++i) 			if(count1[i] != count2[i]) 				f = false; 		 		if(f) 			actual = true; 		else 			actual = false;  		f = true; 		for(i = 0; i<26 && f; ++i) 			if(!(((count1[i]>0) && (count2[i]>0)) || ((count1[i] ==0) && (count2[i]==0)))) 				f = false; 		 		if(f) 			chef = true; 		else 			chef = false; 		 		if(chef == actual) 			cout<<"YES"<<endl; 		else 			cout<<"NO"<<endl; 	}   } 
#include<iostream>   using namespace std;   int main() {     int n;     unsigned long long a[100001];     scanf("%d",&n);     if(n>=69)     {              printf("Yes\n");              return 0;     }     for(int i=0;i<n;i++)     {         scanf("%llu",&a[i]);     }     for(int i=0;i<n-3;i++)     {             for(int j=i+1;j<n-2;j++)             {                     for(int k=j+1;k<n-1;k++)                     {                             for(int l=k+1;l<n;l++)                             {                                               if((a[i]^a[j]^a[k]^a[l])==0)                                               {                                                                           printf("Yes\n");                                                                           return 0;                                               }                             }                     }                       }     }     printf("No\n");     return 0; }
#include<bits/stdc++.h> using namespace std; int dp[2][300003]; char str1[200003]; char str2[200003]; int main() {      int t,j;     cin>>t;     while(t--)     {         scanf("%s",str1);         scanf("%s",str2);         int i;         for(i=0;str1[i]!='\0';i++)         {             for(j=0;j<2;j++)             {                 dp[j][i]=0;             }         }         for(i=0;str1[i]!='\0';i++)         {             if(str1[i]=='#')             dp[0][i]=-1;             if(str2[i]=='#')                 dp[1][i]=-1;         }         if(dp[0][0]==-1&&dp[1][0]==-1)             cout<<"No"<<endl;         else         {             if(dp[0][0]!=-1)                 dp[0][0]=0;             if(dp[1][0]!=-1)                 dp[1][0]=0;             for(j=1;str1[j]!='\0';j++)             {                 for(i=0;i<2;i++)                 {                     if(dp[i][j]!=-1)                     {                         if(dp[i][j-1]!=-1&&dp[!i][j-1]!=-1)                         dp[i][j]=min(dp[i][j-1],1+dp[!i][j-1]);                         else if(dp[i][j-1]!=-1)                             dp[i][j]=(dp[i][j-1]);                         else if(dp[!i][j-1]!=-1)                             dp[i][j]=1+dp[!i][j-1];                         else                         {                             dp[i][j]=-1;                         }                        }                 }             }             if(dp[1][strlen(str1)-1]==-1&&dp[0][strlen(str1)-1]==-1)                 cout<<"No"<<endl;             else             {                 cout<<"Yes"<<endl;                 if(dp[1][strlen(str1)-1]!=-1&&dp[0][strlen(str1)-1]!=-1)                     cout<<min(dp[1][strlen(str1)-1],dp[0][strlen(str1)-1])<<endl;                     else if(dp[1][strlen(str1)-1]==-1)                     cout<<dp[0][strlen(str1)-1]<<endl;                 else                     cout<<dp[1][strlen(str1)-1]<<endl;              }           }      } } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         string array[n];         for(int i=0;i<n;i++){             cin>>array[i];         }         int dp[n][n];         int dp1[n][n];         int count=0;         for(int i=n-1;i>=0;i--){             for(int j=n-1;j>=0;j--){                 dp[i][j]=1;                 dp1[i][j]=1;                 if(array[i][j]=='#'){                     dp[i][j]=0;                     dp1[i][j]=0;                 }                 if(i+1<=n-1 && dp[i+1][j]==0){                     dp[i][j]=0;                 }                 if(j+1<=n-1 && dp1[i][j+1]==0){                     dp1[i][j]=0;                 }                 if (dp[i][j]==1 && dp1[i][j]==1){                     count++;                 }                              }         }         cout<<count<<endl;     } }
/*  * Bidhan Roy  * University of Dhaka  */  using namespace std;  #include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <list> #include <ctime> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector>  #define rep(i,n) for(__typeof(n) i=0; i<(n); i++) #define foreach(i,n) for(__typeof((n).begin())i =(n).begin();i!=(n).end();i++) #define inf (1<<30) #define eps 1e-9 #define pb push_back #define ins insert #define mp make_pair #define sz(x) ((int)x.size()) #define clr clear() #define all(x) x.begin(),x.end() #define xx first #define yy second #define sqr(x) ((x)*(x)) #define mem(x,val) memset((x),(val),sizeof(x)); #define read(x) freopen(x,"r",stdin); #define rite(x) freopen(x,"w",stdout); #define chk(a,k) ((bool)(a&(1<<(k)))) #define off(a,k) (a&(~(1<<(k)))) #define on(a,k) (a|(1<<(k)))  typedef long long i64; typedef unsigned long long ui64; typedef string st; typedef vector<int> vi; typedef vector<st> vs; typedef map<int,int> mii; typedef map<st,int> msi; typedef map<int,st> mis; typedef set<int> si; typedef set<st> ss; typedef pair<int,int> pii; typedef vector<pii> vpii;  namespace matrix{     #define size 105     #define wint int     wint mat[size][size],tmp[size][size],res[size][size];     wint MOD;     int n;     void init(int _n,wint _MOD){         n=_n;         MOD=_MOD;         mem(mat,0);         mem(tmp,0);         mem(res,0);     }     void mul(wint r[][size],wint a[][size],wint b[][size]) {         rep(i,n) rep(j,n) {             i64 val=0;             rep(t,n) val+=1LL*a[i][t]*b[t][j];             tmp[i][j]=val%MOD;         }         rep(i,n) rep(j,n) r[i][j]=tmp[i][j];     }     void mPow(wint r[][size],wint a[][size],wint p) {         if (p<0) return;         mem(r,0);         rep(i,n) r[i][i]=1;         while(p>0) {             if(p&1) mul(r,r,a);             mul(a,a,a); p>>=1;         }     }     void pow(wint p){         mPow(res,mat,p);         rep(i,n) rep(j,n) mat[i][j]=res[i][j];     }     void fill(){ 	    rep(i,n-1) { 	        mat[0][i]=1; 	        if(i) mat[i][i-1]=1; 	    }     }     void print(wint pp[][size]){         rep(i,1){             rep(j,n) printf(" %09d",pp[i][j]);             cout<<endl;         }     }     #undef MOD     #undef size     #undef wint }; #define mx 105 #define mod 100000007 i64 powmod( long long b, i64 p, i64 m=mod ){     long long r=1;     for(i64 i=(1<<30); i;i>>=1){         r*=r; if(r>m) r%=m;         if(p&i) {r*=b; if(r>m) r%=m;}     }     return r; } i64 x[mx]; int my[mx][mx]; int main(){     //read("in.txt");     int test;     scanf("%d",&test);     while(test--){         int in,s1,s2,k,n;         scanf("%d%d%d%d%d",&in,&s1,&s2,&k,&n);         int tot=1;         x[1]=in;         tot++;         rep(i,s1){             x[tot]=(x[tot-1]+1);             if(x[tot]>mod) x[tot]%=mod;             tot++;         }         rep(i,s2){             x[tot]=(x[tot-1]*2);             if(x[tot]>mod) x[tot]%=mod;             tot++;         }         if(n<tot) { cout<<x[n]<<endl; continue; }         matrix::init(k+1,mod-1);         matrix::fill();         matrix::pow(n-tot+1);         mem(my,0);         for(int i=k-1,j=0; i>=0; j++,i--) my[j][i]=1;         //cout<<"Before "<<endl;         //matrix::print(my);         matrix::mul(my,matrix::mat,my);         i64 ans=1;         //cout<<"After power "<<n-tot+1<<"-->";         //matrix::print(my);         for(int i=1,j=tot-1; i<=k; i++,j--){             ans*=powmod(x[j],my[0][k-i]);             if(ans>mod) ans%=mod;         }         cout<<ans<<endl;     }     return 0; } 
#include <iostream> #include <cstdio> #include <queue> #include <vector> #include <utility> #include <algorithm> #include <map>  using namespace std;  int dx[] = {1,0}; int dy[] = {0,1}; int tenpow[9];  int getpos(int number , int i , int j) {     int pos = (3 * i + j);     number /= tenpow[pos];     return number % 10; }  inline int getnum(int num, int pos) //get the digit at position 'pos' from the number 'num' {     int i, j;     // Consider num = 123456789 and pos = 3     j = num; // j = 123456789     j /= tenpow[pos]; // j = 123456789/tenpow[3] => j = 123456789/1000 => j = 123456     return j%10; // returning value 123456%10 = 6 at position 3. Remember positions are 0 based. } inline int setnum(int num, int pos, int newnum) // Set the digit at position 'pos' to 'newnum' {     int ret=0;     int i, j;     // Consider num = 123456789, pos = 3 and newnum = 5     j = num; // j = 123456789     int x = num % tenpow[pos]; // x = 123456789%tenpow[3] => x = 123456789%1000 => x = 789     ret = x + newnum * tenpow[pos]; // ret = 789 + 5*tenpow[3] => ret = 789 + 5*1000 => ret = 5789     j /= tenpow[pos+1]; // j = 123456789/tenpow[4] => j = 123456789/10000 => j = 12345     j *= tenpow[pos+1]; // j = 12345*10000 => j = 123450000     ret += j; // ret = 5789 + 123450000 => ret = 123455789     return ret; }  int findNewState (int num , int x1 , int y1 , int x2 , int y2 ) {     int p1 = 3 * x1 + y1;     int p2 = 3 * x2 + y2;      int n1 = getnum(num, p1); // n1 = getnum(123456789, 1) => n1 = 8     int n2 = getnum(num, p2); // n2 = getnum(123456789, 5) => n2 = 4     int ret = 0;     ret = setnum(num, p1, n2); // ret = setnum(123456789, 1, 4) => ret = 123456749     ret = setnum(ret, p2, n1); // ret = setnum(123456789, 5, 8) => ret = 123856749     return ret; }    int isPrime (int n) {     if (n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 || n == 17 || n == 19)         return true;     return false; }  int main() {         tenpow[0] = 1;         for (int i = 1; i <= 9; i++)             tenpow[i] = 10 * tenpow[i - 1];          // precomutation         queue<int> Q;         int start = 123456789;         Q.push(start);         map<int , int > dist;         dist[start] = 0;          while (!Q.empty())         {             int top = Q.front();             //cout << top << endl;             //cout << dist[top] << endl;             Q.pop();             // now go for all possible states             for (int i = 0; i < 3; i++)             {                 for (int j = 0; j < 3; j++)                 {                     int x = i;                     int y = j;                     for (int k = 0; k < 2; k++)                     {                         int nx = x + dx[k];                         int ny = y + dy[k];                          if (nx >= 0 && nx <= 2 && ny >= 0 && ny <= 2)                         {                             if (isPrime(getpos(top , nx , ny) + getpos(top , x , y)) )                             {                                 //printf("this %d %d\n" , getpos(top , nx , ny) , getpos(top , x, y));                                 //printf("%d %d %d %d %d\n" , top , nx , ny , x , y);                                 int newState = findNewState(top , nx , ny , x , y );                                 //cout << newState << endl;                                 if (dist.find(newState) == dist.end())                                 {                                     Q.push(newState);                                     dist[newState] = dist[top] + 1;                                 }                             }                         }                     }                 }             }         }         /*         map<int , int> :: iterator it;         int cnt = 0;         for (it = dist.begin() ; it != dist.end() && cnt++ <= 1000000; it++)         {             printf("%d %d\n" , it->first , it->second);             if (it->first >= 732415689)                 break;         }          cout << "done" << endl;         */     int T;     scanf("%d" , &T);      while (T--)     {         int temp = 0;         for (int i = 0; i < 3; i++)         {             for (int j = 0; j < 3; j++)             {                 int t;                 scanf("%d" , &t);                 temp *= 10;                 temp += t;             }         }          if (dist.find(temp)!= dist.end())             printf("%d\n" , dist[temp]);         else             printf("-1\n");      }      return 0; } 
#include <iostream> #include <vector> using namespace std; typedef long long ll; typedef vector < ll > row; typedef vector < row > matrix; ll MOD = (ll) 1e9 + 7; void clear (matrix & A) {   for (size_t i = 0; i < A.size (); i++)     for (size_t j = 0; j < A[i].size (); j++)       A[i][j] = 0; } matrix mul (const matrix & A, const matrix & B) {   matrix C = A;   clear (C);   for (size_t i = 0; i < C.size (); i++)     for (size_t j = 0; j < C[i].size (); j++)       for (size_t k = 0; k < A[i].size (); k++) 	C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;   return C; } matrix pow (const matrix & A, ll p) {   if (p == 0)     {       matrix C = A;       clear (C);       for (size_t i = 0; i < C.size (); i++) 	C[i][i] = 1;       return C;     }   matrix C = pow (A, p / 2);   C = mul (C, C);   if (p & 1)     C = mul (C, A);   return C; }  void solve () {   ll L;   cin >> L; // Distance   const int nn = 16;   matrix Z = matrix (nn, row (nn, 0));   matrix A = Z;    for (int i = 1; i < nn; i++)     A[i][i - 1] = 1;    int k, l;   cin >> k; // no. of jumps   for (int i = 0; i < k; i++)     {       cin >> l;       A[0][l - 1]=1;     }    matrix B = pow (A, L);   cout << B[0][0] << endl; } int main () {   int t;   cin >> t;   while (t--)     solve ();   return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e3 + 10; int parent[MAXN]; int findP(int x){     return (parent[x] == x?x:(parent[x] = findP(parent[x]))); } void merge(int x, int y){     int px = findP(x);     int py = findP(y);     parent[px] = py; } int main(){     int t;     cin >> t;     while(t--){         int N, M;         scanf("%d%d", &N, &M);         for(int i = 0;i < N;++i){             parent[i] = i;         }         while(M--){             int x, y;             scanf("%d%d", &x, &y);             merge(x, y);         }         int q;         scanf("%d", &q);         while(q--){             int x, y;             scanf("%d%d", &x, &y);             if(findP(x) == findP(y)){                 printf("YO\n");             } else {                 printf("NO\n");             }         }     }     return 0; } 
#include<bits/stdc++.h> using namespace std; class plan{   public:     int m;     double r;     int c; }; int main(){     int t;     cin>>t;     while(t--){         double d;         int u,n;         cin>>d>>u>>n;         double last=d*u;         int answer=0;                  plan *array=new plan[n];         for(int i=0;i<n;i++){             cin>>array[i].m>>array[i].r>>array[i].c;         }         for(int i=0;i<n;i++){             if((((double)array[i].c/array[i].m)+array[i].r*u)<last){                 answer=i+1;                 last=(((double)array[i].c/array[i].m)+array[i].r*u);             }         }         cout<<answer<<endl;              } }
#include <iostream>  #include <stdlib.h>  using namespace std;  int main() {     int q,t,p,k;     cin>>t;     q = t;      long long maxm =0,minm =10000000;      while(t--)     {         long long a[6],area;          for(int i =0;i<=5;i++) {cin>>a[i];}         area = abs(((a[0]-a[4])*(a[3]-a[1]))-((a[0]-a[2])*(a[5]-a[1])));         if (area>=maxm) { maxm = area;                 k = t+1;}         if(area<=minm) { minm = area;                 p =t+1;}        }     cout<<q-p+1<<" "<<q-k+1<<endl; } 
#include <bits/stdc++.h> #define ll long long int using namespace std;  int main() {     ll graph[251][251],i,j,k,s,g,d,v,t;     cin>>v;     for(i=0;i<v;i++)     {         for(j=0;j<v;j++)         {             cin>>graph[i][j];         }     }     for(i=0;i<v;i++)     {         for(j=0;j<v;j++)         {             for(k=0;k<v;k++)             {                 if(graph[j][k]>(graph[j][i]+graph[i][k]))                     graph[j][k]=graph[j][i]+graph[i][k];             }         }     }     cin>>t;     while(t--)     {         cin>>s>>g>>d;         i=graph[s][g]+graph[g][d];         j=graph[s][d];         cout<<i<<" "<<i-j<<endl;     }     return 0; } 
#include<iostream> using namespace std; int main () { 	int a; 	//cout<<"enter the no, of test cases"; 	cin>>a; 	for(int b=0;b<a;b++) 	   { 	   	int c; 	   	//cout<<"enter the no. of horses"; 	   	cin>>c; 	   	int *d=new int[c]; 	   	//cout<<"enter the horses's aukad"; 	   	for(int e=0;e<c;e++) 	   	    {  	   	         cin>>d[e]; 	   	     } 	     //Sorting of the array 	       int x=0; 		 for(int f=0;f<c;f++) 	        { 			  int min=d[f]; 			 for(int g=x;g<c;g++) 	             {  	              if(min>d[g]) 	                {  	                  d[f]=d[g]; 	                  d[g]=min; 	                  min=d[f]; 					} 	        	 	 			    } 				x++; 	        	 	       	} 	       	int *g=new int[c-1]; 	       	for(int h=0;h<c-1;h++) 	       	   { 	       	   	g[h]=d[h+1]-d[h]; 	       		} 	          int min=g[0]; 	           for(int k=0;k<c-1;k++) 	              { 	              	if(min>g[k]) 	              	{ min=g[k]; 					  } 	           	 	           	 			      } 			      cout<<min<<endl;         }                                                                                                                                                                                         } 
 #include<iostream>     #include<cmath>     using namespace std;     #define swap(m,n) m^=n^=m^=n          int main()     {     int t;     std::cin>>t;     while(t)     {     int m,n,p,q;     std::cin>>m>>n>>p>>q;     m-=p;     n-=q;     if(m<n) swap(m,n);     puts(n-int((m-n)*(1+sqrt(5.0))/2)?"Alice":"Bob");     t--;     }     //system("PAUSE");     return 0;     } 
#include <bits/stdc++.h> #define pp pair < int  , int > using namespace std;  const int N = 1e3 + 5;  char mat [N][N];  pp getNull(){     return make_pair(-1 , -1); } bool isNull(pp k){     return k == getNull(); } int n; void recur(int i , int j , int pos , string pat , long long & cur) {     if(pos == pat.size() - 1){        // cout << "Pattern matched" << endl;         ++cur;         return;     }     if(i - 1 >= 1 && j - 1 >= 1 && mat[i - 1][j - 1] == pat[pos + 1]){         recur(i - 1 , j - 1 , pos + 1 , pat , cur);     }     if(i - 1 >= 1 && j + 1 <= n && mat[i - 1][j + 1] == pat[pos + 1]){         recur(i - 1 , j + 1 , pos + 1 , pat , cur);     }     if(i + 1 <= n && j - 1 >= 1 && mat[i + 1][j - 1] == pat[pos + 1]){         recur(i + 1 , j - 1 , pos + 1 , pat , cur);     }     if(i + 1 <= n && j + 1 <= n && mat[i + 1][j + 1] == pat[pos + 1]){         recur(i + 1 , j + 1 , pos + 1 , pat , cur);     } } int main(){     long long ans , cur;     string pat;     cin >> n;     // Grid size     for(int i = 1; i <= n; ++i){         for(int j = 1; j <= n; ++j){             cin >> mat[i][j];         }     }     cin >> pat;     /* here goes the     solving     part     */     ans = 0;     for(int i = 1; i <= n; ++i){         for(int j = 1; j <= n; ++j){             cur = 0;             if(mat[i][j] == pat[0]){               recur(i , j , 0 , pat , cur);             }             ans += cur;         }     }     cout << ans;     return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const int MAXN = 1e6 + 10; LL A[MAXN]; int main(){     int N;     cin >> N;     for(int i = 1;i <= N;++i){         cin >> A[i];     }     LL x;     cin >> x;     sort(A + 1, A + 1 + N);     reverse(A + 1, A + 1 + N);     LL ans = 0;     LL inc = 0;     for(int i = 1;i <= N;++i){         A[i] += inc;         if(N - i + 1 >= x){             inc += max(0LL, 0 - A[i]);             ans += x * max(0LL, 0 - A[i]);         } else{             ans += max(0LL, 0 - A[i]);         }     }     cout << ans << "\n";     return 0; } 
#include <iostream> #include<stdlib.h> #include<math.h> #include <iomanip> using namespace std;  int main() {     int t;     cin>>t;    while(t--){             float P ,S;         cin>>P>>S;    float x1,x2,y1,y2,v,v2;         x1 = (P+sqrt(P*P - 24*S))/12;         y1 = (P/4 - 2*x1);         x2 = (P-sqrt(P*P - 24*S))/12;         y2 = (P/4 - 2*x2);       if(x1<=0||x1>=y1) x1==0;       if(x2<=0||x2>=y2) x2==0;              v = x1*x1*y1;        v2 = x2*x2*y2;  if (v<v2) v=v2;       cout<<setprecision(2)<<fixed<<v<<endl;       }  }    
#include<iostream> #include<bits/stdc++.h> #define F(i,x,y) for(i=x;i<y;i++) #define S(n) scanf("%lld",&n) #define s(n) scanf("%d",&n) #define P(n) printf("%lld\n",n) #define p(n) printf("%d\n",n) #define LLI long long int #define R return 0 using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,k,i; s(n); 		LLI a[n],x; 		F(i,0,n) S(a[i]); 		s(k); 		x=a[k-1]; 		//cout<<x<<endl; 		sort(a,a+n); 		F(i,0,n){ 			if(a[i]==x) 			break; 		} 		p(i+1); 	} 	R; }
#include <cctype> #include <cmath> #include <cstdio>   using namespace std;   const int BUFSIZE = 4096; const char MINUS = '-'; const char ZEROCHAR = '0';   char r_buffer[BUFSIZE]; int r_bufpos = BUFSIZE;   int readint() {     int sign = 1;     int n = 0;     for (; r_bufpos < BUFSIZE && r_buffer[r_bufpos] != MINUS &&             !isdigit(r_buffer[r_bufpos]); r_bufpos++);     if (r_bufpos == BUFSIZE)     {         r_bufpos = 0;         fread(r_buffer, 1, BUFSIZE, stdin);         for (; r_bufpos < BUFSIZE && r_buffer[r_bufpos] != MINUS &&                 !isdigit(r_buffer[r_bufpos]); r_bufpos++);     }     if (r_buffer[r_bufpos] == MINUS)     {         sign = -1;         r_bufpos += 1;     }     for (; r_bufpos < BUFSIZE && isdigit(r_buffer[r_bufpos]); r_bufpos++)         n = 10 * n + r_buffer[r_bufpos] - ZEROCHAR;     if (r_bufpos == BUFSIZE)     {         r_bufpos = 0;         fread(r_buffer, 1, BUFSIZE, stdin);         for (; r_bufpos < BUFSIZE && isdigit(r_buffer[r_bufpos]); r_bufpos++)             n = 10 * n + r_buffer[r_bufpos] - ZEROCHAR;     }     return sign * n; }   const int MAXSIZE = 2000; const double LOBOUND = -5.0e+3; const double UPBOUND = 5.0e+3;   int X[MAXSIZE]; int Y[MAXSIZE]; int T, N, A, B, C; double EPSILON = 5.0e-7;   inline double euclidean(double x, double x0, double y, double y0) {     return sqrt(pow(x - x0, 2) + pow(y - y0, 2)); }   inline double f(double x) {     double y = -1.0 * (A * x + C) / B;     double dist = 0.0;     for (int i=0; i < N; i++)         dist += euclidean(x, X[i], y, Y[i]);     return dist; }   /*  SUM (2(x - x0) + 2(y - y0)y') / 2sqrt((x - x0)^2 + (y - y0)^2))  */ inline double dxfp(double x) {     double y = -1.0 * (A * x + C) / B;     double dy = -1.0 * A / B;     double res = 0.0;     for (int i=0; i < N; i++)         res += (x - X[i] + (y - Y[i]) * dy) / euclidean(x, X[i], y, Y[i]);     return res; }   double newton(double left, double right) {     double res;     double mid = left + (right - left) / 2;     while (fabs(res = dxfp(mid)) >= EPSILON)     {         if (res < 0)             left = mid;         else             right = mid;         mid = left + (right - left) / 2;     }     return mid; }   int main() {     double xhat;     double a, b;     T = readint();     for(; T > 0; T--)     {         N = readint();         A = readint();         B = readint();         C = readint();         for(int i=0; i < N; i++)         {             X[i] = readint();             Y[i] = readint();         }         for (a = -1.0; dxfp(a) > 0; a *= 2);         for (b = 1.0; dxfp(b) < 0; b *= 2);         xhat = newton(a, b);         if ( xhat < LOBOUND || xhat > UPBOUND )             printf("NO\n");         else             printf("%.6f\n", f(xhat));     }     return 0; } 
/* CONCEPT OF THIS PROBLEM  `````````````````````````````````````````````````````````````````````````````` minimum palindrome base  1.point:->base of a number in between is  2<=base<= sqrt(n); 2.point:->if not then the base of a number is (n-i)/i when (n-i)/i>i AND (n-i)%i==0 where for second point i>=2 and i<=sqrt(n); ```````````````````````````````````````````````````````````````````````````````` */ #include<iostream> #include<stdio.h> #include<cmath> #include<cstdlib> using namespace std; int main() { long long int tc,n,b,s,r,t,i; scanf("%lld",&tc); while(tc--) { b=s=0; scanf("%lld",&n); if(n==1||n==3||n==5) { printf("2\n");continue; } if(n==2||n==4) { printf("3\n");continue; } if(n==6) { printf("5\n");continue; } for(i=2;i*i<=n;i++) { s=0; t=n; while(t) { r=t%i; s=(s+r)*i; t/=i; } s/=i; if(n==s) { b=i; break; } } if(b) printf("%lld\n",b); else { for(i=sqrt(n);i;i--) { if((((n-i)/i)>i)&&!((n-i)%i)) {printf("%lld\n",(n-i)/i);break;} } } } return 0; }   
#include <iostream> using namespace std; int main(){     int t;     cin>>t;     while(t--)      {        long long a,d,l,r,x;        long long s=0;        cin>>a>>d>>l>>r;         for(long long i=l;i<l+9;i++)        {   x=(a%9+(((d%9)*((i-1)%9))%9))%9;            if(x!=0)            s+=x;            else s+=9;        }        long long result=((r-l+1)/9)*s;        for(long long i=l;i<l+(r-l+1)%9;i++)        {   x=(a%9+(((d%9)*((i-1)%9))%9))%9;        if(x!=0)            result+=x;            else result+=9;        }        cout<<result<<endl;      } } 
#include<bits/stdc++.h> using namespace std;  #define REP(i,a,b) for(int i=a;i<b;i++) #define rep(i,n) REP(i,0,n)  #define ll long long #define ull unsigned ll #define INF 2000000009 #define N 100009 char str[N]; int count1[30]; int sum[30]; int dp[30][30]; vector<int> count2; int main() {     int t;     scanf("%d",&t);     while(t--)     {         scanf("%s",str);         int K;         scanf("%d",&K);         for(int i=0;i<26;i++)         count1[i]=0;         int n=strlen(str);         for(int i=0;i<n;i++)         {             count1[str[i]-'a']++;         }         count2.clear();         for(int i=0;i<26;i++)         if(count1[i]!=0)count2.push_back(count1[i]);         sort(count2.begin(),count2.end());         int ans=0;         int ind=0;         int sz=count2.size();         for(int i=0;i<sz;i++)             for(int j=0;j<sz;j++)             dp[i][j] = INF;         if(count2[sz-1]-count2[0]<=K)         {             printf("0\n");             continue;         }          sum[0]=count2[0];         for(int i=1;i<sz;i++)             sum[i] = sum[i-1]+count2[i];          for(int i=0;i<=sz-1;i++)         {             int diff;             int psum;             if(i==0)             psum=0;             else             psum = sum[i-1];             if(count2[sz-1]-count2[i]<=K)                     diff =0;                 else                     diff = count2[sz-1]-count2[i]-K;             dp[sz-1][i] = psum + diff;         }          for(int i=sz-2;i>=0;i--)         {             for(int j=0;j<=i;j++)             {                 dp[i][j] =INF;                 for(int k=0;k<=j;k++)                 {                   int temp=0;                   //if(j==0)                   //temp=0;                   //else                   //temp = sum[j-1]- ((k==0)?0:sum[k-1]);                   for(int z=k;z<j;z++)                     temp += count2[z];                   int diff = ((count2[i]-count2[j]<=K)?0:(count2[i]-count2[j]-K));                   dp[i][j] = min(dp[i][j],dp[i+1][k]+temp+diff);                 }             }         }          ans = INF;         for(int i=0;i<sz;i++)             for(int j=0;j<=i;j++)                 if((count2[i]-count2[j]<=K))                 ans = min(ans,dp[i][j]);          /*for(int i=0;i<sz;i++)         {             for(int j=0;j<sz;j++)             {                 if(dp[i][j]==INF)                     printf("X ");                 else                     printf("%d ",dp[i][j]);             }             printf("\n");         }*/         printf("%d\n",ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e4 + 10; const int INF = 4000; vector<vector<int> > grf(MAXN); bool isArticulate[MAXN]; int low[MAXN]; int visT = 0; void dfs(int x, int p){     low[x] = ++visT;     int sz = grf[x].size();     int cntTree = 0;     int minBack = INF;     for(int i = 0;i < sz;++i){         if(grf[x][i] == p) continue;         if(low[grf[x][i]] == 0){             dfs(grf[x][i], x);             if(low[grf[x][i]] >= low[x]){                 isArticulate[x] = true;             }             ++cntTree;         }         minBack = min(minBack, low[grf[x][i]]);     }     if(x == 0){         isArticulate[x] = (cntTree > 1);         return ;     }     low[x] = min(low[x], minBack); } int main(){     int t;     scanf("%d", &t);     while(t--){         int N, M, K;         scanf("%d%d%d", &N, &M, &K);         for(int i = 0;i < N;++i){             grf[i].clear();         }         while(M--){             int A, B;             scanf("%d%d", &A, &B);             grf[A].push_back(B);             grf[B].push_back(A);         }         visT = 0;         for(int i = 0;i < N;++i){             low[i] = 0;             isArticulate[i] = false;         }         dfs(0, -1);         int cnt = 0;         for(int i = 0;i < N;++i){             if(isArticulate[i]) {                 ++cnt;;             }         }         printf("%d\n", K * cnt);     }     return 0; } 
#include <iostream>   using namespace std;  int main() {     int t;     cin >>t;     while(t--){         long long n,q,sum,m;           cin>>n;         long long  p[n];         cin>> p[0];         sum= p[0];         m= p[0];         for(long long i=1;i<n;i++){             cin >>p[i];             if(p[i]<m) m = p[i];             sum +=p[i];         }          q = (sum-m)*m;         cout<<q<<endl;     } } 
#include <iostream> #include <stdio.h> #include <string.h> using namespace std;  int main() {  int t, flag;  char s[15];  scanf("%d", &t);  getchar();  while(t--) {   flag=0;   gets(s);   if(s[0]<'a' || s[0]>'h' || s[1]<'1' || s[1]>'8' || s[2]!='-' || s[3]<'a' || s[3]>'h' || s[4]<'1' || s[4]>'8' || strlen(s)!=5) {    cout<<"Error"<<endl;   }   else {    if(s[0]>s[3]) {     if(s[1]>s[4]) {      if(s[0]-s[3]==1 && s[1]-s[4]==2) flag=1;      else if(s[0]-s[3]==2 && s[1]-s[4]==1) flag=1;     }     else {      if(s[0]-s[3]==1 && s[4]-s[1]==2) flag=1;      else if(s[0]-s[3]==2 && s[4]-s[1]==1) flag=1;     }    }    else {     if(s[1]>s[4]) {      if(s[3]-s[0]==1 && s[1]-s[4]==2) flag=1;      else if(s[3]-s[0]==2 && s[1]-s[4]==1) flag=1;     }     else {      if(s[3]-s[0]==1 && s[4]-s[1]==2) flag=1;      else if(s[3]-s[0]==2 && s[4]-s[1]==1) flag=1;     }    }    if(flag==1) cout<<"Yes"<<endl;    else cout<<"No"<<endl;   }  }  return 0; }
#include <stdio.h> #include <stdlib.h> #define MOD 10000000  int main() {   int T, N, sum, values[1000],i,j;   long long dp[10001],total;   scanf("%d",&T);   while(T--)   {     scanf("%d",&N);     sum = 0;     for(i=0; i<N; i++)     {       scanf("%d",&values[i]);       sum += values[i];     }     for(i=0; i<=sum; i++)      dp[i] = 0;     dp[0] = 1;      for(i=0; i<N; i++) //coin-change DP      for(j=sum; j>=0; j--)       if(dp[j] > 0 )//&& j + values[i] <= sum)        dp[j + values[i]] = ((dp[j+values[i]]) + (dp[j]))%MOD;      total = 0;     for(i=0; i<=sum; i++)      if(dp[i] > 0)      {        long long inc = ((long long)((((long long)abs(sum - 2*i))) * (dp[i])))%MOD;        total = (total + inc)%MOD;      }     printf("%ld\n",total);   }   return 0; } 
#include <bits/stdc++.h> #define pb push_back #define mp make_pair #define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);  typedef long long ll; typedef unsigned long long llu;  using namespace std;  int main() {     FIO     int t;     cin>>t;     while(t--)     {         int n,d;         cin>>n>>d;         string a,b;         cin>>a>>b;         vector<int> ca(26,0),cb(26,0);         bool poss = true;         for(int i=0; i<a.length()&&i<d; i++)         {             for(int j=i; j<n; j+=d)             {                 ca[a[j]-'a']++;                 cb[b[j]-'a']++;             }                          for(int j=0; j<26; j++)             {                 if(ca[j]!=cb[j])                 {                     poss = false;                     break;                 }                 ca[j] = 0;                 cb[j] = 0;             }                          if(!poss)                 break;         }         cout<<(poss?"Yes":"No")<<endl;     } 	return 0; } 
#include<bits/stdc++.h>                         //Author: Sharad Chandran #define lld long long int                       //Handle: sharad07 #define llu unsigned long long int #define pb(x) push_back(x) #define pii pair<int,int> #define pll pair<lld,lld> #define pq priority_queue<int>  #define mp(x,y) make_pair(x,y) #define sz size() #define inp1(x) scanf("%lld",&x) #define inp2(x,y) scanf("%lld%lld",&x,&y) #define inp3(x,y,z) scanf("%d%d%d",&x,&y,&z) #define print(x) printf("%d",x) #define println(x) printf("%lld\n",x) #define _for(i,x,y) for(int i=x;i<y;i++) using namespace std; const int maxx=1e5+2; lld mod=1e9+7; lld A[maxx],C[102][102]; lld k,sum[102][maxx],flag,n,Pow[102][maxx];   inline bool cmp(const lld &a,const lld &b) {     return a>b?1:0; }   inline lld neg_mod(lld &num) {     if(num>mod) num-=(num/mod)*mod;      else if(num<0)      {         lld temp=-num,quo;         quo=temp/mod;         if(quo*mod!=temp) quo++;         num=quo*mod-temp;     } }   lld modPow(lld a, lld x, lld p)  {     //calculates a^x mod p in logarithmic time.     lld res = 1;     while(x > 0)     {         if( x % 2 != 0)         {             res = (res * a);             neg_mod(res);         }         a = (a * a) % p;         x /= 2;     }     return res; }   lld modInverse(lld a, lld p)  {     return modPow(a, p-2, p); }   lld nCr(lld n, lld k, lld p) // calculates C(n,k) mod p (assuming p is prime). {     lld numerator = 1;      for (lld i=0; i<min(k,p); i++)      {         numerator = (numerator * (n-i) );         neg_mod(numerator);     }          lld denominator = 1;      for (lld i=1; i<=min(k, p); i++)     {         denominator = (denominator * i);         neg_mod(denominator);     }     lld ans=numerator* modInverse(denominator,p);     neg_mod(ans);     return  ans; }   lld calc(int r) {     lld ans=0,coeff=C[k][r];     _for(i,0,n-1)     {         ans=(ans+Pow[k-r][i]*sum[r][i+1]);         neg_mod(ans);     }     ans*=coeff;     neg_mod(ans);     return ans; }   inline void solve()  //..O(NK +NlogN) {     inp2(n,k);     _for(i,0,n)      {         inp1(A[i]);         Pow[0][i]=1;     }          sort(A,A+n,cmp);          _for(i,0,k+1)     {             if(i>0)          {             Pow[i][n-1]=Pow[i-1][n-1]*A[n-1];             neg_mod(Pow[i][n-1]);         }         sum[i][n-1]=Pow[i][n-1];         for(int j=n-2;j>=0;j--)         {                if(i>0)             {                 Pow[i][j]=Pow[i-1][j]*A[j];                 neg_mod(Pow[i][j]);             }             sum[i][j]=sum[i][j+1]+Pow[i][j];             neg_mod(sum[i][j]);         }     }          lld res=0;          flag=1;     for(int r=0;r<=k;r++)     {         res=res+calc(r)*flag;         neg_mod(res);         flag*=-1;     }     res=(res*2)%mod;     println(res); }   int main() {     int t;     inp1(t);          _for(i,0,101)     {         _for(j,0,i+1) C[i][j]=nCr(i,j,mod);     }          while(t--)     {         solve();     }     return 0; }
import java.io.OutputStreamWriter; import java.io.BufferedWriter; import java.util.Comparator; import java.io.OutputStream; import java.io.PrintWriter; import java.util.RandomAccess; import java.util.AbstractList; import java.io.Writer; import java.util.List; import java.io.IOException; import java.util.Arrays; import java.util.InputMismatchException; import java.math.BigInteger; import java.io.InputStream; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Iterator; import java.util.Random; import java.math.BigInteger; import java.io.InputStreamReader; import java.io.BufferedReader; import java.math.BigDecimal; import java.text.DecimalFormat; import java.util.Stack;  public class Main  { 	public static void main(String[] args) throws Exception 	{ 		InputStream inputStream = System.in; 		OutputStream outputStream = System.out;  		InputReader in = new InputReader(inputStream); 		OutputWriter out = new OutputWriter(outputStream); 		SaveTheTrees solver = new SaveTheTrees(); 		int T = in.readInt(); 		for(int count = 0; count < T; count++) 		{ 			solver.solve(count+1, in, out);			 		} 		out.close();  	}//end of main() }   class SaveTheTrees  { 	int N; 	int[] A; 	Point2D[] points;  	public void solve(int testNumber, InputReader in, OutputWriter out) throws Exception 	{ 		N = in.readInt(); 		A = new int[N];  		for(int count = 0; count < N; count++) 		{ 			A[count] = in.readInt(); 		}  		int numOfPoints = (N*2 - 3); 		points = new Point2D[numOfPoints]; 		 		long[] yMin = new long[N]; 		long[] yMax = new long[N]; 		yMin[N-1] = A[N-1]; 		yMax[N-1] = A[N-1]; 		for(int count = N-2; count >= 0; count--) { 			yMin[count] = Math.min(yMin[count+1], A[count+1]); 			yMax[count] = Math.max(yMax[count+1], A[count+1]); 		}  		int pointCount = 0; 		for(int xCount = 0; xCount < N-2; xCount++) { 			points[pointCount] = new Point2D(A[xCount], yMin[xCount]); 			//System.out.println(points[pointCount]); 			points[pointCount+1] = new Point2D(A[xCount], yMax[xCount]); 			//System.out.println(points[pointCount+1]); 			pointCount+=2; 		} 		points[pointCount] = new Point2D(A[N-2], A[N-1]); 		//System.out.println(points[pointCount]); 		//System.out.println(pointCount+1); 		out.print(getArea(points, out) + "\n");		 		//long ans = getSchedule(X, Y, N); 		//out.print(ans + "\n");  	}//end of solve()  	public long getArea(Point2D[] points, OutputWriter out) 	{ 		GrahamScan gs = new GrahamScan(); 		gs.grahamScan(points); 		Point2D[] hull = gs.getCCWHull(); 		long area = 0; 		for(int count = 1; count < hull.length; count++) { 			area += ((hull[count-1].x * hull[count].y) - (hull[count-1].y * hull[count].x)); 		} 		 		return Math.abs(area); 	}  }//end of class SaveTheTrees  class InputReader  { 	private InputStream stream; 	private byte[] buf = new byte[1024]; 	private int curChar; 	private int numChars;   	public InputReader(InputStream stream)  	{ 		this.stream = stream; 	} 	  	public int read()  	{ 		if (numChars == -1) 			throw new InputMismatchException(); 		if (curChar >= numChars)  		{ 			curChar = 0; 			try  			{ 				numChars = stream.read(buf); 			}  			catch (IOException e)  			{ 				throw new InputMismatchException(); 			}  			if (numChars <= 0) 				return -1; 		} 		return buf[curChar++]; 	}   	public int readInt()  	{ 		int c = read();  		while (isSpaceChar(c)) 			c = read();  		int sgn = 1; 		if (c == '-')  		{ 			sgn = -1; 			c = read(); 		}  		int res = 0; 		do  		{ 			if (c < '0' || c > '9') 				throw new InputMismatchException(); 			res *= 10; 			res += c - '0'; 			c = read(); 		}  		while (!isSpaceChar(c));  		return res * sgn; 	}  	public String readString()  	{ 		StringBuilder sb = new StringBuilder(); 		int c = read(); 		while (isWhiteSpace(c))  		{ 		    c = read(); 		}  		while (!isWhiteSpace(c))  		{ 		    sb.appendCodePoint(c); 		    c = read(); 		}  		return sb.toString(); 	}  	public static boolean isWhiteSpace(int c)  	{ 		return c >= -1 && c <= 32; 	}   	public static boolean isSpaceChar(int c)  	{ 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; 	}   }   class OutputWriter  { 	private final PrintWriter writer; 	  	public OutputWriter(OutputStream outputStream)  	{ 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); 	} 	  	public OutputWriter(Writer writer)  	{ 		this.writer = new PrintWriter(writer); 	} 	  	public void print(Object...objects)  	{ 		for (int i = 0; i < objects.length; i++)  		{ 			if (i != 0) 				writer.print(' '); 			writer.print(objects[i]); 		} 	} 	  	public void printLine(Object...objects)  	{ 		print(objects); 		writer.println(); 	} 	  	public void close()  	{ 		writer.close(); 	}   }   class GrahamScan { 	Stack<Point2D> hull = new Stack<Point2D>(); 	 	public void grahamScan(Point2D[] points) { 		int pointsCount = points.length; 	 		// sort by y-coordinate 		Arrays.sort(points); 		 		// sort by points[0].polarOrder 		Arrays.sort(points, 1, pointsCount, points[0].polarOrder()); 		 		hull.push(points[0]); 		 		// find index k1 such that points[0] != points[k1] 		int k1; 		for(k1 = 1; k1 < pointsCount; k1++) { 			if(!points[k1].equals(points[0])) { 				break; 			} 		} 		 		// if all points co-incide 		if (k1 == pointsCount) { 			return; 		} 		 		// find index k2 such that points[0], points[k1], points[k2] are non-collinear 		int k2; 		for(k2 = k1+1; k2 < pointsCount; k2++) { 			if(Point2D.ccw(points[0], points[k1], points[k2]) != 0) { 				break; 			} 		} 		 		// points[k2-1] is the second extreme point 		hull.push(points[k2-1]); 		 		for(; k2 < pointsCount; k2++) { 			Point2D top = hull.pop(); 			while(Point2D.ccw(hull.peek(), top, points[k2]) <= 0) { 				top = hull.pop(); 			} 			hull.push(top); 			hull.push(points[k2]); 		}  	} 	 	public Point2D[] getCCWHull() { 		Point2D[] ccwHull = new Point2D[hull.size() + 1]; 		int count = hull.size(); 		while(count > 0) { 			ccwHull[count-1] = hull.pop(); 			count--; 		} 		ccwHull[ccwHull.length - 1] = ccwHull[0]; 		 		return ccwHull; 	}  }// end of Graham Scan  class Point2D implements Comparable<Point2D> { 	long x, y; 	 	public Point2D(long x, long y) { 		this.x = x; 		this.y = y; 	} 	 	public int compareTo(Point2D that) { 		if (this.y < that.y) return -1; 		if (this.y > that.y) return 1; 		if (this.x < that.x) return -1; 		if (this.x > that.x) return 1; 		return 0; 	} 	 	public boolean equals(Object other) { 		if (this == other) return true; 		if (other == null) return false; 		if (this.getClass() != other.getClass()) return false; 		Point2D that = (Point2D) other; 		return this.x == that.x && this.y == that.y; 	} 	 	public int hashCode() { 		int hashX = ((Long)x).hashCode(); 		int hashY = ((Long)x).hashCode(); 		return 31*hashX + hashY; 	} 	 	public static int ccw(Point2D a, Point2D b, Point2D c) { 		long area1 = (c.y - a.y) * (b.x - a.x); 		long area2 = (b.y - a.y) * (c.x - a.x); 		 		if (area1 > area2) { 			return 1; 		} 		if (area2 > area1) { 			return -1; 		} 		 		return 0; 	} 	 	private class PolarOrder implements Comparator<Point2D> { 	 		public int compare(Point2D p1, Point2D p2) { 			long dy1 = p1.y - y; 			long dy2 = p2.y - y; 			long dx1 = p1.x - x; 			long dx2 = p2.x - x; 			if (dy1 >= 0 && dy2 < 0) return -1; 			if (dy1 < 0 && dy2 >= 0) return 1; 			// 3 collinear and horizontal points 			if (dy1 == 0 && dy2 == 0) { 				if (dx1 < 0 && dx2 >= 0) return 1; 				if (dx1 >= 0 && dx2 < 0) return -1; 			} 			 			return -ccw(Point2D.this, p1, p2); 		} 		 	} 	 	public Comparator<Point2D> polarOrder() { 		return new PolarOrder(); 	} 	 	public String toString() { 		return "(" + x + "," + y + ")"; 	} }
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm> #include<cmath>   using namespace std;  int main() { 	int T, A, B, K; 	cin>>T;  	int num[100001], i, j, found=3, q; 	num[1] = 0; 	num[2] = 1; 	num[3] = 1;  	while(T--) { 		cin>>A>>B>>K; 		 		if(B > found) { 			for(i=found + 1; i<=B; ++i) { 				num[i] = -1; 				for(j = 2; j<=(int)sqrt(i); ++j) { 					if(num[j] != 1) 						continue; 					if(i%j == 0) { 						q = i/j; 						if(q%j == 0) 							num[i] = num[q]; 						else 							num[i] = num[q] + 1; 						break; 					} 				}	 				 				if(num[i] == -1) 					num[i] = 1;	 			} 			found = B; 		}  		int ans = 0; 		for(i=A; i<=B; ++i) 			if(num[i] == K) 				++ans;  		cout<<ans<<endl; 	}		 } 
#include <bits/stdc++.h>  #define mod 1000000007  using namespace std;  long long countU[1001],countL[1001],totcount[1001]; long long dp1[1001][1001],dp2[1001][1001];  int main(int argc, char **argv) { 	int N,M,C,i,j,u,l; 	 	scanf("%d%d%d",&N,&M,&C); 	for(i=0;i<=C;i++) 	{ 		countU[i]=0; 		countL[i]=0; 	} 	for(i=0;i<N;i++) 	{ 		scanf("%d",&u); 		countU[u]++; 	} 	for(i=0;i<M;i++) 	{ 		scanf("%d",&l); 		countL[l]++; 	} 	for(i=0;i<=C;i++) 	{ 		totcount[i]=countU[i]*countL[i]; 	} 	 	for(i=0;i<=C;i++) 	{ 		dp1[0][i]=0; 		dp1[1][i]=totcount[i]; 		dp2[0][i]=0; 		if(i>0) 		{ 			dp2[1][i]=dp2[1][i-1]+totcount[i]; 		} 		else 		{ 			dp2[1][i]=0; 		} 	} 	 	for(i=2;i<=C;i++) 	{ 		for(j=1;j<=C;j++) 		{ 			dp1[i][j]=(totcount[j]*dp2[i-1][j-1])%mod; 			dp2[i][j]=(dp2[i][j-1]+dp1[i][j])%mod; 		} 		printf("%lld ",dp2[i][C]); 	} 	printf("0\n"); 	 	return 0; } 
  #include <cstdio> #include <memory.h> #include <algorithm> using namespace std; const int M1=111000000; int t,n,m,k1,k2,k3,i,cur,sum[10010],s[10010],a[10010]; void inc(int i) {   for (int j=i; j<=m; j=(j<<1)-(j&(j-1))) s[j]++; } int findsum(int i) { //printf("findsum %d\n",i);   int r=0;   for (int j=i; j>0; j&=j-1) r+=s[j];   return r; } int solve(int k) {   int l,r,h,mid,rs;   l=0; r=2*M1;   while (l<r) {     mid=(l+r)/2+1; h=mid-M1;     //printf("%d %d %d\n",l,r,h);     memset(s,0,sizeof(s));     inc((lower_bound(sum,sum+m,0)-sum)+1);     for (rs=cur=i=0; i<n; i++) {     //printf("%d %d\n",i,n);       cur+=a[i];       //printf("%d\n",cur-h);       rs+=findsum(upper_bound(sum,sum+m,cur-h)-sum);       //printf("%d\n",rs);       inc((lower_bound(sum,sum+m,cur)-sum)+1);       //for (int i=1; i<=m; i++) printf("%d ",s[i]);puts("~~");     }     if (rs<k) r=mid-1; else l=mid;   }   return r-M1; } int main() {   scanf("%d",&t);   while (t--) {     scanf("%d%d%d%d",&n,&k1,&k2,&k3);     sum[0]=0;     for (i=0; i<n; i++) {       scanf("%d",&a[i]);       sum[i+1]=sum[i]+a[i];     }     m=n+1;     sort(sum,sum+m);     m=unique(sum,sum+m)-sum;     printf("%d %d %d\n",solve(k1),solve(k2),solve(k3));   }   return 0; }    
#include<bits/stdc++.h> using namespace std; int main() { 	long long int n,i,k; 	scanf("%lld%lld",&n,&k); 	long long int a[n+1],j,sum[n+1],max,x,y; 	sum[0]=0; 	set<pair<long long int,pair<long long int,long long int> > >ins; 	for(i=1;i<=n;i++) 	{ 		scanf("%lld",&a[i]); 		sum[i]=sum[i-1]+a[i]; 		ins.insert(make_pair(sum[i],make_pair(i,0))); 	} 		set<pair<long long int,pair<long long int,long long int> > >::iterator it; 	while(k--) 	{ 		it=ins.end(); 		it--; 		max=it->first; 		x=it->second.first; 		y=it->second.second; 		printf("%lld ",max); 		ins.erase(it); 		if(y<x) 		{ 			ins.insert(make_pair(sum[x]-sum[y+1],make_pair(x,y+1))); 		} 		if(ins.size()==0) 		break; 	} 	return 0; }
#include<iostream> #include<map> #include<string>  using namespace std; typedef pair<int, int> mypair; typedef map<char, mypair> mymap;  void checklap(string S) {     mymap M;     mypair temp;     int i, j;     if(S.length() % 2 == 0)     {         i = S.length()/2 - 1;         j = S.length()/2;     }     else     {         i = S.length()/2 - 1;         j = S.length()/2 + 1;     }      while(i >= 0 && j <= S.length()-1)     {         if(M.find(S[i]) != M.end())         {             M[S[i]].first++;         }         else         {             temp.first = 1;             temp.second = 0;             M[S[i]] = temp;         }          if(M.find(S[j]) != M.end())         {             M[S[j]].second++;         }         else         {             temp.first = 0;             temp.second = 1;             M[S[j]] = temp;         }         i--;         j++;     }      mymap::iterator itr;      for(itr = M.begin(); itr != M.end(); itr++)     {         if(itr->second.first != itr->second.second)         {             cout<<"NO"<<endl;             return;         }     }     M.clear();     cout<<"YES"<<endl;  }  int main() {      int T;     cin>>T;     int i;     string S;      for(i=0;i<T;i++)     {         cin>>S;         checklap(S);     }      return 0; } 
 #include <stdio.h>  int main() { 	int N, i, x, y, cnt2, cnt5; 	long long ans; 	scanf("%d", &N); 	for (i = 0; i < N; i++) { 		scanf("%d", &x); 		cnt2 = cnt5 = 0; 		y = x; 		while ((y & 1) == 0) { 			cnt2++; 			y >>= 1; 		} 		while ((y % 5) == 0) { 			cnt5++; 			y /= 5; 		} 		ans = x; 		while (cnt5 > cnt2) { 			ans <<= 2; 			cnt2 += 2; 		} 		printf("%lld\n", ans); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string a,b;         cin>>a>>b;         int count1[123]={0};         int count2[123]={0};         int ans=0;         for(int i=0;i<a.length();i++){             count1[a[i]]++;         }         for(int i=0;i<b.length();i++){             count2[b[i]]++;         }         for(int i=48;i<=122;i++){             ans+=min(count1[i],count2[i]);         }         cout<<ans<<endl;     } }
#include <iostream> #include <cstdio> #include <cstring> using namespace std;  int t,n,k,m; int arr[18]; int myArr[19];  int count_one (int n)     { int count = 0;         while( n )         {         n = n&(n-1);            count++;         }         return count; }  bool valid(){ 	for(int i=0;i<=n-k;i++){ 		int max = -1; 		int cnt = 0; 		for(int j=i;j<i+k;j++){ 			if(myArr[j]>max){ 			 				max = myArr[j]; 				cnt = 1; 			} else if(myArr[j]==max){ 				cnt++; 			} 			 		} 		 		if(cnt>=m) 			return false; 	} 	return true; }  int main() { 	// your code goes here 	 	scanf("%d",&t); 	 	while(t--){ 		scanf("%d %d %d",&n,&k,&m); 		 		for(int i=0;i<n;i++) 			scanf("%d",arr+i); 		 		int u = (1<<n)-1; 		int maxx = 100; 		for(int i=0;i<=u;i++){ 			 			for(int j=0;j<n;j++){ 				if(i&(1<<j)) 					myArr[j] = arr[j]+1; 				else 					myArr[j] = arr[j]; 				 			} 			 			if(valid()){ 			 				int h = count_one(i); 				 				if(maxx>h) 					maxx = h; 			} 			 		} 		maxx = maxx==100 ? -1 : maxx; 		printf("%d\n",maxx); 	} 	 	return 0; }
#include<bits/stdc++.h> int main() {     int i,t,j,color,k,n,m,c[50],p[50];     long long cost[50],den,num,costfreq[50],colfreq[50],freq[50],col[50],dp1[50][50],dp2[50][50],subcol[50];     scanf("%d",&t);     while(t--)     {         scanf("%d %d",&n,&m);         den=num=0LL;         for(i=0;i<=n;i++)             {freq[i]=0LL;             costfreq[i]=0LL;}         for(i=0;i<n;i++)         {             scanf("%d %d",&c[i],&p[i]);             freq[c[i]]++;             costfreq[c[i]]+=p[i];         }         j=0;         for(i=0;i<=n;i++)             if(freq[i]!=0LL)         {             col[j]=i;             colfreq[j]=freq[i];             cost[j]=costfreq[i];             subcol[j]=(1LL<<freq[i])-1LL;             j++;         }         dp1[0][0]=1LL;         dp1[0][1]=subcol[0];         for(i=2;i<=j;i++)             dp1[0][i]=0LL;         for(i=1;i<j;i++)             dp1[i][0]=1LL;         for(i=1;i<j;i++)             for(k=1;k<=j;k++)                 dp1[i][k]=dp1[i-1][k]+(dp1[i-1][k-1]*subcol[i]);         for(i=m;i<=j;i++)             den=den+dp1[j-1][i];         //printf("%lld\n",den);         dp2[0][0]=0LL;         dp2[0][1]=(1LL<<(colfreq[0]-1LL))*cost[0];         for(i=2;i<=j;i++)             dp2[0][i]=0LL;         for(i=1;i<j;i++)             dp2[i][0]=0LL;         for(i=1;i<j;i++)             for(k=1;k<=j;k++)                 dp2[i][k]=(dp2[i-1][k])+(dp2[i-1][k-1]*subcol[i])+(dp1[i-1][k-1]*cost[i]*(1LL<<(colfreq[i]-1LL)));         for(i=m;i<=j;i++)             num=num+dp2[j-1][i];         //printf("%lld\n",num);         printf("%0.8lf\n",(double)num/den);     }     return 0; } 
#include<bits/stdc++.h> using namespace std;   int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n; 		int h[n],d[n]; 		int i; 		int sumh=0, sumd=0,no=0; 		for(i=0;i<n;i++) 		{ 			cin>>h[i]; 		} 		for(i=0;i<n;i++) 		{ 			cin>>d[i]; 		}	 		for(i=0;i<n;i++) 		{ 			sumh+=h[i]; 			sumd+=d[i]; 		} 		if(n==1) 		{ 			if(sumh<sumd) 				no = -1; 			else 				no = sumh-sumd; 		} 		else if(n==2) 		{ 			if(sumd!=sumh) 				no = -1; 			else  				no=abs(min(h[0]-d[0],h[1]-d[1])); 		} 		else         	{             		if(((sumd-sumh)%(n-2))||(sumd<sumh))                 		no=-1;             		else             		{                 		no=(sumd-sumh)/(n-2);                 		for(i=0;i<n;i++)                     			if((no+h[i]-d[i])%2||(no+h[i]-d[i]<0))                         			break;                 			if(i<n)                     				no=-1;            		 } 		} 		cout<<no<<endl; 	} 	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <algorithm> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <cstdlib> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cassert> #include <climits> //#include <ext/hash_map>   using namespace std; using namespace __gnu_cxx;   #define REP(i,n) for(int i = 0; i < int(n); ++i) #define REPV(i, n) for (int i = (n) - 1; (int)i >= 0; --i) #define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)   #define FE(i,t) for (__typeof((t).begin())i=(t).begin();i!=(t).end();++i) #define FEV(i,t) for (__typeof((t).rbegin())i=(t).rbegin();i!=(t).rend();++i)   #define two(x) (1LL << (x)) #define ALL(a) (a).begin(), (a).end()   #define pb push_back #define ST first #define ND second #define MP(x,y) make_pair(x, y)   typedef long long ll; typedef unsigned long long ull; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<string> vs;   int count_saved(char a[],int n){ 	int count =0,i=0 ; 	if(n==0) 		return 0; 	else if(n==1){ 		if(a[0]=='0') 			count++; 	} 	else 	{ 		if(a[0]=='0' && a[1]=='0') 			count++; 		FOR(i,1,n-1){ 			if(a[i]=='0' && a[i-1]=='0' && a[i+1]=='0'){ 					count++; 			} 		} 		if(a[n-2]=='0' && a[n-1]=='0') 			count++; 	} 	return count; }   int main(){ 	int test; 	scanf("%d",&test); 	while(test--){ 		int n,count=0; 		scanf("%d",&n); 		char s[n]; 		scanf("%s",s); 		count = count_saved(s,n); 		printf("%d\n",count); 	} 	return 0; }  
#include<stdio.h> #include<iostream> #include<stdlib.h> #include<string.h> #include<vector> #include<stack> #include<queue> #include<climits> #include<algorithm> #include<set> #include<map> #include<limits.h>  #define FOR(i ,  n) \ 	for(i = 0; i < n; i++) #define FORS(i ,startForIndex , endForIndex) \ 	for(i = startForIndex ;i < endForIndex; i++) #define pb push_back #define ss(n) scanf("%s",n) #define sd(n) scanf("%d",&n) #define pd(n) printf("%d\n",&n) #define fill(x,v) memset(x,v,sizeof(x)) #define sz(x)  x.size()   using namespace std ; long long int arr[1001]={0}; long long int nr[1001]={0}; long long int mo=1000000007; long long int fac[1001]={0}; long long int ifact[1001]={0}; long long int pow(long long int p,long long int j) { 	if(j==1) 	{ 		return p; 	} 	if(j==0) 	{ 		return 1; 	} 	long long int tmp=pow(p,j/2); 	tmp=((tmp*tmp))%mo; 	if(j%2==0) 	{ 		return tmp; 	} 	else 	{ 		return (tmp*p)%mo; 	} } long long int fact(int i) { 	if(i==0||i==1) 	{ 		fac[i]=1; 		ifact[i]=1; 		return fac[i]; 	} 	if(fac[i]!=0) 	{ 		return fac[i]; 	} 	fac[i]=(i*fact(i-1))%mo; 	ifact[i]=(pow(fac[i],mo-2)%mo); 	return fac[i]; }  long long int ncr(int i,int j) { 	if(j==0) 	{ 		return 1; 	} 	if(j==1) 	{ 		return i; 	} 	long long int tmp; 	tmp=(ifact[i-j]*ifact[j])%mo; 	tmp=(tmp*fac[i])%mo; 	return tmp;  	 } void pre() { 	int i; 	int j; 	long long int t; 	t=fact(1000); 	nr[1]=1; 	nr[2]=1; 	//printf("i m  here\n"); 	int k; 	for(i=3;i<=1000;i++) 	{ 		k=i/2+i%2; 		for(j=0;j<k;j++) 		{ 			nr[i]+=ncr(i,j); 			nr[i]%=mo; 		} 	} } 			  int main(){ 	int t; 	pre(); 	cin>>t; 	long long int n; 	int i; 	long long int ans=0; 	int a[1000]; 	while(t>0) 	{ 		t--; 		cin>>n; 		FOR(i,n) 		{ 			cin>>a[i]; 		} 		if(n%2==0) 		{ 			cout<<nr[i]<<endl;  		} 		else 		{ 			ans=pow(2,n-1); 	         	cout<<ans<<endl; 		} 	} } 
#include<bits/stdc++.h> using namespace std; long long gcd(long long a,long long b){     if(b%a==0){         return a;     }     else{         return gcd(b%a,a);     } } int main(){     long long t;     cin>>t;     while(t--){         long long n;         cin>>n;         long long *array=new long long[n];         for(long long i=0;i<n;i++){             cin>>array[i];         }         long long gcd1=array[0];         for(long long i=1;i<n;i++){             if(array[i]>=gcd1){                 gcd1=gcd(gcd1,array[i]);             }             else{                 gcd1=gcd(array[i],gcd1);             }                      }         if(gcd1==1){             cout<<-1<<endl;         }         else{             int flag=0;             for(int i=2;i<=floor(sqrt(gcd1));i++){                 if(gcd1%i==0){                     cout<<i<<endl;                     flag=1;                     break;                 }             }             if(flag==0){                 cout<<gcd1<<endl;             }         }              } }
#include <algorithm> #include <cstdio>  #define MAX_N 50 #define MAX_VALUE 16 #define pow2i(x) (1 << (x))  using namespace std;  int a[MAX_N]; int b[MAX_N]; int p[MAX_N]; double dp[MAX_N][1 << MAX_VALUE];  int skip_whitespace() { 	int ch; 	while (true) { 		ch = getchar_unlocked(); 		if (ch != ' ' && ch != '\n') 			break; 	} 	return ch; }  template<typename T> T read_unsigned_integer() { 	T result = (T) 0; 	int ch = skip_whitespace(); 	while (ch >= '0' && ch <= '9') { 		result = 10 * result + (ch - '0'); 		ch = getchar_unlocked(); 	} 	return result; }  template<typename T> T read_signed_integer() { 	T result = (T) 0; 	bool flip = false; 	int ch = skip_whitespace(); 	if (ch == '-') { 		flip = true; 		ch = skip_whitespace(); 	} 	while (ch >= '0' && ch <= '9') { 		result = 10 * result + (ch - '0'); 		ch = getchar_unlocked(); 	} 	return flip ? -result : result; }  int solve_problem() { 	int n;  	n = read_unsigned_integer<int>(); 	for (int i = 0; i < n; i++) { 		p[i] = read_unsigned_integer<int>(); 		a[i] = read_unsigned_integer<int>() - 1; 		b[i] = read_unsigned_integer<int>() - 1; 	}  	double result = 0.0; 	if (n <= 16) { 		int max_mask = pow2i(n); 		for (int i = 0; i < max_mask; i++) { 			double prob = 1.0; 			int mask = 0; 			bool valid = true; 			for (int j = 0, k = i; j < n; j++, k >>= 1) 				if (k & 1) { 					int pos_mask = pow2i(a[j]); 					if ((mask & pos_mask) == 0) { 						mask |= pos_mask; 						prob *= (double) p[j] / 100; 					} else { 						valid = false; 						break; 					} 				} else { 					int neg_mask = pow2i(b[j]); 					if ((mask & neg_mask) == 0) { 						mask |= neg_mask; 						prob *= (double) (100 - p[j]) / 100; 					} else { 						valid = false; 						break; 					} 				} 			if (valid) 				result += prob; 		} 	}  	printf("%lf\n", result);  	return 0; }  int main() { 	int num_tests;  	num_tests = read_unsigned_integer<int>(); 	for (int i = 0; i < num_tests; i++) 		solve_problem();  	return 0; } 
#include <iostream> #include <bits/stdc++.h>  using namespace std;  int v[10000][10000] = {0}; int c[10000] = {0}; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,m; 		cin>>n>>m; 		vector<int>p(m); 		fill(p.begin(),p.end(),0); 		for(int i=0;i<m;i++) 		{ 			int a; 			cin>>a; 			p[a]++; 		} 		for(int i=0;i<n;i++) 		{ 			cin>>c[i]; 			for(int j=0;j<c[i];j++) 			{ 				cin>>v[i][j]; 			} 			sort(v[i],v[i]+c[i]); 			reverse(v[i],v[i]+c[i]); 		} 		int res=0; 		for(int i=0;i<n;i++) 		{ 			for(int j=0;j<min(c[i],p[i]);j++) 			{ 				res += v[i][j]; 			} 		} 		cout<<res<<endl; 	} 	return 0; }  		 		 
#include <stdio.h> #define MAXN 105  inline int Max(int a , int b){ return (a>b?a:b); }  int n,m; int mapa[MAXN][MAXN]; bool vis[MAXN][MAXN][10][3][3]; int DP[MAXN][MAXN][10][3][3]; int P; char c; int answer;  void reset(){     for(int i=0;i<=n+1;i++)     for(int j=0;j<=m+1;j++)     for(int k=0;k<10;k++)     for(int w=0;w<3;w++)     for(int p=0;p<3;p++)         vis[i][j][k][w][p]=false; }  int busca(int y, int x, int ant, int row, int col){     if(vis[y][x][ant][row][col])         return DP[y][x][ant][row][col];     if(y>n||x>m)         return 0;     int aux=0;     int num=mapa[y][x];     if(row==1)         num+=P;     if(col==1)         num+=P;     num%=10;     aux=Max(aux,busca(y+1,x,ant,0,col));     aux=Max(aux,busca(y,x+1,ant,row,0));     aux=Max(aux,busca(y+1,x,ant,1,col));     aux=Max(aux,busca(y,x+1,ant,row,1));     if(ant>=num){         aux=Max(aux,busca(y+1,x,num,0,col)+1);         aux=Max(aux,busca(y,x+1,num,row,0)+1);         aux=Max(aux,busca(y+1,x,num,1,col)+1);         aux=Max(aux,busca(y,x+1,num,row,1)+1);     }     vis[y][x][ant][row][col]=true;     return DP[y][x][ant][row][col]=aux; }  int main(){     int t;     scanf("%d",&t);     while(t--){         scanf(" %d %d",&n,&m);         for(int i=1;i<=n;i++){             for(int j=1;j<=m;j++){                 scanf(" %c",&c);                 mapa[i][j]=c-'0';             }         }         answer=0;         for(P=0;P<10;P++){             reset();             answer=Max(answer,busca(1,1,9,0,0));             answer=Max(answer,busca(1,1,9,1,0));             answer=Max(answer,busca(1,1,9,0,1));             answer=Max(answer,busca(1,1,9,1,1));         }         printf("%d\n",answer);     }     return 0; } 
#include<stdio.h> #include<algorithm> using namespace std; int main() {     int t,n,m,arr[101][101],dp[101][101],i,j,dir[101][101],x,y,x1,y1;     char s[102];     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&n,&m);         for(i=0;i<n;i++)         {             scanf("%s",s);             for(j=0;j<m;j++)             arr[i][j]=s[j]-'0';         }  		 dp[0][0]=arr[0][0]+arr[1][0]+arr[0][1]; 		  		 for(i=1;i<m-1;i++) 		 { 				dp[0][i]=dp[0][i-1]+arr[0][i+1]+arr[1][i]; 				dir[0][i]=0; // comes from right 		 }  		 dp[0][m-1]=dp[0][m-2]+arr[1][m-1]; 		 dir[0][m-1]=0;  		  for(i=1;i<n-1;i++) 		  { 				dp[i][0]=dp[i-1][0]+arr[i+1][0]+arr[i][1]; 				dir[i][0]=1; // comes from up 		  } 		   		  dp[n-1][0]=dp[n-2][0]+arr[n-1][1]; 		  dir[n-1][0]=1;          		  for(int i=1;i<n-1;i++) 		  { 				for(j=1;j<m-1;j++) 				{  				   int a=(dir[i-1][j]!=1)?0:arr[i][j-1]; 				   int b=(dir[i][j-1]>=1)?0:arr[i-1][j]; 				    				   int x=dp[i-1][j]+arr[i+1][j]+arr[i][j+1]+a; 				   int y=dp[i][j-1]+arr[i+1][j]+arr[i][j+1]+b; 				    				   dp[i][j]=min(x,y);  				   if(x<y)                    dir[i][j]=1;                                        else if(y<x)                    dir[i][j]=0;                                        else                    dir[i][j]=2;                  } 		  } 		   		  for(int i=1;i<m-1;i++) 		  { 				   int a=(dir[n-2][i]!=1)?0:arr[n-1][i-1]; 				   int b=(dir[n-1][i-1]>=1)?0:arr[n-2][i];  				   int x=dp[n-2][i]+arr[n-1][i+1]+a; 				   int y=dp[n-1][i-1]+arr[n-1][i+1]+b; 				    				   dp[n-1][i]=min(x,y);  				   if(x<y)                    dir[n-1][i]=1;                     else if(y<x)                    dir[n-1][i]=0;                     else                    dir[n-1][i]=2; 		  } 		   		  for(int i=1;i<n-1;i++) 		  { 				   int a=(dir[i-1][m-1]!=1)?0:arr[i][m-2]; 				   int b=(dir[i][m-2]>=1)?0:arr[i-1][m-1];  				   int x=dp[i-1][m-1]+arr[i+1][m-1]+a; 				   int y=dp[i][m-2]+arr[i+1][m-1]+b;  				   dp[i][m-1]=min(x,y);  				   if(x<y)                    dir[i][m-1]=1;                     else if(y<x)                    dir[i][m-1]=0;                     else                    dir[i][m-1]=2; 		  } 		    		   		  int a=dir[n-2][m-1]!=1?0:arr[n-1][m-2]; 		  int b=dir[n-1][m-2]>=1?0:arr[n-2][m-1]; 		   		  dp[n-1][m-1]=min(dp[n-2][m-1]+a,dp[n-1][m-2]+b);  	            printf("\n%d",dp[n-1][m-1]); 	}     return 0; } 
#include <bits/stdc++.h> using namespace std; #define b first #define l second int main(){ 	int t,i,n; 	scanf("%d", &t); 	while(t--) 	{ 		scanf("%d", &n); 		vector<pair<int,int> > arr(n); 		for(i=0; i<n; i++){ 			scanf("%d%d", &arr[i].b, &arr[i].l); 		} 		sort(arr.begin(), arr.end()); 		long long total = 0; 		vector<int> songs; 		for (int i = 0; i < n; ++i) { 			if (i==0 || arr[i-1].b < arr[i].b) { 				songs.push_back(arr[i].l); 			} else { 				total += arr[i].l; 			} 		} 		sort(songs.begin(), songs.end()); 		long long ans = songs.size() * total; 		for (int i = 0; i < songs.size(); ++i) { 			ans += (long long)(i+1) * songs[i]; 		} 		printf("%lld\n", ans); 	} }
#include<iostream> using namespace std; int main() {     int t=1,T;     cin>>T;     while(t<=T)     {         int i,j,n,b=0,c=0;         cin>>n;         int a[n];         for(i=0;i<n;i++)         {             cin>>a[i];         }     for(i=0;i<n-1;i++)     {         for(j=i+1;j<n;j++)         {             if(a[i]>a[j])                 b++;         }     }     for(i=0;i<n-1;i++)     {         {             if(a[i]>a[i+1])                 c++;         }     }     if(b==c)         cout<<"YES"<<endl;     else         cout<<"NO"<<endl;     t++;     } } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e4 + 10; vector<int> primes; bool sieve[MAXN]; int ans[MAXN]; int dead[MAXN]; void go(){     memset(sieve, 1, sizeof sieve);     sieve[0] = sieve[1] = false;     for(int i = 2;i * i < MAXN;++i){         if(sieve[i]){             for(int j = i * i;j < MAXN;j += i){                 sieve[j] = false;             }         }     }     for(int i = 2;i < MAXN;++i){         if(sieve[i])             primes.push_back(i);     }     int sz = primes.size();     memset(dead, 0, sizeof dead);     memset(ans, 0, sizeof ans);     for(int i = 0;i < sz && (2 * primes[i] < MAXN);++i){         dead[2 * primes[i]] = 1;     }     for(int i = 1;i < MAXN;++i){         for(int j = 0;j < sz && primes[j] <= i;++j){             ans[i] += dead[i - primes[j]];         }     } }   int main(){     go();     int t;     scanf("%d", &t);     while(t--){         int N;         scanf("%d", &N);         printf("%d\n", ans[N]);     }      return 0; } 
#include<iostream> #include<cstdio> #include<cmath> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> #include<stack> #include<queue> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define vb vector<bool> #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf ll power(ll a,ll b) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a,b/2); 	temp=(temp*temp)%mod; 	if(b&1) 		temp=(temp*a)%mod; 	return temp; } class graph { 	vi * adj; 	int time; 	public: 		graph( int v) 		{ 			adj = new vi[v]; 			time = 0; 		} 		void add_edge(int u, int v) 		{ 			adj[u].pb( v); 			adj[v].pb( u); 		} }; int main() { 	ios_base::sync_with_stdio(false); 	int i, n, t; 	cin >> t; 	ll val; 	while( t--) 	{ 		cin >> n; 		vi v(n); 		int maxi =0, c=0; 		ll ans=1; 		for( i=0;i<n;i++ ) 		{ 			cin >> v[i]; 			maxi = max( maxi, v[i]); 		} 		for( i=0;i<n;i++ ) 		{ 			if( v[i]==maxi ) 			{ 				c++; 			} 		} 		val = power( 2,c); 		val %= mod; 		val =(val-2+mod)%mod; 		ans =(ans+val)%mod; 		cout << ans << "\n"; 	}     return 0; } 
/*If we choose an arbitrary assignment for any two adjacent cells of the original state, then the entire rest of the state can be determined from the current state. For example, if we choose values for original[0] and original[1], then current[1] is defined as original[0]^original[1]^original[2] (where '^' is exclusive or), thus original[2]=original[0]^original[1]^current[1]. Repeating the process allows us to determine all cells of the original state. Depending on the initial assignment, this may or may not yield a valid solution. There are only 4 initial assignments to try, and we simply count the number that yield valid solutions. */ #include<stdio.h> #include<string.h>   int main() {     short int test,count=0,n,i,j,t;     char str[52];     short int arr[52],arr1[52],sol[52];     scanf("%hd",&test);     while(test--)     {                    if(count>1)                  printf("Multiple solutions\n");                    scanf("%s",str);                  n=strlen(str);                  for(i=0;i<n;i++)                  arr[i]=str[i]-'0';                  count=0;                    /* case 1 */                  arr1[0]=0;                  arr1[1]=0;                  for(j=1;j<n;j++)                  {                                    if(j!=n-1)                                    {                                        arr1[j+1]=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                                    else                                    {                                        t=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                  }                  if(t==arr1[0] && (t+arr1[1]+arr1[n-1])%2==arr[0])                  {                  count++;                  for(j=0;j<n;j++)                  sol[j]=arr1[j];                  }                    /* case 2 */                    arr1[0]=0;                  arr1[1]=1;                   for(j=1;j<n;j++)                  {                                    if(j!=n-1)                                    {                                        arr1[j+1]=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                                    else                                    {                                        t=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                  }                  if(t==arr1[0] && (t+arr1[1]+arr1[n-1])%2==arr[0])                  {                  count++;                  if(count>1)                  continue;                  for(j=0;j<n;j++)                  sol[j]=arr1[j];                  }                    /* case 3 */                    arr1[0]=1;                  arr1[1]=0;                   for(j=1;j<n;j++)                  {                                   if(j!=n-1)                                    {                                        arr1[j+1]=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                                    else                                    {                                        t=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                  }                  if(t==arr1[0] && (t+arr1[1]+arr1[n-1])%2==arr[0])                  {                  count++;                  if(count>1)                  continue;                  for(j=0;j<n;j++)                  sol[j]=arr1[j];                  }                    /* case4 */                    arr1[0]=1;                  arr1[1]=1;                   for(j=1;j<n;j++)                  {                                    if(j!=n-1)                                    {                                        arr1[j+1]=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                                    else                                    {                                        t=(arr1[j-1]+arr1[j]+arr[j])%2;                                    }                  }                  if(t==arr1[0] && (t+arr1[1]+arr1[n-1])%2==arr[0])                  {                  count++;                  if(count>1)                  continue;                  for(j=0;j<n;j++)                  sol[j]=arr1[j];                  }                    switch(count)                  {                               case 0: printf("No solution\n");                               break;                               case 1: for(j=0;j<n;j++)                                       printf("%hd",sol[j]);                                       printf("\n");                               break;                  }       }     return 0; }
#include<bits/stdc++.h> #include<cstdio> #include<cstdlib> #include<cmath> #define all(c) c.begin(),c.end() #define gc() getchar_unlocked() using namespace std; typedef long long int ll; typedef pair<ll,ll> pii; const ll inf = 1e10+1;   /* AUTHOR :- DIPJAL CHHETRI     INSTITUTION :- Jaypee Institute of Information Technology,Noida */   inline void scan( ll &n )//fast input function {    n=0;    int ch=gc();int sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=gc();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=gc();    n=n*sign; } inline ll min1(ll x,ll y) {     return(x<y?x:y); } inline ll max1(ll x,ll y) {     return(x>y?x:y); } int main() {     ll n;     ll tt;     scan(tt);     while(tt--){     scan(n);     map<pair<ll,ll>,int> freq;     map<pair<ll,ll>,int> mtp;     ll x,y;     ll xmin=inf,ymin=inf;     ll xmax=-inf,ymax=-inf;     pair<ll,ll> great=make_pair(5,-inf);     pair<int,int> creat=make_pair(5,inf);     for(int i=0;i<n;i++){             scan(x);scan(y);             freq[make_pair(x,y)]++;             if(y>great.second)             {                 great=make_pair(x,y);             }             if(y<creat.second)             {                 creat=make_pair(x,y);             }       xmin=min1(xmin,x);     xmax=max1(xmax,x);     ymin=min1(ymin,y);     ymax=max1(ymax,y);     mtp[make_pair(x,y)]=i+1; } pii top_left,top_right,bottom_left,bottom_right; top_left=make_pair(xmin,ymax); top_right=make_pair(xmax,ymax); bottom_left=make_pair(xmin,ymin); bottom_right=make_pair(xmax,ymin); int t1=freq[top_left]; int t2=freq[top_right]; int t3=freq[bottom_left]; int t4=freq[bottom_right]; if(t1){     printf("1\n");     printf("%d SE\n",mtp[top_left]);     continue; } if(t2){         printf("1\n");         printf("%d SW\n",mtp[top_right]);         continue; } if(t3){         printf("1\n");         printf("%d NE\n",mtp[bottom_left]);         continue; } if(t4){         printf("1\n");         printf("%d NW\n",mtp[bottom_right]);         continue; } printf("2\n"); if(great.first<creat.first) {     printf("%d SE\n",mtp[great]);     printf("%d NW\n",mtp[creat]);     continue; } printf("%d SW\n",mtp[great]); printf("%d NE\n",mtp[creat]); } return 0;}  
#include<iostream> #include<cstdlib> #include<cstring> #include<queue> using namespace std; /*****1- white  2- gray  3-black*****/  struct edge; struct node  {        int color,d;        node *pi;        edge *adj; }; struct edge {        int data;        edge *adj; }; int n;node *array[101]; int power(int base, int n) { int i, p; p = 1; for (i = 1; i <= n; ++i) p = p * base; return p; } int bfs(int s) {      int i,sum;node * temp;edge *p;      queue <node*> q;      for(i=1;i<=n;i++)          {                        array[i]->color=1;            array[i]->d=999999;            array[i]->pi=NULL;          }      array[s]->color=2;      array[s]->d=0;      array[s]->pi=NULL;      q.push(array[s]);      while(q.size()!=0)      {           temp=q.front();           q.pop();              p=temp->adj;           while(p!=NULL)           {              if(array[p->data]->color==1)              {                 array[p->data]->color=2;                 array[p->data]->d=temp->d+1;                 array[p->data]->pi=temp;                 q.push(array[p->data]);              }              p=p->adj;           }           temp->color=3;      }sum=0;      for(i=1;i<=n;i++)      {           sum+=array[i]->d;      }      return sum;                    }                                                    main() {       int t,i,a,min,c,v,st;edge *p,*q;       double ans;       scanf("%d",&t);       while(t--)       {          scanf("%d",&n);          for(i=1;i<=n;i++)          {            array[i]=(node*)malloc(sizeof(node));            array[i]->color=1;            array[i]->d=999999;            array[i]->pi=NULL;            array[i]->adj=NULL;          }          for(i=1;i<=n;i++)          {//cout<<"anuj"<<endl;scanf("%d",&a);cout<<"a "<<c<<endl;             while(true)             {                 scanf("%d",&a); c=getchar();                           p=(edge*)malloc(sizeof(edge));                                                     p->data=a;                 p->adj=NULL;                  q=array[i]->adj;                        if(array[i]->adj==NULL)                 array[i]->adj=p;                 else                 {                    while(q->adj!=NULL)                    {                         q=q->adj;                    }                    q->adj=p;                 } if(c=='\n')break;             }          }min=999999;          for(i=1;i<=n;i++)          {             v=bfs(i); //cout<<"hi "<<v<<" hi"<<endl;                          if(v<min)             {               min=v;               st=i;             }          }         //cout<<"min="<<min<<" n="<<n<<endl;                           ans=(double)min/(double)n;          printf("%d %.6f\n",st,ans);       }       //system("pause"); }                                 
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <vector> #define ll long long using namespace std;  ll MAX = 1000000001; ll t,k,q,lefty,righty,mid,rank,n; ll arr1[20005]; ll arr2[20005]; vector<ll> ff[10005]; pair<ll,ll> query[505]; vector<pair<ll,ll > > v; ll pnt[20005];  struct Comp {    bool operator()(const pair<ll,ll>& s1, const pair<ll,ll>& s2)    {        return s1.first < s2.first;    } };  int main() { 	 	scanf("%lld",&t); 	MAX *= MAX; 	MAX *= 2; 	 	while(t--){ 		scanf("%lld %lld",&k,&q); 		for(ll i=0;i<10004;i++) 			ff[i].clear(); 		v.clear(); 		 		for(ll i=0;i<k;i++) 			scanf("%lld",arr1+i); 			 		for(ll i=0;i<k;i++) 			scanf("%lld",arr2+i); 		 		sort(arr1,arr1+k); 		sort(arr2,arr2+k);  		for(ll i=0;i<q;i++){ 			ll tmp; 			scanf("%lld",&tmp); 			query[i].first = tmp; 			ff[tmp].push_back(i); 		} 		 		for(ll i=0;i<k;i++){ 			pnt[i] = 0; 			ll temp = arr1[i]+arr2[pnt[i]]; 			v.push_back(make_pair(temp*-1,i)); 		} 		make_heap(v.begin(),v.end(),Comp()); 		 		ll p1 = k*k<10002 ? k*k : 10002; 		 		for(ll i=1;i<=p1;i++){ 			ll q1 = v.front().first; 			ll q2 = v.front().second; 			 			for(ll j=0;j<ff[i].size();j++){ 				query[ff[i][j]].second = q1*-1; 			} 			pop_heap (v.begin(),v.end()); 			v.pop_back(); 			if(pnt[q2]<k-1){ 				pnt[q2]++; 				ll k1 = arr1[q2]+arr2[pnt[q2]]; 				v.push_back(make_pair(k1*-1,q2));  				push_heap (v.begin(),v.end(),Comp()); 			}  		} 		 		for(ll i=0;i<q;i++) 			printf("%lld\n",query[i].second); 	} 	 	return 0; }
#include<string.h> #include<string> #include<iostream> #include<stdio.h> using namespace std; char str[2000]; string s[2000]; string tmp; int main(){ 	int t; 	scanf("%d",&t); 	int answer; 	int len; 	int mid,newmid; 	int counter; 	string ansstr; 	int i,j; 	string gsn; 	while(t--){ 		scanf(" %s",str); 		len=strlen(str); 		if(len<9){ 			printf("unlucky\n"); 			continue; 		} 		gsn=""; 		gsn+=str[0]; 		s[0]=gsn; 		for(i=1;i<len;i++){ 			s[i]=s[i-1]+str[i]; 		} 		mid=(len+1)/2-1; 		answer=1000000000; 		for(i=0;i<=mid-4;i++){ 			if(i==0){ 				tmp="lucky"; 				tmp+=(str+5); 			} 			else{ 				tmp=""; 				tmp=s[i-1]+"lucky"; 				tmp+=(str+i+5); 			} 			counter=0; 			//cout<<"original tmp = "<<tmp<<endl; 			for(j=i;j<=i+4;j++){ 				if(tmp[j]!=str[j]) 					counter++; 			} 			for(j=0;j<=mid;j++){ 				if(tmp[j]!=tmp[len-j-1]){ 					counter++; 					if(j>=i&&j<=i+4){ 					tmp[len-1-j]=tmp[j]; 					} 					else{ 					tmp[j]=min(tmp[j],tmp[len-j-1]); 					tmp[len-1-j]=tmp[j]; 					} 				} 			} 			//cout<<"tmp = "<<tmp<< " " << counter<<endl; 			if(counter<answer){ 				answer=counter; 				ansstr=tmp; 			} 			if(counter==answer){ 				if(tmp.compare(ansstr)<0) 					ansstr=tmp; 			} 		} 		if(len%2==1) 			newmid=mid; 		else  			newmid=mid+1; 		for(i=newmid;i<=len-5;i++){ 			tmp=""; 			tmp=s[i-1]+"lucky"; 			tmp+=(str+i+5); 			counter=0; 			for(j=i;j<=i+4;j++){ 				if(tmp[j]!=str[j]) 					counter++; 			} 			for(j=newmid;j<len;j++){ 				if(tmp[j]!=tmp[len-j-1]){ 					counter++; 					if(j>=i&&j<=i+4) 						tmp[len-1-j]=tmp[j]; 					else{ 					tmp[j]=min(tmp[j],tmp[len-j-1]); 					tmp[len-1-j]=tmp[j]; 				} 				} 			} 		//	cout<<"tmp = "<<tmp<< " " << counter<<endl; 			if(counter<answer){ 				answer=counter; 				ansstr=tmp; 			} 			if(counter==answer){ 				if(tmp.compare(ansstr)<0) 					ansstr=tmp; 			} 		} 		cout<<ansstr<<" "<<answer<<endl; 	} 	return 0; }
//author - techaddict #include <iostream> #include <sstream> #include <string> #include <vector> #include <deque> #include <queue> #include <set> #include <map> #include <algorithm> #include <functional> #include <utility> #include <cmath> #include <cstdlib> #include <ctime> #include <cstdio> using namespace std;  int GetInt(){ 	char c;int X=0;while(c=getchar(),c<'0'||c>'9'); 	while(c>='0'&&c<='9'){X=X*10+c-48;c=getchar();} 	return X; }  void PutInt(int X){ 	int Len=0,Data[10]; 	while(X){Data[Len++]=X%10;X/=10;} 	while(Len--)putchar(Data[Len]+48); }  int diff[1000010],result[100010]; int occ(int n, int dig){ 	int ret=0; 	while(n>0){ 		if(n%10==dig)ret++; 		n/=10; 	} 	return ret; }  void pre(){ 	int sum4,sum7,sumprev4=0,sumprev7=0; 	for(int i=0;i<=100000;i++){ 		sum4=sumprev4+occ(i,4); 		sum7=sumprev7+occ(i,7); 		result[i]=result[i-1]+diff[sum4-sum7]; 		diff[sum4-sum7]++; 		sumprev7=sum7;sumprev4=sum4; 	} }  int main(){ 	#ifndef ONLINE_JUDGE 		freopen("input", "r", stdin); 		freopen("output", "w", stdout); 	#endif 	pre(); 	int t,a,b,c,d,n,m,x,y; 	t=GetInt(); 	while(t--){ 		n=GetInt(); 		PutInt(result[n]);putchar('\n'); 	} }
#include<iostream> #include<cstdio> #include<cstring>  using namespace std;  int main(){     int t,len,i,counts[2][10],j;     char a[200010], b[200010];     cin>>t;     while(t--){         for(i=0;i<2;i++)         for(j=0;j<10;j++)             counts[i][j]=0;         scanf("%s",a);         scanf("%s",b);         len=strlen(a);         int pos[2]={0};         for(i=0;i<len;i++){ 		    counts[0][a[i]-'0']++; 		    counts[1][b[i]-'0']++;         }             i=6;             int sub=0;             bool complete=false;             while(counts[0][7]!=0 && !complete){ 				if(i==-1){ 					i=4; 					complete = true; 				} 				if(i==7) 					complete = true; 				sub=counts[0][7]>counts[1][i]?counts[1][i]:counts[0][7];                 counts[0][7]-=sub;                 counts[1][i]-=sub;                 i=counts[1][i]==0?i-1:i;                 if(i==4 && !complete) 					i--; 				else if(i==3 && complete){ 					i=7; 					complete = false; 				} 				pos[0]+=sub;             }             i=6;             complete=false;             while(counts[1][7]!=0 && !complete){ 				if(i==-1){ 					i=4; 					complete = true; 				} 				if(i==7) 					complete = true; 				sub=counts[1][7]>counts[0][i]?counts[0][i]:counts[1][7];                 counts[1][7]-=sub;                 counts[0][i]-=sub;                 i=counts[0][i]==0?i-1:i;                 if(i==4 && !complete) 					i--; 				else if(i==3 && complete){ 					i=7; 					complete = false; 				} 				pos[0]+=sub;             } 			i=3;             complete=false;             while(counts[0][4]!=0 && !complete){ 				if(i==-1){ 					i=4; 					complete = true; 				} 				sub=counts[0][4]>counts[1][i]?counts[1][i]:counts[0][4];                 counts[0][4]-=sub;                 counts[1][i]-=sub;                 i=counts[1][i]==0?i-1:i;                 pos[1]+=sub;             }             i=3;             complete=false;             while(counts[1][4]!=0 && !complete){ 				if(i==-1){ 					i=4; 					complete = true; 				} 				sub=counts[1][4]>counts[0][i]?counts[0][i]:counts[1][4];                 counts[1][4]-=sub;                 counts[0][i]-=sub;                 i=counts[0][i]==0?i-1:i;                 pos[1]+=sub;             }                  for(i=0;i<pos[0];i++)             cout<<"7";         for(i=0;i<pos[1];i++)             cout<<"4";         cout<<endl;     }     return 0; } 
#include<stdio.h> #include<string.h> char s[10001]; int pow2[1001]; int pow8[1001]; int comb[1001][1001]; int ac[14]={4,7,44,47,74,77,444,447,474,477,744,747,774,777}; int b=1000000007; int cf(int k,int w,int cnt) { 	int v,q=0,i,ret=0;; 	if(k>4) q++; 	if(k>7) q++; 	if(q>0) 	{ 		for(i=0;i<14;i++) 		if((w+cnt)>=ac[i]) 		{ 			if(ac[i]>cnt) 			{ 				v=comb[w-1][ac[i]-cnt-1]; 				v=((long long)v*q)%b; 				v=(v*(long long)pow2[ac[i]-cnt-1])%b; 				v=(v*(long long)pow8[w+cnt-ac[i]])%b; 				ret=(ret+v)%b; 			} 		} 		else break; 		k=k-q; 	} 	for(i=0;i<14;i++) 		if((w+cnt)>ac[i]) 		{ 			if(ac[i]>=cnt) 			{ 				v=comb[w-1][ac[i]-cnt]; 				v=((long long)v*k)%b; 				v=(v*(long long)pow2[ac[i]-cnt])%b; 				v=(v*(long long)pow8[w+cnt-ac[i]-1])%b; 				ret=(ret+v)%b; 			} 		} 		else 			break; 	return ret; } int main() { 	int cnt,len,i,j,v,t,k,tc; 	pow2[0]=1;pow8[0]=1; 	for(i=1;i<1001;i++) 	{ 		pow2[i]=((long long)pow2[i-1]*2)%b; 		pow8[i]=((long long)pow8[i-1]*8)%b; 	} 	for ( i = 0; i <1001; i++) { 		comb[i][0] = 1; 		for (j = 1; j <= i; j++) 			comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) %b; 	} 	scanf("%d",&t); 	while(t--) 	{ 		tc=2; 		v=0; 		while(tc--) 		{ 		 k=v; 		 scanf("%s",s); 		 len=strlen(s); 		 cnt=0; 		 v=0; 		 for(i=0;i<len;i++) 		 { 			v=(v+cf(s[i]-'0',len-i,cnt))%b; 			if(s[i]=='7'||s[i]=='4')	cnt++; 		 } 		} 		for(i=0;i<14;i++) 	    	if(cnt==ac[i]) v=(v+1)%b; 		printf("%d\n",(b+v-k)%b); 	}    return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int c=0;         string s;         cin>>s;         for(int i=0;i<s.length();i++)         {             if(s[i]!='7'&&s[i]!='4')                 c++;         }         cout<<c<<endl;     } } 
#include<iostream> #include<cstring> #include<cstdio> using namespace std; int main(){     int test;     cin>>test;     while(test--){         char s[100000];         cin>>s;         int n = strlen(s);         long long final=((long long)(n))*(n+1)/2;         int i,j; 		for(i=0;i<n;i=j) 		{ 			for(j=i;j<n && s[j]==s[i];j++); 			if(s[i]=='7') 				final-=((long long)(j-i))*(j-i+1)/2; 		} 		cout << final << endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int n,k;     cin>>k>>n;     string a1[k];     for(int i=0;i<k;i++){         cin>>a1[i];     }     string a2[n];     for(int i=0;i<n;i++){         cin>>a2[i];         if(a2[i].length()>=47){             cout<<"Good"<<endl;         }         else{             int flag=0;             for(int j=0;j<k;j++){                 if(a2[i].find(a1[j])!=-1){                     cout<<"Good"<<endl;                     flag=1;                     break;                 }             }             if(flag==0){                 cout<<"Bad"<<endl;             }         }     } }
#include <stdio.h>  inline int Max(int a, int b){ return (a>b?a:b); }  int t; char cad[2005]; int DP[2005][30][30]; int n;  int main(){     scanf("%d",&t);     while(t--){         scanf(" %s",cad);         for(n=0;cad[n];n++);         for(int i=0;i<30;i++)             for(int j=0;j<30;j++)                 DP[n][i][j]=0;         for(int pos=n-1;pos>=0;pos--){             for(int x1=29;x1>=0;x1--){                 for(int x2=0;x2<30;x2++){                     DP[pos][x1][x2]=0;                     if(cad[pos]-'a'>=x1)                         DP[pos][x1][x2]=Max(DP[pos][x1][x2],DP[pos+1][cad[pos]-'a'][x2]+1);                     if(cad[pos]-'a'<=x2)                         DP[pos][x1][x2]=Max(DP[pos][x1][x2],DP[pos+1][x1][cad[pos]-'a']+1);                     DP[pos][x1][x2]=Max(DP[pos][x1][x2],DP[pos+1][x1][x2]);                 }             }         }         printf("%d\n",DP[0][0][29]);     }     return 0; } 
#include<iostream> #include<cstring> #include<cstdio> #include<vector> #include<cmath> #include<algorithm> #include<cstdlib>  using namespace std;   inline bool check(int x) {     while (x > 0) {         int dig = x % 10;         if (dig == 4 || dig == 7) {             return true;         }         x /= 10;     }     return false; } int main() {     int t;     scanf("%d",&t);     while(t--)     {         long long int num;         scanf("%lld",&num);         long long int count=0;         for(long long int i=1;i*i<=num;i++)         {             if(num%i==0)             {                 count=count+check(i);                 if(i*i<num)                     count=count+check(num/i);             }         }         printf("%d\n",count);     }      return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define fin freopen("i1.txt","r",stdin) #define pb(x) push_back(x) #define mp(x,y) make_pair(x,y) #define fastio ios_base::sync_with_stdio(false); cin.tie(0); #define ll long long #define oo(x) do{ for(int zo=1;zo<=5;zo++) cout<<x; cout<<"\n"; }while(0);  int main(){     //fin;      ll t;     cin>>t;      while(t--) {         ll n;         cin>>n;          ll a[n+5];         for(ll i=0;i<n;i++)             cin>>a[i];          string ans="No";          for(ll i=2;i<n;i++){             if(a[i]==a[i-1] && a[i-1]==a[i-2]) ans="Yes";         }          cout<<ans<<endl;      }      return 0; } 
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>   using namespace std;   int main() { 	int T; 	string input; 	cin>>T; 	while(T--) { 		cin>>input; 		int i, len = input.length(), empty = 0; 		for(i=len-1; i>=0; --i) { 			if(input[i]!='?' && input[i]!='F') 				continue;	 			if(input[i]=='?') { 				empty = 1; 				--i; 				while(input[i]=='?' && empty < 4 && i>=0) { 					++empty; 					--i; 				} 				if(empty == 4) { 					input[i+1] = 'C'; 					input[i+2] = 'H'; 					input[i+3] = 'E'; 					input[i+4] = 'F';		 					++i; 				} 				else if(empty == 1) { 					if((i >=0) && (input[i]=='E')) { 						if((i-2 >= 0 ) && (input[i-1]=='H' || input[i-1]=='?') && (input[i-2]=='C' ||input[i-2]=='?')) { 							input[i+1] = 'F'; 							input[i] = 'E'; 							input[i-1] = 'H'; 							input[i-2] = 'C'; 							i = i - 2; 						 						} 						else { 							input[i+1] = 'A'; 							++i;  						} 					} 					else { 						input[i+1] = 'A'; 						++i; 					} 				}   				else if(empty == 2) { 					if((i >= 0) && (input[i]=='H')) { 						if((i-1 >= 0) && (input[i-1]=='C' || input[i-1]=='?')) { 							input[i-1] = 'C'; 							input[i] = 'H'; 							input[i+1] = 'E'; 							input[i+2] = 'F'; 							--i;; 						} 						else { 							input[i+2] = 'A'; 							i += 2; 						} 					} 					else { 						input[i+2] = 'A'; 						i += 2; 					} 				}   				else if((i >= 0) && (empty == 3 && input[i] == 'C')) { 					input[i+1] = 'H'; 					input[i+2] = 'E'; 					input[i+3] = 'F';		 				} 				else { 					input[i+3] = 'A'; 					i = i + 3; 				} 			 			}   			else { 				if((i-3 >= 0) && (input[i-1] == 'E' || input[i-1] == '?') && (input[i-2] == 'H' || input[i-2] == '?') && (input[i-3] =='C' || input[i-3] == '?')) { 					input[i] = 'F'; 					input[i-1] ='E'; 					input[i-2] = 'H'; 					input[i-3] = 'C'; 					i = i - 3; 				} 			} 			 		} 		 		cout<<input<<endl; 	} } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll int segment[4000002]; ll  int arr[1000002]; void constructtree(int low,int high,int pos) {     if(low==high)     {         segment[pos]=arr[low];         return ;     }     int mid=(low+high)/2;     constructtree(low,mid,2*pos+1);     constructtree(mid+1,high,2*pos+2);     segment[pos]=segment[2*pos+1]+segment[2*pos+2]; } void update(int low,int high,int index,int value,int pos) {     if(low>high||index>high||index<low)         return ;     if(low==high)     {         if(low==index)         {             arr[index]=arr[index]+value;             segment[pos]=arr[index];         }         return;     }     int mid=(low+high)/2;     update(low,mid,index,value,2*pos+1);     update(mid+1,high,index,value,2*pos+2);     segment[pos]=segment[2*pos+1]+segment[2*pos+2]; } ll int query(int low,int high,int qlow,int qhigh,int pos) {     if(qlow>high||qhigh<low||low>high||qlow>qhigh)         return 0;     if(qlow<=low&&qhigh>=high)     {         return segment[pos];     }     int mid=(low+high)/2;    ll a= query(low,mid,qlow,qhigh,2*pos+1);     ll b=query(mid+1,high,qlow,qhigh,2*pos+2);     return a+b; } int main() {     ll int n,q;     scanf("%lld%lld",&n,&q);      int i,opt;     char ch;     for(i=0;i<n;i++)     {         scanf("%lld",&arr[i]);     }     constructtree(0,n-1,0);     ll a,b;     while(q--)     {         cin>>ch;         if(ch=='S')         {           scanf("%d%d",&a,&b);             printf("%lld\n",query(0,n-1,a,b,0));         }         else if(ch=='G')         {             scanf("%d%d",&a,&b);              update(0,n-1,a,b,0);          }         else         {             scanf("%d%d",&a,&b);              update(0,n-1,a,-b,0);           }      }  } 
#include<bits/stdc++.h> using namespace std;  int val[25]; int dp[25][20007]; int main() {     int t,n,W;     cin>>t;     for(int i=0;i<t;i++)     {         cin>>n>>W;         for(int j=0;j<n;j++)             cin>>val[j];         for(int j=0;j<=n;j++)         {             for(int k=0;k<=W;k++)             {                 if(j==0||k==0)                     dp[j][k]=0;                 else if(val[j-1]<=k)                     dp[j][k]=max(dp[j-1][k],val[j-1]+dp[j-1][k-val[j-1]]);                 else                     dp[j][k]=dp[j-1][k];             }         }        /* for(int j=0;j<=n;j++)         {             for(int k=0;k<=W;k++)             {cout<<dp[j][k]<<" ";}cout<<endl;}*/         if(dp[n][W]==W)             cout<<"Yes"<<endl;         else             cout<<"No"<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int k;         cin>>k;         int array[k];         for(int i=0;i<k;i++){             cin>>array[i];         }         int a=1;         int stems=1;         for(int i=0;i<k;i++){                          if(array[i]>stems){                 a=0;                 break;             }             stems=(stems-array[i])*2;         }         if(a==0 || stems>0){             cout<<"No"<<endl;         }         else{             cout<<"Yes"<<endl;         }     } }
#include<bits/stdc++.h> using namespace std; int order[50][50]; int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         memset(order, 0, sizeof order);         while(N--){             int s, f, c;             scanf("%d%d%d", &s, &f, &c);             order[s][f] = max(order[s][f], c);         }         vector<int> ans(100, 0);         for(int f = 0;f <= 48;++f){                 int cur = 0;             for(int s = 0;s < f;++s){                 cur = max(cur, ans[s]);                 ans[f] = max(ans[f], cur + order[s][f]);             }         }         int final_ans = 0;         for(int i = 0;i <= 48;++i){             final_ans = max(final_ans, ans[i]);         }         printf("%d\n", final_ans);     }     return 0; } 
#include<iostream> int b[1001][1001]; char array[1001][1001]; #ifdef ONLINE_JUDGE #	define gc getchar_unlocked #else #	define gc getchar #endif inline void fps(int &x) {     register int c = gc(); 	x = 0;     for(;((c<48 || c>57));c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } main() {       int n,i,j,k,ch,cv,cd1,cd2,t,max;       fps(n);       for(i=0;i<n;i++)       {              scanf("%s",array[i]);       }       for(i=0;i<n;i++)       {              for(j=0;j<n;j++)              {                  if(array[i][j]=='.')                  b[i][j]=0;                  else                  {                        /////horizontal////                        k=j;ch=0;                        while(k<n)                        {                              if(array[i][k]=='X')                              ch++;                              else                              break;                              k++;                        }                        k=j-1;                        while(k>=0)                        {                              if(array[i][k]=='X')                              ch++;                              else                               break;                              k--;                        }                        ///////vertical////                        k=i;cv=0;                        while(k>=0)                        {                              if(array[k][j]=='X')                              cv++;                              else                              break;                              k--;                        }                        k=i+1;                        while(k<n)                        {                              if(array[k][j]=='X')                              cv++;                              else                               break;                              k++;                        }                        //////////diagonal////                        k=i;t=j;cd1=0;                        while(k<n&&t<n)                        {                              if(array[k][t]=='X')                              cd1++;                              else                               break;                              k++;t++;                        }                        k=i-1;t=j-1;                        while(k>=0&&t>=0)                        {                              if(array[k][t]=='X')                              cd1++;                              else                              break;                              k--;t--;                        }                        //////////diagonal2/////                        k=i;t=j;cd2=0;                        while(k<n&&t>=0)                        {                             if(array[k][t]=='X')                             cd2++;                             else                              break;                             k++;t--;                        }                        k=i-1;t=j+1;                        while(k>=0&&t<n)                        {                             if(array[k][t]=='X')                             cd2++;                             else                             break;                             k--;                             t++;                        }                                              if(cv>ch)                        max=cv;                        else                        max=ch;                        if(max<cd1)                        max=cd1;                        if(max<cd2)                        max=cd2;                        b[i][j]=max;                  }              }       }       for(i=0;i<n;i++)       {            for(j=0;j<n;j++)            {                    printf("%d ",b[i][j]);            }            printf("\n");       }       //system("pause"); }                                                                                                                                                                                                                   
#include <iostream> #include <vector> #include <algorithm> using namespace std; int main() { 	int T, N, K; 	cin>>T; 	while(T--) 	{ 		int sum = 0, sum1 = 0, sum2 = 0; 		cin>>N>>K; 		vector<int> W(N); 		for(int i=0; i<N;i++) 		{ 			cin>>W[i]; 			sum+=W[i]; 		} 		sort(W.begin(),W.end()); 		for(int i=0;i<K;i++) 			sum1+=W[i]; 		int i = K,j=N-1; 		while(i--) 		{ 			sum2+=W[j]; 			j--; 		} 		cout<<max(abs(sum-2*sum1),abs(sum-2*sum2))<<endl; 	}   } 
#include <iostream> #include <cmath> using namespace std;  long long myf(long long x){ 	if(x<0) 		return -x; 	else 		return x; }  int main(){  	long long n,k,t,i,j = 0,m = 0,s = 0,x; 	cin>>t;  	while(t>0){  		s = 0; 		m=0; 		cin>>n>>k; 		long long a[n],b[n];  		for (i = 0; i < n; i++){		// Difference bw i++, ++i  in for loop ?????? 			cin>>a[i]; 		} 		for (i = 0; i < n; i++){ 			cin>>b[i]; 		}  		for(i = 0; i < n; i++){ 			s += a[i]*b[i]; 			x = myf(b[i]); 			if(x > m){ 				m = x; 				j = i; 			} 		}  		s += k*m; 		cout<<s<<endl;  		t--; 	} 	return 0; }
//Archit Rai #include<bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define sz(a) (int)(a.size()) #define all(c) (c).begin(),(c).end() #define F first #define S second #define si(n) scanf("%d",&n) #define sll(n) scanf("%lld",&n) #define REP(i,a,b) for(int i=a;i<b;i++) #define MOD 1000000007 #define endl '\n' #define PIN(n) printf("%d\n",n) #define PLLN(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL) typedef long long int ll; #define N 200010 ll powmod(ll a,ll b) {     if(b==0)return 1;     ll x=powmod(a,b/2);     ll y=(x*x)%MOD;     if(b%2) 	return (a*y)%MOD;     return y%MOD; }  inline void FINT(int &x) {     register int c = getchar_unlocked();     x = 0;     int neg = 0;     for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());     if(c=='-') { 	neg = 1; 	c = getchar_unlocked();     }     for(; c>47 && c<58 ; c = getchar_unlocked()) { 	x = (x<<1) + (x<<3) + c - 48;     }     if(neg) 	x = -x; }   //Template ends here int dp[N],sum[103]; int a[N]; ll temp[N]; int main() {     temp[0] = 1;     REP(i,1,N)     { 	temp[i] = temp[i-1]*2; 	if(temp[i]>MOD) temp[i] %= MOD;     }     int tc;     FINT(tc);     while(tc--)     { 	int n; 	FINT(n); 	ll ans=0; 	int m=0,mi=101; 	REP(i,1,n+1) 	{ 	    FINT(a[i]); 	    m=max(m,a[i]); 	    mi=min(mi,a[i]); 	} 	int curr=0; 	REP(d,mi-m,m-mi+1) 	{ 	    memset(sum,0,sizeof(sum)); 	    curr=0; 	    for(int i=1;i<=n;i++) 	    { 		int val=1LL; 		if((a[i]-d)>=1 && (a[i]-d)<=100) 		{ 		    val+=(ll)sum[a[i]-d]; 		    if(val>MOD) 			val%=MOD; 		} 		sum[a[i]]+=val; 		if(sum[a[i]]>MOD) 		    sum[a[i]]%=MOD; 		curr+=val; 		if(curr>MOD) 		    curr%=MOD; 	    } 	    ans+=curr; 	    ans-=n; 	    while(ans<0) 		ans+=MOD; 	} 	ans+=n; 	if(ans>MOD) 	    ans%=MOD; 	int ans1=(int)temp[n]-1-(int)ans; 	while(ans1<0) 	    ans1+=MOD; 	PIN(ans1);     }     return 0; } 
#include<iostream> #define MOD 1000000007 using namespace std;  long long power(long long n) { 	if (n==0) 	{ 		return 1; 	} 	if (n==1) 	{ 		return 2; 	} 	long long z = (power(n/2))%MOD; 	long long y = (z*z)%MOD; 	if (n%2==1) 	{ 		y = (y*2)%MOD; 	} 	return y; }  int main() { long long t,i,n,j; cin>>t; for (i=0;i<t;i++) { cin>>n; j=(power(n)-1)%MOD; cout<<j<<endl; } } 
#include <bits/stdc++.h> using namespace std; #define N 101000 int Mn[N * 4], se[N * 4]; int a[N], val[N]; #define inf 10000   void build(int st, int en, int id) {     Mn[id] = se[id] = inf;     if(st == en) return ;     int mid = (st + en) >> 1;     build(st, mid, id * 2);     build(mid + 1, en, id * 2 + 1); }   void update(int id, int va) {     se[id] = min(se[id], va);     Mn[id] = min(Mn[id], va); } void push_down(int id) {     int l = id * 2;     int r = id * 2 + 1;     update(l, se[id]);     update(r, se[id]); }   void add(int l, int r, int st, int en, int id, int va) {     if(l > en || r < st) return ;     if(l <= st && en <= r) {         update(id, va);         return ;     }     push_down(id);     int mid = (st + en) >> 1;     add(l, r, st, mid, id * 2, va);     add(l, r, mid + 1, en, id * 2 + 1, va); }   int calc(int l, int st, int en, int id) {     if(st == en) return Mn[id];     int mid = (st + en) >> 1;     push_down(id);     if(mid >= l) return calc(l, st, mid, id * 2);     return calc(l, mid + 1, en, id * 2 + 1); } typedef long long ll;   ll f[600], g[600];   int main() {     //freopen("1.in", "r", stdin);     int T, n, m, K, l, r, c;     for(scanf("%d", &T); T --;) {         scanf("%d%d%d", &n, &K, &m);         ll sum = 0;         for(int i = 1; i <= n; i ++) scanf("%d", &val[i]), sum += val[i];         build(1, n, 1);         for(int i = 0; i < m; i ++) {             scanf("%d%d%d", &l, &r, &c);             add(l, r, 1, n, 1, c);         }         for(int i = 1; i <= n; i ++) a[i] = calc(i, 1, n, 1);         for(int i = 0; i <= K; i ++) f[i] = 0;         for(int i = 1; i <= n; i ++) if(val[i] < 0 && a[i] <= K) {         	for(int j= 0; j <= K; j ++) g[j] = 0;             for(int j = 0; j <= K - a[i]; j ++) g[j + a[i]] = f[j] - val[i];             for(int j = 0; j <= K; j ++) f[j] = max(f[j], g[j]);         }         ll mn = 0;         for(int i = 0; i <= K; i ++) mn = max(mn, f[i]);         sum += mn;         printf("%lld\n", sum);     }     return 0; }
#include <iostream> #include <cmath> #include <climits> #include <cstdio> #include <cstdlib> using namespace std; int a[101][101]; int n,ctr = 0; int arr[101][101]; float fun(int i,int j) {     if(i == n-1 && j == n-1)     {         return a[i][j];     }     if(arr[i][j] != -3000)         return arr[i][j];     if(i == n-1 && j != n-1)     {         arr[i][j] = a[i][j] + fun(i,j+1);         return arr[i][j];     }     if(i != n-1 && j == n-1)     {         arr[i][j] = a[i][j] + fun(i+1,j);         return arr[i][j];     }         int y = a[i][j] + fun(i+1,j);     int r = a[i][j]+ fun(i,j+1);     arr[i][j] = max(y,r);     return arr[i][j]; } int main() {     int t;     cin >> t;     while(t--)     {         cin >> n;         for(int i = 0 ; i < n ; i++)         {             for(int j = 0 ; j < n ; j ++)             {                 arr[i][j] = -3000;             }         }         for(int i = 0 ; i < n; i++)         {             for(int j = 0 ; j < n ; j++)             {                 cin >> a[i][j];             }         }         float res = fun(0,0);         if(res < 0)             cout << "Bad Judges" << endl;         else         {             printf("%.6f\n",res/(2*n-3));             // cout << res/(2.0*n - 3) << endl;         }     } 	return 0; }
#include <bits/stdc++.h> using namespace std; pair <int,int> p[250001]; int main(int argc, char const *argv[]) { 	ios::sync_with_stdio(0); 	int r,c,l,i,j,deep; 	long long e1,e2; //	int t=5; //	while(t--) //	{ 		cin>>r>>c; 	int a[r+1][c+1]; 	for(i=1;i<=r;i++) 		for(j=1;j<=c;j++) 			cin>>a[i][j];  	cin>>l; 	deep=l; 	i=0; 	while(l--) 	{ 		cin>>p[i].first>>p[i].second; 		i++; 	} 	e1=e2=0; 	for(i=0;i<deep;i++) 	{ 		if (p[i].first>r ||p[i].second>c) 		{ 			e1=-1; 		} 		else if(e1!=-1) 		{ 			e1+=a[p[i].first][p[i].second]; 		} 		if (p[i].second>r ||p[i].first>c) 		{ 			e2=-1; 		} 		else if(e2!=-1) 		{ 			e2+=a[p[i].second][p[i].first]; 		} 	} 	cout<<max(e1,e2)<<endl; //	} 	return 0; }
#include <iostream> using namespace std; int arr[20][20001],clash[21][21],collide[21]; int recurse(int m,int n,int row) { 	if(row>=m) 		return 0; 	if(collide[row]==1) 		return recurse(m,n,row+1); 	else 	{ 		int case1,case2; 		case1=recurse(m,n,row+1); 		int i,change[m]; 		for(i=0;i<m;i++) 			change[i]=0; 		for(i=0;i<m;i++) 		{ 			if(clash[row][i]==1) 			{ 				if(collide[i]!=1) 				{ 					collide[i]=1; 					change[i]=1; 				} 			} 		} 		collide[row]=1; 		case2=1+recurse(m,n,row+1); 		for(i=0;i<m;i++) 		{ 			if(change[i]==1) 				collide[i]=0; 		} 		collide[row]=0; 		if(case1>case2) 			return case1; 		else 			return case2; 	} } int main() { 	int m,n; 	cin>>n>>m; 	n++; 	int i,j,k,inpt; 	for(i=0;i<m;i++) 		for(j=0;j<n;j++) 			arr[i][j]=0; 	for(i=0;i<m;i++) 	{ 		cin>>k; 		arr[i][0]=k; 		for(j=1;j<=k;j++) 		{ 			cin>>inpt; 			arr[i][inpt]=1; 		} 	} 	for(i=0;i<m;i++) 	{ 		for(j=0;j<m;j++) 			clash[i][j]=0; 	} 	int l; 	for(i=0;i<m;i++) 	{ 		for(j=(i+1);j<m;j++) 		{ 			for(l=1;l<=n;l++) 			{ 				if(arr[i][l]==1 && arr[j][l]==1) 				{ 					clash[i][j]=1; 					clash[j][i]=1; 					break; 				} 			} 		} 	} 	for(i=0;i<21;i++) 		collide[i]=0; 	int offer=recurse(m,n,0); 	cout<<offer<<"\n"; 	return 0; }
#include<bits/stdc++.h> using namespace std; class node{     public:         string ext;         string type; }; int main(){     int n,q;     cin>>n>>q;     node *array=new node[n];     for(int i=0;i<n;i++){         cin>>array[i].ext>>array[i].type;     }          for(int i=0;i<q;i++){         string s;         cin>>s;         int length=s.length();         int j=length-1;         string exte;         while(j>=0){             if(s[j]!='.'){                 exte=s[j]+exte;                 j=j-1;             }             else{                 break;             }         }         if(j==-1){             cout<<"unknown"<<endl;         }         else{             int flag=0;             for(int k=0;k<n;k++){                 if(array[k].ext==exte){                     cout<<array[k].type<<endl;                     flag=1;                     break;                 }             }             if(flag==0){                 cout<<"unknown"<<endl;             }         }     } }
#include<iostream> #include<stdio.h> #define MOD 1000000007L using namespace std;  int a[1000000];  int main() {     int t; /*     freopen("input.txt","r",stdin);     freopen("output.txt","w",stdout);*/      scanf("%d",&t);      while(t--)     {         long int i,m,n,l;         int c=0;         scanf("%ld",&n);          /*if(n==1L)         {             printf("26\n");             continue;         }*/          for(i=0;i<n;i++)         a[i]=0;          if(n%2==0)         {             m=1L;             a[m-1]=1;              while(m<n)             {                 l=m;                 do                 {                 if(m%2==0)                 m=m/2;                 else                 m=n/2+(m+1)/2;                  a[m-1]=1;                 }while(m!=l);                  c++;                 i=1L;                 while(i<=n&&a[i-1]!=0)                 i++;                 m=i;             }         }         else         {             m=1L;             a[m-1]=1;             n--;             //a[n]=0;             c++;              while(m<n)             {                 l=m;                 do                 {                 if(m%2==0)                 m=m/2;                 else                 m=n/2+(m+1)/2;                 a[m-1]=1;                 }while(m!=l);                  c++;                  i=1L;                 while(i<=n&&a[i-1]!=0)                 i++;                 m=i;             }          }          long int res=1LL;         for(i=1;i<=c;i++)         res=(res*26LL)%MOD;          printf("%ld\n",res);     }      return 0; } 
#include <cstdio> #include <cstring> #include <vector> #include <algorithm> #define SI ({int x;scanf("%d",&x);x;}) #define pb(x) push_back(x) using namespace std;   int main() { int t = SI, x, y, m, p, n, z;   while(t--) { n = SI; m=p=z=0; while(n--) { x=SI; y=SI; if(x>y) p++; else if(x<y) m++; else z++; }   if(z||(p>0&&m>0)) puts("YES"); else puts("NO"); }   return 0; }
#include<bits/stdc++.h> using namespace std;  struct pos_info { 	long long int val, sum, till_sum, rev_till_sum; }data[100005];  long long temp, temp_sum;  int main() { 	int t; 	cin >> t;  	while(t--) { 		int n, i ;  		cin >> n; 		long long temp_min = 1e9, res = -1, temp_max = -1e10, temp_max_sum = -1e10, prev_zero;	  		for(i = 1 ; i <= n ; i++) { 			cin >> data[i].val; 			temp_max = max(temp_max, data[i].val); 		}  		data[0].val = data[n+1].val = 0; 		data[0].till_sum = data[n+1].till_sum = 0; 		data[0].rev_till_sum = data[n+1].rev_till_sum = 0; 		 		temp_sum = 0;  		for(i = 0 ; i <= n + 1 ; i++) { 			if(temp_sum + data[i].val >= 0) { 				temp_sum += data[i].val; 				data[i].till_sum = temp_sum; 				res = max(res, data[i].till_sum ); 			}else{ 				temp_sum = 0; 				data[i].till_sum = data[i].rev_till_sum = 0; 			} 		}  		temp_sum = 0;  		for(i = n + 1 ; i >= 0 ; i--) { 			if(temp_sum + data[i].val >= 0) { 				temp_sum += data[i].val; 				data[i].rev_till_sum = temp_sum; 				res = max(res, data[i].rev_till_sum); 			}else{ 				temp_sum = 0; 				data[i].till_sum = data[i].rev_till_sum = 0; 			}  		}  		for(i = 1 ; i <= n ; i++) { 			//printf("%lld %lld\n",data[i].till_sum, data[i].rev_till_sum); 			if(data[i].val < 0) { 				res = max(res, data[i-1].till_sum + data[i+1].rev_till_sum); 			} 		} 		 		if(temp_max < 0)	 			res = temp_max;  		printf("%lld\n",res);		 	} 	return 0; }
#include <iostream> #include <bits/stdc++.h> using namespace std;   int main()  { 	long long int t,a,b,c,max,p1,p2,v,pr,ans,m; 	cin>>t; 	while(t--) 	{ 	    cin>>a>>b>>c; 	    max=0; 	    ans=0; 	    m=a*100+b; 	    for(int i=1;i<10000&&((a*100+b)>=c);i++) 	    { 	        v=a*100+b-c; 	        p1=v%100; 	        p2=v/100; 	        pr=p1*100+p2-m; 	        if(pr>max) 	        { 	            max=pr; 	            ans=i; 	        } 	        a=p1; 	        b=p2; 	    } 	    cout<<ans<<"\n"; 	} 	return 0; }
#include <cstdio>  using namespace std; const int N_MAX = 5000; unsigned long long MAX = 1000000007; unsigned long long fact[N_MAX+1]; unsigned long long mul_inv[N_MAX+1];  inline unsigned long long combi(int n, int r) {     return (((fact[n] * mul_inv[r]) % MAX) * mul_inv[n-r]) % MAX; }  inline unsigned long long exp_mod(int x, int y) {     unsigned long long term = x;     unsigned long long prod = 1;      while (y != 0)     {         if (y & 0x1)             prod = (prod * term) % MAX;         term = (term * term) % MAX;         y >>= 1;     }     return prod; }  int main() {      fact[0]     = fact[1]    = 1;     mul_inv[0]  = mul_inv[1] = 1;      for(int i=2; i<=N_MAX; i++)     {         fact[i]    = (fact[i-1] * i) % MAX;         mul_inv[i] = exp_mod(fact[i], MAX-2);     }      while (true)     {         int N, K;         scanf("%d %d", &N, &K);         if (N == 0 && K == 0)             break;          unsigned long long position_ways, direction_ways, total_ways;         position_ways  = combi(N-2, K/2) % MAX;         direction_ways = combi(N-2, N-1-K/2-(K&0x1)) % MAX;         total_ways = (2 * (position_ways * direction_ways) % MAX) % MAX;         printf("%lld\n", total_ways);     }     return 0; } 
#include<iostream> #include<cstring> #define Si(i) scanf("%d",&i) int n,k,f,w; int ans=0;  int h[1009]; int x;   using namespace std;  int  fun(int i,int s,int pp){    //cout<<i<<"* ";                 for(int j=1;j<=k;j++){              if(i-j<0)              return 1;                     if(h[i-j]==0)                     {//cout<<"\n ans="<< i-j;                      h[i-j]=1;                     h[s]=0;                                        ans+=pp;                     return 2;                                          }                                          else if(j == (k) ) //if coin                      {                         f= fun(i-j,s,pp+1);                     if(f==1)                     return 1;                     else return 0;                                                                                                                                                   }                                                       }                     }   int main(){     int t; cin>>t; while(t--){ scanf("%d%d",&n,&k);  memset(h,0,sizeof(h)); int mx=0; for(int i=0;i<n;i++){ scanf("%d",&x); h[x-1]=1; mx=max(mx,x); }  ans=0; for(int i=mx+1;i>=0;i--){         if(h[i]==0)         continue;             w= fun(i,i,1);        if(w==0){                i++; }                           }                      printf("%d\n",ans);  } //system("pause"); return 0; } 
#include <bits/stdc++.h> using namespace std; long long arr[100000], cnt[100001]; int main () { 	long t, n, i, c; 	long long int res; 	cin >> t; 	while (t--) 	{ 		cin >> n; 		memset(cnt,0,sizeof cnt); 		for (i=1; i<=n; i++) 			cnt[i] = 0; 		cin >> arr[0]; 		cnt[arr[0]]++; 		c = 1; 		for (i=1; i<n; i++) 		{ 			cin >> arr[i]; 			if (arr[i]==arr[i-1]) 			{ 				c++; 				cnt[arr[i]] += c; 			} 			else 			{ 				c = 1; 				cnt[arr[i]] += c; 			} 		} 		res = 1; 		for (i=1; i<=n; i++) 		{ 			if (cnt[i]!=0) 				res = (res * cnt[i])%1000000007; 		} 		cout << res << endl; 	} 	return 0; }
#include<iostream> #include<vector> #include<string> #include<queue>  #define ITERATE(c,it) for(typeof((c).begin()) it = (c).begin();it!=(c).end();it++)  #define PN(i,j) my_pair(i,j,N) #define PS(i,j) my_pair(i,j,max_subsets)  #define UN(val,k,l) get_pair(k,l,val,N) #define US(val,k,l) get_pair(k,l,val,max_subsets)   const int max_treasure = 13; const int max_n = 13; const int max_subsets = 1 << max_treasure; const int max_vertices = max_n*max_n;   using namespace std;  typedef vector<int> vi; typedef vector<vi> vii;  inline int mark(int i,int val) { 	return (1<<i) | val; } inline int my_pair(int i,int j,int Base) { 	//Map from NxN->N. Note 0<=j<base 	return i*Base+j; }   void get_pair(int & i,int & j,int Val,int Base) { 	j = Val% Base; 	i = (Val - j) / Base; }  int dist[(max_vertices+1)*max_subsets]; int tr_index[max_vertices]; string maze[max_n]; vii adj_list(max_vertices,vector<int>());    int main(){ 	int T,N; 	cin >> T; 	for(int i=0;i<T;i++){ 		cin >> N; 		int tr_count = 0; //Treasure count 		for(int j=0;j<N;j++){ 			cin>>maze[j]; 			for(int k=0;k<N;k++){ 				adj_list[PN(j,k)].clear(); 				 				if(maze[j][k] == '*')  					tr_index[PN(j,k)] = (tr_count++);  				else  					tr_index[PN(j,k)] = -1; 				 				if(maze[j][k] == '#') 					continue; 					 				if(j>0 && maze[j-1][k] != '#'){ 					adj_list[PN(j-1,k)].push_back(PN(j,k)); 					adj_list[PN(j,k)].push_back(PN(j-1,k)); 				} 				if(k > 0 && maze[j][k-1] != '#'){ 					adj_list[PN(j,k-1)].push_back(PN(j,k)); 					adj_list[PN(j,k)].push_back(PN(j,k-1)); 				}  			} 		 			 		 		} 		 		for(int j=0;j<N;j++){ 			for(int k=0;k<N;k++){ 				for(int l=0;l<(1<<tr_count);l++) 					dist[PS(PN(j,k),l)] = -1; 				} 			} 		queue<int> q; 		q.push(PS(PN(0,0),0)); 		dist[PS(PN(0,0),0)] = 0; 		while (q.size()){ 			int val=q.front(); 			int vertex,treasure_collected;  			q.pop(); 			US(val,vertex,treasure_collected); 			ITERATE(adj_list[vertex],it){ 					int next = PS(*it,treasure_collected); 					if(tr_index[*it] != -1) 						next=PS(*it,mark(tr_index[*it],treasure_collected)); 					if(dist[next] == -1){ 						dist[next] = dist[val] + 1; 						q.push(next); 						} 				} 			 			} 		cout<<dist[PS(PN(N-1,N-1),(1<<tr_count)-1)]<<endl; 	} } 
#include <stdio.h> #include <stdlib.h>   struct gameCase { 	int h1; 	int h2; 	int h3; 	int nextLink; }allCases[242];   bool gameEqual (gameCase t1,gameCase t2) { 	if(t1.h1 == t2.h1 && t1.h2 == t2.h2 && t1.h3 == t2.h3) 		return true; 	if(t1.h1 == t2.h2 && t1.h2 == t2.h3 && t1.h3 == t2.h1) 		return true; 	if(t1.h1 == t2.h3 && t1.h2 == t2.h1 && t1.h3 == t2.h2) 		return true; 	return false; }   gameCase acShift (int a,int b,int c) {   	int h1=a,h2=b,h3=c;   	// Clear bits 1,2 of h2 ... and 1,6 of h3 	h2 = h2 & 15; 	h3 = h3 & 30;   	// Shift first one 	h1 = h1<<1;   	// Check if '0' is set , if yes , set the first one 	if (h1 & 64) { 		h1 = (h1 & 62) | 1; 		h2 = h2 | 16; 	}   	// Check if first one is set (common to all) 	if (h1 & 32) { 		h2 = h2 | 32; 		h3 = h3 | 32; 	}   	// Check the bit 2 of h1 ... for setting h3's last bit 	if (h1 & 16) 		h3 = h3 | 1;   	gameCase g={h1,h2,h3,-1}; 	return g; } gameCase cShift (int a,int b,int c) { 	int h1=a,h2=b,h3=c;   	// Clear bits 1,2 of h2 ... and 1,6 of h3 	h2 = h2 & 15; 	h3 = h3 & 30;   	// Check if bit 6 is already set ,if yes adjust bit '0' to be propagated to 1 	if (h1 & 1) { 		h1 = h1 | 64;   		// Adjust one for 3 & 4 		h2 = h2 | 32; 		h3 = h3 | 32; 	} 	// Shift first one 	h1 = (h1>>1)&63;   	// Check if bit 6 is set , set bit 2 of h2 	if (h1 & 1) { 		h2 = h2 | 16; 	}   	// Check the bit 2 of h1 ... for setting h3 	if (h1 & 16) 		h3 = h3 | 1;   	gameCase g={h1,h2,h3,-1}; 	return g; }   gameCase getGame(){ 	register int a=0,b=0; 	gameCase g; 	a=(getchar()-'0')<<1; 	b=(getchar()-'0')<<3; 	a=a | ((getchar()-'0')<<2); 	a=a | ((getchar()-'0')); 	b=b | ((getchar()-'0')<<2); 	a=a | ((getchar()-'0')<<3); 	a=a | (getchar()-'0')<<5; 	b=b | ((getchar()-'0')<<1); 	a=a | ((getchar()-'0')<<4); 	g.h1=a; 	b=b | ((a&1)<<4); 	b=b | (a&32); 	b=b | ((getchar()-'0')); 	g.h2=b; 	a=(a&16)>>4; 	a=a | (b&32); 	a=a | ((b&1)<<4); 	a=a | ((getchar()-'0')<<1); 	a=a | ((getchar()-'0')<<3); 	a=a | ((getchar()-'0')<<2); 	g.h3=a; 	getchar(); // For return 	return g; } inline int scanInt() {       register int retInt = 0,d;       while ((d = getchar()) >= '0') {             retInt = (retInt<<3) + (retInt<<1) + (d-'0');       }       return retInt; }   int main(void) { 	 	int a,b,c; 	gameCase base; 	base.h1 = 49; 	base.h2 = 49; 	base.h3 = 49; 	base.nextLink = -1; 	int gameIndex=0; 	allCases[gameIndex++] = base; 	int processing = 0,x; 	while (processing<=gameIndex) { 		a=allCases[processing].h1; 		b=allCases[processing].h2; 		c=allCases[processing].h3;   		gameCase t=cShift(a,b,c); 		for (x=0;x<gameIndex;x++) { 			if (gameEqual(allCases[x],t)) { 				break; 			} 		} 		if (x==gameIndex) { 			t.nextLink = processing; 			allCases[gameIndex++] = t; 		} 		t=cShift(b,c,a); 		for (x=0;x<gameIndex;x++) { 			if (gameEqual(allCases[x],t)) { 				break; 			} 		} 		if (x==gameIndex) { 			t.nextLink = processing; 			allCases[gameIndex++] = t; 		} 		t=cShift(c,a,b); 		for (x=0;x<gameIndex;x++) { 			if (gameEqual(allCases[x],t)) { 				break; 			} 		} 		if (x==gameIndex) { 			t.nextLink = processing; 			allCases[gameIndex++] = t; 		} 		t=acShift(a,b,c); 		for (x=0;x<gameIndex;x++) { 			if (gameEqual(allCases[x],t)) { 				break; 			} 		} 		if (x==gameIndex) { 			t.nextLink = processing; 			allCases[gameIndex++] = t; 		} 		t=acShift(b,c,a); 		for (x=0;x<gameIndex;x++) { 			if (gameEqual(allCases[x],t)) { 				break; 			} 		} 		if (x==gameIndex) { 			t.nextLink = processing; 			allCases[gameIndex++] = t; 		} 		t=acShift(c,a,b); 		for (x=0;x<gameIndex;x++) { 			if (gameEqual(allCases[x],t)) { 				break; 			} 		} 		if (x==gameIndex) { 			t.nextLink = processing; 			allCases[gameIndex++] = t; 		} 		processing++; 	} 	gameIndex--; 	 	int testCases=scanInt(); 	while (testCases--) {                	int count=0;     	gameCase start = getGame();     	for (count=0;count<gameIndex;count++) {             if(gameEqual(start,allCases[count])){                 start.nextLink=allCases[count].nextLink;                 break;             }         }     	int moves[8],value=0;     	count=0;     	while(start.nextLink!=-1) {             //printGame(start);             gameCase t=acShift(start.h1,start.h2,start.h3);     	    if (gameEqual(allCases[start.nextLink],t)) {                     moves[count++]=value+1;                     t.nextLink = allCases[start.nextLink].nextLink;                     start=t;     				continue;     	    }             t=acShift(start.h2,start.h3,start.h1);     	    if (gameEqual(allCases[start.nextLink],t)) {                     value=(value+1)%3;                     moves[count++]=value+1;                     t.nextLink = allCases[start.nextLink].nextLink;                     start=t;     				continue;     	    }             t=acShift(start.h3,start.h1,start.h2);     	    if (gameEqual(allCases[start.nextLink],t)) {                     value=(value+2)%3;                     moves[count++]=value+1;                     t.nextLink = allCases[start.nextLink].nextLink;                     start=t;     				continue;     	    }             t=cShift(start.h1,start.h2,start.h3);     	    if (gameEqual(allCases[start.nextLink],t)) {                     moves[count++]=value+4;                     t.nextLink = allCases[start.nextLink].nextLink;                     start=t;     				continue;     	    }             t=cShift(start.h2,start.h3,start.h1);     	    if (gameEqual(allCases[start.nextLink],t)) {                     value=(value+1)%3;                     moves[count++]=value+4;                     t.nextLink = allCases[start.nextLink].nextLink;                     start=t;     				continue;     	    }             t=cShift(start.h3,start.h1,start.h2);     	    if (gameEqual(allCases[start.nextLink],t)) {                     value=(value+2)%3;                     moves[count++]=value+4;                     t.nextLink = allCases[start.nextLink].nextLink;                     start=t;     				continue;     	    }         }         printf("%d\n",count);         for(int i=0;i<count;i++) {              printf("%d %d\n",(moves[i]-1)%3,(moves[i]>3));         }     } 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string a,b;         cin>>a>>b;         int n;         cin>>n;         string *array=new string[n];         for(int i=0;i<n;i++){             cin>>array[i];         }         long long dp[26]={0};         for(int i=0;i<a.length();i++){             dp[a[i]-97]++;         }         for(int i=0;i<b.length();i++){             dp[b[i]-97]++;         }         for(int i=0;i<n;i++){             for(int j=0;j<array[i].length();j++){                 dp[array[i][j]-97]--;             }         }         //for(int i=0;i<26;i++){            // cout<<dp[i]<<" ";         //}         //cout<<endl;         int flag=1;         for(int i=0;i<26;i++){             if(dp[i]<0){                 cout<<"NO"<<endl;                 flag=0;                 break;             }                      }         if(flag==1){             cout<<"YES"<<endl;         }     } }
#include<bits/stdc++.h> using namespace std; bool find(string a,string b){     int l1=a.length();     int l2=b.length();     int i=0,j=0;     while(i<l1 && j<l2){         if(a[i]==b[j]){             i++;             j++;         }         else{             j++;         }     }     if(j==l2 && i!=l1){         return false;     }     return true;      } int main(){     int t;     cin>>t;     while(t--){         string m,w;         cin>>m>>w;         if(m.length()>w.length() && find(w,m)==1){             cout<<"YES"<<endl;         }         else if(find(m,w)==1){             cout<<"YES"<<endl;         }         else{             cout<<"NO"<<endl;         }              } }
#include<bits/stdc++.h>  using namespace std;  #define fin freopen("i1.txt","r",stdin) #define pb(x) push_back(x) #define mp(x,y) make_pair(x,y) #define fastio ios_base::sync_with_stdio(false); cin.tie(0); #define ll long long #define oo(x) do{ for(int zo=1;zo<=5;zo++) cout<<x; cout<<"\n"; }while(0);  int main(){      ll t;     cin>>t;      while(t--) {         ll n;         cin>>n;          for(ll i=0;i<n;i++){             ll x=i%26;             cout<< string(1,x+'a') ;         }         cout<<"\n";     }      return 0; } 
#include <cstdio> #include <iostream> #include <cassert> #include <cstring> #include <cstdlib> #include <math.h>   using namespace std;    int main() { 	while (1) 	{ 		int score=0, click=0, users=0; 		char a[4]; 		cin>> click; 		if (click== 0) break; 		for(click>0; click--;) 		{ 			scanf("%s %d",a, &score); 			if (a[0]== 'P')score--; else score++; 			score=abs(score); 			if(score>users)             users = score;             else if( (users - score)%2)             users++; 			 		} 	printf("%d\n",users); 	 	} 	 }
#include<bits/stdc++.h> using namespace std; int visited[72][72]; int a[72][72]; int m,n; int dx,dy; int mn; bool isValid(int i,int j) {     if(i >= 0 && j >= 0 && i<m && j < n)         return true;     return false; } int c = 0; void dfs(int i,int j,int sum) {     if(i == dx && j == dy)     {         mn = min(mn,sum);         c++;         return;     }     int x[] = {1,-1,0,0};     int y[] = {0,0,1,-1};     int k;     for(k=0;k<4;k++)     {         int xx,yy;         xx = i+x[k];         yy = j+y[k];         if(isValid(xx,yy) && visited[xx][yy] == 0)         {             visited[xx][yy] = 1;             dfs(xx,yy,sum+a[xx][yy]);             visited[xx][yy] = 0;         }     }     return; } int main() {     int i,j,t;     cin>>m>>n;     for(i=0;i<m;i++)     {         for(j=0;j<n;j++)         {             cin>>a[i][j];         }     }     cin>>dx>>dy>>t;     mn = INT_MAX;     dx--;     dy--;     int dp[72][72];     for(i=0;i<m;i++)     {         for(j=0;j<n;j++)             dp[i][j] = 1000000;     }     //dfs(0,0,a[0][0]);     int k;     dp[0][0] = a[0][0];     for(k=0;k<m*(n-1)+n*(m-1);k++)     {         for(i=0;i<m;i++)         {             for(j=0;j<n;j++)             {                 if(i >= 1 && dp[i][j] > dp[i-1][j]+a[i][j])                     dp[i][j] = dp[i-1][j]+a[i][j];                 if(i < m-1 && dp[i][j] > dp[i+1][j]+a[i][j])                     dp[i][j] = dp[i+1][j]+a[i][j];                 if(j >= 1 && dp[i][j] > dp[i][j-1]+a[i][j])                     dp[i][j] = dp[i][j-1]+a[i][j];                 if(j < n-1 && dp[i][j] > dp[i][j+1]+a[i][j])                     dp[i][j] = dp[i][j+1]+a[i][j];                 //cout<<dp[i][j]<<" ";             }             //cout<<endl;         }      }     //cout<<dp[dx][dy]<<endl;     mn = dp[dx][dy];     if(mn <= t)     {         cout<<"YES"<<endl;         cout<<t-mn<<endl;     }     else         cout<<"NO"<<endl; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e9 + 7; void mul(LL (*A)[2], LL (*B)[2]){ 	LL C[2][2]; 	for(int i = 0;i < 2;++i){ 		for(int j = 0;j < 2;++j){ 			C[i][j] = 0; 			for(int k = 0;k < 2;++k){ 				C[i][j] = C[i][j] + A[i][k] * B[k][j]; 				C[i][j] %= MOD; 			} 		} 	} 	for(int i = 0;i < 2;++i){ 		for(int j = 0;j < 2;++j){ 			A[i][j] = C[i][j]; 		} 	} } void power(LL (*A)[2], LL N){ 	LL ans[][2] = 		{ 			{1, 0}, 			{0, 1} 		}; 	while(N > 0){ 		if(N & 1) 			mul(ans, A); 		mul(A, A); 		N >>= 1; 	} 	for(int i = 0;i < 2;++i){ 		for(int j = 0;j < 2;++j){ 			A[i][j] = ans[i][j]; 		} 	} } LL getAns(int N){ 	switch(N){ 		case 1: return 4; 		case 2: return 12; 	} 	LL ans[][2] =  		{ 			{2, 3}, 			{1, 0} 		}; 	power(ans, N - 2); 	return (ans[0][0] * 12) % MOD; } int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		int N; 		scanf("%d", &N); 		printf("%lld\n", getAns(N)); 	}  	return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long LL; LL fac[20]; int main(){ 	fac[0] = 1; 	for(int i = 1;i < 20;++i) 		fac[i] = i * fac[i - 1]; 	int t; 	cin >> t; 	while(t--){ 		string s; 		cin >> s; 		int N = s.size(); 		int cnt[10] = {0}; 		for(int i = 0;i < N;++i){ 			++cnt[s[i] - '0']; 		} 		LL ans = 0; 		for(int i = 0;i < N;++i){ 			for(int j = 0;j < (s[i] - '0');++j){ 				if(cnt[j] == 0) continue; 				LL curAns = fac[N - i - 1]; 				--cnt[j]; 				for(int k = 0;k < 10;++k){ 					curAns /= fac[cnt[k]]; 				} 				++cnt[j]; 				ans += curAns; 			} 			--cnt[s[i] - '0']; 		} 		printf("%lld\n", ans + 1); 	} 	return 0; }
#include<iostream> #include<stdio.h> //#define getchar_unlocked getchar   using namespace std;   /*struct cart{ int stime=0;             int av=1;             /*cart(){ stime=0;                     av=1;                    }           } ;*/            inline int fr() {         int ip=0;         char p=getchar_unlocked();         for(; p<33;) {                 p=getchar_unlocked();         }         while(p>32) {                 ip = (ip << 3) + (ip << 1) + (p - '0');                 p=getchar_unlocked();         }         return ip; }     int main(){ int cart[50]={0};     int n,m,q,p,r,c,test,comp,av;                     //for(int i=0;i<100;i++) cout<<car[i].av; system("PAUSE");     test=fr();     while(test--){   int carav[50]={0};                                 n=fr(); m=fr(); q=fr();p=fr(); r=fr(); c=fr();  comp=0, av=n;                   for(int i=1;i<=c;i++) {                           if(i%r==0 && m>0 ){                                         q=q+1;                                         m=m-1;                                          }                           for(int k=0;k<n;k++){                                                if(i-cart[k]==p && carav[k]==1) {comp++; carav[k]=0; av++;}                                                if(carav[k]==0 && q>0){                                                           cart[k]=i;                                                           carav[k]=1; q--; av--;}                                               }                                                                                                                                                                                        }                                                                        /*  for(int i=0;i<n;i++)                                                if(carav[i]==0)c1++;*/                                               printf("%d %d %d %d \n",av,comp,m,q);//c1<<" "<<comp<<" "<<m<<" "<<q<<endl;                                                      }                                                           //system("PAUSE");                           }
//KGP SUMMERS THROUGH dijkstra ALGORITHM #include<iostream> #include<cstdio> #include<list> #include<vector> #include<algorithm> #include<math.h> #define M 2505 #include<utility>  using namespace std;  int tres; int key[M]; int visit[M];  int min1() {     int m=1000000000,index;     for(int i=0;i<tres+2;i++)     {         if((m>key[i])&&(visit[i]==0))          {m=key[i];index=i;}      }      return index; }                   vector<pair<int,int> > dist[M];    int main() {     int t,n,a,b,c,i,j,k;          scanf("%d",&t);          while(t--)     {         scanf("%d",&tres);         int x[M];         int y[M];                 for(i=0;i<tres+2;i++)         {             visit[i]=0;             dist[i].clear();             key[i]=1000000000;         }             for(i=0;i<tres;i++)         {             scanf("%d%d",&x[i],&y[i]);                    //  printf("mayank %d %d %d\n",i,x[i],y[i]);         }                          scanf("%d %d",&x[i],&y[i]);            // printf("mayank %d %d %d\n",i,x[i],y[i]);         i=i+1;         scanf("%d %d",&x[i],&y[i]);        //     printf("mayank %d %d %d\n",i,x[i],y[i]);                 for(i=0;i<tres+2;i++)         {                      for(j=i+1;j<tres+2;j++)             {         //        printf("x[i]   %d x[j] %d  %d  %d \n\n",x[i],x[j],y[i],y[j]);                 int d=((x[i]-x[j])*(x[i]-x[j]))+((y[i]-y[j])*(y[i]-y[j]));               dist[i].push_back(make_pair(j,d));               dist[j].push_back(make_pair(i,d));           //      printf("%d    %d   dist[i][j]  %d\n",i,j,dist[i][j]);             }         }         key[tres]=0;                  for(i=0;i<tres+2;i++)         {             int u=min1();             visit[u]=1;           //  printf("mk %d   %d\n",u,key[u]);             vector<pair<int,int> >::iterator jt;             for(jt=dist[u].begin();jt!=dist[u].end();jt++)             {                  // printf("hi mauan this isme   %d    %d     %d\n",u,jt->first);                 if((visit[jt->first]==0)&&(key[jt->first]>(jt->second)+key[u]))                 {key[jt->first]=(jt->second)+key[u];                // printf("mdaasd   %d   %d    %d\n",u,jt->first,key[jt->first]);                 }                 }                            }                                      printf("%d\n",key[tres+1]);       //  system("pause");        }               }             
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string a;         cin>>a;         int length=a.length();         int oper=2;         for(int i=1;i<length;i++){             int dif=(int)a[i]-(int)a[i-1];             if(dif>=0){                 oper=oper+1+dif;             }             else{                 oper=oper+27+dif;             }         }         if(oper<=11*length){             cout<<"YES"<<endl;         }         else{             cout<<"NO"<<endl;         }     } }
/*  IF THIS COMMENT IS REMOVED THE PROGRAM WIint BLOW UP  *  *  Copyright (c) 2016, Aadil  *  Aint rights reserved.  *  *  This program is licensed under the F**cked_UP_Coder (FUP) License v0.2  *  *  You can use this program freely, if :  *  - this code works :P  *  - you are a FUP  */  #include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> #include <climits> #include <string> #include <queue> #include <stack> #include <map>  using namespace std;  typedef long long ll; typedef long double ld; typedef unsigned long long ull; #define input0based(arr, n) for(ll i = 0; i < n; ++i) cin >> arr[i]; #define input1based(arr, n) for(ll i = 1; i <= n; ++i)  cin >> arr[i]; #define forLoop(start, end) for(ll i = (start); i < (end); ++i)  int main() {          cin.sync_with_stdio(false);          ll t;     cin >> t;          vector<string> arr;     cin.clear();     cin.ignore(INT_MAX, '\n');     string temp;          ll z = t;     while (z-- > 0) {         getline(cin, temp);         arr.push_back(temp);     }          for (ll i = 0; i < t; ++i) {                  int ch[26] = { 0 };                  ll len = arr[i].length();                  for (ll j = 0; j < len; ++j) {             if (arr[i][j] >= 'A' && arr[i][j] <= 'Z')                 ++ch[tolower(arr[i][j]) % 97];             else if (arr[i][j] >= 'a' && arr[i][j] <= 'z')                 ++ch[arr[i][j] % 97];         }                           char x = '~';         for (ll i = 0; i < 26; ++i) {           //cout << ch[i] << " ";             if (ch[i] == 0) {                 x = i + 97;                 break;             }         }                  cout << x << endl;     }          return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int n;     cin>>n;     while(n>0){         int *array=new int[n];         for(int i=0;i<n;i++){             cin>>array[i];         }         sort(array,array+n);         int sum=0;         for(int i=n-1;i>1;i--){             int j=0;             int k=i-1;             while(k>j){                 if(array[j]+array[k]<array[i]){                     sum=sum+k-j;                     j++;                 }                 else{                     k--;                 }             }         }         cout<<sum<<endl;         cin>>n;     } }
#include<iostream> #include <sstream> #include<cstring> #include<algorithm>  using namespace std;  template <typename T>   string NumberToString ( T Number )   {      ostringstream ss;      ss << Number;      return ss.str();   }    int main(){  int k,base; long long a; cin>>a>>base>>k; for(int i=0;i<k;i++){ 	cout<<a%(base+1)<<" "; 	a = a/(base+1); } cout<<endl; return 0; }
#include <iostream> #include <algorithm> #include <cstdio> #include <queue> #include <math.h> #include <limits.h> #include <cstdlib> #include <string.h> #include <vector> #include <set> #include <map> #include <stack> using namespace std; //prankuragarwal #define ll         long long #define S(x)       scanf("%d", &x) #define Sl(x)      scanf("%lld", &x) #define Sd(x)      scanf("%lf", &x) #define P(x)       printf("%d\n", x) #define Pl(x)      printf("%lld\n", x) #define Pd(x)      printf("%lf\n", x) #define Pblank()   printf(" ") #define mem(x,y)   memset(x,y,sizeof(x)) #define F(x,y,z,i) for (x = y; x < z; x = x + i) #define mod 1000000007 int main() { 	ll int t; 	Sl(t); 	while(t--) {         ll int n; 		Sl(n); 		ll int i, tm; 		string str; 		map<ll int, string> m1; 		map<ll int, ll int> m2; 		map<ll int, ll int> :: iterator it;  		for(i = 0; i < n; i++) { 			cin >> str >> tm; 			m1[tm] = str; 			m2[tm]++; 		}  		for(it = m2.begin(); it != m2.end(); it++) { 			if(it->second > 1) { 				m2.erase(it); 			} 		}  		ll int sz = m2.size(); 		if(sz == 0) { 			cout << "Nobody wins." << endl; 		} 		else { 			it = m2.begin(); 			cout << m1[it->first] << endl; 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {        long long int n;     cin>>n;     if((n-1)%4==0) cout<<"ALICE"<<endl;     else cout<<"BOB"<<endl;     }     return 0; } 
#include <iostream> #include <cstdio> #include <cstring> #define ll long long using namespace std;  ll mod = 1000000007; ll n,b,q,a; ll num[200005]; ll suf[200005]; ll dp[200005];  int main() { 	// your code goes here 	 	memset(suf, 0 ,sizeof suf); 	memset(dp, 0 ,sizeof dp); 	 	scanf("%lld %lld",&n,&b); 	 	for(ll i=1;i<=n;i++) 		scanf("%lld",num+i); 	 	suf[b] = 1; 	dp[b] = 1; 	 	for(ll i=b-1;i>=1;i--){ 		ll temp = suf[i+1]-suf[i+num[i]+1]; 		temp = (temp+mod)%mod; 		dp[i] = temp; 		suf[i] = dp[i] + suf[i+1]; 		suf[i] %= mod; 	} 	 	 	scanf("%lld",&q); 	 	while(q--){ 		scanf("%lld",&a); 		printf("%lld\n",dp[a]); 	} 	 	return 0; }
#include <iostream> using namespace std;  int main() { 	int t,a[100009]={0},l,r,i,j; 	for(i=0;i<100009;i++) 	{ 		a[i]=1; 	} 	for(i=2;i<100009;i++) 	{ 		if(i%2) 		{ 			for(j=i;j<100009;j+=i) 			{ 				a[j]+=i; 			} 		} 	} 	long long int ans; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d %d",&l,&r); 		ans=0; 		for(i=l;i<=r;i++) 		{ 			ans+=a[i]; 		} 		printf("%lld\n",ans); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     long long a;     cin>>a;     if(a%6==0 || a%6==1 || a%6==3){         cout<<"yes";     }     else{         cout<<"no";     } }
#define DEBUG 1 #include <stdio.h> #include <string.h> #include <limits.h> #include <algorithm> using namespace std;   int dp[78][78][78][78]; int main(void) { int sum[78][78], Y, X, y, x, i, j, ans;   for(i=0;i<78;i++) sum[0][i]=sum[i][0]=0;   while(1) { scanf("%d%d", &Y, &X); if(!Y&&!X) break;   for(y=0;y<Y;y++) for(x=0;x<X;x++) { scanf("%d", &i); sum[y+1][x+1]=sum[y+1][x]+sum[y][x+1]-sum[y][x]+i; } int ans=INT_MIN;   for(y=Y-3;y>=0;y--) for(x=X-3;x>=0;x--) for(i=y+3;i<=Y;i++) for(j=x+3;j<=X;j++) { dp[y+1][x+1][i-1][j-1]=sum[i-1][j-1]-sum[i-1][x+1]-sum[y+1][j-1]+sum[y+1][x+1]; if(i-y>3) dp[y+1][x+1][i-1][j-1]=min(dp[y+1][x+1][i-1][j-1],min(dp[y+2][x+1][i-1][j-1],dp[y+1][x+2][i-1][j-1])); if(j-x>3) dp[y+1][x+1][i-1][j-1]=min(dp[y+1][x+1][i-1][j-1],min(dp[y+1][x+1][i-2][j-1],dp[y+1][x+1][i-1][j-2])); ans=max(ans,sum[i][j]-sum[i][x]-sum[y][j]+sum[y][x]-dp[y+1][x+1][i-1][j-1]); }   printf("%d\n", ans); } return 0; }
#include <bits/stdc++.h> using namespace std;  int main() {     int t;     cin>>t;     while(t--)     {         int h,m,res=0,s,g,i;         cin>>h>>m;         g=max(h,m);         s=min(h,m);         if(s<10)         res+=s;         else         res+=10;         for(i=11;i<=g;i=i+11)         {             if(i<g&&i<s)             res+=3;             else if(i<g&&(i%10)<s)             res++;         }         cout<<res<<endl;              } return 0; }
#include <stdio.h>   int main(){ 	int n, i, t; 	scanf("%d", &n); 	int s=0; 	for(i=0;i<n;i++){ 		scanf("%d", &t); 		s+=t; 	} 	if(s%2==0){ 		s=s/2; 	} 	else{ 		s = s/2 + 1; 	} 	if(n>s){ 		printf("%d\n", n); 	} 	else 		printf("%d\n", s); 	return 0; }
#include <stdio.h> #define gc getchar_unlocked   int getInt() { 	int x = 0; 	char c = gc(); 	while (c<'0'||c>'9') c=gc(); 	while (c>='0'&&c<='9') { 		x = (x<<3) + (x<<1) + c-'0'; 		c = gc(); 	} 	return x; }   typedef struct { 	int R1; 	int R2; 	int used; } Band;   Band band[1000]; int cubes[1000];   void sortCubes(int n) { 	for (int i = 0; i < n-1; i++) { 		int min_pos = i; 		for (int j = i+1; j < n; j++) { 			if (cubes[j] > cubes[min_pos]) 				min_pos = j; 		} 		if (i != min_pos) { 			int temp = cubes[i]; 			cubes[i] = cubes[min_pos]; 			cubes[min_pos] = temp; 		} 	} }   void sortBands(int m) { 	for (int i = 0; i < m-1; i++) { 		int min_pos = i; 		for (int j = i+1; j < m; j++) { 			if (band[j].R1 > band[min_pos].R1 ||  					band[j].R1 == band[min_pos].R1 && band[j].R2 < band[min_pos].R2) 				min_pos = j; 		} 		if (1 || i != min_pos) { 			int temp1 = band[i].R1, temp2 = band[i].R2; 			band[i].R1 = band[min_pos].R1, band[i].R2 = band[min_pos].R2; 			band[min_pos].R1 = temp1, band[min_pos].R2 = temp2; 		} 	} }   int packCubes(int n, int m) { 	int packed = 0; 	for (int i = 0; i < n; i++) { 		int l = cubes[i] * 7; 		for (int j = 0; j < m; j++) { 			if (band[j].used || band[j].R1 > l || band[j].R2 < l) 				continue; 			band[j].used = 1; 			//printf("%d %f %d %d\n", cubes[i], l, band[j].R1, band[j].R2); 			packed++; 			break; 		} 	} 	return packed; }   int main() { 	int T = getInt(); 	while (T--) { 		int N = getInt(); 		for (int i = 0; i < N; i++) 			cubes[i] = getInt(); 		sortCubes(N); 		int M = getInt(); 		for (int i = 0; i < M; i++) { 			band[i].R1 = getInt() * 11; 			band[i].R2 = getInt() * 11; 			band[i].used = 0; 		} 		sortBands(M); 		printf("%d\n", packCubes(N, M)); 	} 	return 0; }
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>  using namespace std;  struct pairs { 	int u, v; };  int main() { 	int T, N, M, i; 	cin>>T; 	while(T--) { 		cin >> N >> M; 		 		int s[N], ans[M]; 		pairs A[M]; 		for(i = 0; i<M ; ++i) { 			ans[i] = 0; 			cin >> A[i].u >> A[i].v; 		} 		 		for(i = 0; i<N; ++i) 			s[i] = 0;  		for(i = M-1; i>=0; --i) { 			if(s[A[i].u] || s[A[i].v]) 				continue; 			ans[i] = 1; 			s[A[i].u] = s[A[i].v] = 1; 			 		}			  		for(i = 0; i<M; ++i) 			if(ans[i]) 				cout<<i<<' '; 		cout<<endl; 	} } 
#include <iostream> #include <map> using namespace std;   int main() { 	// your code goes here 	int arr[100]; 	map<int,int> hash; 	int num_elem,i,j,res=0,key; 	cin>>num_elem; 	 	for(i=0;i<num_elem;i++) 		cin>>arr[i]; 	 	for(i=0;i<num_elem;i++) 		for(j=i+1;j<num_elem;j++){ 			key=arr[i]+arr[j]; 			hash[key]++; 			if(hash[key]>res) 				res=hash[key]; 	} 	 	cout<<2*res; } 
#include<iostream> #include<stdio.h> using namespace std; #define max 1000000007 long long recursion(long long dp[][1005],int n,int i) { long long sum=0;  if(i>n) return 0; if(n<=0) return 0;  if(dp[n][i]==-1) { dp[n][i]=(recursion(dp,n-1,i-1)+(recursion(dp,n-1,i)*i)%max)%max;  } return dp[n][i];  }   int main() { int T,n=1001,i,j; long long dp[1005][1005],ans; for(i=1;i<=n;i++) for(j=1;j<=n;j++) dp[i][j]=-1; dp[1][1]=1; for(i=0;i<=n;i++) { dp[0][i]=0; dp[i][0]=0; }  scanf("%d",&T); while(T--) { scanf("%d",&n);  ans=0; for(i=1;i<=n;i++) ans=(ans+recursion(dp,n,i))%max; printf("%lld\n",ans); }  }
#include<iostream> #include<cstdio> #include<vector> #include<algorithm>   using namespace std;   int a[1005],n,visited[1005];   int main() { 	scanf("%d",&n); 	for (int i=1;i<=n;i++) scanf("%d",&a[i]); 	int i=1,z=0; 	visited[i]=true; 	//printf("1 "); 	vector<int> ans; 	ans.push_back(1);	 	while (1) { 		i=a[i]; //		printf("%d ",i); 		ans.push_back(i); 		if (visited[i]) { //			printf("\n"); 			ans.push_back(-1); 			int temp=-1; 			for (int j=1;j<=n;j++) if (!visited[j]){ temp=j;break;} 			if (temp==-1)break; 			else { 				i=temp; //				printf("%d ",i); 				ans.push_back(i);	 			} 		} 		visited[i]=true; 	} 	int sz=ans.size(); 	int r=0; 	for (int i=0;i<sz;i++) if (ans[i]==-1)r++; 	printf("%d\n",r); 	for (int i=0;i<sz;i++) { 		if (ans[i]==-1)printf("\n"); 		else printf("%d ",ans[i]); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; int A[MAXN]; int leftEdge[MAXN]; int rightEdge[MAXN]; vector<pair<int, int> > pairs; int main(){     int t;     cin >> t;     while(t--){         int N, M;         scanf("%d%d", &N, &M);         for(int i = 1;i <= N;++i){             scanf("%d", &A[i]);         }         pairs.clear();         for(int i = 1;i <= M;++i){             int x, y;             scanf("%d%d", &x, &y);             pairs.push_back(make_pair(x, y));         }         for(int i = 1;i <= N;++i){             leftEdge[i] = rightEdge[i] = i;         }         for(int i = 0;i < M;++i){             rightEdge[pairs[i].first] = max(rightEdge[pairs[i].first], pairs[i].second);             leftEdge[pairs[i].second] = min(leftEdge[pairs[i].second], pairs[i].first);         }         for(int i = 2;i <= N;++i){             rightEdge[i] = max(rightEdge[i], rightEdge[i - 1]);         }         for(int i = N;i >= 1;--i){             rightEdge[i] = rightEdge[rightEdge[i]];         }         for(int i = N - 1;i >= 1;--i){             leftEdge[i] = min(leftEdge[i], leftEdge[i + 1]);         }         for(int i = 1;i <= N;++i){             leftEdge[i] = leftEdge[leftEdge[i]];         }         bool is = true;         for(int i = 1;i <= N;++i){             is &= (leftEdge[i] <= A[i] && A[i] <= rightEdge[i]);         }         if(is){             printf("Possible\n");         } else printf("Impossible\n");     }     return 0; } 
#include <vector> #include <string.h> #include <stdio.h> #include <iterator> #include <iostream> #include <list>  #include <map> #define  pb push_back using namespace std;  int main()  { 	list<int>  adj[10]; 	char s[100005]; 	vector<int> v; 	list <int> :: iterator it; //	queue <int> q; 	int i,j,cv,len,flag=0,t; 	adj[0].pb(4); 	adj[0].pb(5); 	adj[0].pb(1); 	adj[1].pb(0); 	adj[1].pb(6); 	adj[1].pb(2); 	adj[2].pb(1); 	adj[2].pb(3); 	adj[2].pb(7); 	adj[3].pb(4); 	adj[3].pb(2); 	adj[3].pb(8); 	adj[4].pb(0); 	adj[4].pb(3); 	adj[4].pb(9); 	adj[5].pb(8); 	adj[5].pb(7); 	adj[5].pb(0); 	adj[6].pb(9); 	adj[6].pb(8); 	adj[6].pb(1); 	adj[7].pb(9); 	adj[7].pb(5); 	adj[7].pb(2); 	adj[8].pb(5); 	adj[8].pb(6); 	adj[8].pb(3); 	adj[9].pb(4); 	adj[9].pb(6); 	adj[9].pb(7); 	map<int,char> m; 	m[0]='A'; 	m[1]='B'; 	m[2]='C'; 	m[3]='D'; 	m[4]='E'; 	m[5]='A'; 	m[6]='B'; 	m[7]='C'; 	m[8]='D'; 	m[9]='E'; 	scanf("%d",&t); 	while(t--) { 	scanf("%s",s); 	i=0; 	len=strlen(s); 	cv=s[i]-65; 	v.pb(cv); 	i++; 	while(i<len) 	{ 		//cout<<t<<"\n"; 		for(it=adj[cv].begin();it!=adj[cv].end();it++) 			if(m[*it]==s[i]) 			{ 				v.pb(*it); 				i++; 				break; 				 			} 		if(it==adj[cv].end()) 			break; 		else 			cv=*it; 	} 	if(i==len) 		for(j=0;j<v.size();j++) 			printf("%d",v[j]); 	else 	{ 		i=0; 		v.clear(); 		cv=s[i]-65+5; 		v.pb(cv); 		i++; 		while(i<len) 		{ 	//		cout<<cv; 			for(it=adj[cv].begin();it!=adj[cv].end();it++) 				if(m[*it]==s[i]) 				{ 					v.pb(*it); 					i++; 					break; 				} 			if(it==adj[cv].end()) 				break; 			else 				cv=*it; 		} 		if(i==len) 			for(j=0;j<v.size();j++) 				printf("%d",v[j]); 		else 			printf("-1"); 	} 	printf("\n"); 	v.clear(); } 	return 0; }
#include<bits/stdc++.h> using namespace std;  int main() {     int t;     cin>>t;     while(t--)     {         int ans=0;         string s;         cin>>s;         int n;         cin>>n;         /*for(int x,y,sp=0;sp<12*n;sp++)         {             y=sp;             while(true)             {                 x=y;                 for(int i=0;i<s.length();i++)                     x +=s[i]-'R';                 if(x>=12*n)                     break;                 y=x;                 ans++;             }          }*/         int l=0;         for(int i=0;i<s.length();i++)             l +=s[i]-'R';         for(int i=l;i<12*n;i +=l)             ans +=12*n-i;           cout<<ans<<endl;     }     return 0; } 
#include <iostream> #include <stdio.h> using namespace std; int main(){     int t;     scanf("%d",&t);     while(t--){         int i,n,min,arr[100000],tmp=0;         scanf("%d",&n);         for(i=0;i<n;i++){             scanf("%d",&arr[i]);         }         min=arr[0];         for(i=0;i<n-1;i++){             if((arr[i+1] > min) && (tmp < arr[i+1]-min))                 tmp=arr[i+1]-min;             if(arr[i+1] < min)                 min=arr[i+1];         }         if(tmp==0)             printf("UNFIT \n");         else             printf("%d \n",tmp);      } } 
#include <iostream> using namespace std; int main() { 	int t;long long int i,l,d,s,c; 	cin>>t; 	while(t-->0) 	{int f=0; 		cin>>l>>d>>s>>c; 		long long int ans=s; 		if(d==1) {if(ans>=l){f=1;cout<<"ALIVE AND KICKING"<<endl;continue;} 				 } 		for(i=1;i<d;i++) 		{ 			ans=ans+ans*c; 			if(ans>=l){f=1;cout<<"ALIVE AND KICKING"<<endl;break;} 		} 		if(f==0) cout<<"DEAD AND ROTTING"<<endl; 	}//end of while 	 	return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long LL; vector<pair<LL, LL> > A; int main(){     LL N, M, H;     cin >> N >> M >> H;     for(int i = 1;i <= H;++i){         LL T, C;         scanf("%lld%lld", &T, &C);         A.push_back(make_pair(C, T));     }     sort(A.begin(), A.end());     LL ans = 0;     LL cnt = 0;     for(int i = 0;i < H;++i){         LL cur = min(N * M - cnt, A[i].second);         ans += cur * A[i].first;         cnt += cur;     }     if(cnt != N * M){         printf("Impossible\n");     } else {         printf("%lld\n", ans);     }     return 0; } 
#include <iostream> #include <cstdio> #include <cmath> #include <cstdlib> using namespace std; int arr[100005][2];  typedef struct A { long long x, y; };   int comp(const void *a, const void *b) {  A *i1, *i2;  i1=(A*)a; i2=(A*)b;  if(i1->x > i2->x) return 1;  if(i1->x == i2->x && i1->y < i2->y) return 1;  return 0; }  int main() {  // your code goes here  int t, n, i;  double dis;  A arr[100005];  scanf("%d", &t);  while(t--) {   scanf("%d", &n);    for(i=0; i<n; i++) cin>>arr[i].x>>arr[i].y;   qsort(arr, n, sizeof(A), comp);   dis=0;   for(i=1; i<n; i++) dis=dis+sqrt((arr[i].x-arr[i-1].x)*(arr[i].x-arr[i-1].x)+(arr[i].y-arr[i-1].y)*(arr[i].y-arr[i-1].y));   printf("%.2f\n", dis);  }  return 0; }
#include <stdio.h>   const int ABSENT = 0, PRESENT = 1, TRUE = 1, FALSE = 0;   char In_Buff[22][20] = {"AH KH QH TH JH", \ 								"KH 5S 3C 5C 7D", \ 								"QH QD 2S QC 2C", \ 								"QH QD QS QC 2C", \ 								"6H 2H 3H 4H 5H",\ 								"6H 2H KH 4H 5H",\ 								"6H 2H 3S 4H 5H",\ 								"AH AS 2S AC 5H",\ 								"AH AS 3S 8C 8H",\ 								"AH KS 3S 8C 8H",\ 								"AH KS 3S 6C 8H",\ 							  };   /* char In_Buff[22][16] = {"KH AH QH TH JH", \ 								"AS KS QS TS JS", \ 								"AD KD QD TD JD", \ 							  }; */ const char Result[11][20] = {"royal flush", \ 									  "straight flush", \ 									  "four of a kind", \ 									  "full house", \ 									  "flush", \ 									  "straight", \ 									  "three of a kind", \ 									  "two pairs", \ 									  "pair", \ 									  "high card", \ 									 }; char Card_Stack[4][16]; // 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 // A  2  3  4  5  6  7  8  9  T  J   Q   K   A   x   x     void Calculate_Result(char *cTemp); void Adjust_Array(char *cTemp); int Royal_Flush(void); int Straight_Flush(void); int Four_Of_A_Kind(void); int Full_House(void); int Flush(void); int Straight(void); int Three_Of_A_Kind(void); int Two_Pairs(void); int Pair(void); void Debug_Array(void);   int main(void){  int i,j;  int iInput;  char Garbage[10];  //iInput = 11;  /*--------->>>>>>scan input data <<<<<<------------*/  scanf("%d",&iInput);  for(i= 0; i < iInput;i++){ 	for(j=0;j<5;j++){ 	  scanf("%s",&Garbage);//In_Buff[i][j]); 	  In_Buff[i][0+(j*3)] =  Garbage[0]; 	  In_Buff[i][1+(j*3)] =  Garbage[1]; 	  In_Buff[i][2+(j*3)] =  ' '; 	}  }  /*--------->>>>>>Output data <<<<<<------------*/  for(i=0; i< iInput; i++){ 	Calculate_Result(In_Buff[i]); //	printf("\n%s",Result[i]);  }  /*--------->>>>>>Output data <<<<<<------------*/  return(0); }   void Calculate_Result(char *cTemp){  // printf("\n %s",cTemp);   Adjust_Array(cTemp);   if(Royal_Flush()){ 	 printf("\nroyal flush"); 	 return;   }   if(Straight_Flush()){ 	 printf("\nstraight flush"); 	 return;   }   if(Four_Of_A_Kind()){ 	 printf("\nfour of a kind"); 	 return;   }   if(Full_House()){ 	 printf("\nfull house"); 	 return;   }   if(Flush()){ 	 printf("\nflush"); 	 return;   }   if(Straight()){ 	 printf("\nstraight"); 	 return;   }   if(Three_Of_A_Kind()){ 	 printf("\nthree of a kind"); 	 return;   }   if(Two_Pairs()){ 	 printf("\ntwo pairs"); 	 return;   }   if(Pair()){ 	 printf("\npair"); 	 return;   }   printf("\nhigh card"); return;   }   //void Adjust_Array( char *cTemp) //this array fills the Card_Stack global array with the cards present or not //at the corresponding location. void Adjust_Array( char *cTemp){ int i,j; int tempValue, tempSet, Set;   for(i=0; i< 4; i++) 	 for(j=0; j< 16; j++) 		Card_Stack[i][j] = ABSENT;     for(i = 0; i<14; i++){ 	 tempValue  = cTemp[i]; 	 i++; 										//move to next char in string. 	 tempSet = cTemp[i]; //	 printf("[%c%c]",tempValue,tempSet); 	 i++;                              //skip the spaces.   	 switch(tempSet){ 		case 'S': Set = 0; break; 		case 'H': Set = 1; break; 		case 'D': Set = 2; break; 		case 'C': Set = 3; break; 	 } 	 switch(tempValue){ 		case 'A': 					Card_Stack[Set][0]  = 'A';//PRESENT; 					Card_Stack[Set][13] = 'A';//PRESENT; 					break; 		case 'T': 					Card_Stack[Set][9]   = 'T';//PRESENT; 					break; 		case 'J': 					Card_Stack[Set][10]  = 'J';//PRESENT; 					break; 		case 'Q': 					Card_Stack[Set][11]   = 'Q';//PRESENT; 					break; 		case 'K': 					Card_Stack[Set][12]   = 'K';//PRESENT; 					break; 		case '2': 		case '3': 		case '4': 		case '5': 		case '6': 		case '7': 		case '8': 		case '9': 					Card_Stack[Set][tempValue - '1']  = tempValue; 					break; 	 }   } }   int Royal_Flush(void){ int i,j,ser; ser = 0;   for(i=0; i< 4; i++){ 	 for(j=9; j< 16; j++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 		  else ser = 0; 		  if(ser == 5) return (TRUE); 	 }   }   return (FALSE); }   int Straight_Flush(void){ int i,j,ser; ser = 0;   for(i=0; i< 4; i++){ 	 for(j=0; j< 16; j++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 		  else ser = 0; 		  if(ser == 5) return (TRUE); 	 }   }   return (FALSE); } int Four_Of_A_Kind(void){ int i,j,ser; ser = 0;   for(j=0; j< 16; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 4) return (TRUE);   }   return (FALSE); }   int Full_House(void){ int i,j,ser; ser = 0;   for(j=0; j< 16; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 3) break;   }   if(ser != 3)  return (FALSE);   for(j=0; j< 16; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 2) return (TRUE);   }   return (FALSE);   } int Flush(void){ int i,j,ser; ser = 0;   for(i=0; i< 4; i++){ 	 ser = 0; 	 for(j=0; j< 13; j++){   //ACE Should not be counted twice!!!! 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 		  if(ser == 5) return (TRUE); 	 }   }   return (FALSE); }   int Straight(void){ int i,j,ser; char Temp_Stack[16];   for(j=0; j< 16; j++){   Temp_Stack[j] = Card_Stack[0][j] | Card_Stack[1][j] | Card_Stack[2][j] | Card_Stack[3][j] ; } ser = 0; for(j=0; j< 16; j++){   if(Temp_Stack[j] != ABSENT) ser += 1;   else ser = 0;   if(ser == 5) return (TRUE); } return (FALSE); }   int Three_Of_A_Kind(void){ int i,j,ser; ser = 0;   for(j=0; j< 16; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 3) return (TRUE);   }   return (FALSE); } int Two_Pairs(void){ int i,j,ser; ser = 0;   for(j=0; j< 13; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 2) break;   }   if(ser != 2)  return (FALSE);   j++;   for(; j< 13; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 2) return (TRUE);   }  return (FALSE);     } int Pair(void){ int i,j,ser; ser = 0;   for(j=0; j< 13; j++){ 	 ser = 0; 	 for(i=0; i< 4; i++){ 		  if(Card_Stack[i][j] != ABSENT) ser += 1; 	 } 	 if(ser == 2) return(TRUE);   }  return (FALSE);   } void Debug_Array(void){ int i,j;   printf("\n********Debug Out**********");   for(i=0; i< 4; i++){ 	 printf("\n %d[  ",i); 	 for(j=0; j< 16; j++){ 		  if(Card_Stack[i][j] != ABSENT) printf("%c",Card_Stack[i][j]); 		  else printf("0"); 		  if( !((j+1)%5)) printf(" "); 	 } 	 switch(i){ 		case 0: printf("  ] SPADE"); break; 		case 1: printf("  ] HEARTS"); break; 		case 2: printf("  ] DIAMONDS"); break; 		case 3: printf("  ] CLUBS"); break; 	 }   }   printf("\n******Debug Out***********");   return ; } 
#include<stdio.h>  int  primecheck(int num) {     int i;     for(i=2;i<=num/2;i++)     {         if(num%i==0)             return 0;     }         return 1; }  int main() {     long int t,x,y;     int sum;     scanf("%ld",&t);      while(t--)     {         scanf("%ld %ld",&x,&y);          sum=x+y+1;         for(sum=x+y+1;;sum++)         {              if(primecheck(sum))             {                 printf("%d\n",sum-x-y);                 break;              }         }      }     return 0;  } 
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<cmath> #include<ctime> #include<cassert>  using namespace std;  #define MEM(a,b) memset(a,(b),sizeof(a)) #define MAX(a,b) ((a) > (b) ? (a) : (b)) #define MIN(a,b) ((a) < (b) ? (a) : (b)) #define MP make_pair #define pb push_back    #define M 1000000007 #define maxt 1000  typedef long long  LL;   LL maxn=1;   int main() {    int i,j,k,T,p,q,a;    for(i=0;i<9;i++) maxn*=10;    cin>>T;    assert(T>=1 && T<=1000);    while(T--)    {       LL L,R;       cin>>L>>R;        assert(L>=1 && R>=L && R<=maxn);        LL p=1;       LL ans=0;        for(i=1;i<=10;p*=10,i++)       {          LL q=p*10-1;           LL x=MAX(p,L);          LL y=MIN(q,R);           if(x>y) continue;           x%=M;          y%=M;          LL r= ( y*(y+1)/2 - x*(x-1)/2)%M;          r=(r*i)%M;           ans=(ans+r)%M;       }        if(ans<0) ans+=M;       cout<<ans<<endl;    }  	return 0; } 
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>  using namespace std;  int max(int a , int b) { 	if(a < b) 		return b; 	else 		return a; }  int main() { 	int T, N, W; 	cin>>T; 	while(T--) { 		cin >> N >> W; 		 		int i, j, C[N+1], P[N+1], T[N+1]; 		 		for(i = 1 ; i<N+1; ++i)  			cin >> C[i] >> P[i] >> T[i];  		int A[W+1][N+1]; 		for(i = 0; i<W+1; ++i) 			A[i][0] = 0;  		for(j = 0; j<N+1; ++j) 			A[0][j] = 0;  		for(i = 1; i<W+1; ++i) { 			for(j = 1; j<N+1; ++j) { 				if(i-T[j]>=0) 					A[i][j] = max((P[j] * C[j]) + A[i-T[j]][j-1], A[i][j-1]); 				else 					A[i][j] = A[i][j-1]; 			} 		} 		 		cout<<A[W][N]<<endl; 	} } 
#include<bits/stdc++.h> using namespace std; typedef long double LD; int main(){     int t;     cin >> t;     while(t--){         LD pa;         cin >> pa;         LD ans = max((LD)0, 1 - 2*pa) * 10000 + 10000 * pa + 2 * pa * (1 - pa) * 10000;         printf("%.6Lf\n", ans);     }      return 0; } 
        #include<iostream>         #include<stdio.h>         #include<map>         #include<math.h>         #include<string.h>         #include<vector>         #include<queue>         #include<list>         #include<iomanip>         #include<algorithm>         #define FOR(i,a,b) for(long long int i=(a);i<=(b);++i)         #define NFOR(i,a,b) for(long long int i=(a);i>=(b);--i)         #define pb push_back         #define ll long long         using namespace std;        ll p[100001];         void gprime()         {         	FOR(i,0,100000)         	p[i]=1;         	p[0]=0;p[1]=0;         	for(int i=2;i*i<=100000;++i)         	{         		if(p[i]){         		for(int j=2*i;j<=100000;j+=i)         		p[j]=0;}}         }         int main()         {         	ll t;         	cin>>t;         	gprime();         	ll cd[1000005]={0};         	while(t--)         	{         		ll l,r;         		ll count=0;         		cin>>l>>r;         		FOR(i,l,r)         		cd[i-l]=0;         		for(ll i=1;i*i<=r;++i)         		{         	     for(ll j=((l-1)/i+1)*i;j<=r;j+=i)         	     {         	     	if(j<i*i);         	     	else if(j==i*i)         	     	cd[j-l]++;         	     	else if(j>i*i)         	     	cd[j-l]+=2;         	     }         		}         		         		FOR(i,l,r)         			{if(p[cd[i-l]])         			{++count;}         		}         		cout<<count<<endl;         	}         	return 0;         }  
#include <stdio.h> #define N 100 int a[N]; int main() {     int t, n, k, i, j, k1, x, c;      scanf("%d", &t);     while(t--) {         scanf("%d%d", &n, &k);           x = 0;           for(i=0; i<n; i++) {             scanf("%d", &a[i]);         }                  for (i = 0; i < n; i++) { 			for (j = i; j < n; j++) { 				c = 0; 				for (k1 = i; k1 <= j; k1++) { 					if (a[k1] % 2 == 0) { 						c++; 					} 				} 				if (c == k) { 					x = 1; 				} 			} 		}                  if(x)             printf("YES\n");         else             printf("NO\n");              }           	return 0; }  
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; bool sieve[MAXN]; vector<int> first(MAXN, 0); vector<int> second(MAXN, 0); vector<int> third(MAXN, 0);  vector<int> secondAns(MAXN, 0); vector<int> thirdAns(MAXN, 0); vector<int> primes; void preprocess(){     memset(sieve, 1, sizeof sieve);     sieve[0] = sieve[1] = 0;     for(int i = 2;i * i < MAXN;++i){         if(sieve[i]){             for(int j = i * i;j < MAXN;j += i){                 sieve[j] = false;             }         }     }     for(int i = 0;i < MAXN;++i){         first[i] = 0;         if(sieve[i]) {             first[i] = i;             primes.push_back(i);         }     }     int sz = primes.size();     for(int i = 0;i < MAXN;++i){         for(int j = 0;j < sz;++j){             int p = primes[j];             int q = p * p;             if(q > i) break;             if(first[i - q] != 0){                 second[i] = q;                 secondAns[i] = p;                 break;             }         }     }     for(int i = 0;i < MAXN;++i){         for(int j = 0;j < sz;++j){             int p = primes[j];             int q = p * p * p;             if(q > i) break;             if(second[i - q] != 0){                 third[i] = q;                 thirdAns[i] = p;                 break;             }         }     } } int main(){     preprocess();     int N;     while(scanf("%d", &N) != EOF && N != 0){         int A, B, C;         C = thirdAns[N];         N -= third[N];         B = secondAns[N];         N -= second[N];         A = first[N];         if(C == 0) A = B = 0;         printf("%d %d %d\n", A, B, C);     }     return 0; } 
#include <iostream> #include <math.h> #include <stdlib.h> using namespace std;  int n; long long int D[100000];  void readInp() { 	cin>>n; 	for(int i=0; i<n; i++){ 		cin>>D[i]; 	} } void calc() { 	int p1=0, p2=0; 	long long ans=0; 	while(true){ 		while(p1<n && D[p1]<=0){ 			p1++; 		} 		while(p2<n && D[p2]>=0){ 			p2++; 		} 		if(p1<n && p2<n){ 			ans += min(D[p1],-D[p2]) * abs(p2-p1); 			if(D[p1] < -D[p2]){ 				D[p2] = D[p2] + D[p1]; 				D[p1] = 0; 			}else{ 				D[p1] = D[p2] + D[p1]; 				D[p2] = 0; 			} 		} 		else 			break; 	} 	cout<<ans<<endl; } int main(int argc, char const *argv[]) { 	int t; 	cin>>t; 	while(t){ 	readInp(); 	calc(); 	t--; 	} 	return 0; }
//ANIKET #include<stdio.h> int main() { int T; unsigned int   T1,T2,T3,T4; double  ans=0.0000,temp=0.00,temp2=0.0; scanf("%d",&T); while(T--)  {   scanf("%d %d %d %d",&T1,&T2,&T3,&T4);   temp=(T1+T2);   temp2=(double)T1/(double)temp;   //printf("temp=%.6lf",temp2);   printf("\n%.6lf",temp2);  } return 0; }
#include<iostream> #include<cstdio> using namespace std; int main(){ 	int t; 	scanf("%d",&t); 	for(int i=0;i<t;i++) 	{ 		 		long long int n,a,count1=0,sum=0,count2=0; 		scanf("%lld",&n); 		for(long long int j=0;j<n;j++) 		{ 			scanf("%lld",&a); 		             if(a==2)      			 { 			 	count1++; 			 	count2++; 			 } 			 else if(a>2) 			   count1++; 		} 		long long int ans= (count1*(count1-1))/2- (count2*(count2-1))/2; 		printf("%lld\n",ans); 	}     	return 0; } 
#include <iostream> #include <string.h> using namespace std;  char inp[1000000];  bool isPallindromePossible(char inp[]) { 	int n = strlen(inp);  	int p1=0, p2=n-1; 	int pos1=0,pos2=0; 	while(p1<=p2){ 		if(inp[p1]==inp[p2]){ 			p1++; 			p2--; 		}else{ 			pos1 = p1; 			pos2 = p2; 			break; 		} 	} 	if(p1>p2) 		return true; 	p1 = 0, p2 = n-1; 	bool firstInvalid = false, secondInvalid = false; 	while(p1 <= p2){ 		if(p1==pos1) 			p1++; 		if(inp[p1] != inp[p2]){ 			firstInvalid = true; 			break; 		}else{ 			p1++; 			p2--; 		} 	} 	if(p1>p2) 		return true; 	p1 = 0, p2 = n-1; 	while(p1 <= p2){ 		if(p2==pos2) 			p2--; 		if(inp[p1] != inp[p2]){ 			secondInvalid = true; 			break; 		}else{ 			p1++; 			p2--; 		} 	} 	if(firstInvalid && secondInvalid) 		return false; 	 	return true; }  void readInp(char inp[]) { 	cin>>inp; } int main() { 	int t; 	cin>>t; 	while(t){ 	readInp(inp); 	bool res = isPallindromePossible(inp); 	if(res) 		cout<<"YES"<<endl; 	else 		cout<<"NO"<<endl; 	t--; 	} }
#include <bits/stdc++.h> #define ll long long int using namespace std;  int main() {     vector<ll> r,g,b;     ll t,a,p,c,i,m,ans;     cin>>t;     while(t--)     {         cin>>a>>p>>c>>m;         r.resize(a);         g.resize(p);         b.resize(c);         for(i=0;i<a;i++)             cin>>r[i];         for(i=0;i<p;i++)             cin>>g[i];         for(i=0;i<c;i++)             cin>>b[i];         sort(r.rbegin(),r.rend());         sort(g.rbegin(),g.rend());         sort(b.rbegin(),b.rend());         while(m--)         {             if(r[0]>=g[0] && r[0]>=b[0])             {                 for(i=0;i<a;i++)                     r[i]/=2;             }             else if(g[0]>=r[0] && g[0]>=b[0])             {                 for(i=0;i<p;i++)                     g[i]/=2;             }             else             {                 for(i=0;i<c;i++)                     b[i]/=2;             }         }         if(r[0]>g[0])             ans=r[0];         else             ans=g[0];         if(ans<b[0])             ans=b[0];         cout<<ans<<endl;     }     return 0; } 
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>  using namespace std;  struct pairs { 	int u, v; };  int main() { 	int T, A, B; 	cin>>T; 	while(T--) { 		cin>>A>>B; 		if(A%2 && B%2) 			cout<<"Vanka"<<endl; 		else 			cout<<"Tuzik"<<endl; 	} } 
#include<stdio.h>  main()  {  	int t,b;  	int i,s,e,l,j,ctr ;  	scanf("%d",&t);  	bool ispainted[501][10];  	  	while(t--)  	{  		scanf("%d",&b);  		for(i=0;i<501;i++)  		  for(j=0;j<10;j++)  		    ispainted[i][j]=false;  		    ctr=0;  		while(b--)  		{  			scanf("%d%d%d",&s,&e,&l);  			for(i=s;i<=e;i++)  		    {  			   ispainted[i][l]=true;	  		    }  	       }  	    for(i=1;i<501;i++)  	     {for(j=0;j<9;j++)  	       {  				if(ispainted[i][j] && ispainted[i][j+1])  				  {  					ctr+=1;  					break;	  				  }  				  			}  		 }  		 printf("%d\n",500-ctr);      }  }  
#include <cstdio> #include <algorithm> using namespace std;  #define mod 1000000007  int ret, n, m, comb[1000000 + 5][6], i, j;  int func (int n) { 	if (n < 6) return 0; 	return comb[n - 6 + 5][5]; }  int main () { 	scanf("%d", &n); 	comb[0][0] = 1; 	for(i = 1; i <= n; i++) for(j = 1, comb[i][0] = 1; j <= 5; j++) comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % mod; 	for(i = 1; i <= n; i++) if ((n - i) % 2 == 0) ret = (ret + func((n - i) / 2)) % mod; 	printf("%d\n", ret); 	return 0; }
#include <iostream> using namespace std;  int noOfElements; long long totalSum;  void generateRankList() { 	long long int total = noOfElements; 	total = (total * (noOfElements + 1)) / 2; 	long long int diff = total - totalSum; 	int rank = noOfElements; 	int count = 0; 	while(diff>0 && rank>0)         {             if (rank-1>=diff) diff=0;             else             {                 diff = diff - rank + 1;             }             rank--;             count++;         } 	cout<<count<<endl; }  void readInp() { 	cin>>noOfElements>>totalSum; }  void calc() { 	generateRankList(); }  int main(int argc, char const *argv[]) { 	int noOftests; 	cin>>noOftests; 	for(int i=0; i<noOftests; i++){ 		readInp(); 		calc(); 	} 	return 0; }
#include <bits/stdc++.h>  #define FOR(i,a,b) for(int i= a; i<= b; i++) #define FORD(i,a,b) for(int i= a; i>= b; i--) #define For(i,a,b) for(int i= a; i< b; i++) #define Ford(i,a,b) for(int i= a; i> b; i--) #define FORE(i,v) for (__typeof((v).begin()) i=(v).begin();i!=(v).end();i++) #define Fill(s,a) memset(s,a,sizeof(s)); #define pb push_back #define mp make_pair #define fi first #define se second  using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int, int> pii; typedef unsigned long long ull;  const int N = 100100;  int findColor(int x) {     int level = 0;     while (x != 1)     {         x/= 2;         level++;     }     return level % 2; }  int main() {     ios_base::sync_with_stdio(false);     //freopen("test.inp","r",stdin);     //freopen("test.out","w",stdout);     int q;     cin >> q;      int fl = 0;     while (q--)     {         string type;         int x, y;         cin >> type;         if (type != "Qi") cin >> x >> y;         if (type == "Qi") fl = 1 - fl;         else         {             int cnt[2];             Fill(cnt,0);             int colorX = findColor(x);             if (fl) colorX = 1 - colorX;             int colorY = findColor(y);             if (fl) colorY = 1 - colorY;             while (x != y)             {                 if (x > y)                 {                     cnt[colorX]++;                     colorX = 1 - colorX;                     x/= 2;                 }                 else                 {                     cnt[colorY]++;                     y/= 2;                     colorY = 1 - colorY;                 }             }             cnt[colorX]++;             if (type == "Qb") cout << cnt[0] << endl;             else cout << cnt[1] << endl;         }     }     return 0; } 
#include <iostream> #include <cstdio> #include <map> #include <set> #include <string> #include <cstring> #include <sstream> #include <vector> #include <queue> #include <deque> #include <bitset> #include <cmath> #include <stack> #include <algorithm> #include <cctype> #include <fstream> #include <cassert> #include <iomanip> using namespace std; #define pb push_back #define FOR(i,ini,fin) for(int i=(int)ini;i<(int)fin;i++) #define FOR_INC(i,ini,fin,inc) for(int i=(int)ini;i<(int)fin;i+=inc) #define FOR_IT(iter,C) for(typeof(C.begin()) iter = C.begin();iter!=C.end();iter++) #define all(A) A.begin(), A.end() #define mem(x,val) memset(x,val,sizeof(x)) #define EPS 1e-9 #define MAY 100010 #define INF 2000000000 #define MOD 1000000007 #define PI 3.141592654 typedef long long LL; typedef double D; #define G(x) (D)(x) #define F(x) (LL)(x) typedef pair<int,int>par; typedef pair<int,par>arco; #define mp make_pair #define sc second #define fs first  D memo[MAY][38]; int yes[MAY][38];  D f(int n, int k){     if(k>36||n<=0)return G(0.0);     if(n>=0&&k==0)return G(n); //base     if(yes[n][k])return memo[n][k];     D prob=0;     FOR(x,0,n)prob=G(prob)+G(f(x,k-1));     yes[n][k]=1;     return memo[n][k]=G(G(prob)/G(n)); } int main(){     mem(memo,0);     FOR(K,0,38){         D sum=G(0.0);         FOR(N,0,MAY){             if(N==0)memo[N][K]=0;             else if(K==0)memo[N][K]=G(N), sum+=G(N); //base             else sum+=G(memo[N-1][K-1]), memo[N][K]=G(G(sum)/G(N));         }     }     //puts("ok");     int t;scanf("%d",&t);     int n,k;     while(t--){         scanf("%d %d",&n,&k);         if(k>36)cout<<0<<endl;         else printf("%.10lf\n",memo[n][k]);     }     return 0; } 
#include<iostream> using namespace std;  int rel[108],c[108][108],prev[108],mark[108],n;  int nextDFS(int k) {	 	if(k<0)   return 1; 	 	if(mark[k])  return 0; 	 	mark[k]=1; 	 	for( int i=1; i<=n; i++) 	{ 		if(!c[k][i])  continue; 		 		if( nextDFS(prev[i]) ) 		{ 			prev[i]=k; 			 			return 1; 		} 	} return 0;	 }   int main() { 	int tc,m,a,b,i,j,ans; 	 	cin>>tc; 	 	while(tc--) 	{ 		ans=0; 		 		cin>>n>>m; 		 		for(i=1; i<=n; i++) 		 rel[i]=0; 	 		for(i=1; i<=n; i++) 		 for(j=1; j<=n; j++) 	 	   c[i][j]=0; 		 		while(m--) 		{ 			cin>>a;    rel[a]++; 			 			cin>>b;    rel[b]++; 			             c[a][b]=1;			 		} 		 		for(i=1; i<=n; i++) 		{ 			if(!rel[i]) 			 ans++; 		} 			 		for(i=1; i<=n; i++) prev[i]=-1; 		 		for(i=1; i<=n; i++) 		 { 		 	if(!rel[i]) 		 	 continue; 		 	  		 	for(j=1; j<=n; j++)  mark[j]=0;  		 	 		 	if(!nextDFS(i)) ans++;	 		 } 		 		  cout<<ans<<endl; 	} return 0;	 }
#include <iostream> #include <cstdio> #include <vector> #include <algorithm> #include <cstring> using namespace std; typedef pair<int,int> ii; vector<ii> a; vector<ii> x; int p, q; int n; int main() {     scanf("%d", &n);     while (n) {         a.clear();         x.clear();         for (int i=0; i<n; i++) {             scanf("%d%d", &p, &q);             x.push_back(ii(p,q));         }         sort(x.begin(), x.end());         for (int i=1; i<n; i++) {             if (x[i].first == x[i-1].first) {                 a.push_back(ii(x[i].second, abs(x[i].second-x[i-1].second)));             }         }         sort(a.begin(), a.end());         long long ans = 0;         long long temp = 1;         for (int i=1; i<a.size(); i++) {             if (a[i]==a[i-1]) temp++;             else {                 ans = ans+(temp*(temp-1))/2;                 temp = 1;             }         }         ans = ans+(temp*(temp-1))/2;         printf("%lld\n", ans);         scanf("%d", &n);     }     return 0; } 
#include<iostream> #include<cstdio> using namespace std;  int main(){ 	int m,n,k,i,j; 	scanf("%d",&n); 	int arr[n+1][n+1]; 	int bits[n+1][n+1][11]; 	for(i=1;i<=n;i++) 		for(j=1;j<=n;j++){ 			for(k=1;k<=10;k++) 				bits[i][j][k]=0; 			scanf("%d",&arr[i][j]); 		} 	 	int i1,j1; 	for(i=1;i<=n;i++){ 		for(j=1;j<=n;j++){ 			for(k=1;k<=10;k++) 				bits[i][j][k]=bits[i-1][j][k]+bits[i][j-1][k]-bits[i-1][j-1][k]; 			bits[i][j][arr[i][j]]++; 		} 	} 	//bool hash[m+1][n+1][26]={0}; 	scanf("%d",&m); 	 	 	 	while(m--){ 		scanf("%d%d%d%d",&i,&j,&i1,&j1); 		int count=0,l; 		for(k=1;k<=10;k++){ 			l=bits[i1][j1][k]-bits[i-1][j1][k]-bits[i1][j-1][k]+bits[i-1][j-1][k]; 			if(l>0) 				count++; 		} 		printf("%d\n",count); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; #define ll long long ll int dp1[1000003]; ll int arr[1000003]; ll int dp2[1000003]; ll max(ll a,ll b) {     if(a>b)         return a;     return b; }  int main() {     int t;     cin>>t;     while(t--)     {         int n,k,i;         cin>>n>>k;         for(i=1;i<=n;i++)         {             scanf("%lld",&arr[i]);         }         dp1[n+1]=INT_MIN;         dp2[n+1]=INT_MIN;          for(i=1;i<=n;i++)         {             dp1[i]=max(dp1[i-1]+arr[i],arr[i]);         }         for(i=n;i>=1;i--)         {             dp2[i]=max(dp2[i+1]+arr[i],arr[i]);         }          for(i=n;i>=1;i--)         {             dp2[i]=max(dp2[i],dp2[i+1]);         }         ll maxi=INT_MIN;         for(i=1;i<=(n-k-1);i++)         {             maxi=max(maxi,dp1[i]+dp2[i+k+1]);         }      cout<<maxi<<endl;        }   } 
#include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm>  using namespace std;   string s="abcdefghijklmnopqrstuvwxyz"; int main(){    int t;     cin>>t;     int count=0;     while(t--)         {         int n,temp;         cin>>n;         temp=n;         int i,min=n-1;         for(i=2;i<=sqrt(n);i++)             {             if(n%i==0)             {if(abs(i-(temp/i))<min)              min=abs(i-(temp/i));}         }         cout<<min<<endl;     }     return 0; }    
#include<bits/stdc++.h> using namespace std; typedef long long LL; int main(){     int t;     cin >> t;     while(t--){         int x, y;         scanf("%d%d", &x, &y);         x = abs(x);         y = abs(y);         int z = min(x, y);         LL ans = 2 * z;         x -= z;         y -= z;         if(y == 0){             if(x & 1) ans += 2 * x + 1;             else ans += 2 * x;         } else {             if(y & 1) ans += 2 * y - 1;             else ans += 2 * y;         }         printf("%lld\n", ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; const int INF = 1e8; vector<vector<int> > grf(MAXN); vector<vector<int> > rev(MAXN); set<pair<int, int> > qq; bool vis[MAXN]; int val[MAXN]; void dfs(int x){     if(vis[x]) return ;     vis[x] = true;     qq.insert(make_pair(0, x));     val[x] = 0;     int sz = grf[x].size();     for(int i = 0;i < sz;++i){         dfs(grf[x][i]);     } } int main(){     int N, M;     scanf("%d%d", &N, &M);     while(M--){         int a, b;         scanf("%d%d", &a, &b);         if(a != b){             grf[a].push_back(b);             rev[b].push_back(a);         }     }     for(int i = 1;i <= N;++i){         val[i] = INF;     }     memset(vis, 0, sizeof vis);     dfs(1);     while(!qq.empty()){         int node = qq.begin()->second;         int curVal = qq.end()->first;         qq.erase(qq.begin());         int sz = rev[node].size();         for(int i = 0;i < sz;++i){             int next = rev[node][i];             if(val[next] > val[node] + 1){                 val[next] = val[node] + 1;                 qq.insert(make_pair(val[next], next));             }         }         sz = grf[node].size();         for(int i = 0;i < sz;++i){             int next = grf[node][i];             if(val[next] > val[node]){                 val[next] = val[node];                 qq.insert(make_pair(val[next], next));             }         }     }     if(val[N] == INF){         printf("-1\n");     } else{         printf("%d\n", val[N]);     }     return 0; } 
 #include <algorithm>     #include <stdio.h>     #include <assert.h>     #include <string.h>       #define MIN(a,b) ((a)<(b) ? (a) : (b))     #define MAX(a,b) ((a)>(b) ? (a) : (b))       using std::sort;       #define ASSERT(x)       typedef struct {     unsigned short v1, v2;     unsigned int w;     } edge_t;       typedef struct node_t {     node_t *head;     node_t *next;     } node_t;       node_t *node_head(node_t *node){         if(node->head == NULL){         return node;         }           node->head = node_head(node->head);         return node->head;     }       node_t *node_append(node_t *head_last, node_t *tail_first){         node_t *head_head = node_head(head_last);         ASSERT(tail_first->head == NULL);         ASSERT(head_head->head == NULL);         ASSERT(head_last->next == NULL);         tail_first->head = head_head;         head_last->next = tail_first;         return head_head;     }          bool edge_cmp_max(const edge_t &a, const edge_t &b)     {         return a.w > b.w;     }                         char digit_lut[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";       static char *fmt_uint(int x, char *s){         char b[16], *p = b+16;         if(x < 100){         if(x < 10) { s[0] = '0' + x; s[1] = 0; return s+1; }         else { s[0] = digit_lut[x*2]; s[1] = digit_lut[x*2+1]; s[2] = 0; return s+2; }         }         do {         char *d = digit_lut + (x%100)*2;         *(--p) = d[1]; *(--p) = d[0];         x /= 100;         } while(x >= 10);         if(x){ *(s++) = '0' + x; }         while(p != b+16){ *(s++) = *(p++); *(s++) = *(p++); }         *s = 0;         return s;     }         void mat_print(int A[1000][1000], int n, int m)     {         int i, j;         char buf[20000];         for(i = 0; i < n; i++){         char *ptr = buf;         for(j = 0; j < m; j++){         if(j != 0){         *ptr = ' ';         ptr++;         }           ptr = fmt_uint(A[i][j], ptr);         }         *ptr = 0;         printf("%s\n", buf);         }     }         void max_score_pairs(int n_nodes, node_t *nodes, int n_edges, edge_t *edges,     int C[1000][1000])     {     int i, j;     sort(edges, edges+n_edges, edge_cmp_max);     j = 0;     for(i = 0; i < n_edges; i++){     int v1 = edges[i].v1;     int v2 = edges[i].v2;     int w = edges[i].w;     node_t *n1 = &nodes[v1];     node_t *n2 = &nodes[v2];     node_t *h1 = node_head(n1);     node_t *h2 = node_head(n2);          if(h1 == h2)         continue;          C[v1][v2] = C[v2][v1]=w;          node_t *cur1 = h1;          while(1){              node_t *cur2 = h2;                  while(cur2){             int i1 = cur1 - nodes;             int i2 = cur2 - nodes;             int c;                     c = w;                                          C[i1][i2] = C[i2][i1]=c;                          cur2 = cur2->next;         }                  if(cur1->next==NULL){             node_append(cur1, h2);             break;         }         cur1 = cur1->next;     }               } }          int main(int argc, char **argv)     {         int i;         int n_vert = 0;         int n_edge = 0;                 edge_t *edges;                 node_t nodes[1000]= {};                 int A[1000][1000] = {};                       char c = getchar_unlocked();         while(c==' ' || c== '\n' || c=='\t') c=getchar_unlocked();           while(c >='0' && c <='9')             {                 n_vert = (n_vert<<3) + (n_vert<<1) + c-'0';                 c=getchar_unlocked();              }             while(c==' ' || c== '\n' || c=='\t') c=getchar_unlocked();           while(c >='0' && c <='9')             {                 n_edge = (n_edge<<3) + (n_edge<<1) + c-'0';                 c=getchar_unlocked();              }                 edges = (edge_t*)malloc(n_edge * sizeof(edge_t));                 for(i = 0; i < n_edge; i++){             int j=0,k=0; long int weight=0;               while(c==' ' || c== '\n' || c=='\t') c=getchar_unlocked();               while(c >='0' && c <='9')             {                 j = (j<<3) + (j<<1) + c-'0';                 c=getchar_unlocked();              }               while(c==' ' || c== '\n' || c=='\t') c=getchar_unlocked();                          while(c >= '0' && c<='9')             {                 k = (k<<3) + (k<<1) + c-'0';                 c=getchar_unlocked();              }                        while(c==' ' || c== '\n' || c=='\t') c=getchar_unlocked();               while(c >= '0' && c<='9')             {                 weight = (weight<<3) + (weight<<1) + c-'0';                 c=getchar_unlocked();              }                          edges[i].v1 = j;             edges[i].v2 = k;             edges[i].w = weight;         }                             max_score_pairs(n_vert, nodes, n_edge, edges, A);         mat_print(A, n_vert, n_vert);         free(edges);         return 0;     }   
#include<iostream> #include<cstdlib> #include<algorithm> int rank[100009],parent[100009],res[100009],edge[400009][3]; static int comp(const void* p1, const void* p2) {   int* arr1 = (int*)p1;   int* arr2 = (int*)p2;   return arr1[2] - arr2[2]; } void link(int x,int y) {      if(rank[x]>rank[y])      {         parent[y]=x;      }      else parent[x]=y;      if(rank[x]==rank[y])      rank[y]=rank[y]+1; } int find( int x) {      if(x!=parent[x])      {          parent[x]=find(parent[x]);      }      return parent[x]; } bool uni(int x,int y) {      if(x==y)return false;      x=find(x);y=find(y);if(x==y)return false;      link(x,y);return true; }                            main() {       int t,n,m,x,y,w,j,k,i;char build[100009];       scanf("%d",&t);       while(t--)       {           scanf("%d%d%*c",&n,&m);long long cost=0;           scanf("%s",build);           for(i=0;i<=n;i++)           {              parent[i]=i;              rank[i]=0;           }                       for(i=0;i<m;i++)           {               scanf("%d%d%d",&x,&y,&w);                                 edge[i][0]=x;edge[i][1]=y;edge[i][2]=w;           }             qsort(edge, m, 3*sizeof(int), comp);              for(i=0;i<m;i++)           {                x=edge[i][0];y=edge[i][1];w=edge[i][2];                           if(build[edge[i][0]-1]=='R')x=0;if(build[edge[i][1]-1]=='R')y=0;                           if(w<=0)               {                 cost+=w;                 uni(x,y);               }  else{                         if(uni(x,y))                {                     cost+=edge[i][2];                }}           }           printf("%lld\n",cost);       }       //system("pause"); }                                                                   
#include<iostream> #include<cstring> #include<algorithm> using namespace std; int main() {     int n;     cin>>n;     int count=0;     for(int i=1; i<=n; i++)     {         int x1,x2,x3,y1,y2,y3;         cin>>x1>>y1;         cin>>x2>>y2;         cin>>x3>>y3;         int x=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);         int y=(x1-x3)*(x1-x3)+(y1-y3)*(y1-y3);         int z=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);        // cout<<x<<" "<<" "<<y<<" "<<z<<endl;         if((x+y==z)||(x+z==y)||(y+z==x))             count++;     }     cout<<count; } 
//Akhand Chutiyaapa KAR DIYA #include<bits/stdc++.h> using namespace std; #define mp make_pair #define pb push_back #define all(x) x.begin(),x.end() #define init int t;t=readInt();while(t--) #define traverse(itr) #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) typedef vector<int> vi;  typedef vector<vi> vvi;  typedef pair<int,int> pi; typedef pair<int,pi> pii; #define MAX INT_MAX #define MIN INT_MIN #define lli long long int int readInt () {     bool minus = false;     int result = 0;     char ch;     ch = getchar();     while (true) {         if (ch == '-') break;         if (ch >= '0' && ch <= '9') break;         ch = getchar();     }     if (ch == '-') minus = true; else result = ch-'0';     while (true) {         ch = getchar();         if (ch < '0' || ch > '9') break;         result = result*10 + (ch - '0');     }     if (minus)         return -result;     else         return result; } int main() {     init     {            lli h,s;         cin>>h>>s;         double arr[3];         double sum1=sqrt(h*h+4*s);         //MA KI CHUT CHUTIYAPA HO GYA equal kaise bhul gya!!!!!!!!!         if(h*h-4*s>=0)         {             double sum2=sqrt(h*h-4*s);             double side1=(sum2+sum1)/2;             double side2=2*s/side1;             arr[0]=side1;             arr[1]=side2;             arr[2]=h;             sort(arr,arr+3);             printf("%lf ",arr[0]);             printf("%lf ",arr[1]);             printf("%lf\n",arr[2]);         }         else             cout<<-1<<endl;     }     return 0; }  
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; int A[MAXN];  int main(){     int N, M;     scanf("%d%d", &N, &M);     for(int i = 0;i < N;++i){         scanf("%d", &A[i]);     }     int offset = 0;     while(M--){         char type;         scanf(" %c", &type);         if(type == 'C'){             int d;             scanf("%d", &d);             offset += d;         } else if(type == 'A'){             int d;             scanf("%d", &d);             offset -= d;         } else {             int d;             scanf("%d", &d);             d = d - 1 + offset;             while(d >= N) d -= N;             printf("%d\n", A[d]);         }         while(offset >= N) offset -= N;         while(offset < 0) offset += N;     }     return 0; } 
#include<stdio.h> #include<malloc.h> int main() { 	int n,q; 	int *row,*column; 	int i; 	int add,k; 	int maxrow,maxcolumn; 	char input[10]; 	scanf("%d %d",&n,&q); 	row=(int *)malloc((n+1)*sizeof(int)); 	column=(int *)malloc((n+1)*sizeof(int)); 	for(i=0;i<=n;i++) 		row[i]=column[i]=0; 	maxrow=maxcolumn=1; 	for(i=0;i<q;i++) 	{ 		 		scanf("%s %d %d",input,&k,&add); 		if(input[0]=='R') 		{ 				if(maxrow==k) 				{ 					row[k]=row[k]+add; 				} 				else 				{ 					row[k]=row[k]+add; 					if(row[k]>row[maxrow]) 						maxrow=k; 				}  		} 		else 		{ 			if(maxcolumn==k) 			{ 				column[k]=column[k]+add; 			} 			else 			{ 				column[k]=column[k]+add; 				if(column[k]>column[maxcolumn]) 					maxcolumn=k; 			} 		} 		 	} 	printf("%d",row[maxrow]+column[maxcolumn]); 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){     long long  n,k,answer;     cin>>n>>k>>answer;     long long *array=new long long[n];     for(int i=0;i<n;i++){         cin>>array[i];     }     string operator1;     cin>>operator1;     if(k==0){         cout<<answer<<endl;     }     else{     if(operator1=="AND"){             for(int j=0;j<n;j++){                 answer=answer&array[j];              }                  cout<<answer<<endl;     }     else if(operator1=="OR"){                  for(int j=0;j<n;j++){                 answer=answer|array[j];              }                  cout<<answer<<endl;     }     else{         if(k%2==0){             cout<<answer<<endl;             continue;         }             for(int j=0;j<n;j++){                 answer=answer^array[j];              }                               cout<<answer<<endl;                       }     }     } }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         int num;         int dp[100000];         for(int i=0;i<100000;i++){             dp[i]=0;         }         int sum=0;         for(int i=0;i<n;i++){             cin>>num;             if(dp[num-1]==0){                 dp[num-1]=1;                 sum++;             }         }         cout<<sum<<endl;                       } }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         string s;         cin>>s;         int length=s.length();         long long sum=1;         int flag=0;         for(int i=0;i<ceil(length/2.0);i++){             if(s[i]==s[length-i-1] && s[i]=='?'){                 sum=(sum*26)%10000009;             }             else if(s[i]=='?' || s[length-1-i]=='?'){                 sum=(sum*1)%10000009;             }             else if(s[i]!=s[length-1-i]){                 sum=0;                 flag=1;                 break;             }         }         cout<<sum<<endl;     } }
#include <iostream> #include <string.h> #include <math.h> #include <stdlib.h> #include <stdio.h> #include <vector> #include <algorithm>   using namespace std;   #define FASTIO 1   #if FASTIO ///////////////////// ////// INPUT //////// //////////////////// class INPUT {   static const int BUFSIZE = 1<<16;   static char buffer[];   char *bufpos;   char *bufend;   void grabBuffer();   public:   INPUT() { grabBuffer(); }   bool eof() { return bufend==buffer; }   char nextChar() { return *bufpos; }   inline char readChar();   inline void skipWS();   long long int readUnsigned();   long long int readInt(); };   char INPUT::buffer[INPUT::BUFSIZE];   void INPUT::grabBuffer() {   bufpos = buffer;   bufend = buffer + fread( buffer, 1,BUFSIZE,stdin); }   char INPUT::readChar() {   char res = *bufpos++;   if(bufpos==bufend) grabBuffer();   return res; }   inline bool myisspace(char c) { return c<=' '; }   void INPUT::skipWS() {   while(!eof() && myisspace(nextChar())) readChar(); }   long long INPUT::readUnsigned() {   skipWS();   long long res = 0;   while(!eof() && isdigit(nextChar())) {     res = 10u * res + (readChar()-'0');   }   return res; }   long long int INPUT::readInt() {   skipWS();   bool neg = false;   if(!eof() && nextChar()=='-') { neg=true; readChar(); }   long long int res = static_cast<long long int>(readUnsigned());   if(neg) res = -res;   return res; }   ///////////////////// ////// OUTPUT ////// ////////////////////   class OUTPUT {   static const int BUFSIZE = 1<<16;   static char buffer[];   char *bufpos;   char *BUFLIMIT;   void flushBuffer();   public:   OUTPUT():bufpos(buffer),BUFLIMIT(buffer+BUFSIZE-100) {}   ~OUTPUT() { flushBuffer(); }   inline void operator()(char c);   inline void operator()(unsigned x);   inline void operator()(int x);   inline void operator()(unsigned long long int x);   inline void operator()(long long int x);   inline void operator()(const char*s);   void operator()(const string&s) { operator()(s.c_str()); }   template<class A,class B>     void operator()(const A& a,const B& b) {       operator()(a); operator()(b);     }   template<class A,class B,class C>     void operator()(const A& a,const B& b,const C&c) {       operator()(a); operator()(b); operator()(c);     }   template<class A,class B,class C,class D>     void operator()(const A& a,const B& b,const C&c,const D&d) {       operator()(a); operator()(b); operator()(c); operator()(d);     }   template<class A,class B,class C,class D,class E>     void operator()(const A& a,const B& b,const C&c,const D&d,const E&e) {       operator()(a); operator()(b); operator()(c); operator()(d); operator()(e);     }   template<class A,class B,class C,class D,class E,class F>     void operator()(const A& a,const B& b,const C&c,const D&d,const E&e,const F&f) {       operator()(a); operator()(b); operator()(c); operator()(d); operator()(e); operator()(f);     } };   char OUTPUT::buffer[OUTPUT::BUFSIZE];   void OUTPUT::flushBuffer() {   char *p = buffer;   while(p < bufpos) {     p += fwrite( p,1, bufpos-p,stdout);   }   bufpos = buffer; }   void OUTPUT::operator()(char c) {   *bufpos = c;   ++bufpos;   if(bufpos >= BUFLIMIT) flushBuffer(); }   void OUTPUT::operator()(unsigned x) {   char *old = bufpos;   do {     *bufpos = char('0' + x % 10u);     x /= 10u;     ++bufpos;   } while(x);   reverse(old, bufpos);   if(bufpos >= BUFLIMIT) flushBuffer(); }   void OUTPUT::operator()(int x) {   if(x<0) { operator()('-'); x = -x; }   operator()(static_cast<unsigned>(x)); }   void OUTPUT::operator()(unsigned long long int x) {   char *old = bufpos;   do {     *bufpos = char('0' + x % 10u);     x /= 10u;     ++bufpos;   } while(x);   reverse(old, bufpos);   if(bufpos >= BUFLIMIT) flushBuffer(); }   void OUTPUT::operator()(long long int x) {   if(x<0) { operator()('-'); x = -x; }   operator()(static_cast<unsigned long long int>(x)); }   void OUTPUT::operator()(const char*s) {   while(*s) operator()(*s++); }   INPUT input; OUTPUT output;   #endif   typedef unsigned long long ull;   int main( int argc, char** argv) {   ull N = input.readInt();   ull M = input.readUnsigned();   ull K = input.readUnsigned();     if( N<3) output(1,"\n");     ull max1 = 0, max2 = 0, sum = 0;   ull A;   for( int i=0; i<N; i++)   {     A = input.readUnsigned();     sum += (A = (M-A)/K + 1);     if( max1 < A) max2 = max1, max1 = A;     else if( max2 < A) max2 = A;   }   ull Min = sum - max1, Max = sum;   if( Min < (max2<<1)) Min = 2*max2;   else if( Min&1) Min++;     if( sum<(max1<<1)) Max = (sum-max1)<<1;   else if( Max&1) Max--;     output( ((Max-Min+2)/2)%1000000007, "\n");   return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e7 + 7; LL A[50][59]; int main(){     int N, M;     cin >> N >> M;     for(int i = 1;i <= N;++i){         for(int j = 1;j <= M;++j){             cin >> A[i][j];         }     }     LL ans = 1;     for(int j = 1;j <= M;++j){         LL sum = 0;         for(int i = 1;i <= N;++i){             sum += A[i][j];         }         sum %= MOD;         sum += MOD;         sum %= MOD;         ans *= sum;         ans %= MOD;     }     printf("%lld\n", ans);     return 0; } 
#include <iostream> #include<algorithm>  using namespace std;  int main() {     long long n,k,m=0,mx=0;       cin>>n>>k;      long long a[n];          for(long long i=0;i<n;i++){             cin >>a[i];             if(a[i]>m) m= a[i];         }         if(k!=0){           for(long long x=0;x<n;x++){                 a[x] = m-a[x];                 if (a[x]>mx) mx =a[x];}                 if(k%2==0){         for(long long y=0;y<n;y++){                     a[y] = mx - a[y];}                 }           }          for(long long z=0;z<n;z++){           cout<<a[z]<<" ";}   }   
#include<bits/stdc++.h> using namespace std; int main(){     long long n,m;     cin>>n>>m;     for(int i=0;i<m;i++){         long long q;         cin>>q;         if(q<n+2){             cout<<0<<endl;         }         else{             if(q-n-2<n){                 cout<<q-n-1<<endl;             }             else{                 cout<<n-(q-(n+2+(2*n-1)/2))<<endl;             }         }     } }
#include <iostream> using namespace std;  int main(){ 	int r,c,x; 	cin >> r >> c;  	int rc[r]; 	int cl[c];  	for(int i = 0; i < r; i++) { 		rc[i] = 100000001; 	}  	for(int j = 0; j < c; j++) { 		cl[j] = 0; 	}  	int a[r][c]; 	for(int i = 0; i < r; i++) { 		for(int j = 0; j < c; j++) { 			cin >> a[i][j]; 			if (a[i][j] < rc[i]) { 				rc[i] = a[i][j]; 			} 			if(a[i][j] > cl[j]) { 				cl[j] = a[i][j]; 			} 		} 	}  	for (int i = 0; i < r; i++) { 		for (int j = 0; j < c; j++) { 			if ((a[i][j] == rc[i]) && (a[i][j] == cl[j])) { 				cout << a[i][j] << endl; 				return 0; 			} 		} 	}  	cout << "GUESS" << endl; 	return 0;  }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         int *array=new int[n];         for(int i=0;i<n;i++){             cin>>array[i];         }         int oper=0;         sort(array,array+n);         for(int i=0;i<n-1;i++){             if(array[i]!=array[i+1]){                 oper=oper+array[i+1]-array[i];                 for(int j=i+2;j<n;j++){                     array[j]=array[j]+array[i+1]-array[i];                 }             }         }         cout<<oper<<endl;     } }
#include<bits/stdc++.h> #define mod 1000000007 long long a[9][2097152]; using namespace std; int main() {     long long t,n,i,j,k,p,q,u,v,b[22],x,y,z;     cin>>t;     while(t--)     {         cin>>n>>k;         for(i=j=0;i<n;i++)         {             cin>>b[i];             j+=b[i];         }         if(j==0)         {             if(n>=k)             {                 cout<<"yes\n";             }             else             {                 cout<<"no\n";             }             continue;         }         else if(j%k==0)         {             z=j/k;         }         else         {             cout<<"no\n";             continue;         }         p=pow(2,n)-1;         for(i=0;i<=k;i++)         {             for(j=0;j<=p;j++)             {                 a[i][j]=0;             }         }         a[0][0]=1;         for(i=0;i<k;i++)         {             for(j=0;j<=p;j++)             {                 if(a[i][j]==1)                 {                     for(x=q=0;x<n;x++)                     {                         if(((j>>x)&1)==1)                         {                             q+=b[x];                         }                     }                     q=q-i*z;                     for(x=0;x<n;x++)                     {                         if(((j>>x)&1)==0)                         {                             y=j|(1<<x);                             if(q+b[x]==z)                             {                                 a[i+1][y]=1;                             }                             else if(q+b[x]<z)                             {                                 a[i][y]=1;                             }                         }                     }                  }             }         }         if(a[k][p]==1)         {             cout<<"yes\n";         }         else         {             cout<<"no\n";         }     }     return 0; } 
#include<stdio.h> long long int verifyPerfectDigit( long long int tmp){   while( tmp ){     if(tmp%10!=0 && tmp%10!=1 && tmp%10!=4 && tmp%10!=9){       return 0;     }     tmp = tmp / 10;   }   return 1; } main(){   long long int t,i,j,count;   long long int a,b,square, pdps[200];   scanf("%lld", &t);   j=0;   for( i=1; i<=100000; i++ ){     square = i*i;     if( verifyPerfectDigit(square) == 1 ){       pdps[j++] = square;     }   }   while(t--){     count = 0;     scanf("%lld%lld", &a, &b);     for(i=0; i<j; i++){       if(pdps[i]>=a && pdps[i]<=b)         count++;     }     printf("%lld\n", count);   }   return 0; }
#include<stdio.h> #include<stdlib.h>  double mat[105][105]; int ed[101][101]; int n,m; int sign;  void swap_rows(int i,int j) { 	double temp; 	int k; 	for(k = 0; k < n; k++) 	{ 		temp = mat[i][k]; 		mat[i][k] = mat[j][k]; 		mat[j][k] = temp; 	} 	if(sign)sign = 0; 	else sign = 1; }  int det_test() { 	int i,nzr,j,k; 	double q; 	sign = 0; 	for( i = 0; i < n; i++) 	{ 		if(mat[i][i] == 0) 		{ 			nzr = i; 			for(k = i + 1;k < n;k++) 				if(mat[k][i] != 0){ nzr = k; break; } 			if(i != nzr)swap_rows(i,nzr); 		} 		if(mat[i][i] != 0) 		{ 			for(j = i + 1;j < n; j++) 			{ 				q = mat[j][i] / mat[i][i]; 				for(k = i ;k < n;k++)mat[j][k] = mat[j][k] - ( q * mat[i][k] ); 			} 		} 	} 	double det = mat[0][0]; 	for(i = 1; i < n; i++)det = det * mat[i][i]; 	return det; }  int main() { 	int t; 	int i,j;  	int vi,vj; 	double arand;  	scanf("%d",&t); 	srand(230); 	while(t--) 	{		 		scanf("%d%d",&n,&m);  		for(i = 0;i < n;i++) 		for(j = 0;j < n;j++) 		mat[i][j] = 0;  		for(i=1;i<=m;i++) 		{ 			scanf("%d%d",&vi,&vj); 			vi--; 			vj--; 			 			if(mat[vi][vj] != 0)continue; 			 			arand = ( rand() % n ) + 1; 			 			if(vi < vj) 			{ 		 		mat[vi][vj] = arand; 				mat[vj][vi] = -arand; 			} 			else if(vi > vj) 			{ 				mat[vi][vj] = -arand; 		 		mat[vj][vi] = arand; 			} 		}		 		if(n & 1)puts("NO"); 		else if(det_test())puts("YES"); 		else puts("NO"); 	} 	return 0; }
#include<iostream> #include<cmath> #include<vector> #include<cstdio> #include<string> #include<sstream> #include<algorithm> #define ll long long using namespace std; int T; ll n,m,q,k; const ll pMOD=(ll)1e9+7; ll powr(ll q, ll n) { 	q=q%pMOD; n=n%(pMOD-1); 	if(n==0) return 1; 	if(q==0) return 0; 	if(n%2==0) 	{ 		ll k=powr(q,n/2); 		k=(k*k)%pMOD; 		return k; 	} 	else 	{ 		ll k=powr(q,(n-1)/2); 		k=(k*k)%pMOD; 		k=(k*q)%pMOD; 		return k; 	} } int main() { 	cin>>T; 	for(int ii=0;ii<T;ii++) 	{ 		cin>>n>>m>>q>>k; 		if(m<q){cout<<0<<endl;continue;} 		ll ans=powr(q-1,n); 		ans+=powr(q+1,n); 		ans-=2*powr(q,n); 		ans*=(m-q); 		while(ans<0) {ans+=pMOD;} 		ans=ans%pMOD; 		cout<<ans<<endl; 	} 	return 0; } 
#include <iostream> #include <cstring>  using namespace std;  long long modu=1000000007; long long fact[100009];  void gen_fact(){ 	fact[0]=1; 	long long j=1; 	while(j<100009){ 		fact[j]=((fact[j-1]%modu)*(j%modu))%modu; 		j++; 	} }  long long fast_powmod(long long a, long long k, long long m){ 	if(k==1){ 		return a%m; 	} 	else{ 		if(k%2==0){ 			long long temp=(fast_powmod(a,k/2,m))%m; 			return (temp*temp)%m; 		} 		else{ 			long long temp=fast_powmod(a,k/2,m)%m; 			return ((a%m)*((temp*temp)%m))%m; 		} 	} }  long long invmodulo(long long a,long long m){ 	return fast_powmod(a,m-2,m)%m; }  long long multmod(long long a, long long b, long long m){ 	return ((a%m)*(b%m))%m; }  char inp[100009]; long long t,i=0,ans,freq_arr[26],j=0,temp,P,S,k=0,l=0,m=0,n;   int main(){ 	cin>>t; 	i=0; 	gen_fact(); 	while(i<t){ 		cin>>inp; 		j=0; 		while(j<26){ 			freq_arr[j]=0; 			j++; 		} 		j=0; 		n=strlen(inp); 		while(j<n){ 			temp=inp[j]-97; 			freq_arr[temp]++; 			freq_arr[temp]=freq_arr[temp]%modu; 			j++; 		} 		j=0; 		P=fact[n]%modu; 		while(j<26){ 			P=(P*(invmodulo(fact[freq_arr[j]],modu)%modu))%modu; 			j++; 		}   		S=0; 		S=1;//No swaps 		//One Swap 		j=0,k=0; 		while(j<26){ 			k=0; 			while(k<j){ 				S=(S+(freq_arr[j]*freq_arr[k])%modu)%modu; 				k++; 			} 			j++; 		} 		//Two Swaps 		j=0,k=0,l=0; 		while(j<26){ 			k=0; 			while(k<j){ 				l=0; 				while(l<k){ 					S=(S+(((2*freq_arr[j]*freq_arr[k])%modu)*freq_arr[l])%modu)%modu; 					l++; 				} 				k++; 			} 			j++; 		} 		//Two completely disjoint 		j=0,k=0,l=0,m=0; 		while(j<26){ 			k=0; 			while(k<j){ 				l=0; 				while(l<k){ 					m=0; 					while(m<l){ 						S=(S+((3*freq_arr[m]*freq_arr[l])%modu*(freq_arr[k]*freq_arr[j])%modu)%modu)%modu; 						m++; 					} 					l++; 				} 				k++; 			} 			j++; 		}   		//One letter common 		j=0,k=0,l=0; 		while(j<26){ 			k=0; 			while(k<26){ 				l=0; 				while(l<k){ 					if((l!=j)&&(k!=j)){ 					S=(S+((freq_arr[k]*freq_arr[l])%modu*((freq_arr[j]-1)*freq_arr[j])%modu)%modu)%modu; 					} 					l++; 				} 				k++; 			} 			j++; 		}   		j=0,k=0,l=0; 		while(j<26){ 			k=0; 			while(k<j){ 				S=(S+(((((freq_arr[j]*(freq_arr[j]-1))%modu)*(freq_arr[k]*(freq_arr[k]-1))%modu)%modu)*invmodulo(4,modu))%modu)%modu; 				k++; 			} 			j++; 		} 		P=P+modu;  		cout<<"\n"<<(P*((P-S)%modu))%modu; 		i++; 	}  	return 0; }
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e5 + 10; typedef long long LL; const int MOD = 1e9 + 7; int A[MAXN]; bool vis[MAXN]; int wp[MAXN]; int f[MAXN]; int pf[MAXN]; void go(){ 	for(int i = 1;i < MAXN;++i){ 		f[i] = i; 		pf[i] = i; 	} 	for(int i = 2;i * i < MAXN;++i){ 		if(pf[i] == i){ 			for(int j = i, z = 1;j < MAXN;j += i, ++z){ 				pf[j] = i; 				if(pf[z] == pf[j]){ 					f[j] = f[z] * i; 				} 				else { 					f[j] = i; 				} 			} 		} 	} } int main(){ 	go(); 	int t; 	scanf("%d", &t); 	while(t--){ 		int N; 		scanf("%d", &N); 		for(int i = 1;i <= N;++i){ 			scanf("%d", &A[i]); 			vis[i] = false; 			wp[i] = 1; 		} 		for(int i = 1;i <= N;++i){ 			if(!vis[i]){ 				int cnt = 1; 				int j = A[i]; 				while(j != i){ 					vis[j] = true; 					j = A[j]; 					++cnt; 				} 				while(cnt > 1){ 					wp[pf[cnt]] = max(wp[pf[cnt]], f[cnt]); 					cnt /= f[cnt]; 				} 			} 		} 		LL ans = 1; 		for(int i = 1;i <= N;++i){ 			ans = (ans * wp[i]); 			if(ans >= MOD) ans %= MOD; 		} 		printf("%lld\n", ans); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  const int MAXN = 1e2 + 10; typedef double LL; int A[MAXN]; LL P[MAXN]; LL dp[MAXN][MAXN * MAXN]; int main(){ 	memset(dp, 0, sizeof dp); 	int t; 	scanf("%d", &t); 	while(t--){ 		int N; 		scanf("%d", &N); 		int sum = 0; 		for(int i = 1;i <= N;++i){ 			scanf("%d", &A[i]); 			sum += A[i]; 		} 		for(int i = 1;i <= N;++i){ 			scanf("%lf", &P[i]); 			P[i] /= 100; 		} 		dp[0][0] = 1; 		for(int i = 1;i <= N;++i){ 			for(int j = 0;j <= sum;++j){ 				dp[i][j] = 0; 				//give it to Abra 				if(A[i] <= j) 					dp[i][j] += dp[i - 1][j - A[i]] * P[i]; 				//give it to Kadabara 				dp[i][j] += dp[i - 1][j] * (1 - P[i]); 			} 		} 		// for(int i = 1;i <= N;++i){ 		// 	for(int j = 0;j <= sum;++j){ 		// 		printf("%8lld ",dp[i][j]); 		// 	} 		// 	cout << "\n"; 		// } 		LL ans = 0; 		for(int i = (sum + 1)/2;i <= sum;++i){ 			ans += dp[N][i]; 		} 		printf("%.6f\n", ans); 	}    	return 0; }
#include<stdio.h> int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		long long int a,b; 		scanf("%lld %lld",&a,&b); 		if(a>=b) 			printf("%lld\n",a-b); 		else 			printf("%lld\n",b-a);  	} 	return 0; }
#include<iostream> #include<cstring> #include<queue> #include<cstdlib> using namespace std; int area[1009][1009]; char str[1009*1009]; main() {       int t,x,y,m,n,l,i,j,len,count,sx,sy,temp;       scanf("%d",&t);       while(t--)       {             scanf("%d%d%d%d%d",&n,&m,&x,&y,&l);//temp=y;y=x;x=m-temp+1;             count=0;sx=x;sy=y;             for(i=1;i<=n;i++)             {               for(j=1;j<=m;j++)               area[i][j]=0;             }             scanf("%s",str);             len=strlen(str);             area[x][y]=1;queue<char> Q;             for(i=0;i<len;i++)             {                 if(str[i]=='U')y++;else if(str[i]=='D')y--;else if(str[i]=='R')x++;else x--;                 area[x][y]=1;                 Q.push(str[i]);             }             /******snake position*****                 for(i=1;i<=n;i++)                 {                    for(j=1;j<=m;j++)                    {                       if(area[i][j]==1)                                     printf(" * ");                       else printf(" 0 ");                    }                    printf("\n");                 }                                            /**********END***********/                 //printf("\n");             while(true)             {                 area[sx][sy]=0;                 if(Q.front()=='U')sy++;else if(Q.front()=='D')sy--;else if(Q.front()=='R')sx++;else sx--;                 Q.pop();                 Q.push(str[len-1]);                        if(str[len-1]=='U')y++;else if(str[len-1]=='D')y--;else if(str[len-1]=='R')x++;else x--;                 if(x>n||y>m||x<1||y<1)                 {                    printf("WALL %d\n",count);break;                 }                 else if(area[x][y]==1)                 {                    printf("BODY %d\n",count);break;                 }                 else                 {                                    area[x][y]=1;count++;                 }                 //printf("%d \n",Q.size());                 /******snake position*****                for(i=1;i<=n;i++)                 {                    for(j=1;j<=m;j++)                    {                       if(area[i][j]==1)                                     printf(" * ");                       else printf(" 0 ");                    }                    printf("\n");                 }                           printf("\n");                 /**********END***********/               }       }       //system("pause"); }                                                       
/** author -- Ayush Sharma **/ #include<iostream> #include<cstdio> #include<cstring> #include<vector> #include<cstdlib> #include<cassert> #define FOR(i,a,b) for(int i=a;i<b;i++) #define min3(a,b,c) (a<b?(a<c?a:c):(b<c?b:c)) #define max3(a,b,c) (a>b?(a>c?a:c):(b>c?b:c)) #define min(a,b) (a<b?a:b) #define max(a,b) (a>b?a:b) #define MAX 1000001 #define infi 100000 using namespace std; typedef long long LL; LL F[MAX]; LL A[MAX]; void rationals(){     F[0] = 0;     F[1] = 0;     int i = 2;     while(i <= MAX){         if(F[i] == 0){             F[i] = i-1;             for(int j = 2; i*j < MAX; j++){                 if(F[i*j] == 0 && F[j] != 0){                     if(j % i == 0)                         F[i*j] = F[j]*i;                     else                         F[i*j] = F[j]*(i-1);                 }             }         }         i++;     }     for(int i = 1; i < MAX; i++){         A[i] = A[i-1] + F[i];     } } int main(){     int TC;scanf("%d",&TC);     rationals();     while(TC--){         int N;         scanf("%d",&N);         printf("%lld\n",A[N]);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         long long n,k;         cin>>n>>k;         if(k==0){             cout<<0<<" "<<n<<endl;             continue;         }         cout<<n/k<<" "<<n%k<<endl;     } }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         int r,c;         cin>>r>>c;         string a[r];         for(int i=0;i<r;i++){             cin>>a[i];         }         int flag=0;         for(int i=0;i<r;i++){             for(int j=0;j<c;j++){                 if(a[i][j]=='s' || a[i][j]=='S'){                     if(j<=c-5){                         if((a[i][j+1]=='p' || a[i][j+1]=='P') && (a[i][j+2]=='o' || a[i][j+2]=='O') && (a[i][j+3]=='o' || a[i][j+3]=='O') && (a[i][j+4]=='n' || a[i][j+4]=='N')){                             flag=1;                             break;                         }                                              }                     if(i<=r-5){                         if((a[i+1][j]=='p' || a[i+1][j]=='P') && (a[i+2][j]=='o' || a[i+2][j]=='O') && (a[i+3][j]=='o' || a[i+3][j]=='O') && (a[i+4][j]=='n' || a[i+4][j]=='N')){                             flag=1;                             break;                         }                     }                 }                              }             if(flag==1){                 break;             }         }         if(flag==1){             cout<<"There is a spoon!"<<endl;         }         else{             cout<<"There is indeed no spoon!"<<endl;         }              } }
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e9 + 7;  LL power(LL A, LL B, LL MOD){     LL ans = 1;     while(B > 0){         if(B&1LL)  ans = (ans * A) % MOD;         A = (A * A) % MOD;         B >>= 1;     }     return ans; } int main(){     int t;     cin >> t;     while(t--){         int N;         scanf("%d", &N);         LL p = 1;         LL ans = 1;         while(N > 0){             if(N & 1)                 ans = (ans * power(2, p, MOD)) % MOD;             p = (p * 10) % (MOD - 1);             N >>= 1;         }         printf("%lld\n", (ans * ans) % MOD);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const int MAXN = 1e6 + 10; LL A[MAXN]; void update(int pos, LL val){     while(pos < MAXN){         A[pos] += val;         pos += (pos & (-pos));     } } LL query(int pos){     LL ans = 0;     while(pos > 0){         ans += A[pos];         pos -= (pos & (-pos));     }     return ans; } int main(){     LL N, M, C;     cin >> N >> M >> C;     memset(A, 0, sizeof A);     update(1, C);     while(M--){         char type;         scanf(" %c", &type);         if(type == 'S'){             LL u, v, k;             scanf("%d%d%lld", &u, &v, &k);             update(u, k);             update(v + 1, -k);         } else {             LL k;             scanf("%d", &k);             printf("%lld\n", query(k));         }     }     return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define sz(x) int((x).size()) #define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i)) #define ROF(i,a,b) for(int (i) = (a); (i) >= (b); --(i)) #define rep(i,n) for (int (i) = 0; (i) < (n); ++(i)) #define fe(i,a) for (int (i) = 0; (i) < int((a).size()); ++(i)) #define C(a) memset((a),0,sizeof(a)) #define inf 1000000000 #define pb push_back #define ppb pop_back #define all(c) (c).begin(), (c).end() #define pi 2*acos(0.0) #define sqr(a) (a)*(a) #define mp(a,b) make_pair((a), (b)) #define fpresent(c,x) ((c).find(x) != (c).end())  #define X first #define Y second #define rz resize #define endl '\n' #define TCASE int __t; cin >> __t; while (__t--)   typedef vector<int> ivi; typedef vector < ivi > ivvi; typedef unsigned long long ull; typedef long long int ll; typedef vector< ll > vi; typedef vector < vi > vvi; typedef pair<int, int> pii;   int main () { 	ios_base::sync_with_stdio(0); 	cin.tie(0); 	 	TCASE  	{ 		ll l,r; 		cin>>l>>r; 		int u=0,w=1; 		int ans=0;   		ll temp;   		for(int i=1;i<=60;i++) 		{ 			temp=pow(2,i); 			for(int j=0;j<=38;j++) 			{ 				if(temp >=l && temp <=r)ans++; 				else if(temp >r)break; 				temp*=3; 				if(temp > (ll)1e18)break; 				 			} 		} 		if(l==1)++ans; 		cout<<ans<<endl; 		 	} 	return 0; }  
#include <iostream> #include <vector> #include <algorithm> using namespace std; 	vector<int> a; int bsearch(int temp,int low,int high) { 		if(low>high) 			return -1; 		if(low==a.size()) 			return -1; 		int mid=(low+high)/2; 		if(a[mid]>temp) 		{ 			if(mid==0||a[mid-1]<=temp) 				return mid; 			else 				return bsearch(temp,low,mid-1); 		} 		else 			return bsearch(temp,mid+1,high); } int main() { 	std::ios_base::sync_with_stdio(false); 	int t,n,temp,i,j,max,count; 	cin>>t; 	while(t--) 	{ 		cin>>n>>temp; 		a.push_back(temp); 		for(i=1;i<n;i++) 		{ 			cin>>temp; 		/*	if(temp>=a[a.size()-1]) 			{ 				a.push_back(temp); 				continue; 			}*/ 			j=bsearch(temp,0,a.size()); 			if(j==-1) 				a.push_back(temp); 			else 				a[j]=temp; 		} 				cout<<a.size()<<" "; 			for(j=0;j<a.size();j++) 				cout<<a[j]<<" "; 					  cout<<endl; 		a.clear(); 	} 	return 0; }
//dark_9 #include <iostream> #include <sstream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <math.h> #include <stack> #include <queue> #include <ctype.h> #include <map> #include <bitset> #include <limits> typedef long long ll; #define filla(x,y) memset(x,y,sizeof(x)) #define pb push_back #define mp make_pair #define INF 0x3f3f3f3f #define F first #define S second #define gc getchar #define MOD 1000000000 using namespace std; long long choose(int n,int k) {     if(k==0)         return 1;     else     {         long long f=1;         if(k>n-k)             k=n-k;         int p=1;         while(p<=k)         {             f*=n--;             f/=p++;         }         return f;     } } /*ll power(int a,int b) {     ll ret;     if(b==0)         return 1;     if(b==1)         return a;     ret=power(a,b/2);     ret=(ret*ret);     if(b&1)         ret=(ret*a);     return ret; }*/ ll dp[2005][2005]; ll c[4050][4050]; ll s[2005][2005]; void scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } /*bool cmp(int a,int b) {     return a>b; }*/ int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif         int i,j;         for(i=0;i<4050;i++)             c[i][0]=1;         for(i=1;i<4002;i++)         {             for(j=1;j<=i;j++)             {                 if(i==j)                     c[i][j]=1;                 else                     c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;             }         }     int t;     scanf("%d",&t);     while(t--)     {         int n,m;         memset(dp,0,sizeof(dp));         memset(s,0,sizeof(s));         scanint(n);scanint(m);         dp[1][0]=1;         s[1][0]=1;         for(i=1;i<=m;i++)         {             dp[1][i]=c[i+m-1][m-1];             s[1][i]=(s[1][i-1]%MOD+dp[1][i]%MOD)%MOD;         }         for(i=2;i<=n;i++)         {             for(j=0;j<=m;j++)             {                 dp[i][j]=((s[i-1][j])*(c[j+m-1][m-1]))%MOD;                 s[i][j]=(s[i][j-1]+dp[i][j]%MOD)%MOD;             }         }         printf("%lld\n",s[n][m]);     }     return 0; }  
#include<bits/stdc++.h> #include <iostream> using namespace std; string func(string a, string b) { int lcs_con[a.length()+1][b.length()+1];         memset(lcs_con,0,sizeof(lcs_con));      int result=-1;     int x=-1;     int y=-1; 	string g;     for(int i=1;i<=a.length();++i)       for(int j=1;j<=b.length();++j)       {           if(a[i-1]==b[j-1])lcs_con[i][j]=lcs_con[i-1][j-1]+1;           else lcs_con[i][j]=0;            if(lcs_con[i][j]>result)           {                           result=lcs_con[i][j];                x=i;                y=j;                string	c = a.substr(x-result,result);           	if (g.length() < c.length()) { 								g = c; 							} 							else if (g.length() == c.length() && g > c) { 								g = c; 							}           }       }       if (result ==-1){       	return "";       }       return g; } int main() { 	int t; 	cin >> t; 	while (t--) { 		int n; 		cin >> n; 		string g; 		map< string , vector<int> >m; 		for (int k = 1; k <= n; k++) { 			string a,b; 			int fl = 0; 			cin >> a; 			/*if (k == 1) { 				cin >> b; 				k++; 				c = func(a,b); 			} 			else { 				c = func(a,c); 			}*/ 		for (int i = 0; i < a.length(); i++) { 				string b = a.substr(0,i+1); 				for (int j = 0; j < b.length(); j++) { 					string c = b.substr(b.length()-j-1,j+1); 					if (m[c].size() == 0 || m[c].back() != k){ 						m[c].push_back(k); 						//cout << c << " "; 						if (m[c].size()==n) { 							if (g.length() < c.length()) { 								g = c; 							} 							else if (g.length() == c.length() && g > c) { 								g = c; 							} 						} 						fl = 1; 					} 				} 			} 			//cout << endl; 		} 		 		cout << g <<endl; 	} 	return 0; }
 //Author Phinfinity #include<iostream> #include<cstdio> #include<vector> #include<cassert> #include<sstream> #include<map> #include<set> #include<stack> #include<queue> #include<algorithm> #include<string> #include<cstring> #include<cctype> #include<cmath> #include<cstdlib> //#include<climits> using namespace std; #define pop_count(n) __builtin_popcount(n) #define FOR(i,a,b) for(int i= (int)a; i< (int)b; ++i) #define REP(i,n) FOR(i,0,n) #define PB push_back #define ALL(x) x.begin(),x.end() #define LET(x,a) __typeof(a) x(a) #define IFOR(i,a,b) for(LET(i,a);i!=(b);++i) #define EACH(it,v) IFOR(it,v.begin(),v.end()) #define MP make_pair  typedef pair<int,int> PI; typedef vector<int> VI; typedef long long LL; #define INF 1000000000  vector<vector<int> > g; int a[11234]; bool dfs(int i) {    a[i]=-1;    int cv = 0;    for(size_t j=0;j<g[i].size();j++) {       int v = g[i][j];       if(a[v]==-1) 	 return false;       if(a[v]==0 && !dfs(v)) return false;       cv = max(a[v],cv);    }    a[i]=cv+1;    return true; } int main() {    int t;    scanf("%d",&t);    while(t--) {       int m,n;       scanf("%d%d",&n,&m);       g.clear();       g.resize(n);       while(m--) { 	 int tmp1,tmp2; 	 scanf("%d%d",&tmp1,&tmp2); 	 tmp1--; 	 tmp2--; 	 g[tmp1].PB(tmp2);       }       memset(a,0,sizeof(a));       int ans=0;       int i;       for(i=0;i<n;i++){ 	 if(a[i]==0) 	    if(!dfs(i)) 	       break; 	 ans = max(ans,a[i]);       }       if(i<n) 	 printf("IMPOSSIBLE\n");       else 	 printf("%d\n",ans);    }    return 0; } 
#include <cstdio> #include <cstring> #include <cassert>   const int maxm = 10000000;   int frac[maxm];   int main() { 	int n, m; 	assert(scanf("%d%d", &n, &m) == 2 && 1 <= n && n <= 100000 && 1 <= m && m <= 10000000); 	frac[0] = 1 % m; 	for (int i = 1; i < m; ++ i) { 		frac[i] = (long long)frac[i - 1] * i % m; 	} 	int answer = 0; 	for (int i = 0; i < n; ++ i) { 		long long x; 		assert(scanf("%lld", &x) == 1 && 1 <= x && x <= 1000000000000000000LL); 		 		int part1 = 0; 		if (x + 1 < m) { 			part1 = frac[x + 1]; 		} 		 		long long y = x; 		long long z = x + 1; 		if (y % 2 == 0) { 			y /= 2; 		} else { 			z /= 2; 		} 		 		int part2 = (x % m) * ((y % m) * (z % m) % m) % m; 		 		int current = (part1 + part2 + m - 1) % m; 		 		answer = (answer + current) % m; 	} 	printf("%d\n", answer); 	 	return 0; } 
#include <iostream> #include <string>  using namespace std;  int main(int argc, char const *argv[]) {     int t, i, len_s, count;      cin>>t;      while(t--)     {         string j,s;          cin>>j>>s;          len_s = s.length();         count = 0;          for(i = 0; i < len_s; ++i)         {             if(j.find(s[i]) != -1)                 ++count;         }          cout<<count<<"\n";     }     return 0; }
#include <bits/stdc++.h> using namespace std; int a[200000]; int n; void range_update(int l, int r){ 	r = min(n,r); 	for(l+=n,r+=n;l<r;l>>=1,r>>=1) 	{ 		if(l&1)a[l++]+=1; 		if(r&1)a[--r]+=1; 	} }  int query(int p ) {	 	int ans=0; 	for(p+=n;p>0;p>>=1){ 		ans+=a[p]; 	} 	return ans; }  int main() { 	int k,t,result; 	ios::sync_with_stdio(false); 	cin>>t; 	char c; 	while(t--) 	{ 		cin>>n>>k; 		for(int i=0;i<n;i++) 		{ 			cin>>c; 			if(c=='G')a[n+i]=0; 			else a[n+i]=1; 		} 		//buid the tree; 		for(int i = n-1;i>0;i--) 		{ 			a[i] = 0;  		} 		// 		result = 0; 		for(int i = 0;i<n;i++) 		{ 			if((query(i)&1)){ 				result++; 				range_update(i,i+k); 			} 		} 		cout<<result<<"\n"; 	} }
#include <iostream> #include <string.h> using namespace std;  #define gc getchar #define MAX 1000005 typedef long long ll;  int n,q; ll coun[4][4][MAX]={0}; ll occ[4][MAX]={0};  int input() {   int n = 0, ch;   while(!(ch >= '0' && ch <= '9'))ch = getchar();   while(ch >= '0' && ch <= '9')     {       n = (n << 3) + (n << 1) + (ch - '0');       ch = getchar();     }   return n; }  int num(char a) { 	if(a=='c')return 0; 	if(a=='h')return 1; 	if(a=='e')return 2; 	if(a=='f')return 3;  	return -1;  }   void prescale(char buf[]) {  	int c[4]={0};  	c[num(buf[0])]++; 	coun[num(buf[0])][num(buf[0])][0]++; 	occ[num(buf[0])][0]++;   	for(int i=1;i<n;i++) 	{ 		c[num(buf[i])]++;  		for(int j=0;j<4;j++) 		{ 			coun[num(buf[i])][j][i]=coun[num(buf[i])][j][i-1]+c[j]; 		}  		for(int j=0;j<4;j++) 		{	 			if(num(buf[i])!=j) 			{ 				for(int k=0;k<4;k++) 				{ 					coun[j][k][i]=coun[j][k][i-1]; 				} 			}  		}  		for(int j=0;j<4;j++) 		{ 			occ[j][i]=occ[j][i-1]; 		}  		occ[num(buf[i])][i]++;  	}  }   ll query(char a,char b,int l,int r) { 	if(l>=0) 	{ 		ll repa = occ[num(a)][l-1]; 		ll coub = occ[num(b)][r] - occ[num(b)][l-1];  		ll rep = repa*coub;  		ll cou = coun[num(b)][num(a)][r] - coun[num(b)][num(a)][l-1] - rep;  		//cout<<rep <<" "<<coun[num(b)][num(a)][l-1] <<" "<<coun[num(b)][num(a)][r] <<endl;  		return cou;  	}  	return coun[num(b)][num(a)][r];  }  char buf[MAX];  int main() { 	 	scanf("%s",buf);  	n=strlen(buf);  	prescale(buf);  	scanf("%d",&q);  	char a,b; 	int l,r;  	while(q-->0) 	{  		while(!(a == 'c' || a == 'h' || a == 'e' || a =='f'))a = getchar(); 		while(!(b == 'c' || b == 'h' || b == 'e' || b =='f'))b = getchar(); 		l = input(); 		r = input();	  		printf("%lld\n",query(a,b,l-1,r-1));  		a='a'; 		b='a';  	}   }         
#include<iostream> #include<math.h> #include<cstdio> #include<cstring> #include<algorithm> #include<limits.h> #include<vector> #define gc getchar_unlocked using namespace std;     void fastWrite(int a) { 	char snum[20]; 	int i=0; 	do 	{ 		snum[i++]=a%10+48; 		a=a/10; 	}while(a!=0); 	i=i-1; 	while(i>=0) 	putchar_unlocked(snum[i--]); 	putchar_unlocked('\n'); }  void fastin(int &x) { 	int sign=1; 	register int a=gc(); 	x=0; 	for(;a<48 || a>57;a=gc()) 	{ 		if(a=='-') 		sign=-1; 	} 	for(;a>47 && a<58;a=gc()) 		x=(x<<1)+(x<<3)+a-48;	 	 	x=x*sign; 		 } void fastin(long long int &x) { 	register int a=gc(); 	x=0; 	for(;a<48 || a>57;a=gc()); 	for(;a>47 && a<58;a=gc()) 		x=(x<<1)+(x<<3)+a-48;	 }  long long int bser(int l,int h,int s,long long int arr[]) { 	if(h<l) 	return l; 	else  	{ 		int mid=(l+h)/2; 		if(arr[mid]<=s) 		return bser(mid+1,h,s,arr); 		else 		return bser(l,mid-1,s,arr);	 	}	 }  int main() { 	int i,t,len,k,q,j,c_0,c_1; 	char string[100005]; 	long long int r,l,sum=0,cfr[100005],limit[100005]; 	fastin(t); 	while(t--) 	{ 		fastin(len);fastin(k);fastin(q); 		scanf("%s",string); 		c_0=c_1=0; 		if(string[0]=='1') c_1++; 		else c_0++; 		j=0; 		for(i=0;i<len;i++) 		{ 			while(j<len && c_0<=k && c_1<=k) 			{ 				j+=1; 				if(j>len-1) break; 				if(string[j]=='1') c_1++; 				else c_0++; 			} 			limit[i]=j-1; 			if(string[i]=='1') c_1--; 			else c_0--; 		}		 		 		/*for(i=0;i<len;i++) cout<<limit[i]<<" "; 		cout<<"\n"; 		*/ 		 		cfr[0]=limit[0]; 		for(i=1;i<len;i++) 		cfr[i]=cfr[i-1]+limit[i]; 		 		while(q--) 		{ 			sum=0; 			fastin(l);fastin(r); 			l--;r--; 			sum+=( (r-l+1)-(  ((r*(r+1))>>1) - ((l*(l-1))>>1) ) ); 			/*long long int m=l; 			while(m<=r && limit[m]<=r) 			{ 				m++; 			}*/ 			long long int m=bser(l,r,r,limit); 			 			if(l==0) 			{ 				sum+=cfr[m-1]; 				sum+=((r-m+1)*(r)); 				 			} 			else 			{ 				sum+=cfr[m-1]-cfr[l-1]; 				sum+=((r-m+1)*(r)); 			}	 			printf("%lld\n",sum); 			 			 		} 	} 	 	return 0; }  /*while(q--) 		{ 			sum=0; 			c_0=c_1=0; 			fastin(l);fastin(r); 			l--;r--; 			j=l; 			if(string[j]=='1') c_1++; 			else c_0++; 			 			for(i=l;i<=r;i++) 			{ 				while(j<=r && c_0<=k && c_1<=k) 				{ 					j+=1; 					if(j>r) break; 					if(string[j]=='1') c_1++; 					else c_0++; 				} 				sum+=j-i; 				if(string[i]=='1') c_1--; 				else c_0--; 			} 			printf("%lld\n",sum);	 		}*/
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>   using namespace std;  int min(int a , int b) { 	if(a<b) 		return a; 	else 		return b; }  int main() { 	int N; 	cin>>N; 	char s[N][101];  	int i, len; 	for(i = 0; i<N; ++i) { 		cin>>s[i]; 		 		for(len = 0; s[i][len]!='\0'; ++len); 		sort(s[i], s[i] + len); 	}  	int a[26], b[26], count, alpha; 	for(i = 0; i<26; ++i) 		a[i] = 0; 	 	count = 1; 	alpha = s[0][0]; 	for(len = 1; s[0][len] != '\0'; ++len) { 		if(alpha == s[0][len]) 			++count; 		else { 			a[alpha-'a'] = count; 			count = 1; 			alpha = s[0][len]; 		} 	} 	a[alpha-'a'] = count; 	 		 	for(i = 1; i<N; ++i) { 		count = 1; 		alpha = s[i][0];  		for(len = 0; len<26; ++len) 			b[len] = 0;  		for(len = 1; s[i][len] != '\0'; ++len) { 			if(alpha == s[i][len]) 				++count; 			else { 				b[alpha-'a'] = count;				 				count = 1; 				alpha = s[i][len];  			}		 		} 		b[alpha-'a'] = count;  		for(len = 0; len<26; ++len) 			a[len] = min(a[len], b[len]); 	}  	int f = 1; 	for(i = 0; i<26; ++i) { 		for(len = 0; len<a[i]; ++len) { 			f = 0; 			cout<<(char)('a'+i); 		} 	} 	 	if(f) 		cout<<"no such string"; 	cout<<endl; } 
#include<bits/stdc++.h> using namespace std; int gcd(int a,int b){     if(a==0){         return b;     }      else if(b%a==0 ){         return a;     }     else{         return gcd(b%a,a);     } } int main(){     int t;     cin>>t;     while(t--){         int n;         cin>>n;         int *array=new int[n];         int gcd1=0;         for(int i=0;i<n;i++){             cin>>array[i];             if(array[i]>gcd1){                 gcd1=gcd(gcd1,array[i]);             }             else{                 gcd1=gcd(array[i],gcd1);             }                      }         if (gcd1==1){             cout<<n<<endl;         }         else{             cout<<-1<<endl;         }                       } }
#include<bits/stdc++.h> using namespace std; const int MAXN = 50 + 10; const int INF = 1e9; int A[MAXN]; int main(){     int N;     cin >> N;     for(int i = 1;i <= N;++i)         cin >> A[i];     int Q;     cin >> Q;     while(Q--){         int x;         cin >> x;         int ans = 0;         for(int i = 1;i <= N;++i){             int mini = INF;             for(int j = i;j <= N;++j){                 mini = min(mini, A[j]);                 if(mini == x) ++ans;             }         }         printf("%d\n", ans);     }     return 0; } 
#include<iostream> #include<stdio.h> #include<string> #include<string.h> #include<algorithm>   using namespace std;   int main() { 	int T, N, D, i; 	cin>>T; 	while(T--) { 		cin>>N>>D; 			 		unsigned long long int A[N], ans = 0, prev; 		for(i = 0; i<N; ++i) 			cin>>A[i];  		sort(A, A+N); 		 		prev = A[N-1] + 1; 		for(i=N-1; i>0; --i) { 			if(A[i] - A[i-1] < D) { 				ans += A[i] + A[i-1]; 				--i; 			} 		}  		cout<<ans<<endl; 	} } 
#include <iostream> #include <cstdio> #include <set> #include <cstring>  using namespace std;  struct flight {   int flightidx, deptime, arrtime, arrcityidx;   bool operator() (const flight& lhs, const flight& rhs) const {     return lhs.deptime < rhs.deptime;   } };  int main() {   int t, n;   bool flights[10005];   set<flight, flight> cityflights[10005];   int dt, at, dc, ac;   int start, stime, end, etime;   int curcity, curtime, flightstaken;    scanf("%d", &t);    while(t--) {     memset(flights, 0, 10005 * sizeof(bool));      for (int i = 0; i < 10005; ++i)     {       cityflights[i].clear();     }      scanf("%d", &n);      for (int j = 0; j < n; ++j)     {       scanf("%d%d%d%d", &dc, &dt, &ac, &at);        flight f;       f.flightidx = j;       f.deptime = dt;       f.arrtime = at;       f.arrcityidx = ac;        cityflights[dc].insert(f);     }      scanf("%d%d%d%d", &start, &stime, &end, &etime);      curcity = start;     curtime = stime;     flightstaken = 0;      /*     for (int i = 0; i < 5; ++i)     {       printf("city: %d\n", i);       for (set<flight, flight>::iterator itr = cityflights[i].begin(); itr != cityflights[i].end(); ++itr)       {         printf("%d ", itr->deptime);       }       printf("\n");     }     */      while(true) {       if(curcity == end && curtime <= etime) {         printf("Yes %d\n", flightstaken);         break;       }        flight f1;       f1.deptime = curtime;        set<flight, flight>::iterator itr = cityflights[curcity].lower_bound(f1);       if(itr == cityflights[curcity].end() || flights[itr->flightidx] == 1) {         printf("No\n");         break;       }        curcity = itr->arrcityidx;       curtime = itr->arrtime;       flights[itr->flightidx] = 1;       flightstaken++;     }   } }
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e5 + 10; long double E[MAXN]; int main(){     E[1] = 0.45;     for(int i = 2;i < MAXN;++i){         E[i] = 0.45 + E[i - 1]/10;      }     for(int i = 2;i < MAXN;++i){         E[i] += E[i - 1];     }     int t;     scanf("%d", &t);     while(t--){         int N;         scanf("%d", &N);         printf("%.6Lf\n", E[N]);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     long long n,d;     cin>>n>>d;     long long *array=new long long[n];     for(int i=0;i<n;i++){         cin>>array[i];     }     sort(array,array+n);     long long count=0;     for(int i=0;i<n-1;){         if((array[i+1]-array[i])<=d){             count++;             i=i+2;         }         else{             i++;         }     }     cout<<count;      }
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e9 + 7; LL power(LL A, LL B){     LL ans = 1;     while(B > 0){         if(B & 1LL){             ans = (ans * A) % MOD;         }         A = (A * A) % MOD;         B >>= 1;     }     return ans; } int main(){     int t;     cin >> t;     while(t--){         LL N;         scanf("%lld", &N);         LL ans = 0;         LL p = power(26, ((N + 1) >> 1));         LL q = power(26, N/2);         ans = (26 * ((q + MOD - 1) % MOD)) % MOD;         ans = (ans * 2) % MOD;         ans = (ans * power(25, MOD - 2)) % MOD;         if(N & 1LL)             ans = (ans + p) % MOD;         printf("%lld\n", ans);     }     return 0; } 
#include <iostream> using namespace std;  int main() { 	int t,n,a,b,c,q,l,r; 	cin>>t; 	while(t-->0) 	{ 		cin>>n>>c>>q; 		for(int i=0;i<q;i++) 		{ 			cin>>l>>r; 			if((l<=c&& c<=r)) 			{a=c-l; 			b=r-a; 			c=b; 			}         }//end of for 		cout<<c<<endl; 	}//end of while 	 	// your code goes here 	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){         long long array[3];         cin>>array[0]>>array[1]>>array[2];         sort(array,array+3);         long long product=array[0]%1000000007;         product=(product*((array[1]-1)%1000000007))%1000000007;         product=(product*((array[2]-2)%1000000007))%1000000007;         cout<<product<<endl;     } }
	#include <iostream> 	#include <fstream> 	#include <set> 	#include <utility> 	#include <string> 	#include <vector> 	#include <math.h> 	#include <algorithm> 	#include <stdio.h> 	using namespace std;  	#define gc getchar_unlocked   	int main(){ 		//multiset< float , float > ang; 		//ifstream cin("input.txt"); 		vector <int> hour , min ; 		vector <float>angle; 		string str; 		int h , m ;  		double diff, cal1 ,cal2 ,  i , j;; 		h = 11 ; 		m = 59; 		for ( i = 0 ; i <= h ; i++ ){ 			for ( j = 0 ; j <= m ; j = j + 1){ 				cal1 = (i*60/2) + (j/2); // hour angle 				cal2 = (j*6); // min angle; 				diff = fabs(cal1 - cal2) ; 				if ( diff > 180 ){ 					 					diff = 360 - diff ; 				} 				//cout << cal1 << " " << cal2 << " " << diff << endl; 				 				hour.push_back(i); 				min.push_back(int(j)); 				angle.push_back(diff); 				//cout << diff << endl; 				  			} 		}   		int t , size; 		double value; 		cin >> t; 		size = hour.size(); 		while( t-- ){ 			//cin >> value; 			scanf("%lf",&value); 			if ( ((value*120) - int(value*120) )!= 0){ 				value = int(value*120)/120.00; 				//cout << value << endl; 			}  			for ( int i = 0 ; i < size;i++ ){ 				//cout << angle[i] << endl;  				if ( value == angle[i] ){ 					if ( hour[i] > 9 && min[i] > 9 ){ 						//cout << hour[i] <<":" << min[i] << endl; 						printf("%d:%d\n" ,hour[i] ,min[i]); 					} 					else if ( hour[i] <= 9 && min[i] > 9 ){ 						//cout << "0" << hour[i] <<":" << min[i] << endl; 						printf("0%d:%d\n" ,hour[i],min[i] ); 					} 					else if ( hour[i] > 9 && min[i] <= 9 ){ 						//cout << hour[i] <<":" << "0" << min[i] << endl; 						printf("%d:0%d\n",hour[i],min[i]); 					} 					else { 						//cout << "0" << hour[i] <<":" << "0" << min[i] << endl; 						printf("0%d:0%d\n",hour[i],min[i]); 					}  					 					 				}   			} 		}       	}
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e6; const int MAXN = 3e6 + 10; LL A[MAXN]; LL B[MAXN]; int main(){     int t;     scanf("%d", &t);     while(t--){         int N, a, b, c, d;         scanf("%d%d%d%d%d", &N, &a, &b, &c, &d);         LL aSum = 0;         LL bSum = 0;         LL s = d;         for(int i = 0;i < MOD;++i){             A[i] = 0;         }         for(int i = 1;i <= N;++i){             ++A[s];             s = (a * s * s + b * s + c) % MOD;         }         int _j = 0;         for(int i = MOD - 1;i >= 0;--i){             while(A[i] > 0){                 B[_j] = i;                 ++_j;                 --A[i];             }         }         for(int i = 0;i < N;++i){             if(i&1){                 aSum += B[i];             } else {                 bSum += B[i];             }         }         LL ans = aSum - bSum;         if(ans < 0) ans = -ans;         printf("%lld\n", ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     string s;     cin>>s;     while(t--){         string b;         cin>>b;         string out="";         int length=b.length();         for(int i=0;i<length;i++){             if((int)b[i]==95){                 out=out+' ';             }             else if((int)b[i]>=97 && (int)b[i]<=122){                 out=out+s[b[i]-97];             }             else if((int)b[i]>=65 && (int)b[i]<=90){                 out=out+(char)((int)s[b[i]-65]-32);             }             else{                 out=out+b[i];             }         }         cout<<out<<endl;     } }
#include<bits/stdc++.h> using namespace std; int main(){ 	int t; 	scanf("%d", &t); 	while(t--){ 		int N; 		scanf("%d", &N); 		int ans = 0; 		map<pair<string, string>, string> cost; 		map<string, string> parent; 		map<string, string> child; 		for(int i = 1;i < N;++i){ 			string A, B, C; 			cin >> A >> B >> C; 			cost[make_pair(A, B)] = C; 			parent[B] = A; 			child[A] = B; 			if(parent[A] == "") parent[A] = ""; 		} 		string start; 		for(map<string, string> :: iterator it = parent.begin();it != parent.end();++it){ 			if(it->second == "") 				start = it->first; 		} 		while(child[start] != ""){ 			string &C = cost[make_pair(start, child[start])]; 			cout << start << " " << child[start] << " " << C << "\n"; 			start = child[start]; 			int N = C.size(); 			int nc = 0; 			for(int i = 0;i < N - 1;++i){ 				nc = (nc * 10 + C[i] - '0'); 			} 			ans += nc; 		} 		cout << ans << "$\n"; 	} 	return 0; }
#include <iostream> #include <stdio.h> #include <algorithm> #define ll long long using namespace std; const int N = 1e4 + 2; ll arr[N]; double brr[N]; int main(){ 	int t, i, j, n, m,  tempn; 	double pr; 	scanf( "%d", &t );     	while(t--){                 scanf("%d %d %lf", &n, &m, &pr );                 pr /= 100.0f;                 for( i=0 ; i<m ; ++i ){                         scanf("%d", &tempn );                         arr[i] = tempn-1;                 }                 sort( arr, arr+m ) ;                 for( i=0 ; i<m ; ++i ) brr[i] = 1.0;                 for( j=1 ; j<n ; j<<=1 ){                         for( i=0 ; i<m ; ++i ) arr[i] >>= 1;                         int k = 0;                         for( i=0 ; i<m ; ++i ){                                 if( arr[i] == arr[i+1] && m!=1 && i!=m-1){                                         arr[i-k] = arr[i];                                         brr[i-k] = brr[i]*brr[i+1] + pr*brr[i]*(1.0-brr[i+1]) + pr * ( 1- brr[i] ) * brr[i+1];                                         i++;k++;                                 }                                 else{                                         arr[i-k] = arr[i];                                         brr[i-k] = brr[i]*pr;                                 }                         }                         m -= k;                 }                 printf("%.13lf\n", 100.0*brr[0]);     	}     	return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1 << 16; const int MOD = 1e9 + 7; typedef long long LL; LL v[MAXN]; LL p[MAXN][140]; inline int getMax(int x, int y){ 	if(p[x][0] > p[y][0]) 		return x; 	else if(p[x][0] < p[y][0]) 		return y; 	else { 		for(int i = p[x][0];i >= 1;--i){ 			if(p[x][i] > p[y][i]) 				return x; 			else if(p[x][i] < p[y][i]) 				return y; 		} 		return x; 	} } inline void mul(int des, int src, LL val){ 	LL carry = 0; 	p[des][0] = 0; 	for(int i = 1;i <= p[src][0];++i){ 		++p[des][0]; 		LL z = carry + val * p[src][i]; 		p[des][p[des][0]] = z % 10; 		carry = z/10; 	} 	while(carry){ 		++p[des][0]; 		p[des][p[des][0]] = carry % 10; 		 carry /= 10;	 	} } int main(){ 	int h; 	while(scanf("%d", &h) != EOF && h != 0){ 		int n = (1 << h) - 1; 		for(int i = 1;i <= n;++i){ 			scanf("%lld", &v[i]); 		} 		for(int i = n - (1 << (h - 1)) + 1;i <= n;++i){ 			p[i][0] = 0; 			while(v[i] > 0){ 				++p[i][0]; 				p[i][p[i][0]] = v[i] % 10; 				v[i] /= 10; 			} 		} 		for(int i = n - (1 << (h - 1));i >= 1;--i){ 			int ind = getMax((i << 1), (i << 1) + 1); 			mul(i, ind, v[i]); 		} 		LL ans = 0; 		for(int i = p[1][0];i >= 1;--i){ 			ans = ans * 10 + p[1][i]; 			ans %= MOD; 		} 		printf("%lld\n", ans); 	} 	return 0; }
#include      <iostream> #include      <list> #define endl '\n' #define each(c, e, s) for (typeof(c.begin()) e = c.begin(); e != c.end(); ++e) if (*e != s) using namespace std; typedef long long ll; const ll PRIME = 1000000007; struct Node { 	list<int> childs; 	int treeSize; 	ll sum; }; Node nodes[10002]; void dfs(int from, int cameFrom) { 	nodes[from].treeSize = 1; 	each(nodes[from].childs, child, cameFrom) dfs(*child, from), nodes[from].treeSize += nodes[*child].treeSize; 	nodes[from].sum = nodes[from].treeSize; 	ll cst = 1; 	each(nodes[from].childs, child, cameFrom) { 		cst += nodes[*child].treeSize; 		nodes[from].sum = (nodes[from].sum + nodes[*child].treeSize * (nodes[from].treeSize - cst)) % PRIME; 	} 	nodes[from].sum = (2 * nodes[from].sum - 1) % PRIME; } int main(int argc, char **argv) { 	ios_base::sync_with_stdio(false), cin.tie(0); 	int n, i, from, to, t; 	ll res; 	cin >> t; 	while (t--) { 		cin >> n; 		for (i = 1; i <= n; i += 1) nodes[i].childs.clear(); 		for (i = 0; i < n - 1; i += 1) { 			cin >> from >> to; 			nodes[from].childs.push_back(to); 			nodes[to].childs.push_back(from); 		} 		dfs(1, 0);  		res = 0; 		for (i = 1; i <= n; i += 1) res = (res + i * nodes[i].sum) % PRIME; 		cout << res << endl; 	} 	return 0; } 
#include<stdio.h> #include<ctype.h> #include<string.h> #include<limits.h>  #include<iostream> #include<cmath> #include<limits> #include<map> #include<set> #include<queue> #include<list> #include<string> #include<map>  using namespace std;  #define FOR(I,N) for(I = 0 ; I < N ; I++) #define FOR2(I,K,N) for(I = K ; I < N ; I++) #define RFOR(I,N) for(I = N ; I >= 0 ; I--) #define RFOR2(I,K,N) for(I = N ; I >= K ; I--) #define isend(C) (C == '\n' || C == '\r' || C == EOF) #define iswhitespace(C) (C == '\t' || C ==' ' || C == '\n' || C == '\r' || C == EOF)  #define ll long long #define ull unsigned long long  #define MOD 1000000007  // #define FASTIO  // FASTIO BEGIN  #ifdef FASTIO  #define FASTIO_INSIZE 1000000 #define FASTIO_OUTSIZE 1000000  char inputBuf[FASTIO_INSIZE]; char *inptr = inputBuf;  char outputBuf[FASTIO_OUTSIZE]; char *outptr = outputBuf;  #define consumewhite {while(iswhitespace(*inptr)) inptr++;}  inline unsigned long long get_ulonglong() { 	unsigned long long ans = 0; 	while(isdigit(*inptr)) 	{ 		ans = ((ans*10) + (*inptr - '0')); 		inptr++; 	}  	consumewhite;  	return ans; }  inline long long get_longlong() { 	long long ans=0; 	int flag = 1; 	if(*inptr == '-') 	{ 		flag = -1; 		inptr++; 	} 	 	while(isdigit(*inptr)) 	{ 		ans = ((ans*10) + (*inptr - '0')); 		inptr++; 	}  	consumewhite;  	return flag*ans; }  inline int get_string(char *s,int mode) { 	// mode = 1 for gets, 0 for scanf("%s")  	int len = 0; 	while((mode && !isend(*inptr)) || (!mode && !iswhitespace(*inptr))) 	{ 		s[len++] = *inptr++; 	}  	consumewhite;  	s[len] = '\0'; 	return len; }   #define printf(...) outptr+= sprintf(outptr, __VA_ARGS__)  #define GETINTANDSPACE(N) { N = (int) get_longlong(); } #define GETINT(N) { N = (int) get_longlong(); } #define GETUINT(N) { N = (unsigned int) get_ulonglong(); } #define GETLONG(N) { N = (long) get_longlong(); } #define GETULONG(N) { N = (unsigned long) get_ulonglong(); } #define GETLONGLONG(N) { N = (long long) get_longlong(); } #define GETULONGLONG(N) { N = get_ulonglong(); } #define gets(S) get_string(S,1) #define GETSTRING(S) get_string(S,0) #define getchar() (*inptr++)  #define takeInput fread_unlocked(inputBuf,sizeof(char),FASTIO_INSIZE,stdin); #define printOutput fwrite_unlocked(outputBuf,sizeof(char),outptr-outputBuf,stdout);  #else // NORMAL IO PATH  #define GETINTANDSPACE(N) {scanf("%d\n",& N);} #define GETINT(N) {scanf("%d",& N);} #define GETUINT(N) {scanf("%u",& N);} #define GETLONG(N) {scanf("%ld",& N);} #define GETULONG(N) {scanf("%lu",& N);} #define GETLONGLONG(N) {scanf("%lld",& N);} #define GETULONGLONG(N) {scanf("%llu",& N);} #define GETSTRING(S) {scanf("%s", S);} #define gets(S) (gets(S) != NULL ? strlen(S) : 0)  #define takeInput #define printOutput #define consumewhite scanf("\n")  #endif // END FASTIO  // END FASTIO   main() { 	takeInput; // FASTIO  	map<string, int> map;  	int N,M; 	int i,j;  	int A[60][60] = {0};  	GETINTANDSPACE(N);  	FOR(i,N) 	{ 		char str[30]; 		GETSTRING(str); 		consumewhite; 		map[string(str)] = i; 	}  	GETINTANDSPACE(M);  	FOR(i,M) 	{ 		char str1[30],str2[30]; 		int index1,index2,D; 		GETSTRING(str1); 		GETSTRING(str2); 		GETINTANDSPACE(D); 		index1 = map[string(str1)]; 		index2 = map[string(str2)]; 		A[index1][index2] = D; 	}  	int T; 	GETINTANDSPACE(T); 	while(T--) 	{ 		int k; 		int visited[60] = {0}; 		ll len = 0;  		GETINT(k);  		int cur = -1, flag = 1;  		while(k--) 		{ 			char str[30]; 			GETSTRING(str); 	 			if(flag) 			{ 				if(map.count(string(str)) == 0) 				{ 					flag = 0; 					continue; 				}  				int next = map[string(str)]; 				 				if(cur != -1) 				{ 					if(A[cur][next] == 0 || visited[next]) 						flag = 0; 					else 						len += A[cur][next]; 				} 			 				visited[cur] = 1;	 				cur = next; 			}  		}  		if(flag) 			printf("%lld\n",len); 		else 			printf("ERROR\n");  		consumewhite; 	} 	 	printOutput; // FASTIO 	return 0; } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; std::vector<int > adjList[1000010]; std::vector< pair<int , int > > V; int depth[100010];   void dfs(int curr_vertex , int parent) { 	std::vector<int >::iterator it = adjList[curr_vertex].begin(); 	while(it!=adjList[curr_vertex].end()) 	{ 		if((*it)!=parent) 		{ 			depth[(*it)] = depth[curr_vertex] +  1; 			dfs((*it) , curr_vertex); 		} 		it++; 	} }  int main() { int test , N , u , v; si(test); while(test--) { 	si(N); 	for(int i=0;i<N+4;i++) 		adjList[i].clear();  	for(int i=1;i<=N-1;i++){ 		si(u);si(v); 		adjList[u].pb(v); 		adjList[v].pb(u); 	}  	depth[1] = 1; 	dfs(1 ,  -1);  	int left , right; 	left = 0; 	right = N-1;  	V.clear(); 	for(int i=1;i<=N;i++) 		V.pb(mp(depth[i] , i)); 	sort(V.begin() , V.end());  	int ans = 0 , flag = 0 , curr;  	while(left <= right) 	{ 		if(flag == 0) 		{ 			curr = left; 			while((V[left].first == V[curr].first) && left<=right) 				left++; 		} 		else 		{ 			right--; 		} 		flag = 1 - flag; 		ans++; 	} 	printf("%d\n", ans);  }  return 0; }           
    //     //AUTHOR: KISLAY     //DATE: Thu Feb 10 03:32:45 IST 2011     #include <vector>     #include <cassert>     #include <list>     #include <map>     #include <set>     #include <queue>     #include <deque>     #include <stack>     #include <bitset>     #include <algorithm>     #include <functional>     #include <numeric>     #include <utility>     #include <sstream>     #include <iostream>     #include <iomanip>     #include <cstdio>     #include <cmath>     #include <cstdlib>     #include <ctime>     #include <cstring>     #include <climits>     #include <fstream>     #include <sstream>     #include<ctype.h>           #define PI 3.1415926535897932384626433832795028841971693993751058209749Lf     #define INF 2000000000     #define INFI 1e37     #define pb push_back     #define PRINT(x) cout << #x << " " << x << endl     #define MAX ((int)1e6+10)     #define MOD 1000000007     #define BUF 4096           char ibuf[BUF];     int ipt = BUF;           int readInt() {     while (ipt < BUF && ibuf[ipt] < '0') ipt++;     if (ipt == BUF) {     fread(ibuf, 1, BUF, stdin);     ipt = 0;     while (ipt < BUF && ibuf[ipt] < '0') ipt++;     }     int n = 0;     while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');     if (ipt == BUF) {     fread(ibuf, 1, BUF, stdin);     ipt = 0;     while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');     }     return n;     }           using namespace std;     int ways[MAX];     int ans[MAX];     int a[MAX];     int main()     {     int n,m,j;     n=readInt();     m=readInt();     for(int i=0;i<n;i++)     {     a[i]=readInt();     }     ans[n-1]=0;     ways[n-1]=1;     int k=j=n-1;     int sum=0,sumways=0;     for(int i=n-2;i>=0;i--)     {     sum+=a[i+1]-a[i];     while(sum>m)     {     sum-=a[j]-a[j-1];     sumways-=ways[j];     if(sumways<0)     sumways+=MOD;     --j;     }     ans[i]=ans[j]+1;     while(ans[k]!=ans[i])     {     sumways+=ways[k];     if(sumways>MOD)     sumways-=MOD;     k--;     }     ways[i]=sumways;     }     printf("%d %d\n",ans[0]-1,ways[0]);           return 0;     } 
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<cstdio> #include <ctime> #include<cassert>   using namespace std;   #define MEM(a,b) memset(a,(b),sizeof(a)) #define MAX(a,b) ((a) > (b) ? (a) : (b)) #define MIN(a,b)  ((a) < (b) ? (a) : (b)) #define istr(S) istringstream sin(S) #define MP make_pair #define pb push_back #define inf 1000000000 #define maxn 1000000 #define SI(x) scanf("%d",&x) #define SL(x) scanf("%l",&x) #define SLL(x) scanf("%ll",&x) #define SLLU(x) scanf("%llu",&x) #define SC(x) scanf("%c",&x) #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))   #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))    typedef long long  LL; //typedef __int64 LL; typedef pair<int,int> pi; typedef vector<int> vi; typedef vector<string> vs; typedef vector<double> vd;       typedef long long int ll; using namespace std;     int main() {  int cases,maxsum,dullcount,dull,indx,pagecount,lvstorn,lvs; float avgPerLv; scanf("%d",&cases); while(cases--) { scanf("%d",&pagecount); maxsum=(pagecount*(pagecount+1))/2;//summation of all printed pages //cout<<"maxsum"<<maxsum<<endl; scanf("%d",&dullcount); FOR(i,0,dullcount) { scanf("%d",&dull); maxsum=maxsum-dull; } //cout<<"maxsum"<<maxsum<<endl; scanf("%d",&lvstorn); lvs=(pagecount/2)+(pagecount%2); //cout<<"lvs"<<lvs<<endl; avgPerLv=(float)maxsum / lvs; //cout<<"avgPerLv"<<avgPerLv<<endl; printf("%0.4f\n",(lvs-lvstorn)*avgPerLv); } return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <complex> #include <utility> #include <fstream> #include <sstream> #include <iostream> #include <iomanip> #include <cctype> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits>  using namespace std;   typedef long long LL; typedef unsigned long long ULL; typedef long double LD; typedef vector<int> VI; typedef vector<string> VS; typedef vector<VI> VVI; typedef pair<int,int> PII;  #define REP(i,a,b) for(int i=a;i<b;i++) #define rep(i,n) REP(i,0,n) #define REV(i,a,b) for(int i=a-1;i>=b;i--) #define rev(i,n) REV(i,n,0) #define TR(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++) #define GI ({ int x; scanf("%d",&x); x; }) #define ALL(v) v.begin(),v.end() #define PB push_back #define MP make_pair #define PQ priority_queue #define inf (int)(1e9) #define linf (LL)(1e18) #define eps (double)(1e-9) #define leps (LD)(1e-18) #define PI (double)(3.141592653589793238)   int age[100005],l[100005],r[100005],in[100005]; string s,p; int f[200005];  int root(int n) { 	REP(i,1,n+1) 		cin>>age[i]; 	memset(l,-1,sizeof l); 	memset(r,-1,sizeof r); 	memset(in,0,sizeof in); 	int a,b; 	char c; 	rep(i,n-1) 	{ 		cin>>a>>b>>c; 		if(c=='M') 			l[a]=b; 		if(c=='E') 			r[a]=b; 		in[b]++; 	} 	REP(i,1,n+1) 		if(in[i]==0) 			return i; 	return -1; }  void build(string &s,int i) { 	if(i==-1) 		return; 	s.PB(char(age[i]+30)); 	s.PB((char)27); 	build(s,l[i]); 	s.PB((char)26); 	build(s,r[i]); }  void fail() { 	int m=p.length(); 	int i=0,j=-1; 	f[i++]=j++ + 1; 	while(i<m) 	{ 		if(p[i]==p[j]) 			f[i++]=j++ + 1; 		else if(j>0) 			j=f[j-1]; 		else 			f[i++]=0; 	} }  bool kmp() { 	int n=s.length(),m=p.length(); 	int i=0,j=0; 	while(i<n) 	{ 		if(s[i]==p[j]) 		{ 			i++,j++; 			if(j==m) 				return 1; 		} 		else if(j>0) 			j=f[j-1]; 		else 			i++; 	} 	return 0; }  int main() { 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	int n,q,m; 	cin>>n; 	int st=root(n); 	s=""; 	build(s,st); 	//cout<<s<<'\n'; 	cin>>q; 	rep(i,q) 	{ 		cin>>m; 		st=root(m); 		p=""; 		build(p,st); 		//cout<<p<<'\n'; 		fail(); 		cout<<(kmp()?"YES\n":"NO\n"); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; const int INF = 1e8; int T[MAXN]; int D[MAXN]; int main(){     int N, K;     scanf("%d%d", &N, &K);     for(int i = 1;i < MAXN;++i)         D[i] = INF;     for(int i = 1;i <= N;++i){         scanf("%d", &T[i]);         D[T[i]] = min(D[T[i]], min(i, N - i + 1));     }     int ans = INF;     for(int i = 1;i <= N;++i){         int th = T[i];         int oth = K - T[i];         //cout << th << " " << oth << "\n";         if(th != oth && oth > 0 && D[oth] != INF){             ans = min(ans, max(D[th], D[oth]));         }     }     if(ans == INF) ans = -1;     printf("%d\n", ans);     return 0; } 
#include<bits/stdc++.h> using namespace std; const int MAXN = 1e6 + 10; const int INF = 1e9 + 10; int child[MAXN][27]; int indexi[MAXN]; int pr[MAXN]; int nodecnt = 0;  int v[MAXN]; string str[MAXN]; void insert(int ind){     int node = 0;     int N = str[ind].size();     for(int i = 0;i < N;++i){         int ch = str[ind][i];         if(ch == '-') ch = '{';         ch -= 'a';          if(child[node][ch] == 0){             child[node][ch] = ++nodecnt;             pr[child[node][ch]] = -INF;         }         node = child[node][ch];         if(pr[node] < v[ind]){             pr[node] = v[ind];             indexi[node] = ind;         }     } } int query(string s){     int N = s.size();     int node = 0;     for(int i = 0;i < N;++i){         int ch = s[i];         if(ch == '-') ch = '{';         ch -= 'a';          node = child[node][ch];         if(node == 0){             return 0;         }     }     return indexi[node]; } int main(){     memset(child, 0, sizeof child);     str[0] = "NO";     int N;     scanf("%d", &N);     for(int i = 1;i <= N;++i){         cin >> str[i];         scanf("%d", &v[i]);         insert(i);     }     int Q;     cin >> Q;     while(Q--){         string s;         cin >> s;         cout << str[query(s)] << "\n";     }     return 0; } 
#include<iostream> using namespace std;  int a[200005]={0};  int main(){ 	int n,p; 	cin>>n>>p; 	for(int i=0;i<n;i++){ 		cin>>a[i]; 	} 	int cura=1000000000; 	int curd=1000000000; 	for(int i=0;i<11 && i<n-1;i++){ 		for(int j=i+1;j<12 && j<n ;j++){ 			int num=a[j]-a[i]; 			int den=j-i; 			if(num%den==0){ 				int d=num/den; 				int a1=a[i]-d*i; 				int count=0; 				for(int k=0;k<n;k++){ 					if(a[k]!=(a1+k*d)){ 						count++; 					} 				} 				//cout<<count<<endl; 				if(count<=p && a1<cura){ 					cura=a1; 					curd=d; 				} 				else if(count<=p && a1==cura && d<curd){ 					cura=a1; 					curd=d; 				} 			} 		} 	} 	for(int i=0;i<n;i++){ 		cout<<(cura+i*curd)<<" "; 	} 	cout<<endl; 	return 0; } 
#include<iostream> #include<cstring> #include<algorithm> using namespace std; int main() {     int n1,n2,n3;     cin>>n1>>n2>>n3;     int tot=n1+n2+n3;     int a[150000];     int k=0;     while(k!=(tot))         cin>>a[k++];     sort(a,a+tot);     int i=0;     int vot=0;     while(i<tot)     {         int j=i,count=0;         while(a[j]==a[i]&&j<tot)            { count++;j++;}         if(count>=2)             vot++;         i=i+count;     }     cout<<vot<<endl;     i=0;     while(i<tot)     {         int j=i,count=0;         while(a[j]==a[i]&&j<tot)           {  count++;j++;}         if(count>=2)             cout<<a[i]<<endl;         i=i+count;     } }
#include<iostream> #include<stdio.h> #include<stdlib.h> int main() {     long int t;     scanf("%ld",&t);     while(t--)     {         long int n,*a,i,s;         scanf("%ld",&n);         a=(long int*)malloc(n*sizeof(long int));         for(i=0;i<n;i++)             scanf("%ld",&a[i]);         s=0;         for(i=0;i<n;i++)             if(s<a[i]+i)             s=a[i]+i;         printf("%ld\n",s);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 1e9 + 7; LL fac[600]; LL power(LL A, LL B){     LL ans = 1;     while(B > 0){         if(B & 1) ans = (ans * A) % MOD;         A = (A * A) % MOD;         B >>= 1;     }     return ans; } int main(){     fac[0] = 1;     for(int i = 1;i < 600;++i){         fac[i] = (fac[i - 1] * i) % MOD;     }     int t;     cin >> t;     while(t--){         string s;         cin >> s;         int aCnt[26] = {0};         int ACnt[26] = {0};         int sz = s.size();         for(int i = 0;i < sz;++i){             if(s[i] >= 'a')                 aCnt[s[i] - 'a'] += 1;             else ACnt[s[i] - 'A'] += 1;         }         LL ans = fac[s.size()];         for(int i = 0;i < 26;++i){             ans = (ans * power(fac[aCnt[i]], MOD - 2)) % MOD;         }         for(int i = 0;i < 26;++i){             ans = (ans * power(fac[ACnt[i]], MOD - 2)) % MOD;         }         printf("%lld\n", ans);     }     return 0; } 
#include <vector> #include <algorithm> #include <iostream> #include <cmath> #include <cstdlib> #include <cstring>   #define FOR(A,B,C) for(int A=B;A<C;A++) #define EFOR(A,B,C) for(int A=B;A<=C;A++) #define RFOR(A,B,C) for(int A=B;A>=C;A--) #define PB(A,B) A.push_back(B); #define SORT(A) sort( A.begin(),A.end() ) #define ALL(A) A.begin(),A.end() #define VI vector<int> #define VS vector<string> #define VD vector<double> #define VB vector<bool> #define SZ(A) int(A.size()) #define LL long long   using namespace std;   inline void Input(int &N) { 	int ch,sign; 	N=0;   	while((ch<'0'||ch>'9')&&ch!='-'&&ch!=EOF) 		ch=getchar();   	if(ch=='-') 		sign=-1,ch=getchar(); 	else 		sign=1;   	do 		N=(N<<3)+(N<<1)+(ch-'0');while((ch=getchar())>='0'&&ch<='9');   	N*=sign; 	return; }   int main() { //	freopen("Input.txt","r",stdin); 	int ways[22][205][12]; 	memset(ways,0,sizeof(ways)); 	int MOD=1000007;   	EFOR(fill,1,9) 		ways[1][0][fill]=1;   	EFOR(alldig,2,20){ 		EFOR(alldif,0,200) 			EFOR(ending,0,9) 				EFOR(tmp,0,9){ 					if(alldif-tmp<0) 						continue;   					if(tmp+ending<=9) 							ways[alldig][alldif][ending]+=ways[alldig-1][alldif-tmp][ending+tmp];   					if(ending-tmp>=0 && tmp!=0) 						ways[alldig][alldif][ending]+=ways[alldig-1][alldif-tmp][ending-tmp]; 					ways[alldig][alldif][ending]%=MOD; 				} 	}   	int T,num,wt; 	Input(T); 	while(T--){ 		Input(num),Input(wt);   		int ans=0; 		EFOR(done,0,9){ 			ans+=ways[num][wt][done]; 			ans%=MOD; 		} 		printf("%d\n",ans); 	}   //	fclose(stdin); 	return 0; }  
 /*  **	Author : Amit Bansal	**  */  #include<stdio.h> #include<iostream> #include<string.h> #include<ctype.h> #include<math.h> #include<stdlib.h>  #include<vector> #include<algorithm> #include<string> #include<sstream>  #include<map> #include<set> #include<list> #include<queue> #include<stack> #include<bitset>  #include<functional> #include<numeric> #include<utility> #include<iomanip> #include<ctime>  using namespace std; typedef long long						LL; typedef vector<int> 						VI; typedef vector<LL> 						VLL; typedef vector<double> 						VD; typedef vector<string> 						VS; typedef vector<VI>						VVI; typedef vector<VLL>						VVLL; typedef pair<int,int> 						II; typedef vector<II> 						VII; typedef vector<VII> 						VVII; typedef stringstream 						ss;  #define all(v)							(v).begin(),(v).end() #define fors(i,n)						for(int i=0;i<n;i++) #define fori(i,x,n)						for(int i=x;i<n;i++) #define ford(i,x,n)						for(int i=x;i>n;i--) #define pb(x)							push_back(x) #define SZ(v)							int(v.size()) #define SORT(v)							sort(all(v)) #define gcd                                                     __gcd #define maxv(v)							*max_element(all(v)) #define minv(v)							*min_element(all(v)) #define sumv(v)							accumulate(all(v),0); #define SI 							( {int x;scanf("%d",&x);x;} ) #define sqr(a) 							(a)*(a) #define mp 							make_pair #define reset(x,y)						memset(x,y,sizeof x); #define seive(n) 					VI prime(n+1,1); prime[0]=prime[1]=0; fori(i,2,sqrt(n)+1) if(prime[i]) for(int j=i*i;j<=n;j+=i) prime[j]=0; #define pi 2*acos(0.0) #define inf 1000000000  #define eps 1e-9  int hx[]={ -2, -2, -1, -1,  1, 1 , 2, 2 };			//moves of a knight(horse) int hy[]={ -1,  1, -2,  2, -2, 2, -1, 1 };			//sorted: first on x ,then on y  int dx[]={ 1, -1, 0,  0 };					//E,W,N,S int dy[]={ 0,  0, 1, -1 };  int nx[]={ 1, -1, 0,  0, -1,  1, 1, -1 };			//N-8 neighbourhood int ny[]={ 0,  0, 1, -1,  1, -1, 1, -1 };			//E,W,N,S,N-W,S-E,N-E,S-W   class pt {     public: 	int x,y; };  typedef vector<pt> 	VP;   /*    bool comp(pt a1,pt a2)    {    if(a1.x<a2.x)    return true;    else if(a1.x>a2.x)    return false;    else    {    if(a1.y<a2.y)    return true;    return false;    }    }  */  int main() {     LL mod = 1000000080798150871ll;     VVLL ar(1010,VLL(1010,0));     fors(i,1010) 	ar[i][0]=ar[i][i]=1;     fori(i,1,1010) 	fori(j,1,1010) 	{ 	    ar[i][j]=ar[i-1][j]+ar[i-1][j-1]; 	    if(ar[i][j]>=mod) 		ar[i][j] -= mod; 	}      int t = SI;     while(t--)     { 	string str; 	int n=SI,m=SI,l=SI,k=SI; 	LL ans=0; 	VVI num(n,VI(m)); 	fors(i,n) 	{ 	    cin>>str; 	    fors(j,m) 		num[i][j]=(int)(str[j]-'0'); 	} 	int cnt; 	bool fl; 	if(l>n || k>m) 	    cout<<0<<endl; 	else 	{ 	    if(k==1) 	    { 		fors(i,m) 		{ 		    cnt=0; 		    fors(j,n) 			if(num[j][i]) 			    cnt++; 		    ans+=ar[cnt][l]; 		    if(ans>=mod) 			ans -= mod; 		} 	    } 	    else if(k==3) 	    { 		cnt = 0; 		fors(i,n) 		{ 		    fl = true; 		    fors(j,m) 			if(num[i][j]==0) 			{ 			    fl=false; 			    break; 			} 		    if(fl) 			cnt++; 		} 		ans=ar[cnt][l];; 	    } 	    else 	    { 		cnt = 0; 		fors(i,n) 		    if(num[i][0] && num[i][1]) 			cnt++; 		ans=ar[cnt][l];; 		if(m==3) 		{ 		    cnt = 0; 		    fors(i,n) 			if(num[i][0] && num[i][2]) 			    cnt++; 		    ans=ans+ar[cnt][l];; 		    if(ans>=mod) 			ans -= mod; 		    cnt = 0; 		    fors(i,n) 			if(num[i][1] && num[i][2]) 			    cnt++; 		    ans=ans+ar[cnt][l];; 		    if(ans>=mod) 			ans -= mod; 		} 	    } 	    cout<<ans<<endl; 	}     }      return 0; }    
#include<bits/stdc++.h> #define ull unsigned long long using namespace std;  ull a[9] = {2,3,5,7,11,13,17,19,23};  ull mul(ull a, ull b, ull n) { 	ull s = (ull)((long double)a*b/n)-1; 	return (a*b-s*n)%n; } ull long_pow(ull a, ull d, ull n) { 	ull res=1; 	while(d>0) { 		if (d&1) res=mul(res,a,n); 		a=mul(a,a,n); 		d>>=1; 	} 	return res; }  bool miller_rabin(ull a, ull d, ull n) { 	a=2+rand()%(n-4); 	ull x=long_pow(a,d,n); 	if(x==1 || x==n-1) return 1; 	while(d!=(n-1)) 	{ 		x=mul(x,x,n); 		if(x==1) return 0; 		if(x==n-1) return 1; 		d=mul(d,2,n); 	} 	return 0; }  bool prime(ull n) { 	if(n<=1) return 0; 	for(int i=0; i<9; i++) 	{ 		if(n==a[i]) return 1; 	} 	if(!(n&1)) return 0;  	ull d=n-1; 	while(!(d&1)) { 		d>>=1; 	} 	for(int i=0; i<9; i++) 	{ 		if(!miller_rabin(a[i],d,n)) return 0; 	} 	return 1; }  int main() { 	ios::sync_with_stdio(0); 	cin.tie(0); 	int t; 	ull n; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		if(n==2) { 			cout<<2<<endl; 			continue; 		} 		if(!(n&1)) n--; 		while(1) 		{ 			if(prime(n)) { 				cout<<n<<endl; 				break; 			} 			n-=2; 		} 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  int main() { 	// your code goes here 	 int T; 	 int i,h,l,N,H; 	long long max; 	scanf("%d",&T); 	long long arr[1000000]; 	while(T--){ 		scanf("%d%d",&N,&H); 		memset(arr,0,sizeof(long long)*N); 		for(i=0;i<N;i++){ 			scanf("%d %d",&l,&h); 			arr[l]++; 			arr[h+1]--; 		} 		for(i=1;i<N;i++){ 			arr[i]+=arr[i-1]; 		} 		for(i=1;i<N;i++){ 			arr[i]+=arr[i-1]; 		} 		max=arr[H-1]; 		for(i=1;i<=N-H;i++){ 			if(max<arr[i+H-1]-arr[i-1])max=arr[i+H-1]-arr[i-1]; 		} 		max= ((long long)N)*(long long)H-max; 		printf("%lld\n",max); 	} 	return 0; }
//mistake found on line 92 //modifying the assert statement to pinpoint which variable is behaving unexpectedly //n1 and n4 can be zero, even if n1>0 and n4<n-1; e.g. ###a#a#a#a### //forgot to put the fix for the previous observation; doing so now  #include <iostream> #include <vector> #include <cstdio> #include <cstring> #include <string> #include <cmath> #include <algorithm> #include <utility> #include <stack> #include <sstream> #include <list> #include <map> #include <queue> #include <set> #include <deque> #include <bitset> #include <functional> #include <numeric> #include <utility> #include <iomanip> #include <cmath> #include <cstdlib> #include <ctime> #include <climits> #include <cassert>  using namespace std;  #define FOR(i,a,b)				for (i=a;i<b;i++) #define s(n)					scanf("%d",&n) #define p(n)					printf("%d\n",n) #define pl(n)					printf("%lld\n",n) #define sd(n)					int n;scanf("%d",&n) #define sl(n)					scanf("%lld",&n) #define sld(n)					long long int n;scanf("%lld",&n) #define pb(n)                                   push_back(n) #define all(c)                                  (c).begin(),(c).end() #define tr(container,it)                        for (typeof(container.begin()) it=container.begin();it!=container.end();it++ ) #define sz(a)                                   int((a).size()) #define clr(a)                                  memset(a,0,sizeof(a)) #define mp(a,b)                                 make_pair(a,b)  #define INF                                     LONG_MAX #define UINF                                    ULONG_MAX #define INF_LL                                  LLONG_MAX #define UINF_LL                                 ULLONG_MAX  typedef long long ll; typedef vector <int> vi; typedef vector <vi> vvi; typedef vector <string> vstr;  int main() {     sd(T);     int t;     int i,j;     FOR(t,0,T)     {         string str;         cin>>str;         int n=sz(str);         vi hashes;         FOR(i,0,n) if (str[i]=='#') hashes.pb(i);         vvi mat(n,vi(26,0));         if (str[0]!='#') mat[0][str[0]-'a']++;         FOR(i,1,n)         {             FOR(j,0,26) mat[i][j]=mat[i-1][j];             char c=str[i];             if (c!='#') mat[i][c-'a']++;         }         int max_fw[n],max_bw[n];         FOR(i,0,n)         {             int mx=0;             FOR(j,0,26) mx=max(mx,mat[i][j]);             max_fw[i]=mx;         }         max_bw[0]=max_fw[n-1];         FOR(i,1,n)         {             int mx=0;             FOR(j,0,26) mx=max(mx,mat[n-1][j]-mat[i-1][j]);             max_bw[i]=mx;         }         int num_hashes=sz(hashes);         int ans=0;         FOR(i,0,num_hashes-2)         {             int p1=hashes[i],p2=hashes[i+1],p3=hashes[i+2];             if (p1>0&&p2>p1+1&&p3>p2+1&&p3<n-1)             {                 int n1=max_fw[p1];                 int n2=0;                 FOR(j,0,26) n2=max(n2,mat[p2][j]-mat[p1][j]);                 int n3=0;                 FOR(j,0,26) n3=max(n3,mat[p3][j]-mat[p2][j]);                 int n4=max_bw[p3];                 assert(n2>0&&n3>0);                 if (n1>0&&n4>0) ans=max(ans,n1+n2+n3+n4+3);             }         }         p(ans);     } }
#include<iostream>  using namespace std;  int main() { 	int T; 	cin>>T; 	while(T--) { 		int f = 0; 		unsigned long long int N, n; 		cin>>N; 		 		if(N == 1) { 			cout<<2<<endl; 			continue; 		}  		n = N+1; 		while(n!=1) { 			if(n%2 == 1) { 				cout<<-1<<endl; 				f = 1 ; 				break; 			} 			n = n/2; 		}  		if(f) 			continue;  		cout<<((N+1)/2)-1<<endl; 	} }
#include <bits/stdc++.h> #define ll long long int using namespace std;  int main() {     int dp[1001][1024],a[1000],n,t,i,j,k;     cin>>t;     while(t--)     {         cin>>n>>k;         for(i=0;i<n;i++)             cin>>a[i];         for(i=0;i<1024;i++)             dp[0][i]=0;         dp[0][0]=1;         for(i=1;i<=n;i++)         {             for(j=0;j<=1023;j++)             {                 dp[i][j]=dp[i-1][j]|dp[i-1][j^a[i-1]];             }         }         j=0;         for(i=0;i<=1023;i++)         {         	//cout<<dp[n][i]<<" ";             if(j<(dp[n][i]*(i^k)))                 j=dp[n][i]*(i^k);         }         cout<<j<<endl;     }     return 0; } 
    //Data Structure includes     #include<vector>     #include<stack>     #include<set>     #include<map>     #include<queue>     #include<deque>     #include<string>      //Other Includes     #include<iostream>     #include<algorithm>     #include<cstring>     #include<cassert>     #include<cstdlib>     #include<cstdio>     #include<cmath>     using namespace std;      // Output macros     #define p(n)				  printf("%d\n",n)     #define pnl					  printf("\n")      // Input macros     #define s(n)                  scanf("%d",&n)     #define sc(n)                 scanf("%c",&n)     #define sl(n)                 scanf("%lld",&n)     #define sf(n)                 scanf("%lf",&n)     #define ss(n)                 scanf("%s",n)      // Useful constants     #define INF                   (int)1e9     #define EPS                   1e-9      // Useful hardware instructions     #define bitcount              __builtin_popcount     #define gcd                   __gcd       // Useful container manipulation / traversal macros     #define forall(i,a,b)         for(int i=a;i<b;i++)     #define foreach(v, c)         for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v)     #define all(a)                a.begin(), a.end()     #define in(a,b)               ( (b).find(a) != (b).end())     #define pb                    push_back     #define fill(a,v)             memset(a, v, sizeof a)     #define sz(a)                 ((int)(a.size()))     #define mp                    make_pair       // Some common useful functions     #define checkbit(n,b)                ( (n >> b) & 1)     #define DREP(a)                      sort(all(a)); a.erase(unique(all(a)),a.end())     #define INDEX(arr,ind)               (lower_bound(all(arr),ind)-arr.begin())      typedef vector<int> VI;     typedef vector<vector<int> > VVI;     typedef long long LL;     typedef vector<long long > VLL;     typedef pair<int, int > PII;      /*Main code begins now */    	int in[100][100],T;    	bool cmprow(int r1, int r2){    		bool res = true; 		for(int j=0;j<T && res;j++) 			if( in[r1][j] != in[r2][j] ) 				res = false;    		return res;    	}    	bool compare(int row){    		bool res = true; 		for(int i=0;i<T && res;i++){ 			res = cmprow(row,i); 			if( (!res && !in[row][i]) || (res && in[row][i]) ) 				res = true; 			else 				res = false; 		} 		return res;    	}      void solve(){ 		s(T);     	string s;     	forall(i,0,T)     		forall(j,0,T){ 				cin>>s; 				if(s=="NO") 					in[i][j] = 0; 				else  					in[i][j] = 1;    		     		}     	int outrow=0;     	bool found = false;     	for(int i=0;i<T;i++){ 			if(in[i][i]){ 				found = compare(i); 				if(found==true){ 					outrow = i; 					break; 				} 			}     	}     	if(found){ 			for(int i=0;i<T;i++){ 				if(in[outrow][i])	 					printf("YES\n"); 				else 					printf("NO\n"); 			} 		} 		else 			for(int i=0;i<T;i++) 				printf("NO\n");     }     int main(){           solve();               return 0;     }
