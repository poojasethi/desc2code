t = int(raw_input())

while t > 0:
    x = raw_input()
    y = raw_input()
    z = ''
    for i in range(len(x)):
        if x[i] == y[i] == 'B':
            z += 'W'
        elif x[i] == y[i] == 'W':
            z += 'B'
        else:
            z += 'B'
    print z
    t -= 1

test_cases = input()
for test_case in range(test_cases):
    n = input()
    ints = map(int, raw_input().split())
    final_counter = ''
    arr = [1]*n
    for i in range(n - 2, -1, -1):
        curr = ints[i]
        next = ints[i+1]
        if (curr > 0 and next > 0) or (curr < 0 and next < 0):
            continue
        else:
            arr[i] = arr[i]+arr[i+1]
    print ' '.join(str(a) for a in arr)
#Mahasena
#https://www.codechef.com/problems/AMR15A

input()
n=map(int,raw_input().split())
even=0
odd=0
for i in n:
	if i%2==0:
		even+=1
	else:
		odd+=1
if even>odd:
	print "READY FOR BATTLE"
else:
	print "NOT READY"

t = input()
for i in range(t):
    A = raw_input()
    balance = 0
    max_balance = 0
    for j in A:
        if j == '(':
            balance = balance+1
        else:
            balance = balance-1
        max_balance = max(max_balance,balance)
    k = 0
    B = ''
    while k <max_balance:
        B +='('
        k+=1
    l = -(max_balance)
    while l < 0:
        B +=')'
        l+=1
    
    print B
t = input()
for i in range(t):
    N = input()
    n = map(int,raw_input().split())
    j = 0
    count = 0
    while(j<N):
        k=0
        while(j+k<N):
            #print n[k:j+k+1]
            sum = 0
            product = 1
            for a in n[k:j+k+1]:
                sum += a
                product *= a
            k+=1
            if(sum == product):
                count+=1
        j+=1
    print count
#Chef and his Sequence 
#https://www.codechef.com/problems/CHEFSQ

t=input()
while t!=0:
	t-=1
	input()
	n=map(int,raw_input().split())
	input()
	f= map(int, raw_input().split())
	flag=0
	for i in f:
		if i in n:
			flag+=1
	if flag==len(f):
		print "Yes"
	else:
		print "No"

from itertools import izip
t = input()
for i in range(t):
    s1 = raw_input()
    s2 = raw_input()
    min = 0
    max = 0
    for j,k in izip(s1,s2):
        if(j != '?' and k != '?'):
            if(j==k):
                min+=0
                max+=0
            else:
                min+=1
                max+=1
        elif(j == '?' and k != '?'):
            min+=0
            max+=1
        elif(j != '?' and k == '?'):
            min+=0
            max+=1
        elif(j == '?' and k == '?'):
            min+=0
            max+=1
    print min,max
#include <stdio.h>
int returnMax (int a, int b){
	if (a>=b) return a;
		else return b;
}
int main()
{
	int t;
	int p[100];
	char c;
	scanf("%d\n",&t);
	while (t--)
	{
		p['a']=0; p['b']=0;
		while ((c=getchar())!='\n') p[c]++;
		printf("%d\n", p['a']+p['b']-returnMax(p['a'],p['b']));
	}
	return (0);
}  
#Chef And Operators 
#https://www.codechef.com/problems/CHOPRT
t=input()
while t!=0:
	t-=1
	a,b=map(int,raw_input().split())
	if a<b:
		print "<"
		continue
	if a==b:
		print '='
		continue
	else:
		print '>'

chef=raw_input()
c,h,e,f=0,0,0,0
for i in chef:
    if i=='C':
        c+=1
    elif i=='H':
        if h<c:
            h+=1
    elif i=='E':
        if e<h:
            e+=1
    elif i=='F':
        if f<e:
            f+=1
print f

import heapq
from math import log
mod=10**9+7
n,k=map(int,raw_input().split())
li=list(map(int,raw_input().split()))
dp=[0]*n
dp[0]=li[0]
heap=[]
heapq.heappush(heap,(log(dp[0]),0))
for i in xrange(1,k):
    dp[i]=(dp[0]*li[i])%mod
    heapq.heappush(heap,(log(dp[0])+log(li[i]),i))
for i in xrange(k,n):
    while heap[0][1]<i-k:
        heapq.heappop(heap)
    dp[i]=(dp[heap[0][1]]*li[i])%mod
    heapq.heappush(heap,(heap[0][0]+log(li[i]),i))
print dp[n-1]%mod
 
# Codechef Beginner Problem CIELRCPT

t = int(raw_input())

while t>0:
    p = int(raw_input())
    count = 0
    c = 0

    while (p-2048) > 0:
        p = p - 2048
        c = c + 1

    binary = bin(2048)[2:]
    count = count + (binary.count('1') * c);

    binary = bin(p)[2:]
    count = count + binary.count('1')

    t = t -1
    print count
for i in range(int(raw_input())):
    n=int(raw_input())
    s=raw_input()
    r=n-s.count('R')
    g=n-s.count('G')
    b=n-s.count('B')
    print min(r,g,b)
#CODECHEF PROBLEM: COMM3
#AUTHOR: diksham1

t = int(raw_input())
while(t>0):
	range = int(raw_input())
	x1,y1 = map(float, raw_input().split())
	x2,y2 = map(float, raw_input().split())
	x3,y3 = map(float, raw_input().split())
	ctr = 0;
	if ((y2-y1)**2 + (x2-x1)**2)**0.5 <=range:
		ctr += 1;
	if ((y3-y1)**2 + (x3-x1)**2)**0.5 <=range:
		ctr += 1;
	if ((y2-y3)**2 + (x2-x3)**2)**0.5 <=range:
		ctr += 1;	
	if	ctr >=2:
		print "yes"
	else:
		print "no"
	t -= 1


t = input()
for i in range(t):
    a,b = map(int,raw_input().split())
    operation = 0
    while(a&(a-1)):
        a = a >> 1
        operation+=1
    while(a<b):
        a = a << 1
        operation+=1
    while(a>b):
        a = a >> 1
        operation+=1
    print operation
t = input()
for i in range(t):
    houses = []
    for j in range(101):
        houses.append(0)
    M,x,y = map(int,raw_input().split())
    p = map(int,raw_input().split())
    for k in p:
        houses_coverd = x*y
        min_value = max(k-houses_coverd,1)
        max_value = min(k+houses_coverd,100)
        l = min_value
        while(l<=max_value):
            houses[l]=1
            l +=1
            if(houses.count(0)-1 == 0):
                break;
    print houses.count(0)-1    
t = input()
for i in range(t):
    N,k = map(int,raw_input().split())
    n = map(int,raw_input().split())
    operation = 0
    for i in n:
        quotient = i/k
        remainder = i%k
        next_value = k*(quotient+1)-i
        if(quotient > 0):
            min_value = min(next_value,remainder)
        else:
            min_value = next_value
        operation += min_value
    
    print operation
t=input()
while(t>0):
	n,k,e,m=map(int,raw_input().split())
	s=[]
	i=0
	while(i<n-1):
		a=map(int,raw_input().split())
		s.append(sum(a))
		i+=1
	a=map(int,raw_input().split())
	a=sum(a)
	#print "s"
	s.append(a);i=0;e=0
	while(i<n-1):
		if(s[i]>=a):e+=1
		i+=1
	#print s
	s=sorted(s,reverse=True)
	#print s
	#print "e"
	#print e
	if(e<=k-1):
		print 0
	else:
		#print "diff"
		diff=s[k-1]-a
		#print diff
		if(diff>=m):
			print "Impossible"
		else:
			print diff+1
	t-=1
t = input()
for _ in xrange(t):
    n = input()
    count = 0
    while n > 1:
        n = n/5
        count += n
    print count
def factorial(num):
	if num == 0:
		return 1
	else:
		tempvar = 1
		while num > 1:
			tempvar = tempvar * num
			num = num - 1
		return tempvar
list = []
testcases = int(raw_input())
for cases in range(testcases):
		caseinput = int(raw_input())
		list.append(caseinput)
		
for item in list:
	print factorial(item)
t=input()

while(t>0):
    a,b=map(int, raw_input().split())
    k=a+b
    print k
    t-=1

for x in xrange(int(raw_input())):
	input = raw_input().split()
	print int(input[0]) % int(input[1])
for i in range(input()):
	num_arr  =  map(int,list(raw_input()))
	print num_arr[0]+num_arr[-1]

t=int(raw_input())
for i in range(t):
	n=int(raw_input())
	number_notes=0
	number_notes=number_notes+n/100
	n=n%100
	number_notes=number_notes+n/50
	n=n%50
	number_notes=number_notes+n/10
	n=n%10
	number_notes=number_notes+n/5
	n=n%5
	number_notes=number_notes+n/2
	n=n%2
	number_notes=number_notes+n/1

	print number_notes
t = int(raw_input())
for i in xrange(t):
	n = int(raw_input())
	sum=0
	while(n>0):
		temp = n%10
		n=n/10
		sum+=temp
	print sum
for testcases in xrange(int(raw_input())):
	print int(raw_input()[::-1])

for x in range(0,input()):
	number = input()
	if number < 10 :
		print("What an obedient servant you are!")
	else:
		print("-1") 
#Total Expenses 
#https://www.codechef.com/problems/FLOW009

t=input()
while t!=0:
	t-=1
	q, p =map(int,raw_input().split())
	if q>1000:
		q=q-(0.1*q)
		print "%.6f"%(q*p)
	else:
		print "%.6f"%(q*p)

t = input()
for i in range(t):
    n = raw_input()
    if (n == 'B' or n == 'b'):
        print "BattleShip"
    elif (n == 'c' or n == 'C'):
        print "Cruiser"
    elif (n == 'D' or n == 'd'):
        print "Destroyer"
    elif (n == 'F' or n == 'f'):
        print "Frigate"
    
t = input()
for i in range(t):
    sal = input()
    gross = 0
    if(sal<1500):
        gross = 2*sal
    else:
        gross = 1.98*sal+500
    
    print "{0:g}".format(gross)
a = input()
for x in range(a):
    test = raw_input().split()
    if int(test[0]) + int(test[1]) + int(test[2]) == 180:
        print 'YES'
    else:
        print 'NO'
#Grade The Steel 
#https://www.codechef.com/problems/FLOW014
#!/usr/bin/env/ python


t=input()
while t!=0:
	t-=1
	h, cc, ts= map(float,raw_input().split())
	cond1 = (h>50)
	cond2 = (cc<0.7)
	cond3 = (ts>5600)
	if cond1 and cond2 and cond3:
		print 10
		continue
	if cond1 and cond2:
		print 9
		continue
	if cond2 and cond3:
		print 8
		continue
	if cond1 and cond3:
		print 7
		continue
	if cond1 or cond2 or cond3:
		print 6
		continue
	if not cond1 and not cond2 and not cond3:
		print 5

#https://www.codechef.com/problems/FLOW015
#Gregorian Calendar 
day={0:'saturday',1:'sunday',2:'monday',3:'tuesday',4:'wednesday',5:'thursday',6:'friday'}
t=input()
while t!=0:
	t-=1
	y = input()-1
	n = (1)+(2*13)+(3*(13+1)/5)+y+(y/4)-(y/100)+(y/400)+2
	n=n%7
	print day[n]

t=int(raw_input())
a=b=c=max1=max2=0
while(t>0):
	a,b,c=map(int,raw_input().split())
	max1=max(a,b,c)
	if max1==a:
		max2=max(b,c)
	if max1==b:
		max2=max(a,c)
	if max1==c:
		max2=max(a,b)	 		
	print max2
	max1=max2=a=b=c=0
	t=t-1
def f(n):
 if n<=1:
  return 1
 else:
  return n*f(n-1)
 
t=input()
while t:
 t-=1
 n=input()
 print f(n)
#https://www.codechef.com/problems/FRGTNLNG
#Forgotten Language


t=input()
while t!=0:
	t-=1
	fg, md = map(int,raw_input().split())
	fo_lg = raw_input().split()
	mo_lg=[]
	for _ in range(md):
		x = raw_input().split()[1:]
		for i in x:
			mo_lg.append(i)
#	print fo_lg
#	print mo_lg
	for i in fo_lg:
		if i in mo_lg:
			print "YES",
		else:
			print "NO",
	print '\n'

t = input()
for i in range(t):
    apple,orange,gold_coin = map(int,raw_input().split())
    max_value = 0
    min_value = 0
    if(apple>=orange):
        max_value = apple
        min_value = orange
    else:
        max_value = orange
        min_value = apple
        
    difference = max_value-min_value
    added_difference = difference
    gd = gold_coin
    
    while(added_difference <= difference and added_difference>=0 and gd > 0):
        if(added_difference == 0):
            break
        else:
            gd -=1
            min_value+=1
            difference = added_difference
            added_difference = max_value - min_value
    
    print added_difference
import math
t=int(raw_input())
while(t>0):
	num=int(raw_input())
	sq=math.sqrt(num)
	print int(sq)
	t=t-1
#Greedy puppy 
#https://www.codechef.com/problems/GDOG
#!/usr/bin/env python

def greedy(n,k):
	l=[]
	for i in range(1,k+1):
		per_person = n/i
		total_spent = per_person*i
		l.append(n-total_spent)
	print max(l)

t= input()
while t!=0:
	t-=1
	n,k=(map(int,raw_input().split()))
	greedy(n,k)

#https://www.codechef.com/problems/HEADBOB
#Tanu and Head-bob 
#!/usr/bin/env python

def headbob(s):
	x=set(s)
	if len(x)==1:
		if 'N' in x:
			print "NOT SURE"
		elif 'I' in x:
			print "INDIAN"
		elif 'Y' in x:
			print "NOT INDIAN"
	else:
		if not 'Y' in x and not 'I' in x:
			print "NOT SURE"
		if 'I' in x:
			print 'INDIAN'
		if not 'I' in x and 'Y' in x and 'N' in x:
			print 'NOT INDIAN'

t=input()
while t!=0:
	t-=1
	input()
	headbob(raw_input())

d, a = map(float, raw_input().split())
c = d % 5 
if (d < a and a > (d+0.50)):
    if c == 0 :
        rem = a - (d+0.50)
        print "%.2f" %(rem)
    else:
        print "%.2f" %(a)


else:
    print "%.2f" %(a)
l = map(int,raw_input().split(' '))
n = l[0]
k = l[1]
ctr = 0
while n!=0:
  ent = int(raw_input())
  if ent%k==0:
    ctr+=1
  n-=1	

print ctr  
  
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# para todos os test cases...
for li_T in xrange(int(raw_input())):

    # N
    li_N = int(raw_input())
                        
    # Ao...An
    lst_A = map(int, raw_input().split())

    # Bo...Bn
    lst_B = map(int, raw_input().split())

    # inicia total
    l_tot = 0

    # primeito caso
    if lst_A[0] >= lst_B[0]:
        # incrementa total
        l_tot += 1

    # para todos os casos seguintes...
    for l_ndx in xrange(li_N):
        # vai dar tempo de cozinhar ?
        if (lst_A[l_ndx] - lst_A[l_ndx - 1]) >= lst_B[l_ndx]:
            # incrementa total
            l_tot += 1

    # resultado
    print l_tot

for t in xrange(int(raw_input())):
	activities, nationality = raw_input().split()
	laddu = 0
	for i in range(int(activities)):
		activity = raw_input()
		if (activity.startswith("CONTEST_WON")):
			laddu += 300
			rank = int(activity.split()[1])
			if (rank <= 20):
				bonus = 20 - rank
				laddu += bonus
		elif (activity.startswith("TOP_CONTRIBUTOR")):
			laddu += 300
		elif (activity.startswith("BUG_FOUND")):
			severity = int(activity.split()[1])
			laddu += severity
		elif (activity.startswith("CONTEST_HOSTED")):
			laddu += 50
	if (nationality == "INDIAN"):
		answer =  laddu/200
	else:
		answer =  laddu/400
	print answer
			


n = int(raw_input())

for i in range(n):
    Dic = {}
    for j in raw_input():
        if j not in Dic.keys():
            Dic[j] = 1
        else:
            Dic[j] += 1
            
    lst = sorted(Dic.values(), reverse = True)
    if lst[0] == sum(lst[1:]):
        print "YES"
    else:
        print "NO"
import numpy as np
T=int(raw_input())
for i in xrange(T,0,-1):
	N,M=[int(x) for x in raw_input().split()]
	A=np.zeros((N,M))
	ans=np.zeros(M)
	for nl in xrange(0,N,1):
		temp=raw_input()
		cnt=0
		for tc in list(temp):
			A[nl][cnt]=int(tc)
			cnt+=1
	sumcnt=0		
	for ml in xrange(0,M,1):
	    for nlo in xrange(0,N-1,1):
	        for nll in xrange(nlo+1,N,1):
	           sumcnt+= A[nlo,ml] and A[nll,ml]
	    ans[ml]=sumcnt
	    sumcnt=0
	final=ans.sum(dtype=np.int32)
	print final
t = input() #Taking the number of test cases as input
#print t

while t > 0:

    num = raw_input() #Taking each number as input
    #print num

    count = 0

    for i in num:
        if i == "4":
            count += 1

    print count

    t -= 1

#Chef and Dolls 
#https://www.codechef.com/problems/MISSP

t=input()
while t!=0:
	t-=1
	ti=[]
	for _ in xrange(input()):
		ti.append(input())
	tis=list(set(ti))
#	print ti,tis
	for i in tis:
		if ti.count(i)%2!=0:
			print i
			break

for t in range(int(raw_input())):
	n=int(raw_input())
	a=map(int,raw_input().split())
	print (n-1)*min(a)
#!/usr/bin/env python
from sys import exit

def findMax(l, r):
	chosenOne = {
		'l': l[0],
		'r': r[0],
		'x': l[0]*r[0],
		'i': 1
	};
	for i in range(len(l) - 1):
		if (chosenOne['x'] < l[i]*r[i]) or (chosenOne['x'] == l[i]*r[i] and chosenOne['r'] < r[i]):
			chosenOne['l'] = l[i];
			chosenOne['r'] = r[i];
			chosenOne['x'] = l[i]*r[i];
			chosenOne['i'] = i+1;

	print chosenOne['i'];


def main():
	t = int(raw_input());
	executed = 0;	
	while(t > executed):
		n = int(raw_input());
		lArr = map(int, str(raw_input()).split(" "));
		rArr = map(int, str(raw_input()).split(" "));
		findMax(lArr, rArr);
		executed = executed + 1;

if __name__ == '__main__':
	main()
	exit
# cook your code here
test_cases = input()
for test_case in range(test_cases):
    m = input()
    mat = []
    counter = 0
    for i in range(m):
        o = map(int, raw_input().split())
        mat.append(o)
    dic = {}
    for i in range(m):
        for j in range(m):
            dic[mat[i][j]] = (i,j)
    x,y = dic[1]
    for i in range(2,(m**2)+1):
        a,b = dic[i]
        counter += abs(a-x) + abs(b-y)
        x,y = a,b
    print(counter)
from math import floor
t = input()
for i in range(t):
    n = input()
    print int(floor(n/2))+1
t = int(raw_input())

while t:
	n, m = map(int, (raw_input().split()))
	print n*(m-1) + m*(n-1)
	t = t-1

t = input()
for _ in xrange(t):
    expr = raw_input()
    stack = []
    out_expr = ""
    for c in expr:
        if c == ')':
            out_expr += stack.pop()
        elif c == '(':
            pass
        elif c.isalpha():
            out_expr += c
        else:
            stack.append(c)
    print out_expr 
#https://www.codechef.com/problems/PALL01
#The Block Game 
#!/usr/bin/env python

def cl(s):
	flag=0
	if len(s)%2==0:
		pass
	if len(s)%2!=0:
		s=list(s)
		del s[len(s)/2]
		''.join(s)

	pall(s, flag)

def pall(s, flag):
	for i in range(len(s)):
		if s[i]!=s[len(s)-(i+1)]:
			flag+=1
			break
	if flag>0:
		print 'losses'
	else:
		print 'wins'

t=input()
while t!=0:
	t-=1
	cl(raw_input())

import operator
while True:
    n = input()
    if(n == 0):
        break
    else:
        if (1<=n) and (n<=100000):
            str_permut = raw_input().split(' ');
            dict = {}
            for i in range(1,len(str_permut)+1):
                dict[i] = int(str_permut[i-1])
            sorted_x = sorted(dict.items(), key=operator.itemgetter(1))
            dict_values = dict.values()
            sorted_keys = []
            for w in sorted_x:
                sorted_keys.append(w[0])
            if(cmp(dict_values,sorted_keys) == 0):
                print "ambiguous"
            else:
                print "not ambiguous"
                
            
import sys
def prime_numbers(limit=10**6):
    '''Prime number generator. Yields the series
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...
    using Sieve of Eratosthenes.
    '''
    yield 2
    sub_limit = int(limit**0.5)
    flags = [True, True] + [False] * (limit - 2)
    # Step through all the odd numbers
    for i in range(3, limit, 2):
        if flags[i]:
            continue
        yield i
        # Exclude further multiples of the current prime number
        if i <= sub_limit:
            for j in range(i*i, limit, i<<1):
                flags[j] = True

p=list(prime_numbers())

for i in range(int(raw_input())):
    r=int(raw_input())
    if r in p:
        print 'yes'
    else:
        print 'no'

#https://www.codechef.com/problems/RECIPE
#Cutting Recipes 

from fractions import gcd
t=input()
while t!=0:
	n= map(int, raw_input().split())[1:]
	t-=1
	x=reduce(gcd, n)
	for i in n:
		print i/x,

from fractions import gcd
t = input()
for i in range(t):
    l,b = map(int,raw_input().split())
    gcd_value = gcd(l,b)
    lcm = int(l/gcd_value)*int(b/gcd_value)
    print lcm
#Chef and Remissness 
#https://www.codechef.com/problems/REMISS
t=input()
while t!=0:
	t-=1
	a,b =map(int,raw_input().split())
	print max(a,b), a+b

# cook your code here

M = 1000000007
S = 0
B = 0
P = 1

T = int(raw_input())
for i in range(T):
    n = int(raw_input()) + 1
    if n <= 1:
        print 0
        continue
    L = [int(x) for x in raw_input().split()]
    S = 0
    B = 2 * L[0] % M
    P = 2
    for j in xrange(1, n):
        a = L[j]
        S *= 2
        S %= M
        S += a * B
        S %= M
        B += P * a
        B %= M
        P *= 2
        P %= M
    print S
tc = int(raw_input())
while tc > 0:
	tc = tc - 1
	n = int(raw_input())
	for i in xrange(n):
		a, b = map(int, raw_input().split())
	ans = 0
	for i in xrange(1,n+1):
		ans = ans ^ i
	print ans

def splitter():
    N=0
    K=1
    while N<(2*K):
        x=raw_input()
        l=x.split(" ")
        for i in range(2):
            l[i]=int(l[i])
        if l[0]<=10000 and l[0]>=1:
            N=l[0]
        K=l[1]
    return N,K
def lister():
    global N
    l=[]
    while len(l)!=N:
        x=raw_input()
        l=x.split(" ")
        for i in range(N):
            l[i]=int(l[i])
    return l
T=input()
while T>0:
    N,K=splitter()
    l=lister()
    f=[]
    L=[]
    l.sort()
    while len(f)<K:
        f.append(l.pop(0))
    while len(L)<K:
        L.append(l.pop(-1))
    avg=0
    for i in l:
        avg+=i
    avg/=((N-2*K)*1.0)
    avg=str(avg)
    p=0
    l=len(avg)
    for i in range(l):
        if avg[i]==".":
            p=i
    if p==0:
        avg=avg+".000000"
    else:
        if -p-1>6:
            while l-p!=6:
                avg=avg[0,l-p]
        if l-p-1<6:
            for i in range(6-(l-p-1)):
                avg+="0"
    print avg
    T-=1
t=input()
while t:
	t-=1
	n=input()
	a = map(int,raw_input().split())
	a.sort()
	print a[0]+a[1]
#https://www.codechef.com/problems/SNAPE
#Snape and Ladder 
from math import sqrt as sq
t=input()
while t!=0:
	t-=1
	b, ls =map(int,raw_input().split())
	print sq((ls**2)-(b**2)), sq((b**2)+(ls**2))

t = input()
while(t>0):
    t -= 1
    l,r = map(int,raw_input().split())
    sum = 0
    for i in range(l,r+1):
        str_i = str(i)
        if str_i == str_i[::-1]:
            sum+=i
    print sum
print int(raw_input())
for t in xrange(int(raw_input())):
    n = int(raw_input())
    a = sorted(map(int, raw_input().split()), reverse = True)
    c = 0
    l = []
    i = 0
    while (i < n-1):
        if (a[i] == a[i+1]):
            l.append(a[i])
            c+=1
            i+=2
            if (c==2):
                break
        else:
            i+=1
    if (c==2):
        print l[0]*l[1]
    else:
        print -1

test_cases = input()
for test_case in range(test_cases):
    m = map(list, raw_input())
    n = map(list, raw_input())
    isBreak = False
    for i in m:
        if i in n:
            print('Yes')
            isBreak = True
            break
    if isBreak is False:
        print('No')
    
from sys import stdin,stdout
t = int(stdin.readline().strip())
for _ in xrange(t):
	n = int(stdin.readline().strip())
	b = [1]*n
	a = map(int,stdin.readline().strip().split(' '))
	for i in xrange(1,n):
		if a[i-1] <= a[i]:
			b[i] = b[i-1]+1
	stdout.write(str(sum(b))+"\n")
for _ in range(int(raw_input())):
    n=int(raw_input())
    lst=[map(int,raw_input().split()) for i in range(n)]
    for i in range(n-2,-1,-1):
        for j in range(i+1):
            lst[i][j]+=max(lst[i+1][j+1],lst[i+1][j])
    print lst[0][0]
        
t = int(raw_input())
lead=[]
leader=[]
player1 = 0
player2 = 0
while t:
    num = raw_input().split()
    player1 += int(num[0])
    player2 += int(num[1])
    
    leader.append(1 if(player1>player2) else 2)
    lead.append(abs(player1-player2))
    t -= 1
max_lead = max(lead)
winner = leader[lead.index(max_lead)]
print winner,max_lead
# cook your code here
#O(n)
from math import sqrt
def isint(d):
    try:
        d=int(d)
        return True
    except ValueError:
        return False
t=int(raw_input())
for i in range(t):
    x=int(raw_input())
    n=(sqrt(8*x+1)-1)//2
    print int(n)
t=int(raw_input())
lst=list()
for item in range(t):
    num=int(raw_input())
    lst.append(num)
lst.sort()
for item in lst:
    print item
a = input()
for x in range(a):
    str1 = raw_input()
    str2 = raw_input()
    flag = 0
    if len(str1) == len(str2):
        for y in range(len(str1)):
            if str1[y] != '?' and str2[y] !='?':
                if str1[y] != str2[y]:
                    flag += 1
                    break
    if flag == 0:
        print 'Yes'
    else:
        print 'No'

import math
T= int(raw_input()) # number of cases
 
for i in range(T):
    N=str(raw_input()).split(" ")[0]
    U=set(range(1,int(N)+1))
    A=set(map(int,str(raw_input()).split(" ")))
    B=set(map(int,str(raw_input()).split(" ")))
    print str(len(A&B))+" "+ str(len(U-(A|B)))

# cook your code here
test_count = input()
for test in range(test_count):
    n = input()
    l1 = list(raw_input())
    l2 = list(raw_input())
    l3 = map(int, raw_input().split())
    k = 0
    max = l3[0]
    for i in range(n):
        if l1[i] == l2[i]:
            k+=1
            if max < l3[k]:
                max = l3[k]
    if k==n:
        print(l3[n])
    else:
        print(max)
#include<stdio.h>
int min(int a,int b)
{
	return (a < b ? a : b);
}
int main()
{
	int n,i,j,k,max_fuel,current_fuel,limit,t,l,input[65];
	scanf("%d",&n);
	while(n--)
	{
		for(i = 1;i <= 64;i++)
			scanf("%d",&input[i]);
		i = 1;
		max_fuel = input[1];
		while(1)
		{
			printf("%d ",i);
			current_fuel = max_fuel;
			max_fuel = -1;
			if(i+current_fuel >= 64)
				break;
			limit = i+current_fuel;
			for(j = i+1;j <= limit;j++)
			{
				t = current_fuel + i + input[j] - j;
				if(t <= 5 && t - i + 5 + j >= max_fuel)
				{
					max_fuel = t - limit + j;
					l = t;
					k = j;
				}
			}
			i = k;
			max_fuel = l;
		}
		printf("64\n");
	}
	return 0;
}
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct _elem{
	
	char c;
	int val;
}elem;
 
elem A[200];
char str[200];
 
int comp(void *e1, void *e2){
	
	elem *a1 = (elem *)e1;
	elem *a2 = (elem *)e2;
 
	if(a1->val==a2->val) return 1;
 
	else return a1->val - a2->val;
 
}
 
int main(){
	
	int cases;
 
	scanf("%d", &cases);
 
	int i;
 
	for(i=0;i<cases;i++){
		
		scanf("%s", str);
 
		int j=0, ind=0;
		int score=0;
		for(j=0;j<strlen(str);j++){
			if(str[j]>='0' && str[j]<='9'){
				if(ind>0){
					A[ind-1].val -= score;
				}
				A[ind].c = str[j];
				A[ind].val = score;
				score=0;
				ind++;
			}
			else{
				switch(str[j]){
					case 'Z':
						score+=1;
						break;
					case 'Q':
						score+=3;
						break;
					case 'E':
						score+=5;
						break;
					case 'T':
						score+=7;
						break;
					case 'U':
						score+=9;
				}
			}
		}
 
		A[ind-1].val -=score;
		qsort(A, ind, sizeof(elem), comp);
		for(j=0;j<ind;j++)
			printf("%c",A[j].c);
		printf("\n");
	}
	return 0;
}
 
#include<stdio.h>

int main()
{
	int n,nx;
	int grid[8][8];
	int max;
	int ship[64];
	int count;
	int i,j,k,l;
	
	scanf("%d",&n);
	for(;n>0;n--)
	{
		for(max=0;max<8;max++)
			for(count=0;count<8;count++)
				grid[max][count]=0;
		for(l=0;l<8;l++)
		{
		scanf("%d",&nx);
		i=7-((nx-1)/8);
		if(i%2)
			j=(nx-1)%8;
		else
			j=7-((nx-1)%8);
		
		grid[i][j]=-1;
		for(k=1;k<=7;k++)
		{
			if(i-k>=0)
			{
				if(grid[i-k][j]!=-1)
					grid[i-k][j]+=(16-2*k);
			}
			if(i+k<=7)
			{
				if(grid[i+k][j]!=-1)
					grid[i+k][j]+=(16-2*k);
			}
			if(j-k>=0)
			{
				if(grid[i][j-k]!=-1)
					grid[i][j-k]+=(16-2*k);
			}
			if(j+k<=7)
			{
				if(grid[i][j+k]!=-1)
					grid[i][j+k]+=(16-2*k);
			}
			if(i-k>=0&&j-k>=0)
			{
				if(grid[i-k][j-k]!=-1)
					grid[i-k][j-k]+=(8-k);
			}
			if(i+k<=7&&j-k>=0)
			{
				if(grid[i+k][j-k]!=-1)
					grid[i+k][j-k]+=(8-k);
			}
			if(i+k<=7&&j+k<=7)
			{
				if(grid[i+k][j+k]!=-1)
					grid[i+k][j+k]+=(8-k);
			}
			if(i-k>=0&&j+k<=7)
			{
				if(grid[i-k][j+k]!=-1)
					grid[i-k][j+k]+=(8-k);
			}
		}
		}
		count=0;
		max=0;
		for(i=0;i<8;i++)
		{
			for(j=0;j<8;j++)
			{
				if(grid[i][j]>max)
				{
					count=1;
					max=grid[i][j];
					if(i%2)
						ship[0]=8*(7-i)+j+1;
					else
						ship[0]=8*(7-i)+(7-j)+1;
				}
				else if(grid[i][j]==max)
				{
					if(i%2)
						ship[count++]=8*(7-i)+j+1;
					else
						ship[count++]=8*(7-i)+(7-j)+1;
				}
			}
		}
		for(i=1;i<count;i++)
		{
			for(j=i-1;j>=0;j--)
			{
				if(ship[j+1]<ship[j])
				{
					ship[j]+=ship[j+1];
					ship[j+1]=ship[j]-ship[j+1];
					ship[j]-=ship[j+1];
				}
				else 
					break;
			}
		}
		printf("%d",ship[0]);
		for(i=1;i<count;i++)
			printf(" %d",ship[i]);
		printf("\n");		
	}
	return 0;
}


def isprime(n):
  if n == 2 or n == 3: return 0
  if n < 2 or n%2 == 0: return 1
  if n < 9: return 0
  if n%3 == 0: return 1
  r = int(n**0.5)
  f = 5
  while f <= r:
    if n%f == 0: return 1
    if n%(f+2) == 0: return 1
    f +=6
  return 0
    
def main():
    t=raw_input()
    for j in xrange(int(t)):
        b,c=map(long,raw_input().split())
        k=c
        while k<=c and k>=b:
        #for k in range(c,b-1,-1):
            if k<=3:
                print -1
                break
            if k%2==0:
                print k
                break
            if isprime(k)==1:
                print k
                break
            k=k-1
        else:
            print -1
            
if __name__ == '__main__':
    main()
#include<stdio.h>
#define MOD 1000000007
long long int dp[501][501];
void ini()
{
    int i,j;
    for(i=0;i<=500;++i)
    {
        for(j=0;j<=500;++j)
        {
            dp[i][j]=0LL;
        }
    }
    //dp[i][j] means total number of ways to buy j cakes until i days
    dp[0][0]=1LL;

    /*base case*/

    for(j=0;j<=500;++j)
        dp[1][j]=1LL;

    for(i=2;i<=500;++i)
    {
        dp[i][1]=dp[i][i]=1LL;
        for(j=i+1;j<=500;++j)
        {
            dp[i][j]=dp[i][j-1]+dp[i-1][j-1];
            dp[i][j]%=MOD;
        }
    }
    /*
    for(i=0;i<=3;++i)
    {
        for(j=0;j<=4;++j)
        {
            printf("%lld ",dp[i][j]);
        }
        printf("\n");
    }*/
}
int main(void)
{
    ini();
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int n,l,h;
        scanf("%d %d %d",&n,&l,&h);
        int i;
        long long int ans=0LL;
        for(i=l;i<=h;++i)
            ans+=dp[i][n]%MOD;
        printf("%lld\n",ans%MOD);
    }
    return 0;
}

def toBin(n):
	binary = []
	while n!=0:
		bit = str(n%2)
		binary.append(bit)
		n = n/2
	binary.reverse()
	return binary


def main():
	tc = int(raw_input())
	while tc>0:
		n = int(raw_input())
		binary = toBin(n)
                """for x in xrange(0,32-len(binary)):
                        binary.append(0)"""
		lenx=len(binary)
		for x in xrange(0,len(binary)):
			if lenx%2!=0 and x%2!=0:
				binary[x]='0'
			if lenx%2==0 and x%2==0:
				binary[x]='0'
		str = ''.join(binary)
		print int(str,2)
		tc=tc-1

if __name__ == '__main__':
	main()

for _ in range(input()):
	n=input()
	r,c=[0]*100,[0]*100
	for i in range(n):
		x,y=map(int,raw_input().split())
		r[x]+=1
		c[y]+=1
	max_x,max_y=0,0
	for i in range(100):
		if r[i]:
			max_x+=1
		if c[i]:
			max_y+=1
	#print max_x,max_y		
	print min(max_x,max_y)		
			
t=int(raw_input())
for i in range(t):
    n,m,p,q,r=map(int,raw_input().split())
    if (n+m+p+q)<=r:
        print "YES"
    else:
        print "NO"
import sys

for __ in range(input()) :
    s = map(ord,raw_input())
    mark = [0]*150
    for i in s :
        mark[i] += 1
    frnt , bck = 0 , 0
    for i in s :
        if mark[i] == 1 :
            frnt = i
            break
    for i in reversed(s) :
        if mark[i] == 1 :
            bck = i
            break
    if frnt == 0 or bck == 0 :
        print "PANDEY"
    else :
        if frnt > bck :
            print "SHANKY"
        else :
            if frnt==bck :
                print "PANDEY"
            else :
                print "ANKU"

t = input()
for x in range(t):
     a = input()
     print abs(a)
# your code goes here
from sys import stdin, stdout
t = int(stdin.readline())
while t:
	t -= 1
	n = int(stdin.readline())
	a = map(int, stdin.readline().strip().split(' '))
	if n <= 2:
		stdout.write(str(n)+"\n")
	else:
		m = 2
		c = 2
		i = 2
		while i < n:
			if a[i] != a[i-1] + a[i-2]:
				m = max(c, m)
				c = 2
			else:
				c += 1
			i += 1
		m = max(c, m)
		stdout.write(str(m)+'\n')
#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
int main() {
	big l,t,n,i,j,k,temp,c,count;
	vb v;
	cin>>t;
	while(t-->0)
    {
        count=0;
        cin>>n>>k;
        FOR(i,0,n-1)
        {
            cin>>temp;
            if(temp>=k) count++;
        }
        cout<<count<<endl;
    }
    
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define fs first
#define sc second
#define p 1000000007
#define pb push_back
#define mp make_pair
typedef long long Int;
typedef pair<Int,Int> pii;
typedef vector<Int> vi;
typedef vector<pii> vii;

//segment trees
struct node
{
    Int val;
    Int left;
    Int right;
};
struct node Tree[400000];
struct node Tree2[400000];
void merge(Int a)
{
    Tree[a].val=Tree[2*a].val+Tree[2*a+1].val;
    Tree[a].left=Tree[2*a].left;
    Tree[a].right=Tree[2*a+1].right;
}
 void update(Int curr,Int i,Int v)
 {
     if (Tree[curr].left==Tree[curr].right&&Tree[curr].left==i)
        Tree[curr].val+=v;
     else if (Tree[curr].left<=i&&Tree[curr].right>=i)
     {
         Tree[curr].val+=v;
         update(2*curr,i,v);
         update(2*curr+1,i,v);
     }
 }
void buildtree(Int curr,Int L,Int R)
{
    if (L>R)
        return;
    else if (L==R)
    {
        Tree[curr].val=0;
        Tree[curr].left=L;
        Tree[curr].right=R;
    }
    else
    {
        Int mid=L+(R-L)/2;//to avoid overflow
        buildtree(2*curr,L,mid);
        buildtree(2*curr+1,mid+1,R);
        merge(curr);
    }
}
Int query(Int curr,Int L,Int R)
{
    if (Tree[curr].left>=L&&Tree[curr].right<=R)
        return Tree[curr].val;
    else if (Tree[curr].right<L||Tree[curr].left>R)
        return 0;
    else
        return query(2*curr,L,R)+query(2*curr+1,L,R);
}
//second tree
void merge2(Int a)
{
    Tree2[a].val=Tree2[2*a].val+Tree2[2*a+1].val;
    Tree2[a].left=Tree2[2*a].left;
    Tree2[a].right=Tree2[2*a+1].right;
}
 void update2(Int curr,Int i,Int v)
 {
     if (Tree2[curr].left==Tree2[curr].right&&Tree2[curr].left==i)
        Tree2[curr].val+=v;
     else if (Tree2[curr].left<=i&&Tree2[curr].right>=i)
     {
         Tree2[curr].val+=v;
         update2(2*curr,i,v);
         update2(2*curr+1,i,v);
     }
 }
void buildtree2(Int curr,Int L,Int R)
{
    if (L>R)
        return;
    else if (L==R)
    {
        Tree2[curr].val=0;
        Tree2[curr].left=L;
        Tree2[curr].right=R;
    }
    else
    {
        Int mid=L+(R-L)/2;//to avoid overflow
        buildtree2(2*curr,L,mid);
        buildtree2(2*curr+1,mid+1,R);
        merge2(curr);
    }
}
Int query2(Int curr,Int L,Int R)
{
    if (Tree2[curr].left>=L&&Tree2[curr].right<=R)
        return Tree2[curr].val;
    else if (Tree2[curr].right<L||Tree2[curr].left>R)
        return 0;
    else
        return query2(2*curr,L,R)+query2(2*curr+1,L,R);
}
//ends here

vi G[100005];
Int tim;
Int in[100005];
Int out[100005];
Int level[100005];
pii Query[100005];
void initialise()
{
    for (Int i=0;i<100004;++i)
    {
        tim=-1;
        G[i].clear();
    }
    buildtree(1,0,100003);
    buildtree2(1,0,100003);
    update2(1,0,1);
}
void dfs(Int src)
{
    in[src]=++tim;
    for (Int i=0;i<G[src].size();++i)
    {
        level[G[src][i]]=level[src]+1;
        dfs(G[src][i]);
    }
    out[src]=tim;
}
int main()
{
    Int T;
    cin>>T;
    while (T--)
    {
        initialise();
        Int M,type,V,N=0;
        cin>>M;
        for (Int i=0;i<M;++i)
        {
            cin>>Query[i].fs>>Query[i].sc;
            if (Query[i].fs==0)
            {
                ++N;
                G[Query[i].sc].pb(N);
            }
        }
        level[0]=0;
        dfs(0);
        Int temp=0;
        for (Int i=0;i<M;++i)
        {
            if (Query[i].fs==0)
            {
                ++temp;
                if (level[temp]%2==1)
                    update(1,in[temp],1);
                else
                    update2(1,in[temp],1);
            }
            else
            {
                Int u=query(1,in[Query[i].sc],out[Query[i].sc]);//number of ones
                Int v=query2(1,in[Query[i].sc],out[Query[i].sc]);//number of zeroes
                u=u*(u-1)/2;
                v=v*(v-1)/2;
                cout<<u+v<<"\n";
            }
        }
    }
    return 0;
}

#define pb push_back
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
#define ll long long
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
int q,i,m,l,j,ans=0,k;
char s[20010];
int dp[20010][510];
int main() {
	cin>>s;
	scanf("%d",&q);
int	le=strlen(s);
	for(k=1;k<=q;k++)
	{
		ans=0;
		scanf("%d%d",&m,&l);
		memset(dp,0,sizeof(dp));
		for(i=1;i<=le;i++)
		{
			dp[i][(s[i-1]-'0')%m]=1;
		}
		for(i=2;i<=le;i++)
		{
			for(j=0;j<m;j++)
			{
				dp[i][(j*10+(s[i-1]-'0'))%m]+=dp[i-1][j];
			}
		}
		for(i=1;i<=le;i++)
		{
			ans+=dp[i][l];
		}
		printf("%d\n",ans);
	}
	// your code goes here
	return 0;
}
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mp make_pair
#define MOD 1000000007
#define pii pair<int,int>
#define sc scanf
#define pf printf
#define MAX 105
using namespace std;

struct cmp
{
    bool operator()(pii a ,pii b){
        return a.second > b.second;
    }
};

ll modpow(ll base, ll exp, ll mod) 
{
  base %= mod;
  ll result = 1;
  while (exp > 0) {
    if (exp & 1) result = (result * base) % mod;
    base = (base * base) % mod;
    exp >>= 1;
  }
  return result;
}

ll num[MAX][MAX],fo[MAX][MAX],rev[MAX][MAX];

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	//freopen("C:/Users/HP/Desktop/codejam/1A_large_input.txt","r",stdin);//redirects standard input
	//freopen("C:/Users/HP/Desktop/codejam/1A_large_output.txt","w",stdout);//redirects standard output
	int t,n,m;
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		for(int i=1; i<=n; i++)
		{
			for(int j=1; j<=m; j++)
			{
				cin>>num[i][j];
			}
		}
		for(int i=0; i<=n; i++)
		{
			num[i][0]=0;
			num[i][m+1]=0;
		}
		for(int i=0; i<=m+1; i++)
		{
			num[0][i]=0;
		}
		for(int i=0; i<=n; i++)
		{
			fo[i][0]=num[i][0];
			rev[i][m]=num[i][m];
			fo[i][1]=num[i][1];
			rev[i][m+1]=num[i][m+1];
		}
		for(int i=0; i<=m+1; i++)
		{
			fo[0][i]=num[0][i];
			rev[0][i]=num[0][i];
		}
		for(int i=1; i<=n; i++)
		{
			for(int j=1; j<=m; j++)
			{
				fo[i][j]=fo[i-1][j-1]+num[i][j];
			}
		}
		for(int i=1; i<=n; i++)
		{
			for(int j=m; j>0; j--)
			{
				rev[i][j]=rev[i-1][j+1]+num[i][j];
			}
		}
		
		/*cout<<endl;
		for(int i=0; i<=n; i++)
		{
			for(int j=0; j<=m+1; j++)
			{
				cout<<" "<<fo[i][j];
			}
			cout<<endl;
		}
		cout<<endl;
		for(int i=0; i<=n; i++)
		{
			for(int j=0; j<=m+1; j++)
			{
				cout<<" "<<rev[i][j];
			}
			cout<<endl;
		}
		cout<<endl;*/
		
		int len=-1+min(n,m);
		ll ans=-(ll)100*MOD,p;
		for(int i=1; i<=n; i++)
		{
			for(int j=1; j<=m; j++)
			{
				for(int k=1; k<=len; k++)
				{
					if(i+k<=n && j+k<=m) {
						p=fo[i+k][j+k]+rev[i+k][j]-fo[i-1][j-1]-rev[i-1][j+k+1];
						if(!(k&1)) {
							p-=num[i+k/2][j+k/2];
						}
						ans=max(ans,p);
						//cout<<" "<<i<<" "<<j<<" "<<k<<" "<<p<<" "<<ans<<endl;
					}
				}
			}	
		}
		cout<<ans<<endl;
	}
	
	return 0;
}
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <memory.h>
#include <cstring>
using namespace std;
long long len[20000];
long long dig[20000];
long long mod=1000000007;
map<long long,long> dp;
long long powmod(long long x, long long n) {
	long long nn=n;
	if(x==10 && dp[nn]!=0)
	return dp[nn];
    long long w=1,p=x;
    while (n) {
        if (n%2) w=(w%mod*p%mod)%mod;
        p=(p%mod*p%mod)%mod;
        n/=2;
    }
    if(x==10)
    dp[nn]=w;
    return w%mod;
    }
long long getagp(long long n)
{
	if(n<=0)
		return 0;
 
	n--;
	long long x=(9*( ( (n%mod+1)*powmod(10,n+1) )%mod-1+mod))%mod - (10*(powmod(10,n)-1+mod)%mod)%mod + mod;
	x=x%mod;
	x=(x*powmod(81,mod-2))%mod;
	x=(x*10)%mod;
	return x;
}
long long getgp(long long n)
{
	if(n<0)
		return 0;
	long long x=(powmod(10,n+1)-1+mod)%mod;
	x=(x*powmod(9,mod-2))%mod;
	return x;
}
long long getagp1(long long n)
{
	if(n<0)
		return 0;
	n++;
	long long a=n;
	long long r=10;
	long long x=( (((powmod(10,n)-n%mod+mod)%mod)*9)%mod + ((powmod(10,n-1)-1+mod)%mod*10)%mod )%mod;
	x=(x*powmod(81,mod-2))%mod;
	return x;
 }
int main()
{
	//cout<<getagp1(0)<<endl;
	int t;
	scanf("%d",&t);
	while(t--)
	{
		long long m;
		scanf("%lld",&m);
		long long tot=0;
		for(int i=0;i<m;i++)
		{
			scanf("%lld %lld",&len[i],&dig[i]);
			tot=tot+len[i];
		}
		long long ctot=tot;
		long long ans=0;
		for(int i=0;i<m;i++)
		{
 
			long long x=((((getagp(tot-1)-getagp(tot-len[i]-1)+mod)%mod*45)%mod)*dig[i])%mod;
			x=(x*powmod(10,mod-2))%mod;
			long long y=(getgp(tot-1)-getgp(tot-len[i]-1)+mod)%mod;
			y=((y*dig[i])%mod*(dig[i]-1))%mod;
			y=(y*powmod(2,mod-2))%mod;
			ans=((ans+x)%mod+y)%mod;
			//cout<<x<<endl;
			tot=tot-len[i];
		//	cout<<ans<<endl;
		}
		long long arr[m];
		tot=0;
		
		///ans=0;
		for(int i=m-1;i>=0;i--)
		{
			if(i==m-1)
			{
				arr[i]=(dig[i]*getgp(len[i]-1))%mod;
				//cout<<len[i]-2<<endl;
				tot=tot+len[i];
				//cout<<getagp1(5)<<endl;
				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + len[i])%mod )%mod*dig[i])%mod)%mod;
				//cout<<ans<<endl;
				
			}
			else
			{	
				tot=tot+len[i];
				//cout<<"-----"<<((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])<<endl;
				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + (len[i]%mod*(arr[i+1]+1)%mod)%mod)%mod )%mod*dig[i])%mod)%mod;
				arr[i]=(arr[i+1]+(((dig[i]*getgp(len[i]-1))%mod)*(powmod(10,tot-len[i] )))%mod)%mod;
				//cout<<getgp(4)<<endl;
			}
			//cout<<ans<<endl;
			//cout<<arr[i]<<endl;
 
		}
		//cout<<ans<<endl;
 		printf("%lld\n",ans);
	}
	
	return 0;
 
} 
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair <int,int> pii;
typedef vector <int> vi;

#define rep(i, n) for(int i = 0; i < (n); ++i)
#define forn(i, a, b) for(int i = (a); i < (b); ++i)
#define ford(i, a, b) for(int i = (a); i >= (b); --i)
#define fore(i, a, b) forn(i, a, b + 1)

#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define all(c) c.begin(), c.end()
#define mset(a, v) memset(a, v, sizeof(a))
#define sz(a) ((int)a.size())

#define gi(x) scanf("%d", &x)
#define pis(x) printf("%d ", x)
#define pin(x) printf("%d\n", x)
#define pnl printf("\n")
#define dbn cerr << "\n"
#define dbg(x) cerr << #x << " : " << (x) << " "
#define dbs(x) cerr << (x) << " "

#define foreach(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it)

const int MAX_N = 100100;

vi a[MAX_N];
vector <pii> toRemove[MAX_N];
pii toInsert[MAX_N], ans[MAX_N];
int cnt[MAX_N];

int main() {
    int T; gi(T);
    rep(z, T) {
        int n, m;
        gi(n), gi(m);
        rep(i, n) a[i].clear(), toRemove[i].clear(), toInsert[i] = mp(n, 0);
        rep(i, m + 1) cnt[i] = 0;

        rep(i, n) {
            int x; gi(x);
            rep(j, x) {
                int id; gi(id);
                a[i].pb(id);
            }
        }
        int ptr = n - 1, numTypes = 0;
        for(int i = n - 1; i >= 0; --i) {
            while(ptr >= 0 and numTypes < m) {
                rep(j, sz(a[ptr])) {
                    cnt[a[ptr][j]]++;
                    if(cnt[a[ptr][j]] == 1) ++numTypes;
                }
                --ptr;
            }
            if(numTypes == m) {
                toRemove[ptr + 1].pb(mp(i - ptr, ptr + 1));
                toInsert[i] = mp(i - ptr, ptr + 1);
            }

            rep(j, sz(a[i])) {
                cnt[a[i][j]]--;
                assert(cnt[a[i][j]] >= 0);
                if(cnt[a[i][j]] == 0) --numTypes;
            }
        }

        set <pii> possible;

        for(int i = n - 1; i >= 0; --i) {
            possible.insert(toInsert[i]);
            ans[i] = *possible.begin();
            if(i < n - 1) ans[i] = min(ans[i], mp(ans[i + 1].ff + 1, ans[i + 1].ss - 1));

            foreach(toRemove[i], it) possible.erase(*it);
        }
        rep(i, n) pis(ans[i].ss + 1), pin(ans[i].ss + ans[i].ff);
    }
    return 0;
}
// codechef_codes.cpp : Defines the entry point for the console application.

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <time.h>
#include <cstdlib>
#include <deque>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vector<int> > vvi;
typedef pair<int, int> ii;
typedef vector<pair<int, int> > vii;
typedef vector<vector<pair<int, int> > > vvii;

#define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define max(a,b) ((a)>(b)?a:b)
#define min(a,b) ((a)<(b)?a:b)
#define min_3(a,b,c) (min((a),min((b),(c))))
#define INF 1000000007
#define pb push_back 
#define PB pop_back
#define pf push_front
#define PF pop_front
#define MP make_pair
#define all(x) (x).begin(), (x).end()
#define nall(x) (x).rbegin(), (x).rend()
#define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it)
#define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it)
#define mset(a,b) memset(a,b,sizeof(a))
#define ia(a,n) FOR(i,0,n-1)cin>>a[i]
#define ia1(a,n) FOR(i,1,n)cin>>a[i]
#define fpresent(c,x) ((c).find(x) != (c).end())  // set,map
#define present(c,x) (find(all(c),x) != (c).end())  //vector
#define F first
#define S second
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define NFOR(i,a,b) for(int i=a;i>=b;--i)
#define rep(i,n) FOR(i,0,n-1)
#define TCASE int __T;cin>>__T;FOR(Tc,1,__T)
inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; }
inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); }
inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; }
inline int neg(int x, int m = INF) { x = -x;return norm(x); }


/// debug //////
#define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;}
#define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;}
#define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;


int main() {
	boost;
	ll tc,N,a,M,num,count = 0;
	cin >> tc;
	while (tc--) {
		cin >> N >> a >> M ;
		cout << (((a-1)+M)%N)+1 << endl;
	}
}
// codechef_codes.cpp : Defines the entry point for the console application.
//

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <time.h>
#include <cstdlib>

#define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define max(a,b) ((a)>(b)?a:b)
#define min(a,b) ((a)<(b)?a:b)
#define min_3(a,b,c) (min((a),min((b),(c))))
#define INF 1000000007

using namespace std;

int a[107];
int arr[27][27];

int main() {
	boost;
	int tc,l,co,cou,flag;
	string str1,str2,str;
	cin >> tc;
	while (tc--) {
		flag = 1;
		for (int i = 0; i < 26; i++) {
			for(int j = 0 ; j < 26 ; j++)
				arr[i][j] = 0;
				}	
				cin>>str1>>str2;
				if (str1.length() != str2.length()) {
					cout << "NO"<<endl;
					continue;
				}
				cin >> l;
				for(int i = 0 ; i < l; i++){
					cin >> str;
					arr[str[0]-'a'][str[3]-'a'] = 1;
					}
				for (int k = 0; k < 26; k++) {
					for (int i = 0; i < 26; i++) {
						for(int j = 0; j < 26 ; j++)
							arr[i][j] = arr[i][j] | (arr[i][k]&arr[k][j]);
					}
				}
				for (int i = 0; i < str1.length(); i++) {
					if (str1[i] != str2[i]) {
						if(arr[str1[i] - 'a'][str2[i] - 'a'] != 0)
							flag = 1;
						else {
							flag = 0;
							break;
						}
					}
				}
				if(flag)
					cout << "YES"<<endl;
				else
					cout << "NO"<<endl;
	}
}
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define ll long long
#define mp make_pair
#define F first
#define S second
#define pii pair<int,int>
#define ll long long
#define mod 1000000007
#define maxn 2000005
#define vi vector<int>
#define fr freopen("input.in","r",stdin)
#define fw freopen("output.out","w",stdout)

set<int> avail;
vector<int> pref;
int ans[100005];
int test,n,p,curr;

int main(){

    //fr; fw;

    scanf("%d",&test);

    while(test--){

        avail.clear();
        pref.clear();

        scanf("%d",&n);
        
        for(int i = 1; i <= (5*n-2); i++){
            avail.insert(i);
        }
        
        for(int i = 1; i <= n; i++){
            scanf("%d",&p);
            pref.pb(p);
        }
        set<int>::iterator it;
        for(int i = n-1; i > -1; i--){
            curr = pref[i];
            it = avail.lower_bound(curr);
            if(it != avail.end()){
                ans[i+1] = *it;
                curr = *it;
            }
            else{
                ans[i+1] = *avail.begin();
                curr = ans[i+1];
            }
            avail.erase(curr);
            avail.erase(curr+1);
            avail.erase(curr+2);
            avail.erase(curr-1);
            avail.erase(curr-2);
        }
        for(int i = 1; i <= n; i++){
            printf("%d ",ans[i]);
        }
        printf("\n");
    }
    return 0;
}
#include <bits/stdc++.h>
using namespace std;
 
#define INF 1000000007
 
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vector<int> > vvi;
typedef pair<int,int> ii;
typedef vector<pair<int,int> > vii;
typedef vector<vector<pair<int,int> > > vvii;
 
#define all(x) x.begin(), x.end()
#define tr(x,it) for(auto it = x.begin();it!=x.end();++it)
#define ntr(x,it) for(auto it = x.rbegin();it!=x.rend();++it)
#define sz(a) int((a).size()) 
#define pb push_back 
#define PB pop_back
#define pf push_front
#define PF pop_front
#define MP make_pair
#define clr clear
#define rz resize
 
#define ia(a,n) FOR(i,0,n-1)cin>>a[i]
#define ia1(a,n) FOR(i,1,n)cin>>a[i]
#define fpresent(c,x) ((c).find(x) != (c).end())  // set,map
#define present(c,x) (find(all(c),x) != (c).end())  //vector
#define F first
#define S second
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define NFOR(i,a,b) for(int i=a;i>=b;--i)
#define rep(i,n) FOR(i,0,n-1)
#define TCASE int __T;cin>>__T;FOR(Tc,1,__T)
inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;}
inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);}
 
ll expo(int base, int exp, int MOD=INF) {
    ll res=1;
    while(exp>0) {
       if(exp&1) res=(res*(ll)base)%MOD;
       base=((ll)base*base)%MOD;
       exp=exp>>1;
    }
    return (int) res;
}
int fac[200001];
int ifac[200001];
inline int C(int n, int r)
{
	int ans=1;
	ans=mul(ans,fac[n]);
	ans=mul(ans,ifac[r]);
	ans=mul(ans,ifac[n-r]);
	return ans;
}
int main()
{
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    
    fac[0]=1;
    FOR(i,1,200000)fac[i]=mul(fac[i-1],i);
    FOR(i,0,200000)ifac[i]=expo(fac[i],INF-2);
    TCASE
    {
    	int n,k;
    	cin>>n>>k;
    	if(n==1){cout<<"-1\n";continue;}
    	int kr=sqrt(k);
    	int ans=0;
    	ans=add(ans,C(kr+n-1,n));
    //	cout<<ans<<" ";
    	int krr=kr;
    	//if(kr*kr==k)kr--;
    	FOR(i,1,kr)
    	{
    		int no=k/(i)-k/(i+1);
    		if(k/i <= krr)continue;
    		ans=add(ans,mul(no,C(i+n-2,n-1)));
    	}
    	cout<<ans<<"\n";
    }
    
	return 0;
}
 
#include <iostream>
using namespace std;

int main() {
	
	int t;
	cin>>t;
	while(t--){
	    int n,q;
	    long long int a,b,c,d;
	    cin>>a>>b;
	    cin>>q;
	    bool ans=true;
	    while(q--){
	        cin>>c>>d;
	        if((c>a&&c<b)||(d>a&&d<b))
	            ans=false;
	       else if(c<=a&&d>=b)
	            ans=false;
	    }
	    if(ans)  cout<<"YES"<<endl;
	       else cout<<"NO"<<endl;
	}
	return 0;
}

#include<iostream>
#include<cstdio>
#include<cassert>
#include<cmath>
#include<vector>
#include<set>
#include<map>
#include<string>
#include<algorithm>
#define vvl vector<vector<long long> >
#define vvi vector<vector<long long> >
long long mod=10000007;
using namespace std;
long long temp[2][2];

void MatrixMult(long long A[][2], long long B[][2])
{
	for(int i = 0; i < 2; i++)
		for(int j = 0; j < 2; j++)
		{
			temp[i][j] = 0;
			for(int k = 0; k < 2; k++)
				temp[i][j] =(temp[i][j] + (A[i][k] * B[k][j]) % mod) % mod;
		}
	for(int i = 0; i < 2; i++)
		for(int j = 0; j < 2; j++)
			A[i][j] = temp[i][j];
}

long long FindFibonacci(long long n)
{
	if (n == 0)
		return 0;
	if (n == 1)
		return 1;
	n--;
	long long ans[2][2];
	long long res[2][2];

	res[0][0] = res[1][1] = 1;
	res[0][1] = res[1][0] = 0;
	ans[0][0] = ans[0][1] = ans[1][0] = 1;
	ans[1][1] = 0;
	while(n)
	{
		if(n & 1)
			MatrixMult(res, ans);
		MatrixMult(ans, ans);
		n >>= 1;
	}
	return (res[0][0] + res[0][1]) % mod;
}

void mat_mult(vector<vector<long long> > a,vector<vector<long long> > b, vector<vector<long long> > &c)
{
	assert (a.size()!=0);
	assert (b.size()!=0);
	assert (a[0].size()==b.size());
	c.resize(a.size());
	for (int i=0;i<c.size();++i)c[i].resize (b[0].size());
	for (int i=0;i<a.size();++i){
		for (int k=0;k<b[0].size();++k){
			c[i][k] = 0;
			for (int j=0;j<a[i].size();++j) {
				c[i][k] = ( c[i][k] + ( a[i][j] * b[j][k] ) % mod ) % mod;
			}
		}
	}
}
vector<vector< vvl > > pre(11,vector< vvl > (65));
int rev(int a,int b,int c)
{
	int ans=(a<<2)+(b<<1)+c;
	return ans;
}
void eye (vvl &a, int dim){
	a.resize (dim);
	for (int i=0;i<dim;++i){a[i].resize(dim);a[i][i]=1;}
}
void trans(vvl a,vvl &b)
{
	int q=a.size(),w=a[0].size();
	b.resize(w);
	for(int i=0;i<w;++i)
	{
		b[i].resize(q);
		for(int j=0;j<q;++j)
		{
			b[i][j]=a[j][i];
		}
	}
}
void init(int k)
{
	vvl mat(4*k,vector<long long> (4*k,0));
	int size=4*k;
	for(int i=0;i<size;++i)
	{
		int a,b,c;
		c=i&1;
		b=(i>>1)&1;
		a=i>>2;
		mat[i][rev((a+1)%k,b,0)]++;
		if(c==0)
		{
			mat[i][rev(a,b,1)]++;	
		}	
		mat[i][rev(a,1,0)]++;
	}
	pre[k][1]=mat;
}
void doit()
{
	long long n,k;
	scanf("%lld%lld",&n,&k);
	if(k==0)
	{	
		printf("%lld\n",FindFibonacci(n+1));
	}
	else
	{
		vvl ans;
		eye(ans,4*k);
		int i=1;
		while(n)
		{
			vvl p=pre[k][i];
			if(n%2==1)mat_mult(ans,p,ans);
			i++;
			n/=2;
		}
		long long v=ans[0][2]+ans[0][3];
		v%=mod;
		printf("%lld\n",v);
	}
}
int main()
{
	for(int i=1;i<=10;++i)init(i);
	for(int i=1;i<=10;++i)
	{
		for(int j=2;j<=64;++j)
		{
			vvl p=pre[i][j-1];
			mat_mult(pre[i][j-1],p,pre[i][j]);
		}
	}
	int t;
	scanf("%d",&t);
	while(t--)
	{
		doit();
	}
	return 0;
}

#include <bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		string s;
        cin>>s;
        int p,q;
        cin>>p>>q;
        int len = s.size();
        sort(s.begin(),s.end());
        while(q--)
        {
        	int n;
        	cin>>n;
        	if(n<=len*p)
        	{
        		int print= (n-1)/p;
        		cout<<s[print]<<endl;
        	}
        	else cout<<-1<<endl; 
        }
	}
	return 0;
}
#include <bits/stdc++.h>
#define N 500005
using namespace std;
typedef long long int lli;
typedef struct{
	lli maxm, sum;
	bool inc, dec;
	lli left;
	lli right;
}seg;

seg st[N];
lli a[N];

void build(int ss, int se, int si){
	if(ss > se) return;
	if(ss == se){
		st[si].maxm = a[ss];
		st[si].sum = a[ss];
		st[si].inc = 1;
		st[si].dec = 1;
		return;
	}
	int mid = (ss + se) / 2;
	build(ss, mid, 2*si);
	build(mid+1, se, 2*si+1);
	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm);
	st[si].sum = st[2*si].sum + st[2*si+1].sum;
	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]);
	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]);
}

void update(int ss, int se, int si, int index){
	if(ss > se) return;
	if(ss > index || se < index) return;
	if(ss == se && ss == index){
		st[si].maxm = a[index];
		st[si].sum = a[index];
		st[si].inc = true;
		st[si].dec = true;
		return;
	}
	int mid = (ss + se) / 2;
	update(ss, mid, 2*si, index);
	update(mid+1, se, 2*si+1, index);
	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm);
	st[si].sum = st[2*si].sum + st[2*si+1].sum;
	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]);
	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]);
}

lli getmax(int qs, int qe, int ss, int se, int si){
	if(qe < ss || qs > se || ss > se) return 0;
	if(qs <= ss && se <= qe) return st[si].maxm;
	int mid = (ss + se) / 2;
	return max(getmax(qs, qe, ss, mid, 2*si), getmax(qs, qe, mid+1, se, 2*si+1));
}

lli getsum(int qs, int qe, int ss, int se, int si){
	if(qe < ss || qs > se || ss > se) return 0;
	if(qs <= ss && se <= qe) return st[si].sum;
	int mid = (ss + se) / 2;
	return getsum(qs, qe, ss, mid, 2*si) + getsum(qs, qe, mid+1, se, 2*si+1);
}

bool getinc(int qs, int qe, int ss, int se, int si){
	if(qe < ss || qs > se || ss > se) return 1;
	if(qs <= ss && se <= qe) return st[si].inc;
	int mid = (ss + se) / 2;
	lli x = getinc(qs, qe, ss, mid, 2*si);
	lli y = getinc(qs, qe, mid+1, se, 2*si+1);
	if(qs <= mid && mid+1 <= qe)
		return (x && y && a[mid] <= a[mid+1]);
	else
		return (x && y);
}
lli getdec(int qs, int qe, int ss, int se, int si){
	if(qe < ss || qs > se || ss > se) return 1;
	if(qs <= ss && se <= qe) return st[si].dec;
	int mid = (ss + se) / 2;
	lli x = getdec(qs, qe, ss, mid, 2*si);
	lli y = getdec(qs, qe, mid+1, se, 2*si+1);
	if(qs <= mid && mid+1 <= qe)
		return (x && y && a[mid] >= a[mid+1]);
	else
		return (x && y);
}
int main() {
	int n, m, index, qs, qe, qtype;
	char c;
	lli newval;
	scanf("%d%d", &n, &m);
	for(int i = 0 ; i < n;  i++)
		scanf("%lld", &a[i]);
	build(0, n-1, 1);
	for(int i = 0 ; i < m ; i++){
		c = getchar();
		scanf("%c", &c);
		if(c == 'U'){
			scanf("%d%lld", &index, &newval);
			index--;
			a[index] = newval;
			update(0, n-1, 1, index);
		}
		else{
			scanf("%d%d", &qs, &qe);
			qs--;
			qe--;
			switch(c){
				case 'M': printf("%lld\n", getmax(qs, qe, 0, n-1, 1));
						break;
				case 'S': printf("%lld\n", getsum(qs, qe, 0, n-1, 1));
						break;
				case 'I': printf("%d\n", getinc(qs, qe, 0, n-1, 1));
						break;
				case 'D': printf("%d\n", getdec(qs, qe, 0, n-1, 1));
						break;
			}
		}
	}
	return 0;
} 
#include<bits/stdc++.h>
using namespace std;
# define d double 
# define l long int
struct Point{
	d x;
	d y;
};
int compareX(const void* a, const void* b)
{
    Point *p1 = (Point *)a,  *p2 = (Point *)b;
    return (p1->x - p2->x);
}
// Needed to sort array of points according to Y coordinate
int compareY(const void* a, const void* b)
{
    Point *p1 = (Point *)a,   *p2 = (Point *)b;
    return (p1->y - p2->y);
}
d dist(Point p1, Point p2)
{
    return sqrt( (p1.x - p2.x)*(p1.x - p2.x) +
                 (p1.y - p2.y)*(p1.y - p2.y)
               );
}
d stripmin(Point strip[],l size, d sum)
{
	d mini = sum;  
	qsort(strip, size, sizeof(Point), compareY); 
	for(l i=0;i<size;i++)
	{
		for(l j=i+1;j<size&&(strip[j].y-strip[i].y)<(mini/2);j++)
		{
			for(l k=j+1;k<size&&(strip[k].y-strip[i].y)<(mini/2);k++)
			{
				d di=(dist(strip[i],strip[j])+dist(strip[k],strip[j])+dist(strip[i],strip[k]));
				if(di<mini) mini=di;
			}
		}
	}
	return mini;
}
/*d bruteforce(Point P[],int n)
{
	d mini = FLT_MAX;
    for (int i = 0; i < n; i++)
        for (int j = i+1; j < n; j++)
        	for(int k=j+1;k<n;k++)
            	{d di=(dist(P[i],P[j])+dist(P[k],P[j])+dist(P[i],P[k])); //cout<<i<<j<<k<<" "<<di<<"\n";
            		if(mini>di) mini=di;}
    return mini;
}*/
d minsum(Point P[],l n)
{
	if(n<3)
	{
		return DBL_MAX;
	}
	l mid=n/2;
	Point midpt=P[mid];
	d lf=minsum(P,mid);
	d rt=minsum(P+mid,n-mid);
	d sum=min(lf,rt);
	//cout<<sum<<"\n";
	Point strip[n];
	l j = 0;
    for (l i = 0; i < n; i++)
        if (abs(P[i].x - midpt.x) < (sum/2))
            strip[j] = P[i], j++;
    d middle=stripmin(strip,j,sum);
    //cout<<min(middle,sum)<<"\n";
    return min(middle,sum);
}
int main()
{
	int t;
	cin>>t;
	int h=t;
	l n;
	Point P[100005];
	while(t--){
		cin>>n;
		for(l i=0;i<n;i++)
		{
			cin>>P[i].x>>P[i].y;
		}
		    qsort(P, n, sizeof(Point), compareX);
		cout<<"Case "<<h-t<<": "<<setprecision(10)<<minsum(P, n)<<"\n";
	}
}
#include<bits/stdc++.h>
#define ll long long
#define SIZE 100009

using namespace std;

inline int LSOne(int n){         // Returns least Significant 1's place
	return n&(-n);
}

class FenwickTree{
	vector<ll> ft;                                                      // Fenwick tree usable from 1 to n
	public:
	FenwickTree(int n){              
		ft.assign(n+1,0);
	}
	ll rsq(int b){                                                      //Returns the cumulative freq from index 1 to n
		ll sum =0; 
		for(; b >0; b = b-LSOne(b)){                                      //O(logn)
			sum += ft[b];
		}
		return sum;
	}
	ll rsq(int a, int b){                                              // Returns The cumulative freq from index a to b
		return rsq(b) - (a == 1? 0 : rsq(a-1));
	}
	void adjust(int idx,int a){                                        // Adjusts the Array's idxth element, increments by a
		for(; idx < (int)ft.size();idx += LSOne(idx))                   // O(logn)
			ft[idx] +=a;
	}
	void rupd(int idx1,int idx2, int b){                              // Range updates Fenwick tree
		adjust(idx1, b);
//		cout<<"in"<<endl;
		adjust(idx2+1, -1*b);
	}
	ll pointq(int idx1){                                              // Point Query fenwick tree
		return rsq(idx1);
	}
};


int main(){
	ios::sync_with_stdio(false);
	int T,H;
	cin>>T;                                                                    // Test cases and hold
	H = T;

	while(T--){
		ll ans =0;                                                            // ans holds no of inversions
		int A[SIZE], n,k;
		set<int> A1;                                                          // set to check if there r any repeated Ai's
		cin>>n>>k;
		for(int i=0; i< n; i++){
			cin>>A[i];
			A1.insert(A[i]);
		}
		FenwickTree t(n+3);

		for(int i =0; i< n; i++){                                        // Function to find no of invs
			ans+= t.pointq(A[i]);
			t.rupd(1,A[i]-1,1);
		}

		cout<<"Case "<<H-T<<": ";
		if(ans>k){                                                       // If invs are more then ans is ans-k
			cout<<ans-k<<endl;
		}
		else{                                                           // If k is more-> more swaps even aftr sortd
			if(A1.size() != n)cout<<0<<endl;                             // 2 identical elements can b swappd again nd again
			else
			if((k-ans)%2)cout<<1<<endl;                                  // check parity
			else cout<<0<<endl;
		}
	}
	return 0;
}


#include<bits/stdc++.h>
#define SIZE 2000009
#define ll long long

using namespace std;

inline bool compare(int a,int b, vector<int> &A){
	return A[a]+a >= A[b] +b;
}


class SegmentTree{                                                           // Point update Range Query Std SEg Tree
	vector<int> st, A;
	int n;
	int left(int p){return p<<1;}
	int right(int p){return (p<<1) +1;}
	int rmq(int p, int L,int R, int i,int j){
		if(R<i || L>j) return -1;
		if(L>i && R<j) return st[p];
		if(L==R) return st[p];
		int p1 = rmq(left(p), L  , (L+R)/2,i, j );
		int p2 = rmq(right(p), (L+R)/2 +1, R, i, j);
		if(p1 == -1)
			return p2;
		if(p2 == -1)
			return p1;
		return compare(p1,p2,A) ? p1: p2;
	}
	void build_st(int p , int L, int R){
		if(L == R) {st[p] = L;return;}

		build_st(left(p), L  , (L+R)/2);
		build_st(right(p), (L+R)/2+1, R);
		int p1 = st[left(p)] , p2 = st[right(p)];
		st[p] = (compare(p1,p2,A) ? p1 : p2 );
	}

	public:

	SegmentTree(vector<int> &hol){
		st.assign(4*hol.size(),0);
		A = hol;
		n = hol.size() ;
		build_st(1,0,n-1);
	}
	int rmq(int i, int j){
		return rmq(1, 0, n-1, i, j);
	}
};



void zalgor(string &s, vector<int> &z){
	int L = 0, R = 0;
	int n = s.length();
	for (int i = 1; i < n; i++) {
		if (i > R) {
			L = R = i;
			while (R < n && s[R-L] == s[R]) R++;
			z[i] = R-L; R--;
		} else {
			int k = i-L;
			if (z[k] < R-i+1) z[i] = z[k];
			else {
				L = i;
				while (R < n && s[R-L] == s[R]) R++;
				z[i] = R-L; R--;
			}
		}
	}
}

int main(){
//	char A[SIZE],B[SIZE],A1[SIZE],B1[SIZE];

	ios::sync_with_stdio(false);
	int T, q;
   string A,B,A1,B1;
//   int ans=0,fa[SIZE] = {0},fb[SIZE] ={0}, n;// = A1.length();

	cin>>T;
	for(int q =1; q<=T; q++){
	//string A,B,A1,B1;
	cin>>A;

	cin>>B;

	A1 = B+A;
	B1 = A+B;

	int ans=0, n = A1.length();
	vector<int> fa(n+5,0), fb(n+5,0);
	ans =0; n = A1.length();
	zalgor(A1,fa);
	zalgor(B1,fb);
	n = n/2;

	for(int i =0; i< n; i++){
		fa[i] = fa[i +n];
	}
//	cout<<endl;
	
	for(int i =0; i< n; i++){
		fb[i] = fb[i + n];
	}
//	cout<<endl;
	cout<<"Case "<<q<<": ";

	vector<int> k(fa.begin(), fa.begin()+n);
	SegmentTree t (k);
	int h = A.length();
//	cout<<t.rmq(h,n)<<endl;;
	for(int i =0; i< n; i++){
		if(t.rmq(0,fb[i]) !=-1)
		ans = max(ans,( fa[t.rmq(0,fb[i])] + t.rmq(0,fb[i]) >=i ?i + t.rmq(0,fb[i]):0 ));
	}
	cout<<ans<<endl;
	}
	return 0;
}



#include <bits/stdc++.h>

using namespace std;
#define INF 1010000000
#define EPS 1E-12
#define MP make_pair
#define MT make_tuple
#define ST first
#define ND second
#define REP(i, n) for(int i = 0; i < (n); ++i)
#define REPD(i, n) for(int i = (n) - 1; i >= 0; --i)
#define FOR(i, a, n) for(int i = (a); i <= (n); ++i)
#define FORD(i, a, n) for(int i = (a); i >= (n); --i)
#define DD(x, args...) { vector<string> _v = _split(#args, ','); _err(x, _v.begin(), args); }
#define D(args...) DD(", ", args)
#define DE(args...) DD("\n", args)
#define D2(a, args...) { cerr << a << ": "; D(args); }
#define DD2(x, a, args...) { cerr << a << ": "; DD(x, args); }
#define E cerr << endl;
#define OUT(...) ostream& operator<<(ostream& ost, const __VA_ARGS__& _cnt) { return _out(ost, ALL(_cnt)); }
#define SZ(x) ((int)(x).size())
#define PB push_back
#define EB emplace_back
#define ALL(x) x.begin(), x.end()
#define endl '\n'

typedef long long LL;
typedef pair<int, int> PII;
typedef pair<LL, LL> PLL;
typedef pair<double, double> PDD;

template<class c1> ostream &_out(ostream &ost, c1 a, c1 b);

template<class... Types> ostream& operator<<(ostream& out, const tuple<Types...>& value);
template<class T1, class T2> ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt);

template<class T1> OUT(vector<T1>);
template<class T1> OUT(deque<T1>);
template<class T1> OUT(list<T1>);
template<class T1, class T2> OUT(set<T1, T2>);
template<class T1, class T2> OUT(multiset<T1, T2>);
template<class T1, class T2, class T3> OUT(map<T1, T2, T3>);
template<class T1, class T2, class T3> OUT(multimap<T1, T2, T3>);

template<class T1, class T2> 
ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt)
	{ return ost << '(' << _cnt.ST << ", " << _cnt.ND << ')'; }

template<class T1>
ostream& _out(ostream& ost, T1 a, T1 b)
	{ ost << '{'; if(a != b) { ost << *a; while(++a != b) ost << ", " << *a; } return ost << '}'; }

template<class Type, unsigned N, unsigned Last>
struct tuple_printer {
	static void print(ostream& out, const Type& value) 
	{ out << get<N>(value) << ", "; tuple_printer<Type, N + 1, Last>::print(out, value); }
};
template<class Type, unsigned N>
struct tuple_printer<Type, N, N> {
	static void print(ostream& out, const Type& value) 
		{ out << get<N>(value); }
};
template<class... Types>
ostream& operator<<(ostream& out, const tuple<Types...>& value) 
	{ out << '('; tuple_printer<tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value); out << ')'; return out; }

vector<string> _split(const string& s, char c) {
	int br = 0;
	vector<string> v(1);
	REP(i, SZ(s)) {
		if(s[i] == '[' || s[i] == '(' || s[i] == '{'/* || s[i] == '<'*/) br++;
		else if(s[i] == ']' || s[i] == ')' || s[i] == '}'/* || s[i] == '>'*/) br--;
		if(s[i] == c && br == 0) v.PB("");
		else v.back().PB(s[i]);
  }
  return v;
}

template<class T1>
void _err(string del, vector<string>::iterator it, T1 a) { 
	bool wb = (*it)[0] == ' ', we = (*it).back() == ' ';
	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << endl; 
	(void)del;
}
template<class T1, class... Args>
void _err(string del, vector<string>::iterator it, T1 a, Args... args) { 
	bool wb = (*it)[0] == ' ', we = (*it).back() == ' ';
	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << del; 
	_err(del, ++it, args...); 
}

template<class T> 
T maxx(const T& a) 
	{ return a; }
template<class T, class... Args> 
T maxx(const T& a, Args... args) 
	{ return max(a, maxx(args...)); }
template<class T> 
T minn(const T& a) 
	{ return a; }
template<class T, class... Args> 
T minn(const T& a, Args... args) 
	{ return min(a, minn(args...)); }

/////////////////////////////////////////////////////////////////////

vector<vector<int> > v;
vector<vector<tuple<int, int, int> > > seg;
int power;
vector<vector<int> > jump;
vector<int> dep;
vector<PII> inter;
vector<int> T;
int N;

int prep(int a, int pp, int cur = 0) {
	jump[a][0] = pp;
	FOR(i, 1, power)
		jump[a][i] = jump[jump[a][i - 1]][i - 1];
	
	inter[a].ST = cur;
	for(auto& i : v[a]) {
		if(i == pp)
			continue;
		dep[i] = dep[a] + 1;
		cur = prep(i, a, cur + 1);
	}
	inter[a].ND = cur;
	
	return cur;
}

int LCA(int a, int b) {
	if(dep[a] < dep[b])
		swap(a, b);
	
	int sub = dep[a] - dep[b];
	int len = 0;
	while(sub > 0) {
		if(sub % 2 == 1)
			a = jump[a][len];
		len++;
		sub /= 2;
	}
	
	if(a != b) {
		len = power;
		while(len >= 0) {
			if(jump[a][len] != jump[b][len]) {
				a = jump[a][len];
				b = jump[b][len];
			}
			len--;
		}
		a = b = jump[a][0];
	}
	
	return a;
}

int get(int a) {
	int res = 0;
	a += N;
	while(a != 0) {
		res += T[a];
		a /= 2;
	}
	return res;
}

void add(int a, int b, int val) {
	a += N;
	b += N;
	
	T[a] += val;
	if(a != b)
		T[b] += val;
	while(a + 1 < b) {
		if(a % 2 == 0)
			T[a + 1] += val;
		if(b % 2 == 1)
			T[b - 1] += val;
		a /= 2;
		b /= 2;
	}
}

int solve(int a, int pp = -1) {
	int res = 0;
	for(auto& i : v[a]) {
		if(i == pp)
			continue;
		res += solve(i, a);
	}
	int tres = res;
	
	for(auto& i : seg[a]) {
		int bg, en, cost;
		tie(bg, en, cost) = i;
		res = max(res, cost + get(inter[bg].ST) + get(inter[en].ST) + tres);
	}
	
	add(inter[a].ST, inter[a].ND, tres - res);
	
	return res;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int ts;
	cin >> ts;
	
	FOR(zz, 1, ts) {
		int n;
		cin >> n;
		power = sizeof(n) * 8 - __builtin_clz(n - 1);
		v.clear(); 			v.resize(n + 1);
		seg.clear(); 		seg.resize(n + 1);
		jump.clear(); 		jump.resize(n + 1, vector<int>(power + 1));
		dep.clear(); 		dep.resize(n + 1);
		inter.clear(); 	inter.resize(n + 1);
		T.clear();			T.resize(1 << (power + 1));
		N = 1 << power;
		
		REP(i, n - 1) {
			int a, b;
			cin >> a >> b;
			v[a].EB(b);
			v[b].EB(a);
		}
		
		prep(1, 1);
		
		int q;
		cin >> q;
		
		REP(i, q) {
			int a, b, c;
			cin >> a >> b >> c;
			seg[LCA(a, b)].EB(a, b, c);
		}
		
		cout << "Case " << zz << ": " << solve(1) << endl;
	}
	
	return 0;
}
/*
2
7
1 2
1 3
2 4
2 5
3 6
3 7
3
4 7 10
2 5 6
6 7 5
9
1 5 
1 2 
1 3 
2 7 
3 4 
3 8 
8 9 
8 6
5
5 1 4
7 3 8
3 4 3
1 8 11
6 9 4
*/ 
#include<bits/stdc++.h>
#include<stdio.h>
//#include<algorithm>
using namespace std;
//tuhinkundu
#define MOD 1000000007
#define ll         long long
#define s(n)                        scanf("%d",&n)
#define sc(n)                       scanf("%c",&n)
#define sll(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)
#define sstr(n)                       scanf("%s",&n)
#define p(n)	printf("%d\n",n)
#define pll(n)	printf("%lld\n",n)
#define pc(n)	printf("%c\n",n)
#define pstr(n)	printf("%s\n",n)
#define pbl   printf(" ")
#define pnew printf("\n")
int main()
{
	int t;
	s(t);
	int num=1;
	while(t--)
	{
		int n;
		s(n);
		int arr[n];
		for(int i=0;i<n;i++)
		s(arr[i]);
		sort(arr,arr+n,greater<int>());
		/*for(int i=0;i<n;i++)
		printf("%d ",arr[i]);
		pnew;*/
		printf("Case %d: %d\n",num++,arr[0]+arr[1]+arr[2]);
	}
	return 0;
}
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<string>
#include<string.h>
#include<vector>
#include<map>
#include<algorithm>
#include<limits.h>
#include<set>
 
using namespace std;
#define lli long long int
#define ulli unsigned long long int
#define in(t) scanf("%d",&t)
#define inl(t) scanf("%ld",&t)
#define inll(t) scanf("%lld",&t)
#define inlu(t) scanf("%llu",&t)
#define MOD 1000000007
//int flaga[1001],flagb[1001];//a[101],b[101];//num[1001];
int main()
{
    int t,i,n,ca,cb,num,c,d;
    in(t);
    //t=in();
    while(t--)
    {
    ca=cb=c=d=num=0;
    //int flaga[1001]={0};
    //int flagb[1001]={0};
    //memset(flaga,0,sizeof(flaga));
    //memset(flagb,0,sizeof(flagb));
    map<int,int>flaga;
    map<int,int>flagb;
    in(n);
    int a[n+1],b[n+1];
    //n=in();
    for(i=0;i<n;i++)
    {
    in(a[i]);
    flaga[a[i]]=1;
    }
    for(i=0;i<n;i++)
    {
    in(b[i]);
    flagb[b[i]]=1;
    }
    while(1)
    {
    in(num);
    if(num>0)
    {
    if(flaga[num]==1)
    {
    flaga[num]=-1;
    ca++;
    }
    if(flagb[num]==1)
    {
    flagb[num]=-1;
    cb++;
    }
    }
    else
    {
    break;
    }
    }
    for(i=0;i<ca;i++)
    {
    if(flaga[a[i]]==-1)
    c++;
    }
    for(i=0;i<cb;i++)
    {
    if(flagb[b[i]]==-1)
    d++;
    }
    if(c==n && d==n)
    printf("MIKE HARVEY\n");
    else if(c==n)
    printf("MIKE\n");
    else if(d==n)
    printf("HARVEY\n");
    else
    printf("0\n");
    }
    return 0;
}
#define pb push_back
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
#define ll long long
#include <iostream>
#include<bits/stdc++.h>
using namespace std;

int main() {
	int m,n;
	scanf("%d%d",&m,&n);
	while(m!=0&&n!=0)
	{
		int i,val[510]={0},e[510]={0},j,dp[510][510];
		memset(dp,0,sizeof(dp));
		for(i=0;i<n;i++)
		{
			scanf("%d%d",&val[i],&e[i]);
		}
	for(i=0;i<=n;i++)
	{
		for(j=0;j<=m;j++)
		{
			if(i==0||j==0)
			{
				dp[i][j]=0;
			}
			else if(val[i-1]<=j)
			{
				dp[i][j]=max(dp[i-1][j],dp[i-1][j-val[i-1]]+e[i-1]);
			}
			else
			{
				dp[i][j]=dp[i-1][j];
			}
		}
	}
	int m1=m,n1=n,ans=0,an=0;
	for(i=0;i<=m;i++)
	{
		if(dp[n][i]>ans)
		{
			ans=dp[n][i];
			an=i;
		}
	}
	printf("%d %d\n",an,dp[n][m]);
	scanf("%d%d",&m,&n);
	}
	// your code goes here
	return 0;
}
#include<stdio.h>
#define MOD 10000007
typedef unsigned long long ULL;
//const ULL f_1=1,f_2=5;
inline void read(ULL *ll){
	*ll=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){
		*ll=(*ll)*10+ch-'0';
		ch=getchar();
	}
}
ULL pow2(ULL n){
	if(n==0) return 1;
	if(n==1) return 2;
	if(n==2) return 4;
	if(n%3==0) return (pow2(n/3)*((pow2(n/3)*pow2(n/3))%MOD))%MOD;
	if(n%3==1) return (pow2(1)*pow2(n-1))%MOD;
	if(n%3==2) return (pow2(2)*pow2(n-2))%MOD;
}
int main(){
	ULL N,i,ct;//pt;
	int T;
	scanf("%d",&T);
	while(T--){
		read(&N);
		/*pt=f_1;ct=f_2;
		if(N==1){printf("%llu\n",f_1);continue;}
		if(N==2){printf("%llu\n",f_2);continue;}
		for(i=3;i<=N;i++){
			ct=(ct+2*pt);
			pt=(ct-2*pt);
			ct=ct%MOD;
			pt=pt%MOD;
		}*/
		ct=pow2(N);
		if(N%2==0) ct++;
		else ct--;
		printf("%llu\n",ct);
	}
	return 0;
}
#include <cmath>
#include <algorithm>
#include <vector>
#include <iostream>
#include <cstdio>
#include <complex>
#include <queue>
using namespace std;
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Ford(i,a,b) for(int i=a;i>=b;i--)
#define fi first
#define se second
#define sr(x) (int)x.size()
#define BUG(x) {cout << #x << " = " << x << endl;}
#define PR(x,a,b) {cout << #x << " = "; For(_,a,b) cout << x[_] << ' '; cout << endl;}
#define Bit(s,i) ((s&(1<<i))>0)
#define Two(x) (1<<x)
const int modul = 1000000007;
const int nmax = 1000010;
const double e = 1e-8;
const double pi = acos(-1);
typedef long long ll;
typedef pair<int,int> pii;
int n,m,stest;
ll Tree[4*nmax];
int Lazy[4*nmax][4];
ll sum(int n) {
    return ( (ll)n * (n+1) )/2;
}
void Cal(int i,int lo,int hi) {
    int mid = (lo+hi) >> 1;
//    BUG(10);
//    cout << i << " " << lo << " " << hi;
//    PR(Lazy[i],1,3);
    if (Lazy[i][3]!=modul) {
        int x = Lazy[i][3]; Lazy[i][3]=modul;
        Tree[2*i] = x*(mid-lo+1); Lazy[2*i][3]=x;
        Tree[2*i+1] = x*(hi-mid); Lazy[2*i+1][3]=x;
    }
    if (Lazy[i][1]!=0) {
        int x = Lazy[i][1]; Lazy[i][1]=0;
        Tree[2*i] += x*sum(mid-lo+1); Lazy[2*i][1]+=x;
        Tree[2*i+1]+=x* (sum(hi-mid) + (ll)(mid-lo+1)*(hi-mid)); Lazy[2*i+1][1]+=x; Lazy[2*i+1][2]+=(mid-lo+1);
    }
    if (Lazy[i][2]!=0) {
        int x = Lazy[i][2]; Lazy[i][2]=0;
        Tree[2*i] += x*(mid-lo+1); Lazy[2*i][2]+=x;
        Tree[2*i+1]+=x*(hi-mid); Lazy[2*i+1][2]+=x;
    }
}
void update(int i,int lo,int hi,int u,int v,int type,int x) {
    if (v<lo || hi<u) return;
    if (u<=lo && hi<=v) {
        if (type==1) {
            Tree[i]+=sum(hi-lo+1);
            Lazy[i][1]++;
        } else if (type==2) {
            Tree[i]+=x*(hi-lo+1);
            Lazy[i][2]+=x;
        } else if (type==3) {
            Tree[i] = x*(hi-lo+1);
            Lazy[i][3]=x;
            Lazy[i][1]=Lazy[i][2]=0;
        }
        return;
    }
    int mid = (lo+hi) >> 1;
    if (Lazy[i][1]!=0 || Lazy[i][2]!=0 || Lazy[i][3]!=modul) Cal(i,lo,hi);
    update(2*i,lo,mid,u,v,type,x);
    update(2*i+1,mid+1,hi,u,v,type,x);
    Tree[i] = Tree[2*i] + Tree[2*i+1];
}
ll query(int i,int lo,int hi,int u,int v) {
    if (v<lo || hi<u) return 0;
    if (u<=lo && hi<=v) return Tree[i];
    int mid = (lo+hi) >> 1;
    if (Lazy[i][1]!=0 || Lazy[i][2]!=0 || Lazy[i][3]!=modul) Cal(i,lo,hi);
    return query(2*i,lo,mid,u,v) + query(2*i+1,mid+1,hi,u,v);
}
void init(int i,int lo,int hi) {
    Tree[i]=0;
    Lazy[i][1]=Lazy[i][2]=0;
    Lazy[i][3]=modul;
    if (lo==hi) return;
    int mid = (lo+hi) >> 1;
    init(2*i,lo,mid);
    init(2*i+1,mid+1,hi);
}
int main() {
    //freopen("input.txt","r",stdin);
    ios::sync_with_stdio(false);
    for (cin >> stest;stest;stest--) {
        cin >> n >> m;
        init(1,0,n-1);
        For(i,1,m) {
            int type,u,v,x;cin >> type;
            if (type==1) {
                cin >> u >> v;
                update(1,0,n-1,u,v,type,1);
            } else if (type==2 || type==3) {
                cin >> u >> v >> x;
                update(1,0,n-1,u,v,type,x);
            } else {
                cin >> u >> v;
                cout << query(1,0,n-1,u,v) << endl;
            }
        }
    }
    return 0;
}


t = input()
for tc in xrange(t):
    n = input()
    x = []
    for names in xrange(n):
        a = raw_input()
	x.append(a)
    y = set(x)
    count=0
    for names in y:
	if x.count(names)%2!=0:
	    count+=1
    print count	
t=input()
while t!=0:
    a=raw_input()
    s=a[0]
    for i in range(0,len(a)-1):
        if a[i]==a[i+1]:
            s=s+'0'
        else:
            s=s+'1'
    print s
    t-=1
import sys
t=int(sys.stdin.readline())
while t>0:
    t-=1
    n=int(sys.stdin.readline())
    for i in range(n):
        m=int(sys.stdin.readline())
        temp=list(map(int,sys.stdin.readline().split()))
        j=i
        while j<len(temp):
            print temp[j],
            j+=n

#Merging Rivers


def main():

        N = int(raw_input())
        counter = 1
        first_time = True

        while(N != 0):

                if(first_time == False):
                        print

                first_time = False
                last_digit = N%10

                while(last_digit != 1 and last_digit != 3 and last_digit != 9):
                        N+=sum([int(i) for i in str(N)])
                        last_digit = N%10

                print "Case #%d" % counter
                print "first meets river %d at %d" % (N%10,N)

                N = int(raw_input())
                counter+=1

main()

import java.io.*;
class AkashMS 
{

    
    public static void main(String[] args)throws IOException
    {
         DataInputStream d=new DataInputStream(System.in);
         int T=Integer.parseInt(d.readLine());
         
         int flag=0;
         long n=0,m=0,res=1;
         while(T!=0)
         {
             String s[]=d.readLine().split(" ");
             n=Long.parseLong(s[0]);
             m=Long.parseLong(s[1]);
         if(m<=n)
         {
             System.out.println(0);
             T--;
             continue;
         }
         else
         {
             for(int i=2;i<=n;i++)
             {
                 res=res*i;
                 res=res%m;
             }
             System.out.println(res);
             T--;
             m=0;n=0;
             flag=0;res=1;
         }
     
        }
    }
}
#include<stdlib.h>
#include<stdio.h>
#include<string.h> 
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	long long int arr[102][102],brr[102][102],i,j,n,m,t,k,MAX,sum;
	
		scanf("%lld",&t);
while(t--)
{	
	
	for(i=0;i<102;i++)
	{
		
		for(j=0;j<102;j++)
		{
			arr[i][j]=0;
			brr[i][j]=0;
			}

		}


	MAX=0;
		scanf("%lld",&n);
			scanf("%lld",&m);
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		scanf("%lld",&arr[i][j]);

	}
	
	for(i=m-1;i>=0;i--)
	brr[n-1][i]=arr[n-1][i];
	
	/*for(i=n-2;i>=0;i--)
	brr[i][n-1]=arr[i][n-1];*/

	for(i=n-2;i>0;i--)
	{
		for(j=m-1;j>=0;j--)
		{
			if(j==0)
			brr[i][j]=arr[i][j]+max(brr[i+1][j+1],brr[i+1][j]);
			else if(j==m-1)
			brr[i][j]=arr[i][j]+max(brr[i+1][j-1],brr[i+1][j]);
			else
			brr[i][j]=arr[i][j]+max(max(brr[i+1][j+1],brr[i+1][j]),brr[i+1][j-1]);	
		}
	
	}	
	
	MAX=arr[0][0]+max(brr[1][1],brr[1][0]);
	
	for(i=1;i<m-1;i++)
	{
		sum=arr[0][i]+max(brr[1][i-1],max(brr[1][i],brr[1][i+1]));
		if(sum>MAX)
		MAX=sum;
		}
		
	sum=arr[0][m-1]+max(brr[1][m-1],brr[1][m-2]);
	
		if(sum>MAX)
		MAX=sum;
	
	
	printf("%lld\n",MAX);
}
}


#include <iostream>
#include <string.h>
#include <stdio.h>
using namespace std;

void prt(long long int n)
{
	if(n>0)
	{
		n--;
		prt(n/26);

		cout<<char((n%26)+65);
	}
}

int main()
{
    int a;
    long long int r;
    cin>>a;
    while(a!=0)
    {
    cin>>r;
       prt(r);
       cout<<endl; a--;
    }return 0;
}

#include <stdio.h>

int main(void) {
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		int a[n],b[n],i;
		for(i=0;i<n;i++)
		scanf("%d %d",&a[i],&b[i]);
		int j,temp,temp1;
		for(i=0;i<n-1;i++)
		{
			for(j=0;j<n-1-i;j++)
			{
				if(b[j]>b[j+1])
				{
					temp=b[j];
					b[j]=b[j+1];
					b[j+1]=temp;
					temp1=a[j];
					a[j]=a[j+1];
					a[j+1]=temp1;
				}
			}
		}
		int count=1;
		j=1;int k=0;
		while(j<n)
		{
		while(a[j]>=b[k] && j<n)
		{
			count++;
			k=j;
			j++;
		}
		j++;
		}
		printf("%d\n",count);
	}
	// your code goes here
	return 0;
}

#include<stdlib.h>
#include<stdio.h>
#include<string.h> 
#include<iostream>
#include<algorithm>
using namespace std;

char arr[105][105];
long long int n,m;

int fun(long long index,long long i,long long j)
{
	
	if(i>=n||j>=m||i<0||j<0)
	return 0;
	if(arr[i][j]!='C')
	return 0;
	
	arr[i][j]='1';
	fun(index,i+1,j);
	fun(index,i,j+1);
	fun(index,i-1,j);
	fun(index,i,j-1);
	return 1;	
}




int main()
{
	long long int i,j,index,t,ans;
	
	scanf("%lld",&t);
	while(t--)
	{
		index=0;
		scanf("%lld %lld",&n,&m);
		for(i=0;i<n;i++)
		scanf("%s",arr[i]);
		
		for(i=0;i<n;i++)
		{
			for(j=0;j<m;j++)
			{
				if(fun(index,i,j))
				index++;				
				}


		}
	//cout<<index;	
	ans=1;
	for(i=1;i<=index;i++)
	ans=(2*ans)%1000000007;
	
	printf("%lld\n",ans-1);
	
	}



}


#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int count(char *,char *);
int main()
{
	int t;
	char s[100001],c[100001];
	scanf("%d",&t);
	while(t--)
	{
		scanf("%s%s",s,c);
		printf("%d\n",count(s,c));
	}
	return 0;
}
int count(char *strng,char *pat)
{
	if(strlen(strng)<strlen(pat) || strlen(strng)==0 || strlen(pat)==0)
		return 0;
	else
	{
		int count=0,i,j;
		for(i=0;i<strlen(strng)-strlen(pat)+1;i++)
		{
			if(strng[i]==pat[0])
			{
				for(j=1;j<strlen(pat);j++)
				{
					if(strng[i+j]!=pat[j])
						break;
					else if(j==strlen(pat)-1)
						count++;
				}
			}
		}
		return count;
	}
}
#include <iostream>
#include <string.h>
#include<algorithm>

using namespace std;
long long int getSum(long long int n)
{
    long long int sum;
    /*Single line that calculates sum*/
    for(sum=0; n > 0; sum+=n%10,n/=10);
    return sum;
}
int main()
{
    int a;
    long long int ct;
    cin>>a;
    while(a!=0)
    {
        cin>>ct;
        l1:if(ct<=24)
        cout<<ct<<endl;
        else
        {ct=getSum(ct);goto l1;}

a--;

    }return 0;
}

def digsum(n):
        sum = 0
        while (n>0):
                sum = sum + n%10
                n = n//10
        return sum
 
x = int(input())
 
i = 0
 
for i in range(x):
        m = int(input())
        y = 2**m
        z = digsum(y)
        print(z)
tc = int(raw_input())
while (tc>0):
	tc = tc - 1
	n = int(raw_input())
	print 1+pow(2, n-2)

t = input()
for i in range(t):
     f=1
     d = input()
     for j in range(1,d+1):
     	f=f*j
     print f  
#include <stdio.h>

int main(){
	long long int tc,n;
	scanf("%lld",&tc);
	while(tc--){
		scanf("%lld",&n);
		if(n & (n-1))
			printf("Yes\n");
		else
			printf("No\n");
		}
	return 0;
	}
#include <stdio.h>
#define mo 1000000007

int b[50][50];
long long x[70000], y[50], z[50][50];

long long losen(int n)
{
int i, j, k, t;
char c;
for(i=-1; ++i<n;)
	for(j=-1; ++j<n; b[i][j]=scanf(" %c",&c)&&(c=='Y'));
for(x[i=0]=1; ++i<(1<<n); x[i]=0);
for(i=-1; ++i<(1<<n);)
	for(j=-1; ++j<n;)
		if(!(i&(1<<j)))
			{
			for(k=0; k<n&&!(i&(1<<k)&&(b[j][k]==1)); k++);
			if(k==n)
				if((x[t=i^(1<<j)]+=x[i])>=mo) x[t]-=mo;
			}
return x[(1<<n)-1];
}

main()
{
int fall, a, v, w, i, j;
for(y[i=0]=1; ++i<50; y[i]=(i*y[i-1])%mo);
for(i=-1; ++i<50;)
	for(j=!(z[i][i]=z[i][0]=1); ++j<i; z[i][j]=(z[i-1][j]+z[i-1][j-1])%mo);
for(scanf("%d",&fall); fall--; scanf("%d %d %d",&a,&v,&w),printf("%lld\n",((((((((losen(a)%mo)*losen(v)%mo)*losen(w))%mo)*z[a+v+w][a+v])%mo)*z[a+v][a])%mo)));
return 0;
}


#include<iostream>
#include<cstdio>
#include<memory.h>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<string>
#include<map>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<assert.h>
#include<set>
#include<deque>
#include<climits>
#include<utility>

using namespace std;

#define lc(i) (i<<1)
#define rc(i) ((i<<1)+1)
#define iscan(n) scanf("%d",&n)
#define llscan(n) scanf("%lld",&n)
#define cscan(n) scanf("%c",&n)
#define sscan(n) scanf("%s",n)
#define FOR(i,a,b) for(i=a;i<b;++i)
#define MP make_pair
#define PB push_back
#define LL long long
#define _MAX 10000
#define FILL(a,x) memset(a,x,sizeof a)
#define REP(i,n) for(i=0;i<n;++i)

int MOD;
int C[27][27];

int nCr(int n, int r)
{
	if(n < r)
	{
		return 0;
	}
	if(r > n - r)
		r = n-r;
	if(r == 0)
		return 1;
	if(C[n][r] != -1)
		return C[n][r];
	C[n][r] = (nCr(n-1,r-1) + nCr(n-1,r)) % MOD;
	return C[n][r];
}

int a[26];
int n,m;
int bnd;
int dp[(1<<16)][26][26];

int solve(int msk, int rem, int id)
{
	if(rem == 0) return 1;
	if(rem > n-id) return 0;
	if(dp[msk][rem][id] != -1)
		return dp[msk][rem][id];
	int ret = 0;
	for(int i=0;i<=bnd;++i)
	{
		if(!(msk & (1<<i)) && (a[i] & (1<<id)))
			ret += solve(msk|(1<<i),rem-1,id+1);
	}
	ret += solve(msk,rem,id+1);
	return dp[msk][rem][id] = ret%MOD;
}

int F[26];

int fact(int nn)
{
	if(F[nn] != -1)
		return F[nn];
	return F[nn] = (fact(nn-1) * nn)%MOD;
}

int main()
{
	MOD = 10007;
	FILL(C,-1);
	FILL(a,0);
	FILL(dp,-1);
	FILL(F,-1);
	F[0] = 1;
	F[1] = 1;
	int k;
	iscan(n);
	iscan(m);
	iscan(k);
	int i,j;
	REP(i,n)
	{
		REP(j,m)
		{
			int b;
			iscan(b);
			if(b)
			{
				a[j] |= (1<<i);
			}
		}
	}
	sort(a,a+m);
//	REP(i,m)cout<<a[i]<<endl;
	int full = 0;
	i = m-1;
	while(i>=0 && full < 10 && a[i] == (1<<n)-1)
	{
		--i;
		++full;
	}
	bnd = i;
//	cout<<bnd<<" "<<full<<endl;
	int ans = 0,tmp;
	for(i=0;i<=full && i <= k;++i)
	{
		tmp = solve(0,k-i,0);
	//	printf("solve(%d,%d,%d) = %d\n",0,k-i,0,tmp);
		tmp = (tmp * ((nCr(n-k+i,i) * nCr(full,i)) % MOD)) % MOD;
		tmp = (tmp*fact(i)) % MOD;
		ans += tmp;
	}
	printf("%d\n",ans % MOD);
	
	return 0;
}

/*
Success is a matter of hanging on, when others have let go.
Its not who you are, that holds you back, its who you think you are not.
The future belongs to those, who believe in the beauty of their dreams.
*/
//{ /* theCodeGame */
#include<iostream>
#include<cmath>
#include<algorithm>
#include<climits>
#include<vector>
#include<queue>
#include<bitset>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
using namespace std;
#define MOD 1000000007LL
#define LL long long
#define ULL unsigned long long
#define LD long double
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) ((x)*(x))
#define CUBE(x) ((x)*(x)*(x))
#define si(n) scanf("%d",&n)
#define si2(n,m) scanf("%d %d",&n,&m)
#define sf(n) scanf("%f",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
#define slu(n) scanf("%llu",&n)
#define sd(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define pnl printf("\n")
#define REP(i,n) for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define FORR(i,n,e) for(int i=(n);i>=(e);i--)
#define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d))
#define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))
//#undef mydebug
#ifdef mydebug
#define DB(x) cout<<#x<<"="<<(x)<<"\n"
#define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n"
#define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n"
#define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n"
#define pnld pnl;
#else
#define DB(x)
#define DB2(x,y)
#define DB3(x,y,z)
#define DB4(x,y,z,a)
#define pnld
#endif
#define FILL(a,b) memset(a,b,sizeof(a))
const double PI=3.14159265358979323846264338327950288419716939937510582097494459230;
//template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;}
void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";}
void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;}
ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);}
//}
void precompute(){}
void doThis(){
    int n;
    si(n);
    		if(n%2 || n&(n-1))
			cout<<"BMEENA\n";
		else
			cout<<"BKUL\n";
}

int main(){
#ifdef amy
freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr);
#endif
precompute();
int t=1;
scanf("%d",&t);
while(t--){doThis();}
#ifdef amy
fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC));
#endif
return 0;
}

#include<iostream>

using namespace std;
int main(void)
{
    long long int N,ans=0,i;
	cin>>N;
    for(i=1;i<=N;i++)
    {
    	ans += i*(N/i);
    }
    cout<<ans<<endl;
    return 0;
} 
#include<bits/stdc++.h>

//zone
using namespace std;
long long int fact[100005];
int main()
{
    int t;
    int n,c;
    cin >> t;
    long long int val = 1;
    while(t--)
    {
        val = 1;
        cin >> n >> c;
        long long int i;
        for(i = n ; i > n - c ; i--)
        {

            val = val * i;
            val = val % 1000000007;
        }
        cout<<val<<endl;
    }
    return 0;
}
#include<iostream>
#include<cstdio>
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm>

using namespace std;

typedef long long ll;
void convert(ll num, vector <int> &v)
{
	while (num>0)
		v.push_back(num % 10), num /= 10;
	reverse(v.begin(), v.end());
}
int main()
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		ll n, k, sum = 0;
		int i;
		scanf("%lld %lld", &n, &k);
		for (i = 1; i<17; i++)
		{
			sum += i*(pow(10, i) - pow(10, i - 1));
			if (sum>k)
				break;
		}
		sum -= i*(pow(10, i) - pow(10, i - 1));
		int digit = i;
		k -= sum;
		ll num;
		if (k%digit)
		{
			num = k / digit + pow(10, digit - 1);
			k %= digit;
			vector <int> v;
			convert(num, v);
			printf("%d\n", v[k - 1]);
		}
		else
		{
			num = num = k / digit + pow(10, digit - 1) - 1;
			vector <int> v;
			convert(num, v);
			printf("%d\n", v[v.size()-1]);
		}
	}

	return 0;
}

#include<cstdio>
#include<vector>
using namespace std;
vector<int> v[202];
vector<int> vv;
int cc;
int mod=1000000007;
int gcd(int a,int b)
{
	if(b==0) return a;
	if(a<b) return gcd(b,a);
	
	return gcd(b,a%b);
	
}
void proc(int x)
{
	vv.clear();
	
	for(int i=0;i<cc;i++)
	{
		for(int j=0;j<v[i].size();j++)
		{
			if(gcd(x,v[i][j])>1)
			{
				vv.push_back(i);
				break;
			}
		}
	}
}
int get_long()
{
	int r=vv[0];
	int sz=v[vv[0]].size();
	for(int i=1;i<vv.size();i++)
	{
		if(sz<v[vv[i]].size())
		{
			r=vv[i];
			sz=v[vv[i]].size();
		}
	}
	
	return r;
}

int get_max(int x)
{
	int mx=v[x][0];
	for(int i=1;i<v[x].size();i++)
	if(mx<v[x][i]) mx=v[x][i];
	
	return mx;
}
int main()
{

	
	int ntc; scanf("%d",&ntc);
	while(ntc--)
	{
		
		 cc=0;
		int N; scanf("%d",&N);
		for(int i=0;i<202;i++) v[i].clear();
		for(int i=0;i<N;i++)
		{
			int t; scanf("%d",&t);
			proc(t);
			if(vv.size()==0) 
			{
				v[cc].push_back(t);
				cc++;
			}
			else
			{
				
				int l=get_long();
			//	printf("here %d  %d  %d  %d\n",t,vv.size(),l,vv[1]);
				
				v[l].push_back(t);
				
			//	printf("again  %d  %d  %d\n",vv.size(),vv[0],vv[1]);
				for(int i=0;i<vv.size()  ;i++)
				{
					
					if(vv[i]==l) continue;
					//printf("hhh %d\n",i);
					int x=vv[i];
					for(int j=0;j<v[x].size();j++) 
					{
						v[l].push_back(v[x][j]);
					
					}
					v[x].clear();
					
				}
			}
		//	printf("after step  %d %d\n",v[0].size(),v[1].size());
			
		}
		
		long long ans=1;
		
	//	printf("Checking %d %d \n",v[0].size(),v[1].size());
		for(int i=0;i<cc;i++)
		{
			if(v[i].size()>0)
			{
				
				int tmp=get_max(i);
			//	printf("there  %d\n",tmp);
				ans=(ans*tmp)%mod;
			}
		}
		printf("%lld\n",ans);
	}
	
}

#include <bits/stdc++.h>
using namespace std ;

#define MAXN 5 
#define LL long long 
#define sc(x) scanf("%d",&x) 
#define pr(x) printf("%d\n",x) 
#define MOD 1000000007


int res[MAXN][MAXN],Temp[MAXN][MAXN],A[MAXN][MAXN],F[MAXN] , T , N ;



void init(){
	memset(res,0,sizeof res) ;
	memset(A,0,sizeof A) ;
	for(int i=0;i<MAXN;i++)
		res[i][i] = 1 ;
	A[0][1] = A[1][2] = A[2][3] = A[4][4] = 1 ;
}


void mult(int A[MAXN][MAXN],int B[MAXN][MAXN]){

	for(int i=0;i<MAXN;i++){
		for(int j=0;j<MAXN;j++){
			Temp[i][j] = 0 ;
			for(int k=0;k<MAXN;k++){
				Temp[i][j] += (1LL * A[i][k] * B[k][j]) % MOD ;
				Temp[i][j] %= MOD ; 
			}
		}
	}
	for(int i=0;i<MAXN;i++){
		for(int j=0;j<MAXN;j++){
			A[i][j] = Temp[i][j] ;
		}
	}
}

void power(int N){

	while(N){
		if(N&1){
			mult(res,A) ;
		}
		N /= 2 ;
		mult(A,A) ;
	}
}
int main(){

	sc(T) ;
	while(T--){
		sc(N) ;		
		init() ;
		for(int i=0;i<MAXN;i++){
			sc(A[3][i]) ;
			A[3][i] += MOD ;
			A[3][i] %= MOD ;
		}
		swap(A[3][0],A[3][3]) ;
		swap(A[3][1],A[3][2]) ;
		for(int i=0;i<MAXN-1;i++){
			sc(F[i]) ;
			F[i] += MOD ;
			F[i] %= MOD ;
		}
		F[4] = 1 ;
		power(N-1) ;
		int ans = 0 ;
		for(int i=0;i<MAXN;i++){
			ans += (1LL * F[i] * res[0][i]) % MOD ;
			ans %= MOD ;
		}
		pr(ans) ;
	}
	return 0 ; 
}

// waMachine
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int mod = 1e9+7;
ll dp[33][33][33][33];
int arr[33][33];
ll E[33][33],F[33][33];
inline ll solve_top(int pos,int l,int r,int d){
  return d*(E[pos][r]-E[pos][l-1]);
}
inline ll solve_bot(int pos,int l,int r,int d){
  return d*(E[pos][r]-E[pos][l-1]);
}
inline ll solve_lft(int pos,int l,int r,int d){
 return d*(F[r][pos]-F[l-1][pos]);
}
inline ll solve_rgt(int pos,int l,int r,int d){
 return d*(F[r][pos]-F[l-1][pos]);
}
ll solve(int rt,int rb,int cl,int cr,int d){
  //cout << rt << " " << rb << " " << cl << " " << cr << endl;
  if(rt>rb || cl>cr) return 0;
  if(dp[rt][rb][cl][cr] != -1) return dp[rt][rb][cl][cr];
  ll a = solve_top(rt,cl,cr,d) + solve(rt+1,rb,cl,cr,d+1);
  ll b = solve_bot(rb,cl,cr,d) + solve(rt,rb-1,cl,cr,d+1);
  ll c = solve_lft(cl,rt,rb,d) + solve(rt,rb,cl+1,cr,d+1);
  ll e = solve_rgt(cr,rt,rb,d) + solve(rt,rb,cl,cr-1,d+1);
  ll res = max(max(max(a,b),c),e);
  dp[rt][rb][cl][cr] = res;
  return res;
}
int main(){
  //freopen("qns.txt","r",stdin);
  //freopen("ans.txt","w",stdout);
  int t,n,m;
  scanf("%d",&t);
  while(t--){
   memset(dp,-1,sizeof dp);
   scanf("%d %d",&n,&m);
   for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      scanf("%d",&arr[i][j]);
    }
   }
   for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      E[i][j] = E[i][j-1] + arr[i][j];
      F[i][j] = F[i-1][j] + arr[i][j];
    }
   }
   ll ans = solve(1,n,1,m,1);
   printf("%lld\n",ans);
  }
  return 0;
}
import sys
import math

primes = []

for i in range (1000001) :
	primes.append(1)
	
primes[0] = 0
primes[1] = 0
for i in range(1000001) :

	if primes[i] :
	
		j = i*2
		
		while j <= 1000000 :
			
			primes[j] = 0
			j+=i
			

T = int(sys.stdin.readline())

while T :

	N = int(sys.stdin.readline())
	
	rt = int(math.sqrt(N))
	
	if rt*rt == N :
			if primes[rt] == 1 :
				print "YES"
			else :
				print "NO"
		
	else :
	
		print "NO"
		
	T-=1
n=input()
for I in range(n):
    a=input()
    c=map(int,raw_input().split())
    l1=[]
    l2=[]
    for i in range(len(c)):
        if c[i]==-1:
            l1.append(-1)
        if c[i]==1:
            l2.append(1)
    for j in l2:
        l1.append(j)
    for i in l1:
        print i,        
    

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
 
int poly[100][2];
int Up[100][2];
int IF[100];
int N,M,R;
 
int sun();
 
int sum()
{
	double dis,a,b,c;
	double a1,b1,c1;
	int i,j;
	int count=0;
	int xdis;
	int ydis;
	double max;
	long long int sign1,sign2,sign3,sign4;
	max = (R*R);
	
	for(i=0;i<N;i++)
	{
		for(j=0;j<M;j++)
		{
			xdis = (Up[i][0]-poly[j][0]);
			ydis = (Up[i][1]-poly[j][1]);
			dis  = (xdis*xdis)+(ydis*ydis);
			if(dis<=max)
			{
				IF[i] = -1;
				count++;
				break;
			}
		}
	}
	if(M>1)
	for(i=0;i<N;i++)
	{
		if(IF[i]!=-1)
			for(j=0;j<M-1;j++)
			{
				a = poly[j][1] - poly[j+1][1];
				b = poly[j+1][0] -	poly[j][0];
				c = (poly[j][0]*poly[j+1][1])-(poly[j][1]*poly[j+1][0]);
				
				dis = (a*Up[i][0])+(b*Up[i][1])+c;
				dis = dis * dis;
				dis = dis /((a*a)+(b*b));
				
				if(dis<=max)
				{
					sign1 = b*(Up[i][0]-poly[j][0])-a*(Up[i][1]-poly[j][1]);
					sign2 = b*(poly[j+1][0]-poly[j][0])-a*(poly[j+1][1]-poly[j][1]);
					sign3 = b*(Up[i][0]-poly[j+1][0])-a*(Up[i][1]-poly[j+1][1]);
					sign4 = b*(poly[j][0]-poly[j+1][0])-a*(poly[j][1]-poly[j+1][1]);
					if(sign1*sign2>=0&&sign3*sign4>=0)
					{
						count++;
						break;
					}	
				}
			}
	}
	
	return count;
}					
				
main()
{
	int	tc;
	int 	i;
	int  k=1;
	scanf("%d",&tc);
	
	while(k<=tc)
	{
		scanf("%d%d%d",&N,&M,&R);
		
		for(i=0;i<N;i++)
		{
			scanf("%d%d",&Up[i][0],&Up[i][1]);
			IF[i] = 0;
		}	
		for(i=0;i<M;i++)
			scanf("%d%d",&poly[i][0],&poly[i][1]);
		printf("Case #%d: ",k);
		printf("%d\n",sum());
		k++;
	}
	
	return 0;
}				
 
#V 1.01. Forgot to account for uppercase alphabets earlier -_-
T = (int)(raw_input())
while T:
	res = ""
	s = raw_input()
	for i in range(0, len(s)):
    	 if s[i].isalpha():
    	 	if ord(s[i])+1==123:
    		 	res = res + 'a'
    		elif ord(s[i])+1==91:
    			res = res + 'A'
    	 	else:
    	 		res=res+(chr(ord(s[i])+1))
    	print res
	T-=1
#include <iostream>
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int t,n,i,j,m,f;
    int arr[1000];
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d %d",&f,&n,&m);
        for(i=0;i<f;i++)
        {
            scanf("%d",&arr[i]);
        }
        sort(arr,arr+f);
        int mn=arr[0];
        arr[f]=m;
        for(i=1;i<=f;i++)
        {
            if(mn>arr[i]-arr[i-1])
            {
                mn=arr[i]-arr[i-1];
            }
        }
        printf("%d\n",mn*n);
    }
    return 0;
}

#include <bits/stdc++.h>

using namespace std;

long long L,R,INF;
long long karp[100007];
long long hopcroft[100007];
long long ar[100007],pr[100007],X[10000],XX[10000],Y[10000],YY[10000];
vector<long long> adj[100007];


bool Bfs()
{
    queue<long long> q;
    long long i;
    for( i=1;i<=L;i++)
    {
        if( hopcroft[i] ) karp[i] = INF;
        else
        {
            karp[i] = 0;
            q.push( i );
        }
    }
    karp[0] = INF;
    while( !q.empty())
    {
        long long u = q.front();
        q.pop();
        for( i=0;i<adj[u].size();i++)
        {
            long long v = adj[u][i];
            if( karp[hopcroft[v]] == INF )
            {
                karp[hopcroft[v]] = karp[u] + 1;
                q.push( hopcroft[v] );
            }
        }
    }
    return karp[0] != INF;
}
bool Dfs( long long u )
{
    if( !u ) return true;
    long long i;
    for( i=0;i<adj[u].size();i++)
    {
        long long v = adj[u][i];
        if( karp[hopcroft[v]]==karp[u]+1 && Dfs( hopcroft[v] ))
        {
            hopcroft[u] = v;
            hopcroft[v] = u;
            return true;
        }
    }
    karp[u] = INF;
    return false;
}

double dist(long long i,long long j)
{
    double q,w;
    q=X[i]-XX[j];
    w=Y[i]-YY[j];
    return q*q+w*w;
}

int main()
{
    double low,high,mid;
    long long i,j,k,l,cnt,ans,test,q,w,e,r,n,m;

    cin>>n>>m;

    for(i=1;i<=n;i++)
    {
        cin>>X[i]>>Y[i];
    }

    for(i=1;i<=n;i++)
    {
        cin>>XX[i]>>YY[i];
    }

    low=0;
    high=1e10;

    cnt=0;

    while(cnt<=200)
    {
        cnt++;
        mid=low+high;
        mid/=2;

        for(i=0;i<=2*n+5;i++)
        {
            karp[i]=0;
            hopcroft[i]=0;
            adj[i].clear();
        }

        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                if(dist(i,j)>mid*mid)
                {
                    adj[i].push_back(j+n);
                    adj[j+n].push_back(i);
                }
            }
        }

        L=n;
        R=n;

        long long Ans = 0;
        while( Bfs())
        {
            for( i=1;i<=L;i++)
            {
                if( hopcroft[i] ) continue;
                if( Dfs( i ))
                {
                    Ans++;
                }
            }
        }

        if(2*n-Ans>=m) high=mid;
        else low=mid;
    }

    printf("%.10lf\n",mid);
}

#include <bits/stdc++.h>

using namespace std;

#define double long double

long long X[1000009],Y[1000009];
vector<pair<long long,long long> >vec;
map<pair<long long,long long> , long long >mymap;
long long A,N,M;

long long get(long long n,long long m)
{
    if(n-A+1<=0 || m-A+1<=0) return 0;
    return (n-A+1)*(m-A+1);
}

long long check(long long i,long long j)
{
    if(i+1>N || i<0) return 0;
    if(j+1>M || j<0) return 0;
    return 1;
}

int main()
{
    long long n,m,a,c,i,x,y,tot,totsq,q,w,e,r,temp;
    double now,ans=0,tata,pi=acos(-1.0);

    scanf("%lld%lld%lld%lld",&n,&m,&a,&c);
    N=n;
    M=m;
    A=a;

    for(i=1;i<=c;i++)
    {
        scanf("%lld%lld",&X[i],&Y[i]);

        mymap[make_pair(X[i],Y[i])]=1;

        if(check(X[i],Y[i])) vec.push_back(make_pair(X[i],Y[i]));
        if(check(X[i]-1,Y[i])) vec.push_back(make_pair(X[i]-1,Y[i]));
        if(check(X[i],Y[i]-1)) vec.push_back(make_pair(X[i],Y[i]-1));
        if(check(X[i]-1,Y[i]-1)) vec.push_back(make_pair(X[i]-1,Y[i]-1));
    }

    tot=vec.size();

    totsq=get(n,m);
    tata=pi/12.0;
    tata+=sqrt(3.0)/8.0;
    tata*=2;
    //cout<<totsq<<endl;
    //cout<<tata<<endl;
    //tata*=2;

    sort(vec.begin(),vec.end());

    for(i=0;i<tot;i++)
    {
        //cout<<vec[i].first<<" "<<vec[i].second<<endl;
        if(i)
        {
            if(vec[i]==vec[i-1]) continue;
        }

        //cout<<vec[i].first<<" "<<vec[i].second<<endl;

        x=vec[i].first;
        y=vec[i].second;
        q=mymap[make_pair(x,y)];
        w=mymap[make_pair(x,y+1)];
        e=mymap[make_pair(x+1,y)];
        r=mymap[make_pair(x+1,y+1)];

        //cout<<q<<" "<<w<<" "<<e<<" "<<r<<" ";

        temp=totsq-get(x,m)-get(y,n)-get(m-y-1,n)-get(n-x-1,m)+get(x,y)+get(m-y-1,x)+get(m-y-1,n-x-1)+get(n-x-1,y);
        //cout<<temp<<" ";

        if(q+w+e+r>=3) now=temp*1.0;
        else if(q+w+e+r>=2)
        {
            if(q+r>=2 || w+e>=2) now=temp*1.0;
            else now=temp*tata;
        }
        else now=temp*pi/4.0;

        ans+=now;
        //cout<<now<<" u \n";

    }

    //cout<<ans<<endl;

    //cout<<a*a*totsq<<endl;

    ans=ans/(totsq);

    cout<<std::setprecision(10)<<fixed<<ans<<endl;

}

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N = 5e5 + 10;
const int Q = 1e5 + 10;

const int LOG = 20;

#define left LEFt
#define right RIGHT
#define index INDEX
#define copy COPY

vector<int> edge[N];
int n, m;
int father[N][LOG], left[N], right[N], dep[N];

void get_dfs_order() {
	vector<pair<int, int> > stack;
	stack.push_back(make_pair(1, 0));
	father[1][0] = 0;
	
	int index = 0;
	left[1] = ++index;
	dep[1] = 0;
	while (stack.size()) {
		int x = stack.back().first, e = stack.back().second;
		stack.pop_back();
		if (e == edge[x].size()) {
			right[x] = index;
			continue;
		}
		int y = edge[x][e++];
		stack.push_back(make_pair(x, e));
		if (y == father[x][0]) {
			continue;
		} else {
			left[y] = ++index;
			dep[y] = dep[x] + 1;
			stack.push_back(make_pair(y, 0));
			father[y][0] = x;
		}
	}
	
	for (int i = 0; i + 1 < LOG; i++) {
		for (int j = 1; j <= n; j++) {
			father[j][i + 1] = father[father[j][i]][i];
		}
	}
}

const int POOL = (int)(Q * 0.55 * LOG * LOG * 4);

struct Node {
	int lchild, rchild, sum;
	Node(int lchild, int rchild, int sum) : lchild(lchild), rchild(rchild), sum(sum) {
	}
	Node() {}
}pool[POOL];
int used = 0;

int copy;

int build_inner(int l, int r) {
	int x = used++;
	Node& tmp = pool[x];
	if (l == r) {
		tmp.sum = 0;
		tmp.lchild = tmp.rchild = -1;
	} else {
		int mid = (l + r) >> 1;
		tmp = Node(build_inner(l, mid), build_inner(mid + 1, r), 0);
	}
	return x;
}

struct ONode {
	int lchild, rchild, root;
	ONode(int lchild, int rchild, int root) : lchild(lchild), rchild(rchild), root(root) {}
	ONode() {}
}Opool[Q * LOG * 4];
int Oused = 0;

int root[Q];

int build_outter(int l, int r) {
	int x = Oused++;
	ONode& tmp = Opool[x];
	if (l == r) {
		tmp.root = copy;
		tmp.lchild = tmp.rchild = -1;
	} else {
		int mid = (l + r) >> 1;
		tmp = ONode(build_outter(l, mid), build_outter(mid + 1, r), copy);
	}
	return x;
}

struct Query {
	int type, u, v, w, k;
	Query() {}
}query[Q];

int get_lca(int u, int v) {
	if (dep[u] < dep[v]) {
		swap(u, v);
	}
	for (int i = LOG - 1; i >= 0; i--) {
		if (dep[u] - (1 << i) >= dep[v]) {
			u = father[u][i];
		}
	}
	if (u == v) {
		return u;
	}
	for (int i = LOG - 1; i >= 0; i--) {
		if (father[u][i] != father[v][i]) {
			u = father[u][i];
			v = father[v][i];
		}
	}
	return father[u][0];
}

int insert_inner(int rt, int l, int r, int pos, int delta) {
	int x = used++;
	Node& tmp = pool[x];
	tmp = pool[rt];
	
	tmp.sum += delta;
	
	if (l == r) {
		return x;
	} else {
		int mid = (l + r) >> 1;
		if (pos <= mid) {
			tmp.lchild = insert_inner(tmp.lchild, l, mid, pos, delta);
		} else {
			tmp.rchild = insert_inner(tmp.rchild, mid + 1, r, pos, delta);
		}
	}
	return x;
}

int insert(int rt, int l, int r, int pos, int w, int delta) {
	int x = Oused++;
	ONode& tmp = Opool[x];
	tmp = Opool[rt];
	
	tmp.root = insert_inner(tmp.root, 0, m - 1, w, delta);
	
	if (l == r) {
		return x;
	}
	
	int mid = (l + r) >> 1;
	if (pos <= mid) {
		tmp.lchild = insert(tmp.lchild, l, mid, pos, w, delta);
	} else {
		tmp.rchild = insert(tmp.rchild, mid + 1, r, pos, w, delta);
	}
	return x;
}

void get_node(int x, int l, int r, int ql, int qr, vector<int> &ret) {
	if (r < ql || qr < l) {
		return;
	}
	if (ql <= l && r <= qr) {
		ret.push_back(Opool[x].root);
		return ;
	}
	int mid = (l + r) >> 1;
	get_node(Opool[x].lchild, l, mid, ql, qr, ret);
	get_node(Opool[x].rchild, mid + 1, r, ql, qr, ret);
}

int solve(int l, int r, int x, int k) {
	static vector<int> rnode, lnode;
	rnode.clear(); get_node(root[r], 1, n, left[x], right[x], rnode);
	lnode.clear(); get_node(root[l - 1], 1, n, left[x], right[x], lnode);
	
	{
		int tot = 0;
		for (int i = 0; i < rnode.size(); i++) tot += pool[rnode[i]].sum;
		for (int i = 0; i < lnode.size(); i++) tot -= pool[lnode[i]].sum;
		if (tot < k) {
			return -1;
		}
	}
	
	int lv = 0, rv = m - 1;
	while (lv < rv) {
		int lsum = 0, dir = 0;
		for (int i = 0; i < rnode.size(); i++) lsum += pool[pool[rnode[i]].lchild].sum;
		for (int i = 0; i < lnode.size(); i++) lsum -= pool[pool[lnode[i]].lchild].sum;
		int mid = (lv + rv) >> 1;
		if (lsum < k) {
			k -= lsum;
			dir = 1;
			lv = mid + 1;
		} else {
			dir = 0;
			rv = mid;
		}
		
		for (int i = 0; i < rnode.size(); i++) {
			rnode[i] = dir ? pool[rnode[i]].rchild : pool[rnode[i]].lchild;
		}
		for (int i = 0; i < lnode.size(); i++) {
			lnode[i] = dir ? pool[lnode[i]].rchild : pool[lnode[i]].lchild;
		}
	}
	return lv;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i < n; i++) {
		int u, v;
		scanf("%d %d", &u, &v);
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	
	get_dfs_order();
	
	vector<int> values;
	
	int q;
	scanf("%d", &q);
	for (int i = 1; i <= q; i++) {
		int type;
		scanf("%d", &type);
		query[i].type = type;
		if (type == 1) {
			int u, v, w;
			scanf("%d %d %d", &u, &v, &w);	
			query[i].u = u;
			query[i].v = v;
			query[i].w = w;
			values.push_back(w);
		} else {
			int x, l, r, k;
			scanf("%d %d %d %d", &x, &l, &r, &k);
			query[i].u = l;
			query[i].v = r;
			query[i].k = k;
			query[i].w = x;
		}
	}
	
	sort(values.begin(), values.end());
	values.erase(unique(values.begin(), values.end()), values.end());
	m = values.size();
	
	copy = build_inner(0, m - 1);
	root[0] = build_outter(1, n);
	
	for (int i = 1; i <= q; i++) {
		if (query[i].type == 1) {
			int u = query[i].u;
			int v = query[i].v;
			int w = query[i].w;
			w = lower_bound(values.begin(), values.end(), w) - values.begin();
			int lca = get_lca(u, v);
			if (dep[u] > dep[v]) swap(u, v);
			
			root[i] = insert(root[i - 1], 1, n, left[v], w, 1);
			if (u != lca) {
				root[i] = insert(root[i], 1, n, left[u], w, 1);
				root[i] = insert(root[i], 1, n, left[lca], w, -1);
			}
			if (father[lca][0]) root[i] = insert(root[i], 1, n, left[father[lca][0]], w, -1);
		} else {
			int l = query[i].u;
			int r = query[i].v;
			int x = query[i].w;
			int k = query[i].k;
			root[i] = root[i - 1];
			int ret = solve(l, r, x, k);
			printf("%d\n", ret == -1 ? ret : values[ret]);
		}
	}
	
	return 0;
}
#include <iostream>
#include <cstdio>
#include <vector>
#include <string>
#include <map>
#include <cstring>

using namespace std;

#define si(a) scanf("%d",&a)
#define f first
#define s second
#define MAX 10005

vector<int> graph[MAX];
int dp[MAX][2],hoite_hobe[MAX];

int go(int now,int wh)
{
    if(graph[now].size()==0){
        return hoite_hobe[now]!=wh;
    }
    int &ret=dp[now][wh];
    if(ret!=-1)
        return ret;
    int tmp1=1,tmp2=0;
    int i;
    for(i=0;i<graph[now].size();i++){
        int to=graph[now][i];
        tmp1+=go(to,!wh);
        tmp2+=go(to,wh);
    }
    return ret=min(tmp2,tmp1);
}

map<string,int> all[MAX];
char str[1005];
bool vis[MAX];


void solve(void)
{
    memset(dp, -1, sizeof(dp));
    memset(vis, 0, sizeof(vis));
    int n,i,j;
    si(n);
    int cnt=1;
    char ss[20];

    for(i=0;i<n;i++){
        scanf("%s",ss);
        scanf("%s",str);
        int len=strlen(str);
        int pr = -1, prnd = 0;
        for(j=0;j<=len;j++)
            if(str[j] == '/' || j == len) {
                if(pr != -1) {
                    string x(str, pr, j-pr);
                    if(all[prnd].find(x) == all[prnd].end()) all[prnd][x] = cnt++;
                    int nd = all[prnd][x];
                    if(!vis[nd]) {
                        graph[prnd].push_back(nd);
                        //printf("add: %d to %d\n", prnd, all[x]);
                    }
                    prnd = nd;
                    vis[prnd] = true;
                }
                pr = j+1;
            }
        hoite_hobe[prnd] = !strcmp(ss, "stage");
    }
/*
    for(map <string, int>::iterator it = all.begin(); it != all.end(); it++) {
        printf("%s %d\n", it->f.c_str(), it->s);
    }
*/
    printf("%d\n", go(0, 0));
    //cout<<endl;
    for(i = 0; i < cnt; i++) {
        graph[i].clear();
        all[i].clear();
    }
}

int main()
{
    //freopen("inp.txt", "r", stdin);
    int t;
    si(t);
    while(t--) solve();

    return 0;
}

#include <bits/stdc++.h>
	
using namespace std;
	
#ifndef ONLINE_JUDGE
	bool debug = false;
#else
	bool debug = true;
#endif
	
typedef long long unsigned llu;
typedef long long lld;
typedef long ld;
 
//definition
 
//macros
#define vi  	vector < int >
#define vld 	vector < ld >
#define vlld 	vector < lld >
#define vllu 	vector < llu >
#define pii 	pair <int, int>
#define plld 	pair<lld, lld>
#define vpii 	vector< pii >
#define vplld 	vector< plld >
 
#define gc  	getchar_unlocked
#define pc  	putchar_unlocked
#define rr  	freopen("input.txt", "r", stdin)
#define wr  	freopen("output.txt", "w", stdout)
 
//important constants
#define MOD 	1000000007
#define INF  	1LL<<57LL
#define MAX 	1000001
#define pi  	M_PI
#define ESP 	(1e-9)
 
//looping
#define fr(i,a)         	for(i=0;i<a;i++)
#define fe(i,a)         	for(i=0;i<=a;i++)
#define fu(i,a,n)       	for(i=a;i<n;i++)
#define fue(i,a,n)      	for(i=a;i<=n;i++)
#define fd(i,n,a)       	for(i=n;i>a;i--)
#define fde(i,n,a)      	for(i=n;i>=a;i--)
#define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
 
//input output
#define sd(n) 		scanf("%d",&n)
#define sld(n) 		scanf("%ld",&n)
#define slld(n) 	scanf("%lld",&n)
#define pfd(n) 		printf("%d",n)
#define pfld(n) 	printf("%ld",n)
#define pflld(n) 	printf("%lld",n)
 
//shortcut
#define ff      	first
#define ss      	second
#define clr     	clear()
#define pb      	push_back
#define mp      	make_pair
#define gcd(a,b)	__gcd(a,b)
#define sz(a)		((int)(a.size()))
#define len(a)		((int)a.length())
#define all(vi)		vi.begin(), vi.end()
#define mem(i,n)	memset(i,n,sizeof(i))
#define IOS     	ios_base::sync_with_stdio(false); cin.tie(NULL)
 
#define imax 	numeric_limits<int>::max()
#define imin 	numeric_limits<int>::min()
#define ldmax 	numeric_limits<ld>::max()
#define ldmin 	numeric_limits<ld>::min()
#define lldmax 	numeric_limits<lld>::max()
#define lldmin 	numeric_limits<lld>::min()
//end of definition
 
const int dx[]={0,1,0,-1,1,1,-1,-1,0};
const int dy[]={1,0,-1,0,-1,1,1,-1,0};
 
template<typename X> inline X square(const X& a) { return a * a; }
 
 
//fast input
 
int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;}
ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;}
lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;}
llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;}
 
//end of fast input
 
//fast output
 
//no line break
void print_d(int n)     	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);}
void print_ld(ld n)     	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);}
void print_lld(lld n)     	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}
void print_llu(llu n)     	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}
 
//new line
void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);}
void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);}
void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
 
//special char
char sp;
void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);}
void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);}
void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
 
//end of fast output

#define SSTR( x ) static_cast< std::ostringstream & >( \
        ( std::ostringstream() << std::dec << x ) ).str()

lld dp[5005][5005],a[5005];
int n;

lld jump(int i,int x)
{
	if(dp[i][x]!=-1)
		return dp[i][x];
	if(i==x)
		return 0;
	if(i<x)
	{
		dp[i][x]=jump(i,x-1);
		if(a[i]>a[x])
			dp[i][x]=max(dp[i][x],1+jump(x,i+1));
	}
	else
	{
		dp[i][x]=jump(i,x+1);
		if(a[i]>a[x])
			dp[i][x]=max(dp[i][x],1+jump(x,i-1));
	}
	return dp[i][x];
}

int main()
{
	sp=' ';
	mem(dp,-1);
	int i;
	n=scan_d();
	fr(i,n)
		a[i]=scan_lld();
	fr(i,n)
		printsp_lld(max(jump(i,0),jump(i,n-1)));
	return 0;
}

#include <bits/stdc++.h>
	
using namespace std;
	
#ifndef ONLINE_JUDGE
	bool debug = false;
#else
	bool debug = true;
#endif
	
typedef long long unsigned llu;
typedef long long lld;
typedef long ld;
 
//definition
 
//macros
#define vi  	vector < int >
#define vld 	vector < ld >
#define vlld 	vector < lld >
#define vllu 	vector < llu >
#define pii 	pair <int, int>
#define plld 	pair<lld, lld>
#define vpii 	vector< pii >
#define vplld 	vector< plld >
 
#define gc  	getchar_unlocked
#define pc  	putchar_unlocked
#define rr  	freopen("input.txt", "r", stdin)
#define wr  	freopen("output.txt", "w", stdout)
 
//important constants
#define MOD 	1000000007
#define INF  	1LL<<57LL
#define MAX 	1000001
#define pi  	M_PI
#define ESP 	(1e-9)
 
//looping
#define fr(i,a)         	for(i=0;i<a;i++)
#define fe(i,a)         	for(i=0;i<=a;i++)
#define fu(i,a,n)       	for(i=a;i<n;i++)
#define fue(i,a,n)      	for(i=a;i<=n;i++)
#define fd(i,n,a)       	for(i=n;i>a;i--)
#define fde(i,n,a)      	for(i=n;i>=a;i--)
#define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
 
//input output
#define sd(n) 		scanf("%d",&n)
#define sld(n) 		scanf("%ld",&n)
#define slld(n) 	scanf("%lld",&n)
#define pfd(n) 		printf("%d",n)
#define pfld(n) 	printf("%ld",n)
#define pflld(n) 	printf("%lld",n)
 
//shortcut
#define ff      	first
#define ss      	second
#define clr     	clear()
#define pb      	push_back
#define mp      	make_pair
#define gcd(a,b)	__gcd(a,b)
#define sz(a)		((int)(a.size()))
#define len(a)		((int)a.length())
#define all(vi)		vi.begin(), vi.end()
#define mem(i,n)	memset(i,n,sizeof(i))
#define IOS     	ios_base::sync_with_stdio(false); cin.tie(NULL)
 
#define imax 	numeric_limits<int>::max()
#define imin 	numeric_limits<int>::min()
#define ldmax 	numeric_limits<ld>::max()
#define ldmin 	numeric_limits<ld>::min()
#define lldmax 	numeric_limits<lld>::max()
#define lldmin 	numeric_limits<lld>::min()
//end of definition
 
const int dx[]={0,1,0,-1,1,1,-1,-1,0};
const int dy[]={1,0,-1,0,-1,1,1,-1,0};
 
template<typename X> inline X square(const X& a) { return a * a; }
 
 
//fast input
 
int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;}
ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;}
lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;}
llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;}
 
//end of fast input
 
//fast output
 
//no line break
void print_d(int n)     	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);}
void print_ld(ld n)     	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);}
void print_lld(lld n)     	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}
void print_llu(llu n)     	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}
 
//new line
void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);}
void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);}
void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
 
//special char
char sp;
void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);}
void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);}
void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}
 
//end of fast output

#define SSTR( x ) static_cast< std::ostringstream & >( \
        ( std::ostringstream() << std::dec << x ) ).str()

int main()
{
	int aa,ab,ba,bb,t,n,i;
	string x,ans;
	t=scan_d();
	while(t--)
	{
		ans="";
		aa=ab=ba=bb=0;
		n=scan_d();
		while(n--)
		{
			getline(cin,x);
			if(x=="aa")
				aa++;
			else if(x=="bb")
				bb++;
			else if(x=="ba")
				ba++;
			else
				ab++;
		}
		fr(i,aa/2)
			ans+="aa";
		ab=min(ab,ba);
		fr(i,ab)
			ans+="ab";
		fr(i,bb/2)
			ans+="bb";
		if(aa&1)
			ans+="aa";
		else if(bb&1)
			ans+="bb";
		fr(i,bb/2)
			ans+="bb";
		fr(i,ab)
			ans+="ba";
		fr(i,aa/2)
			ans+="aa";
		cout<<ans<<endl;
	}
	return 0;
}

for _ in xrange(input()):
    n=input()
    ans="YES"
    a=sorted(map(int, raw_input().split()))
    for i in xrange(1, n):
        if a[i]==a[i-1]:
            ans="NO"
            break
    print ans

# your code goes here
i_num = int(raw_input())
Nvar, Mvar = 0,0
def step_calc(pos_var, step):
	pos_var += step
	if pos_var <= Mvar:
		return pos_var
	pos_var -= Mvar
	return Mvar + (pos_var%(Nvar - Mvar + 1))
	
for i_var in xrange(i_num):
    i_line = raw_input().split(' ')
    i_line = [int(item) for item in i_line]
    Nvar, Mvar = i_line[0], i_line[1]
    S_var = i_line[2]
    Pvar, Qvar = i_line[3], i_line[4]
    coinc_num = 0
    Pcurr, Qcurr = 0,0
    for t_var in xrange(S_var):
        Pcurr = step_calc(Pcurr, Pvar)
        Qcurr = step_calc(Qcurr, Qvar)
        if Pcurr == Qcurr:
            coinc_num += 1
    print(coinc_num)
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

#define si(a) scanf("%d",&a)
#define MOD 1000000007

int dp[5005][5005];
int jog[5005];

int mod_mul(long long a,long long b)
{
    return (a*b)%MOD;
}

int mod_plus(int a,int b)
{
    return (a+b)%MOD;
}

int main()
{
    int i,j;
    for(i=1;i<5005;i++){
        int sm=1;
        for(j=1;j<5005;j++){
            dp[j][i]=mod_mul(26,sm);
            int ttt=sm;
            sm=mod_plus(jog[j],sm);
            jog[j]=mod_plus(jog[j],mod_mul(25,ttt));
        }
    }
    for(i=0;i<5005;i++)
        for(j=1;j<5005;j++)
            dp[i][j]=mod_plus(dp[i][j],dp[i][j-1]);
    int t;
    si(t);
    for(int ca=1;ca<=t;ca++){
        int x;
        si(x);
        int ans=0;
        for(i=0;i<=x;i++)
            ans=mod_plus(ans,dp[i][x]);
        printf("%d\n",ans);
    }
    return 0;
}

def sort_array ( array , length):
    for c in range(0,length-1):
        for d in range(0,length-c):
            if array[d] > array[d-1] :
                temp=array[d]
                array[d]=array[d-1]
                temp = array[d-1]
 
a1 = raw_input()
a = list(a1)
b1 = raw_input()
b = list(b1)
l1=len(a)
l2=len(b)
 
if l1 != l2 :
    print "No"
else :
    sort_array(a,l1);
    sort_array(b,l2);
    flag=1
    for i in range(0,l1):
        if a[i] != b[i] :
            flag=0
            break
    if flag == 1 :
        print "Yes"
    else :
        print "No"
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define MOD 1000000007

ll n, m;

ll sub(ll x, ll y) {
	//returns x - y;
	x = x % MOD;
	y = y % MOD;
	return (x + MOD -y) % MOD;
}

ll apsum(ll p, ll q) {
	ll m = ((p%MOD) * ((q-p+1)%MOD))%MOD;;
	if (p == q)
		return m;
	// ap sum
	ll s = (q-p);
	ll t = s + 1;
	if (s % 2 == 0) s/=2LL;
	else t/=2LL;
	s = ((s%MOD) * (t % MOD))%MOD;
	return (s +  m) % MOD;
}

int main() {
	cin >> n >> m;

	if (m <= n/m) {
		ll s =0;
		for (int i = 1; i <= m; i++)
			s = (s + (n % i))%MOD;
		cout <<s <<endl;
		return 0;
	}
	ll s = 0;
	ll df = 0;
	if (m > n) {
		df = (df + ((m -n)%MOD * (n%MOD)))%MOD;
		m = n;
	}
	//cout <<s<<" "<<n <<" "<<m << endl;

	for (ll i = 1; i * i <= n; i++) {
		//cout <<i<<endl;
		ll tmp1 = (((n/i))%MOD*i)%MOD;

		s = (s + tmp1)%MOD;
		//cout <<i <<" " <<tmp1<<endl;

		ll re = n/i;
		ll lft = n /(i+1);
		
		lft ++;
		re = min(re, m);
		//cout <<lft<<"***"<<re<<endl;

		if (lft > re) continue;
		if (n/i == i) continue;

		ll tmp2 = (apsum(lft, re)*i) % MOD;
		s = (s+ tmp2)%MOD;
		//cout <<i <<" " << tmp2<<"&&"<<endl;
	}
	//cout <<"&&&\n";

	//cout <<s <<endl;
	ll tmp = ((m%MOD)*(n%MOD))%MOD;

	cout <<(tmp -s + df + MOD + MOD)%MOD <<endl;
	return 0;
}
import sys

number_of_testcases = int(sys.stdin.readline())

for num in range(number_of_testcases):
  size_of_array = int(sys.stdin.readline())
  my_array = map(int, sys.stdin.readline().split())
  sorted_my_array = sorted(my_array)
  op = ""
  while(len(sorted_my_array)>0):
    op += "%d "%sorted_my_array.pop(0)
    if len(sorted_my_array)>0:
      op += "%d "%sorted_my_array.pop(-1)
  print op 
  
#Enter your code here

import math
def prime(n):
    count=0
    while(n%2==0):
        count+=1
        n/=2
    for i in range(3,int(math.sqrt(n))+1,1):
        while (n%i==0):
            count+=1
            n/=i
    if n>2:
        count+=1
    return count
t=int(raw_input())
for i in xrange(t):
    n=int(raw_input())
    print prime(n)
#include <iostream>
#include <cstdio>

typedef long long ll;

using namespace std;

inline int test()
{
    ll p, c;
    scanf("%lld %lld",&p, &c);
    c++;
    ll n = p/c;
    ll mod = p%c;
    if (mod)
    {
        n++;
    }
    //if (c>p){printf("1\n"); return 0;}
    printf("%lld\n",n);

    return 0;
}

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        test();
    }

    return 0;
}

#include<stdio.h>
int main()
{

    int i,j,k,h,T;
    scanf("%d",&T);
    int a[T];
    for(i=0;i<T;i++)
    {
        scanf("%d",&a[i]);
    }
    for(k=0;k<T;k++)
    {
       h=a[k];

    for(i=h;i>=1;i=i-2)
    {
        for(j=h;j>i;j--)
        printf(" ");
        for(j=1;j<=i;j++)
        printf(".");
        for(j=1;j<=h;j++)
        printf(".");
        if(i==h-4)
        {
              for(j=1;j<=h-7;j++)
              printf(" ");
              for(j=1;j<=6;j++)
              printf(".");
              for(j=1;j<=h-7;j++)
              printf(" ");

        }
        else if(i==h-2)
        {
            for(j=1;j<=h-6;j++)
            printf(" ");
            printf(".  .");
            for(j=1;j<=h-6;j++)
            printf(" ");
        }
        else if(i!=h)
        {
            for(j=1;j<=2*h-8;j++)
            printf(".");
        }
        else
        {
            for(j=1;j<=2*h-8;j++)
            printf(" ");
        }

        for(j=1;j<=h;j++)
            printf(".");
        for(j=1;j<=i;j++)
            printf(".");
             printf("\n");
    }


    for(i=h;i>=1;i=i-2)
    {
        for(j=1;j<=2*h-4;j++)
        printf(" ");
        for(j=h;j>i;j--)
        printf(" ");
        for(j=1;j<=2*i;j++)
        printf(".");
        printf("\n");
    }
printf("***\n");
    }

    return 0;
}

#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;

long long int mypow(long long int a, int b)
{
	if(b==0)
		return 1;
	long long int temp = a*a;
	if(b%2==0)
		return mypow(temp,b/2);
	return a*mypow(temp,b/2);
}

bool exists(long long int n,int b)
{
	double cand = pow(n,1/(double)b);
	long long int c1 = cand;
	if(mypow(c1,b)==n || mypow(c1+1,b)==n)
		return true;
	return false;
}

int main()
{
	int t;
	long long int n;
	scanf("%d",&t);
	//printf("T recieved was %d\n",t);
	for(int l=0;l<t;l++)
	{
	//	printf("%d inputs remaining\n",t-l);
		scanf("%lld",&n);
	//	printf("N recieved was %d\n",n);
		int lim = log(n)/log(2) + 1;
		bool done = false;
		for(int i = lim;i>=2;i--)
		{
			if(exists(n,i))
			{
				printf("YES\n");
				done = true;
				break;
			}
		}
		if(!done)
		{
			printf("NO\n");
		}
	}
	//printf("DOne\n");
	return 0;
}
t=int(raw_input())
for i in xrange(t):
	a,b,sum=map(int,raw_input().split())
	n=2*sum/(a+b)
	d=(b-a)/(n-5)
	a1=a-2*d;
	print n
	for j in xrange(n):
		print a1+j*d,
	print 

for i in xrange(input()):
    st=raw_input().split()[0]
    ords=0
    for k in xrange(0,len(st)):
        ords=ords+ord(st[k])
    ords=ords/len(st)
    print chr(ords)
        

from math import *
 
t=int(raw_input())
 
for x in range(0,t):
    
    n=int(raw_input())
    
    sum=0
    
    foo=n
    
    while(foo>0):
        
        sum=sum+ (foo%10)
        
        foo=foo//10
        
    
    ans=n%sum
    
    print(ans) 
#! /usr/bin/python


# imports
import sys
import StringIO


class Problem(object):
    def __init__(self, reader):        
        self.reader = reader

    def run(self):                        
        test_case_count = int(self.reader.readline().strip())
        for test_case in range(test_case_count):
            text = self.reader.readline().strip()
            character_sum = self.get_character_sum(text)
            closest_power = self.get_closest_power_of_2(character_sum)
            print (character_sum - closest_power)

    def get_character_sum(self,  text):
        char_sum = 0
        for char in text:
            char_sum += ord(char)
            
        return int(char_sum)
            
    def get_closest_power_of_2(self,  max_limit):
        power_value = 1
        while power_value < max_limit :
            power_value *= 2
        
        return int(power_value / 2)

# Main entry point
############################################################ 
if __name__ == "__main__":

    data = sys.stdin

    problem = Problem(data)
    problem.run();

from math import *

t=int(raw_input())

for x in range(0,t):
    
    n=int(raw_input())
    
    sum=0
    
    foo=n
    
    while(foo>0):
        
        sum=sum+ (foo%10)
        
        foo=foo//10
        
    foobar=int(pow(2,sum))
    
    ans=foobar*n
    
    print(ans)
#include<iostream>
using namespace std;
int main()
{
	int i;
	char c;
	cin>>i;
	c=i+97;
	cout<<c;
	return 0;
}
a,b,c=map(int,raw_input().split())
while True:
    if a==0 and b==0 and c==0:
        break
    x1=b-a
    x2=c-b
    if x1==x2:
        print "AP",c+x1
    else:
        print "GP",int((c*c)/float(b))
    a,b,c=map(int,raw_input().split())    
t=int(input())
while(t):
	str=raw_input()
	ans=0
	if '+' in str:
		b=str.split('+')
		ans=int(b[0])+int(b[1])
	else:
		b=str.split('-')
		ans=int(b[0])-int(b[1])
	print ans
	t=t-1
from math import *
n = int(raw_input())
print factorial(2*n-1)/(factorial(n)*factorial(n-1))

t = int(raw_input())
 
while t:
	n = int(raw_input())
	pos = []
	dig = ['0','d','h','a','p','u','s','v']
	while n!=0:
		d = n % 7
		n = n / 7
		pos.append(d)
	
	pos.reverse()
	
	word = ''
	for i in pos:
		word += dig[i]
	print word
	
	t -= 1 
t=input()
while t!=0:
    n,c=raw_input().split(' ')
    n=int(n)
    c=int(c)
    s=0
    flag=0
    d=1
    first=0
    last=0
    while d<=2:
        first=(2*c-n*(n-1)*d)/(2*n)
        if first<1:
            flag=0
            break
        
        last=first+(n-1)*d
        s=n*(first + last)/2
        
        if s==c:
            flag=1
            break
            
        d=d+1
    
    if flag==0:
        print "No"
    
    else:
        print "Yes"

    t=t-1

    

#define MAX 10000001
#define MOD 10007
char primes[MAX];
int ans[MAX];
int i,j,k;
void init(){
    long long j;
    for(i=2;i<MAX;i++) primes[i]='1';
    for(i=4;i<MAX;i+=2) primes[i]='0';
    for(i=3;i<=sqrt(MAX);i+=2){
        if(primes[i]=='1'){
            for(j=(long long)(i*i);j<MAX;j+=i) primes[j]='0';
        }
    }
    ans[2]=1;
    for(i=3;i<MAX;i++) if(primes[i]=='1') ans[i]=1+ans[i-1]; else ans[i]=ans[i-1];
}
int power(int pow){
    int res=1;
    int pw=2;
    while(pow){
        if(pow&1) res=(res*pw)%MOD;
        pw=(pw*pw)%MOD;
        pow>>=1;
    }
    return res;
}
int main(){
    int n;init();
    while(~scanf("%d",&n)){
        printf("%d\n",(n==1)?0:power(ans[n]-1));
    }
    return 0;
}
import sys
for i in xrange(int(sys.stdin.readline())):
    n,m=map(int,sys.stdin.readline().split(' '))
    x,y=[],[]
    for j in xrange(m):
        X,Y=map(int,sys.stdin.readline().split(' '))
        x.append(X)
        y.append(Y)
    if n in y:
        b=x[y.index(n)]
        if b==n-1:
            if (n-1 in y):
                print 1
            else:
                print 2,n-1
        else:
            if x.count(b)==n-b and b not in y:
                print 2,b
            else:
                print 1
    else:
        print 2,n
import math
t=input("")
while(t):
	inp=raw_input("")
	inp=inp.split()
	n=int(inp[0]);k=int(inp[1]);m=int(inp[2])
	m=m/n;
	if(m>0):
		print int(math.log(m,k))
	else:
		print 0
	t=t-1

#include <stdio.h>
int cal(char *a,char *b,int m,int n)
{
    int result=0,i,j;
    int dp[m+1][n+1];
    for(i=0;i<=m;i++)
    {
        
        for(j=0;j<=n;j++)
        {
            
            if(i==0 || j==0)
            dp[i][j]=0;
            
            else if(a[i-1]==b[j-1])
            dp[i][j]=dp[i-1][j-1]+1;
            
            else
            dp[i][j]=0;
            
            result=result>dp[i][j]?result:dp[i][j];
        }
        
    }
    
    return result;
    
}
int main(void) {
	// your code goes here
	int m,n;
	scanf("%d %d",&m,&n);
	char a[m],b[n];
	scanf("%s",a);
	scanf("%s",b);
	int ans=cal(a,b,m,n);
	printf("%d\n",ans);
	return 0;
}


/*	Template by
	Ashwin Kumar
	IIT Delhi */
#include<algorithm>
#include<iostream>
#include<cassert>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<string>
#include<ctime>
#include<deque>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<vector>	
using namespace std;

typedef pair<int, int> pii;
typedef long long LL;
#define MOD 1000000007
#define INF 1000000000

vector<int> adj[500];
vector<int> deg;
int visited[500];

void dfs(int i) {
	visited[i] = 1;
	deg.push_back(adj[i].size());
	for (int j = 0; j < adj[i].size(); j++)
		if (!visited[adj[i][j]])
			dfs(adj[i][j]);
}

int main() {
	int T;
	scanf("%d", &T);
	for (int t = 0; t < T; t++) {
		int N, M, u, v;
		scanf("%d %d", &N, &M);
		for (int i = 0; i < N; i++)
			adj[i].clear();
		for (int i = 0; i < M; i++) {
			scanf("%d %d", &u, &v);
			adj[u-1].push_back(v-1);
			adj[v-1].push_back(u-1);
		}
		memset(visited, 0, sizeof visited);
		int cnt = 0;
		int good = 1;
		for (int i = 0; i < N; i++) {
			if (!visited[i]) {
				deg.clear();
				dfs(i);
				int n = deg.size();
				if (n > 1) {
					cnt++;
					sort(deg.begin(), deg.end(), greater<int>());
					int m = -1;
                    for (int j = 1; j <= n; j++)
                 		if (deg[j-1] >= j-1)
                    		m = j;
              		int a = 0, b = 0;
              		for (int j = 1; j <= m; j++)
             			a += deg[j-1]; 
              		for (int j = m+1; j <= n; j++)
              			b += deg[j-1];
              		if (a != m*(m-1)+b) {
              			good = 0;
              			break;
              		}
				}
			}
		}
		if (cnt > 2)
			good = 0;
		if (!good)
			printf("NO\n");
		else
			printf("YES\n");
	}
	return 0;
}

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Arrays;

public class Main {
	private static int mutationLength(int n) {
		HashSet<String> set = new HashSet<String> ();
		String s = "" + n;
		while (!set.contains(s)) {
			set.add(s);
			char[] asc = s.toCharArray();
			Arrays.sort(asc);
			char[] desc = new char[asc.length];
			for (int i = 0; i < desc.length; ++i)
				desc[i] = asc[asc.length - 1 - i];
			int nDesc = Integer.parseInt(new String(desc));
			int nAsc = Integer.parseInt(new String(asc));
			s = "" + (nDesc - nAsc);
		}
		return set.size();
	}

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			int n = Integer.parseInt(br.readLine());
			if (n == 0)
				break;
			System.out.println(mutationLength(n));
		}
	}
}
#include <iostream>
#include <algorithm>
using namespace std;

int fourst(int d[])
{
        if((d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3]) || 
        (d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4]))
        return 1;
    return 0;
}

int fivest(int d[])
{
    if(d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4])
    return 1;
    else
    return 0;
}

int main()
{
    int t; cin>>t;
    while(t--)
    {
        int dice[5];        
        int max[12]={0};
        int c1=0,c2=0,c3=0,c4=0,c5=0,c6=0,ce=0,co=0,cf=0,css=0,cls=0,cy=0;
        for(int i=0;i<5;i++)
        {
            cin>>dice[i];
            switch(dice[i])
            {
                case 1: max[0]++;break;
                case 2: max[1]+=2;break;
                case 3: max[2]+=3;break;
                case 4: max[3]+=4;break;
                case 5: max[4]+=5;break;
                case 6: max[5]+=6;break;
            }
            if(dice[i]%2==0)
            max[6]+=dice[i];
            else
            max[7]+=dice[i];
        }
        sort(dice,dice+5);
        if(dice[0]==dice[4])
        max[8]=40;
        else if((dice[0]==dice[1] && dice[2]==dice[4]) || (dice[0]==dice[2] && dice[3]==dice[4]))
        max[9]=15;
        else if(fivest(dice)==1)
        max[10]=30;
        else if(fourst(dice)==1)
        max[11]=20;
        else
        ;
        sort(max,max+12);
        cout<<max[11]<<endl;
        
    }
    return 0;
}
#include<iostream>
#include<stdio.h>
#define DIV 1000000

using namespace std;

typedef unsigned long long int Lint;

Lint raise( Lint a, Lint b ) {
	
	Lint d;

	if( b == 0 )
		return 1;
	else {
		
		if( b & 0x1 ) {

			d = raise( a, ( b - 1 ) / 2 ) % DIV;
			return ( ( a % DIV ) * ( (d * d ) % DIV ) ) % DIV;
		}
		else {

			d = raise( a,  b / 2 ) % DIV;
			return ( d * d ) % DIV;
		}
	}
}

int main() {
	
	Lint t, a, b;

	while( 1 ) {
		
		scanf("%llu %llu", &a, &b );

		if( ( a == 0 ) && ( b == 0 ) )
			break;
		printf("%llu\n", raise( a, b ) );		
	}

	return 0;
}

from math import factorial

while 1:

    n=raw_input()
    
    if(n=="#"):
        break
        
    ans=0
    
    foo=int(n)
    
    for i in range(1,foo+1):
        
        foobar=int(factorial(int(i)))
        
        ans+=pow(i,foobar,10)
        
        ans=ans%10
        
    print(ans)
    
    
while(1):
	try:
		n =int(raw_input())
		if n == 1 or n == 0:
			print n
		else:
			print 2*n-2
	except:
		break
def ris(s):
    stack = []
    my = ""
    for t in s:
        if t == ")":
            my += stack.pop()
        elif t in ("+","-","*","/","^"):
            stack.append(t)
        elif t != "(":
            my += t
    print(my)
n = input()
while(n):
    x = raw_input()
    ris(x)
    n -= 1 
#include<stdio.h>
int main()
{
    int t,i;
    scanf("%d",&t);
     for(i=1;i<=t;i++)
     {
         int n,p,x;
         scanf("%d%d",&n,&x);
         int ar[n];
         for(p=0;p<n;p++){
        scanf("%d",&ar[p]);
         }
         int y=0;
         for(p=0;p<n;p++){
        if(ar[p]>x)
              y++;
         }
         printf("%d\n",y);
     }
}

#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define mod 1000000007
#define si(i) scanf("%lld",&i);
#define pi(i) printf("%lld",i);
#define rep(i,st,end) for(i=st;i<end;i++) 


int main(){
    
    #ifndef ONLINE_JUDGE
    	freopen("in","r",stdin);
    	freopen("out","w",stdout);
	#endif
    
	ll n,q;
	si(n); si(q);	
	char s[n+5];
    scanf("%s",s+1);
    ll arr[256];
    memset(arr,0,sizeof(arr));
    for(ll i=1;i<=n;i++) arr[s[i]]++;
    while(q--){
    	ll p;
    	si(p);
    	if(p==1){
    		char c;
    		cin>>c;
    		printf("%lld\n",arr[c]);
    	}else{
    		ll x;
    		char y;
    		si(x); 
    		cin>>y;
    		arr[s[x]]--;
    		arr[y]++;
    		s[x]=y;
    	}
    }
    return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define mod 1000000007
#define si(i) scanf("%lld",&i);
#define pi(i) printf("%lld",i);
#define rep(i,st,end) for(i=st;i<end;i++) 

bool comp(pair<ll,ll> a,pair<ll,ll> b){
	if(a.second < b.second) return true;
	else if(a.second == b.second){
		if(a.first < b.first) return true;
		else return false;
	}
	else return false;
}

int main(){
    
    #ifndef ONLINE_JUDGE
    	freopen("in","r",stdin);
    	freopen("out","w",stdout);
	#endif
    
	ll t;
	si(t);
	while(t--){
		ll n;
		si(n);
		vector< pair<ll,ll> > v;
		for(ll i=0;i<n;i++){
			ll j,k;
			si(j); si(k);
			v.push_back(make_pair(j,k));
		}
		sort(v.begin(),v.end(),comp);
		ll cnt=0,prev=0;
		for(ll i=0;i<v.size();i++){
			if(v[i].first > prev){
				cnt++;
				prev=v[i].second;
			}
		}
		printf("%lld\n",cnt);
	}
    return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define mod 1000000007
#define si(i) scanf("%lld",&i);
#define pi(i) printf("%lld",i);
#define rep(i,st,end) for(i=st;i<end;i++) 


int main(){
    
    #ifndef ONLINE_JUDGE
    	freopen("in","r",stdin);
    	freopen("out","w",stdout);
	#endif
    
	ll t;	
	si(t);
    while(t--){
    	ll n,m,q;
    	si(n); si(m);
    	vector<ll> row,column;
    	row.push_back(0); row.push_back(n);
    	column.push_back(0); column.push_back(m);
    	si(q);
    	while(q--){
    		ll i,j;
    		si(i); si(j);
    		row.push_back(i); 
    		column.push_back(j);
    	}
    	sort(row.begin(),row.end());
    	sort(column.begin(),column.end());

    	ll mn_row=mod,mx_row=0; 

    	for(ll i=1;i<row.size();i++){
    		if(row[i]==row[i-1]) continue;
    		mn_row=min(mn_row,row[i]-row[i-1]);
    		mx_row=max(mx_row,row[i]-row[i-1]);
    	}

    	ll mn_column=mod,mx_column=0;

    	for(ll i=1;i<column.size();i++){
    		if(column[i]==column[i-1]) continue;
    		mn_column=min(mn_column,column[i]-column[i-1]);
    		mx_column=max(mx_column,column[i]-column[i-1]);
    	}

    	printf("%lld %lld\n",mn_row*mn_column,mx_row*mx_column);
    }
    return 0;
}
#include<bits/stdc++.h>

#define MOD 1000000007
#define MODSET(d) if ((d) >= MOD) d %= MOD;

using namespace std;

const int LK = 17;

int gcdArray[LK][100005];

int getGCDQuery(int l, int r)
{
    if (l == r)
    {
        return gcdArray[0][l];
    }
    else
    {
        int k = log2(r - l);
        return __gcd(gcdArray[k][l], gcdArray[k][r - (1 << k) + 1]);
    }
}

int main()
{
    #ifdef VSP4
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    #endif // VSP4

    long long int t, n, k, i, j, first, last, mid, curr, ans;

    cin >> n >> k;

    for (i = 0; i < n; i++)
    {
        cin >> gcdArray[0][i];
    }

    for (j = 1; j < LK; j++)
    {
        for (i = 0; i < n - (1 << j) + 1; i++)
        {
            gcdArray[j][i] = __gcd(gcdArray[j-1][i], gcdArray[j-1][i + (1 << (j - 1))]);
        }
    }

    ans = 0;

    for (i = 0; i < n; i++)
    {
        first = i;
        last = n-1;
        curr = -1; //impossible initially

        while (first <= last)
        {
            mid = (first + last) / 2;

            if (getGCDQuery(i, mid) >= k)
            {
                curr = mid;
                first = mid + 1;
            }
            else
            {
                last = mid - 1;
            }
        }

        if (curr != -1) //if at all possible gcd >= k
        {
            ans = max(ans, curr - i + 1);
        }

    }

    cout << ans << "\n";

    return 0;
}

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define pb push_back
#define pob pop_back
#define pf push_front
#define pof pop_front
#define mp make_pair
#define all(a) a.begin(),a.end()
#define bitcnt(x) __builtin_popcountll(x)
#define M 1000000007
#define total 500005
//#define M 1000000007
typedef unsigned long long int uint64;
typedef long long int int64;
/*
inline void fast(int &x) {
    register int c = getchar_unlocked();
    x = 0;
    int neg = 0;
    for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());
    if(c=='-') {
        neg = 1;
        c = getchar_unlocked();
    }
    for(; c>47 && c<58 ; c = getchar_unlocked()) {
        x = (x<<1) + (x<<3) + c - 48;
    }
    if(neg)
        x = -x;
}
*/
vector<int64>key;
queue<pair<int64,int64> >q;
bool visit[100005];
int main(){
	int64 j,t,k,c,i,f,val;
	cin>>t;
	while(t--){
		memset(visit,false,sizeof(visit));
		cin>>k>>c>>i>>f;
		for(j=0;j<k;j++){
			cin>>val;
			key.pb(val);
		}
		int64 ans=-1;
		q.push(mp(i,0));
		pair<int64,int64>tmp;
		while(!q.empty()){
			tmp=q.front();
			q.pop();
			if(tmp.first==f){
				ans=tmp.second;
				break;
			}
			tmp.first=tmp.first%100000;
			visit[tmp.first]=true;
			for(i=0;i<k;i++){
				int64 x=(tmp.first*key[i])%100000;
				if(visit[x]==false){
					visit[x]=true;
					q.push(mp(x,tmp.second+1));
				}	
			}
		}
		if(ans==-1){
			cout<<-1<<endl;
		}
		else{
			cout<<ans*c<<endl;
		}
		q=queue<pair<int64,int64> >();
		key.clear();	
	}
	return 0;
}
from __future__ import division
answers=[]
t = input("")
for i in range(t):
    N,num = raw_input("").split()
    N = int(N)
    for j in range(N):
        num = eval(num+raw_input(""))
        num = str("{0:.2f}".format(num))
    answers.append(num)
for i in range(t):
    print answers[i]
#include <stdio.h>
#include <stdlib.h>

typedef unsigned long long ULL;

ULL gcd(ULL a,ULL b){
  ULL c;
  while(b>0) c=a%b, a=b, b=c;
  return a;
}

ULL bin(ULL n,ULL k){
	if(k>n)return 0;
  if(k> n - k ) 
     k = n - k; 

  ULL p,i,d;
  p=1;
 for(i=1;i<=k;i++){
    d=gcd(p,i);
    p/=d;
    p*=(n-i+1)/(i/d);
  }
  return p;
}

int main(){
  int TST;
  scanf("%d",&TST);
  while(TST--){
    ULL n,k,ans;
    scanf("%llu %llu",&n,&k);
    ans=bin(n,k);
    printf("%llu\n",ans);
  }
  return 0;
}

#include <stdio.h>
#include <stdlib.h>
         
typedef unsigned long long ULL;
         
int main(){
   ULL TST,n,sto;
   scanf("%llu",&TST);
    while(TST--){  scanf("%llu",&n);
          	      sto= (n*n)-(n-1)*(n-1);
                  if((n&(n-1))) printf("Yes\n");
                  else  printf("No\n");
          }
          return 0;
        } 

for t in xrange(int(raw_input())):
    s = raw_input()
    count = 0
    start = 0
    for c in s:
        if c=='i':
            start += 1
        else:
            start -= 1
            if (start<0):
                start = 0
                count += 1
    print  count, start




import math

def nCr(n,r):
  f = math.factorial
  return f(n) / f(r) / f(n-r)
tc = int(raw_input())
for i in range (0,tc):
	score = map(int, raw_input().split())
	score.sort()
	k = int(raw_input())
	x = score[-k:]
	temp = x[0]
	print nCr(score.count(temp),x.count(temp))
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int T = input.nextInt();
        for (int t=0; t<T; t++) {
            char[] w1 = input.next().toCharArray();
            char[] w2 = input.next().toCharArray();
            char[] w3 = input.next().toCharArray();
            char[] w4 = input.next().toCharArray();
            int[][][][] dp = new int[w1.length+1][w2.length+1][w3.length+1][w4.length+1];
            for (int i1=1; i1<=w1.length; i1++) {
                char c1 = w1[i1-1];
                for (int i2=1; i2<=w2.length; i2++) {
                    char c2 = w2[i2-1];
                    for (int i3=1; i3<=w3.length; i3++) {
                        char c3 = w3[i3-1];
                        for (int i4=1; i4<=w4.length; i4++) {
                            char c4 = w4[i4-1];
                            int value = Math.max(Math.max(dp[i1-1][i2][i3][i4],dp[i1][i2-1][i3][i4]),Math.max(dp[i1][i2][i3-1][i4],dp[i1][i2][i3][i4-1]));
                            if (c1 == c2 && c2 == c3 && c3 == c4) {
                                value = Math.max(value, 1+dp[i1-1][i2-1][i3-1][i4-1]);
                            }
                            dp[i1][i2][i3][i4] = value;
                        }
                    }
                }
            }
            System.out.println(w1.length+w2.length+w3.length+w4.length-4*dp[w1.length][w2.length][w3.length][w4.length]);
        }
    }

}

#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        if(n<3)
            cout<<1<<endl;
        else
        {
            int x=ceil(log10(2*M_PI*n)/2+n*log10(n/exp(1)));
            cout<<x<<endl;
        }

    }

    return 0;
}

import java.util.Scanner;

public class Main {
    static long mod = 1000000007;

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int T = input.nextInt();
        for (int t=0; t<T; t++) {
            long a = input.nextInt();
            long b = input.nextInt();
            long c = input.nextInt();
            long d = input.nextInt();
            long T1 = input.nextInt();
            long T2 = input.nextInt();
            long T3 = input.nextInt();
            long T4 = (a*T3+b*T2+c*T1+d)%mod;
            int N = input.nextInt();
            long[][] M = new long[][] {
                {1+a, b-a, c-b, -c},
                {1, 0, 0, 0},
                {0, 1, 0, 0},
                {0, 0, 1, 0}
            };
            M = modPow(M, N-1);
            long result = M[3][0]*T4+M[3][1]*T3+M[3][2]*T2+M[3][3]*T1;
            result %= mod;
            if (result < 0) {
                result += mod;
            }
            System.out.println(result);
        }
    }

    static long[][] modPow(long[][] M, int exp) {
        long[][] result = new long[][] {
            {1, 0, 0, 0},
            {0, 1, 0, 0},
            {0, 0, 1, 0},
            {0, 0, 0, 1}
        };
        long[][] pow = M;
        while (exp != 0) {
            if ((exp&1) == 1) {
                result = multiply(result, pow);
            }
            exp >>>= 1;
            pow = multiply(pow, pow);
        }
        return result;
    }

    static long[][] multiply(long[][] A, long[][] B) {
        long[][] C = new long[4][4];
        for (int i=0; i<4; i++) {
            for (int j=0; j<4; j++) {
                long value = 0;
                for (int k=0; k<4; k++) {
                    value += A[i][k]*B[k][j];
                }
                C[i][j] = value%mod;
            }
        }
        return C;
    }

}

// A C++ program to check if a given graph is Eulerian or not
#include<iostream>
#include <list>
using namespace std;
 
// A class that represents an undirected graph
class Graph
{
    int V;    // No. of vertices
    list<int> *adj;    // A dynamic array of adjacency lists
public:
    // Constructor and destructor
    Graph(int V)   {this->V = V; adj = new list<int>[V]; }
    ~Graph() { delete [] adj; } // To avoid memory leak
 
     // function to add an edge to graph
    void addEdge(int v, int w);
 
    // Method to check if this graph is Eulerian or not
    int isEulerian();
 
    // Method to check if all non-zero degree vertices are connected
    bool isConnected();
 
    // Function to do DFS starting from v. Used in isConnected();
    void DFSUtil(int v, bool visited[]);
};
 
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
    adj[w].push_back(v);  // Note: the graph is undirected
}
 
void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
 
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
 
// Method to check if all non-zero degree vertices are connected.
// It mainly does DFS traversal starting from
bool Graph::isConnected()
{
    // Mark all the vertices as not visited
    bool visited[V];
    int i;
    for (i = 0; i < V; i++)
        visited[i] = false;
 
    // Find a vertex with non-zero degree
    for (i = 0; i < V; i++)
        if (adj[i].size() != 0)
            break;
 
    // If there are no edges in the graph, return true
    if (i == V)
        return true;
 
    // Start DFS traversal from a vertex with non-zero degree
    DFSUtil(i, visited);
 
    // Check if all non-zero degree vertices are visited
    for (i = 0; i < V; i++)
       if (visited[i] == false && adj[i].size() > 0)
            return false;
 
    return true;
}
 
/* The function returns one of the following values
   0 --> If grpah is not Eulerian
   1 --> If graph has an Euler path (Semi-Eulerian)
   2 --> If graph has an Euler Circuit (Eulerian)  */
int Graph::isEulerian()
{
    // Check if all non-zero degree vertices are connected
    if (isConnected() == false)
        return 0;
 
    // Count vertices with odd degree
    int odd = 0;
    for (int i = 0; i < V; i++)
        if (adj[i].size() & 1)
            odd++;
 
    // If count is more than 2, then graph is not Eulerian
    if (odd > 2)
        return 0;
 
    // If odd count is 2, then semi-eulerian.
    // If odd count is 0, then eulerian
    // Note that odd count can never be 1 for undirected graph
    return (odd)? 1 : 2;
}
 
// Function to run test cases
void test(Graph &g)
{
    int res = g.isEulerian();
    if (res == 0)
        cout << "NO\n";
    else if (res == 1)
        cout << "NO\n";
    else
        cout << "YES\n";
}
 /*
// Driver program to test above function
int main()
{
    // Let us create and test graphs shown in above figures
    Graph g1(5);
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 1);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    test(g1);
 
    Graph g2(5);
    g2.addEdge(1, 0);
    g2.addEdge(0, 2);
    g2.addEdge(2, 1);
    g2.addEdge(0, 3);
    g2.addEdge(3, 4);
    g2.addEdge(4, 0);
    test(g2);
 
    Graph g3(5);
    g3.addEdge(1, 0);
    g3.addEdge(0, 2);
    g3.addEdge(2, 1);
    g3.addEdge(0, 3);
    g3.addEdge(3, 4);
    g3.addEdge(1, 3);
    test(g3);
 
    // Let us create a graph with 3 vertices
    // connected in the form of cycle
    Graph g4(3);
    g4.addEdge(0, 1);
    g4.addEdge(1, 2);
    g4.addEdge(2, 0);
    test(g4);
 
    // Let us create a graph with all veritces
    // with zero degree
    Graph g5(3);
    test(g5);
 
    return 0;
}*/
int main()
{
	int t,i,a,b,n,m;
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		Graph g(n);
		for(i=0;i<m;i++)
		{
			cin>>a>>b;
			g.addEdge(a-1,b-1);
		}
		test(g);
	}
	return 0;
} 
#include<bits/stdc++.h>
using namespace std;
#define m 1000000007
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        long long int n,res=1,num;
        scanf("%lld",&n);
        for(long long int i=0;i<n;i++)
        {
            scanf("%lld",&num);
            res=(((num)%m)*(res))%m;
        }
        cout<<(res)%m<<endl;
    }

    return 0;

}

#include<stdio.h>
#include<stdlib.h>
long int *a;
long int *size;

long int root(long int x)
	{	
        while(x!=a[x])
        	x=a[x];
        return x;
	}
void connect(long int p,long  int q)   {       
       if (p == q) return; 
           // Make smaller root point to larger one.   
              if   (size[p] < size[q]) 
              	{
              	a[p] = q; 
              	size[q] = size [q] + size[p];
                } 
              	   
              else 
              {
              	a[q] = p; 
              	size[p] = size [p] + size[q];
              }          
                    }	

int connected(long int x,long int y)
{
	if(x==y)
		return 1;
	else
	 return 0;
}
int main()
{

	int t;

	scanf("%d",&t);
	while(t--)
		{
			long int n,q,c,i,x,y;
			scanf("%li %li",&n,&c);
			
			a=(long int *)malloc((n+1)*sizeof(long int));
			size=(long int *)malloc((n+1)*sizeof(long int));
			for ( i = 1; i <= n; ++i)
			{
				a[i]=i;
			}
            for (i = 0; i < c; ++i)
            {
            	scanf("%li %li",&x,&y);
            	connect(root(x),root(y));
            }
            scanf("%li",&q);
            for ( i = 0; i < q; ++i)
            {
            	scanf("%li %li",&x,&y);
            	if(connected(root(x),root(y)))
            	{
            		printf("Yes\n");
            	}
            	else
            	{
            		printf("No\n");
            	}
            }

		}
}

#include <stdio.h>

void swap(int *x, int *y)
{
    int t;
    t=*x;
    *x=*y;
    *y=t;
}

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int n;
        scanf("%d",&n);
        int s[n],f[n];
        int i,j,k,t;

        for(i=0;i<n;i++)
            scanf("%d%d",&s[i],&f[i]);

        for(i=n/2;i>0;i/=2)
        {
            for(j=i;j<n;j++)
            {
                for(k=j-i;k>=0;k-=i)
                {
                    if(f[k+i]>=f[k])
                        break;
                    else
                    {
                        swap(&s[k],&s[k+i]);
                        swap(&f[k],&f[k+i]);
                    }
                }
            }
        }
        int count =1;
        i=0;

        for(j=1;j<n;j++)
        {
            if(s[j]>f[i])
            {
                count++;
                i=j;
            }
        }

        printf("%d\n",count);
    }
    return 0;
}

#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	long long int t,x,f,n,i;
	cin>>t;
	for(x=0;x<t;x++)
	{
		cin>>n;
		f=1;
		i=2;
		if(n==1)
		cout<<"1"<<endl;
		else
		{
		
		while(f<n)
		{
			f=pow(2,i++)-1;
		}
		if(f!=1)
		{
			f=pow(2,i-1)-1;
		}
		cout<<f<<endl;
           		
	}
	}
}
#include<bits/stdc++.h>

using namespace std;

#define si(x) scanf("%d",&x)
#define pri(x) printf("%d",x)
#define sll(x) scanf("%lld",&x)
#define pll(x) printf("%lld",x)
#define sstr(s) scanf("%s",s)
#define pstr(s) printf("%s",s)
#define nl printf("\n")
#define ll long long int
#define mod 1000000007
ll a[101][101];

void power(int n, int p)
{
    if(p==1)
	return;
    ll id[n][n],temp[n][n];
    memset(temp,0,sizeof(temp));
    memset(id,0,sizeof(id));
    for(int i=0;i<n;++i)
	for(int j=0;j<n;++j)
	    if(i==j)
		id[i][j]=1;
    while(p)
    {
	if(p&1)
	{
	    memset(temp,0,sizeof(temp));
	    for(int i=0;i<n;++i)
	    {
		for(int j=0;j<n;++j)
		{
		    for(int k=0;k<n;++k)
		    {
			temp[i][j] = (temp[i][j]+(id[i][k]*a[k][j])%mod)%mod;
		    }
		}
	    }
	    for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)
		    id[i][j]=temp[i][j];
	}
	memset(temp,0,sizeof(temp));
	for(int i=0;i<n;++i)
	{
	    for(int j=0;j<n;++j)
	    {
		for(int k=0;k<n;++k)
		{
		    temp[i][j] = (temp[i][j]+(a[i][k]*a[k][j])%mod)%mod;
		}
	    }
	}
	for(int i=0;i<n;++i)
	    for(int j=0;j<n;++j)
		a[i][j]=temp[i][j];
	p=p>>1;
    }
    for(int i=0;i<n;++i)
	for(int j=0;j<n;++j)
	    a[i][j]=id[i][j];
}

int main()
{
    int t;
    si(t);
    while(t--)
    {
	int e,n;
	si(n); si(e);
	memset(a,0,sizeof(a));
	int x,y;
	for(int i=0;i<e;++i)
	{
	    si(x); si(y);
	    a[x][y]++;
	    a[y][x]++;
	}
	int q,l;
	si(q); si(l);
	power(n,l);
	while(q--)
	{
	    si(x); si(y);
	    pll(a[x][y]%mod); nl;
	}
    }
    return 0;
}

	#include<stdio.h>
	#include<string.h>
	char str[1001];
	int palin(int s, int e)
	{
		int i,j,flag=0;
		for(i=s,j=e;i<=s+((e-s)/2);j--,i++)
		if(str[i]!=str[j])
		{
			flag=1;
			break;
		}
		if(flag==0)
		return 1;
		else return 0;
	}
	main()
	{
		int t,i,j,res,count=0;

		scanf("%d",&t);
		while(t--)
		{
			count=0;
			scanf("%s",str);
			for(i=0;i<strlen(str);i++)
			{
				for(j=i;j<strlen(str);j++)
			{

					res=palin(i,j);



					if(res==1) count++;
				}
			}
			printf("%d\n",count);
		}
	return 0;
	}

#include<bits/stdc++.h>
using namespace std;
vector<int> a[10001];
int n;
int visited[10001];
 
int ways(int x){
	if(x==n) return 1;
	if(visited[x]==-1){
		int f=0;
        int t=a[x].size();
		for(int i=0; i<t; i++){
				f+=ways(a[x][i]);
        }
		
		visited[x]=f;
	}
    return visited[x];
}
 
int main(){
	cin>>n;
    memset(visited,-1,sizeof(visited));
	int x=1,y=1;
	while(x!=0 && y!=0){
		scanf("%d %d", &x, &y);
		a[x].push_back(y);
	}
    int m=ways(1);
    printf("%d", m);
	
} 
t = int(raw_input())
while t>0:
	t-=1
	a=list(raw_input())
	b=list(raw_input())
	if len(set(a))==1:
		print "Unlucky Chef"
		continue
	cnt1 = 0
	cnt2 = 0
	for i in xrange(len(a)):
		if a[i] != b[i]:
			if a[i]=='1':
				cnt1+=1
			else:
				cnt2+=1
	print "Lucky Chef"
	print max(cnt1, cnt2)
import sys

for __ in range(input()) :
    n = input()
    ans = 0
    for i in range(n+1) :
        while i :
            ans += (i&1)
            i >>= 1
    print ans
T=int(raw_input());
for t in range(T) :
	l=raw_input().split();
	N=int(l[0]);
	K=int(l[1]);
	l=raw_input().split();
	A=[int(i) for i in l];
	countdict={};
	for i in A :
		if i in countdict :
			countdict[i]=countdict[i]+1;
		else :
			countdict[i]=1;
	mindiff=N+1;
	for key in countdict :
		if K>countdict[key]:
			diff=K-countdict[key];
		else :
			diff=countdict[key]-K;
		if diff<mindiff :
			mindiff=diff;
	print mindiff;

#include<iostream>
using namespace std;
#include<stdio.h>
#include<algorithm>
#include<vector>
#include<queue>
#include<utility>
#include<stack>
#include<map>
#include<set>
#include<string.h>
#include<math.h>
#define MOD 1000000007
#define MIN -100000000
#define MAX 100000000
#define ll long long int
template<class T>T gcd(T a,T b){return (b==0)?a:gcd(b,a%b);}
template<class T>T lcm(T a,T b){return (a*b)/gcd(a,b);}
template<class T>T powmod(T a,T b,T mod) {T res=1;if(a>=mod)a%=mod;for(;b;b>>=1){if(b&1)res=res*a;if(res>=mod)res%=mod;a=a*a;if(a>=mod)a%=mod;}return res;}

/* HOPE n WILL :)
	NGU :)
	_/\_ 	*/
// MG

//int a[1000001];

int main()
{
	ll p,g,a,b,n,i,t,s,a1,b1,ans;
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld %lld",&p,&g);
		scanf("%lld %lld",&a,&b);
		ans=powmod(g,a*b,p);
		ans=ans%p;
		printf("%lld\n",ans);
	}
	return 0;
}
//----------shivam_wadhwa----------//
#include <bits/stdc++.h>
#define ll long long int
#define sc1(x) scanf("%d",&x)
#define sc2(x,y) scanf("%d%d",&x,&y)
#define scll(x) scanf("%lld",&x)
#define pint(c) printf("%d",c)
#define pll(c) printf("%lld",c)
#define ps() printf(" ")
#define pn() printf("\n")

#define vi vector<int>
#define vii vector<pair<int,int> >
#define mp make_pair
#define pb push_back

//loops
#define ff(i,n,a) for(i=a;i<n;++i)
#define fb(i,n,a) for(i=n,i>=a;--i)

//constants
const int mxn=1e5+1;
const int MOD=1e9+7;
using namespace std;
int solve(int b,int r)
{
	if(b<=0)
	{
		if(r<=0)
		return 1;
		else return 0;
	}
	//	return 1;
	if(r<=0)
		return 1;
	if(r>b*6)
		return 0;
	int ans1=solve(b-1,r);
	int ans2=solve(b-1,r-1);
	int ans3=solve(b-1,r-4);
	int ans4=solve(b-1,r-6);
	return ans1+ans2+ans3+ans4;
}
int main()
{
	int t=1;
	sc1(t);
	while(t--)
	{
		ll r,b;
		cin>>b>>r;
		if(r<=b*6)
			cout<<solve(b,r)<<endl;
		else cout<<0<<endl;
	}
	return 0;
}
import math

def dfs(graph,start):
    visited,stack=set(),[start]
    ans=1
    while stack:
        vertex=stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            ans*=fac[len(graph[vertex]-visited)]
            #ans*=math.factorial(len(graph[vertex]-visited))
            stack.extend(graph[vertex]-visited)
    return ans

fac=[]
fac.append(1)
fac.append(1)
for i in range(2,100001):
    fac.append(fac[i-1]*(i%1000000007))
    fac[i]%=1000000007
#print fac

t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    if(n==1):
        q=int(raw_input())
        print "1"
    else:
        dic={}
        for j in range(n-1):
            a,b=map(int,raw_input().split())
            if a in dic and b in dic:
                dic[a].add(b)
                dic[b].add(a)
            elif a not in dic and b not in dic:
                dic[a]=set([b])
                dic[b]=set([a])
            elif a in dic and b not in dic:
                dic[a].add(b)
                dic[b]=set([a])
            else:
                dic[a]=set([b])
                dic[b].add(a)    
        q=int(raw_input())
    #    print dic
        ans=dfs(dic,q)
        print ans%1000000007
#include<stdio.h>
#include<stdlib.h>
#include<cstring>
#include<iostream>
#include<ctype.h>
#include<algorithm>
#include<vector>
#include<string>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<cmath>
#include<bitset>
#include<iomanip>
#include<complex>
#include<utility>
 
#define X first
#define Y second
#define gc getchar_unlocked
#define REP(i,n) for(int i=0;i<(n);i++)
#define REP_1(i,n) for(int i=1;i<=(n);++i)
#define REP_2(i,a,b) for(int i=(a);i<(b);++i)
#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)
#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))
#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)
#define DOW_1(i,n) for(int i=(n);0<i;--i)
#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)
#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)
#define FOREACH(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a)
#define RFOREACH(a,b) for(typeof((b).rbegin()) a=(b).rbegin();a!=(b).rend();++a)
#define PB push_back
#define PF push_front
#define MP make_pair
#define IS insert
#define ES erase
#define IT iterator
#define RI reserve_iterator
#define PQ priority_queue
#define LB lower_bound
#define UB upper_bound
#define ALL(x) x.begin(),x.end()
 
#define PI 3.1415926535897932384626433832795
#define EXP 2.7182818284590452353602874713527
#define MOD7 10000007
#define MOD9 1000000009
using namespace std;
 
typedef long long LL;
typedef long double LD;
typedef double DB;
typedef pair<int,int> PII;
typedef vector<int> VI;
typedef pair<int,PII> PIII;
typedef pair<LD,int> PLDI;
typedef vector<PII> VII;
 
template<class T>
T Mul(T x,T y,T P){
T F1=0;
while(y)
{
if(y&1)
{
F1+=x;
if(F1<0||F1>=P)F1-=P;
}
x<<=1;
if(x<0||x>=P)x-=P;
y>>=1;
}
return F1;
}
 
template<class T>
T Pow(T x,T y,T P){
T F1=1;x%=P;
while(y)
{
if(y&1)
{
F1=Mul(F1,x,P);
}
x=Mul(x,x,P);
y>>=1;
}
return F1;
}

template<class T>
T Swap(T &x,T &y)
{
	int tmp=x;
	x=y;
	y=tmp;
}
 
template<class T>
T Gcd(T x,T y){
if(y==0)return x;
T z;
while(z=x%y){
x=y,y=z;
}
return y;
}

template<class T>
T Abs(const T x){
return x<0?-x:x;
}

int inline inp() {
    register int N = 0, C;
    while ((C = gc()) < '0');
    do {
    N = (N<<3) + (N<<1) + C - '0';
    }while ((C = gc()) >= '0');
    return N;
    }
/*------------------------------------------------------------------------------------------------------------------------------------------*/

int val[100005][12];
main()
{
	int  i,j,m,x,n,k;
	string str;
	LL sum=0;
	n=inp();
	m=inp();
	//getchar();
	cin>>str;
	val[0][(int)str[0]-'0']++;
	for(i=1;i<n;i++)
	{ 
	for(j=0;j<10;j++)
	{
	if(j==str[i]-'0')
	val[i][j]=val[i-1][j]+1;
	else
	val[i][j]=val[i-1][j];
	}
	}
	/*for(x=2;x<=n;x++)
	{
		for(i=0;i<=9;i++)
			if(val[x-1][i]>0)
				val[x][i]=val[x-1][i];
		val[x][a[x]]++;
	}*/
	/*REP(q,n+1){
	REP(w,10)
		cout<<val[q][w]<<"  ";
	cout<<endl;
	}*/
	while(m--)
	{
		sum=0;
		x=inp();
		k=str[x-1]-'0';
		
		for(int i=0;i<10;i++)
		{
			if(k!=i)
			{
			if(k-i<0)
			{
			sum+=val[x-1][i]*(k-i)*(-1);}
			else
			sum+=val[x-1][i]*(k-i);
			}
			}	
		printf("%lld\n",sum);
	}
return 0;
}

for _  in xrange(input()):
    n=input()
    s=map(int,raw_input().split())
    midpos=sum(s)/n
    moves=0
    for i in s:
        moves+=abs(i-midpos)
    print moves    

for _ in range(input()):
    try:
        eval(raw_input())
        print 'YES'
    except TypeError:
        print 'YES'
    except:
        print 'NO'
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll A[100005],pre[100005];
int main()
{
    int n,i;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%lld",&A[i]);
    ll mini=LONG_LONG_MAX,sum=0,tmp;
    sort(A,A+n);
    for(i=2;i<n;i++)
        sum+=A[i];
    pre[0]=0;
    for(i=1;n-2*i>=0;i++)
        pre[i]=pre[i-1]+A[n-2*i];
    for(i=0;i<n/2;i++)
    {
        tmp=(n-2-i)*A[0]+(2*i+1)*A[1]+sum-pre[i];
        mini=min(mini,tmp);
    }
    if(n==1)
        printf("%lld\n",A[0]);
    else
        printf("%lld",mini);
    return 0;
}

#include<iostream>
#include<algorithm>

using namespace std;

int main()
{
	int t,n; cin>>t>>n;
	while(t--)
	{
		int marks[n];
		for(int i=0;i<n;i++)
		cin>>marks[i];
		sort(marks,marks+n);
		cout<<(marks[n-1]-marks[0])<<endl;
	}
	return 0;
}
import sys

for t in xrange(int(sys.stdin.readline())):
	n=int(sys.stdin.readline())
	arr=map(int,sys.stdin.readline().split())
	s=sum(arr)
	if s%n ==0:
		avg=s/n
		c=0
		for i in xrange(n):
			c+=abs(avg-arr[i])
		print c/2
	else:
		print "No Treat"
def solve(array):
    count = {}
    for c in array:
        count[c] = count.get(c,0) + 1
    res = 0
    for v in count.values():
        res += (v+1) / 2
    return res

def buy1_get1():
    T = int(raw_input())
    for t in xrange(T):
        array = raw_input().strip()
        print solve(array)

if __name__ == "__main__":
    buy1_get1()
def maxim(lis,n):
    i=0
    maxi=-1000
    maxib=-100
    coord=0
    while i<n:
        t=lis[i][0]+lis[i][0]*lis[i][1]/100
        if(t==maxi):
            if(lis[i][0]>maxib):
                maxi=t
                maxib=lis[i][0]
                coord=i
        elif(t>maxi):
            maxi=t
            maxib=lis[i][0]
            coord=i
        else:
            "boo"
        i+=1    
    return coord        
t=input()
while t:
    t-=1
    n=input()
    k=n
    lis=[]
    while n:
        n-=1
        a=raw_input()
        a=a[:-1]
        a=a.split()
        a[1]=a[1][1:]
        lis+=[[int(a[1]),int(a[2]),a[0]]]
    print lis[maxim(lis,k)][2]
        

	import java.io.BufferedReader;
	import java.io.FileReader;
	import java.io.InputStreamReader;
	import java.util.StringTokenizer;
	import java.util.Arrays;
	 
 
	class TestClass
		{
		static int INFINITY=1000000;
		int n;
		int[][] adj;
		int[] visited;
		static int w;
	    public static void main(String args[] ) throws Exception {
	        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	        new TestClass().solve(br);
	        br.close();
	  }
	  void solve(BufferedReader br)throws Exception
	  {
	  	int t=Integer.parseInt(br.readLine());
	  	for(int l=0;l<t;l++)
	  	{ 
	  		StringTokenizer st=new StringTokenizer(br.readLine());
	  		n=Integer.parseInt(st.nextToken());
	  		int k=Integer.parseInt(st.nextToken());
	  		adj=new int[n+1][n+1];
 		
	  		for(int i=0;i<k;i++)
	  		{
	  			st=new StringTokenizer(br.readLine());
	  			int x=Integer.parseInt(st.nextToken());
	  			int y=Integer.parseInt(st.nextToken());
	  			int cst=Integer.parseInt(st.nextToken());
	  			adj[x][y]=cst;
	  			adj[y][x]=cst;
	  		}
  		int m=Integer.parseInt(br.readLine());
	  		int ycount=0;
	  		for(int i=0;i<m;i++)
	  		{
	  			visited=new int[n+1];
	  			st=new StringTokenizer(br.readLine());
	  			int s=Integer.parseInt(st.nextToken());
	  			int d=Integer.parseInt(st.nextToken());
	  			w=adj[s][d];
	  			dfs(s);
	  			if(visited[d]!=1)
	  			{
	  				ycount++;
	  			}
	  			
	  		}
	  		//System.out.println(ycount);
	  		int a=gcd(ycount,m);
	  		
	  		System.out.println((ycount/a)+"/"+(m/a));
	  		
	  		
	  }
	 }
	 void dfs(int n)
	   {
		 visited[n]=1;
	 	for(int i=0;i<adj[n].length;i++)
	 	{
	 		if(adj[n][i]!=0&&visited[i]==0&&adj[n][i]<w)
	 		{
	 			dfs(i);
 		}
	 	}
	 }
	 int gcd(int a,int b)
	 {
	 	if(b!=0)
	 	{
	 		return gcd(b,a%b);
	 	}	 	else
	 	{
	 		return a;
	 	}
	 }
	}

import sys

mark = {}
for __ in range(input()) :
    q , ids = map(int,sys.stdin.readline().split())
    if q == 1 :
        mark[ids] = 1
    else :
        print "yes" if mark.has_key(ids) else "no"

print "Mark Crimson"

T = int(raw_input())

while T > 0:
    N = int(raw_input())
    ans = 0
    prev = None
    l = map(int, raw_input().split())
    for i in range(N):
        curr = l[i]
        if i>0 and curr>prev:
            ans += curr-prev
            curr = prev 
        prev = curr
    print ans
            
    T -= 1
#include<stdio.h>

int main()
{
int n,q,tem,i,j,x,y,count;
scanf("%d%d",&n,&q);
int a[10001][101]={{}};
for(i=1;i<=n;i++)
{
	scanf("%d",&tem);
	for(j=1;j<101;j++)
		a[i][j]=a[i-1][j];
	a[i][tem]++;
}
while(q--)
{
	count=0;
	scanf("%d%d",&x,&y);
	for(j=1;j<101;j++)	
		if(a[y][j]-a[x-1][j]>0)count++;
	printf("%d\n",count);
}
return 0;
}

t = input()
for _ in xrange(t):
    x = raw_input().split()
    n,p = int(x[0]),float(x[1])
    a = [0]*(n+10)
    a[0],a[1],a[2] = 0,2,2
    for i in xrange(3,n+1):
    	a[i] = (a[i-2]+2)*p + (a[i-3]+2)*(1-p)
    print ('%.2f' % a[n])
#include<stdio.h>
#include<math.h>
int main()
{
    long int tcase;
    scanf("%ld",&tcase);
    while(tcase--)
    {
        long long int l,ans;
        scanf("%lld",&l);
        ans=(-3+sqrt(9+l));
        if(ans==0)
        printf("-1\n");
        else
        printf("%lld\n",ans+1);
    }
	return 0;
}
/* The code has been taken from : http://comeoncodeon.wordpress.com/category/algorithm/ */
#include<iostream>
#include <bits/stdc++.h>
using namespace std;
#include<vector>
 
/* This function calculates (a^b)%MOD */
long long pow(int a, int b, int MOD)
{
    long long x=1,y=a; 
    while(b > 0)
    {
        if(b%2 == 1)
        {
            x=(x*y);
            if(x>MOD) x%=MOD;
        }
        y = (y*y);
        if(y>MOD) y%=MOD; 
        b /= 2;
    }
    return x;
}
 
/*  Modular Multiplicative Inverse
    Using Euler's Theorem
    a^(phi(m)) = 1 (mod m)
    a^(-1) = a^(m-2) (mod m) */
long long InverseEuler(int n, int MOD)
{
    return pow(n,MOD-2,MOD);
}
 
long long C(int n, int r, int MOD)
{
    vector<long long> f(n + 1,1);
    for (int i=2; i<=n;i++)
        f[i]= (f[i-1]*i) % MOD;
    return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD;
}
 
int main()
{    
    int n,p=1000000007,t;
    scanf("%d",&t);
    while(t--)
    {
    	scanf("%d",&n);
        printf("%lld\n",(C(2*n,n,p)*InverseEuler(n+1,p))%p);
    }
}
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		int maxi=0,x;
		int freq[1000005];
		memset(freq,0,sizeof(freq));
		for(int i=0;i<n;i++)
			cin>>x,freq[x]+=1,maxi=max(maxi,x);
		int ans,got=1;
		for(int i=maxi;i>0 && got;i-=1)
		{
			int j=i;
			int c=0;
			while(j<=maxi)
			{
				if(freq[j]>0)
					c+=freq[j];
				if(c>1)
				{
					ans=i;
					got=0;
					break;
				}
				j+=i;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
#include<iostream>
#include<algorithm>
#include<stdio.h>
#define GETCHAR getchar_unlocked
inline int readInt()
{
int flag=1;
int n = 0;
char c;
while (1)
{
c=GETCHAR();
if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;}
else if(flag!=1) break;
}
return n;
}
using namespace std;
int main(){
	int t;
	t=readInt();
	while(t--){
		int n;
		n=readInt();
		int arr[n];
		for(int i=0;i<n;i++){
			arr[i]=readInt();
		}
		int sumarray[n];
		sort(arr,arr+n);
		for(int i=0;i<n;i++)
		sumarray[i]=arr[i];
		
		
		for(int i=1;i<n;i++){
			
			sumarray[i]+=sumarray[i-1];
			//cout<<sumarray[i]<<" ";
		}
		
		long long int queries;
		queries=readInt();
		for(int i=0;i<queries;i++){
			int req;
			req=readInt();
			//cout<<"hi";
			//BINARY SEARCH
			int low=0;
			int high=n-1;
			while(low<high){
				int mid=(low+high)/2;
				if(sumarray[mid]<req)
				low=mid+1;
				else
				high=mid-1;
			}
			//cout<<low;
			if(sumarray[low]>=req)
			low--;
			printf("%d ",low+1);
		}
		cout<<"\n";
	}
}
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<cstring>
using namespace std;
int arr1[100010];
int arr2[100010];
int ans[1000010];
int main(){
	int t;
	scanf("%d",&t);
	//string tt;
	//getline(cin,tt);
	while(t--){
		//string a,b;
	    char a[100010];
	    char b[100010];
	    scanf("%s %s",a,b);
		//getline(cin,a,' ');
	    //getline(cin,b);
		for(int i=0;i<100010;i++){
			arr1[i]=0;
			arr2[i]=0;
			ans[i]=0;
		}
		int len1=strlen(a);
		int len2=strlen(b);
		for (int j=len1-1,i=0;j>=0;j--,i++)
			arr1[i]=a[j]-'A';
			
		for (int j=len2-1,i=0;j>=0;j--,i++)
			arr2[i]=b[j]-'A';
			
		
		//for(int i=0;i<=a.length()-1;i++)
		//cout<<arr1[i]<<" ";
		//for(int i=0;i<=b.length()-1;i++)
		//cout<<arr2[i]<<" ";
		int takecarry=0;
		int limit=max(len1,len2);
		//cout<<limit<<"\n";
		for(int i=0;i<=limit;i++){
			ans[i]=arr1[i]+arr2[i]+takecarry;
			takecarry=ans[i]/26;  
			ans[i]%=26;
		}
		//cout<<limit;
		//for(int i=0;i<=limit;i++)
		//cout<<ans[i]<<" ";
		for (int i=limit;i>=0;i--) 
		{
			if (i==limit && ans[i]==0){
			}
			//continue;
			else
			printf("%c",'A'+ans[i]);
		}
		printf("\n");
	}
}
n=int(raw_input())
dic={'0':'0','6':'9','9':'6','8':'8',"1":"1"}
for _ in xrange(n):
    num=raw_input().strip()
    strs=""
    for x in reversed(num):
        if x not in dic:
            print "NO"
            break
        strs+=dic[x]
    else:
        print "YES"
        print strs
        

import string
s = raw_input().split()
l = len(s)
for i in range(l):
    s[i] = string.lower(s[i])
while True:
    p = raw_input().split()
    l1 = len(p)
    a = 1
    for i in range(l1):
        if string.lower(p[i]) not in s:
            a = 0
            break
    if a:
        break
    else:
        print "No"
print "Yes"

import java.io.*;

class C3001 
{
	static String findValue(String col)
	{
		String colour[]={"black","brown","red","orange","yellow","green","blue","violet","grey","white"};
		String code[]={"0000","0001","0010","0011","0100","0101","0110","0111","1000","1001"};
		int pos=-1;
		for(int i=0;i<10;i++)
		{
			if(colour[i].equals(col))
			{
				pos=i;
				break;
			}
		}
		return code[pos];
	}
	public static void main(String args[]) throws IOException
	{
		//long t1=System.currentTimeMillis();
		//BufferedReader in=new BufferedReader(new FileReader(new File("test")));
		BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out=new PrintWriter(System.out);
		String res[]=in.readLine().split("\\s+");
		String totalbin=findValue(res[0])+findValue(res[1])+findValue(res[2])+findValue(res[3]);
		//System.out.println(totalbin);
		Long totdec=Long.parseLong(totalbin,2);
		Long multiplier=Long.parseLong(findValue(res[3]),2);
		Long ans=totdec*(long)Math.pow(10, multiplier);
		out.println(ans+" Guntur");
		out.flush();
		//long t2=System.currentTimeMillis();
		//out.println(t2-t1);
		//out.flush();
	}
}

/* Author: Karlheinz Jung */
/* Compiler: Borland Turbo C 2.01 */
/* Computer: Rabbit 286 */
/* Problem: A day at Canteen (C3002) */

#include <stdio.h>
#include <limits.h>

int main()
{
int a, b, c, d, e, m=INT_MAX;
int r[25];
int *p=r-1, *q=r+26;
scanf("%d %d %d %d %d",&a,&b,&c,&d,&e);
r[0]=a+b-c*d/e;
r[1]=a+b-c/d*e;
r[2]=a+b*c-d/e;
r[3]=a+b*c/d-e;
r[4]=a+b/c-d*e;
r[5]=a+b/c*d-e;
r[6]=a-b+c*d/e;
r[7]=a-b+c/d*e;
r[8]=a-b/c+d*e;
r[9]=a-b/c*d+e;
r[10]=a-b*c+d/e;
r[11]=a-b*c/d+e;
r[12]=a*b+c-d/e;
r[13]=a*b+c/d-e;
r[14]=a*b-c/d+e;
r[15]=a*b-c+d/e;
r[16]=a*b/c+d-e;
r[17]=a*b/c-d+e;
r[18]=a/b+c-d*e;
r[19]=a/b+c*d-e;
r[20]=a/b-c+d*e;
r[21]=a/b-c*d+e;
r[22]=a/b*c+d-e;
r[23]=a/b*c-d+e;
for(; ++p<q; m=m>*p&&*p>0?*p:m);
printf("%d\n",m);
return 0;
}

#include <iostream>
#include <stdio.h>
#include <vector>

using namespace std;

int main() {
	
	string s1, s2;
	vector<int> A( 26, 0 );
	int i, n1, n2;
	
	cin >> s1 >> s2;
	
	for( n1 = 0;s1[ n1 ] != '\0';n1++ );
	for( n2 = 0;s2[ n2 ] != '\0';n2++ );
	
	for( i = 0;i < n1;i++ )
		A[ s1[ i ] - 97 ]++;
	
	for( i = 0;i < n2;i++ )
		A[ s2[ i ] -97 ] = 0;
	
	for( i = 0;i < 26;i++ )
		if( A[ i ] > 0 )
			cout << (char)( 97 + i ) << A[ i ];
	
	cout << endl;
			
	return 0;
}

#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <cassert>
using namespace std;
#define p(x) cout<<#x<<":"<<x<<"\n"

int x,y,i;
char o;
double s;
char str[100];

int main()
{
  scanf("%d%c%d",&x,&o,&y);
  assert(x>1);
  assert(max(x,y)<=100000000);
  if(o=='!')
  {
    assert(y==0);
    for(i=2;i<=x;i++)
      s+=log10(i);	
	s++;
  }
  else if(o=='*')
  {
    assert(y>0);
    sprintf(str,"%lld",(long long)x*y);
    s=strlen(str);
  }
  else if(o=='/')
  {
    assert(y>0);
	if(x/y==0)
	  s=0;
	else
	{
	  sprintf(str,"%d",x/y);
      s=strlen(str);
	}
  }
  else 
  {
    assert(y>=0);
	s=y*log10(x)+1;
  }
  printf("%d\n",(int)(s+1e-8));
  return 0;
}
/*
Success is a matter of hanging on, when others have let go.
Its not who you are, that holds you back, its who you think you are not.
The future belongs to those, who believe in the beauty of their dreams.
*/
//{ /* theCodeGame */
#include<iostream>
#include<cmath>
#include<algorithm>
#include<climits>
#include<vector>
#include<queue>
#include<bitset>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
using namespace std;
#define MOD 1000000007LL
#define LL long long
#define ULL unsigned long long
#define LD long double
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) ((x)*(x))
#define CUBE(x) ((x)*(x)*(x))
#define si(n) scanf("%d",&n)
#define si2(n,m) scanf("%d %d",&n,&m)
#define sf(n) scanf("%f",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
#define slu(n) scanf("%llu",&n)
#define sd(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define pnl printf("\n")
#define REP(i,n) for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define FORR(i,n,e) for(int i=(n);i>=(e);i--)
#define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d))
#define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))
//#undef mydebug
#ifdef mydebug
#define DB(x) cout<<#x<<"="<<(x)<<"\n"
#define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n"
#define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n"
#define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n"
#define pnld pnl;
#else
#define DB(x)
#define DB2(x,y)
#define DB3(x,y,z)
#define DB4(x,y,z,a)
#define pnld
#endif
#define FILL(a,b) memset(a,b,sizeof(a))
const double PI=3.14159265358979323846264338327950288419716939937510582097494459230;
//template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;}
void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";}
void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;}
ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);}
//}
#define size 53
LL dp[size][size];
void precompute(){
    FOR(i,0,size){
        FOR(j,0,size){
            if(!i||!j){
                dp[i][j]=1;
            }else{
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
            //cout<<dp[i][j]<<" ";
        }
       // pnld;
    }

}
void doThis(){
    int N,M;
    si2(N,M);
    printf("%lld\n",dp[N][M]);
}

int main(){
#ifdef amy
freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr);
#endif
precompute();
int t=1;
//scanf("%d",&t);
while(t--){doThis();}
#ifdef amy
fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC));
#endif
return 0;
}

from sys import stdin

new_matrix = lambda m,n,v : [ [v for j in xrange(n)] for i in xrange(m) ]

T = int(stdin.readline())

for _t in xrange(T):

    data = map(int,stdin.readline().split())
    numIngredientes = data[0]
    vals = data[1:]

    a = ord('a')
    seq = ['-'] + [ ord(x)-a for x in stdin.readline().strip() ]
    L = len(seq)-1
    
    N = int(stdin.readline())

    dp = new_matrix(N+1,L+1,0)
    sol = new_matrix(N+1,L+1,'')
    for i in xrange(1,N+1):
        for j in xrange(1,L+1):
            if vals[seq[j]]<=i :
                op1 = dp[i][j-1]
                op2 = dp[i-vals[seq[j]]][j-1]+vals[seq[j]]
                if op1>op2 :
                    dp[i][j]=op1
                    sol[i][j]=sol[i][j-1]
                elif op2 > op1 :
                    dp[i][j]=op2
                    sol[i][j]=sol[i-vals[seq[j]]][j-1]+chr(seq[j]+a)
                else :
                    dp[i][j]=op1
                    sol[i][j]=min(sol[i][j-1],sol[i-vals[seq[j]]][j-1] + chr(seq[j]+a))
            else :
                dp[i][j]=dp[i][j-1]
                sol[i][j]=sol[i][j-1]

    
    print "IMPOSSIBLE" if dp[N][L]<N else sol[N][L]
            
    

#include<stdio.h>
#include<malloc.h>

int num,pairs,rs;
#define SIZE 100001
struct pair
{
	int num;
	int depend;
	struct pair *next;
};
struct pair mypair[SIZE];
int visited[SIZE];
int main()
{

  int tests, tc;
  int i;

  //freopen("input.txt","r",stdin);
  //scanf("%d",&tests);
  tests = 1;
  
  for(tc = 0; tc < tests; tc++)
  {
	  
	  scanf("%d %d %d",&num,&pairs,&rs);
	  int A, B;

	  for(i = 0; i <= num; i++)
	  {
			  mypair[i].num = i;
			  mypair[i].next = NULL;
			  visited[i] = 0;

	  }

	  for( i = 1; i <= pairs; i++)
	  {   
		  scanf("%d %d", &A,&B);

		  struct pair* temp;

		  temp = mypair[A].next;
		  mypair[A].next = (struct pair*)malloc(sizeof(struct pair));
		  mypair[A].next->num = B;
		  mypair[A].depend++;
		  mypair[A].next->next = temp;
	  }

	  //==========Scan Done=======//
	  int depend = 0;
	  int min = 999999;
	  int jj;
	 // while(1)
	  //{

		for(i = 1; i <= num; i++)
		{
			depend = 0;

				  for(jj = 0; jj <= num; jj++)
					{
						 visited[jj] = 0;
				    }

			struct pair *temp = &mypair[i];

			while(temp != NULL)
			{
				if(visited[temp->num] == 0)
				{
					depend++;
					visited[temp->num] = 1;

										
					if(temp->next == NULL)
					{
						temp = mypair[temp->num].next;

					}
					else 
						temp = temp->next;
				}
				else
					temp = temp->next;
               //visited[temp->num] = 0;

			}
			if(depend < min)
				min = depend;

		}


	  //}


	printf("%d",min*rs);
  }
  return 0;
}
t=int(raw_input())
for i in xrange(t):
    a,b,c,d=map(int,raw_input().split())
    a2,b2,c2,d2=map(int,raw_input().split())
    ans=((c-a)*(d-b))+((c2-a2)*(d2-b2))
    r3x1=max(a,a2)
    r3y1=max(b,b2)
    r3x2=min(c,c2)
    r3y2=min(d,d2)
    
    if r3x1<r3x2 and r3y1<r3y2:
        ans-=((r3x2-r3x1)*(r3y2-r3y1))
    print ans
import sys

T = int (raw_input ())

for i in range (T) :
	min_candles ,min_candle_digit = 9, 0
	candles = map (int, raw_input ().split ())	
	zero_candles = candles[0]	
	for j in range (1, len (candles)) :
		if min_candles > candles[j] :
			min_candles = candles[j]
			min_candle_digit = j

	output = ""
	if zero_candles < min_candles :
		output += str (1)
		for j in range (zero_candles + 1) :
			output += str (0)
		print output
	else :
		for j in range (min_candles + 1) :
			output += str (min_candle_digit)
		print output

    #include <iostream>
    #include <cstdio>
    #include <algorithm>
    #include <string>
    #include <vector>
    #include <map>
    #include <set>
     
    using namespace std;
     
    #define MODULUS 1000000007
    /*
    long long pow(int a, int b, int MOD)
    {
    long long x=1,y=a;
    while(b > 0)
    {
    if(b%2 == 1)
    {
    x=(x*y);
    if(x>MOD) x%=MOD;
    }
    y = (y*y);
    if(y>MOD) y%=MOD;
    b /= 2;
    }
    return x;
    }
     
    /* Modular Multiplicative Inverse
    Using Euler's Theorem
    a^(phi(m)) = 1 (mod m)
    a^(-1) = a^(m-2) (mod m) */
    /*
    long long InverseEuler(int n, int MOD)
    {
    return pow(n,MOD-2,MOD);
    }
     
    long long C(int n, int r, int MOD)
    {
    vector<long long> f(n,1);
    for (int i=2; i<=n;i++)
    f[i]= (f[i-1]*i) % MOD;
    return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD;
    }
    */
    /*
    long long C(int n, int r, int MOD)
    {
    vector< vector<long long> > C(2,vector<long long> (r+1,0));
     
    for (int i=0; i<=n; i++)
    {
    for (int k=0; k<=r && k<=i; k++)
    if (k==0 || k==i)
    C[i&1][k] = 1;
    else
    C[i&1][k] = (C[(i-1)&1][k-1] + C[(i-1)&1][k])%MOD;
    }
    return C[n&1][r];
    }
     
    long long C(int n, int r)
    {
    if (r==0) return 1;
    else return (C(n-1,r-1) * n / r)%MODULUS;
    }
    */
     
    int countFact(int n, int p)
    {
    int k=0;
    while (n>0)
    {
    k+=n/p;
    n/=p;
    }
    return k;
    }
     
    /* This function calculates (a^b)%MOD */
    long long pow(int a, int b, int MOD)
    {
    long long x=1,y=a;
    while(b > 0)
    {
    if(b%2 == 1)
    {
    x=(x*y);
    if(x>MOD) x%=MOD;
    }
    y = (y*y);
    if(y>MOD) y%=MOD;
    b /= 2;
    }
    return x;
    }
     
    long long C(int n, int r, int MOD)
    {
    long long res = 1;
    vector<bool> isPrime(n,1);
    for (int i=2; i<=n; i++)
    if (isPrime[i])
    {
    for (int j=2*i; j<=n; j+=i)
    isPrime[j]=0;
    int k = countFact(n,i) - countFact(r,i) - countFact(n-r,i);
    res = (res * pow(i, k, MOD)) % MOD;
    }
    return res;
    }
     
    int main()
    {
    int t,i;
    // scanf("%d", &t);
    // while ( t-- ) {
    // cout << C(5,1,MODULUS) << endl;
     
    int n,m,k,x,y;
    int min = 0;
    scanf("%d %d %d", &n, &m, &k);
    for ( i = 0; i < k; ++i ) {
    scanf("%d %d", &x, &y);
    min += y;
    }
    int total = n - min;
    if ( total < 0 ) {
    printf("0\n");
    return 0;
    }
    int C1 = total + m - 1;
    int C2 = m - 1;
    printf("%lld\n", C(C1,C2,MODULUS));
     
    // }
    return 0;
    } 
#include<bits/stdc++.h>
#define ll long long
#define pii pair<ll,ll>
using namespace std;

int bit(int a){
	set<int> digits;
	int ac= a;
	while(a!=0){
		digits.insert(a%10);
		a = a/10;
	}
	int ans = 0;
	for(set<int> ::iterator it = digits.begin(); it!= digits.end() ; it++){
		ans += 1<<(*it);
	}
	return ans;
}

pair<ll, ll> M[1024];

bool compare(int a, int b){
	if(M[a].first < M[b].first)
		return true;
	if(M[a].first > M[b]. first)
		return false;
	return M[a].second < M[b].second;
}

int main(){

	while(!feof(stdin)){
		if(feof(stdin))return 0;
		for(int i =0; i< 1024; i++){
			M[i] = make_pair(0,0);
			}
		int n;
		cin>>n;
		int A[101];
		for(int i =0; i< n; i++){
			cin>>A[i];
			int a = bit(A[i]);
			for(int x =0; x< 1024; x++){
				if((int)(x&a) == 0){
					if(M[x|a].first <M[x].first + A[i]){
						M[x|a].first = M[x].first + A[i];
						M[x|a].second = M[x].second + 1;
					}
					else if(M[x|a].first == M[x].first + A[i]){
						 M[x|a].second = max(M[x|a].second, M[x].second + 1);
					}
				}
			}
		}
		if(feof(stdin))return 0;

		int idx= 0;
		for(int i =1; i< 1024; i++){
			if(compare(idx, i))
				idx  = i;
		}
		cout<<M[idx].second<<endl;
	}
	return 0;
}


#include<iostream>
#include<math.h>
#include<stdlib.h>
using namespace std;
 
int a[1010];
main()
{
	int t;
	cin>>t;
	for(int k=1;k<=t;k++)
	{
		int n;
		cin>>n;
		for(int i=0;i<n;i++)
		{
			cin>>a[i];
		}
		int table[n];
		for(int i=0;i<n;i++)
		{
			table[i]=1;
		}
		for(int i=1;i<n;i++)
		{
			for(int j=i-1;j>=0;j--)
			{
				if(a[i]>=a[j]&&table[i]<table[j]+1)
				{
					table[i]=table[j]+1;
					//cout<<"table["<<i<<"] : "<<table[i]<<endl;
				}
			}
		}
		int max=table[0];
		for(int i=1;i<n;i++)
		{
			if(table[i]>max)
			max=table[i];
		}
		cout<<max<<endl;
	}
}  
memo = {}
def C(n, r, p):
    ''' {n choose r} modulo p (p is prime) '''
    if r < 0 or r > n:
        return 0
    if r == 0 or r == n:
        return 1
    if n >= p: # Lucas theorem
        return C(n/p, r/p, p) * C(n%p, r%p, p) % p
    if (n, r, p) not in memo:
        memo[n, r, p] = (C(n-1, r-1, p) + C(n-1, r, p)) % p
    return memo[n, r, p]
t=int(raw_input())
p=int(1009)
for i in range(t):
    n,r=map(int,raw_input().split())
    print C(n,r,p)

#!/usr/bin/python



list=[0,0]
sum=0
LIMIT=100001

for n in xrange(1,LIMIT):
	sum+=(n*n)/4
	list.append(sum)

	
cases=int(raw_input())
for i in xrange(cases):
	n=int(raw_input())
	print list[n-1]




T = int(raw_input())

for z in xrange(T):
    s = raw_input().strip()

    cache = [ [0 for j in xrange(55)] for i in xrange(55) ]

    N = len(s)
    for l in xrange(N,0,-1):
        for i in xrange(N-l+1):
            j = i+l
            
            if i == 0 or j == N:
                cache[i][j] = 0
            else:
                cache[i][j] = cache[i-1][j] + cache[i][j+1] - cache[i-1][j+1]
                if s[i-1] == s[j]:
                    cache[i][j] += cache[i-1][j+1] + 1

    tot = 0
    for i in xrange(N):
        for j in xrange(i+1,N+1):
            if s[i] == s[j-1]:
                tot += cache[i][j] + 1

    print tot

a=[]
i=2
a.insert(0,0)
a.insert(1,2)
while i<101:
    n=4*a[i-1]-2*a[i-2]
    a.append(n)
    i=i+1
#def f(n):
#   if n == 0:
#       return 0
#   elif n == 1:
#       return 2
#   else:
#       return 4*f(n-1) -2*f(n-2)
t=input()
i=0
while i<t:
    n=input()
    if n%2==0:
    	n=n/2-1
    	print a[n]
    else:
	print "0"
    i=i+1
    

using namespace std;

#include <string>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <list>
#include <map>
#include <set>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string.h>
#include <stack>
#include <queue>
#include <limits.h>
#include <iterator>
#include <iomanip>
#include <time.h>

#define null NULL
#define PRINT_NEW_LINE printf("\n")
#define gc getchar_unlocked
#define MAX_INPUT_SIZE 1001
#define CODEFORCES_MAX_INPUT_SIZE 101
#define TOPCODER_MAX_INPUT_SIZE 51
#define ALPHABET_SIZE 26
#define HACKER_RANK_LOWER_CASE "hackerrank"
#define MAX_SIZE_USER_INPUT 101
#define LIMIT 10000001
#define MODN 1000000007
#define MAX_SIZE 1000001

#define gc getchar_unlocked

void solveProblem() {
    bool primeNumbers[MAX_SIZE];
    memset(primeNumbers, true, sizeof(primeNumbers));
    primeNumbers[0] = false;
    primeNumbers[1] = false;
    for (int outerCounter = 2; outerCounter * outerCounter < MAX_SIZE; outerCounter++) {
        if (primeNumbers[outerCounter]) {
            for (int innerCounter = outerCounter * 2; innerCounter < MAX_SIZE; innerCounter = innerCounter + outerCounter) {
                primeNumbers[innerCounter] = false;
            }
        }
    }
    int countOfPrimes[MAX_SIZE] = { 0 };
    for (int outerCounter = 2; outerCounter < MAX_SIZE; outerCounter++) {
        if (primeNumbers[outerCounter]) {
            countOfPrimes[outerCounter] = countOfPrimes[outerCounter - 1] + 1;
        } else {
            countOfPrimes[outerCounter] = countOfPrimes[outerCounter - 1];
        }
    }
    unsigned int testCases;
    int fUserInput, sUserInput;
    scanf("%u", &testCases);
    while (testCases--) {
        scanf("%d %d", &fUserInput, &sUserInput);
        printf("%d\n", countOfPrimes[sUserInput] - countOfPrimes[fUserInput - 1]);
    }
}

int main() {
    solveProblem();
    return 0;
}

#include <iostream>
#include<algorithm>
using namespace std;
int main()
{
    int t,i,j;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        long int a[n];
        for(i=0;i<n;i++)
            cin>>a[i];
        sort(a,a+n);
        i=0;
        j=n-1;
        if(n%2!=0)
        {
            while((j-i)>=2)
            {
                cout<<a[j]<<" "<<a[i]<<" ";
                j--;
                i++;
            }
            cout<<a[j];
        }
        else
        {
            while(i<j)
            {
                cout<<a[j]<<" "<<a[i]<<" ";
                j--;
                i++;
            }
        }
        cout<<"\n";
    }
    return 0;
}

#include<iostream>
#include<stdio.h>
#include<algorithm>
#define MOD 26
using namespace std;
int main()
{
    int t,n,s,e;
    scanf("%d",&t);
    long long fibo[90];
    fibo[1]=fibo[2]=1;
    for(int i=3;i<90;i++){
        fibo[i]=(fibo[i-1]+fibo[i-2])%26;
        if(fibo[i]==0)
            fibo[i]=26;
    }
    while(t--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            printf("%c",(char)65+fibo[i]-1);
        printf("\n");
    }
}
/*
Input:
2
5
8

Output:
AABCE
AABCEHMU
*/

#include <cstdio>
#include <cstring>
#define LSOne(S) (S & (-S))
using namespace std;
 
typedef long long ll;
 
// B1 and B2 are two fenwick trees
// Original array entries are assumed to be 0
// and only updates are stored.
ll B1[100005], B2[100005];
 
// Array size
int N;
 
// Point query
// Returns value at position b in the array for ft = B1
// Returns value to be subtracted from query(B1, b) * b for ft = B2
ll query(ll* ft, int b)	{
	ll sum = 0;
	for (; b; b -= LSOne(b)) sum += ft[b];
	return sum;
}
 
// Range query: Returns the sum of all elements in [1...b]
ll query(int b) {
    return query(B1, b) * b - query(B2, b);
}
 
// Range query: Returns the sum of all elements in [i...j]
ll range_query(int i, int j)    {
    return query(j) - query(i - 1);
}
 
// Point update: Adds v to the value at position k in the array
// ft is the fenwick tree which represents that array
void update(ll* ft, int k, ll v) {
	for (; k <= N; k += LSOne(k)) ft[k] += v;
}
 
// Range update: Adds v to each element in [i...j]
void range_update(int i, int j, ll v)	{
	update(B1, i, v);
	update(B1, j + 1, -v);
	update(B2, i, v * (i - 1));
	update(B2, j + 1, -v * j);
}
 
int main()  {
	int T, C, p, q, cmd;
	ll v;
 
	scanf("%d", &T);
	while (T--)	{
		// C -> No. of operations
		scanf("%d %d", &N, &C);
		memset(B1, 0, (N+1) * sizeof(ll));
		memset(B2, 0, (N+1) * sizeof(ll));
		while (C--)	{
			scanf("%d %d %d", &cmd, &p, &q);
			// cmd is 0 for a range update and 1 for a range query
			if (cmd == 1)   {
                		scanf("%lld", &v);
                		range_update(p, q, v);
			} else
                		printf("%lld\n", range_query(p, q));
		}
	}
 
    return 0;
}
from string import *
for i in xrange(int(raw_input())):
    n,k=map(int,raw_input().split(' '))
    c=raw_input()
    s={c[0]:1}
    x=1
    l=1
    for j in xrange(1,len(c)):
        if c[j] in s.keys():
            s[c[j]]+=1
        else:
            s[c[j]]=1
        if c[j]==c[j-1]:
            l+=1
            if l>=k:
                x=0
        else:
            l=1
    if x:
        print -1
    else:
        result=1
        l=0
        for j in xrange(1,len(c)):
            if c[j]!=c[j-1]:
                result+=1
                l=0
            else:
                l+=1
                if l>=k:
                    result+=1
                    l=0
        print result
def dfs_rec(adj, source, visited):
	visited[source] = 1
	for v in adj[source]:
		if visited[v] == 0:
			return dfs_rec(adj, v, visited)


def dfs_iter(adj):
	p = len(adj)
	visited = [0]*p
	stack = [0]
	while len(stack) != 0:
		v = stack.pop()
		if visited[v] != 1:
			visited[v] = 1
			for u in adj[v]:
				if visited[u] != 1:
					stack.append(u)

	return visited
		
def dfs_iter_spoj(adj, source, visited):
	p = len(adj)
	stack = [source]
	while len(stack) != 0:
		v = stack.pop()
		if visited[v] != 1:
			visited[v] = 1
			for u in adj[v]:
				if visited[u] != 1:
					stack.append(u)

	return visited

for _ in xrange(int(raw_input())):
	p = int(raw_input())
	q = int(raw_input())
	visited = [0]*p
	adj = {}
	for x in range(p): adj[x] = []
	for _ in xrange(q):
		m,n = map(int, raw_input().split())
		adj[m].append(n)
		adj[n].append(m)

	count = 0
	for source in range(p):
		if visited[source] != 1:
			dfs_iter_spoj(adj, source, visited)
			count += 1

	print count

t=int(input())
for i in range(t):
    n=int(input())
    [a,b,c,d]=map(int,raw_input().split())
    if a==c and b==d:
        ans=0
    elif (a+b)%2 == (c+d)%2:
        ac=max(a,c)-min(a,c)
        bd=max(b,d)-min(b,d)
        if (a+b)==(c+d) or ac==bd:
            ans=1
        else:
            ans=2
    else:
        ans=-1
    print ans
def prime (a):
    b=1
    p=0
    while b<a:
        f=a%b
        if f==0:
            p+=1
        b+=1
    if p<2:
        return True
n=input()
for i in range(n):
    a=map(int,raw_input().split())
    c=0
    for j in range(a[0],a[-1]+1):
        d=str(j)
        if j!=1 and d==d[::-1] and prime(j)==True:
            c+=j
    print c

from __future__ import division
from sys import stdin
t=int(stdin.readline())
while t>0:
	gs=raw_input().split()
	a=int(gs[0])
	b=int(gs[1])
	c=int(gs[2])
	flag = total = dif= 0
	pos = int(stdin.readline())
	if ((b/a) == (c/b) or a==b==c):
		print "YES"
		diff=b/a
		flag = 1
		total = a+b+c
	elif(b-a == c-b):
		print "YES"
		diff=c-b	
		flag = 2
		total = a+b+c
	else:
		print "NO"
		flag = 0
	if(flag == 1):
		ans = c
		if(pos <=len(gs)):
			print gs[pos-1]
			print int(total)
		elif(diff==1 and a!=b):
			for i in range(len(gs),pos):
				ans +=diff
				total +=ans
			print int(ans)
			print int(total)
		elif(diff==1 and a==b==c):
			for i in range(len(gs),pos):
				total +=ans
			print int(ans)
			print total
		else:	
			for i in range(len(gs),pos):
				ans *=diff
				total +=ans
			print int(ans)
			print int(total)
	elif(flag==2):
		ans = c
		if(pos<=len(gs)):
			print gs[pos-1]
			print total
		else:
			for i in range(len(gs),pos):
				ans +=diff
				total+=ans
			print ans
			print total
	t -=1

	
for _ in range(input()):
  x=int(raw_input())
  i=1
  p=0
  while (p<=x):
    p=2**i +i
    i+=1
  #print i,p>x
  if(p>x):
    i-=2
    p=(2**i)+i
  #print i,p
  ps=abs(p-x)
  if (ps%2==0) and (ps<2**i):
    #print 'Yes'
    if (ps/2)%2==0:
      print 'LEFT'
    else:
      print 'RIGHT'
  else :
    print 'NO'
  #print i,ps,2**i
#include<iostream>
int main()
{
   std::cout<<"Welcome2C^3";
   return 0;
}
#include <iostream>
#include <cstdio>
using namespace std;
 
int dp[10][10];
int power(int n,int exp)
{
    int ans=1;
    for(int i=1;i<=exp;++i)
    {
        ans*=n;
    }
    return ans;
}
void init()
{
    dp[0][0]=1;
    dp[1][0]=2;
    dp[1][1]=2;
    dp[1][2]=2;
    dp[1][3]=1;
    dp[1][4]=1;
    dp[1][5]=1;
    dp[1][6]=1;
    for(int i=2;i<=9;++i)
    {
        for(int j=0;j<=9;++j)
        {
            int m=power(j,i)%7;
            for(int k=0;k<7;++k)
            {
                dp[i][(m+k)%7]+=dp[i-1][k];
            }
        }
    }
    /*for(int i=2;i<=3;++i){
        for(int j=0;j<7;++j)
            printf("%d ",dp[i][j]);
        printf("\n");
    }*/
}
int dig[11];
void solve()
{
    int n;
    scanf("%d",&n);
    int num=n,digits=0;
    while(num>0)
    {
        dig[digits++]=num%10;
        num/=10;
    }
    int ans=0,curr=0;
    for(int i=digits-1;i>=0;--i){
        for(int j=0;j<dig[i];++j){
            int m=(power(j,i+1)%7+curr)%7;
            ans+=dp[i][(7-m)%7];
            //printf("%d %d ans: %d\n",i,j,ans);
        }
        curr+=power(dig[i],i+1);
    }
    if(curr%7==0) ans++;
    printf("%d\n",ans-1);
}
int main() {
	int t;
	init();
	scanf("%d",&t);
	while(t--)
	{
	    solve();
	}
	/*int ans=0;
	for(int i=0;i<=999;++i){
	    int j=1,cp=i,s=0;
	    while(cp>0){
	        s+=power(cp%10,j);
	        j++;
	        cp/=10;
	    }
	    if(s%7==0) ans++;
	}
	printf("actual: %d",ans);
	*/
	return 0;
}
from sys import stdin
a,b,c=map(int,stdin.readline().split())
if c-b>b-a:
    print c-b-1
elif c-b<b-a:
    print b-a-1
else:
    print c-b-1


#!/usr/bin/python

tmp = raw_input()
nums = raw_input().split()
nums = map(int, nums)
nums.sort()
print nums[((len(nums) + 1) / 2) - 1]

# your code goes here
import math
t=raw_input().split()
t=int(t[0])
val = 0.4342944819032518

while(t):
	x=raw_input().split()
	x=int(x[0])
	print int(x*val+1)
	
	t-=1
n,k=map(int,raw_input().split())
arr=map(int,raw_input().split())
arr.sort()
arr=filter(lambda x: x <=k, arr)
f=0


for i in range(0,len(arr)):
    
    brr=map(lambda x: x+arr[i] ,arr)
    brr[i]=-1
    

    if k in brr:
        f=1
        break
    
if f==1:
    print 'Yes'
else:
    print 'No'
    

n,q=map(int,raw_input().split())
sz=[]
idi=range(n+1)#array containing the objects idi[i]=i
for i in range(n+1):
    sz.append(1)
''' unite to trees by pointing one root of one to the other'''
def union(x,y):
    rootx=root(long(x))
    rooty=root(long(y))
    if(rootx==rooty):
        return
    if(sz[rootx]< sz[rooty]):
        idi[rootx]=rooty
        sz[rooty]+=sz[rootx]
    else:
        idi[rooty]=rootx
        sz[rootx]+=sz[rooty]
#checks whether given object have the same parent or not
def connected(x,y):
    return root(long(x))==root(long(y))
#finds the root of the object
def root(x):
    while(x!=idi[x]):
        x=idi[x]
    return x


for _ in xrange(q):
    t,x,y=map(int,raw_input().split())
    if(t==0):
        union(long(x),long(y))
    else:
        if(connected(long(x),long(y))==True):
            print "Yes"
        else:
            print "No"

        

# cook your code here
l=raw_input().split()
for i in l:
    j=0
    final=""
    while j<len(i):
        final+=i[j]
        if(i[j] in "aeiou"):
            j+=3
        else:
            j+=1
    print final+"",
#include<iostream>
#include<cstring>
using namespace std ;
#define ll long long int
int dp[2001][2001] ;
int main()
{
    int i,j,k,n,m,p,t ;
    cin >> t ;
    char a[100001] ;
    char b[100001] ;

    while(t--) {
        cin >> a ;
        cin >> b ;
        int k1,k2,k3,k4 ;
        int l1 = strlen(a) ;
        int l2 = strlen(b) ;
        memset(dp,0,sizeof(dp)) ;
        for(i=0;i<=l2;i++) dp[i][0] = i ;
        for(i=0;i<=l1;i++) dp[0][i] = i ;
        for(i=1;i<=l2;i++) {
            for(j=1;j<=l1;j++) {
                if(b[i-1] == a[j-1]) {
                    k1 = dp[i-1][j-1]  ;
                }
                else k1 = dp[i-1][j-1] + 1 ;
                k2 = dp[i-1][j] + 1 ;
                k3 = dp[i][j-1] + 1 ;
                dp[i][j] = k1<k2?(k1<k3?k1:k3):(k2<k3?k2:k3) ;
            }
        }
        cout << dp[l2][l1] << endl ;
    }

    return 0 ;
}

#include<iostream>
#include<climits>
#include<stdio.h>
using namespace std;
#define N 105

int maxi(int a,int b){
	return a>b?a:b;
}

int cal(int mat[][N],int num){
	int i,j;
	int** sol = new int*[num];
	for(i = 0; i <num; ++i)
    	sol[i] = new int[num];	
	sol[0][0]=mat[0][0];		
	for(i=1;i<num;i++)
		sol[i][0]=sol[i-1][0]+mat[i][0];	
	for(i=1;i<num;i++)
		sol[0][i]=sol[0][i-1]+mat[0][i];
	for(i=1;i<num;i++){
		for(j=1;j<num;j++){
			sol[i][j]=mat[i][j]+maxi(sol[i-1][j],sol[i][j-1]);
		}
	}
	return sol[num-1][num-1];		
}

int main(){
	int t;
	cin>>t;
	while(t--){
		int num,i,j,mat[N][N];
		float res;
		cin>>num;
		
		for(i=0;i<num;i++)
			for(j=0;j<num;j++)
				cin>>mat[i][j];
		res=cal(mat,num);
		int k=2*num - 3;
		if(res<0)
			cout<<"No funds\n";
		else
			printf("%f\n",res/k);				
	}
	return 0;
}
#include<iostream>
#include<cmath>
#include<cstdio>
#define MAX 1000005
#define MOD 1000000007
#define ll long long
using namespace std;
 
int numfact[MAX+5];
int count[11][MAX+5];
 
void precalc_fact()
{	
	for(int i=1;i<=MAX;i+=2)
		numfact[i]=0;
		
	for(int i=2;i<=MAX;i+=2)
		numfact[i]=1;
	
	for(int i=3;i<=MAX;i+=2)
		if(!numfact[i])
			for(int j=i;j<=MAX;j+=i)
				numfact[j]+=1;
}
 
int main()
{
	precalc_fact();
	for(int k=0;k<11;k++) count[k][0]=0;
	for(int i=1;i<MAX;i++)
	{
		for(int k=0;k<11;k++)
		{
			if(k==numfact[i]) count[k][i]=1+count[k][i-1];
			else count[k][i]=count[k][i-1];
		}
	}
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int a,b,n;
		scanf("%d%d%d",&a,&b,&n);
		int ct=count[n][b]-count[n][a];
		if(numfact[a]==n) ct++;
		printf("%d\n",ct);
	}
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll arr[100010];
ll bit[30];
vector<ll>v,vv;
int main()
{
	ll t,i,n,j;
	scanf("%lld",&t);
	ll ans=0;
	while(t--)
	{
		v.clear();
		vv.clear();
		//cin>>n;
		scanf("%lld",&n);
		for(i=0;i<n;i++)
		{
			scanf("%lld",&arr[i]);
			//cin>>arr[i];
			v.push_back(arr[i]);
		}
		ans=0;
		map<ll,ll>mm;
		map<ll,ll>::iterator it;
		mm.clear();
		ll jj=28;
		while(1)
		{
			mm.clear();
			vv.clear();
		
			for(i=0;i<v.size();i++)
			{
				for(j=jj;j>=0;j--)
				{
					if(v[i]&(1<<j))
					{
						mm[-j]++;
						
					}
				}
			}
			ll kk;ll flag=0;
			for(it=mm.begin();it!=mm.end();it++)
			{
				if(it->second>=2)
				{
					flag=1;
					kk=-(it->first);
					break;			
				}
			}
			if(flag==0)
			{
				break;
			}
			for(i=0;i<v.size();i++)
			{
				if(v[i]&(1<<kk))
				{
					vv.push_back(v[i]);
				}
			}
			v.clear();
			v=vv;
			jj=kk-1;
			ans+=(1<<kk);
			//cout<<ans<<endl;
		}
		printf("%lld\n",ans);
	}
}
#include<bits/stdc++.h>
#define mod 1000000007
#define ll long long int
using namespace std;
main()
{
       int t,z,z1,flag,i,j;
       char m[100000],w[1000000],temp;
	 	cin>>t;
       while(t--)
	   {
	   	flag=0;
	   char	a[26]={0},b[26]={0};
	   	  cin>>m;
	   	  cin>>w;
	   	  z=strlen(m);
	   	  z1=strlen(w);
	   	   if(z!=z1)
	   	   {
	   	   	  cout<<"NO"<<endl;
	   	   	  continue;
			  }
		  	   for(i=0;i<z;i++)
	   	  {
	   	  	a[m[i]-97]++;
	   	  	b[w[i]-97]++;
	   	  }
		  
	   	  for(i=0;i<26;i++)
	   	  {
	   	  	if(a[i]!=b[i])
	   	  	{
	   	  		flag=1;
	   	  		break;
				 }
		  }
		  if(flag==1)
		  cout<<"NO"<<endl;
		  else
		  cout<<"YES"<<endl;
	   }      
}

#include <iostream>
#include<stdio.h>
using namespace std;
int a[1000];
void solve()
{
    int n,x,ans=-1,cnt=0;
    for(int i=0;i<=500;i++) a[i]=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        a[x]++;
    }
    for(int i=500;i>=0;i--)
    {
        if(a[i]>cnt)
        {
            cnt=a[i];
            ans=i;
        }
    }
    printf("%d %d\n",ans,cnt);
}
int main()
{
   int t;
   cin >> t;
   for(int i=0;i<t;i++) solve();
   
   return 0;
}

t=int(raw_input())
for i in range(t):
    a,b=map(int,raw_input().split())
    print str(a**b)[-1:]    
#include<stdio.h>
long long int GCD(long long int x,long long int y)
{
    if(y==0)
    return x;
    else
    return GCD(y,x%y);
}
int main()
{
    long long int tcase;
    scanf("%lld",&tcase);
    while(tcase--)
    {
        long long int n,i,k;
        scanf("%lld",&n);
        long long int a[100001],gcd;
        for(i=0;i<n;i++)
        scanf("%lld",&a[i]);
        k=a[0];
        for(i=1;i<n;i++)
        {
            k=GCD(k,a[i]);
        }
        printf("%lld\n",k);
    }
    return 0;
}
#include <bits/stdc++.h>

using namespace std;

char op_reverse(char op)
{
    if(op=='+')
         return '-';
    else if(op=='-')
        return '+';
    else if(op=='*')
         return '/';
    else if(op=='/')
         return '*';
}

float calc(long long int num,long long int num2,char op)
{
    if(op=='+')
         return num+num2;
    else if(op=='-')
        return num-num2;
    else if(op=='*')
         return num*num2;
    else if(op=='/')
         return (float)num/num2;
}

int isop(char c)
{
    switch(c)
    {
        case '+': return 1; break;
        case '-' : return 1; break;
        case '*' : return 1 ;
        case '/' : return 1;

        default : return 0;
            }
}

int main()
{
    int test;
    cin>>test;
    string str;
     getline(cin,str);
    while(test--)
    {

        getline(cin,str);
        int n=str.length();
        int op_flag=0;
        int equals=0;
        char op;
        string num(1,str[0]);
        string num2,num3;
        for(int i=1;i<n;i++)
        {
        	if(str[i]==' ')
        	    continue;
            if(equals==0 && str[i]=='=')
            {
                equals++;
            }
            else if(op_flag==0 && isop(str[i]) )
            {
                op_flag=1;
                op=str[i];
            }
            else if(op_flag==0)
            {
                num=num+str[i];
            }
            else if(op_flag==1 && equals==0)
            {
                num2=num2+str[i];
            }
            else
               num3=num3+str[i];
        }
        if(num=="x" || num=="-x")
        {
            long long int n2=atoi(num2.c_str());
            long long int n3=atoi(num3.c_str());
         if(num=="x")
            printf("%.6f\n",calc(n3,n2,op_reverse(op)));
         else
            printf("%.6f\n",-calc(n3,n2,op_reverse(op)));
        }
        else if(num2=="x" || num2=="-x")
        {
            long long int n=atoi(num.c_str());
            long long int n3=atoi(num3.c_str());
         if(num2=="x")
         {
            if(op=='/' || op=='-')
               printf("%.6f\n",calc(n,n3,op));
               
            else 
              printf("%.6f\n",calc(n3,n,op_reverse(op)));
         }
         else
         {
         	    if(op=='/' || op=='-')
               printf("%.6f\n",-calc(n,n3,'-'));
            else
              printf("%.6f\n",-calc(n3,n,op_reverse(op)));

         }
        }
        else
        {
            long long int n=atoi(num.c_str());
            long long int n2=atoi(num2.c_str());
         if(num3=="x")
            printf("%.6f\n",calc(n,n2,op));
          else
            printf("%.6f\n",-calc(n,n2,op));
        }
    }
    return 0;
}

#include <bits/stdc++.h>
using namespace std;

double dist(double a,double b,double c)
{
	return sqrt(pow(a,2)+pow(b,2)+pow(c,2));

}
struct subset
{
    int parent;
    int rank;
};
int find(struct subset subsets[], int i)
{
    // find root and make root as parent of i (path compression)
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
 
    return subsets[i].parent;
}
 
// A function that does union of two sets of x and y
// (uses union by rank)
void Union(struct subset subsets[], int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);
 
    // Attach smaller rank tree under root of high rank tree
    // (Union by Rank)
    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;
 
    // If ranks are same, then make one as root and increment
    // its rank by one
    else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}


int main()
{
	int t;
	cin>>t;
	while(t--)
	{
	
	
		 int n;
		double d;
		cin>>n>>d;
		int arr[n];
		double a[n],b[n],c[n];
		 int val[n];
		
		for( int i=0;i<n;i++)
		{
		
			cin>>a[i]>>b[i]>>c[i];
			arr[i]=i;
				val[i]=0;
		
		}


    struct subset *subsets =
        (struct subset*) malloc( n * sizeof(struct subset) );
 
    for (int v = 0; v < n; ++v)
    {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

 

		
		
		
		
		
		for(int i=0;i<n;i++)
		{	
			
			
			for(int j=i+1;j<n;j++)
			{
				if(dist(a[i]-a[j],b[i]-b[j],c[i]-c[j])<=d)
					{
						
      				 	 int x = find(subsets, arr[i]);
       				        	int y = find(subsets,arr[j]);
       				 
					Union(subsets, x, y);		
					
					
					}

			
			
			}
		
		
		}
		int count=0;
		for(int i=0;i<n;i++)
		{

			val[find(subsets, arr[i])]=1;

			
		
		
		}

				for(int i=0;i<n;i++)
		{
			if(val[i]==1)
				count++;
			
		
		
		}
		
		
		
	cout<<count<<endl;
	
	
	
	
	
	
	}



return 0;
}
#include <stdio.h>
#include <algorithm>
using namespace std;
 
typedef long long LL;
 
LL a[100];
LL b[100];
 
int main(int argc, char* argv[])
{
    int h, i, j, t, n;
    scanf("%d", &t);
    for(h=0;h<t;h++)
    {
        scanf("%d", &n);
        for(i=0;i<n;i++)
        {
            scanf("%lld", &a[i]);
        }
        sort(a,a+n);
        int start=0, cnt=0;
        while(1)
        {
            LL acc=a[start];
            bool got_it=false;
            int nextstart=0;
            for(i=start+1;i<n;i++)
            {
                if(a[i]>acc)
                {
                    nextstart=i;
                    got_it=true;
                    break;
                }
                acc+=a[i];
            }
            b[cnt++]=acc/a[start];
            if(got_it==false)
            {
                break;
            }
            start=nextstart;
        }
        LL ans=1;
        for(i=0;i<cnt;i++)
        {
            ans*=b[i]+1;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
 
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<pii> vpii;
typedef unsigned long long llu;

#define debug(x) cerr<<#x<<" "<<x<<endl;
#define f first
#define s second
#define mp make_pair
#define pb push_back
int G[25][25];
void do_it_here()
{ set<int> A;
    for(int i=1;i<=21;i++)
        G[1][i]=G[i][1]=1;
    for(int i=2;i<=21;i++)
    {
        for(int j=2;j<=21;j++)
        {
            for(int x=1;x<=i;x++)
            {
                for(int y=1;y<=j;y++)
                {
                    int h;
                    h=G[x-1][y-1]^ G[x-1][j-y] ^G[i-x][y-1] ^G[i-x][j-y];
                    A.insert(h);
                }
            }
            int start=0;
            while(1)
            {
                if(A.count(start)==0)
                {G[i][j]=start; break;}
                else
                    start++;
            }
            A.clear();
            }
        }
    }
int main()
{
    int t,n,m;
    do_it_here();
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d",&n,&m);
        if(G[n][m])
            printf("Alice\n");
        else
            printf("Bob\n");

    }
    return 0;
}

#include <bits/stdc++.h>
using namespace std;
int main()
{
	string tn,nn;
	int t,n,q;
	//cin>>t;
	//while(t--) {
		map<string,string> mp;
		cin>>n>>q;
		while(n--) {
			cin>>tn>>nn;
			mp[nn]=tn;
		}
		while(q--) {
			cin>>nn;
			if(mp.find(nn)== mp.end())
				cout<<"Name not found\n";
			else
				cout<<mp[nn]<<endl;
		}
	//}

}
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

struct Point {
    long long x, y;
    bool operator <(const Point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
};

long long cross(const Point &O, const Point &A, const Point &B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

vector <Point> convex_hull(vector <Point> P) {

    int n = P.size(), k = 0;
    vector<Point> H(2*n);

    sort(P.begin(), P.end());

    for(int i = 0; i<n; i++) {
        while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--;
        H[k++] = P[i];
    }

    for(int i=n-2, t=k+1; i>=0; i--) {
        while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--;
        H[k++] = P[i];
    }

    H.resize(k-1);
    return H;
}

long double dist(Point p1, Point p2) {
	return sqrt(1.0*(p1.x - p2.x)*(p1.x - p2.x)+1.0*(p1.y - p2.y)*(p1.y - p2.y));
}

long long abs_(long long a) {
	if(a < 0) return -a;
	return a;
}

int main() {
	int T;
	cin >> T;
	while(T--) {
		int n;
		cin >> n;
		long long t1, t2;
		if(n == 1) {
			cin >> t1 >> t2;
			cout << 0 << " " << 0 << endl;
			continue;
		}
		vector <Point> p(n);
		for(int i=0; i<n; i++) {
			cin >> t1 >> t2;
			p[i].x = t1;
			p[i].y = t2;
		}
		vector <Point> convex = convex_hull(p);
		long long A = 0;
		long double P = 0;
		for(int i=0; i<convex.size()-1; i++) {
			P += dist(convex[i], convex[i+1]);
		}
		P += dist(convex[0], convex[convex.size()-1]);
		for(int i=1; i<convex.size()-1; i++) A += abs_(cross(convex[0], convex[i], convex[i+1]));
		A /= 2;
		cout << floor(P) << " " << A << endl;
	}
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
int main()
{ int t,i;
 long long int value,sum ,n;
 long long int mod=1000000007 ;
 cin>>t;
 while(t--)
 {
     cin>>n;
     sum=0;
    value=7;
 for(i=0;i<n;i++)
 {
     sum=sum+value;
     sum=sum%mod;
     value=value*10 +7;
     value=value%mod;
     }
     cout<<sum<<endl;
 }



 return 0;
}
#include <bits/stdc++.h>
using namespace std;
int main() {
	int t,i;
	cin>>t;
	while(t--) {
		stack<int> ss;
		string exp;
		cin>>exp;
		for(i=0;i<exp.size();i++) {
			if(i==0 && (exp[i]==')'||exp[i]=='}'||exp[i]==']')) {
				cout<<"no\n";break;
			}

		 if(exp[i]==')'||exp[i]=='}'||exp[i]==']') {
		 	char ch=exp[i];
				if((ch==')'&& ss.top()=='(') || (ch=='}'&& ss.top()=='{')|| (ch==']'&& ss.top()=='[')) 
					ss.pop();
				else {
					cout<<"no\n"; break;
				}
			}

			else if(exp[i]=='('||exp[i]=='{'||exp[i]=='[')
				ss.push(exp[i]);
		}

		if(ss.empty() and i!=0)
			cout<<"yes\n";
	}
	return 0;
}
#include <bits/stdc++.h>
#include <stdio.h>

using namespace std;

unsigned long long f[25];
char ans[26];

int changer (int n)
{
	int i = 25;
	unsigned long long k = f[n];
	while (k > 0) {
		unsigned long long r = k%10;
		ans[i] = '0' + r;
		i--;
		k = k/10;
	}
	return i+1;
}

void precompute ()
{
	f[1] = 0;
	f[2] = 1;
	for (int i = 3 ; i <= 22 ; i++)
	{
		f[i] = f[i-1]*(i-1);
		f[i] += f[i-2]*(i-2);
	}
}

int main ()
{
	precompute ();
	int t;
	scanf ("%d",&t);
	while (t--)
	{
		int k,n,count = 0;
		scanf ("%d %d",&k,&n);
		if (k == 0 && n == 1) {
			printf ("%d\n",1);
			continue;
		}
		else if (k < 10)
		{
			for (int i = changer (n) ; i <= 25 ; i++)
				if (ans[i] == '0' + k) count++;
		}
		else if (k == 100)
		{
			for (int i = changer (n) + 2 ; i <= 25 ; i++) {
				if (ans[i] == '0' && ans[i-1] == '0' && ans[i-2] == '1')
					count++;
			}
		}
		else {
			for (int i = changer(n) + 1 ; i <= 25 ; i++) {
				if (ans[i] == '0' + k%10 && ans[i-1] == '0' + (k/10)%10)
					count++;
			}
		}
		printf ("%d\n",count);
	}

	return 0;
}

    # include<bits/stdc++.h>
    # define LL long long int
     
    using namespace std;
     
    int main(void)
    {
    	LL T , N , K;
    	for (cin>>T;T--;)
    	{
    		cin>>N>>K;
    		if (K > N-K)
    		        K = N-K;
    		LL ans = 1LL,num=1LL,den=1LL;
    		for (int i=0;i<K;i++)
    		{
    				ans *= ((N-i));
    				ans /= (i+1);
    		}
    		cout<<ans<<endl;
    	}
    	return (0);
    } 
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int i,j,k=0,c,b,f;
    string a;
    while(1)
    {
        f=1;
        getline(cin,a);
        if(a[0]=='/'&&a[1]=='/') break;
        j=a.length();
        for(c=0;c<j;c++)
        {
            if(a[c]=='i'&&a[c+1]=='f')
            {
                //cout<<"1"<<endl;
                f=0;
                break;
            }
            if(a[c]=='w'&&a[c+1]=='h'&&a[c+2]=='i'&&a[c+3]=='l'&&a[c+4]=='e')
            {
                 //cout<<"2"<<endl;
                f=0;
                break;
            }
            if(a[c]=='f'&&a[c+1]=='o'&&a[c+2]=='r')
            {
                 //cout<<"3"<<endl;
                f=0;
                break;
            }
            if(a[c]=='e'&&a[c+1]=='l'&&a[c+2]=='s'&&a[c+3]=='e')
            {
                 //cout<<"4"<<endl;
                f=0;
                break;
            }
            if(a[c]=='{')
                {
                     //cout<<"5"<<endl;
                    f=0;
                    break;
                }
            if(a[c]=='}')
            {
                 //cout<<"6"<<endl;
                f=0;
                break;
            }
            if(a[0]=='#')
            {
                 //cout<<"7"<<endl;
                f=0;
                break;
            }
            if(a[c]=='('&&a[c+1]==')')
            {
                 //cout<<"8"<<endl;
                f=0;
                break;
            }
            if(a[c]==';')
            {
                //cout<<"9"<<endl;
                f=0;
                break;
            }
            if(a[c]=='('&&a[c+1]!='"')
            {
                f=0;
                break;
            }
        }
        if(f==1) k++;
    }
    printf("%d",k);
    return 0;
} 
#include <bits/stdc++.h>
using namespace std;
vector<int> visited(1000,0);
vector<int>vec[1000];
int n;
int dfs(int s)
{
	stack<int> S;
	S.push(s);
	visited[s]=1;
	int no=1;
	while(!S.empty()) {
		s=S.top();S.pop();
		for(int i=0;i<vec[s].size();i++) {
			if(visited[vec[s][i]]!=1) {
				visited[vec[s][i]]=1;
				S.push(vec[s][i]); no++;
			}
		}
	}
	return no;
}
int main()
{
	int n,x,y,cnt=0;
	cin>>n;
	vector<int> v;
	for(int i=1;i<=n;i++) {
		cin>>x>>y;x--;y--;
		vec[x].push_back(y);vec[y].push_back(x);
	}
	for(int i=0;i<n;i++) { 
		if(visited[i]!=1) {
			int no=dfs(i);
			v.push_back(no);
			cnt++;
		}
	}
	cout<<cnt<<endl;
	sort(v.begin(),v.end());
	for(int i=0;i<v.size();i++)
		cout<<v[i]<<" ";
	cout<<endl;
	
}
#include <bits/stdc++.h>
using namespace std;
int main() {
	int t,i,temp;
	cin>>t;
	getchar();
	while(t--) {
		string s;
		getline(cin,s);

		for(i=0;i<s.size();i++) {
			if(s[i]>='a' and s[i]<='z') {
				int k=s[i]-'a';
				cout<<k*k;				
			}
			if(s[i]==' ') {
				cout<<"$";
				continue;
			}
			if(s[i+1]>='a'and s[i+1]<='z')
				cout<<"-";
		}
		cout<<endl;
		}	 
		return 0;
}
import sys
from math import sqrt
def RESQ():
	t = int(raw_input())
	while t:
		n = int(raw_input()); diff = sys.maxint
		for i in range(1,int(sqrt(n))+1):
			if n % i is 0 and diff > (n/i - i):
				diff = n/i - i
		print diff; t-=1
def sieve(n):
	L = [0 for i in range(n+1)]; Pr = []
	for i in range(2,int(sqrt(n))+1):
		if L[i] is 0:
			Pr.append(i)
			for j in range(2*i,n+1,i): L[j] = 1
	return Pr
P = sieve(int(5e6))
def CDQU1():
	t = int(raw_input())
	while t:
		m,n = map(int,raw_input().split())
		m1,n1 = m,n; sum = 0
		SS = [0 for i in range(n-m+1)]
		if m1 == 1: m1 = 2; SS[0] = 1
		for i in P:
			if i <= int(sqrt(n)):
				if m1 < i: m1 = i
				low = ( m1 / i ) * i
				if low < m1 or low == i: low+=i
				for j in range(low,n+1,i):
					SS[j-m] = 1
			else: break
		for i in range(n-m+1):
			if SS[i] is 0:
				sum+=(i+m)
		print sum
		t-=1
if __name__ == '__main__': CDQU1()

#include<bits/stdc++.h>
using namespace std;
int main()
{
string  str;
int t,c;
cin>>t;
while(t--)
{
     c=0;
cin>>str;
for(int i=0;i<str.size();i++)
{
if(str[i]=='a' || str[i]=='e' ||str[i]=='i' ||str[i]=='o' ||str[i]=='u' )
c++;
else if(str[i]=='A' || str[i]=='E' ||str[i]=='I' ||str[i]=='O' ||str[i]=='U' )
c++;
}
if(c==0)
cout<<"no"<<endl;
else
cout<<"yes"<<endl;
}
}


import math
l=[]
for t in range(int(raw_input())):
	n=int(raw_input())
	l.append(n)
n=max(l)
p=int(math.sqrt(n))
a=[0]*(p+1)
for i in range (1,p+1):
	a[i]=a[i-1]+i*i
for n in l:
	p=int(math.sqrt(n))
	print a[p]
# your code goes here
"""created by : rjohari23"""

t = int(raw_input())
while t:
	s1 = raw_input()
	s2 = raw_input()
	
	
	ans = s1.replace(s2,'')
	#print len(ans)
	if len(ans)>0:
		print ans
	else:
		print 0
	
	t -= 1
    #include<stdio.h>
    #include<math.h>
    int main()
    {
    	int test,N;
    	long long ans;
    	scanf("%d",&test);
    	while(test--)
    	{
    		scanf("%d",&N);
    		if(N==2)
    		{
    			printf("15\n");
    			continue;
    		}
    		ans=pow(N,N+1)-(N-1);
    		printf("%lld\n",ans);
    	}
    	return 0;
    } 
test=input()
for num in range(test):
    s=raw_input()
   
    n=1
    x=""
    while n<(len(s)):
      p=(str(s[n-1])+str(s[n]))
      
      r=int(p)
      if(r<55)and (r!=32):
        p=p+str(s[n+1])
        n=n+1
      r=int(p)
      x=x+chr(r)
      
      n=n+2
   
    
    print x
    
mod=10**9+7
f=[1,1]
a=1
b=1
for i in xrange(1010):
    c=a+b
    a=b
    b=c
    f.append(c%mod)
t=input()
for _ in xrange(t):
    a,b=map(int,raw_input().split())
    s=sum(f[a-1:b])
    print s%mod

from itertools import combinations as c
def primes(n):
    """ Returns  a list of primes < n """
    sieve = [True] * n
    for i in xrange(3,int(n**0.5)+1,2):
        if sieve[i]:
            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)
    return [2] + [i for i in xrange(3,n,2) if sieve[i]]

for i in range(input()):
	n,l,r = map(int,raw_input().split())
	p = primes(n+1)
	su = 0
	for item in p:
		a = r/item  -  (l-1)/item
		su += a
	to_sub = 0
	ll = len(p)
	for i in range(ll):
		for j in range(i+1,ll):
		#print comb
			pro = p[i]*p[j]
			a = (r/pro)
			b = ((l-1)/pro)
			#print l,pro,l/pro
			to_sub += a-b
		#print to_sub
	print su-to_sub





import sys 
f = sys.stdin
MOD = 1000000007
T = int(f.readline())
while T:
	A,B = [int(x) for x in f.readline().split()]
	ans = A * B - A - B
	ans %= MOD
	if ans < 0 :
		ans += MOD 
	print ans 
	T -= 1
import math
n=input()
s=math.factorial(n)+3**n-n
print (s%(10**9+7)) 
from math import*
for i in range (input()):
    num ,k = map(int,raw_input().split())
    a = factorial(num)
    arr = map(int,raw_input().split())
    maxi = max(arr)
    print a%maxi 
array=["0","1","2","3","4","5","6","7","8","9"]
for k in range(input()):
     string=raw_input()
     l=""
     for k in string:
             if k not in array:
                     l+=k
     print l
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    x=bin(n)[2:]
    x=len(x)-1
    x2=pow(2,x)
    ans=2*(n-x2)
    if ans==0:
        print x2
    else:
        print ans
# cook your code here
n,m,t=map(int,raw_input().split())
a=[[0 for i in range(m)]for i in range(n)]
b=[[0 for i in range(m)]for i in range(n)] 
q=[]
m_max=0
f_max=0
for i in range(n):
    q.append(raw_input())
    for j in range(m):
        if i==0 or j==0:
            if q[i][j]=='M':
                a[i][j]=1
                m_max=1
            else:
                b[i][j]=1
                f_max=1
for i in range(1,n):
    for j in range(1,m):
        if q[i][j]=='M':
            a[i][j]=min(min(a[i-1][j],a[i][j-1]),a[i-1][j-1])+1
        else:
            b[i][j]=min(min(b[i-1][j],b[i][j-1]),b[i-1][j-1])+1
        m_max=max(m_max,a[i][j])
        f_max=max(f_max,b[i][j])
for _ in range(t):
    k,s=map(str,raw_input().split())
    if(s=='M'):
        if(int(k)>m_max):
            print 'no'
        else:
            print 'yes'
    else:
        if(int(k)>f_max):
            print 'no'
        else:
            print 'yes'
from sys import stdin, stdout
t = int(stdin.readline())
while t:
	t -= 1
	n, m, k = map(int, stdin.readline().strip().split(' '))
	N = stdin.readline().strip()
	M = stdin.readline().strip()
	M = M[:k]
	count = 0
	for i in range(len(N)-k+1):
		s = N[i:i+k]
		if s == M:
			count += 1
	if count == 0:
		count = -1
	stdout.write(str(count)+'\n')
#include<iostream>
#include<string.h>
using namespace std;
int main()
{
    int i,j,k,t,a[124]={0},p=0;
    char s[1000001],ch;
    cin>>t;
    for(i=0; i<t; i++)
    {
        cin>>s;
        for(j=0; s[j]!=0; j++)
        {
            k=s[j];
            a[k]++;
            if(k>=65 && k<=97)
            {
                k=k+32;
                a[k]++;
            }
            else if(k>=97 && k<=123)
            {
                k=k-32;
                a[k]++;
            }
        }
        for(j=97; j<=123; j++)
        {
            if(a[j]>1)
            {
                ch=j;
                cout<<ch<<" ";
                p=1;
            }
        }
        if(p==0)
            cout<<-1;
        memset(a,0,sizeof(a));
        cout<<"\n";
        p=0;
    }
    return 0;
}

#include <bits/stdc++.h>
using namespace std;
int a[10004];
int main() {
    int t;
    scanf("%d",&t);
    while(t--){
        int n,i,j;
        scanf("%d",&n);
        for(i=0;i<n;i++)
            scanf("%d",&a[i]);
        for(i=0;i<n-1;i++){
            int c=0;
            for(j=i+1;j<n;j++){
                if(a[j]<a[i])
                    c++;
            }
            printf("%d ",c);
        }
        printf("0\n");
    }
	return 0;
}

s=raw_input()
t=int(input())
while t>0:
	a,b=map(int,raw_input().split())
	if s[(a-1)%len(s)]==s[(b-1)%len(s)]:
		print "Yes"
	else:
		print "No"
	t-=1
T=int(raw_input())
for i in xrange(T):
	N,K=map(int,raw_input().split())
	A=map(int,raw_input().split())
	K,B=K+1,[0]*N
	B[0]=max(0,A[0])
	for j in xrange(1,K):
		B[j]=max(A[j],B[j-1])
	for j in xrange(K,N):
		B[j]=max((A[j]+B[j-K]),B[j-1])
	print B[N-1]


import sys
for i in sys.stdin:
	z =  i.strip()
	l = z.find('//')
	ss = z[:l]
	sr = z[l:]
	sp = ss.replace('->','.')
	print sp+sr
    #include<stdio.h>
    #include<string.h>
     
    int main()
    {
        int i,T,Len,Alice,Bob;
        char M[28],S1[102],S2[102],Hash[28],Hash1[28],Hash2[28];
        scanf("%d",&T);
        getchar();
        gets(M);
        for(i=0; i<26; i++) Hash[M[i]-97] = i;
        while(T--)
        {
           Alice=Bob=0;  
           for(i=0; i<26; i++) Hash1[i]=Hash2[i]=0; 
           gets(S1);
           gets(S2);
           Len = strlen(S1);
           for(i=0; i<Len; i++) { Hash1[S1[i]-97]++;  Hash2[S2[i]-97]++; }
           
           for(i=0; i<26; i++)
           {
             if(Hash1[i]>Hash2[i]) Alice+=Hash[i];
             else if(Hash1[i]<Hash2[i]) Bob+=Hash[i];
           }
           
           if(Alice>Bob) printf("ALICE\n");
           else if(Alice<Bob) printf("BOB\n");
           else printf("TIE\n");
        }
      return 0;    
    } 
/*	Jayesh Lahori	    */
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<stack>
#include<queue>
#include<map>
#include<set>

using namespace std;

/* General Declarations */

#define INF		1000000007
#define LL		long long int
#define SI(n)		scanf("%lld",&n);
#define SC(c)		scanf("%c",&c);
#define SS(s)		scanf("%s",s);
#define FOR(x,a,b)	for(LL x=a;x<b;x++)
#define REP(i,n)	for(LL i=0;i<n;i++)
#define MP		make_pair
#define PB		push_back


/* Container's */

#define	VI		vector<LL>
#define PLL             pair<LL,LL>  /* A Single Pair  */
#define VP		vector<PLL> /* Vector of Pairs */
#define VS		vector<string>
#define VVI		vector<VI>
#define VVS		vector<VS>

LL parent[1000010];
LL children[1000010];

LL find(LL x)
{
	if(parent[x]==x)
		return x;
	return parent[x]=find(parent[x]);
}

int main()
{
	LL tc;
	SI(tc);	
	while(tc--)
	{

		LL n,m;
		SI(n);
		SI(m);

		REP(i,n+1)
		{
			parent[i]=i;
			children[i]=1;
		}

		priority_queue<pair<LL,PLL > > q; 

		while(m--)
		{
			LL x,y,w;
			SI(x);
			SI(y);
			SI(w);
		
			x--;
			y--; /* O based indexing of Vertices */

			q.push(MP(-w,MP(x,y))); /* q take pair of LL and PLL , So First do a MP for PLL then MP for overall pair */
		}

		LL ans=0;
		LL cnt=0;

		while(!q.empty())
		{
			if(cnt==n-1)
				 break;   /* All Vertices are included in MST */

			pair<LL,PLL> dummy=q.top();
			q.pop();

			LL x=dummy.second.first;  /* 1st of Inner Pair */
			LL y=dummy.second.second; /* 2nd of Inner Pair */ 
			LL w=-dummy.first;        /* First of Outer Pair */

			LL c1 = find(x);
			LL c2 = find(y);
			if(c1 != c2)
			{
				if(children[c1] < children[c2]) 
					swap(c1, c2);
				children[c1] += children[c2];
				children[c2]=1;
				parent[c2] = c1;
				ans+=w;
				cnt+=1;
			}

		}
		printf("%lld\n",ans); /* Cost of Spanning Tree */
	}

	return 0;
}

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cctype>
#include <complex>
 
using namespace std;
 
#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define Sl(x) scanf("%I64d",&x)
#define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl
 
const double PI = 4*atan(1);
typedef complex<double> base;
 
vector<base> omega;
int FFT_N;
void init_fft(int n)
{
     FFT_N  = n;
     omega.resize(n);
     double angle = 2 * PI / n;
     
     for(int i = 0; i < n; i++)
          omega[i] = base( cos(i * angle), sin(i * angle));
}
 
void fft (vector<base> & a)
{
     int n = (int) a.size();
     if (n == 1)  return;
     int half = n >> 1;
     
     vector<base> even (half),  odd (half);
     for (int i=0, j=0; i<n; i+=2, ++j)
     {
          even[j] = a[i];
          odd[j] = a[i+1];
     }
     fft (even), fft (odd);
     
     for (int i=0, fact = FFT_N/n; i < half; ++i)
     {
          base twiddle =  odd[i] * omega[i * fact] ;
          a[i] =  even[i] + twiddle;
          a[i+half] = even[i] - twiddle;
     }
}
void multiply (const vector<long long> & a, const vector<long long> & b, vector<long long> & res)
{
     vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end());
     int n = 1;
     while (n < 2*max (a.size(), b.size()))  n <<= 1;
     fa.resize (n),  fb.resize (n);
     
     init_fft(n);
     fft (fa),  fft (fb);
     for (size_t i=0; i<n; ++i)
          fa[i] = conj( fa[i] * fb[i]);
     fft (fa);
 
     res.resize (n);
     for (size_t i=0; i<n; ++i)
          res[i] = (long long) (fa[i].real() / n + 0.5);
}
 
int main() {
    int i,j,t,abcd;
    S(t);
    while(t--) {
        int n1,n2;
    	vector<long long> v1,v2,res;
    	S(n1); S(n2);
    	F(i,0,n1+1) {
    		int x;
    		S(x);
    		v1.pb(x);
    	}
    	F(i,0,n2+1) {
    		int x;
    		S(x);
    		v2.pb(x);
    	}
    	multiply(v1,v2,res);
	while ( !res.empty() && *(res.end()-1) == 0 ) res.pop_back();
    	int n = res.size();
    	printf("%d\n", n-1);
    	F(i,0,n) printf("%d ", res[i]);
    	printf("\n");
    }
    return 0;
} 
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<vector>
#include<fstream>
#include<iomanip>
#include<bitset>
#include<deque>
#include<string>
#include<map>
#include<cstring>
#include<sstream>
#include<cmath>
#include<cassert>
using namespace std;

#define MOD 100001
long long ans;

void compute (int f, int l, int d)
{
	if (f < 0 || l < 0)
		return;
	assert (f <= l);
	int n = (l-f)/d+1;
	long long sum = ((long long)(f+l)*(long long)n)/2;
	ans = (ans+sum)%MOD;
}

int main ()
{
	int T;
	scanf ("%d", &T);
	for (int t = 0; t < T; t++)
	{
		int N;
		ans = 0;
		scanf ("%d", &N);
		int start_odd, start_even, end_odd, end_even;
		if (N%2 == 1)
		{
			start_odd = (N+1)/2;
			end_odd = (N-6*(N/6)+1)/2;
			start_even = (N-3)/2+1;
			end_even = (N-3-6*((N-3)/6))/2+1;
		}
		else
		{
			start_odd = (N-3+1)/2; 
			end_odd = (N-3-6*((N-3)/6)+1)/2;
			start_even = N/2+1;
			end_even = (N-6*(N/6))/2+1;
		}
		compute (end_odd, start_odd, 3);
		compute (end_even, start_even, 3);
		printf ("%lld\n", ans);
	}
	return 0;
}

#include <stdio.h>
#include <string.h>
int diff(int a[]) 
{
	int max = 0,min = 10000000,i;
	for(i = 0; i < 3; i++) {
		if(a[i] > max)
			max = a[i];
		if(a[i] < min)
			min = a[i];
		}
		return max - min + 1;
}
int value(char a[], int i) 
{
	if(a[i] == 'B')
		return 0;
	else if(a[i] == 'R')
	 	return 1;
	else
		 return 2;
}
int main() 
{
	char a[100001];
	int b[3] = {0};
	int s,i,k,min = 10000000;
	int t,l;
	scanf("%d",&t);
	while(t--) {
		min = 10000000;
		scanf("%s",a);
			b[0] = b[1] =b[2] = 0;
		l = strlen(a);
		for(i = 0; i < l; i++) {
			k = value(a,i);
			b[k] = i+1;
			if(b[0] != 0 && b[1] != 0 && b[2] != 0) {
				s = diff(b);
				if (s < min) {
					min = s;
				}
			}
			if(min == 3)
				break;
			
			
		}
		printf("%d\n",min );
		
	}
	return 0;
}
// AUTHOR : SIKANDER MAHAN
// sikander_nsit
// PLAGIARISM IS BAD

#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include<string.h>
#define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)
#define all(c) c.begin(),c.end()
#define mod 1000000007
#define itor(c) typeof(c.begin())
#define ll long long
#define vi vector<int>
#define vs vector<string>
#define si set<int>
#define msi multiset<int>
#define ii pair<int,int>
#define sii set<ii>
#define vii vector<ii>
#define vvi vector<vi>
#define pb push_back
#define mp make_pair

using namespace std;

long long exponent(long long base,int e)
{
    long long result=1;
    while(e>0)
    {
        if(e%2)
            result=(result*base)%mod;
        e=e>>1;
        base=(base*base)%mod;
    }
    return result;
}

long long degree(long long a)
{
    long long k=1000000005;
    long long res = 1;
    long long cur = a;
    while (k)
    {
        if (k%2)
        {
            res = (res * cur)%mod;
        }
        k /= 2;
        cur = (cur * cur)%mod;
    }
    return res;
}

int main()
{
    //ios::sync_with_stdio(false);
    //freopen("input.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int t=0,i=0,j=0,n=0,k=0,len,x;
    ll inv=degree(25LL);
    ll temp,num,ans;
    cin>>t;
    string str;
    for(i=0;i<t;++i)
    {
        cin>>n;
        x=n;
        cin>>str;
        len=str.length();
        k=min(len,n);
        temp=1;
        ans=0;
        for(j=0;j<k;++j)
        {
            temp*=(str[j]-96);
            temp%=mod;
            ans+=temp;
            ans%=mod;
        }
        temp--;
        if(temp<0)
            temp+=mod;
        temp=(temp*26)%mod;
        n=max(0,n-len);
        num=exponent(26LL,n)-1;
        if(num<0)
            num+=mod;
        temp=(temp*num)%mod;
        temp=(temp*inv)%mod;
        ans=(ans+temp)%mod;
        if(x>=len)
        ans--;
        if(ans<0)
        ans+=mod;
        cout<<ans<<endl;
    }
	return 0;
}

#include<bits/stdc++.h>
using namespace std;
char mat[1010][1010];
bool visited[1010][1010];
int dist[1010][1010];
int x1[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,m;
		cin>>n>>m;
		for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
		{
			visited[i][j]=false;
			dist[i][j]=INT_MAX;
		
		}
		for(int i=0;i<n;i++)
		cin>>mat[i];
		queue<pair<int,int> > q;
		q.push(make_pair(0,0));
		dist[0][0]=0;
		visited[0][0]=true;
		while(!q.empty())
		{
			int r=q.front().first;
			int c=q.front().second;
			q.pop();
			visited[r][c]=true;
			for(int i=0;i<4;i++)
			{
				int x=r+x1[i];
				int y=c+dy[i];
				if(x>=0&&x<n&&y>=0&&y<m&&!visited[x][y]&&mat[x][y]!=mat[r][c])
				{
					dist[x][y]=dist[r][c]+1;
					visited[x][y]=true;
					q.push(make_pair(x,y));
				}
			}
		}
		if(visited[n-1][m-1])
		cout<<dist[n-1][m-1]+1<<"\n";
		else
		cout<<"-1\n";
	}
	
}
#include <iostream>
#include <vector>
#include <cstdio>
#include <cmath>
#include <vector>
using namespace std;
#define lli long long int

long long func(long long a, long long b,long long n)
{
     long long i,t,sum,j,p1=0,p2=0,c;
     vector <long long> v;
     if ( n%2 == 0  ) {
        v.push_back(2);
        while ( n%2 == 0 ) n = n/2;
     }
     t = (long long)(sqrtl(n));
     for ( i = 3; i <= t; i += 2 ) {
         if ( n%i == 0 ) {
            v.push_back(i);
            while ( n%i == 0 ) n = n/i;
         }
         if ( n == 1 ) break;
     }
     if ( n != 1 ) {
        v.push_back(n);
     }
     t = (long long)(v.size());     
     
     for ( i = 0; i < 1 << t; i++ ) {
         sum = 1;
         c = 0;
         for ( j = 0; j < t; j++ ) {
              if ( i & (1<<j) ) {
                 c++;
                 sum *= v[j];
              }
         }
         if ( c&1 ) {
            p1 += a/sum;
            p2 += b/sum;
         }
         else {
              if ( sum != 1 ) {
                 p1 -= a/sum;
                 p2 -= b/sum;
              }
         }
     }
     p2 = b - p2;
     p1 = a - p1;
     return p2-p1;
}



int main()
{
    int t;
    cin>>t;
    while(t--)
    {
              int fl=0;
              lli n,x,m;
              cin>>n>>x>>m;
              if(n%x!=0) fl=1;
              n=n/x;    
              while(m--)
              {
                        lli l,r;
                        cin>>l>>r;
                        if(fl==1)
                        {
                                 cout<<"0\n";
                                 continue;
                        }    
                        if(l%x==0) l=l/x;
                        else l=(l/x+1);
                        r=r/x;
                        cout<<func(l-1,r,n)<<"\n";                        
              }
    }
    return 0;
}
                        
                        

// AUTHOR : SIKANDER MAHAN
// sikander_nsit
// PLAGIARISM IS BAD

#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include<string.h>
#define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)
#define all(c) c.begin(),c.end()
#define mod 1000000007
#define itor(c) typeof(c.begin())
#define ll long long
#define vi vector<int>
#define si set<int>
#define msi multiset<int>
#define ii pair<int,int>
#define sii set<ii>
#define vii vector<ii>
#define vvi vector<vi>
#define pb push_back
#define mp make_pair

using namespace std;

struct node
{
    vector<int> v;
    vector<ll> vs;
};

node segtree[400009];
int arr[100002];
vi vec;

void initialise(int b,int e,int ind)
{
    int ind2=ind*2;
    int ind1=ind2+1;
    int temp,sz1,sz2,i,j;
    if(b==e)
    {
        segtree[ind].v.pb(arr[b]);
    }
    else
    {
        initialise(b,(b+e)/2,ind2);
        initialise((b+e)/2+1,e,ind1);
        sz1=segtree[ind2].v.size();
        sz2=segtree[ind1].v.size();
        i=0,j=0;
        while(true)
        {
            if(i==sz1)
            {
                while(j<sz2)
                {
                    segtree[ind].v.pb(segtree[ind1].v[j]);
                    ++j;
                }
                break;
            }
            else if(j==sz2)
            {
                while(i<sz1)
                {
                    segtree[ind].v.pb(segtree[ind2].v[i]);
                    ++i;
                }
                break;
            }
            else
            {
                if(segtree[ind2].v[i]<=segtree[ind1].v[j])
                {
                    segtree[ind].v.pb(segtree[ind2].v[i]);
                    ++i;
                }
                else
                {
                    segtree[ind].v.pb(segtree[ind1].v[j]);
                    ++j;
                }
            }
        }
    }
    sz1=segtree[ind].v.size();
    segtree[ind].vs.pb(0);
    for(temp=0;temp<sz1;++temp)
    {
        segtree[ind].vs.pb(segtree[ind].vs[temp]+segtree[ind].v[temp]);
    }
}

void query(int ind,int b,int e,int i,int j)
{
    if(i>e || j<b)
        return;
    if(b>=i && e<=j)
    {
        vec.pb(ind);
        return;
    }
    query(ind*2,b,(b+e)/2,i,j);
    query(ind*2+1,(b+e)/2+1,e,i,j);
}

int main()
{
    //ios::sync_with_stdio(false);
    //freopen("input.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int t,i,j,n,m,l,r,sz,k,num,mx,temp;
    ll sum;
    int b[100],e[100];
    vi vtemp;
    int ind[100];
    cin>>n;
    for(i=0;i<n;++i)
    {
       cin>>arr[i];
    }
    initialise(0,n-1,1);
    cin>>m;
    for(i=0;i<m;++i)
    {
        vec.clear();
        cin>>l>>r>>k;
        query(1,0,n-1,l-1,r-1);
        sz=vec.size();
        sum=0;
        for(j=0;j<sz;++j)
        {
            b[j]=0;
            e[j]=min(k,(int)segtree[vec[j]].v.size());
        }
        while(true)
        {
            mx=0;
            for(j=1;j<sz;++j)
            {
                if((e[j]-b[j]) > (e[mx]-b[mx]))
                {
                    mx=j;
                }
            }
            if(e[mx]-b[mx]<2)
            {
                break;
            }
            temp=(e[mx]+b[mx]-1)/2;
            num=segtree[vec[mx]].v[temp];
            sum=0;
            for(j=0;j<sz;++j)
            {
                ind[j]=upper_bound(segtree[vec[j]].v.begin()+b[j],segtree[vec[j]].v.begin()+e[j],num)-segtree[vec[j]].v.begin();
                sum+=(ind[j]-b[j]);
            }
            sum-=(ind[mx]-temp-1);
            ind[mx]=temp+1;
            if(sum>=k)
            {
                for(j=0;j<sz;++j)
                {
                    e[j]=ind[j];
                }
            }
            else
            {
                k-=sum;
                for(j=0;j<sz;++j)
                {
                    b[j]=ind[j];
                }
            }
        }
        vtemp.clear();
        for(j=0;j<sz;++j)
        {
            if(e[j]-b[j])
            {
                vtemp.pb(segtree[vec[j]].v[b[j]]);
            }
        }
        sort(all(vtemp));
        sum=0;
        for(j=0;j<k;++j)
        {
            sum+=vtemp[j];
        }
        for(j=0;j<sz;++j)
        {
            sum+=segtree[vec[j]].vs[b[j]];
        }
        cout<<sum%mod<<endl;
    }
    return 0;
}

#include<iostream>
using namespace std;
int main()
{
    
    int t; cin>>t;
    while(t--)
    {
        long n; cin>>n;
        bool inc=true;
        bool dec=true;
        if(n/10==0)
        cout<<"0"<<endl;
        else
        {
        while(n!=0)
        {
            int x=n%10;
            n=n/10;
            int y=n%10;
            if(x>=y)
            inc=false;
            else
            dec=false;
        }
        if(inc==false && dec==false)
        cout<<"1"<<endl;
        else
        cout<<"0"<<endl;
    }
    }
    return 0;
}
#include <iostream>
using namespace std;

int main()
{
    int a; cin>>a;
    while(a--)
    {
        long long x,y;
        cin>>x>>y;
        int a1[10]={0};
        while(x!=0)
        {
            int r=x%10;
            a1[r]++;
            x=x/10;
        }
        while(y!=0)
        {
            int r=y%10;
            a1[r]--;
            y=y/10;
        }
        int i=0;
        for(i=0;i<10;i++)
        {
            if(a1[i]>0)
            break;
        }
        if(i==10)
        cout<<"1"<<endl;
        else cout<<"0"<<endl;
    }
    return 0;
}

#include <iostream>
#include<cstdio>
using namespace std;
int main()
{
   int t;
   cin>>t;
   while(t--)
   {
       string str;
       cin>>str;
       int l=str.length();
       int i,s=0;
       for(i=0;i<l;i++)
       {
           char ch=str[i];
           int x=ch;
           s=s+x;
       }
       s=s/l;
       char c=s;
       cout<<c<<"\n";
   }
   return 0;
}

#include <iostream>

using namespace std;

char a[100000000];
int main()
{
    int test;
    cin>>test;
    while(test>0)
     {
        cout<<"\n";

        int sum=0,b=0;
        cin>>a;
        for(int i=0;a[i]!='\0';i++)
        {
            sum+=a[i]-48;
            b=b*10+(a[i]-48);
        }
        sum=sum<<b;
        cout<<sum;
        test--;
     }
    return 0;
}

#include <stdio.h>

int main(void) {
	int t,n,k,i,x,c;
	scanf("%d", &t);
	while (t--){
		c=0;
		scanf("%d %d", &n, &k);
		for (i=0; i<n; i++){
			scanf("%d",&x);
			if (x<=0)
				c++;
		}
		if (c>=k){
			printf("NO\n");
		}
		else{
			printf ("YES\n");
		}
	}
	return 0;
}

#include <stdio.h>
#include <math.h>
int check(int n){
	if (n%2==1)
		return 0;
	double m = n;
	double s = sqrt(m);
	if ((int)s!=s){
		return 0;
	}
	return 1;
}
int gcd(int a, int b){
	if (a==0)
		return b;
	if (b==0)
		return a;
	if (a>b)
		return gcd(a%b,b);
	else
		return gcd(a,b%a);
}
int main(void) {
	int t,n,i,fac,count,temp;
	scanf ("%d", &t);
	while (t--)
	{
		fac = 0;
		count = 0;
		scanf("%d", &n);
		for (i=1; i*i<=n; i++){
			if (n%i==0){
				temp = n/i;
				if (i ==1 || i == temp){
					//printf ("%d ", i);
					fac++;
					if (check(i)==1)
						count++;
				}
				else{
					fac+=2;
					//printf ("%d %d ", i, temp);
					if (check(i)==1)
						count++;
					if (check(temp)==1)
						count++;
				}
			}
		}
		if (count==0)
			printf ("0\n");
		else{
			int g = gcd(count,fac);
			printf("%d/%d\n",count/g,fac/g);
		}
	}
	return 0;
}

#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include <vector>
#include <deque>
#include <list>
#include <set>
#include <map>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <iterator>
#include <numeric>
#include <utility>
using namespace std;

template< class T > T _abs(T n) { return (n < 0 ? -n : n); }
template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); }
template< class T > T _min(T a, T b) { return (a < b ? a : b); }
template< class T > T sq(T x) { return x * x; }
template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); }
template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); }
template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; }
template< class T > void setmax(T &a, T b) { if(a < b) a = b; }
template< class T > void setmin(T &a, T b) { if(b < a) a = b; }

#define ALL(c) c.begin(), c.end()
#define PB(x) push_back(x)
#define UB(s, e, x) upper_bound(s, e, x)
#define LB(s, e, x) lower_bound(s, e, x)
#define REV(s, e) reverse(s, e);
#define SZ(c) c.size()
#define SET(p) memset(p, -1, sizeof(p))
#define CLR(p) memset(p, 0, sizeof(p))
#define MEM(p, v) memset(p, v, sizeof(p))
#define CPY(d, s) memcpy(d, s, sizeof(s))
#define ll long long
#define ff first
#define ss second
#define DEBUG if(0)

#define si(x) scanf("%d",&x)
#define pi(x) printf("%d\n",x)
#define siz 100100
int main()
{
             ll int n,i,a[siz],q;
              cin>>n;
              for(i=1;i<=n;i++)
              cin>>a[i];
              cin>>q;
              while(q--)
              {
                      ll  int l,r,key=-1;
                        cin>>l>>r;
                        for(i=1;i<=n;i++)
                        {
                          if(i>=l && i<=r)
                          continue;
                             if(key==-1)
                             key=a[i];
                             else
                             key=(key*a[i])/__gcd(key,a[i]);
                             }
                          key%=26;
                       //   cout<<key<<"\n";
                        char  str[siz];
                        scanf("%s",str);
                        for(i=0;str[i]!='\0';i++)
                        {
                        if(str[i]>='a' && str[i]<='z')
                        {
                        char c=(str[i]-'a'+26-key)%26;
                         c+='a';
                         cout<<c;
                         }
                         if(str[i]>='A' && str[i]<='Z')
                        {
                        char c=(str[i]-'A'+26-key)%26;
                         c+='A';
                         cout<<c;
                         }
                        
                         }  
                        printf("\n");//<<"\n";
                        }
                        return 0;
                        }        

import math
def ch(n):
    if(math.sqrt(n).is_integer()):
        return 1
    else:
        return 0
def sum(n):
    m=int(math.sqrt(n))+1
    s=0
    for i in range(2,m):
        if n%i==0:
            s=s+i+n/i
    if ch(n)==1:
        s=s-m-1
    return s+1
t=input()
while(t):
    t=t-1
    n=input()
    p=sum(n)
    if n==sum(p):
        print "Yes, amicable with "+str(p)
    else:
        print "No"
    
        
        
    

arr = [2,3,5,7,11,13,17,31,37,71,73,79,97,113,131,197,199,311,337,373,719,733,919,971,991,1193,1931,3119,3779,7793,7937,9311,9377,11939,19391,19937,37199,39119,71993,91193,93719,93911,99371,193939,199933,319993,331999,391939,393919,919393,933199,939193,939391,993319,999331]
n=input()
for i in range(n):
	a=input()
	if a in arr:print "Yes"
	else:print "No"
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<cmath>
#include<climits>
#include<vector>
#include<iterator>
#include<set>
#include<bitset>
#include<ctime>
#include<iomanip>

#define fr(i,a,b) for(int i=a; i<b; i++)
#define s(a) scanf("%d", &a)
#define sl(a) scanf("%lld", &a)
#define p(a) printf("%d\n", a)
#define w(t) while(t--)
#define pb push_back
#define CLR(a) memset(a, 0, sizeof(a))
#define MAX(a, b) a>b?a:b

using namespace std;

typedef long long int lli;
typedef vector<int> VI;
typedef vector<string> VS;

const int SIZ = 3006;
const int alpha = 26;

int main() {
	char input[SIZ], sorted[SIZ];
	int testcase, index, sort[alpha], length, count, k, t1, t[SIZ];
	s(testcase);
	w(testcase) {
		scanf("%s %d", sorted, &index);
		length = strlen(sorted);
		index = length-index;
		k=0;
		for(int i=length-1;i>=0;i--)
			input[k++] = sorted[i];
		input[k] = '\0';
		CLR(sort);
		fr(i,0,length) {
			int j = (int)input[i]-'a';
			sort[j]++;
		}
		count=0;
		fr(i,0,alpha)	
			if(sort[i]>0)
				fr(j,0,sort[i]) {
					sorted[count++] = (char)(i+'a');
				}
		t1=0;
		fr(i,0,alpha) {
			if(sort[i]>0) {
				k=0;
				fr(j,0,sort[i]) {
					while(k<length) {
						if(input[k]==(char)(i+'a'))		t[t1++]=k;
						k++;
					}
				}
			}
		}
		fr(i,0,length) {
			sorted[i] = input[index];
			index = t[index];
		}
		sorted[length] = '\0';
		printf("%s\n",sorted);
	}
	return 0;
}
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
using namespace std;
int matrix[3009][3009];
int LCSfind(string a, string b)
{
    int len1,len2;
    len1=a.size();
    len2=b.size();
    //int matrix[len1+1][len2+1];
    register int i,j;
    for(i=0; i<=len1; i++)
        matrix[i][0]=0;
    for(i=0; i<=len2; i++)
        matrix[0][i]=0;
    for(i=1; i<=len1; i++)
        for(j=1; j<=len2; j++)
        {
            if(a[i-1]==b[j-1])
                matrix[i][j]=matrix[i-1][j-1]+1;
            else matrix[i][j]=max(matrix[i-1][j],matrix[i][j-1]);
        }
    return  matrix[len1][len2];
}

int main()
{
    #ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
	#endif
	int cas;
	for(scanf("%d",&cas);cas--;)
    {
        string a="",b="";
        char p;
        int k,tem;
        scanf("%d",&k);
        register int i,j;
        getchar();
        for(i=0; i<k; i++)
        {
            scanf("%c",&p);
            scanf("%d",&tem);
            for(j=0; j<tem; j++)
                a+=p;
        }
        //cout<<a<<endl;
        scanf("%d",&k);
        getchar();
        for(i=0; i<k; i++)
        {
            scanf("%c",&p);
            scanf("%d",&tem);
            for(j=0; j<tem; j++)
                b+=p;
        }
        //cout<<b<<endl;
        int longes=LCSfind(a,b);
        //printf("%d\n",longes);
        printf("%d\n",(a.size()-longes)*2+(b.size()-longes));
    }

    return 0;
}


#include <iostream>
using namespace std;

int main()
{
   for (int i = 1; i < 101; ++i)
   {
       if      (i % 3 == 0 && i % 5 == 0) cout << "FizzBuzz";
       else if (i % 3 == 0)               cout << "Fizz";
       else if (i % 5 == 0)               cout << "Buzz";
       else                               cout << i;
       cout << endl;
   }
}
s=raw_input()
t=raw_input()
j=0
for i in t:
	if i is s[j]:
		j+=1
print(j)
#include<bits/stdc++.h>
#define ll long long int
using namespace std;

struct node
{
	ll x,y;
}ar[10005];
node p0;
void swap(node &a,node &b)
{
	node temp=a;
	a=b;
	b=temp;
}
int orientation(node p,node q, node r)
{
	ll val=((q.y-p.y)*(r.x-q.x))-((q.x-p.x)*(r.y-q.y));
	if(val==0) return 0;
	return (val>0)?1:2;
}
ll dist(node p,node q)
{
	return ((p.x-q.x)*(p.x-q.x))+((p.y-q.y)*(p.y-q.y));
}
int cmp(const void* g,const void* f)
{
	node *p1=(struct node*) g;
	node *p2=(struct node*) f;
	int o=orientation(p0,*p1,*p2);
	if(o==0) return (dist(p0,*p1)<=dist(p0,*p2))? -1:1;
	return (o==2)?-1:1;
}
node next_to(stack<node> &s)
{
	node p1=s.top();
	s.pop();
	node p2=s.top();
	s.push(p1);
	return p2;
}
int main()
{
	ll n,i,x,y;
	scanf("%lld",&n);
	for(i=0;i<n;i++)
	{
		//scanf("%lld%lld",&ar[i].x,&ar[i].y);
		cin>>ar[i].x>>ar[i].y;
	}
	//printf("3.%lld %lld\n",(ll)ar[8424].x,(ll)ar[8424].y);
	ll ind=0;
	for(i=1;i<n;i++)
	{
		if(ar[i].y<ar[ind].y||(ar[i].y==ar[ind].y&&ar[i].x<ar[ind].x)) ind=i;
	}
	//printf("1.%lld %lld %lld\n",ar[0].x,ar[0].y,ind);
	swap(ar[0],ar[ind]);

	p0=ar[0];
	qsort(&ar[1],n-1,sizeof(node),cmp);
	ll m=1;
	for(ll i=1;i<n;i++)
	{
		while(i<n-1&&orientation(p0,ar[i],ar[i+1])==0) i++;
		ar[m]=ar[i];
		m++;
	}
	stack<node> s;
	s.push(ar[0]);
	s.push(ar[1]);
	s.push(ar[2]);
	for(i=3;i<m;i++)
	{
		while(orientation(next_to(s),s.top(),ar[i])!=2)
		s.pop();
		s.push(ar[i]);
	}
	node p1=s.top(),p3;
	p3=p1;
	ll size=s.size();
	//printf("%lld",size);
	//printf("%lld %lld\n",p1.x,p1.y);
	s.pop();
	double sum=0.0;
	while(!s.empty())
	{
		node p2=s.top();
		//printf("%lld %lld %lld %lld\n",p1.x,p1.y,p2.x,p2.y);
		sum+=sqrt((double)dist(p1,p2));
		p1=p2;
		//printf("%lld %lld\n",p1.x,p1.y);
		s.pop();
	}
	if(size>2) sum+=sqrt((double)dist(p3,p1));
	printf("%.1lf\n",sum);
	return 0;
}

#include <bits/stdc++.h>

using namespace std;

const long long MOD=(1e9+7);

typedef long long ll;

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int t;
	//cin>>t;
	//while(t--)
	{
		string temp;
		getline(cin,temp);
		for(int i=0;i<temp.length();i++)
		{
			if(temp[i]!=' ')
				cout<<temp[i];
			else 
			{
				cout<<" ";
				while(temp[i]==' ')
					i++;
				i--;
			}
		}

	}
	return 0;
}
#include <bits/stdc++.h>

using namespace std;

const long long MOD=(1e9+7);

typedef long long ll;

int luck(int n)
{
	int T[10], k=0, i, s=0;
	
	while(n>0)
	{
		T[k]=n%10; k++; n/=10;
	}
	
	for(i=0;i<k;i++)
	 s+=T[i];
	
	return s;
}
 
int month(string m)
{
	    const char *mm=m.c_str();
		if(strcmp(mm,"January")==0) return 1;
		if(strcmp(mm,"February")==0)  return 2;
		if(strcmp(mm,"March")==0)  return 3;
		if(strcmp(mm,"April")==0)  return 4;
		if(strcmp(mm,"May")==0)  return 5;
		if(strcmp(mm,"June")==0)  return 6;
		if(strcmp(mm,"July")==0) return 7;
		if(strcmp(mm,"August")==0) return 8;
		if(strcmp(mm,"September")==0)  return 9;
		if(strcmp(mm,"October")==0) return 10;
		if(strcmp(mm,"November")==0) return 11;
		if(strcmp(mm,"December")==0) return 12;
	
}
 


int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int t;
	//cin>>t;
	//while(t--)
	{
	int dd, yy, lucky, error;
	string mm;
	cin >>dd>>mm>>yy;
	lucky=dd*month(mm)+yy;
	
	error = luck(lucky);
	
	while(error>9)
	{
		error=luck(error);
	}
	
	cout<<error;
	
	}
	return 0;
}
#include <iostream>
#include<cstdio>
using namespace std;

int main()
{
    char s[10];
    scanf("%s",s);
    int i,sum=0;
    for(i=0;i<5;i++)
    {
        int a=s[i]-48;
        int b=s[i+5]-48;
        sum=sum+a*b;
    }
    cout<<sum<<"\n";
}

#include<stdio.h>
using namespace std;
int main()
{
	int a,b,temp,t,i,j;
	float x=2,*arr,f;
	scanf("%d",&t);
	arr=new float[t];
	for(i=0;i<t;i++)
	{
		scanf("%d%d",&a,&b);
		if(a>b)
		{
			temp=a;
			a=b;
			b=temp;
		}
		f=1/(float)a;
		for(j=a+1;j<=b;j++)
			x+=f;
		arr[i]=b/x;
		x=2;
	}
	for(i=0;i<t;i++)
		printf("%f\n",arr[i]);
}		
#include <iostream>

using namespace std;

int binomialCoeff(int n, int k)
{
    int res = 1;
    if( k>n-k)
        k = n-k;
    for(int i =0;i<k;++i)
    {
        res*=(n-i);
        res/=(i+1);
    }
    return res;
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int d,r;
        cin>>d>>r;
        int n = d+r;
        int res = binomialCoeff(n,d);
        cout<<res<<endl;
    }
    return 0;
}


#include<stdio.h>
#include<math.h>
using namespace std;
int main()
{
	int t,count,n,p=2,m=1,j;
	float f;
	scanf("%d",&t);
	for(int i=0;i<t;i++)
	{
	scanf("%d",&n);
	m=1,p=2,count=1;
	if(n==0)
		goto l;
	m+=p,p++;
	while(true)
	{	
		f=sqrt(m);	
		for(j=2;j<=f;j++)
		{
			if(count>n)
				break;
			else if(j==f)
				count++;
			else if(m%j==0)
				count+=2;
		}
		if(j-1==(int)f&&count==n)
		{
			break;
		}
		count=1;m+=p;p++;	
	}
	l:
	printf("%d\n",m);
	}
}
#include <bits/stdc++.h>
using namespace std;
long long GCD(long long a,long long b)
{
	if(b==0)
		return a;
	return GCD(b,a%b);
}
long long LCM(long long a,long long b)
{
	return (a*b)/GCD(a,b);
}
int main()
{
	int N;
	cin>>N;
	int n[N],d[N];
	for(int i=0;i<N;i++)
	{
		cin>>n[i];cin>>d[i];
	}
	int gcd=n[0];
	int lcm=d[0];
	for(int i=1;i<N;i++)
	{
		gcd=GCD(gcd,n[i]);
		lcm=LCM(lcm,d[i]);
	}

	cout<<gcd<<"/"<<lcm<<endl;
	return 0;

}

#include<iostream>
using namespace std;

int func(char *a){
	int i=0;
	while(a[i]!=NULL){
		i++;
	}
	return i;
}

int main(){
	int t;
	char a[50];
	cin>>t;
	while(t--){
		cin>>a;
		cout<<func(a)<<endl;
	}
}

#include<iostream>
using namespace std;

int counter(int count,int b)
{
    int sum=0;
    while(count>0)
    {
        sum+=count/b;
        count=count/b;
    }
    return sum;
}

int main()
{
    int t; cin>>t;
    while(t--)
    {
        int n; cin>>n;
        cout<<counter(n,2)<<"\n"<<counter(n,3)<<"\n"<<counter(n,5)<<"\n";
    }
    return 0;
}

import java.util.Scanner;
class Pattern 
{

	
	public static void main(String[] args) 
	{
		int arr[]=new int[10];
		int max=0,pos=0;
		Scanner in=new Scanner(System.in);
		for(int j=0;j<10;j++)
		{
			arr[j]= in.nextInt();
			if(arr[j]>max)
			{
				max=arr[j];
			    pos=j;
			}
			
		}//end of for
		
		while(arr[pos]>0)
		{
			for(int i=0;i<10;i++)	
			{
				
				if(arr[i]-arr[pos] <0)
					System.out.print(" ");
				else
					System.out.print("*");
			}//end of for
			System.out.println();
			arr[pos]-=1	;	
		}//end of while
	}

}//end of class

def index(a):
    m=0
    ind=0
    for i in range(len(a)):
        if a[i]>m:
            m=a[i]
            ind=i
    return ind
t=input()
while(t>0):
    t-=1
    a=map(int,raw_input().split())
    n=input()
    count=0
    for i in range(n):
        k=index(a)
        if a[k]>=1:
            count+=a[k]
            a[k]-=1
        else:break
    print count
        

t=input()
while(t>0):
    t-=1
    n=input()
    arr=map(int,raw_input().split())
    dp=[]
    for i in range(n):
        dp.append([arr[i]])
    for i in range(1,n):
        for j in range(i):
            if arr[i]>arr[j] and len(dp[i])<=len(dp[j]):
                dp[i].append(arr[j])
    maxi,index=0,0
    for i in range(n):
        if len(dp[i])>maxi:
            maxi=len(dp[i])
            index=i
    print len(dp[index])
    """for i in range(1,len(dp[index])):
        print dp[index][i],
    print dp[index][0]"""

t = raw_input();
t = int(t);
while (t>0):
    (a,b) = raw_input().split();
    a = int(a);
    b = int(b);
    tmp = a**70;
    if (tmp % b == 0):
        print 'Yes';
    else:
        print 'No';
    t = t-1;

# your code goes here
cases = input()

for case in xrange(cases):
	num = input()
	if num%6==0:
		print 'Misha'
	else:
		print 'Chef'

def baseN(num, b, numerals="0123456789abcdefghijklmnopqrstuvwxyz"):
    return ((num == 0) and numerals[0]) or (baseN(num // b, b, numerals).lstrip(numerals[0]) + numerals[num % b])
for _ in xrange(input()):
    k=input()
    print int(baseN(k-1,5))*2
    
import math
     
"""def power(a,b):
        if(b<0):
            return power(1/a,-b)
        elif(b==0):
            return 1
        elif(b==1):
            return a
        elif(b%2==0):
            return power(a*a,b/2)%1000000007
        elif(b%2!=0):
            return (a * power(a*a,(b-1)/2))%1000000007
"""
     
'''def powerfn(a,n):
        result = 1
        value = a
        power = n
        while(power>0):
            if(power%2!=0):
                result = result*value
                result = result%1000000007
            value = value*value
            value = value%1000000007
            power = power/2
        return result
     
def modular_inv(n):
        return powerfn(n,1000000005)'''
mod=1000000007      
def powerfn(a,n):
    result = 1
    value = a
    power = n
    while(power>0):
        if(power%2!=0):
            result = result*value
            result = result%1000000007
        value = value*value
        value = value%1000000007
        power = power/2
    return result

def modular_inv(n):
    return powerfn(n,mod-2)
     
     
factorials=[]
inverse_fac=[]
factorials.append(1)
inverse_fac.append(1)
for i in range(1,100002):
        factorials.append(i*factorials[i-1]%1000000007)
for i in range(1,100002):
        inverse_fac.append(modular_inv(i)*inverse_fac[i-1]%1000000007)
    #print factorials
    #print inverse_fac
     
t=int(raw_input())
for i in range(t):
        s=raw_input()
        n,k=s.split()
        n=int(n)
        k=int(k)
        arr=list(map(int,raw_input().split()))
        counter=0
        for i in arr:
            if(i==0):
                counter+=1
        if(n==1 or counter==n):
            print "1"
        else:
            if(counter>1 and counter<n):
                n=n-counter+1
            if(n<=k):
                k=n
            ans=0
            for j in range(k,-1,-2):
                ans=((ans+((((inverse_fac[j]*factorials[n])%1000000007)*inverse_fac[n-j])%1000000007))%1000000007)
            print ans%1000000007 

#include <bits/stdc++.h>
#define N 21
 
#define cout2(x, y) cout << x << " " << y << endl
#define pb(x) push_back(x)
#define all(x) x.begin(), x.end()
#define INF (1<<30)
#define M 1000000007
 
using namespace std;

long long memo[1<<N];
int a[N][N];


int main() {
	
	int tc = 0;
	scanf("%d", &tc);
	
	while(tc--){
		
		int n, m;
		scanf("%d%d", &n, &m);
		
		memset(a, 0, sizeof a);
		int u, v;
		
		for(int i = 0; i < m; i++){	
			
			scanf("%d%d", &u, &v);
			u--, v--;
			a[u][v] = 1;
			
		}
		

		memo[0] = 1;
		for(int i = 1; i < (1<<n); i++){
			
			int bit = __builtin_popcount(i);
			memo[i] = 0;
			
			for(int j = 0; j < n; j++){
				
				if((i>>j)&1){
					
					memo[i] = ( memo[i] + (a[n - bit][j] * memo[i - (1<<j)]) % M ) % M;
				}
			}
			
			memo[i] %= M;
			if(memo[i] < 0) memo[i] += M;
		}
		
		printf("%lld\n", memo[(1<<n) - 1]);
	} 
	
}
import java.io.IOException;
import java.io.InputStream;

public class Main {

    public static void main(String[] args) throws IOException {
        InputReader reader = new InputReader(System.in);
        int T = reader.readInt();
        StringBuilder output = new StringBuilder();
        for (int t=0; t<T; t++) {
            int N = reader.readInt();
            String s = reader.readString(N);
            long[] C = reader.readLongArray(N);
            long[][] dp = new long[N+1][15];
            for (int n=1; n<=N; n++) {
                char c = s.charAt(n-1);
                long cost = C[n-1];
                // 0: R
                // 5: GR
                // 6: BR
                // 11: GBR
                // 12: BGR
                if (c == 'R') {
                    dp[n][0] = dp[n-1][0];
                    dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5]);
                    dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6]);
                    dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1]));
                    dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2]));
                } else {
                    dp[n][0] = dp[n-1][0]+cost;
                    dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5])+cost;
                    dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6])+cost;
                    dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1]))+cost;
                    dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2]))+cost;
                }
                // 1: G
                // 3: RG
                // 4: BG
                // 13: RBG
                // 14: BRG
                if (c == 'G') {
                    dp[n][1] = dp[n-1][1];
                    dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3]);
                    dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4]);
                    dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0]));
                    dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2]));
                } else {
                    dp[n][1] = dp[n-1][1]+cost;
                    dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3])+cost;
                    dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4])+cost;
                    dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0]))+cost;
                    dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2]))+cost;
                }
                // 2: B
                // 7: RB
                // 8: GB
                // 9: RGB
                // 10: GRB
                if (c == 'B') {
                    dp[n][2] = dp[n-1][2];
                    dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7]);
                    dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8]);
                    dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0]));
                    dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1]));
                } else {
                    dp[n][2] = dp[n-1][2]+cost;
                    dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7])+cost;
                    dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8])+cost;
                    dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0]))+cost;
                    dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1]))+cost;
                }
            }
            long min = Long.MAX_VALUE;
            for (long value : dp[N]) {
                min = Math.min(min, value);
            }
            output.append(min).append('\n');
        }
        System.out.print(output);
    }

    static final class InputReader {
        private final InputStream stream;
        private final byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int read() throws IOException {
            if (curChar >= numChars) {
                curChar = 0;
                numChars = stream.read(buf);
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public final int readInt() throws IOException {
            return (int)readLong();
        }

        public final long readLong() throws IOException {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
                if (c == -1) throw new IOException();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return negative ? -res : res;
        }

        public final String readString(int length) throws IOException {
            char[] A = new char[length];
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
                if (c == -1) throw new IOException();
            }
            A[0] = (char)c;
            for (int n=1; n<length; n++) {
                A[n] = (char)read();
            }
            return new String(A);
        }

        public final int[] readIntArray(int size) throws IOException {
            int[] array = new int[size];
            for (int i=0; i<size; i++) {
                array[i] = readInt();
            }
            return array;
        }

        public final long[] readLongArray(int size) throws IOException {
            long[] array = new long[size];
            for (int i=0; i<size; i++) {
                array[i] = readLong();
            }
            return array;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
    }

}

#if defined (_MSC_VER) && (!ONLINE_JUDGE)
#pragma comment(linker, "/STACK:16777216")
#pragma warning(once: 4309 4244 4005 4018)
#define _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_DEPRECATE
#define _CRT_DISABLE_PERFCRIT_LOCKS
#define gc _getc_nolock
#define pc _putc_nolock
#include <utils.h>
#include <mymaths.h>
#include <bigint.h>
#include <InfInt.h>
#include <safeint.h>
using namespace msl::utilities; // e.g.: 	SafeInt<int> n = INT32_MAX; n += 1; throws exception!
#else
#define gc getc_unlocked
#define pc putc_unlocked
#endif

#include <bits/stdc++.h>
using namespace std;

typedef unsigned int uint;
typedef unsigned long long uint64;
typedef long long int64;

static struct IO {
	char tmp[1 << 10];

	// fast input routines - http://ideone.com/fOK6CW
	char cur;

	inline char nextChar ( )
	{
		return cur = gc (stdin);
	}
	inline char peekChar ( )
	{
		return cur;
	}

	inline operator bool ( )
	{
		return 0 != peekChar ( );
	}
	inline static bool isBlank (char c)
	{
		return (c < '-' && c);
	}
	inline bool skipBlanks ( )
	{
		while (isBlank (nextChar ( ))); return peekChar ( ) != 0;
	}

	inline IO& operator >> (char & c)
	{
		c = nextChar ( ); return *this;
	}

	inline IO& operator >> (char * buf)
	{
		if (skipBlanks ( )) {
			if (peekChar ( )) {
				*(buf++) = peekChar ( );
				while (!isBlank (nextChar ( ))) *(buf++) = peekChar ( );
			} *(buf++) = 0;
		} return *this;
	}

	inline IO& operator >> (string & s)
	{
		if (skipBlanks ( )) {
			s.clear ( ); s += peekChar ( );
			while (!isBlank (nextChar ( ))) s += peekChar ( );
		}
		return *this;
	}

	inline IO& operator >> (double & d)
	{
		if ((*this) >> tmp) sscanf (tmp, "%lf", &d); return *this;
	}

#define defineInFor(intType) \
	inline IO& operator >>(intType & n) { \
		if (skipBlanks()) { \
			int sign = +1; \
			if (peekChar() == '-') { \
				sign = -1; \
				n = nextChar() - '0'; \
			} else \
				n = peekChar() - '0'; \
			while (!isBlank(nextChar())) { \
				n += n + (n << 3) + peekChar() - 48; \
			} \
			n *= sign; \
		} \
		return *this; \
	}

	defineInFor (int)
		defineInFor (unsigned int)
		defineInFor (long long)
		defineInFor (unsigned long long)

		// fast output routines
		inline void putChar (char c)
	{
		pc (c, stdout);
	}
	inline IO& operator << (char c)
	{
		putChar (c); return *this;
	}
	inline IO& operator << (const char * s)
	{
		while (*s) putChar (*s++); return *this;
	}

	inline IO& operator << (const string & s)
	{
		for (int i = 0; i < (int) s.size ( ); ++i) putChar (s[i]); return *this;
	}

	char * toString (double d)
	{
		sprintf (tmp, "%lf%c", d, '\0'); return tmp;
	}
	inline IO& operator << (double d)
	{
		return (*this) << toString (d);
	}


#define defineOutFor(intType) \
	inline char * toString(intType n) { \
		char * p = (tmp + 30); \
		if (n) { \
			bool isNeg = 0; \
			if (n < 0) isNeg = 1, n = -n; \
			while (n) \
				*--p = (n % 10) + '0', n /= 10; \
			if (isNeg) *--p = '-'; \
		} else *--p = '0'; \
		return p; \
	} \
	inline IO& operator << (intType n) { return (*this) << toString(n); }

#define defineOutForU(intType) \
	inline char * toString(intType n) { \
		char * p = (tmp + 30); \
		if (n) { \
			while (n) \
				*--p = (n % 10) + '0', n /= 10; \
		} else *--p = '0'; \
		return p; \
	} \
	inline IO& operator << (intType n) { return (*this) << toString(n); }

	defineOutFor (int)
		defineOutFor (long long)
		defineOutForU (unsigned long long)

#define endl ('\n')
#define cout __io__
#define cin __io__
} __io__;

class TimeTracker {
	clock_t start, end;
public:
	TimeTracker ( )
	{
		start = clock ( );
	}
	~TimeTracker ( )
	{
		end = clock ( );
		fprintf (stderr, "%.3lf s\n", (double) (end - start) / CLOCKS_PER_SEC);
	}
};
#ifdef ONLINE_JUDGE
// insert here functions from mymath.h, bigint.h, utils.h
#endif

//using namespace jj;		// http://www.jjj.de/fxt/#fxtbook				

int main ( )
{
	//cin.sync_with_stdio(0); cin.tie(0);
#ifndef ONLINE_JUDGE
	//freopen ("input.txt", "rt", stdin);
	//freopen ("output.txt", "wt", stdout);
	TimeTracker tt;
	// at return, destructor of TimeTracker tt is called, thus it shows elapsed time in stderr
#endif
	//cout << jj::gcd (16, 24);
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		int c[101] { };
		for (int i = 0; i < n; i++) {
			int d; cin >> d;
			c[d]++;
		}
		for (int i = 1; i <= 100; i++) {
			if (c[i] == 1) {
				cout << i << endl;
				break;
			}
		}
	}
}
def solve(N):
    a = N - N % 7
    b = N - a
    while a % 7 != 0 or b % 4 != 0:
        a -= 7
        b = N - a
        if a < 0:
            break
            
    if a < 0:
        return "-1"
    else:
        return a     
    
def chefluck():
    """
    1 <= T <= 1000 
    1 <= N <= 1000000000 (10^9)
    """
    T = int(raw_input())
    for t in xrange(T):
        N = int(raw_input())
        print solve(N)

if __name__ == "__main__":
    chefluck()
import sys

for t in xrange(int(sys.stdin.readline())):
	n,m=sys.stdin.readline().split()
	n,m=[int(n),int(m)]
	arr=[[] for i in xrange(n)]
	for i in xrange(n):
		arr[i]=map(int,sys.stdin.readline().split())
	store=[[]for i in xrange(m+n)]
	for i in xrange(n):
		for j in xrange(m):
			store[i+j].append(arr[i][j])
	for i in xrange(m+n):
		for j in xrange(len(store[i])):
			print store[i][j],

def read():
    return map(int, raw_input().split())

def is_X(c):
    if c == 'X':
        return 1
    else:
        return 0

T = read()[0]

for n in range(T):
    N, K = read()

    Box =[None for i in range(N)]
    for i in range(N):
        s = raw_input()
        Box[i] = list(s)
        
    H1 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    V1 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    D1 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    D3 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    
    H2 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    V2 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    D2 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    D4 = [ [0 for i in range(0, N)]  for j in range(0, N)]

    H1[0][0] = V1[0][0] = D1[0][0] = D3[i][j] = is_X(Box[0][0])
    max_len = 0
    for i in range(N):
        if max_len >= K:
            break
        for j in range(N):
            if i==0 and j==0:
                continue
            c = Box[i][j]
            #horizontal
            if i > 0:
                if  is_X(c) == 0:
                    H1[i][j] = 0
                else:
                    H1[i][j] = H1[i-1][j] + 1
            else:
                H1[i][j] = is_X(c)
            #vertical
            if j > 0:
                if is_X(c) == 0:
                    V1[i][j] = 0
                else:
                    V1[i][j] = V1[i][j-1] + 1
            else:
                V1[i][j] = is_X(c)
            #diagonal
            if i>0 and j>0:
                if is_X(c) == 0:
                    D1[i][j] = 0
                else:
                    D1[i][j] = D1[i-1][j-1] + 1
            else:
                D1[i][j] = is_X(c)
            #diagonal
            if i>0 and j < N-1:
                if is_X(c) == 0:
                    D3[i][j] = 0
                else:
                    D3[i][j] = D3[i-1][j+1] + 1
            else:
                D3[i][j] = is_X(c)
            
            max_len = max(max_len, H1[i][j], V1[i][j], D1[i][j], D3[i][j])

    if max_len >= K:
        print 'YES'
        continue
        
    H2 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    V2 = [ [0 for i in range(0, N)]  for j in range(0, N)]
    D2 = [ [0 for i in range(0, N)]  for j in range(0, N)]

    H2[N-1][N-1] = V2[N-1][N-1] = D2[N-1][N-1] = is_X(Box[N-1][N-1])
    max_len = 0
    l = range(N)[::-1]
    for i in l:
        if max_len >= K:
            break
        for j in l:
            if i==N-1 and j==N-1:
                continue
            c = Box[i][j]
            #horizontal
            if i < N-1:
                if  is_X(c) == 0:
                    H2[i][j] = 0
                else:
                    H2[i][j] = H2[i+1][j] + 1
            else:
                H2[i][j] = is_X(c)
            #vertical
            if j < N-1:
                if is_X(c) == 0:
                    V2[i][j] = 0
                else:
                    V2[i][j] = V2[i][j+1] + 1
            else:
                V2[i][j] = is_X(c)
            #diagonal
            if i<N-1 and j<N-1:
                if is_X(c) == 0:
                    D2[i][j] = 0
                else:
                    D2[i][j] = D2[i+1][j+1] + 1
            else:
                D2[i][j] = is_X(c)
            #diagonal
            if i < N-1 and j>0:
                if is_X(c) == 0:
                    D4[i][j] = 0
                else:
                    D4[i][j] = D4[i+1][j-1] + 1
            else:
                D4[i][j] = is_X(c)
            
            max_len = max(max_len, H2[i][j], V2[i][j], D2[i][j], D4[i][j])

    if max_len >= K:
        print 'YES'
        continue
    
    max_len = 0
    for i in range(N):
        for j in range(N):
            if Box[i][j] == '.':
                h = v = d = d2 = 0
                if i > 0:
                    h += H1[i-1][j]
                if j > 0:
                    v += V1[i][j-1]
                if i>0 and j>0:
                    d += D1[i-1][j-1]
                if i>0 and j < N-1:
                    d2 += D3[i-1][j+1]
               
                if i < N-1:
                    h += H2[i+1][j]
                if j < N-1:
                    v += V2[i][j+1]
                if i<N-1 and j<N-1:
                    d += D2[i+1][j+1]
                if i < N-1 and j>0:
                    d2 += D4[i+1][j-1]
                
                max_len = max( max_len, h+1, v+1, d+1, d2+1 )
                if max_len >= K:
                    break

    if max_len >= K:
        print 'YES'
        continue
    else:
        print 'NO'
    
        

    
import math
def fact(n):
	q=1
	for i in xrange(2,n+1):
		q*=i
	return q
t=int(raw_input())
for i in xrange(t):
	n,m=map(int,raw_input().split())
	q=n*(n-1)*(n-2)/6
	r=m*(m-1)*(m-2)/6
	print q-r

t=int(raw_input())
for ad in range(t):
	n,m=map(int,raw_input().split())
	a=map(int,raw_input().split())
	a=sorted(a)
	u_list=a[:m]
	d_list=a[m:]
	print sum(d_list)-sum(u_list)
T=input();
for t in range(T) :
         S=raw_input();
         maxc=0;
         char=-1;
         for i in range(26) :
             c=S.count(chr(97+i));
             if c>maxc :
                  maxc=c;
                  char=i;
         S=S.replace(chr(97+char),'?')
         print S;

                            #include<iostream>
                            #include<stdio.h>
                            #include<string.h>
                            using namespace std;
                            char a[100000];
                            void sw(long long int r){
                            long long int i,q;
                            for(i=0;a[i]!='\0';i++){
                            q=r;
                            if(a[i]>=97&&a[i]<=122){
                             q=q-122+a[i];
                             q=q%26;
                             if(q<=0)
                             q=q+26;
                             a[i]=q+96;
                            }
                            if(a[i]>=65&&a[i]<=90){
                             q=q-90+a[i];
                             q=q%26;
                             if(q<=0)
                             q=q+26;
                             a[i]=q+64;
                            }
                            }
                            cout<<a<<"\n";
                            }
                            int main(){
                            int n,x;
                            long long int p;
                            cin>>n;
                            for(x=0;x<n;x++){
                            cin>>p;
                            cin.get();
                            gets(a);
                            sw(p);
                            }
                            return 0;
                            }          

#include <bits/stdc++.h>
using namespace std;
const int N = 100000;
typedef long long ll;

int t, p;
ll k, n, fact[N] = {1};

int cnt(ll n, int p) {
	return n < p ? 0 : cnt(n / p, p) + n / p;
}

ll modpow(ll b, ll e, ll m) {
	b %= m;
	ll a = 1;
	while (e) {
		if (e & 1) a = a * b % m;
		if (e >>= 1) b = b * b % m;
	}
	return a;
}

ll lucas(ll n, ll k, int p) {
	if (n < 0 || k < 0 || n < k) return 0;
	if (n < p) return fact[n] * modpow(fact[k] * fact[n-k] % p, p - 2, p) % p;
	return lucas(n % p, k % p, p) * lucas(n / p, k / p, p) % p;
}

int main() {
	scanf("%d", &t);
	while (t--) {
		scanf("%lld%lld%d", &n, &k, &p);
		for (int i = 1; i < p; ++i)
			fact[i] = fact[i - 1] * i % p;
		int mult = cnt(n, p) - cnt(k, p) - cnt(n-k, p);
		if (mult > 0) printf("0\n");
		else printf("%lld\n", lucas(n, k, p));
	}
}
#include<bits/stdc++.h>
#define mod 1000000007
#define ll long long int

using namespace std;

ll n;
vector<ll> vec[100100];
ll dp[100100];


ll visit[100100];

ll dfs(ll u)
{
    visit[u]=1;
    ll ans=1;
    ll child=0;
    for(ll i=0;i<vec[u].size();i++)
    {
        ll v=vec[u][i];
        if(visit[v]==0)
        {
            ans=(ans*(1+dfs(v)))%mod;
            child=1;
        }
    }


    //ans=(ans*fact[child])%mod;
    //cout<<ans<<" "<<u<<" "<<child<<endl;
    if(child==0) return dp[u]=1;
    else return dp[u]=ans;

}

int main()
{
    //preCal();

    //for(ll i=0;i<5;i++) cout<<fact[i]<<endl;

    ll test;
    scanf("%lld",&test);

    while(test--)
    {
        memset(visit,0,sizeof(visit));
        for(int i=0;i<=100000;i++) vec[i].clear();
        scanf("%lld",&n);

        for(ll i=1;i<n;i++)
        {
            ll u,v;
            scanf("%lld %lld",&u,&v);
            vec[u].push_back(v);
            vec[v].push_back(u);

        }

        dfs(1);

        ll ans=0;
        for(int i=1;i<=n;i++) ans=(ans+dp[i])%mod;

        printf("%lld\n",ans);

    }



    return 0;
}

for u in range(input()):
    test1 = map(int,raw_input().split())
    test2 = map(int,raw_input().split())
    count = 0
    for x in test2:
        x += test1[1]
        if x % 7 == 0:
            count +=1
    print count

for _ in range(input()):
    n = input()
    arr = map(int, raw_input().split())
    count = 0 # Stores the count of the number of lazy people
    for i in arr:
        if i == -1 :
            count += 1
    count -= 1 # to exclude Gennady
    print (1+float(count)/2)
#include<cstdio>
#include<iostream>
#include<algorithm>
#define NN 10000005
using namespace std;
int c[NN];

inline int max(int a, int b){return a>b?a:b;}

int main()
{
    int n, K, x, sum, cnt,ans=0;
    scanf("%d%d", &n, &K);
    for(int i=0; i<n; i++)
    {
        scanf("%d", &c[i]);
    }
    sort(c, c+n);
    for(int i=0; i<n-1; i++)
    {
        cnt=0, sum=0;
        while(sum<=K && i+cnt<n-1)
        {
            sum+= (cnt+1)*(c[i+cnt+1]- c[i+cnt]);
            //cout<<sum<<" "<<cnt<<" "<<i<<endl;
            if(sum<=K)  cnt++;

        }
        cnt++;
        ans = max(ans,cnt);
    }
    printf("%d\n", ans);
}


t=int(raw_input())
for i in range(t):
    n,m=map(int,raw_input().split())
    if m>n:
        print "Balaji",m-n
    elif n>m:
        print "Bipin",n-m
    else:
        print "No Winner"
#include<stdio.h>
int main()
{
	int ve=1,N,i=0,j,ter[12],c,d;
	char ans[12];
	scanf("%d",&N);
	if(N==0)
	{
		putchar('0');
		putchar('\n');
		return 0;
	}
	if(N<0)
	{
		ve=-1;
		N=0-N;
	}
	while(N)
	{
		d=N%3;
		ter[i++]=d;
		N=N/3;
	}
	while(i<12)
		ter[i++]=0;
	i=0;
	c=0;
	while(i<12)
	{
		if(ter[i]+c==3)
		{
			ans[i]='0';
			c=1;
		}
		else if(ter[i]+c==2)
		{
			ans[i]='-';
			c=1;
		}
		else if(ter[i]+c==1)
		{
			ans[i]='|';
			c=0;
		}
		else
		{
			ans[i]='0';
			c=0;
		}
		i++;
	}
	if(ve==-1)
	{
		for(i=0;i<12;i++)
		{
			if(ans[i]=='|')
				ans[i]='-';
			else if(ans[i]=='-')
				ans[i]='|';
		}
	}
	i=11;
	while(ans[i]=='0')
		i--;
	while(i>=0)
		putchar(ans[i--]);
	return 0;
}
/* Here we are just required to find the four basic points
   on the coordinate axes and do some math.
*/
#include<iostream>
#include<set>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include <iomanip>
#include<algorithm>
#include<math.h>
#include<cstdio>
#include<cstring>
 
using namespace std;
 
struct Point
{
	double x;
	double y;
};
 
 
 
double dist(Point A,Point B)
{
	double p1,p2,s;
	p1 = pow((B.x-A.x),2);
	p2 = pow((B.y-A.y),2);
	s = p1+p2;
	s = sqrt(s);
	//cout<<s<<endl;
	return s;
}
void round_double(double & num, int to)
{
	long places = 1, whole = *(&num);
	for(int i = 0; i < to; i++) places *= 10;
	num -= whole;              // Subtracts the integer part
	num *= places;			   // .1234  -> 123.4
	num = (long)floor(num);
	num /= places;			   // 123 -> .123
	num += whole;			   // Again add integer part to it
}
 
inline void print(long double n){
    n *= 1000;
    n = round(n);
    n /= 1000;
    cout<<n<<endl;
}
int main()
{
	double per;				// To store the perimeter
	Point A,B,C,D,P1,P2,P3,P4;
	// To store various contributions in each quadrant
	double C1,C2,C3,C4;
 
	scanf("%lf %lf",&A.x,&A.y);
	scanf("%lf %lf",&B.x,&B.y);
	scanf("%lf %lf",&C.x,&C.y);
	scanf("%lf %lf",&D.x,&D.y);
 
	/*
	printf("%lf %lf",A.x,A.y);
	printf("%lf %lf",B.x,B.y);
	printf("%lf %lf",C.x,C.y);
	printf("%lf %lf",D.x,D.y);
	*/
 
	P1.x = 0;
	P1.y = (((B.y - A.y)/(B.x - A.x))*(A.x)*(-1) + A.y) ;
	P2.y = 0;	
	P2.x = ((C.x - B.x)/(C.y- B.y))*(B.y)*(-1) + B.x ;
	P3.x = 0;	
	P3.y = ((D.y - C.y)/(D.x - C.x))*(C.x)*(-1) + C.y ;
	P4.y = 0;	
	P4.x = ((A.x - D.x)/(A.y - D.y))*(D.y)*(-1) + D.x ;
 
	per = dist(A,B) + dist(B,C) + dist(C,D) + dist(D,A);
 
	//cout<<P1.x<<" "<<P1.y<<endl;
	//cout<<P2.x<<" "<<P2.y<<endl;
	//cout<<P3.x<<" "<<P3.y<<endl;
	//cout<<P4.x<<" "<<P4.y<<endl;
 
	C1 = dist(A,P1) + dist(A,P4);
	C2 = dist(B,P1) + dist(B,P2);
	C3 = dist(C,P2) + dist(C,P3);
	C4 = dist(D,P3) + dist(D,P4);
 
	C1 = (C1/per) * 100;   //round_double(C1,3);
	C2 = (C2/per) * 100;   //round_double(C2,3);
	C3 = (C3/per) * 100;   //round_double(C3,3);
	C4 = (C4/per) * 100;   //round_double(C4,3);
 
	print(C1);
	print(C2);
	print(C3);
	print(C4);
 
	return 0;
}
T=input()
while T:
      T-=1
      count=0
      n,m=[int(x) for x in raw_input().split()]
      r,c=[int(x) for x in raw_input().split()]
      N=n
      finalarr=[]
      while n:
            n-=1
            arr=[]
            save=[]
            arr2=raw_input()
            for i in arr2:
                  arr.append(i)
            finalarr.append(arr)
      for i in range (0,N-r+1):
            for j in range (0,m-c+1):
                  nex=0
                  for x in range (0,r):
                        if nex==1:
                              break
                        for y in range (0,c):
                              if nex==1:
                                    break
                              if finalarr[x+i][y+j]=='.':
                                    nex=1
                  if nex!=1:
                        count+=1
                        save.append([i,j])
                  
      print count
      
      for a in save:
            print a[0],a[1]
            

def main():
    from string import ascii_lowercase as al
    t = input()
    for i in xrange(t):
        string = raw_input().strip()
        d = {}
        ans = ""
        indx = 0
        for _ in string:
            try:
                ans += d[_]
            except:
                d[_] = al[indx]
                ans += al[indx]
                indx += 1
        print ans
main()

test=int(raw_input())
while(test>0):
	inp=map(int,raw_input().split())
	overs,crr,nrr=inp[0],inp[1],inp[2]
	new_rr=(float)((overs*crr)+nrr)/(overs+1)
	#print overs,crr,nrr,new_rr
	print "%.2f" % new_rr
	test-=1

MOD = 10**9+7

def fast_exp(base, exp):
	res = 1
	while (exp>=1):
		if (exp%2==1):
			res = (res*base)%MOD
		base = (base*base)%MOD
		exp/=2
	return res

for testCase in range(int(raw_input())):
	n = int(raw_input())
	a = map(int,raw_input().split())
	m = max(a)
	c = a.count(m)
	print fast_exp(2,c)-1
	
import re
#t test cases
t = int(raw_input())
for i in range(0,t):
        #n command lines
        n = int(raw_input())
        path = "/"
        for j in range(0,n):
                com = raw_input()
                #print "New command"
                if com == "pwd":
                        #print current working dir
                        print path

                else:
                        com = com.split(' ')[1]
                        if com[-1] != '/':
                                com = com + '/'
                        while com != "":
                                #print "Processing : ", com," PWD : ", path
                                #shift to the directory as per command
                                if com[0] == '.' and com[1] == '/':
                                        # same dir
                                        com = com[2:]
                                elif com[0:2] == "..":
                                        # one dir back
                                        path = path.rsplit('/',2)[0] + '/'
                                        com = com[3:]
                                elif com[0] == '/':
                                        # from root
                                        path = "/"
                                        com = com.split('/',1)[1]
                                else:
                                        # within the current dir
                                        path = path + com.split('/', 1)[0] + '/'
                                        com = com.split('/',1)[1]


t=input()
for x in range(t):
	l=input()
	r=raw_input()
	s=''
	for i in range(l):
#		if i==0 or i==1:
#			continue
		if r[i]=='2' or r[i]=='3' or r[i]=='5' or r[i]=='7':
			s=s+r[i]
		elif r[i]=='4':
			s=s+'322'
		elif r[i]=='6':
			s+='35'
		elif r[i]=='8':
			s+='2227'
		elif r[i]=='9':
			s+='7332'
	s=sorted(s)
	k=''.join(s)
	print k[::-1]
			

# cook your code here
for _ in range(input()):
    n,fff = map(int,raw_input().split())
    s = map(int,raw_input().split())
    if min(s) == 1 or max(s) == n:
        print 'NO'
    else:
        f = True
        s = sorted(s)
        for i in range(len(s)-2):
            if s[i+2]-s[i] == 2:
                f = False
        if f:
            print 'YES'
        else:
            print 'NO'
t = int (raw_input())
while(t>0):
	n,d = map(int,raw_input().split())
	a =[]
	sum = 0
	ans =0
	mape = map(int,raw_input().split())
	for i in mape:
		sum += i
	if(sum + (n-1)*10 >d):
		ans = -1;
	else:
		ans = (d- sum)/5
	print ans		
	t =t-1

for a in range(input()):
    ins = sorted(val for val in raw_input())
    if ins[0]=="0":
        for x in range(1,len(ins)):
            if int(ins[x])>0:
                ins[0] = ins[x]
                ins[x] = "0"
                break
            
    if "".join(ins) == raw_input():
        print "AC"
    else:
        print "WA"
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

inline bool isleap(int y)
{
	if(y%400==0) return true;
	else if(y%4==0 && y%100!=0) return true;
	else return false;
}


int main()
{
	std::string date,mmm,dd,yyyy;
	int t,days,count;
	cin>>t;
	for(count=1;count<=t;count++)
	{
		cin>>date;
		dd=date.substr(0,2);
		yyyy=date.substr(7);
		mmm=date.substr(3,3);

			if(mmm=="JAN") days=0;
			else if(mmm=="FEB") days=31;
			else if(mmm=="MAR") days=59;
			else if(mmm=="APR") days=90;
			else if(mmm=="MAY") days=120;
			else if(mmm=="JUN") days=151;
			else if(mmm=="JUL") days=181;
			else if(mmm=="AUG") days=212;
			else if(mmm=="SEP") days=243;
			else if(mmm=="OCT") days=273;
			else if(mmm=="NOV") days=304;
			else if(mmm=="DEC") days=334;

			if(isleap(std::stoi(yyyy)) && mmm!="JAN" && mmm!="FEB") days++;

			days+=stoi(dd);


			if(days<=300) cout<<"\nCase "<<count<<": "<<days<<" Hundreds";
			else if(days<=360) cout<<"\nCase "<<count<<": "<<(days-300)<<" Tens";
			else cout<<"\nCase "<<count<<": "<<(days-360)<<" Ones";



		}

	return 0;

}
import sys
def main():
    i = int(sys.stdin.readline())
    #print "yo"
    while i!=0:
        #print i
        #count =1
        i=i-1
        s= sys.stdin.readline().split()
        for x in range(len(s)):
            if(s[x]=="8"):
                s[x]="ate"
            elif(s[x]=="w8"):
                s[x]="wait"
            elif(s[x]=="gr8"):
                s[x]="great"
            elif(s[x]=="4"):
                s[x]="for"
            elif(s[x]=="b4"):
                s[x]="before"
        print ' '.join(s)
                
main()

#include<cstdio>
#include<cstdlib>
#include<cstring>
#define INF 1000000001
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)


int dp[1001][1001];
char a[1001][1001];
int calc(int n,int k)
{
    int i,j;
    for(j=0;j<n;j++) dp[n-1][j]=a[n-1][j]-48;
    for(i=n-2;i>=0;i--)
    {
        for(j=0;j<n;j++)
        {
            if(!(i&1)) dp[i][j]=min(min((j>0?dp[i+1][j-1]:INF),(j<n-1?dp[i+1][j+1]:INF)),dp[i+1][j])+a[i][j]-48;
            else dp[i][j]=max(max((j>0?dp[i+1][j-1]:-1),(j<n-1?dp[i+1][j+1]:-1)),dp[i+1][j])+a[i][j]-48;
        }
    }
    int cnt=0;
    for(j=0;j<n;j++) if(dp[0][j]>=k) cnt++;
    return cnt;
}

int main()
{
    int t,n,k,i;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&k);
        for(i=0;i<n;i++) scanf("%s",a[i]);
        printf("%d\n",calc(n,k));
    }
    return 0;
}

count= input()
for _ in range(count):
    ans= input()
    print pow(2, ans, 1000000007)
from math import ceil
from math import sqrt
t=input()
for _ in xrange(t):
    n=input()
    if n==1:
        print "0"
    else:
        ans=ceil((-1+sqrt(1+4*2*(n-1)))/2)
        print int(ans)

#include<stdio.h>
#include<math.h>
#include<iostream>
using namespace std;
int prime(long long n);
int main()
{
	long long t,n,i,x[10000],y[10000],z[10000];
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		for(i=0;i<n;i++)
		{
			scanf("%lld%lld%lld",&x[i],&y[i],&z[i]);
		}
		long long  a=0,b=0,c=0;
		for(i=0;i<n;i++)
		{
			a=a+x[i];
			b=b+y[i];
			c=c+z[i];
		}
		//printf("%lld\n%lld\n%lld",a,b,c);
		int q=prime(a);
		int w=prime(b);
		int e=prime(c);
		//printf("%d\n%d\n%d",q,w,e);
		if(q==0&&q==w&&q==e)
			printf("YES\n");
		else
			printf("NO\n");
	}	
	return 0;
}
int prime(long long  n)
{
	long long i;
	int flag=0;
	if(n==1||n==0)
		flag=1;
	for(i=2;i<=sqrt(n);i++)
	{
		if(n%i==0)
		{
			flag=1;
			break;
		}
	}
	return flag;
}
t=int(raw_input())
for x in range(t):
    (a,b)=raw_input().split()
    ra=""
    rb=""
    for i in xrange(len(a)-1,-1,-1):
        ra=ra+a[i]
    for i in xrange(len(b)-1,-1,-1):
        rb=rb+b[i]
    rsum=int(ra)+int(rb)
    rst=str(rsum)
    s=""
    for i in xrange(len(rst)-1,-1,-1):
        s=s+rst[i]
    print int(s)
#! /usr/bin/python

def reverse(num):
    temp = 0
    while(num):
        temp = temp*10 + num%10
        num /=10
        
    return temp
    
def main_func():
    iterator = int(raw_input())
    while(iterator):
        num = int(raw_input()) + 1
        while(num < 99999):
            temp = reverse(num)
            if temp == num:
                print num
                break
            else:
                num += 1

        iterator -= 1
        
if __name__ == '__main__':
    main_func()
# cook your code here
t=int(raw_input())
for x in range(t):
    (a,b)=raw_input().split()
    if b in a:
        print "1"
    else:
        print "0"
t = int(raw_input())
for i in range(t):
    X, Y, x, y = map(int, raw_input().split())
    room = X*Y
    tile = x*y
    if room%tile == 0:
        print "yes"
    else:
        print "no"
import math
x = input()
z = raw_input()
l = len(z)
for y in xrange(l):
    if z[y]=="W":
        x*=2
        x+=11
    else:
        x = int(math.ceil(x/float(2)))
print x

def f(d, N, C, X):

	cows_placed = 1
	last_pos = X[0]
	for i in xrange(1, N):
		if X[i] - last_pos >= d:
			cows_placed += 1
			last_pos = X[i]
			if cows_placed == C:
				return 1

	return 0

N, C = map(int, raw_input().split())

X = []
for i in xrange(N):
	X.append(input())

X.sort()

start = 0
end = X[N-1]

while start < end:

	mid = (start+end)/2
	val = f(mid, N, C, X)

	if val == 1:
		start = mid+1
	else: #if val == 0:
		end = mid

print start-1
def calc(x):
    s=set()
    for i in xrange(len(x)):
        for j in xrange(i,len(x)):
            s.add(x[i:j+1])
    print len(s)

t=int(raw_input())    
for i in xrange(t):
    n=raw_input()
    calc(n)
t=int(raw_input())
for i in range (t):
    c,d=map(int,raw_input().split())
    print (c*d-c-d)
    

#include <iostream>
using namespace std;
int main(){
        int n;
        cin>>n;
        int ct=0;
        int k=n;
        while(n!=0){
        n=n/2;    
            ct++;
        }
        int a[ct];
        int i=0;
        n=k;
        //System.out.println(ct);
        while(n!=0){
            a[i]=n%2;
            n=n/2;
            i++;
            
        }
      int ft=0;  
        for(i=0;i<ct;i++){
            if(a[i]==1){
                ft++;
            }
        }
        
        
        cout<<ft;
        
    }
    
    

	
	
	
	
	


from sys import stdin
t=stdin.readline()
t=map(int,stdin.readlines())
for m in t:
    count = 0
    for i in range(1,m):
        for j in range(i+1,m+1):
            if (i*j)%(i+j)==0:
                count+=1;
    print count
             
from sys import stdin
def gcd(a,b):
    while a%b:
        t=a%b
        a=b
        b=t
    return b
t=stdin.readline()
t=map(int,stdin.readlines())
a=[1,1]
ma = 1000000007
for i in range (2,105):
    x=a[i-1]
    y=gcd(i,x)
    x/=y
    a.append((x*i))
for m in t:
    print (a[m] +1)%ma


#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
void fun(int h);
int main()
{
    int h,ans;
    scanf("%d",&h);
    fun(h);
    //printf("%d\n",ans);
}
void fun(int h)
{
    if(h==0)
        printf("1\n");
    else if(h==2)
        printf("8\n");
    else if(h==1)
        printf("0\n");
    else
    {
        while(h>0)
        {
            if(h%2==0)
            {
                printf("8");
                h-=2;
            }
            else
            {
                printf("4");
                h-=1;
            }

        }
    }
}

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define pb push_back
#define pob pop_back
#define pf push_front
#define pof pop_front
#define mp make_pair
#define all(a) a.begin(),a.end()
#define bitcnt(x) __builtin_popcountll(x)
#define M 1000000007
typedef unsigned long long int uint64;
typedef long long int int64;

string s[5];
int main(){
	int i,j;
	for(i=0;i<4;i++)
	cin>>s[i];
	int flag=0;
	for(i=0;i<4;i++){
		for(j=0;j<4;j++){
			if(i>0&&j>0){
				if(s[i-1][j]==s[i-1][j-1]&&s[i-1][j]==s[i][j-1]){
				flag=1;
				break;}
			}
			if(i>0&&j<3){
				if(s[i-1][j+1]==s[i][j+1]&&s[i-1][j+1]==s[i-1][j]){
					flag=1;
					break;
				}
			}
			if(i<3&&j>0){
				if(s[i][j-1]==s[i+1][j-1]&&s[i+1][j]==s[i][j-1]){
				flag=1;
				break;}
			}
			if(i<3&&j<3){
				if(s[i][j+1]==s[i+1][j]&&s[i+1][j+1]==s[i][j+1]){
				flag=1;
				break;}
			}	
		}
		if(flag==1)
		break;
	}
	if(flag==1){
		cout<<"POSSIBLE";
	}
	else{
		cout<<"NOT POSSIBLE";
	}
	return 0;
}
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define pb push_back
#define pob pop_back
#define pf push_front
#define pof pop_front
#define mp make_pair
#define all(a) a.begin(),a.end()
#define bitcnt(x) __builtin_popcountll(x)
#define M 1000000007
typedef unsigned long long int uint64;
typedef long long int int64;

int main(){
	vector<int>v;
	int n;
	while(cin>>n){
		v.pb(n);
	}
	sort(all(v));
	n=v.size();
	int ans,cnt=558;
	do{
		int val=0,tmp=0;
		for(int i=0;i<n;i++){
			val=val*10+v[i];
		}
		int l=sqrt(val);
		for(int i=1;i<=l;i++){
			if(val%i==0)
			tmp+=2;
		}
		if(l*l==val)
		tmp--;
		if(tmp<cnt){
		ans=val;	
		cnt=tmp;}
	}while(next_permutation(all(v)));
	cout<<ans<<endl;
	return 0;
}
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define pb push_back
#define pob pop_back
#define pf push_front
#define pof pop_front
#define mp make_pair
#define all(a) a.begin(),a.end()
#define bitcnt(x) __builtin_popcountll(x)
#define M 1000000007
typedef unsigned long long int uint64;
typedef long long int int64;

string s;
int ans,n;
void go(int idx,int cost,int col){
	if(cost>=ans)
	return ;
	if(idx==n-1){
		ans=min(cost,ans);
		return;
	}
	for(int i=idx+1;i<n;i++){
		if(col==0){
			if(s[i]=='G')
			go(i,cost+(i-idx)*(i-idx),1);
		}
		if(col==1){
			if(s[i]=='B')
			go(i,cost+(i-idx)*(i-idx),2);
		}
		if(col==2){
			if(s[i]=='R')
			go(i,cost+(i-idx)*(i-idx),0);
		}
	}
}
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>s;
		n=s.length();
		ans=1e7;
		go(0,0,0);
		if(ans==1e7)
		cout<<-1<<endl;
		else
		cout<<ans<<endl;
	}
	return 0;
}
#include<vector>
#include<cstring>
#include<algorithm>
#include<stdio.h>
#include<climits>
#include<set>
#include<cmath>
#include<list>
#include<bitset>
#include<map>
#include<iostream>
#include<queue>
#define test(t) while(t--)
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
 
#define p(n) printf("%d\n",n)
#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>
#define pb push_back
#define inf 1000000000LL
#define mp make_pair
#define imax (int) 1000000007
//#define inf 100000000
#define ill unsigned long long
#define gc getchar_unlocked
using namespace std;
int main()
{
	char str[51][51];
int dp[52][52];
	int tmp;
	int n;
	int t;
	s(t);
	while(t--)
	{
	s(n);
	int i,j;
	for(i=0;i<n;++i)
	{
		
		for(j=0;j<n;++j)
		{
			scanf(" %c",&str[i][j]);
			tmp=(int)str[i][j];
			if(tmp>=48 && tmp<=57)
			{
				dp[i][j]=tmp-48;
			}
			else if(tmp>=65 && tmp<=90)
			{
				dp[i][j]=tmp-29;
			}
			else if(tmp>=97 && tmp<=122)
			{
				dp[i][j]=tmp-87;
			}
			else
			{
				dp[i][j]=INT_MAX;
			}
		}
	}
/*	for(i=0;i<n;++i)
	{
		for(j=0;j<n;++j)
		{
			cout<<str[i][j];
		}
		cout<<"\n";
	}*/
	int k;
	for(k=0;k<n;++k)
	{
		for(i=0;i<n;++i)
		{
			for(j=0;j<n;++j)
			{
				if(dp[i][k]!=INT_MAX && dp[k][j]!=INT_MAX && i!=j)
				{
					dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
				}
			}
		}
	}
/*	for(i=0;i<n;++i)
	{
		for(j=0;j<n;++j)
		{
			cout<<dp[i][j]<<" ";
		}
		cout<<"\n";
	}*/
int ans;
	ans=0;
	for(i=0;i<n;++i)
	{
		for(j=0;j<n;++j)
		{
			//cout<<dp[i][j];
			if(i!=j)
			{
			ans=max(ans,dp[i][j]);
		    }
		}
		
	}
	if(ans==INT_MAX)
	printf("-1\n");
	else
	printf("%d\n",ans);
   }
} 
import sys
t=sys.stdin.readline()
t=int(t)
for k in range(0,t):
	n=sys.stdin.readline()
	n=int(n)
	d=0
	for i in range(0,n):
		string=sys.stdin.readline()
		t,s=string.split(" ")
		t=int(t)
		s=int(s)
		d=d+t*s
	print d
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<string>
#include<cstring>
#include<sstream>
#include<cmath>
#include<climits>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<iterator>
using namespace std;
 
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
 
#define sstr(str) scanf ("%s", str); 
 
#define p(n) printf("%d ",n)
#define pl(n) printf("%ld ",n)
#define pll(n) printf("%lld ",n)
 
#define pf(n) printf("%f\n",n)
#define pd(n) printf("%lf\n",n)
 
#define pnl(n) printf("%d\n",n)
#define plnl(n) printf("%ld\n",n)
#define pllnl(n) printf("%lld\n",n)
#define nl() putchar_unlocked('\n')
 
#define ll long long
#define MAX(a,b) a>b?a:b
#define all(c) c.begin(), c.end()
#define rall(c) c.rbegin(), c.rend()    // reverse all 
#define pb push_back
#define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++)
#define loop(i,a,n) for(int i=a;i<n;i++)
typedef vector<int> vi;
typedef vector<long long> vll;
typedef vector< vector<int> > vvi;
typedef vector<string> vstr;
 
#define sz(a) int((a).size()) 
#define szar(a) int(sizeof(ar)/sizeof(ar[0]))
#define osit ostream_iterator 
 
void pvec(vi v)
{
  tr(v,it) { p(*it);}
  nl();
}
 
void pvec(vll v)
{
  tr(v,it) { pll(*it);}
  nl();
}
 
std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems)          
 {
    std::stringstream ss(s);                                            //  aa#bc#d -> aa, b,c,d
    std::string item;                                                   //  aa##c#d -> aa, "", c,d
    while (std::getline(ss, item, delim)) {                             //  aa#bc#  -> aa, bc, ""
        elems.push_back(item);                                          //  #a#b#   -> "", a, b, ""
    }
    if(s[s.size() - 1] == delim) elems.push_back("");
    return elems;
}
 
 
std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}
 
int get()                  // working even in loops, working excellent
{
  char c;
  while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-'));
  bool Flag=(c=='-');
  if(Flag)
    c=getchar_unlocked();
  int X=0;
  while(c>='0'&&c<='9')
    {
      X=X*10+c-48;
      c=getchar_unlocked();
    }
  return Flag?-X:X;
}
 
inline void get(char *str)
 
{
    register char c = 0;
    register int i = 0;
    while (c < 33)
        c = getchar_unlocked();
 
    while (c != '\n') {
        str[i] = c;
        c = getchar_unlocked();
        i = i + 1;
    }
    str[i] = '\0';
 
}
 
void output(int X)        // working even in loops, working excellent
{
  if(X<0)
    {
      putchar_unlocked('-');
      X=-X;
    }
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar_unlocked(Data[Len]+48);
 
  putchar_unlocked(' ');
}
void output(ll X)        // working even in loops, working excellent
{
  if(X<0)
    {
      putchar_unlocked('-');
      X=-X;
    }
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar_unlocked(Data[Len]+48);
 
  putchar_unlocked(' ');
}
 
template<class T>
void p2d(T c, int n,int m)
{
  nl();
  loop(i,0,n)
  {
    loop(j,0,m)
    {
      cout << c[i][j] << " ";
    }
    nl();
  }
}
 
int main()
{
 
// DONT USE FAST I/O METHODS when dealing with file input/ouput
// get() giving error if using the below file i/o
 
  /*#ifndef ONLINE_JUDGE
  freopen("input.txt","r",stdin);
  freopen("output.txt","w",stdout);
  #endif */
  int t=get();
  while(t--)
  {
    int cnt=0;
    int n=get();
    while(true)
    {
      //printf("n / 7==%d\n",n%7 );
      if(n%7 == 0)
      {
        n /= 7;
        cnt++;
      } 
      else break;

    }
    //printf("the cnt is %d\n",cnt );
    if(cnt==2) printf("YES\n");
    else printf("NO\n");
  }



 
 
  return 0;
}
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<string>
#include<cstring>
#include<sstream>
#include<cmath>
#include<climits>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<iterator>
using namespace std;
 
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
 
#define sstr(str) scanf ("%s", str); 
 
#define p(n) printf("%d ",n)
#define pl(n) printf("%ld ",n)
#define pll(n) printf("%lld ",n)
 
#define pf(n) printf("%f\n",n)
#define pd(n) printf("%lf\n",n)
 
#define pnl(n) printf("%d\n",n)
#define plnl(n) printf("%ld\n",n)
#define pllnl(n) printf("%lld\n",n)
#define nl() putchar_unlocked('\n')
 
#define ll long long
#define MAX(a,b) a>b?a:b
#define all(c) c.begin(), c.end()
#define rall(c) c.rbegin(), c.rend()    // reverse all 
#define pb push_back
#define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++)
#define loop(i,a,n) for(int i=a;i<n;i++)
typedef vector<int> vi;
typedef vector<long long> vll;
typedef vector< vector<int> > vvi;
typedef vector<string> vstr;
 
#define sz(a) int((a).size()) 
#define szar(a) int(sizeof(ar)/sizeof(ar[0]))
#define osit ostream_iterator 
 
void pvec(vi v)
{
  tr(v,it) { p(*it);}
  nl();
}
 
void pvec(vll v)
{
  tr(v,it) { pll(*it);}
  nl();
}
 
std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems)          
 {
    std::stringstream ss(s);                                            //  aa#bc#d -> aa, b,c,d
    std::string item;                                                   //  aa##c#d -> aa, "", c,d
    while (std::getline(ss, item, delim)) {                             //  aa#bc#  -> aa, bc, ""
        elems.push_back(item);                                          //  #a#b#   -> "", a, b, ""
    }
    if(s[s.size() - 1] == delim) elems.push_back("");
    return elems;
}
 
 
std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}
 
int get()                  // working even in loops, working excellent
{
  char c;
  while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-'));
  bool Flag=(c=='-');
  if(Flag)
    c=getchar_unlocked();
  int X=0;
  while(c>='0'&&c<='9')
    {
      X=X*10+c-48;
      c=getchar_unlocked();
    }
  return Flag?-X:X;
}
 
inline void get(char *str)
 
{
    register char c = 0;
    register int i = 0;
    while (c < 33)
        c = getchar_unlocked();
 
    while (c != '\n') {
        str[i] = c;
        c = getchar_unlocked();
        i = i + 1;
    }
    str[i] = '\0';
 
}
 
void output(int X)        // working even in loops, working excellent
{
  if(X<0)
    {
      putchar_unlocked('-');
      X=-X;
    }
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar_unlocked(Data[Len]+48);
 
  putchar_unlocked(' ');
}
void output(ll X)        // working even in loops, working excellent
{
  if(X<0)
    {
      putchar_unlocked('-');
      X=-X;
    }
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar_unlocked(Data[Len]+48);
 
  putchar_unlocked(' ');
}
 
template<class T>
void p2d(T c, int n,int m)
{
  nl();
  loop(i,0,n)
  {
    loop(j,0,m)
    {
      cout << c[i][j] << " ";
    }
    nl();
  }
}
 
int main()
{
 
// DONT USE FAST I/O METHODS when dealing with file input/ouput
// get() giving error if using the below file i/o
 
  /*#ifndef ONLINE_JUDGE
  freopen("input.txt","r",stdin);
  freopen("output.txt","w",stdout);
  #endif */
  int t=get();
  while(t--)
  {
    string s1,s2;
    cin >> s1;
    cin >> s2;
    sort(s1.begin(),s1.end());
    sort(all(s2));

    if(s1 == s2) printf("YES\n");
    else printf("NO\n");

  }
 
 
  return 0;
}
t = int(raw_input())
print t/5
t=t%5
print t/3
t=t%3
print t/2
t=t%2
print t

/* Name- Aayush Agarwal
   Language -C++
   */
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <list>
#include <deque>
#include <stack>
#include <iterator>
#include <cassert>
#include <cctype>
#include <string>
#include <sstream>
#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>
#define fOr(i,n) for(int i=0;i<n;i++)
#define For(i,n) for(int i=1;i<=n;i++)
#define ss(a) scanf("%s",a)
#define si(a) scanf("%d",&a)
#define sl(a) scanf("%lld",&a)
#define pi(a) printf("%d ",a)
#define pl(a) printf("%lld ",a)
#define ps(a) printf("%s ",a)
#define nl    printf("\n");
#define ll long long int
#define ull unsigned long long int
#define mod 1000000007
using namespace std;

const double eps=1e-9;
const double PI=2*acos(0.0);

#define VI vector<int>
#define VS vector<string>
#define VL vector<long long int>
#define VVI vector<VI>
#define PII pair<int,int>
#define PLL pair<ll,ll>
#define PSS pair<string,string>
#define PSI pair<string,int>
#define VPII vector<PII>
#define VPLL vector<PLL>
#define VPSS vector<PSS>
#define VPSI vector<PSI>
#define pb(a) push_back(a)
#define mp(a,b) make_pair(a,b)
#define sqr(x) ((x)*(x))
#define min(a,b) ((a<b)?a:b)


ll dp[10005][12];

int  main()
{	

	for(int i=0;i<=10;i++)
	{
		dp[0][i]=1;
	}
	
	for(int i=1;i<=10000;i++)
	{
		for(int j=1;j<=10;j++)
		{
			if(i==j)
			dp[i][j]=(1<<i)-1;
			else if(i<j)
			dp[i][j]=(1<<i);
			else
			{
				dp[i][j]=dp[i-1][j]+dp[i-1][j]-dp[i-j-1][j]+mod;
				if(dp[i][j]>=mod)
				dp[i][j]%=mod;
			}
		}
	}
	int t,n,k;
	si(t);
	while(t--)
	{
		si(n);
		si(k);
		if(n==1)
		printf("1\n");
		else
		cout<<dp[n-1][k]<<endl;
		
	}
	
}
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
long long int n,i,ct,temp,start,end1;
struct sethu
{
    long long int x;
    long long int l;
}point[200005];
bool fun(struct sethu s1,struct sethu s2)
{
    return (s1.x<=s2.x);
}
int main()
{
    cin>>n;
    for(i=1;i<=2*n;i+=2)
    {
        cin>>point[i].x>>point[i+1].x;
        point[i].l=1;
        point[i+1].l=-1;
    }
    sort(point+1,point+2*n+1,fun);
    ct=1;
    temp=0;
    for(i=1;i<=2*n;i++)
    {
       if(point[i].l==1)
        temp++;
    else
        temp--;
    ct=max(ct,temp);
    }
    //ct=max(ct,temp);
    cout<<ct<<"\n" ;
}

#include<iostream>
#include<set>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstdio>
#include<cstring>
 
#define sd(x) scanf("%d",&x)
#define MP make_pair
#define PB push_back
#define MOD 1000000007
#define M 40000000
#define F first
#define S second
#define ll long long int
#define LL long long int
 
using namespace std;
 
#define N 200001
 
int vis[N], RIGHT[N], arr[N], LEFT[N], b[101][N];
vector<int> adj[N];
int n;
inline LL powr(LL i, LL x, LL c){
    if(x <= 0){
        return 1%c;
    }
    LL ans = powr(i, x/2, c);
    ans*=ans;
    if(ans >= c)
        ans %= c;
    if(x & 1){
        ans *= i;
    }
    if(ans >= c)
        ans %= c;
    return ans;
}
inline int count(int pos, int val){
    int ans  =0 ;
    while(pos > 0){
        ans += b[val][pos];
        pos -= (pos & -pos);
    }
    return ans;
}
inline int update(int pos, int x, int val){
    while(pos <= n){
        b[x][pos] += val;
        pos += pos & -pos;
    }
    return 0;
}
inline int range(int l, int r, int x){
    int ans = 0;
    ans = count(r, x);
    ans -= count(l-1, x);
    return ans;
}
int cnt = 0;
inline int make(int x){
    cnt++;
    int i;
    LEFT[x] = cnt;
    for(i = 0; i < adj[x].size(); i++){
        if(vis[adj[x][i]] == 0){
            vis[adj[x][i]] = 1;
            make(adj[x][i]);
        }
    }
    RIGHT[x] = cnt;
    return 0;
}
int main(){
    int  k, i, x, y, z, pos, l, r;
    LL c;
    cin>>n>>k;
    for(i = 1; i <= n; i++){
        sd(arr[i]);
    }
    for(i = 1; i < n; i++ ){
        sd(x);
        sd(y);
        adj[x].PB(y);
        adj[y].PB(x);
    }
    for(i = 1; i <= n; i++){
        vis[i] = 0;
    }
    vis[1] = 1;
    make(1);
    for(i = 0; i <= 100; i++){
        for(int j = 0; j <= n; j++){
            b[i][j] = 0;
        }
    }
    //cout<<"Yes";
    for(i = 1; i <= n; i++){
        update(LEFT[i], arr[i], 1);
    }
 
    for(i = 0; i < k; i++){
        sd(x);
        sd(y);
        sd(z);
        if(x == 1){
            pos = LEFT[y];
            update(pos, arr[pos], -1);
            update(pos, z, 1);
            arr[pos] = z;
        }
        else{
            LL ans = 1;
            l = LEFT[y];
            r = RIGHT[y];
            c = z;
            for(int j = 1; j <= 100; j++){
                x = range(l, r, j);
                //cout<<j<<" "<<x<<endl;
                ans *= powr(j, x, c);
                if(ans >= c){
                    ans %= c;
                }
            }
            printf("%lld\n", ans);//<<endl;
        }
    }
    return 0;
}  
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		string a,b;
		int c[75]={0},d[75]={0},m=0,i;
		cin>>a;
		cin>>b;
		for(i=0;i<a.length();i++)
		{
			c[a[i]-48]++;		
		}
		for(i=0;i<b.length();i++)
		{
			d[b[i]-48]++;
		}
		for(i=0;i<75;i++)
		{
			if(c[i]!=0&&d[i]!=0)
			m++;
		}
		cout<<m<<endl;
	}
return 0;
}
# include<bits/stdc++.h>
# define LL long long int
# define pb push_back

using namespace std;

LL gcd(LL a,LL b)
{
    if (b==0)
        return a;
    return gcd(b,a%b);
}

int main(void)
{
    LL T ,n, k , Q;
    for (scanf("%lld",&T);T--;)
    {
        scanf("%lld",&n);
        vector<LL> vec;
        bool flag = false;
        LL max = 0x00;
        for (int i=0;i<n;i++)
        {
            scanf("%lld",&Q);
            vec.pb(Q);
            if (Q%5)
                flag = true;
        }
        
        LL min = LONG_MAX;
        for (int i=0;i<n;i++)
        {
            while (!(vec[i]%5))
                vec[i] /= 5;
            while (!(vec[i]%3))
            vec[i] /= 3;
            if (max < vec[i])
                max = vec[i];
            if (min > vec[i])
                min = vec[i];
        }
        
       if (min==max)
            printf("Yes\n");
        else
            printf("No\n");
    }
    return (0);
}
#include<stdio.h>
int main() {
    int n;
    scanf("%d",&n);
    int a[20][20];
    int prime[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741};
    int p,i,j,b,k;
    p=0;
    i=0;
    j=0;
    k=n;
    while (k>0){
        b=k;
        while (b>0){
            a[i][j]=prime[p];
            p=p+1;
            b-=1;
            j+=1;}
        k-=1;
        j-=1;
        i+=1;
        b=k;
        while (b>0) {
            a[i][j]=prime[p];
            p=p+1;
            b-=1;
            i+=1; }
        b=k;
        i-=1;
        j-=1;
        while (b>0){
            a[i][j]=prime[p];
            p=p+1;
            b-=1;
            j-=1; }
        k-=1;
        b=k;
        j+=1;
        i-=1;
        while (b>0){
            a[i][j]=prime[p];
            p=p+1;
            b-=1;
            i-=1; }
        i+=1;
        j+=1;
}
    for(i=0;i<n;i++){
        for(j=0;j<n;j++)
            printf("%d ",a[i][j]);
        printf("\n");}
return 0;
}

#include<stdio.h>
int main()
{
long int in[10]={2,3,5,13,89,233,1597,28657,514229,433494437};
int n;
scanf("%d",&n);
printf("%ld\n",in[n-1]);
return 0;
}
#include<stdio.h>
#include<math.h>
int main()
{
int nt;
long int n,b,i,sum,r;
scanf("%d",&nt);
while(nt--)
{
sum=0;
scanf("%ld%ld",&n,&b);
i=0;
while(n)
{
r=n%10;
sum=sum+(long)pow(b,i++)*r;
n/=10;
}
printf("%c",sum);
}
return 0;
}
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    print (pow(2,n,100000)-1%100000)%100000
#include <cstdio>
#include <queue>
#include <cstring>
#include <memory.h>
#include <algorithm>
using namespace std;
#define M 101
char s[M][M],s1[M][M];
int a[M],st[M],en[M],mid[M],nxt[M],flag[M],vis[M];
queue<int> qq;
int main() {
    int cas,n,i,j,k,l,ss,tt,fg;
    for(scanf("%d",&cas);cas--;) {
        scanf("%d",&n);
        memset(a,0,sizeof(a));
        memset(st,0,sizeof(st));
        memset(en,0,sizeof(en));
        memset(mid,0,sizeof(mid));
        memset(vis,0,sizeof(vis));
        memset(nxt,-1,sizeof(nxt));
        for(i=0;i<n;i++) {
            scanf("%s",s[i]);
            strcpy(s1[i],s[i]);
            l=strlen(s[i]);
            for(k=j=0;j<l;j++) if(!j || s[i][j-1]!=s[i][j]) s[i][k++]=s[i][j];
            s[i][k]=0;
            for(j=0;j<k;j++) vis[s[i][j]-'a']=1;
        }
        int no=0;
        for(k=0;k<n;k++) {
            l=strlen(s[k]);
            if(l==1) a[s[k][0]-'a']=1;
            else {
                st[s[k][0]-'a']++;
                en[s[k][l-1]-'a']++;
                nxt[s[k][0]-'a']=s[k][l-1]-'a';
                for(i=0;i<l;i++) {
                    for(j=i+1;j<l;j++) if(s[k][i]==s[k][j]) break;
                    if(j<l) break;
                }
                if(i<l) {no=1;break;}
                for(i=1;i<l-1;i++) mid[s[k][i]-'a']++;
            }
        }
        for(i=0;i<26;i++) {
            if(mid[i]) {
                if(mid[i]>1 || a[i] || st[i] || en[i]) {no=1;break;}
            }
            if(st[i]>1 || en[i]>1) {no=1;break;}
        }
        if(no) {puts("NOT POSSIBLE");continue;}
        for(k=i=0;i<26;i++) if(vis[i]) k++;
        if(k==1) {
            for(i=0;i<n;i++) printf("%s",s1[i]);
            puts("");
            continue;
        }
        for(ss=tt=i=0;i<26;i++){
            if(!st[i] && en[i]) tt++;
            if(st[i] && !en[i]) ss++;
        }
        for(i=0;i<26;i++) {
            if(!vis[i]) continue;
            memset(flag,0,sizeof(flag));
            flag[i]=1;
            while(!qq.empty()) qq.pop();
            qq.push(i);
            while(!qq.empty()){
                k=qq.front();qq.pop();
                if(nxt[k]<0) continue;
                k=nxt[k];
                if(flag[k]) {no=1;break;}
                flag[k]=1;
                qq.push(k);
            }
            if(no) break;
        }
        if(no) {puts("NOT POSSIBLE");continue;}
        if(ss==1 && tt==1) {
            for(i=0;i<26;i++) if(a[i] && !st[i] && !en[i]) break;
            if(i<26) {puts("MORE THAN ONE");continue;}
            for(i=0;i<26;i++) if(st[i] && !en[i]) break;
            k=i;
            for(;;) {
                for(i=0;i<n;i++) {
                    l=strlen(s[i]);
                    if(s[i][0]==k+'a' && s[i][l-1]==k+'a') printf("%s",s1[i]);
                }
                for(i=0;i<n;i++) {
                    l=strlen(s[i]);
                    if(s[i][0]==k+'a' && s[i][l-1]!=k+'a') break;
                }
                if(i==n) break;
                printf("%s",s1[i]);
                k=s[i][strlen(s[i])-1]-'a';
            }
            puts("");
        }
        else puts("MORE THAN ONE");
    }
}
T=input()
list=[]
for i in range(T):
    M=input()
    for j in range(2):
        l=map(int,raw_input().split())
        l.sort()
        list.append(l)
for j in range(0,2*T-1,2):
    count=0
    for k in range(len(list[j])):
        for t in range(len(list[j+1])):
            if list[j][k]<=list[j+1][t]:
                list[j+1].remove(list[j+1][t])
                break
    print len(list[j])-len(list[j+1]) 
T=int(raw_input(""))
n=0
k=0
while(T>0):
	raw_input("")
	T=T-1
	tn=raw_input("")
	tnlist=tn.split()
	n=int(tnlist[0])
	#print n
	k=int(tnlist[-1])
	#print k
	imp=raw_input("")
	implist=imp.split()
	implistnum=[]
	for num in implist:
		implistnum.append(int(num))
	implistnum.sort()
	implistnum.reverse()
	#print implistnum
	i=0
	sum=0
	while(i<k):
		sum=sum+implistnum[i]
		i=i+1
	print sum
	
#include <iostream>
#include <algorithm>
#include <stdio.h>
#include <cstring>
using namespace std;

long long dp[1<<16][16];
int main()
{
    int t,n,k;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d",&n,&k);
        memset(dp,0,sizeof(dp));
        for(int i=0;i<n;++i)
        {
            dp[1<<i][i]=1;
        }
        int f=(1<<n)-1;
        for(int i=1;i<=f;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(i&(1<<(j))){
                    for(int x=0;x<n;++x)
                    {
                        if((i&(1<<x))==0 && abs(x-j)<=k){
                            dp[i|(1<<x)][x]+=dp[i][j];
                        }
                    }
                }
            }
        }
        long long ans=0;
        for(int i=0;i<n;++i) ans+=dp[f][i];
        printf("%lld\n",ans);
    }
    return 0;
}

#include<stdio.h>
int is_safe(int mat[300][300],int i,int j,int visited[300][300],int r,int c){
    if(i<r && j<c && mat[i][j]==1 && visited[i][j]==0)
        return(1);
    else
    return(0);
}
void Dfs(int mat[300][300],int i,int j,int visited[300][300],int r,int c){
visited[i][j]=1;
if(is_safe(mat,i,j+1,visited,r,c)==1)
    Dfs(mat,i,j+1,visited, r, c);
if(is_safe(mat,i+1,j,visited,r,c)==1)
    Dfs(mat,i+1,j,visited,r ,c); 
if(is_safe(mat,i,j-1,visited,r,c)==1)
    Dfs(mat,i,j-1,visited, r, c);
if(is_safe(mat,i-1,j,visited,r,c)==1)
    Dfs(mat,i-1,j,visited,r ,c);
}
int main(){
	int t,r,c,i,j,count=0;
	int mat[300][300];
	int visited[300][300];
	scanf("%d",&t);
	while(t--){
		count=0;
		scanf("%d %d",&r,&c);
		for(i=0;i<r;i++){
  			for(j=0;j<c;j++){
                scanf("%d", &mat[i][j]);
                visited[i][j]=0;
  			}
		}
		for(i=0;i<r;i++){
  		    for(j=0;j<c;j++){
 		        if((mat[i][j]==1)&&(visited[i][j]==0)){
                   Dfs(mat,i,j,visited,r,c);
                   count++;
                }
            }
		}
        printf("%d\n",count);
	}
	return(0);
}
//
//  main.cpp
//  Complete The Series (Easy)
//
//  Created by etudes on 31/01/2015.
//  Copyright (c) 2015 spoj. All rights reserved.
//

#include <iostream>
#include <fstream>
#include <string.h>
#include <cstdio>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <cassert>
#include <list>
#include <iomanip>
#include <math.h>
#include <deque>
#include <utility>
#include <map>
#include <set>
#include <bitset>
#include <numeric>
#include <climits>
#include <cctype>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <functional>
#include <sstream>

#define  MOD 1000000007
#define rep(i,n) for(int i = 0; i < n; ++i)
#define rrep(i,n) for(int i = 1; i <= n; ++i)
#define drep(i,n) for(int i = n-1; i >= 0; --i)
#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)
#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)
#define rng(a) a.begin(),a.end()
#define maxs(x,y) x = max(x,y)
#define mins(x,y) x = min(x,y)
#define pb push_back
#define sz(x) (int)(x).size()
/*vi s;
 cout<<sz(s);
 sort(s.begin(), s.end(), myfunction);*/
#define  MOD 1000000007
#define rep(i,n) for(int i = 0; i < n; ++i)
#define rrep(i,n) for(int i = 1; i <= n; ++i)
#define drep(i,n) for(int i = n-1; i >= 0; --i)
#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)
#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)
#define rng(a) a.begin(),a.end()
#define maxs(x,y) x = max(x,y)
#define mins(x,y) x = min(x,y)
#define pb push_back
#define sz(x) (int)(x).size()
#ifndef ONLINE_JUDGE
#define gc getchar
#define pc putchar
#else
#define gc getchar_unlocked
#define pc putchar_unlocked
#endif
#define N 1

using namespace std;
int sol[N];

int t[600000];

int main()
{   ios::sync_with_stdio(false);
    
    for (int i =0; i<24; i++) {
        for (int j =0; j<60; j++) {
            for (int k =0; k<60; k++) {
               if(i||j||k) t[i*3600+j*60+k]=t[i*3600+j*60+k-1];
                if (i/10==k%10&&k/10==i%10&&j%10==j/10) {
                    t[i*3600+j*60+k]++;
                }
            }
        }
    }
    int q;
    cin>>q;
    string s1,s2;
    while (q--) {
        cin>>s1>>s2;
        cout<<t[((s2[0]-'0')*10+(s2[1]-'0'))*3600+((s2[3]-'0')*10+(s2[4]-'0'))*60+((s2[6]-'0')*10+(s2[7]-'0'))]-t[((s1[0]-'0')*10+s1[1]-'0')*3600+((s1[3]-'0')*10+s1[4]-'0')*60+((s1[6]-'0')*10+s1[7]-'0')-1]<<"\n";
    }
    
    return 0;
}
import sys
t=int(sys.stdin.readline())
while t!=0:
    n=int(sys.stdin.readline())
    f=1
    for i in range (1,n+1):
        f=f*i
    f=str(f)
    c=0
    l=len(f)-1
    while l>=0:
        if f[l]=='0':
            c+=1
            l-=1
        else:
            break
    print c
    t-=1

n,m=map(int,raw_input().split())
counter=0
while(n!=0):
    counter+=1
    n-=1
    if counter%m==0:
        n+=1
print counter
# python3

def optimal(n):
    if(n >= 5):
        res = 5
    elif(n < 5 and n >= 3):
        res = 3
    elif(n < 3 and n >= 1):
        res = 1
    elif(n < 1):
        return -1
    return res

if __name__ == "__main__":
    count = -1
    l = []
    test = int(raw_input())
    while(test):
        n = int(raw_input())
        while(n):
            z = optimal(n)
            n = n - z
            count = count + 1
        if(count % 2 == 0):
            l.append(0)
        else:
            l.append(1)
        count = -1
        test = test - 1

    for i in l:
        if(i == 0):
            print "JENNY"
        else:
            print "JACK"

for i in xrange(int(raw_input())):
    n=int(raw_input())
    nos=raw_input()
    x,y,z=nos.split()
    j=9
    count=0
    number=""
    while j>0 and count==0:
        number=str(j)+x+y+z
        for k in xrange(9,-1,-1):
            number=str(j)+x+y+z
            number=number+str(k)
            a=int(number)
            if a%n==0:
                count+=1
                print j,k,(int(number)/n)
                break
        j-=1
    if count==0:
        print "0"

t=int(input())
ans=0
l=[-1]*(100001)
while(t>0):
	s=raw_input().split(" ")
	x=int(s[1])
	if(s[0]=="found"):
		l[x]=ans
	elif(l[x]>=0):
		ans=max(ans,l[x]+x)
		l[x]-=1
	t-=1
	
print ans


t=int(input())
while(t>0):
	n=int(input())
	print 2*n*n
	t-=1
// Sharad Gupta 
// IIIT - Hyderabad
#include<iostream>
#include<sstream>
#include<cstdio>
#include<climits>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<deque>
#include<bitset>
#include<map>
#include<set>
#include<stack>
#include<list>
#include<vector>
#include<queue>

using namespace std;

#define VI vector < int >
#define VVI(A,N,M) vector< VI > A( N, VI (M) )
#define LL long long
#define LLU unsigned long long
#define SI ({int x;scanf("%d",&x);x;})
#define SC ({char x;scanf("%c",&x);x;})
#define PI acos(-1)
#define mp make_pair
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define sz(x) ((int) (x).size())
#define SORT(c) sort(ALL(c))
#define FIT(it,v) for (typeof(v.begin()) it = v.begin(); it != v.end(); it++)
#define FITD(it,v) for (typeof(v.rbegin()) it = v.rbegin(); it != v.rend(); it++)
#define FOR(i,start,end) for(int i=start;i<end;i++)
#define IATOV(a) ({vector<int> v(a,a+sizeof(a)/sizeof(int));v;})
#define CATOV(a) ({vector<char> v(a,a+sizeof(a)/sizeof(char));v;})
#define sieve(a) ({int b=ceil(sqrt(a));VI d(a,0);VI e;int f=2;e.pb(2);e.pb(3);for(int x=1;x<b+1;x++){for(int y=1;y<b+1;y++){int n=(4*x*x)+(y*y);if(n<=a&&(n%12==1||n%12==5)){d[n]^=1;}n=(3*x*x)+(y*y);if(n<=a&&n%12==7){d[n]^=1;}n=(3*x*x)-(y*y);if(x>y&&n<=a&&n%12==11){d[n]^=1;}}}for(int r=5;r<b+1;r++){if(d[r]){for(int i=r*r;i<a;i+=(r*r)){d[i]=0;}}}for(int c=5;c<a;c++){if(d[c]){e.pb(c);}}e;})
#define INF 1000000007
#define EPS 1e-9
#define mt(x, y, z) mp(mp(x,y),z)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define setbits(x) __builtin_popcount(x) //tell number of 1's in binary form
#define GC getchar_unlocked
template <class T> string str(T Number){

			string Result; // string which will contain the result

						ostringstream convert; // stream used for the conversion

										convert << Number; // insert the textual representation of 'Number' in the characters in the stream

															Result = convert.str();
																					return Result;
}
int StringToNumber ( const string &Text )
{
			istringstream ss(Text);
						int result;
										return ss >> result ? result : 0;
}
template<class T> inline vector<pair<T,int> > FACTORISE(T n){vector<pair<T,int> >R;for (T i=2;n>1;){if (n%i==0){int C=0;for (;n%i==0;C++,n/=i);R.push_back(make_pair(i,C));}i++;if (i>n/i) i=n;}if (n>1) R.push_back(make_pair(n,1));return R;}
template<class T> inline T TOTIENT(T n) {vector<pair<T,int> > R=FACTORISE(n);T r=n;for (int i=0;i<R.size();i++)r=r/R[i].first*(R[i].first-1);return r;}
double rnd(float d) //for rounding values
{
			return floor(d + 0.49);
}
template<class T>inline T input(T x){char c=GC();x=0;T s=1;while(c<48||c>57){if(c=='-')s=-1;c=GC();}while(c>=48&&c<=57){x=(x<<3)+(x<<1)+c-48;c=GC();}return x*s;}
LL power(LL a, LL b,LL mod){LL ret=1;while(b>0){   if(b&1)ret = (ret*a)%mod;a=(a*a)%mod;b/=2;}   	return ret%mod;}
map<int,int> c;
int main()
{
	int t=input(t);
	while(t--)
	{
		c.clear();
		int n=input(n);
		vector<int> a(n),d(n);
		int sum=0;
		FOR(i,0,n){a[i]=input(a[i]);sum+=a[i];}
		if(sum%2!=0)
			cout<<0<<endl;
		else
		{
			LL ways=0;
			int s=0;
			sum/=2;
			FOR(i,0,n) {
				s += a[i];
				ways += c[s];
				c[s+sum]++;
			}
			cout<<ways<<endl;
		}


	}
	return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	scanf("%d",&n);
	long long int x,y;
	int i;
	scanf("%lld%lld",&x,&y);
	x=y-x;
	long long int a[n];
	bool b[x+1];
	memset(b,0,sizeof(b));
	for(i=0;i<n;i++) {
		scanf("%lld",&a[i]);
		a[i]-=1;
		if(a[i]<=x)
		b[a[i]]=true;
	}
	/*for(i=1;i<200;i++) {
		printf("%d ",i);
		if(b[i]) printf("1\n");
		else printf("0\n");
	}*/
	for(i=1;i<=x;i++) {
		if(!b[i]) {
		for(int j=0;j<n;j++) {
			if(i-a[j]>0) {
				if(b[i-a[j]]) {
					b[i]=true;
					break;
				}
			}
		}
	}
	}
	/*for(i=1;i<200;i++) {
		printf("%d ",i);
		if(b[i]) printf("1\n");
		else printf("0\n");
	}*/
	if(b[x]) printf("POSSIBLE\n");
	else printf("IMPOSSIBLE\n");
}
#include<stdio.h>
 
int main()
{int t,n,i;
long long int a[101];
  long long int m=5;
   scanf("%d",&t) ;
  a[0]=1;
  a[1]=1;
  a[2]=3;
   while(t--)
   {long long int m=5;
    scanf("%d",&n);         
       
     
    
           for(i=3;i<=100;i++,m+=2)
          {a[i]=(a[i-1]*m)%1000000007;
          }
       
       
       
     
      printf("%lld\n",a[n]) ;
      
    }
 }
#include<stdio.h>
int main()
{
long long int r,d;
scanf("%lld",&r);
d=r*2.1270888;
printf("%lld",d);
return 0;
}
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,flag=0,i;
        cin>>n;
        for(i=1;i<=n;i++)
        {
            int temp=i,rem=0,sum=0;
            while(temp!=0)
            {
                rem=temp%10;
                sum+=rem;
                temp/=10;
            }
            if(sum+i==n)
            {
                flag=1;
                break;
            }
        }
        if(flag==1)
        {
            cout<<i<<endl;
        }
        else
        {
            cout<<"NONE"<<endl;
        }
    }
    return 0;
}

#include<iostream>
#include<cstdio>

using namespace std;

int main() 
{
	int t;
	int n;
	int i, j, k, max;
	scanf ("%d",&t);
	while(t--) {
		scanf ("%d",&n);
		int a[n][n];
		for ( i = 0; i < n; i++ ) {
			for ( j = 0; j < n; j++ ) {
				scanf ("%d",&a[i][j] );
			}
		}
		for ( i = n-2; i >= 0; i-- ) {
			for ( j = 0; j < n; j++ ) {
				max = -32768;
				if ( j == 0 ) {
					if ( a[i+1][j] > a[i+1][j+1] )
						max = a[i+1][j];
					else
						max = a[i+1][j+1];
					a[i][j] = a[i][j] + max;
				}
				else if ( j == n-1 ) {
					if ( a[i+1][j] > a[i+1][j-1] )
						max = a[i+1][j];
					else
						max = a[i+1][j-1];
					a[i][j] = a[i][j] + max;
				}
				else {
					for ( k = j-1; k <= j+1; k++ ) {
						if ( a[i+1][k] > max )
							max = a[i+1][k];
					}
					a[i][j] = a[i][j] + max;
				}
			}
		}
		max = -32768;
		for ( i = 0; i < n; i++ ) {
			if ( a[0][i] > max )
				max = a[0][i];
		}
		printf ( "%d\n",max);
	}
	return 0;
}


#include <iostream>
 
using namespace std;
 
unsigned long npow(int n)
{
	unsigned long x = 1;
 
	while(n > 0)
	{
		x = x * 10; n--;
	}
 
	return x;
}
 
void sort(unsigned long a[][2], int n)
{
	unsigned long temp;
 
	for(int i = 1 ; i < n ; i++)
	{
		for(int j = 0 ; j < n - i ; j++)
		{
			if(a[j][1] < a[j+1][1])
			{
				temp = a[j][1];
				a[j][1] = a[j+1][1];
				a[j+1][1] = temp;
 
				temp = a[j][0];
				a[j][0] = a[j+1][0];
				a[j+1][0] = temp;
			}
		}
	}
}
 
int main()
{
	int t, x, nd, d;
	unsigned long narr[20][2], max, no, dec;
	
	cin >> t;
 
	for(int i = 0 ; i < t ; i++)
	{
		cin >> x;
 
		for(int j = 0 ; j < x ; j++)
		{
			cin >> narr[j][0];
		}
 
		max = narr[0][0];
 
		for(int j = 1 ; j < x ; j++)
		{
			if(narr[j][0] > max)
				max = narr[j][0];
		}
 
		nd = 0;
		while(max > 0)
		{
			max = max / 10; nd++;
		}
 
		for(int j = 0 ; j < x ; j++)
		{
			d = 0;
			no = narr[j][0];
 
			while(no > 0)
			{
				no = no / 10; d++;
			}
			dec = npow(nd - d);
 
			narr[j][1] = narr[j][0] * dec + ( narr[j][0] / npow(d - 1) ) * ( dec - 1 ) / 9;
		}
 
		sort(narr, x);
 
		for(int j = 0 ; j < x ; j++)
		{
			cout << narr[j][0];
		}
 
		cout << endl;
	}
 
 
	return 0;
}
 

#include <bits/stdc++.h>
using namespace std;

int main() {
	int n,m;
	cin>>m>>n;
	int arr[m];
	long long sum =0;
	for(int i =0;i<m;i++){
		cin>>arr[i];
		sum+=arr[i];
	}
	if(sum<n){
		cout<<"NO"<<endl;
	}
	else{
		sort(arr,arr+m);
		sum-=arr[m-1];
		if(sum>=(arr[m-1]-1)){
			cout<<"YES"<<endl;
		}
		else{
			cout<<"NO"<<endl;
		}
	}
	return 0;
}
#include<cstdio>
#include<string>
#include<list>
#include<iostream>
#include<map>
using namespace std;
char input[81];
char tempArray[17];
bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev);
void empty(){}
int main()
{
	int test;
	list<string> lst[15];
	scanf("%d",&test);
	while(test--)
	{
		for(int i=0;i<15;i++)
			lst[i].clear();
		int wrdCnt;
		scanf("%d",&wrdCnt);
		string temp;
		cin.get();
		while(wrdCnt--)
		{
			getline(cin,temp);
			lst[temp.size()-1].push_front(temp);
		}
		scanf("%[A-Z \t]s",input);
		map<char,char>mp;
		map<char,char>rev;
		char* ptr = input;
		if(!decrypt(lst,ptr,mp,rev))
		{
			for(int i=0;input[i];i++)
			{
				if(input[i]>='A' && input[i] <='Z')
					printf("*");
				else
					printf("%c",input[i]);
			}
			printf("\n");
		}

	}
}
bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev)
{
	if(*ptr){
	while(*ptr == ' ' | *ptr =='\t')
		ptr++;
	string tempStr;
	tempStr.reserve(20);
	while(*ptr != ' ' && *ptr)
		tempStr+= *(ptr++);
	for(list<string>::iterator itr = lst[tempStr.size()-1].begin();itr != lst[tempStr.size()-1].end();itr++)
	{
		map<char,char> tmpMap = mp;
		map<char,char> tmpRev = rev;
		for(int j=0;j<tempStr.size();j++)
		{			char tmp;
			if(tmp = tmpMap[tempStr[j]])
			{
				if(itr->at(j) != tmp)
					goto d;
			}
			else
			{
				if(!tmpRev[itr->at(j)]){
				tmpMap[tempStr[j]] = itr->at(j);
				tmpRev[itr->at(j)] = tempStr[j];
				}
				else
				{
					goto d;
				}
			}
		}
		if(decrypt(lst,ptr,tmpMap,tmpRev))
			return true;
		d:
		continue;
	}
	}
	else
	{
		for(int i =0;input[i];i++)
		{
			char tmp;
			if(tmp = mp[input[i]])
			{
				printf("%c",tmp);
			}
			else
				printf("%c",input[i]);
		}
		printf("\n");
		return true;
	}
	return false;
}

#include <stdio.h>
#define _R if(k.x-t<1||k.y-t<1||k.x+t>8||k.y+t>8)break;
#define _T {puts("yes");return;}
#define U(a,b,c,d) {if(feld[a][b]==c||feld[a][b]==d)_T if(feld[a][b]!='0')break;}
 
typedef struct {
int x, y;
}krd;
 
krd inp()
{
int a;
krd r;
scanf("%d",&a);
r.x=a%10;
r.y=9-a/10;
return r;
}
 
void losen()
{
int t, x, y;
char feld[10][10];
krd a, sp1, sp2, k;
 
for(x=1; x<=8; x++)	// Feld nullsetzen
for(y=1; y<=8; feld[x][y++]='0');
 
// weiss einlesen
for(t=0; ++t<=8; a=inp(),feld[a.x][a.y]='a'); // Bauer
for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='b'); // Turm
sp1=inp(),feld[sp1.x][sp1.y]='c'; // Springer1
sp2=inp(),feld[sp2.x][sp2.y]='c'; // Springer2
for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='d'); // Laeufer
a=inp(),feld[a.x][a.y]='e'; // 
a=inp(),feld[a.x][a.y]='f'; // 
 
// schwarz einlesen
for(t=0; ++t<=8; a=inp(),feld[a.x][a.y]='A'); // Bauer
for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='B'); // Turm
sp1=inp(),feld[sp1.x][sp1.y]='C'; // Springer1
sp2=inp(),feld[sp2.x][sp2.y]='C'; // Springer2
for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='D'); // Laeufer
a=inp(),feld[a.x][a.y]='E'; // Dame
k=inp(),feld[k.x][k.y]='F'; // Koenig
 

if(feld[k.x-1][k.y+1]=='a'||feld[k.x+1][k.y+1]=='a')_T
 
// horizontaler / vertikaler Angriff durch Turm oder Dame
for(x=k.x+1; x<=8; x++)	// nach rechts
U(x,k.y,'b','e')
for(x=k.x-1; x>=1; x--)	// nach links
U(x,k.y,'b','e')
for(y=k.y+1; y<=8; y++)	// nach unten
U(k.x,y,'b','e')
for(y=k.x-1; y>=1; y--)	// nach oben
U(k.x,y,'b','e')
 
// diagonaler Angriff durch Laefer oder Dame
for(t=1; t<=8; t++) // nach links oben
{_R U(k.x-t,k.y-t,'d','e')}
for(t=1; t<=8; t++) // nach rechts oben
{_R U(k.x+t,k.y-t,'d','e')}
for(t=1; t<=8; t++) // nach links unten
{_R U(k.x-t,k.y+t,'d','e')}
for(t=1; t<=8; t++) // nach rechts unten
{_R U(k.x+t,k.y+t,'d','e')}
 
// Angriff durch Springer
if(abs(k.x-sp1.x)==1 && abs(k.y-sp1.y==2))_T
if(abs(k.x-sp1.x)==2 && abs(k.y-sp1.y==1))_T
if(abs(k.x-sp2.x)==1 && abs(k.y-sp2.y==2))_T
if(abs(k.x-sp2.x)==2 && abs(k.y-sp2.y==1))_T
 
// Angriff durch Koenig
for(x=k.x-1; x<=k.x+1; x++)
for(y=k.y-1; y<=k.y+1; y++)
if(feld[x][y]=='f')_T
 
puts("no");
}
 
main()
{
int fall;
for(scanf("%d\n",&fall); fall--; losen());
return 0;
}
#include <cassert>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>


size_t N;
char s[20][32];
size_t ss[20];
// best string
size_t bs;
char b[20*20+1];


#include <sys/time.h>
class time_limit
{
public:
	time_limit(double dt_limit): _tv0(), _dt_limit(dt_limit)
	{
		gettimeofday(&_tv0, 0);
	}
	bool operator() ()
	{
		timeval tv1;
		gettimeofday(&tv1, 0);
		double dt=tv1.tv_sec-_tv0.tv_sec+ 1e-6*(tv1.tv_usec-_tv0.tv_usec);
		return dt<_dt_limit;
	}

private:
	timeval _tv0;
	double _dt_limit;
};


void rec(size_t n=0, size_t cs=0)
{
	// current string
	static char c[20*20+1];
	static bool used[20]={};

	if(n==0)
	{
		for(size_t k=0; k<N; ++k)
		{
			std::copy(s[k], s[k]+ss[k], c);
			used[k]=1;
			rec(1, ss[k]);
			used[k]=0;
		}
	}
	else if(n<N)
	{
		for(size_t k=0; k<N; ++k)
			if(!used[k])
			{
				used[k]=1;
				// s[k] is a substring of c
				if(std::search(c, c+cs, s[k], s[k]+ss[k])!=c+cs)
					rec(n+1, cs);
				for(size_t j= cs<ss[k]?0:cs+1-ss[k]; j<cs; ++j)
					if(std::equal(c+j, c+cs, s[k]))
					{
						std::copy(s[k]+cs-j, s[k]+ss[k], c+cs);
						rec(n+1, j+ss[k]);
					}
				used[k]=0;
			}
	}
	else
	{
		if(bs==0 || cs<bs)
		{
			std::copy(c, c+cs, b);
			bs=cs;
			b[bs]=0;
			//std::cout << bs << " " << b << std::endl;
		}
	}
}


int main()
{
	size_t T=1;
	//scanf("%zu", &T);
	//assert(1<=T && T<=20);
	/*char c;
	for(size_t i=0; i<2; ++i)
		scanf("%c", &c);
	scanf("%c", &c);
	time_limit go(0.3*(int(c)/10));
	while(go());
	std::cout << int(c) << std::endl;
	return 0;*/

	for(size_t t=0;; ++t)
	{
		N=0;
		scanf("%zu", &N);
		if(N==0)
			break;
		assert(1<=N && N<=20);
		for(size_t n=0; n<N; ++n)
		{
			scanf("%s", s[n]);
			ss[n]=strlen(s[n]);
			assert(2<=ss[n] && ss[n]<=20);
		}
		bs=0;
		rec();
		b[bs]=0;
		printf("%s\n", b);
	}
	return 0;
}


/*

3\nATGC

*/


#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	map<string,int> mp;
	int prev=0;
	for(int i=0;i<n;++i)
	{
		string s;
		cin>>s;
		mp[s]++;
		if(mp[s]==prev+1)
		{
			cout<<prev+1<<" "<<s<<endl;
			prev++;
		}
	}
}
#include <iostream>
#include <math.h>
typedef long long ll;
int main(){

	long long find_log(long long, long long);
	long long func(ll, ll, ll, ll, long long, long long, long long, ll);

	ll T, E, A, B, C, D ;
	long long X,N,Y;

	std::cin >> T;

	for(long long i = 0; i < T; i++){
		std::cin >> E >> A >> B >> C >> D >> X >> Y;
		N = find_log(X, Y);
		std::cout << func(A, B, C, D, X, Y, N, E) << std::endl;}

	return 0;}

ll func(ll a, ll b, ll c, ll d, long long x, long long y, long long n, ll e){
	if(n==1)
		return e;
	
	n /= 2;
	long long f1 = (x-1)/n;
	long long f2 = (y-1)/n;

	if(f1&&f2)
		return d*func(a, b, c, d, x-n, y-n, n, e);
	else if(f1&&!f2)
		return c*func(a, b, c, d, x-n, y, n, e);
	else if(!f1&&!f2)
		return a*func(a, b, c, d, x, y, n, e);
	else 
		return b*func(a, b, c, d, x, y-n, n, e);}

long long find_log(long long x, long long y){
	long long max = x > y ? x : y;
	long long n = 1;

	while(n<max)
		n<<=1;

	return n;}


#include <bits/stdc++.h>
using namespace std;
#define lld long long
#define pb(x) push_back(x)
int tmp;
struct trie{

	trie* node[10];
	int val;


};
trie* insert(trie* t, int idx, string s){
	int let=s[idx]-'0';
	if(idx == s.size()){
		t-> val = tmp;
		return t;
	}
	if(t->node[let] == NULL){
		t->node[let] = new trie();
	}
	t->node[let] = insert(t->node[let], idx+1, s);
	//t-> val = 0;
	return t;
}

int find(trie* t,string s, int idx){
	 int dig =s[idx]-'0';
	 int new_dig = -1, ans = -1;
	for(int i = 0; i <= 9; i++){
		if(t->node[i] != NULL){
			if(((dig+i) % 10) >= ans){
				ans = ((dig+i) % 10);
				new_dig = i;
			}
		}
	}
	//cout<<s[idx]<<' '<<new_dig<<endl;
	if(new_dig == -1){
		return t->val;
	}
	return find(t->node[new_dig],s,idx+1);
}
lld nsum(lld  a, lld b){
	vector<int> num;
	if(a < b){
		swap(a,b);
	}
	while(a>0){
		int v = ((a%10)+(b%10))%10;
		num.pb(v);
		a/=10;
		b/=10;
	}
	int sz = num.size();
	lld ret = 0;
	for(int i = sz-1; i >= 0; i--){
		ret = ret*10 + num[i];
	}
	return ret;
}
string toStr(int n){
	string s = "0000000000";
	char ch;
	for(int i = 9; i >= 0; i--){
		ch = (n%10)+'0';
		n/=10;
		s[i] = ch;
	}
	return s;
}

int main(){
	//freopen("test.txt","r",stdin);
	int n;
	lld ans=0;
	cin >> n;
	trie* root = new trie();
	string s;
	for(int i = 0; i < n; i++){
		cin >> tmp;
		s = toStr(tmp);
		lld xyz=find(root,s,0);
		if(i != 0)
			ans = max(ans, nsum(xyz,tmp));
		//cout<<tmp<<' '<<xyz<<' '<<nsum(xyz,tmp)<<endl;
		root = insert(root,0,s);
		//cout<<endl;
	}
	cout << ans;
	return 0;
}
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

#define sz(x) int(x.size())
#define LL long long

const int N = 109;
int a[N][N], n, m;
int u[N][N], d[N][N], l[N][N], r[N][N];
int main()
{
//    freopen("in.txt", "r", stdin);
    while(~scanf("%d%d", &n, &m))
    {
        memset(a, 0, sizeof(a));
        memset(u, 0, sizeof(a));
        memset(d, 0, sizeof(a));
        memset(l, 0, sizeof(a));
        memset(r, 0, sizeof(a));
        for(int i = 1; i <= n; ++ i)
        for(int j = 1; j <= m; ++ j) scanf("%d", &a[i][j]);

        for(int i = 1; i <= n; ++ i)
        {
            for(int j = 1; j <= m; ++ j)
                if(a[i][j] == a[i][j - 1]) l[i][j] = l[i][j - 1] + 1;
                else l[i][j] = 1;

            for(int j = m; j >= 1; -- j)
                if(a[i][j] == a[i][j + 1]) r[i][j] = r[i][j + 1] + 1;
                else r[i][j] = 1;
        }

        for(int j = 1; j <= m; ++ j)
        {
            for(int i = 1; i <= n; ++ i)
                if(a[i][j] == a[i - 1][j]) u[i][j] = u[i - 1][j] + 1;
                else u[i][j] = 1;

            for(int i = n; i >= 1; -- i)
                if(a[i][j] == a[i + 1][j]) d[i][j] = d[i + 1][j] + 1;
                else d[i][j] = 1;
        }
        int o = 0;
        for(int i = 1; i <= n; ++ i)
        {
            for(int j = 1; j <= m; ++ j)
            {
                for(int i1 = i; i1 <= n; ++ i1)
                {
                    for(int j1 = j; j1 <= m; ++ j1)
                    {
                        int di = i1 - i + 1, dj = j1 - j + 1;
                        if(r[i][j] >= dj &&
                           d[i][j] >= di &&

                           l[i1][j1] >= dj &&
                           u[i1][j1] >= di
                           )
                           o = max(o, di * dj);
                    }
                }
            }
        }
        printf("%d\n", o);
    }

    return 0;
}


#include<iostream>
#include<cmath>
using namespace std;
int main(){
    int n, i;
    float a, f, angle=0;
    cin>>n;
    char c[n];
    for(i=0;i<n;i++)
        cin>>c[i];
    cin>>a>>f;
    for(i=0;i<n;i++){
        if(c[i]=='L')
            angle=angle-a;
        else angle=angle+a;
        if(abs(angle)>=f){
            cout<<"NO";
            return 0;
        }
    }
    cout<<"YES";
    return 0;
}

#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <limits>
#include <string.h>
#include <bitset>
#include <assert.h>
#include <queue>

 //#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair


using namespace std;
#define DEBUG(x) cout << '>' << #x << ':' << x << endl;
#define imax numeric_limits<int>::max()
#define imin numeric_limits<int>::min()
#define lmax numeric_limits<LL>::max()
#define lmin numeric_limits<LL>::min()
#define SZ(x) (int)x.size()
typedef long long LL;
#define all(x)					x.begin(),x.end()

LL n, m;

LL valid(LL i, LL j)
{
    if (i >= 1 && j >= 1 && i <= n && j <= m){
        return 1;
    }
    return 0;
}



LL end = 0;
LL arr[202][202];
LL ans[202][202];
LL next_mx = 0;
LL fla[202][202];

void go (LL x, LL y, LL cur)
{
  //  cout<<x<<" "<<y<<"\n";
    if (x == 1 || x == n || y == 1 || y == m){
        end = 1;
    }

    if (fla[x][y] == 1){
        return;
    }
    fla[x][y]=1;
    ans[x][y] = 1;
    for (LL i = -1; i<=1;i++){
        for (LL j=-1;j<=1;j++){
            if (i == 0 && j == 0){
                continue;
            }
            LL nx = x + i;
            LL ny = y + j;
            if ( valid(nx, ny) == 1){
                if (arr[nx][ny] > cur){
                    next_mx = min (next_mx, arr[nx][ny]);
                }
                if (ans[nx][ny] == 0 && arr[nx][ny] <= cur){
                    go (nx, ny, cur);
                } else if (ans[nx][ny] == 1){
                    go (nx, ny, cur);
                }
            }
        }
    }
}


int main()
{
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for (LL i=1;i<=n;i++){
        for (LL j=1;j<=m;j++){
            cin>>arr[i][j];
        }
    }
    LL x, y;
    cin>>x>>y;
    LL cur = arr[x][y];
    LL cnt = 0;
    while (end == 0 ){
        next_mx = 1e9;
        go(x,y, cur);
        memset (fla, 0, sizeof(fla));
   //     cout<<next_mx<<"\n";
        cur = next_mx;
        cnt++;
    }
   // cout<<"end "<<end<<"\n";
    for (LL i=1;i<=n;i++){
        for (LL j=1;j<=m;j++){
            if (ans[i][j] == 1){
                cout<<"1";
            } else {
                cout<<"0";
            }
            if (j != m){
                cout<<" ";
            }
        }
        cout<<"\n";
    }
    return 0;
}
/*



*/

#include<iostream>
using namespace std;
long long int d[7][10001]={0};
bool e[7][10001]={0};
long long int f(int b,int n)
              {
                  if(e[b][n])
                  return d[b][n];
                  if(n<=0)
                  return 1;
                  if(b==0)
                  return 1;
                  long long int s=1;
                  s+=f(b-1,n);
                  s+=f(b-1,n);
                  s+=f(b-1,n-1);
                  s+=f(b-1,n-2);
                  s+=f(b-1,n-3);
                  s+=f(b-1,n-4);
                  s+=f(b-1,n-6);
                  s+=f(b,n-1);
                  s+=f(b,n-2);
                  s+=f(b,n-3);
                  s+=f(b,n-5);
                  s+=f(b,n-1);
                  s+=f(b,n-2);
                  s+=f(b,n-5);
                  s+=f(b,n-7);
                  s%=10000007;
                  e[b][n]=1;
                  return d[b][n]=s;
                  }

int main()
{
    int t,j=0;
    cin>>t;
    while(t--)
    {
              j++;
              cout<<"Case "<<j<<": ";
              int n;
              cin>>n;
              int i;
              long long int s=0;
              s+=f(6,n);
              s%=10000007;
              cout<<s<<endl;
              }
              return 0;
              }

#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<iostream>
typedef long long ll;
using namespace std;
#define mod 10000000000283LL

//int getchar_unlocked()  {return getchar();}
inline void f(int &x);
/*inline void f(int &x) {
	register int c = getchar_unlocked();
	x = 0;
	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());
	for(; c>47 && c<58 ; c = getchar_unlocked()) {
		x = (x<<1) + (x<<3) + c - 48;
	}
}*/

int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163};

ll mulmod(ll a, ll b){
    ll x = 0, y=a%mod;
    while(b){
		x = (x + (b%10)*y)%mod;		
        y = (y*10)%mod;
        b /= 10;
    }
    return x;
}

ll modexponent(ll base, ll exponent) {
	ll result = 1;	
	while (exponent > 0) {
		if ((exponent & 1) == 1)
			result = mulmod(result, base);
		exponent = exponent >> 1;
		base = mulmod(base, base);		
	}	
	
	return result;
}

ll phi(ll n){ 
	ll result=1; 
	if(!(n%2)){ 
		n/=2; 
		while(!(n%2)){ 
			n/=2; 
			result*=2; 
		} 
	} 
	for(ll k=3;k*k<=n;k+=2){ 
		if(!(n%k)){ 
			n/=k; 
			result*=k-1; 
			while(!(n%k)){ 
				n/=k; 
				result*=k; 
			} 
		} 
	} 
	if(n>1) 
		result*=n-1; 
 
	return result; 
}

int nc;
int phi2(int n){
	int res=nc=n;
	for(int i=0;prime[i]*prime[i]<=nc && n>1;i++){
		if(n%prime[i]==0){res/=prime[i]; res*=(prime[i]-1);}
		while(n%prime[i]==0)n/=prime[i];
	}
	if(n>1){ res*=n-1; res/=n;}
	return res;
	
}

int main(){
	int t,i,j,k,n;
	f(t);
	while(t--){
		f(n);f(k);
		ll sum , val1, val2;
		if (n == 1)
			sum = k;
		else {
			ll x, y;
			x=modexponent(n-1, mod - 2);
			if (x < 0) x += mod ;
			val1 = mulmod(phi(n), x); val2 = modexponent(n, k) - 1;
			sum = mulmod(val1, val2);			
		}
		printf("%lld\n", sum);
	}
	return 0;
}


#define BUF 4096
char ibuf[BUF];
int ipt = BUF; 
inline void f(int &n) {
	while (ipt < BUF && ibuf[ipt] < '0') ipt++;
	if (ipt == BUF) {
		fread(ibuf, 1, BUF, stdin);
		ipt = 0;
		while (ipt < BUF && ibuf[ipt] < '0') ipt++;
	}
	n = 0;
	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
	if (ipt == BUF) {
		fread(ibuf, 1, BUF, stdin);
		ipt = 0;
		while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
	}
}

#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <memory>
#include <cctype>
#include <cstring>
#include <vector>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <set>
#include <algorithm>
#include <utility>
using namespace std;

#define MAX 100001

vector<int>queen;
vector<int>lose;
int a[MAX]={0};
int ans[MAX]={0};

int main (){
  a[1] = -1;
  lose.push_back(0);
  lose.push_back(1);
  lose.push_back(9);
  ans[0]=1;
  ans[1]=1;
  ans[9]=1;
  int i,j;
  for(i=2; i<MAX; i++){
	if(a[i] == 0){
	  queen.push_back(i);
	  for(j=2*i; j<MAX; j+=i){
		a[j]++;
	  }
	} else {
	  if(a[i] == 2){
		queen.push_back(i);
	  }
	}
  }
  for(i=10; i<MAX; i++){
	bool win = false;
	for(j=0; j<lose.size(); j++){
	  if(a[i-lose[j]] == 0 || a[i-lose[j]] == 2){
		win = true;
		break;
	  }
	}
	if(!win){
	  lose.push_back(i);
	  ans[i]=1;
	}
  }
/*  for(i=0; i<lose.size(); i++)
	printf("%d %d\n",i, lose[i]);*/
  int t;
  scanf("%d",&t);
  while(t--){
	char name[4];
	int n;
	scanf("%s%d",name,&n);
	if(ans[n]){
	  if(name[0] == 'S')
		printf("Pre\n");
	  else
		printf("Sak\n");
	}
	else {
	  if(name[0] == 'S')
		printf("Sak\n");
	  else
		printf("Pre\n");
	}
  }
  return 0;
}

#include <stdio.h>
#include <math.h>

#define SQRTMAXN 1000
#define MAXN     1000000
#define MAXK     1000000000
#define MOD      1000000007

int primes[MAXN + 1], invprimes[MAXN + 1], nprimes ;

int fastpow(long long int a, int p)
{
	long long int i = 1 ;
	
	while (p)
	{
		if (p & 1)
		{
			i = (i * a) % MOD ;
		}
		
		p /= 2 ;
		a *= a ;
		a %= MOD ;
	}
	
	return i ;
}

int main()
{
	long long int R, S ;
	int           i, j, k, n, t ;
	
	for (i = 2 ; i <= SQRTMAXN ; i++)
	{
		if (!primes[i])
		{
			for (j = i * i ; j <= MAXN ; j += i)
			{
				primes[j] = 1 ;
			}
		}
	}
	
	for (i = 2, nprimes = 0 ; i <= MAXN ; i++)
	{
		if (!primes[i])
		{
			invprimes[nprimes] = fastpow(i - 1, MOD - 2) ;
			primes[nprimes++]  = i ;
		}
	}
	
	primes[nprimes] = MAXN + 1 ;
	
	scanf("%d", &t) ;
		
	while (t--)
	{
		scanf("%d%d", &n, &k) ;
		
		R = 1LL ;
				
		for (i = 0 ; primes[i] <= n; i++)
		{
			S  = 0LL ;
			S += fastpow(primes[i], k + 1) - 1 ;
			S *= invprimes[i] ;
			S %= MOD ;
			S += MOD - k - 1 ;
			S %= MOD ;
			S *= invprimes[i] ;
			S %= MOD ;
			R *= S ;
			R %= MOD ;
		}
		
		printf("%lld\n", R) ;
	}	
	
	return 0 ;
}

/*
Success is a matter of hanging on, when others have let go.
Its not who you are, that holds you back, its who you think you are not.
The future belongs to those, who believe in the beauty of their dreams.
*/
//{ /* theCodeGame */
#include<iostream>
#include<cmath>
#include<algorithm>
#include<climits>
#include<vector>
#include<queue>
#include<bitset>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
using namespace std;
#define MOD 1000000007LL
#define LL long long
#define ULL unsigned long long
#define LD long double
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) ((x)*(x))
#define CUBE(x) ((x)*(x)*(x))
#define si(n) scanf("%d",&n)
#define si2(n,m) scanf("%d %d",&n,&m)
#define sf(n) scanf("%f",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
#define slu(n) scanf("%llu",&n)
#define sd(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define pnl printf("\n")
#define REP(i,n) for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define FORR(i,n,e) for(int i=(n);i>=(e);i--)
#define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d))
#define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))
//#undef mydebug
#ifdef mydebug
#define DB(x) cout<<#x<<"="<<(x)<<"\n"
#define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n"
#define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n"
#define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n"
#define pnld pnl;
#else
#define DB(x)
#define DB2(x,y)
#define DB3(x,y,z)
#define DB4(x,y,z,a)
#define pnld
#endif
#define FILL(a,b) memset(a,b,sizeof(a))
const double PI=3.14159265358979323846264338327950288419716939937510582097494459230;
//template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;}
void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";}
void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;}
ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);}
//}
#define size 111
const int dx[]={-1,0,1,0};
const int dy[]={0,1,0,-1};//no diagonal movements
int ANS[size][size];//for answer
//for taking the map
int M,N,Sx,Sy,Fx,Fy;

void precompute(){}
void doThis(){
    string map[size];
    FILL(ANS,0);
    si2(M,N);
    si2(Sx,Sy);
    si2(Fx,Fy);
    REP(i,M){
        cin>>map[i];//ss(map[i]);
    }
    queue<pair<int,int> >q;
    q.push(make_pair(Sx,Sy));
    ANS[Sx][Sy]=1;
   // DB3("pushing..",Sx,Sy);
    while(!q.empty()){
        int x = q.front().first;
        int y = q.front().second;
       // DB3("poped..",x,y);
        q.pop();
        if(x==Fx&&y==Fy){
            //DB4(x,Fx,y,Fy);
            break;
        }
        //trying each move using dx,dy
        FOR(i,0,4){
            int tX=x;
            int tY=y;
           // DB3("for 1 to 4 direction loop",x,y);
            while(1){
                //DB("while loop");
                tX=tX+dx[i];
                tY=tY+dy[i];
                //DB4(dx[i],dy[i],tX,tY);
                if(tX>=0&&tY>=0&&tX<M&&tY<N&&map[tX][tY]=='.'&&ANS[tX][tY]==0){
                    ANS[tX][tY]=ANS[x][y]+1;
                    //DB4(x,y,ANS[x][y],ANS[tX][tY]);
                    //DB3("pushing..",tX,tY);
                    q.push(make_pair(tX,tY));
                }else{
                    //DB("break out of loop");
                    break;
                }
            }
        }//end for dx dy
    }
   /* pnld;
    REP(i,M){
        REP(j,M){
            cout<<ANS[i][j]<<" ";
        }
        pnld;
    }
    pnld;*/
    if(ANS[Fx][Fy]){
        printf("%d\n",ANS[Fx][Fy]-1);
    }else{
        puts("0");
    }
}

int main(){
#ifdef amy
freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr);
#endif
precompute();
int t=1;
scanf("%d",&t);
while(t--){doThis();}
#ifdef amy
fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC));
#endif
return 0;
}

#include <algorithm>

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <iostream>
#include <iterator>

#include <map>

#include <numeric>

#include <queue>

#include <set>
#include <sstream>
#include <string>

#include <vector>

using namespace std;

#define ALL(c) (c).begin(), (c).end()

#define CLEAR(x) memset(x,0,sizeof x);
#define CLEARA(x) memset(&x,0,sizeof x);

#define FILL(x,v) memset(x,v,sizeof x);
#define FILLA(x,v) memset(&x,v,sizeof x);
#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--) 
#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)
 
#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)
#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)
#define REVERSE(c) reverse(ALL(c))

#define SORT(c) sort(ALL(c))
 
#define VAR(a,b) __typeof(b) a=(b)
 
#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())

#define INF 0x7fffffff
#define pb push_back
#define X first
#define Y second
#define SZ(c) (int)(c).size()
#define MP make_pair

#define MAX_BIT 20

typedef pair<int, int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long LL;

struct trie
{
	int set;
	struct trie *one, *zero; 
};

int main()
{
	struct trie *temp,*node;
	int n,q,a,b,max_xor,pow2;
	temp = new trie;
	temp->set = 0;
	temp->zero = NULL;
	temp->one = NULL;
	scanf("%d",&n);
	REP(i,n)
	{
		scanf("%d",&a);
		pow2 = 1<<MAX_BIT;
		node = temp;
		while(pow2!=1)
		{
			pow2 = pow2>>1;
			if(pow2 & a)
			{
				if(node->one==NULL)
				{
					node->one = new trie;
					node = node->one;
					node->set = 1;
					node->zero = NULL;
					node->one = NULL;
				}
				else
				{
					node = node->one;
				}
			}
			else
			{
				if(node->zero==NULL)
				{
					node->zero = new trie;
					node = node->zero;
					node->set = 0;
					node->zero = NULL;
					node->one = NULL;
				}
				else
				{
					node = node->zero;
				}
			}
		}
	}		
	scanf("%d",&q);	
	REP(i,q)
	{
		scanf("%d",&b);
		pow2 = 1<<MAX_BIT;
		max_xor = 0;
		node = temp;
		while(pow2!=1)			
		{
			pow2 = pow2>>1;
			if(pow2 & b)
			{
				if(node->zero!=NULL)
				{
					max_xor+=pow2;
					node = node->zero;					
				}
				else
				{
					node = node->one;
				}
			}
			else
			{
				if(node->one!=NULL)
				{
					max_xor+=pow2;
					node = node->one;					
				}
				else
				{
					node = node->zero;
				}			
			}
		}
		printf("%d\n",max_xor);
	}
	return 0;
}



a=[]
a.append(0)
a.append(1)
for i in range(2,4782):
    a.append(a[i-1]+a[i-2])


n=int(raw_input())
while n!=0:
    print a[n]
    n=int(raw_input())

#!/usr/bin/python
# -*- encoding: utf-8 -*-
# pylint: disable=invalid-name,missing-docstring,bad-builtin
from sys import stdin

def main():
    arr = [0]*(1000001)
    arr[0] = arr[1] = 1
    for x in xrange(2, 1000001):
        arr[x] = (arr[x - 1] + arr[x - 2]) % 1000000007
    dstream = map(int, stdin.read().split())
    for t in xrange(1, dstream[0] + 1):
        print arr[dstream[t]]

main()

/*just checking solution by commenting some lines*/

#include <cstdio>
#include <vector>

using namespace std;

inline int readInt() {
	int res;
	scanf("%d", &res);
	return res;
}

int dist(int x1, int y1, int x2, int y2) {
	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

int d[100];
vector <pair <int, int> > e[101];
int r[100][201];

void go(int v, int p, int l) {
	fill_n(r[v], l + 1, d[v]);
	for (int i = 0; i < e[v].size(); i++) {
		int nv = e[v][i].first;
		if (nv == p)
			continue;
		int ll = l - e[v][i].second;
		int d = e[v][i].second;
		if (ll < 0)
			continue;
		go(nv, v, ll);
		for (int j = l; j >= d; j--) {
			for (int k = 0; k <= j - d; k++)
				r[v][j] = max(r[v][j], r[v][k] + r[nv][j - d - k]);
		}
	}
}

int main() {
//	freopen("output.txt", "w", stdout);
	int t = readInt();
	for (int tt = 1; tt <= t; tt++) {
		int n = readInt();
		int l = readInt();
		for (int i = 0; i < n; i++) {
			d[i] = readInt();
			e[i].clear();
		}
		for (int i = 0; i < n - 1; i++) {
			int a = readInt();
			int b = readInt();
			int c = readInt();
			e[a].push_back(make_pair(b, c));
			e[b].push_back(make_pair(a, c));
		}
		go(0, -1, l / 2);
		int ans = r[0][l / 2];
		printf("Case #%d: %d\n", tt, ans);
	}
//	system("pause");
    return 0;
}

/*
6 25
5 8 3 3 10 7
0 1 4
3 0 3
2 3 2
5 2 3
4 5 4

4 2 5
-10 5 2 6
1 2 1
2 3 1
2 4 1

*/

#include<stdio.h>
int main()
{
    int t, n, i, x, j, k,b,s;
    unsigned a[10000];
/*    scanf("%d", &t);
    while(t--)
    {*/
		s=0;
	    scanf("%d%d", &b,&n);
    	if (n==0)
	    printf("1\n");
    	else
	    {a[0]=1;
    	for (i=1, k=0; i<=n; i++)
	    for (j=0, x=0; j<=k; j++)
    	{
		    a[j]=a[j]*b + x;
		    x=a[j]/10;
    		a[j]=a[j]%10;
    		if (x!=0 && j==k)
    		a[++k]=0;
    	}
    	while (k>=0)
    	{
			s+=a[k];
			printf("%d", a[k--]);
    	}
    	printf("\n%d",s);
    	}
//    }
    return 0;
}

r=lambda n:o[n]if n<10 else''.join(dict(zip('ivxlc','xlcdm'))[c]for c in r(n//10))+o[n%10]
o=' i ii iii iv v vi vii viii ix'.split(' ')

inp = int(raw_input())
while (inp != 0):
    i = 0
    v = 0
    x = 0
    l = 0
    c = 0
    for index in range(1, inp + 1):
        rom = r(index)
        i += rom.count("i")
        v += rom.count("v")
        x += rom.count("x")
        l += rom.count("l")
        c += rom.count("c")
    print '{0} {1} {2} {3} {4}'.format(i, v, x, l, c)
    inp = int(raw_input())

R = [0,9,189,2889,38889,488889,5888889,68888889,788888889]

def process(N):
    for i in xrange(8,-1,-1):
        if  N >  R[i]:
            N -= R[i]
            if N % (i+1): return 'Impossible!'
            else:         return N / (i+1) + 10**i - 1

def main():
    while True:
        N = raw_input()
        if N == '#': break
        print process(int(N))

main()

import re
tc = int(raw_input())
while tc>0:
	tc = tc - 1
	s = raw_input()
	s = re.findall(r'\d+', s)
	ans = 0
	for i in s:
		ans = ans + int(i)
	print ans

t=input()
while(t>0):
    s=raw_input()
    s=s.lower()
    A=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]
    flag=0
    for i in range(len(A)):
        c=s.count(A[i])
        if(c>=1):
            flag=1
        else:
            flag=-1
            break
    if(flag==1):
        print "TRUE"
    else:
        print "FALSE"
    t=t-1
    

t=input()
while(t>0):
    s=raw_input()
    s=s.lower()
    a=list(set(s))
    A=[]
    for i in range(len(a)):
        A.append(s.count(a[i]))
    c=0
    for i in range(len(A)):
        if(A[i]>1):
            c+=1
        else:
            c+=0
    print c
    t=t-1
    

tc = int(raw_input())
while (tc>0):
	tc = tc - 1
	s = raw_input()
	a, e, i, o, u = s.count('a'), s.count('e'), s.count('i'), s.count('o'), s.count('u')
	de = len(s)
	nu = len(s) - 4 - a - e - i - o - u + 1
	print str(nu) + "/" + str(de)
t=input()
for i in range(t):
    s=raw_input()
    m=list(set(list(s.lower())))
    if len(m)%2==0:
        print "Terrorist"
    else:
        print "Counter Terrorist"
      
#include "stdio.h"
#include "algorithm"

using namespace std;
int n, a[100010], bit[100010];
pair <int,int> Unique[100010];
long long k, ans, cnt;

void update(int x, int val)
{
    for (; x<=n; x+=x&(-x))
        bit[x] += val;
}
long long get(int x)
{
    long long hsgs = 0;
    for (; x; x-=x&(-x))
        hsgs += bit[x];
    return hsgs;
}

main()
{
    scanf("%d %lld", &n, &k);
    for (int i=1; i<=n; i++)
        scanf("%d", &Unique[i].first), Unique[i].second = i;

    sort(Unique+1, Unique+n+1);
    for (int i=1, j=1, d=0; j<=n; i=j)
    {
        d++;
        for (; j<=n; j++)
            if (Unique[i].first == Unique[j].first) a[Unique[j].second] = d;
                else break;
    }

    for (int i=1, j=1; i<=n; i++)
    {
        cnt += get(n) - get(a[i]);
        update(a[i], 1);
        while (j < i)
        {
            int p = get(a[j]-1);
            if (cnt-p < k) break;
            else cnt -= p, update(a[j++], -1);
        }
        if (cnt >= k) ans += j;
    }

    printf("%lld", ans);
}


t = int(raw_input())

for i in range(0, t):
  string = raw_input()
  e = 0
  p = 0
  for j in range(0, len(string)):
    if string[j] == 'E':
      e += 1
    else:
      p += 1
  print min(e, p), max(e, p) - min(e, p)
  

#include <iostream>
using namespace std;

char chess[9][9];
bool endFlag,rowUA[9],columnUA[9],diaMajorUA[16],diaMinorUA[16];

bool attacked(int i,int j)
{
    return rowUA[i] || columnUA[j] || diaMajorUA[i-j+8] || diaMinorUA[i+j-1];
}

void putQueen(int i,int j)
{
    rowUA[i]=columnUA[j]=diaMajorUA[i-j+8]=diaMinorUA[i+j-1]=true;
    chess[i][j]='*';
}

void zeroAll()
{
    for (int i=1;i<=8;i++)
        for (int j=1;j<8;j++)
            chess[i][j]=' ';
    for (int i=1;i<=8;i++)
        rowUA[i]=columnUA[i]=false;
    for (int i=1;i<=15;i++)
        diaMajorUA[i]=diaMinorUA[i]=false;
}

int main()
{
    int testCases,j[9];
    cin>>testCases;
    while (testCases--)
    {
        for (int i=1;i<=8;i++)
            cin>>j[i];
        for (int i=1;i<=8;i++)
            if (!attacked(i,j[i]))
                putQueen(i,j[i]);
            else
            {
                cout<<"No"<<endl;
                goto endCase;
            }
        cout<<"Yes"<<endl;
        endCase:;
        zeroAll();
    }
    return 0;
}
#include<cstdio>
#include<cmath>
using namespace std;

int fib(int n)
{
    if(n==1 || n==2)return 1;
    else return fib(n-1)+fib(n-2);
}


int main()
{
    int n,p;
    int v[39];
    v[0]=0;
    int i=1;
    while(i<=38)
    {
        v[i]=0;
        int t=fib(i);
        int x=5;
        while(x<=t)
        {
            v[i]=v[i]+t/x;
            x=x*5;
        }
        i++;
    }
    scanf("%d",&n);
    while(n>0)
    {
        scanf("%d",&p);
        printf("%d\n",v[p]);
        n--;
    }
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<list>

using namespace std;

void quick_sort(vector<long> &a,int left,int right)
{
    int i = left, j = right;
    int tmp;
    int pivot = a[(left + right) / 2];
    while (i <= j)
    {
        while (a[i] < pivot)    i++;
            while (a[j] > pivot)    j--;

            if (i <= j)
            {
                tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
                i++;
                j--;
            }

    }

    if (left < j)   quick_sort(a, left, j);
    if (i < right)  quick_sort(a, i, right);
}

int pos_search(vector<long> &a,long x,int l,int r)      //a sorted
{
    int s=a.size()-1;
    if(l==r) return l;
    else if(a[(l+r)/2]<x) pos_search(a,x,(l+r)/2 + 1,r);
    else pos_search(a,x,l,(l+r)/2);
}

int main()
{
    vector<long> v;
    int t,n,i,f;
    long a,g;
    scanf("%d",&t);
    while(t>0)
    {
        v.clear();
        scanf("%d",&n);
        v.push_back(0);
        i=1;
        while(i<=n)
        {
            scanf("%ld",&a);
            v.push_back(a);
            i++;
        }
        scanf("%d",&f);
        g=v[f];
        quick_sort(v,0,n);
        printf("%d\n",pos_search(v,g,0,n));
        t--;
    }
}

#include <stdio.h>

int main(void) {
    long long int T,N,n,count,i;
    scanf("%lld",&T);
    for(i=0;i<T;i++)
    {
        N=100000;
        scanf("%lld",&n);
        count=0;
        while(N>=n)
        {
            count++;
            N=N-n;
        }
        printf("%lld litres will last for %lld weeks\n",n,count);
        
    }
    
    
    
	// your code goes here
	return 0;
}

import math
sach=True
while sach==True:
	try:	
		p=raw_input()
		n=int(p)
		x=math.factorial(n)
		s=str(x)
		s=s[::-1]
		ans=0
		for i in s:
			if i=='0':
				ans+=1
			else:
				break
		print ans
	except EOFError:
		sach=False

import sys
t=input()
str1=raw_input()
for _ in range(t):
    ss=raw_input()
    str1=str1.replace(ss, "")
if(len(str1)==0):
    print '0'
else:
    print str1

#!/usr/local/bin/python2.7
    
print "NOT YET!";
a = 'CcDdEFfGgABS' * 3;
T = int(input());
while T:
	T -= 1
	s = raw_input().split();
	pos1 = a.find(s[0])
	pos2 = a.find(s[1], pos1 + 1)
	print 'Major' if pos2 - pos1 == 4 else 'Minor'

import sys
def gcd(n,m):
    if n%m==0:
        return m
    return gcd(m,n%m)

def check(a,b,n):
    if n>a and n>b:
        return False
    if n%gcd(a,b)==0:
        return True
    return False

t=int(sys.stdin.readline())
while t!=0:
    a,b,n=map(int,sys.stdin.readline().split())
    if check(a,b,n):
        sys.stdout.write("YES\n")
    else:
        sys.stdout.write("NO\n")
    t-=1

#include <bits/stdc++.h>
#define MOD 1000000007
using namespace std;
 
pair<long long,long long> BB[2005];
long long ANS[2005],FF[200005],INVF[200005];
 
long long expoMod(long long b,long long K)
{
    if(K==0)
        return 1;
    long long ANS=expoMod(b,K/2);
    ANS=(ANS*ANS)%MOD;
    if(K%2==0) return ANS;
    else{
        ANS=(ANS*b)%MOD;
        return ANS;
    }
}
 
long long compute(long long a,long long b,long long c,long long d)
{
    long long x = c-a;
    long long y = d-b;
    long long res = FF[x+y];
    res = (res * INVF[x]) % MOD;
    res = (res * INVF[y]) % MOD;
    res = res % MOD;
    return res;
}
 
int main()
{
    //freopen("inp.in","r",stdin);
    long long t,M,N,K,x,y;
    
    FF[0] = 1;
    
    for(long long i = 1 ; i <= 200005 ; i++) FF[i] = (FF[i-1]*i) % MOD;

    INVF[200005] = expoMod(FF[200005],MOD-2);
    for(long long i = 200004; i >= 0 ; i--) INVF[i] = ( INVF[i+1]*(i+1) ) % MOD;
    int T;
    cin >> T;
    while(T--){
    cin >> M >> N >> K;

    for(int i = 0 ; i < K ; i++)
    {
        cin >> x >> y;
        BB[i]=make_pair(x,y);
    }

    BB[K]=make_pair(M,N);
    sort(BB,BB+K+1);
 
    for(int i=0;i<=K;i++) ANS[i]=compute(1,1,BB[i].first,BB[i].second);
    
    for(int i=0;i<K;i++)
    {
        for(int j=i+1;j<K+1;j++)
        {
            if((BB[j].first<BB[i].first) or (BB[j].second<BB[i].second))
                continue;
            ANS[j]=(ANS[j]-(ANS[i]*compute(BB[i].first,BB[i].second,BB[j].first,BB[j].second))%MOD+MOD)%MOD;
        }
    }

    if(ANS[K] < 0) ANS[K]+=MOD;
    cout << ANS[K] << "\n";
    }
    return 0;
} 
#include<bits/stdc++.h>
#define pb(a) push_back(a)
#define mp(a,b) make_pair(a,b)
#define pii pair<double,int>

using namespace std;

double dist[10001];
bool visited[10001];
int n;
double m[1001][1001];
vector <int> g[1001];
int s,t;

double dijkstra() {
	priority_queue <pii> pq;
	memset(visited,false,sizeof(visited));
	visited[s]=true;
	dist[s]=101.0;
	memset(dist,0.0,sizeof(dist));
	pq.push(mp(0.0,s));
	int i,j,u,v;
	pii w;
	while (!pq.empty()) {
		w=pq.top(); pq.pop();
		u=w.second;
		if (visited[u]==true && u!=s) continue;
		dist[u]=w.first;
		//printf("%d: %f\n",u,w.first);
	//	if (u==t) return w.first;
		visited[u]=true;
		for (i=0;i<g[u].size();i++) {
			v=g[u][i];
			if (visited[v]==false) {
				//printf("%d\n",v);
				if (u!=s) {
					pq.push(mp(min(dist[u],m[u][v]),v));
				}
				else {
					pq.push(mp(m[u][v],v));
				}
			}
		}
	}
	return dist[t];
}

int main() {
	int u,v,i,j,k,x,y;
	double d;
	int z;
	scanf("%d",&z);
	while (z--) {
		scanf("%d",&n);
		scanf("%d %d %lf",&u,&v,&d);
		s=1;
		t=1;
		while (u!=-1 && v!=-1) {
			s=min(s,u);
			s=min(s,v);
			t=max(t,u);
			t=max(t,v);
			g[u].pb(v);
			m[u][v]=m[v][u]=d;
			g[v].pb(u);
			scanf("%d %d %lf",&u,&v,&d);
		}
		printf("%0.7lf\n",dijkstra());
		for (i=0;i<=1000;i++) g[i].clear();
	}
	return 0;
}






t=int(raw_input())
for i in range(t):
    n=raw_input()
    q=raw_input()
    print n.count(q)
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
 
int IndexOf(char a[], char c)
{
    int i=0;
    for(i=0;i<strlen(a);i++)
    {
        if(a[i]==c)
        return i;
    }
    return -1;
}
 
int main()
{
    char row1[]="qwertyuiop";
    char row2[]="asdfghjkl";
    char row3[]="zxcvbnm";
    bool uppercase=false;
    char q[1000];
    cin.getline(q,1000);
    char ans[1000];
        {
            int i=0;
            for(i=0;i<strlen(q);i++)
            {
                uppercase=false;
                char c=q[i];
                if(c==' ' || c=='A' || c=='a' || c=='Q' || c=='q' || c=='Z' || c=='z')
                {
                    switch(c)
                        {
                                case 'A':c='L';break;
                                case 'a':c='l';break;
                                case 'Q':c='P';break;
                                case 'q':c='p';break;
                                case 'z':c='m';break;
                                case 'Z':c='M';break;
                        }
                        ans[i]=c;
                }
                else
                {
                    if(c-97 < 0)
                    {
                        c+=32;
                        uppercase=true;
                    }
                    int k1,k2,k3;
                    k1=IndexOf(row1,c);
                    k2=IndexOf(row2,c);
                    k3=IndexOf(row3,c);
                    
                    if(k1>0)
                    c=row1[--k1];
                    else if(k2>0)
                    c=row2[--k2];
                    else
                    c=row3[--k3];
                    if(uppercase==true)
                    c-=32;
                    ans[i]=c;
                }
            }
            ans[i]='\0';
            cout<<ans<<endl;
        }
    return 0;
}
#include<stdio.h>
int main()
{
int i,j,a[3][3],b[3][3],k=15,m,n;
for(m=0;m<3;m++)
for(n=0;n<3;n++)
{
a[m][n]=0;
}
m=1;
n=2;
a[m][n]=k;
for(i=0;i<3;i++)
{
	while(m==n&&m,n<2)
	{
	m++;
	n++;
	k++;
	a[m][n]=k;
	}
	if(m==2&&n==2)
	n--;
	if(m!=n&&n==2)
	{
	if(m==0)
	{
	k++;
	a[m][n]=k;
	n=n-2;
	m++;
	}
	else
	{
	k++;
	m++;
	n=n-2;
	a[m][n]=k;
	}
	}
	if(m!=n&&n==0)
	{
	if(m==1)
	{
	k++;
	a[m][n]=k;
	}
	else
	{
	m=m-2;
	n++;
	k++;
	a[m][n]=k;
	}
	}
	if(m!=n&&n==1)
	{
	if(a[m][n]==0)
	{
	k++;
	a[m][n]=k;
	m=m-2;
	n++;
	}
	else
	{
	n--;
	k++;
	a[m][n]=k;
	}
	}
}
b[0][1]=a[1][2];
b[1][0]=a[0][1];
b[2][0]=a[0][0];
b[1][1]=a[1][1];
b[0][2]=a[2][2];
b[1][2]=a[2][1];
b[0][0]=a[0][2];
b[2][1]=a[1][0];
b[2][2]=a[2][0];
for(m=0;m<3;m++)
{
for(n=0;n<3;n++)
printf(" ",a[m][n]);
printf("\n");
}
printf("\n");
for(m=0;m<3;m++)
{
for(n=0;n<3;n++)
printf(" ",b[m][n]);
printf("\n");
}
printf("\n");
b[2][1]=a[1][2];
b[1][2]=a[0][1];
b[0][2]=a[0][0];
b[1][1]=a[1][1];
b[2][0]=a[2][2];
b[1][0]=a[2][1];
b[2][2]=a[0][2];
b[0][1]=a[1][0];
b[0][0]=a[2][0];
for(m=0;m<3;m++)
{
for(n=0;n<3;n++)
printf(" ",b[m][n]);
printf("\n");
}
printf("\n");
b[1][0]=a[1][2];
b[2][1]=a[0][1];
b[2][2]=a[0][0];
b[1][1]=a[1][1];
b[0][0]=a[2][2];
b[0][1]=a[2][1];
b[2][0]=a[0][2];
b[1][2]=a[1][0];
b[0][2]=a[2][0];
for(m=0;m<3;m++)
{
for(n=0;n<3;n++)
printf(" ",b[m][n]);
printf("\n");
}
return 0;
}
#include<iostream>
#include<string.h>
using namespace std;
int main()
{
    char c[1000];
    cin.getline(c,1000);
    for(int i=0;i<strlen(c);i++)
    {
        char a=c[i]+1;
        if(c[i]=='z')
        cout<<"a";
        else
        cout<<a;
    }
    cout<<endl;
    return 0;
}
#include<stdio.h>
int main()
{
int n,x,y,cnt=0,len[100],i,j,k,l,m,capi[100],capj[100];
char a[100][100],b[100][100],c,d[100][100];
i=0;j=0;
while((c=getchar())!=EOF)
//while((c=getchar())!='#')
{
if(c=='\n')
{
a[i][j]='\0';
len[i]=j;
i++;j=0;
}
else
{
if(c>=65 && c<=90)
{
capi[cnt]=i;
capj[cnt]=j;
cnt++;
c=tolower(c);
}
a[i][j++]=c;

}
}
a[i][j]='\0';
len[i]=j;
for(k=0;k<=i;k++)
{
//for(l=0;l<len[k];l++)
m=0;
for(l=len[k]/2+1;l<len[k];l++)
b[k][m++]=a[k][l];

b[k][len[k]/2]=a[k][len[k]/2];

m=len[k]/2+1;
for(l=0;l<len[k]/2;l++)
b[k][m++]=a[k][l];
b[k][m]='\0';
}
/*for(x=i-1;x>=0;x--)
{
for(y=0;y<m;y++)
{
d[x][y]=b[z++][y];
}
d[x][y]='\0';
}
*/
for(n=cnt-1;n>=0;n--)
{
b[capi[n]][capj[n]]=toupper(b[capi[n]][capj[n]]);
}
for(j=i;j>=0;j--)
printf("%s\n",b[j]);


return 0;
}
#include<stdio.h>

void IsPalindrome(long long int p,int count)
{
    long long int temp=0,temp2=0;
    temp2 = p;

    while(temp2)
    {
        temp = temp2%10 + temp * 10;
        temp2 /= 10;
    }

    if(temp == p)
    {
        printf("\n%d %lld",count,temp);
        return;
    }
    else
        IsPalindrome(temp + p,count+1);
}

int main()
{
    int t=0;
    long long int p=0;

    scanf("%d",&t);
    while(t--)
    {
        scanf("%lld",&p);
        IsPalindrome(p,0);
    }
}

NonLeap_Months=[31,28,31,30,31,30,31,31,30,31,30,31]
Leap_Months=[31,29,31,30,31,30,31,31,30,31,30,31]

def is_leap(year):
	if(year%400==0):
	       return 1
	elif(year%100==0):
	       return 0
	elif(year%4==0):
	       return 1
	else:
	       return 0
T=raw_input().strip('\n')
T=int(T)
for _ in xrange(T):
	Date=raw_input().split('/')
	Year=int(Date[2])
	Month=int(Date[1])
	Day=int(Date[0])
	if(is_leap(Year)==1):
#		print "entered"
		temp=Month-1
		if(Month>=1 and Month<=12 and Day>=1 and Leap_Months[temp]>=Day):
			if(Leap_Months[temp]==Day):
				if(Month==12):
					x=1
					Month=1
					Year+=1
			 		print str(x)+'/'+str(Month)+'/'+str(Year)
				else:
				 	x=1
				 	Month+=1
			 		print str(x)+'/'+str(Month)+'/'+str(Year)

			else:
			 	x=Day+1
			 	print str(x)+'/'+str(Month)+'/'+str(Year)
		else:
		 	print "Invalid Date"
	else:
		temp=Month-1
		if(Month>=1 and Month<=12 and Day>=1 and NonLeap_Months[temp]>=Day):
			if(NonLeap_Months[temp]==Day):
				if(Month==12):
					x=1
					Month=1
					Year+=1
					print str(x)+'/'+str(Month)+'/'+str(Year)
				else:
					x=1
					Month+=1
					print str(x)+'/'+str(Month)+'/'+str(Year)

			else:
				x=Day+1
				print str(x)+'/'+str(Month)+'/'+str(Year)
		else:
			print "Invalid Date"

#include<bits/stdc++.h>

using namespace std;

int main()
{
	int t,n,m,i,j,a[1009][1009],dp[1009][1009];
	
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		
		for(i=0;i<n;i++)
		{
		
			for(j=0;j<m;j++)
			{
				cin>>a[i][j];
				dp[i][j]=INT_MAX;
			}
		}
		
		dp[0][0]=a[0][0];

		for(i=1;i<n;i++)
		{
			dp[i][0]=a[i][0]+dp[i-1][0];
		}

		for(j=1;j<m;j++)
		{
			dp[0][j]=a[0][j]+dp[0][j-1];
		}

		for(i=1;i<n;i++)
		{
			for(j=1;j<m;j++)
			{
				dp[i][j] = ( dp[i-1][j] < dp[i][j-1] ? ( dp[i-1][j] +a[i][j] ) : (dp[i][j-1]+a[i][j] )  );
			}
		}
		cout<<dp[n-1][m-1]<<endl;
	}
	return 0;
}

#include<bits/stdc++.h>
using namespace std;
long long adj[101][101],n,m,cost[101],shortest[101][101],minv[101];
bool visited[101];
struct edge
{
	long long u,v,weight,serial;
};
deque<edge> deq;
deque<long long>ans;
struct pa
{
	long long x,y;
};
class cmp
{
	public:
	bool operator()(pa a,pa b)
	{
		return a.y>b.y;
	}
}; 
pa va,node;
edge e;
bool nec(long p,long q,long wei)
{
    if(shortest[p][q]==wei)
	return 1;
	else
	return 0;
}
int main()
{
	priority_queue<pa,deque<pa>,cmp> pq;
	long long int s,a,b,w,t;
	cin>>t;
	while(t--)
	{
	cin>>n>>m;
	for(int i=1;i<=100;i++)
	{
		for(int j=1;j<=100;j++)
		adj[i][j]=1000000000;
	}
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>w;
		a++;
		b++;
		adj[a][b]=min(w,adj[a][b]);
		adj[b][a]=min(w,adj[b][a]);
		e.serial=i-1;
		e.u=a;
		e.v=b;
		e.weight=w;
		deq.push_back(e);
	}
	for(int s=1;s<=n;s++)
	{
	for(int i=1;i<=100;i++)	
	{
	cost[i]=100000000000000;
	visited[i]=0;
	minv[i]=cost[i];
	}
	va.x=s;
	va.y=0;
	cost[s]=0;
	minv[s]=0;
	pq.push(va);
	while(!pq.empty())
	{
	    node=pq.top();
	    pq.pop();
	    long long u=node.x;
	    long long v=node.y;
	    if(visited[u])
	    continue;
	    for(int i=1;i<=n;i++)
	    {
	    	if(adj[u][i]==-1)
	    	continue;
	    	if(!visited[i] && cost[u]+adj[u][i]<cost[i])
	    	{
	    		va.x=i;
	    		cost[i]=cost[u]+adj[u][i];
	    		va.y=cost[i];
	    		minv[i]=min(minv[i],cost[i]);
	    		pq.push(va);
			}
		}
		visited[u]=1;
	}
	for(int i=1;i<=n;i++)
	shortest[s][i]=shortest[i][s]=cost[i];
}
     for(int i=0;i<deq.size();i++)
     {
     	long long up=deq[i].u;
     	long long vp=deq[i].v;
     	long long wp=deq[i].weight;
     	if(!nec(up,vp,wp))
     	ans.push_back(deq[i].serial);
	 }
	 cout<<ans.size()<<endl;
	 for(int i=0;i<ans.size();i++)
	 cout<<ans[i]<<endl;
	 deq.clear();
	 ans.clear();
}
}
#include <bits/stdc++.h>
using namespace std;

#define F  first
#define S  second
#define MP make_pair
#define PB push_back

const int N = 1003;

int n, m, ans = INT_MAX;
char A[N][N];
bool visited[N][N];
int dist[N][N];

bool ok(int i, int j) {
    return !visited[i][j] and A[i][j] != '#';
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0);
    cin>>n>>m;
    int x, y;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            cin>>A[i][j];
            if(A[i][j] == 'S')
            {
                x = i, y = j;
            }
        }
    }
    queue < pair<int,int> > Q;
    Q.push(MP(x,y));
    visited[x][y] = 1;
    while(!Q.empty())
    {
        int i, j;
        pair <int,int> P = Q.front();
        Q.pop();
        if(A[P.F][P.S] == 'E') {
            cout<<dist[P.F][P.S]<<"\n";
            return 0;
        }
        if(P.F - 1 >= 1) {
            i = P.F - 1, j = P.S;
            if(ok(i, j)) {
                Q.push(MP(i, j));
                visited[i][j] = 1;
                dist[i][j] = 1 + dist[P.F][P.S];
            }
        }
        if(P.F + 1 <= n) {
            i = P.F + 1, j = P.S;
            if(ok(i, j)) {
                Q.push(MP(i, j));
                visited[i][j] = 1;
                dist[i][j] = 1 + dist[P.F][P.S];
            }
        }
        if(P.S - 1 >= 1) {
            i = P.F, j = P.S - 1;
            if(ok(i, j)) {
                Q.push(MP(i, j));
                visited[i][j] = 1;
                dist[i][j] = 1 + dist[P.F][P.S];
            }
        }
        if(P.S + 1 <= m) {
            i = P.F, j = P.S + 1;
            if(ok(i, j)) {
                Q.push(MP(i, j));
                visited[i][j] = 1;
                dist[i][j] = 1 + dist[P.F][P.S];
            }
        }
    }
    cout<<"-1\n";
    return 0;
}
#include <bits/stdc++.h>
using namespace std;

vector <int> primes = {2,3,5};

inline
bool is_prime(int n)
{
    if(n < 2) return 0;
    for(int i=0;primes[i]*primes[i]<=n;++i)
	if(n % primes[i] == 0)
	    return 0;
    return 1;
}

void generate_primes(int n)
{
    for(int i=7;i<=n;i+=2)
	if(is_prime(i))
	    primes.push_back(i);
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0);
    generate_primes(31623);
    int t;
    cin>>t;
    while(t--)
    {
        int n, ans;
        cin>>n;
        for(int i=0;primes[i]<=n and i<primes.size();++i)
        {
            if(n % primes[i] == 0)
            {
                ans = primes[i];
                while(n % primes[i] == 0)
                    n /= primes[i];
            }
        }
        if(n>1) ans = n;
        cout<<ans<<"\n";
    }
    return 0;
}
#include<iostream>
using namespace std;

long long count[1000000]={0};

main()
{
	int data;
	long long ans,n;
	
	cin>>n;
	ans = (n*(n-1)) /2;
	for(int i=0;i<n;i++)
	{
		cin>>data;
		count[data-1]++;
	}
	for(int i=0;i<1000000;i++)
	 ans -= (count[i]*(count[i]-1)) /2;
	 
	cout<<ans<<endl; 
}
#include<stdio.h>
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<sstream>
#include<set>
#include<map>
#include<stack>
#include<cmath>
#include <map>
#include<cstdlib>
#include<cstring>
#include<string>
#include<set>
#include<cassert>
using namespace std;
 
#define DEBUG //on-off switch for prlling statements
 
// Input macros
#define s(n)                        scanf("%d",&n)
#define sc(n)                       scanf("%c",&n)
#define sl(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)
#define ss(n)                       scanf("%s",n)
 
// Useful constants
#define INF                        1000000000
#define EPS                         1e-14
 
// Useful hardware instructions
#define bitcount                    __builtin_popcount
#define gcd                         __gcd
 
// Useful container manipulation / traversal macros
#define forall(i,a,b)               for(ll i=a;i<b;i++)
#define foreach(v, c)               for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v)
#define all(a)                      a.begin(), a.end()
#define in(a,b)                     ( (b).find(a) != (b).end())

#define fill(a,v)                    memset(a, v, sizeof a)
#define sz(a)                       ((ll)(a.size()))
 
// Some common useful functions
#define maX(a,b)                     ( (a) > (b) ? (a) : (b))
#define miN(a,b)                     ( (a) < (b) ? (a) : (b))
 
#define ll long long int
#define llu long long unsigned
#define ld long
#define mod 1000000007
#define F first
#define S second
#define pb push_back
#define llu long long unsigned
#define ld long
ll ans[402];
ll dp[402][402][402];
ll wt[402];
ll c[402][402];
ll powval[402][402];
ll power(ll x,ll y)
{
	if(y == 0)
	return 1;
	ll d=power(x,y/2);
	d=(d*d)%mod;
	if(y&1)
	{
		d=(x*d)%mod;
	}
	return d;
}
ll divmodulo(ll num,ll den)
{
	num=num%mod;
	den=power(den,mod-2);
	return (num*den)%mod;
}
ll mul(ll x,ll y)
{
	return ((x%mod)*(y%mod))%mod;
}
ll ncr(ll n,ll r)// calculatencr
{
	if(r == 0 || r==n)
	return n;
	ll num=1;
	ll den=1;
	for(int i=0;i<r;i++)
	{
		num=(num*((n-i)%mod))%mod;
		den=(den*(i+1))%mod;
	}
	return divmodulo(num,den);
	
}

void calc(int x,ll k)
{
	ll ans=0;
	ll y=wt[0];
	ll val=divmodulo(((power(y,k+1)-1)%mod+mod)%mod,y-1);
	for(int j=0;j<=min((ll)400,k);j++)
	{
	
		ll zero=k-j;
		ans=(ans+(val*dp[400][x][j]))%mod;

		val=divmodulo(((ncr(k+1,j+1)*power(y,k-j)-val)%mod+mod)%mod,y-1);
	}
	ans=((ans-dp[400][x][0])%mod+mod)%mod;
	printf("%lld\n",ans%mod);
}

void preprocess() 
{
	for(int i=0;i<=401;i++)
	{
		powval[i][0] = 1;
		for(int j=1;j<=401;j++)
		{
			powval[i][j] =( powval[i][j-1]*wt[i])%mod;
		}
	}
	fill(c,0);
	for(int i=0;i<=401;i++)
	{
		c[i][0]= 1;
		c[i][i]=1;
	}
	for(int i=1;i<=401;i++)
	{
		for(int j=1;j<i;j++)
		{
			c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod;
		
		}
	}
}
void solvedp()
{
	dp[0][0][0]=1;
	for(int i=0;i<=400;i++)
	{
		for(int j=0;j<=400;j++)
		{
			for(int k=0;k<=j;k++)
			{

				int next=i+1;
				dp[next][j][k] =(dp[next][j][k]+dp[i][j][k] )%mod;
				int val=j;
				for(int l=1;l+k<=400;l++)
				{
					val += next;
					if(val > 400) break;
					dp[next][val][k+l] = (dp[next][val][k+l]+((c[l+k][k]*powval[next][l])%mod)*dp[i][j][k])%mod;
		
				}
			}
		}
	}
}

int main()
{
	fill(wt,0);
int n;
	ll k;
	s(n);
	sl(k);
	for(int i=0;i<n;i++)
	{
		int x;
		s(x);
		wt[x]++;
	}
	preprocess();
	solvedp();
	assert(wt[0] != 1);
	int q;
	s(q);
	for(int i=0;i<q;i++)
	{
		int x;
		s(x);
		if(wt[0] == 0)
		{
			ll sum=0;
			for(int j=1;j<=min((ll)400,k);j++)
			{
				sum=(sum+dp[400][x][j])%mod;
			}
			printf("%lld\n",sum%mod);
			continue;
		}
		calc(x,k);
	}
}
#include <bits/stdc++.h>
using namespace std;
#define long int64_t
#define mp make_pair
#define mt make_tuple

const int module = 1000000007;

struct matrix
{
	static int n;
	int T[64][64];

	matrix () {fill(T[0], T[n], 0);}
	inline int* operator[] (int x) {return T[x];}

	static matrix mul (matrix x,matrix y)
	{
		matrix t;
		int i, j, k;

		for (i = 0; i < n; ++i)
		for (j = 0; j < n; ++j)
		for (k = 0; k < n; ++k)
			t[i][j] = (1LL * x[i][k] * y[k][j] + t[i][j]) % module;

		return t;
	}

	matrix power (long x)
	{
		if (x == 1) return *this;

		matrix *s = new matrix(power(x >> 1));
		*s = mul(*s, *s);
		if (x & 1) *s = mul(*s, *this);
		return *s;

		return *this;
	}
} G;

int C[32][32];
int matrix::n;
int n;

void enter ()
{
	long k;
	int m, x, y;
	scanf("%d%d%lld", &n, &m, &k);
	matrix::n = n << 1;

	while (m--)
	{
		scanf("%d%d", &x, &y);
		++G[x - 1][y - 1];
		++G[x - 1][y - 1 + n];
	}

	for (x = n; x < 2 * n; ++x) G[x][x] = 1;
	G = G.power(k);
}

void solve ()
{
	int q, x, y;

	for (x = 1; x <= n; ++x)
	{
		matrix t;
		t[0][x - 1] = 1;
		t = matrix::mul(t, G);

		for (y = 1; y <= n; ++y) C[x][y] = t[0][y - 1 + n];
	}

	scanf("%d", &q);
	while (q--)
	{
		scanf("%d%d", &x, &y);
		printf("%d\n", C[x][y]);
	}
}

int main ()
{
	#ifdef isMyPC
		freopen("test.inp", "r", stdin);
	#endif

	enter ();
	solve ();

	return 0;
}
N=int(input())
D=[0]*N
for i in range(N-1):
    a,b=map(int,raw_input().split())
    a-=1;b-=1;
    D[a]+=1
    D[b]+=1
ans=N*(N-1)*(N-2)
ans/=6
ans-=(N-1)*(N-2)
for i in D:
    if i>=2:
        ans+=(i*(i-1))/2
print ans

//satyaki3794
#include <bits/stdc++.h>
#include <iomanip>
#define ff first
#define ss second
#define pb push_back
#define MOD (1000000007LL)
#define LEFT(n) (2*(n))
#define RIGHT(n) (2*(n)+1)

using namespace std;
typedef long long ll;
typedef pair<int, int> ii;
typedef pair<int, ii> iii;

ll pwr(ll base, ll p, ll mod = MOD){
ll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;
}



char hash_ch(char ch){
	if(ch == 'A')	return 'A';
	if(ch == 'C')	return 'B';
	if(ch == 'T')	return 'C';
	return 'D';
}


struct palin_node{
    int next[26], len, sufflink, halflink;
};


int ticks, suff;
char str[100005];
palin_node tree[400050];
ll cnt[100005];


void init_palindrome_tree(){
    ticks = suff = 2;
    tree[1].len = -1;    tree[1].sufflink = 1;	tree[1].halflink = 1;
    tree[2].len = 0;    tree[2].sufflink = 1;	tree[2].halflink = 1;
}

int get_link(int curr, int pos){
    while(1){
        curr = tree[curr].sufflink;
        int currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos])  break;
    }
    return curr;
}

void add_letter(int pos){

    int currlen, curr = suff, curr2 = suff;
    int ch = str[pos]-'a';

    while(1){
        currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos])  break;
        curr = tree[curr].sufflink;
    }

    if(tree[curr].next[ch] != 0){
        //node already exists
        suff = tree[curr].next[ch];
        return;
    }

    //create new node, by appending ch to both ends of max suffix palindrome
    ticks++;
    suff = ticks;
    tree[ticks].len = tree[curr].len + 2;
    tree[curr].next[ch] = ticks;

    if(tree[ticks].len == 1){
        tree[ticks].sufflink = tree[ticks].halflink = 2;
        return;
    }

    //now find suffix link of the newly created node
    while(1){
        curr = tree[curr].sufflink;
        currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]){
            tree[ticks].sufflink = tree[curr].next[ch];
            break;
        }
    }

    curr = tree[curr2].halflink;
    while(1){
    	currlen = tree[curr].len;
        if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos] && (tree[tree[curr].next[ch]].len)*2<=tree[ticks].len){
            tree[ticks].halflink = tree[curr].next[ch];
            break;
        }
        curr = tree[curr].sufflink;
    }
}


void print_tree(){
	for(int i=1;i<=ticks;i++){
		cout<<i<<": len = "<<tree[i].len<<" link = "<<tree[i].sufflink<<" halflink = "<<tree[i].halflink;
		cout<<" and next =";
		for(int j=0;j<4;j++)	cout<<" "<<tree[i].next[j];cout<<endl;
	}
	cout<<endl;
}



int main()
{
    // ios_base::sync_with_stdio(0);

    scanf("%s", str);
// cout<<str<<endl;

	init_palindrome_tree();
	for(int i=0;str[i]!='\0';i++){
		add_letter(i);
		cnt[suff]++;
// cout<<"after inserting "<<i<<" suff = "<<suff<<endl;
	}

	// print_tree();

// for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl;


	for(int i=ticks;i>=3;i--)
		cnt[tree[i].sufflink] = (cnt[tree[i].sufflink] + cnt[i]) % MOD;
	cnt[1] = cnt[2] = 0;

// for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl;

	ll ans = 0;
	for(int i=3;i<=ticks;i++){
		ans += cnt[i] * cnt[tree[i].sufflink];
		ans %= MOD;
		cnt[i] += cnt[tree[i].sufflink];
		cnt[i] %= MOD;
	}

	printf("%lld", ans);
    return 0;
}








def main():
    for _ in xrange(input()):
        X = input()
        if X == 0:
            print 3

        else:
            if X == 1:
                print 1
            else:
                if X % 4 == 0:
                    print X
                elif (X - 3) % 4 == 0:
                    print X - 1
                else:
                    print -1

if __name__ == '__main__':
    main()

#!/usr/bin/python

# build parenthesis table
# populate table with initial values 1 -> 1, 2 -> 1, 3 -> 2, 4 -> 5
table = [1, 1, 1, 2, 5]
# compute the remaining values
for i in range(5, 1001):
	# initialize count to zero
	count = 0
	# for all values upto i
	for j in range(1, i/2 + 1):
		# compute number of ways to paren j, i - j elements
		count = count + 2 * (table[j] * table[i - j])
	# check if i is even
	if (i % 2) == 0:
		# subtract the extra i/2 * i/2
		count = count - (table[i/2] * table[i/2])
	# insert count in table
	table.append(count)
# read test cases
testcases = int(raw_input())
# for each test case
for i in range(0, testcases):
	# read the value of n
	n = int(raw_input())
	# print the corrosponding value from the table
	print table[n]%10000

#!/usr/bin/python
"Solve the Rescue problem at CodeChef"
def main():
 testcases = int(raw_input())
 for testcase in xrange(testcases):
  capacity, men, women, children = map(int, raw_input().split())
  max_women = min(women, (men << 1))
  max_children = min((men + max_women) << 2, int(capacity * 0.8))
  children_rescued = min(children, max_children)
  adults_rescued = min(men + max_women, capacity - children_rescued)
  women_rescued = min(max_women, int(adults_rescued * 0.66666667))
  men_rescued = adults_rescued - women_rescued
  print men_rescued, women_rescued, children_rescued
main()

import math
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    x=len(bin(n)[2:])-1
    print pow(2,x)
def fn(a):
    return a[0]
a={}
for _ in range(int(raw_input())):
    i=raw_input()
    if i not in a:
        a[i]=1
    else:
        a[i]+=1
b=a.items()
b.sort(key=fn)
for i in b:
    print i[0],i[1]

import math
t = input()
for _ in xrange(t):
    a, b, c, k = map(int, raw_input().split())
    if b * b >= 4 * a * (c - k):
        s = (b * b - 4 * a * (c - k)) ** 0.5
        root = (-b + s) / (2 * a)
        print int(math.ceil(root))
    else:
        print -1
 
a = input()
for b in range(a):
    c = raw_input().split()
    d = map(int,raw_input().split())
    d.sort()
    print
    d = d[:-int(c[1])]
    sum = 0
    for k in d:
        sum += k
    print sum
import time
arr=[0]*(100000+6)
sp=[2]*(100000+6)
sp[1]=1
sp[0]=0
def generateSP(n):
    for i in range(3,n+1,2):
        #print(i)
        #print(arr[i])
        if arr[i]==0:
            arr[i]=1
            #print("y"+str(i))
            sp[i]=i
            j=i
            while j*i<=n:
                if arr[j*i]==0:
                    arr[j*i]=1
                    sp[j*i]=i
                j+=2                
def phi(n):
    u=[]
    ans=n
    while n>1:
        if sp[n] not in u:
            u.append(sp[n])
            ans=ans-(ans/sp[n])
        n=n/sp[n]
    return ans

etd=[0]*100005
t=time.time()
generateSP(100005)
for i in range(1,100005):
    etd[i]=phi(i)
#print(time.time()-t)
#print(etd[:25])



mod=1000000007
f=[0,1,1,2]
for i in range(100003):
    f.append((f[-1]+f[-2])%mod)

t=int(raw_input())
while t>0:
    n=int(raw_input())
    n+=1
    r=0
    for i in range(1,int(pow(n,0.5))+1):
        if n%i==0:
            r=(r+(f[i]*etd[n/i]))%mod
            if i!=n/i:
                r=(r+(f[n/i]*etd[i]))%mod     
    r=(r-1)%mod
    print(r)
    t-=1

N , Q = (raw_input("").split())
N = int(N)
Q = int(Q)

a = raw_input().split(" ")
A = [int(n) for n in a]
	
min_value = min(A)
max_value = max(A)

for i in range(Q):
	t = int(raw_input(""))
	if min_value <= t <= max_value:
		print "Yes"
	else:
		print "No"
#include<bits/stdc++.h>
using namespace std;
int prime[100050];
int pr[100050];
void pre()
{
	int i,j;
	prime[0]=1;
	prime[1]=1;
	for(i=2;i<=100049;i++)
	{
		if(!prime[i])
		{
			for(j=2*i;j<=100049;j+=i)
			prime[j]=1;
		}
	}
	int cc;
	for(i=100048;i>=0;i--)
	{
		if(prime[i]==0)
		{
			pr[i]=i;
			cc=i;
		}
		else
		{
			pr[i]=cc;
		}
		//cout<< pr[i] << "  "
	}
}
int a[1005][1005];
int main()
{
	pre();
	int n,m;
	scanf("%d %d",&n,&m);
	int i,j;
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		scanf("%d",&a[i][j]);
	}
	long long int mini=1e15;
	for(i=0;i<n;i++)
	{
		long long int co=0;
		for(j=0;j<m;j++)
		{
			if(prime[a[i][j]]==1)
			{
			    //cout<<pr[a[i][j]]<<endl;
				co+=pr[a[i][j]]-a[i][j];
			}
		}
	//	printf("%d ",co);
		mini=min(mini,co);
	}
	//printf("\n");
	for(i=0;i<m;i++)
	{
		long long int co=0;
		for(j=0;j<n;j++)
		{
			if(prime[a[j][i]]==1)
			{
				co+=pr[a[j][i]]-a[j][i];
			}
		}
	//	printf("%d ",co);
		mini=min(mini,co);
	}
	//printf("\n");
	printf("%lld\n",mini);
	return 0;
}

def left(s):
	s = s[-1]+s[:-1]
	s = s.lstrip('0')
	return s

def right(s):
	s = s[1:]+s[0]
	s = s.lstrip('0')
	return s

num = int(raw_input())
while num:
	n = raw_input()
	maximum = max(int(left(right(n))),int(right(left(n))))

	tmp = n
	for j in range(len(n)):
		tmp = left(tmp)
		maximum = max(int(tmp),maximum)
	
	tmp = n
	for k in range(len(n)):
		tmp = right(tmp)
		maximum = max(int(tmp),maximum)
		
	print maximum

	num = num-1
			

#include<stdio.h>
 
main(){
 
int t,n,i;
scanf("%d",&t);
while(t--){
scanf("%d",&n);
char ch;
long long int v[n],result=1;
for(i=0;i<n;i++){
scanf("%lld",&v[i]);
}
i=0;
while(i<n-1){
scanf("%c",&ch);
switch(ch){
case 'a':
v[i+1]=v[i]+v[i+1];
v[i]=1;
i++;
break;
case 'm':
i++;
break;
}
}
for(i=0;i<n;i++)
result=(result*v[i])%1000000007;
printf("%lld\n",result);
}
}
    #include<stdio.h>
    #include<stdlib.h>
     
    int n,s,t;
    int save[10001];
    int close[10001];
    int store[10001][3];
    int test,l,ans[40];
     
    int rec(int node,int prev);
     
    int main(){
     
    //printf("Enter the value of test cases..\n");
    scanf("%d",&test);
     
    for(l=0;l<test;l++)
    {
    //printf("Enter the value of n..\n");
    scanf("%d",&n);
    //printf("Enter the value of s..\n");
    scanf("%d",&s);
    //printf("enter the no of saved sdges..\n");
    scanf("%d",&t);
     
    int i,j;
    for(i=1;i<=n;i++)
    {
    save[i]=0;
    //printf("Enter the no of closed edges..\n");
    scanf("%d",&close[i]);
    //printf("enter the edges' indices..\n");
    for(j=0;j<close[i];j++)
    scanf("%d",&store[i][j]);
    }
     
    int temp;
    for(i=0;i<t;i++)
    {
    //printf("Enter the indices of the edges to be saved..\n");
    scanf("%d",&temp);
    save[temp]=1;
    }
    if(save[s]==1)
    {
    ans[l]=1;
    continue;
    }
    if(close[s]==0||close[s]==1)
    {
    ans[l]=0;
    continue;
    }
    ans[l]=rec(s,0);
    // if(l!=test-1)
    //printf("\n");
    }
    for(l=0;l<test;l++)
    {
    if(ans[l]==0)
    printf("yes\n");
    else
    printf("no\n");
    }
    }
    int rec(int node,int prev)
    {
    int i,temp;
    int min=1000000;
    if(save[node]==1)
    {
    return 1;
    }
     
    if(node!=s&&(close[node]==1||close[node]==2))
    return 0;
     
    for(i=0;i<close[node];i++)
    {
    if(store[node][i]!=prev)
    {
    temp=rec(store[node][i],node);
    if(min>temp)
    min=temp;
    }
    }
    // printf("%d",min);
    if(min==1000000)
    exit(1);
    return min;
    } 
#include <iostream>
#include <vector>
using namespace std;

vector<long long int> v;

void init()
{
	long long int k; 
	for(int i = 1; i < 250000; i++)
	{

		v.push_back(k);
		k += i*i;
	}
}

int main()
{
	int t,val;
	cin >> t;
	init();
	for(int i = 0; i < t; i++)
	{
		cin >> val;
		cout << v[val] << endl;
	}
	return 0;
}
#include<stdio.h>
main()
{
    int test_cases,a1,a2,a3,a4,ways,k,run;
    scanf("%d",&test_cases);
    for(k=0;k<test_cases;k++)
    {
        scanf("%d",&run);
        ways=0;
        for(a1=run;a1>=0;a1-=6)
        {
            for(a2=a1;a2>=0;a2-=4)
            {
                for(a3=a2;a3>=0;a3-=2)
                {
                    ways++;
                }
            }
        }

        printf("%d\n",ways);
    }

return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define MOD 1000000007
#define LL unsigned long long

void MUL(LL F[2][2], LL M[2][2]);


void BP(LL F[2][2],LL n);

LL Solve(LL n)
{
  LL F[2][2] = {{1,1},{1,0}};
  if (n == 0)
      return 0;
  BP(F, n-1);
  return F[0][0];
}

void MUL(LL F[2][2], LL M[2][2])
{
  LL x =  F[0][0]*M[0][0] + F[0][1]*M[1][0];
  LL y =  F[0][0]*M[0][1] + F[0][1]*M[1][1];
  LL z =  F[1][0]*M[0][0] + F[1][1]*M[1][0];
  LL w =  F[1][0]*M[0][1] + F[1][1]*M[1][1];

  F[0][0] = x%MOD;
  F[0][1] = y%MOD;
  F[1][0] = z%MOD;
  F[1][1] = w%MOD;
}

void BP(LL F[2][2], LL n)
{
  if( n == 0 || n == 1)
      return;
  LL M[2][2] = {{1,1},{1,0}};
 
  BP(F, n/2);
  MUL(F, F);
 
  if (n%2 != 0)
     MUL(F, M);
}

int main()
{
    long T;
    LL N;
    scanf("%ld",&T);
    while(T--)
    {
        scanf("%llu",&N);
        printf("%llu\n",Solve(N));
    }
    return 0;
}

inp,ans,ph=set(raw_input()),['sad','happy'],set('iloveyou')
print ans[len(inp.intersection(ph)) == len(ph)]
from math import sqrt as S
print "\n".join(str(int(S(i))) for i in [input() for __ in range(input())])
#include <stdio.h>
#include <memory.h>
#include <vector>
using namespace std;
char b[41][41];
vector<int> con[1000];
int mx[1000];
bool vis[1000];
int x[41][41];
bool bpm(int v){
	for(int i=0; i<con[v].size(); i++){
		int j=con[v][i];
		if(vis[j]) continue;
		vis[j]=1;
		if(mx[j]==-1 || bpm(mx[j])){
			mx[j]=v;
			return 1;
		}
	}
	return 0;
}
int main(){
    //freopen("in.txt", "r", stdin);
    int T;
    scanf("%d", &T);
    int n, m, i, j;
    while(T--){
    	memset(b, 0, sizeof(b));
    	for(i=0; i<1000; i++) con[i].clear();
    	memset(x, -1, sizeof(x));
        scanf("%d %d", &n, &m);
        for(i=0; i<n; i++) scanf("%s", b[i]);
        int cl=0;
        for(i=0; i<n; i++){
            for(j=0; j<m; j++){
                if(b[i][j]=='.'){
					if(b[i][j+1]=='*') ++cl;
                }else{
                	x[i][j]=cl;
                }
            }
            ++cl;
        }
        int cm=0;
        for(i=0; i<m; i++){
            for(j=0; j<n; j++){
                if(b[j][i]=='.'){
                	if(b[j+1][i]=='*') ++cm;
                }else if(x[j][i]>=0){
                	con[cm].push_back(x[j][i]);
                }
            }
            ++cm;
        }
        memset(mx, -1, sizeof(mx));
        int res=0;
        for(i=0; i<cm; i++){
        	memset(vis, 0, sizeof(vis));
        	res+=bpm(i);
        }
        printf("%d\n", res);
    }
}
# cook your code here
t = int(input())
for i in range(t):
    n = int(input())
    if(n%2==0):
        print n
    else:
        print n-1

#include <stdio.h>
#include <iostream>

using namespace std;

int main()
{
	/*
	freopen("C:\\__Current\\SolutionsToPogContestProblems\\10055_HashmatTheBraveWarrior\\input.txt", "r", stdin);
	freopen("C:\\__Current\\SolutionsToPogContestProblems\\10055_HashmatTheBraveWarrior\\output.txt", "w", stdout);
	*/

	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);

	long long number1, number2;
	while (cin >> number1 >> number2)
	{
		//cerr << number1 << " " << number2;
		if (number1 == 0 && number2 == 0) { break; }

		int numberOfCarryOperations = 0;

		while (number1 > 0 && number2 > 0) {


			//1. extract rightmost digit of 1st number
			int rightmostDigitOfNumber1 = number1 % 10;
			// stop extracting if there are no more digits left
			if (number1 > 0) {
				number1 = number1 / 10;
			}

			//2. extract rightmost digit of 2nd number 
			int rightmostDigitOfNumber2 = number2 % 10;
			//stop extracting if there are no more digits left
			if (number2 > 0) {
				number2 = number2 / 10;
			}

			//3. add the extracted digits; and if no more digits left, display the result
			int sum = rightmostDigitOfNumber1 + rightmostDigitOfNumber2;
			if (sum > 9){
				numberOfCarryOperations++;
			}
		}

		switch (numberOfCarryOperations)
		{
		case 0:
			cout << "No carry operation.\n";
			break;
		case 1:
			cout << "1 carry operation.\n";
			break;
		default:
			cout << numberOfCarryOperations << " carry operations.\n";
			break;
		}
	}

	return 0;
}

#include<stdio.h>
int main()
{
printf("5\n13");
return 0;
}
#include <stdio.h>
#include <iostream>
 
int main ()
{
    char A[150][150], Input [150];
    long M, N, I, J, Case=0, Flag = 0;
    //freopen ("10189in", "r", stdin);
    //freopen ("10189out", "w", stdout);
 
    while (1){
 
        gets(Input);
        sscanf(Input,"%ld%ld",&M,&N);
 
        if (M==0 && N==0)
            break;
 
        long B[150][150] = {0};
 
        for (I=0; I<M; I++)
            gets (A[I]);
 
        for (I=0; I<M; I++ ) {
 
            for (J=0; J<N; J++){
 
                if (A[I][J]=='*'){
                    B[I][J+1]++;
                    B[I+1][J+1]++;
                    B[I+1][J]++;
                    B[I+1][J-1]++;
                    B[I][J-1]++;
                    B[I-1][J-1]++;
                    B[I-1][J]++;
                    B[I-1][J+1]++;
                }
            }
 
        }
 
        // output
        if (Flag==1)
            printf("\n");
        Flag = 1;
        printf("Field #%ld:\n", ++Case);
        for (I=0; I<M; I++){
            for (J=0; J<N; J++){
                if (A[I][J]=='*')
                    printf("%c", A[I][J]);
                else
                    printf("%ld", B[I][J]);
 
            }
            printf("\n");
        }
 
        //printf("\n");
    }
    return 0;
}
    #include<stdio.h>
     
    int main()
    {
    int testcases,i,arr[6][6],j,k,count,n=6;
     
    scanf("%d",&testcases);
    for(i=0;i<testcases;i++)
    {
    for(j=0;j<6;j++)
    {
    for(k=0;k<6;k++)
    scanf("%d",&arr[j][k]);
    }
    count=0;
    for(j=0;j<6;j++)
    {
    for(k=0;k<6;k++)
    {
    if(arr[j][k]==1)
    {
    if(((j-1)>=0 && (arr[j-1][k]==1)) || ((j+1)<n && (arr[j+1][k]==1)) || ((k+1)<n && arr[j][k+1]==1) || ((k-1)>=0 && arr[j][k-1]==1))
    count++;
    }
    }
    }
    if(count==6)
    printf("correct\n");
    else
    printf("incorrect\n");
    }
    return 0;
    } 
#include <bits/stdc++.h>
using namespace std;
int r , c;
char a[100][100];
string w;
char p;
int x[] = { -1, -1, -1, 0, 0, 1, 1, 1 };
int y[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
bool solve (int ro , int colo)
{
    int l = w.length();
    for (int dr = 0 ; dr < 8; ++dr)
    {
        int k , rd = ro + x[dr], cd = colo + y[dr];
       for (k = 1 ; k < l ; ++k)
    {
        if (rd >= r || cd >= c || rd < 0 || cd < 0) break;
        if (w[k] != a[rd][cd]) break;
        rd = rd + x[dr], cd  = cd +y[dr];
    }
     if ( k == l) return 1;
    }
    return 0;
}
void srch (string w)
{
    for (int i = 0 ; i < r ; ++i)
     for (int j = 0 ; j < c ; ++j)
        if (a[i][j] == w[0])
        {
         if (solve (i , j)) cout << ++i << " " << ++j << endl;
         break;
        }
}
int main (void)
{
    while (true)
    {
     cin >> r >> c;
     if (!r && !c) break;
        for (int i = 0 ; i < r ; ++i)
        for (int j = 0 ; j < c ; ++j)
        {
            cin >> p;
            a[i][j] = (tolower(p));
        }
    int tc;
    cin >> tc;
    for (int i = 0 ; i < tc ; ++i)
    {
     cin >> w;
    for (int j = 0 ; j < w.size() ; ++j)
    {
        w[j] = tolower(w[j]);
    }
    srch(w);
    }
}
}

// codechef practice(peer) Windows
#include<iostream>
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
using namespace std;
int main()
{
    int t;
    int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6;
    cin>>t;
    while(t--)
    {
              cin>>x1>>y1>>x2>>y2;
              cin>>x3>>y3>>x4>>y4;
              x5=max(x1,x3);
              y5=max(y1,y3);
              x6=min(x2,x4);
              y6=min(y2,y4);
              if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6;
              else cout<<"No Overlap";
              cout<<"\n";
    }
}

    
              
              
              
              
    

#author Apoorv kumar
#easy as hell
print "ABCD\nABCE\nABCFX\n"
print "ABCFX\nABCE\nABCD\n"

x,y=map(int,raw_input().split())
if(x == 0 and y==0):
    c=False
else:
    c=True

while(c):
    fib=[]
    p=0
    r=1
    while(1):

        n=p+r
        if(n<=y):
            fib.append(n)
        else:
            break
        p=r
        r=n
    fib.append(x)
    fib.append(y)
    fib.sort()
    ix=fib.index(x)
    iy=fib.index(y)

    fib=fib[ix:iy]
    lfib=len(fib)
    output=lfib-1
    print output

    x,y=map(int, raw_input().split())
    if(x==0 and y==0):
        c=False
    else:
        c=True
import math
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    for j in range(1,1001):
        n2=(str(n)[::-1])
        n2=int(n2)
        if n2==n:
            print j-1,n2
            break 
        else:
            n=n+n2
print "80 20 100 60"
print "No Overlap"

for _ in range(0,input()):
    a,ns,ew=raw_input(),['SOUTH','','NORTH'],['WEST','','EAST']
    print ns[int(round((a.count('N')-a.count('S'))/abs(a.count('N')-a.count('S')+.1)))+1]+ ew[int(round((a.count('E')-a.count('W'))/abs(a.count('E')-a.count('W')+.1)))+1]
t = int(raw_input())
for tt in range(t) :
    w = []
    n,m,k = [int(i) for i in raw_input().split()]
    for nn in range(n) :
        w.append([int(i) for i in raw_input().split()])
    p = w[n-1][0]
    j = n-2
    if m == 1 :
        j = n-2
        while j >= 0 :
            p += w[j][0]
            j = j-1
    else :
        r = 0
        while j>=0 :
            if r == 0 :
                if w[j][r] <= w[j][r+1] :
                    p += w[j][r]
                else :
                    p += w[j][r+1]
                    r = r + 1
            elif r == (m-1) :
                if w[j][r-1] <= w[j][r] :
                    p += w[j][r-1]
                    r = r - 1
                else :
                    p += w[j][r]
            else :
                x = min(w[j][r-1],w[j][r],w[j][r+1])
                p = p + x
                if w[j][r-1] == x :
                    r = r - 1
                elif w[j][r+1] == x :
                    r = r + 1
                     
            j -= 1 
    if p > k :
        print "No"
    else :
        print "Yes"
#include<stdio.h>
int main(){
		int n,i;
		scanf("%d",&n);
		int sum = 0;
		for(i=n;i>0;i--){
				sum = sum+i;
		}
		printf("%d",sum);
		return 0;
		
}

#include<stdio.h>
int main()
{
    int per, area;
    scanf("%d", &per);
    area = (per / 4)* (per / 4);
    printf("%d\n", area);
    return 0;
}

#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
big checkprime(big n)
{
    big i,count=0;
    FOR(i,2,n-1)
        if(n%i==0)
        {
            count=1;
            break;
        }
    if(count==1 || n==1)return 0;
    return 1;
}
int main() {
	big l,t,n,i,j,k,r,temp,m,x,y,z,a,b,c,sig,sum=0;
	vb v;
	big count=0;
	string s;
	cin>>i>>j>>k;
	cout<<i*3+k<<endl;
    
	return 0;
}
import java.util.*;
class business
{
public static void main(String args[])
{
Scanner sc=new Scanner(System.in);
int cp,rep,sp;
cp=sc.nextInt();
rep=sc.nextInt();
sp=sc.nextInt();
if(cp+rep<sp)
System.out.println("PROFIT");

else if(cp+rep>sp)
System.out.println("LOSS");



}

}
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
int main()
{
int i;
char x[100000],p;
scanf("%s",&x);
for(i=0;i<strlen(x);i++)
{
if(x[i]=='X')
cout<<"A";
else if(x[i]=='Y')
cout<<"B";
else if(x[i]=='Z')
cout<<"C";
else
{
p=x[i]+3;
cout<<p;
}
 
}
 
return 0; 
 
}  
#include<stdio.h>
main()
{
     int p,l;
     float b;
     int a;
     scanf("%d %d",&p,&l);
     b= (float)(p-2*l)/2;
     a=l*b;
     printf("%d\n",a);
 return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define LL      long long
#define LD      long double
#define PB		push_back
#define LOOP(i,n)  for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define mod		1000000007
int main()
{
	int n;
	cin>>n;
	int Sum=0;
	for(int i=1;i<n;i++)
		if(n%i==0)
			Sum+=i;
	cout<<Sum<<endl;
	return 0;
}

#include<iostream>
using namespace std;
int main()
{
    int x1,y1,x2,y2,x,y;
    cin>>x1>>y1>>x2>>y2>>x>>y;
    if((x1<=x&&x<=x2)||(x1>=x&&x>=x2))
       {
           if((y1<=y&&y<=y2)||(y1>=y&&y>=y2))
              {
                  cout<<"INSIDE";
                  return 0;
              }
       }
       cout<<"OUTSIDE";
       return 0;
}

t = int(raw_input())
for _ in xrange(t):
	n = int(raw_input())
	ans = 1
	for i in range(2,n):
		if n%i==0:
			ans+=i
	print ans

while True:
	[n, m] = [int(i) for i in raw_input().split()]
	if n == 0 and m == 0:
		break
	count = {}
	for nn in xrange(n):
		dna = raw_input()
		if dna not in count:
			count[dna] = 1
		else:
			count[dna] += 1
	x = [0] * n
	for c in count:
		x[count[c] - 1] += 1
	for i in x:
		print i
#-------------------------------------------------------------------------------
# Name:        Prison Break
# Purpose:     Practice
#
# Author:      pikku
#
# Created:     16/02/2013
#-------------------------------------------------------------------------------

def decode(msg,c):
    lst = []
    i = 0
    while(i < len(msg)):
        x = msg[i:i+c]
        lst.append(x)
        i += c

    i = 1
    while(i < len(lst)):
        lst[i] = lst[i][::-1]
        i +=2
    dec_msg = ""
    i = 0
    while(i < c):
        j = 0
        while(j <len(lst)):
            dec_msg += lst[j][i]
            j +=1
        i +=1

    return dec_msg

def main():
    t = int(raw_input())
    i = 0
    while(i < t):
        c = int(raw_input())
        msg = str(raw_input())
        print decode(msg,c)
        i += 1
    return 0

main()


#toioynnkpheleaigshareconhtomesnlewx
#ttyohhieneesiaabss



﻿# Using Recursive Method. Complexity will be 2^n
def fab(a,b,n):
    if n==1:
        return a
    if n==2:
        return b
    else:
        return fab(a,b,n-1)+fab(a,b,n-2)

t = input()
for i in xrange(t):
    a, b, n = map(int, raw_input().split())
    # Testing a naive approach. Surely complexity θ(n).
    if n==1: print a
    elif n==2: print b
    else:
        for i in xrange(2,n):
            c = a+b
            a = b
            b = c
        print c

# For Complexity log n use the Matrix Exponentiation Method.
# Better Reference at
# http://fusharblog.com/solving-linear-recurrence-for-programming-contest/

#include<iostream>
using namespace std; 
string arr[10][10]= {"0","0","0","0","0","0","0","0","0","0",
                "0","1","2","3","4","5","6","7","8","9",
                "0","2","4","6","8","10","12","14","16","18",
                "0","3","6","9","12","15","18","21","24","27",
                "0","4","8","12","16","20","24","28","32","36",
                "0","5","10","15","20","25","30","35","40","45",
                "0","6","12","18","24","30","36","42","48","54",
                "0","7","14","21","28","35","42","49","56","63",
                "0","8","16","24","32","40","48","56","64","72",
                "0","9","18","27","36","45","54","63","72","81"};
    
              
              
string add(string q,string w)
{   long long int l1,l2,carry,sum,l,diff,flag,i,pos;
    carry=0;
    string s="";
    l1=q.length();
    l2=w.length();
    if(l1>=l2)
    {         l=l1;
              flag=1;
              diff=l1-l2;
    }
    else
    {         l=l2;
              diff=l2-l1;
              flag=2;
    }
    if(flag==1)
    {          for(i=0;i<diff;i++)
               w=" "+w;
    }
    else
    if(flag==2)
    {          for(i=0;i<diff;i++)
               q=" "+q;
    }
    
    for(i=l-1;i>=0;i--)
    {                     sum=carry;
                          if(q[i]!=' ')
                          sum=sum+q[i]-48;
                          if(w[i]!=' ')
                          sum=sum+w[i]-48 ;  
                          carry=sum/10;
                          sum=sum%10;
                          s=(char)(sum+48)+s;
    }
    if(carry>0)
    s=(char)(carry+48)+s;
    pos=0;
    flag=0;
    l=s.length();
    if(l>1)
    {
    for(i=0;i<l;i++)
    {               if(s[i]!='0')
                    {pos=i;
                    flag=1;
                    break;}
    }
    for(i=0;i<l-pos;i++)
    s[i]=s[i+pos];
    
   s.resize(l-pos);
if(flag==0)
     s="0";
     }
    return s;   
}  

string subd(string q,string w)
{   long long int l1,l2,carry,sum,l,diff,flag,i,j,pos;
    carry=0;
    string s="";
    //cout<<"doin... dekh lo"<<q<<" "<<w<<endl;
    l1=q.length();
    l2=w.length();
    //cout<<l1<<" bty  "<<l2<<endl;
    if(l1>=l2)
    {         l=l1;
              flag=1;
              diff=l1-l2;
    }
    else
    {         l=l2;
              diff=l2-l1;
              flag=2;
    }
    ///cout<<"diff dekho toh"<<diff<<endl;
    if(flag==1)
    {          for(i=0;i<diff;i++)
               w=" "+w;
    }
    else
    if(flag==2)
    {          for(i=0;i<diff;i++)
               q=" "+q;
    }
   // cout<<"q="<<q<<endl;
    //cout<<"W="<<w<<endl;
    for(i=l-1;i>=0;i--)
    {                     if(q[i]>=w[i] && w[i]>34)
                          s=(char)(q[i]-w[i]+48)+s;
                          else
                          if(w[i]<34)
                          s=(char)(q[i])+s;
                          else
                          {
                              for(j=i-1;j>=0;j--)
                              {                  if(q[j]>w[j] && q[j]>48)
                                                 {            pos=j;
                                //                              cout<<"pos="<<pos;
                                                              break;
                                                 }
                              }
                              q[pos]--;
                              //cout<<"q="<<q<<endl;
                              for(j=pos+1;j<i;j++)
                              q[j]=q[j]+9;
                              //cout<<"q="<<q<<endl;
                              q[i]=q[i]+10;
                              //cout<<"q="<<q<<endl;
                              i++;
                          }           
    }
    pos=0;
    flag=0;
    l=s.length();
    if(l>1)
    {
    for(i=0;i<l;i++)
    {               if(s[i]!='0')
                    {pos=i;
                    flag=1;
                    break;}
    }
    for(i=0;i<l-pos;i++)
    s[i]=s[i+pos];
     s.resize(l-pos);
     if(flag==0)
     s="0";
}   //cout<<"returnin s"<<s<<endl;
    return s;   
}          
string mult(string a,string b)
{   long long int l1,l2,flag,diff,max,l,i,pos;
    string z1,z2,z0,s1,s2,ans;
    l1=a.length();
    //cout<<"a="<<a<<endl;
  // cout<<"b="<<b<<endl;
  /// cout<<"l1="<<l1<<endl;
    l2=b.length();
  // cout<<"l2="<<l2<<endl;
  // cin>>i;
    if(l1==1 && l2==1)
    {z2=arr[ a[0]-48 ][ b[0]-48 ];
    return z2;
    }
    
    else
    {
    if(l1>=l2)
    {         l=l1;
              flag=1;
              diff=l1-l2;
    }
    else
    {         l=l2;
              diff=l2-l1;
              flag=2;
    }
    if(flag==1)
    {          for(i=0;i<diff;i++)
               b='0'+b;
    }
    else
    if(flag==2)
    {          for(i=0;i<diff;i++)
               a='0'+a;
    }
    max=(l-1)/2;
  // cout<<"max="<<max<<endl;
    z2=mult(a.substr(0,max+1),b.substr(0,max+1) );
  // cout<<"z2="<<z2<<endl;
    z0=mult(a.substr(max+1),b.substr(max+1) );
  //  cout<<"z0="<<z0<<endl;
  /// cout<<"z2 change? ="<<z2<<endl;
  //  cout<<"s1=sudstr of"<<max+1;
    s1=add(a.substr(0,max+1),a.substr(max+1) );
  // cout<<"s1="<<s1<<endl;
    s2=add(b.substr(0,max+1),b.substr(max+1) );
  // /cout<<"s2="<<s2<<endl;
    z1=mult(s1,s2);
//   cout<<"z1 after multi s1 s2="<<z1<<endl;
  // cout<<"z1="<<z1<<endl;
  // cout<<"z2="<<z2<<endl;
    z1=subd(z1,z2);
   // cout<<"z1 - z2="<<z1<<endl;
   // cout<<"z0="<<z0<<endl;
    z1=subd(z1,z0);
  // cout<<"z1 - z0="<<z1<<endl;
  //  cout<<"max now"<<max<<endl;
    for(i=0;i<2*(l/2);i++)
    z2=z2+'0';
  // / cout<<"z2 after ading 0="<<z2<<endl;
    for(i=0;i<l/2;i++)
    z1=z1+'0';
   // cout<<"z1 after ading 0="<<z1<<endl;
    z2=add(z2,z1);
  // cout<<"z2 +z1="<<z2<<endl;
    z2=add(z2,z0);
  // cout<<"z2+ z0="<<z2<<endl;
    pos=0;
    l=z2.length();
    flag=0;
    if(l>1)
    {
    for(i=0;i<l;i++)
    {               if(z2[i]!='0')
                    {pos=i;flag=1;
                    break;}
    }
    if(pos>0)
    for(i=0;i<l-pos;i++)
    z2[i]=z2[i+pos];
     z2.resize(l-pos);
    if(flag==0)
    z2="0";
    }   
}   //cout<<"ans for"<<a<<"*"<<b<<endl<<z2<<endl;
    return z2;
}
    
    




int main()
{   
     
     long long int u,l,p,flag,sub;
     string a,b,c;
     cin>>u;
     while(u--)
     {         cin>>a>>b;
               sub=0;
               if(a[0]=='-' && b[0]!='-')
               sub=1;
               else
               if(a[0]!='-' && b[0]=='-')
               sub=1;
               if(a[0]=='-')
               a=a.substr(1);
               if(b[0]=='-')
               b=b.substr(1);
               c=mult(a,b);
               flag=0;
               l=c.length();
                if(sub==1)
                                             printf("-");
                    for(p=0;p<l;p++)
                          {                  if(c[p]=='0' && flag==0)
                                             continue; 
                                             else
                                             {flag=1;
                                            
                                             printf("%c",c[p]);
                                             }
                          }
                          if(flag==0)
                          cout<<"0";
                                             printf("\n"); 
     }
}

#include<bits/stdc++.h>

using namespace std;

#define ff first
#define ss second
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define sz(x) ((int)x.size())

const int MOD = 1e9+7;

typedef long long ll;
typedef pair<int,int> pii;
#define int long long
const int MAXN = 1e3+3;
int TL[MAXN][MAXN],BR[MAXN][MAXN];
int ar[MAXN][MAXN];
#undef int
int main() {
	//freopen("TASK.in","r",stdin);freopen("TASK.out","w",stdout);
	#define int long long
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%lld",&ar[i][j]);
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(i==1) TL[i][j]=TL[i][j-1]+ar[i][j];
			else if(j==1) TL[i][j]=TL[i-1][j]+ar[i][j];
			else TL[i][j]=max(TL[i-1][j],TL[i][j-1])+ar[i][j];
		}
	}
	for(int i=n;i>=1;i--) {
		for(int j=m;j>=1;j--) {
			if(i==n) BR[i][j]=BR[i][j+1]+ar[i][j];
			else if(j==m) BR[i][j]=BR[i+1][j]+ar[i][j];
			else BR[i][j]=max(BR[i+1][j],BR[i][j+1])+ar[i][j];
		}
	}
	int ans=TL[n][m];
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(j!=1) {
				int temp=0;
				if(i!=1) {
					temp=TL[i-1][j]+ar[i][j]-p+ar[i][j-1];
					ans=max(ans,temp+BR[i][j]-ar[i][j]);
					if(i!=n) ans=max(ans,temp+BR[i+1][j-1]);
				}
				temp=TL[i][j-1]+ar[i][j]-p;
				ans=max(ans,temp+BR[i][j]-ar[i][j]);
				if(i!=n) ans=max(ans,temp+BR[i+1][j-1]);
			}
			if(i!=1) {
				int temp=0;
				if(j!=1) {
					temp=TL[i][j-1]+ar[i][j]-p+ar[i-1][j];
					ans=max(ans,temp+BR[i][j]-ar[i][j]);
					if(j!=m) ans=max(ans,temp+BR[i-1][j+1]);
				}
				temp=TL[i-1][j]+ar[i][j]-p;
				ans=max(ans,temp+BR[i][j]-ar[i][j]);
				if(j!=m) ans=max(ans,temp+BR[i-1][j+1]);
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}

#include <bits/stdc++.h>
using namespace std;

#define INF 1000000007

typedef long long ll;
typedef unsigned long long ull;


typedef vector<vector<int> > vvi;
typedef pair<int,int> ii;
typedef vector<pair<int,int> > vii;
typedef vector<vector<pair<int,int> > > vvii;

#define all(x) (x).begin(), (x).end()
#define nall(x) (x).rbegin(), (x).rend()
#define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it)
#define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it)
#define ufy(v) sort(all(v));(v).erase(unique(all((v))),(v).end())
#define sz(a) int((a).size()) 
#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pb push_back 
#define PB pop_back
#define pf push_front
#define PF pop_front
#define MP make_pair
#define clr clear
#define rz resize
#define C(a,b) memset(a,b,sizeof(a))
#define ia(a,n) FOR(i,0,n-1)cin>>a[i]
#define ia1(a,n) FOR(i,1,n)cin>>a[i]
#define fpresent(c,x) ((c).find(x) != (c).end())  // set,map
#define present(c,x) (find(all(c),x) != (c).end())  //vector
#define F first
#define S second
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define NFOR(i,a,b) for(int i=a;i>=b;--i)
#define rep(i,n) FOR(i,0,n-1)
#define TCASE int __T;cin>>__T;FOR(Tc,1,__T)
inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;}
inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);}
inline int norm(int x,int m=INF){if(x>=m)x%=m;if(x<0)x+=m;return x;}
inline int neg(int x,int m=INF){x=-x;return norm(x);}

typedef vector<ll> VD;
typedef vector<VD> VVD;
typedef vector<int> VI;
VI LLL,RRR;
VVD Cost;
ll MinCostMatching(const VVD &cost, VI &Lmate, VI &Rmate) {
  int n = int(cost.size());

  // construct dual feasible solution
  VD u(n);
  VD v(n);
  for (int i = 0; i < n; i++) {
    u[i] = cost[i][0];
    for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]);
  }
  for (int j = 0; j < n; j++) {
    v[j] = cost[0][j] - u[0];
    for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
  }
  
  // construct primal solution satisfying complementary slackness
  Lmate = VI(n, -1);
  Rmate = VI(n, -1);
  int mated = 0;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      if (Rmate[j] != -1) continue;
      if ((cost[i][j] - u[i] - v[j]) ==0) {
	Lmate[i] = j;
	Rmate[j] = i;
	mated++;
	break;
      }
    }
  }
  
  VD dist(n);
  VI dad(n);
  VI seen(n);
  
  // repeat until primal solution is feasible
  while (mated < n) {
    
    // find an unmatched left node
    int s = 0;
    while (Lmate[s] != -1) s++;
    
    // initialize Dijkstra
    fill(dad.begin(), dad.end(), -1);
    fill(seen.begin(), seen.end(), 0);
    for (int k = 0; k < n; k++) 
      dist[k] = cost[s][k] - u[s] - v[k];
    
    int j = 0;
    while (true) {
      
      // find closest
      j = -1;
      for (int k = 0; k < n; k++) {
	if (seen[k]) continue;
	if (j == -1 || dist[k] < dist[j]) j = k;
      }
      seen[j] = 1;
      
      // termination condition
      if (Rmate[j] == -1) break;
      
      // relax neighbors
      const int i = Rmate[j];
      for (int k = 0; k < n; k++) {
	if (seen[k]) continue;
	const ll new_dist = dist[j] + cost[i][k] - u[i] - v[k];
	if (dist[k] > new_dist) {
	  dist[k] = new_dist;
	  dad[k] = j;
	}
      }
    }
    
    // update dual variables
    for (int k = 0; k < n; k++) {
      if (k == j || !seen[k]) continue;
      const int i = Rmate[k];
      v[k] += dist[k] - dist[j];
      u[i] -= dist[k] - dist[j];
    }
    u[s] += dist[j];
    
    // augment along path
    while (dad[j] >= 0) {
      const int d = dad[j];
      Rmate[j] = Rmate[d];
      Lmate[Rmate[j]] = j;
      j = d;
    }
    Rmate[j] = s;
    Lmate[s] = j;
    
    mated++;
  }
  
  ll value = 0;
  for (int i = 0; i < n; i++)
    value += cost[i][Lmate[i]];
  
  return value;
}


int X[301],Y[301],P[301],A[301];
int main()
{
    boost;
    TCASE
    {
    	int n,m;
    	cin>>n>>m;
    	FOR(i,0,n-1)cin>>X[i]>>Y[i]>>P[i];
    	multiset<int> s;
    	FOR(i,0,m-1){int x;cin>>x;s.insert(x);}
    	int _i=0;
    	ntr(s,it){A[_i++]=*it;if(_i==n)break;}
    	Cost.clear();
    	FOR(i,0,n-1)
    	{
    		Cost.pb(VD());
    		FOR(j,0,_i-1)
    		{
    			Cost[i].pb(min(X[i]+Y[i],A[j])*1LL*INF-P[i]*min(max(0,A[j]-X[i]),Y[i]));
    			Cost[i][j]=-Cost[i][j];
    		}
    		FOR(j,_i,n-1)
    		Cost[i].pb(0);
    	}
    	
    	ll x=-MinCostMatching(Cost,LLL,RRR);
    	if(x%INF==0)x-=INF;
    	cout<<(x+INF)/INF<<" "<<(INF-(x%INF))%INF<<"\n";
    }
	return 0;
}

#include<iostream>
#include<cstdio>
 
using namespace std;
 
int main(){
    int tcs;
    scanf("%d", &tcs);
    
    while(tcs--){
        int N, M;
        int student_list[101] = {0};
        int teacher_list[101] = {0};
 
        scanf("%d", &M);
        for(int i=0; i<M; i++)
            scanf("%d", &student_list[i]);
 
        scanf("%d", &N);
        for(int i=0; i<N; i++)
            scanf("%d", &teacher_list[i]);
 
        int DIST[N+1][M+1];
        for(int i=0; i<=M; i++)
            DIST[0][i] = i;
        for(int i=0; i<=N; i++)
            DIST[i][0] = i;
 
        for(int r=1; r<=N; r++){
          for(int c=1; c<=M; c++){
              if(student_list[c-1] == teacher_list[r-1]){
                 DIST[r][c] = DIST[r-1][c-1]; 
              } else {
                 int min_val = min(DIST[r-1][c], DIST[r][c-1]);
                 min_val = min(min_val, DIST[r-1][c-1]);
                 DIST[r][c] = min_val+1;
              }
          }
        }
        /*
        for(int r=0; r<=N; r++){
          for(int c=0; c<=M; c++)
              printf("%d", DIST[r][c]);
          cout << endl;
        }*/
        printf("%d\n", DIST[N][M]);
    }
    return 0;
} 
import java.io.*;
import java.math.*;
import java.lang.*;
import java.util.*;
public class Main{
public static void main(String args[])
{
Scanner sc=new Scanner(System.in);
int x=0,y=0;
BufferedReader br=new BufferedReader(new InputStreamReader(new DataInputStream(System.in)));
try{
x=sc.nextInt();
y=sc.nextInt();
}catch(Exception e){}
BigInteger X,Y,A,B,C;
while(y!=1)
{
X=new BigInteger(String.valueOf(x));
Y=new BigInteger(String.valueOf(y));
while(!(X.equals(new BigInteger("0"))))
{
if(Y.remainder(X).equals(new BigInteger("0")))
C=Y.divide(X);
else
C=Y.divide(X).add(new BigInteger("1"));
System.out.print(C.toString()+" ");
A=X.multiply(C).subtract(Y);
B=Y.multiply(C);
X=A;
Y=B;
}
System.out.println();
try{
x=sc.nextInt();
y=sc.nextInt();
}catch(Exception e){}
}
}
}
#include <bits/stdc++.h>

using namespace std;

const int N = 505;
int sz;

vector < int > adj[N];
int color[N];

void reset ()
{
	for (int i = 0; i < N; i++)
		adj[i].clear ();
}

bool dfs (int v, int col)
{
	sz++;
	color[v] = col;
	for (int i = 0; i < adj[v].size (); i++)
		if (color[adj[v][i]] == -1)
		{
			if (!dfs (adj[v][i], col ^ 1))
				return false;
		}
		else if (color[adj[v][i]] == col)
			return false;
	return (sz >= 2);
}

bool Check (int n)
{
	memset (color, -1, sizeof (color));
	int cnt = 0;
	bool bp = false;
	for (int i = 0; i < n; i++)
		if (color[i] == -1)
		{
			cnt++;
			sz = 0;
			bp |= dfs (i, 0);
		}
	return (bp & cnt >= 2);
}

int main ()
{
	int T, n, m, x, y;
	cin >> T;
	while (T--)
	{
		cin >> n >> m;
		reset ();
		for (int i = 0; i < m; i++)
		{
			cin >> x >> y;
			adj[x].push_back (y);
			adj[y].push_back (x);
		}
		if (Check (n))
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
	}
	return 0;
}
/*
author :  R Anirudh 
*/

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <cassert>
#include <climits>
#include <limits>
using namespace std;
#define SIZE(A) ((int)(A.size()))
#define MSET(A,x) memset(A,x,sizeof(A));
#define FILL(A,x) fill(A.begin(),A.end(),x)
#define REP(i,N) for(int i=0;i<(int)(N);i++)
#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ALL(x) x.begin(),x.end()
#define INF (INT_MAX/2)
#define LLINF (LONG_LONG_MAX/2LL)
#define EPS 1e-12
#define GI ({int t;scanf("%d",&t);t;})
#define GL ({long long t;scanf("%lld",&t);t;})
#define GF ({double t;scanf("%lf",&t);t;})
#define bitCount(n) __builtin_popcount(n)
#define MOD 10000009
#define MAXN 1000005
#define FIX(a) (((a)%MOD+MOD)%MOD)
typedef long long LL;
typedef unsigned long long ULL;
#define pb push_back

list<int> *adj;
bool *visited;
int *costs;
int component;
list<int> *paths;

void dfs_util(int);

void dfs(int n){
component=0;
FOR(i,0,n){
if(!visited[i]){
dfs_util(i);
component++;
}
}
}

void dfs_util(int v){

visited[v]=true;
paths[component].pb(v);
list<int>::iterator it;
for(it=adj[v].begin();it!=adj[v].end();it++){
 if(!visited[*it]){
  dfs_util(*it);
}
}
}


int main(){  
int t;
cin>>t;
while(t--){
int n;
LL m;
scanf("%d %lld",&n,&m);
adj = new list<int>[n];
visited = new bool[n];
costs = new int[n];
paths = new list<int>[n];
FOR(i,0,n){
visited[i]=false;
}
FOR(i,0,n){
scanf("%d",&costs[i]);
}
FOR(i,0,m){
int a,b;
scanf("%d %d",&a,&b);
a--;
b--;
adj[a].pb(b);
adj[b].pb(a);
}

dfs(n);
LL total=0;
list<int>::iterator it;
FOR(i,0,component){
int min=INT_MAX;
 for(it=paths[i].begin();it!=paths[i].end();it++){
if(costs[*it]<min){
  min=costs[*it];
}
}
total+=min;
}


printf("%lld\n",total);
}
return 0;
}

#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

using namespace std;
typedef long long int llint;
template <typename customDataType>
void fastread(customDataType * a)
{
    char c=0; *a=0;
    while(c<33){c=getchar_unlocked();}
    while(c>33){*a=(*a<<3)+(*a<<1)+c-'0'; c=getchar_unlocked();}
    return;
}//fastread ends


int main()
{
    int numberOfPlanes,minToWish,seconds,xtemp,ytemp,tupdate;
    int ppos_x[10000];
    int ppos_y[10000];
    int xchange[10000];
    int ychange[10000];
    float radius[10000];
    fastread(&numberOfPlanes);
    fastread(&minToWish);
    float rmin=0,rmin_in;

    for(int i=0;i<numberOfPlanes;++i)
    {
        fastread(&ppos_x[i]);
        fastread(&ppos_y[i]);
        fastread(&xchange[i]);
        xchange[i] -= ppos_x[i];    //Xf-Xi;
        fastread(&ychange[i]);
        ychange[i]-= ppos_y[i];    //Yf-Yi;
        radius[i] = sqrt(pow((llint)ppos_x[i],2)+pow((llint)ppos_y[i],2));
    }

    rmin=3000;
    for(seconds=0;seconds<=1000;++seconds)
    {
        rmin_in=0;
        for(int i=0;i<numberOfPlanes;++i)
        {
            xtemp = ppos_x[i] + xchange[i]*seconds;
            ytemp = ppos_y[i] + ychange[i]*seconds;
            radius[i] = sqrt(pow((llint)xtemp,2)+pow((llint)ytemp,2));
        }
        sort(radius,radius+numberOfPlanes);
        rmin_in=radius[minToWish-1];
        if(rmin > rmin_in)
        {
            rmin = rmin_in;
            tupdate=seconds;
        }
    }
    printf("%.2f\n%d\n",rmin,tupdate);
    return 0;
}

/*
  Name: Shed Problem
  Copyright: 
  Author: Shobhit Saxena
  Date: 17/12/12 21:37
  Description: Dynamic solution of the shed problem. This algo takes O(lb) to solve the matrix. Better than the naive algorithm tht takes O(l^2 b^2). 
*/



#include<stdio.h>

#define MAX 1000

#define GETCHAR getchar//_unlocked

#define min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c))

int matrix[1000][1000];
int main()
{
    int r,c;
    char temp;
    
    scanf("%d %d ",&r,&c);
    int max=0;
    
    for(int i=0;i<r;i++)
    {
            for(int j=0;j<c;j++)
            {
                    scanf(" %c",&temp);
                    if(temp=='T') matrix[i][j]=0;
                    else if(temp=='.')
                    {
                         if(!i||!j) matrix[i][j]=1;
                         else 
                         {
                              matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1]);         
                         }          
                    }
                    max=max>matrix[i][j]?max:matrix[i][j];                  
                   
            }
         
    }
    printf("%d\n",max?(max*max):-1);
    return 0;
}

import java.awt.Point;
import java.io.*;
import java.util.Arrays;

/*
 * Word Mess
 */
class EN03 {

	static char[][] map;
	static final int d[][] ={{0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1}};
	static Point fn;
	
	public static void main(String[] args)throws IOException {
		// TODO Auto-generated method stub
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder out = new StringBuilder();
		int n = Integer.parseInt(in.readLine());
		map = new char[n+2][n+2];
		for(char ch[] : map)
			Arrays.fill(ch, '#');
		for (int i=0;i<n;i++){
			String l = in.readLine();
			for (int j=0;j<n;j++){
				map[j+1][i+1] = l.charAt(j);
			}
		}
		String wrds = in.readLine();
		while (!wrds.startsWith("0")){
			boolean fnd = false;
			for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++){
			if (map[j][i] == wrds.charAt(0))
			for (int k=0;k<6;k++){
				if (dfs(new Point(j,i),wrds,k,0)){
					fnd = true;
					out.append(i+","+j+" "+fn.y+","+fn.x+"\n");
				}
			}
			}
			if (!fnd)
				out.append("Not found\n");
			wrds = in.readLine();
		}
		
		System.out.print(out);
	}

	static boolean dfs(Point st, String w,int dir,int in){
		//pln(st);
		fn = new Point(st);
		if (in == w.length()-1)
			return true;
		if (map[st.x+d[dir][0]][st.y+d[dir][1]] == w.charAt(in+1)){
			return dfs(new Point(st.x+d[dir][0],st.y+d[dir][1]),w,dir,in+1);
		}
		return false;
	}
	static void pln(Object o){
		System.out.println(o);
	}
}

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <algorithm>

#define N 200
#define K 20

int n, l[N], f[N], fm;
char b[N][K], *p[N];
#define MIN(a,b) ((a)<(b)?(a):(b))

int comp(const void *a, const void *b)
{
    int d = strlen(*(char**)b) - strlen(*(char**)a);
    if(d != 0) return d;
    return strcmp(*(char**)a, *(char**)b);
}

bool hopr(const char *a, const char *b)
{
char rep = 0;
bool seen = false;
for(int i = 0; a[i]; i++) {
if(b[i] == rep) seen = true;
if(a[i] != b[i]){
if(rep || a[i] > b[i]) return false;
rep = b[i];
}
}
return seen;
}

bool hopd(const char *a, const char *b)
{
int i;
for(i = 0; a[i] == b[i]; i++);
for(i++; a[i]; i++)
if(a[i] != b[i-1]) return false;
return true;
}

int main()
{
scanf("%d", &n);
for(int i = 0; i < n; i++) {
scanf("%s", b[i]);
p[i] = b[i];
}
qsort(p, n, sizeof(char*), comp);

for(int i = 0; i < n; i++)
l[i] = strlen(p[i]);
fm = 0;
for(int i = n-1; i >= 0; i--) {
f[i] = 1;
for(int j = i+1; j < n && l[i] - l[j] <= 1; j++) {
if(((l[i]==l[j] && hopr(p[i], p[j])) || (l[i]==l[j]+1 && hopd(p[i],p[j]))) && f[i] < f[j]+1)
f[i] = f[j]+1;
}
if(f[i] > fm) fm = f[i];
}
printf("%d\n", fm);
//system("pause");
return 0;
}

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;

public class Main {
	
	private static java.io.PrintWriter writer;
	private static ArrayList<String> dict;
	public static void main(String[] args) {
		java.io.BufferedReader reader =new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
		writer=new java.io.PrintWriter(new java.io.OutputStreamWriter(System.out),true);
		
		try {
			int limit=Integer.parseInt(reader.readLine());
			while(limit-->0){
				String str=reader.readLine();
				if(str.equalsIgnoreCase(""))
					str=reader.readLine();
				
				int dic_Len=Integer.parseInt(reader.readLine());
				populateDictonary(str,dic_Len,reader);
			}
		} catch (NumberFormatException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return;
		} catch (java.io.IOException e) {
			// TODO Auto-gene	rated catch block
			e.printStackTrace();
			return;
		}
	}

	private static void populateDictonary(String str,int dictionary,BufferedReader reader) {
		// TODO Auto-generated method stub	
		dict=new ArrayList<String>();
//		lenOfWords=new ArrayList<Integer>();
		for (int i = 0; i < dictionary; i++) {
			try {
				String inputDict=reader.readLine();
				dict.add(inputDict);
				
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return;
			}
		}
		
		int step=0;
		int pos=0;
		int totalCount=0;
		while(pos!=str.length()) {
		if(pos+step<=str.length()){
			String subString=str.substring(pos, pos+step);
			if(isPresent(subString)){
				totalCount++;
				pos=step+pos;
				step=0;
			}
			else{
				step++;
			}
			
			
		}
		else{
			pos++;
			step=0;
		}
			
		}
		writer.println(totalCount);
		writer.flush();
		
	}
	
	public static boolean isPresent(String subString){
		
		if(dict.contains(subString))
			return true;

		return false;
	}
}

#include <stdio.h>
#include <queue>
#include <stack>
#define MX_N 1010
#define A first
#define B second
#define mp make_pair

using namespace std;

typedef pair<int,int> pii;
typedef pair<int,pii> piii;
typedef pair<pii,pii> pfour;
typedef pair<int,pfour> pfive;
priority_queue<pfive> heap;
stack<pii> output;
piii opt[MX_N][MX_N];
char str[MX_N][MX_N];
int t,n,m;
int a,b,c,d;

int main() {
	int i,j;
	scanf("%d",&t);
	while(t--) {
		scanf("%d %d",&n,&m);
		scanf("%d %d %d %d",&a,&b,&c,&d);
		for(i=0;i<n;i++) {
			scanf("%s",str[i]);
			for(j=0;j<m;j++) {
				opt[i][j] = mp(-1,mp(-1,-1));
			}
		}
		heap.push(mp(0,mp(mp(a,b),mp(-1,-1))));
		while(!heap.empty()) {
			pfive top = heap.top();
			heap.pop();
			top.A = -top.A;
			int x = top.B.A.A,y = top.B.A.B;
			if(x < 0 || x >= n || y < 0 || y >= m) continue;
			if(top.A >= opt[x][y].A && opt[x][y].A > -1) continue;
			if(str[x][y] == '#') continue;
			opt[x][y] = mp(top.A,top.B.B);
			heap.push(mp(-top.A-1,mp(mp(x+1,y),mp(x,y))));
			heap.push(mp(-top.A-1,mp(mp(x-1,y),mp(x,y))));
			heap.push(mp(-top.A-1,mp(mp(x,y+1),mp(x,y))));
			heap.push(mp(-top.A-1,mp(mp(x,y-1),mp(x,y))));
		}
		if(opt[c][d].A == -1) {
			printf("-1\n");
			continue;
		}
		while(a != c || b != d) {
			output.push(mp(c,d));
			int x = c,y = d;
			c = opt[x][y].B.A;
			d = opt[x][y].B.B;
		}
		output.push(mp(a,b));
		while(!output.empty()) {
			pii top = output.top();
			output.pop();
			printf("%d %d\n",top.A,top.B);
		}
	}
	return 0;
}
from sys import stdin
a=stdin.readline()
for i in xrange(int(a)):
    n=int(stdin.readline())
    if n%2==0:
        print (n/2 + (n/2-1)*(n/2))
    else:
        print ((n/2)+1)*(n/2)

t = input()
for i in range(t):
    st = raw_input()
    l = len(st)
    tc,dc,ct=0,0,0
    while(ct<l):
        if(st[ct]=='T'):
            tc=tc+1
        else:
            tc=tc-1
        ct=ct+1
        if tc<0:
            break
    if tc==0:
        print "YES"
    else:
        print "NO"

#!/usr/bin/python

num = int(raw_input())
div = 8192
count = 0
while div > 0:
	if num >= div:
		count = count + 1
		num = num - div
	div = div / 2
print count

N,i=input(),1;
while i<=N:
	i*=2;
i/=2;	print 1+2*(N-i);

#include<bits/stdc++.h>
using namespace std;
#define mod 274877906944
int main()
{
    int t;
    cin>>t;
    while(t--)
    {


    long long int ans=0;
    long long int a,d,n,x;
    cin>>a>>d>>n>>x;
    for(int i=0;i<=n;i++)
    {
        ans=((ans*x)%mod+(a+i*d)%mod)%mod;
    }
    cout<<ans<<endl;
    }
    return 0;
}

for i in range(input()):
    d=input()
    if d%2==0:
        print d
    else:
        print d-1
import sys

lists = map(int,sys.stdin.readline().split())
ans = 9999999999999999L
for i in range(1,len(lists)) :
    ans = min(ans,abs(lists[i-1]-lists[i]))
print ans
x=raw_input()
l=len(x)
if l>=3:
    l=l/2
    print x[l-1:l+2]
else:
    print "0"

a = map(int, raw_input().split())

x = str(a[0])
y = str(a[1])

flag = 0

for i in x:
	for j in y:
		if i==j:
			flag = 1

if flag==1:
	print "TRUE"
else:
	print "FALSE"



x=raw_input()
l=len(x)
s=""
for i in range(0,l):
    if x[i]==x[l-i-1]:
        s=s+x[i]
    else:
        break
print s
    

N=int(raw_input())
T=int(raw_input())
m=map(int,raw_input().split())
t=map(int,raw_input().split())
dp = [[0]*(2) for i in range(T+1)]
for i in range(N):
	for x in xrange(T,t[i]-1,-1):
		dp[x][0]=max(dp[x][0],dp[x-t[i]][0]+m[i])
		dp[x][1]=max(dp[x][1],dp[x-t[i]][1]+m[i],dp[x-t[i]][0]+2*m[i])
print dp[T][1]

t=int(input())
while(t):
  t=t-1
  n=int(input())
  k=1
  ans=0
  while(n>0):
    if(n%3==0):
      ans=6*k+ans
      n=n/3-1
    elif(n%3==1):
    	ans=4*k+ans
    	n=(n-1)/3
    elif(n%3==2):
        ans=5*k+ans
        n=(n-2)/3
    k=k*10
  print ans
      
for __ in range(input()):
    m,x = input(),0
    arr = map(int, raw_input().split())
    for i in range(len(arr)-1):
        for j in range(i+1,len(arr)):
            if (arr[i]^arr[j]) %2!=0:
                x+=1
    print x
from math import factorial as gamer
for i in range(input()):
    print gamer(input())
t = input()
for x in range(t):
    f = 1
    k = int(raw_input())
    for j in range(1,k+1):
         f = f * j
    print f  
alice=list(raw_input())
bob=list(raw_input())
punish=[x for x in bob if x in alice]
print len(punish)
l=[int(i) for i in raw_input().split()];
n=l[0];
m=l[1];
l=[int(i) for i in raw_input().split()];
l.sort();
l=l[::-1];
print l[m-1];

import sys

for cases in xrange(int(sys.stdin.readline())):
	n = int(sys.stdin.readline())
	l = list(map(int, sys.stdin.readline().split()))
	l.sort()
	c = 0
	t = 0
	bullets = 6
	f = 0
	for i in l:
		if t < i:
			c += 1
			bullets -= 1
			if bullets == 0:	
				bullets = 6
				t += 1
			t += 1
		else:
			print "Killed",c
			f = 1
			break
	if f == 0:	print "Bhai Ho!"
import math
t=int(raw_input())
for x in range (t):
 a=input()
 print math.factorial(a)
# your code goes here
mod=1000000007
def power(A,B):
	res=1
	while B>0:
	    if B&1:
		    res=(res*A)%mod
	    A=(A*A)%mod
	    B=B>>1
	return res    
	

t=input()

while t:
	A,B=raw_input().split(" ")
	A=int(A)
	B=int(B)
	print(power(A,B))
	t-=1
for _ in range(input()):
	s=raw_input()
	a=[0]*26
	for i in s:
		if i>='a' and i<='z':
			a[ord(i)-97]+=1
	m1=max(a)
	i=a.index(m1)
	a[i]=0
	m2=max(a)
	j=a.index(m2)
	a[j]=0
	m3=max(a)
	k=a.index(m3)
	a[k]=0
	print 'ocul.in/'+str(chr(i+97))+str(m1)+str(chr(j+97))+str(m2)+str(chr(k+97))+str(m3)
		
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int m;
ll fib(int n)
{
    n--;
    ll x[2][2]={{1,0},{0,1}},y[2][2]={{1,1},{1,0}},a,b,c,d;
    while(n>0)
    {
        if(n%2==1)
        {
            a=((x[0][0]*y[0][0])%m+(x[0][1]*y[1][0])%m)%m;
            b=((x[0][0]*y[0][1])%m+(x[0][1]*y[1][1])%m)%m;
            c=((x[1][0]*y[0][0])%m+(x[1][1]*y[1][0])%m)%m;
            d=((x[1][0]*y[0][1])%m+(x[1][1]*y[1][1])%m)%m;
            x[0][0]=a,x[0][1]=b,x[1][0]=c,x[1][1]=d;
        }
        a=((y[0][0]*y[0][0])%m+(y[0][1]*y[1][0])%m)%m;
        b=((y[0][0]*y[0][1])%m+(y[0][1]*y[1][1])%m)%m;
        c=((y[1][0]*y[0][0])%m+(y[1][1]*y[1][0])%m)%m;
        d=((y[1][0]*y[0][1])%m+(y[1][1]*y[1][1])%m)%m;
        y[0][0]=a,y[0][1]=b,y[1][0]=c,y[1][1]=d;
        n/=2;
    }
    return x[0][0];
}
int main()
{
    int i,t,n;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        printf("%lld\n",(fib(n)*2)%m);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef vector<ii> vii;

#define MAXN 100010
#define MAXK 6
int n,k;
int nb;
int buttons[MAXN];
int coor[MAXK];
int perm[2*MAXK+2];
int count[2*MAXK+2];
char vist[2*MAXK+2];
bool flag;

bool back(int a){
  if(a == k) return true;
//   if(flag){
//     cout << a << ' ' << coor[a] << endl;
//     for(int j = 0; j < nb; ++j){
//       cout << count[j] << ' ';
//     }
//     cout << endl;
//   }
  for(int i = 0; i < nb; ++i){
    if(vist[i]) continue;
//     if(flag) cout << i << ' ' << count[i] << endl;
    vist[i] = true;
    perm[2*(a+1)] = i;
    int j = 0;
//     if(flag) cout << nb << endl;
    while(j < nb and (vist[j] or count[j] != count[i]-coor[a])){ ++j; }
    if(j < nb){
//       if(flag) cout << a << ' ' << i << ' ' << j << endl;
      vist[j] = true;
      perm[2*(a+1)+1] = j;
      if(back(a+1)) return true;
      vist[j] = false;
    }
    vist[i] = false;
  }
  return false;
}

bool ini(){
  for(int i = 0; i < nb; ++i){
    perm[0] = i;
    for(int j = 0; j < nb; ++j){
//       if(i == 1 and j == 2) flag = true;
//       else flag = false;
      if(i == j) continue;
      perm[1] = j;
      memset(count,0,sizeof(count));
      memset(vist,0,sizeof(vist));
      vist[i] = vist[j] = 1;
      bool st = false;
      for(int q = 0; q < n; ++q){
	if(st) ++count[buttons[q]];
	if(buttons[q] == i) st = true;
	else if(buttons[q] == j) st = false;
      }
      if(back(0)) return true;
    }
  }
  return false;
}

int main(){
  int t; cin >> t;
  for(int cass = 0; cass < t; ++cass){
    cin >> n >> k;
    for(int i = 0; i < n; ++i){ cin >> buttons[i]; --buttons[i]; }
    for(int i = 0; i < k; ++i) cin >> coor[i];
    nb = 2*k+2;
    if(ini()){
      for(int i = 0; i < nb; ++i){
	if(i) cout << ' ';
	cout << perm[i]+1;
      }
      cout << '\n';
    }
    else cout << "Stupid Fish\n";
  }
}
for _ in xrange(int(raw_input())):
    n=int(raw_input())
    if n&1:
        n=n/2
        print(n*(n+1))
    else:
        n=n/2
        print(n*n)

#include<stdio.h>
int main()
{ int n,m,a[1000],b[1000],c[1000],e=0,i,j,d[1000];
        scanf("%d",&n);
        if(n<=1000)
        for(j=0;j<n;j++)
        {       e=0;
                scanf("%d",&m);
                if(m<=1000)
                for(i=0;i<m;i++)
                {
                        scanf("%d %d %d",&a[i],&b[i],&c[i]);
                        if(a[i]>=-100000&&a[i]<=100000&&b[i]>=-100000&&b[i]<=100000&&c[i]>=-100000&&c[i]<=100000)
                        {

                        }else
                        return 0;
                }
                for(i=0;i<m;i++)
                {
                        e=e+a[i]+b[i]+c[i];
                }
                if(e==0)
                d[j]=1;
                else
                d[j]=0;
        }
        for(j=0;j<n;j++)
       {
               if(d[j]==1)
        printf("YES\n");
        else
         printf("NO\n");

}
return 0;}

n=input()
for i in range(n):
	m=input()
	if(m%17==0):
		print 'YES'
	else:
	 	print 'NO'

import math
import random
M=1000000007
n=int(raw_input())
ap=[int (x) for x in raw_input().split()]
q=int(raw_input())
if n<=10000 or (ap[1]%2==0 and ap[2]%2==1 and ap[3]%2==1 and ap[4]%2==1):
    ap=[0]+ap
    for i in range(q):
        l=[int (x) for x in raw_input().split()]
        if len(l)==2:
            r1=0
            r2=1
            r=l[1]
            i=1
            while i<=n:
                r2=(r2*ap[i])%M
                r1+=math.log10(ap[i])
                i+=r    
            r1=r1-int(r1)
            r1=10**r1
            while r1<1:
                r1*=10
            r1=int(r1+.0000000001)
            print r1,r2
        else:
            ap[l[1]]=l[2]
else:
    # 1 p f
    # 2 R
    M=1000000007
    def ebsmod(a,b):
        i=1
        res=1
        while i<=b:
            if b&i:
                res=(res*a)%M
            i*=2
            a=(a*a)%M
        return res
    ap=[1]+ap
    log_array=[math.log10(i) for i in ap]
    log_sum=[0]*(n+1)
    prod=[1]*(n+1)
    for i in range(2,n+1):
        prod[1]=(prod[1]*ap[i])%M
        log_sum[1]+=log_array[i]
    for i in range(2,n+1):
        j=i+1
        while j<=n:
            prod[i]=(prod[i]*ap[j])%M
            log_sum[i]+=log_array[j]
            j+=i
    a1=ap[1]
    log_a1=math.log10(a1)
    for i in range(q):
        l=[int (x) for x in raw_input().split()]
        if len(l)==2:
            R=l[1]
            first_digit=log_sum[R]+log_a1
            first_digit=first_digit-int(first_digit)
            first_digit=10**first_digit
            while first_digit<1:
                first_digit*=10
            first_digit=int(first_digit+.0000000001)
            product=(prod[R]*a1)%M
            print first_digit,product
        else:
            p=l[1]
            f=l[2]
            if p==1:
                a1=ap[1]=f
                log_a1=math.log10(f)
            else:
                new_log=math.log10(f)
                div=ebsmod(ap[p],M-2)
                upper_limit=int(math.sqrt(p-1))
                for i in range (1,upper_limit+1):
                    if (p-1)%i==0:
                        log_sum[i]=log_sum[i]+new_log-log_array[p]
                        prod[i]=(prod[i]*div)%M
                        prod[i]=(prod[i]*f)%M
                        if i*i!=(p-1):
                            log_sum[(p-1)/i]=log_sum[(p-1)/i]+new_log-log_array[p]
                            prod[(p-1)/i]=(prod[(p-1)/i]*div)%M
                            prod[(p-1)/i]=(prod[(p-1)/i]*f)%M
                log_array[p]=new_log
                ap[p]=f   
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<math.h>

using namespace std;

long long int fact(long long int num)
{
    long long int factorial=1;
    for(int a=1;a<=num;a++)
    factorial=factorial*a;
    return factorial;
}

int main()
{
    long long int ar[20];
    int n;
       cin>>n;
       for(int i=0;i<n;i++)
        ar[i]=fact(n) + pow(2,n) - n;
       cout<<ar[n-1]<<endl;
       return 0;
}

#include<bits/stdc++.h>
using namespace std;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar_unlocked();
    }
    return x;
}
inline void putint(int n){
        int N = n, rev, count = 0;
        rev = N;
        if (!N){
            putchar_unlocked('0');
            putchar_unlocked('\n');
            return ;
        }
        while (!(rev%10)){
            count++;
            rev/= 10;
        }
        rev = 0;
        while (N) { 
            rev = (rev<<3) + (rev<<1) + N % 10;
            N /= 10;
        } 
        while (rev != 0){
            putchar_unlocked(rev % 10 + '0');
            rev /= 10;
        }
        while (count--){
            putchar_unlocked('0');
        }
    putchar_unlocked('\n');
}
vector<int> v[100001];
bool visited[100001]={0};
vector<int> ans;
void bfs(int node){
    queue<int> q;
    q.push(node);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        visited[u]=1;
        int x=v[u].size();
        for(int i=0;i<x;i++){
            int child=v[u][i];
            if(!visited[child]){
                q.push(child);
                ans.push_back(child);
                visited[child]=1;
                if(child==node){
                    ans.clear();
                    return;
                }
            }
        }
    }
    
}
int main(){
    int t=scan();
    while(t--){
        for(int i=0;i<100001;i++){
            v[i].clear();
        }
        memset(visited,0,sizeof(visited));
        int n=scan(),m=scan();
        while(m--){
            int a=scan(),b=scan();
            v[a].push_back(b);
        }
        bool f=0;
        int an=0;
        for(int i=1;i<=n;i++){
            if(!visited[i]){
            memset(visited,0,sizeof(visited));
                ans.clear();
            bfs(i);
               // cout<<ans.size()<<" ";
                if(ans.size()>=n-1){
                    f=1;
                    an=i;
                   // if(i==2){
                    //printf("%d ",ans.size());
                    //} 
                    break;
                }
            }
        }
        if(f==0){
            putchar_unlocked('-');
            putchar_unlocked('1');
            putchar_unlocked('\n');
        }
        else{
            putint(an);
            
        }
        ans.clear();
    }
}
#include <algorithm>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <functional>
#include <numeric>
#include <utility>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cassert>
#include <climits>

using namespace std;

#define endl       '\n'
#define spc        printf(" ")
#define nln        printf("\n")                     ///printnewline
#define fast_IO    ios_base::sync_with_stdio(false);
#define Max(a,b,c) max(a,max(b,c))                  ///3 ta theke max
#define Min(a,b,c) min(a,min(b,c))                  ///3 ta theke min
#define sqr(x)     (x)*(x)

#define z(x)       fabs(x)<EPS
#define iqu(x,y)   z(fabs(x-y))

#define rep(i,a,b)  for(i=a;i<=b;i++)
#define rep0(i,n)   for(i=0;i<n;i++)
#define rep1(i,n)   for(i=1;i<=n;i++)               ///looping
#define rev(i,a,b)  for(i=a;i>=b;i--)
#define rev0(i,n)   for(i=n-1;i>=0;i--)
#define rev1(i,n)   for(i=n;i>=1;i--)
#define forstl(i,v) for(i=0;i<v.size();i++)
#define forit(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(p)      p.begin(),p.end()

#define SET(p)     memset(p,-1,sizeof(p))
#define CLR(p)     memset(p,0,sizeof(p))            ///memset
#define MEM(p,v)   memset(p,v,sizeof(p))

#define READ(f)    freopen(f, "r", stdin)           /// file
#define WRITE(f)   freopen(f, "w", stdout)

#define sz(c)      (int)c.size()
#define pb(x)      push_back(x)                     ///STL defines
#define mp(x,y)    make_pair(x,y)
#define xx         first
#define yy         second
#define _itr(v)    __typeof(v.begin())

#define LLI        long long int
#define i64        long long int
#define i64u       unsigned long long int
#define LLU        unsigned long long int
#define Double     long double
#define PI         acos(-1.0)                        ///PI er value

typedef vector<int>     vi;
typedef vector<i64>     vll;
typedef vector<string>  vs;
typedef pair<int, int>  pii;
typedef pair<i64, i64>  pll;

#define check(n, pos)  (bool)(n & (1LL<<(pos)))      ///CHECK
#define biton(n, pos)  (n | (1LL<<(pos)))            ///ON     }-bit opr.
#define bitoff(n, pos) (n & ~(1LL<<(pos)))           ///OFF

// reading and writing case
#define readcase  int cas,kase=0;CI(cas);while((cas--)&&(++kase))
#define printcase printf("Case %d:",kase)

//debugging infinite variable
bool deb_mode = 0;
#define debug(a...) if(deb_mode){cout<<"Line= "<<__LINE__<<" -> ";Dbug,a,#a;Dbug.printall();cout<<endl;}
class debugger {
    vector<string> vars;
public:
    template<typename T> debugger& operator , ( const T v ) { stringstream ss; ss << v, vars.push_back( ss.str() ); return *this; }
    void printall() { int j = 0, l = vars.size(); for( int i = 0; i < ( l - 1 ); i++ ) { if( i )cout << ", "; for( j; j < vars[l - 1].size(); j++ ) { if( vars[l - 1][j] == ',' ) {j++; break;} cout << vars[l - 1][j]; } cout << " = " << vars[i]; } vars.clear(); }
} Dbug;

///STL printing output stream overloading
template <typename T1, typename T2> inline ostream& operator << ( ostream& os, const pair<T1, T2>& p ) { return os << "(" << p.first << "," << p.second << ")"; }
template <typename T> inline ostream &operator << ( ostream & os, const vector<T>& v ) { bool first = true; os << "{"; for( unsigned int i = 0; i < v.size(); i++ ) { if( !first ) os << ","; os << v[i]; first = false; } return os << "}"; }
template <typename T> inline ostream &operator << (  ostream & os, const set<T>& v ) { bool first = true; os << "{"; for ( typename set<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii ) { if( !first ) os << ","; os << *ii; first = false; } return os << "}"; }
template <typename T1, typename T2> inline ostream &operator << ( ostream & os, const map<T1, T2>& v ) { bool first = true; os << "{"; for ( typename map<T1, T2>::const_iterator ii = v.begin(); ii != v.end(); ++ii ) { if( !first ) os << ","; os << *ii ; first = false; } return os << "}"; }

template <typename T> void getarray( T a[], int b, int e ) { for( int i = b; i < e + b; i++ ) cin >> a[i]; }
template <typename T> void printarray( T a[], int b, int e ) { for( int i = b; i < e - 1 + b; i++ ) cout << a[i] << " "; if( e - 1 + b >= 0 ) cout << a[e - 1 + b] << endl; }
template <typename T> void printV( vector<T> v ) { int sz = v.size(); if( sz ) cout << v[0]; for( int i = 1; i < sz; i++ ) cout << " " << v[i]; nln; }

template <typename T> T gcd( T a, T b ) { if( b == 0 ) return a; return gcd( b, a % b ); }
template <typename T> T BigMod ( T b, T p, T m ) { if ( p == 0 ) return 1; if ( p % 2 == 0 ) { T s = BigMod( b, p / 2, m ); return ( ( s % m ) * ( s % m ) ) % m; } return ( ( b % m ) * ( BigMod( b, p - 1, m ) % m ) ) % m; }
template <typename T> T ModInv ( T b, T m ) { return BigMod( b, m - 2, m ); }

template<class T> inline void read( T &x ) { bool Minus = 0; char c; for( c = getchar(); c <= 32; c = getchar() ) ; if( c == '-' ) Minus = 1, c = getchar(); for( x = 0; c > 32; c = getchar() ) x = x * 10 + c - '0'; if( Minus ) x = -x; }
char getc() { char c; for( c = getchar(); c <= 32; c = getchar() ); return c; }  ///input char with buffering
int CI( int &_x ) { return scanf( "%d", &_x ); }
int CI( int &_x, int &_y ) { return scanf( "%d %d", &_x, &_y ); }
int CI( int &_x, int &_y, int &_z ) { return scanf( "%d %d %d", &_x, &_y, &_z ); }
int CI( int &_a, int &_b, int &_c, int &_d ) { return scanf( "%d %d %d %d", &_a, &_b, &_c, &_d ); }

template <class T> string toString( T n ) { ostringstream oss; oss << n; return oss.str(); }
int toInt( string s ) { int r = 0; istringstream sin( s ); sin >> r; return r; }
i64 toLong( string s ) { i64 r = 0; istringstream sin( s ); sin >> r; return r; }
bool isVowel( char ch ) { ch = tolower( ch ); if( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' )return true; return false; }
bool isUpper( char c ) { return c >= 'A' && c <= 'Z'; }
bool isLower( char c ) { return c >= 'a' && c <= 'z'; }

int dr8[8] = { +1, -1, +0, +0, +1, -1, -1, +1};   ///8 direction move
int dc8[8] = { +0, +0, -1, +1, +1, +1, -1, -1};
int dr4[4] = { +0, +0, +1, -1};                   ///4 direction move
int dc4[4] = { -1, +1, +0, +0};                   ///or adjacent dir.
int kn8r[8] = { +1, +2, +2, +1, -1, -2, -2, -1};  ///knight moves
int kn8c[8] = { +2, +1, -1, -2, -2, -1, +1, +2};

const double EPS = 1e-9;                         ///constants
const int INF = ( 1 << 30 ) - 1;
const i64 LINF = ( 1ll << 62 ) - 1;
const int mod = ( int )1e9 + 7;
const int MAX = ( int )1e5;
///____________________________Main Coding Starts From Here________________________///




i64 F( i64 N, i64 C ) {
    if( N == 1 ) return 1;
    i64 T = 0;
    for( int i = 1; i < N; i++ ) if( N % i == 0 ) T = ( T + F( i, C ) );
    return T;
}


vector<i64> Factorize( i64 N ) {
    vector<i64> F;
    int cnt = 0;
    while( N % 2 == 0 ) { cnt++; N /= 2; }
    if( cnt ) F.pb( cnt );
    for( i64 i = 3; i * i <= N ; i++ ) {
        cnt = 0;
        while( N % i == 0 ) { cnt++; N /= i;}
        if( cnt ) F.pb( cnt );
    }
    if( N > 1 ) F.pb( 1 );
    sort( all( F ) );
    return F;
}

map< vector<i64>, int > DP;

i64 Solve( i64 N ) {
    if( N == 1 ) return 1LL;
    vector < i64 > F = Factorize( N );
    if( DP.find( F ) != DP.end() ) return DP[F];
    i64 ans = 1LL;
    for( i64 i = 2; i * i <= N; i++ ) {
        if( N % i == 0 ) {
            ans += Solve( i );
            if( i != N / i ) ans += Solve( N / i );
            ans %= mod;
        }
    }
    return DP[F] = ans;
}


int main() {
#ifndef ONLINE_JUDGE
//    READ("in.txt");
//    WRITE("out.txt");
    deb_mode = 1;
#endif
    if( deb_mode )
        srand( int( time( NULL ) ) );


    int i, j, k, l, n, m, q, a, b, c;

    readcase {
        i64 N, C;
        cin >> N >> C;
        //vector < i64 > F = Factorize( N );
        i64 T = Solve( N );
        cout << ( T * C ) % mod << "\n";
    }





    if( deb_mode )
        cerr << "EXECUTION TIME = " << ( 1.0 * clock() ) / CLOCKS_PER_SEC << " SECONDS\n";
    return 0;
}

#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mp make_pair
#define NL printf("\n")
#define mem(a,b) memset(a, b, sizeof(a))
#define ft first
#define sd second
using namespace std;
const ll mod = 1000000007;
typedef pair<int,int> pii;
ll power(ll a, ll b){
    if(b==0){
        return 1;
    }
    ll tmp=power(a, b/2);
    tmp=(tmp%mod) * (tmp%mod);
    if(b&1){
        tmp = a*(tmp%mod);
    }
    return tmp%mod;
}
int main(){
    //printf("Hello World..!\n");
    int t;
    cin>>t;
    while(t--){
        ll c, k;
        cin>>c>>k;
        ll x=1, y=0;
        while(x<=c){
            y++;
            x *= 2;
        }
        //ll x = (double)log2(c);
        ll ans = power(y-1 ,k);
        cout<<ans<<endl;
    }
    return 0;
}

t=input()

while(t>0):
    n=input()
    o=n-1
    print o
    t-=1
    

    

def key(a):
    return a[1]
for i in xrange(int(raw_input())):
    n=int(raw_input())
    l={}
    for j in xrange(n):
        a,b=raw_input().split()
        b=int(b)
        if a not in l:
            l[a]=b
        else:
            l[a]+=b
    l=l.items()
    l.sort(key=key)
    print l[-1][0],l[-1][1]
    

#include<bits/stdc++.h>
#include <math.h>
using namespace std;

#define MOD 1000000007
#define MAX 2010
#define ll long long
#define slld(t) scanf("%lld",&t)
#define sd(t) scanf("%d",&t)
#define sld(t) scanf("%ld",&t)
#define pd(t) printf("%d\n",t)
#define plld(t) printf("%lld\n",t)
#define pcc pair<char,char>
#define pp pair<int,int>
#define pll pair<ll,ll>
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define mp(a,b) make_pair(a,b)
#define F first
#define S second
#define pb(x) push_back(x)

int A[1000007];

bool f(int x)
{
	if(x==1) return false;
	int m = sqrt(x);
	if(m*m==x){
		return true;
	}
	return false;
}
int main()
{
	int t;
	sd(t);
	while(t--)
	{
		int n;
		sd(n);
		int count = 0;
		for( int i=1; i<=n; i++)
		{
			sd(A[i]);
			int k = __gcd(i,A[i]);
			if(f(k))
			{
				count++;
			}
		}
		sort(A+1,A+n+1);
		ll ans = 1;
		for( int i=n; i>n-count; i--)
		{
			ans = ans*A[i];
			ans%=MOD;
		}
		plld(ans);
	}
}
def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)

     
            


def main():
    t=input()
    for unused in range(0,t):
        [n,q]=map(int,raw_input().split())
        a=[0]
        
        a.extend(map(int,raw_input().split()))
        
        prefix=[0,a[1]];suffix=[0]*(n+1);suffix[n]=a[n];
        

        for i in range(2,n+1):
            prefix.append(gcd(prefix[i-1],a[i]))

        i=n-1
        while i>0:
            suffix[i]=gcd(suffix[i+1],a[i])
            i-=1
             
        
        for nouse in range(0,q):
            [l,r]=map(int,raw_input().split())
            if r==n:
                res=prefix[l-1]
            else:
                res=gcd(prefix[l-1],suffix[r+1])
            print res
                
            
    
main()
            

t=input()
for ti in range(t):
    hn=map(int,raw_input().split())
    h=hn[0]
    a=map(int,raw_input().split())
    b=sorted(a)
    boolean=True
    for i in range(len(b)):
        if (i!=0 and b[i]-b[i-1]>h) or (i==0 and b[i]>h):
            print "No"
            boolean=False
            break
    if boolean==True:
        print "Yes"
            
            

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main() {
	int tc;
	cin >> tc;
	string sn;
	while (tc--) {
		cin >> sn;
		if(next_permutation(sn.begin(),sn.end()))
			cout << sn << endl;
		else
			cout << "-1"<<endl;
	}
	return 0;
}
T=input()
while T:
    T-=1
    N=input()
    A=[int(x) for x in raw_input().split()]
    arr=[0]*4001
    count=0
    for i in range(0,len(A)):
        arr[A[i]+2000-i]+=1
        if count<arr[A[i]+2000-i]:
            count=arr[A[i]+2000-i]
    print N-count

mod = 10**9+7
t = input()
while t > 0:
    n = input()
    ans  = 0
    for i in range(1,n+1):
        res = int(n/i)
        ans += i*res
    print ans%mod
    t -= 1
from fractions import gcd
t=int(raw_input())
counter=0
for i in range(t):
    counter+=1
    a,b,c=map(int,raw_input().split())
    gcdans=gcd(a,b)
    if c%gcdans==0:
        print "Case "+str(counter)+": Yes"
    else:
        print "Case "+str(counter)+": No"
#include <bits/stdc++.h>
#define ll long long
#define mod 215372682525
using namespace std;
int main()
{
    int t;
    ll sum,a,d,n,x,i;
    cin>>t;
    while(t--)
    {
        cin>>a>>d>>n>>x;
        ll b[n+1];
        b[0]=1;
        for(i=1;i<=n;i++)
        {
            b[i] = (x*b[i-1])%mod;
        }
        sum=0;
        ll temp=0;
        for(i=0;i<=n;i++)
        {
            sum = (sum + a*b[n-i])%mod;
            temp = (temp + i*b[n-i])%mod;
        }
        sum = (sum + d*temp)%mod;
        printf("%lld\n",sum);
    }
    return 0;
}

from operator import itemgetter
n=int(raw_input())
dic={}
for i in range(n):
    s=raw_input()
    if s in dic:
        dic[s]+=1
    else:
        dic[s]=1
arr=[]
for i in dic:
    c=[]
    c.append(i)
    c.append(dic[i])
    arr.append(c)
arr=sorted(arr,key=itemgetter(0))
#print arr
for i in arr:
    print i[0],i[1] 
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
 
long long int fn(long long int a[], long long int b, long long int i){
    return (b*a[i+1]+b+a[i+1]);
}
 
int main() {
 
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
    long long int T, N, M, X, i, j, c_sort[1005], sorted[1005], k, l, count;
    scanf("%lld", &T);
    while(T--){
        scanf("%lld %lld", &N, &M);
        for(i=1;i<=N;i++){
            scanf("%lld", &sorted[i]);
//            c_sort[X]++;
        }
        /*
        j=1;
        for(i=0;i<1001;i++){
            while(c_sort[i]!=0){
                sorted[j]=i;
                j++;
                c_sort[i]--;
            }
        }
        */
        /*
        for(i=0;i<5;i++){
            printf("%lld\n", sorted[i]);
        }
        */
        if(N==1){
            printf("%lld\n", sorted[1]%M);
        }
        else{
            count=sorted[1]*sorted[2]+sorted[1]+sorted[2];
            for(k=2;k<N;k++){
                count=fn(sorted, count, k)%M;
//                printf("%lld\n", count);
            }
            printf("%lld\n", count%M);
        }
    }
    return 0;
}
from math import sqrt
 
 
def disp(A):
    j = 0
    for i in A:
        print j, i
        j += 1
    print 
 
def Asum(A):
    s = 0L
    for i in A:
        s += sum(i)
    return long(s)
 
def solve(N):
    N = sqrt(1 + 8*N) - 1
    N /= 2
    N = int(N)
#    print N
    A = [[0] * (i + 1) for i in xrange(N)]
    A[0][0] = 1
    for i in xrange(1, N):
        A[i][0] = A[i][i] = 1
        for j in xrange(1, i):
            A[i][j] = A[i-1][j-1] + A[i-1][j]
#    disp(A)
    removeoutermost(A, N)
    A = A[2:]
#    disp(A)
    prev = Asum(A)
    A = step2(A)
#    disp(A)
    step3(A)
#    disp(A)
    print prev - Asum(A)
    
 
def removeoutermost(A, N):
    for i in xrange(0, N):
        A[i] = A[i][1:-1]
 
def is_prime(N):
    if (N == 1):
        return False
    for i in xrange(2, N):
        if N % i == 0:
            return False
    return True
 
def step2(A):
    B = [x for x in A if is_prime(x[0])]
    return B
 
def step3(A):
    for i in xrange(len(A)):
        div = A[i][0]
        for j in xrange(len(A[i])):
            A[i][j] /= div
 
t = input()
for i in xrange(t):
    n = input()
    solve(n) 
t=int(raw_input())
 
while(t):
    t-=1
    m,n=map(int,raw_input().split(" "))
    if(m and n):
        print m/2+n/2+1
    else:
        print 0
    
shuffle_list=[0,0,1]
for i in xrange(3,21):
	shuffle_list.append((i-1)*(shuffle_list[-1]+shuffle_list[-2]))
for i in xrange(input()):
    print shuffle_list[input()]

#include<bits/stdc++.h>
using namespace std;
int hash[30];
void zero()
{
	for(int i=0;i<30;i++)
		hash[i]=0;
}
int main()
{
	//std::ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--)
	{
		zero();
		string a,b;
		cin>>a>>b;
		int count=0;
		for(int i=0;i<b.length();i++)			
			hash[b[i]-'a']++;
		int pos;
		for(int i=0;i<30;i++)		
			if(hash[i]>0)	
			{
				count = hash[i];
				pos=i;
				break;
			}
		for(int i=pos+1;i<30;i++)
		{
			if(hash[i]>0)
			{
				count=count^hash[i];
			}
		}
		if(count > 0)
			cout<<a<<endl;
		else
		{
			if(a=="Varun")
				cout<<"Tarun\n";
			else
				cout<<"Varun\n";
		}
	}
	return 0;
}

from __future__ import print_function
from fractions import Fraction
t = input();
while(t > 0):
	n, m = map(int, raw_input().split());
	if(n % 2 == 0):	en = on = n / 2;
	else:	en, on = n / 2, n / 2 + 1;
	if(m % 2 == 0):	em = om = m / 2;
	else:	em, om = m / 2, m / 2 + 1;
	den = n * m; num = en * om + on * em;
	if(num == 0):	print(num, "/", den, sep = "", end = "\n");
	else:
		print(Fraction(num, den), end = "\n");
	t -= 1;
import random
import math

for test_Case in range(int(raw_input())):
        potion = raw_input()
        count_potion = [0]*26
        for c in potion:
                count_potion[ord(c)-ord('a')]+=1
        count_ingr = [0]*26
        n = int(raw_input())
        for i in range(n):
                temp = raw_input()
                for c in temp:
                        count_ingr[ord(c)-ord('a')]+=1
        ans = "YES"
        for i in range(26):
                if (count_potion[i]>count_ingr[i]):
                        ans = "NO"
        print ans

import math
t = input();
while(t > 0):
	print math.factorial(input());
	t -= 1;
def main():
    t = input()
    for i in xrange(t):
        a,b = map(int, raw_input().split())
        p = pow(a,b)
        ans = 0
        print p,
        while p!=0:
            ans += p%10
            p = p/10
        print ans
main()

#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;scanf("%d",&t);
	int i,j;
	while(t--)
	{
		char s[100];
		cin>>s;
		int l = strlen(s);
		int cnt=0;
		for(i=0;i<l-1;i++)
		{
			if(s[i]=='h')
			{
				for(j=i+1;j<l;j++)
				{
					if(s[j]=='m')
						cnt++;
					else
						break;
				}
			}
		}
		cout<<cnt<<endl;
	}
	return 0;
} 
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;scanf("%d",&t);
	while(t--)
	{
		double x1,y1,x2,y2,r;
		cin>>x1>>y1>>x2>>y2;
		cin>>r;
		if(x1>x2)
		{
			swap(x1,x2);
			swap(y1,y2);
		}
		x1+=r;x2-=r;
		double dis = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
		dis=sqrt(dis);
		printf("%.6lf\n",dis);
	}
	return 0;
}

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
 * Created By : Mayank Garg 
 * CSE, MNNIT-ALLAHABAD 
 *_._._._._._._._._._._._._._._._._._._._.*/

#include<bits/stdc++.h>
using namespace std;

#define test() int t;scanf("%d",&t);for(int tno=1;tno<=t;tno++)

#define mp make_pair
#define pb push_back
#define fl(i,a,b) for(i=a;i<=b;i++)
#define rfl(i,b,a) for(i=b;i>=a;i--)
#define wl(n) while(n--)
#define X first
#define Y second
#define all(c) c.begin(),c.end() //eg sort(all(v));

#define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++)
#define present(container, element) (container.find(element) != container.end()) //for set,map,etc
#define cpresent(container, element) (find(all(container),element) != container.end()) //for vectors

typedef long long ll;
typedef double lf;
typedef vector<int> vi; 
typedef vector< vi > vvi; 
typedef pair<int,int> pii;
typedef pair<int,pair<int,int> > piii ;

#define sz(a) int((a).size())
#define clr(a) memset(a,0,sizeof(a))
#define ini(a) memset(a,-1,sizeof(a))


// Input Output
#define sc(n) scanf("%d",&n)
#define sc2(n,m) sc(n), sc(m)
#define scs(s) scanf("%s",s);
#define pd(n) printf("%d",n)
#define pd2(n,m) printf("%d %d",n,m)
#define scc(n) scanf("%c",&n)
#define infile() freopen("input.txt","r",stdin);
#define output() freopen("output.txt","w",stdout);

#define scl(n) scanf("%lld",&n)
#define scl2(n,m) scanf("%lld%lld",&n,&m)
#define pdl(n) printf("%lld",n)
#define pdl2(n,m) printf("%lld %lld",n,m)
#define newln printf("\n")
#define space printf(" ")

//Bitwise
#define chkbit(s, b)    (s & ((lli)1<<b))
#define setbit(s, b)    (s |= ((lli)1<<b))
#define clrbit(s, b)    (s &= ~(1<<b))

//cost
#define MOD 1000000007
#define MOD_INV 1000000006
#define MAX 100009
#define INF ((1LL<<62)-1)

//Error check
#define debug() printf("here\n")
#define PV(v)       	{ for(int i=0;i<v.size();i++) printf("%d ",v[i]);printf("\n"); }
#define PA(a,st,ed)     { for(int i=st;i<=ed;i++) printf("%d ",a[i]);printf("\n"); }  
#define chk(a) cerr << endl << #a << " : " << a << endl
#define chk2(a,b) cerr << endl << #a << " : " << a << "\t" << #b << " : " << b << endl

ll pw(ll base ,ll expo,ll c)
{
	if(expo == 0 )
	return  1 ; 
	ll f = pw(base , expo /2,c) ; 
	if(expo&1)
	return (((f*f)%c)*base)%c ; 
	return (f*f)%c;
}
//-----------------------------------------------------------------------------------------------

const int N = 30000009;
int ans[N];
int prime[N]={0};
int main()
{
	int i,j,k;
	prime[0]=prime[1]=0;
	for(i=2;i*i<N;i++)
	{
		if(prime[i]==0)
		{
			prime[i]=i;
			for(j=2*i;j<N;j+=i)
			{
				if(prime[j]==0)
					prime[j]=i;
			}
		}
	}
	for(;i<N;i++)
	{
		if(prime[i]==0)
			prime[i]=i;
	}
	ans[2]=1;
	ans[3]=1;
	ans[1]=0;
	for(i=4;i<N;i++)
	{
		ans[i]=ans[i/prime[i]]+1;
	}
	for(i=2;i<N;i++)
	{
		ans[i]+=ans[i-1];
	}
	test()
	{
		int n;
		sc(n);
		printf("%d\n",ans[n]);
	}
	return 0;
}
#include <bits/stdc++.h>
// Input macros
#define s(n)                        scanf("%d",&n)
#define sc(n)                       scanf("%c",&n)
#define sl(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)
#define ss(n)                       scanf("%s",n)
// Useful constants
#define INF                         (int)1e9
#define EPS                         1e-9
#define MOD   1000000007
// Useful container manipulation / traversal macros
#define forall(i,a,b)               for(int i=a;i<b;i++)
#define foreach(v, c)               for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v)
#define all(a)                      a.begin(), a.end()
#define in(a,b)                     ( (b).find(a) != (b).end())

// Some common useful functions
#define maX(a,b)                     ( (a) > (b) ? (a) : (b))
#define miN(a,b)                     ( (a) < (b) ? (a) : (b))
#define checkbit(n,b)                ( (n >> b) & 1)

//dataTypes
#define ll long long int
#define ld long double 
#define vi vector<int> 
#define vll vector<long long int>
//STLFunctions
#define pb(v,x) v.push_back(x)
#define maxElement(v) *max_element(v.begin(), v.end())
#define minElement(v) *min_element(v.begin(), v.end())

using namespace std;

int main() {
	int t;
	cin>>t;
	while(t--)
	{
	    string s;
	    ll i, j, ans=0, count=0;
	    cin>>s;
	    if(s.length()==1) count=1;
	    else
	    {
	    for(i=0; i<s.length(); i++)
	    {
	        if(i==0)
	        {
	            if(s[i]!=s[i+1]) count++;
	        }
	        else if(i==s.length()-1)
	        {
	            if(s[i]!=s[i-1]) count++;
	            
	        }
	        else
	        {
	            if(s[i]!=s[i+1] && s[i]!=s[i-1]) count++;
	        }
	        
	    }
	    }
	    ans=pow(2,count);
	    cout<<ans<<endl;
	}
	
	return 0;
}

/*--------------------------
|  Author- Advitiya Brijesh |
|  PIE @ MNNIT Allahabad    |
|  advitiyabrijesh@gmail.com|
|                           |
---------------------------*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<list<ll> > vli;
typedef vector<int> vi;
typedef vector<pair<ll,ll> > vpll;
typedef vector<pair<int,int> > vpii;
typedef pair<int ,int> pii;
#define F first
#define S second
#define pb push_back
#define mp make_pair
#define rep(i,n) for(int i=0;i<n;++i)
#define REP(i,a,b) for(int i=a;i<=b;++i)
#define PER(i,b) for(int i=b;i>=0;--i)
#define sd(n) scanf("%d",&n)
#define sld(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
#define ss(n) scanf("%s",n)
#define sc(n) scanf("%c",&n)
#define oll(n) printf("%lld\n",n);
#define mset(n,k) memset(n,k,sizeof(n))
#define MOD 1000000007
#define MAX 2000005
#define MAXN 1005
vector<int>v;
bool isprime[1000005]={true};
ll mulmod(ll a,ll b,ll c){

  ll x=0,y=a%c;

  while(b){

    if(b&1){

      x=(x+y)%c;

    }

    y=(y*2)%c;

    b/=2;

  }

  return x%c;
}
//modular expo
ll power(ll x, unsigned long long int  y, ll p)
{
    ll res = 1;
    x = x % p;
    while (y > 0)
    {
        if (y & 1)
            res=mulmod(res,x,p);

        y = y>>1;
        x=mulmod(x,x,p);
    }
    return res%p;
}
bool miller(long long p){
    if(p<2){
        return false;
    }
    if(p!=2 && p%2==0){
        return false;
    }
    long long s=p-1;
    while(s%2==0){
        s/=2;
    }
    for(int i=0;i<4;i++){
        long long a=rand()%(p-1)+1,temp=s;
        long long mod=power(a,temp,p);
        while(temp!=p-1 && mod!=1 && mod!=p-1){
            mod=mulmod(mod,mod,p);
            temp *= 2;
        }
        if(mod!=p-1 && temp%2==0){
            return false;
        }
    }
    return true;
}
void seive(){
    //v.pb(2);
    for(int i=2;i<=1000000;++i){
        if(isprime[i]){
            v.pb(i);
            for(int j=i*i;j<=1000000;j+=i){
                isprime[j]=false;
            }
        }
    }
}

/*bool miller(ll p,int iteration = 6)
{
    if(p<2)
        return 0;
    if(p!=2 && p%2==0)
        return 0;
    ll s=p-1;
    while(s%2==0){
        s/=2;
    }
    ll base[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    for(int i=0;i<iteration;i++) {
        ll a= base[i];
        if (a > p- 2)
            a = rand()%(p-1)+1;
        ll temp=s;
        ll mod=modpow(a,temp,p);
        while(temp!=p-1 && mod!=1 && mod!=p-1) {
            //mod=(mod*mod)%p;
            mod = mulmod (mod, mod, p);
            temp *= 2;
        }
        if(mod!=p-1 && temp%2==0)
            return 0;
    }
    return 1;
}*/

ll PollardRho(ll n)
{
    if(n%2==0) return 2ll;
    ll x=(ll) rand()%n;
    ll y=x;
    ll c=(ll) rand()%n;
    ll d;
    do{
        x= (mulmod (x, x, n) + c) % n;//(((x*x)%n)+c)%n;
        y=(mulmod (y, y, n) + c) % n;//(((y*y)%n)+c)%n;
        y=(mulmod (y, y, n) + c) % n;//(((y*y)%n)+c)%n;
        d=__gcd(abs(x-y),n);
    }while(d==1);
    return d;
}
int pfactor(ll n)   {
    if( n==1 ) return 0;
    if( miller(n))
    {
        return 1;
    }
    ll div=PollardRho(n);
    return pfactor(div) + pfactor(n/div);
}

int divi (ll n) {
    int ans = 0;
    if (n > 1) {
        ans += pfactor(n);

    }
    return ans;
}
int main(){
    seive();
    int t;
    sd(t);
    while(t--){
        ll n,k;
        sll(n),sll(k);
        ll pfn=divi(n),pfk=divi(k);
        ll ans=1LL<<pfk;
        ans++;
        ans=power(ans,pfn,MOD);
        printf("%lld\n",ans);
    }
return 0;}

#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
#define MOD 1000000007

ll dp[202][102][108][3];
ll arr[5]={0,1,2,4,6};

ll fun(ll reg,ll free,ll sum,ll dot)
{
	if(dot==3)
		return 0;
	if(sum>=100)
		return 1;
	if(reg<=0 || free<0)
		return 0;
	if(dp[reg][free][sum][dot]!=-1)
		return dp[reg][free][sum][dot];
	
	ll i=0,ans=0;
	for(i=0;i<5;i++)
	{
		if(i==0)
			ans=(ans+fun(reg-1,free,sum+arr[i],dot+1));
		else
			ans=(ans+fun(reg-1,free,sum+arr[i],0));
		
		if(free>0)
			ans=(ans+fun(reg,free-1,sum+arr[i],dot));
	}	
	
	return dp[reg][free][sum][dot]=ans%MOD;
	
}

int main()
{
	ll t,b,n;
	scanf("%lld",&t);
	memset(dp,-1,sizeof(dp));
	while(t--)
	{
		scanf("%lld%lld",&b,&n);
		printf("%lld\n",fun(b,n,0,0));
	}
	

 return 0;
}

using namespace std;
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <limits.h>
#include <vector>
#include <map>
#include <bitset>
#include <string>
#include <iterator>
#include <set>
#include <utility>
#include <queue>
#include <numeric>
#include <functional>
#include <ctype.h>
#include <stack>
#include <algorithm>
#include <cstdlib>
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define wl(n) while(n--)
#define ll long long
#define bitcnt(x) __builtin_popcount(x)
#define P(x) printf("%d\n",x)
#define PB push_back
#define MP make_pair
#define fl(i,n) for(i=0;i<n;i++)
#define fil(i,a,n) for(i=a;i<n;i++)
#define rev(i,a,n) for(i=n-1;i>=a;i--)
#define mem(a,i) memset(a,i,sizeof(a))
#define F first
#define S1 second
typedef pair<int,int> P;
vector<int> v1;
pair<int,int> p1;
#define MOD 1000000007
#define debug(x)  printf("####%d####\n",x);
#define nl printf("\n");
#define str string
int a[1234567];
string s,s1;
int dp[1001];
ll pow1(ll x,ll y)
{
    if(y==0)
    return 1;
    ll temp= pow1(x,y/2)%MOD;
    if(y%2==0)
    return (temp*temp)%MOD;
    else
    return (((temp*temp)%MOD)*x)%MOD;
}
// suffix array starts
   #define MAXN 200013
   #define LOGN 20
   int level[LOGN][MAXN],stp,cnt,rankarray[MAXN],sa[MAXN],lcp[MAXN];
   ll cntA[MAXN],cntB[MAXN],cntU[MAXN];
   struct node
   {
       int nr[2],p;    
   }L[MAXN];
   int findlcp(int x, int y,int n)
   {
      int ans =0 ; 
      for (int k = stp-1; k>=0 && x<n && y<n; k--)
      {
          if(level[k][x]==level[k][y])
          {
              int t = (int)pow1(2, k);
              ans+=t; 
              x += t, y +=t;
          }
      }
      return ans; 
   }
   bool cmp(struct node a,struct node b)
   {
       if(a.nr[0]!=b.nr[0])
           return a.nr[0]<b.nr[0];
       return a.nr[1]<b.nr[1];
   }
   void kasai(int n,string s)
   {
       int i,k=0;
       for (int i = 0; i < n; ++i,k?k--:0)
       {
           if(rankarray[i]==n-1)
           {
               k=0;
               continue;
           }
           int j=sa[rankarray[i]+1];
           while(i+k<n&&j+k<n&&s[i+k]==s[j+k])
               k++;
           lcp[rankarray[i]]=k;
       }
   }
   void build(int n,string s)
   {
       int i;
       fl(i,n)
       level[0][i]=s[i]-'a'; // ith length se start hone vaali string ki lexographical rankarrayition
       for(stp=1,cnt=1;cnt<n;stp++,cnt*=2)
       {
           fl(i,n)
           {
               L[i].nr[0]=level[stp-1][i];
               if(i+cnt<n)
                   L[i].nr[1]=level[stp-1][i+cnt];
               else
                   L[i].nr[1]=-1;// INT_MAX in case of smallest lexographical rotation;
               L[i].p=i;
           }
           sort(L,L+n,cmp);
           fl(i,n)
           {
               if(i>0&&L[i].nr[0]==L[i-1].nr[0]&&L[i].nr[1]==L[i-1].nr[1])
                   level[stp][L[i].p]=level[stp][L[i-1].p];
               else
                   level[stp][L[i].p]=i;
           }
       }
       fl(i,n)
       sa[level[stp-1][i]]=i;
       fl(i,n)
       rankarray[sa[i]]=i; // ith sequence kis rankarrayition se start ho raha h 
       kasai(n,s);
   }
   // end of suffix array
void computeDistinctSubstrings(int n,ll cnt[])
{
	cnt[1]++;
	cnt[n-sa[0]+1]--;
	int i;
	fil(i,1,n)
	{
		cnt[lcp[i-1]+1]++;
		cnt[n-sa[i]+1]--;
	}
	fil(i,1,n+1)
	cnt[i]+=cnt[i-1];
}
int main()
{
    //std::ios_base::sync_with_stdio(false);
    int t;
    int n,i,j,k,m,l;


    cin>>s;
    n=s.length();
    build(n,s);
    computeDistinctSubstrings(n,cntA);
    

    cin>>s1;
    m=s1.length();
    build(m,s1);
    computeDistinctSubstrings(m,cntB);
    

    s+="#"+s1;
    m=s.length();
    build(m,s);
    fil(i,1,m)
    {
    	if(sa[i]<n)
    	{
    		cntU[lcp[i-1]+1]++;
    		cntU[n-sa[i]+1]--;
    	}
    	else if(sa[i]>n)
    	{
    		cntU[lcp[i-1]+1]++;
    		cntU[m-sa[i]+1]--;
    	}
    }
    fil(i,1,m+1)
    cntU[i]+=cntU[i-1];

    int q;
    S(q);
    wl(q)
    {
    	S2(j,k);
    	if(j==1)
    		cout<<cntA[k]+cntB[k]-cntU[k]<<"\n";
    	else if(j==2)
    		cout<<cntU[k] - cntB[k]<<"\n";
    	else if(j==3)
    		cout<<cntU[k] - cntA[k]<<"\n";
    	else
    		cout<<2*cntU[k] - cntA[k] - cntB[k]<<"\n";
    }
    
    /*fil(i,1,m+1)
    cout<<cntA[i]<<" ";
    nl;

    fil(i,1,m+1)
    cout<<cntB[i]<<" ";
    nl;

    fil(i,1,m+1)
    cout<<cntU[i]<<" ";
    nl;
*/
    /*ll ans=0;
    fl(i,m+1)
    ans+=2*cntU[i]-cntA[i]-cntB[i];

    cout<<ans<<"\n";*/

    return 0;
}
/*
._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
	ABHINANDAN AGARWAL
	MNNIT ALLAHABAD
	CSE
._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
*/
//Principia mathematica.. 
#include<bits/stdc++.h>
using namespace std;
#define pc putchar_unlocked
#define gc getchar_unlocked
typedef long long ll;
typedef unsigned long long llu;
#define mp make_pair
#define pb push_back
#define sc(x) scanf("%d",&x)
#define sc2(x,y) scanf("%d%d",&x,&y)
#define scstr(x) scanf("%s",x)
#define pd(x) printf("%d",x)
#define pstr(x) printf("%s",x)
#define newl() printf("\n")
#define fl(i,n) for (i=0;i<n;i++)
#define fle(i,n) for (i=1;i<=n;i++)
#define fla(i,a,n) for (i=a;i<n;i++)
#define mem(a,i) memset(a,i,sizeof(a))
#define fi first
#define se second
typedef pair<int,int> pii;
typedef pair<int,pair<int,int> > piii ;
#define wl(n) while (n--)
#define MOD 1000000007
//-------------
int A[2000+10];
int B[2000+10];
int vis1[2000+10]={0};
int vis2[2000+10]={0};
int p,n;
pii pos[2000+10];
map<pii,int>M;
int fuck=1,is11=0,is12=0;
void DFS(int *arr,int *vis,int cur,vector<int>&s,int *is)
{
	//printf("DFS called:cur:%d\n",cur);
	if (!(1<=cur&&cur<=4*n-4))
	{
		exit(1);
	}
	if (arr[cur]==-1)
	{
		(*is)++;
	}
	if (arr[cur]!=-1)
		s.pb(arr[cur]);
	if (A[cur]!=B[cur])
		fuck=0;
	vis[cur]=1;
	pii x=pos[cur];
	int i,j;
	for (i=n-1;i>=-(n-1);i-=(n-1))
	{
		if (i==0)continue;
		for (j=1;j>=-1;j--)
		{

			if (j==0)continue;
			//printf("i:%d and j:%d\n",i,j);
			//printf("i:%d and j:%d\n",i,j);
			if (1<=x.fi-i&&x.fi-i<=n&&1<=x.se-j&&x.se-j<=n)
			{
				int pp=M[mp(x.fi-i,x.se-j)];
				if (vis[pp]==0)
				{	DFS(arr,vis,pp,s,is);
					//printf("calling %d,%d from %d,%d\n",pos[pp].fi,pos[pp].se,x.fi,x.se);
				}
			}
			if (1<=x.fi-j&&x.fi-j<=n&&1<=x.se-i&&x.se-i<=n)
			{
				int pp=M[mp(x.fi-j,x.se-i)];
				if (vis[pp]==0)
				{	DFS(arr,vis,pp,s,is);
					//printf("calling %d,%d from %d,%d\n",pos[pp].fi,pos[pp].se,x.fi,x.se);
				}
			}
		}
	}
}

int doit(vector<int>&v1,vector<int>&v2)
{
	int z=v1.size(),i,j;
	for (i=0;i<z;i++)
	{
		if (v1[0]==v2[i])
		{
			break;
		}
	}
	if (i==z)return 0;
	for (j=0;j<z;j++)
	{
		if (v1[j]!=v2[(j+i)%z])
			return 0;
	}
	return 1;
}

int main()
{
	int t;
	sc(t);
	wl(t)
	{
		int i,j;
		p=1;
		sc(n);
		M.clear();
		for(i=1;i<=4*n-4;i++)
		{
			sc(A[i]);

		}

		for (i=1;i<=4*n-4;i++)
		{
			sc(B[i]);
		}
		for (i=0;i<=2000;i++)
		{
			vis1[i]=0;
			vis2[i]=0;
		}
		for (i=1;i<=n;i++)
		{
			pos[p]=mp(1,i);
			M[mp(1,i)]=p++;
		}
		for (i=2;i<=n;i++)
		{
			//pos[p++]=
			pos[p]=mp(i,n);
			M[mp(i,n)]=p++;
		}
		for (i=n-1;i>=1;i--)
		{
			pos[p]=mp(n,i);
			M[mp(n,i)]=p++;
		}
		for (i=n-1;i>=2;i--)
		{
			pos[p]=mp(i,1);
			M[mp(i,1)]=p++;
		}
		/*for (i=1;i<p;i++)
		{
			printf("for index:%d (%d,%d)\n",i,pos[i].fi,pos[i].se);
		}*/
		int ftot=1;
		int comps=0;
		for(i=1;i<=4*n-4;i++)
		{
			if (vis1[i]!=vis2[i])
			{
				//printf("Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!\n");
			}
			if (vis1[i]==0)
			{
				comps++;
				fuck=1;
				is11=0;is12=0;
				//printf("Yo.. new DFS called for node :%d\n",i);
				vector<int>s1,s2;
				//printf("before tha call\n");
				DFS(A,vis1,i,s1,&is11);
				//printf("before the call\n");
				DFS(B,vis2,i,s2,&is12);
				//multiset<int>::iterator it1,it2;
				vector<int>::iterator it1,it2;
				//-----------------------------------------	
				/*it1=s1.begin();it2=s2.begin();
				printf("Compnent %d first set::",comps);
				while(it1!=s1.end())
				{
					printf("%d || ",*it1);it1++;
				}
				printf("Second set:: ");
				while (it2!=s2.end())
				{
					printf("%d || ",*it2);it2++;
				}*/
				//-----------------------------------------

				it1=s1.begin();
				it2=s2.begin();
				int f=1;
				//printf("i:%d size of set:%ld set2:%ld\n",i,s1.size(),s2.size());
				if (s1.size()!=s2.size())
					f=0;
				if (f&&is11>0)
				{
					f=doit(s1,s2);
				}

				/*if (f)
				{
					if(fuck==0)
					{
						if ((*s1.begin())!=-1)
						{
							f=0;
							//break;
						}
					}
				}*/
				if (!f)
				{
					ftot=0;
					break;
				}
			}
		}
		//printf("components:%d \n",comps);
		if (ftot)
		{
			printf("YES\n");
		}
		else
			printf("NO\n");

	}		

	return 0;

}
primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 ,127,131,137,139,149,151,157,163,167,173 ,179,181,191,193,197,199,211,223,227,229 ,233,239,241,251,257,263,269,271,277,281 ,283,293,307,311,313,317,331,337,347,349 ,353,359,367,373,379,383,389,397,401,409 ,419,421,431,433,439,443,449,457,461,463 ,467,479,487,491,499,503,509,521,523,541 ,547,557,563,569,571,577,587,593,599,601 ,607,613,617,619,631,641,643,647,653,659 ,661,673,677,683,691,701,709,719,727,733 ,739,743,751,757,761,769,773,787,797,809 ,811,821,823,827,829,839,853,857,859,863 ,877,881,883,887,907,911,919,929,937,941 ,947,953,967,971,977,983,991, 997]
t = input()
for a in range(t):
    n = input()
    res=0
    for b in range(9, 1000):
        if primes[b]>n:
            print res
            break
        if primes[b] == 997:
            res+=997
            print res
            break
        res+=primes[b]

# cook your code here
t = int(input())
for i in range(t):
    w = raw_input()
    count = 0
    for j in range(len(w)):
        if(w[j]=='B'):
            count = count+2
        elif(w[j]=='A' or w[j]=='R' or w[j]=='P' or w[j]=='O' or w[j]=='D' or w[j]=='Q' ):
            count = count+1
        else:
            pass
    print count
for x in xrange(int(raw_input())):
    a = raw_input()
    count = 0
    for item in a:
        if item == 'A' or item == 'D' or item == 'O' or item == 'P' or item == 'Q' or item == 'R':
            count += 1
        elif item == 'B':
            count += 2
    print count
def solve(N, arrival, departure):
    arrival.sort()
    departure.sort()
    i = count = res = 0
    for n in xrange(N):
        count += 1
        if departure[i] <= arrival[n]:
            count -= 1
            i += 1
        res = max(res, count)
    return res

def hotel():
    T = int(raw_input())
    for t in xrange(T):
        N = int(raw_input())
        arrival = map(int, raw_input().split())
        departure = map(int, raw_input().split())
        print solve(N, arrival, departure)

if __name__ == "__main__":
    hotel()
j = int(raw_input())
while (j > 0):
    i = int(raw_input())
    if (i <= 6):
        print 2
    elif (i>6 and i<=75):
        print 3
    elif (i>75 and i <= 480):
        print 4
    elif (i>480 and i <= 2205):
        print 5
    elif (i > 2205 and i<= 8232):
        print 6
    elif (i > 8232 and i <= 26544):
        print 7
    else:
        print 8
    j = j-1

def sumer(no):
    return ((no)**2+(no))/2
t_cases = int(raw_input())

for i in xrange(t_cases):
    values = (raw_input()).split(" ")
    n=int(values[0])
    k=int(values[1])
    h_shakes = 0
    
    if k==0 or n==k :
        h_shakes+= sumer(n-1)   
    else:
        h_shakes +=sumer(n-1) - (n-k)
        
    print h_shakes

j = int(raw_input())
while (j > 0):
    m = map(int,raw_input().split(' '))
    l = []
    while (m[0] > 0):
        l.append(map(int,raw_input().split(' ')))
        m[0] = m[0] - 1
    while (m[1] > 0):
        i = int(raw_input())
        q = 1
        for k in range(len(l)):
            if (l[k][0] <= i and l[k][1] >= i):
                q = 0
                break
        if (q == 0):
            print "NO"
        else:
            print "YES"
        m[1] = m[1]-1
    j = j-1

t=input()
for i in range(t):
    n=input()
    s=0
    a=[]
    flag=0
    a.append(1)
    while(s<n):
        for j in range(len(a)-1):
            s+=a[j]
        a.append(s)
   
    
    for i in range(len(a)-1):
        flag+=a[i]
    if n==flag:
        print True
    else:
        print False
#include <iostream>
#include <cmath>
#define aa long long
using namespace std;
aa int square(aa int n)
{
    aa int num,rev=0;
    while(n!=0)
    {
        num = n%10;
        rev = rev + (num*num);
        n = n/10;
    }
    return rev;
}
int main()
{
    aa int tc;
    cin>>tc;
    while(tc--)
    {
        aa int n,temp;
        cin>>n;
        aa int a[n];
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
        }
        for(int i=0;i<n;i++)
        {
            temp  = square(a[i]);
            while(temp >= 10)
            {
                temp = square(temp);
            }
            if(temp == 1) cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
        }

    }
}

#include<bits/stdc++.h>
using namespace std;

int main()
{
    long long int t,ans,n,i,a[1000000],check;
    cin>>t;
    while(t--)
    {
        ans=0;
        cin>>n;
        for(i=0;i<n;i++)
        cin>>a[i];
        
        check=a[0];
        for(i=0;i<n;i++)
        if(a[i]>check)
        {
            check=a[i];
            ans++;
        }
        cout<<ans<<" ";
        
    }
    
    return 0;
}
#include <cstdio>
using namespace std;

int main() {

		int t,i,n,a,j,ans;bool displaced;
		scanf("%i%i",&t,&n);
		while(t--)
		{
	        scanf("%i",&j);
	        j++;
	        for(i=1,ans=0;i<n;i++,j++)
                { scanf("%i",&a);
                  displaced=(a-j)%n;
                  ans+=displaced;
                }
	        printf("%i\n",ans);
		}
    return 0;
}

#include <iostream>
#include <bitset>
#include <string>
using namespace std;
void binary(int num)

{

	int rem;

	if (num <= 1)

	{

		cout << num;

		return;

	}

	rem = num % 2;

	binary(num / 2);

	cout << rem;

}
int main() {
	long t, n, i, a, j;
	cin >> t;

	while (t--) {
		cin >> n;

		for (i = 1; i <= n; i++) {
			cin >> a;
			for (j = 1; j <= a; j++) {

				binary(j);
				cout << " ";

			}
		}
		cout << endl;
	}
}

# your code goes here
from sys import stdin, stdout
from math import pi
t = int(stdin.readline())
while t:
	t -= 1
	r1, h1, r2, h2 = map(float, stdin.readline().strip().split(' '))
	v2 = pi*r2*r2*h2
	v1 = pi*r1*r1 *h1 /3
	v1 += 2*pi*r1*r1*r1 /3
	stdout.write("%.18f" % v1 + ' '+"%.18f"%v2 +'\n')
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#include <map>
#include <vector>
#include <list>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <string>
#include <cmath>
using namespace std;
#define FOR(i,a,b) for(i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
struct pb
{
	int x,y;
}posb[251],tmpb;
vector<pb>useb;
vector<int> a[251];
vector<int> b[251];
int n,s;
struct pa
{
	int x,y;
}posa[251],tmpa;
vector<pa>usea;
int sa,sb;
int pres(int a1,int b1)
{
	int i,j;
	for(i=1;i<=sa;i++)
	{
		if(posa[i].x==a1&&posa[i].y==b1)
			return 1;
	}
	for(j=1;j<=sb;j++)
	{
		if(posb[j].x==a1&&posb[j].y==b1)
			return 1;
	}		
	return 0;
}
int frea(int a1,int b1)
{
	int i;
	if(a1<1||b1<1||a1>n||b1>n)
		return 0;
	for(i=0;i<usea.size();i++)
		if(usea[i].x==a1&&usea[i].y==b1)
			return 0;
	if(!pres(a1,b1))
	{
		tmpa.x=a1;
		tmpa.y=b1;
		usea.push_back(tmpa);
	}
}
int freb(int a1,int b1)
{
	if(a1<1||b1<1||a1>n||b1>n)
		return 0;
	int i;
	for(i=0;i<useb.size();i++)
		if(useb[i].x==a1&&useb[i].y==b1)
			return 0;
	if(!pres(a1,b1))
	{
		tmpb.x=a1;
		tmpb.y=b1;
		useb.push_back(tmpb);
	}
}
int chka(int f,int g)
{
	if(posa[f].x==posa[g].x&&posa[f].y==posa[g].y)
		return 0;
	if(abs(posa[f].x-posa[g].x)==1&&posa[f].y==posa[g].y)
		return 1;
	else if(abs(posa[f].y-posa[g].y)==1&&posa[f].x==posa[g].x)
		return 1;
	return 0;
}
int chkb(int f,int g)
{
	if(posb[f].x==posb[g].x&&posb[f].y==posb[g].y)
		return 0;
	if(abs(posb[f].x-posb[g].x)==1&&posb[f].y==posb[g].y)
		return 1;
	else if(abs(posb[f].y-posb[g].y)==1&&posb[f].x==posb[g].x)
		return 1;
	return 0;
}

int tot,visita[1001],visitb[1001];
int dfsa(int v)
{
	int i;
	tot++;
	visita[v]=1;
	frea(posa[v].x+1,posa[v].y);
	frea(posa[v].x,posa[v].y+1);
	frea(posa[v].x-1,posa[v].y);
	frea(posa[v].x,posa[v].y-1);
	for(i=0;i<a[v].size();i++)
	{
		if(!visita[a[v][i]])
			dfsa(a[v][i]);
	}
}
int dfsb(int v)
{
	int i;
	tot++;
	visitb[v]=1;
	freb(posb[v].x+1,posb[v].y);
	freb(posb[v].x,posb[v].y+1);
	freb(posb[v].x-1,posb[v].y);
	freb(posb[v].x,posb[v].y-1);

	for(i=0;i<b[v].size();i++)
	{
		if(!visitb[b[v][i]])
			dfsb(b[v][i]);
	} 
}
struct an
{
	char col;
	int d,c;
}ans[1001];
bool cmpa(an p1, an p2)
{
	if(p1.c!=p2.c)
		return (p1.c>p2.c);
	return (p1.d>p2.d);
}
bool cmpb(an p1,an p2)
{
	if(p1.c!=p2.c)
		return (p1.c>p2.c);
	return (p1.d>p2.d);
}

int main()
{
	int t,i,j;
	scanf("%d\n",&t);
	int xt=0;
	char c;
	while(xt<t)
	{
		xt++;
		sa=0;
		sb=0;
		fill(visita,visita+1001,0);
		fill(visitb,visitb+1001,0);
		scanf("%d %d",&n,&s);
		for(i=1;i<=s;i++)
		{
			a[i].clear();
			b[i].clear();
			scanf(" %c ",&c);
				if(c=='B')
				{
					sb++;
					scanf("%d %d",&posb[sb].x,&posb[sb].y);
				}
				else
				{
					sa++;
					scanf("%d %d",&posa[sa].x,&posa[sa].y);
				}
		}
		printf("Case #%d:\n",xt);
		for(i=1;i<=sb;i++)
		{
			for(j=i+1;j<=sb;j++)
			{
				if(chkb(i,j))
				{
					b[i].push_back(j);
					b[j].push_back(i);
				}
			}
		}
	
		int ant=0;
		useb.clear();
		for(i=1;i<=sb;i++)
		{
			tot=0;
			if(!visitb[i])
			{
				dfsb(i);
				ans[ant].d=useb.size();
				ans[ant].col='B';
				ans[ant++].c=tot;
//				printf("%d\n",tot);
			//	for(j=0;j<useb.size();j++)
		//			printf("%d %d, ",useb[j].x,useb[j].y);
	//			printf("\n");
				useb.clear();
			}
		}
		sort(ans,ans+ant ,cmpb);
		for(i=0;i<ant;i++)
			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d);
//		printf("\n\n");
		for(i=1;i<=sa;i++)
		{
			for(j=i+1;j<=sa;j++)
			{
				if(chka(i,j))
				{
					a[i].push_back(j);
					a[j].push_back(i);
				}
			}
		}
		ant=0;
		usea.clear();
		for(i=1;i<=sa;i++)
		{
			tot=0;
			if(!visita[i])
			{
				dfsa(i);
				ans[ant].d=usea.size();
				ans[ant].col='W';
				ans[ant++].c=tot;
				usea.clear();
			}
		}
//		for(i=1;i<=sa;i++)
//		{
//			for(j=0;j<a[i].size();j++)
//				printf("%d ",a[i][j]);
//			printf("\n");
//		}
	sort(ans,ans+ant,cmpa);
		for(i=0;i<ant;i++)
			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d);
		printf("\n");
	}
	return 0;
}

#include <iostream>
#include "bits/stdc++.h"
using namespace std;

int main() {
	int t;
	  scanf("%d",&t);
	 while(t--)
	 {
	   long long a=1,b=2,x;
	   long  long ans=0;
	      scanf("%lld",&x);
	     while(1)
	     {
	     	if(x<=a)
	     	  break;
	     	  long long g=a;
	     	  a=b;
	     	b=g+b;
	     //	cout<<a<<" "<<b<<endl;
	     	
	     	  ans++;
	     }
	    if(x<a)
	      ans--;
	     printf("%lld\n",ans);
	 }
	return 0;
}
#include<iostream>

using namespace std;

int main()
{
	int n;
	cin>>n;
	int arr[1001];
	for(int i=0;i<1001;i++)
	arr[i]=0;
	for(int i=0;i<n;i++)
	{
		int x;
		cin>>x;
		arr[x]++;
	}
	int max=arr[0],ans=0;
	for(int i=1;i<1001;i++)
	{
		if(arr[i]>arr[i-1])
		{
			max=arr[i];
			ans=i;
		}
	}
	cout<<ans<<endl;
	cout<<max<<endl;
	return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ld long double
#define sl(x) scanf("%lld",&x)
#define pl(x) printf("%lld",x)
#define sld(x) scanf("%Lf",&x)
#define pld(x) scanf("%0.6Lf",x)
#define pline() printf("\n")

int main(){
    ll i,h;
    ld n,a[102],m,sum=0;
    ld ans1,ans2,res;
    sld(n);sld(m);sl(h);
    for(i=1;i<=m;i++){
        sld(a[i]);
        sum+=a[i];
    }
    if(sum>=n){
        sum--;ans1=1;ans2=1;
        //cout<<sum<<endl;
        for(i=0;i<=n-2;i++){
            ans1*=(sum-i)/(i+1);
            //cout<<ans1<<endl;
        }

        sum++;
        sum=sum-a[h];
        //cout<<endl;
        for(i=0;i<=n-2;i++){
            ans2*=(sum-i)/(i+1);
            //cout<<ans2<<endl;
        }
        
        res=(ans1-ans2)/ans1;
        printf("%Lf",res);
    }
    else
    printf("-1");
    pline();
	return 0;
} 
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
    long long int n,ti;
    cin>>n>>ti;
    
    long long int T[n][n];
    long long int toll[n][n];
    
    for(int i=0;i<n;i++)
      for(int j=0;j<n;j++)
        cin>>T[i][j];
        
        
    for(int i=0;i<n;i++)
      for(int j=0;j<n;j++)
        cin>>toll[i][j];
        
    
    long long int dp[55][10005];
    
    for(int i=0;i<55;i++)
      for(int j=0;j<10005;j++)
        dp[i][j]=INT_MAX;
        
    for(int i=0;i<=ti;i++)
      dp[0][i]=0;
        
    for(int time=1;time<=ti;time++)
      {
       for(int destination=1;destination<n;destination++)
         {
          for(int source=0;source<n;source++)
            {
              if(destination==source)
                 continue;
               if(time>=T[source][destination])
               dp[destination][time]=min(dp[destination][time],dp[source][time-T[source][destination]]+toll[source][destination]);
            }
          }
      }
    /*for(int i=0;i<n;i++)
      { for(int j=0;j<=ti;j++)
         {
           cout<<dp[i][j]<<" ";
         }
        cout<<endl;
      }*/
    int min_time=ti;
    while(dp[n-1][ti]==dp[n-1][ti-1])
      {
      ti--;
       min_time--;
      }
    cout<<dp[n-1][ti]<<" "<<min_time<<endl;
   }
	return 0;
}
import sys
x='01'
t=int(sys.stdin.readline())
for i in range(t):
        s=sys.stdin.readline()
        sys.stdout.write("%d\n"%s.count(x))

import sys
t=int(sys.stdin.readline())
for i in xrange(t):
        x=int(sys.stdin.readline())
        s=format(x,'b')
        l=len(s)
        k=l-1
        c=0
        while k>-1:
                if s[k]=='1':
                        break 
                c+=1
                k-=1
        sys.stdout.write("%d\n"%c)

T = int(raw_input())
for i in xrange(T):
	S = raw_input()
	numLst = []
	charLst = []
	ansLst = []
	for i in S:
		if (ord(i) > 47 and ord(i) < 58): 	
			numLst.append(i)
		else:
			charLst.append(i)
	numLst.sort(reverse=True)
	charLst.sort(reverse=True)
	for i in xrange(S.__len__()):
		if (ord(S[i]) > 47 and ord(S[i]) < 58):
			ansLst.append(numLst.pop())
		else:
			ansLst.append(charLst.pop())
	print "".join(ansLst)

import sys
t=int(sys.stdin.readline())
for k in xrange(t):
        n=int(sys.stdin.readline())
        s=(n*(n+1))/2
        a=map(int,sys.stdin.readline().split())
        s=s-sum(a)
        sys.stdout.write("%d\n"%s)

for _ in range(input()):
	n,m=map(int,raw_input().split())
	if n<m:
		print n*(n+1)/2
	elif n==m:
		print n*(n-1)/2
	else:
		print (m*(m-1)/2)*(n//m)+(((n%m)*(n%m+1))/2)
		
			
			
def len(n):
    l=0
    while n:
        n/=10
        l+=1
    return l

def isprime(n):
    if n==2:
        return 1
    var=None
    for i in xrange(2,n):
        if n%i==0:
            break
        var=i
    if var==n-1:
        return 1
    else:
        return 0

def num_rot(n,f):
    l=len(n)-1
    while f:
        f-=1
        i=n%10
        n/=10
        n+=i*(10**l)
    return n

def cir_prime(n):
    k=n
    l=len(n)
    if isprime(k)==1:
        while l!=0:
            l-=1
            k=num_rot(n,l)
            if isprime(k)!=1:
                break
            if k<n and cir_prime(k)!=0:
                break
        if l==0:
            return 1
        else:
            return 0
    else:
        return 0

t=int(input())
for j in xrange(1,t+1):
    n=int(input())
    count=0
    for i in xrange(2,n):
        if cir_prime(i)==1:
            count+=1
    print "Number of circular primes below %d is %d"%(n,count)

import math
def sumof(n):
	sq,su=int(math.sqrt(n)),0
	for i in xrange (2,sq+1):
		if n%i==0:
			su+=i+((n/i) if i*i!=n else 0)
		else:
			continue
	return su+1
t=int(raw_input())
for i in xrange(t):
	n=int(raw_input())
	s1=sumof(n)
	s2=sumof(s1)
	if s2==n:
		print 'Yes, amicable with %d' %s1
	else:
		print 'No'

import sys
m=sys.stdin.readline()
m=int(m)
n=sys.stdin.readline()
n=int(n)
for i in range(m,n):
	k=i
	sum=0
	while(k):
		sum=sum+(k%10)**3
		k=k/10
	if(sum==i):
		print i
testcase = raw_input();
tc  = int(testcase)

while (tc > 0):
	
	flames = "FLAMES"
	#flames[0] = 'X'
	
	name1=list((raw_input()).replace(' ',''))
	name2=list((raw_input()).replace(' ',''))
	
	
	#ht = {}
	
	count =0
	count1 = 0
	
	i=0
	while(i < len(name1)): 
		j=0
		while(j < len(name2)):
			if(name1[i] == name2[j]):
				name2[j] = '0' 
				name1[i] = '0'
				break	
			j +=1 	
		i += 1		
	
	name1 = "".join(name1)
	name2 = "".join(name2)
	
	joined = str(name1+name2).replace('0','')
	count = len(joined)
	
	"""while( i < len(joined)):
		if ht.has_key(joined[i]):
			ht[joined[i]] = ht[joined[i]] + 1 
		else:
			ht[joined[i]] = 1
		i += 1	
	
	count = 0
	for key in ht:
		ht[key] %= 2
		count += ht[key]"""
	
	letters=6
	 	
	while(len(flames) != 1):
		index = count % letters
		if(index == 0):
			flames=flames.replace(flames[len(flames)-1],"")
		else:
			flames=flames.replace(flames[index-1],"")
			flames=flames[index-1:]+flames[:index-1]
		letters -= 1	
	
	if( flames == "F"):
		print "FRIENDS"
	
	if( flames == "L"):
		print "LOVE"
	
	if( flames == "A"):
		print "ADORE"
	
	if( flames == "M"):
		print "MARRIAGE"
	
	if( flames == "E"):
		print "ENEMIES"
	
	if( flames == "S"):
		print "SISTER"
		
	#print ht.keys(),ht.values()	
	#print count
	#print flames
	
	tc -= 1
#!/usr/bin/env python

def main():
    N = int(raw_input())
    # what the fuck is this shit !
    while True:
        try:
            X = raw_input()
        except:
            break
        H = map(int, X.split())
        C = 0
        while H:
            e = H.pop(0)
            H2, C1, C2 = list(H), e, 0
            for i in xrange(len(H2)):
                if H2[i] > e-1:
                   C2 += H2[i]-(e-1)
                   H2[i] = e-1
            #print C+C2, H2, C+C1, H
            if C1 <= C2:
               C += C1
            else:
               C += C2
               H  = H2
        print C

main()


T=input()
for _ in xrange(T):
	N,i=input(),1;
	while i<=N:
		i*=2;
	i/=2;
	print	1+2*(N-i);

t=int(raw_input())
for _ in range(t):
    s=int(raw_input())
    if s>0:
        arr=map(int,raw_input().split())
        dp=[0]*s
        dp[0]=arr[0]
        if s>1:
            dp[1]=max(arr[0],arr[1])
        if s>2:
            for i in range(2,s):
                dp[i]=max(dp[i-2]+arr[i], dp[i-1])
            
        print dp[s-1]
    else:
        print 0

l = raw_input().split()
n, k = int(l[0]), int(l[1])
l = raw_input().split()
l = [int(i) for i in l]
a, b = 1, -1
ans = -1*sum(l[:n-k])+sum(l[n-k:])
print ans
test = int(raw_input())
i=0
while(test > 0):
	n=int(raw_input())
	s=list(raw_input())
	a=map(int,raw_input().split())
	b=''
	for i in xrange(0,n):
		t=a[i]-1
		tmp=s[i]
		s[i]=s[t]
		s[t]=tmp
		
	print "".join(s)	
	test=test-1


a=raw_input()
c,f=0,0
for i in range(len(a)):
    val=1
    while i<len(a)-1 and a[i]==a[i+1]:
        i=i+1
        val=val+1
    if val>f:
        f=val
        c=a[i]
    elif val==f:
        if c>a[i]: c=a[i]
print c
print f

t=int(raw_input())
for i in xrange(t):
    n=int(raw_input())
    x=list(map(int,raw_input().split()))
    print max(x)
t=raw_input()
t=int(t)
while t:
	x,m,n=raw_input().split()
	x=int(x)
	m=int(m)
	n=int(n)
	ans=0
	if(x==1):
		ans=(m+1)%n
	else:
		ans=pow(x,m+1,n*(x-1))-1+n*(x-1)
		ans=ans%(n*(x-1))
		ans=ans/(x-1)
	print (ans)
	t=t-1 
t = int(raw_input())
for i in range(t):
    n = int(raw_input())
    if n == 1 or n == 10 or n == 100 or n == 1000 or n == 10000 or n == 100000:
        print "NO"
    else:
        print "YES"
for I in range(input()):
 x=raw_input().split()
 a=long(x[0])
 b=long(x[1])
 sum=0
 if b==1:
  print a
  continue
 while a!=0:
  sum+=a%b
  a/=b
 print sum
#Anwesh Mohanty
mod=10**9+7
t=input()
while t>0:
	n,m=map(int,raw_input().split())
	if n==1:
		print m%mod
	elif n==2:
		print m*(m-1)
	else:
		print (m*(m-1)*pow(m-2,n-2,mod)%mod) #nPm
	t-=1
#Anwesh Mohanty
t=input()
while t>0:
	a,b=map(int,raw_input().split())
	if((a+b)%5==0):
		r=int(2*(a+b)/5)
		print abs(r-a)
	else:
		print -1
	t-=1
t=int(raw_input())
for i in range(t):
    k,n=map(int,raw_input().split())
    if n==1:
        print "1"
    elif n==2 or n==3:
        print k
    else:
        print pow(k,pow(2,n-3,1000000006),1000000007)
#include<bits/stdc++.h>
using namespace std;
int a[1000005],a1[1000000],a2[1000000];
int main()
{
	int n,m,i,j;
	scanf("%d %d",&n,&m);
	for(i=0;i<n;i++)
	{
		scanf("%d",&a1[i]);
		a[ a1[i] ]=1;
	}
	for(i=0;i<m;i++)	scanf("%d",&a2[i]);
	int cnt=0;
	for(i=0;i<m;i++)
	{
		if(a[a2[i]]==1)
		{
			cnt++;
			a[a2[i]]=0;
		}
	}
	printf("%d",cnt);
	return 0;
}
#include<stdio.h>
#include<string.h>

void swap (int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

int p[12],p1,p2,end=2;
int main()
{
    int o,i,tmp,j,count=0;
    p1=1;
    p2=2;
    char str[2];
    scanf("%i",&o);
    for(i=0;i<o;i++)
    {
        for(j=0;j<6;j++)
        {
            scanf("%s",str);
            if(strcmp(str,"1")==0)
            {
                p[p1]+=1;
                swap(&p1, &p2);
            }
            else if(strcmp(str,"2")==0)
            {
                p[p1]+=2;
            }
            else if(strcmp(str,"3")==0)
            {
                p[p1]+=3;
                swap(&p1, &p2);
            }
            else if(strcmp(str,"4")==0)
                p[p1]+=4;
            else if(strcmp(str,"5")==0)
            {
                p[p1]+=5;
             swap(&p1, &p2);
            }
            else if(strcmp(str,"6")==0)
            {
                p[p1]+=6;
            }
            else if(strcmp(str,"W")==0)
            {
                p1=++end;
                count++;
                if(count==10)
                    break;
            }
        }
        if(count==10)
            break;
        swap(&p1, &p2);
    }
    if((count==10)||(strcmp(str,"W")==0))
        end=end-1;
    for(i=1;i<=end;i++)
    {
        printf("Player %i %i\n",i,p[i]);
    }
    return 0;
}

#include <stdio.h>
#include <algorithm>
#include <math.h>
using namespace std;
const int maxn = 1e5+10;
int n,q,sn,a[maxn],cnt[maxn],l,r,ans,ret[maxn];
struct query{
    int l,r,id;
    bool operator < (const query &op)const{
        if ((l-1)/sn==(op.l-1)/sn){
            return r<op.r;
        }
        return (l-1)/sn<(op.l-1)/sn;
    }
} p[maxn];
void add(int x) {cnt[x]++;if (cnt[x]==1) ans++;}
void del(int x) {cnt[x]--;if (cnt[x]==0) ans--;}
int main(){
    scanf("%d",&n);sn=trunc(sqrt(n));
    for (int i=1; i<=n; i++) scanf("%d",&a[i]);
    scanf("%d",&q);
    for (int i=1; i<=q; i++) scanf("%d%d",&p[i].l,&p[i].r),p[i].id=i;
    sort(p+1,p+q+1);
    l=1;r=0;
    for (int i=1; i<=q; i++){
        while (r<p[i].r){r++;add(a[r]);}
        while (r>p[i].r){del(a[r]);r--;}
        while (l<p[i].l){del(a[l]);l++;}
        while (l>p[i].l){l--;add(a[l]);}
        ret[p[i].id]=ans;
    }
    for (int i=1; i<=q; i++) printf("%d\n",ret[i]);
}

#include <bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define ll long long int
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define F(i,a,n) for(int i=(a);i<(n);++i)
#define FF(i,a,n) for(i=(a);i<(n);++i)
#define REP(i,a,n) for(i=(a);i<=(n);++i)
#define V(x) vector<x>
#define Sd(x) scanf("%d",&x)
#define Sl(x) scanf("%lld",&x)
#define M(x,i) memset(x,i,sizeof(x))
#define all(c) c.begin(), c.end()
#define present_mapset(c,x) ((c).find(x) != (c).end())
#define cpresent_vector(c,x) (find(all(c),x) != (c).end())
#define repstl(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ )
#define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl
#define matrix vector< vector<ll> >
#define PI acos(-1.0)
#define EPS 1e-9
#define F1 first
#define S2 second
#define Lf 2*r
#define Rg 2*r+1
//vector< vector<int> >Matrix(N, vector<int>(M,0));
#define gc getchar_unlocked
#define MAXNN 1000010
#define mod 1e9+7

inline void inputfile() {
#ifndef ONLINE_JUDGE
    freopen("input.in","r",stdin);
#endif
}
inline void cpp_input()
{ios_base::sync_with_stdio(false);
    cin.tie(NULL);}
template <typename T>
void scanint(T &x)
{
    register int c = gc();
    x = 0;
    int neg = 0;
    for(;((c<48 || c>57) && c != '-');c = gc());
    if(c=='-') {neg=1;c=gc();}
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
    if(neg) x=-x;
}

//ind -> parent
int ind[MAXNN],arr[MAXNN];

inline void func()
{

    M(ind,-1);
}

int find(int x)
{
    if (ind[x]<0)
    return x;
    else
    return find(ind[x]);
}

void Union(int x,int y)
{
    int xroot,yroot;
    xroot=find(x);
    yroot=find(y);
    if(xroot==yroot)
        return;
    if(ind[xroot]<=ind[yroot])
        {
            ind[xroot]+=ind[yroot];
            ind[yroot]=xroot;
        }
    else
    {
        ind[yroot]+=ind[xroot];
        ind[xroot]=yroot;
    }
}
int main()
{
    inputfile();
    cpp_input();
  int t,i,n,m,x,y,final,k;
  scanint(t);
  while(t--){

  scanint(n);scanint(m);scanint(k);
   func();
   while(m--)
   {
    scanint(x);
    scanint(y);
    Union(x,y);
   }
   sort(ind+1,ind+n+1);
   final=0;
   for(i=1; i<=n && ind[i]<0 && i<=k; i++)
   {
    final+=ind[i];
   }
   printf("%d\n",-final);

    }
  return 0;
}

#include<stdio.h>
#include<string.h>
#include<iostream>
#include<climits>
#include<vector>
#include<algorithm>
#include<list>
#include<queue>
#define mod 1000000007
#define ll long long
#define min(a,b)(a<b?a:b)
#define max(a,b)(a>b?a:b)
#define MAX 100001
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int a,b,c;
		cin>>a>>b>>c;
		int maxm=max(a,max(b,c));
		int sum=a+b+c;
		int flag=1;
		if(maxm>sum-maxm)
		{
			cout<<"Alice\n";
			continue;
		}
		if((a+b+c)%2==0)
		flag=0;
		
	
		//cout<<ans;
		if(flag)
		cout<<"Alice\n";
		else
		cout<<"Bob\n";
	}
}
#include<iostream>
#include<algorithm>
using namespace std;

struct node
	{
	 int fr;
	 int v;
	};

bool operator<(const node& a,const node& b)
	{
	 if(a.fr%2==b.fr%2)
		return a.v<b.v;
	 else
		return (a.fr%2==1);
	}


int main()
{
 int t; 
 cin>>t;
 while(t--)
	{
	 string s;
 	 cin>>s;
	 node S[s.size()];
	 int C[26];
	 for(int i=0;i<26;i++)
		C[i]=0;
	 for(int i=0;i<s.size();i++)
		C[s[i]-'a']++;
	 
	 for(int i=0;i<s.size();i++)
		{
		 S[i].fr=C[s[i]-'a'];
		 S[i].v=s[i];
		}
	 sort(S,S+s.size());
	 
	 for(int i=0;i<s.size();i++)
		cout<<(char)S[i].v;
	 cout<<"\n";
	}
 return 0;
}

#include<stdio.h>
#include<stdlib.h>

int main()
{
    int n,m,r,coolness[2001],set[101],i,j,temp,count,k,a[101][101],min;

    for(i=0;i<101;i++)
        set[i]=0;

    for(i=0;i<=2000;i++)
        coolness[i]=-1;

    coolness[42]=0;

    scanf("%d%d%d",&n,&m,&r);

    for(i=0;i<n;i++)
    {
        for(j=0;j<m;j++)
        {
            scanf("%d",&a[i][j]);

            if(a[i][j]==42)
                set[i]=1;

        }
    }

    for(i=0;i<n;i++)
    {
        if(set[i]==1)
        {
          for(j=0;j<m;j++)
          {
            if(coolness[a[i][j]]==-1)
            coolness[a[i][j]]=1;
          }
        }
    }

  for(count=0;count<n;count++)
  {
    for(i=0;i<n;i++)
    {
      if(set[i]!=1)
      {
          min=-1;
          for(j=0;j<m;j++)
          {
            if((min==-1 && coolness[a[i][j]]!=-1)||(coolness[a[i][j]]<min && coolness[a[i][j]]!=-1))
                 min=coolness[a[i][j]];
          }
          if(min!=-1)
          {
                  set[i]=1;
                  temp=min;

                  for(k=0;k<m;k++)
                  {
                      if(coolness[a[i][k]]!=temp)
                        coolness[a[i][k]]=temp+1;
                  }
          }
      }
    }
  }

  int num;
  for(i=0;i<r;i++)
  {
      scanf("%d",&num);
      printf("%d\n",coolness[num]);
  }
    return 0;
}

#include<stdio.h>
#include<math.h>
int main()
{
    long int x;
    long int n,m,r,c,t,o,i,a,b,y,d,op,max;
    scanf("%ld",&x);
    while(x--)
    {
       scanf("%ld",&n);
       scanf("%ld",&m);
       scanf("%ld",&r);
       scanf("%ld",&c);
       scanf("%ld",&t);
       
       a=2*r-1;
       b=(m-c)*2+1;
       y=(n-r+1)*2;
       d=2*c;
       
       o=a;
       op=1;
       if(b<o){o=b;op=2;}
       if(y<o){o=y;op=3;}
       if(d<o){o=d;op=4;}
       switch(op)
       {
       	case 1:
       		max=o*o-1;
       		break;
       	case 2:
       		max=o*o+o-1;
       		break;
       	case 3:
       		max=o*o-1;
       		break;
       	case 4:
       		max=o*o+o-1;
       }
       if(t>max)t=max;
       o = sqrt(t+1);
       t=t-o*o+1;
       if(o%2==0)
       {
       	r+=o/2;
       	r--;
       	c+=o/2;
       	for(i=1;i<=t;i++)
       	{
       		if(i==1)r++;
       		else if(i<=o+1)c--;
       		else r--;
       	}
       }
       else
       {
       	r-=o/2;
       	c-=o/2;
       	for(i=1;i<=t;i++)
       	{
       		if(i==1)r--;
       		else if(i<=o+1)c++;
       		else r++;
       	}
       }
       printf("%ld %ld\n",r,c);
    }
return 0;
}
n,m=map(int, raw_input().split())
a=[ raw_input().split() for j in xrange(n) ]
while m>0:
	m-=1
	ang=input()
	ang/=90
	ang%=4
	if(ang==1):
		for j in xrange(0,n):
			for i in xrange(n-1,-1,-1):
				print a[i][j],
			print 
	elif(ang==2):
		for i in xrange(n-1,-1,-1):
			for j in xrange(n-1,-1,-1):
				print a[i][j],
			print 
	elif(ang==3):
		for i in xrange(n-1,-1,-1):
			for j in xrange(0,n):
				print a[j][i],
			print 
	else:
		for row in a:
			print " ".join(map(str,row))
inversion=0
def merge(array,i,j):
	global inversion
	# raw_input()
	# print i,j
	if(j==i):
		return [array[i]]
	else:
		array1 = merge(array,i,(j+i)/2)
		array2 = merge(array,(j+i)/2+1,j)
		# print array1, array2
		retarr = []
		while( len(array2)>0 and len(array1)>0 ):
			if(array1[0]>array2[0]):
				retarr.append(array2.pop(0))
				inversion+=len(array1)
			else:
				retarr.append(array1.pop(0))
		# inversion+=len(array1)
		retarr=retarr +array1+array2
		return retarr
num = []
n = int(raw_input())
num = map(int,raw_input().split())
result = merge(num,0,n-1)
# for i in range(0,100000):
	# print result.pop(0)
print inversion

N = int (raw_input())

words = []
maxDep = 0

def dfs(dic, depth):
    global maxDep
    if dic['__a'] > 1:
        if depth > maxDep:
            maxDep = depth
    for key in dic.keys():
        if key!='__a':
            if dic[key]['__a'] > 1:
                dfs(dic[key], depth+1)
    
dic = {}
dic['__a'] = 0
for i in range(N):
    words.append(raw_input())
    
    
    curDic = dic
    
    for l in range(len(words[i])):
        if not curDic.has_key(words[i][l]):
            curDic[words[i][l]] = {}
            curDic[words[i][l]]['__a'] = 0
        curDic['__a'] += 1
        curDic = curDic[words[i][l]]
dfs(dic, 0)
print maxDep
    
#!/usr/bin/python

s=raw_input()
dp = [ [ 0 for j in xrange(20)] for i in xrange(20) ]
op = [ '_' for i in xrange(20) ]
n = len(s)
m = 0
f = [0, 1]
for i in xrange(2,20):
    f.append(0)
    for j in xrange(1,i):
        f[i] += f[j] * f[i-j]
for i in xrange(n):
    if i%2 == 0 and s[i] == 'T':
        dp[i/2][1] = 1
    else: op[i/2] = s[i]
n = (n+1)/2
for l in xrange(2,n+1):
    for i in xrange(n+1-l):
        for k in xrange(i,i+l-1):
            la,lb = k+1-i,l+i-k-1
            if op[k] == '.': dp[i][l] += dp[i][la] * dp[k+1][lb]
            if op[k] == '+':
                dp[i][l] += f[la] * f[lb]
                dp[i][l] -= (f[la] - dp[i][la]) * (f[lb] - dp[k+1][lb])
            if op[k] == '*':
                dp[i][l] += dp[i][la] * (f[lb] - dp[k+1][lb])
                dp[i][l] += (f[la] - dp[i][la]) * dp[k+1][lb]
print dp[0][n]

# with python comes the FRREEEEEEEDOM.... BRING ON THE SO CALLED LARGE NUMBERS...
# this is why i LIKE PYTHON... 
# I M PYTHONIC....
x = int(raw_input());
primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29,31, 37, 41, 43, 47, 53, 59, 61, 67, 71,73, 79, 83, 89, 97, 101, 103, 107, 109, 113,127, 131, 137, 139, 149, 151, 157, 163, 167, 173,179, 181, 191, 193, 197, 199, 211, 223, 227, 229,233, 239, 241, 251, 257, 263, 269, 271, 277, 281,283, 293, 307, 311, 313, 317, 331, 337, 347, 349,353, 359, 367, 373, 379, 383, 389, 397, 401, 409,419, 421, 431, 433, 439, 443, 449, 457, 461, 463,467, 479, 487, 491, 499, 503, 509, 521, 523, 541,547, 557, 563, 569, 571, 577, 587, 593, 599, 601,607, 613, 617, 619, 631, 641, 643, 647, 653, 659,661, 673, 677, 683, 691, 701, 709, 719, 727, 733,739, 743, 751, 757, 761, 769, 773, 787, 797, 809,811, 821, 823, 827, 829, 839, 853, 857, 859, 863,877, 881, 883, 887, 907, 911, 919, 929, 937, 941,947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013]
isprime = True
for num in primes:
	if x % num == 0 and x != num:
		isprime = False
		break
if x==1:
	print"GET LOST!.....\n"
elif isprime:
	print"PRIME\n"
else:
	print"COMPOSITE\n"

def getData(file):
    auta = []
    prefs = {}

    n = int(file.readline())
    for i in xrange(0,n): file.readline() 
    for i in xrange(0,n): auta.append(file.readline().strip())
    for i in xrange(0,n): 
        prefs[i] = file.readline().strip().split(' ')[1:]

    return n, auta, prefs

def feasible(prefs, i, auta, pouziteAuta):
    if len(auta) == len(pouziteAuta): return True
    pos = [x for x in prefs[i] if x not in pouziteAuta]
    for p in pos:
        if feasible(prefs, i+1, auta, pouziteAuta + [p]): return True
    return False

if __name__ == "__main__":
    import sys
    n, auta, prefs = getData(sys.stdin)
    print ["No","Yes"][feasible(prefs, 0, auta, [])]
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define M 5000021 
char str[M];
int Z[M];
int min(int a,int b){ return a<b?a:b;}
void Zarray(int n)
{
	int L,R,i;
	L=R=0;
	for(i=1;i<n;i++)
	{
		if(i>R)
		{
			L=R=i;
			while(R<n && str[R-L]==str[R])
				R++;
			Z[i] = R-L;
			R--;
		}
		else
		{
			int k=i-L;
			if(Z[k]<R-i+1)
				Z[i] = Z[k];
			else
			{
				L=i;
				while(R<n && str[R-L]==str[R])
					R++;
				Z[i] = R-L;
				R--;
			}
		}
	}
}
int main()
{
	int sl,q,p;
	scanf("%s",str);
	sl = strlen(str);
	Zarray(sl);
	scanf("%d",&q);
	while(q--)
	{
		scanf("%d",&p);
		int ans = min(Z[p],p);
		printf("%d\n",ans);
	}
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long int LL;
#define sd(x) scanf("%d", &x)
#define mp make_pair
#define pb push_back
#define vi vector<int>
#define ft first
#define sc second
#define INF 1000000000
#define MOD 10000007
int n, k;
pair<LL,LL> c[205];
LL cost[205][205];
LL dp[205][37];
LL func(int last, int tot)
{
	if (tot < 0) {
		return 100000000000000LL;
	}
	if (last == n+1) {
		if (tot == 0) return 0;
		else return 100000000000000LL;
	}
	if (dp[last][tot] != -1) return dp[last][tot];
	LL ans = 100000000000000LL;
	for (int i = last; i <= n; i++) {
		ans = min(ans, cost[last][i] + func(i+1, tot-1));
	}
	return dp[last][tot] = ans;
}
int main()
{
	int t;
	scanf("%d", &t);
	while (t--) {
		cin>>n>>k;
		memset(dp, -1, sizeof dp);
		for (int i = 1; i <= n; i++) cin>>c[i].first;
		for (int i = 1; i <= n; i++) cin>>c[i].second;
		sort(c+1, c+n+1);
		for (int i = 1; i <= n; i++) {
			for (int j = i; j <= n; j++) {
				int sel = i;
				LL cst = (j-i)*c[sel].second;
				for (int l = i; l <= j; l++) {
					cst += abs(c[sel].first - c[l].first); 
				}
				cost[i][j] = cst;
				for (sel = i+1; sel <= j; sel++) {
					cst -= (j-i)*c[sel-1].second;
					cst += (j-i)*c[sel].second;
					cst -= (j - sel+1)*(c[sel].first - c[sel-1].first);
					cst += (sel - i)*(c[sel].first - c[sel-1].first);
					cost[i][j] = min(cost[i][j], cst);
				}
			//	cout<<cost[i][j]<<" "<<endl;
			}
		}
		
		printf("%lld\n", func(1, k));
	}
	return 0;
}
#include "bits/stdc++.h"
using namespace std;
        #define rep(i,n) for(int i = 0; i < n; ++i)
        #define REP(i,a,b) for(int i = a ; i <= b; ++i)
        #define rep1(i,n) for(int i = 1; i <=n ; ++i)
        #define s(n) scanf("%lf",&n)
        #define rev(i,n) for(int i = n-2; i >= 0 ; --i)
        #define REV(i,a,b) for(int i = a ; i >= b ; --i)
        #define INF 1000000000
        #define pii pair<int,int>
        #define pb(a) push_back(a)
        #define ll long long
        #define vi vector<int>
        #define mii map<int,int>
        #define msi map<string,int>
        #define vii vector<vector<int> >
        #define vpp vector<pair<int,int> >
        #define MOD 1000000007
        #define PDD pair<double,double>
        #define vl vector<long long>
        #define pil pair<int,long long>
        #define pll pair<long long,long long>
        #define sz(v) (int)v.size()
        #define mp make_pair
        #define pi 3.1415926536
        #define gc getchar_unlocked
        #define ios std::ios::sync_with_stdio(false)
        #define e(a) exp(a)
        #define limit 100000000
        #define gc getchar_unlocked
    ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
    ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
    ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
    ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
    // ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); }
//vll v;
    const double EPS = 1e-9;  /*two numbers are deemed equal if their abs difference is less than some small epsilon , [less than operator- if(a<b-EPS){}],[less than or equal -if(a<b+EPS){}]*/
    vector<ll> m[33];
    vector<ll> m1[33];
    int main(int argc, char const *argv[])
    {
    	//ios;
    	int n, k, A, B;
    	scanf("%d%d%d%d", &n, &k, &A, &B);
    	ll a[n+1];ll b[n+1];ll c[n+1];
    	rep(i,n)
    	scanf("%lld", &a[i]); 

  for(int i = 0; i < n; i++){
int number  = a[i];
   ll pro = 1;
     int flag = 0;
     while(number % 2 == 0){
     	flag = 1;
         number = number / 2;         
     }
     if(flag == 1)pro *= 2;
     for(int j = 3; j <= sqrt(a[i]); j++){
     	 flag = 0;
         while(number % j == 0){
         	flag = 1;
         	number = number / j; 
         }
         if(flag == 1)pro*=j;
     }

     if(number > 2){
     	pro *= number;
     }
     a[i] = pro;
   }
   // for(int i = 0; i < n; i++){cout << a[i] << " " ;}cout << "\n";
    	int divide = n/2;
    	int divide1 = n - divide;
    	ll prec = pwr(2, divide);
    	ll prec1 = pwr(2, divide1);
    	for(int i = 0; i < divide; i++){b[i] = a[i];}//firstpart
		for(int i = divide; i < n; i++)c[i-divide] = a[i];//secondpart
    	//BITMASKS
    	for(int i = 0; i < prec; i++){
    		ll c1 = 0, pro = 0;
    		for(int j = 0; j < divide; j++){
    			if(i & (1<<j)){
    				c1++;
    				pro += b[j];
    				// cout << "*"
    			}
    			
    		}
    		m[c1].push_back(pro);
    	}
// for(int i = 0 ; i <= 2; i++){
// 	cout << i <<  "\n";
// 	for(int j = 0 ; j  < m[i].size(); j++)cout << m[i][j] << " ";
// 		cout << "\n";
// }
    	for(int i = 0; i < prec1; i++){
    		ll c1 = 0, pro = 0;
    		for(int j = 0; j < divide1; j++){
    			if(i & (1<<j)){
    				c1++;
    				pro += c[j];
    			}
    			
    		}
    		m1[c1].push_back(pro);
    	}

    	for(int i  = 0 ; i <= k; i++){
    		sort(m1[i].begin(), m1[i].end());
    	}

    	//end BITMASKS
    	ll c3 = 0;
    	for(int i = 0; i <= k; i++){
    		for(int j = 0; j <= k; j++){
    			if(i+j <= k){
    				for(int p = 0; p < m[i].size(); p++){
    					// for(int q = 0; q < m1[j].size(); q++){
    					// 	if(m1[j][q] + m[i][p] >= A && m1[j][q] + m[i][p] <= B)c3++;
    					// }
    					int val = A - m[i][p];
						int id1 = lower_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin();
						val = B - m[i][p];
						int id2 = upper_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin() - 1;
						c3 = c3 + max(0,id2 - id1 + 1);
    				}
    			}
    		}
    	}
    	printf("%lld", c3);
    	return 0;
    }
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <vector> 
#include <limits.h>
#include <string>
#include <map>

using namespace std;

int main(){
	map<char,int> count;
	string str,resp="";
	int N,K;
	cin >> N >> K >> str;
	for(int j=0;j<K;j++){
		count['a'] = 0;count['b']=0;count['c']=0;
		for(int i=0;i<N/K;i++){
			count[str[K*i+j]]++;
		}
		if(count['a'] >= max(count['b'],count['c'])) resp+='a';
		else if(count['b'] >= count['c']) resp +='b';
		else resp+='c';
	}
	cout << resp << endl;
	return 0;
}
#include<iostream>
#include<vector>
using namespace std;
#include<algorithm>
bool func(pair<long long int ,long long int >&a,pair<long long int,long long int  >&b)
{
	if(a.first > b.first)return true;
	else if(a.first == b.first)
	{
		return a.second<b.second;
	}
	else 
	return false;
}
int main()
{
long long int n;
cin >> n;
long long int x=n;
long long int item1,item2;
long long int i=0;
vector<pair<long long int ,long long int > >v;
pair<long long int ,long long int >p;
for(i=0;i<x;i++)
{
cin >> item1;
cin >> item2;
p=make_pair(((long long )item1)*((long long)item2),i+1);
v.push_back(p);
}
sort(v.begin(),v.end(),func);
long long int q;
cin >> q;
long long int item;
while(q--)
{
 cin>>item;
 cout << v[item-1].second << endl;
}
return 0;
}
//You only fail when you stop trying...
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
#define ll  long long int
#define inf 100000000000000
#define mod 1000000007
#define pb push_back
#define mp make_pair
#define all(v) v.begin(),v.end()
#define S second
#define F first
#define boost1 ios::sync_with_stdio(false);
#define boost2 cin.tie(0);
#define mem(a,val) memset(a,val,sizeof a)
#define endl "\n"
#define maxn 100001

vector<ll>v[maxn];
ll dist[maxn][2],cost[maxn],h[maxn];
int main()
{
	boost1;boost2;
	ll i,j,n,m,x,y,d0,d1,cur,distance,mode,nxt;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	cin>>h[i];
	for(i=1;i<=n;i++)
	cin>>cost[i];
	for(i=1;i<=m;i++)
	{
		cin>>x>>y;
		v[x].pb(y);
		v[y].pb(x);
	}
	for(i=1;i<=n;i++)
	{
		dist[i][0]=inf;
		dist[i][1]=inf;
	}
	dist[1][0]=dist[1][1]=cost[1];
	priority_queue<pair<ll,pair<ll,ll> > >q;
	q.push(mp(-dist[1][0],mp(0,1)));
	q.push(mp(-dist[1][1],mp(1,1)));
	while(!q.empty())
	{
		cur=q.top().S.S;
		distance=-q.top().F;
		mode=q.top().S.F;
		q.pop();
		if(dist[cur][mode]!=distance)
		continue;
		for(i=0;i<v[cur].size();i++)
		{
			nxt=v[cur][i];
			if(h[nxt]>h[cur])
			{
				if(mode==0)
				{
					d0=distance;
					d1=distance+cost[nxt];
				}
				else
				{
					d0=distance+cost[cur];
					d1=distance+cost[cur]+cost[nxt];
				}
			}
			else if(h[nxt]==h[cur])
			{
				if(mode==0)
				{
					d0=distance;
					d1=distance+cost[nxt];
				}
				else
				{
					d0=distance+cost[nxt];
					d1=distance;
				}
			}
			else
			{
				if(mode==0)
				{
					d0=distance+cost[cur]+cost[nxt];
					d1=distance+cost[cur];
				}
				else
				{
					d0=distance+cost[nxt];
					d1=distance;
				}
			}
			if(dist[nxt][0]>d0)
			{
				dist[nxt][0]=d0;
				q.push(mp(-dist[nxt][0],mp(0,nxt)));
			}
			if(dist[nxt][1]>d1)
			{
				dist[nxt][1]=d1;
				q.push(mp(-dist[nxt][1],mp(1,nxt)));
			}
		}
	}
	ll ans=min(dist[n][0],dist[n][1]);
	if(ans==inf)
	cout<<"-1";
	else
	cout<<ans;
	return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define ll long long int
#define mp make_pair
#define f first
#define s second
int main()
{
	vector < pair<ll,ll> > v;
	long long int n,m,i,a,b,p,count=0;
	scanf("%lld%lld%lld",&n,&m,&p);
		while(p--)
		{
			scanf("%lld%lld",&a,&b);
			v.pb(mp(m-b+a-1,a));
		}
	sort(v.begin(),v.end());
	ll sz=v.size(),cm,ci;
	cm=-1;
	ci=-1;
	ll multi=0;
	for(i=0;i<sz;i++)
	{
			if((v[i].f==cm&&v[i].s==ci)||(i==0))
			{
				multi++;
			}
			else
			{
				count=count^((cm%2)*multi);
				multi=1;
			}
			cm=v[i].f;
			ci=v[i].s;
		
	}
	count=count^((cm%2)*multi);
	if(count==0)
	printf("No\n");
	else
	printf("Yes\n");
	return 0;
}  
/* [theMighty] Deathsurgeon (Rupesh Maity)
* 3rd year, B.Tech in IT
* IIIT Allahabad
*/

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <math.h>
#include <string>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <stack>
#include <queue>
#include <vector>
#include <map>
#include <utility>
#include <climits>
#include <ctime>

#define LL long long
#define pii pair<int, int>

#define MOD 1000000007
#define MAX 100001
#define sd(x) scanf("%d", &x)

using namespace std;

pii point[3000];
int bit[3001][3001];
int hx, hy;

int fun(int top, int down, int left, int right) {
	int tot = 0;
	for (int i = right; i > 0; i -= i & -i) {
		for (int j = top; j > 0; j -= j & -j) {
			tot += bit[i][j];
		}
	}

	for (int i = left; i > 0; i -= i & -i) {
		for (int j = down; j > 0; j -= j & -j) {
			tot += bit[i][j];
		}
	}
	
	for (int i = right; i > 0; i -= i & -i) {
		for (int j = down; j > 0; j -= j & -j) {
			tot -= bit[i][j];
		}
	}

	for (int i = left; i > 0; i -= i & -i) {
		for (int j = top; j > 0; j -= j & -j) {
			tot -= bit[i][j];
		}
	}
	
	return tot;
}

int main()
{
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
	//	freopen("output.txt", "w", stdout);
#endif
	int n;
	cin >> n;
	int x[3000];
	int y[3000];

	for (int i = 0; i < n; i++) {
		cin >> x[i] >> y[i];
		point[i] = { x[i], y[i] };
	}

	// precompute
	sort(x, x + n);
	sort(y, y + n);
	hx = unique(x, x + n) - x;
	hy = unique(y, y + n) - y;

	// compress
	for (int i = 0; i < n; i++) {
		point[i].first = upper_bound(x, x + hx, point[i].first) - x;
		point[i].second = upper_bound(y, y + hy, point[i].second) - y;
	}

	for (int i = 0; i < n; i++) {
		int x = point[i].first;
		int y = point[i].second;

		for (int j = x; j <= hx; j += j & -j) {
			for (int k = y; k <= hy; k += k & -k) {
				++bit[j][k];
			}
		}
	}
	/*
	for (int i = 1; i <= hx; i++) {
		for (int j = 1; j <= hy; j++) {
			int c = 0;
			for (int p = i; p > 0; p -= p&-p) {
				for (int q = j; q > 0; q -= q & -q) {
					c += bit[p][q];
				}
			}
			cout << i << j << c << endl;
		}
	}
	*/
	int q;
	cin >> q;

	while (q--) {
		int a, b, k;
		cin >> a >> b >> k;

		if (k > n) {
			puts("-1");
			continue;
		}

		int l = 0, h = 1000000000;

		while (l < h) {
			int mid = (h - l) / 2 + l;
			int top = b + mid;
			int down = b - mid;
			int left = a - mid;
			int right = a + mid;

			top = upper_bound(y, y + hy, top) - y;
			down = lower_bound(y, y + hy, down) - y;
			right = upper_bound(x, x + hx, right) - x;
			left = lower_bound(x, x + hx, left) - x;

			int cnt = fun(top, down, left, right);

			if (cnt < k) {
				l = mid + 1;
			}
			else {
				h = mid;
			}
		}

		cout << l << endl;
	}

	return 0;
}
#include<stdio.h>
#define dummy (sizeof(temp) / sizeof(2[temp]))
int temp[] = {1,2,3,4};
int main()
{
int d;
//Block 1 Starts here
for(d=-1;d <= 2;d++) //Line 1 
//Block 1 Ends here
printf("%d\n",temp[d+1]);
return 0;
}
#include<stdio.h>
#include<iostream>
using namespace std;
int help(int help)
{
help=help+2;
return help;
}
int main()
{
int test=10;
int pleh=help(test);
cout<<pleh<<endl;
return 0;
} 
long long f(long long n)
{
long long r=0;
if(n>=0)
r=(n+1)*(n+2)*(n+3);
return (r/6) ;
}
int main()
{
long long N,A,B,C;
scanf("%lld%lld%lld%lld",&N,&A,&B,&C);
printf("%lld\n",f(N)-f(N-A-1)-f(N-B-1)-f(N-C-1)+f(N-A-B-2)+f(N-A-C-2)+f(N-C-B-2)-f(N-A-B-C-3));
return 0;
}

#include <stdio.h>
#include <string.h>
int main()
{int size;
scanf ("%d",&size);
int arr[size],i;
for(i=0;i<size;i++)
{
scanf("%d",&arr[i]);
printf("%d",arr[i]);
}
return 0;
}
#include<stdio.h>
int main(void)
{
int i, num=1;
while(num<=10)
{
i=2;
while(i<num)
{
if(num%i==0)
break;
i++; }
if(i==num)
printf("%3d, ", num);
num++; }
return 0;
} 
#include<iostream>
using namespace std;
int main()
{
cout<<"Intechxication2012"<<endl;
return 0;
}
    #include<stdio.h>
    #pragma warn -rpt
    int main()
    {
    int a[]={1,2,3,4,5,6};
    int *j,k;
    j=a;
    #ifdef b
    j=j*2;
    #endif
    k=a+4;
    k=k/2;
    printf("%d",1);
    return 0;
    } 
    #include <stdio.h>
    #define numbre number
    #define num number
    int main()
    {
    int number = 0, remainder = 0;
    //while(number != -1)
    {
    //printf("Enter an integer (-1 to stop): ");
    scanf("%d",&number);
    //if(number != -1)
    {
    remainder = numbre % 2;
    }
    if(remainder!=1)
    printf("%d is an even number.\n", num);
    else
    printf("%d is an odd number.\n", number);
    }
    //printf("%d is an odd number.", number);
    return 0;
    } 
#include <stdio.h>
#include <stdlib.h>
char names[6][60] =
{
"kisalaya", "kunal", "aaditya"
"jp", "sambhav", "mayank"
};
int main()
{
int i;
int choice;
for( i = 0; i < 1; i++ )
{
choice = 5;
printf( "%s", "mayank" );
}
return 0;
}
#include<stdio.h>
int main()
{
	int a[]={1,2,3,4,5};
	int j;
	//Block 1 starts here
	int *b=a;
	for(j=0;j<5;j++)
	{
		printf("%d",*b);
		b++;
	}
	return 0;
	//Block 1 ends here
}
 
#include<stdio.h>
int f(int);
int main()
{
            int f(int);
            int b;
            b = f(20);
            printf("%d",b);
            return 0;
}
 
int f(int a)
{
int x;
            return x=(a > 20 ? 10 : 20);
}
#include<stdio.h>

#include<stdlib.h>

#include<stdio.h>

#include<stdlib.h>

struct ex

{

int i;

float j;

char *s;

};

struct ex *p;
int main()

{



p=(struct ex*)malloc (sizeof(struct ex));

p->s=(char*)malloc(20);

free(p);

printf("Executed");return 0;

}
#include<stdio.h>
using namespace std;
int main()
{
    char s='A';
printf("%c",s);

return 0;
}
t = input()
while t > 0:
	n = input()
	print (n * (n - 1))/2
	t = t - 1
# cook your code here
n=input()
for i in range(n):
    x=raw_input()
    
    print long(x[::-1])

#include <iostream>
#include <cstdio>
#include <cassert>
using namespace std;

long long N, K, M;
long long pos, scroll, up, down;
long long length;

void perform();
long long top(long long k);
bool visible(long long k);

int main() {
  long long T;
  assert(scanf("%lld",&T)==1);
  while(T) {
    perform();
    T--;
  }
  return 0;
}

void perform() {
  pos = 1;
  up = 1;
  down = 1;
  length = 0;
  scroll = 0;
  assert(scanf("%lld %lld %lld", &N, &K, &M)==3);
  
  long long v;
  for(long long i=0;i<M;++i) {
    assert(scanf("%lld",&v)==1);
//     cerr << scroll << " " << length << " " << up << " " << down << "\n";
    
    down = max(down, v);
    up = min(up, v);
    
    if(visible(v))
      continue;
    if(v>pos) {
      length += top(v) - pos;
      pos = top(v);
    }
    else {
      length += pos-v;
      pos = v;
    }
    scroll++;
    
    if(visible(up)&&visible(down))
      scroll--;
    else {
      up = v;
      down = v;
    }
  }
  
  printf("%lld %lld\n", scroll, length);
//   cerr << up << " " << down << "\n";
}
long long top(long long k) {
  return (k-K+1);
}
bool visible(long long k) {
  if(k>=pos&&k<pos+K)
    return true;
  return false;
}
using namespace std;
#include <iostream>
#include <assert.h>
#define FORab(i,a,b) for(__typeof(b) i=(a);i<=(b);i++)
#define FOR1(i,n) FORab(i,1,n)
#define MAX 1010
#define ll long long
ll mem[MAX][MAX]={0},cum[MAX][MAX]={0};
bool isMemed[MAX][MAX]={0};
ll solve(ll i, ll j) {
    //cout<<i<<' '<<j<<endl;
    if(isMemed[i][j]) {return mem[i][j];}
    if(isMemed[j][i]) {return mem[i][j]=mem[j][i];}
    //if(i == 0) return 0;
    //if(j == 0) return 0;
    isMemed[i][j] = true;
    ll &ans = mem[i][j];
    if(i < j) { swap(i,j); }
    if(i%j == 0) return ans=i/j;
    return ans=i/j+solve(j, i%j);
}
 
int main() {
 
    FOR1(i, MAX-1) FOR1(j, MAX-1) { solve(i, j); }
    FOR1(i, MAX-1) FOR1(j, MAX-1)
    {
        cum[i][j]=cum[i-1][j]+mem[i][j];
    }
    //cout<<solve(4,4)<<" "<<solve(4,5)<<" "<<solve(5,4)<<" "<<solve(5,5)<<" "<<endl;
    //cout<<mem[2][5]<<" "<<cum[2][5]<<endl;
    ll x=0;
    FORab(i,1,2)
        FORab(j,5,10)x+=mem[i][j];
        //cout<<x<<endl;
    ll t; cin>>t;
    FOR1(cno, t) {
        ll m, n, p, q;
        cin>>m>>n>>p>>q;
        ll ans=0;
        FORab(j, p, q) {
            ll mdiv = (m-1)/j;
            ll ndiv = n/j;
            ll mmod = (m-1)%j;
            ll nmod = n%j;
            /*
            if(mdiv == ndiv) {
                ans = getAns(j, mmod, nmod);
            } else if(mmod < nmod) {
                getAns(j, mmod, nmod)+getAns(j, 1, mmod-1);*/
                ll msum=j*(mdiv*(mdiv-1))/2 + (mmod+1)*mdiv;
                ll nsum=j*(ndiv*(ndiv-1))/2 + (nmod+1)*ndiv;
               // cout<<nsum<<" .. "<<msum<<endl;
                msum+=cum[j-1][j]*mdiv+cum[mmod][j];
                nsum+=cum[j-1][j]*ndiv+cum[nmod][j];
                ans+=nsum-msum;
    //            cout<<nsum<<" "<<msum<<endl;
                //assert(nsum>=msum);
                //assert(ans>=0);
            }
            cout<<ans<<endl;
    }
 
    return 0;
}
 
#include<vector>
#include<stack>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<string>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>

using namespace std;

#define s(n)					scanf("%d",&n);
#define sl(n)                   scanf("%lld", &n);
#define sf(n) 					scanf("%lf",&n);
#define ss(n) 					scanf("%s",n);
#define INF						(int)1e9
#define LINF					(long long)1e18
#define EPS						1e-12
#define FOR(i,a,b)				for(int i=a;i<b;i++)
#define REP(i,n)				FOR(i,0,n)
#define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)
#define mp						make_pair
#define FF						first
#define SS						second
#define tri(a,b,c)				mp(a,mp(b,c))
#define XX						first.first
#define YY						first.second
#define ZZ						second
#define pb						push_back
#define fill(a,v) 				memset(a,v,sizeof a)
#define all(x)					x.begin(),x.end()
#define SZ(v)					((int)(v.size()))
#define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end())
#define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin())
#define debug(args...)			{dbg,args; cerr<<endl;}
#define dline					cerr<<endl
#define SP                      system("pause");
#define HAHA                    printf("HAHA\n");
#define mod                     10000

void debugarr(int *arr, int ind1, int ind2)
{
	cout<<"[ ";
	for(int i=ind1;i<=ind2;i++)
		cout<<arr[i]<<" ";
	cout<<"]"<<endl;
}

typedef long long LL;
typedef pair<int,int> PII;
typedef pair<LL,LL> PLL;
typedef pair<LL,PII> TRI;

typedef vector<int> VI;
typedef vector<LL> VL;
typedef vector<PII> VII;
typedef vector<PLL> VLL;
typedef vector<TRI> VT;

typedef vector<VI> VVI;
typedef vector<VL> VVL;
typedef vector<VII> VVII;
typedef vector<VLL> VVLL;
typedef vector<VT> VVT;

/////////////////////////////////////////////////////////////////////////////////////////

#define N 50005
#define base (1<<16)

int x[N], y[N];
pair< PII, int> a[N];
int n;
map<int, int> xmap, ymap;
int cnt[4][N];
int xt[N], yt[N];
int seg[base << 1];

//   23
//   01

int sum(int node, int l, int r, int L, int R)
{
    if(l == L && r == R) return seg[node];
    int M = (L+R)>>1;
    int NN = node << 1;
    if(r <= M) return sum(NN, l, r, L, M);
    if(l > M) return sum(NN|1, l, r, M+1, R);
    return sum(NN, l, M, L, M) + sum(NN|1, M+1, r, M+1, R);
}

void update(int ind, int val)
{
    for(int i = ind+base; i; i>>=1) seg[i] += val;
}

void go(int ind)
{
    sort(a, a+n);
    fill(seg, 0);
    REP(i, n)
    {
        cnt[ind][a[i].ZZ] = sum(1, 0, a[i].YY, 0, base-1);
        update(a[i].YY, 1);
    }
}

int main()
{
    int T; s(T)
    while(T--)
    {
        fill(cnt, 0);
        xmap.clear();
        ymap.clear();
        s(n)
        REP(i, n)
        {
            s(x[i]) s(y[i])
            a[i].XX = x[i];
            a[i].YY = y[i];
            a[i].ZZ = i;
        }
        int xcnt = 0;
        sort(x, x+n);
        REP(i, n) if(i == 0 || x[i] != x[i-1]) xmap[x[i]] = xcnt++;
        int ycnt = 0;
        sort(y, y+n);
        REP(i, n) if(i == 0 || y[i] != y[i-1]) ymap[y[i]] = ycnt++;
        REP(i, n)
        {
            a[i].XX = xmap[a[i].XX];
            a[i].YY = ymap[a[i].YY];
        }
        go(0);
        REP(i, n) a[i].XX = xcnt - 1 - a[i].XX;
        go(1);
        REP(i, n) a[i].YY = ycnt - 1 - a[i].YY;
        go(2);
        REP(i, n) a[i].XX = xcnt - 1 - a[i].XX;
        go(3);
        LL ans = 0LL;
        REP(i, n)
        {
            //cout << cnt[0][i] << " " << cnt[1][i] << " " << cnt[2][i] << " " << cnt[3][i] << endl;
            ans = (ans + (LL) cnt[0][i]*cnt[2][i]);
            ans = (ans + (LL) cnt[1][i]*cnt[3][i]);
        }
        //cout << "ans ---------------- :O  ------- " << ans << endl;
        fill(xt, 0); fill(yt, 0);
        REP(i, n) xt[a[i].XX]++;
        REP(i, n) yt[a[i].YY]++;
        REP(i, xcnt) ans = (ans - (LL) xt[i]*(xt[i]-1)*(xt[i]-2)/6);
        REP(i, ycnt) ans = (ans - (LL) yt[i]*(yt[i]-1)*(yt[i]-2)/6);
        printf("%lld\n", ans<<1);
    }
}


#include <cstdio>
#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <memory.h>
#include <utility>
#include <queue>
#include <algorithm>
#include <cmath>
#include <map>
#include <set>
#include <ctime>
using namespace std;
 
#define mp make_pair
#define pb push_back
#define sz(a) int((a).size())
#define forn(i, n) for (int i=0; i<(n); ++i)
 
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
 
const int maxn = 505;
const int maxm = 5000000;
const int inf = 1000000000;
 
 
vector<pii> g[maxn];
int cap[maxm], cost[maxm];
int V, E;
 
inline void add(int x, int y, int ca, int co)
{
  cap[E] = ca, cost[E] = co, g[x].pb(mp(y, E++));
  cap[E] = 0, cost[E] = -co, g[y].pb(mp(x, E++));
}
 
int d[maxn], p[maxn], pe[maxn];
int u[maxn];
vector<int> q, nq;
int n, m;
 
bool bf(int S, int T)
{
  forn (i, V) d[i] = inf, u[i] = 0, p[i] = -1;
  q.clear();
  d[S] = 0;
  q.pb(S);
  for (int it=1; !q.empty(); ++it)
  {
    nq.clear();
    forn (i, sz(q))
    {
      int x = q[i];
      forn (j, sz(g[x]))
      {
        int y = g[x][j].first, e = g[x][j].second;
        if (d[y] > d[x]+cost[e] && cap[e] > 0)
        {
          d[y] = d[x]+cost[e];
          p[y] = x, pe[y] = e;
          if (u[y] != it)  u[y] = it, nq.pb(y);
        }
      }
    }
    q = nq;
  }
  return d[T] != inf;
}
 
int mcmf(int S, int T)
{
  int flow = 0, res = 0;
  while (bf(S, T))
  {
    int push = inf;
    for (int x=T; p[x]!=-1; x=p[x])
      push = min(push, cap[pe[x]]);
    flow += push;
    for (int x=T; p[x]!=-1; x=p[x])
      res += cost[pe[x]] * push, cap[pe[x]] -= push, cap[pe[x]^1] += push;
  }
  if (flow != n) return -1;
  return res;
}
 
int main()
{
  int tc; scanf("%d", &tc);
  while (tc--)
  {
    scanf("%d %d", &n, &m);
    V = 2*n+2;
    int S = V-2, T = V-1;
    E = 0;
    forn (i, V) g[i].clear();
    forn (i, m)
    {
      int x, y, z; scanf("%d %d %d", &x, &y, &z);
      --x, --y;
      add(x, y+n, 1, z);
    }
    forn (i, n)
    {
      add(S, i, 1, 0);
      add(i+n, T, 1, 0);
    }
    int res = mcmf(S, T);
    if (res == -1) puts("Impossible");
    else printf("%d\n", res);
  }
 
 
  return 0;
} 
/* Author: Karlheinz Jung */
/* Compiler: Borland Turbo C 2.01 */
/* Computer: Rabbit 286 */
/* Problem: Leaky containers (IOPC1107) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define LL long long
#define ULL unsigned long long
#ifndef ONLINE_JUDGE
	#define buffer_size 1000
#else
	#define buffer_size 200000000
#endif
#define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;}
#define MI(a,b) a<b?a:b

char pq1[buffer_size];
char *ez1;

int sint(){int wq1=1,wq2=0;_T}
long slong(){long wq1=1,wq2=0;_T}
LL sLL(){LL wq1=1,wq2=0;_T}
ULL sULL(){ULL wq1=1,wq2=0;_T}
int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;}

int R, C, m, n, d, X, Y, tot, temp, out;
int r[25], c[25], br[105], bc[105];

void dfs(int z)
{
int i;
if(tot<out)
	{
	if(z==n)
		{
		if(tot>=n+m)
			{
			out=tot;
			}
		else
			{
			for (i=0; i<=R-X; i++)
				{
				temp=tot+i*(C-Y);
				if(temp>=n+m)
					{
					out=MI(out,temp);
					}
				else
					{
					temp+=((n+m-temp+(R-X-i)-1)/(R-X-i))*(R-X-i);
					out=MI(out,temp);
					}
				}
			}
		}
	else
		{
		if(br[r[z]])
			{
			br[r[z]]=0;
			X++;
			tot+=C-Y;
			dfs(z+1);
			br[r[z]]=1;
			X--;
			tot-=C-Y;
			}
		else
			{
			dfs(z+1);
			}
		if(bc[c[z]])
			{
			bc[c[z]]=0;
			Y++;
			tot+=R-X;
			dfs(z+1);
			bc[c[z]]=1;
			Y--;
			tot-=R-X;
			}
		else
			{
			dfs(z+1);
			}
		}
	}
}


void losen()
{
int i;
R=sint();
C=sint();
n=sint();
m=sint();
for(i=0; i<n; i++)
	{
	r[i]=sint();
	c[i]=sint();
	d=sint();
	}
X=Y=tot=0;
out=10000;
memset(br,1,sizeof(br));
memset(bc,1,sizeof(bc));
dfs(0);
printf("%d\n",out);
}

int main()
{
int fall;
if(fread(pq1,1,sizeof(pq1),stdin));
ez1=pq1;
for(fall=sint(); fall--; losen());
return 0;
}

#include <stdio.h>
#define max 1000000 
#define MOD 100000007

int main()
{
int fall, t, i;
long N, F[max+1];

for(t=1; t<=max; F[t++]=1);
for(t=2; t<=max/2; t++)
	for(i=t; i+t<= max;)
		{
		F[i+=t]+=F[i-t];
		if(F[i]>=MOD)
			F[i]-=MOD;
		}
for(scanf("%d",&fall); fall--; scanf("%ld", &N), printf("%ld\n", F[N]));

return 0;
}

/* Author: Karlheinz Jung */
/* Compiler: Borland Turbo C 2.01 */
/* Computer: Rabbit 286 */
/* Problem: Move the books (IOPC1109) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <stdbool.h>

#define LL long long
#define ULL unsigned long long
#ifndef ONLINE_JUDGE
	#define buffer_size 1000
#else
	#define buffer_size 20000000
#endif
#define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;}
#define qs_auf(feld,laenge) qs_fkt(feld,laenge,sizeof(feld[0]),0)
#define qs_ab(feld,laenge) qs_fkt(feld,laenge,sizeof(feld[0]),1)
#define MA(a,b) (((a)>(b))?(a):(b))
#define MI(a,b) (((a)<(b))?(a):(b))

char pq1[buffer_size];
char *ez1;

int sint(){int wq1=1,wq2=0;_T}
long slong(){long wq1=1,wq2=0;_T}
LL sLL(){LL wq1=1,wq2=0;_T}
ULL sULL(){ULL wq1=1,wq2=0;_T}
int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;}

int comparator_auf(const void *elem1, const void *elem2){return(*(int*)elem1-*(int*)elem2);}
int comparator_ab(const void *elem1, const void *elem2){return(*(int*)elem2-*(int*)elem1);}
void qs_fkt(void *feld, int laenge, int size_element, int richtung)
{
if(!richtung)
	qsort(feld,laenge,size_element,comparator_auf);
else
	qsort(feld,laenge,size_element,comparator_ab);
}

void losen()
{
int n=sint(), k=sint(), i=-1, a, o=1, s=0;
while(++i<n)
	{
	a=sint();
	if((i&1)==(n&1)) s^=a-o;
	o=a;
	}
if(!(!s||k<s)) k++;
printf("%d %d\n",k,s^k);
}

int main()
{
int fall;
if(fread(pq1,1,sizeof(pq1),stdin));
ez1=pq1;
for(fall=sint(); fall--; losen());
return 0;
}

#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<sstream>
#include<string>
#include<string.h>
#include<deque>
#include<vector>
#include<stack>
#include<queue>
#include<math.h>
#include<map>
#include<set>

using namespace std;

typedef long long LL;
typedef pair<int,int> pii;

double PI = acos(-1);
double EPS = 1e-7;
int INF = 1000000000;
int MAXINT = 2147483647;
LL INFLL = 1000000000000000000LL;
LL MAXLL = 9223372036854775807LL;

#define fi first
#define se second
#define mp make_pair
#define pb push_back

#define SIZE(a) (int)a.size()
#define ALL(a) a.begin(),a.end()
#define RESET(a,b) memset(a,b,sizeof(a))
#define FOR(a,b,c) for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a,b,c) for (int (a)=(b); (a)>=(c); (a)--)
#define FORIT(a,b) for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); (a)++)
#define MIN(a, b) (a) = min((a), (b))
#define MAX(a, b) (a) = max((a), (b))
#define PAUSE system("pause")

#define input(in) freopen(in,"r",stdin)
#define output(out) freopen(out,"w",stdout)

pii M[8] = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1),mp(-1,1),mp(-1,-1),mp(1,-1),mp(1,1)};

/*\   \
\   \*/


LL A[50009],P[50009],C,N;

int main()
{
	LL t;
	scanf("%lld",&t);
    while(t--)
    {
    	A[0]=0;
    	scanf("%lld%lld",&N,&C);
    	for(LL i=1;i<=N;i++)
    	{
    		scanf("%lld",&A[i]);
   		}
   		for(LL i=0;i<N;i++)
    	{
    		scanf("%lld",&P[i]);
   		}
   		P[N]=0;
   		
   		LL total =0,fuel=0;
   		FOR(now,0,N-1)
        {
        	LL k = now+1,buy=now;
        	LL dist = A[now+1]-A[now];
        	LL base = dist;
        	while( k<N && C >= base )
        	{
        		if(P[k]<=P[now]) break;
       			base += A[k+1]-A[k];
        		k++;
        	}
        	
        		
        	if( C < base )
       	 		base=C;
 	 		
 	 		base -= fuel;

 	 		if(base>0)
 	 		{
        		total += P[buy]*base;
   		        fuel = base + fuel - dist;
   		    }
   		    else fuel -= dist;
        }
      
       
        printf("%lld\n",total);
    }
}
/* Author: Karlheinz Jung */
/* Compiler: Borland Turbo C 2.01 */
/* Computer: Rabbit 286 */
/* Problem: Giant fountain (IOPC1111) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define LL long long
#define ULL unsigned long long
#ifndef ONLINE_JUDGE
	#define buffer_size 1000
	#define siz 1000
#else
	#define buffer_size 200000000
	#define siz 30005
#endif
#define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;}

char pq1[buffer_size];
char *ez1;

int sint(){int wq1=1,wq2=0;_T}
long slong(){long wq1=1,wq2=0;_T}
LL sLL(){LL wq1=1,wq2=0;_T}
ULL sULL(){ULL wq1=1,wq2=0;_T}
int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;}

int comparator(const void *elem1, const void *elem2){return(*(int*)elem1-*(int*)elem2);}
void qs(int *feld, int laenge){qsort(feld,laenge,sizeof(int),comparator);}

int w2;
int S[siz];

int A(int z)
{
int mi=0, mid, ma=w2-1;
while(mi<=ma)
	{
	if(S[mid=(mi+ma)>>1]==z) return mid;
	if(S[mid]<z)
		mi=mid+1;
	else
		ma=mid-1;
	}
}

void losen()
{
int n, k, m, w1=1, r, i=0;
int l[siz], c[siz], s[siz], e[siz], w[siz];
LL sum, temp, o1, o2;
LL a[siz];
for(n=sint(),k=sint(),m=sint(),l[0]=S[0]=0; ++i<=k; l[i]=sint(),c[i]=sint(),l[i]+=l[i-1],S[w1++]=l[i]);
for(i=-1; ++i<m; s[i]=sint(),e[i]=sint(),w[i]=sint(),s[i]--,S[w1++]=s[i],S[w1++]=e[i]);
for(qs(S,w1),i=w2=1; i<w1; i++)
	if(S[i]!=S[i-1]) S[w2++]=S[i];
for(i=-1; ++i<=k; l[i]=A(l[i]));
for(i=0; i<w2; a[i++]=0);
for(i=-1; ++i<m; s[i]=A(s[i]),e[i]=A(e[i]),a[s[i]]+=w[i],a[e[i]]-=w[i]);
for(sum=a[o1=o2=0],i=r=1; i<w2; i++)
	{
	if(sum>=c[r])
		{
		o2+=S[i]-S[i-1];
		o1+=(S[i]-S[i-1])*(sum-c[r]);
		}
	else
		{
		temp=o1/(c[r]-sum);
		if(temp>=S[i]-S[i-1])
			{
			o2+=S[i]-S[i-1];
			o1-=(S[i]-S[i-1])*(c[r]-sum);
			}
		else
			{
			o2+=temp;
			o1=0;
			}
		}
	r+=(l[r]==i);
	sum+=a[i];
	}
printf("%lld %lld\n",o1,o2);
}

int main()
{
int fall;
if(fread(pq1,1,sizeof(pq1),stdin));
ez1=pq1;
for(fall=sint(); fall--; losen());
return 0;
}

#include <stdio.h>
#include <string.h>
#define siz 410
#define MOD 100000007
#define S(a,b) memset(a,b,sizeof(a))
#define T(a) a[kn][k][w]=a[kn][k][1-(w)]
#define U(a) for(k=-1;++k<=K;sum%=MOD,a[kn][k][w]=(int)sum)
#define V(a) for(l=-!(sum=0); ++l<=k; sum+=(long long)a)

int N, R, K, gr[siz], el[siz], ja[siz][siz][2], ne[siz][siz][2], li[siz][siz], be[siz];

int g(int kn)
{
int v, k, l, ad=1, w=1;
long long sum;
for(k=!(be[kn]=ne[kn][0][0]=ja[kn][0][0]=1); ++k<=K; ne[kn][k][0]=ja[kn][k][0]=0);
for(; ad<=gr[kn]; ad++,w=1-w)
	{
	if((v=li[kn][ad-1])==el[kn])
		{
		for(k=-1; ++k<=K; T(ja),T(ne));
		continue;
		}
	if(!be[v])
		g(v);
	U(ja)
		{
		V(ja[kn][k-l][1-(w)]*ja[v][l][gr[v]&1]);
		for(l=-1; ++l<=k-1; sum+=(long long)ne[kn][k-l-1][1-(w)]*ne[v][l][gr[v]&1]);
		}
	U(ne)
		V(ja[v][l][gr[v]&1]*ne[kn][k-l][1-(w)]);
	}
return ja[kn][K][gr[kn]&1];
}

main()
{
int fall, x, y, i, qf, qb, u, v, q[400];;
for(scanf("%d",&fall); fall--;)
	{
	for(i=-(!!scanf("%d %d %d",&N,&R,&K)),S(gr,0),S(el,-1),S(be,0),S(ja,0),S(ne,0),S(li,-1); ++i<R; scanf("%d %d",&x,&y),li[x][gr[x]++]=y,li[y][gr[y]++]=x);
	for(el[1]=!(qf=qb=0),q[qb++]=1; qf<qb;)
		for(u=q[qf++]+(i=0); i<gr[u]; i++)
			if((v=li[u][i])!=el[u])
				el[q[qb++]=v]=u;
	g(1);
	printf("%d\n", ja[1][K][gr[1]&1]);
	}
return 0;
}

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>
#include <cmath>
#include <set>
#include <ctime>
#include <algorithm>
#define min(a,b)	((a)<(b)?(a):(b))
#define max(a,b)	((a)>(b)?(a):(b))
#define abs(a)	((a)<0?-(a):(a))
#define inf 214748364
#define pi 3.141592653589793
#define maxn 1010
#define maxm 30001
using namespace std;
typedef long long ll;
int con,st[maxm],en[maxm],next[maxm];
int fir[maxn];
int ma[maxm],l[maxm],t[maxm];
double v[maxm];
int n,m;
double f[maxn];
//int g[maxn];
int head,tail,q[1000001];
inline void addline(int st,int en,double inpv)
{
	next[++con]=fir[st],fir[st]=con;
	t[con]=en,v[con]=inpv;
}
inline bool check(double ans)
{
	memset(fir,0,sizeof(fir));
	con=0;
	for(int i=1;i<=m;++i)
		addline(st[i],en[i],ma[i]-l[i]*ans);
	memset(f,127,sizeof(f));
	f[1]=0;
	q[head=tail=0]=1;
	while(head<=tail)
	{
		int p=q[head++];
		for(int i=fir[p];i;i=next[i])
		if(f[t[i]]>f[p]+v[i])
		{
			f[t[i]]=f[p]+v[i];
			q[++tail]=t[i];
//			g[t[i]]++;
			if(f[n]<=0)
				return 1;
		}
	}
	return f[n]<=0;
}
int main()
{
	int tim;
	scanf("%d",&tim);
	while(tim--)
	{
		scanf("%d%d",&n,&m);
		if(n<=1)
		{
			printf("0.0000\n");
			continue;
		}
		for(int i=1;i<=m;++i)
		{
			scanf("%d%d%d%d",&st[i],&en[i],&ma[i],&l[i]);
			if(ma[i]<=60)
				ma[i]=l[i]*(70-ma[i]);else
				ma[i]=l[i]*10;
		}
		double low=0,high=1e4,mid;
		while(high-low>1e-6)
		{
			mid=(low+high)/2.0;
			if(check(mid))
				high=mid;else
				low=mid;
		}
		printf("%.4lf\n",low+0.0000499999999);
//		printf("%.4lf\n",low);
	}
	return 0;
}

import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	static Scanner in;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int n = ni();
		int[][] mat = new int[21][21];
		String map = "BCDFGHJKLMNPQRSTVWXYZ";
		for(int i = 0;i < n;i++){
			String line = in.next();
			int h = map.indexOf(line.charAt(0));
			int t = map.indexOf(line.charAt(line.length()-1));
			mat[h][t]++;
		}
		
		out.println(permanent(mat));
	}
	
	static int MOD = 100000007;
	
	public static long permanent(int[][] A)
	{
		int n = A.length;
		long[] dp = new long[1<<n];
		dp[0] = 1;
		for(int i = 0;i < 1<<n;i++){
			for(int j = 0;j < n;j++){
				if((i&(1<<j))==0){
					dp[i|(1<<j)] += dp[i]*A[Integer.bitCount(i)][j];
					dp[i|(1<<j)] %= MOD;
				}
			}
		}
		return dp[(1<<n)-1];
	}
	
	public static void main(String[] args) throws Exception
	{
		in = INPUT.isEmpty() ? new Scanner(System.in) : new Scanner(INPUT);
		out = new PrintWriter(System.out);

			solve();
		out.flush();
	}
	
	static int ni() { return Integer.parseInt(in.next()); }
	static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include<vector>
#include<stack>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<string>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<string>
 
using namespace std;
 
#define s(n)                                 scanf("%d",&n)
#define sl(n)                                   scanf("%lld",&n)
#define sf(n)                                   scanf("%lf",&n)
 
#define EPS                                             1e-9
 
#define FOR(i,a,b)                              for(int i=a;i<b;i++)
#define REP(i,n)                                FOR(i,0,n)
#define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)
 
#define mp                                              make_pair
#define pb                                              push_back
 
#define FF                                              first
#define SS                                              second
 
#define tri(a,b,c)                              mp(a,mp(b,c))
#define XX                                              first
#define YY                                              second.first
#define ZZ                                              second.second
 
/*Important ones*/
#define fill(a,v)                               memset(a,v,sizeof a)     //Works properly only for v = 0 or -1
#define all(x)                                  x.begin(),x.end()
 
#define SZ(v)                                   ((int)(v.size()))
#define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end())
#define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())
 
//typedefs. Use if you feel comfortable
typedef pair<int,int> PII;
typedef pair<long long,long long> PLL;
typedef pair<int,PII> TRI;

typedef vector<int> VI;
typedef long long LL;
typedef vector<LL> VL;
typedef vector<PII> VII;
typedef vector<PLL> VLL;
typedef vector<TRI> VT;
 
typedef vector<VI> VVI;
typedef vector<VL> VVL;
typedef vector<VII> VVII;
typedef vector<VLL> VVLL;
typedef vector<VT> VVT;

#define MAX 305 
#define INF 1e9

int N, M, P, C, rech[MAX], adm[MAX][MAX];

int main(){
	
	int X, Y, T;
	
	s(N);	s(M);	s(P);	s(C);
	FOR(i,0,P){
		s(T);
		rech[T] = 1;
	}
	rech[N-1] = rech[0] = 1;
	FOR(i,0,N)
		FOR(j,0,N)
			adm[i][j] = INF;
	FOR(i,0,M){
		s(X);	s(Y);	s(T);
		adm[X][Y] = adm[Y][X] = T;
	}
	FOR(k,0,N)
		FOR(i,0,N)
			FOR(j,0,N)
				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]);
	FOR(i,0,N)
		FOR(j,0,N)
			if(adm[i][j] > C || !rech[i] || !rech[j])
				adm[i][j] = INF;
	FOR(k,0,N)
		FOR(i,0,N)
			FOR(j,0,N)
				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]);
	if(adm[0][N-1] == INF)
		cout<<-1<<endl;
	else
		cout<<adm[0][N-1]<<endl;
	
	return 0;
	
}

/*takes two integers N and M and tries to find twice the sum of the quotients of the integer division of (i * N) by M varying i from 0 to M-1 both included. But as he started computing the sums for larger values of M and N, things started becoming very complex. So he has asked for your help. You need to output the sum that Bob needs.
Input

The first line of the input contains an integer T denoting the number of test cases.
Saurav Shekhar(sauravshekhar01@gmail.com)
IOPC 2013*/

#include<stdio.h>

long long int gcd(long long int a, long long int b)
{	long long int c;
	c = a%b;
	while(c)
	{	//printf("a = %d,b = %d\n",a,b);
		a = b;
		b = c;
		c = a%b;
	}
	//printf("gcd = %d\n",b);
	return b;
}

int main()
{	
	int T;
	long long int M,N,k=0;
	long long int sum = 0;
	scanf("%d",&T);
	while(T--)
	{
		k=0; sum=0;
		scanf("%lld %lld",&M,&N);	//printf("%d\n",M);
		if(M>N)
			k = gcd(M,N);
		else
			k = gcd(N,M);
		sum = M*N -M -N + k ;
		printf("%lld\n",sum);
	}
	return 0;
}

#include <cstdio>
#include <algorithm>
#include<iostream>
using namespace std;

#define S(x) scanf("%d",&x)

int main()
{
    int t,n,x,y;
    S(t);
    while(t--)
    {
        S(n);
        int a[n],b[n];
        for(int i=0;i<n;i++)
        {
            a[i]=0;
            b[i]=0;
        }    
        int r1,r2;
        S(r1);
        for(int i=0;i<n-1;i++)
        {
            S(x);S(y);
            a[x]++;a[y]++;
        }
        S(r2);
        for(int i=0;i<n-1;i++)
        {
            S(x);S(y);
            b[x]++;b[y]++;
        }
        int ans1=a[r1],ans2=b[r2];
        if(ans1!=ans2)putchar('0');
        else
        {
        	std::sort(a,a+n);
            std::sort(b,b+n);
			bool flag=false;
            for(int i=0;i<n;i++)
            {
                if(a[i]!=b[i])
                {
                    flag=true;
                    break;
                }
            }
            if(flag==false)putchar('1');
            else putchar('0');
        }
        putchar(10);
    }
}
#include<stdio.h>
int main()
{
	int t,n;
	scanf("%d",&t);
	for(t;t>0;t--)
	{
		scanf("%d",&n);
		if(n%2==0 || n%3==0)
		printf("YES\n");
		else
		printf("NO\n");
	}
	return 0;
}
import java.awt.geom.Line2D;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int n = ni();
		int[][] coj = new int[n][];
		int[][] cod = new int[n][];
		for(int i = 0;i < n;i++){
			coj[i] = new int[]{ni(), ni()};
		}
		for(int i = 0;i < n;i++){
			cod[i] = new int[]{ni(), ni()};
		}
		int[][] g = new int[n][n];
		for(int i = 0;i < n;i++){
			double[][] co = new double[n-1][];
			int p = 0;
			for(int j = 0;j < n;j++){
				if(j != i){
					co[p++] = new double[]{coj[j][0], coj[j][1]};
				}
			}
			double[][] hull = convexHull(co);
			for(int j = 0;j < n;j++){
				if(isOnIn(cod[j][0], cod[j][1], hull)){
					g[i][j] = Math.abs(cod[j][0]-coj[i][0])+Math.abs(cod[j][1]-coj[i][1]);
				}else{
					g[i][j] = 
							(cod[j][0]-coj[i][0])*(cod[j][0]-coj[i][0]) +
							(cod[j][1]-coj[i][1])*(cod[j][1]-coj[i][1]);
				}
			}
			tr(g[i]);
		}
		out.println(hungarianMax(g));
	}
	
	public static int hungarianMax(int[][] w)
	{
		int n = w.length;
		int INF = 2000000*400;
		int[] fx = new int[n];
		int[] fy = new int[n];
		int[] x = new int[n];
		int[] y = new int[n];
		Arrays.fill(x, -1);
		Arrays.fill(y, -1);
		for(int i = 0;i < n;i++){
			for(int j = 0;j < n;j++){
				fx[i] = Math.max(fx[i], w[i][j]);
			}
		}
		
		int[] t = new int[n];
		int[] s = new int[n+1];
		outer:
		for(int i = 0;i < n;){
			Arrays.fill(t, -1);
			s[0] = i;
			int q = 0;
			for(int p = 0;p <= q;p++){
				for(int k = s[p], j = 0;j < n;j++){
					// if exist in N(S)-T
					if(fx[k] + fy[j] == w[k][j] && t[j] < 0){
						// add to S,T
						s[++q] = y[j];
						t[j] = k;
						if(s[q] < 0){
							// augment path
							for(p = j;p >= 0;j = p){
								y[j] = k = t[j];
								p = x[k];
								x[k] = j;
							}
							i++;
							continue outer;
						}
					}
				}
			}
			// Improve Labelling
			int d = INF;
			for(int j = 0;j < n;j++){
				if(t[j] < 0){
					for(int k = 0;k <= q;k++){
						d = Math.min(d, fx[s[k]] + fy[j] - w[s[k]][j]);
					}
				}
			}
			for(int j = 0;j < n;j++){
				if(t[j] >= 0)fy[j] += d;
			}
			for(int k = 0;k <= q;k++){
				fx[s[k]] -= d;
			}
		}
		
		int ret = 0;
		for(int i = 0;i < n;i++){
			ret += w[i][x[i]];
		}
		return ret;
	}	
	
	public static boolean isOnIn(double x, double y, double[][] poly){
		int n = poly.length;
		int cc = Line2D.relativeCCW(poly[n-1][0], poly[n-1][1], poly[0][0], poly[0][1], x, y);
		if(cc == 0)return true;
		for(int i = 0;i < n-1;i++){
			int ccc = Line2D.relativeCCW(poly[i][0], poly[i][1], poly[i+1][0], poly[i+1][1], x, y);
			if(ccc == 0)return true;
			if(cc != ccc)return false;
		}
		return true;
	}
	
	public static double[][] convexHull(double[][] co)
	{
		int n = co.length;
		Arrays.sort(co, new Comparator<double[]>(){
			public int compare(double[] a, double[] b){
				if(a[0] - b[0] != 0)return (int)Math.signum(a[0] - b[0]);
				return (int)Math.signum(a[1] - b[1]);
			}
		});
		
		int[] inds = new int[n + 1];
		int p = 0;
		for(int i = 0;i < n;i++){
			if(p >= 1 && co[inds[p-1]][0] == co[i][0] && co[inds[p-1]][1] == co[i][1])continue;
			while(p >= 2 && Line2D.relativeCCW(
					co[inds[p-2]][0], co[inds[p-2]][1],
					co[inds[p-1]][0], co[inds[p-1]][1],
					co[i][0], co[i][1]) == 1)p--;
			inds[p++] = i;
		}
		
		int inf = p + 1;
		for(int i = n - 2;i >= 0;i--){
			if(co[inds[p-1]][0] == co[i][0] && co[inds[p-1]][1] == co[i][1])continue;
			while(p >= inf && Line2D.relativeCCW(
					co[inds[p-2]][0], co[inds[p-2]][1],
					co[inds[p-1]][0], co[inds[p-1]][1],
					co[i][0], co[i][1]) == 1)p--;
			inds[p++] = i;
		}
		
		double[][] ret = new double[p-1][];
		for(int i = 0;i < p-1;i++)ret[i] = co[inds[i]];
		return ret;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include <cstdio>
#include <vector>
#include <queue>
using namespace std;

vector <int> adj[100000];
int degree[100000]={0};

void solve(int vertices,int lim)
{
	int vertex;
	queue <int> store;
	for(int i=0;i<vertices;i++)
		if(degree[i]<lim)
		{
			degree[i]=0;
			store.push(i);
		}
	while(!store.empty())
	{
		vertex=store.front();
		store.pop();
		degree[vertex]=0;
		for(int i=0;i<adj[vertex].size();i++)
			if(degree[adj[vertex][i]])
			{
				degree[adj[vertex][i]]--;
				if(degree[adj[vertex][i]]!=0 && degree[adj[vertex][i]]<lim)
					store.push(adj[vertex][i]);
			}
	}
}

int main()
{
	int vertices,edges,lim,x,y;
	scanf("%d %d %d",&vertices,&edges,&lim);
	for(int i=0;i<edges;i++)
	{
		scanf("%d %d",&x,&y);
		adj[x].push_back(y);
		adj[y].push_back(x);
		degree[x]++;
		degree[y]++;
	}
	solve(vertices,lim);
	int cnt=0;
	for(int i=0;i<vertices;i++)
		if(degree[i])
			cnt++;
	printf("%d\n",cnt);
	return 0;
}
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<stack>
#include<string>
#include<cctype>
#include<list>
#include<set>
#include<deque>
#include<queue>
#include<bitset>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<ctime>
 
using namespace std;
 
long long int  prime[100000];
long long int p[10000],j;long long int m,MOD=1000000007;
long long power(long int a,long long int b)
{
	long long x=1,y=a; 
	while(b > 0)
	{
		if(b%2 == 1)
		{
			x=(x*y);
			if(x>m) x%=m;
		}
		y = (y*y);
		if(y>m) y%=m; 
		b /= 2;
	}
	return x;
}
 
int main()
{
    long long int i,c,t,n,hcf;c=0;m=MOD;
    long long int ans,curr,y,k,p1;
    long long int lcm[100005];
    for(i=0;i<100000;i++)prime[i]=0;
    for(j=2;j+j<100000;j+=1) prime[2*j]=1;
    for(i=3;i<3200;i+=2)
    {
                             
          if(prime[i]==1) continue;
          for(j=i;i*j<100000;j+=2) prime[i*j]=1;
    }
  j=0;
  for(i=2;i<100000;i++) {if(prime[i]==0){ p[j]=i;j++;}}
  lcm[0]=1;
  lcm[1]=1;
  for(i=2;i<100002;i++)
  {                    t=i;
                       if(!prime[i])lcm[i]=(lcm[i-1]*i)%m;
                       else
                       {c=0;
             for(k=0;(p[k]*p[k]<=t)&&(k<j);k++)
             {
                                      if(i%p[k]==0){p1=p[k];c++;while(i%p[k]==0){i=i/p[k];}}
                                      if(c>=1)break;
             }
                                      if((c==1)&&(i==1))lcm[t]=(lcm[t-1]*p1)%m;
                                      else lcm[t]=lcm[t-1];
                                      }
                                      
                                      i=t;
}
                                                
  /*for(i=0;i<10;i++)printf("%lld ",lcm[i]);*/
  scanf("%lld",&t);
  while(t--)
  {
            scanf("%lld",&n);n++;
            /*for(i=0;(i<j)&&(p[i]<=n);i++)
            {
                                      curr=0;c=p[i];
                                      while(c<=n)
                                      {
                                           curr++;
                                           c=c*p[i];
                                      }
                                      y=p[i];//printf("%lld ",curr); 
	while(curr > 0)
	{
		if(curr%2 == 1)
		{
			ans=(ans*y);
			if(ans>m) ans%=m;
		}
		y = (y*y);
		if(y>m) y%=m; 
		curr /= 2;
	}
             }*/
                 
            ans=lcm[n];
            ans=(ans*power(n,m-2))%m;        
            printf("%lld\n",ans);
  

}
                                                   
                                                 
            
            
  
  
            return 0;
  
 }

#include <cstdio>
#include <cstring>
#include <queue>

int M, N, C, D;
int dp[102*100*100*10];

char map[102][101][10];

inline int encrypt(int n, int c, int r, int d){
    return ((n * C + c) * C + r) * D + d;
}

inline void decrypt(int &n, int &c, int &r, int &d, int val){
    d = val % D; val /= D;
    r = val % C; val /= C;
    c = val % C; val /= C;
    n = val;
}

void go(int n, int c, int r, int d, int val, std::queue<int>& que){

    int obc = (n == 0 || n == N + 1)? c: ((((n + d) & 1)? c + r: c - r) + C) % C;
    if(map[n][obc][d] == 'X') return;

    int idx = encrypt(n, c, r, d);
    if(dp[idx] == -1) dp[idx] = val, que.push(idx);

}

int main(){

    scanf("%d %d %d %d\n" ,&M ,&N ,&C ,&D);

    memset(dp, -1, sizeof(dp));

    for(int i = 0; i < D; i++){
        for(int j = 0; j < N+2; j++){
            static char buf[200]; gets(buf);
            for(int k = 0; k < C; k++) map[j][k][i] = buf[k];
        }
    }

    int st, ed;
    for(int c = 0; c < C; c++){
        for(int d = 0; d < D; d++){
            if(map[0][c][d] == 'S') st = encrypt(0, c, 0, d);
        }
    }

    int ans = -1;
    dp[st] = 0;
    std::queue<int> que; que.push(st);
    while(!que.empty()){

        int n, c, r, d, idx;
        idx = que.front(); que.pop();
        if(dp[idx] > M) break;

        decrypt(n, c, r, d, idx);
        if(map[n][c][d] == 'D'){
            ans = dp[idx];
            break;
        }

        int nr = (r + 1) % C, stp = dp[idx] + 1;
        if(n > 0) go(n - 1, c, nr, d, stp, que);
        if(n < N + 1) go(n + 1, c, nr, d, stp, que);
        if(c > 0) go(n, c - 1, nr, d, stp, que);
        if(c < C - 1) go(n, c + 1, nr, d, stp, que);
        if(d > 0) go(n, c, nr, d - 1, stp, que);
        if(d < D - 1) go(n, c, nr, d + 1, stp, que);
        go(n, c, nr, d, stp, que);

    }

    printf("%d\n" ,ans);

}
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		for(int T = ni();T >= 1;T--){
			int n = ni(), m = ni(), s = ni(), e = ni();
			double[][] g = new double[n][n];
			double[] w = new double[n];
			for(int i = 0;i < m;i++){
				int f = ni(), t = ni(), lw = ni();
				g[f][t]++;
				g[t][f]++;
				g[f][f]--;
				g[t][t]--;
				w[f] -= lw;
				w[t] -= lw;
			}
			for(int i = 0;i < n;i++){
				g[i][e] = 0;
			}
			for(int i = 0;i < n;i++){
				if(g[i][i] == 0)g[i][i] = 1;
			}
			g[e][e] = 1;
			w[e] = 0;
			
			out.printf("%.6f\n", solve(g, w)[s]);
		}
	}
	
	public static double[] solve(double[][] a, double[] c)
	{
		int n = a.length;
		int[] ps = new int[n];
		for(int i = 0;i < n;i++)ps[i] = i;
		
		// Forward Elimination
		for(int i = 0;i < n;i++){
			int pivot = -1;
			int from = -1;
			double amax = 0;
			for(int j = i;j < n;j++){
				if(Math.abs(a[ps[j]][i]) > amax){
					amax = Math.abs(a[ps[j]][i]);
					pivot = ps[j];
					from = j;
				}
			}
			if(pivot == -1)return null;
			int d = ps[i]; ps[i] = ps[from]; ps[from] = d;
			
			for(int j = i+1;j < n;j++){
				a[ps[i]][j] /= a[ps[i]][i];
			}
			c[ps[i]] /= a[ps[i]][i];
			a[ps[i]][i] = 1.0;
			for(int j = i+1;j < n;j++){
				for(int k = i+1;k < n;k++){
					a[ps[j]][k] -= a[ps[j]][i] * a[ps[i]][k];
				}
				c[ps[j]] -= a[ps[j]][i] * c[ps[i]];
				a[ps[j]][i] = 0.0;
			}
			
		}
		
		// Back Substitution
		for(int i = n-1;i >= 0;i--){
			for(int j = i-1;j >= 0;j--){
				c[ps[j]] -= a[ps[j]][i] * c[ps[i]];
			}
		}
		
		double[] ret = new double[n];
		for(int i = 0;i < n;i++){
			ret[i] = c[ps[i]];
		}
		
		return ret;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;
typedef pair<int, int> ii;
#define int_max 200000000000

#define LL long long
#define mp make_pair
#define pb push_back
LL gcd(LL m, LL n){
LL r; while (n != 0){ r=m%n; m=n; n=r;} return m; }

LL mod;

long long int expmod(int a,int b)
{
	long long int x=1,y=a;
	while(b>0)
	{
		if(b&1) x=(x*y)%mod;
		y=(y*y)%mod;
		b>>=1;
	}
	return x;
}
int main()
{
	int t;
	scanf("%d", &t);
	while(t--)
	{
		int n;
		scanf("%d", &n);
		mod=n*n;
		LL ans=expmod(2, n)+1;
		ans=ans%mod;
		printf("%lld\n", ans);
	}

	return 0;
}


#include<vector>
#include<stack>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<string>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<string>
 
using namespace std;
 
#define s(n)                                 scanf("%d",&n)
#define sl(n)                                   scanf("%lld",&n)
#define sf(n)                                   scanf("%lf",&n)
 
#define EPS                                             1e-9
 
#define FOR(i,a,b)                              for(int i=a;i<b;i++)
#define REP(i,n)                                FOR(i,0,n)
#define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)
 
#define mp                                              make_pair
#define pb                                              push_back
 
#define FF                                              first
#define SS                                              second
 
#define tri(a,b,c)                              mp(a,mp(b,c))
#define XX                                              first
#define YY                                              second.first
#define ZZ                                              second.second
 
/*Important ones*/
#define fill(a,v)                               memset(a,v,sizeof a)     //Works properly only for v = 0 or -1
#define all(x)                                  x.begin(),x.end()
 
#define SZ(v)                                   ((int)(v.size()))
#define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end())
#define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())
 
//typedefs. Use if you feel comfortable
typedef pair<int,int> PII;
typedef pair<long long,long long> PLL;
typedef pair<int,PII> TRI;

typedef vector<int> VI;
typedef long long LL;
typedef vector<LL> VL;
typedef vector<PII> VII;
typedef vector<PLL> VLL;
typedef vector<TRI> VT;
 
typedef vector<VI> VVI;
typedef vector<VL> VVL;
typedef vector<VII> VVII;
typedef vector<VLL> VVLL;
typedef vector<VT> VVT;

#define MAX 1010 
#define INF 1e9
#define DIST(i,j) (abs(X[i]-X[j])+abs(Y[i]-Y[j])+abs(Z[i]-Z[j]))
/*
struct node{
	int x, y, z, d;
	node(){}
	node(int X, int Y, int Z, int D){
		x = X;	y = Y;	z = Z;	d = D;
	}
};

bool operator < (node &a, node &b){
	return a.d>b.d;
}
*/
int N, X[MAX], Y[MAX], Z[MAX], pref[MAX], dp[MAX], ans;

int main(){
	
	int tests;
	
	s(tests);
	FOR(testcases,0,tests){
		s(N);
		FOR(i,0,N){
			s(X[i]);
			s(Y[i]);
			s(Z[i]);
			if(i)
				pref[i] = pref[i-1] + DIST(i-1,i);
			else
				pref[i] = 0;
		}
		dp[0] = 0;
		FOR(i,1,N)
			dp[i] = pref[i-1];
		FOR(i,2,N)
			FOR(j,1,i)
				dp[i] = min(dp[i], dp[j]+DIST(j-1,i)+pref[i-1]-pref[j]);
		ans = INF;
		FOR(i,1,N)
			ans = min(ans, dp[i]+pref[N-1]-pref[i]);
		printf("%d\n", ans);
	}
	
	return 0;
	
}

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		for(int T = ni();T >= 1;T--){
			int n = ni(), m = ni();
			int[][] pers = new int[n][];
			for(int i = 0;i < n;i++){
				pers[i] = new int[]{ni(), ni()};
			}
			int[][] jobs = new int[m][];
			for(int i = 0;i < m;i++){
				jobs[i] = new int[]{ni(), ni(), ni()};
			}
			int[] ends = new int[2*(n+m)];
			for(int i = 0;i < n;i++){
				ends[2*i] = pers[i][0];
				ends[2*i+1] = pers[i][1];
			}
			for(int i = 0;i < m;i++){
				ends[2*(n+i)] = jobs[i][0];
				ends[2*(n+i)+1] = jobs[i][1];
			}
			Arrays.sort(ends);
			
			int[] from = new int[2*(n+m)+2*(n+m)*m+m];
			int[] to = new int[2*(n+m)+2*(n+m)*m+m];
			int[] w = new int[2*(n+m)+2*(n+m)*m+m];
			// 0,2*(n+m) mid
			// 2*(n+m),2*(n+m)+m mid2
			// 2*(n+m)+m src
			// 2*(n+m)+m+1 sink
			int p = 0;
			for(int i = 0;i < 2*(n+m)-1;i++){
				if(ends[i+1]-ends[i] == 0)continue;
				int ct = 0;
				for(int j = 0;j < n;j++){
					if(pers[j][0] <= ends[i] && ends[i+1] <= pers[j][1]){
						ct++;
					}
				}
				
				from[p] = 2*(n+m)+m; to[p] = i; w[p] = ct*(ends[i+1]-ends[i]); p++;
				
				for(int j = 0;j < m;j++){
					int len = Math.min(jobs[j][1], ends[i+1]) - Math.max(jobs[j][0], ends[i]);
					if(len > 0){
						from[p] = i; to[p] = 2*(n+m) + j; w[p] = len; p++;
					}
				}
			}
			int all = 0;
			for(int j = 0;j < m;j++){
				from[p] = 2*(n+m)+j; to[p] = 2*(n+m)+m+1; w[p] = jobs[j][2]; p++;
				all += jobs[j][2];
			}
			int[][][] g = packWD(2*(n+m)+m+2, from, to, w, p);
			if(maximumFlowDinic(g, 2*(n+m)+m, 2*(n+m)+m+1) == all){
				out.println("YES");
			}else{
				out.println("NO");
			}
		}
	}
	
	public static int maximumFlowDinic(int[][][] g, int source, int sink)
	{
		int n = g.length;
		
		// unweighted invgraph
		int[] p = new int[n];
		for(int i = 0;i < n;i++){
			for(int j = 0;j < g[i].length;j++)p[g[i][j][0]]++;
		}
		int[][] ig = new int[n][];
		for(int i = 0;i < n;i++)ig[i] = new int[p[i]];
		for(int i = n-1;i >= 0;i--){
			for(int j = 0;j < g[i].length;j++){
				ig[g[i][j][0]][--p[g[i][j][0]]] = i;
			}
		}
		
		int[][] f = new int[n][n];
		int[] d = new int[n];
		int[] q = new int[n];
		int ret = 0;
		while(true){
			Arrays.fill(d, -1);
			q[0] = source;
			int r = 1;
			d[source] = 0;
			
			for(int v = 0;v < r;v++){
				int cur = q[v];
				// plus flow
				for(int[] ne : g[cur]){
					int nex = ne[0], w = ne[1];
					if(d[nex] == -1 && w - f[cur][nex] > 0) {
						q[r++] = nex;
						d[nex] = d[cur] + 1;
					}
				}
				// minus flow
				for(int nex : ig[cur]){
					if(d[nex] == -1 && -f[cur][nex] > 0) {
						q[r++] = nex;
						d[nex] = d[cur] + 1;
					}
				}
			}
			if(d[sink] == -1)break;
			int delta = 0;
			while((delta = dfsDinic(d, g, ig, f, source, sink, Integer.MAX_VALUE)) > 0){
				ret += delta;
			}
		}
		
		return ret;
	}
	
	public static int dfsDinic(int[] d, int[][][] g, int[][] ig, int[][] f, int cur, int t, int min)
	{
		if(cur == t){
			return min;
		}else{
			int left = min;
			for(int[] ne : g[cur]){
				int nex = ne[0], w = ne[1];
				if(d[nex] == d[cur]+1 && w-f[cur][nex] > 0){
					int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, w-f[cur][nex]));
					if(fl > 0){
						f[cur][nex] += fl;
						f[nex][cur] -= fl;
						left -= fl;
						if(left == 0)return min;
					}
				}
			}
			for(int nex : ig[cur]){
				if(d[nex] == d[cur]+1 && -f[cur][nex] > 0){
					int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, -f[cur][nex]));
					if(fl > 0){
						f[cur][nex] += fl;
						f[nex][cur] -= fl;
						left -= fl;
						if(left == 0)return min;
					}
				}
			}
			return min-left;
		}
	}
	
	public static int[][][] packWD(int n, int[] from, int[] to, int[] w, int sup)
	{
		int[][][] g = new int[n][][];
		int[] p = new int[n];
		for(int i = 0;i < sup;i++)p[from[i]]++;
		for(int i = 0;i < n;i++)g[i] = new int[p[i]][2];
		for(int i = 0;i < sup;i++){
			--p[from[i]];
			g[from[i]][p[from[i]]][0] = to[i];
			g[from[i]][p[from[i]]][1] = w[i];
		}
		return g;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include<stdio.h>
int call_maybe(int,int,int,int *);
int main()
{
    int n,q,u,i,x,y;
    scanf("%d%d",&n,&q);
    int arr[n];
    scanf("%d",&u);
    arr[u]=u;
    while(n-->1)
    {
        scanf("%d%d",&x,&y);
        arr[y]=x;
    }
      for(i=0;i<q;i++)
       {
        scanf("%d%d",&x,&y);
        if(call_maybe(x,y,u,arr))
            printf("1\n");
        else if(call_maybe(y,x,u,arr))
          printf("-1\n");
          else
            printf("0\n");
       }
       return 0;
}
int call_maybe(int x,int y,int u,int *arr)
{
    while((x!=u)&&(x!=y))
    {
        x=arr[x];
    }
    if(x==y)
        return 1;
    else
        return 0;
}

#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
#include<stack>
#include<queue>
#include<vector>
#include<algorithm>
#define MOD 1000000007
typedef long long LL ;
int fact[10000005] ;

int main(){
    int t,p,i,j;
    LL rem,n,quo,ans;
    fact[1] = 1;
    scanf("%d",&t);
    for(i=1;i<=t;i++){
        scanf("%lld %d",&n,&p);
        for(j=2;j<=p;j++) fact[j] = LL(fact[j-1])*j%p ;
        ans = 1;
        while(n > 0){
           quo =  n/p ;
           rem = n%p ;
           ans = LL(ans)*(quo%2==0?1:-1)*fact[rem]%p ;
           n = quo ;
        }
        if(ans < 0) ans+= p ;
        printf("%d\n",ans);
    }
return 0;
}

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <vector>
#include <utility>
using namespace std;

#define		S(x)				scanf("%d",&x)
#define		INC(i,a,b)			for(int i=a;i<b;++i)
#define		REP(i,n)			INC(i,0,n)
#define		FF				first
#define		SS				second
#define		mp				make_pair
#define		tri(a,b,c)			mp(a,mp(b,c))
#define		XX				FF
#define		YY				SS.FF
#define		ZZ				SS.SS

typedef pair<int,int> PII;
typedef pair<int,PII> TRI;
typedef vector<int> VI;
typedef vector<PII> VII;

const int MAX_N = 1e5, MAX_M = 2e5;
bool ans = true;
int n, m;
TRI E[MAX_M];
int S[MAX_N], R[MAX_N];
int F[MAX_M];

int findSet(int);
void link(int,int);

int main() {
  S(n); S(m);
  REP(i,n) {
    S[i] = i;
    R[i] = 0;
  }
  REP(i,m) {
    S(E[i].YY); S(E[i].ZZ); S(E[i].XX);
  }
  sort(E,E+m);
  
  int l, c=0, r=1;
  
  REP(i,m) {
    int d = E[i].ZZ;
    if(d>c) {
      if(r==1) {
	c = d;
	l = i;
	r = 0;
      }
      else {
	i = l-1;
	r = 1;
	continue;
      }
    }
    
    int a = E[i].YY, b = E[i].ZZ;
    if(r==1) {
      if(findSet(a)!=findSet(b)) link(S[a],S[b]);
      else if(F[i]==1) {
	ans = false;
	break;
      }
    }
    else {
      if(findSet(a)==findSet(b)) F[i] = 0;
      else F[i] = 1;
    }
  }
  
  if(ans) cout << "YES";
  else cout << "NO";
  
  return 0;
}

int findSet(int v) {
  if(v!=S[v]) S[v] = findSet(S[v]);
  return S[v];
}
void link(int a, int b) {
  if(R[a]<R[b]) S[a] = b;
  else {
    S[b] = a;
    if(R[a]==R[b]) R[a]++;
  }
}
#include <algorithm>
#include <iostream>
#include <cassert>
#include <cstdio>
#include <vector>
#include <set>
using namespace std;

#define		LL			long long
#define		S(x)			scanf("%d",&x)
#define		SL(x)			scanf("%lld",&x)
#define		INC(i,a,b)		for(int i=a;i<b;++i)
#define		REP(i,n)		INC(i,0,n)
#define		mp			make_pair
#define		FF			first
#define		SS			second
#define		tri(a,b,c)		mp(a,mp(b,c)
#define		XX			FF
#define		YY			SS.FF
#define		ZZ			SS.SS
#define		pb			push_back
#define		SZ(arr)			((int)(arr.size()))

struct overtake {
  LL d, s;
  int a, b; // a is overtaken by b (not true ID)
};

inline bool operator< (const overtake &x, const overtake &y) {
  if(x.d*y.s < x.s*y.d) return true;
  else if(x.d*y.s==x.s*y.d) {
    if(x.a<y.a || (x.a==y.a && x.b<y.b)) return true;
  }
  return false;
}

typedef pair<LL,LL> PLL;
typedef pair<LL,PLL> TRI;
typedef vector<int> VI;

const int MAX_N = 1e5+7;
int n, q, L[MAX_N];
VI F;
TRI H[MAX_N];
set<overtake> O;

void begin();
void repeat();
void answer(LL);
bool check(int,LL);

int main() {
  int t; S(t);
  while(t--) {
    begin();
    repeat();
    REP(i,q) {
      LL pos; SL(pos);
      answer(pos);
    }
  }
  return 0;
}

void begin() {
  F.clear();
  O.clear();
  S(n); S(q);
  REP(i,n) {
    SL(H[i].XX); SL(H[i].YY); H[i].ZZ = i; // (distance, speed, ID)
  }
  sort(H,H+n,greater<TRI>()); // Sort in order of distance
  REP(i,n) L[i] = i-1; // Linked list
  F.pb(0); // First in race
  
  // Add values to overtake set, and discard useless ones
  INC(i,1,n) {
    TRI curr = H[i];
    TRI prev = H[L[i]]; // The horse just ahead
    
    if(curr.YY<=prev.YY) {
      L[i+1] = L[i];
    }
    else {
      overtake temp;
      temp.s = curr.YY-prev.YY; temp.d = prev.XX-curr.XX;
      temp.a = L[i]; temp.b = i;
      O.insert(temp);
      
    }
  }
}
void repeat() {
  while(!O.empty()) {
    overtake top = *O.begin();
    O.erase(O.begin());
    L[top.b] = L[top.a];
    if(L[top.a]!=-1) {
      overtake temp;
      temp.a = L[top.a]; temp.b = top.a;
      temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX;
      assert(temp.s>0 && temp.d>0);
      O.erase(O.find(temp));

      temp.a = L[top.a]; temp.b = top.b;
      temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX;
      assert(temp.s>0 && temp.d>0); // b will eventually overtake a, necessarily
      O.insert(temp);
    }
    else F.pb(top.b);
  }
}
void answer(LL tm) {
  int l=0,r=SZ(F);
  while(r-l>1) {
    int d = (r+l)/2;
    if(check(d,tm)) l=d;
    else r=d;
  }
  printf("%lld\n",H[F[l]].ZZ);
}
bool check(int h, LL tm) {
  if(h==0) return true;
  int curr = F[h];
  int prev = F[h-1];
  
  LL dcurr = H[curr].XX + (H[curr].YY*tm);
  LL dprev = H[prev].XX + (H[prev].YY*tm);
  
  if(dcurr>=dprev) return true;
  return false;
}
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.Queue;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		outer:
		for(int T = ni();T >= 1;T--){
			int n1 = ni(), n2 = ni(), m = ni();
			int[] from = new int[m];
			int[] to = new int[m];
			for(int i = 0;i < m;i++){
				from[i] = ni()-1;
				to[i] = ni()-1;
			}
			int[][] g = packD(n1, from, to);
			for(int[] row : g){
				Arrays.sort(row);
			}
			if(n1 != n2){
				out.println(m);
				for(int i = 0;i < n1;i++){
					for(int e : g[i]){
						out.println((i+1) + " " + (e+1));
					}
				}
				continue outer;
			}
			int[] mat = doBipartiteMatchingHKNoRec(g, n2);
			for(int v : mat){
				if(v == -1){
					out.println(m);
					for(int i = 0;i < n1;i++){
						for(int e : g[i]){
							out.println((i+1) + " " + (e+1));
						}
					}
					continue outer;
				}
			}
			int[] xfrom = new int[m-n1];
			int[] xto = new int[m-n1];
			int[] w = new int[m-n1];
			int p = 0;
			for(int i = 0;i < n1;i++){
				for(int e : g[i]){
					if(mat[i] != e){
						xfrom[p] = mat[i]; xto[p] = e; w[p] = i; p++;
					}
				}
			}
			int[][] xg = packD(n2, xfrom, xto);
			int[][] xig = packD(n2, xto, xfrom);
			int[] clus = decomposeToSCCNoRec(xg, xig);
			int ct = 0;
			for(int i = 0;i < p;i++){
				if(clus[xfrom[i]] != clus[xto[i]]){
					ct++;
				}
			}
			out.println(ct);
			for(int i = 0;i < p;i++){
				if(clus[xfrom[i]] != clus[xto[i]]){
					out.println((w[i]+1) + " " + (xto[i]+1));
				}
			}
		}
	}
	
	public static int[] decomposeToSCCNoRec(int[][] g, int[][] ig)
	{
		int n = g.length;
		boolean[] visited = new boolean[n];
		int[] po = new int[n];
		int pop = 0;
		
		int[] stack = new int[n];
		int[] sinds = new int[n];
		int sp = 0;
		for(int i = 0;i < n;i++){
			if(!visited[i]){
				sinds[sp] = 0;
				stack[sp++] = i;
				while(sp > 0){
					int cur = stack[sp-1];
					visited[cur] = true;
					while(sinds[sp-1] < g[cur].length && visited[g[cur][sinds[sp-1]]])sinds[sp-1]++;
					if(sinds[sp-1] == g[cur].length){
						po[pop++] = cur;
						sp--;
					}else{
						stack[sp] = g[cur][sinds[sp-1]];
						sinds[sp] = 0;
						sp++;
					}
				}
			}
		}
		
		int[] ret = new int[n];
		Arrays.fill(visited, false);
		int clus = 0;
		Queue<Integer> q = new ArrayDeque<Integer>();
		for(int i = n - 1;i >= 0;i--){
			if(!visited[po[i]]){
				q.add(po[i]);
				visited[po[i]] = true;
				while(!q.isEmpty()){
					int cur = q.poll();
					ret[cur] = clus;
					for(int k : ig[cur]){
						if(!visited[k]){
							q.add(k);
							visited[k] = true;
						}
					}
				}
				clus++;
			}
		}
		
		return ret;
	}
	
	static int[][] packD(int n, int[] from, int[] to) {
		int[][] g = new int[n][];
		int[] p = new int[n];
		for(int f : from)
			p[f]++;
		for(int i = 0;i < n;i++)
			g[i] = new int[p[i]];
		for(int i = 0;i < from.length;i++){
			g[from[i]][--p[from[i]]] = to[i];
		}
		return g;
	}
	
	public static int[] doBipartiteMatchingHKNoRec(int[][] g, int m)
	{
		int n = g.length;
		if(n == 0)return new int[0];
		int[] from = new int[m];
		int[] to = new int[n];
		Arrays.fill(to, -1);
		Arrays.fill(from, n);
		
		int[] d = new int[n+1];
		int[] stack = new int[n+1];
		int[] adjind = new int[n+1];
		while(true){
			Arrays.fill(d, -1);
			int[] q = new int[n];
			int r = 0;
			for(int i = 0;i < n;i++){
				if(to[i] == -1){
					d[i] = 0;
					q[r++] = i;
				}
			}
			
			for(int p = 0;p < r;p++) {
				int cur = q[p];
				for(int adj : g[cur]){
					int nex = from[adj];
					if(d[nex] == -1) {
						if(nex != n)q[r++] = nex;
						d[nex] = d[cur] + 1;
					}
				}
			}
			if(d[n] == -1)break;
			
			for(int i = 0;i < n;i++){
				if(to[i] == -1){
					int sp = 1;
					stack[0] = i;
					adjind[0] = 0;
					boolean prevB = false;
					outer:
					while(sp >= 1){
						int cur = stack[sp-1];
						if(cur == n){
							prevB = true;
							sp--;
							continue;
						}
						for(;adjind[sp-1] < 2*g[cur].length;){
							int adj = g[cur][adjind[sp-1]/2];
							if(adjind[sp-1] % 2 == 0){
								int nex = from[adj];
								if(d[nex] == d[cur] + 1){
									stack[sp] = nex;
									adjind[sp] = 0;
									adjind[sp-1]++;
									sp++;
									continue outer;
								}else{
									adjind[sp-1]+=2;
								}
							}else{
								if(prevB){
									to[cur] = adj;
									from[adj] = cur;
									prevB = true;
									sp--;
									continue outer;
								}
								adjind[sp-1]++;
							}
						}
						d[cur] = -1;
						prevB = false;
						sp--;
					}
					if(prevB){
					}
				}
			}
		}
		
		return to;
	}
	
	public static int[][][] packWD(int n, int[] from, int[] to, int[] w) {
		int[][][] g = new int[n][][];
		int[] p = new int[n];
		for(int f : from)
			p[f]++;
		for(int i = 0;i < n;i++)
			g[i] = new int[p[i]][2];
		for(int i = 0;i < from.length;i++){
			--p[from[i]];
			g[from[i]][p[from[i]]][0] = to[i];
			g[from[i]][p[from[i]]][1] = w[i];
		}
		return g;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int mod = 1000000007;
		for(int T = ni();T >= 1;T--){
			int n = ni(), m = ni();
			int[][] M = new int[n][n];
			for(int i = 0;i < m;i++){
				int f = ni(), t = ni();
				M[f][t]--;
				M[t][f]--;
				M[f][f]++;
				M[t][t]++;
			}
			
			int[][] U = new int[n-1][n-1];
			for(int i = 0;i < n-1;i++){
				for(int j = 0;j < n-1;j++){
					U[i][j] = M[i][j];
					if(U[i][j]<0)U[i][j]+=mod;
				}
			}
			out.println(det(U, mod));
		}
	}
	
	public static int det(int[][] A, int mod)
	{
		int[][] lu = decomposeToLU(A, mod);
		if(lu == null)return 0;
		long mul = 1;
		for(int i = 0;i < A.length;i++){
			mul = mul * lu[i][i] % mod;
		}
		return (int)mul;
	}
	
	public static int[][] decomposeToLU(int[][] A, int mod)
	{
		int n = A.length;
		int[][] LU = new int[n][n];
		for(int r = 0;r < n;r++){
			for(int j = r;j < n;j++){
				long sum = 0;
				for(int k = 0;k < j;k++){
					sum += (long)LU[r][k]*LU[k][j]%mod;
				}
				LU[r][j] = (int)((A[r][j]-sum%mod+mod)%mod);
			}
			if(LU[r][r] == 0)return null;
			long inv = invl(LU[r][r], mod);
			for(int i = r+1;i < n;i++){
				long sum = 0;
				for(int k = 0;k < i;k++){
					sum += (long)LU[i][k]*LU[k][r]%mod;
				}
				LU[i][r] = (int)((A[i][r]-sum%mod+mod)*inv%mod);
			}
		}
		return LU;
	}
	
	public static long invl(long a, long mod)
	{
		long b = mod;
		long p = 1, q = 0;
		while(b > 0){
			long c = a / b;
			long d;
			d = a; a = b; b = d % b;
			d = p; p = q; q = d - c * q;
		}
		return p < 0 ? p + mod : p;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.math.BigInteger;
import java.util.*;
/**
 *
 * @author Rohan
 */
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        input();
    }
    
    public static void input(){
        InputReader in=new InputReader(System.in);
        PrintWriter out=new PrintWriter(System.out);
        
        int t=in.readInt();
        while(t-->0){
            long n=in.readLong(),b=in.readLong();
            if(n==1){
                if(b==1) out.println("Odd"); else out.println("Even"); continue;
            }
            BigInteger big=new BigInteger(2*b+""); BigInteger f=new BigInteger(1+"");
            for(long i=1;i<=n;i++){
                f=f.multiply(new BigInteger(i+"")); f=f.remainder(big);
            }
            long mod=Long.parseLong(f.toString()); 
            if(mod>=b) out.println("Odd"); else out.println("Even");
        } out.flush(); out.close();
    }
}
class InputReader {

		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		public int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		public int readInt() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') {
				sgn = -1;
				c = read();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}
                
                public long readLong() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			long sgn = 1;
			if (c == '-') {
				sgn = -1;
				c = read();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}

		public String readString() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public boolean isSpaceChar(int c) {
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		public String next() {
			return readString();
		}

		public interface SpaceCharFilter {
			public boolean isSpaceChar(int ch);
		} 
}
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <cmath>
#include <algorithm>
#include <functional>
#include <numeric>
#include <bitset>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <map>
#include <cassert>

#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define S1(x) scanf("%lld",&x)
#define epsilon 0.000000000000001
#define pie acos (-1.0)
#define MAXNODES 100001
#define sz size()
#define MAX 100009
using namespace std;

ill a[MAX];
ill parent[MAX];
ill d[MAX];
ill level[MAX];
vector < vector <ill> > s;
ill root;
ill chainhead[MAX];
ill which[MAX];
ill where[MAX];
ill ssize[MAX];
ill chain;

class seg
{
    private:

    public:
        vector <ill> a;
        vector <ill> flag;
        ill ss;
        void add (ill index)
        {
            ss++;
        }

        seg ()
        {
            ss = 0;
        }

        void space ()
        {
            a.resize (7*ss + 10);
            fill (a.begin(), a.end(), 0);

            flag.resize (7*ss + 10);
            fill (flag.begin(), flag.end(), 0);
        }

        void build (ill node, ill x, ill y)
        {
            if (x > y) {
                return;
            }
            if (x == y) {
                a[node] = 0;
                return;
            }
            ill mid = (x+y)/2;
            build (node*2, x, mid);
            build (node*2 + 1, mid+1, y);
            a[node] = a[node*2] + a[node*2 + 1];
        }

        void checking (ill node, ill x, ill y)
        {
            if (flag[node] == 0) {
                return;
            }

            ill mid = (x+y)/2;

            if (2*node < 7*ss) {
                a[node*2] += (ill)(mid-x+1)*flag[node];
                flag[node*2] += flag[node];
            }
            if (2*node +1 < 7*ss) {
                a[node*2 +1] += (ill)(y-mid)*flag[node];
                flag[node*2 +1] += flag[node];
            }
            flag[node] = 0;
        }

        ill query (ill node, ill x, ill y, ill sx, ill sy)
        {
        //    cout << node << " " << 4*ss << " " << x << " " << y << " " << sx << " " << sy << endl;
            if (x > y) {
                return 0;
            }
            if (x > sy || y < sx) {
                return 0;
            }
            checking (node, x, y);

            if (sx <= x && sy >= y) {
                return a[node];
            }

            if (x == y) {
                return a[node];
            }
            ill mid = (x+y)/2;
            if (sy <= mid) {
                return query (2*node, x, mid, sx, sy);
            }
            if (sx > mid) {
                return query (2*node +1, mid+1, y, sx, sy);
            }
            return query (2*node, x, mid, sx, sy) + query (2*node + 1, mid+1, y, sx, sy);
        }



        void update (ill node, ill x,


                     ill y, ill sx, ill sy, ill value)
        {
            if (x > y) {
                return;
            }
            if (x  > sy || y < sx) {
                return;
            }
            checking(node, x, y);
            if (x == y) {
                a[node] = a[node]+value;
               // a[x] += value;
                return;
            }



            if (sx <= x && sy >= y) {
                flag[node] += value;
                a[node] = a[node]+((ill)(y-x+1)*value);
                return;
            }
            ill mid = (x+y)/2;
            update (node*2, x, mid, sx, sy, value);
            update (node*2 +1, mid+1, y, sx, sy, value);
            a[node] = a[node*2] + a[node*2 +1];
        }
};
vector <seg> segment;

ill lca( ill a, ill b)
{
    while (which[a] != which[b]) {
        ill a1 = chainhead[which[a]];
        ill b1 = chainhead[which[b]];
        if (level[a1] < level[b1]) {
            b = parent[b1];
        } else {
            a = parent[a1];
        }
    }
    if (a == -1 || b == -1) {
        return root;
    }
    if (level[a] < level[b]) {
        return a;
    }
    return b;
}

ill query (ill u)
{
    ill sum = 0;
    ill total=0;
    while (u != -1) {
       // cout << "AA " << u << endl;
        ill cc = which[u];
      //  cout << ssize[cc] << " " << where[u] << endl;
        ill xx =  segment[cc].query (1, 0, ssize[cc]-1, where[u], where[u]);

        sum = sum + total*xx;
        xx =  segment[cc].query (1, 0, ssize[cc]-1, 0, where[u]);
        sum = sum + xx;
        total = total + (ill)(where[u]+1);
        u = chainhead[cc];
        u = parent[u];
    }
    return sum;
}

void update (ill index, ill value)
{
    ill cc = which[index];
    segment[cc].update (1, 0, ssize[cc]-1, where[index],  ssize[cc]-1, value);
}


void dfs (ill index, ill p)
{
    d[index] = 1;
    parent[index] = p;
    ill i;

    F (i, 0, s[index].size()) {
        ill x = s[index][i];
        if (x == p) {
            continue;
        }
        level[x] = level[index] + 1;
        dfs (x, index);
        d[index] = d[index] + d[x];
    }
}

void hld (ill index, ill p)
{
    if (chainhead[chain] == -1) {
        chainhead[chain] = index;
    }
    which[index] = chain;
    where[index] = ssize[chain];
    ssize[chain]++;
    segment[chain].add (0);

    ill i,j=-1,xx=-1;

    F (i, 0, s[index].size()) {
        ill x = s[index][i];
        if (x == p) {
            continue;
        }
        if (d[x] > xx) {
            xx = d[x];
            j = x;
        }
    }

    if (j == -1) {
        return;
    }
    hld (j, index);

    F (i, 0, s[index].size()) {
        ill x = s[index][i];
        if (x == p || x == j) {
            continue;
        }
        chain++;
        hld (x, index);
    }
}

int main()
{
  // freopen ("input.txt", "r", stdin);
    ill tt,ix=1;


    ill i,n;
    S1 (n);
    ill qq;
    S1 (qq);

    S1 (root);
    root--;

    s.clear();      s.resize (n);
    F (i, 0, n-1) {
        ill x,y;
        S1 (x);      S1 (y);
        x--;        y--;
        s[x].pb (y);
        s[y].pb (x);
    }

    level[root] = 0;
    dfs (root, -1);

    segment.clear();
    segment.resize (n+3);

    chain = 0;
    memset (chainhead, -1, sizeof(chainhead));
    memset (ssize, 0, sizeof(ssize));

    hld (root, -1);
    F (i, 0, chain+4) {
        segment[i].space ();
        segment[i].build (1, 0, ssize[i]-1);
    }
    //cout << "SDAS" << endl;

  //  cout << "SDAD " << qq << endl;
    while (qq--) {
        char ch[3];
        scanf ("%s", ch);
        if (ch[0] == 'U') {
            ill x;
            ill y;
            S1(x);
            S1(y);
            x--;
            update (x, y);

            continue;
        }

        ill x,y;
        S1(x);
        S1(y);
        x--;
        y--;
        ill ll = lca(x,y);


      //  cout << x << " " << y << " " << ll << endl;
        ill ans = query(y)+query(x)-query(ll)-(parent[ll]!=-1?query(parent[ll]):0);
        printf ("%lld\n", ans);
      //  cout << "A" << endl;
      //  cout << endl;

    }


    return 0;
}
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <string>
#include <cassert>

using namespace std;
typedef long long LL;
typedef pair<int,int> pii;

#define forup(i,a,b) for(int i=a; i<b; ++i)
#define fordn(i,a,b) for(int i=a; i>b; --i)
#define rep(i,a) for(int i=0; i<a; ++i)

#define dforup(i,a,b) for(i=a; i<b; ++i)
#define dfordn(i,a,b) for(i=a; i>b; --i)
#define drep(i,a) for(i=0; i<a; ++i)

#define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0

#define gi(x) scanf("%d",&x)
#define gl(x) cin>>x
#define gd(x) scanf("%lf",&x)
#define gs(x) scanf("%s",x)

#define pis(x) printf("%d ",x)
#define pin(x) printf("%d\n",x)
#define pls(x) cout<<x<<" "
#define pln(x) cout<<x<<"\n"
#define pds(x) printf("%.12f ",x)
#define pdn(x) printf("%.12f\n",x)
#define pnl() printf("\n")

#define fs first
#define sc second

#define pb push_back

const int inv=1000000000;
const int minv=-inv;

const int max_n=100010;

// Geometry

struct point
{
	LL xc,yc;
	point(){}
	point(LL xc_, LL yc_){xc=xc_; yc=yc_;}
};

point operator +(const point &a, const point &b) {return point(a.xc+b.xc,a.yc+b.yc);} // Vector Addition
point operator -(const point &a, const point &b) {return point(a.xc-b.xc,a.yc-b.yc);} // Vector Subtraction
LL operator *(const point &a, const point &b) {return (a.xc*b.xc+a.yc*b.yc);} // Dot Product
LL operator ^(const point &a, const point &b) {return (a.xc*b.yc-a.yc*b.xc);} // Cross Product : Right-Hand Rule

bool leftturn(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))>0ll); }
bool straight(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))==0ll); }

point pfix;
struct point_tan_cmp : public binary_function <point,point,bool>
{
	bool operator() (const point &a, const point &b) { return ((a.yc-pfix.yc)*(b.xc-pfix.xc)>(b.yc-pfix.yc)*(a.xc-pfix.xc)); }
};
// X: all points should be distinct
// X: order of points in array will be changed
// X: triples of points may be collinear
// X: there should exist three non-collinear points
// cX: points will be sorted in clockwise order (all turn will be right turns)
void ConvexHull(point X[], int N, int cX[], int &cXsz)
{	
	int fix=0;
	for(int i = 1; i<N; i++){
		if(X[i].xc<X[fix].xc or (X[i].xc==X[fix].xc and X[i].yc>X[fix].yc))
			fix=i;
	}
	swap(X[0],X[fix]);
	pfix=X[0];
	
	sort(X+1,X+N,point_tan_cmp());
	X[N]=X[0];
	
	cXsz=0;
	cX[cXsz++]=0;
	cX[cXsz++]=1;
	forup(i,2,N+1)
	{
		while(cXsz>=2 and (leftturn(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]) or straight(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i])))
			--cXsz;
		if(i==N) break;
		cX[cXsz++]=i;
	}
}

// End

int T;
int n;
point P[max_n];
int H[max_n],nH;

int main()
{
	gi(T);

	rep(z,T)
	{
		gi(n);

		rep(i,n)
		{
			gl(P[i].xc);
			gl(P[i].yc);
		}

		if(n<=2)
			pin(n-1);
		else
		{
			ConvexHull(P,n,H,nH);
			pin(2*nH-3+3*(n-nH));
		}
	}
	
	return 0;
}
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		for(int T = ni();T >= 1;T--){
			int n = ni();
			boolean inv = false;
			TopologicalOrder to = new TopologicalOrder(n);
			while(true){
				String type = ns();
				if(type.equals("END"))break;
				if(type.charAt(0) == 'U'){
					int f = ni()-1, t = ni()-1;
					if(inv){
						int d = f; f = t; t = d;
					}
					to.connect(f, t);
				}else{
					int f = ni()-1, t = ni()-1;
					if(to.iord[f] < to.iord[t]){
						out.println("YES");
					}else{
						out.println("NO");
						inv ^= true;
					}
				}
			}
		}
	}
	
	public static class TopologicalOrder
	{
		public boolean[][] g;
		public int[] ord;
		public int[] iord;
		public boolean sc;
		
		public TopologicalOrder(int n) {
			g = new boolean[n][n];
			ord = new int[n];
			iord = new int[n];
			for(int i = 0;i < n;i++){
				ord[i] = i;
				iord[i] = i;
			}
			sc = false;
		}
		
		boolean connect(int u, int v)
		{
			if(u == v)return sc; // meaningless loop
			if(g[u][v])return sc; // already connected
			
			g[u][v] = true;
			if(iord[u] <= iord[v])return sc; // trivial
			
			int n = g.length;
			int[] anc = new int[n];
			int[] des = new int[n];
			boolean[] erased = new boolean[n];
			int ap = 0, dp = 0;
			anc[ap++] = u;
			des[dp++] = v;
			erased[iord[v]] = erased[iord[u]] = true;
			int r = iord[v], l = iord[u];
			while(true){
				l--;
				while(l > r && !anyOfOneToMany(ord[l], anc, 0, ap, g))l--;
				if(anyOfOneToMany(ord[l], anc, 0, ap, g)){
					anc[ap++] = ord[l];
					erased[l] = true;
				}
				if(l == r)break;
				
				r++;
				while(r < l && !anyOfManyToOne(des, 0, dp, ord[r], g))r++;
				if(anyOfManyToOne(des, 0, dp, ord[r], g)){
					des[dp++] = ord[r];
					erased[r] = true;
				}
				if(r == l)break;
			}
			
			// cycle check
			// (i)
			int t = l;
			int hit = 0;
			for(int i = 0;i < ap;i++){
				if(anc[i] == ord[t])hit++;
			}
			for(int i = 0;i < dp;i++){
				if(des[i] == ord[t])hit++;
			}
			if(hit == 2){
				return sc = true;
			}
			
			// (ii)
			for(int i = 0;i < ap;i++){
				for(int j = 0;j < dp;j++){
					if(g[des[j]][anc[i]]){
						return sc = true;
					}
				}
			}
			
			int L = iord[v], R = iord[u];
			for(int i = 0;i < n;i++){
				if(erased[i]){
					iord[ord[i]] = -1;
					ord[i] = -1;
				}
			}
			
			int at = 0, dt = 0;
			for(l = t;l >= L;l--){
				if(ord[l] == -1){
					ord[l] = anc[at++];
					iord[ord[l]] = l;
				}else if(anyOfOneToMany(ord[l], anc, at, ap, g)){
					anc[ap++] = ord[l];
					ord[l] = anc[at++];
					iord[ord[l]] = l;
				}
			}
			
			for(r = t + 1;r <= R;r++){
				if(ord[r] == -1){
					ord[r] = des[dt++];
					iord[ord[r]] = r;
				}else if(anyOfManyToOne(des, dt, dp, ord[r], g)){
					des[dp++] = ord[r];
					ord[r] = des[dt++];
					iord[ord[r]] = r;
				}
			}
			
			return sc;
		}
	}
	
	private static boolean anyOfOneToMany(int x, int[] a, int l, int r, boolean[][] g)
	{
		for(int i = l;i < r;i++){
			if(g[x][a[i]])return true;
		}
		return false;
	}
	
	private static boolean anyOfManyToOne(int[] a, int l, int r, int x, boolean[][] g)
	{
		for(int i = l;i < r;i++){
			if(g[a[i]][x])return true;
		}
		return false;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include <cstdio>
#include <algorithm>
#include <map>
#include <vector>
#include <cstring>
 
using namespace std;
 
typedef pair<int,int> cp;
 
const int N = 200020;
const int mod = 100711433;
 
int q, pe[N];
int n, dep[N], pep[N];
int be[N], ed[N], times;
 
struct edge {
     int to, nx, dl;
} ee[N + N];
int eq[N], en = 1;
 
int fa[N][21], fw[N][21];
 
int tr[N], cc[N], ans[N];
vector<cp> vec[N];
 
cp ups[N], dws[N];
int upx[N], upn;
int dwx[N], dwn, dwb[N];
 
int fpm(int a, int b) {
     int w = 1;
     for (a %= mod; b; b >>= 1, a = (long long)a * a % mod)
          if (b & 1) w = (long long)w * a % mod;
     return w;
}
int inv(int x) {
     return fpm(x, mod - 2);
}
void dfs(int d, int p) {
     be[d] = ++times;
     for (int j = eq[d], k; k = ee[j].to, j; j = ee[j].nx)
          if (k != p) {
               fa[k][0] = d;
               dep[k] = dep[d] + 1;
               dfs(k, d);
          } else ee[j].dl = 1;
     ed[d] = times;
}
int lca(int u, int v, int& lcc) {
     int flag = 0;
     if (dep[u] < dep[v]) swap(u, v), flag = 1;
     int _u = u;
     int dt = dep[u] - dep[v], _dt = dt;
     for (int j = 0; j < 20; j ++)
          if (dt >> j & 1) u = fa[u][j];
     if (u == v) {
          int o = _u;
          if (!_dt) return u;
          dt = _dt - 1;
          for (int j = 0; j < 20; j ++)
               if (dt >> j & 1) o = fa[o][j];
          lcc = o;
          return u;
     }
     for (int j = 19; j >= 0; j --)
          if (fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j];
     lcc = !flag? u: v;
     return fa[u][0];
}
int get(int u, int v) {
     if (dep[u] < dep[v]) swap(u, v);
     int dt = dep[u] - dep[v], ret = 0;
     for (int j = 0; j < 20; j ++)
          if (dt >> j & 1) ret = (ret + fw[u][j]) % mod, u = fa[u][j];
     if (u == v) return ret;
     for (int j = 19; j >= 0; j --)
          if (fa[u][j] != fa[v][j]) {
               ret = (ret + fw[u][j]) % mod, u = fa[u][j];
               ret = (ret + fw[v][j]) % mod, v = fa[v][j];
          }
     ret = (ret + fw[u][0]) % mod;
     ret = (ret + fw[v][0]) % mod;
     return ret;
}
inline void inc(int& a, int b) {
     a = (a + b) % mod;
}
void clean() {
     for (int i = 1; i <= n; i ++) vec[i].clear();
     memset(tr, 0, sizeof(tr));
}
void add(int w, int v) {
     for (int j = w; j <= n; j += j & -j) inc(tr[j], v);
}
int ask(int w) {
     int ret = 0;
     for (int j = w; j; j -= j & -j) inc(ret, tr[j]);
     return ret;
}
void work(int d) {
     int sz = vec[d].size();
     for (int l = 0; l < sz; l ++) add(vec[d][l].first, vec[d][l].second);
     int temp = (ask(ed[d]) - ask(be[d] - 1) + mod) % mod;
     inc(ans[d], (long long)temp * cc[d] % mod);
     for (int j = eq[d]; j; j = ee[j].nx)
          if (!ee[j].dl) work(ee[j].to);
}
void calc() {
     work(1);
}
void deal_up() {
     clean();
     for (int i = 1; i <= upn; i ++) {
          int D = pep[ups[i].first] - 1, x = upx[i];
          long long ww = inv(pe[D]);
          vec[ups[i].second].push_back(make_pair(be[ups[i].first], ww * x % mod));
     }
     for (int i = 1; i <= n; i ++) cc[i] = (long long)pep[i] * pe[pep[i]] % mod;
     calc();
 
     clean();
     for (int i = 1; i <= upn; i ++) {
          int D = pep[ups[i].first] - 1, x = upx[i];
          long long ww = (long long)D * inv(pe[D]) % mod; ww = mod - ww;
          vec[ups[i].second].push_back(make_pair(be[ups[i].first], ww * x % mod));
     }
     for (int i = 1; i <= n; i ++) cc[i] = pe[pep[i]];
     calc();
}
void deal_dw() {
     clean();
     for (int i = 1; i <= dwn; i ++) {
          int D = dep[dws[i].first] - dwb[i], x = dwx[i];
          long long ww;
          if (D >= 0) ww = inv(pe[D]);
          else ww = pe[-D];
          vec[dws[i].first].push_back(make_pair(be[dws[i].second], ww * x % mod));
     }
     for (int i = 1; i <= n; i ++) cc[i] = (long long)dep[i] * pe[dep[i]] % mod;
     calc();
     
     clean();
     for (int i = 1; i <= dwn; i ++) {
          int D = dep[dws[i].first] - dwb[i], x = dwx[i];
          long long ww;
          if (D >= 0) ww = (long long)D * inv(pe[D]) % mod;
          else ww = (long long)(mod + D) * pe[-D] % mod;
          ww = mod - ww;
          vec[dws[i].first].push_back(make_pair(be[dws[i].second], ww * x % mod));
     }
     for (int i = 1; i <= n; i ++) cc[i] = pe[dep[i]];
     calc();
}
int main() {
     scanf("%d %d", &n, &q);
     for (int i = 1, u, v; i < n; i ++) {
          scanf("%d %d", &u, &v);
          ee[++en] = (edge){v, eq[u]}, eq[u] = en;
          ee[++en] = (edge){u, eq[v]}, eq[v] = en;
     }
 
     dep[1] = 1;
     dfs(1, 0);
     for (int i = 1; i <= n; i ++) pep[i] = n + 1 - dep[i];
     for (int j = 1; j < 20; j ++)
          for (int i = 1; i <= n; i ++) fa[i][j] = fa[fa[i][j - 1]][j - 1];
 
     for (int i = 0; i <= n; i ++) pe[i] = !i? 1: (long long)pe[i - 1] * q % mod;
     
     int cmds1, cmds2, x, u, v;
     scanf("%d %d", &cmds1, &cmds2);
     while (cmds1 --) {
          scanf("%d %d %d", &x, &u, &v);
          int lc2, lc = lca(u, v, lc2), ori;
          if (lc != u) ups[++upn] = make_pair(u, lc2), upx[upn] = x;
          ori = dep[u] - dep[lc] + 1;
          dws[++dwn] = make_pair(lc, v), dwx[dwn] = x, dwb[dwn] = ori;
     }
     
     deal_up();
     deal_dw();
     
     for (int i = 1; i <= n; i ++) fw[i][0] = ans[fa[i][0]];
     for (int j = 1; j < 20; j ++)
          for (int i = 1; i <= n; i ++)
               fw[i][j] = (fw[i][j - 1] + fw[fa[i][j - 1]][j - 1]) % mod;
     
     while (cmds2 --) {
          int u, v;
          scanf("%d %d", &u, &v);
          int lc2, lc = lca(u, v, lc2);
 
          int ret = get(u, v);
          ret = (ret + ans[u]) % mod;
          ret = (ret + ans[v]) % mod;
          ret = (ret - ans[lc] + mod) % mod;
          
          printf("%d\n", ret);
     }
}
#include<bits/stdc++.h>
using namespace std;

#define FOR(_i,_a,_b) for(int _i=_a;_i<=_b;_i++)
#define TCASE int _t;scanf("%d",&_t);FOR(_i,1,_t)
#define NFOR(_i,_a,_b) for(int _i=_a;_i>=_b;_i--)
#define pb push_back
#define all(_vec) _vec.begin(),_vec.end()
#define READ(x) freopen(x,"r",stdin);
#define VECTORPRINT(_vec) {int _t=0;while(_t<_vec.size()){cout<<_vec[_t++]<<' ';}}
#define whatis(x) cout<<#x<<"= "<<x<<endl;
//#define REP(i,n) for (int i = 1; i <= n; i++)
#define REP(i, n) for(int i=0;i<n;i++)

typedef vector<int> vi;
typedef vector<pair<int,int> > vpii;
typedef long long lli;
typedef unsigned long long ulli;
typedef vector<lli> vlli;
typedef vector<vector<lli> > matrix;

const int sz=1000*100+100;
const int k=2;
int mod;

void mul(lli a[k+1][k+1],lli b[k+1][k+1]){
    lli tmp[k+1][k+1]={0};
    FOR(i,1,k) FOR(j,1,k) FOR(kk,1,k)
        tmp[i][j]=(tmp[i][j]+a[i][kk]*b[kk][j]) % mod;
    FOR(i,1,k) FOR(j,1,k) a[i][j]=tmp[i][j];
}

void power(lli t[k+1][k+1],lli n){
    if(n==1) return;
    lli iden[k+1][k+1]={0,0,0,0,1,0,0,0,1};

    if(n%2==1) { mul(iden,t); }
    mul(t,t);
    power(t,n/2);

    mul(t,iden);
    //FOR(i,1,k) FOR(j,1,k) t[i][j]=iden[i][j]*t[i][j] % mod;
}

vi primes;
int sievearr[sz +1];

void create_seive(int n){
    for(int i=2;i*i<=n;i++)
        if(sievearr[i]==0)
            for(int j=i*i;j<=n;j+=i)
                sievearr[j]=1;
    FOR(i,2,n)
        if(sievearr[i]==0)
            primes.pb(i);
}

lli fastexpo(lli a,int b){
    lli res=1;
    while(b){
        if(b&1) res*=a;
        a=a*a;
        b/=2;
    }
    return res;
}

int main(){
#ifndef ONLINE_JUDGE
    READ("in.txt")
#endif
create_seive(sz);
int len=primes.size();

TCASE{
    lli n,r;
    lli tmp,a;
    cin>>n>>r>>mod;
    if( mod == 1 || n < r){
			cout<<0<<endl;
			continue;
    }

    vlli factors(n+1,0);

int p;
FOR(j,n-r+1,n){
    tmp=j;
    for(int i=0;primes[i]*primes[i]<=tmp;++i){
        p=primes[i];
        while(tmp%p==0){factors[p]+=1; tmp/=p;}
    }
    if(tmp!=1)
        factors[tmp]+=1;

    tmp=j-(n-r);
    for(int i=0;primes[i]*primes[i]<=tmp;++i){
        p=primes[i];
        while(tmp%p==0){factors[p]-=1; tmp/=p;}
    }
    if(tmp!=1)
        factors[tmp]-=1;
}

    lli ans[k+1][k+1]={0};
    ans[1][1]=0; ans[1][2]=1;
    ans[2][1]=1; ans[2][2]=1;
    //FOR(i,0,k) FOR(j,0,k) cout<<ans[i][j]<<" \n"[j==k];
    for(int i=0;primes[i]<=n;i++){
        p=primes[i];
        if(factors[p]==0) continue;
        //FOR(j,1,factors[i])
            power(ans,fastexpo(p,factors[p]) );
    }
    //cout<<"ans"<<endl;
    //FOR(i,0,k) FOR(j,0,k) cout<<ans[i][j]<<" \n"[j==k];

    lli inv[k+1][k+1]={0};
    inv[1][1]=-1; inv[1][2]=1;
    inv[2][1]=1; inv[2][2]=0;

    mul(ans,inv);

    vi f1(k+1);
    f1[1]=1;
    f1[2]=1;

    lli res=0;
    FOR(i,1,k)
        res=(res+ans[1][i]*f1[i]) % mod;

    cout<<res<<endl;
}

return 0;
}

#include <bits/stdc++.h>
using namespace std;
//#define fi(x) scanf("%lld",x)
#define MID ((l+r) >> 1)
#define LT (nd << 1)
#define RT ((nd << 1) | 1)
#define MAX 1123
typedef long long int LL;

template <typename T>
inline void fi(T *a)
{
 register char c=0;
 while (c<33) c=getchar_unlocked();
 *a=0;
 int tmp = 0;
 while (c>33)
 {
     if ( c == 45 ) tmp = 1;
     else *a=*a*10+c-'0';
     c=getchar_unlocked();
 }
 if ( tmp == 1 ) *a = 0-(*a);
}

struct node{
    LL lsum,rsum,msum,sum;
    node():lsum(0),rsum(0),msum(0),sum(0){}
    node(LL v):lsum(v),rsum(v),msum(v),sum(v){}

    void print(){
        cout << "MAX: " << msum << " SUM : " << sum << " LMAX: " << lsum << " RMAX: " << rsum << endl;
    }
};

node Merge(node left,node right){
    node res;
    res.sum = left.sum + right.sum;
    res.lsum = max(left.lsum,left.sum+right.lsum);
    res.rsum = max(right.rsum,right.sum+left.rsum);

    res.msum = max(left.msum,right.msum);
    res.msum = max(res.msum,left.rsum+right.lsum);
    return res;
}

LL A[MAX],S,N,Q;
node RQ[MAX][MAX];

void compute(){
    for(LL i = 0; i < S; ++i) RQ[i][i] = node(A[i]);
    for(LL i = 1; i < S; ++i){
        for(LL j = 0; j+i < S; ++j){
            LL l = j, r = i+j;
            RQ[j][j+i] = Merge(RQ[j][MID],RQ[MID+1][i+j]);
        }
    }
}

node Range(LL st,LL sz){
    if (st+sz-1 < S) return RQ[st][st+sz-1];

    node n1 = RQ[st][S-1],res;
    sz -= (S-st);

    if (sz <= S)
        res = RQ[0][sz-1];
    else {
        LL d = sz/S;
        sz = sz%S;
        node fr = RQ[0][S-1];
        res = fr;

        res.sum = res.sum*d;
        if (fr.sum > 0){
            res.lsum += max(fr.sum*(d-1),(LL)0);
            res.rsum += max(fr.sum*(d-1),(LL)0);
            LL ans = LLONG_MIN;
            if (d > 1)
                ans = fr.lsum + fr.rsum + max(fr.sum*(d-2),(LL)0);
            res.msum = max(res.msum,ans);
        }

        if (sz != 0)
            res = Merge(res,RQ[0][sz-1]);
    }

    res = Merge(n1,res);
    return res;
}

struct seg{
    vector<node> v;
    vector<LL> lazy;
    LL sz;

    seg():sz(0){}
    void Resize(LL k){
        sz = k;
        v.resize(3*sz,node());
        lazy.resize(3*sz,-1);
    }

    void pushdown(LL nd,LL l,LL r){
        if (lazy[nd] == -1) return;
        LL v1 = lazy[nd];
        node res = Range(v1,r-l+1);
        v[nd] = res;
        if (l != r)
            lazy[LT] = v1, lazy[RT] = (v1+MID-l+1)%S;
        lazy[nd] = -1;
    }

    void update(LL nd,LL l,LL r,LL a,LL b,LL M){
        pushdown(nd,l,r);
        if (l > b || r < a) return;
        if (l >= a && r <= b){
            lazy[nd] = (M+l-a)%S;
            pushdown(nd,l,r);
            return;
        }

        update(LT,l,MID,a,b,M);
        update(RT,MID+1,r,a,b,M);
        v[nd] = Merge(v[LT],v[RT]);
    }

    void update(LL a,LL b,LL M){
        update(1,0,sz-1,a,b,M);
    }

    node query(LL nd,LL l,LL r,LL a,LL b){
        pushdown(nd,l,r);
        if (l >= a && r <= b)
            return v[nd];

        if (MID < a) return query(RT,MID+1,r,a,b);
        if (MID+1 > b) return query(LT,l,MID,a,b);

        node n1 = query(LT,l,MID,a,b);
        node n2 = query(RT,MID+1,r,a,b);
        return Merge(n1,n2);
    }

    node query(LL a,LL b){
        return query(1,0,sz-1,a,b);
    }
};

void solve(){
    fi(&S),fi(&N),fi(&Q);
    for(int i = 0; i < S; ++i)
        fi(&A[i]);
    compute();

    seg SG;
    SG.Resize(N);

    char ch[10];
    LL a,b,c;
    while(Q--){
        scanf("%s",ch);
        fi(&a),fi(&b),--a,--b;
        if (ch[0] == 'U'){
            fi(&c),--c;
            c %= S;
            SG.update(a,b,c);
            continue;
        }

        node res = SG.query(a,b);
        printf("%lld\n",res.msum);
    }
}

int main()
{
    solve();
    return 0;
}

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

bool graph[111][111];
char s[111][111];

int n, root;
vector<int> adj[200];
int mate[200];
bool v1[200], v2[200];

template<typename T> int size(const T& c) { return int(c.size()); }
template<typename T> T sqr(T x) { return x*x; }
template<typename T> bool remin(T& x, T y) { if (x <= y) return false; x = y; return true; }
template<typename T> bool remax(T& x, T y) { if (x >= y) return false; x = y; return true; }

#define FOR(i, a, b) for (int i(a), _b(b); i <= _b; ++i)
#define FORD(i, a, b) for (int i(a), _b(b); i >= _b; --i)
#define REP(i, n) for (int i(0), _n(n); i < _n; ++i)
#define REPD(i, n) for (int i((n) - 1); i >= 0; --i)

bool dfs(int x) {
  if (v1[x]) return false;
  v1[x] = v2[x] = true;
  REP(z, size(adj[x])) {
    int y = adj[x][z];
    if (y != root && mate[y] == -1) {
      mate[x] = y;
      mate[y] = x;
      return true;
    }
  }
  REP(z, size(adj[x])) {
    int y = adj[x][z];
    if (y != root && !v2[y] && dfs(mate[y])) {
      mate[x] = y;
      mate[y] = x;
      return true;
    }
  }
  v2[x] = false;
  return false;
}

int solve() {
  int res = 0;
  REP(z, 13) {
    REP(i, n) random_shuffle(adj[i].begin(), adj[i].end());
    REP(i, n) mate[i] = -1;
    vector<int> order(n);
    REP(i, n) order[i] = i;
    random_shuffle(order.begin(), order.end());
    int cur = 0;
    REP(i, n) {
      root = order[i];
      if (mate[root] != -1) continue;
      REP(i, n) v1[i] = v2[i] = false;
      if (dfs(root)) ++cur;
    }
    remax(res, cur);
  }
  return res;
}

int main() {
    // freopen("J.in", "r", stdin);
    // memset(matchL, -1, sizeof(matchL));
    //     memset(matchR, -1, sizeof(matchR));
    //     int matched = 0;
    //     for (int i = 0; i < n; i++) {
    //         memset(seen, false, sizeof(seen));
    //         if (bpm(i)) matched++;
    //     }

    int T;

    for (int T = 1;; T++) {
        int m;
        scanf("%d%d", &n, &m);
        if (n + m == 0) break;
        for (int i = 0; i < n; i++) scanf("%s", s[i]);

        memset(graph, false, sizeof(graph));
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (s[i][j] == '.') {
                    graph[i][j] = true;
                    graph[j][i] = true;
                }
        for (int i = 0; i < n; i++) adj[i].clear();
        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (graph[i][j]) adj[i].push_back(j);

        bool ok = true;
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < n; j++) if (graph[i][j]) cnt++;
            if (cnt == 0) ok = false;
        }

        printf("Case#%d: ", T);

        if (ok == false) { printf("IMPOSSIBLE\n"); continue; }

        printf("%d\n", (n - solve()) * m);
    }
    return 0;
}
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<string>
#include<string.h>
#include<cstring>
#include<stack>
#include<queue>
#include<cassert>
#include<cmath>
using namespace std;

#define LL long long int
#define PII pair<int,int>
#define PB push_back
#define MP make_pair
#define INF 1000000000
#define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0)
#define MOD 1000000007

string s;
int dp[5001][5001][3][2];
int vis[5001][5001][3][2];
int citer = 0;
char ss[2000];
int  getans(int n, int m, int cinter, int contin){
    if(m < 0)m = 0;
    if(n == -1)return (m == 0 && cinter == 0);
    int &cret = dp[n][m][cinter][contin];
    int &cvis = vis[n][m][cinter][contin];
    if(cvis != citer){
        LL ret = 0;
        cvis = citer;
        ret += getans(n - 1, m, cinter, 0);
        if(s[n] != 'a'){
            if(contin  == 1){
                ret += getans(n - 1, m, cinter, 1);
            }
            if(cinter > 0)
                ret += getans(n - 1, m, cinter - 1, 1);
        }
        else{
            if(contin == 1)
                ret += getans(n - 1, m - 1, cinter, 1);
            if(cinter > 0)
                ret += getans(n - 1, m - 1, cinter - 1, 1);
        }
        cret = ret % MOD;
    }
    return cret;
}
int main(){
    int t, m;
    cin >> t;
    while(t--){
        citer += 2;
        cin >> s >> m;
        cout<<getans(s.size() - 1, m, 3, 0)<<endl;
    }
        
    return 0;
}

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define int64 long long
const int mod = (int) 1e9 + 7, k = 2000;
using namespace std;

typedef int arr32[1100010];

arr32 fra, inv, g, f, s;
int n, m, x;

void inc(int &a, const int &b)  {
	a += b;
	if (a < 0)  a += mod;
	if (a >= mod)  a -= mod;
}
int64 ex(int x, int y, int w)  {
	if ((w = (w % y + y) % y) % x == 0)  return w / x;
	return (ex(y % x, x, -w) * y + w) / x;
}
int C(int x, int y)  {
	return (int64) fra[x] * inv[x - y] % mod * inv[y] % mod; 
}
void prepare()  {
	fra[0] = f[0] = 1;
	for (int i = 1; i <= n + k; ++i)  fra[i] = (int64) fra[i - 1] * i % mod;
	inv[n + k] = ex(fra[n + k], mod, 1);
	for (int i = n + k; i >= 1; --i)  inv[i - 1] = (int64) inv[i] * i % mod;
}
int main()  {
	scanf("%d", &n), prepare();
	for (int i = 1; i <= n; ++i)  scanf("%d", &x), ++s[x];
	for (int i = 1; i <= k; ++i)  {
		if (s[i] == 0)  continue;
		for (int j = 0; j <= k; ++j)  g[j] = f[j], f[j] = 0;
		for (int j = 0; j <= s[i]; ++j)  {
			int64 sign = j & 1 ? -1 : 1;
			for (int p = 0; p <= k; ++p)
				if (p + (i + 1) * j > k)  break;
				else  inc(f[p + (i + 1) * j], sign * g[p] * C(s[i], j) % mod);
		}
	}
	for (int i = 0; i <= k; ++i)  s[i] = C(n + i - 1, i);

	scanf("%d", &m);
	for (int i = 1; i <= m; ++i)  {
		scanf("%d", &x);
		int ans = 0;
		for (int j = 0; j <= x; ++j)  inc(ans, (int64) f[j] * s[x - j] % mod);
		printf("%d\n", ans);
	}
}

# include <iostream>
# include <fstream>
# include <sstream>
# include <iomanip>
# include <algorithm>
# include <numeric>
# include <cstdio>
# include <cmath>
# include <cstdlib>
# include <cstring>
# include <vector>
# include <list>
# include <set>
# include <map>
# include <stack>
# include <queue>
# include <deque>
# define inf 1000000007
using namespace std;
typedef unsigned long long int ulli;
int main() {
    #ifndef ONLINE_JUDGE
        freopen("../input.txt","r",stdin);
    #endif
	int t;
	int N, a, b, c, d, k, Q;

	bool vis[1005][2];
	scanf("%d", &t);
	while(t--) {

		scanf("%d %d %d %d %d %d %d", &N, &a, &b, &c, &d, &k, &Q);

		for(int i=0;i<=1000;i++) {		
			vis[i][0] = false;
			vis[i][1] = false;
		}
		int res = inf;
		int iter = 0, steps, currN, applied;
		queue< pair< pair<int, int>, int> > q;
		q.push(make_pair(make_pair(N, 0), 1));
                q.push(make_pair(make_pair(N%d, 1), 0));
		while(!q.empty()) {
			iter++;

			currN = q.front().first.first;
			steps = q.front().first.second;
			applied = q.front().second;

			q.pop();

			if(Q%k == (currN%k)) {
				res = steps;
				break;
			}

			if(vis[currN][applied]) {
				continue;
			}
			vis[currN][applied] = true;
			steps++;

			if(applied == 0) {
				//q.push(make_pair(make_pair(currN % d, steps), 0));
				q.push(make_pair(make_pair((currN + a)%d, steps), 0));
				q.push(make_pair(make_pair(((currN - b)%d + d)%d, steps), 0));
				q.push(make_pair(make_pair((currN * c)%d, steps), 0));
			}

			q.push(make_pair(make_pair((currN + a)%k, steps), 1));
			q.push(make_pair(make_pair(((currN - b)%k + k)%k, steps), 1));
			q.push(make_pair(make_pair((currN * c)%k, steps), 1));
		}
		if(res == inf)
			printf("-1\n");
		else
			printf("%d\n", res);
	}
    return 0;
}
#include<stdio.h>

int main()
{
    int t,m;
    char str[100001];
    int i,min,swaps;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%s%d",str,&m);
        swaps=0;
        for(i=0;i<m;i++)
        {
            if(str[i]=='B')
                swaps++;
        }
        min=swaps;
        while(str[i] && min!=0)
        {
            if(str[i-m]=='A' && str[i]=='B')
                swaps++;
            else if(str[i-m]=='B' && str[i]=='A')
                swaps--;
            if(swaps<min)
                min=swaps;
            i++;
        }
        printf("%d\n",min);
    }
    return 0;
}

#include<stdio.h>

long long gcd(long long p, long long q)
{
    if(p==q || p==0)
        return q;
    else if (q==0)
        return p;
    else if(p>q)
        return gcd(q,p%q);
    else
        return  gcd(p,q%p);
}

int main()
{
    int t;
    long long p,q,r;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%lld%lld",&p,&q);
        r=gcd(p,q);
        p=p/r;
        q=q/r;
        if(p==1)
        {
            if(q&(q-1)==0)
                printf("YES\n");
            else
            {
                while(q%2==0)
                {
                    q=q>>1;
                }
                if(((q+1)&q)==0)
                    printf("YES\n");
                else
                    printf("NO\n");
            }

        }
        else if(p<=q+1 && (p&(p-1))==0 && ((q+1)&q)==0  )
            printf("YES\n");
        else
            printf("NO\n");

    }
    return 0;
}

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int[] primes = sieveEratosthenes(100000);
		int[] tots = enumTotient(100000, primes);
		
		int n = ni();
		int K = ni();
		int[] from = new int[n-1];
		int[] to = new int[n-1];
		for(int i = 0;i < n-1;i++){
			from[i] = ni()-1;
			to[i] = ni()-1;
		}
		int[][] g = packU(n, from, to);
		int[][] pars = parents3(g, 0);
		int[] a = na(n);
		int[] par = pars[0], dep = pars[2];
		int[][] spar = logstepParents(par);
		
		for(int i = 0;i < K;i++){
			char t = nc();
			if(t == 'U'){
				int x = ni()-1;
				a[x] = ni();
			}else{
				int x = ni()-1, y = ni()-1, mod = ni();
				int lca = lca2(x, y, spar, dep);
				int[] path = new int[23];
				int[] pes = new int[23];
				int p = 0;
				path[p] = a[x]; pes[p] = mod; p++;
				while(x != lca){
					x = par[x];
					path[p] = a[x]; pes[p] = tots[pes[p-1]]; p++;
					if(pes[p-1] == 1)break;
				}
				if(pes[p-1] != 1){
					int rem = dep[y]-dep[lca]-1;
					while(rem >= 0){
						x = ancestor(y, rem, spar);
						path[p] = a[x]; pes[p] = tots[pes[p-1]]; p++;
						if(pes[p-1] == 1)break;
						rem--;
					}
				}
//				tr(Arrays.copyOf(path, p));
//				tr(Arrays.copyOf(pes, p));
				
				long val = 1;
				double z = 1;
				boolean big = false;
				for(int j = p-1;j >= 0;j--){
					val = pow(path[j], val+(big?tots[pes[j]]:0), pes[j]);
					if(path[j] == 1){
						z = 1;
						big = false;
					}else if(!big){
						z = Math.pow(path[j], z);
						if(z >= pes[j]){
							big = true;
						}
					}
				}
				out.println(val);
			}
		}
		
		
	}
	
	public static long pow(long a, long n, long mod) {
		a %= mod;
		long ret = 1;
		int x = 63 - Long.numberOfLeadingZeros(n);
		for(;x >= 0;x--){
			ret = ret * ret % mod;
			if(n << 63 - x < 0)
				ret = ret * a % mod;
		}
		return ret;
	}
	
	public static int[] sieveEratosthenes(int n) {
		if(n <= 32){
			int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
			for(int i = 0;i < primes.length;i++){
				if(n < primes[i]){
					return Arrays.copyOf(primes, i);
				}
			}
			return primes;
		}

		int u = n + 32;
		double lu = Math.log(u);
		int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)];
		ret[0] = 2;
		int pos = 1;

		int[] isp = new int[(n + 1) / 32 / 2 + 1];
		int sup = (n + 1) / 32 / 2 + 1;

		int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
		for(int tp : tprimes){
			ret[pos++] = tp;
			int[] ptn = new int[tp];
			for(int i = (tp - 3) / 2;i < tp << 5;i += tp)
				ptn[i >> 5] |= 1 << (i & 31);
			for(int i = 0;i < tp;i++){
				for(int j = i;j < sup;j += tp)
					isp[j] |= ptn[i];
			}
		}

		// 3,5,7
		// 2x+3=n
		int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4,
				13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };
		int h = n / 2;
		for(int i = 0;i < sup;i++){
			for(int j = ~isp[i];j != 0;j &= j - 1){
				int pp = i << 5 | magic[(j & -j) * 0x076be629 >>> 27];
				int p = 2 * pp + 3;
				if(p > n)
					break;
				ret[pos++] = p;
				for(int q = pp;q <= h;q += p)
					isp[q >> 5] |= 1 << (q & 31);
			}
		}

		return Arrays.copyOf(ret, pos);
	}
	
	public static int[] enumTotient(int n, int[] primes)
	{
		int[] ret = new int[n+1];
		int M = (int)Math.sqrt(n)*9;
		int[][] q = new int[2][M+1];
		q[0][0] = 1;
		ret[1] = 1;
		int cu = 1, pr = 0;
		int cul = 0, prl = 1;
		for(int p : primes){
			for(int i = 0;i < prl;i++){
				long prq = q[pr][i];
				long cur = prq * p;
				int t = ret[q[pr][i]] * (p-1);
				while(cur <= n){
					q[cu][cul++] = (int)prq;
					ret[(int)cur] = t;
					prq = cur; cur *= p; t *= p;
				}
			}
			cu ^= 1; pr ^= 1;
			prl = cul;
			cul = 0;
		}
		return ret;
	}		
	
	public static int lca2(int a, int b, int[][] spar, int[] depth) {
		if(depth[a] < depth[b]){
			b = ancestor(b, depth[b] - depth[a], spar);
		}else if(depth[a] > depth[b]){
			a = ancestor(a, depth[a] - depth[b], spar);
		}

		if(a == b)
			return a;
		int sa = a, sb = b;
		for(int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer
				.numberOfTrailingZeros(t);t > 0;t >>>= 1, k--){
			if((low ^ high) >= t){
				if(spar[k][sa] != spar[k][sb]){
					low |= t;
					sa = spar[k][sa];
					sb = spar[k][sb];
				}else{
					high = low | t - 1;
				}
			}
		}
		return spar[0][sa];
	}

	protected static int ancestor(int a, int m, int[][] spar) {
		for(int i = 0;m > 0 && a != -1;m >>>= 1, i++){
			if((m & 1) == 1)
				a = spar[i][a];
		}
		return a;
	}

	public static int[][] logstepParents(int[] par) {
		int n = par.length;
		int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;
		int[][] pars = new int[m][n];
		pars[0] = par;
		for(int j = 1;j < m;j++){
			for(int i = 0;i < n;i++){
				pars[j][i] = pars[j - 1][i] == -1 ? -1
						: pars[j - 1][pars[j - 1][i]];
			}
		}
		return pars;
	}
	
	public static int[][] parents3(int[][] g, int root) {
		int n = g.length;
		int[] par = new int[n];
		Arrays.fill(par, -1);

		int[] depth = new int[n];
		depth[0] = 0;

		int[] q = new int[n];
		q[0] = root;
		for(int p = 0, r = 1;p < r;p++){
			int cur = q[p];
			for(int nex : g[cur]){
				if(par[cur] != nex){
					q[r++] = nex;
					par[nex] = cur;
					depth[nex] = depth[cur] + 1;
				}
			}
		}
		return new int[][] { par, q, depth };
	}
	
	static int[][] packU(int n, int[] from, int[] to) {
		int[][] g = new int[n][];
		int[] p = new int[n];
		for(int f : from)
			p[f]++;
		for(int t : to)
			p[t]++;
		for(int i = 0;i < n;i++)
			g[i] = new int[p[i]];
		for(int i = 0;i < from.length;i++){
			g[from[i]][--p[from[i]]] = to[i];
			g[to[i]][--p[to[i]]] = from[i];
		}
		return g;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include <iostream>
#include <cstring>

using namespace std;

int source, sink, n, m;
int cap[201][201], vis[201], node, a[201][201], aa[201][201];
int totr, totc, r[201], c[201];

bool flow(int pos)
{
    if(vis[pos] == node) return false;
    vis[pos] = node;
    for(int i = 0; i < n+m+2; i++) {
        if(!cap[pos][i]) continue;
        if(i == sink) {
            cap[pos][i]--;
            cap[i][pos]++;
            if(pos < n) {
                a[pos][i] = 1;
            }
            else {
                a[i][pos] = 0;
            }
            return true;
        }
        if(flow(i)) {
            cap[pos][i]--;
            cap[i][pos]++;
            if(pos < n) {
                a[pos][i] = 1;
            }
            else {
                a[i][pos] = 0;
            }
            return 1;
        }
    }
    return false;
}

int main()
{
    int t;
    ios_base::sync_with_stdio(false);
    cin >> t;
    int cs = 0;
    while(t--) {
        cin >> n >> m;
        cs++;
        cout << "TestCase #:" << cs << endl;
        totr = totc = 0;
        for(int i = 0; i < n; i++) cin >> r[i], totr += r[i];
        for(int j = 0; j < m; j++) cin >> c[j], totc += c[j];
        source = n+m;
        sink = n+m+1;
        memset(cap, 0, sizeof(cap));
        memset(aa, 0, sizeof(aa));
        memset(a, 0, sizeof(a));
        memset(vis, 0, sizeof(vis));
        for(int i = 0; i < n; i++) {
            cap[source][i] = r[i];
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                cap[i][j+n] = 1;
            }
        }

        for(int i = 0; i < m; i++) {
            cap[i+n][sink] = c[i];
        }
        int ans = 0;
        node = 1;
        while(flow(source)) {
            node++;
            ans++;
        }
        //cout << ans << endl;
        if(ans != totr || totr != totc) {
            cout << -1 << endl;
            continue;
        }
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(cap[j+n][i] == 1) {
                    cap[j+n][i] = 0;
                    cap[source][i]++;
                    cap[i][source]--;
                    cap[j+n][sink]++;
                    cap[sink][j+n]--;
                    node++;
                    if(!flow(source)) {
                        cap[j+n][i] = 1;
                        cap[source][i]--;
                        cap[i][source]++;
                        cap[j+n][sink]--;
                        cap[sink][j+n]++;
                    }
                }
                else {
                    cap[i][n+j] = 0;
                }
            }
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                cout << cap[j+n][i];
            }
            cout << endl;
        }

    }
}

    #include <bits/stdc++.h>
     
    using namespace std;
     
    int main (){
    int t, L, K;
    char str[1000002];
    std::vector<int> v;
     
    scanf("%d",&t);
    while(t--){
    v.clear();
    scanf("%s %d %d",str,&K,&L);
    int l = strlen(str), ct=1;
    for(int i=1;i<=l;++i)
    {
    if(str[i]==str[i-1]) ct++;
    else{
    v.push_back(ct);
    ct=1;
    }
    }
    sort(v.begin(), v.end(), greater<int>());
    l = v.size();
    int ans = 0, an;
    for(int i=0;i<l;++i)
    {
    ans += min(v[i],K);
    v[i]-=K;
    }
    if(ans>=L){
    printf("%d\n",L);
    continue;
    }
    an = ans;
    for(int i=0;i<l;++i){
    int need = L-an;
    if(need<=0 || v[i]<=0) break;
    if(v[i]>=need){
    ans += need + (need+K-1)/K;
    an += need;
    v[i] -= need;
    }
    else{
    int q = v[i]/K;
    if(q!=0){
    ans += q*(K+1);
    an += q*K;
    v[i] -= q*K;
    }
    }
    }
    if(an >= L){
    printf("%d\n",ans);
    continue;
    }
    sort(v.begin(), v.end(), greater<int>());
    for(int i=0;i<l;++i)
    {
    if(v[i]<=0) break;
    int need = L-an;
    if(need<=0) break;
    if(v[i]>=need){
    ans += need + 1,
    an += need;
    v[i] -= need;
    }
    else{
    ans += v[i] + 1,
    an += v[i];
    v[i] -= v[i];
    }
    }
    if(an >= L){
    printf("%d\n",ans);
    continue ;
    }
    //printf("%d\n",2*L-1);
    }
    return 0;
    } 
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		// E_cur = sum_pre E_pre * p(pre->cur) + P_cur * t_cur
		// E_cur = (sum_pre E_pre+(sum P_pre)*t_cur) * p(pre->cur)
		// P_cur = sum_pre P_pre * p(pre->cur)
		int cas = 1;
		while(true){
			int n = ni(), m = ni(), Q = ni();
			if(n == 0 && m == 0 && Q == 0)break;
			int[][] rates = new int[n][n];
			int[] ratesum = new int[n];
			int[][] dats = new int[m][];
			DJSet ds = new DJSet(n);
			for(int i = 0;i < m;i++){
				int f = ni()-1, t = ni()-1;
				ds.union(f, t);
				rates[f][t] = rates[t][f] = ni();
				ratesum[f] += rates[f][t];
				ratesum[t] += rates[t][f];
				dats[i] = new int[]{f, t, ni(), ni()};
			}
			out.println("Case #" + (cas++) + ":");
			double[][] M = new double[2*n][2*n];
			for(int i = 0;i < m;i++){
				int f = dats[i][0];
				int t = dats[i][1];
				double p1 = (double)rates[f][t]/ratesum[f];
				double p2 = (double)rates[t][f]/ratesum[t];
				M[t+n][f+n] += p1;
				M[t][f] += p1;
				M[f+n][t+n] += p2;
				M[f][t] += p2;
				M[t+n][f] += p1 * dats[i][2];
				M[f+n][t] += p2 * dats[i][3];
//				M[t+n][f+n] = M[t][f] = 
//				M[f+n][t+n] = M[f][t] = 
//				M[t+n][f] += M[t][f] * dats[i][2];
//				M[f+n][t] += M[f][t] * dats[i][3];
			}
			int[] map = new int[n];
			int z = 0;
			for(int i = 0;i < n;i++){
				if(ds.equiv(i, 0)){
					map[i] = z++;
				}else{
					map[i] = -1;
				}
			}
			double[][] T = new double[2*z][2*z];
			for(int i = 0;i < n;i++){
				for(int j = 0;j < n;j++){
					if(map[i] != -1 && map[j] != -1){
						T[map[i]][map[j]] = M[i][j];
						T[map[i]+z][map[j]] = M[i+n][j];
						T[map[i]][map[j]+z] = M[i][j+n];
						T[map[i]+z][map[j]+z] = M[i+n][j+n];
					}
				}
			}
			
			for(int q = 0;q < Q;q++){
				int al = ni()-1;
				if(!ds.equiv(0, al)){
					out.println("INFINITE");
					continue;
				}
				al = map[al];
				double e = 0;
				{
					double[][] MM = new double[2*z][];
					for(int i = 0;i < 2*z;i++){
						MM[i] = Arrays.copyOf(T[i], 2*z);
					}
					for(int i = 0;i < z;i++){
						MM[i][al] = 0;
						MM[i+z][al] = 0;
						MM[i+z][al+z] = 0;
					}
					
					double[] v = new double[2*z];
					v[0] = 1;
					double[] st = steady(MM, v);
					if(st == null){
						e = Double.POSITIVE_INFINITY;
					}else{
						e += st[al+z];
					}
				}
				{
					double[][] MM = new double[2*z][];
					for(int i = 0;i < 2*z;i++){
						MM[i] = Arrays.copyOf(T[i], 2*z);
					}
					for(int i = 0;i < z;i++){
						MM[i][0] = 0;
						MM[i+z][0] = 0;
						MM[i+z][0+z] = 0;
					}
					
					double[] v = new double[2*z];
					v[al] = 1;
					double[] st = steady(MM, v);
					if(st == null){
						e = Double.POSITIVE_INFINITY;
					}else{
						e += st[0+z];
					}
				}
				if(e == Double.POSITIVE_INFINITY){
					out.println("INFINITE");
				}else{
					out.printf("%.4f\n", e);
				}
			}
		}
	}
	
	public static class DJSet {
		public int[] upper;

		public DJSet(int n) {
			upper = new int[n];
			Arrays.fill(upper, -1);
		}

		public int root(int x) {
			return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
		}

		public boolean equiv(int x, int y) {
			return root(x) == root(y);
		}

		public boolean union(int x, int y) {
			x = root(x);
			y = root(y);
			if (x != y) {
				if (upper[y] < upper[x]) {
					int d = x;
					x = y;
					y = d;
				}
				upper[x] += upper[y];
				upper[y] = x;
			}
			return x == y;
		}

		public int count() {
			int ct = 0;
			for (int u : upper)
				if (u < 0)
					ct++;
			return ct;
		}
	}
	
	public static double[] mul(double[][] A, double[] v)
	{
		int m = A.length;
		int n = v.length;
		double[] w = new double[m];
		for(int i = 0;i < m;i++){
			double sum = 0;
			for(int k = 0;k < n;k++){
				sum += A[i][k] * v[k];
			}
			w[i] = sum;
		}
		return w;
	}
	
	// double行列の2乗
	public static double[][] p2(double[][] A)
	{
		int n = A.length;
		double[][] C = new double[n][n];
		for(int i = 0;i < n;i++){
			for(int k = 0;k < n;k++){
				for(int j = 0;j < n;j++){
					C[i][j] += A[i][k] * A[k][j];
				}
			}
		}
		return C;
	}
	
	// A^e*v
	public static double[] pow(double[][] A, double[] v, int m)
	{
		double[][] mu = A;
		double[] r = v;
		for(;m > 0;m>>>=1){
			if((m&1)==1)r = mul(mu, r);
			mu = p2(mu);
		}
		return r;
	}
	
	public static double[] steady(double[][] T, double[] v)
	{
		int n = T.length;
		double[][] U = new double[n][n];
		for(int i = 0;i < n;i++){
			for(int j = 0;j < n;j++){
				U[i][j] = (i == j ? 1 : 0) - T[i][j];
			}
		}
		return solve(U, v);
	}
	
	public static double[] solve(double[][] a, double[] c)
	{
		int n = a.length;
		int[] ps = new int[n];
		for(int i = 0;i < n;i++)ps[i] = i;
		
		// Forward Elimination
		for(int i = 0;i < n;i++){
			int pivot = -1;
			int from = -1;
			double amax = 0;
			for(int j = i;j < n;j++){
				if(Math.abs(a[ps[j]][i]) > amax){
					amax = Math.abs(a[ps[j]][i]);
					pivot = ps[j];
					from = j;
				}
			}
			if(pivot == -1)return null;
			int d = ps[i]; ps[i] = ps[from]; ps[from] = d;
			
			for(int j = i+1;j < n;j++){
				a[ps[i]][j] /= a[ps[i]][i];
			}
			c[ps[i]] /= a[ps[i]][i];
			a[ps[i]][i] = 1.0;
			for(int j = i+1;j < n;j++){
				for(int k = i+1;k < n;k++){
					a[ps[j]][k] -= a[ps[j]][i] * a[ps[i]][k];
				}
				c[ps[j]] -= a[ps[j]][i] * c[ps[i]];
				a[ps[j]][i] = 0.0;
			}
			
		}
		
		// Back Substitution
		for(int i = n-1;i >= 0;i--){
			for(int j = i-1;j >= 0;j--){
				c[ps[j]] -= a[ps[j]][i] * c[ps[i]];
			}
		}
		
		double[] ret = new double[n];
		for(int i = 0;i < n;i++){
			ret[i] = c[ps[i]];
		}
		
		return ret;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
const int MAXN = 200, MAXM = 600 + 10;

struct Edge {
  int u, v, w, c;
  bool operator < (const Edge &rhs) const {
    return w == rhs.w ? c < rhs.c : w < rhs.w;
  }
} E[MAXM];
int L[MAXM], R[MAXM], H[MAXM];
int dsu[MAXN], n, m1, m2, x;

int get(int x) {
  if (x != dsu[x]) dsu[x] = get(dsu[x]);
  return dsu[x];
}

bool ok(int need) {
  for (int i = 1; i <= n; ++i) dsu[i] = i;
  for (int i = 0; i < m1 + m2; ++i) {
    int u = get(L[i]), v = get(R[i]);
    if (u != v) dsu[u] = v;
  }
  for (int i = 1; i <= n; ++i) {
    if (get(i) != get(1)) return 0;
  }
  int low = 0, upp = 0;
  for (int i = 1; i <= n; ++i) dsu[i] = i;
  for (int i = 0; i < m1; ++i) {
    int u = get(L[i]), v = get(R[i]);
    if (u != v) dsu[u] = v, ++upp;
  }
  for (int i = 1; i <= n; ++i) dsu[i] = i;
  for (int i = m1; i < m1 + m2; ++i) {
    int u = get(L[i]), v = get(R[i]);
    if (u != v) dsu[u] = v, ++low;
  }
  low = n - 1 - low;
  return need >= low && need <= upp;
}

PII check(int add) {
  for (int i = 1; i <= n; ++i) dsu[i] = i;
  for (int i = 0; i < m1 + m2; ++i) {
    E[i] = (Edge){L[i], R[i], H[i], i >= m1};
    if (i < m1) E[i].w += add;
  }
  sort(E, E + m1 + m2);
  int tot(0), cnt(0);
  for (int i = 0; i < m1 + m2; ++i) {
    int u = get(E[i].u), v = get(E[i].v);
    if (u != v) {
      dsu[u] = v; cnt += !E[i].c;
      tot += E[i].w;
    }
  }
  return PII(tot, cnt);
}

int solve(int need) {
  if (!ok(need)) return -1;
  int l = -105, r = 105, tot;
  while (l <= r) {
    int m = (l + r) >> 1;
    PII now = check(m);
    if (now.second >= need) l = m + 1, tot = now.first - need * m;
    else r = m - 1;
  }
  return tot;
}

void run() {
  scanf("%d%d%d%d", &n, &m1, &m2, &x);
  for (int i = 0; i < m1 + m2; ++i) {
    scanf("%d%d%d", L + i, R + i, H + i);
  }
  int a = solve(x);
  int b = solve(n - 1 - x);
  if (a == -1) a = b;
  else if (b != -1) a = min(a, b);
  printf("%d\n", a);
}

int main() {
  int T; scanf("%d", &T);
  for (int cas = 1; cas <= T; ++cas) run();
  return 0;
}

t = int(input())
for i in range(t):
    n = int(input())
    l = map(int, raw_input().split())
    count = 0
    pslope = 0
    for i in range(len(l)-1):
        cslope = l[i+1]-l[i]
        if(pslope!=0):
            if((cslope>0 and pslope<0) or (cslope<0 and pslope>0)):
                count = count + 1
        pslope = cslope
    print count

a=[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073L, 4807526976L, 7778742049L, 12586269025L, 20365011074L, 32951280099L, 53316291173L, 86267571272L, 139583862445L, 225851433717L, 365435296162L, 591286729879L, 956722026041L, 1548008755920L, 2504730781961L, 4052739537881L, 6557470319842L, 10610209857723L, 17167680177565L, 27777890035288L, 44945570212853L, 72723460248141L, 117669030460994L, 190392490709135L, 308061521170129L, 498454011879264L, 806515533049393L, 1304969544928657L, 2111485077978050L, 3416454622906707L, 5527939700884757L, 8944394323791464L, 14472334024676221L, 23416728348467685L, 37889062373143906L, 61305790721611591L, 99194853094755497L, 160500643816367088L, 259695496911122585L, 420196140727489673L, 679891637638612258L, 1100087778366101931L, 1779979416004714189L, 2880067194370816120L, 4660046610375530309L, 7540113804746346429L, 12200160415121876738L, 19740274219868223167L, 31940434634990099905L, 51680708854858323072L, 83621143489848422977L, 135301852344706746049L, 218922995834555169026L, 354224848179261915075L, 573147844013817084101L, 927372692193078999176L, 1500520536206896083277L, 2427893228399975082453L, 3928413764606871165730L, 6356306993006846248183L, 10284720757613717413913L, 16641027750620563662096L, 26925748508234281076009L, 43566776258854844738105L, 70492524767089125814114L, 114059301025943970552219L, 184551825793033096366333L, 298611126818977066918552L, 483162952612010163284885L, 781774079430987230203437L, 1264937032042997393488322L, 2046711111473984623691759L, 3311648143516982017180081L, 5358359254990966640871840L, 8670007398507948658051921L, 14028366653498915298923761L]
import sys
t=sys.stdin.readline()
t=int(t)
for i in xrange(t):
    x=sys.stdin.readline()
    x=int(x)
    if x in a:
        print "YES"
    else:
        print "NO"

t=raw_input()
t=int(t)
while t:
    t-=1
    n=raw_input()
    n=int(n)
    for i in xrange(1,n):
        j=i
        sum=i
        while j:
            sum+=j%10
            j/=10
        if sum==n:
            j=-1
            break
    if j!=-1:
        print "NONE"
    else:
        print i
t=input()
while t>0:
	A=map(str,raw_input().split())
	B=[]
	for i in xrange(len(A)):
		c=A[i]
		B.append(c[::-1])
	print " ".join(B)
	t=t-1
	
	
#include<bits/stdc++.h>

using namespace std;

int func(int a1){
	int ans =0;
	while(a1>0){
		ans+= a1%2;
		ans++;
		a1 /= 2;
	}
	ans-=2;
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
   int T;
	cin>>T;
	while(T--){
	int n;
	cin>>n;
	int a = n, b =0, ans = 0,a1 = n;
	ans = func(a1);
//	cout<<ans<<endl;
	int anscp = ans, ansc = ans;
	int n1 = n/2, n2 = n/2 + n%2;
	anscp = min(anscp, max(func(n1),func(n2)) );
	while(a>0){
//		cout<<max(func(a),func(b))<<' '<<b<<endl;
		anscp = min(anscp,max(func(a),func(b)));
		
		b += a&(-a);
		ans -= 1;
		a -= a&(-a);

	}

	cout<<anscp<<endl;
	}
	return 0;
}

import sys
import sets

fibo = set([1])
prev = 1
cur = 1
aux = 1
for i in range(51):
	cur += aux
	fibo.add(cur)
	aux = prev
	prev = cur

ntest = int(sys.stdin.readline().strip())
for i in range(ntest):
	n = int(sys.stdin.readline().strip())
	if n in fibo:
		print "is fibo"
	else:
		print "not fibo" 
x = [0,1]
m = 2
l = 0
while l<1000000000:
	l = x[m-1]+x[m-2]
	x.append(l)
	m+=1
t = int(raw_input())
while t:
	t -= 1
	n = int(raw_input())
	if n in x:
		print 'Yes'
	else:
		print 'No'
read = lambda: map(int, raw_input().split())
read_s = lambda: map(str, raw_input().split())

def dfs(x, nums):
    if x > 1e10: return
    nums.append(x)
    dfs(x * 10 + 4, nums)
    dfs(x * 10 + 3, nums)

nums = []
dfs(0, nums)
nums.sort()
n, = read()
print nums[n]
a=input()
b=input()
print "Result =",a+b 
def factorial(n):
	if n == 0:
		return 1
	return n*factorial(n-1)
n = int(input())
print factorial(n)
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int dp[455][455][455];
int main()
{
    string a,b,c;
    int t,i,j,k,l;
    cin>>t;
    while(t--)
    {
        cin>>a>>b>>c;
        l=a.length();
        for(i=0;i<=l;i++)
            for(j=0;j<=l;j++)
                dp[0][i][j]=dp[i][0][j]=dp[i][j][0]=0;
        for(i=1;i<=l;i++)
            for(j=1;j<=l;j++)
                for(k=1;k<=l;k++)
                    if(a[i-1]==b[j-1]&&b[j-1]==c[k-1])
                        dp[i][j][k]=1+dp[i-1][j-1][k-1];
                    else
                        dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),dp[i][j][k-1]);
        cout<<3*(l-dp[l][l][l])<<endl;
    }
    return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll MOD=1000000007;
long long int power(long long int a, long long int b)
{
    long long int x=1,y=a;
    while(b > 0)
    {
        if(b%2 == 1)
        {
            x=(x*y);
            if(x>MOD) x%=MOD;
        }
        y = (y*y);
        if(y>MOD) y%=MOD;
        b /= 2;
    }
    return x;
}
ll f(ll n)
{
    ll res=power(n,4);
    res=(res-(6*power(n,3))%MOD+MOD)%MOD;
    res=(res+(23*power(n,2))%MOD)%MOD;
    res=(res-(42*n)%MOD+MOD)%MOD;
    res=(res+24)%MOD;
    res=(res*power(24,MOD-2))%MOD;
    res=(res+n)%MOD;
    return res;
}
int main()
{
    int t,n;
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<f(n)<<endl;
    }
    return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MAX 80000
int tree[MAX],lazy[MAX];
map<int,int> mpx,mpy;
struct rect
{
    int x1,y1,x2,y2;
};
struct query
{
    int x,y1,y2,val;
};
rect A[10005];
vector<query> v;
bool comp(query a,query b)
{
    if(a.x==b.x)
        return a.val>b.val;
    return a.x<b.x;
}
void update_tree(int node, int a, int b, int i, int j, int value)
{
  	if(lazy[node] != 0)
    {
   		tree[node] += lazy[node];
		if(a != b)
		{
			lazy[node*2] += lazy[node];
            lazy[node*2+1] += lazy[node];
		}
   		lazy[node] = 0;
  	}
	if(a > b || a > j || b < i)
		return;
  	if(a >= i && b <= j)
  	{
        tree[node] += value;
		if(a != b)
		{
			lazy[node*2] += value;
			lazy[node*2+1] += value;
		}
        return;
	}
	update_tree(node*2, a, (a+b)/2, i, j, value);
	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value);
	tree[node] = max(tree[node*2],tree[node*2+1]);
}
int query_tree(int node, int a, int b, int i, int j)
{
	if(a > b || a > j || b < i)
        return 0;
	if(lazy[node] != 0)
	{
		tree[node] += lazy[node];
		if(a != b)
		{
			lazy[node*2] += lazy[node];
			lazy[node*2+1] += lazy[node];
		}
		lazy[node] = 0;
	}
	if(a >= i && b <= j)
		return tree[node];
	int q1 = query_tree(node*2, a, (a+b)/2, i, j);
	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j);
	int res = max(q1,q2);
	return res;
}
int main()
{
	int t,n,i,szx,szy,res;
	map<int,int>::iterator it;
	query q;
	cin>>t;
	while(t--)
	{
	    memset(lazy, 0, sizeof lazy);
	    memset(tree,0,sizeof tree);
	    mpx.clear();
	    mpy.clear();
	    v.clear();
	    cin>>n;
	    for(i=0;i<n;i++)
        {
            cin>>A[i].x1>>A[i].y1>>A[i].x2>>A[i].y2;
            mpx[A[i].x1]++;
            mpy[A[i].y1]++;
            mpx[A[i].x2]++;
            mpy[A[i].y2]++;
        }
        szx=szy=0;
        for(it=mpx.begin();it!=mpx.end();it++)
            it->second=szx++;
        for(it=mpy.begin();it!=mpy.end();it++)
            it->second=szy++;
        for(i=0;i<n;i++)
        {
            q.x=mpx[A[i].x1];
            q.y1=mpy[A[i].y1];
            q.y2=mpy[A[i].y2];
            q.val=1;
            v.push_back(q);
            q.x=mpx[A[i].x2];
            q.val=-1;
            v.push_back(q);
        }
        sort(v.begin(),v.end(),comp);
        for(i=res=0;i<v.size();i++)
        {
            update_tree(1,0,szy-1,v[i].y1,v[i].y2,v[i].val);
            res=max(res,query_tree(1,0,szy-1,0,szy-1));
        }
        cout<<res<<endl;
	}
}

#include<iostream>
using namespace::std;

struct node{
	int v;
	node* next;


	node()
	{
		next = NULL;
	}
};


struct LinkedList{
	node* head;
	node* tail;

	LinkedList()
	{
		head= NULL;
		tail = NULL;
	}

	void add(int v)
	{
		node* temp = new node;
		temp->v = v;
		//temp->length = l;

		if(head==NULL)
			{
				head=temp;
				tail = head;
				return ; 
			}

		tail->next = temp;
		tail = temp;	

	}

};


class Graph{

	public:
	LinkedList* al;
	int* marked;
	int n,m,l;
	int count;
	
	public:
	void input()
	{
		cin>>n;
		m=n-1;
		al = new LinkedList[n+1];
		marked = new int[n+1];
		count=0;
		int i,j,k,temp;
		for(i=0;i<m;i++)
		{
			cin>>j>>k;
			temp=j;
		//	j=max(j,k);
		//	k=min(temp,k);
			al[k].add(j);
			al[j].add(k);
		}

		for(i=1;i<=n;i++)
		marked[i]=0;
		
		cin>>l;
		for(i=0;i<l;i++)
		{
			cin>>j;
			solution(j);
			cout<<n-count<<"\n";
		}
	}

	void solution(int s)
	{
	 	int i,j,k;

	 	i=s;

	 	//marked[i]=0;

	 	while(i!=1 && marked[i]==0)
	 	{
	 		marked[i]=1;
	 		count++;
	 		i=al[i].head->v;
	 		//i=1;
	 	}

	 	if(i==1 && marked[i]==0)
	 	{
	 		marked[i]=1;
	 		count++;
	 	}
	}
	void clear()
	{
		delete[] al;		
	}

};


int main()
{
	int t;
	cin>>t;
	
	Graph g;	
	
	while(t--)
	{
		
		g.input();
		g.clear();
	}
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair <int,int> pii;
typedef vector <int> vi;

#define rep(i, n) for(int i = 0; i < (n); ++i)

#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define all(c) c.begin(), c.end()
#define mset(a, v) memset(a, v, sizeof(a))
#define sz(a) ((int)a.size())

#define gi(x) scanf("%d", &x)
#define pis(x) printf("%d ", x)
#define pin(x) printf("%d\n", x)
#define pnl printf("\n")
#define dbn cerr << "\n"
#define dbg(x) cerr << #x << " : " << (x) << " "
#define dbs(x) cerr << (x) << " "

const int maxN = 101;
const int maxM = 101;

int st[maxN], en[maxN];
int b[maxM], e[maxM], req[maxM];

const int inf = 0x3f3f3f3f;

struct edge {
    int x, y, cap, flow;
};

struct DinicFlow {
    vector <edge> e;
    vector <int> cur, d;
    vector < vector <int> > adj;
    int n, source, sink;

    DinicFlow() {}

    DinicFlow(int v) {
        n = v;
        cur = vector <int> (n + 1);
        d = vector <int> (n + 1);
        adj = vector < vector <int> > (n + 1);
    }

    void addEdge(int from, int to, int cap) {
        edge e1 = {from, to, cap, 0};
        edge e2 = {to, from, 0, 0};
        adj[from].push_back(e.size()); e.push_back(e1);
        adj[to].push_back(e.size()); e.push_back(e2);
    }

    int bfs() {
        queue <int> q;
        for(int i = 0; i <= n; ++i) d[i] = -1;
        q.push(source); d[source] = 0;
        while(!q.empty() and d[sink] < 0) {
            int x = q.front(); q.pop();
            for(int i = 0; i < (int)adj[x].size(); ++i) {
                int id = adj[x][i], y = e[id].y;
                if(d[y] < 0 and e[id].flow < e[id].cap) {
                    q.push(y); d[y] = d[x] + 1;
                }
            }
        }
        return d[sink] >= 0;
    }

    int dfs(int x, int flow) {
        if(!flow) return 0;
        if(x == sink) return flow;
        for(;cur[x] < (int)adj[x].size(); ++cur[x]) {
            int id = adj[x][cur[x]], y = e[id].y;
            if(d[y] != d[x] + 1) continue;
            int pushed = dfs(y, min(flow, e[id].cap - e[id].flow));
            if(pushed) {
                e[id].flow += pushed;
                e[id ^ 1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    int maxFlow(int src, int snk) {
        this->source = src; this->sink = snk;
        int flow = 0;
        while(bfs()) {
            for(int i = 0; i <= n; ++i) cur[i] = 0;
            while(int pushed = dfs(source, inf)) {
                flow += pushed;
            }
        }
        return flow;
    }
};

int main() {
    #ifdef LOCAL
    freopen("in.txt", "r", stdin);
    #endif
    
    int T;
    gi(T);

    rep (tc, T) {

        int n, m;
        gi(n), gi(m);

        vi v;

        rep (i, n) {
            gi(st[i]), gi(en[i]);
            v.pb(st[i]);
            v.pb(en[i]);
        }

        rep (i, m) {
            gi(b[i]), gi(e[i]), gi(req[i]);
            v.pb(b[i]);
            v.pb(e[i]);
        }

        sort(all(v));
        v.resize(unique(all(v)) - v.begin());

        DinicFlow mf(2 + n + m + sz(v) - 1);

        int nodes = 2 + n + m + sz(v) - 1;
        
        int src = 0;
        int sink = nodes - 1;

        rep (i, n) {
            mf.addEdge(src, i + 1, inf);

            rep (j, sz(v) - 1) {
                if (v[j] >= st[i] and v[j + 1] <= en[i]) {
                    mf.addEdge(i + 1, n + 1 + j, (v[j + 1] - v[j]));
                }
            }
        }

        rep (i, m) {
            mf.addEdge(n + 1 + sz(v) - 1 + i, sink, req[i]);

            rep (j, sz(v) - 1) {
                if (v[j] >= b[i] and v[j + 1] <= e[i]) {
                    mf.addEdge(n + 1 + j, n + 1 + sz(v) - 1 + i, (v[j + 1] - v[j]));
                }
            }
        }

        int flow = mf.maxFlow(src, sink);

        int required = 0;
        rep (i, m) required += req[i];

        puts(flow == required ? "YES" : "NO");
    }

    return 0;
}
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5005;
vector <int> G[MAXN], T[MAXN];
vector < pair<int,int> > bridges;
int par[MAXN], depth[MAXN], lo[MAXN];
bool vis[MAXN], is_imp[MAXN];
int parent(int pos)
{
	if(par[pos] != pos)
		par[pos] = parent(par[pos]);
	return par[pos];
}
void bridge_dfs(int pos, int prev)
{
	vis[pos] = true;
	depth[pos] = 1+depth[prev];
	lo[pos] = depth[pos];
	for (int i = 0; i < G[pos].size(); ++i)
	{
		if(G[pos][i] != prev)
		{
			if(!vis[G[pos][i]])
			{
				bridge_dfs(G[pos][i], pos);
				if(lo[G[pos][i]] <= depth[pos])
				{
					// not bridge
					lo[pos] = min(lo[pos], lo[G[pos][i]]);
					int p1 = parent(pos), p2 = parent(G[pos][i]);
					if(p1 < p2)
						par[p2] = p1;
					else
						par[p1] = p2;
				}
				else
					bridges.push_back(make_pair(pos,G[pos][i]));
			}
			else
				lo[pos] = min(lo[pos],depth[G[pos][i]]);
		}
	}
}
int leaf_dfs(int pos, int prev)
{
	vis[pos] = true;
	int ans = 0;
	if(T[pos].size() <= 1)
		ans = 1;
	for (int i = 0; i < T[pos].size(); ++i)
	{
		if(T[pos][i] != prev)
			ans+=leaf_dfs(T[pos][i],pos);
	}
	return ans;
}
int main()
{
	// freopen("input.txt", "r", stdin);
	// ios_base::sync_with_stdio(0);
	int t;
	scanf("%d", &t);
	while(t--)
	{
		int n,m,u,v;
		scanf("%d %d", &n, &m);
		for (int i = 0; i < m; ++i)
		{
			scanf("%d %d", &u, &v);
			G[u].push_back(v);
			G[v].push_back(u);
		}
		for (int i = 1; i <= n; ++i)
		{
			par[i] = i;
		}
		memset(vis, false, sizeof vis);
		for (int i = 1; i <= n; ++i)
		{
			if(!vis[i])
				bridge_dfs(i,0);
		}
		memset(vis, false, sizeof vis);
		memset(is_imp, false, sizeof is_imp);
		for (int i = 0; i < bridges.size(); ++i)
		{
			// cout<<bridges[i].first<<" "<<bridges[i].second<<" becomes\n";
			bridges[i].first = parent(bridges[i].first);
			bridges[i].second = parent(bridges[i].second);
			// cout<<bridges[i].first<<" "<<bridges[i].second<<"\n";
			T[bridges[i].first].push_back(bridges[i].second);
			T[bridges[i].second].push_back(bridges[i].first);
		}
		for (int i = 1; i <= n; ++i)
			is_imp[parent(i)] = true;
		int ans = 0, leaf_ctr = leaf_dfs(1,0);
		for (int i = 1; i <= n; ++i)
		{
			if(is_imp[i] && !vis[i])
			{
				ans++;
				int lf = leaf_dfs(i,0);
				if(lf > 1)
					lf--;
				if(leaf_ctr > 1)
					leaf_ctr--;
				leaf_ctr+=lf;
			}
		}
		if(leaf_ctr > 1)
			ans+=((leaf_ctr+1)/2);
		if(n == 2)
			printf("-1\n");
		else
			printf("%d\n", ans);
		// cleanup
		bridges.clear();
		for (int i = 1; i <= n; ++i)
		{
			G[i].clear();
			T[i].clear();
		}
	}
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int add(int a,int b)
{
    if(a==0&&b==0)
        return 0;
    if(a==0&&b==1)
        return 1;
    if(a==1&&b==0)
        return 1;
    if(a==1&&b==1)
        return 10;
}
int main()
{
    int t,i,a,b,c,sum,len1,len2;
    ll k;
    string l,s,res;
    cin>>t;
    while(t--)
    {
        cin>>l>>k;
        s.clear();
        while(k)
        {
            s.push_back((char)(k%2+'0'));
            k/=2;
        }
        len1=l.length(),len2=s.length();
        for(i=0;i<len1/2;i++)
            swap(l[i],l[len1-i-1]);
        res.clear();
        //cout<<l<<" "<<s<<endl;
        i=c=0;
        while(true)
        {
            if(i<len1)
                a=l[i]-'0';
            else
                a=0;
            if(i<len2)
                b=s[i]-'0';
            else
                b=0;
            sum=add(add(a,b),c);
            c=sum/10;
            sum%=10;
            res.push_back((char)(sum+'0'));
            i++;
            if(i>=len1&&i>=len2)
            {
                if(c)
                    res.push_back((char)(c+'0'));
                break;
            }
        }
        for(i=res.length()-1;i>=0;i--)
            cout<<res[i];
        cout<<endl;
    }
    return 0;
}

#include <iostream>
#include <string>
using namespace std;

int main() {
	
	int t;
	cin>>t;
	string a,b;
	int f=0;
	while(t--)
	{
		f=1;
		cin>>a>>b;
		int l1 = a.length();
		int l2=b.length();
		if(l1!=(l2+1))
		{
			cout<<"0\n";
			continue;
		}
		int cnt=0;
		for(int i=0,j=0;i<l1&&j<l2;)
		{
			if(a[i]==b[j])
			{
				i++;j++;
			}
			else
			{
				i++;cnt++;
			}
			if(cnt>1)
			{
				f=0;
				break;
			}
		}
		if(f)
			cout<<"1\n";
		else
			cout<<"0\n";
	}
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
bool sieve[5000005];
ll MOD=1000000007,id[200005];
vector<int> prime;
long long int power(long long int a, long long int b)
{
    long long int x=1,y=a;
    while(b > 0)
    {
        if(b%2 == 1)
        {
            x=(x*y);
            if(x>MOD) x%=MOD;
        }
        y = (y*y);
        if(y>MOD) y%=MOD;
        b /= 2;
    }
    return x;
}
int main()
{
    int i,j,t,k;
    for(i=2;i*i<=3000000;i++)
        if(!sieve[i])
        for(j=i*i;j<=3000000;j+=i)
            sieve[j]=true;
    for(i=2;i<=3000000;i++)
        if(!sieve[i])
        prime.push_back(i);
    for(i=1;i<=200000;i++)
        id[i]=power(prime[i-1],prime[i-1]);
    cin>>t;
    while(t--)
    {
        cin>>k;
        cout<<id[k]<<endl;
    }
    return 0;
}

def fact(x):
 i=1
 ans=1
 while i<=x:
            ans=ans*i
            i=i+1
 
 return ans 
 
test=input()
for num in range(test):
      
        f=raw_input().split()
        x,y=(int(f[0]),int(f[1]))
        if x-y<0:
           print '1'
        else:
          print (fact(x)/(fact(y)*fact(x-y))) 
def process(N, M):
    Nrow, Ncol, Crow, Ccol = 0, 0, 0, 0
    for i in xrange(N):
        tmp = 0
        for j in xrange(N):
            tmp ^= M[i][j]
        if  tmp:
            Nrow += 1
            Crow  = i + 1
    for j in xrange(N):
        tmp = 0
        for i in xrange(N):
            tmp ^= M[i][j]
        if  tmp:
            Ncol += 1
            Ccol  = j + 1
    if   Nrow==1 and Ncol==1:
         return '(%s,%s)' % (Crow, Ccol)
    elif Nrow==0 and Ncol==0:
         return '1'
    else:
         return '0'

def main():
    T = int(raw_input())
    for t in xrange(T):
        N = int(raw_input())
        M = []
        for n in xrange(N):
            M.append(map(int, raw_input().split()))
        print process(N, M)

main()

for _ in range(input()):
	n=input()
	a=map(int,raw_input().split())
	c=0
	for i in range(n):
		for j in range(n-i-1):
			if a[j]>a[j+1]:
				a[j],a[j+1]=a[j+1],a[j]
				#print a[j],a[j+1]
				c+=1
				#print c
	print c			
# cook your code here
t=int(raw_input())
for z in range(t):
    n=int(raw_input())
    cl=map(int,raw_input().split())
    ck=map(int,raw_input().split())
    for i in set(cl) & set(ck):
        cl.remove(i)
        ck.remove(i)
    cl.sort()
    ck.sort()
    s=0
    for i in range(len(cl)):
        s+=abs(cl[i]-ck[i])
    print "Case "+str(z+1)+": "+str(s)        
for num in range(input()):
	# n  =input()
	p,q = map(int,raw_input().split())
	arr1 = list(raw_input())
	arr2 = list(raw_input())
	dp=[[0 for i in range(q+1)] for i in range(p+1)]
	for i in range(1,p+1):
		for j in range(1,q+1):
			if arr1[i-1]==arr2[j-1]:
				dp[i][j] += (1+ dp[i-1][j-1])
			else:
				dp[i][j] += max(dp[i-1][j],dp[i][j-1])
	ans = p+q-dp[p][q]
	
	print "Case "+str(num+1)+": "+str(ans)
a,o,b=raw_input().split()
if o=='+':
    print int(a)+int(b)
elif o=='-':
    print int(a)-int(b)
elif o=='*':
    print int(a)*int(b)
elif o=='/':
    print int(a)/int(b)
else:
    print "Invalid Operator" 
def con(a):
    summ=0
    while True:
        summ+=a%10
        a/=10
        if(a==0):
            break
    if((summ/10)>=1):
        return con(summ)
    else:
        return summ
for _ in xrange(input()):
    s_li=[]
    input()
    li=map(int,raw_input().split())    
    for j in xrange(len(li)):
        s_li.append(con(li[j])) 
    big=max(s_li)
    color=['red','blue','pink','white','black','violet','cyan','yellow','green','brown']
    print color[big]
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    dic={}
    x=raw_input()
    for j in range(n):
        if x[j] in dic:
            dic[x[j]]+=1
        else:
            dic[x[j]]=1
    for j in dic:
        if dic[j]%2!=0:
            print j
            break
def findOccurences(s, ch):
    return [i for i, letter in enumerate(s) if letter == ch]

def fibo(n):
    a=0
    b=1
    fibon=[0,1]
    while(b<n):
        c=a+b
        fibon.append(c)
        a=b
        b=c
    return fibon


n=int(raw_input())
i=0
stri=[]
singlelist=[]
finalsingle=[]
alphabet=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']

#take input
while(i<n):
    stri.append(raw_input())
    i+=1


#find unqiue char in each and append in  singlelist
#so which ever character occurs n times in singlelist are the unique char
i=0
while(i<n):
    w=stri[i]
    s=list(w)
    j=0
    while(j<len(s)):
        noofoccurence=findOccurences(s,s[j])
        if(len(noofoccurence)==1):
            singlelist.append(s[j])
        j+=1
    i+=1

#print list of unique char
#print(singlelist)



#find the finallist which contains only unique char
i=0
while(i<len(singlelist)):
    noofoccurence=findOccurences(singlelist,singlelist[i])
    if(len(noofoccurence)==n):
        if(singlelist[i] in finalsingle):
            j=1
        else:
            finalsingle.append(singlelist[i])
    i+=1

#print(finalsingle)


value=0
i=0
#finding the value(unique char ke position ka sum)
if(len(finalsingle)==0):
    value=7
else:
    while(i<len(finalsingle)):
        value+=(alphabet.index(finalsingle[i])+1)
        i+=1

value=value%26
#print(value)


#input the string
s=raw_input()
a=""
fibon=fibo(len(s))
i=0

#perform the string manipulation
while(i<len(s)):
    if(not s[i].isalpha()):
        c=s[i]
    else:
        z=alphabet.index(s[i])
        if(i in fibon):
            c=alphabet[z-value]
        else:
            z=z+value
            if(z>25):
                z=z-26
            c=alphabet[z]
    a=a+c
    i+=1

#displaying the result
print(a)

# cook your code here
def hitpoint(a,n,t):
    i=0
    h=0
    while(i<n):
        if(a[i]==1):
            h+=t*1
        elif(a[i]==2):
            h+=t*2
        else:
            h+=t*3
        i+=1
    return h

#input size of army
n=int(raw_input())
#input the time in mins
t=int(raw_input())
#convertion to sec
t=t*60
#hit points of the base to be destroyed
h=int(raw_input()) 
#adding the healing effect of the base, so total hit point is h
h=h+(t//60)*n*15
#print(h)

#creating a team with basic 1
i=0
team=[]
hit=0
while(i<n):
    team.append(1)
    i+=1

#checking which army is to be taken with min cost
hit=hitpoint(team,n,t)
if(hit<h):
    flag=0
    i=0
    while(i<n):
        team[i]=2
        hit=hitpoint(team,n,t)
        if(hit>=h):
            flag=2
            break
        i+=1

    if(flag!=2):
        i=0
        while(i<n):
            team[i]=1
            i+=1
        
        i=0
        while(i<n):
            team[i]=3
            j=i+1
            while(j<=n):
                hit=hitpoint(team,n,t)
                if(hit>=h):
                    flag=2
                    break
                else:
                    if(j!=n):
                        team[j]=2
                j+=1
            if(flag==2):
                break
            j=i+1
            while(j<n):
                team[j]=1
                j+=1
            i+=1

#printing the army which needs to be taken
#print(team)

#calculating the cost of the army
i=0
cost=0
while(i<n):
    if(team[i]==1):
        cost+=100
    elif(team[i]==2):
        cost+=500
    else:
        cost+=1500
    i+=1

#printing the cost
print(cost)

from __future__ import print_function
t=input()
while(t):
    cnt=0
    a,b=map(int,raw_input().split())
    for i in xrange(a,b+1):
        if str(i).count('0'):
            cnt+=1
    print(cnt,'/',b-a+1,sep='')
    t-=1
t = input()
for i in range(t):
	n, m = map(int, raw_input().split())
	a = map(int, raw_input().split())
	ans = 0
	for j in range(m):
		ans += a[j]
	for j in range(m, n):
		ans -= (a[j] + 1) / 2
	if ans < 0 :
		print 'DEFEAT'
	else :
		print 'VICTORY'		

using namespace std;

#include <string>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <list>
#include <map>
#include <set>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string.h>
#include <stack>
#include <queue>
#include <limits.h>
#include <iterator>
#include <iomanip>
#include <time.h>

#define null NULL
#define PRINT_NEW_LINE printf("\n")
#define gc getchar_unlocked
#define MAX_INPUT_SIZE 1001
#define CODEFORCES_MAX_INPUT_SIZE 101
#define TOPCODER_MAX_INPUT_SIZE 51
#define ALPHABET_SIZE 26
#define HACKER_RANK_LOWER_CASE "hackerrank"
#define MAX_SIZE_USER_INPUT 101
#define LIMIT 10000001
#define MODN 1000000007
#define MAX_SIZE 1000001

#define gc getchar_unlocked

void solveProblem() {
    unsigned int testCases;
    long long int digitSum;
    string userInput;
    scanf("%u", &testCases);
    while (testCases--) {
        cin >> userInput;
        digitSum = 0;
        for (unsigned int counter = 0; counter < userInput.size(); counter++) {
            if (userInput[counter] >= '0' && userInput[counter] <= '9') {
                digitSum += userInput[counter] - '0';
            }
        }
        printf("%lld\n", digitSum);
    }
}

int main() {
    solveProblem();
    return 0;
}

#include<bits/stdc++.h>
#define M 1000000007
using namespace std;
 
#define MAXN 1005
#define rep(i,a,b) for(i=a;i<b;i++)
#define f0(i,m) for(i=0;i<m;i++)
#define ll long long
#define INF 1000000010
long long a[MAXN][MAXN],L[MAXN][MAXN],R[MAXN][MAXN],Up[MAXN][MAXN],Dn[MAXN][MAXN];
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	int n,m,k,i,j;
	ll temp1,temp2;
	int t;
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		f0(i,n)
			f0(j,m)
				cin>>a[i+1][j+1];
		f0(i,n+2)
        	f0(j,m+2)
        		L[i][j]=Up[i][j]=Dn[i][j]=R[i][j]=INF;
		ll ans=INF;
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=m;j++)
			{
				L[i][j]=min(a[i][j],L[i-1][j]+a[i][j]);
				Up[i][j]=min(a[i][j],Up[i][j-1]+a[i][j]);
			}
		}
		for(i=n;i>=1;i--)
		{
			for(j=m;j>=1;j--)
			{
				R[i][j]=min(a[i][j],R[i+1][j]+a[i][j]);
				Dn[i][j]=min(a[i][j],Dn[i][j+1]+a[i][j]);
			}
		}
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=m;j++)
			{
				ans=min(ans,L[i][j]+R[i][j]+Up[i][j]+Dn[i][j]-3*a[i][j]);
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
#include <bits/stdc++.h>
using namespace std;

int n,u,a,b,ar[100005],add[100005];
vector<int> v[1005];

int main(){
	ios::sync_with_stdio(0); cin.tie(0);
	cin >> n >> u; int s=(int)sqrt(n);
	while (u--){
		cin >> a >> b;
		if (a>=s){
			for (int i=b;i<=n;i+=a) ar[i]++;
		}else v[a].push_back(b);
	}
	for (int i=1;i<=s;i++){
		int sz=v[i].size();
		memset(add,0,sizeof(add));
		for (int j=0;j<sz;j++) add[v[i][j]]++;
		for (int j=1;j<=n;j++){
			add[j]+=add[j-i]; ar[j]+=add[j];
		}
	}
	for (int i=1;i<=n;i++)
	cout << ar[i] << (i==n?"\n":" ");
}
/*
	                         Complexity-> O(Bruce_Lee)

/************************* The Beauty of Code begins *************************/

#include <bits/stdc++.h>
using namespace std;

const int maxn = 200100;
const long long INF = 2000000000000000000LL;
long long n;
long long pos[maxn];

struct segment {
	    long long l, r;
	    segment(long long _L, long long _R) 
	    {
	   	     l = _L;
	   	     r = _R;
	    }
	    long long bestPos()
		{
			long long ans = (l + r) / 2;
			if (ans <= 0)
			{
				ans = 1;
			}
			if (ans > n) ans = n;
			return ans;
		}
		long long bestLen()
		{
			if (r - l + 1 <= 2)
			{
				return -100000;
			}
			return min(bestPos() - l, r - bestPos());
		}	
};

bool operator<(segment y, segment x)
{
	return make_pair(-y.bestLen(), y.bestPos()) < make_pair(-x.bestLen(), x.bestPos());
}

struct forRemSeg {
	   long long L, R;
	   forRemSeg(long long _L, long long _R) 
	   {
	   	     L = _L;
	   	     R = _R;
	   }
};

bool operator < (forRemSeg x, forRemSeg y)
{
	 return x.L < y.L;
}

set< segment > segs;
set< forRemSeg > seg1;

void add(long long l, long long r)
{
	 segs.insert(segment(l, r));
	 seg1.insert(forRemSeg(l, r));
}

void rem(long long l, long long r)
{
	 segs.erase(segment(l, r));
	 seg1.erase(forRemSeg(l, r));
}

void insert(long long x)
{
	 segment Best = *segs.begin();
	 pos[x] = Best.bestPos();
	
	 rem(Best.l, Best.r);
	 add(Best.l, pos[x]);
	 add(pos[x], Best.r);
	
     return;
}

void remove(long long x)
{
     long long Position = pos[x];
     
     set< forRemSeg >::iterator it = seg1.lower_bound(forRemSeg(Position, -1));
     forRemSeg rR = *it;
     it--;
     forRemSeg lL = *it;
     
     long long left = lL.L;
     long long right = rR.R;
     
     rem(left, Position);
     rem(Position, right);
     add(left, right);
     return;
}

int main()
{
   ios::sync_with_stdio(false);
   
   int Q;
   cin >> n >> Q;
   
   add(-INF, INF);
   
   long long id = 1;
   
   while (Q--) {
          int op;
          cin >> op;
          if (op == 1) {
                    insert(id);
                    cout << pos[id] << endl;
                    id++;
          }
          else {
          	    long long x;
          	    cin >> x;
                    remove(x);
          }
          
   }
   return 0;
}
#include <bits/stdc++.h>

#define ll long long

#define SZ(x) (int)(x).size()
#define pb push_back

template<class T>inline void chkmax(T &x, const T &y) {if(x < y) x = y;}
template<class T>inline void chkmin(T &x, const T &y) {if(x > y) x = y;}

template<class T>
inline void read(T &x) {
    char c;int f = 1;x = 0;
    while(((c=getchar()) < '0' || c > '9') && c != '-');
    if(c == '-') f = -1;else x = c-'0';
    while((c=getchar()) >= '0' && c <= '9') x= x*10+c-'0';
    x *= f;
}
int outn;
char out[(int)1e7];
template<class T>
inline void write(T x) {
    if(x < 0) out[outn++] = '-', x = -x;
    if(x) {
        static int tmpn;
        static char tmp[20];
        tmpn = 0;
        while(x) tmp[tmpn++] = x%10+'0', x /= 10;
        while(tmpn) out[outn++] = tmp[--tmpn];
    }
    else out[outn++] = '0';
}

const int N = 1e5;
const int INF = 1e9;

int n, MOD;
int w[N+9];
struct graph {
    int sz, head[N+9], to[N*2+9], ne[N*2+9];
    graph() {
        sz = 1, memset(head, 0, sizeof head);
    }
    inline void addedge(int u, int v) {
        to[sz] = v, ne[sz] = head[u], head[u] = sz++;
        to[sz] = u, ne[sz] = head[v], head[v] = sz++;
    }
}g;

int h[N*3+9][2];
int s[N*3+9][2];
int f[N*3+9];
bool vis[N*3+9];
std::vector<std::pair<int,int> > d[N+9];
int dfn[N+9], tot, size[N+9], fe[N+9];

int qn;

#define inv(x) ((((x)-1)^1)+1)

void dp(int now, int x) {
    if(vis[x]) return ;
    vis[x] = true, h[x][0] = h[x][1] = 1, s[x][0] = s[x][1] = w[now]%MOD;
    for(int i = g.head[now], to, y; i; i = g.ne[i])
        if(x <= n || i != inv(x-n)) {
            dp(to = g.to[i], y = i+n);
            (f[x] += f[y]) %= MOD;
            bool t = w[now] > w[to];
            (f[x] += 1ll*h[x][t]*s[y][t^1]%MOD+1ll*s[x][t]*h[y][t^1]%MOD) %= MOD;
            (h[x][t] += h[y][t^1]) %= MOD, (s[x][t] += s[y][t^1]+1ll*h[y][t^1]*w[now]%MOD) %= MOD;
        }
}

void dfs(int now, int fa) {
    dfn[now] = ++tot, size[now] = 1;
    for(int i = g.head[now], to; i; i = g.ne[i])
        if((to = g.to[i]) != fa) {
            fe[to] = i, dfs(to, now), size[now] += size[to];
            d[now].pb(std::make_pair(dfn[to], i));
        }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("KOL15E.in", "r", stdin);
    freopen("KOL15E.out", "w", stdout);
#endif

    read(n), read(MOD);
    for(int i = 1; i <= n; ++i)
        read(w[i]);
    for(int i = 1; i < n; ++i) {
        int u, v;
        read(u), read(v);
        g.addedge(u, v);
    }
    for(int i = 1; i <= n; ++i)
        dp(i, i);
    dfs(1, 0);
    read(qn);
    while(qn--) {
        int rt, sub;
        read(rt), read(sub);
        if(sub == rt) write(f[sub]);
        else if(dfn[sub] <= dfn[rt] && dfn[rt] <= dfn[sub]+size[sub]-1) {
            int t = std::lower_bound(d[sub].begin(), d[sub].end(), std::make_pair(dfn[rt], INF))-d[sub].begin()-1;
            write(f[inv(d[sub][t].second)+n]);
        }
        else write(f[fe[sub]+n]);
        out[outn++] = '\n';
    }
    printf("%s", out);
    
#ifndef ONLINE_JUDGE
    fclose(stdin);fclose(stdout);
#endif
    return 0;
}

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int MAXN = 100000 + 10, inf = ~0U>>1;
const int P = 333;

namespace Treap {
  struct Node {
    int pri, sz;
    LL val;
    Node* ch[2];
    Node() {}
    Node (LL v, Node* n) : val(v) {
      ch[0]=ch[1]=n; sz=1; pri=rand()-1;
    }
    void upd() {sz=ch[0]->sz+ch[1]->sz+1;}
  } pool[MAXN], *null, *np;
  Node *newNode(LL v) {
    np->val = v; np->sz = 1; np->pri = rand() - 1;
    np->ch[0] = np->ch[1] = null; return np ++;
  }
  void rot(Node* &o,int d) { //d = 1, left; d = 0, right
    Node* k=o->ch[d];
    o->ch[d]=k->ch[!d]; k->ch[!d]=o;
    o->upd(); k->upd(); o=k;
  }
  void ins(Node* &o,LL val) {
    if (o==null) o = newNode(val);
    else {
      //if (val==o->val) return; //same val
      int d=val>o->val; ins(o->ch[d],val);
      if (o->ch[d]->pri<o->pri) rot(o,d);
      else o->upd();
    }
  }
  void del(Node* &o,LL val) {
    if (o==null) return;
    if (o->val==val) {
      int d=o->ch[1]->pri<o->ch[0]->pri;
      if (o->ch[d]==null) {o=null; return;}
      rot(o,d);  del(o->ch[!d],val);
    } else del(o->ch[val>o->val], val);
    o->upd();
  }
  Node* merge(Node *p, Node *q) {
    if (p == null) return q;
    if (q == null) return p;
    if (p->pri >= q->pri) {
      p->ch[1] = merge(p->ch[1], q);
      p->upd(); return p;
    } else {
      q->ch[0] = merge(p, q->ch[0]);
      q->upd(); return q;
    }
  }
  void split(Node *o, LL v, Node* &p, Node* &q) {//[0, v), [v, inf)
    if (o == null) {p = q = null; return;}
    if (o->val < v) {
      split(o->ch[1], v, o->ch[1], q); p = o;
    } else {
      split(o->ch[0], v, p, o->ch[0]); q = o;
    }
    o->upd();
  }
  int kth(Node* o,int k) { //kth number k >= 1
    int s=o->ch[0]->sz+1;
    if (k==s) return o->val;
    return kth(o->ch[k>s],(k<s)?k:k-s);
  }
  int rank(Node* o,int val) { //return how many elements smaller than val
    if (o==null) return 0;
    int s=o->ch[0]->sz;
    if (val==o->val) return s;
    if (val<o->val) return rank(o->ch[0],val);
    else return s+1+rank(o->ch[1],val);
  }
  bool find(Node *o, int x) {
    if (o==null) return 0;
    if (x==o->val) return 1;
    else return find(o->ch[x>o->val],x);
  }
  void init() {
    null=new Node(0,0); np = pool;
    null->ch[0]=null->ch[1]=null;
    null->sz=0; null->pri=inf;
  }
}

LL sum[MAXN];
Treap::Node *tr[MAXN], *p;

void ins(Treap::Node* &rt, LL v) {
  split(rt, v, rt, p);
  rt = Treap::merge(Treap::merge(rt, Treap::newNode(v)), p);
}

void run1(int k) {
  Treap::init(); 
  for (int i = 0; i < k; ++i) {
    tr[i] = Treap::null; sum[i] = 0;
    int n; scanf("%d", &n);
    for (int j = 0; j < n; ++j) {
      int c, w; scanf("%d%d", &c, &w);
      ::ins(tr[i], (sum[i] += w) + c);
    }
  }
  int q; scanf("%d", &q);
  for (int _ = 0; _ < q; ++_) {
    int c, w; scanf("%d%d", &c, &w);
    int id = -1, cnt;
    for (int i = 0; i < k; ++i) {
      Treap::split(tr[i], sum[i] + w, tr[i], p);
      int sz = tr[i]->sz;
      tr[i] = Treap::merge(tr[i], p);
      if (id == -1 || sz < cnt) id = i, cnt = sz;
    }
    printf("%d %d\n", id, cnt);
    Treap::split(tr[id], sum[id] += w, p, tr[id]);
    ::ins(tr[id], sum[id] + c);
  }
}

priority_queue<LL, vector<LL>, greater<LL>> S[MAXN];
#define lson (rt<<1)
#define rson (rt<<1|1)
#define mid ((l+r)>>1)
int mx[MAXN << 4], n, K, M;
void build(int rt, int l, int r) {
  mx[rt] = inf; if (l + 1 == r) return;
  build(lson, l, mid); build(rson, mid, r);
}
int ask(int rt, int l, int r, int w) {
  if (l + 1 == r) return l;
  if (mx[lson] >= w) return ask(lson, l, mid, w);
  else return ask(rson, mid, r, w);
}
void ins(int rt, int l, int r, int x, int v) {
  if (l + 1 == r) {mx[rt] = v; return;}
  if (x < mid) ins(lson, l, mid, x, v);
  else ins(rson, mid, r, x, v);
  mx[rt] = max(mx[lson], mx[rson]);
}

void ins(int i, int c, int w) {
  sum[i] += w;
  while (!S[i].empty() && S[i].top() < sum[i]) S[i].pop();
  vector<LL> pt; S[i].push(c + sum[i]);
  for (int m = 0; m < M; ++m) {
    if (S[i].empty()) ins(1, 0, n, m * K + i, inf);
    else {
      pt.push_back(S[i].top()); S[i].pop();
      ins(1, 0, n, m * K + i, pt.back() - sum[i]);
    }
  }
  for (auto &x: pt) S[i].push(x);
}

void run2(int k) {
  K = k; M = MAXN / K + 1; n = K * M;
  build(1, 0, n);
  for (int i = 0; i < K; ++i) {
    while (!S[i].empty()) S[i].pop();
    sum[i] = 0;
    int n; scanf("%d", &n);
    for (int j = 0; j < n; ++j) {
      int c, w; scanf("%d%d", &c, &w);
      ins(i, c, w);
    }
  }
  int q; scanf("%d", &q);
  for (int i = 0; i < q; ++i) {
    int c, w; scanf("%d%d", &c, &w);
    int r = ask(1, 0, n, w);
    int id = r % K, cnt = r / K;
    printf("%d %d\n", id, cnt);
    ins(id, c, w);
  }
}

int main() {
  int T; scanf("%d", &T);
  for (int cas = 1; cas <= T; ++cas) {
    int k; scanf("%d", &k);
    if (k < P) run1(k);
    else run2(k);
  }
  return 0;
}

#include <iostream>
#include <cassert>
#include <vector>
#include <cstdio>
#include <algorithm>
using namespace std;

#define maxn 100005

vector<int>v[maxn];
int st[maxn],sp,u[maxn],N,T,i,j,x,y,was[maxn],avail;
long long K;

bool dfs(int k){
	st[++sp]=k;u[k]=1;--K;
	if(!K){
		for(int i=1;i<sp;i++)printf("%d ",st[i]);
		printf("%d\n",st[sp]);
		return true;
	}else for(int j=0;j<v[k].size();j++)if(!u[v[k][j]]&&dfs(v[k][j]))break;
	--sp;
	return false;
}

void DFS(int k){
	was[k]=1;
	++avail;
	for(int j=0;j<v[k].size();j++)
		if(!was[v[k][j]])
			DFS(v[k][j]);
}

int main (int argc, char * const argv[]) {
	ios_base::sync_with_stdio(0);
	cin>>T;
	for(;T;T--){
		for(avail=0,i=1;i<=N;i++)u[i]=was[i]=0,v[i].clear();
		cin>>N>>K;
		for(i=1;i<N;i++){
			cin>>x>>y;
			v[x].push_back(y);
			v[y].push_back(x);
			assert(1<=x&&x<=N&&1<=y&&y<=N);
		}
		DFS(1);
		assert(avail==N);
		for(i=1;i<=N;i++)sort(v[i].begin(),v[i].end());
		for(i=1;i<=N;i++)if(K>N)K-=N;else{
			dfs(i);
			break;
		}
		sp=0;
	}
    return 0;
}
#!/usr/bin/python
"Solve the Lost Primes problem at CodeChef"
import sys, os, math, random
if False:  # try with and without
 import psyco
 psyco.full()
last_digits = [1, 3, 7, 9]  # multi-digit primes cannot end in [024568]
digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
DEBUGGING = os.getenv('DEBUGGING', False)
def main():
 primes = sieve(1000000)
 testcases = int(raw_input())
 for testcase in xrange(testcases):
  prime = raw_input()
  if prime == '?':
   print 7  # shortcut this case
   continue
  variables = prime.count('?')
  replacements = [list(digits) for i in xrange(variables)]
  if prime.endswith('?'):
   replacements[-1] = list(last_digits)
  if prime.startswith('?') and 0 in replacements[0]:
   replacements[0].remove(0)  # no leading zeros
  for i in xrange(len(replacements)):
   random.shuffle(replacements[i])
  indices = [0] * len(replacements)
  done = map(lambda l: len(l) - 1, replacements)
  while True:
   if DEBUGGING:
    print >>sys.stderr, 'prime=%s, variables=%s, replacements=%s' % (
     prime, variables, replacements)
   test = prime  # makes a new copy
   for i in xrange(variables):
    test = test.replace('?', str(replacements[i][indices[i]]), 1)
    if DEBUGGING: print >>sys.stderr, 'i=%d, test: %s' % (i, test)
   if is_prime(long(test), primes):
    print test
    break
   else:
    if indices != done:
     increment(replacements, indices)
    else:
     print 'No primes in %s' % prime
     break
def increment(list_of_numbers, list_of_indices):
 for i in xrange(len(list_of_indices) - 1, -1, -1):
  list_of_indices[i] = (list_of_indices[i] + 1) % len(list_of_numbers[i])
  if list_of_indices[i] != 0:
   break
def is_prime(n, primes):
 for i in primes:
  if i >= n:
   return True
  if n % i == 0:
   return False
 return True
def sieve(number = sys.maxint - 1):
 numbers = range(number + 1)
 numbers[1] = 0  # 1 is not a prime; it is a unit
 limit = int(number ** 0.5) + 1
 for i in xrange(2, limit):
  if numbers[i]:
   numbers[2 * i:(number / i) * (i + 1):i] = [0] * ((number / i) - 1)
 return filter(None, numbers)
main()

n, k = map(int, raw_input().split()); a = [int(i) for i in raw_input().split()];
a.sort(); print a[k - 1];
#!/usr/bin/env python

def digisum(N):
    D = [0, 1, 4, 3, 8, 5, 2, 7, 6, 9]
    S = 0
    while N:
        S += D[N%10]
        N /= 10
    return S % 10

def process(A, B):
    R = 0
    while A < B and A % 10:
        R += digisum(A)
        A += 1
    while A < B and B % 10:
        R += digisum(B)
        B -= 1
    R += 45 * ((B - A) / 10)
    R += digisum(B)
    return R

def main():
    T = int(raw_input().strip())
    for t in xrange(T):
        A, B = map(int, raw_input().strip().split()[:2])
        print process(A, B)

main()


import sys
f = sys.stdin

mod = 1000000007
DP = [0]*(2)
DP[0] = [0]*(111)
DP[1] = [0]*(111)
bits = [0]*(111)
X = [0]*(2)
Y = [0]*(2)
X[0] = [0]*(111)
X[1] = [0]*(111)
Y[0] = [0]*(111)
Y[1] = [0]*(111)
def process():
    DP[0][100] = 1
    DP[1][100] = 1
    X[0][100] = 1
    Y[0][100] = 0
    Y[1][100] = 1
    X[1][100] = 0
    i = 99
    while i >= 0 :
        DP[0][i] = DP[0][i+1] + DP[1][i+1]
        DP[1][i] = DP[0][i+1]
        X[0][i] = X[0][i+1] + X[1][i+1]
        Y[0][i] = Y[0][i+1] + Y[1][i+1]
        X[1][i] = X[0][i+1]
        Y[1][i] = Y[0][i+1]
        i -= 1
    return

def find(x) :
    for i in range(0,101) :
        if x > DP[0][i] :
            bits[i] += x - DP[0][i]
            x -= DP[0][i]
            j = 100
            k = i  
            while j > i :
                bits[j] += Y[0][k] * DP[1][j]
                k += 1 
                j -= 1
    return

t = int(f.readline())
process()
while t :
    L,R = [int(x) for x in f.readline().split()]
    R += 1
    for i in range(0,101) :
        bits[i] = 0
    find(R)
    find(L)
    sum = 0
    for i in range(0,101) :
        bits[i] %= 2
        if bits[i] == 1 :
            sum += pow(2,100-i,mod)
            sum %= mod
    print sum
    t -= 1

def solve(c, array):
    if sum(array) <= c: return 'Yes'
    return 'No'

def lecandy():
    T = int(raw_input())
    for t in xrange(T):
        N,C = map(int, raw_input().split())
        array = map(int, raw_input().split())
        print solve(C, array)

if __name__ == "__main__":
    lecandy()
import sys

n = int(sys.stdin.readline())
sys.stdin.readline()

times = {'S': 1, 'C': 2, 'B': 3, 'T': 4}
minn = 1000000
minni = 0

for i in xrange(n):
	summ = sum([times[j] for j in sys.stdin.readline().split()])
	if summ < minn:
		minn, minni = summ, i

print minni + 1

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f first
#define s second
#define pb push_back
#define mp make_pair
#define pii pair<int,int>
#define pil pair<int,ll>
#define pli pair<ll,int>
#define pll pair<ll,ll>
#define mod 95676260903887607LL
vector<int>adj[100011];
int mn,loc,mark[100011];
vector<int>v;
void dfs(int u,int p,int h)
{
    if(h>mn)
    {
        mn=h;
        loc=u;
    }
    for(int i=0;i<adj[u].size();i++)
        if(adj[u][i]!=p)
            dfs(adj[u][i],u,h+1);
}
int dfs1(int u,int p,int h)
{
    if(u==loc)
    {
        v.pb(loc);
        return 1;
    }
    for(int i=0;i<adj[u].size();i++)
        if(adj[u][i]!=p)
            if(dfs1(adj[u][i],u,h+1)==1)
            {
                v.pb(u);
                return 1;
            }
    return 0;
}
int dfs2(int u,int p)
{
    mark[u]=1;
    int mx=0;
    for(int i=0;i<adj[u].size();i++)
    {
        if(adj[u][i]!=p&&mark[adj[u][i]]==0)
            mx=max(mx,dfs2(adj[u][i],u)+1);
    }
    return mx;
}
int main()
{
    int i,j,n,k,t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(i=0;i<=n;i++)
            adj[i].clear();
        for(i=0;i<=n;i++)
            mark[i]=0;
        for(i=1;i<n;i++)
        {
            int p;
            scanf("%d",&p);
            adj[p].pb(i);
            adj[i].pb(p);
        }
        mn=-1;
        dfs(0,-1,0);
        mn=-1;
        int loc1=loc;
        v.clear();
        dfs(loc,-1,0);
        dfs1(loc1,-1,0);
        assert(v[0]==loc);
        assert(v.back()==loc1);
        assert(v.size()==mn+1);
//        printf("%d\n",mn+1);
//        for(i=0;i<v.size();i++)
//            printf("%d ",v[i]);
//        printf("\n");
        int y,mx=1000111,mn1=1000000;
        for(i=0;i<v.size();i++)
        {
            if(i==v.size()-1)
                y=dfs2(v[i],-1);
            else
                y=dfs2(v[i],v[i+1]);
           // cout<<v[i]<<" "<<y<<endl;
            if(y==i)
                mn1=i;
            if(y==mn-i)
                mx=min(mx,i);
        }
        printf("%d\n",mx-mn1+1);
    }
    return 0;
}

cases = int(raw_input())
while cases:
    cases -= 1
    on = 0
    l = []
    n,m,k = [int(x) for x in raw_input().split()]
    for i in range(n):
        st = raw_input()
        l.append(st.count('*'))
    while k:
        k -= 1
        mn = min(l)
        idx = l.index(mn)
        l[idx] = m-mn
    on = sum(l)
    print on
t = input()
for tests in xrange(t):
    n = input()
    a = map(int,raw_input().split())
    s = sum(a)
    if s%n !=0:
        print -1
    else:
        c = s/n
        a.sort()
        time = 0
        for items in a:
            time+=abs(c-items)
        
        print time
#include<bits/stdc++.h>
using namespace std;
long int findhcf(long int a,long int b)
{
	if(b%a==0) return a;
	return findhcf(b%a,a);
}
int main()
{
	int t;
	long int x1,y1,x,y;
	cin>>t;
	while(t--)
	{
		cin>>x1>>y1>>x>>y;
		x=fabs(x-x1);
		y=fabs(y-y1);
		if(x==0||y==0) {cout<<"0\n"; continue;}
		long int hcf=(x<y?findhcf(x,y):findhcf(y,x));
		cout<<x+y-hcf<<"\n";		
	}
	return 0;
}
for _ in range(input()):
	n=input()
	a=raw_input().split()
	x=raw_input()
	b=[0]*n
	#n=a[0].count(x)
	#print n
	for i in range(n):
		c=a[i].count(x)
		b[i]=c
	m=max(b)
	#print b
	for i in range(n):
		if b[i]==m:
			print a[i]
			break
		
		
// Tapan Sahni
#include <algorithm>
#include <iostream>
#include <iterator>
#include <numeric>
#include <sstream>
#include <fstream>
#include <cassert>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
#include <deque>
#include <stack>
#include <list>
#include <iomanip>
#include <map>
#include <complex>
#include <set>

#define mod 1000000007

using namespace std;
typedef long long LL;

const int N = 1000 + 10;
const int inf = 1000000000;

int a[N];
int fdp[N][N] , fdp1[N][N];
vector <pair <int ,int> > v;
int main() {
  ios::sync_with_stdio(false) ; cin.tie(nullptr);
  int t;
  cin >> t;
  while(t--) {
    int n , k;
    cin >> n >> k;
    for(int i = 1; i <= n; i++) cin >> a[i];
    int lis = 0;
    for(int i = 0; i <= n + 1; i++)
      for(int j = 0; j <= n + 1; j++){
        fdp[i][j] = inf;
        fdp1[i][j] = -1;
      }
    fdp[0][0] = 0;
    for (int i = 1; i <= n; i++) {
      for (int j = 0; j <= n; j++) {
        fdp[i][j] = fdp[i - 1][j];
        if (j && fdp[i - 1][j - 1] < a[i])
          fdp[i][j] = min(fdp[i][j], a[i]);
        if (fdp[i][j] != inf)
          lis = max(lis, j);
      }
    }
    fdp1[n + 1][0] = inf;
    for (int i = n; i >= 1; i--){
      for (int j = 0; j <= n; j++){
        fdp1[i][j] = fdp1[i + 1][j];
        if (j && fdp1[i + 1][j - 1] > a[i])
          fdp1[i][j] = max(fdp1[i][j], a[i]);
      }
    }
    LL ans = 0;
    int r;
    for (int i = 1; i < n; i++){
      r = -1;
      for (int j = 0; j <= lis; j++){
        int j1 = lis - j;
        if (fdp1[i + 1][j1] - fdp[i][j] > 1) {
          if (fdp1[i + 1][j1] > k) {
            if (fdp[i][j] >= r)
              ans += max(k - fdp[i][j], 0);
            else
              ans += max(k - r + 1, 0);
            break;
          }
          if (fdp[i][j] >= r)
            ans += max(fdp1[i + 1][j1] - fdp[i][j] - 1, 0);
          else
            ans += max(fdp1[i + 1][j1] - r, 0);
          r = fdp1[i + 1][j1];
        }
      }
    }
    ans += max(k - fdp[n][lis], 0);
    ans += max(min(k, fdp1[1][lis] - 1), 0);
    cout << ans << endl;
  }
  
  return  0;
}
// Never Quit

/* 
 * File:   main.c
 * Author: APOORV
 *
 * Created on 27 June, 2013, 12:03 AM
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * 
 */
int generate_solution(int x,int y);
void generate_seq();
void init();
int check_arr(int x,int i,int j);
int check_reachable(int x,int y,int i);

int seq[294][2]; 

int main(int argc, char** argv) {
    init();
    generate_seq();

    int cnt,x,y,ans;
    scanf("%d",&cnt);
    while (cnt>0) {
        scanf("%d %d",&x,&y);
        ans=generate_solution(x,y);
        if (ans>0) {
            printf("Bhima %d\n",ans);
        } else {
            printf("Shiva %d\n",-1*ans);
        }
        cnt--;
    }
    return (EXIT_SUCCESS);
}

void init() {
    int i;
    for (i=0;i<350;i++) {
        seq[i][0] = 0;
        seq[i][1] = 0;
    }
}

void generate_seq() {
    int x,y,val,flag,loop_var;
    x=y=val=flag=0;
    while (y<1001) {
        x+=1;
        y+=3;
        val++;
        loop_var=0;
        while (loop_var<val) {
            if (seq[loop_var][1]==x) {
                flag=1;
                break;
            }
            loop_var++;
        }
        if (flag == 1) {
            x++;
            y++;
            flag=0;
        }
        if (x<1001 && y<1001) {
            seq[val][0]=x;
            seq[val][1]=y;
        }
    }
}

int generate_solution(int x,int y) {
    int flag=0;
    if (x==0 && y==0) {
        return 0;
    }
    flag = check_arr(x,0,293) + check_arr(y,0,293);
    if ((seq[flag][1]==y || seq[flag][1]==x)&&(seq[flag][0]==y || seq[flag][0]==x)) {
        return -(2*flag);
    } else {
        flag = 0;
        while (flag<=293) {
            if (check_reachable(x,y,flag)!=0) {
                return ((2*flag)+1);
            }
            flag++;
        }
    }
    
    return flag;
}

int check_arr(int x,int i,int j) {
    if (i==j) {
        if (seq[i][0]==x) {
            return i;
        } else {
            return 0;
        }
    } else {
        if (seq[(i+j)/2][0] < x) {
            return check_arr(x,(((j+i)/2)+1),j);
        } else {
            return check_arr(x,i,((j+i)/2));
        }
        
    }
}

int check_reachable(int x,int y,int i) {
    int flag =0;
    if (seq[i][1]==y || seq[i][1]==x || seq[i][0]==y || seq[i][0]==x) {
        flag = 1;
    }
    if ( ((x-seq[i][0]-y+seq[i][1])*(x-seq[i][0]-y+seq[i][1]))<4 || ((x-seq[i][1]-y+seq[i][0])*(x-seq[i][1]-y+seq[i][0]))<4 ) {
        flag = 1;
    }
    return flag;
}

#include<iostream>
#include <string.h>
#include<math.h>
#include <algorithm>
#include<stdio.h>

using namespace std;

bool p[1000100];
int primes[100000];

int main()
{int k=0,i,j;
 long long a,b,z,number,x,y;
 
  for (i=2;i<1000000;i++)
 {
     if (p[i]==0)
     {                primes[k++]=i;
                      for (j=i+i;j<1000000;j+=i)
                      p[j]=1;
     }

 } 
 long long u=k;
 int t;
 long long product,check,exp,temp;
 scanf("%d",&t);
 
 while(t--)
 {
  scanf("%lld %lld %lld",&x,&y,&z);          
  k=0;
  number=z;
  while(z>1 && primes[k]*primes[k]<=number && k<u)
  {
   
   a=0;
    while(z%primes[k]==0)                  
    {                                      a++;
                                           z/=primes[k];      
                                                     
    }
    k++;
   }        
  if (z==1)
  {
  check=primes[--k];         
  }        
  else
  {
      check=z;
      a=1;
  }
          
    product=x*y;      
    exp=0;
    
    temp=check;

    while(product)
    {
    exp+= product/temp;       
    product=product/temp;      
    }
             
    printf("%lld\n",exp/a);      
  
  }

           
 
 
 return 0;
}
#include <stdio.h>
#include <string.h>
 
#define min(a,b) ((a<b)?(a):(b))
#define LL long long int
 
main()
{
int n, q, x, y, s, k=-1, i=-1, c=0;
int a[102];
LL v=0;
LL w[200000];
for(scanf("%d %d",&n,&q),memset(w,0,sizeof(w)); ++i<n; scanf("%d",&a[i]),v+=a[i]);
for(y=v; ++k<n; w[x]|=1)
for(x=a[k],c+=x,i=min(y,c)+1; --i>=x; w[i]|=(w[i-x]<<(long long)1));
for(i=-1; ++i<q; scanf("%d %d",&s,&k),puts(w[s]&((long long)1<<(k-1))?"YES":"NO"));
return 0;
}
#include<bits/stdc++.h>
using namespace std;
const int N=1000001;
double fac[N];
int main()
{
    int h, i, j, t, n, k;
    fac[0]=0;
    for(i=1;i<N;i++)
    {
        fac[i]=fac[i-1]+log(i);
    }
    cin>>t;
    for(h=0;h<t;h++)
    {
        cin>>n>>k;
        double div=(log(2))*(n-1);
        int start=(k<n-k) ? k : n-k;
        double ans=0;
        double s=0;
        for(i=start;i>=0;i--)
        {
            s=exp(fac[n]-fac[i]-fac[n-i]-div);
            if(s<1e-10)
            {
                break;
            }
            ans+=s;
        }
        ans*=100;
        printf("%.1f\n", ans);
    }
    return 0;
}

def factors(n):
    return reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))
t = long(raw_input())
while t:
    t-=1
    a = long(raw_input())
    b = []
    b = factors(a)
    b = list(set(b))
    b.sort()
    c = 1
    for i in xrange(len(b)-1):
        c*=b[i]
    c = str(c)
    print c[-4:]

for _ in range(input()):
	c,d=map(int,raw_input().split())
	if not c%2 or not d%2:
		print 'A'
	else:
		print 'B'
#include<stdio.h>
#include<string.h>
int main()
{
    int n,k,i,j,g;
    long long count,l,o;
    char a[100001];
    scanf("%d",&n);
    while(n--)
    {
        scanf("%s",a);
        k=strlen(a);
        count=0;
        l=o=0;
        for(i=k-1;i>=0;i--)
        {
            if(a[i]=='L')
            {
                l++;
                count+=o;
            }
            else if(a[i]=='O') o+=l;

        }
        printf("%lld\n",count);
    }

    return 0;
}

#include <bits/stdc++.h>

using namespace std;

int main()
{
    unsigned long long int t,d,r,p,num;
    scanf("%llu %llu",&t,&d);
    while(t--)
    {
        scanf("%llu %llu",&num,&p);
        r=num%d;
        if(r==0 || r==1)
        {
            cout<<r<<endl;
        }
        else
        {
            r=pow(r,p);
            r=r%d;
            printf("%llu\n",r);
        }

    }
    return 0;
}

def ncr(n,r):
    if(n==0):	
        return 0
    if(r==1):
        return n
    if(r==2):
        return n*(n-1)/2
    if(r==3):
        return ((n*(n-1)/2)*(n-2)/3)%1000000007
    return (((n*(n-1)/2)*(n-2)/3)*(n-3)/4)%1000000007
for i in xrange(input()):
    a=raw_input()
    count=[a.count('0'), a.count('1'), a.count('2'), a.count('3'), a.count('4'), a.count('5'), a.count('6'), a.count('7'), a.count('8'), a.count('9')]
    ans=0
    for j in xrange(11):
        for k in xrange(j,11):
            for l in xrange(k,11):
                for m in xrange(l,11):
                    s=0
                    used=[0,0,0,0,0,0,0,0,0,0]
                    if j<10:
                        s+=j
                        used[j]+=1
                    if k<10:
                        s+=k
                        used[k]+=1
                    if l<10:
                        s+=l
                        used[l]+=1
                    if m<10:
                        s+=m
                        used[m]+=1
                    if s>0 and s%9==0:
                        val=1
                        for n in xrange(10):
                            if used[n]:
                                val=(ncr(count[n],used[n])*val)%1000000007
                        ans=(ans+val)%1000000007
    print ans

#include <bits/stdc++.h>
using namespace std;
vector<bool> prime(10000,true);
vector<int> v;
void compute()
{
	for(int p=2;p<=10000;p++)
	{
		if(prime[p]==true)
		{
			for(int i=2*p;i<=10000;i=i+p)
			{
				prime[i]=false;
			}
			v.push_back(p); 
		}
	}
}

int main()
{
	compute();
	int n,k;
	cin>>n>>k;
	int cnt=0;
	bool flag=false;
	int i=0;
	while(v[i]+v[i+1]+1<=n)
	{
		int k=v[i]+v[i+1];
		if(binary_search(v.begin(),v.end(),k+1)){
			cnt++;
		}
		i++;
	} 

	if(cnt>=k)cout<<"YES\n";
	else cout<<"NO\n";
}
t=input()
while t:
    n=input()
    a=map(int,bin(n)[2:]+'0')
    num=0L
    for i in xrange(len(a)):
        num+=a[len(a)-i-1]*(5**i)
    print num
    t-=1
    

t = int(raw_input())
for i in range(t):
    s = raw_input().strip()
    s += s
    f = raw_input().strip()
    if f in s:
        print "YES"
    else:
        print "NO"
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        printf("%d\n",(int)((1.0d*n*(n+2)*(2*n+1)/8)));
    }
    return 0;
}

for _ in range(input()):
    n = input()
    if n%2 == 1:
        print '0'
    else:
        c = '9'
        n = n/2
        for i in range(1,n):
            c += '0'
        print c
# cook your code here
t=int(raw_input())
for x in range(t):
    n=int(raw_input())
    d=dict()
    l=map(int,raw_input().split())
    for temp in l:
        if(temp in d.keys()):
            d[temp]+=1
        else:
            d[temp]=1
    m=d.keys()[0]
    m_c=d[d.keys()[0]]
    for k in d.keys():
        if((d[k]>m_c) or (d[k]==m_c and k<m)):
            m=k
            m_c=d[k]
    print str(m)+" "+str(m_c)
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long int
#define endl "\n"
int main(){
    //cin.sync_with_stdio(false);
    int t;
    scanf("%d", &t);
    while(t--){
        ll N ;
        //cin >> N ;
        scanf("%lld", &N);
        if( N ==1) {
                printf("0\n");
                continue;
        }
        printf("%lld\n" , (ll)(N*N -2)/2);
    }
}

#include <cstdio>
#include <vector>

using namespace std;

long long pow(long long x, int n, int p) {
	if (n == 0)
		return 1;
	long long res = pow(x, n / 2, p);
	res = (res * res) % p;
	if (n % 2 == 1)
		res = (res * x) % p;
	return res;
}

int main() {
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++) {
		int n;
		int p;
		scanf("%d%d", &n, &p);
		vector <int> x(n), y(n);
		for (int j = 0; j < n; j++)
			scanf("%d%d", &x[j], &y[j]);
		int cur = 1;
		long long dx = 0;
		long long dy = 0;
		while (cur < n && dx == 0 && dy == 0) {
			dx = x[0] - x[cur];
			dy = y[0] - y[cur];
			cur++;
		}
		if (dx == 0 && dy == 0) {
			printf("Case #%d: MULTIPLE SOLUTIONS\n", i);
			continue;
		}
		if (dx == 0) {
			printf("Case #%d: NO SOLUTIONS\n", i);
			continue;
		}
		if (dx < 0)
			dx += p;
		if (dy < 0)
			dy += p;
		long long a = (dy * pow(dx, p - 2, p)) % p;
		long long b = (y[0] - a * x[0]) % p;
		if (b < 0)
			b += p;
		bool good = true;
		for (int j = 0; j < n; j++) {
			if ((a * x[j] + b) % p != y[j]) {
				good = false;
				break;
			}
		}
		if (good)
			printf("Case #%d: %lld %lld\n", i, a, b);
		else
			printf("Case #%d: NO SOLUTIONS\n", i);
	}
	return 0;
}
# python3

if __name__ == "__main__":

    t = int(raw_input())
    l = []

    i = 0
    while(i < t and t <= 10**6):
        ch = int(raw_input())
        if(ch <= 10**18):
            l.append(ch)
        i = i + 1
    for i in l:
        if(i % 2 == 0):
            print "YES"
        else:
            print "NO"

def d(s1,s2):
    if len(s1) > len(s2):
        s1,s2 = s2,s1
    distances = range(len(s1) + 1)
    for index2,char2 in enumerate(s2):
        newDistances = [index2+1]
        for index1,char1 in enumerate(s1):
            if char1 == char2:
                newDistances.append(distances[index1])
            else:
                newDistances.append(1 + min((distances[index1],
                                             distances[index1+1],
                                             newDistances[-1])))
        distances = newDistances
    return distances[-1]
t = input()
for i in range(t):
    s = raw_input().lower().split()
    r = raw_input().lower().split()
    dist = 0
    for i in range(len(s)):
        dist += d(s[i],r[i])
    print dist

import datetime as dt
T = int(raw_input())
while T:
	start,end=map(str,raw_input().split())
	start_dt = dt.datetime.strptime(start, '%H:%M:%S')
	end_dt = dt.datetime.strptime(end, '%H:%M:%S')
	diff = (end_dt - start_dt) 
	diff.seconds/60
	i = 0 
	ans = str(diff)
	if ans[0] == '-':
		ans = ans[8:16]
	if ans[1] == ':':
		print ans[0],
		print "HOURS",
		print int(ans[2])*10+int(ans[3]),
		print "MINUTES",
		print int(ans[5])*10+int(ans[6]),
		print "SECONDS"
	else:
		print int(ans[0])*10+int(ans[1]),
		print "HOURS",
		print int(ans[3])*10+int(ans[4]),
		print "MINUTES",
		print int(ans[6])*10+int(ans[7]),
		print "SECONDS"
	T-=1
T=input()
while T:
      T-=1
      n,m=[int(x) for x in raw_input().split()]
      while n:
            n-=1
            arr2=[]
            arr=raw_input()
            for i in arr:
                  arr2.append(i)
            for i in range (0,len(arr2)/2):
                  c=arr2[len(arr2)-i-1]
                  arr2[len(arr2)-1-i]=arr[i]
                  arr2[i]=c
            print "".join(arr2)
      

for each_case in range(input()):
    length=input()
    the_list=map(int,raw_input().split())
    for i in range(1,length+1):
        try:
            the_list.index(i)
        except Exception as error:
            print i
            break


t=int(raw_input())
for i in range(0,t):
    n=int(raw_input())
    arr=map(int,raw_input().split())
    mark=[0]*(n+1)
    for u in arr:
        mark[u]=mark[u]+1
    for i in range(1,n+1):
        if mark[i]==0:
            print i
            break

#include <string>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <list>
#include <map>
#include <set>
#include <iostream>
#include <sstream>
#include <cstring>
#include <queue>
#include <deque>
#include <cassert>
#include <cctype>
#define MP make_pair
using namespace std;
typedef pair<int, int> PII;
typedef unsigned long long ULL;
typedef long long LL;

#define MOD
#define INF
#define MAXN 12

const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

int R, C;
char grid[MAXN+1][MAXN+1];
vector<PII> food;

void findit(PII pnt, int dc, vector<vector<int> > &adj)
{
    int dp[R][C];
    memset(dp, -1, sizeof(dp));
    dp[pnt.first][pnt.second] = 0;
    queue<PII> Q;
    Q.push(pnt);
    while(!Q.empty())
    {
        PII p = Q.front();
        Q.pop();

        for(int i=0; i<4; ++i)
        {
            int xx = p.first+dx[i], yy = p.second + dy[i];
            if(xx<0 || yy<0 || xx >=R || yy>=C || grid[xx][yy]=='#' || dp[xx][yy]>-1)
                continue;
            dp[xx][yy] = dp[p.first][p.second] + 1;
            Q.push(MP(xx,yy));
        }
    }
    for(int i=0; i<food.size(); ++i)
        adj[dc][i] = dp[food[i].first][food[i].second];
}

int solve()
{
    food.clear();
    for(int i=0; i<R; ++i)
        for(int j=0; j<C; ++j)
            if(grid[i][j] == 'H')
                food.push_back(MP(i,j));
    for(int i=0; i<R; ++i)
        for(int j=0; j<C; ++j)
            if(grid[i][j] == 'F')
                food.push_back(MP(i,j));
    int N = food.size();
    vector< vector <int> > adj(N, vector<int>(N));

    for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) adj[i][j] = -1;
    for(int i=0; i<N; ++i)
        findit(food[i], i, adj);
    for(int i=0; i<N; ++i)for(int j=0; j<N; ++j)
        if(adj[i][j] == -1)return -1;


    vector<int> pm(N-1);
    int K = N-1;
    for(int i=0; i<K; ++i)
        pm[i] = i+1;
    int rs = R*C+10;
    do
    {
        int r = 0;
        for(int i=0; i<(K-1); ++i)
            r += adj[pm[i]][pm[i+1]];
        r += adj[0][pm[0]] + adj[pm[K-1]][0];
        rs = min(r, rs);
    }while(next_permutation(pm.begin(), pm.end()));
    return rs/2;
}

void readInput()
{
    scanf("%d%d", &R, &C);
    for(int i=0; i<R; ++i)
        scanf("%s", grid[i]);

}

int main()
{

    int testcases;
    scanf("%d", &testcases);
    for(int caseno=1; caseno<=testcases; caseno++)
    {
        printf("Case %d: ", caseno);
        readInput();
        printf("%d\n", solve());
    }
    return 0;
}



#include<bits/stdc++.h>
using namespace std;
#define lim 10000000+1
int ans(int n,int k)
{
	int r=0,p=k;
	while(k<=n)
	{
		r+=n/k;
		k*=p;
	}
	//cout<<n<<" "<<k<<" "<<r<<" opopo"<<endl;
	return r;
     
}
int an(int n,int h)
{
	int y=0;
	while(n%h==0)
	{
		n/=h;
		y++;
	}
	return y;
}
vector<int>v;
bool w[lim];
int main()
{   for(int i=2;i*i<lim;i++)
{
	if(w[i]==false)
	{
		for(int j=2*i;j<lim;j+=i)
		w[j]=true;
	}
}
for(int i=2;i<lim;i++)
{
	if(w[i]==false)
	v.push_back(i);
}
	int t;
	int n,k,res=1000000;
	cin>>t;
	while(t--)
	{ res=1000000;
	cin>>n>>k;
	for(int i=0;v[i]<=k;i++)
	
	{ //cout<<v[i]<<" pp"<<endl;
		if(k%v[i]==0)
		{
	           
	            res=min(res,ans(n,v[i])/an(k,v[i]));
	            
		}
}

	cout<<res<<endl;
	
}
}
t = int(input())
for i in range(t):
    a,b,c = map(float, raw_input().split())
    ans = 0.0
    if(a==0 and b ==0):
        ans = 1

    elif (a==0 and b!=0):

        if (c>=b):
            ans = 1.0
        else:
            ans = c/b

    elif (a!=0 and b==0):

        if(c>=a):
            ans = 1.0
        else:
            ans = c/a

    elif (c<=a and c<=b):

        ans = ((c/a)*(c/b))/2

    elif (b<= c and c<a):

        ans = (c/(2*a))*(c/b)-((c-b)/(2*a))*(c-b)/b

    elif (a<=c and c<b):

        ans = (c/(2*a))*(c/b)-((c-a)/(2*a))*((c-a)/b)

    elif (c > a and c > b and c<=(a+b)):

        ans = (c/(2*a))*(c/b)-((c-a)/(2*a))*((c-a)/b)-((c-b)/(2*a))*((c-b)/b)

    elif c>(a+b):

        ans = 1

    print ans
#include <stdio.h>
int max(int,int,int);
int main(void) 
{
int m,a=0,b=0,c=0,t=0;
scanf("%d",&t);
while(t--)
{
scanf("%d%d%d",&a,&b,&c);
m=max(a,b,c);
if(((m==a)&&(a==(b+c)))||((m==b)&&(b==(a+c)))||((m==c)&&(c==(b+a))))
{
printf("1\n");
}
else
{
    printf("0\n");
}
}
	return 0;
}

int max(int x,int y,int z)
{
int ma;
if ((x>y)&&(x>z))
ma=x;
else if(y>z)
ma=y;
else
ma=z;
return ma;
}
a=1
i=2
l=[1]*10001

eps=10**30

while(i<10001):
	te=i
	while(te%10==0):
		te/=10
	a*=te
	while(a%10==0):
		a/=10
	a%=eps
	l[i]=a
	i+=1

n=input()
while(n>0):
	print l[n]%10
	n=input()


# Fully upgraded Segment Tree
import math
"""
if you are not me...
  tstart = tree start
  qstart = query start
  rest are self explanatory
"""

def middle(start,end):
    return start + (end-start)/2

def MintreeCreate(arr,n):
    h = int(math.ceil(math.log(n,2)))
    stree = [0]*(2*2**h-1)
    fillMin(stree,0,n-1,arr,0)
    return stree
def fillMin(stree,tstart,tend,arr,index):
    if tstart == tend:
        stree[index] = arr[tstart]
        return arr[tstart]
    else:
        mid = middle(tstart,tend)
        stree[index] = min(fillMin(stree,tstart,mid,arr,index*2+1),fillMin(stree,mid+1,tend,arr,index*2+2))
    return stree[index]

def MaxtreeCreate(arr,n):
    h = int(math.ceil(math.log(n,2)))
    stree = [0]*(2*2**h-1)
    fillMax(stree,0,n-1,arr,0)
    return stree
def fillMax(stree,tstart,tend,arr,index):
    if tstart == tend:
        stree[index] = arr[tstart]
        return arr[tstart]
    else:
        mid = middle(tstart,tend)
        stree[index] = max(fillMax(stree,tstart,mid,arr,index*2+1),fillMax(stree,mid+1,tend,arr,index*2+2))
    return stree[index]

def SumtreeCreate(arr,n):
    h = int(math.ceil(math.log(n,2)))
    stree = [0]*(2*2**h-1)
    fillSum(stree,0,n-1,arr,0)
    return stree
def fillSum(stree,tstart,tend,arr,index):
    if tstart == tend:
        stree[index] = arr[tstart]
        return arr[tstart]
    else:
        mid = middle(tstart,tend)
        stree[index] = (fillSum(stree,tstart,mid,arr,index*2+1)+fillSum(stree,mid+1,tend,arr,index*2+2))
    return stree[index]


def getSum(stree,n,qstart,qend):
    return getSumTill(stree,0,n-1,qstart,qend,0)

def getSumTill(stree,tstart,tend,qstart,qend,index):
    if qstart <= tstart and qend >= tend:
        return stree[index]
    if tend < qstart or tstart > qend:
        return 0
    mid = middle(tstart,tend)
    return getSumTill(stree,tstart,mid,qstart,qend,index*2+1)+getSumTill(stree,mid+1,tend,qstart,qend,index*2+2)

def getMin(stree,n,qstart,qend):
    return getMinTill(stree,0,n-1,qstart,qend,0)

def getMinTill(stree,tstart,tend,qstart,qend,index):
    if qstart <= tstart and qend >= tend:
        return stree[index]
    if tend < qstart or tstart > qend:
        return 10**50
    mid = middle(tstart,tend)
    return min(getMinTill(stree,tstart,mid,qstart,qend,index*2+1),getMinTill(stree,mid+1,tend,qstart,qend,index*2+2))

def getMax(stree,n,qstart,qend):
    return getMaxTill(stree,0,n-1,qstart,qend,0)

def getMaxTill(stree,tstart,tend,qstart,qend,index):
    if qstart <= tstart and qend >= tend:
        return stree[index]
    if tend < qstart or tstart > qend:
        return -10**50
    mid = middle(tstart,tend)
    return max(getMaxTill(stree,tstart,mid,qstart,qend,index*2+1),getMaxTill(stree,mid+1,tend,qstart,qend,index*2+2))

def updateVal(arr,stree,n,i,new_value):
    difference = new_value - arr[i]
    arr[i] = new_value
    updateValTill(stree,0,n-1,i,difference,0)

def updateValTill(stree,tstart,tend,i,difference,index):
    if i < tstart or i > tend:
        return
    stree[index] += difference
    if tstart != tend:
        mid = middle(tstart,tend)
        updateValTill(stree,tstart,mid,i,difference,2*index+1)
        updateValTill(stree,mid+1,tend,i,difference,2*index+2)

n,q = map(int,raw_input().split())
arr = map(int,raw_input().split())
MinSegmentTree = MintreeCreate(arr,n)
MaxSegmentTree = MaxtreeCreate(arr,n)
while q > 0:
    q -= 1
    left,right = map(int,raw_input().split())
    print getMax(MaxSegmentTree,n,left,right)-getMin(MinSegmentTree,n,left,right)
x=raw_input()
x=x.split(" ")
y=float(x[1])
y=round(y,2)
x=int(x[0])
if x > y:
    print y
elif x%5 ==0 and x< y-0.50:
    print("{0:.2f}".format(y-x-0.50))
else:
    print y
# your code goes here
"""author : rjohari23"""

t = int(raw_input())
while t:
	no = raw_input()
	ans = ''
	
	for i in range(10):
		if no[i] == '0':
			ans += '-----'
		if no[i] == '1':
			ans += '.----'
		if no[i] == '2':
			ans += '..---'
		if no[i] == '3':
			ans += '...--'
		if no[i] == '4':
			ans += '....-'
		if no[i] == '5':
			ans += '.....'
		if no[i] == '6':
			ans += '-....'
		if no[i] == '7':
			ans += '--...'
		if no[i] == '8':
			ans += '---..'
		if no[i] == '9':
			ans += '----.'
		
	print ans
	print ans.count('.')
	
	t -= 1
def len(n):
    l=0
    while n:
        n/=10
        l+=1
    return l

def isprime(n):
    if n==2:
        return 1
    var=None
    for i in xrange(2,n):
        if n%i==0:
            break
        var=i
    if var==n-1:
        return 1
    else:
        return 0

def num_rot(n,f):
    l=len(n)-1
    while f:
        f-=1
        i=n%10
        n/=10
        n+=i*(10**l)
    return n

def cir_prime(n):
    k=n
    l=len(n)
    if isprime(k)==1:
        while l!=0:
            l-=1
            k=num_rot(n,l)
            if isprime(k)!=1:
                break
            if k<n and cir_prime(k)!=0:
                break
        if l==0:
            return 1
        else:
            return 0
    else:
        return 0

t=int(input())
a=raw_input().split(" ")
for j in a:
    print cir_prime(int(j)),

    

t = input()
for i in range(t):
	n = input()
	a = map(int,raw_input().split())
	a.sort()
	for j in a:
              print j 
n = int(raw_input())
a, b, c = map(int, raw_input().split())
l = map(int, raw_input().split())
ans, count = 0, 0
ans = a*a + b*b + c*c
for i in xrange(len(l)):
	if l[i]*l[i]<=ans:
		count = count + 1
print count
		

#include <bits/stdc++.h>
using namespace std;

int main() {
	// your code goes here
	int n,m;
	cin>>n>>m;
	int mval=INT_MIN;
	for(int i=0;i<n;i++)
	{
		int x;
		int temp=INT_MAX;
		for(int j=0;j<m;j++)
		{
			cin>>x;
			temp=min(temp,x);
		}
		mval=max(mval,temp);
	}
	cout<<mval<<endl;
	return 0;
}
INF=10**20
ZERO=0

def buildMaxTree(pos,start,end):
    if (start==end):
        min_tree_arr[pos]=a[start]
        return None
    mid =(start+end)/2
    buildMaxTree(2*pos,start,mid)
    buildMaxTree(2*pos+1,mid+1,end)
    min_tree_arr[pos]=max(min_tree_arr[2*pos],min_tree_arr[2*pos+1])

def buildMinTree(pos,start,end):
    if (start==end):
        max_tree_arr[pos]=a[start]
        return None
    mid =(start+end)/2
    buildMinTree(2*pos,start,mid)
    buildMinTree(2*pos+1,mid+1,end)
    max_tree_arr[pos]=min(max_tree_arr[2*pos],max_tree_arr[2*pos+1])

def queryMaxTree(pos,start,end,l,r):
    if (l>end or r<start) or (l>r):
        return ZERO                         #No-Overlap
    if (l<=start and r>=end):
        return min_tree_arr[pos]            #Total-Overlap
    mid=(start+end)/2 
    left=queryMaxTree(2*pos,start,mid,l,r)
    right=queryMaxTree(2*pos+1,mid+1,end,l,r)
    return max(left,right)

def queryMinTree(pos,start,end,l,r):
    if (l>end or r<start) or (l>r):
        return INF                          #No-Overlap
    if (l<=start and r>=end):
        return max_tree_arr[pos]            #Total-Overlap
    mid=(start+end)/2
    left=queryMinTree(2*pos,start,mid,l,r)
    right=queryMinTree(2*pos+1,mid+1,end,l,r)
    return min(left,right)

a=[0]
n=input()
arr=map(int,raw_input().split())
a.extend(arr)                               #To_make_1-based-indexing

min_tree_arr=[0]*(4*n+1)                    #max_segment_tree_size
max_tree_arr=[0]*(4*n+1)

buildMaxTree(1,1,n)                         #Tree_building_process
buildMinTree(1,1,n)

for query in xrange(input()):
    l,r=map(int,raw_input().split())
    l+=1                                    #To_make_1-based-indexing               
    r+=1                                    #To_make_1-based-indexing
    minn=queryMinTree(1,1,n,l,r)
    maxx=queryMaxTree(1,1,n,l,r)            #Tree_querying_process
    
    max_left=queryMaxTree(1,1,n,1,l-1)
    max_right=queryMaxTree(1,1,n,r+1,n)
    
    max_outer=max(max_left,max_right)+minn
    max_inner=minn+(maxx-minn)/2.0
    
    if(max_inner>max_outer):
        print max_inner
    else:
        print float(max_outer)

#!/bin/python

T=int(raw_input())
while T:
	S=raw_input()
	F=1
	for i in range(0,len(S)/2+1):
		if S[i]==S[len(S)-1-i]:
			continue
		else: 
			F=0
			break
	if F:
		print 'YES'
	else: print 'NO'
	T-=1
def readInt(d):
    return map(int, raw_input().strip().split(d))
#print readInt(',')

def f(N, K, M):
	if K==1: return N;
	while M > 0 and N%K == 0:
		M -= 1
		N /= K
	if M == 0: return N;
	if M%2 == 0:
		return N;
	return N*K;

t = input()
for _ in xrange(t):
	N,K,M = readInt(' ')
	print f(N,K,M)

for _ in xrange(int(raw_input())):
    n=int(raw_input())
    li=[0]
    lis=map(int, raw_input().split())
    li+=lis
    ans=0
    inc=2
    while(inc<=n):
        temp=0
        for i in xrange(inc, n+1, inc):
            temp+=li[i]
        ans=max(ans, temp)
        inc+=1
    print ans
    
a=input()
b=input()
print(a*b)
import sys

for __ in range(input()) :
    n = input()
    if n==1 :
        print 1
        continue
    k = n
    os , es = n/2 if not n&1 else (n/2)+1 , 0
    n = n/2 
    es = 2*(n*(n+1)/2)
    if k&1 :
        n += 1
        os += 2*(n*(n-1)/2)
    else :
        os += 2*(n*(n-1)/2)
    print os-es
t=input()
while t>0:
	n=input()
	B=[]
	for i in xrange(n):
		A=raw_input()
		A=sorted(A)
		B.append(A[len(A)/2])
	print "".join(B)
	t=t-1
	
		
t = int(raw_input())
for tt in range(t) :
    n = int(raw_input())
    m = int(raw_input())
    k = int(raw_input())
    print pow(n,m,k) 
#BISMILLAH
#NCRAAS
import operator as op
import math

def ncr(n, r):
	r = min(r, n-r)
	if r == 0: return n
	num = reduce(op.mul, xrange(n, n-r, -1))
	denom = reduce(op.mul, xrange(1, r+1))
	return num//denom

if __name__ == '__main__' :
	T=raw_input()
	T=int(T)
	while T > 0 :
		s=raw_input().split(' ')
		n=int(s[0])
		m=int(s[1])
		value = math.factorial(n)/math.factorial(m)/math.factorial(n-m)
		if value ==1 :
			print "1 1"
		else :
			print int(math.log(value,10))+1,int(math.log(value,2))+1
		T-=1


/***********Template Starts Here***********/
//#include <bits/stdc++.h>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <vector>
#include <deque>
#include <functional>
#include <string>
#include <iostream>
#include <cctype>
#include <set>
#include <climits>
#include <iomanip>
#include <cassert>
#include <sstream>
//#include <unordered_map>

#define pb push_back
#define nl puts ("")
#define sp printf ( " " )
#define phl printf ( "hello\n" )
#define ff first
#define ss second
#define POPCOUNT __builtin_popcountll
#define RIGHTMOST __builtin_ctzll
#define LEFTMOST(x) (63-__builtin_clzll((x)))
#define MP make_pair
#define FOR(i,x,y) for(int i = (x) ; i <= (y) ; ++i)
#define ROF(i,x,y) for(int i = (y) ; i >= (x) ; --i)
#define CLR(x,y) memset(x,y,sizeof(x))
#define UNIQUE(V) (V).erase(unique((V).begin(),(V).end()),(V).end())
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define NUMDIGIT(x,y) (((int)(log10((x))/log10((y))))+1)
#define SQ(x) ((x)*(x))
#define ABS(x) ((x)<0?-(x):(x))
#define FABS(x) ((x)+eps<0?-(x):(x))
#define ALL(x) (x).begin(),(x).end()
#define LCM(x,y) (((x)/gcd((x),(y)))*(y))
#define SZ(x) ((int)(x).size())
#define LL long long

using namespace std;

typedef long long vlong;
typedef unsigned long long uvlong;
typedef pair < int, int > pii;
typedef pair < vlong, vlong > pll;
typedef vector<pii> vii;
typedef vector<int> vi;

const vlong inf = 2147383647;
const double pi = 2 * acos ( 0.0 );
const double eps = 1e-9;

#ifdef forthright48
     #include <ctime>
     clock_t tStart = clock();
     #define debug(args...) {dbg,args; cerr<<endl;}
     #define timeStamp printf("Execution Time: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC)
#else
    #define debug(args...)  // Just strip off all debug tokens
    #define timeStamp
#endif

struct debugger{
    template<typename T> debugger& operator , (const T& v){
        cerr<<v<<" ";
        return *this;
    }
}dbg;

//int knightDir[8][2] = { {-2,1},{-1,2},{1,2},{2,1},{2,-1},{-1,-2},{1,-2},{-2,-1} };
//int dir4[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};

inline vlong gcd ( vlong a, vlong b ) {
    a = ABS ( a ); b = ABS ( b );
    while ( b ) { a = a % b; swap ( a, b ); } return a;
}

vlong ext_gcd ( vlong A, vlong B, vlong *X, vlong *Y ){
    vlong x, y, u, v, m, n, a, b, q, r;
    x = 0; y = 1;
    u = 1; v = 0;
    for (a = A, b = B; 0 != a; b = a, a = r, x = u, y = v, u = m, v = n) {
        q = b / a;
        r = b % a;
        m = x - (u * q);
        n = y - (v * q);
    }
    *X = x; *Y = y;
    return b;
}

inline vlong modInv ( vlong a, vlong m ) {
    vlong x, y;
    ext_gcd( a, m, &x, &y );
    if ( x < 0 ) x += m; //modInv is never negative
    return x;
}

inline vlong power ( vlong a, vlong p ) {
    vlong res = 1, x = a;
    while ( p ) {
        if ( p & 1 ) res = ( res * x );
        x = ( x * x ); p >>= 1;
    }
    return res;
}

inline vlong bigmod ( vlong a, vlong p, vlong m ) {
    vlong res = 1 % m, x = a % m;
    while ( p ) {
        if ( p & 1 ) res = ( res * x ) % m;
        x = ( x * x ) % m; p >>= 1;
    }
    return res;
}

/***********Template Ends Here***********/

LL t, tc = 0;
LL n, m, c[10005], d[10005];
LL dp[2002], cur, now;
pll st[2002];

bool meet(pll p1, pll p2, LL pos) {
    LL v1 = p1.ff*pos + p1.ss;
    LL v2 = p2.ff*pos + p2.ss;
    return v1 > v2;
}


int main () {
    #ifdef forthright48
    freopen ( "zz_test.txt", "r", stdin );
    //freopen ( "output.txt", "w", stdout );
    #endif // forthright48

    scanf("%lld", &t);

    while (tc<t) {
        tc++;

        scanf("%lld", &n);
        scanf("%lld", &m);

        for (LL i=1; i<=n; i++) {
            scanf("%lld", &c[i]);
        }

        sort(c+1,c+1+n);

        for (int i=1; i<=n; i++) {
            d[i] = d[i-1] + c[i];
        }

        CLR(dp,-1);
        dp[0] = 0;

        for (int mm=1; mm<=m; mm++) {
            cur = now = 0;
            st[cur++] = MP (n-mm+1,dp[mm-1]-(n-mm+1)*d[mm-1]);

            //debug(st[0].ff , st[0].ss);

            for (int i=mm; i<=n; i++) {

                LL last = dp[i];

                while (now < cur-1 && meet(st[now],st[now+1],d[i])) { now++; }

                dp[i] = d[i]*st[now].ff + st[now].ss;
                //debug(i, "~", dp[i], d[i], st[now].ff, st[now].ss);

                pll ins = MP (n-i,last-d[i]*(n-i));
                if (last == -1) continue;
                st[cur++] = ins;

            }

            //debug(mm, "->", dp[n]);
        }

        printf("%lld\n", dp[n]);
    }


    return 0;
}


import sys

T = int(raw_input())

while T :

	a , b = map(list,sys.stdin.readline().split())
	
	
	i = 0
	j = len(a) - 1
	
	while i <= j :
		t = a[i]
		a[i] = a[j] 
		a[j] = t
		i+=1
		j-=1
	
	i = 0
	j = len(b)-1
	
	while i<= j :
		t = b[i]
		b[i] = b[j] 
		b[j] = t
		i+=1
		j-=1
	
	a = "".join(a)
	a = int(a)
	b = "".join(b)
	b = int(b)
	
	a+=b
	
	a = list(str(a))
	
	i = 0
	j = len(a) - 1
	
	while i <= j :
		t = a[i]
		a[i] = a[j] 
		a[j] = t
		i+=1
		j-=1
	
	a = "".join(a)
	a = int(a)
	print a
	T-=1
	
t = int(raw_input())
for _ in range(t):
	n = int(raw_input())
	n+=1
	while True:
		tmp = str(n)
		if tmp==tmp[::-1]:
			print tmp
			break
		n+=1

T=input()
while T:
    T-=1
    inv=0
    N=list(str(input()))
    length=len(N)
    for i in range(0,length):
        N[i]=int(N[i])
    i=0
    while i<length-1 and N[i+1]==N[i]:
        i+=1
    if i==length-1:
        print 'valid'
        continue
    if N[i+1]>N[i]:
        while i<length-1 and N[i+1]>=N[i]:
            i+=1
        if i==length-1:
            print 'valid'
            continue
        elif N[i+1]<N[i]:
            print 'invalid'
            continue
    elif N[i+1]<N[i]:
        while i<length-1 and N[i+1]<=N[i]:
            i+=1
        if i==length-1:
            print 'valid'
            continue
        elif N[i+1]>N[i]:
            print 'invalid'
            continue

a=list(map(int,raw_input().split()))
b=list(map(int,raw_input().split()))
arr=[]
for i in range(1,len(a)):
    for j in range(1,len(b)):
        arr.append(abs(a[i]-b[j]))
arr=sorted(arr)
print arr[0]
#!/usr/bin/env python

ALPHA  = ''.join(map(lambda x: chr(65 + x), range(26)))
ALPHA += ALPHA.lower()
ALPHA += ''.join(map(str, range(10)))

def main():
    while True:
        try:
            S = raw_input()
        except:
            break
        W = ''
        R = ''
        for c in S:
            if  c in ALPHA:
                W += c
            else:
                R += ''.join(reversed(W))
                R += c
                W  = ''
        if W:
                R += ''.join(reversed(W))
        print R

main()


t=int(input())
while(t>0):
	n=int(input())
	a=map(int,raw_input().split(" "))
	i=n-1
	m=a[i]
	ans=0
	i=n-2
	while(i>=0):
		if(m>a[i]):
			ans+=m-a[i]
		elif(m<a[i]):
			m=a[i]
		i-=1
	print ans
			
	t-=1

cases = int(raw_input())

for case in xrange(cases):
   initial_number = int(raw_input())
   if initial_number % 4:
       print "First"
   else:
       print "Second"
for t in range(int(raw_input())):
    a = [[0]*4 for x in range(4)]
    n = int(raw_input())
    for i in range(n):
        (x, y) = (int(j) for j in raw_input().split())
        index = -1
        if x > 0:
            if y > 0:
                index = 0
            elif y < 0:
                index = 1
        elif x < 0:
            if y < 0:
                index = 2
            elif y > 0:
                index = 3
        if index != -1:
            a[index][((abs(x) & 1) * 2) + (abs(y) & 1)] += 1
    result = 0
    for i1 in range(4):
        for i2 in range(4):
            for i3 in range(4):
                for i4 in range(4):
                    x1 = i1 ^ i2
                    x1 &= x1 >> 1
                    x2 = i2 ^ i3
                    x2 &= x2 >> 1
                    x3 = i3 ^ i4
                    x3 &= x3 >> 1
                    x4 = i4 ^ i1
                    x4 &= x4 >> 1
                    x = x1 ^ x2 ^ x3 ^ x4
                    if x == 0:
                        result += a[0][i1] * a[1][i2] * a[2][i3] * a[3][i4]
    print result
# your code goes here
m,n = map(int,raw_input().split())
a = []
for _ in range(m):
	a.append(map(int,raw_input().split()))

flag = 1
for i in range(m):
	for j in range(n):
		if j > 0:
			if a[i][j-1] != a[i][j]:
				flag = 0
				break
		if i > 0:
			if a[i-1][j] == a[i][j]:
				flag = 0
				break
		
	if flag == 0:
		break

if flag == 0:
	print "NO"
else:
	print "YES"
from math import factorial as fac
def catalan(n):
    return fac(2*n) // fac(n+1) // fac(n)
 
def num_handshakes(n):
    if n % 2 == 1: return 0
    return catalan(n//2)
T=int(raw_input())
while T>0:
    N=int(raw_input())
    print num_handshakes(2*N) %100003
    T=T-1
#!/usr/bin/python

if __name__=="__main__":
	N=input()
	while(N):
		s=raw_input()
		l=len(s)
		x=""
		f=0
		for i in range(l):
			if s[l-i-1]=='4' and f==0:
				x='7'+x
				f=1
			elif s[l-i-1]=='7' and f==0:
				x='4'+x
			else: x=s[l-i-1]+x		
		if f==0:
			print '4'+x
		else:print x
		N-=1

import datetime
dt='21/03/2012'
day, month, year = (int(x) for x in dt.split('/'))    
ans=datetime.date(year,month,day)
print (ans.strftime("%A"))
x=int(raw_input())
l=int(raw_input())
b=int(raw_input())
y=0
while(x):
    a=int(raw_input())
    y=y+a
    x-=1
if(y==(l*b)):
     print "YES"
else:
     print "NO"

#include <bits/stdc++.h>

#define clr(x) memset((x), 0, sizeof(x))
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define in(x) int (x); input((x));
#define x first
#define y second
typedef int itn;

//#define next next12345
//#define prev prev12345
#define left lefdsf232
#define right rig43783
#define x1 x12345
#define y1 y12345

using namespace std;

template<typename T>
T gcd(T x, T y) {
    while (y > 0) {
        x %= y;
        swap(x, y);
    }
    return x;
}

template<class T>
T lcm(T a, T b) {
    return a / gcd(a, b) * b;
}


template<class _T>
inline _T sqr(const _T &x) {
    return x * x;
}

template<class _T>
inline string tostr(const _T &a) {
    ostringstream os("");
    os << a;
    return os.str();
}

typedef long double ld;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const ld PI = 3.1415926535897932384626433832795L;

template<typename T>
inline void input(T &a) {
    static int ed;
    a = 0;
    while (!isdigit(ed = getchar()) && ed != '-') { }
    char neg = 0;
    if (ed == '-') {
        neg = 1;
        ed = getchar();
    }
    while (isdigit(ed)) {
        a = 10 * a + ed - '0';
        ed = getchar();
    }
    if (neg) a = -a;
}

template<typename T = int>
inline T nxt() {
    T res;
    input(res);
    return res;
}

mt19937 generator;

bool check(int v) {
    if (v < 2) return false;
    for (int i = 2; i * i <= v; ++i) {
        if (v % i == 0) {
            return false;
        }
    }
    return true;
}

long long pw(long long a, long long n, long long m) {
    ll res = 1;
    while (n) {
        if (n & 1ll) {
            res = res * a % m;
        }
        a = a * a % m;
        n >>= 1;
    }
    return res;
}


void pre() {
}

void gen() {
}

const int N = 3000;

vector <int> g[N];

int dp[N][N];

int leaves[N];

int l;

void dfs(int v, int p) {
    int ch = 0;
    leaves[v] = 0;
    for (int to : g[v]) {
        if (to == p) continue;
        dfs(to, v);
        leaves[v] += leaves[to];
        ch += 1;
    }

    if (ch == 0) {
        dp[v][0] = 0;
        dp[v][1] = 1;
        leaves[v] = 1;
        return;
    }

    for (int i = 0; i <= leaves[v] && i <= l; ++i) {
        dp[v][i] = 0x3f3f3f3f;
    }

    dp[v][0] = 0;
    if (leaves[v] <= l) dp[v][leaves[v]] = 1;

    int s = 0;

    for (int to : g[v]) {
        if (to == p) {
            continue;
        }
        for (int k = min(s, l); k >= 0; --k) {
            for (int j = 1; j <= leaves[to] && j + k <= l; ++j) {
                dp[v][k + j] = min(dp[v][k + j], dp[v][k] + dp[to][j]);
            }
        }
        s += leaves[to];
    }
}

void read() {
    int n = nxt();

    for (int i = 1; i < n; ++i) {
        int u = nxt() - 1;
        int v = nxt() - 1;
        g[u].pb(v);
        g[v].pb(u);
    }

    for (int i = 0; i < n; ++i) {
        l += g[i].size() == 1;
    }
    l /= 2;
    int ans = l;
    int z = 0;
    vector <int> order(n);
    iota(all(order), 0);
    random_shuffle(all(order));
    double mt;
    while (z < n) {
        int root = order[z++];
        double start = clock();
        dfs(root, root);
        double end = clock();
        if (z == 1) {
            mt = end - start;
        }
        ans = min(ans, dp[root][l]);
        if (end + mt > 1.9 * CLOCKS_PER_SEC) {
            break;
        }
    }
    cout << ans << "\n";
}


void solve2() { }


int main(int argc, char ** argv) {

#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
#else
    #define fname "d"
    //freopen(fname".in", "r", stdin);
    //freopen(fname".out", "w", stdout);
#endif
    int t = 1;
    pre();
#ifdef LOCAL
#endif

//    test();

    int c = 0;
    while (t--) {
        //gen();
        read();
//        gen();
//        gen2();
    }


#ifdef LOCAL
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC * 1000 << " ms." << endl;
#endif
    return 0;
}
t=int(raw_input())
mod=1000000007
fact=[]
def power(a,b):
    if b==0:
        return 1
    else:
        l=power(a,b/2)
        l=(l*l)%mod
        if b%2==1:
            return (l*a)%mod
        return l


def factoria(n):
    fact.append(1)
    for i in range(1,100010):
        num=(fact[i-1]*i)%mod
        fact.append(num)



while t>0:
    temp=raw_input().split(' ')
    n=int(temp[0])
    k=int(temp[1])
    if n<k:
        print "0"
    else:    
        factoria(100000)
        ans1=fact[n-k]
        ans2=fact[k]
        ans=(power(ans1,mod-2)*power(ans2,mod-2))%mod
        ans=(ans*fact[n])%mod
        print ans
    t=t-1

for i in range(10):
    a=set()
    for k in range(10):
        t=int(raw_input())
        a.add(t%42)
    print len(a)
def calc2(n):
        tp=n
        s=''
        while tp>0:
                k=tp%9
                if(k==0):
                        k=9
                s=str(k)+s
                tp=(tp-k)/9
        return int(s)    
def calc1(n,d):
        di=dict()
        for i in range(0,9):
                if i<d:
                        di[i]=i
                else:
                        di[i]=i+1

        s=''
        tp=n
        while tp>0:
                s=str(di[tp%9])+s
                tp/=9
        return int(s)
inp=int(raw_input())
for t in range(0,inp):
        st=raw_input()
        ls=st.split()
        n=int(ls[0])
        d=int(ls[1])
        if d!=0:
                print calc1(n,d)
        else:
                print calc2(n)

import random
T=input()
list=[]
count=0
for i in range(T):
    l=input()
    list.append(l)
for j in range(T):
    if list[j]%2==0:
        print 'ALICE'
    else:
        print 'BOB' 
import math
s=math.factorial(999)
s=str(s)
print len(s)
print s 
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    while True:
        if str(n)==str(n)[::-1]:
            print n
            break
        n+=1
#include<bits/stdc++.h>
using namespace std;

int main() 
{
	int n,t,i,count,max,a[100001];
	cin>>t;
	while(t--)
	{
	    max=INT_MIN;
	    count=1;
	    cin>>n;
	    for(i=0;i<n;i++)
	    cin>>a[i];
	    sort(a,a+n);
	    for(i=0;i<n-1;i++)
	    {
	    if(a[i]==a[i+1])
	    count++;
	    else
	    count=1;
	    if(count>max)
	    max=count;
	    }
	    cout<<max<<endl;
	}
	return 0;
}

n = int(raw_input())
num = []
ans = 0
num = raw_input().split(" ")
for i in range(n):
    if int(num[i])%2 == 0 :
        ans += 1
    else:
        ans -= 1
print abs(ans)
print 2**(bin(int(raw_input())).count('1'))
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll cnt;
pair<ll,ll> st[100010];
ll d[100010];
inline void scanint(ll* x)
{
	register char c = getchar_unlocked();
	*x = 0;
	for(; (c<48)||(c>57);c = getchar_unlocked());
	for(; (c>47)&&(c<58);c = getchar_unlocked())
		*x = (ll)((((*x)<<1) + ((*x)<<3)) + c - 48);
}
inline void printint(ll n)
{
	if(n == 0)
	{
		putchar_unlocked('0');
		putchar_unlocked('\n');
	}
	else
	{
		char buf[20];
		buf[19] = '\n';
		int i = 18;
		while(n)
		{
			buf[i--] = n % 10 + '0';
			n /= 10;
		}
		while(buf[i] != '\n')
			putchar_unlocked(buf[++i]);
	}
}




ll* merge(ll* a,ll i, ll m,ll j){
  ll x,y,z;
  ll n1 = m-i+1;
  ll n2 = j-m;
  ll c[n1],d[n2];
  for(x=0;x<n1;x++){
     c[x]=a[i+x];
  }
  for(x=0;x<n2;x++){
     d[x]=a[m+1+x];
  }
  x=0ll;
  y=0ll;
  z=i;

  while(x<n1&&y<n2){
    if(c[x]<=d[y]){
      a[z]=c[x];
      x++;
    }
    else{
      cnt=cnt+n1-x;
      a[z]=d[y];
      y++;
    }
    z++;
  }

  while(x<n1){
    a[z]=c[x];
    z++;
    x++;

  }
  while(y<n2){
    a[z]=d[y];
    z++;
    y++;
  }
  return a;
}
void mergesort(ll *a,ll i, ll j){
  if(i<j){
  ll m = (i+j)/2;
  mergesort(a,i,m);
  mergesort(a,m+1,j);
  merge(a,i,m,j);


  }
}



int main(){

        ll t;
     //   cin>>t;
        scanint(&t);

        while(t--){
              cnt=0;
              memset(st,0,sizeof(st));
              
              ll n,t1,i,v,ans=0,inp;
           //   cin>>n>>t1;
              scanint(&n);
              scanint(&t1);

              for(i=1;i<=n;i++){
              //    cin>>inp[i]>>v;
              scanint(&inp);
              scanint(&v);


                 st[i]=make_pair(inp,v);

              }
			 sort(st+1,st+n+1);
             for(i=0;i<n;i++){
             	 d[i]=st[i+1].first+st[i+1].second*t1;
             }

//          
			mergesort(d,0,n-1);
            printint(cnt);


        }

}

import java.util.*;
class anticlockspiralfill
{
public static void main(String args[])
{
int k,c,i,j,l,a[][];
Scanner sc=new Scanner(System.in);
l=sc.nextInt();
a=new int[l][l];
switch(l%2)
{
    case 0:
        k=l/2;
        i=k;j=k-1;
        for(c=1;c<=l*l;c++)
        {
            a[i][j]=c;
            if(i<(l-k)&&j==(k-1)&&i!=k-1)
                i++;
            else if(j<(l-k)&&i==(l-k))
                j++;
            else if(i>(k-1)&&j==(l-k))
                i--;
            else if(j>=(k-1)&&i==(k-1))
            {
                if(j==(k-1))
                    k--;
                    j--;
            }
        }
break;
case 1:
          k=l/2+1;
          i=k-1;j=k-1;
        for(c=1;c<=l*l;c++)
        {
            a[i][j]=c;
            if(i>(k-1)&&j==(l-k)&&i!=(l-k))
                i--;
            else if(j>(k-1)&&i==(k-1))
                j--;
            else if(i<(l-k)&&j==(k-1))
                i++;
            else if(j<=(l-k)&&i==(l-k))
            {
                if(j==(l-k))
                    k--;
                j++;
            }
        }
break;
}
    for(i=0;i<l;i++)
    {
        for(j=0;j<l;j++)
            System.out.print(a[i][j]+"\t");
            System.out.println();
    }
}
}
#include<iostream>
#include<cstring>
using namespace std ;
#define rep(i,a,b) for ( int i = (a) ; i < (b) ; i++ )
int ctr = 0 ;
int gr[100][100] , vis[100][100] ;
int N ;
int dx[4]={1,0,0,-1};
int dy[4]={0,1,-1,0};

void dfs(int m , int n)
{
	if ( m==N-1 && n== N-1) ctr++ ;
	vis[m][n]=true;
	if ( m+1<N && !vis[m+1][n] && gr[m+1][n]==0 ) dfs(m+1,n) ;
	if ( n+1<N && !vis[m][n+1] && gr[m][n+1]==0 ) dfs(m,n+1) ;
	if ( m-1>=0 && !vis[m-1][n] && gr[m-1][n]==0 ) dfs(m-1,n) ;
	if ( n-1>=0 && !vis[m][n-1] && gr[m][n-1]==0 ) dfs(m,n-1) ;
	vis[m][n]=false;
}

int main ( )
{

	cin >> N ;
	rep(i,0,N) rep(j,0,N) cin >> gr[i][j] ;
	memset(vis,0,sizeof(vis));
	dfs(0,0);
	cout << ctr << endl ;
	return 0 ;
}
import java.util.*;
import java.lang.*;
import java.io.*;

 class NitsSats{
	public static void main(String [] args){
	int []a=new int[10001];
	for(int i=1;i<10001;i++) a[i]=1;
	int temp=2;
	int n=10001;
	while(temp<n){
		int c=temp;
		for(int i=1;i<10001;i++){
			if(a[i]==1&&c>0){
				c-=1;
			}
			if(c==0){
				a[i]=0;
				c=temp;
				n-=1;
			}
		}
		temp+=1;
	}
	//for(int i=1;i<50;i++) System.out.print(a[i]+" "); System.out.println("");
	int t;
	Scanner sc = new Scanner (System.in);
	t = sc.nextInt();
	while(t!=0){
		t-=1;
		n = sc.nextInt();
		for(int i=1;i<=n;i++){
			if(a[i]==1) System.out.print(i+" ");
			else continue;
		}
		System.out.println("");
	}

	}
}
#include<stdio.h>
int a[10001000];
int main()
{
	int i,j,k,l=2,m=2,t=1;
	a[0]=1;
	a[1]=2;
	for(k=1,m=2;k<25474;k++)
	{
		for(j=0;j<a[k];j++,t++)
			a[t]=m;
		if(t>10000000)
			goto end;
		m++;
	}
end:;
    int test;
    scanf("%d",&test);
	for(i=0;i<test;i++)
	{
		int n;
		scanf("%d",&n);
		printf("%d\n",a[n-1]);
	}
	return 0;
}
#include<iostream>
using namespace std;
int dp[10000000];
int main()
{
    int n,k;
    cin>>n>>k;
    dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        dp[i]=(dp[i-1]+(k-1))%i+1;

    }
    cout<<dp[n]<<endl;

}


/* Come on Code on!!!!
re_hash
dev_cpp
*/

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>
using namespace std;

#define S(a) scanf("%d",&(a))
#define P(a) printf("%d",(a))
#define NL printf("\n")
#define SL(a) scanf("%lld",&(a))
#define PL(a) printf("%lld",(a))
#define ll long long int
#define FOR(I,A,B) for(int I= (A); I<(B); ++I)
#define all(c) c.begin(), c.end()
#define stop system("pause")
#define pb push_back
#define mp make_pair
#define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)

int main(){
    int t;
    S(t);
    while(t--){
        int a,b;
        int x,y;
        S(a);S(b);S(x);S(y);
        int mx = max(a-x,x-1);
        int my = max(b-y,y-1);
        P(mx+my);
        NL;
    }
    return 0;
}
        


/* Come on Code on!!!!
re_hash
dev_cpp
*/

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <ctime>
#include <cassert>
#include <climits>
#include <limits>
using namespace std;

#define S(a) scanf("%d",&(a))
#define P(a) printf("%d",(a))
#define NL printf("\n")
#define SL(a) scanf("%lld",&(a))
#define PL(a) printf("%lld",(a))
#define ll long long int
#define FOR(I,A,B) for(int I= (A); I<(B); ++I)
#define all(c) c.begin(), c.end()
#define stop system("pause")
#define pb push_back
#define mp make_pair
#define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define INF 100000000

int main(){
    int test;
    S(test);
    while(test--){
        int n,t,m;
        S(n);S(t);S(m);
        t+=t;
        int dp[1500];
        dp[0]=0;
        FOR(i,1,m+1){
            int temp;
            S(temp);
            dp[i]=INF;
            for(int j=i;j>=max(1,i-n+1);j--){
                dp[i]=min(dp[i],max(dp[j-1],temp)+t);
            }
        }
        P(dp[m]-t/2);
        printf(" ");
        P((m-1)/n + 1);
        NL;
    }
    return 0;
}
                
                

#include "stdio.h"
#include "stdlib.h"
#include <algorithm>

long long int nC2(long int i) {return ((i*(i-1))/2);}

long int n;
int *array;
long int *cumulative;

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%ld",&n);
		array = new int [n];
		cumulative = new long int [n];
		for(long int index=0;index<n;index++) scanf("%d",array+index);
		cumulative[0] = array[0];
		for(long int index=1;index<n;index++) cumulative[index] = cumulative[index-1] + array[index];
		std::sort(cumulative,cumulative+n);
		long int current = cumulative[0];
		long int count = 1;
		long long int result = 0;
		for(long int index=1;index<n;index++)
		{
			if(cumulative[index]==current) count++;
			else 
			{	
				result += nC2(count);
				if(current == 0) result += count;
				current = cumulative[index];
				count = 1;
			}
		}
		result += nC2(count);
		if(current == 0) result += count;
		printf("%lld\n",result);
	}


	return 0;
}
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <string>
#include <map>

using namespace std;

int main(){
    int t;
    scanf("%d",&t);
    while(t--){
               int n;
               scanf("%d",&n);
               vector <vector <int> > bomb(201,vector <int>(201,0));
               int x,y;
               for(int i=0;i<n;++i){
                       scanf("%d%d",&x,&y);
                       bomb[x][y]=1;
                       }
               int cc=0;
               for(int i=0;i<=200;++i){
                       for(int j=0;j<=200;++j){
                               if(bomb[i][j]==0)
                                                continue;
                               bool a,b,c,d;
                               a=false;
                               for(int ii=0;ii<j;++ii){
                                       if(bomb[i][ii]==1){
                                                          a=true;
                                                          break;
                                                          }
                                       }
                               b=false;
                               for(int ii=j+1;ii<=200;++ii){
                                       if(bomb[i][ii]==1){
                                                          b=true;
                                                          break;
                                                          }
                                       }
                               c=false;
                               for(int ii=0;ii<i;++ii){
                                       if(bomb[ii][j]==1){
                                                          c=true;
                                                          break;
                                                          }
                                       } 
                               d=false;
                               for(int ii=i+1;ii<=200;++ii){
                                       if(bomb[ii][j]==1){
                                                          d=true;
                                                          break;
                                                          }
                                       }                         
                               if((a & b & c & d))
                                     cc++;                 
                               }
                       //cout<<endl;
                       //system("pause");
                       }
               printf("%d\n",cc);
               }
    return 0;
}


#include <cstdio>
 
#define MOD 1000000007
 
int fact[5001], invfact[5001];
 
int powmod(int base, int expo){
    if(expo==0)
		return 1;
	else if(expo&1)
		return (long long)base*powmod(base, expo-1)%MOD;
	else{
		int root=powmod(base, expo>>1);
		return (long long)root*root%MOD;
	}
}
 
int inverse(int x){
	return powmod(x, MOD-2);
}
 
void init(){
	fact[0]=1;
	for(int i=1; i<=5000; i++)
		fact[i]=(long long)i*fact[i-1]%MOD;
	invfact[5000]=inverse(fact[5000]);
	for(int i=5000; i>0; i--)
		invfact[i-1]=(long long)i*invfact[i]%MOD;
}
 
int nCr(int n, int r){
	if(r>n || r<0)
		return 0;
	return (long long)((long long)fact[n]*invfact[r]%MOD)*invfact[n-r]%MOD;
}
 
int main(){
	init();
	int N, K;
	while(scanf("%d %d", &N, &K) && !(N==0 && K==0)){
        if(K==0) {puts("0");continue;}
        N = N/2;
       
		int res=2ll*nCr(N-1, (K)/2)*nCr(N-1, (K-1)/2)%MOD;
		printf("%d\n", res);
	}
}


#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define Hash 1001007

int fa[Hash],num[Hash],son[Hash],next[300001],tot,T,n,i,j,k,aim,a1,a2;
char str[300001][100],s1[100],s2[100],s[100];

int hash(char s[],int l)
{
    int i;
    long long re=0;
    for(i=0;i<l;++i)re=(re*1456+s[i]+78114)%Hash;
    return re;
}

int get(int p)
{
	if(fa[p]==p)return p;
	fa[p]=get(fa[p]);
	return fa[p];
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(i=0;i<Hash;++i)son[i]=0;
		for(i=1;i<=n;++i)
		{
			scanf("%s%s",s1,s2);
			a1=j=hash(s1,strlen(s1));
			for(j=son[j];j;j=next[j])if(strcmp(str[j],s1)==0)break;
			a2=k=hash(s2,strlen(s2));
			for(k=son[k];k;k=next[k])if(strcmp(str[k],s2)==0)break;
			if(!j){++tot;j=tot;memcpy(str[j],s1,sizeof(s1));next[tot]=son[a1];son[a1]=tot;fa[tot]=tot;num[tot]=1;}
			if(!k){++tot;k=tot;memcpy(str[k],s2,sizeof(s2));next[tot]=son[a2];son[a2]=tot;fa[tot]=tot;num[tot]=1;}
			j=get(j);k=get(k);
			if(j!=k)
			{
				fa[j]=k;
				num[k]+=num[j];
			}
			printf("%d\n",num[get(j)]);
		}
	}
}
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

int n,m,ms;
int set[1001][1001];

struct st{
	int p,sz;
}s[1001000];


int findSet(int x){
	if( x!=s[x].p ) return s[x].p=findSet(s[x].p);
	return s[x].p;
}
void Union(int x,int y){  ///cout<<x<<" link "<<y<<endl;
	x=findSet(x); y=findSet(y);
	if( x==y ) return ;
	s[x].p=y;
	s[y].sz+=s[x].sz;
	ms=max(ms,s[y].sz);
}

int main (){
	scanf("%d %d",&n,&m);
	int q; scanf("%d",&q);
	for(int i=0;i<=n;i++) {
		 s[i].p=-1; s[i].sz=1;
	}
	for(int i=0;i<q;i++){
		int c,a,b;
		scanf("%d",&a);
		if( a==0 ) printf("%d\n",ms);
		else {
			scanf("%d %d",&a,&b); // cout<<a<<" "<<b<<endl;
			if( set[a][b] ) continue;
			set[a][b]=1; ms=max(ms,1);
			
			c=(a-1)*m+b;  //cout<<"c"<<c<<endl;
			s[c].p=c; s[c].sz=1;
			
			if( a-1   && set[a-1][b])  Union(c, (a-2)*m+b);
			if( b-1   && set[a][b-1])  Union(c, (a-1)*m+b-1);
			if(a+1<=n && set[a+1][b])  Union(c, (a  )*m+b);
			if(b+1<=m && set[a][b+1])  Union(c, (a-1)*m+b+1);
			
		}
	}
	
	
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
int a[200005][26]={0};
int main()
{
	char str[200001];
	cin>>str;
	int len=strlen(str);
	for(int i=0;i<len;i++)
	{
			for(int j=0;j<26;j++)
				a[i+1][j]=a[i][j];
		a[i+1][str[i]-'a']++;
	}
	int q;
	cin>>q;
	while(q--)
	{
		int ans=0,f=0,l,r;
		cin>>l>>r;
		for(int i=0;i<26;i++)
		{
			ans+=a[r][i]-a[l-1][i];
			if(ans%2!=0)
			{
				ans=ans-1;
				f=1;
			}
		}
		if(f==1)	
		ans=ans+1;
		cout<<ans<<endl;
	}
	return 0;
} 
#include<stdio.h>
int f[1000005];
void Prefix(char p[],int m)
{
    int i,j;
    f[0]=0;
    i=1;
    j=0;
    while(i<m)
    {
        if(p[i]==p[j])
        {
            f[i]=j+1;
            i++;
            j++;
        }
        else
        if(j>0)
        {
            j=f[j-1];
        }
        else
        {
            f[i]=0;
            i++;
        }
    }
}
int KMP(char t[],char p[],int m,int n)
{
    int i=0,j=0;
    Prefix(p,m);
int     count=0;
    while(i<n)
    {
        if(t[i]==p[j])
        {
            if(j==m-1)
            {
                count++;
            }

            i++;
            j++;
        }
        else
        if(j>0)
        j=f[j-1];
        else
        i++;
    }
    return count;
}
int main()
{
    int t,n;
    char s[100005],a[100005];
    scanf("%d",&t);
    while(t--)
    {


    scanf("%s",s);
    scanf("%d",&n);
    while(n--)
    {


    scanf("%s",a);
   int final =KMP(s,a,strlen(a),strlen(s));
   printf("%d\n",final);
    }
    }
}

#include<stdio.h>
 
long long count,m,n,space[100][100];
void lot(int i,int j){
	if((i==m-1&&j==n-1)||(i==m-1&&space[i][j+1]==2147483647)||(j==n-1&&space[i+1][j]==2147483647)||((space[i][j+1]==2147483647)&&space[i+1][j]==2147483647));
	else{
		count++;
		if(i==m-1||space[i+1][j]==2147483647){
			lot(i,j+1);
		}
		else if(j==n-1||space[i][j+1]==2147483647){
			lot(i+1,j);
		}
		else if(space[i][j+1]<space[i+1][j]){
			lot(i,j+1);
		}
		else{
			lot(i+1,j);
		}
	}
}
	
	
int main(){
	long long inputs,i,j;
	scanf("%lld",&inputs);
	while(inputs){
		scanf("%lld",&m);
		scanf("%lld",&n);
		for(i=0;i<m;i++){
			for(j=0;j<n;j++){
				scanf("%lld",&space[i][j]);
			}
		}
		count=0;
		lot(0,0);
		printf("%lld\n",count);
		inputs--;
	}
	return 0;
}	
t_cases = int(raw_input())

for i in range(t_cases):
    
    g_size = int(raw_input())
    passw = ""
    for i in range(g_size):
        passw = passw+''.join((raw_input()).split(" "))

    if passw == passw[::-1] :
        print "Yes"
    else:
        print "No"

#include<iostream>
#include<fstream>
#include<vector>
#include<cstring>
#include<map>
#define in cin
#define out cout
using namespace std;
const int Nmax = 1001;
const int MOD1 = 734057;
const int MOD2 = 941911;
int d[2][Nmax][Nmax];
char s[Nmax+2];
map< pair<int,int>,vector< pair<int,int> > > M;
int main(){
    #ifndef ONLINE_JUDGE
    ifstream in("test.in");
    ofstream out("test.out");
    #endif
    d[0][0][1]=d[1][0][1]=1;
    for(int i=1;i<Nmax;i++){
        for(int j=1;j<Nmax;j++){
            d[0][i][j]=(d[0][i-1][j]+d[0][i][j-1])%MOD1;
            d[1][i][j]=(d[1][i-1][j]+d[1][i][j-1])%MOD2;
            M[make_pair(d[0][i][j],d[1][i][j])].push_back(make_pair(i,j));
        }
    }
    int T; in>>T; in.get();
    while(T--){
        in.getline(s+1,Nmax);
        int n=strlen(s+1);
        int m1=0,m2=0;
        for(int i=1;i<=n;i++){
            m1=(m1*10+(int(s[i])-'0'))%MOD1;
            m2=(m2*10+(int(s[i])-'0'))%MOD2;
        }
        int mn=M[make_pair(m1,m2)].size();
        if(mn==0) out<<"The Grid is Too Big!\n";
        else{
            out<<mn<<'\n';
            for(vector< pair<int,int> >::iterator it=M[make_pair(m1,m2)].begin();it!=M[make_pair(m1,m2)].end();++it){
                out<<it->first<<' '<<it->second<<'\n';
            }
        }
    }
    return 0;
}
#include <iostream>
#include <climits>
using namespace std;
int eggDrop(int f, int e)
{
	if(f <= 1)
		return f;
	int dp[f+1][e+1];
	for(int i=0;i<=f;i++)
		for(int j=0;j<=e;j++)
			dp[i][j] = 0;
	for(int i=1;i<=f;i++)
	{
		for(int j=1;j<=e;j++)
		{
			if(j == 1)
			{
				dp[i][j] = i;
				continue;
			}
			int currMin = INT_MAX;
			int tmp;
			for(int k=1;k<=i;k++)
			{
				tmp = ((dp[k-1][j-1]+1)>dp[i-k][j]?(dp[k-1][j-1]+1):dp[i-k][j]);
				tmp++;
				if(tmp < currMin)
					currMin = tmp;
			}
			dp[i][j] = currMin;
		}
	}
	/*
	for(int i=0;i<=f;i++)
	{
		for(int j=0;j<=e;j++)
			cout << dp[i][j] << " ";
		cout << endl;
	}
	*/
	dp[f][e]++;
	return dp[f][e];
}
 
int main() {
	//code
	int tc;
	cin >> tc;
	int n,k;
	while(tc-- > 0)
	{
	    cin >> n >> k;
	    cout << eggDrop(n,k) << endl;
	}
	return 0;
} 
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int tc;cin>>tc;
    while(tc--)
    {
        int coun=0;string s;cin>>s;
        set<char> S(s.begin(),s.end());set<char>::iterator it;
        for(it = S.begin();it!=S.end();it++) coun++;cout<<coun<<endl;
    }
}
#include<stdio.h>
#include<math.h>
#define ld long double

ld abs(ld a) { return a>0?a:-a; }
ld max(ld a, ld b) { return a>b?a:b; }

int main() 
{
	int N, min_index = 0;
	scanf("%d", &N);
	ld ave_x = 0.0, ave_y = 0.0, min, sum = 0.0, x[N+1], y[N+1];
	
	for(int i=0; i<N; i++)  scanf("%Lf%Lf",&x[i],&y[i]);
	
	for(int i=0; i<N; i++) 
	{
		ave_x += x[i]/(ld)N;
		ave_y += y[i]/(ld)N;
	}
	
	min = sqrt((ave_x-x[0])*(ave_x-x[0]) + (ave_y-y[0])*(ave_y-y[0]));
	for(int i=1; i<N; i++) 
	{
		ld quo = sqrt((ave_x-x[i])*(ave_x-x[i]) + (ave_y-y[i])*(ave_y-y[i]));
		if(quo < min) 
		{
			min = quo;
			min_index = i;
		}
	}
	
	for(int i=0; i<N; i++)   sum += max(abs(x[min_index]-x[i]), abs(y[min_index]-y[i]));
	printf("%0.0Lf\n",sum);
	
	return 0;
}
#include<stdio.h>
int main()
{
    int x,y,z;
    scanf("%d%d",&x,&y);
    z=-x-y;
    printf("%d\n",-z);
}

process.stdin.resume(); 
process.stdin.on('data', function(chunk) {
  var lines = chunk.toString().split('\n');
  var lineSplit = lines[0].trim().split(' ');
  var n = parseInt(lineSplit[0]);
  var k = parseInt(lineSplit[1]);
  if( n > 100000){
    process.exit();
  }
  
  lineSplit = lines[1].trim().split(' ');
  lineSplit.sort();
  var count = 0;
  
  for(var i=0;i<n-1;i++){
    var num1 = parseInt(lineSplit[i]);
    for(var j=i+1;j<n;j++){
      var num2 = parseInt(lineSplit[j]);
      if(num1 + k === num2){
        count++;
        j = n;
      } else if (num1 + k < num2) {
        j = n;
      }
    }
  }

  process.stdout.write(count.toString() + "\n");
  
});

#include<bits/stdc++.h>
using namespace std;
#define lint long long
int main()
{
    int temp,index,x,num,l,t,r,it;
    scanf("%d",&it);
    while(it--)
    {
    int two[100]={1};
    scanf("%d%d",&num,&r);
    if(num==r) printf("0.00\n");
    else if(r==0){
    l=0;
    num=num-r+1;
    for(t=1;t<=num;t++)
    {
        temp=0;
        for(index=0;index<=l;index++)
        {
            x=(two[index]*2)+temp;
            two[index]=x%10;
            temp=x/10;
        }
        for(temp;temp!=0;temp=temp/10)
        {
            l++;
            two[l]=temp%10;
        }

    }
    for(t=l;t>=1;t--)
    {
        printf("%d",two[t]);
    }
         printf("%d.00\n",two[0]-2);

    }
    else
    {
      l=0;
    num=num;
    for(t=1;t<=num;t++)
    {
        temp=0;
        for(index=0;index<=l;index++)
        {
            x=(two[index]*2)+temp;
            two[index]=x%10;
            temp=x/10;
        }
        for(temp;temp!=0;temp=temp/10)
        {
            l++;
            two[l]=temp%10;
        }

    }
    for(t=l;t>=1;t--)
    {
        printf("%d",two[t]);
    }
         printf("%d.00\n",two[0]);

    }

    }
    }

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <algorithm>
using namespace std;

int main()
{
	//ifstream fin("pbuzz.in");
	int A;
	char B;
	vector<int> FRONT;
	vector<int> BACK;
	int counter = 1;
	cin >> A;
	FRONT.push_back(A);
	while(cin>>B>>A)
	{
		if(counter % 2 == 0)
			FRONT.push_back(A);
		else
			BACK.push_back(A);
		counter++;
	}

	//sort(FRONT.begin(), FRONT.end());
	//sort(BACK.rbegin(), BACK.rend());

	for(vector<int>::iterator it = FRONT.begin(); it!= FRONT.end(); it++)
	{
		cout << *it << ",";
	}

	for(int x = BACK.size()-1; x>=0; x--)
	{
		cout << BACK[x] << (x != 0 ? "," : "\n");
	}
}
#include <iostream>
#include <cstdio>
#include <string>
#include <algorithm>
#include <vector>
#include <sstream>

using namespace std;

int main(){
	int T;
	cin >> T;
	string emptyLine;
	getline(cin, emptyLine);
	while(T--){
		vector< vector<string> > info(5);
		for(int i = 0; i < 5; i++){
			string line;
			getline(cin, line);
			stringstream ss(line);
			string item;
			while (std::getline(ss, item, ' ')) {
				info[i].push_back(item);
			}
		}

		/*for(int i = 0; i < 5; i++){
			for(vector<string>::iterator it = info[i].begin(); it != info[i].end(); it++)
				cout << *it << "\t";
			cout << endl;
		}*/


		string seq = "ABCDE";
		bool found = false;
		do {
			bool next = false;
			for(int i = 0; i < 5 && !next; i++){
				char check = 'A'+i;
				int j = seq.find(check);
				for(vector<string>::iterator it = info[i].begin(); it != info[i].end() && !next; it++){
					if (isalpha((*it)[0])){
						if((*it)[0] == 'N'){
							if (isalpha((*it)[1])){
								if ((j<4 && seq[j+1] == (*it)[1]) || (j>0 && seq[j-1] == (*it)[1]))
								{
									next = true;
									continue;
								}
							}
							else{
								if (j == (*it)[1]-'1')
								{
									next = true;
									continue;
								}
							}
						}
						else{
							if ((j<4 && seq[j+1] != (*it)[0]) && (j>0 && seq[j-1] != (*it)[0]))
							{
								next = true;
								continue;
							}

						}
					}
					else if ((*it)[0] == '+'){
						int k;
						for (k = j+1; k < 5; k++)
							if (seq[k] == (*it)[1])
								break;
						if (k != 5)
						{
							next = true;
							continue;
						}
					}
					else if ((*it)[0] == '-'){
						int k;
						for (k = j-1; k >= 0; k--)
							if (seq[k] == (*it)[1])
								break;
						if (k != -1)
						{
							next = true;
							continue;
						}
					}
					else{
						if (j != (*it)[0] - '1')
						{
							next = true;
							continue;
						}
					}
				}
			}

			if (!next){
				found = true;
				break;
			}

		} while ( next_permutation(seq.begin(),seq.end()) && !found);

		cout << seq << endl;
	}

	return 0;
}

#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <vector>
#include <cassert>
using namespace std;
int _clock;

struct Chef
{
	int working;
	bool isWorking()
	{
		return working != 0;
	}
	void work()
	{
		assert(working);
		working++;
		if(working == 6) working = 0;
	}
}chef[5];
void pass()
{
	for (int i = 0; i < 5; ++i)
		if (chef[i].isWorking()) chef[i].work();
	_clock++;
}
int waittime;
struct Per
{
	int time;
	int order[5];
	int p;
	bool servered;
	bool isServered()
	{
		return servered;
	}
	Per(){p = 0; servered = false;}
	void finish()
	{
		order[cuisine()] -= 2;
		servered = false;
	}
	void wait()
	{
		waittime++;
	}
	int cuisine()
	{
		if (p == 5) return 5;
		while (order[p] == 0) p++;
		return p;
	}
	void deal()
	{
		servered = true;
	}
	bool operator < (const Per &e)const
	{
		return time < e.time;
	}
};
const int Maxn = 1000000;
Per que[Maxn];
int in, out;
vector<Per> vec;
int s, n;
void solve()
{
	in = 0, out = 0;
	//cout << vec[1].time <<" " << vec.size() << endl;
	for (_clock = 0; s < vec.size() || in > out; pass())
	{
		if (s < vec.size())
		{
			if (_clock == vec[s].time)
			{
				que[(in++) % Maxn] = vec[s];
				s++;
			}
		}
		while (in > out)
		{
			int cui = que[(out) % Maxn].cuisine();
			if (cui == 5) 
			{
				out++;
				continue;
			}
			if (que[out % Maxn].isServered() && chef[cui].isWorking() == false) 
			{
			//	cout << que[out].time <<" " << cui << endl;
				que[out % Maxn].finish();
				que[(in++) % Maxn] = que[(out++) % Maxn];
				chef[cui].working = 1;
			}
			else break;
		}
		if (in > out)
		{	
			Per& p = que[out % Maxn];
			int cui = p.cuisine();
			if (p.isServered() == false)
			{
				p.deal();
			//	cout<< _clock <<" " <<p.time << " " << p.p<<" " <<chef[cui].working<< endl;
			}
			else if (chef[cui].isWorking())
				p.wait();
		}
	}
}

int main()
{
	int T;
	scanf("%d", &T);
	while (T--)
	{
		waittime = 0;
		s = 0;
		scanf("%d", &n);
		vec.clear();
		for (int i = 0; i < n; ++i)
		{
			Per per;
			scanf("%d", &per.time);
			for (int j = 0; j < 5; ++j)
				scanf("%d", &per.order[j]);
			per.p = 0;
			vec.push_back(per);
		}
		sort(vec.begin(), vec.end());
		solve();
		printf("%d\n", waittime);
	}
	return 0;
}
import java.awt.geom.Line2D;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
 
public class Main {
static InputStream is;
static PrintWriter out;
static String INPUT = "";
static void solve()
{
outer:
for(int T = ni();T >= 1;T--){
long[][] co = new long[4][];
for(int i = 0;i < 4;i++){
co[i] = new long[]{ni(), ni()};
}
long ab = d2(co[0], co[1]);
long bc = d2(co[1], co[2]);
long cd = d2(co[2], co[3]);
long da = d2(co[3], co[0]);
for(int k = 0;k < 4;k++){
if(
(co[(k+1)%4][0]-co[k][0])*(co[(k+2)%4][1]-co[(k+1)%4][1])-
(co[(k+1)%4][1]-co[k][1])*(co[(k+2)%4][0]-co[(k+1)%4][0])
== 0){
out.println("NONE");
continue outer;
}
}
if(Line2D.linesIntersect(co[0][0], co[0][1], co[1][0], co[1][1], co[2][0], co[2][1], co[3][0], co[3][1])){
out.println("NONE");
continue outer;
}
if(Line2D.linesIntersect(co[1][0], co[1][1], co[2][0], co[2][1], co[3][0], co[3][1], co[0][0], co[0][1])){
out.println("NONE");
continue outer;
}
boolean rho = false;
boolean par = false;
if(ab > 0 && ab == bc && bc == cd && cd == da){
rho = true;
}
if(
ab > 0 && bc > 0 && cd > 0 && da > 0 &&
(co[3][0]-co[2][0])*(co[1][1]-co[0][1])-(co[3][1]-co[2][1])*(co[1][0]-co[0][0]) == 0 &&
(co[0][0]-co[3][0])*(co[2][1]-co[1][1])-(co[0][1]-co[3][1])*(co[2][0]-co[1][0]) == 0){
par = true;
}
int ct = 0;
for(int k = 0;k < 4;k++){
if(
(co[(k+1)%4][0]-co[(k)%4][0])*(co[(k+2)%4][0]-co[(k+1)%4][0])+
(co[(k+1)%4][1]-co[(k)%4][1])*(co[(k+2)%4][1]-co[(k+1)%4][1])
== 0)ct++;
}
if(ct == 4 && rho){
out.println("SQUARE");
}else if(ct == 4 && par){
out.println("RECTANGLE");
}else if(rho){
out.println("RHOMBUS");
}else if(par){
out.println("PARALLELOGRAM");
}else{
out.println("QUADRILATERAL");
}
}
}
public static long d2(long[] a, long[] b)
{
return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]);
}
public static void main(String[] args) throws Exception
{
long S = System.currentTimeMillis();
is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
out = new PrintWriter(System.out);
solve();
out.flush();
long G = System.currentTimeMillis();
tr(G-S+"ms");
}
private static boolean eof()
{
if(lenbuf == -1)return true;
int lptr = ptrbuf;
while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
try {
is.mark(1000);
while(true){
int b = is.read();
if(b == -1){
is.reset();
return true;
}else if(!isSpaceChar(b)){
is.reset();
return false;
}
}
} catch (IOException e) {
return true;
}
}
private static byte[] inbuf = new byte[1024];
static int lenbuf = 0, ptrbuf = 0;
private static int readByte()
{
if(lenbuf == -1)throw new InputMismatchException();
if(ptrbuf >= lenbuf){
ptrbuf = 0;
try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
if(lenbuf <= 0)return -1;
}
return inbuf[ptrbuf++];
}
private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
private static double nd() { return Double.parseDouble(ns()); }
private static char nc() { return (char)skip(); }
private static String ns()
{
int b = skip();
StringBuilder sb = new StringBuilder();
while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
sb.appendCodePoint(b);
b = readByte();
}
return sb.toString();
}
private static char[] ns(int n)
{
char[] buf = new char[n];
int b = skip(), p = 0;
while(p < n && !(isSpaceChar(b))){
buf[p++] = (char)b;
b = readByte();
}
return n == p ? buf : Arrays.copyOf(buf, p);
}
private static char[][] nm(int n, int m)
{
char[][] map = new char[n][];
for(int i = 0;i < n;i++)map[i] = ns(m);
return map;
}
private static int[] na(int n)
{
int[] a = new int[n];
for(int i = 0;i < n;i++)a[i] = ni();
return a;
}
private static int ni()
{
int num = 0, b;
boolean minus = false;
while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
if(b == '-'){
minus = true;
b = readByte();
}
while(true){
if(b >= '0' && b <= '9'){
num = num * 10 + (b - '0');
}else{
return minus ? -num : num;
}
b = readByte();
}
}
private static long nl()
{
long num = 0;
int b;
boolean minus = false;
while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
if(b == '-'){
minus = true;
b = readByte();
}
while(true){
if(b >= '0' && b <= '9'){
num = num * 10 + (b - '0');
}else{
return minus ? -num : num;
}
b = readByte();
}
}
private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}
#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
big checkprime(big n)
{
    big i,count=0;
    FOR(i,2,n-1)
        if(n%i==0)
        {
            count=1;
            break;
        }
    if(count==1 || n==1)return 0;
    return 1;
}
int main() {
	big l,t,n,i,j,k,r,temp,m,x,y,z,a,b,c,sig,sum=0;
	vb v;
	big count=0;
	string s;
	cin>>t;
	
	FOR(k,1,t)
	{
	    count=0;
	    cin>>l>>r;
	 FOR(i,l,r)
	 {
	    
	    m=i;
	    sum=0;
	    while(m>0)
	    {
	        sum+=m%10;
	        m/=10;
	    }
	    //cout<<"sum,num are "<<sum<<" "<<i<<endl;
	    if(checkprime(sum)==1) count++;
	 }
	    cout<<count<<endl;
	}
    
	return 0;
}
for x in range(0,input()):
 k,q = input(),map(int,raw_input().split())
 n = (2*sum(q) -k*k -k)/(2.0*k)+1
 if(n == int(n)):  print sum(([abs(a - b) for a, b in zip(q, range( int(n), int(n)+k))]))/2
 else: print - 1
//some variables
var four_letter_words = ["doup","frig","ours","skep","smar","spad","rale","plat","viol","esox","culb","amok","oont","coif","coir","aver","keen","vuln","tsar","apse","onyx","peen"];
var seven_letter_words = ["abalone","abandon","ability","abolish","abdomen","abraham","abyssal","academy","account","achieve","acidity","acquire","acrobat","acronym","acrylic","actress","adaptor","address","already","adjourn","admiral","advance","advisor","aerator","aerosol","affable","afflict","affront","african","backlit","backlog","backrub","badland","baggage","bailout","balance","ballboy","balloon","baloney","bananas","bandage","bandaid"];
var five_letter_words = ["pople","carom","ergot","aglet","cubeb","nerpa","taler","qitra","decoy","swain","oxter","panic"];

var i, j, k;
var crypto = require('crypto');
var possibility, hash;

for (i=0; i<four_letter_words.length; i++) {
	for (j=0; j<seven_letter_words.length; j++) {
		for (k=0; k<five_letter_words.length; k++) {
			possibility = "The world is " + four_letter_words[i] + " " + seven_letter_words[j] + " this email was a " + five_letter_words[k];
			hash = crypto.createHash('md5').update(possibility).digest("hex");
			if (hash == "0c049ca2ad590d34d1753419f64eff19") {
				console.log(possibility);
				break;
			}
		}
	}
} 

import sys
def numberToBase(n, b):
    temp=''
    while n:
        temp+=str(n % b)
        n /= b
    return temp
a=map(int,sys.stdin.readline().split())
i=0
while a[i]!=-1:
    s=numberToBase(a[i],7)
    s=s[::-1]
    sys.stdout.write(s+" ")
    i+=1

fib=[]

i1,i2,i3=map(int, raw_input().split())
y=i3

p=i1
fib.append(p)
r=i2
fib.append(r)

while(y):
    n=p+r
    fib.append(n)
    p=r
    r=n
    y-=1

print fib.pop((i3-1))

t=input()
t=t*2
s=""
s1=""
st=[]
for i in range(0,t):
    s=s+"*"
for i in range(0,t):
	s1=s1+"-"
st.append(s)
temp="-"
for i in range(2,t,2):
    temp2=temp+s[:t-i]+temp
    st.append(temp2)
    temp=temp+"-"
for i in range(t/2-1,0,-1):
	temp2=s1[:i]+"*"+s1[i:t-i-2]+"*"+s1[t-i:]
	st.append(temp2)
for each in st:
	print each
print st[0]
import sys
def josephus(n,k):
    if n==1:
        return 1
    else:
        return (josephus(n-1,k)+k-1)%n+1
n,k=map(int,sys.stdin.readline().split())
sys.stdout.write("%d"%josephus(n,k))

def div(n):
    s=set()
    for i in range(1,int(n**0.5)+1):
        if n%i==0:
            s.add(i)
            s.add(n/i)
    return sum(s)-n
    
q=int(raw_input())
for i in range(q):
    n=int(raw_input())
    print div(n)
import sys

def solve(GP,vis,V,cur,flag,parent) :
    vis[cur] = 1
    for i in GP[cur] :
        if (parent[cur]!=i) and V==i :
            return False
        if not vis[i] :
            parent[i] = cur
            return solve(GP,vis,V,i,1,parent)
    return True
    

n , m = map(int,sys.stdin.readline().split())
GP  = [[] for __ in range(n+1)]
for i in range(m) :
    a , b = map(int,sys.stdin.readline().split())
    GP[a].append(b)
    GP[b].append(a)

ans , vis = True , [0 for __ in range(n+1)]
for i in range(1,n+1) :
        if not vis[i] :
            vis[i] = 1
            ans = solve(GP,vis,i,i,0,[0 for __ in range(n+1)])
            if ans == False :
                break

print "YES" if ans else "NO"
import bisect 
def find_lt(a,x):
    #find rightmost value less than or equal to x
    i=bisect.bisect_right(a,x)
    if i:
        return i-1 
    else:
        return -1
def find_ge(a,x):
    #find leftmost item greator than or equal to x
    i=bisect.bisect_left(a,x)
    if i!=len(a):
        return i
    else:
        return -1
fibo=[];
fibo.append(1);
fibo.append(1);
for i in xrange(500):
    fibo.append(fibo[-2]+fibo[-1]);
    #print fibo[len(fibo)-1];
    #print len(str(fibo[len(fibo)-1]));
while True:
    try:
        a,b=map(int,raw_input().split());
        if a==0 and b==0:
           break; 
        left=find_ge(fibo,a);
        right=find_lt(fibo,b);
        #print left,right
        #print fibo[left],fibo[right]
        if left==-1 or right==-1:
            print 0;
        else:
            print right-left+1
    except:
        break;
 

def pd33():
	while True:
		n=int(raw_input())
		if not n: break
		s=raw_input()
		if n>0:
			m=len(s)/n
			for i in range(n):
				k=0
				for j in range(m):
					if j%2!=0:
						k=2*abs((n-1)/2.0-i)
					else:
						k=0
					if i>=n/2:
						k=-k
					sys.stdout.write(s[int(i+n*j+k)])
			print
		
		


if __name__=="__main__":
	import sys
	pd33()
t=int(raw_input())
for i in range(0,t):
    h,m=map(int, raw_input().split(":"))
    ans = abs(30*h - 5.5*m)
    p=min(360-ans,ans)
    if(p%5==0):
        print "YES"
    else:
        print "NO"
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int main()
{
int k,t;
int ans[10][5];
for(int i = 0; i <= 9; i++){
ans[i][0] = i;
for(int j = 1; j <= 3; j++){
ans[i][j] = ans[i][j-1] * i;
ans[i][j] %= 10;
}
}
   long long int p;
   char s[25];
   scanf("%d",&t);
   while(t--)
   {
     scanf("%s %lld",&s,&p);
     k=s[strlen(s)-1]-'0';
     if(p==0){printf("1\n");continue;}
     p--;
     printf("%d\n",ans[k][p%4]);
   }
   return 0;
}


t= long(raw_input());

while ( t ):
	n = long(raw_input());
	
	a= map(long, raw_input().split());
	
	b=sum(a);
	
	if ( b%2 ):
		print "Sam";
	else:
		print "Zuck";

	t-=1;

for x in range(input()):
    ndays = input()
    nsize = map(int,raw_input().split())
    last = nsize[0]
    incr = 0
    for i in nsize:
        if i == 0:
            continue
        if i>last:
            incr+=1
            last = i
    print incr 
   
            
        
        
from collections import Counter
for x in range(input()):
    ndays = input()
    nsize = map(int,raw_input().split())
    print max(Counter(nsize).values())-1
#include <bits/stdc++.h>
using namespace std;
long long fact[1000005];
int T,N;
int main()
{
	for(int i=1; i<=1000000; i++)fact[i]=1;
	for(int i=2; i<=1000000; i++)
	{
		fact[i]++;
		for(int j=i+i; j<=1000000; j+=i)fact[j]++;
	}
	
	for(int i=2; i<=1000000; i++)fact[i]=fact[i-1]+fact[i];
	cin>>T;
	while(T--)
	{
		scanf("%d",&N);
		cout<<(fact[N]*2)<<"\n";
	}
	return 0;
}
def pali(st):
    i=0
    n=len(st)
    while(i<n/2):
        if(st[i]!=st[n-1-i]):
            break
        i+=1
    if(i==n/2):
        return 1
    else:
        return 0

def pang(st):
    li=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    lii=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    i=0
    n=len(st)
    while(i<n):
        lii[li.index(st[i])]+=1
        i+=1
    i=0
    while(i<26):
        if(lii[i]==0):
            break
        i+=1
    if(i==26):
        return 1
    else:
        return 0

t=int(raw_input())
while(t>0):
    s=raw_input()
    if(pali(s)==1):
        if(pang(s)==1):
            print("palingram")
        else:
            print("palindrome")
    elif(pang(s)==1):
        print("pangram")
    else:
        print("none")
    t=t-1

t=input()
while(t):
    t=t-1
    n=input()
    x=raw_input()
    c=0
    for i in range(0,len(x)-n):
        s=x[i:i+n]
        if(s==s[::-1]):
            c=c+1
    print c
        

def LIS(A):
	DP = [0]*len(A)
	DP[0] = 1
	for x in range(1,len(A)): DP[x] = max([DP[y] + 1 if A[y] <= A[x] else 1 for y in range(x)])
	return max(DP)
raw_input()

 
# binary search
# search for *max* j in lo..hi, s.t., s[m[j]] < s[i]
def binary_search(s, i, m, p, lo, hi):
        
        if s[m[hi]] <= s[i]:
                return hi
 
        if lo > hi:
                return 0 # not found
 
        mid = lo + (hi - lo)/2
        if s[m[mid]] < s[i]:
                return binary_search(s, i, m, p, mid, hi - 1)
        else:
                return binary_search(s, i, m, p, lo, mid - 1)
 
 
def search(s, i, m, p, L):
        return binary_search(s, i, m, p, 1, L)
 
 

def lis(s):
        n = len(s)
 
        # for an increasing sequence of length j,
        # m[j] = k is the position of the smallest value s[k]
        # that is end of the sequence of length j.
        # so s[m[1]], s[m[2]], ... s[m[L]] is the longest sequence.
        m = [-1]*(n + 1)
 
        # p[i] is the position of the predecessor of s[i] in an increasing sequence.
        # need to use p[i] in binary search
        p = [0]*n
 
        # current max length
        L = 0
 
        for i, si in enumerate(s):
                # search for maximum j, s.t., s[m[j]] < s[i]
                # i.e., j is the max length of an i.s that has end value less than s[i]
                j = search(s, i, m, p, L)
 
                # parrent of i
                p[i] = m[j]
 
                if j == L or s[m[j + 1]] > s[i]:
                        # update the end of sequence of length j + 1 to be i
                        # it can happen when j == L, i.e., x[i] extends the current longest i.s
                        # OR, x[i] is a new end of an existing i.s. of length j + 1
                        m[j + 1] = i
 
                        L = max(L, j + 1)
 
    
        return L
 
print lis([int(x) for x in raw_input().split()])

#include <stdio.h>

int main(void) {
	int p,n,t;
	scanf("%d",&t);
	while(t--)
	{
		char a[5];
		int odd[504],even[503],i,j=0,k=0;
		scanf("%d%s%d",&n,a,&p);
		for(i=1;i<=n;i++)
		{
			if(i%2==0)
			 even[j++]=i;
			else
			 odd[k++]=i;
		}
		if(a[0]=='o')
		 printf("%d\n",even[p-1]);
		else
		 printf("%d\n",odd[p-1]);
	}
	return 0;
}

arr=[1]
for i in xrange(1,100001):
    arr.append(((arr[i-1]%1589540031)*(i%1589540031))%1589540031)
t=int(raw_input())
for i in xrange(t):
    n=int(raw_input())
    print arr[n]

# your code goes here
from sys import stdin, stdout
t = int(stdin.readline())
while t:
	t -= 1
	n = int(stdin.readline())
	d = []
	for _ in xrange(n):
		a, p = map(int, stdin.readline().strip().split(' '))
		d.append([p,a])
		if n>1 and p == 0:
			d.pop()
			n -= 1
	ans = ""
	for i in range(len(d)):
		if i < n-1:
			if d[i][0] == 1:
				ans += str(d[i][1]*(d[i][0]))
			else:
				ans += str(d[i][1]*(d[i][0])) + "x^" + str(d[i][0]-1)
			ans += " + "
		else:
			if d[i][0] == 0 and n == 1:
				ans = "0"
			elif d[i][0] == 1:
				ans += str(d[i][1]*(d[i][0]))
			else:
				ans += str(d[i][1]*(d[i][0])) + "x^" + str(d[i][0]-1)
	stdout.write(ans + '\n')
	
for i in xrange(int(raw_input())):
        x=int(raw_input())
        if x%2<>0 and x<>1:
            print 'No'
        else:
            if x<>0:
                print 'Yes'
            else:
                print 'No'
        

import java.math.BigInteger;
import java.util.Scanner;

/**
 * Created by Jess on 4/16/2015.
 */
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int tcs;
        BigInteger base, mod, power;
        tcs = sc.nextInt();
        for (int i = 0; i < tcs; i++) {
            base = sc.nextBigInteger();;
            power = sc.nextBigInteger();
            mod = sc.nextBigInteger();
            base = base.modPow(power, mod);
            System.out.println(base);


        }
    }
}


#include<stdio.h>
#include<string.h>
#include<math.h>
int main()
{
 int t;
 long long i,j,num,n,k,tmp,rem,ans;
 scanf("%d",&t);
 while(t--){
  scanf("%lld",&num);
  tmp = 0, n = 0;
  while(tmp < num){
   n =n+1;
   tmp = pow(2,n+1) - 2;
  }
  tmp = pow(2,n)-2;
  ans = num - tmp -1;
  char str[100000];
  k = -1;
  while(ans>0){
   rem = ans%2;
   k = k+1;
   str[k] = rem + '0';
   ans = ans/2;
   }
   j = n-k-1;
   for(i =1; i<= j; i++)
    printf("5");
   for(i =k; i>=0; i--)
   {
    if(str[i] == '0')
      printf("5");
    else 
      printf("6");
   }
   printf("\n");
  }
  return 0;
 }
#include<stdio.h>
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
    int a1[10][10],a2[10][10],a[10][10],i,j,k,r,sum=0;
    scanf("%d",&r);
	for(i=0;i<r;i++)
	{
	for(j=0;j<r;j++)
	{
	scanf("%d",&a1[i][j]);
    }
    }
	for(i=0;i<r;i++)
	{
	for(j=0;j<r;j++)
	{
    scanf("%d",&a2[i][j]);
    }
    }
	for(i=0;i<r;i++)
	{
	for(j=0;j<r;j++)
	{
	for(k=0;k<r;k++)
	{
	sum=sum+a1[i][k]*a2[k][j];
	}
	a[i][j]=sum;
       sum=0;
    }
    }
	for(i=0;i<r;i++)
	{
	for(j=0;j<r;j++)
	{
	printf("%d ",a[i][j]);
	}
	printf("\n");
    }
    }
return 0;
}
//PPOW, Setter's solution
#include<iostream>
int powers[13][4006]={0};
int main()
{
	int a,n,i,j,k=0,r,b,o,sum,t;
	//FILE *f1=freopen("in2.txt","r",stdin);
	//FILE *f2=freopen("out2.txt","w",stdout);
	r=0;
	//po[0]=1;
	for(o=2;o<=9;o++)
	{
		k=0;
		r=0;
		int po[4004]={0};
		po[0]=1;
		
	  for(i=1;i<=4000;i++)
	  {
		for(j=0;j<=k;j++)
		{
		 po[j]=po[j]*o+r;
		 r=po[j]/10;
		 po[j]=po[j]%10;
		 //sum=0;
		 
		 if(r!=0&&j==k)
		 k++;
		}
		sum=0;
		for(int l=0;l<=k;l++)
	     sum+=po[l];
	     powers[o][i]=sum;
		
	  }
	 // printf("k=%d\n",k);
    }
    for(i=0;i<=4000;i++)
    powers[1][i]=1;
    for(i=1;i<=9;i++)
    powers[i][0]=1;
	
//	printf("computed\n");
	scanf("%d",&t);
	for(i=1;i<=t;i++)
	{
		scanf("%d%d",&a,&b);
		printf("Case %d: %d\n",i,powers[a][b]);
	}	
//	fclose(f1);
//	fclose(f2);
	return 0;
} 
for _ in xrange(input()):
    a,b,c=map(float,raw_input().split())
    t=(a+b+c)*(a+b-c)*(a+c-b)*(b+c-a)
    t=a*b*c/(t**0.5)
    print t

t=input("")
while t:
  t=t-1
  a=input("")
  if(a==2):
    print "YES"  
  elif(a%4==1):
    print "YES"
  else:
    print "NO"

T = input()
for _ in range(T):
	input()
	m = map(int, raw_input().split())
	print str(m[1:])[1:-1].replace(',',''), m[0]
n = int(raw_input())

if n % 2 ==0:
    print "YES"
else:
    print "NO"
#include <cstring>
#include <iostream>
#include <stdio.h>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#include <map>
#include <vector>
#include <list>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bits/stdc++.h>
#include <string>
#include <cmath>
using namespace std;

#define pb push_back
#define mp make_pair
#define mod 1000000007
#define ll long long
#define ff first
#define ss second
#define inf  1e9
#define infll 1e18
#define pr(x) printf("%d\n",x)
#define prs(x) printf("%d ",x)
#define sc(x) scanf("%d",&x)
#define trc(x) cout << #x << " = " << x << endl
#define fr(i,a,n) for(i=a;i<n;i++)
#define fd(i,a,n) for(i=n;i>a;i--)
#define fiv(v) for(i=0;i<v.size();i++)
#define fill(a,v) memset(a,v,sizeof(a))
#define all(a) a.begin(),a.end()
#define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++)

typedef pair<int,int> pi;
typedef vector<int> vi;

char s[101];
int dp[102][2][102],n;
int sol(char s[],int i,int last,int con,int p,int q)
{
    if(i==n)return 0;
    int &res=dp[i][last][con];
    if(res!=-1)return res;
    res=0;
    if(last==0)
    {
        if(con<p)
        res=max(res,(s[i]=='W')+sol(s,i+1,0,con+1,p,q));
        res=max(res,(s[i]!='W')+sol(s,i+1,1,1,p,q));
    }
    else
    {
        if(con<q)
        res=max(res,(s[i]!='W')+sol(s,i+1,1,con+1,p,q));
        res=max(res,(s[i]=='W')+sol(s,i+1,0,1,p,q));
    }
    return res;
}
int main()
{
    int i,j,k,l,m,t,c=0,ans;
    #ifndef ONLINE_JUDGE
   // freopen("in.txt","r",stdin);
    #endif
    sc(t);

    while(t--)
    {
      int p,q;
      sc(p);sc(q);
      scanf("%s",s);
      fill(dp,-1);
      n=strlen(s);
      j=sol(s,0,0,0,p,q);
      pr(j);
    }
    return 0;
}

from math import sqrt
t=input()
while t!=0:
        n=input()
        c=0
        for i in range(2,int(sqrt(n))+1):
                if n%i==0:
                        if str(i).find('5')!=-1 or str(i).find('3')!=-1 or str(i).find('6')!=-1:
                                c+=1
                        #       print i
                        if str(n/i).find('5')!=-1 or str(n/i).find('3')!=-1 or str(n/i).find('6')!=-1:
                                c+=1
                        #       print n/i
 
 
        if str(n).find('3')!=-1 or str(n).find('5')!=-1 or str(n).find('6')!=-1:
                c+=1
        print c
        t-=1
#include <bits/stdc++.h>
using namespace std;

vector<int> vec;

#define INPUT(_x) int _x;cin>>_x;
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define TCASE int _t;cin>>_t;FOR(i,1,_t)
#define VECTORFILL(_vec) int _x;cin>>_x;while(_x!=-1){_vec.push_back(_x);cin>>_x;}
#define VECTOR_FILL(_vec,size) int _x;FOR(i,1,size){cin>>_x; _vec.push_back(_x);}
#define VECTORPRINT(_vec) int _t=-1;while((++_t)<_vec.size()){cout<<_vec[_t]<<" ";}

long long int factorial(int x){
    if(x==1) return 1;
    else return x*factorial(x-1);
}

int main()
{
    TCASE{
       int t; cin>>t;
       long long int ans=0;
       if(t==1) ans=0;
       else
           FOR(i,2,t){
                int sign=pow(-1,i);
                ans+= sign*factorial(t)/factorial(i);    
           }
        
        cout<<ans<<endl;
           
    }
    
    return 0;
}
def ps(n):
    r = int(n**0.5)
    assert r*r <= n and (r+1)**2 > n
    V = [n//i for i in range(1,r+1)]
    V += list(range(V[-1]-1,0,-1))
    S = {i:i*(i+1)//2-1 for i in V}
    for p in range(2,r+1):
        if S[p] > S[p-1]:  # p is prime
            sp = S[p-1]  # sum of primes smaller than p
            p2 = p*p
            for v in V:
                if v < p2: break
                S[v] -= p*(S[v//p] - sp)
    return S[n]# your code goes here

print ps(int(raw_input()))
from random import randint
def fun(N):
	if N>1 :
		for _ in xrange(5):
			Num=randint(1,N-1)
			if pow(Num,N-1,N)!=1:
				return False
		return True
	return False
for _ in xrange(input()):
	if(fun(input())):
		print "PRIME"
	else:
		print "COMPOSITE"

def millerRabin(n):
	# Returns true if probable prime, false if composite
	bases     = [2,3,5,7,11,13,17,19,23]
	nm1       = n-1
	m         = nm1
	d         = 0

	if n in bases:
		return True
	if n < 2:
		return False

	while not m&1:
		d    += 1
		m   >>= 1

	for a in bases:
		done_for_base = False

		b   = pow(a,m,n)
		if b == 1 or b == nm1 :
			#done_for_base = True
			continue
		for k in range(d-1):
			b = pow(b,2,n)
			if b == 1:
				return False
			elif b == nm1:
				done_for_base = True
				break
		if not done_for_base:
			return False
	return True

def valAt(x,y):
	if x>y:
		if x+y > 0:
			n  = 4*x*x - 3*x + y
		else :
			n  = 4*y*y - 3*y + x
	else:
		if x+y > 0:
			n  = 4*y*y -  x - y
		else :
			n  = 4*x*x -  y - x
	return n

def solveCase(x,y):
	r    = 0
	n    = valAt(x,y)
	if millerRabin(n):
		return r
	while True:
		r  += 1
		for k in range(r):
			n1  = valAt(x + r-k, y + 0-k)
			n2  = valAt(x + 0-k, y - r+k)
			n3  = valAt(x - r+k, y + 0+k)
			n4  = valAt(x + 0+k, y + r-k)
			for n in [n1,n2,n3,n4]:
				if millerRabin(n):
					return r

def main():
	T  = int(raw_input(''))
	for t in range(T):
		x,y = [ int(i) for i in raw_input().split() ]
		ans = solveCase(x,y)
		print ans


main()

while 1:
	N,M=map(int,raw_input().split());
	if N==0 and M==0:
		break
	else:
		A,B=N,M; CR=0; ct=0;
		while A or B:
			q,r=A%10,B%10;
			if q+r+CR>9:
				ct+=1;	CR=1;
			A/=10;	B/=10;
		if ct==0:
			print "No carry operation."
		elif ct==1:
			print "1 carry operation."
		else:
			print "%d carry operations." %ct
			 

#include <stdio.h>
int main(){
    int n,a[200],index,temp,i,t,j;
    int prime[27]={1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
    scanf("%d",&t);
    while(t--){
        a[0]=1;
        index=0;
        scanf("%d",&n);
        for(j=0;(prime[j]<=n)&&(j<26);j++){
            temp=0;
            for(i=0;i<=index;i++){
                temp=(a[i]*prime[j])+temp;
                a[i]=temp%10;
                temp=temp/10;
            }
            while(temp>0){
                a[++index]=temp%10;
                temp=temp/10;
            }
        }
        for(i=index;i>=0;i--)
            printf("%d",a[i]);
        printf("\n");
    }
    return(0);
}
a=input()
for i in range(a):
	b=raw_input()
	string=""
	for j in b:
		k=ord(j)
		if(48<=k<=57):
			string+=chr(k+57)
		elif(97<=k<=104):
			string+=chr(k+18)
		elif(105<=k<=114):
			string+=chr(k-57)
		elif(115<=k<=122):
			string+=chr(k-18)
		else:
			string+=j
	print string

tc = int(raw_input())
while (tc>0):
	tc = tc - 1
	a, b, c = map(int, raw_input().split())
	print a*720/(b+c)

def isNumberPrime(n):
    if n == 2: return True
    if n % 2 == 0 or n == 1: return False
    for num in xrange(3, int(n**0.5) + 2, 2):
        if n % num == 0:
            return False
    return True

def isPalindrome(n):
    s = str(n)
    return s==s[::-1]

def prpalin():
    """1 <= N <= 1000000"""
    N = int(raw_input())
    while not (isPalindrome(N) and isNumberPrime(N)):
        N += 1
    print N   

if __name__ == "__main__":
    prpalin()
#include<bits/stdc++.h>
#define LL long long
using namespace std;
pair<LL,LL>pa[30010];
int bs(LL x, int n)
{
    int start=0, end=n-1, mid= (start+end)>>1;
    while(end-start>=2)
    {
        if(pa[mid].first<=x)
        {
            start=mid;
        }
        else end=mid-1; 
        mid= (start+end)>>1;
    }
    while(1)
    {
        if(pa[end].first<x) return end; end--;
    }

}
main()
{
    int t,i,j,N;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&N);
        for(i=0;i<N;i++)
        {
            scanf("%lld",&pa[i].second);  //starting   
            scanf("%lld",&pa[i].first); // finishing time
        }
        pa[N].first= pa[N].second= - 1000000000000LL; // append it at the beginning so that the if a number less than x is not found it returns 0
        N++;
        sort(pa,pa+N);
        
        // now calculate P[j];
        LL dp[N+10];
        int P[N+10];
        P[0]=0;
        for(j=1;j<N;j++)
        {
            P[j]= bs(pa[j].second,j);
        }
        dp[0]=0;
        for(i=1;i<N;i++)
        {
            dp[i]= max(dp[i-1], dp[P[i]]+ pa[i].first- pa[i].second+1);
        }
        printf("%lld\n",dp[N-1]);
    }
   return 0;
}
#chiragjn
t=int(raw_input())
for i in xrange(t):
	n,m=map(int,raw_input().split())
	print m+(n>>1) if m<=n/2 else m-(n>>1)
for _ in range(input()):
	s=raw_input().split()
	c=0
	for i in range(len(s)):
		if s[i][0]==s[i][4] and s[i][1]==s[i][3]:
			c+=1
		elif s[i][0]==s[i][1]and s[i][3]==s[i][4]:
			c+=1
		elif s[i][0]==s[i][3] and s[i][1]==s[i][4]:
			c+=1
	print c		
n=int(input())
l=[]
for i in range(0,n):
 x=raw_input()
 val=0
 for char in x:
  val=val+ord(char)-64
 l.append(val)
for i in l:
 print i
lis=[i for i in range(2,100002,2)]
lis1=[]
for i in xrange(len(lis)):
    lis1.append(lis[i])
s=lis1[0]

for i in range(1,len(lis1)):
    lis1[i]+=s
    s=lis1[i]
#print lis1    
for _ in xrange(int(raw_input())):
    n=int(raw_input())
    for i in xrange(len(lis1)):
        if n<=lis1[i]:
            val=i
            break
    #print i
    if n<=lis1[i]-(i+1):
        print lis[i]-1
    else:
        print lis[i]
#!/usr/bin/env python
MAXN = 26

parent = [0] * MAXN
rank   = [0] * MAXN

def UF_MakeSet():
    for x in xrange(MAXN):
        parent[x] = x
        rank[x]   = 0

def UF_Union(x, y):
    xRoot = UF_Find(x)
    yRoot = UF_Find(y)
    if   xRoot == yRoot:
         return
    if   rank[xRoot] < rank[yRoot]:
         parent[xRoot] = yRoot
    elif rank[xRoot] > rank[yRoot]:
         parent[yRoot] = xRoot
    else:
         parent[yRoot] = xRoot
         rank[xRoot]  += 1

def UF_Find(x):
    if parent[x] != x:
       parent[x] = UF_Find(parent[x])
    return parent[x]

def isABconnected(G, e):
    UF_MakeSet()
    for i in xrange(len(G)):
        if i == e: continue
        x = ord(G[i][0])-ord('A')
        y = ord(G[i][1])-ord('A')
        UF_Union(x, y)
    return UF_Find(0) == UF_Find(1)

def main():
    G = []
    while True:
        R = raw_input().strip()
        if R == 'END': break
        G += [R]
    N = 0
    for i in xrange(len(G)):
        if not isABconnected(G, i):
           print G[i]
           N += 1
    if not N:
       print 'Too Bad, We Lose'

main()



n = input()
q = raw_input()

o = ['']*n
c = 0
for i in xrange(n):
	q1 = int(q[n-1-i], 16)%4
	q2 = int(q[n-1-i], 16)/4 # 00-00 11-11 10-01 10-01 : 0-0 3-3 1-2 2-1
	a = (q1+q2+c) % 4
	c = (q1+q2+c) / 4
	o[n-1-i] = '{:02b}'.format(a)

print ''.join(o)

import math
t=input()
while t>0:
	t-=1
	time=raw_input()
	hrs=int(time[0:2])

	mint=int(time[2:4])
	#print hrs,"  ",mint
	p=input()
	mi=p/60
	sec=p%60
	
	hs=0
	if mi>=60:
		hs+=(mi/60)
		mi%=60

	
		

	hrs=(hrs+hs)%24
	mint=(mint+mi)
	if mint>=60:
		hrs+=1
		hrs%=24
		mint%=60
	
	if(sec >0):

		if(not(hrs==23 and mint==59)):
			mint+=1
			if(mint>=60):
				hrs+=1
				hrs%=24
				mint%=60
			
		
	
	
	
	
	
	h=""
	s=""
	if hrs<10:
		h="0"+str(hrs)
	else:
		h=str(hrs)
	if mint<10:
		s="0"+str(mint)
	else:
		s=str(mint)
	print h+s	



tt = int(raw_input())

def printMaxActivities(s, f, n):
    
    f, s = zip(*sorted(zip(f, s)))
    #print f, s, f[0], s[1]
    i = 0
    ans = 1
    for j in xrange(n):
 
        # If this activity has start time greater than
        # or equal to the finish time of previously 
        # selected activity, then select it
        if s[j] > f[i]:
                #sol1.append(j)
            #print 'adsf'
            ans += 1
            i = j

    #print sol1            
    return ans

sol = []
for i in xrange(tt):
    b = int(raw_input())
    start = []
    finish = []
    for j in xrange(b):
    	a = map(int, raw_input().split())
    	start.append(a[0])
    	finish.append(a[1])

    #print start, finish
    sol.append(printMaxActivities(start, finish, b))

for i in xrange(tt):
    print sol[i]

lis=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
a=raw_input().strip()
leng=len(a)
count=0
if(leng%2==1):
	count+=1
flag=1
for i in lis:
	k=a.count(i)
	if(k%2==1):
		if(count>0):
			count-=1
		else:
			flag=0
			break
if(flag==1):
	print "YES"
else:
	print "NO"

#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
using namespace std;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar_unlocked();
    }
    return x;
}
const int N = 100001;
const int SQN = 350;
int freq[SQN][N]={0};
long long val[SQN]={0};
int start[SQN];
int finish[SQN];
int n,sqn,m;
int timer=0;
int treestart[N];
int treeend[N];
int rev[N];
list<int> v[N];
int level[N]={0};
int lookup[N];
long long sum[N]={0};
void dfs(int node,int parent){
    level[node]=level[parent]+1;
    treestart[node]=++timer;
    rev[timer]=node;
    for(list<int>::iterator it = v[node].begin();it!=v[node].end();++it){
        if(*it!=parent)
            dfs(*it,node);
    }
    treeend[node]=timer;
}
int main(){
    n=scan(),m=scan();
    for(int i=1;i<n;++i){
        int a=scan(),b=scan();
        v[a].pb(b);
        v[b].pb(a);
    }
    dfs(1,0);
    int sqn = sqrt(n);
    int cur=1;
    for(int i=1;i<=n;){
        int j=i;
        start[cur]=i;
        while(j<i+sqn&&j<=n){
            freq[cur][level[rev[j]]]++;
            j++;
            lookup[j-1]=cur;
        }
        i=j;
        finish[cur]=j-1;
        ++cur;
    }
    while(m--){
        int type=scan();
        if(type==1){
            int levl = scan();
            long long vall = scan();
            for(int i=1;i<cur;++i){
                val[i]+=1LL*freq[i][levl+1]*vall;
            }
            sum[levl+1]+=vall;
        }
        else{
            int node = scan();
            int x=lookup[treestart[node]];
            int y=lookup[treeend[node]];
            long long res=0;
            for(int i=x;i<=y;++i){
                if(start[i]>=treestart[node]&&finish[i]<=treeend[node]){
                    res+=val[i];
                }
                else if(start[i]<treestart[node]){
                    for(int j=treestart[node];j<=min(treeend[node],finish[i]);++j){
                        res+=sum[level[rev[j]]];
                    }
                }
                else{
                    for(int j= max(start[i],treestart[node]);j<=treeend[node];++j){
                        res+=sum[level[rev[j]]];
                    }
                }
            }
            printf("%lld\n",res);
        }
    }
}
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string s;
    getline(cin,s);
    char r;
    cin>>r;
    int c=0;
    for(int i=0;i<s.size();i++)
        if(s[i]==r)
        c++;
        cout<<c<<endl;
        return 0;
}

import java.io.*;
public class Main
{
  public static void main(String args[])throws IOException
  {
      BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
      int t,n,k,i,j;
      //t=Integer.parseInt(in.readLine());
      //while(t>=1)
      //{
          n=Integer.parseInt(in.readLine());
          k=n-1;
          for(i=1;i<=n;i++)
          {
              for(j=1;j<=k;j++)
               System.out.print(" ");
              for(j=i;j>=1;j--)
               System.out.print(j);
              for(j=2;j<=i;j++)
               System.out.print(j);
              System.out.println();
              k--;
          }
          k=1;
          for(i=(n-1);i>=1;i--)
          {
              for(j=1;j<=k;j++)
               System.out.print(" ");
              for(j=i;j>=1;j--)
               System.out.print(j);
              for(j=2;j<=i;j++)
               System.out.print(j);
              System.out.println();
              k++;
          }
        //  t--;
      //}
  }
}
#include<bits/stdc++.h>
using namespace std;
#define LL      long long
#define LD      long double
#define PB		push_back
#define LOOP(i,n)  for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define mod		1000000007
int main()
{
	int n;
	cin>>n;
	printf("%f",cos(n*3.14/180.0));
	return 0;
}

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include<math.h>
int cnt=0;
void m(int q,int w,int a,int b){
    if(q<0 || w<0)
        return;
    if(q==a && w==b){
        cnt++;
        return;
    }
    if(q>a||w>b)
        return;
    m(q+1,w,a,b);
    m(q,w+1,a,b);
}
int main(){
    int t;
    scanf("%d",&t);
    while (t>0) {
        int a,b;
        scanf("%d %d",&a,&b);
        m(0,0,a,b);
        t--;
        printf("%d\n",cnt);
        cnt=0;
    }
}
#include<stdio.h>
int main()
{
int t=10,n,m=0,arr[11][21],i,j,a[10];
for(t=0;t<10;t++)
{
scanf("%d",&a[t]);
if(a[t]>m)
m=a[t];
}
for(i=0;i<10;i++)
{
for(j=0;j<m-a[i];j++)
arr[j][i]=0;
for(;j<m;j++)
arr[j][i]=1;
}
for(i=0;i<m;i++)
{for(j=0;j<10;j++)
if(arr[i][j]==0)
printf(" ");
else if(arr[i][j]==1)
printf("*");
printf("\n");
}
return 0;
}
#include<stdio.h>
using namespace std;
int main()
{
	int x,i,j,k,t,n,a[25],b[20],c=0;
	scanf("%d",&t);
	for(x=0;x<t;x++)
	{
		scanf("%d",&n);
		for(i=0;i<n;i++)
			scanf("%d",&b[i]);
		for(i=0;i<n-2;i++)
		      for(j=i+1;j<n-1;j++)
                         		for(k=j+1;k<n;k++)
			         if((b[i]+b[j]>b[k])&&(b[i]+b[k]>b[j])&&(b[j]+b[k]>b[i]))
				   c++;	
		a[x]=c;
		c=0;
	}
	for(i=0;i<t;i++)
		printf("%d\n",a[i]);
}
#include<iostream>
#include<stdio.h>
using namespace std;
 int main()
 {
     int t;
     scanf("%d",&t);
     while(t--)
     {
         int x1,x2,x3,x4,y1,y2,y3,y4;
         scanf("%d %d %d %d",&y1,&y2,&y3,&y4);
         x2=y1+y4-y3;
         x3=y2-y1-y4;
         x4=y1-(x2+x3);
         x1=x4-x2-y3;
         printf("%d %d %d %d\n",x1,x2,x3,x4);
     }
     return(0);
 }

import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.util.Comparator;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.List;
import java.io.IOException;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.math.BigInteger;
import java.io.InputStream;
import java.math.*;
 
public class Main {
public static void main(String[] args) {
InputStream inputStream = System.in;
OutputStream outputStream = System.out;
InputReader in = new InputReader(inputStream);
OutputWriter out = new OutputWriter(outputStream);
int testCount = Integer.parseInt(in.next());
String S;
BigInteger q,high,low,mid,r;
int a,b;
        for (int i = 1; i <= testCount; i++)
                {
                S=in.next();
                q=new BigInteger(S);
                low=new BigInteger("0");
                high=q;
                a=low.compareTo(high);
				//out.printLine(a);
				//out.printLine(S.toString());
                mid=new BigInteger("0");
				while(a==-1)
                        {
                        mid=low.add(high);
                        mid=mid.divide(new BigInteger("2"));
						/*
						out.printLine("low"+low.toString());
						out.printLine("high"+high.toString());
						out.printLine("mid"+mid.toString());*/
                        r=mid.pow(2);
                        b=r.compareTo(q);
                        if(b==-1)
                                {
                                low=mid;//.add(new BigInteger("1"));
                                }
                        else if(b==1)
                                {
                                high=mid;//.subtract(new BigInteger("1"));
                                }
                        else
                                break;
						a=low.compareTo(high);
                        }
                if(q.compareTo(low.pow(2))==0)
                        S=low.toString();
                else if(q.compareTo(high.pow(2))==0)
                        S=high.toString();
				else
					S=mid.toString();
				/*
				out.printLine("low"+low.toString());
				out.printLine("high"+high.toString());
				out.printLine("high"+mid.toString());
                */
				out.printLine(S);
                
				}
				
out.close();
                }
 
}
class InputReader {
 
private InputStream stream;
private byte[] buf = new byte[1024];
private int curChar;
private int numChars;
private SpaceCharFilter filter;
 
public InputReader(InputStream stream) {
this.stream = stream;
}
 
public int read() {
if (numChars == -1)
throw new InputMismatchException();
if (curChar >= numChars) {
curChar = 0;
try {
numChars = stream.read(buf);
} catch (IOException e) {
throw new InputMismatchException();
}
if (numChars <= 0)
return -1;
}
return buf[curChar++];
}
 
public int readInt() {
int c = read();
while (isSpaceChar(c))
c = read();
int sgn = 1;
if (c == '-') {
sgn = -1;
c = read();
}
int res = 0;
do {
if (c < '0' || c > '9')
throw new InputMismatchException();
res *= 10;
res += c - '0';
c = read();
} while (!isSpaceChar(c));
return res * sgn;
}
 
public String readString() {
int c = read();
while (isSpaceChar(c))
c = read();
StringBuilder res = new StringBuilder();
do {
res.appendCodePoint(c);
c = read();
} while (!isSpaceChar(c));
return res.toString();
}
 
public boolean isSpaceChar(int c) {
if (filter != null)
return filter.isSpaceChar(c);
return isWhitespace(c);
}
 
public static boolean isWhitespace(int c) {
return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
}
 
public String next() {
return readString();
}
 
public interface SpaceCharFilter {
public boolean isSpaceChar(int ch);
}
}
 
class OutputWriter {
private final PrintWriter writer;
 
public OutputWriter(OutputStream outputStream) {
writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
}
 
public OutputWriter(Writer writer) {
this.writer = new PrintWriter(writer);
}
 
public void print(Object...objects) {
for (int i = 0; i < objects.length; i++) {
if (i != 0)
writer.print(' ');
writer.print(objects[i]);
}
}
 
public void printLine(Object...objects) {
print(objects);
writer.println();
}
 
public void close() {
writer.close();
}
 
}
#include<bits/stdc++.h>
using namespace std;
double polygonArea(long int X[], long int Y[], long int numPoints) 
{ 
  long int i;         // Accumulates area in the loop
  double area=0;
	for(i=0;i<numPoints;i++)
	{
		if(i==numPoints-1)
		area+=(X[i]*Y[0]-X[0]*Y[i]);
		else
		area+=(X[i]*Y[i+1]-X[i+1]*Y[i]);
		
	}
	
  return abs(area/2);
} 
int main(){
 
    long int t;
   cin>>t;
    while(t--)
	{
 	   long  int n,i,j; //n for no. of polygon
 	   double area=0;
       cin>>n;
       long int X[n];
 	   long int Y[n];
	   long int val;
 	   for(i=0;i<n;i++)
	   {
            cin>>X[i];
 					
   	   }
   	   for(i=0;i<n;i++)
	   {
            cin>>Y[i];
 					
   	   }
   	   
   	   area=polygonArea(X, Y, n);
   	   printf("%.1f",area);
            cout<<endl;
    }
    return 0;
}
 
#include <iostream>
using namespace std;

int n;

int main() {
	// your code goes here
	
	cin >> n;
	
	int p = n;
	int count = 0;
	while(p>0){
		int q = p%2;
		p /= 2;
		if(q==1)
			count++;
	}
	
	int r = 1<<count;

	r = n+1-r;
	cout << r << endl;
	
	return 0;
}
from re import findall
count = int(raw_input())
def test(p):
    x,y = p
    global m
    if eval(str(y)+".0")/x <= m:
        return True
    return False
for i in range(count):
    n,a,b = [int(x) for x in findall("\d+",raw_input())]
    m,net = eval(str(a) + ".0")/b,0
    xx,yr = xrange(1,n+1),int(eval(str(n)+"*"+str(a)+".0")/b)
    if a%b != 0 and n%b != 0:
        yr += 1
    for y in range(1,yr):
        total = 0
        for x in xx:
            if test((x,y)):
                total += n+1-x
                break
        if total != 1:
            if y == 1:
               net += total * (total-1)/2
            else:
                net += total * (total-1)/2 * y
    print net
import java.io.*;
public class Main {
	public static void main(String args[]) throws IOException{
try{
		BufferedReader obj = new BufferedReader(new InputStreamReader(System.in));
		String str = obj.readLine();
		int len = str.length();
		//System.out.println(len);
		int n = Integer.parseInt(str);
		//System.out.println(n);
		/*double pow = Math.pow(10,len-1);
		int intpow = (int)pow;*/
		boolean valid = true;
		int digits[] = new int[len];
		int temp = n;
		for(int i=len-1;i>=0;i--){
			digits[i] = temp%10;
			temp /= 10;
		}
		for(int i=0;i<len;i++){
			if(digits[i]!=0){
				if(n%digits[i]!=0){
					valid = false;
					break;
				}
			}
		}
		if(valid==true)
			System.out.println("Valid");
		else
			System.out.println("Invalid");
}catch(Exception e){}
	}
}

#include <stdio.h>
#define MOD 1000000007
#define LL long long

LL Pow(int n) {
	if(n <= 0) return 1;
	LL x = Pow(n/2) % MOD;
	LL k = (long long) (x*x)%MOD;
	if(n%2) k = (2*k)%MOD;
	return k%MOD;
}
int main() {
	int t,n;
	scanf("%d",&t);
	while(t--) {
		scanf("%d",&n);
		printf("%lld\n",Pow(n));
	}
	return 0;
}
//Author : pakhandi
//
using namespace std;

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>

#define wl(n) while(n--)
#define fl(i,a,b) for(i=a; i<b; i++)
#define rev(i,a,b) for(i=a; i>=b; i--)
#define print(n) printf("%d\n", n)
#define scan(n) scanf("%d", &n)
#define MOD 1000000007
#define ll long long int

char str1[505], operations[505];

int main()
{
	int i, j, cases;
	int a, b, len1, count;
	long long int ans;
	while(1)
	{
		scanf("%s", str1);
		if(str1[0]=='0' && str1[1]=='\0')
			break;
		len1=strlen(str1);
		count=0;
		fl(i,0,len1)
		{
			if(str1[i]=='+' || str1[i]=='-' || str1[i]=='*' || str1[i]=='/')
			{
				operations[count++]=str1[i];
			}
		}
		//count++;
		scanf("%lld", &ans);
		ans=ans*1LL;
		fl(i,0,count)
		{
			scan(a);
			if(operations[i]=='+')
				ans=(ans+a)*1LL;
			else if(operations[i]=='-')
				ans=(ans-a)*1LL;
			else if(operations[i]=='*')
				ans=(ans*a)*1LL;
			else
				ans=(ans/a)*1LL;
			
			ans=(ans%MOD)*1LL;
		}
		print(ans);
	}
	return 0;
}

import java.io.*;

class Main
{
	public static void main(String args[])
	{
		String s;
		long N;
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		for(;;)
		{
			try
			{
				s=br.readLine();
				N=Long.parseLong(s);
				System.out.println(N-1);
			}
			catch(Exception e)
			{
				System.exit(0);
			}
		}
	}
}
#include<stdio.h>
//#include<conio.h>
#include<math.h>
int bsearchsmallerside(int *a,int low ,int high,int item)
{
    if(high==low)
    {
        return low;    
    }
    else
    {
        int   mid=(low+high)/2;
        if(item==a[mid])
        return mid;
        else if(item>a[mid])
        {
        low=mid+1;
        return(bsearchsmallerside(a,low,high,item));
        }
        else
        {
        high=mid; 
        return(bsearchsmallerside(a,low,high,item));
        }   
    }
}


int main()
{
int N,p,q,count,T,reverse,a[100000],i,j,i1,count1,loop,x,y,c;
a[0]=2;
a[1]=3;
count=2;
for(i=5,j,loop=1;i<=100001;loop++)
		{
			 i1=sqrt(i);
			for(j=0;(j<count)&&(a[j]<=i1);j++)
			{
				if(i%a[j]==0)
				break;
			}
			if(a[j]>i1)
			{
			a[count]=i;
			count++;
			}
			if(loop%2!=0)
			i+=2;
			else
			i+=4;			
		}  
		
		//printf("%d %d %d",count,a[count],a[count-1]);
		scanf("%d",&T);
		while(T--)
		{
        reverse=0;
        scanf("%d %d",&p,&q);
        if(p>q)
        {
        c=q;
        q=p;    
        p=c;
        reverse=1;    
        }
        //printf("enter N");
        scanf("%d",&N);
        x=bsearchsmallerside(a,0,9591,p+1);
        y=bsearchsmallerside(a,0,9591,q-1);
        if(a[y]>=q)
        y=y-1;
        if(a[x]<=p)
        x=x+1;
        //printf("\n%d %d\n",a[x],a[y]);
        if(a[x]>a[y] || a[x]>=q || a[y]<=p)
        printf("-1\n");
        else
        {
        count1=(y-x)+1;
        N=N%count1;
        if(N==0)  N=count1;
        //if(reverse==1) N=count1-N+1;
        printf("%d\n",a[x+(N-1)]);    
        }
        }
        //getch();
        return 0;
}

for u in range(input()):
    string = raw_input().split()
    if int(string[-1]) > 200:
        print u + 1
#include<iostream>
#include<math.h>
#include<vector>
using namespace std;

int * sort(int * A,int size,int level)
{
	int i,j,temp,indices[10],count[10],div=pow(10,level);
	for(i=0;i<10;i++)
	{
		count[i]=0;
		indices[i]=0;
	}
	for(i=0;i<size;i++)
	{
		count[(A[i]/div)%10]++;
	}
	int **Ax=new int *[10];
	for(i=0;i<10;i++)
	{
		Ax[i]=new int[count[i]];
	}
	for(i=0;i<size;i++)
	{
		temp=(A[i]/div)%10;
		Ax[temp][indices[temp]]=A[i];
		indices[temp]++;
	}
	if(level!=0)
	for(i=0;i<10;i++)
	{
		if(count[i]>1)
		Ax[i]=sort(Ax[i],count[i],level-1);
	}
	temp=0;
	for(i=0;i<10;i++)//ascending
	{
		for(j=0;j<count[i];j++)
		{
			A[temp+j]=Ax[i][j];
		}
		temp+=count[i];
		delete Ax[i];
	}
	delete Ax;
	return A;	
}

int main()
{
	int i,n,*A;
	cin>>n;
	A=new int[n];
	for(i=0;i<n;i++)cin>>A[i];
	A= sort(A,n,9);
	
	for(i=0;i<n;i++)cout<<A[i]<<" ";
	return 0;
	
}

n,m=map(int,raw_input().split())
a=[0]*(n+2)
#print a
for i in range(m):
	left,right=map(int,raw_input().split())
	a[left]+=1
	a[right+1]-=1
for j in range(1,n+1):
	a[j]+=a[j-1]
a=a[:n+1]
a.sort()
#print a
print a[(n/2)+1]

l=[0]*1000003
l[0]=1
for i in range(1,len(l)):
        l[i]=i*l[i-1]%1000003
for i in range(input()):
	n,x=map(int,raw_input().split())
	if n>=1000003:
                print "0"
	else:
                
                print ((l[n])*x)%1000003

# your code goes here
t = input()
for i in xrange(t):
	s = raw_input()
	count = 0
	for j in s:
		count+=(ord(j)-96)
	print count
t=input()
while(t>0):
	n=input()
	A=[]
	for i in range(n):
		A.append(raw_input())
	s=raw_input()
	for i in range(len(A)):
		if(s==A[i]):
			print "yes"
			break
	else:
		print "no"
	t=t-1

#include<bits/stdc++.h>
using namespace std;
int deepayan(int n,int k,int m)
{
    if(n==1) return 0;
    return ((deepayan(n-1,k,m+1)+m*k)%n);
}
int main()
{
    int n,t,k;
    scanf("%d",&t);
    while(t--){
    scanf("%d",&n);
    scanf("%d",&k);
    printf("%d\n",(deepayan(n,k,1)+1));}
    return 0;
}

import sys

def base(n):
	max=0
	while(n!=0):
		if(n%10 > max):
			max=n%10
			
		n=n/10
	return max+1

def convert(n,b):
	i=0
	sum=0
	while(n!=0):
		sum+=(n%10)*pow(b,i)
		i=i+1
		n=n/10
	
	return sum

def main():
	t=int(raw_input())
	
	while(t!=0):
		a,b=map(int,raw_input().split())
		a=convert(a,base(a))
		b=convert(b,base(b))
		print a+b
		t=t-1
if __name__ == '__main__':
	main()
t = input()
while t:
		t-=1
		x,y = [int(x) for x in raw_input().split()]
		print( ( (y - x + 1) * (y - x) ) / 2 )
import string
for _ in range(int(raw_input())):
    string=str(raw_input()).lower()
    punctuation=['!','@','#',' ','$','%','^','&','*','(',')','-','=','+','[',']',"'",';','/''1','2','3','4','5','6','','7','8','9','0']
    string1=[f for f in string if f not in punctuation]
    string=''.join(string1)
    dictionary={}
    for i in string:
        dictionary[i]=dictionary.get(i,0)+1
    maxvals=max(dictionary.values())
    new=[]
    for a,b in dictionary.items():
        if(b==maxvals):
            new.append(ord(a))
    print str(unichr(max(new)))

def multiply(m1, m2, mod):
    return [
        [(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod,
         (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod],
        [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod,
         (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]
    ]

def findNthPower(n, mod):
    A = [[1, 1], [1, 0]]
    if n == 1:
        return A
    r = findNthPower(n / 2, mod)
    r = multiply(r, r, mod)
    if n % 2 == 1:
        r = multiply(r, A, mod)
    return r


def solve(n, m):
    r = findNthPower(2*n-1, m)
    return "%s/%s" % (r[0][1], r[0][0])


def main():
    for _ in range(int(raw_input())):
        n, m = map(int, raw_input().split())
        print("%s" % solve(n, m))


if __name__ == "__main__":
    main()
def solve(N, stones):
    tmp = 0
    for n in xrange(N):
        tmp += stones[n] / (n+1)
    if tmp % 2 == 0:
        return 'BOB'
    return 'ALICE'

def resn04():
    T = int(raw_input())
    for t in xrange(T):
        N = int(raw_input())
        stones = map(int,raw_input().split())
        print solve(N, stones)

if __name__ == "__main__":
    resn04()
q=int(raw_input())
for i in range(q):
    n=int(raw_input())
    n-=1
    print (((pow(2,n,8388608)*( ( (pow(n,2,8388608)+(n%8388608))%8388608 + (2%8388608) )%8388608)%8388608)%8388608)-(1%8388608))%8388608
__author__ = 'Rajan'

l=int(raw_input())
x=0
A=['0','2','4','6','8']

while(x<l):
    for i in range(0,l):
        n=raw_input()

        if(n[0] in A):
            print "EVEN"
            x=x+1

        else:
            print "ODD"
            x=x+1
def OptimizedDivideAndConquerSingleSellProfit(arr):
    # If the array is empty, the maximum profit is zero.
    if len(arr) == 0:
        return 0

    # This recursive helper function implements the above recurrence.  It
    # returns a triple of (max profit, min array value, max array value).  For
    # efficiency reasons, we always reuse the array and specify the bounds as
    # [lhs, rhs]
    def Recursion(arr, lhs, rhs):
        # If the array has just one element, we return that the profit is zero
        # but the minimum and maximum values are just that array value.
        if lhs == rhs:
            return (0, arr[lhs], arr[rhs])

        # Recursively compute the values for the first and latter half of the
        # array.  To do this, we need to split the array in half.  The line
        # below accomplishes this in a way that, if ported to other languages,
        # cannot result in an integer overflow.
        mid = lhs + (rhs - lhs) / 2
        
        # Perform the recursion.
        ( leftProfit,  leftMin,  leftMax) = Recursion(arr, lhs, mid)
        (rightProfit, rightMin, rightMax) = Recursion(arr, mid + 1, rhs)

        # Our result is the maximum possible profit, the minimum of the two
        # minima we've found (since the minimum of these two values gives the
        # minimum of the overall array), and the maximum of the two maxima.
        maxProfit = max(leftProfit, rightProfit, rightMax - leftMin)
        return (maxProfit, min(leftMin, rightMin), max(leftMax, rightMax))

    # Using our recursive helper function, compute the resulting value.
    profit, _, _ = Recursion(arr, 0, len(arr) - 1)
    return profit


t = int(raw_input())
while(t):
	t -= 1
	n = int(raw_input())
	x = raw_input()
	x = map(int, x.split())
	ans = OptimizedDivideAndConquerSingleSellProfit(x)
	print ans
#include<stdio.h>
#include<string.h>
//#include<iostream>
int main()
{
    char a[22],r;
    int t,i;
    scanf("%d",&t);
    while(t--)
    {
              scanf("%s",a);
              r='1';
              for(i=strlen(a)-1;i>=0;i--)
              {
               if(a[i]=='1'&&r=='1')
               {
                a[i]='0';
                r='1';
               }
               else if(r=='1'&&a[i]=='0')
               {
                a[i]='1';
                r='0';
               }
               else if(r=='0')
               break;
              }
              if(r=='1')
              printf("1");
              printf("%s\n",a);
              
    }
   // system("pause");
    return 0;
}            
               
              

#include<iostream>
using namespace std;

int main()
{
int t; cin>>t;
while(t--)
{
long long int dashes=0;
long long int x; cin>>x;
while(x)
{
int r=x%10;
switch(r)
{
case 1:dashes+=4;break;
case 2:;case 3:;case 5:dashes+=10;break;
case 4:dashes+=8;break;
case 6:;case 0:; case 9:dashes+=18;break;
case 7:dashes+=9;break;
case 8:dashes+=21;break;
}
x=x/10;
}
cout<<dashes<<endl;
}
return 0;
}
#include<iostream>
#include<cstdio>
using namespace std;
void quickSort(int[],int,int);
int main()
{
    int t,m,c,j,a[1000000];
    scanf("%d",&t);
    while(t--)
    {
        j = 0;
        scanf("%d",&m);
        while(j<m)
            scanf("%d",&a[j++]);
        if(m%2==0)
             c = -1;
        else
        {
            quickSort(a,0,m-1);
            c = a[m/2];
        }
        printf("%d\n",c);
    }
    return 0;
}
void quickSort(int arr[], int left, int right) {
      int i = left, j = right;
      bool end = false;
      int tmp;
      int pivot = arr[(left + right) / 2];
      /* partition */
      while (i <= j) {
            while (arr[i] < pivot)
                  i++;
            while (arr[j] > pivot)
                  j--;
            if (i <= j) {
                  tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  i++;
                  j--;
            } 
      }   
      /* recursion */
      if (left < j){
         
            quickSort(arr, left, j);
            }
      if (i < right){
            
            quickSort(arr, i, right);
}
      if (i >= right && left >= j){
            
}} 
#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
big fact(big n)
{
    if(n==0 || n==1) return 1;
    return n*fact(n-1);
}
big gcd(big a, big b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}
int main() {
	big l,t,n,m,i,j,k,temp,*arr,f,a,b,a1,b1,cr,count;
	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3;
	int h,num=0,prev,sum;
	vb v,line;
	char c;
	string s,final;
    cin>>t;
    while(t-->0)
    {
       cin>>s;
       l=s.length();
           RFOR(i,s.length()/2-1,0)
           cout<<s[i];
           
           RFOR(i,s.length()-1,s.length()/2)
           cout<<s[i];
           cout<<endl;
    }
	return 0;
}
#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
int main() {
	big l,t,n,i,j,k,temp,c,count;
	vb v;
	cin>>t;
	while(t-->0)
    {
        count=0;
        cin>>n;
        v.clear();
        FOR(i,0,n-1)
        {
            cin>>temp;
            v.pb(temp*3);
        }
        FOR(i,0,n-1)
        {
            cin>>temp;
            v[i]+=temp;
        }
        sort(v.begin(),v.end());
        cout<<v[n-1]<<endl;
    }
    
	return 0;
}
#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
int main() {
	big l,t,n,i,j,k,temp,c,*arr,inv=0,linv=0,mi=0,ni=0,m,mt,lv;
	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3;
	int h,num=0,prev;
	vb v,line;
	string s;
    cin>>t;
    while(t-->0)
    {
        cin>>n;
        n=n-n%2;
        cout<<(n/4)*(n/4+(n/2)%2)<<endl;
    }
	return 0;
}
#include<iostream>
using namespace std;
int main()
{
  int n,T;
  int l,r,b,t,a3;
  int v1,v2,v3,v4;
  int x1[22],x2[22],y1[22],y2[22];
  cin>>T;
  while(T--)
  {
    cin>>n;
    for(int i=0;i<n;i++)
    {
      cin>>v1>>v2>>v3>>v4;
      x1[i]=v1<v3?v1:v3;
      y1[i]=v2<v4?v2:v4;
      x2[i]=v1>v3?v1:v3;
      y2[i]=v2>v4?v2:v4;
    }
    l=x1[0];
    for(int i=0;i<n;i++)
    {
      if(x1[i]>l)
	l=x1[i];
    }
    r=x2[0];
    for(int i=0;i<n;i++)
    {
      if(x2[i]<r)
	r=x2[i];
    }
    b=y1[0];
    for(int i=0;i<n;i++)
    {
      if(y1[i]>b)
	b=y1[i];
    }
    t=y2[0];
    for(int i=0;i<n;i++)
    {
      if(y2[i]<t)
	t=y2[i];
    }
      a3=(l-r)*(b-t);
      if(a3<0)
	a3=-a3;
     // cout<<"l,r,b,t="<<l<<" "<<r<<" "<<b<<" "<<t<<endl;
    if(l<r&&b<t)
      cout<<a3<<endl;
    else
     cout<<0<<endl;
  }
  return 0;
}
#include <iostream>
#include <algorithm>
using namespace std;
 
int main()
{
    int t; cin>>t;
    while(t--)
    {
        int n; cin>>n;
        int group[n];
        for(int i=0;i<n;i++)
        cin>>group[i];
 
        for(int i=0;i<n;i++)
        {
            int c=group[i];
            bool print=true;
            for(int j=i+1;j<n;j++)
            {
                if(group[j]==c)
                {print=false;break;}
            }
            if(print==true)
            cout<<c<<endl;
        }
    }
    return 0;
}
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
    int t,total,a[4],sol[40005],j,i;
    cin>>t;
    while(t--)
    {
        memset(a,0,sizeof(a));
        memset(sol,0,sizeof(sol));
        cin>>total>>a[0]>>a[1]>>a[2]>>a[3];
        sol[0]=1;
        for(i=0;i<4;i++)
        {
            for(j=total;j>=0;j--)
            {
                if(sol[j]==1)
                {
                    sol[j+a[i]]=1;
                }
            }
        }
        if(sol[total]==1)
            cout<<"YES"<<endl;
        else
            cout<<"NO"<<endl;
    }
}

#include<bits/stdc++.h>
#define LL long long int
#define REP(i,n) for(int i=0;i<n;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define TC int t;scanf("%d",&t);while (t-->0)
#define INP(x) scanf("%d",&x)
#define OUT(x) printf("%d\n",x)
#define INPLL(x) scanf("%lld",&x)
#define OUTLL(x) printf("%lld\n",x)
#define INPS(x) scanf("%s",x)
#define OUTS(x) printf("%s\n",x)
#define INPD(x) scanf("%lf",&x)
#define OUTD(x) printf("%.6lf\n",x)
#define MEM(a,b) memset(a,b,sizeof(a))
#define MP make_pair
#define PB push_back
#define PII pair<int,int>
#define PLL pair<long long,long long>
#define VPII vector<pair<int,int >
#define debug(x) cout<<"### x is: "<<x<<"###"<<endl
#define F first
#define S second
#define MOD 1000000007
#define mod 10000007
#define PI 3.14159265359
using namespace std;
bool a[1000000];
LL primes[1000000],in=0;
void Sieve(int n)
{
    memset(a,true,sizeof(a));
    a[1]=false;
    for(int i=2;i*i<=n;i++)
    {
        if(a[i])
        {
            for(int j=2*i;j<n;j+=i)
                a[j]=false;
        }
    }
    for(int i=2;i<=n;i++)
    {
        if(a[i])
            primes[in++]=i;
    }
}
LL calc(LL idx,LL cur,LL k)
{
		LL square=primes[idx]*primes[idx];
		LL newCur=square*cur;
		LL res=0;

		if(newCur<0||newCur>k)
            return 0;
		res+=k/(newCur);
		res+=calc(idx+1,cur,k);
		if(newCur>0&&newCur<k)
			res-=calc(idx+1,newCur,k);
		return res;
}
LL getNumber(LL n)
{
		LL lo=1; LL hi=2000000000l;
		while(lo<hi)
		{
			LL mid=lo+(hi-lo)/2;
			LL cnt=mid-calc(0,1,mid);
			if(cnt<n)
			{
				lo=mid+1;
			}
			else
			{
				hi=mid;
			}
		}
		return lo;
}
int main()
{
    Sieve(1000000);
    LL n;
    TC
    {
        INPLL(n);
        OUTLL(getNumber(n));
    }
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
 #include<iostream>
 using namespace std;
/* Following function is needed for library function qsort(). Refer
   http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */
int comp(const void* a, const void* b)
{  return *(int*)a > *(int*)b ; }
 
// Function to count all possible triangles with arr[] elements
int findNumberOfTriangles(int arr[], int n)
{
    // Sort the array elements in non-decreasing order
    qsort(arr, n, sizeof( arr[0] ), comp);
 
    // Initialize count of triangles
    int count = 0;
 
    // Fix the first element.  We need to run till n-3 as the other two elements are
    // selected from arr[i+1...n-1]
    for (int i = 0; i < n-2; ++i)
    {
        // Initialize index of the rightmost third element
        int k = i+2;
 
        // Fix the second element
        for (int j = i+1; j < n; ++j)
        {
            // Find the rightmost element which is smaller than the sum
            // of two fixed elements
            // The important thing to note here is, we use the previous
            // value of k. If value of arr[i] + arr[j-1] was greater than arr[k],
            // then arr[i] + arr[j] must be greater than k, because the
            // array is sorted.
            while (k < n && arr[i] + arr[j] > arr[k])
               ++k;
 
            // Total number of possible triangles that can be formed
            // with the two fixed elements is k - j - 1.  The two fixed
            // elements are arr[i] and arr[j].  All elements between arr[j+1]
            // to arr[k-1] can form a triangle with arr[i] and arr[j].
            // One is subtracted from k because k is incremented one extra
            // in above while loop.
            // k will always be greater than j. If j becomes equal to k, then
            // above loop will increment k, because arr[k] + arr[i] is always
            // greater than arr[k]
            count += k - j - 1;
        }
    }
 
    return count;
}
 
// Driver program to test above functionarr[j+1]
int main()
{ int t;
 cin>>t;
while(t--){
 int n,i;
cin>>n;
int a[n];
for(i=0;i<n;i++) cin>>a[i];
cout<<findNumberOfTriangles(a,n)<<endl;
 }
    return 0;
}
#include <stdio.h>
#include <cmath>
#include <algorithm>

#define INF 30000

struct point
{
	int x;
	int y;
};

int comp(const void *a,const void *b){
	point ap = *(point*)a;
	point bp = *(point*)b;

	double sa,sb;

	if(ap.x>0) sa = (double)ap.y/ap.x;
	else if(ap.x==0)sa = INF;
	else sa = 2*INF + (double)ap.y/ap.x;

	if(bp.x>0) sb = (double)bp.y/bp.x;
	else if(bp.x==0)sb = INF;
	else sb = 2*INF + (double)bp.y/bp.x;

	return sa < sb ? 1 : 0;
}

int main(){
	int T;
	scanf("%d",&T);

	while(T--){
		int N;
		scanf("%d",&N);

		point pts[N];
		for(int i=0;i<N;i++) scanf("%d",&pts[i].x);

		int miny=0;
		for(int i=0;i<N;i++){
			scanf("%d",&pts[i].y);
			if(pts[i].y<pts[miny].y) miny=i;
		}

		for(int i=0;i<N;i++){
			if(i!=miny){
				pts[i].x -= pts[miny].x;
				pts[i].y -= pts[miny].y;
			}
		}

		pts[miny].x = pts[0].x;
		pts[miny].y = pts[0].y;
		pts[0].x =0;
		pts[0].y=0;

		qsort(pts+1,N-1,sizeof(point),comp);

		double area=0,a=sqrt(pts[1].x*pts[1].x+pts[1].y*pts[1].y),b,c,s;
		for(int i=1;i<N-1;i++){
			b = sqrt((pts[i].x-pts[i+1].x)*(pts[i].x-pts[i+1].x) + (pts[i].y-pts[i+1].y)*(pts[i].y-pts[i+1].y));
			c = sqrt(pts[i+1].x*pts[i+1].x + pts[i+1].y*pts[i+1].y);
			s = (a+b+c)/2;

			area += sqrt(s*(s-a)*(s-b)*(s-c));
			a=c;
		}

		printf("%.1lf\n",area);
	}
}

import java.util.Scanner;
import java.math.BigInteger;


class RGPVR305 { 
    
	/* Faruk Akgul - Java's Missing Algorithm: BigInteger Sqrt
faruk.akgul.org */

    public static BigInteger sqrt(BigInteger n) {
        BigInteger a = BigInteger.ONE;
        BigInteger b = new BigInteger(n.shiftRight(5).add(new BigInteger("8")).toString());
        while(b.compareTo(a) >= 0) {
            BigInteger mid = new BigInteger(a.add(b).shiftRight(1).toString());
            if(mid.multiply(mid).compareTo(n) > 0) b = mid.subtract(BigInteger.ONE);
            else a = mid.add(BigInteger.ONE);
          }
          return a.subtract(BigInteger.ONE);
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t != 0) {
            BigInteger n = sc.nextBigInteger();
            System.out.println(sqrt(n));
            t -= 1;
        }
    }
}
#define inam aaaaa(e,n,i,g,m,a)
#define aaaaa(p,l,i,n,t,h) t##h##i##l
#define kill aaaaaaa(s,t,u,p,i,d)
#define aaaaaaa(c,a,s,i,n,o) i##s##a##c
#define bug aaaaaaaa(c,h,a,r,i,t,y)
#define aaaaaaaa(m,u,n,g,e,r,i) m##u##n##g
#define aaaaaa ({bug a[]={aaa(52),aaa(49),aaa(44),aaa(44),aaa(4C),aaa(45),aaa(0)};kill(a);})
#define aaa(y) 0x##y
inam(){aaaaaa;}
t=int(raw_input())
for i in range(t):
    n=raw_input()
    counter=1
    a=n[0]
    for j in range(1,len(n)):
        if(n[j]!=a):
            counter+=1
            a=n[j]
    print len(n)-counter
from sys import stdin,exit
def main():
	n=int(raw_input())
	x=map(int,stdin.readline().split())
	while len(x):
		print len(x)
		mn=min(x)
		x= map(lambda e:e-mn, x)
		x[:]=[i for i in x if i]
		
		
	exit(0)

if __name__=="__main__":
	main()
t=input()
while t:
    x,y=map(int,raw_input().split())
    res=x+y
    res=list(str(res))
    while '0' in res:
        res.remove('0')
    x=list(str(x))
    y=list(str(y))
    while '0' in x:
        x.remove('0')
    while '0' in y:
        y.remove('0')
    res1=int(''.join(x))+int(''.join(y))
    res1=str(res1)
    if(res1==''.join(res)):
        print "YES"
    else:
        print "NO"
    t=t-1

s = raw_input()
arr = []
o = 0
k = 0 #
index = 0#
for i in range(len(s)):
    if s[i] == '(':
        o += 1
    elif s[i] == ')':
        o -= 1
    else:
        if o > k:
            k = o
            index = i 
ans = ""           
while s[index]!=")":
    ans += s[index]   
    index += 1
print ans    
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)
t=input()
while t>0:
    t=t-1
    a,b=map(int,raw_input().split())
    
    if a==b:
        print a
    else:
        print gcd(a-1,b-1)+1
        

#include<stdio.h>
#include<stdlib.h>
typedef long long int lli;
lli gcd(lli a,lli b)
{
  if(a==0)
    return b;
  return gcd(b%a,a);
}
int main()
{
  lli n,*arr,q,l,r,i,ans;
  scanf("%lld",&n);
  arr=(lli *)malloc(sizeof(lli)*n);
  for(i=0;i<n;i++)
  {
    scanf("%lld",&arr[i]);
  }
  scanf("%lld",&q);
  while(q--)
  {
    scanf("%lld %lld",&l,&r);
    ans=gcd(arr[l-1],arr[r-1]);
    printf("%lld\n",(arr[l-1]*arr[r-1])/ans);
  }

}

#include<stdio.h> 
using namespace std;
int main()
{
	int I,J,k,i=0,j=0;
	long long c,t,n,ans=0;
	scanf("%lld\n",&t);
	scanf("%lld\n",&n);
	bool f1[200],f2[200];
	c=t;
	while(c){
		f1[i++]=(c%2);
		c=c/2;
	}
	c=n;
	while(c){
		f2[j++]=(c%2);
		c=c/2;
	}
	scanf("%d",&I);
	scanf("%d",&J);
	for(k=I;k<=J;k++){
		f1[k]=f2[k-I];
	}
	for(k=i-1;k>=0;k--){
		ans=(ans*2)+(f1[k]?1:0);
	}
	printf("%llu\n",ans);
	return 0;
} 


test=input()
for num in range(test):
    l=input()
    s=raw_input().split()
    
    t=[]
    for n in range(l):
      t.append(int(s[n]))
      
    count=0
    
    for n in range(l-1):
     
      x=n+1
      p=0
      while x<=l-1:
        if t[x]-t[n]==(x-n):
          p=p+1
        x=x+1
      if p>count:
        count=p
    print l-count-1
import copy
cases = int(raw_input())
i = 1
while cases:
    cases -= 1
    times = int(raw_input()) 
    lis = []
    while times:
        times -= 1
        lis.append(raw_input())
    abb = raw_input().lower()
    print "Data Set "+ str(i) + ":"
    i += 1
    j = 0
    l1 = len(abb)
    for s in lis:
        tmp = copy.copy(s.lower())
        indxs = []
        prev = 0
        for ltr in abb:
            if ltr in tmp:
                idx = tmp.index(ltr)
                indxs.append(idx+prev)
                prev += idx
                tmp = tmp[idx+1:]
        flag = 1
        if len(indxs) == l1:
            for a in range(l1-1):
                if indxs[a] > indxs[a+1]:
                    flag = 0
                    break
            if flag == 1:
                print s
import sys;

aw=False;
bw=False;
def main():
	tc=int(raw_input().strip());
	for x in range(tc):
		global aw;
		global bw;
		aw=False;
		bw=False;
		board=[];
		for y in range(5):
			board.append(raw_input().strip());
		checkHorizontal(board);
		checkVertical(board);
		checkDiagonal(board);
		global aw;
		global bw;
		if aw and bw:
			print "draw";
		elif aw and not bw:
			print "A wins";
		elif bw and not aw:
			print "B wins";
		else:
			print "draw";

def checkHorizontal(b):
	global aw;
	global bw;
	sta="AAA";
	stb="BBB";
	for i in range(5):
		r=b[i];
		if r.find(sta)>=0:
			aw=True;
		elif r.find(stb)>=0:
			bw=True;

def checkVertical(b):
	global aw;
	global bw;
	if aw and bw:
		return 1;
	vb=[];
	for i in range(5):
		s="";
		for j in range(5):
			s=s+b[j][i];
		vb.append(s);
	sta="AAA";
	stb="BBB";
	for i in range(5):
		r=vb[i];
		if r.find(sta)>=0:
			aw=True;
		elif r.find(stb)>=0:
			bw=True;

def checkDiagonal(b):
	global aw;
	global bw;
	if aw and bw:
		return 1;
	sta="AAA";
	stb="BBB";
	st=b[0][0]+b[1][1]+b[2][2]+b[3][3]+b[4][4];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[1][0]+b[2][1]+b[3][2]+b[4][3];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[2][0]+b[3][1]+b[4][2];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[0][1]+b[1][2]+b[2][3]+b[3][4];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[0][2]+b[1][3]+b[2][4];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	
	st=b[0][4]+b[1][3]+b[2][2]+b[3][1]+b[4][0];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[0][3]+b[1][2]+b[2][1]+b[3][0];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[0][2]+b[1][1]+b[2][0];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[1][4]+b[2][3]+b[3][2]+b[4][1];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
	st=b[2][4]+b[3][3]+b[4][2];
	if st.find(sta)>=0:
		aw=True;
	elif st.find(stb)>=0:
		bw=True;
if __name__=="__main__":main();

#include<iostream>
#include<stdio.h>
using namespace std;

int main(){

	int T;
	cin>>T;
	bool visited[1007] = {false};
	while(T--){
		int N;
		cin>>N;
		if(visited[N%1007]==false){
			visited[N%1007]=true;
			cout<<N%1007<<endl;
		}
	}
	return 0;

}

#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int mod = 1e9+7;
ll power(ll x,ll y)
{
    ll temp;
    if( y == 0)
        return 1;
    temp = power(x, y/2);
    if (y%2 == 0)
        return (temp%mod * temp%mod)%mod;
    else
        return (x%mod * temp%mod * temp%mod)%mod;
}

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		ll k,s;
		cin>>k>>s;
		if(s%k==0)
			cout<<(power(s/k,k)%mod)<<"\n";
		else
		{
			ll rem=s%k;
			ll qu=s/k;
			//cout<<rem<<" "<<qu<<"\n";
			cout<<(power(qu+1,rem)%mod * power(qu,k-rem)%mod)<<"\n";
		}
	}
	return 0;
}
for cases in range(input()):
    n=input()
    nums=map(int,raw_input().split())
    print nums.index(max(nums))+1

import itertools

n = int(raw_input())
m = int(raw_input())
ls = range(1, n + 1)
op = list(itertools.combinations(ls, m))
for t in op:
	for x in t:
		print x,
	print
#include <bits/stdc++.h>
using namespace std;

int main() {
	int t;
	cin >>t;
	while(t--){
	    string num;
	    int k,l,i,r=0;
	    cin >>num;
	    cin >>k;
	    l=num.size();
	    
	    for(i=0;i<l;i++){
	        r=r*10+(num[i]-48);
	        if(r<k)
	            continue;
	        r=r%k;    
	    }
	    if(r==0)
	        cout <<"YES\n";
	    else
	        cout <<"NO\n";
	}
	return 0;
}

/*Author :rednivrug15 */
#pragma comment(linker,"/STACK:5677216")
#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define rep(i,n) for(int i=0; i<n ; i++)
using namespace std;
#define mod (int)((1e9)+7)
#define REP(i,n) for (int i = 1; i <= n; i++)

long long power(long long a,long long b)
{
    long long ret=1;
    while(b)
    {
        if(b%2==1)
            ret=(ret*a)%mod;
        a=(a*a)%mod;
        b/=2;
    }
    return ret;
}
long long gcd(long long a,long long b)
{
    return b==0?a:gcd(b,a%b);
}

#define N 500
double ans[N]={50.000000,57.735027,62.996052,66.874030,69.882712,72.302003,74.299714,75.983569,77.426368,78.679344,79.779740,80.755366,81.627464,82.412575,83.123790,83.771625,84.364637,84.909862,85.413150,85.879407,86.312781,86.716807,87.094517,87.448527,87.781110,88.094247,88.389679,88.668937,88.933377,89.184205,89.422493,89.649204,89.865201,90.071259,90.268082,90.456304,90.636504,90.809206,90.974890,91.133994,91.286920,91.434037,91.575684,91.712174,91.843796,91.970817,92.093485,92.212030,92.326664,92.437586,92.544982,92.649024,92.749873,92.847681,92.942588,93.034728,93.124224,93.211193,93.295746,93.377986,93.458010,93.535911,93.611774,93.685683,93.757715,93.827944,93.896439,93.963266,94.028487,94.092163,94.154350,94.215101,94.274467,94.332498,94.389239,94.444735,94.499028,94.552158,94.604164,94.655082,94.704948,94.753794,94.801653,94.848557,94.894533,94.939612,94.983818,95.027180,95.069721,95.111465,95.152437,95.192656,95.232146,95.270926,95.309016,95.346435,95.383202,95.419333,95.454846,95.489757,95.524081,95.557835,95.591032,95.623688,95.655814,95.687426,95.718534,95.749153,95.779293,95.808966,95.838184,95.866957,95.895296,95.923210,95.950710,95.977805,96.004504,96.030816,96.056750,96.082314,96.107517,96.132366,96.156869,96.181033,96.204865,96.228373,96.251564,96.274444,96.297019,96.319296,96.341280,96.362978,96.384396,96.405539,96.426412,96.447021,96.467371,96.487467,96.507314,96.526917,96.546280,96.565407,96.584304,96.602975,96.621423,96.639653,96.657668,96.675474,96.693073,96.710468,96.727665,96.744666,96.761475,96.778095,96.794529,96.810780,96.826853,96.842749,96.858471,96.874024,96.889408,96.904629,96.919687,96.934585,96.949327,96.963915,96.978351,96.992638,97.006777,97.020773,97.034626,97.048338,97.061913,97.075353,97.088658,97.101832,97.114877,97.127793,97.140584,97.153252,97.165797,97.178222,97.190529,97.202719,97.214794,97.226756,97.238607,97.250347,97.261979,97.273504,97.284924,97.296240,97.307453,97.318565,97.329578,97.340493,97.351310,97.362032,97.372660,97.383195,97.393638,97.403991,97.414255,97.424430,97.434518,97.444521,97.454439,97.464274,97.474026,97.483696,97.493287,97.502798,97.512230,97.521586,97.530865,97.540069,97.549198,97.558254,97.567237,97.576148,97.584989,97.593760,97.602462,97.611095,97.619661,97.628161,97.636594,97.644963,97.653267,97.661508,97.669686,97.677802,97.685857,97.693851,97.701786,97.709661,97.717478,97.725237,97.732939,97.740584,97.748173,97.755707,97.763187,97.770612,97.777985,97.785304,97.792571,97.799786,97.806951,97.814064,97.821128,97.828142,97.835108,97.842025,97.848894,97.855716,97.862491,97.869220,97.875902,97.882540,97.889132,97.895680,97.902184,97.908645,97.915062,97.921437,97.927769,97.934060,97.940310,97.946518,97.952686,97.958814,97.964903,97.970951,97.976962,97.982933,97.988866,97.994762,98.000620,98.006441,98.012226,98.017974,98.023686,98.029363,98.035004,98.040611,98.046182,98.051720,98.057223,98.062693,98.068130,98.073534,98.078905,98.084243,98.089550,98.094824,98.100067,98.105279,98.110460,98.115611,98.120731,98.125821,98.130881,98.135912,98.140913,98.145885,98.150829,98.155744,98.160631,98.165490,98.170321,98.175124,98.179901,98.184650,98.189373,98.194069,98.198738,98.203382,98.208000,98.212592,98.217158,98.221700,98.226216,98.230708,98.235175,98.239618,98.244036,98.248431,98.252802,98.257149,98.261473,98.265773,98.270051,98.274306,98.278538,98.282748,98.286936,98.291102,98.295245,98.299367,98.303468,98.307547,98.311605,98.315642,98.319658,98.323653,98.327628,98.331583,98.335517,98.339432,98.343326,98.347201,98.351056,98.354892,98.358708,98.362506,98.366284,98.370044,98.373785,98.377507,98.381211,98.384897,98.388565,98.392214,98.395846,98.399460,98.403057,98.406636,98.410198,98.413742,98.417270,98.420780,98.424274,98.427751,98.431212,98.434656,98.438084,98.441496,98.444891,98.448271,98.451635,98.454983,98.458315,98.461632,98.464933,98.468220,98.471491,98.474747,98.477988,98.481214,98.484425,98.487622,98.490804,98.493972,98.497126,98.500265,98.503390,98.506501,98.509598,98.512681,98.515751,98.518806,98.521849,98.524877,98.527893,98.530895,98.533884,98.536860,98.539822,98.542772,98.545709,98.548634,98.551545,98.554444,98.557330,98.560205,98.563066,98.565916,98.568753,98.571578,98.574391,98.577192,98.579982,98.582759,98.585525,98.588279,98.591022,98.593753,98.596473,98.599181,98.601878,98.604564,98.607239,98.609903,98.612556,98.615198,98.617829,98.620449,98.623059,98.625658,98.628246,98.630824,98.633391,98.635949,98.638495,98.641032,98.643558,98.646074,98.648581,98.651077,98.653563,98.656039,98.658506,98.660963,98.663410,98.665847,98.668275,98.670694,98.673103,98.675502,98.677893,98.680273,98.682645,98.685008,98.687361,98.689705,98.692041,98.694367,98.696684,98.698993,98.701293,98.703584,98.705866,98.708140,98.710405,98.712661,98.714909,98.717149,98.719380,98.721603,98.723817,98.726024,98.728222,98.730411,98.732593,98.734767,98.736933,98.739090,98.741240,98.743382,98.745516,98.747642,98.749760,98.751871,98.753974,98.756070,98.758158,98.760238,98.762311,98.764376};

int main()
{
    int T;
    cin >> T;

    while( T--)
    {
        int n;
        cin >> n;
        printf("%.6lf\n",ans[n-1]);
    }
    return 0;
}

//62.876998
//66.743663

#include <assert.h>
#include <memory.h>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++)
#define rep(i, n) FOR(i, 0, n)
#define CL(a, v) memset((a), (v), sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int, int> pii;

/*** TEMPLATE CODE ENDS HERE */

struct Point {
  int x, y;
  double p;
  Point() {
    x = y = 0;
    p = 0.0;
  }
  Point(int xx, int yy, int pp) {
    x = xx;
    y = yy;
    p = pp / 100.0;
  }
};

bool operator<(Point a, Point b) { return a.x * b.y < b.x * a.y; }

Point tab[1000007];

int main() {
#ifdef LOCAL_HOST
  freopen("input.txt", "r", stdin);
// freopen("output.txt","w",stdout);
#endif

  int n;
  scanf("%d", &n);
  rep(i, n) {
    int p1, p2, p3;
    scanf("%d%d%d", &p1, &p2, &p3);
    tab[i] = Point(p1, p2, p3);
  }

  sort(tab, tab + n);

  double area = 0;
  double ox = 0, oy = 0;
  rep(i, n) {
    area += tab[i].p * (ox * tab[i].y - oy * tab[i].x);
    ox += tab[i].p * tab[i].x;
    oy += tab[i].p * tab[i].y;
  }

  printf("%.9lf\n", -area);

#ifdef LOCAL_HOST
  printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC);
#endif

  return 0;
}

#include <assert.h>
#include <memory.h>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++)
#define rep(i, n) FOR(i, 0, n)
#define CL(a, v) memset((a), (v), sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int, int> pii;

/*** TEMPLATE CODE ENDS HERE */

int g[2000][64];
int not_used[64];

void solve() {
  int n;
  cin >> n;
  rep(i, n) {
    rep(x, 64) g[i][x] = 0;
    rep(j, n) {
      int x;
      cin >> x;
      if (x) {
        g[i][j >> 5] |= 1 << (j & 31);
      }
    }
  }
  int best_range = numeric_limits<int>::max();
  int best_city = -1;
  rep(i, n) {
    queue<int> q;
    vector<int> dist(n, std::numeric_limits<int>::max());
    rep(x, 64) not_used[x] = -1;
    q.push(i);
    not_used[i >> 5] ^= 1 << (i & 31);
    dist[i] = 0;
    while (!q.empty()) {
      int u = q.front();
      q.pop();
      int du = dist[u];
      rep(x, 64) {
        int interesting = not_used[x] & g[u][x];
        if (interesting) {
          rep(y, 32) {
            if ((interesting >> y) & 1) {
              int v = (x << 5) + y;
              dist[v] = du + 1;
              q.push(v);
            }
          }
          not_used[x] ^= interesting;
        }
      }
    }
    int max_dist = *std::max_element(all(dist));
    if (max_dist < best_range) {
      best_range = max_dist;
      best_city = i;
    }
  }
  if (best_city == -1) {
    cout << -1 << endl;
  } else {
    cout << best_range << ' ' << best_city + 1 << endl;
  }
}

void run() {
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}

int main() {
#ifdef LOCAL_HOST
  freopen("input.txt", "r", stdin);
// freopen("output.txt","w",stdout);
#endif

  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  run();
  cout.flush();

#ifdef LOCAL_HOST
  printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC);
#endif

  return 0;
}

#include <bits/stdc++.h>
using namespace std;

#define ms(s, n) memset(s, n, sizeof(s))
#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)
#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)
#define sz(a) int((a).size())
#define all(a) (a).begin(), (a).end()
#define uni(a) (a).erase(unique(all(a)), (a).end())
#define pb push_back
#define pf push_front
#define mp make_pair
#define fi first
#define se second
#define prec(n) fixed<<setprecision(n)
#define bit(n, i) ((n) & (1LL << (i)))
#define bitcount(n) __builtin_popcount(n)
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pi;
typedef vector<int> vi;
typedef vector<pi> vii;
#define EPS 1e-9
const int MOD = (int) 1e9 + 7;
const int INF = (int) 1e9;
const ll LINF = (ll) 1e18;
const ld PI = 2 * acos((ld) 0);
ll gcd(ll a, ll b) {ll r; while (b != 0) {r = a % b; a = b; b = r;} return a;}
ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}
ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}
void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}
void addmod(ll& a, ll val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}

const int maxn = 2010;
int n;
int a[maxn];
int b[maxn];
int x[maxn];
int c[maxn];
int sum[maxn][maxn];
int r[maxn];
int pw[maxn][maxn];
int rp[maxn][maxn];

void solve() {
	cin>>n;
	FOR(i, 1, n + 1) cin>>a[i];
	FOR(i, 1, n + 1) {
		x[i] = MOD - i;
		pw[i][0] = 1; rp[i][0] = 1; rp[i][1] = fpow(x[i], MOD - 2);
		FOR(j, 1, n + 1) {
			pw[i][j] = (ll) pw[i][j - 1] * x[i] % MOD;
			rp[i][j] = (ll) rp[i][j - 1] * rp[i][1] % MOD;
		}
	}
	c[0] = MOD - 1; c[1] = 1;
	FOR(i, 2, n + 1) {
		FORd(j, n + 1, 0) {
			c[j] = (ll) c[j] * x[i] % MOD;
			if (j) addmod(c[j], c[j - 1]);
		}
	}
	reverse(c, c + n + 1);
	FOR(i, 1, n + 1) {
		FOR(j, 0, n + 1) {
			if (j) sum[i][j] = sum[i][j - 1];
			int d = (ll) rp[i][j] * c[j] % MOD;
			if (!(j & 1)) addmod(sum[i][j], d);
			else addmod(sum[i][j], MOD - d);
		}
	}
	FOR(i, 1, n + 1) {
		FOR(j, 1, n + 1) {
			int d = (ll) pw[i][j] * sum[i][j - 1] % MOD;
			if (!(j & 1)) d = MOD - d;
			r[j] = (c[j] - d + MOD) % MOD;
		}
		reverse(r, r + n);
		r[n - 1] = 1;
		int C = 1;
		FOR(j, 1, n + 1) if (i != j) {
			C = (ll) C * (i - j + MOD) % MOD;
		}
		int tot = 0;
		FOR(j, 1, n + 1) addmod(tot, (ll) r[j - 1] * a[j] % MOD);
		b[i] = (ll) tot * fpow(C, MOD - 2) % MOD;
	}
	FOR(i, 0, n) {
		int res = 0;
		FORd(j, n + 1, 0) {
			res = ((ll) res * i + b[j]) % MOD;
		}
		cout<<res<<" ";
	}
}

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
#ifdef _LOCAL_
	freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout);
#endif
	solve();
#ifdef _LOCAL_
	//printf("\nTime elapsed: %dms", 1000 * clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}

#include <bits/stdc++.h>
using namespace std;
 
typedef long long LL;
 
#define PII       pair<LL,LL>
#define all(c)    c.begin(),c.end()
#define sz(c)     (int)c.size()
#define clr(c)    c.clear()
#define pb        push_back
#define mp        make_pair
#define cin(x)	scanf("%d" , &x)
#define MOD		1000000007
#define EPS       1E-10

LL BigMod(LL a,LL b,LL mod)
{
      if(!b) return 1;
      LL x = BigMod(a,b/2,mod);
      x = (x*x)%mod;
      if(b&1) return (x*a)%mod;
      else return x;
}

LL modinv(LL a,LL mod = MOD)
{
      return BigMod(a,mod-2,mod);
}


int main()
{
	LL n,k,m;
	cin >> n >> k >> m;
	if(n == 1 || k == 1)
		cout << m << endl;
	else if(k == 2)
	{
		LL ans = 2 * n - 1;
		ans *= m;
		ans %= MOD;
		cout << ans << endl;
	}
	else if(k == 3)
	{
		LL ans = 1LL * n * n + 1LL * (n - 1) * (n - 1);
		ans %= MOD;
		ans = (ans * m) % MOD;
		cout << ans << endl;
	}
	else if(k==4)
	{
		n -= 1;
		LL ans = (n*(n+1)) % MOD;
		ans = (ans * (4*n + 2)) % MOD;
		ans = (ans * modinv(3 , MOD)) % MOD;
		ans += (2*n+1);
		ans %= MOD;
		ans = (ans * m) % MOD;
		cout << ans << endl;
	}
	else
	{
		n -= 1;
		LL f = (n*n+n) % MOD;
		LL ans = (2 * f * f) % MOD;
		ans = (ans + 2 * f) % MOD;
		ans = (ans * modinv(3)) % MOD;
		ans = (ans + 2 * f + 1) % MOD;
		ans = (ans * m) % MOD;
		cout << ans << endl; 
	}
	return 0;
}
#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> 
using namespace __gnu_pbds;
using namespace std;
#define SF(x)	scanf("%d", &x)
#define PF(x)	printf("%d", x)
#define psp     printf(" ")
#define pnl     printf("\n")
#define pie     cout<<" # "<<endl
#define charint(c) ((c)-'0')
#define pii pair< int, int >
#define pb(x) push_back(x)
#define test int t; scanf("%d",&t);while(t--)
#define forall(i,a,b) for(int i=(a);i<=(b);++i)
#define NFOR(i,a,b) for(int i=(a);i>=(b);--i)
#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define gcd(a,b)   __gcd(a,b)
#define bss binary_search
#define ersort(x)       (sort((x).rbegin(), (x).rend()))
#define rev(v)      (reverse(v.begin(),v.end()))
#define vmax(v)     (*max_element(v.begin(),v.end()))
#define vmin(v)     (*min_element(v.begin(),v.end()))
#define MAX		100050
#define INF		1e9
#define mod     1000000007
#define fi first
#define se second
inline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }
typedef long long 		ll;
typedef unsigned long long	ull;
typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set;
inline int add(int a,int b, int m=mod){a+=b;if(a>=m)a-=m;return a;}
inline int mul(int a,int b, int m=mod){return (int)(((ll)a*(ll)b)%m);}
ll expo(ll base,ll pow){
    ll ans = 1;
    while(pow!=0){
        if(pow&1==1){
            ans = ans*base;
            ans = ans%mod;
        }
        base *= base;
        base%=mod;
        pow/=2;
    }
    return ans;
}
ll inv(ll x){
    return expo(x,mod-2);
}
int expFactor(int n, int p)
{
    int x = p;
    int exponent = 0;
    while ((n/x) > 0)
    {
        exponent += n/x;
        x *= p;
    }
    return exponent;
}
inline int countsetbit(int n)
{
    unsigned int count = 0;
    while (n)
    {
      n &= (n-1) ;
      count++;
    }
    return count;
}
inline int abs(int x){
	if(x<0)
	return -x;
	return x;
}
ll _sieve_size; 
bitset<10000010> bs; 
vector <int> primes; 
void sieve(ll upperbound) { 
	_sieve_size = upperbound + 1; 
	bs.set();
	bs[0] = bs[1] = 0;
	for (ll i = 2; i <= _sieve_size; i++) 
	if (bs[i]) {
		for (ll j = i * i; j <= _sieve_size; j += i) 
			bs[j] = 0;
		primes.push_back((int)i); 
	} 
} 
bool isPrime(ll N) {
if (N <= _sieve_size) return bs[N]; 
for (int i = 0; i < (int)primes.size(); i++)
if (N % primes[i] == 0) return false;
return true;
}
int n,m,val[MAX],wt[MAX];long double cv[MAX];
bool ck(long double mi){
	forall(i,0,n-1){
		cv[i]=val[i]-mi*wt[i];
	}
	sort(cv,cv+n,greater<long double>());
	long double tp=0;
	forall(i,0,m-1){
		tp+=cv[i];
	}
	return (tp>=0);
}
int main(){
	test{
		cin>>n>>m;
		forall(i,0,n-1)
		cin>>val[i]>>wt[i];
		long double lw=0,he=2e5,mi;
		while(he-lw>(1e-8)){
			mi=(lw+he)/2.0;
			if(ck(mi)){
				lw=mi;
			}
			else
			{
				he=mi;
			}
		}
		double as=(he+lw)/2.0;
		printf("%.8lf\n",as);
	}
} 
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
int ar[17];
ll dp[34000][1107];
int DV, K;
int n = 0;

int c = 1;
ll  f(int idx, int bmsk, int modulo) {

	if (idx == n) {
		if (modulo == K)
			return 1;
		else
			return 0;
	}
	if (dp[bmsk][modulo] != -1)
		return dp[bmsk][modulo];

	ll ans = 0;
	int xyar[10] = {0};

	for (int i = 0; i < n; i++) {
		if ( (bmsk & (1 << i)) == 0) {
			if (xyar[ar[i]] == 0) 
			{
				//cout <<ar[i]<<"^^"<<endl;
				//ll x = (modulo * 10 + ar[i]) % DV;

				ans += f ( idx+1, bmsk | (1 << i), (modulo * 10 + ar[i])%DV);
				xyar[ar[i]] = 1;
			}
		}
	}

	dp[bmsk][modulo] = ans;
	return ans;

}
int main()
{
	memset(dp, -1LL, sizeof(dp));
	ll  num;
	cin >> num >> DV >> K;
	
	if (num == 0) {
		if (K > 0) cout <<"0\n";
		else cout <<"1\n";
		return 0;
	}
	while (num > 0) {
		ar[n] = num % 10;
		num /= 10;
		n++;
	}
	cout <<f(0,0,0)<<endl;
	return 0;
}


#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 100000 + 10, K = 17, M = 1e9 + 7;

vector<int> G[MAXN];
int dep[MAXN], f[MAXN][K + 1];
int st[MAXN], ed[MAXN], loc[MAXN << 1];
int n, m, P, dfn;

void dfs(int x, int par = -1) {
  loc[st[x] = dfn++] = x;
  for (int i = 1; i <= K; ++i) f[x][i] = f[f[x][i - 1]][i - 1];
  for (auto &y: G[x]) if (y != par) {
    dep[y] = dep[f[y][0] = x] + 1;
    dfs(y, x);
  }
  loc[ed[x] = dfn++] = x;
}
int lca(int x, int y) {
  if (x == y) return x;
  if (dep[x] < dep[y]) swap(x, y);
  for (int i = K; ~i; --i) {
    if (dep[f[x][i]] >= dep[y]) x = f[x][i];
  }
  if (x == y) return x;
  for (int i = K; ~i; --i) {
    if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
  }
  return f[x][0];
}

int val[MAXN], inv[MAXN], vis[MAXN], sum;
int cnt[MAXN], mul[MAXN], ans[MAXN];
void deal(int x) {
  int c = val[x]; vis[x] ^= 1;
  sum += M - mul[c]; if (sum >= M) sum -= M;
  if (!vis[x]) {
    mul[c] = 1ll * mul[c] * inv[c] % M;
    if (--cnt[c] == 0) mul[c] = 0;
  }
  else {
    if (++cnt[c] == 1) mul[c] = 1;
    mul[c] = 1ll * mul[c] * c % M;
  }
  sum += mul[c]; if (sum >= M) sum -= M;
}

struct Node {
  int l, r, z, id;
  bool operator < (const Node &rhs) {
    return l / P == rhs.l / P ? r < rhs.r : l / P < rhs.l / P;
  }
} Q[MAXN];

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%d", val + i);
  for (int i = 1; i < n; ++i) {
    int u, v; scanf("%d%d", &u, &v);
    G[u].push_back(v);
    G[v].push_back(u);
  }
  dfs(dep[1] = 1);
  P = sqrt(n * 2);
  scanf("%d", &m);
  for (int i = 0; i < m; ++i) {
    int x, y; scanf("%d%d", &x, &y);
    if (st[x] > st[y]) swap(x, y);
    int z = lca(x, y); Q[i].id = i;
    if (z == x) Q[i].l = st[x], Q[i].r = st[y];
    else Q[i].l = ed[x], Q[i].r = st[y], Q[i].z = z;
  }
  sort(Q, Q + m);
  inv[1] = 1; sum = 0;
  for (int i = 2; i < MAXN; ++i) {
    inv[i] = LL(M - inv[M % i]) * (M / i) % M;
  }
  for (int i = 0, l = 0, r = -1; i < m; ++i) {
    if (r < Q[i].r) {
      for (++r; r <= Q[i].r; ++r) deal(loc[r]);
      --r;
    }
    for (; r > Q[i].r; --r) deal(loc[r]);
    for (; l < Q[i].l; ++l) deal(loc[l]);
    if (l > Q[i].l) {
      for (--l; l >= Q[i].l; --l) deal(loc[l]);
      ++l;
    }
    if (Q[i].z) deal(Q[i].z);
    ans[Q[i].id] = sum;
    if (Q[i].z) deal(Q[i].z);
  }
  for (int i = 0; i < m; ++ i) printf("%d\n", ans[i]);
  return 0;
}

/*Author :rednivrug15 */
#pragma comment(linker,"/STACK:5677216")
#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define rep(i,n) for(int i=0; i<n ; i++)
using namespace std;
#define mod (int)((1e9)+7)
#define REP(i,n) for (int i = 1; i <= n; i++)
 
long long power(long long a,long long b)
{
    long long ret=1;
    while(b)
    {
        if(b%2==1)
            ret=(ret*a)%mod;
        a=(a*a)%mod;
        b/=2;
    }
    return ret;
}
long long gcd(long long a,long long b)
{
    return b==0?a:gcd(b,a%b);
}
 
 
int main()
{
    int t;
    scanf("%d",&t);
 
    while(t--)
    {
        long long L;
        int n;
        scanf("%d %lld",&n,&L);
 
        vector < pair < long long, int > > coins(n);
        for( int i=0; i<n; i++ )
        {
            scanf("%lld",&coins[i].first);
            coins[i].second=i;
        }
 
        sort(coins.begin(),coins.end());
 
        if( coins[0].first!=1 )
        {
            printf("-1\n");
            continue;
        }
 
        vector < long long > ans(n,0);
        bool flag=false;
        long long sum=0;
 
        for( int i=0; i<n; ++i )
        {
            if( sum>=coins[i].first)
            {
                flag=true;
                break;
            }
            sum += coins[i].first;
            ans[coins[i].second]++;
 
            long long remaining;
 
            if( i!=n-1 )
                remaining=coins[i+1].first-sum-1;
            else
                remaining=L-sum;
 
            if( remaining>0 )
            {
                ans[coins[i].second] += (remaining+coins[i].first-1)/coins[i].first;
                sum += ((remaining+coins[i].first-1)/coins[i].first)*coins[i].first;
            }
        }
 
        if( flag==true || sum>L)
        {
            puts("-1");
            continue;
        }
 
        for( int i=0; i<n; i++)
            printf("%lld ",ans[i]);
        puts("");
    }
    return 0;
}
#include<bits/stdc++.h>
using namespace std;

int main()
{
   int N,K ;
   cin >> N >> K ;
   int A[1001] ;
   for(int i=0 ; i<N ; i++){
	   cin >> A[i] ;
   }
   sort(A,A+N) ;
   cout << A[K-1] ;
}


/* Author: Karlheinz Jung */
/* Compiler: Borland Turbo C 2.01 */
/* Computer: Rabbit 286 */
/* Problem: Spiral Chess (SC) */

#include <stdio.h>

#ifndef ONLINE_JUDGE
	#define siz 10
#else
	#define siz 110
#endif
#define MI(a,b) a<b?a:b

int N, Q;
int grid[siz][siz], qBlack[siz][siz], qWhite[siz][siz];
int dir[][2]= {{0,1},{1,0},{0,-1},{-1,0}};

int bQuery(int r1, int c1, int r2, int c2)
{
return qBlack[r1][c1]-qBlack[r1][c2+1]-qBlack[r2+1][c1]+qBlack[r2+1][c2+1];
}

int wQuery(int r1, int c1, int r2, int c2)
{
return qWhite[r1][c1]-qWhite[r1][c2+1]-qWhite[r2+1][c1]+qWhite[r2+1][c2+1];
}

int main()
{
int T, total, caseID=1, i, j, k, curDir, ii, jj, blackSum, whiteSum, r1, c1, r2, c2, sol1, sol2;

for(scanf("%d",&T); caseID<=T; caseID++)
	{
	scanf("%d", &N);
	total=N*N;
	i=j=curDir=0;
	memset(grid, -1, sizeof grid);
	for(k=0; k<total; k++)
		{
		scanf("%d",&grid[i][j]);
		ii=i+dir[curDir][0];
		jj=j+dir[curDir][1];
		if(ii<0||ii>=N||jj<0||jj>=N||grid[ii][jj]!=-1) curDir=(curDir+1)%4;
		i+=dir[curDir][0];
		j+=dir[curDir][1];
		}
	memset(qBlack,0,sizeof(qBlack));
	memset(qWhite,0,sizeof(qWhite));
	for(i=N-1; i>=0; i--)
		{
		blackSum=whiteSum=0;
		for(j=N-1; j>=0; j--)
			{
			if((i+j)%2)
				blackSum+=grid[i][j];
			else
				whiteSum+=grid[i][j];
			qBlack[i][j]=i==N-1?blackSum:qBlack[i+1][j]+blackSum;
			qWhite[i][j]=i==N-1?whiteSum:qWhite[i+1][j]+whiteSum;
			}
		}
	scanf("%d",&Q);
	printf("Case #%d:\n", caseID);
	for(k=0; k<Q; k++)
		{
		scanf("%d %d %d %d",&r1,&c1,&r2,&c2);
		sol1=wQuery(r1,c1,r2,c2);
		sol2=bQuery(r1,c1,r2,c2);
		printf("%d\n",MI(sol1,sol2));
		}
	printf("\n");
	}
return 0;
}

n=input()
s=map(int,raw_input().split())
s.sort(reverse=True)
print s[0],s[1]
#include<stdio.h>
#define mod 1000000009
void scanlong(unsigned long long &x){
    char c = getchar_unlocked();
    x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x= (x<<1)+ (x<<3) + c - '0';
        c=getchar_unlocked();
    }
}
void scanint(int &x){
    char c = getchar_unlocked();
    x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x= (x<<1)+ (x<<3) + c - '0';
        c=getchar_unlocked();
    }
}
unsigned long long a[3][3]={{0,0,1},{1,0,1},{0,1,0}};
void power(unsigned long long b){
    unsigned long long c[3][3];
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            c[i][j]=0;
        }
        c[i][i]=1;
    }
    while(b){
        if(b&1){
            unsigned long long temp[3][3]={0};
            for(int i=0;i<3;i++){
                for(int j=0;j<3;j++){
                    for(int k=0;k<3;k++){
                        temp[i][j]+=(a[i][k]*c[k][j])%mod;
                        temp[i][j]%=mod;
                    }
                }
            }
            for(int i=0;i<3;i++)
                for(int j=0;j<3;j++)
                    c[i][j]=temp[i][j];   
        }
        unsigned long long temp[3][3]={0};
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                for(int k=0;k<3;k++){
                    temp[i][j]+=(a[i][k]*a[k][j])%mod;
                    temp[i][j]%=mod;
                }
            }
        }
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                a[i][j]=temp[i][j];
            }
        }    
        b>>=1;
    }
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            a[i][j] =c[i][j];
}
int main(){
    int t;
    scanint(t);
    int f[5]={0,0,1,1,1};
    while(t--){
        a[0][0]=0;
        a[0][1]=0;
        a[0][2]=1;
        a[1][0]=1;
        a[1][1]=0;
        a[1][2]=1;
        a[2][0]=0;
        a[2][1]=1;
        a[2][2]=0;
        unsigned long long n;
        scanlong(n);
        if(n<5){
            printf("%d\n",f[n]);
        }
        else{
            unsigned long long c[3][3]={{0,0,1},{0,1,1},{1,1,1}};
            power(n-4);
            unsigned long long ans = (c[2][0] * a[0][2])%mod;
            ans+=(c[2][1] * a[1][2])%mod;
            ans%=mod;
            ans+=(c[2][2]*a[2][2])%mod;
            printf("%llu\n",ans%mod);
        }
    }
}
# your code goes here
from math import ceil, log
from sys import stdin, stdout
st = []
def getMid(s, e):
	return s + (e-s) / 2

def construct(st, arr, ss, se, si, type):
	if se == ss:
		if se%2 == type:
			st[si] = arr[ss]
		else:
			st[si] = 0
		return st[si]
	m = getMid(ss, se)
	st[si] = max(construct(st, arr, ss, m, si*2+1, type), construct(st, arr, m+1, se, si*2 + 2, type))
	return st[si]
		
def createSegTree(arr, type):
	st = [0] * (2 * (pow(2, int(ceil(log(len(arr))/log(2)))) - 1))
	construct(st, arr, 0, len(arr)-1, 0, type)
	return st
	
def getMaxUtil(st, ss, se, qs, qe, si):
	if qs <= ss and qe >= se:
		return st[si];
	if se < qs or ss > qe:
		return 0
	mid = getMid(ss, se)
	return max(getMaxUtil(st, ss, mid, qs, qe, 2 * si + 1),
    getMaxUtil(st, mid + 1, se, qs, qe, 2 * si + 2))

def getMax(st, n, qs, qe):
	if qs < 0 or qe > n-1 or qs > qe:
		return -1
	return getMaxUtil(st, 0, n-1, qs, qe, 0)
	
def updateUtil(st, ss, se, pos, val, si, type):
	if pos < ss or pos > se:
		return
	if ss == se:
		if pos%2 == type:
			st[si] = val
		return
	mid = getMid(ss, se)
	updateUtil(st, ss, mid, pos, val, 2*si+1, type)
	updateUtil(st, mid+1, se, pos, val, 2*si+2, type)
	st[si] = max(st[2*si+1], st[2*si+2])
	
def update(st, n, pos, val, type):
	updateUtil(st, 0, n-1, pos, val, 0, type)
	
n, q = map(int, stdin.readline().strip().split(' '))
arr = map(int, stdin.readline().strip().split(' '))
odd = createSegTree(arr, 1)
even = createSegTree(arr, 0)
while q:
	q -= 1
	c, l, r = map(int, stdin.readline().strip().split(' '))
	if c == 1:
		update(odd, n, l-1, r, 1)
		update(even, n, l-1, r, 0)
	else:
		stdout.write(str(getMax(odd, n, l-1, r-1) + getMax(even, n, l-1, r-1)) + "\n")
/*
 *  p.cpp
 *  Created on: Aug 1, 2016
 *  Author: Tarun Anand
 *  Copyright (c) 2016 Tarun Anand. All rights reserved.
 */
#include<bits/stdc++.h>
#include<sstream>
using namespace std;
#define mod 1000000007
#define all(v) v.begin(),v.end()
#define loop(i,a,b) for(i=a;i<b;i++)
#define revloop(i,a,b) for(i=a;i>=b;i--)
#define stloop(it,v) for(it=v.begin();it!=v.end();++it)
#define ii pair<int,int>
#define MP make_pair
#define pb push_back
#define ll long long int
#define fill(v,d) memset(v,d,sizeof(v))
#define c 100000
int main()
{  std::ios::sync_with_stdio(false);
   cin.tie(0);
   ll t,i,n;
   cin>>t;
   while(t--)
   { cin>>n;
     cout<<2*n-1<<endl;
   }
   return 0;
}

for i in xrange(input()):
     N=input()
     c=1
     S=2
     while c<N:
          if c%2!=0:
               S=(S*2)-1
          else:
               S=(S*2)+1
          c+=1
     print S

#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

int T,N,i;
long double A,D,t[10111],st[10111],Mv[10111];
long double EPS = 1e-6;

int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %Lf %Lf",&N,&A,&D);        
        for(i=0;i<N;i++)
        {
            scanf("%Lf %Lf",st+i,Mv+i);
            long double Sin = (Mv[i] * Mv[i]) / (2*A);
            if(Sin + EPS >= D)            
                t[i] = st[i] + sqrtl((2*D)/A);
            else
            {
                long double tin = Mv[i] / A;
                long double ta = (D - Sin) / Mv[i];
                t[i] = tin + ta + st[i];
            }
        }        
        for(i=1;i<N;i++)
        {
            t[i] = max(t[i],t[i-1]);
        }
        for(i=0;i<N;i++)
            printf("%Lf\n",t[i]);
    }
    
    return 0;
}
    

#include<bits/stdc++.h>
#define s(a) scanf("%lld",&a)
using namespace std;
typedef long long int LLD;
LLD t,n,m,a1,a2,b1,b2,MOD;
LLD p1[303][303],p2[303][303];
LLD modulo(LLD a,LLD b,LLD c){
    LLD x=1,y=a; // long long is taken to avoid overflow of intermediate results
    while(b > 0){
        if(b%2 == 1){
            x=(x*y)%c;
        }
        y = (y*y)%c; // squaring the base
        b /= 2;
    }
    return x%c;
}
inline LLD modexp(LLD a,LLD b)
{
	LLD ans=1;
	while(b)
	{
		if(b&1)
		{
			ans=(ans*a)%MOD;
			b--;
		}
		a = (a*a)%MOD;
		b=b/2;
	}  
	return ans%MOD;
}
LLD rowmax[303],colmax[303];
LLD rvalue[303][303];
int main()
{
	s(t);
	LLD i,j;
	while(t--)
	{
		s(n);
		s(m);
		s(a1);s(a2);s(b1);s(b2);s(MOD);
		for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
		{
			rvalue[i][j]=0;
			p1[i][j]=modulo((a1*i+a2*j)%MOD,(MOD-2),MOD);
			p2[i][j]=modulo((b2*i+b1*j)%MOD,(MOD-2),MOD);	
		}
		LLD temp;
		for(i=1;i<=n;i++)
		{
			temp=-1;
			for(j=1;j<=m;j++)
				if(p2[i][j]>temp)
					temp=p2[i][j];
			for(j=1;j<=m;j++)
				if(p2[i][j]==temp) rvalue[i][j]++;
		}
		for(i=1;i<=m;i++)
		{
			temp=-1;
			for(j=1;j<=n;j++)
				if(p1[j][i]>temp)
					temp=p1[j][i];
			for(j=1;j<=n;j++)
				if(p1[j][i]==temp) rvalue[j][i]++;
		}
		bool flag = 0;
		vector<pair<int,int> > v;
		int row[303]={0},col[303]={0};
		for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
		{
			if(!flag && rvalue[i][j]==2)
			{
				cout<<i<<" "<<j<<endl;
				flag=1;
				i=n;break;
			}
		}
		if(!flag)printf("-1\n");
	}
	return 0;
}

import java.io.*;
import java.math.*;
import java.util.*;
import java.lang.*;
 
class Main2{ 
 
	public static InputStream inputStream = System.in;
	public static OutputStream outputStream = System.out;
	public static FastReader in = new FastReader(inputStream);
	public static PrintWriter out = new PrintWriter(outputStream);
 
	public static void main(String[] args)throws java.lang.Exception{
		new Main2().run();
		out.close();
	}
	
	long MOD = 1000000003;
	
	boolean[] flag;
	int comps = 0;
	ArrayList<Integer>[] graph;
	int n;
	long[][] memo;
	
	void run()throws RuntimeException{
		int t = in.nextInt();
		for(int i=0; i<t; i++){
			n = in.nextInt();
			int m = in.nextInt();
			graph = new ArrayList[n];
			for(int j=0; j<n; j++){
				graph[j] = new ArrayList<Integer>();
			}
			for(int j=0; j<m; j++){
				int a = in.nextInt();
				int b = in.nextInt();
				graph[a].add(b-n);
			}
			int mask = (int)Math.pow(2, n)-1;
			memo = new long[n][(int)Math.pow(2, n)];
			for(int j=0; j<memo.length; j++){
				Arrays.fill(memo[j], -1);
			}
			out.println(ways(0, mask));
		}
	}
	
	long ways(int start, int mask){
//		System.out.println("called " + start + " " + Integer.toBinaryString(mask));
		if(start==n){
			return 1;
		}
		if(mask==0){
//			System.out.println("edge 0");
			return 0;
		}
		if(memo[start][mask] != -1){
			return memo[start][mask];
		}
		long ans = 0;
		for(Integer to : graph[start]){
			if((mask&(1<<to)) != 0){ // If girl can be taken
//				System.out.println("taken " + to);
				int newMask = (mask ^ (1 << to));  // take girl
				ans += ways(start+1, newMask);  // num ways
				ans %= 1000000003;
			}
		}
//		System.out.println("returning " + ans);
		memo[start][mask] = ans;
		return ans;
	}
}
 
class FastReader{
	private boolean finished = false;
 
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;
 
	public FastReader(InputStream stream){
		this.stream = stream;
	}
 
	public int read(){
		if (numChars == -1){
			throw new InputMismatchException ();
		}
		if (curChar >= numChars){
			curChar = 0;
			try{
				numChars = stream.read (buf);
			} catch (IOException e){
				throw new InputMismatchException ();
			}
			if (numChars <= 0){
				return -1;
			}
		}
		return buf[curChar++];
	}
 
	public int peek(){
		if (numChars == -1){
			return -1;
		}
		if (curChar >= numChars){
			curChar = 0;
			try{
				numChars = stream.read (buf);
			} catch (IOException e){
				return -1;
			}
			if (numChars <= 0){
				return -1;
			}
		}
		return buf[curChar];
	}
 
	public int nextInt(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		int res = 0;
		do{
			if(c==','){
				c = read();
			}
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		} while (!isSpaceChar (c));
		return res * sgn;
	}
 
	public long nextLong(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		long res = 0;
		do{
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		} while (!isSpaceChar (c));
		return res * sgn;
	}
 
	public String nextString(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		StringBuilder res = new StringBuilder ();
		do{
			res.appendCodePoint (c);
			c = read ();
		} while (!isSpaceChar (c));
		return res.toString ();
	}
 
	public boolean isSpaceChar(int c){
		if (filter != null){
			return filter.isSpaceChar (c);
		}
		return isWhitespace (c);
	}
 
	public static boolean isWhitespace(int c){
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
	private String readLine0(){
		StringBuilder buf = new StringBuilder ();
		int c = read ();
		while (c != '\n' && c != -1){
			if (c != '\r'){
				buf.appendCodePoint (c);
			}
			c = read ();
		}
		return buf.toString ();
	}
 
	public String nextLine(){
		String s = readLine0 ();
		while (s.trim ().length () == 0)
			s = readLine0 ();
		return s;
	}
 
	public String nextLine(boolean ignoreEmptyLines){
		if (ignoreEmptyLines){
			return nextLine ();
		}else{
			return readLine0 ();
		}
	}
 
	public BigInteger nextBigInteger(){
		try{
			return new BigInteger (nextString ());
		} catch (NumberFormatException e){
			throw new InputMismatchException ();
		}
	}
 
	public char nextCharacter(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		return (char) c;
	}
 
	public double nextDouble(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		double res = 0;
		while (!isSpaceChar (c) && c != '.'){
			if (c == 'e' || c == 'E'){
				return res * Math.pow (10, nextInt ());
			}
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		}
		if (c == '.'){
			c = read ();
			double m = 1;
			while (!isSpaceChar (c)){
				if (c == 'e' || c == 'E'){
					return res * Math.pow (10, nextInt ());
				}
				if (c < '0' || c > '9'){
					throw new InputMismatchException ();
				}
				m /= 10;
				res += (c - '0') * m;
				c = read ();
			}
		}
		return res * sgn;
	}
 
	public boolean isExhausted(){
		int value;
		while (isSpaceChar (value = peek ()) && value != -1)
			read ();
		return value == -1;
	}
 
	public String next(){
		return nextString ();
	}
 
	public SpaceCharFilter getFilter(){
		return filter;
	}
 
	public void setFilter(SpaceCharFilter filter){
		this.filter = filter;
	}
 
	public interface SpaceCharFilter{
		public boolean isSpaceChar(int ch);
	}
} 
#include<iostream>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<utility>
#include<sstream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<string>
#include<cctype>
#include<queue>
#include<deque>
#include<stack>
#include<cmath>
#include<ctime>
#include<list>
#include<map>
#include<set>
#define pi (acos(-1.0))
#define Abs(a) (((a)<0) ? (-(a)) :(a) )
#define rep(i,n) for((i)=0;(i)<(n);(i)++)
#define Rep(i,n) for(int i=0;i<(n);i++)
#define Rrep(i,n) for(int i=n-1;i>=0;i--)
#define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--)
#define Pii pair<int,int>
#define PB push_back
#define Size(x) ((int)(x.size()))
#define MIN(a,b) ((a)<(b) ? (a):(b))
#define MAX(a,b) ((a)>(b) ? (a):(b))
using namespace std;
typedef long long mint;
typedef unsigned long long umint;
char a[5001],b[5001];
int d[2][2][5005][5005];
int main()
{
    //freopen("in.txt","r",stdin);
    int t,T,sa,sb,k,mx,ka,kb;
    int i,j;
    scanf("%d",&T);
    for(t=1; t<=T; t++)
    {
        scanf("%d%d%d",&sa,&sb,&k);
        scanf("%s%s",a,b);
        if(k>min(sa,sb))
        {
            puts("-1");
            continue;
        }
        rep(ka,2)
        rep(kb,2)
        for(i=0; i<=sa; i++)
            for(j=0; j<=sb; j++)
            {
                if(ka*k>i||kb*k>j)
                {
                    d[ka][kb][i][j]=-1;
                    continue;
                }
                else
                    d[ka][kb][i][j]=0;
                if(i==0||j==0)
                    continue;
                if(a[i-1]==b[j-1])
                {
                    //cout<<"oria "<<d[ka][kb][i-1][j-1]<<endl;
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],(d[ka][kb][i-1][j-1]+1));
                }
                d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i][j-1]);
                d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i-1][j]);
                if(ka)
                {
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][kb][i-k][j]);
                }
                if(kb)
                {
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][0][i][j-k]);
                }
                if(ka&&kb)
                {
                    d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][0][i-k][j-k]);
                }
                //cout<<ka<<" "<<kb<<" "<<i<<" "<<j<<" "<<d[ka][kb][i][j]<<endl;
            }
        //cout<<d[1][1][sa][sb]<<endl;
        printf("%d\n",MAX(0,d[1][1][sa][sb]));
    }
    return 0;
}



#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <utility>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <sstream>
#define FOR(a,b,c) for (int a=b,_c=c;a<=_c;a++)
#define FORD(a,b,c) for (int a=b;a>=c;a--)
#define REP(i,a) for(int i=0,_a=(a); i<_a; ++i)
#define REPD(i,a) for(int i=(a)-1; i>=0; --i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define sz(a) int(a.size())
#define reset(a,b) memset(a,b,sizeof(a))
#define oo 1000000000000000007ll

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, int > plli;

const int maxn = 100007;


int main() {
	//freopen("test.txt","r",stdin);

	int qr;

	cin >> qr;

	for (int i1 = 0; i1 < qr; ++i1) {
		set<plli> myset;
		vector<pii> a[maxn];
		vector<int> list;
		bool free1[maxn];
		int n, m, t, trace[maxn];
		ll d[maxn];

		scanf("%d%d%d", &n, &m, &t);
		int u, v, w;
		REP(i, m) {
			scanf("%d%d%d", &u, &v, &w);
			a[u].pb(pii(v, w));
			a[v].pb(pii(u, w));
		}

		for (int i2 = 0; i2 < t; ++i2) {
			int rr;
			cin >> rr;
			reset(free1, 1);
			d[1] = 0;
			FOR(i, 2, n) d[i] = oo;
			myset.insert(pii(0, 1));
			while (!myset.empty()) {
				u = myset.begin()->se; myset.erase(myset.begin());
				free1[u] = 0;
				REP(i, sz(a[u])) {
					v = a[u][i].fi; w = a[u][i].se;
					if (free1[v] && d[v]>d[u] + w) {
						if (d[v] != oo) myset.erase(myset.find(plli(d[v], v)));
						d[v] = d[u] + w;
						trace[v] = u;
						myset.insert(plli(d[v], v));
					}
				}
			}

			if (d[rr] == oo) printf("-1\n");
			else {
				cout << d[rr] << endl;
			}
		}
	}

	
	//getch();
	return 0;
}
import sys


def euler_phi(x):
    i = 2
    factors = set([])
    ret = x
    while(i<=x):
        if (x%i == 0):
            factors.add(i)
            x = x / i
            i = 2
        else:
            i = i + 1
    #print factors
    for factor in factors:
        ret = (ret * (factor-1)) / factor
    return ret

t  = int(sys.stdin.readline())
for i in range(0,t):
    n = int(sys.stdin.readline())
    print euler_phi(n)
import sys

def main():

    store={'one':1, 'two':2, 'three':3, 'four': 4, 'five' : 5, 'six' : 6,
           'seven' : 7, 'eight' : 8, 'nine' : 9, 'zero' : 0}

    array=['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',
           'nine', 'zero']

    t=int(sys.stdin.readline())
    
    for i in range(t):
        
        word=raw_input().strip()
        expected=len(word)-1
        
        for j in array:
            if len(word)==len(j):
                match=sum(a==b for a, b in zip(j, word))
                if match==expected:
                    break
        print store[j]
main()

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#define mod 1000000007
void scanint(int &x){
    char c = getchar_unlocked();
    x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x= (x<<1)+ (x<<3) + c - '0';
        c=getchar_unlocked();
    }
}
int main(){
    unsigned long long a[105][105]={0};
    int n;
    scanint(n);
    n*=n;
    for(int i=1;i<n;i++){
        a[i][i+1]=1;
    }
    int q;
    scanint(q);
    while(q--){
        int x,y;
        scanint(x);
        scanint(y);
        a[x][y]=1;
    }
    int k;
    scanint(k);
    unsigned long long iden[101][101]={0};
    for(int i=0;i<101;i++){
        iden[i][i]=1;
    }
    while(k){
        if(k&1){
            unsigned long long temp[101][101]={0};
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    for(int k=1;k<=n;k++){
                        temp[i][j]+=a[i][k]*iden[k][j];
                        temp[i][j]%=mod;
                    }
                }
            }
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    iden[i][j]=temp[i][j];
                }
            }
        }
        unsigned long long temp[101][101]={0};
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                for(int k=1;k<=n;k++){
                    temp[i][j]+=a[i][k]*a[k][j];
                    temp[i][j]%=mod;
                }
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                a[i][j]=temp[i][j];
            }
        }
        k>>=1;
    }
    printf("%llu",iden[1][n]%mod);
}

x=input("")
y=raw_input("")
count=0
for i in y:
    if i==".":
        count+=1
print count

def fun(n):
    d=n*(n+1)/2
    return d
x=input("")
m=list()
for i in range(0,x,1):
    m.append(fun(input("")))
for i in m:
    print i

# Konrad Talik
T=input()
while T:
 n=input()
 while ((n%2)==0)and n>1:
  n/=2
 print int(n==1);T-=1

#Enter your code here
a=raw_input().split()
n=int(a[0])
q=int(a[1])
a=raw_input().split()
for i in xrange(n):
    a[i]=int(a[i])
hola=[0]
hola.append(a[0])
for i in range(1,n):
    a[i]+=a[i-1]
    hola.append(a[i])
#print hola
for i in xrange(q):
    ra=raw_input().split()
    l=int(ra[0])
    r=int(ra[1])
    #print hola[l-1],hola[r]
    print hola[n]+hola[l-1]-hola[r]
# cook your code here
T = int(raw_input())
for i in range(T):
    (n,m) = map(int,raw_input().split())
    if n<m:
        if n%2==0:
            print "L"
        else:
            print "R"
    elif m<n:
        if m%2==0:
            print "U"
        else:
            print "D"
    else:
        if n%2==0:
            print "L"
        else:
            print "R"
#include <cstdio>
using namespace std;
int pp[40100],i,j,x,T,n,k,ans,tot,pr[400],ct[400],cnt;
bool p[40100];
int phi(int x) {
    int ans=x;
    for (i=0;i<tot && pp[i]*pp[i]<=x;i++) if (x%pp[i]==0) {
        ans=ans/pp[i]*(pp[i]-1);
        while (x%pp[i]==0) x/=pp[i];
    }
    if (x!=1) ans=ans/x*(x-1);
    return ans;
}
int power(int a,int x) {
	long long s=a,ans=1;
	for (int i=0;x>>i;i++) {
		if ((x>>i)&1) ans=ans*s%(n+1);
		s=s*s%(n+1);
	}
	return ans;
}
void dfs(int dep,int res,int cur) {
    if (res>=ans) return;
    if (dep==cnt) {if (res!=1 && cur==1) ans=res;return;}
    for (int i=0;i<=ct[dep];i++) {
        dfs(dep+1,res,cur);
        res=res*pr[dep];
        cur=power(cur,pr[dep]);
    }
}
int main() {
    for (i=2;i<=40000;i++) if (!p[i]) {
        pp[tot++]=i;
        for (j=i;j<=40000;j+=i) p[j]=1;
    }
    for (scanf("%d",&T);T;T--) {
        scanf("%d%d",&n,&k);
        x=phi(n+1);ans=x;
        for (cnt=j=0;j<tot && pp[j]*pp[j]<=x;j++) if (x%pp[j]==0) {
            pr[cnt]=pp[j];ct[cnt]=0;
            while (x%pp[j]==0) x/=pp[j],ct[cnt]++;
            cnt++;
        }
        if (x!=1) pr[cnt]=x,ct[cnt]=1,cnt++;
        dfs(0,1,k);
        printf("%d\n",ans);
    }
}

#include <iostream>
#include <algorithm>
#include <functional>
#include <vector>
#include <limits.h>
#include <stdio.h>
#include <string>
#include <map>
#include <sstream>
using namespace std;
int n, t;
int a[200500];
int aux[200500];
int inv = 0;
void merge(int l, int m, int r) {
	for (int i = l; i <= r; i++)
		aux[i] = a[i];
	int lb = l, rb = r, mb = m;
	for (int i = lb; i <= rb; i++) {
		if (m + 1 > rb) {
			a[i] = aux[l];
			//printf("%d and %d in %d inv +\n", l, m + 1, i);
			l++;
			continue;
		}
		if (l > mb) {
			a[i] = aux[m + 1];
			//printf("%d and %d in %d \n", l, m + 1, i);
			m++;
			continue;
		}
		if (aux[l] > aux[m + 1]) {
			//printf("%d and %d in %d inv +\n", l, m + 1, i);
			inv += mb - l + 1;
			a[i] = aux[m + 1];
			m++;
		} else {
			a[i] = aux[l];
			//printf("%d and %d in %d\n", l, m + 1, i);
			l++;
		}
	}

}
void msort(int l, int r) {
	if (l >= r)
		return;
	int m = l + (r - l) / 2;
	msort(l, m);
	msort(m + 1, r);
	merge(l, m, r);
}
void solve() {
	inv = 0;
	for (int i = 0 ; i < 200000 ; i++) {
		a[i] = 0;
		aux[i] = 0;
	}
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	msort(1, n);
	printf("%d\n", inv);
}

int main() {
	scanf("%d", &t);
	for (int times = 1; times <= t; times++)
		solve();
	return 0;
}

#include<stdio.h>
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
    int t,n,m;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        printf("%.2f\n",(pow(2,n+1)-pow(2,m+1)));
    }

    return 0;
}

#include<iostream>
#include<string>
#include<algorithm>
#include<vector>
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
using namespace std;
#define mod 1000000007
#define size 200001

long long n, i, j, sum;
vector<long long> pos(size);
vector<long long> pi(size);

int main()
{
	int t;
	cin>>t;
	while(t--){
		cin>>n;
		for(i=0; i<n; ++i){
			cin>>pos[i];
		}
		for(i=0; i<n; ++i){
			cin>>pi[i];
		}
		sum=0;
		for(i=0; i< n-1; ++i){
			for(j=i+1; j<n; ++j){
				if(pi[i]>pi[j])
					sum = (sum + pi[i]*abs(pos[i]-pos[j]))%mod;
				else
					sum = (sum + pi[j]*abs(pos[i]-pos[j]))%mod;
			}
		}
		cout<<sum<<endl;
	}
	return 0;
}
#include<iostream>
using namespace std;
void merges(int arr[],int l,int m,int r)
{
 int i=0;int j=0;int k=l;
 int n1=m-l+1;
 int n2=r-m;
 int a[n1];
 int b[n2];
 for(int x=0;x<n1;x++)
        a[x]=arr[l+x];
 for(int x=0;x<n2;x++)
    b[x]=arr[m+1+x];
 while(i<n1&&j<n2)
 {
     if(a[i]<=b[j])
     {
        arr[k]=a[i];
        i++;
        }
        else{
            arr[k]=b[j];
            j++;
        }
        k++;
 }
 while(i<n1){
    arr[k]=a[i];
    i++;
    k++;
 }
 while(j<n2){
    arr[k]=b[j];
    j++;
    k++;
 }
}
void mergesort(int l,int r,int arr[])
{
 if(l<r)
 {
     int m=l+(r-l)/2;
     mergesort(l,m,arr);
     mergesort(m+1,r,arr);
     merges(arr,l,m,r);
 }
}
void print(int arr[],int n)
{
    for(int i=0;i<n;i++)
        cout<<arr[i]<<endl;
    cout<<endl;
}
int main()
{
    int n;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++)
        cin>>a[i];
    mergesort(0,n-1,a);
    print(a,n);
}

a = input()
l1 = []
for b in range(a):
    c = input()
    l1.append(c)
l1.sort()
for c in l1:
    print c
N=int(raw_input())
H=[int(num) for num in raw_input().split()]

S=[0 for i in xrange(len(H))]
def populateS(i):
    num=1
    minVal=10**9
    while(num<=i):
        val = abs(H[i]-H[i-num])+S[i-num]
        if val<minVal:
            minVal=val
        num = num*2
    return minVal

for i in xrange(1,len(H)):
    S[i] = populateS(i)
print S[-1]

import re
t=raw_input()
flag=1

if len(t)<5:
    flag=0
regex=re.compile('[a-z]')
if len(regex.findall(t))==0:
    flag=0
regex2=re.compile('[A-Z]')
if len(regex2.findall(t))==0:
    flag=0
regex3=re.compile('[0-9]')
if len(regex3.findall(t))==0:
    flag=0
if flag==1:
    print "YES"
else:
    print "NO"

t=input()
while t > 0 :
  n=input()
  if n==0 :
   print n
  else :
   x=(2*n - 1)/2
   y=(2*n -1)**2 + x
   print y
  t=t-1 
testcase = input()
for i in range(0, testcase):
	n, q = map(int, raw_input().split())
	s = raw_input()
	for j in range(0, q):
		c, t = raw_input().split()
		if(t == "even"):
			if(s.count(c)%2 == 0):
				print "yes"
			else:
				print "no"
		else:
			if(s.count(c)%2 == 1):
				print "yes"
			else:
				print "no"
t=int(raw_input())
while t:
	t-=1
	a=raw_input()
	b=raw_input()
	b=b+b
	if a in b: print 'YES'
	else: print 'NO'
#include<bits/stdc++.h>
using namespace std;
 
#define ll long long int
#define mp make_pair
#define pb push_back
#define s(n) scanf("%d",&n);
#define sl(n) scanf("%lld",&n);
#define p(n) printf("%d\n",n)
#define pl(n) printf("%lld\n",n)
 int a[111111];
 class node{
 
	public:
	
 	bool ap;
 	int d;
 	int l;
 	int r;
 	int size;
 		node(){}
 		node(int x){
 			ap=1;
 			d=0;
 			l=r=x;
 			size=1;
 		}
 };
 
 class tree{
 	node tt[4*100000+15];
 	public:
 		tree(){};
 		void build(int s,int e,int idx );
 		node init(int x);
 		node combine(node x,node y);
 		void update(int s,int e,int idx, int id,int x);
 		node query(int s,int e,int idx,int i,int j);
 };
 
 node tree:: init(int x){
 	node t(x);
 	return t;
 }
 node tree:: combine(node x,node y){
 	node t;
 	if(x.size==1&&y.size==1){
 		t.ap=1;
 		t.d=y.l-x.r;
 	}
 	else if(x.size==1&&y.size!=1){
 		t.ap=(y.l==x.r+y.d);
 		t.d=t.ap?y.d:0;
 	}
 	else if(x.size!=1&&y.size==1){
 		t.ap=(y.l==x.r+x.d);
 		t.d=t.ap?x.d:0;
 	}
 	else{
 		t.ap=x.ap&&y.ap&&(y.l==x.r+x.d&&x.d==y.d);
 		t.d=t.ap?x.d:0;
 	}
 	t.l=x.l;
 	t.r=y.r;
 	t.size=x.size+y.size;
 	return t;
 }
void tree:: build(int s,int e,int idx){
	if(s==e){
		tt[idx]=init(a[s]);
		return ;
	}
	int m=(s+e)>>1;
	int l=(idx<<1)+1;
	int r=l+1;
	build(s,m,l);
	build(m+1,e,r);
	tt[idx]=combine(tt[l],tt[r]);
}
void  tree:: update(int s,int e,int idx,int id,int x)
{
    if(s>e||id>e||id<s)return;
    if(s==e&&s==id)
    {
        tt[idx]=init(x);
        return;
    }
    int m=(s+e)>>1;
	int  l=(idx<<1)+1;
	int r=l+1;
    update(s,m,l,id,x);
    update(m+1,e,r,id,x);
    tt[idx]=combine(tt[l],tt[r]);
}
node tree:: query(int s,int e,int idx,int i,int j){
	if(s>=i&&e<=j)
		return tt[idx];
	int m=(s+e)>>1;
	int l=(idx<<1)+1;
	int r=l+1;
	if(m<i)
		return query(m+1,e,r,i,j);
	if(m>=j)
		return query(s,m,l,i,j);
	return combine(query(s,m,l,i,j),query(m+1,e,r,i,j));
}
 
 
int main(){
	tree t;
	int n;
	cin>>n;
	int i,j;
	for(i=0;i<n;i++)
		cin>>a[i];
	t.build(0,n-1,0);
	int q;
	cin>>q;
	while(q--){
		int ty;
		int i,j;
		cin>>ty>>i>>j;
		if(ty){
			node tt=t.query(0,n-1,0,i-1,j-1);
			cout<<tt.ap<<endl;
		}
		else{
			i--;
			a[i]=j;
			t.update(0,n-1,0,i-1,j);
		}
	}
} 
def getAns(x,M):
    a=1
    b=x
    while b!=1:
        c=M/b
        a*=c
        a%=M
        b*=c
        b%=M
        if b>M/2:
            a=M-a
            b=M-b
    return a
t=int(input())
for i in range(t):
    n,p=map(int,raw_input().split())
    if n<p:
        f=1
        i=p-1
        while i>n:
            f=(f*i)%p
            i-=1
        r=p-1
        print (r*getAns(f,p))%p
    else:
        print "0"

from sys import stdin,stdout

for i in xrange(int(stdin.readline().strip())):
    string = stdin.readline().strip()
    d = int(stdin.readline().strip())
    length = len(string)
    
    stdout.write(string[d-1:])
    
    if d % 2 == 0 and length % 2 == 1:
        stdout.write(string[:d-1])
    elif d % 2 == 0 and length % 2 == 0:
        stdout.write(string[:d-1][::-1])
    elif d % 2 == 1 and length % 2 == 1:
        stdout.write(string[:d-1][::-1])
    else:
        stdout.write(string[:d-1])
        
    print
/*
   Ashutosh Singla <ashu1461@gmail.com>
Algorithm:
#tags:
date: Sat Oct 19 23:47:28 IST 2013
 */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<algorithm>

using namespace std;
typedef vector<int> vi; 
typedef pair<int,int> ii;
typedef long long LL;
#define FL(a) memset(a, 0, sizeof a);
#define fill(a,v,N) memset(a, v, sizeof(a[0])*N)
#define sz(a) int((a).size()) 
#define pb push_back 
#define si(n) scanf("%d",&n)
#define sin(n) scanf("%d\n",&n) // for scanning strings ..
#define sill(n) scanf("%lld",&n)
#define pi(n) printf("%d\n",n);
#define pill(n) printf("%lld\n",n);
#define pis(n) printf("%d ",n);

#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())  // map and set find .. 
#define cpresent(c,x) (find(all(c),x) != (c).end())  // stl find ..
#define FREP(b) for(int i=0;i<b;i++)
#define FREPr(b) for(int i=b-1;i>=0;i--)
#define REP(a,b,c) for(int a=b;a<c;a++)
#define REPr(a,b,c) for(int a=b;a>b;a--)
#define mp(a,b) make_pair(a,b);
typedef pair<int, int> ii;
#define MAX_S 100007
/*
   struct data{
   };
   bool operator < (const data &a1, const data &a2){
   }
 */
double dp[2508][1300];
double recursion(int T, int k){
    if(k > T/2 || k < 0 || T<0) return -1.00; 
    if(k == T/2) return k;
    if(dp[T][k]!=-1.00) return dp[T][k];

    double P1 = (double)(k)/(double)(T-k);
    double P2 = (double)(1.0-P1)*(1.0/(double)(T-k-1.0));
    double P3 = (double)k*P2;
    double P4 = (double)(1.0-P1)*(double)(1.0-1.0/(T-k-1.0)-(1.0)*k/(T-k-1.0));
    //    printf("here for t .. %d %d %lf %lf %lf %lf\n",T,k,P1,P2,P3,P4).. 
    dp[T][k] = P1*(1.0 + recursion(T-2, k-1))+ // case: any known card
        P2*(1.0 + recursion(T-2, k))+ // case: both new + both matching
        P3*(2.0 + recursion(T-2, k))+   // case: one new + prev known card
        P4*(1.0 + recursion(T, k+2));   // case : none of the above
//    printf("%lf\n", P4);
    return dp[T][k];
}
int main()
{
    int a,b;
    FREP(2508){
        REP(j,0,1300){ dp[i][j] = -1.00;
        }
    }
    dp[0][0] = 0;
    while(scanf("%d %d",&a, &b)!=EOF){
        printf("%.4lf\n", recursion(a*b, 0));
    }
    return 0;
}


#include<iostream>
#include<stdio.h>

using namespace std ;
int main()
{
	int i=0 ;
	while(1){	int N ;
		int a[100],move=0,sum=0 ;
		
		//scanf("%d",&x) ;
		scanf("%d",&N);
		if(N==0)
		break ;
		for(int j=0 ;j<N ;j++)
		a[j]=0 ;
		for(int j=0 ; j<N ; j++)
		 {
		 scanf("%d",&a[j]) ;
		 sum+=a[j]; 
		 }
		 sum=sum/N ;
		 for(int j=0 ; j<N ; j++)
		 {
		 if(a[j]>(sum))
		 move+=a[j]-sum;
		 else
		 move+=sum-a[j] ;	
		 }
		 i++ ;
		 printf("Set #%d\n",i) ;
		 printf("The minimum number of moves is %d.\n\n",move/2) ;
	}
	
return 0 ;
	
}

#include<bits/stdc++.h>
using namespace std;
#define llt unsigned int
int main()
{
	unsigned int x;
	cin>>x;
	llt even_bits = x & 0xAAAAAAAA; 
	llt odd_bits = x & 0x55555555; 

	even_bits >>= 1; 
	odd_bits <<= 1; 

	 cout<<(even_bits | odd_bits)<<endl; 
	return 0;
}

#include <bits/stdc++.h>

using namespace std;

int main() {

    int t;
    scanf("%d",&t);

    while (t--) {
        int n,m;
        scanf("%d%d",&n,&m);
        int mini = min(n,m);
        if (mini&1)
            printf("Rohan\n");
        else
            printf("Kshitij\n");
    }


    return 0;
}

#include<bits/stdc++.h>

using namespace std;

int val[20],a[20][20],d[20],fin;

void dfs(int r, int n, int ans, int mask){
          int i;
          mask|=1<<r;

          ans+=d[r];
          for(i=1;i<=n;i++){
                if(a[r][i]==1){
                     if((mask&(1<<i))==0)
                     dfs(i,n,ans,mask);

                }
          }
        fin=max(ans,fin);

}

int main(){


          int t;
          cin>>t;
          while(t--){
                  memset(a,0,sizeof(a));
                  memset(d,0,sizeof(d));
                  fin=0;
                  memset(val,0,sizeof(val));
                  int n,i,j,op=-1;
                  cin>>n;
                  for(i=1;i<=n;i++)
                    cin>>d[i];
                  for(i=1;i<=n;i++)
                    for(j=1;j<=n;j++)
                      cin>>a[i][j];
                  for(i=1;i<=n;i++){



                      dfs(i,n,0,0);

                  }

                  cout<<fin<<endl;

          }


}

#Enter your code here
a = input()
for b in range(a):
	c = input()
	if c % 26== 0:
		print c/26
	elif (c % 26) == c:
		print 1
	else:
		print (c/26)+1
		

/*
TEEPA HAIN 
DEKH RAHA HUN KUCH CHEEZE
-----------------------------------------------------------------------------
Author :            ---------------------------------------------------------
    UTKAR$H $AXENA  ---------------------------------------------------------
    IIT INDORE      ---------------------------------------------------------
-----------------------------------------------------------------------------
*/
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
#define fre 	freopen("0.in","r",stdin),freopen("0.out","w",stdout)
#define MOD 1000000007
#define lld signed long long int
#define scanll(x) scanf("%lld",&x)
#define printll(x) printf("%lld\n",x)
#define boost ios_base::sync_with_stdio(0)
//vector<int> g[2*100000+5];int par[2*100000+5];
#define MX 600000+5
lld F[MX];
lld G[MX];
lld A[MX];

lld sF[MX][21];
bool flag_sF[MX][21];
lld sG[MX][21];
bool flag_sG[MX][21];

lld rec1(int mask,int i){
	if(i==-1){
		return G[mask];
	}
	if(flag_sF[mask][i])
		return sF[mask][i];

	flag_sF[mask][i] = 1;
	sF[mask][i] = rec1(mask,i-1);
	if(mask&(1<<i)){
		sF[mask][i] = (sF[mask][i] + rec1(mask^(1<<i),i-1))%MOD;
	}
	return sF[mask][i];
}
lld rec2(int mask,int i){
	if(i==-1){
		return (F[mask]*F[mask])%MOD;
	}
	if(flag_sG[mask][i])
		return sG[mask][i];

	flag_sG[mask][i] = 1;
	sG[mask][i] = rec2(mask,i-1);
	if(mask&(1<<i)){
		sG[mask][i] = (sG[mask][i] + rec2(mask^(1<<i),i-1))%MOD;
	}
	return sG[mask][i];
}
int main()
{
	//fre;
	int N;
	cin>>N;
	assert(N<=600000);
	for(int i=0;i<N;++i){
		scanll(A[i]);
		assert(1<=A[i] and A[i]<=1000000000);
	}
	for(int i=0;i<N;++i){
		F[i] = (A[i]*A[i] + rec1(i,20)*rec1(i,20)) % MOD;
		G[i] = (rec2(i,20)) % MOD;
		for(int j=0;j<=20;++j){
			flag_sF[i][j] = 0;
		}
		for(int j=0;j<=20;++j){
			flag_sG[i][j] = 0;
		} 
		rec1(i, 20);
		G[i] = (rec2(i,20)) % MOD;
		
	}
	lld ans = 0;
	for(int i=0;i<N;++i){
		ans = (ans+((i*F[i])%MOD)*G[i])%MOD;
	}
	printll(ans);
}

#include <bits/stdc++.h>
using namespace std;

#if !ONLINE_JUDGE
#include "debug.h"
#else
#endif

typedef long long int LL;
typedef unsigned long long LLU;
typedef long double LD;

#define INF 1500000000000000000LL
#define MOD 1000000007
#define F first
#define S second
#define PB push_back
#define MK make_pair
#define LEN(vale) strlen(vale)
#define SZ(vale) (int)vale.size()
#define SQ(A) ((A)*(A))
#define FI(i,fa,fb) for(int i=fa;i<fb;++i)
#define FD(i,fa,fb) for(int i=fa;i>fb;--i)
#define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) 
#define bits(vale) __builtin_popcount(vale)
#define VT vector

#define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val;
#define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val;

#define ALL(a) a.begin(),a.end()
#define LB (lower_bound)
#define UB (upper_bound)

#define SI(vale) scanf("%d",&vale)
#define PI(vale) printf("%d\n",vale)
#define PIS(vale) printf("%d ",vale)
#define SL(vale) scanf("%lld",&vale)
#define PL(vale) printf("%lld\n",vale)
#define PLS(vale) printf("%lld ",vale)
#define SS(vale) scanf("%s",vale)
#define PS(vale) printf("%s\n",vale)
#define SLD(vale) scanf("%Lf",&vale)
#define PLD(vale) printf("%0.12Lf\n",vale)
#define NL printf("\n")
#define TCS() int testcase; SI(testcase);while(testcase--) 

typedef pair<int,int> PR;
bool deb = false;
const int N = 1000011;
int n,k;
char a[N];
char pattern[N],text[N];   
int lenp,lent; 
int F[N],match;

void build_fail() {
     F[0] = F[1] = 0;
     for(int i=2;i<=lenp;i++){
          int j = F[i-1];
          while(1) {
               if(pattern[j] == pattern[i-1]) {
                    F[i] = j+1; break;
               }
               if(j == 0) {
                    F[i] = 0;  break;
               }
               j = F[j];
          }
     }
}

void kmp() {
     build_fail();
     int i = 0,j = 0;
     while(1) {
          if(j == lent) break;
          if(text[j] == pattern[i]) {
               i++,j++;
               if(i == lenp)
                    match++;
          }
          else if(i > 0) i = F[i];
          else j++;
     }
}

bool f(LL v){
     FI(i,0,v) pattern[i] = text[i];
     pattern[v] = '\0';
     lenp = v;
     match = 0;
     kmp();
     if(match >= k) return 1;
     return 0;
}

LL bs(LL lo,LL hi){
       LL ans = -1;
       while(lo < hi){
              LL mid = lo + (hi-lo)/2;
              if(f(mid))
                     lo = mid + 1,ans = mid;
              else
                     hi = mid;
       }
       return ans;
}

int main(){
     //clock_t tStart = clock();
     int t;
     //TCS(){
     SI(lent);
     SS(text);
     SI(k);
     int ans = (bs(0,lent+3));
     if(ans == -1) ans = 0;
          PI(ans);
          FI(i,0,ans)
               printf("%c",text[i]); NL;
     //exectime();
     return 0; 
}



import sys 
t=int(input())
while t>0:
	A=list(raw_input())
	B=list(raw_input())
	C=list(set(B))
	D=[]
	F=[]
	Arr=[]
	for i in xrange(len(C)):
		D.append(A.count(C[i]))
		F.append(B.count(C[i]))
		Arr.append(D[i]/F[i])
	print min(Arr)
	t=t-1
from sys import stdin

class Trie:
        def __init__(self):
                self.nextL = [-1] * 300000
                self.nextR = [-1] * 300000
                self.sizeL = [0] * 300000
                self.sizeR = [0] * 300000
                self.hash = 1
        
        def insert(self, no):
                node = 0
                for bit in xrange(17, -1, -1):
                        i = no & 1 << bit != 0
                        nexT = self.nextL if i == 0 else self.nextR
                        size = self.sizeL if i == 0 else self.sizeR
                        if nexT[node] == -1:
                                nexT[node] = self.hash
                                self.hash += 1
                        size[node] += 1
                        node = nexT[node]
        
        def query(self, no, k):
                if k >= 1 << 17:
                        return self.sizeL[0] + self.sizeR[0]
                node, count = 0, 0
                for bit in xrange(17, -1, -1):
                        i = no & 1 << bit != 0
                        j = k  & 1 << bit != 0
                        if node == -1:
                                return count
                        if j == 1:
                                count += self.sizeL[node] if i == 0 else self.sizeR[node]
                        node = self.nextL[node] if (i ^ j) == 0 else self.nextR[node]
                return count
        
lines = iter(stdin.readlines())
for tc in xrange(int(next(lines))):
        N, K = map(int, next(lines).split())
        A = list(map(int, next(lines).split()))
        trie = Trie()
        trie.insert(0)
        xorPrefix = 0
        ans = 0
        for a in A:
                xorPrefix ^= a
                ans += trie.query(xorPrefix, K)
                trie.insert(xorPrefix)
        print ans
t = int(raw_input())

for x in range(t):
	inputs = raw_input()
	inputs = inputs.split(" ")
	m = int(inputs[0])
	n = int(inputs[1])

	city_array = []
	for x in range(m):
		temp = raw_input()
		temp = temp.split(" ")
		city_array.append(temp)


	for x in range(m):
		for y in range(n):
			if city_array[x][y] == '1':
				city_array[x][y] = 1
			else:
				city_array[x][y] = 0

	for x in range(1,m):
		for y in range(1,n):
			if city_array[x][y] == 1:
				city_array[x][y] = min(city_array[x-1][y],city_array[x][y-1],city_array[x-1][y-1]) + 1
			else:
				city_array[x][y] = 0

	max_length = 0
	for x in range(m):
		for y in range(n):
			if city_array[x][y] > max_length:
				max_length = city_array[x][y]

	print(max_length)

#include <bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define upperlimit 1000100
#define INF 1000000000
#define INFL 1000000000000000000
#define eps 1e-8
#define endl '\n'
#define sd(n) scanf("%d",&n)
#define slld(n) scanf("%lld",&n)
#define pd(n) printf("%d",n)
#define plld(n) printf("%lld",n)
#define pds(n) printf("%d ",n)
#define pllds(n) printf("%lld ",n)
#define pdn(n) printf("%d\n",n)
#define plldn(n) printf("%lld\n",n)
#define REP(i,a,b) for(i=a;i<=b;i++)
#define mp make_pair
#define pb push_back
#define pcc pair<char,char>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define F first
#define S second

using namespace std;

ll gcd(ll n1,ll n2){
	if(n1%n2==0)return n2;
	return gcd(n2,n1%n2);
}
ll powmod(ll base,ll exponent)
{
	ll ans=1;
	while(exponent){
		if(exponent&1)ans=(ans*base)%mod;
		base=(base*base)%mod;
		exponent/=2;
	}
	return ans;
}
int arr[upperlimit+1];
vector <int> factors[upperlimit+1];
bool prime[upperlimit+1];
int mobius[upperlimit+1];
int f[upperlimit+1];
int g[upperlimit+1];
int cnt[upperlimit+1];
int dp[upperlimit+1];
ll fn(ll n){
	return (powmod(2,n)-1+mod)%mod;
}
int main()
{
	int n,q,x,y,i,j,k,t;
	for(i=2;i*i<=upperlimit;i++)if(!prime[i])for(j=i*i;j<=upperlimit;j+=i)prime[j]=true;
	for(i=1;i<=upperlimit;i++){
		mobius[i]=1;
		for(j=i;j<=upperlimit;j+=i)factors[j].pb(i);
	}
	for(i=2;i*i<=upperlimit;i++)if(!prime[i])for(j=i*i;j<=upperlimit;j+=i*i)mobius[j]=0;
	for(i=2;i<=upperlimit;i++)if(!prime[i])for(j=i;j<=upperlimit;j+=i)mobius[j]*=-1;
	for(i=2;i<=upperlimit;i++)if(!prime[i])for(ll j1=i;j1<=upperlimit;j1*=i)f[j1]=1;
	for(i=1;i<=upperlimit;i++)if(mobius[i]!=0)for(j=i;j<=upperlimit;j+=i)g[j]=(mod+g[j]+mobius[i]*f[j/i])%mod;
	sd(t);
	while(t--){
		ll answer=0,temp;
		for(i=0;i<=upperlimit;i++){
			arr[i]=0;
			cnt[i]=0;
			dp[i]=0;
		}
		sd(n);
		sd(q);
		for(i=1;i<=n;i++){
			sd(arr[i]);
			cnt[arr[i]]++;
		}
		for(i=1;i<=upperlimit;i++)for(j=i;j<=upperlimit;j+=i)dp[i]+=cnt[j];
		for(i=1;i<=upperlimit;i++){
			temp=(fn(dp[i])*g[i])%mod;
			answer+=temp;
			if(answer>=mod)answer-=mod;
		}
		while(q--){
			sd(x);
			sd(y);
			for(i=0;i<factors[arr[x]].size();i++){
				j=factors[arr[x]][i];
				dp[j]--;
				temp=(mod-powmod(2,dp[j]))%mod;
				temp=(temp*g[j])%mod;
				answer+=temp;
				if(answer>=mod)answer-=mod;
			}
			arr[x]=y;
			for(i=0;i<factors[arr[x]].size();i++){
				j=factors[arr[x]][i];
				temp=(mod+powmod(2,dp[j]))%mod;
				temp=(temp*g[j])%mod;
				dp[j]++;
				answer+=temp;
				if(answer>=mod)answer-=mod;
			}
			plldn(answer);
		}
	}
	return 0;
}

#include<bits/stdc++.h>
using namespace std;
# define l long int
int main()
{
	string s("1");
	s.resize(5911116);
	l j=0;
	l t;
	string k;
	l n;
	for(l i=1;i<=1000000;i++)
	{
		if(i/10==0) {s.at(j)=i+'0'; j++;}
		else if(i/100==0){
			s.at(j)=i/10 +'0';
			j++;
			s.at(j)=i%10+'0';
			j++;
		}
		else if(i/1000==0)
		{
			s.at(j)=i/100+'0';
			j++;
			s.at(j)=(i%100)/10+'0';
			j++;
			s.at(j)=(i%10)+'0';
			j++;
		}
		else if(i/10000==0)
		{
			s.at(j)=i/1000+'0';
			j++;
			s.at(j)=(i%1000)/100+'0';
			j++;
			s.at(j)=(i%100)/10+'0';
			j++;
			s.at(j)=(i%10)+'0';
			j++;
		}
		else if(i/100000==0)
		{
			s.at(j)=i/10000+'0';
			j++;
			s.at(j)=(i%10000)/1000+'0';
			j++;
			s.at(j)=(i%1000)/100+'0';
			j++;
			s.at(j)=(i%100)/10+'0';
			j++;
			s.at(j)=(i%10)+'0';
			j++;	
		}
		else if(i/1000000==0)
		{
			s.at(j)=i/100000+'0';
			j++;
			s.at(j)=(i%100000)/10000+'0';
			j++;
			s.at(j)=(i%10000)/1000+'0';
			j++;
			s.at(j)=(i%1000)/100+'0';
			j++;
			s.at(j)=(i%100)/10+'0';
			j++;
			s.at(j)=(i%10)+'0';
			j++;	
		}
		else if(i==1000000)
		{
			s.at(j)=1+'0'; j++;
			for(int r=0;r<6;r++)
			{
				s.at(j+r)=0+'0';
			}
		}
	}
	//cout<<s<<"\n";
	cin>>t;
	while(t--){
		cin>>n>>k;
		//int len=strlen(n);
		l r;
		//cout<<len<<"\n";
		/*switch(len)
		{
			case 1: r=atoll(n); break;
			case 2: r=(atoll(n)-5)*2 +1; break;
			case 3: r=(atoll(n)-37)*3 +3; break;
			case 4: r=(atoll(n)-278)*4 +5; break;
			case 5: r=(atoll(n)-2222)*5 +4; break;
			case 6: r=(atoll(n)-14815)*6 +5; break;
			case 7: r=5911116;
		}*/
		if(n/10==0) r=n;
		else if(n/100==0) r=(n-5)*2+1;
		else if(n/1000==0) r=(n-37)*3 +3;
		else if(n/10000==0) r=(n-278)*4 +5;
		else if(n/100000==0) r=(n-2222)*5+4;
		else if(n/1000000==0) r=(n-18519)*6+9;
		else r=5911116;
		string a=s.substr(0,r);
		//cout<<a<<"\n";
		//cout<<r<<"\n";
		l pos=-1;
		l cnt=-1;
		do{
			cnt++;
			pos=a.find(k,pos+1);
			//cout<<pos<<"\n";
		}while(pos!=string::npos);
		cout<<cnt<<"\n";
	}
	return 0;
}
import math
for _ in range(input()):
	n=input()
	s=int(math.floor(n//10))
	
	print ((s*(s+1))/2)*10
		
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
static long long int f[1000001],inv[1000001];
long long po(long long a,int b){
    long long x=1,y=a;
    while(b>0){
        if(b%2)
            x=x*y,x%=mod;
        y=y*y;
        y%=mod;
        b/=2;
    }
    return x;
}
long long int C(int n,int r){
    if(n==0||r==0)
        return 1;
    long long int ans=f[n];
    long long int x=inv[n-r];
    long long int y=inv[r];
    ans=(ans*x)%mod;
    ans=(ans*y)%mod;
    return ans;
    
}
int main(){
    f[0]=1;
    inv[0]=po(1,mod-2);
    for(long long int i=1;i<1000001;i++)
        f[i]=(f[i-1]*i)%mod,inv[i]=po(f[i],mod-2);
    int t;
    scanf("%d",&t);
    while(t--){
        int x,y,a,b;
        scanf("%d %d %d %d",&x,&y,&a,&b);
        x++,y++;
        long long total=C(x+y-2,x-1);
        //printf("%lld\n",total)
        long long ex=0;
        int b1=(y-b-1);
        if(b1<0){
            printf("0\n");
            continue;
        }
        long long temp;
        for(int i=0;i<a;i++){
            int r,c;
            r=x-i,c=y-b1;
            temp=(C(i+b1,i)*C(r+c-3,c-2))%mod;
           // temp*=temp;
           // temp%=mod;
            ex+=temp;
             if(ex>=mod)
                ex-=mod;
        }
        //ex=C(a+b-2,a-1);
        //rintf("%lld %lld\n",ex,total);
        total-=ex;
        total+=mod;
        if(total>=mod)
           total-=mod;
        printf("%lld\n",total);
    }
    return 0;
}
/*
400000 400000 200000 200000
*/
#include <iostream>

using namespace std;

bool matrix[1001][1001];
int arr[1001][1001];

inline int ones(int x1,int y1, int x2, int y2)
{
  int ctr=arr[x2][y2]-arr[x1][y2]-arr[x2][y1]+arr[x1][y1];
  return ctr;
}

void ones(int n)
{
  for(int x=1;x<=n;++x)
  {
   for( int y=1;y<=n;++y)
   {
    arr[x][y]=arr[x-1][y]+arr[x][y-1]-arr[x-1][y-1];
    if( matrix[x][y] ) arr[x][y]+=1;
   }
  }
}

int main()
{
     int t,n,h,w,area,temp,m;
     cin>>t;
     while(t--)
     {
        cin>>n;

        for(int i=0;i<=n; ++i)
        {
          arr[0][i]=0;
          arr[i][0]=0;
        }

        for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
        cin>>matrix[i][j];

        ones(n);
        area=arr[n][n];
        h=1;
        m=-1;

        if(area==1 || area==0) { cout<< 0 <<endl; continue; }
        while(h<=n)
        {
          if(area%h==0)
          {
           w=area/h;
           if(w<=n)
           for( int i=1; i<=n-h+1; ++i )
           for( int j=1; j<=n-w+1; ++j )
           {
             temp=ones(i-1,j-1,i+h-1,j+w-1);
             if(temp>m) m=temp;
           }
          }
          h++;
        }
        if(m<0) cout<<m<<endl;
        else
        cout<<area-m<<endl;
     }

    return 0;
}

T=input()
for _ in xrange(T):
	N,C=map(int,raw_input().split())
	A=map(int,raw_input().split())
	val,temp=0,0
	for x in A:
		x-=C
		temp=max(0,temp+x)
		val=max(temp,val)
	print val
	

t=10
while(t):
    t=t-1
    n=input()
    c=0
    for i in range(42,1+n):
        s=bin(i)
        if "101010" in s:
            c=c+1
    print c     

n = int(raw_input())
while n > 0:
	n -= 1
	a = raw_input()
	b = raw_input()
	c = ""
	for x in a:
		#print x
		if x >= 'A' and x <= 'Z':
			x = b[ord(x)-ord('A')]
		c += x
	print c

// codechef_codes.cpp : Defines the entry point for the console application.
//

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <time.h>
#include <cstdlib>

#define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define max(a,b) ((a)>(b)?a:b)
#define min(a,b) ((a)<(b)?a:b)
#define min_3(a,b,c) (min((a),min((b),(c))))
#define INF 1000000007

using namespace std;

int a[107];

int main() {
	boost;
	int tc,l,co,cou;
	string str;
	cin >> tc;
	while (tc--) {
		cou = 0;
		cin >> str;
		int ans = 0 , c1 =0;
		for (int i = 0; i < str.length(); i++) {
			if(str[i] == 'N')	a[i] = c1++;
			else
				a[i] = c1;
		}
		for (int i = 0; i < str.length(); i++) {
			if(str[i] == 'O')	ans = min(ans+1,a[i]);
		}
		cout << ans << endl;
	}
	
}
n = int(raw_input())
p = map(float, raw_input().split())

e = [p[0]]
for i in range(1,n):
    ans = (e[i-1]+p[i-1]+1)*p[i]
    e.append(ans)
    
for i in range(n-1):
    e[i+1]+=e[i]
    
print e[n-1]
mod = 1000000009
n,k = map(int,raw_input().split())
p = pow(2,k,mod)
ans = 1
for i in range(n):
    p-=1
    ans*=p
    ans%= mod
print ans



for b in range(input()):
    c = input()
    d = map(int,raw_input().split())
    d.sort()
    for k in range(d[0],0,-1):
        for l in d:
            if l % k == 0:
                flag = 1
            else:
                flag = 0
                break
        if flag == 1:
            print k
            break

#include <stdio.h>
#include <vector>
#define MX_N 1010

using namespace std;

vector<int> arr[MX_N];
int team[MX_N];
int t,n,error;

void dfs(int i,int T) {
	if(team[i]) {
		if(team[i] != T) error = 1;
		return;
	}
	team[i] = T;
	for(int j=0;j<arr[i].size();j++) {
		dfs(arr[i][j],-T);
	}
}
int main() {
	int i,j;
	scanf("%d",&t);
	while(t--) {
		scanf("%d",&n);
		for(i=1;i<=n;i++) {
			team[i] = 0;
			while(!arr[i].empty()) arr[i].pop_back();
		}
		for(i=1;i<=n;i++) {
			int x,y;
			scanf("%d",&x);
			while(x--) {
				scanf("%d",&y);
				arr[i].push_back(y);
				arr[y].push_back(i);
			}
		}
		error = 0;
		for(i=1;i<=n;i++) {
			if(!team[i]) {
				dfs(i,1);
			}
		}
		if(error) {
			printf("-1");
		}else {
			for(i=1;i<=n;i++) {
				if(team[i] == 1)
					printf("L");
				else
					printf("R");
			}
		}
		printf("\n");
	}
	return 0;
}
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Saransh
 */
import java.io.*;
import java.util.*;
public class Main {

    /**
     * @param args the command line arguments
     */
    static boolean marked[];
    static int memo[];
    public static void main(String[] args) {
        // TODO code application logic here
        try
        {
            ParserLose p=new ParserLose(System.in);
            
            marked=new boolean[100001];
            memo=new int[100001];
            for(int i=1;i<100000;i++)
                find(i);
            
            int t=p.nextInt();
            while(t-->0)
            {
                int m=find(p.nextInt());
                System.out.println(m);
            }
        }
        catch(Exception e)
        {

        }
    }
    public static int find(int t)
    {
        if(t<=0)
            return 0;
        if(t==1)
        {
            marked[t]=true;
            memo[t]=t;
            return 1;
        }
        if(t==2)
        {
            marked[t]=true;
            memo[t]=t;
            return t;
        }
        if(t==3)
        {
            marked[t]=true;
            memo[t]=t;
            return 3;
        }
        if(marked[t])
            return memo[t];
        int min=Integer.MAX_VALUE;
        for(int i=1;i<=t/2;i++)
        {
            if(t%i==0)
            {
                int k=1+find(t-i);
                if(k<min)
                    min=k;
            }
        }
        marked[t]=true;
        memo[t]=min;
        return min;
    }
    public static int dig(int a)
    {
        if(a==0)
            return a;
        return a%10+dig(a/10);
    }
    public static void check(String a,String b)
    {
        char tmp1[]=a.toCharArray();
        char tmp2[]=b.toCharArray();
        if(tmp1.length!=tmp2.length)
        {
            System.out.println("NO");
            return;
        }
        Arrays.sort(tmp1);
        Arrays.sort(tmp2);
        for(int i=0;i<tmp1.length;i++)
        {
            if(tmp1[i]!=tmp2[i])
            {
                System.out.println("NO");
                return;
            }
        }
        System.out.println("YES");
    }

}

class ParserLose
{
    final private int BUFFER_SIZE = 1 << 16;
    private DataInputStream din;
    private byte[] buffer;
    private int bufferPointer,bytesRead;
    public ParserLose(InputStream in)
    {
        din=new DataInputStream (in);
        buffer=new byte[BUFFER_SIZE];
        bufferPointer=bytesRead=0;
    }
    public int nextInt() throws Exception
    {
        int ret=0;
        byte c =read();
        while(c<=' ')c=read();

        do{
            ret=ret*10+(c-'0');
            c=read();
        }while(c>' ');

        return ret;
    }
    public String nextString() throws Exception
	   {
		   StringBuffer sb=new StringBuffer("");
		   byte c = read();
		   while (c <= ' ') c = read();
		   do
		   {
			   sb.append((char)c);
			   c=read();
		   }while(c>' ');
		   return sb.toString();
	   }
	   public char nextChar() throws Exception
	   {
		   byte c=read();
		   while(c<=' ') c= read();
		   return (char)c;
	   }
    private byte read() throws Exception
    {
        if(bufferPointer==bytesRead)fillBuffer();
        return buffer[bufferPointer++];
    }
    private void fillBuffer() throws Exception
    {
        bytesRead=din.read(buffer,bufferPointer=0,BUFFER_SIZE);
        if(bytesRead==-1)buffer[0]=-1;
    }

}
#include <bits/stdc++.h>
using namespace std;

int main() {
	int t;
	cin>>t;
	while(t--){
	    string a,b;
	    cin>>a>>b;
	    map<char,int>count1;
	    map<char,int>count2;
	    for(int i=0;i<a.length();i++) count1[a[i]]++;
	    for(int i=0;i<b.length();i++) count2[b[i]]++;
	    bool flag=true;
	    for(char i='a';i<='z';i++){
	        if(count1!=count2){
	            flag=false;
	            break;
	        }
	    }
	    if(flag) cout<<"YES\n";
	    else cout<<"NO\n";
	}
	return 0;
}

#include <iostream>
using namespace std;
#include<stdio.h> 
int dp[1002][1002];
 
int main()
{
	int t,m,n,k;
	scanf("%d", &t);
	while(t--)
	{
		scanf("%d %d %d", &m, &n, &k);
		m++;
		n++;
		dp[0][1] = 1;
		for(int i = 1; i <= m; i++)
			for(int j = 1; j <= n; j++)
				dp[i][j] = (dp[i][j-1] + dp[i-1][j])%k;
		/*
		for(int i = 1; i <= m; i++)
		{
			for(int j = 1; j <= n; j++)
			cout<<dp[i][j]<<" ";
			cout<<"\n";
		}
		*/		
		printf("%d\n", dp[m][n]);
	}
} 
#include<stdio.h>
int main()
{
    int t,i;
    scanf("%d",&t);
    for(i=1;i<=t;i++)
    {
        int x,y,z,s,p;
        scanf("%d%d%d",&x,&y,&z);
        p=x+y;
        s=z%p;
        if(s>x||s==0){
          printf("Anish\n");
        }
        else
            printf("Aman\n");
    }
}

#include<iostream>
#include<algorithm>
#include<stack>
#include<string>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<cmath>
#define pb push_back
#define big long long
#define FOR(i,a,b) for(i=a;i<=b;i++)
#define RFOR(i,a,b) for(i=a;i>=b;i--)
#define vi vector<int>
#define vb vector<big>
using namespace std;
big fact(big n)
{
    if(n==0 || n==1) return 1;
    return n*fact(n-1);
}
int main() {
	big l,t,n,i,j,k,temp,c,*arr,sum,f;
	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3;
	int h,num=0,prev;
	vb v,line;
	string s;
    cin>>t;
    while(t-->0)
    {
        cin>>n;
        cout<<4*n*n*n+6*n*n*(n-1)<<endl;
    }
	return 0;
}
#include<stdio.h>
int main()
{
int t,n,a,b,c,i,j;
long long int e;
scanf("%d",&t);
while(t--)
{
e=0;
scanf("%d %d %d %d",&n,&a,&b,&c);
for(i=0;i<=a&&i<=n;i++)
{
for(j=0;j<=b&&j<=n-i;j++)
{
e++;
if(c>(n-(i+j)))
{
e=e+(n-(i+j));
}
else
{
e=e+c;
}
}
}
printf("%lld\n",e);
}
return 0;
} 

import java.util.Scanner;

class decreasingstrings
{
    public static void main(String args[])throws Exception
    {
        try{
        Scanner in=new Scanner(System.in);
        long t;
        int n,r,d;
        String st="zyxwvutsrqponmlkjihgfedcba";
        t=in.nextLong();
        while(t-->0)
        {
            n=in.nextInt();
            String res="";
            if(n<=25)
            {
                System.out.println(st.substring((25-n),st.length()));
            }
            else
            {
               r=n%25;
               d=n/25;
               if(r>0)
               res=st.substring(25-r);
               for(int i=0;i<d;i++)
                   res+=st;
                 System.out.println(res);  
            }
        }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        
    }
    
}

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;

class Main {

    public static String recRemove(String orig, String remove) {

        String remStart = "<" + remove + ">";
        String remEnd = "</" + remove + ">";

        int end = orig.indexOf(remEnd);
        
        if(end==-1)
           return orig;

        String newString1 = orig.substring(0, end);
        String newString2 = orig.substring(end + remEnd.length(), orig.length());
        int start = newString1.lastIndexOf(remStart);
        newString1 = newString1.substring(0, start);
        orig = newString1 + newString2;

        return recRemove(orig, remove);

    }

    public static String spaceAdjust(String orig) {

        int index = orig.indexOf("  ");
        if(index==-1)
            return orig;

        String newString1 = orig.substring(0, index+1);
        String newString2 = "";
        try {
            newString2 = orig.substring(index+2, orig.length());
        }
        catch (Exception e) {
        }

        orig = newString1 + newString2;

        return spaceAdjust(orig);
    }

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        line = br.readLine();
        int t = Integer.valueOf(line).intValue();
        StringTokenizer strTok;
        while ((t--) > 0) {
            line = br.readLine();
            strTok = new StringTokenizer(line, "}");
            String orig = strTok.nextToken();
            String remove = strTok.nextToken();

            strTok = new StringTokenizer(remove, ",");
            remove = strTok.nextToken();

            strTok = new StringTokenizer(orig, "{");
            orig = strTok.nextToken();

            orig = spaceAdjust(recRemove(orig, remove)).trim();
            if(orig.length()==0)
                System.out.println("NO TEXT");
            else
                System.out.println(orig);
        }
    }
}
#include<stdio.h>
int main()
{
    int k , n , t , b[65]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313}  ;   
     int  i , c[100000] , a[9592] , j , r , q ;
     long long int s;
     for(i=0 ; i<100000 ; i++)
   { c[i] = i + 1 ; }
 
   c[0] = 0 ;

   for(i=0 ; i<65 ; i++)
   {  
     for(j=b[i] ; j<100000 ; j+=b[i])
     { 
       if(c[j-1]>0)
        { if(c[j-1]!=b[i])
          c[j-1]=0 ;
        }
     }
   }
   j=0;
     for(i=0 ; i<100000 ; i++)
   {  if( c[i]>0 )
     { a[j] = c[i] ;
       j++ ;
     }
   }
   
   
scanf("%d",&t);
while(t--)
{    s = 0 ;
    scanf("%d",&n);
    scanf("%d",&k); 
    if(k==0)
    {   
        s=n-2;
        s*=(s+1);
        s /=2;
        s+=n-2+1;
        printf("%llu\n",s);
    }
  else
    if(k>9592)
    { printf("0\n"); }
  else
    {
                     
    if(a[k-1]<=n)
    s=n-a[k-1]+1;
    else
    s = 0;
                     
           for( i=1 ; i<9592 ; i++ )
           {   if((i+k-1>=9592)||(a[i+k-1]>n))
               break ;
                r = n + 1 - a[i+k-1] ;  
                q = a[i] - a[i-1] ;
               s+=r*q ;     
           }
    printf("%llu\n",s) ;
    }

}
return 0 ;
}


  

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string.h>
#include <cstring>
#define oo (int)1e9
#define fill( a , v ) memset( a , v , sizeof (a) )
#define bits( x ) __builtin_popcount( x )
#define gcd( a , b ) __gcd( a, b )
#define lcm( a , b ) (a/gcd( a, b ) ) * b
#define add push_back
#define s(n) scanf( "%d" , &n )
const int mxn = 10000 + 10;
typedef long long ll;

using namespace std;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};

int dp[16][1<<16][2];
short vis[16][1<<16][2];
int id;
int mat[4][4];
int a[4][4];

int solve( int prev , int mask , int turn )
{
	if( !mask )return 0;
	
	int &d = dp[prev][mask][turn];
	short &v = vis[prev][mask][turn];
	
	if( v == id )return d;
	v = id;
	
	if( turn ) d = oo;
	else d = -oo;
	
	if( turn )
	{
		int x = prev / 4;
		int y = prev % 4;
		
		bool neighbour = 0;
		for(int i=0;i<4;i++)
		{
			int nx = x + dx[i];
			int ny = y + dy[i];
			
			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 )
			{
				int mm = mat[nx][ny];
				
				if( mask & mm )
				{
					neighbour = 1;
					d = min( d , -a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) );
				}
			}
		}
		
		if( !neighbour )
		{
			for(int i=0;i<16;i++)
			 if( mask & 1<<i )
			 d = min( d , -a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn )  );
		}
	}
	else
	{
		int x = prev / 4;
		int y = prev % 4;
		
		bool neighbour = 0;
		for(int i=0;i<4;i++)
		{
			int nx = x + dx[i];
			int ny = y + dy[i];
			
			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 )
			{
				int mm = mat[nx][ny];
				
				if( mask & mm )
				{
					neighbour = 1;
					d = max( d , a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) );
				}
			}
		}
		
		if( !neighbour )
		{
			for(int i=0;i<16;i++)
			 if( mask & 1<<i )
			 d = max( d , a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn )  );
		}		
	}
	
	return d;
}

int main()
{
	for(int i=0,c=1;i<4;i++)
	 for(int j=0;j<4;j++,c<<=1)
	  mat[i][j] = c;
	  
	  
	int runs;
	s( runs );
	
	while( runs-- )
	{
		++id;
		for(int i=0;i<4;i++)
		 for(int j=0;j<4;j++)
		  s( a[i][j] );
		  
		int soln = -oo;
		int mm = (1<<16)-1;
		
		for(int i=0;i<16;i++)
		 soln = max( soln , a[i/4][i%4] + solve( i , mm ^ 1<<i , 1 )  );
		 
		 printf( "%d\n" , soln );
	}
}

#include <stdio.h>
 
 
long long int mod=1000000007; 

long long int p_cal(long long int x, long long int y)
{
    long long int temp;
    if( y == 0)
        return 1;
    temp = p_cal(x, y/2);
    if (y%2 == 0)
        return (temp*temp)%mod;
    else
        return (((x*temp)%mod)*temp)%mod;
}


 
int main()
{
  long long int n,T,p,ans,x=2; 
  scanf("%lld",&T);
  while(T--)
  {
	  scanf("%lld",&n);
  	  p=p_cal(2,n-1);
  	  printf("%lld\n",p);
 }
  return 0;
}

#include<iostream>
#include <stdio.h>
using namespace std;
int main()
{
    int t; cin>>t;
    while(t--)
    {
        int size=0; cin>>size;
        int s=0,c=0,sg=0,cg=0;
        char tt; cin.get(tt);
        for(int i=0;i<size;i++)
        {
            char d; cin>>d;
            if(d=='S')
            s++;
            else
            c++;
            
            if(s==4)
            {
                s=0;c=0;
                sg++;
            }
            else if(c==4)
            {
                s=0;c=0;
                cg++;
            }
            else continue;
        }
        cout<<sg<<"-"<<cg;
        if(s>0 || c>0)
        {
            if(s==3)
            s=40;
            else
            s=s*15;
            
            if(c==3)
            c=40;
            else c=c*15;
            
            cout<<","<<s<<"-"<<c<<endl;
        }
        cout<<endl;
    }
    return 0;
}
#!usr/bin/python
#function for removing zeros at the end
def cut(n):
  
  if (n==0): 
    return 0;
  
  while(n>0):
    if(n%10 == 0):
      n=n/10;
    else:
      break;   
      
  return n;
  
  
  
case=input();
#taking input
string=[];
for i in range(case) :
	string.append(raw_input());
       	      
        	


#operating on them
for i in range(case):
	
	list=string[i].lower().split('x');
	
	l=len(list);
	
        #got the list of nos
        if ('0' in list):
          print "Robot hanged.";
          continue;
        
        t=1;
	for j in list:
        	j=int(j);
        	j=cut(j*t);
        	t=j;
        t=t%10;	
        	
	print t;
		
		
		
		

      
import sys

for __ in range(input()) :
    n , k = map(int,sys.stdin.readline().split())
    lists = map(int,sys.stdin.readline().split())
    dp = [0]*(k+1)
    dp[0]=1
    for i in lists :
        for j in range(k-i,-1,-1) :
            if dp[k] :
                break
            if dp[j] :
                dp[j+i] = 1
    print dp[k]

#include	<iostream>

using std::cin;
using std::cout;
using std::endl;

#include	<cstring>


#define		Chars		22
#define		base		1000000000

int main(){
	int cases, i, j;
	char ch;
	char string[] = "welcome to conscientia";
	long int *cal1 = new long int[Chars];
	long int *cal2 = new long int[Chars];
	cin >> cases;
	cin.get();
	for(i = 0; i < cases; ++i){
		memset(cal1, 0, sizeof(int) * Chars);
		memset(cal2, 0, sizeof(int) * Chars);
		while((ch = cin.get()) != '\n'){
			for(j = 0; j < Chars; ++j){
				if(ch == string[j]){
					if(j == 0)
						cal2[j] =  (cal1[j] + 1) % base;
					else
						cal2[j] = (cal1[j] + cal1[j - 1]) % base;
				} else {
					cal2[j] = cal1[j];
					if(cal2[j] == 0)
						break;
				}
			}
			memcpy(cal1, cal2, sizeof(int) * Chars);
			memset(cal2, 0, sizeof(int) * Chars);			
		}
		cout << cal1[Chars - 1] << endl;
	}
	return 0;	
}
#include<stdio.h>
#include<math.h>
#define MAX_PRIME 3402

int prime[MAX_PRIME];
bool chkPrime[1000002]={true,true};

inline void initPrimes() {
       const int lim = 31627;
       int currPos=1,primeCount=0;
       do {
           while(chkPrime[currPos]) currPos++;
           prime[primeCount++]=currPos;
           int temp=currPos;
           while((temp+=currPos)<=lim)
               chkPrime[temp]=true;
		   currPos++;
       } while(currPos<=MAX_PRIME);
	   while(currPos<=lim){
	       if(!chkPrime[currPos])
			  prime[primeCount++]=currPos; 
		   currPos++;
	   }
}
int main()
{
	initPrimes();
    int testCases;
	scanf("%d",&testCases);
    while(testCases--){
       int a,b,i,j;
	   scanf("%d%d",&a,&b);

	   for(i=b-a;i>=0;i--)
	       chkPrime[i]=true;
	   if(a==1)
	      chkPrime[0]=false;
	   int lim = (int)sqrt((double)b);
	   for(i=0;prime[i]<=lim;i++){
		   j=a-a%prime[i];
		   if(j<a)
			   j+=prime[i];
		   while(j<=b){
		       if(j!=prime[i])
				   chkPrime[j-a]=false;
		       j+=prime[i];
		   }
	   }
	   int count=0;
	   for(i=2;i<=b-a;i++)
	       if(chkPrime[i-2]&&chkPrime[i])
			   count++;
       printf("%d\n",count);
    }
	return 0;
}

#include<bits/stdc++.h>
#define pb(x) push_back(x)
#define mp(i,j) make_pair(i,j)
#define ll long long 
int lolol;
#define S(x) lolol=scanf("%l64d", &x)
#define s(x) lolol=scanf("%d", &x)
#define getchar_unlocked getchar
using namespace std;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c<'0'||c>'9'){
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar_unlocked();
    }
    return x;
}
int main(){
    ll n,m;
    n=scan(); m=scan();
    vector<pair<ll,ll> > a[n+1];
    while(m--){
        ll x,y,z;
        x=scan(); y=scan(); z=scan();
        a[x].pb(mp(y,2*z));
        a[y].pb(mp(x,2*z));
    }
    vector<ll> pol;
    ll k; k=scan();
    for(int i=0; i<k; i++){
        ll x; x=scan();
        pol.pb(x);
    }
    ll p; 
    p=scan();
    vector<ll> boost;
    for(int i=0; i<p; i++){
        ll x; x=scan();
        boost.pb(x);
    }
    ll st,en; st=scan(); en=scan();
    ll dist[n+1]; memset(dist,-1,sizeof dist);
    priority_queue<pair<ll,ll> > q;
    q.push(mp(0,en));
    dist[en]=0;
    while(!q.empty()){
        ll node=q.top().second;
        q.pop();
        ll sz=a[node].size();
        for(int i=0; i<sz; i++){
            ll nbr=a[node][i].first;
            ll wt=a[node][i].second;
            if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){
                dist[nbr]=dist[node]+wt;
                q.push(mp(-dist[nbr],nbr));
            }
        }
    }
    ll dist_thief=dist[st];
    if(dist_thief==-1){
        cout<<-1;
        return 0;
    }
    for(int i=0; i<k; i++){
        if(dist[pol[i]]>=0){
            if(dist[pol[i]]<=dist[st]){
                cout<<-1<<endl;
                return 0;
            }
        }
    }
    for(int i=0; i<p; i++){
        if(dist[boost[i]]>=0){
            a[boost[i]].pb(mp(en,dist[boost[i]]/2));
            a[en].pb(mp(boost[i],dist[boost[i]]/2));
        }
    }
    memset(dist,-1,sizeof(dist));
    dist[en]=0;
    q.push(mp(0,en));
    while(!q.empty()){
        ll node=q.top().second;
        q.pop();
        ll sz=a[node].size();
        for(int i=0; i<sz; i++){
            ll nbr=a[node][i].first;
            ll wt=a[node][i].second;
            if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){
                dist[nbr]=dist[node]+wt;
                q.push(mp(-dist[nbr],nbr));
            }
        }
    }
    for(int i=0; i<k; i++){
        if(dist[pol[i]]<=(dist_thief)){
            cout<<-1;
            return 0;
        }
    }
    cout<<(dist_thief/2);
    
}
while(1):
 try:
   t=raw_input()
   a=[]
   while(len(a)==0):
     a=raw_input().split()
   sum=0
   a.reverse()
   x=""
   k=len(a)
   for j in range(k):
         a[j]=int(a[j])
         sum=sum+a[j]
         x=x+str(a[j])
         if(j!=k-1):
             x=x+" "
         
   print x
   print sum
 except EOFError: break  
def tidrice():
    T = int(raw_input())
    for t in xrange(T):
        N = int(raw_input())
        votes = {}
        for n in xrange(N):
            user, score = raw_input().split()
            if score == '+':
                votes[user] = 1
            else:
                votes[user] = -1
        print sum(votes.values())

if __name__ == "__main__":
    tidrice()
import sys

dp , MOD = [] , 10**9+7
def compute() :
    dp.extend([1,1])
    for i in range(2,10**6+1) :
        dp.append(dp[i-1]+dp[i-2])
        dp[-1] = dp[-1]%MOD
        
if __name__ == "__main__" :
    compute()
    for __ in range(input()) :
        print dp[input()]
n=int(input())
def fun( n):
	if n==0:
		return 1
	if n==1:
		return 2
	return 2*fun(n-1)
ans=fun(n)	
print ans	
	
	

   
def fact(n):
    if(n<=1):
        return 1
    else:
        return fact(n-1)*n
t=input()
while t:
    t=t-1
    r=len(raw_input().strip())-1
    print fact(2*r)/(fact(r)*fact(r+1))

test=raw_input()
t=int(test)
while(t>0):
	lst=[]
	n=int(raw_input())
	lst=map(int,raw_input().split())
	if((max(lst)-min(lst))>1):
		print "BAD"
	else:
		print "GOOD"
	t=t-1
import sys
nCase = int(sys.stdin.readline())
for i in range(nCase):
	n = int(sys.stdin.readline()) - 1
	print pow(2,n,1000)
t=int(raw_input())
while t>0:
    n,m=[int(x) for x in raw_input().split()]
    p=[int(x) for x in raw_input().split()]
    if n==1:
        print m
    else:
        ans=m
        for i in range (len(p)):
            if p[i]<=m:
                for j in range(i,n):
                    if p[j]>p[i]:
                        c=m/p[i]
                        a=m-c*p[i]
                        a=a+c*p[j]
                        if a>ans:
                            ans=a
        print ans
    t=t-1
            
    
t=input()
for x in range(0,t):
    n=input()
    s=bin(n)
    cnt=s.count('1')
    print cnt

t=input()
for _ in xrange(t):
	a,b=map(int,raw_input().split())
	print max(a,b),(a+b)
/* Divanshu Garg */
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cctype>
#include <cassert>

using namespace std;

#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define piii pair< int,pii >
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define Sl(x) scanf("%lld",&x)
#define M(x,i) memset(x,i,sizeof(x))
#define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl
#define fr first
#define se second

int k;
int grundy[1005];

int f(int n) {
    if ( n < k ) return 0;
	if ( n == k ) return 1;
    if ( grundy[n] != -1 ) return grundy[n];
    int i;
    set<int> mex;
    F(i,1,(n-k+1)) {
        int temp = f(i)^f(n-k-i);
        mex.insert(temp);
    }
    set<int>::iterator it;
    int ans = 0;
    FE(it,mex) {if (*it !=ans) break;ans++;}
	grundy[n] = ans;
    return ans;
}

int main() {
    M(grundy,-1);
    int t,i,n;
    cin >> t >> k;
    F(i,0,t) {
        cin >> n;
        cout << (f(n)>0?"Brainy":"Clumsy") << endl;
    }
    return 0;
}
T=input()
while T:
    T-=1
    tl,n=[int(x) for x in raw_input().split()]
    if n==0:
        n=1
    print pow(tl,n,pow(10,9)+7)

import math 
id = input()
t = input()

def equals(a,b):
	if (abs(a-b) < 0.000001):
		return True ; 
	return False ; 

def dist(x1,y1,x2,y2): 
	return math.sqrt((x1-x2)**2+(y1-y2)**2) ; 

while (t!=0) : 
	s = raw_input()
	s1 = s.split(" ") 
	x1 = int(s1[0]) 
	y1 = int(s1[1])
	x2 = int(s1[2]) 
	y2 = int(s1[3])
	x3 = int(s1[4]) 
	y3 = int(s1[5])

	l = []
	l.append(dist(x1,y1,x2,y2))
	l.append(dist(x2,y2,x3,y3))
	l.append(dist(x3,y3,x1,y1))
	l.sort()
	a = l[0]
	b = l[1]
	c = l[2]

	if (id == 1):
		if (equals(a,b) | equals(b,c) | equals(c,a)):
			print "Isosceles triangle" 
		else : 
			print "Scalene triangle"
	if (id == 2):
		if (equals(a,b) | equals(b,c) | equals(c,a)):
			print "Isosceles",
			if (equals(a**2+b**2,c**2)):
				print "right triangle"
			elif (a**2+b**2 > c**2):
				print "acute triangle"
			else :
				print "obtuse triangle"
		else : 
			print "Scalene",
			if (equals(a**2+b**2,c**2)):
				print "right triangle"
			elif (a**2+b**2 > c**2):
				print "acute triangle"
			else :
				print "obtuse triangle"
	t-= 1
#include <algorithm>
#include <bitset>
#include <cmath>
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <stack>
#include <queue>
#include <utility>
#include <vector>
#define mod 1000000007
using namespace std;

long long up[20010][22],down[20010][22];
int n,k,T;
vector<int> adj[20010];
int pre[20010];
long long c[22][22],sum[22];

void calc_down(int u)
{
    for (int i = 0; i < adj[u].size(); i++)
    {
        int v = adj[u][i];
        if (pre[u] == v) continue;
        pre[v] = u;  calc_down(v);
    }
    
    for (int i = 0; i <= k; i++) down[u][i] = 1;
    for (int i = 0; i < adj[u].size(); i++)
    {
        int v = adj[u][i];
        if (pre[u] == v) continue;
        for (int j = 0; j <= k; j++)
          for (int t = 0; t <= j; t++) down[u][j] = (down[u][j] + c[j][t] * down[v][t]) % mod;
    }
}

void calc_up(int u)
{
//    cout << "iter to: " << u << endl;    
    for (int i = 0; i <= k; i++) sum[i] = 1;
    for (int i = 0; i < adj[u].size(); i++)
    {
        int v = adj[u][i];
        if (pre[u] == v) continue;
        for (int j = 0; j <= k; j++)
          for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod;
    }
/*    cout << "without root" << endl;
    for (int j = 0; j <= k; j++) cout << sum[j] << ' ';
    cout << endl;*/
        
    for (int j = 0; j <= k; j++) sum[j] = (sum[j] + up[u][j]) % mod;
      
/*    cout << "with root" << endl;
    for (int j = 0; j <= k; j++) cout << sum[j] << ' ';
    cout << endl;*/
      
    for (int i = 0; i < adj[u].size(); i++)
    {
        int v = adj[u][i];
        if (pre[u] == v) continue;
        for (int j = 0; j <= k; j++)
          for (int t = 0; t <= j; t++) sum[j] = (sum[j] - c[j][t] * down[v][t]) % mod;
/*        cout << "processed: " << v << endl;
        for (int j = 0; j <= k; j++) cout << sum[j] << ' ';
        cout << endl;*/
        for (int j = 0; j <= k; j++)
          for (int t = 0; t <= j; t++) up[v][j] = (up[v][j] + c[j][t] * sum[t]) % mod;
        for (int j = 0; j <= k; j++)
          for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod;          
    }
//    cout << endl;
    for (int i = 0; i < adj[u].size(); i++)
    {
        int v = adj[u][i];
        if (pre[u] == v) continue;
        calc_up(v);
    }
}

int main()
{
//    freopen("treesum.in","r",stdin);
//    freopen("treesum.ou","w",stdout);
    scanf("%d", &T);
    memset(c,0,sizeof(c));
    c[0][0] = 1;
    for (int i = 1; i <= 20; i++)
      for (int j = 0; j <= i; j++)
      {
            c[i][j] = c[i - 1][j];
            if (j) c[i][j] = (c[i][j] + c[i - 1][j - 1]) % mod;            
        }        
        
    while (T--)
    {
        scanf("%d %d", &n, &k);
        for (int i = 0; i < n; i++) adj[i].clear();
        for (int i = 0; i < n - 1; i++)
        {
            int u,v;  scanf("%d %d", &u, &v);
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        for (int i = 0; i < n; i++) pre[i] = -1;
        calc_down(0);
        for (int i = 0; i < n; i++)
          for (int j = 0; j <= k; j++) up[i][j] = 0;
        calc_up(0);
        for (int i = 0; i < n; i++)
        {
            long long ans = (up[i][k] + down[i][k]) % mod;
            printf("%lld\n", (ans + mod) % mod);
        }
        printf("\n");
    }                          
}

#include<bits/stdc++.h>
#define pb(x) push_back(x)
#define all(x) x.begin(), x.end()
#define cout2(x, y) cout << x << " " << y <<  endl
#define N 100005

using namespace std;

long long tree[2][3 * N], A1[N], A2[N], A3[N], B[3 * N], aux[N];

int add = 1e9, mod = 10000;
map<int, int>mapa[10000];

void update(int x, int id, long long val){
	
	for(int i = x; i < 3 * N; i += i&-i)tree[id][i] += val;	
}

long long query(int x, int id){
	
	long long ans = 0;
	for(int i = x; i > 0; i -= i&-i)ans += tree[id][i];
	return ans;	
}

int main(){

	int tc = 0;
	scanf("%d", &tc);
	
	while(tc--){
		
		for(int i = 0; i < mod; i++)mapa[i].clear();
		memset(tree, 0, sizeof tree);
		
		int P, Q, R, top = 0;
		
		scanf("%d", &P);
		for(int i = 0; i < P; i++)scanf("%lld", &A1[i]), B[top++] = A1[i] += add;
		
		scanf("%d", &Q);
		for(int i = 0; i < Q; i++)scanf("%lld", &A2[i]), B[top++] = A2[i] += add;
		
		scanf("%d", &R);
		for(int i = 0; i < R; i++)scanf("%lld", &A3[i]), B[top++] = A3[i] += add;
		
		sort(B, B + top);
		int id = 1;
		
		for(int i = 0; i < top; i++)
			if(mapa[B[i]%mod].find(B[i]) == mapa[B[i]%mod].end())
				mapa[B[i]%mod][B[i]] = id++;
		
		for(int i = 0; i < P; i++)A1[i] = mapa[A1[i]%mod][A1[i]];
		for(int i = 0; i < Q; i++)A2[i] = mapa[A2[i]%mod][A2[i]];
		for(int i = 0; i < R; i++)A3[i] = mapa[A3[i]%mod][A3[i]];
		
		for(int i = 0; i < Q; i++){
			
			if(i < P)update(A1[i], 0, 1);
			aux[i] = query(A2[i], 0);
		}
		
		long long ans = 0;
		for(int i = 0; i < R; i++){
			
			if(i < Q)update(A2[i], 1, aux[i]);
			ans  += query(A3[i], 1);
		}
		
		printf("%lld\n", ans);
	}
}


t = int(raw_input())
for i in range(0, t):
	p, y = raw_input().split()
	p = int(p)
	y = int(y)
	for j in range(0, (y-2000)):
		p = p**2 % (10**9 + 7)
	print p % (10**9 + 7)	
t = input()
for i in range(t):
    d = 9999999
    index = 0
    for j in range(10):
        mn = map(int,raw_input().split())
        s = max(mn)-min(mn)
        if s<=d:
            d = s
            index = j+1
    print index,d        
        

t=raw_input()
t=int(t)
while t>0:
    f,m=raw_input().split()
    f=int(f);
    m=int(m);
    if m%f==0:
        print "CORRECT"
    else:
        print "WRONG"
    t=t-1
t=input()
m=1000000007
for i in range(0,t):
    n=input()
    if n<=3:
        print "0"
    else :
        print (n*(n-3)/2)%m

#include <bits/stdc++.h>
#define rf freopen("inp.in", "r", stdin)
using namespace std;

const int MAX = 100005;
vector < int > edgeList[MAX];
vector < int > bridgeTree[MAX];

int A[MAX], B[MAX], V[MAX];
int N, M, Q;
pair < int, int > DP[MAX];
int D[MAX], L[MAX], cur = 0;

bool isBridge[MAX];

void dfs(int u, int p){
	D[u] = L[u] = ++cur;
	V[u] = 1;
	for(int i = 0 ; i < edgeList[u].size() ; i++){
		int v = A[edgeList[u][i]] + B[edgeList[u][i]] - u;
		if(v == p) continue;
		if(V[v] == 0){
			dfs(v, u);
			L[u] = min(L[u], L[v]);
			if(L[v] > D[u]) isBridge[edgeList[u][i]] = true;
		}
		else L[u] = min(L[u], D[v]);
	}
}

int dfs2(int u, int p){
	int x = 1;
	V[u] = 1;
	for(int i = 0 ; i < bridgeTree[u].size() ; i++){
		int v = bridgeTree[u][i];
		if(v == p) continue;
		x += dfs2(v, u);
	}
	return x;
}

long long choose(int x){
	long long res = ( (x)*1LL*(x-1) ) / 2;
	return res;
}

int main(){
		
	scanf("%d %d %d\n", &N, &M, &Q);
	for(int i = 1 ; i <= M ; i++){
		scanf("%d %d\n", &A[i], &B[i]);
		edgeList[A[i]].push_back(i);
		edgeList[B[i]].push_back(i);
	}

	for(int i = 1 ; i <= N ; i++){
		if(V[i] == 0)
			dfs(i, -1);
	}

	for(int i = 1 ; i <= M ; i++){
		if(isBridge[i]){
			bridgeTree[A[i]].push_back(B[i]);
			bridgeTree[B[i]].push_back(A[i]);
		}
	}

	for(int i = 1 ; i <= N ; i++) V[i] = 0;
	
	long long K = 0;
	for(int i = 1 ; i <= N ; i++){
		if(V[i] == 0) K += choose(dfs2(i, -1));
	}

	if(K >= Q){
		printf("-1\n");
		return 0;
	}

	++K;

	DP[0].first = DP[0].second = 0;
	DP[1].first = 2, DP[1].second = 1;
	
	for(int i = 2; i <= K ; i++){
		DP[i].first = 1e9;
		for(int j = 2 ; ; j++){
			long long p = choose(j);
			if(i >= p && (DP[i - p].first + j < DP[i].first) ){
				DP[i].first  = DP[i - p].first  + j;
				DP[i].second = DP[i - p].second + 1;
			}
			if(i < p) break;
		}
	}

	int res = DP[K].first += (DP[K].second == 2);
	printf("%d\n",res);
}
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
	int x;
	double w,y,z;
	cin>>x>>y;
	if((double)(y-x)>=0.50)
	{
		if(x%5==0 )
	{
		y=(y-(double)x-0.50);
	//	std::cout<<std::fixed;
	//std::cout<<std::setprecision(2)<<y<<'\n';
	} 
}
std::cout<<std::fixed;
	std::cout<<std::setprecision(2)<<y;
return 0;
} 
#include<bits/stdc++.h>
using namespace std;

int main(){
int t;
scanf("%d",&t);
while(t--){

deque<int> q;
int n,x;
scanf("%d",&n);
for(int i=0;i<n;i++)
scanf("%d",&x),q.push_back(x);
x=0;
int f=0,g=0;
long long suml=0,sumr=0;
	while(!q.empty()){
		if(suml<=sumr)
		suml+=q.front()+1,q.pop_front();
		else sumr+=q.back()+1,q.pop_back();
		
	
	}
	cout<<max(sumr,suml)+1<<endl;
}
return 0;
}
import numpy as np
import bisect
t=int(raw_input())
x=np.array(list(map(int,raw_input().split())))
x=sorted(x)
#print x
n=int(raw_input())
for i in range(n):
    a,b=map(int,raw_input().split())
    p=bisect.bisect_left(x,a)
    q=bisect.bisect_right(x,b)
    print q-p
dp=[0 for i in xrange(100001)]
m=(10**9)+7
dp[0]=1
dp[1]=0
for i in xrange(2,100001):
    dp[i]=(i-1)*(dp[i-1]+dp[i-2])%m

for _ in xrange(input()):
    print dp[input()]
#include<iostream>
#include<algorithm>
#include<functional>
#include<utility>
#include<cstring>
#include<climits>
#include<cstdlib>
#include<cstdio>
#include<vector>
#include<cmath>
#include<stack>
#include<queue>
#include<deque>
#include<map>
#include<set>
#define MAX LONG_LONG_MAX
#define MIN LONG_LONG_MIN
#define ll long long
#define mp make_pair
#define pb push_back
#define M 1000000007
#define ff first
#define ss second
#define INF 1e17
using namespace std;

ll exponentiation(ll a,ll b)
{
    ll ans=1;
    while(b>0)
    {
       if(b%2==1)
            ans=(ans*a)%M;
       a=(a*a)%M;
       b/=2;
    }
    return ans%M;
}
ll maxi=MIN;
ll fen_tree[100000];
ll update(ll index,ll value)
{
    while(index<=maxi)
    {
        fen_tree[index]+=value;
        index+=((index)&(-index));
    }
}
ll build(ll index)
{
    ll sum=0;
    while(index>0){
        sum+=fen_tree[index];
        index-=((index)&(-index));
    }
    return sum;
}
int main()
{
    ll t,n;
    scanf("%lld",&t);
    while(t--)
    {
        memset(fen_tree,0,sizeof(fen_tree));
        scanf("%lld",&n);
        ll sum,arr[n];
        for(int i=0;i<n;i++)
            scanf("%lld",&arr[i]);
        maxi=*max_element(arr,arr+n);
        for(int j=0;j<n;j++)
        {
            sum=build(arr[j]-1);
            cout<<sum<<" ";
            update(arr[j],1);
        }
        cout<<endl;
    }
return 0;
}

#include<stdio.h>
int main()
{
int t,i;
scanf("%d",&t);
for(i=1;i<=t;i++)
{
long long int x,y,z,t,a,b,gcd;
scanf("%lld%lld",&x,&y);
a=x;
b=y;
while(b!=0){
t=b;
b=a%b;
a=t;
}
gcd=a;
z=x*y/gcd;
printf("%lld\n%lld\n",gcd,z);
}
}

#include <iostream>
#include <string>
using namespace std;

bool find(string S1, string S2) {
	for(int i = 0; i < S2.size(); i++) {
		if (S1[i] != S2[i])
			return false;
	}
	return true;
}

int main() {
	int N, Q;
	long long int priority[1000];
	string name[1000], query;
	cin >> N;
	for(int i = 0; i < N; i++) {
		cin >> name[i] >> priority[i];
	}
	cin >> Q;
	for(int i = 0; i < Q; i++) {
		long long int max = -1000000001;
		int pos = -1;
		cin >> query;
		for(int j = 0; j < N; j++) {
			if(find(name[j], query)) {
				if(priority[j] > max) {
					max = priority[j];
					pos = j;
				}
			}
		}
		if(pos != -1)
			cout << name[pos] << endl;
		else
			cout << "NO" << endl;
	}
	return 0;
}
import java.math.BigInteger;
import java.io.*;
class Main
{
public static void main(String args[])
{
int d;
String s1,s2;
BigInteger b1,b2;
BigInteger bi[];
try
{
BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
d=Integer.parseInt(bf.readLine());
while(d-->0)
{
s1=bf.readLine();
s2=bf.readLine();
if(s2.equals("0"))
{
System.out.println("0 0");
continue;
}
b1=new BigInteger(s1);
b2=new BigInteger(s2);
bi=b1.divideAndRemainder(b2);
System.out.println(bi[1]+" "+bi[0]);
}
}catch(Exception ioe){}
}
}
"""
f = open('Alarge.in','r')
a = f.read()
b = a.split('\n')
del(b[-1])
f.close()
"""
import sys

def solve(l):
    del(l[-1])
    pos = {}
    pos['X'] = []
    pos['O'] = []
    pos['T'] = None
    for i in xrange(len(l)):
        for j in xrange(len(l[0])):
            if l[i][j] == 'T':
                pos['T'] = (i,j)

            elif l[i][j] == 'X':
                pos['X'].append((i,j))
            elif l[i][j] == 'O':
                pos['O'].append((i,j))

    ## Check Row.
    #for i in xrange(4):
    #    for j in xrange(4):

    count = 0

    while count < 4:
        a = []
        for i in xrange(4):
            a = a + [l[count][i]]
        m = same(a)

        if m != None:
            if m[0] == True:
                return m[1] + ' won'
        count += 1

    ## Check Column.

    count = 0
    while count < 4:
        a = []
        for i in xrange(4):
            a = a + [l[i][count]]
        #print a
        m = same(a)

        if m != None:
            if m[0] == True:
                return m[1] + ' won'
        count += 1

    ## Check Diagonal.

    ## First diagonal...
    partial = [l[i][i] for i in xrange(4)]
    m = same(partial)
    if m != None:
        if m[0] == True:
            return m[1] + ' won'

    ## Second diagonal...

    p = [l[i][j] for i in xrange(4) for j in xrange(4) if i + j == 3]
    m = same(p)
    if m != None:
        if m[0] == True:
            return m[1] + ' won'

    for i in xrange(len(l)):
        for j in xrange(len(l[0])):
            if l[i][j] == '.':
                return 'Game not completed'

    return 'Draw'
    

    
def same(partial_list):
    q = partial_list
    symbol = q[0]
    #########################
    if symbol == 'T':
        a = q[1]
        if a != '.':
            for i in xrange(2,len(q)):
                if q[i] != a:
                    return False, -1

            return True, a
    #########################

    
    elif symbol != '.':
        pos = -1
        ## symbol is either 'X' or 'O'....
        c = False

        for i in xrange(len(q)):
            if q[i] == 'T':
                c = True
                pos = i

        if c == False:
            ## i.e. there is no 'T' in q
            for i in xrange(len(q)):
                if q[i] != symbol:
                    return False, -1
            return True, q[0]

        else: ## c == True, i.e. there is a 'T' in q
            for i in xrange(len(q)):
                if i != pos and q[i] != symbol:
                    return False, -1

            return True,q[0]
    ##########################

T = int(sys.stdin.readline())
for casenum in xrange(T):
    x = []
    y = []
    for i in xrange(5):
        a = sys.stdin.readline().strip()
        x.append(a)

    for i in xrange(len(x)):
        s = ''
        for v in x[i].split(' '):
            s += v
        y.append(s)
    #print y
    print 'Case #%d: %s' % (casenum + 1, solve(y))

using namespace std;

#include <string>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <list>
#include <map>
#include <set>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string.h>
#include <stack>
#include <queue>
#include <limits.h>
#include <iterator>
#include <iomanip>
#include <time.h>

#define null NULL
#define PRINT_NEW_LINE printf("\n")
#define gc getchar_unlocked
#define MAX_INPUT_SIZE 1001
#define CODEFORCES_MAX_INPUT_SIZE 101
#define TOPCODER_MAX_INPUT_SIZE 51
#define ALPHABET_SIZE 26
#define HACKER_RANK_LOWER_CASE "hackerrank"
#define MAX_SIZE_USER_INPUT 101
#define LIMIT 10000001
#define MODN 1000000007
#define MAX_SIZE 1000001

#define gc getchar_unlocked

void solveProblem() {
    unsigned int testCases, size;
    long long int input, result;
    scanf("%u", &testCases);
    while (testCases--) {
        scanf("%u", &size);
        result = 1;
        for (unsigned int counter = 0; counter < size; counter++) {
            scanf("%lld", &input);
            result = (result * input) % MODN;
        }
        cout << result % MODN << endl;
    }
}

int main() {
    solveProblem();
    return 0;
}

for _ in range(input()):
	n=int(input())
#	temp=pow(2,n)
	if n==1:
		print 1
	else:
		print 0
	#for i in range(temp):
	#	res^=i
	#print res	
		
t=int(raw_input())
for x in range(t):
	s=raw_input()
	print s.count(' ')+1
#include <stdio.h>
#include <string.h>
int main()
{
	char str[100][10001];
	int i=0,v[5],t,j;
	long long wow[100];
	scanf("%d",&t);
	for(j=0;j<t;j++)
	{
	scanf("%s",str[j]);
	}
	for(j=0;j<t;j++)
	{
		for(i=0;i<5;i++)
	{
		v[i]=0;
	}
	for(i=0;str[j][i]!='\0';i++)
	{
		switch(str[j][i])
		{
		case 'A' :
			v[0]+=2;
			break;
			case 'E' :
			v[1]+=2;
			break;
			case 'I' :
			v[2]+=2;
			break;
			case 'O' :
			v[3]+=2;
			break;
			case 'U' :
			v[4]+=2;
			break;
			case 'a' :
			v[0]++;
			break;
			case 'e' :
			v[1]++;
			break;
			case 'i' :
			v[2]++;
			break;
			case 'o' :
			v[3]++;
			break;
			case 'u' :
			v[4]++;
			break;
        
		}
	}
	wow[j]=1;
		for(i=0;i<5;i++)
		{
			if(v[i]!=0)
			{
			wow[j]=wow[j]*v[i];
			}
		}
//	if(v[0]+v[1]+v[2]+v[3]+v[4]==0)
//		wow[j]=0;
	}
	for(j=0;j<t;j++)
	{
		printf("%lld\n",wow[j]);
	}
	
	return 0;
}     
#include <bits/stdc++.h>
using namespace std;
int T,N;
int A[100005];
int main()
{
	cin>>T;
	while(T--)
	{
		scanf("%d",&N);
		for(int i=0; i<N; i++)scanf("%d",&A[i]);
		sort(A,A+N);
		int flag=0;
		int curr=0;
		int ans=0; int cnt=0;
		for(int i=0; i<N ; i++)
		{
			int tmp=A[i]-curr;
			if(tmp<=0){
				flag=1;
				break;
			}
			curr++;
			ans++;
			cnt++;
			if(cnt==6)
			{
				cnt=0;
				curr++;
			}
		}
		if(flag==1)cout<<"Goodbye Rick"<<"\n"<<ans<<"\n";
		else cout<<"Rick now go and save Carl and Judas"<<"\n";
	}
	return 0;
}
// AUTHOR: ARVIND NAIR

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;

#define as(z,x,y) assert(x <=z  && z<= y);
#define s(x)   scanf("%d",&x)
#define rep(a,c)   for ( long int (a)=0; (a)<(c); (a)++)
#define repn(a,b,c)  for ( long int (a)=(b); (a)<=(c); (a)++)
#define repd(a,b,c)  for (  long int (a)=(b); (a)>=(c); (a)--)
#define all(v) (v).begin(),(v).end()
#define fi  first
#define se  second
#define pb  push_back
#define mp  make_pair
#define INF (int)1e9
#define EPS (double)(1e-9)
#define MOD (int)1e9+7
#define M(x,i) memset(x,i,sizeof(x))
#define trace(x)    cout<<#x<<" is "<<x<<"\n"
#define sz(x) (int)(x.size())
#define tr(i) for(typeof(i.begin()) it=i.begin(); it!=i.end();it++)
#define MAXN 1000005

int flag[4*MAXN];
vector<pii> v;

struct node {
  int sum;
  node(int l,int r):sum(0) {}
  node():sum(-1)  {}

}tree[4*MAXN];

void push(int v,int start, int end) {
  
  int mid=(start+end)>>1;
    tree[2*v].sum+=flag[v];
    tree[2*v+1].sum+=flag[v];
    flag[2*v]+=flag[v];
    flag[2*v+1]+=flag[v];

    flag[v]=0;
}

void add(int v,int start, int end,int val) {
  tree[v].sum+=val;
  flag[v]+=val;
}


void build(int v,int start, int end) {

   if(start==end)
    {  tree[v]=node(start,end);
        return;
      }

       int mid=(start+end)>>1;
       build(2*v,start,mid);
       build(2*v+1,mid+1,end);
       tree[v].sum=max(tree[2*v].sum,tree[2*v+1].sum);
    
}

void update(int v,int start, int end, int l, int r, int val)  {

  if(start>r or end<l)
    return;

  if(l<=start and r>=end)
   { add(v,start,end,val);
      return;
    }

      push(v,start,end);
     int mid=(start+end)>>1;
       update(2*v,start,mid,l,r,val);
       update(2*v+1,mid+1,end,l,r,val);

    tree[v].sum=max(tree[2*v].sum,tree[2*v+1].sum);
}

int query(int v, int start, int end, int l, int r)  {

if(l>end or r<start) 
  return 0;

  if(l<=start and r>=end)
    return tree[v].sum;

   push(v,start,end);
   int mid=(start+end)>>1;
       int res1=query(2*v,start,mid,l,r);
       int res2=query(2*v+1,mid+1,end,l,r);

  return max(res1,res2);
  
}

int main()
{ ios_base::sync_with_stdio(false);  cin.tie(0); 

int n; cin>>n;
M(flag,0);
build(1,1,MAXN);

rep(i,n) {

  int x,y; cin>>x>>y;
  --y;
  v.pb(mp(x,y));
  update(1,1,MAXN,x,y,1);
}

vi ans;

 rep(i,n) {
  
  update(1,1,MAXN,v[i].fi,v[i].se,-1);
    int ret=query(1,1,MAXN,1,MAXN);
    if(ret<2)
      ans.pb(i+1);
    update(1,1,MAXN,v[i].fi,v[i].se,1);
    }


    cout<<sz(ans)<<"\n";

    rep(i,sz(ans))
    cout<<ans[i]<<" ";
return 0;
}

#include<stdio.h>
int main()
{
	int tc,n,i,j,q=0,ans=0,temp=0,num=0;
	int *a,*b;
	scanf("%d",&tc);
	while(tc--)
	{
		q=0;
		ans=0;
		scanf("%d",&n);
		a=(int *)malloc(n*sizeof(int));
		b=(int *)malloc(n*sizeof(int));
		for(i=0;i<n;i++)
			scanf("%d",&a[i]);
		for(i=0;i<n;i++)
			scanf("%d",&b[i]);
		for(i=0;i<n;i++)
		{
			if(num==a[i] && i!=0)
				continue;
			num=a[i];
			for(j=0;j<n;j++)
			{
				temp=b[j];
				if(temp==b[j+1])
					continue;
				if(temp>=num)
				{
					q=j-i;
				}
					
			}
			if(q>ans)
				ans=q;
		}
		printf("%d\n",ans);		
	}
}	    
for i in xrange(int(raw_input())):
    x=int(raw_input())
    if x%4==0:print x
    if x%4==1:print 1
    if x%4==2:print x+1
    if x%4==3:print 0
    

string = list(raw_input())
orig_string_len = len(string)
s = 0
while s <= orig_string_len - 3:
    if (string[s] == ' ' and string[s + 1] == ' '):
        del string[s]
        orig_string_len -= 1
    else:
        s += 1
print ''.join(string)

#include <iostream>
#include <cmath>
using namespace std;

int main() {
	int N,Nc,K,a,op=1;
	cin>>N>>K;
	Nc=N--;
	cin>>a;
	while(N--)
	{
	    int b;
	    cin>>b;
	    if(abs(a-b)<=K)
	        op++;
	    else
	    {
	        cout<<op<<endl;
	        return 0;
	    }
	    a=b;
	}
	cout<<Nc<<endl;
	return 0;
}

def f(n):
    count=0
    temp=1
    for i in range(5,n+1,5):
        temp=0
        t=i
        while t%5==0:
            t/=5
            temp+=1
        count+=i*temp
    return count
t=int(raw_input())
for i in range(t):
    n=int(raw_input())
    print f(n)  
import sys

s = raw_input()
cnt , n = [[0 for _ in range(len(s)+1)] for __ in range(3)] , len(s)
if s[0] == 'A' :
    cnt[0][0] = 1
elif s[0] == 'B' :
    cnt[1][0] = 1
else :
    cnt[2][0] = 1
for i in range(1,n) :
    if s[i] == 'A' :
        cnt[0][i] = cnt[0][i-1]+1
        cnt[1][i] = cnt[1][i-1]
        cnt[2][i] = cnt[2][i-1]
    elif s[i] == 'B' :
        cnt[1][i] = cnt[1][i-1]+1
        cnt[0][i] = cnt[0][i-1]
        cnt[2][i] = cnt[2][i-1]
    else :
        cnt[2][i] = cnt[2][i-1]+1
        cnt[1][i] = cnt[1][i-1]
        cnt[0][i] = cnt[0][i-1]

ans , dic = 0 , {}
for i in range(n+1) :
    if not dic.has_key((cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])) :
        dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])] = 1
    else :
        ans += dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])]
        dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])]+= 1

print ans

#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
struct point
{
	int dis,v,next;
}e[20010];
int cnt,head[110];
void addedge(int u,int v,int dis)
{
	e[cnt].v = v;
	e[cnt].dis = dis;
	e[cnt].next = head[u];
	head[u] = cnt ++;
}
int dis[110],visit[110];
queue<int> q;
int c[110];
int spfa(int n,int r)
{
	memset(c,0,sizeof(c));
	while(!q.empty()) q.pop();
	for(int i = 1; i <= n; i ++) {
		dis[i] = r;
		q.push(i);
		visit[i] = 1;
	}
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		visit[u] = 0;
		for(int i = head[u]; i != -1; i = e[i].next) 
			if(dis[e[i].v] < dis[u] + e[i].dis) {
				dis[e[i].v] = dis[u] + e[i].dis;
				if(!visit[e[i].v]) {
					c[e[i].v] ++;
					if(c[e[i].v] > n) return 0;
					visit[e[i].v] ++;
					q.push(e[i].v);
				}
			}
	}
	int sum = 0;
	for(int i = 1; i <= n; i ++)
		sum += dis[i];
	printf("%d\n",sum);
	for(int i = 1; i <= n; i ++) {
		printf("%d",dis[i]);
		if(i == n) printf("\n");
		else printf(" ");
	}
	return 1;
}
int main()
{
	int n,m,r,t,x,y,z;
	scanf("%d",&t);
	while(t--) {
		scanf("%d%d%d",&n,&m,&r);
		memset(head,-1,sizeof(head));
		cnt = 0;
		while(m --) {
			scanf("%d%d%d",&x,&y,&z);
			addedge(y,x,z);
		}
		if(!spfa(n,r)) printf("Inconsistent analysis.\n");
	}
	return 0;
}

import math as m
no=int(raw_input())
out=[]
inp=[]
for i in range(no):
    a,b= map(int,raw_input().split())
    inp.append([a,b])

for inputar in inp:
    a=inputar[0]
    b=inputar[1]

    if(a/2<b):
        out.append(-1)
        continue
    
    sol=[i for i in range(1,a+1)]
    if(b==0):
        out.append(sol)
        continue
    interval=m.ceil(a/float(b))
    if(int(interval)%2==0):
        i=0
        while(i<a-2*b):
            for j in range(i,i+b):
                temp=sol[j+b]
                sol[j+b]=sol[j]
                sol[j]=temp
            i+=2*b
        i=a-2*b
        for j in xrange(i,a-b):
                temp=sol.pop(a-1)
                sol.insert(i,temp)
    else:
        for i in xrange(0,a-b,2*b):

            for j in xrange(i,i+b):
                temp=sol[j+b]
                sol[j+b]=sol[j]
                sol[j]=temp
        i+=b
        for j in xrange(i,a-b):
                temp=sol.pop(a-1)
                sol.insert(i,temp)
    out.append(sol)
            

    

    
                
    
        
for i in out:
    if(i==-1):
        print "-1"
    else:
        print ' '.join(map(str,i))




            
        
        

import sys
 
n = input()
lists = map(int,sys.stdin.readline().split())
bit = [0]*32
for i in lists :
	bits = 0
	while i :
		if i&1 :
			bit[bits] += 1
		i >>= 1
		bits += 1
 
ans = 0
for i in range(0,32) :
	if bit[i] :
		ans += (bit[i]*(bit[i]-1)/2)*(1<<i)

print ans
import heapq
def func(pq,sum,res,n,flag):
    if n==0:
        if flag:
            heapq.heappush(pq, sum)
        return
    func(pq, sum+res[n-1], res, n-1, True)
    func(pq, sum, res, n-1, flag)
    


t=int(raw_input())
for i in range(t):
    res=[]
    pq=[]
    
    n=int(raw_input())
    x=raw_input()
    ss=map(int,x.split())#ss-->subset sum list
    ss.sort()
    if n==1:
        res.append(ss[1])
    elif n==2:
        res.append(ss[1])
        res.append(ss[2])
    else:
        res.append(ss[1])
        res.append(ss[2])
        heapq.heappush(pq,ss[1]+ss[2])
        for x in range(3,len(ss)):
            if len(pq)>0 and ss[x]==pq[0]:
                heapq.heappop(pq)
            else:
                func(pq, ss[x], res, len(res), False)
                res.append(ss[x])
                   
                
                
            if len(res)==n:
                break
    for j in range(n):
               print res[j],
    print ''    
    
                
            
        
        
        
        
    
tests = input()
for t in range(tests):
	v = [0]*1001
	n, k = map(int, raw_input().split())
	x = map(int, raw_input().split())
	for i in range(n):
		v[x[i]] += 1
	ok = False
	for i in range(1001):
		if (i-k-1>=0): v[i] += v[i-k-1]
		if (v[i] >= n-1): ok = True
	print "YES" if ok else "NO"

def solve(v):
	global x
	global b
	global c
	global merged
	
	
	for i in merged:
		if len(i) == 2:
			v -= i[1]
		elif v >= i[1]:
			v += i[2]
		
		if v <= 0:
			return False
	
	return True
	
	

def bin_search(mx):	
	low, high = 1, mx
	while low <= high:
		v = (low+high)/2
		rvc, rvp = solve(v), solve(v-1)
		if rvc and not rvp:
			return v
		
		if rvc:
			high = v-1
		else:
			low = v+1
		
def merge():
	global b
	global c
	global dish
	global clan
	
	tmp = []
	i,j = 0, 0
	while i < b and j < c:
		if dish[i][0] < clan[j][0]:
			tmp.append(dish[i])
			i += 1
		else:
			tmp.append(clan[j])
			j += 1
	
	while i < b:
		tmp.append(dish[i])
		i += 1
	
	#~ while j < c:
		#~ tmp.append(clan[j])
		#~ j += 1
	
	return tmp
	

x,b,c = 0,0,0
dish = []
clan = []
merged = []
t = int(raw_input())
for i in range(t):
	x = int(raw_input())
	b = [int(j) for j in raw_input().split()]
	dish = [[b[j],b[j+1]] for j in range(1, len(b[1:]), 2)]
	b = b[0]
	
	c = [int(j) for j in raw_input().split()]
	clan = [[c[j],c[j+1],c[j+2]] for j in range(1, len(c[1:]), 3)]
	c = c[0]
	
	mx = sum([j[1] for j in dish]) + 1
	
	merged = merge()
	#~ print merged
	print bin_search(mx)


C = [[0 for x in xrange(100)] for x in xrange(100)]

def dp():
    for i in range(100):
        for j in range(min(99, i)):
            if j == 0 or j == i:
                C[i][j] = 1
            else:
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];

def work(r, c, g):
    maxUsed = -1
    ans = []
    x = r
    y =  c
    while C[x][y] < g:
        x = x + 1
        if x == 100:
            x = 99;
            break;
    while C[x][y] > g:
        x = x - 1;
        if x < 0:
            x = 0;
            break;
    if C[x][y] == g:
        print 1
        print g
        return;

    ans += [C[x][y]]
    g -= C[x][y]
    maxUsed = C[x][y]
    y = y - 1;
    while g > 0:
        while C[x][y] < g and C[x][y] <= maxUsed:
            x = x + 1;
            if x == 100:
                x = 99;
                break;
        while C[x][y] > g or C[x][y] >= maxUsed:
            x = x - 1;
            if x < 0:
                x = 0;
                break;
        ans += [C[x][y]]
        g -= C[x][y];
        y = y - 1;

    print len(ans);
    s = ""
    for q in ans:
        s += str(q) + " "
    print s


if __name__ == '__main__':
    dp()
    T = int(raw_input())
    while T > 0:
        T = T - 1;
        r, c, g = map(int, raw_input().split());
        work(r, c, g)
    exit(0)

import math

list_u = []
list_v = []

def find_level(n):
	return int(math.floor(math.log(n,2))) + 1

def find_lca(u, v):
	while u != v:
		while u > v:
			if u % 2 == 0:
				list_u.append(0)
			else:
				list_u.append(1)
			u = u / 2
		while v > u:
			if v % 2 == 0:
				list_v.append(0)
			else:
				list_v.append(1)
			v = v / 2
	# list_u.reverse()
	# list_v.reverse()
	return u

if __name__ == "__main__":
	Q = raw_input()
	Q = int(Q)
	while(Q > 0):
		Q -= 1
		del list_u[:]
		del list_v[:]
		ans = 0
		n_u_v = raw_input()
		n, u, v = n_u_v.split()
		n = int(n)
		u = int(u)
		v = int(v)
		lca = find_lca(u, v)
		# n_level = find_level(n)
		# lca_level = find_level(lca)
		# u_level = find_level(u)
		# v_level = find_level(v)
		# max_diff_level = max(u_level - lca_level, v_level - lca_level)
		# ans += 2**(n_level - max_diff_level - 1) - 1
		# complex_level = n_level - max_diff_level
		# start = 2**(complex_level - 1)
		# end = 2**(complex_level)
		# for i in xrange(start, end):
		# 	tmp = i
		# 	for item in list_u:
		# 		tmp = tmp*2 + item
		# 		if tmp > n:
		# 			break
		# 	if tmp > n:
		# 		break
		# 	tmp = i
		# 	for item in list_v:
		# 		tmp = tmp*2 + item
		# 		if tmp > n:
		# 			break
		# 	if tmp > n:
		# 		break
		# 	else:
		# 		ans += 1
		tmp = n
		for item in list_u:
			if tmp % 2 != item:
				tmp -= 1
			tmp /= 2
		num1 = tmp
		tmp = n
		for item in list_v:
			if tmp % 2 != item:
				tmp -= 1
			tmp /= 2
		num2 = tmp
		ans = min(num1, num2)
		print ans

bcof = [[1 for i in xrange(n+1)] for n in xrange(102)]

for i in xrange(1, 101):
	for j in xrange(1, i+1):
		bcof[i+1][j] = bcof[i][j-1] + bcof[i][j]

for _ in xrange(int(raw_input())):
	n, k, p = map(int, raw_input().split())
	s = 0
	ans = [n for _ in xrange(k+1)]
	for i in xrange(1, k+1):
		ans[i] = (pow(n+1, i+1)) - 1
		for j in range(2, i+2):
			ans[i] -= ((bcof[i+1][j]*ans[i+1-j]))
		ans[i] = (ans[i]/(i+1))
	print (ans[k] % p)
#!/usr/bin/python
mod = 1000000007
#import psyco
#psyco.full()
def matrix_mult(A, B):
  C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
  for i in range(3):
	  for j in range(3):
		  for k in range(3):
			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
	  	          if(C[i][k] > 1000000007):
				C[i][k] = C[i][k] % 1000000007
  return C

def matrix_mult_1(A, B):
  C = [[0, 0],[0,0]]
  for i in range(2):
	  for j in range(2):
		  for k in range(2):
			  C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % 1000000007
  return C

def matrix_mult_4(A, B):
  C = [[0, 0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
  for i in range(5):
	  for j in range(5):
		  for k in range(5):
			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
		          if(C[i][k] > 1000000007):
				C[i][k] = C[i][k] % 1000000007
  return C

def matrix_mult_5(A,B):
  C=[]
  for i in range(9):
	  C.append([0,0,0,0,0,0,0,0,0])
  for i in range(9):
	  for j in range(9):
		  for k in range(9):
			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
		          if(C[i][k] > 1000000007):
				C[i][k] = C[i][k] % 1000000007
  return C

def matrix_mult_6(A,B):
  C=[]
  for i in range(18):
	  C.append([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
  for i in range(18):
	  for j in range(18):
		  for k in range(18):
			  #if( A[i][j] > mod):
		#		  A[i][j] = A[i][j] % mod
		#	  elif (B[j][k] > mod):
		#		  B[j][k] = B[j][k] % mod
			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
	       #           if(C[i][k] > mod):
			  C[i][k] = C[i][k] % mod
  return C

def fast_exp(A, n, flag):
  if n == 1:
	return A
  else:
    if n & 1 == 0:
      A1 = fast_exp(A, n/2,flag)
      if(flag == 2):
	      return matrix_mult_1(A1, A1)
      elif (flag == 3):
	      return matrix_mult(A1,A1)
      elif (flag == 4):
	      return matrix_mult_4(A1,A1)
      elif( flag == 5):
	      return matrix_mult_5(A1,A1)
      elif (flag == 6):
	      return matrix_mult_6(A1,A1)
    else:
      A1 = fast_exp(A,n-1,flag)
      if(flag == 2):
	      return matrix_mult_1(A,A1)
      elif(flag == 3):
	      return matrix_mult(A,A1)
      elif(flag == 4):
	      return matrix_mult_4(A,A1)
      elif(flag == 5):
	      return matrix_mult_5(A,A1)
      elif(flag == 6):
	      return matrix_mult_6(A,A1)

def fast_pow(n):
  if n == 1:
	return 2
  if n == 0:
        return 1
  else:
    if n % 2 == 0:
		        ans = fast_pow(n/2)
      		   	ans = ans % mod
     			return (ans*ans) % mod
    else:
			ans = fast_pow(n-1)
		        ans = ans % mod
		        return ans*2

def solve_1(n):
    A = [[0,1,0],[0,0,1],[1,1,1]]
    A_n = fast_exp(A,n-3)
    return A_n[2][0] + A_n[2][1] + A_n[2][2]*2

def solve_2(n):
    if(n == 1):
	    return 2
    elif(n == 2):
	    return 7
    A = [[0,1],[2,3]]
    A_n = fast_exp(A,n-2,2)
    return A_n[1][0]*2 + A_n[1][1]*7

def solve_3(n):
    A = [[0,1,0],[0,0,1],[-2,3,6]]
    if(n == 1):
	    return 4
    elif(n == 2):
	    return 25
    elif(n == 3):
    	    return 161
    A_n = fast_exp(A,n-3,3)
    return A_n[2][0]*4 + A_n[2][1]*25 + A_n[2][2]*161

def solve_4(n):
    ans= [8,89,1033,11929,137845]
    if(n <= 5):
	    return ans[n-1]
    A = [[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[8,-30,-21,20,10]]
    A_n = fast_exp(A,n-5,4)
    return A_n[4][0]*8 + A_n[4][1]*89 + A_n[4][2]*1033 + A_n[4][3]*11929 + A_n[4][4]* 137845

def solve_5(n):
    ans = [16,317,6631,137845,2867739,59655167,1240971177,25815151595,537016650729]
    if(n <= 9):
	    return ans[n-1]
    A = [[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1],[-10,69,29,-662,790,73,-278,9,21]]
    Ab = fast_exp(A,n-9,5)
    return Ab[8][0]*16 + Ab[8][1]*317+ Ab[8][2]*6631+ Ab[8][3]*137845+Ab[8][4]*2867739+Ab[8][5]*59655167 + Ab[8][6]*1240971177 + Ab[8][7]* 25815151595 + Ab[8][8]*537016650729 

def solve_6(n):
	ans =[32,1129,42563,1592731,59655167,2234126207,83670667271,3133560234217,117355367786585,4395090865370635,164601109918978615,6164497208894901477,230867373009598884627,8646243499452479433569,323811570588787197424201,12127108524504811121752257,454173891617617632766031151,17009324474195992258878836533]
	if(n <= 18):
		return ans[n-1]
	for i in range(18):
		ans[i] = ans[i] % mod
	A=[[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]]
	A.append([28,-622,3386,6203,-70276,38077,355981,-410368,-499260,751787,154999,-396016,27152,50702,-3905,-2391,120,36])
        Ab = fast_exp(A,n-18,6)
	#print len(ans)
	finalans = 0
	for i in range(18):
		finalans = finalans + ((Ab[17][i] % mod)*ans[i]) % mod
		if(finalans > mod):
			finalans % mod
	return finalans
inp = raw_input()
inp = inp.split()
#print inp[0],inp[1]
inp[0] = int(inp[0]); inp[1] = int(inp[1]);
if(inp[0] == 1):
	if(inp[1] == 1):
		print 2
	else:
		print fast_pow(inp[1])%mod
elif(inp[0] == 2):
	print (solve_2(inp[1])*2)%mod
elif(inp[0] == 3):
	print (solve_3(inp[1])*2)%mod
elif(inp[0] == 4):
	print (solve_4(inp[1])*2)%mod
elif(inp[0] == 5):
	print (solve_5(inp[1])*2)%mod
elif(inp[0] == 6):
	print (solve_6(inp[1])*2)%mod

// Alfonso2 Peterssen (mukel)
#include <iostream>
#include <cstdio>
#include <sstream>

#include <algorithm>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>

#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cassert>

using namespace std;

typedef long long int64;

#define endl '\n'
#define SZ(c) ((int)((c).size()))
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
#define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i)
#define ALL(c) (c).begin(), (c).end()

struct fastCin {
	char cur;
	inline char nextChar() { return cur = getc_unlocked(stdin); }
	inline char peekChar() { return cur; }
	inline operator bool() { return (peekChar() != 0); }
	inline static bool isBlank(char c) { return (c < '0' && c); }
	inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; }
	fastCin() { cur = 0; }
	char tmp[1 << 8];
	inline fastCin& operator >> (int & n) {
		if (skipBlanks()) {
			int sign = +1;
			if (peekChar() == '-') {
				sign = -1;
				n = nextChar() - '0';
			}
			else
				n = peekChar() - '0';
			while (!isBlank(nextChar())) {
				n *= 10;
				n += peekChar() - '0';
			}
			n *= sign;
		}
		return *this;
	}
	inline fastCin& operator >> (int64 & n) {
		if (skipBlanks()) {
			int sign = +1;
			if (peekChar() == '-') {
				sign = -1;
				n = nextChar() - '0';
			}
			else
				n = peekChar() - '0';
			while (!isBlank(nextChar())) {
				n *= 10;
				n += peekChar() - '0';
			}
			n *= sign;
		}
		return *this;
	}
	#define cin cin2
} cin2;

const int64
	MAXN = 2 * 3114LL * 3114 * 3114 * 3114 * 3114;

vector< int64 > powerNums;

int64 squareRoot(int64 n)
{
	int64 r = sqrt(n);
	//while (r * r < n) ++r;
	//while (r * r > n) --r;
	return r;
}

bool isPowerNum(int64 n)
{
	if (n < 4) return false;
	int64 sq = squareRoot(n);
	return sq * sq == n || binary_search(ALL(powerNums), n);
}

int64 getPowerNumsLessThan(int64 n)
{
	if (n < 4) return 0;

	int64 sq = squareRoot(n);

	int64 r = lower_bound(ALL(powerNums), n) - powerNums.begin();

	r += sq - 1;
	if (sq * sq == n)
		--r;

	return r;
}

int64 getNonPowerIndex(int64 n)
{
	assert( !isPowerNum(n) );
	return n - getPowerNumsLessThan(n) + 1;
}

int simulate(int64 n)
{
	int64 nIndex = getNonPowerIndex(n);

	//cout << "nIndex = " << nIndex << endl;

	int64 pos = 2;

	int steps = 0;

	int64 lo, hi;

	while (1)
	{
		steps++;

		if (pos == nIndex)
			return steps;

		if (pos < nIndex)
			pos *= 2;
		else
		{
			lo = pos / 2;
			hi = pos;
			break;
		}
	}

	while (lo + 1 < hi)
	{
		int64 mid = (lo + hi) / 2;

		steps++;

		if (mid == nIndex)
			return steps;

		if (mid < nIndex)
			lo = mid;
		else
			hi = mid;
	}

	return steps + 1;
}

void calcNonSquarePowerNums()
{
	powerNums.reserve(1 << 20);

	for (int64 a = 2, f; (f = a * a * a) <= MAXN; ++a)
	{
		int64 limit = MAXN / a + 1;
		for (;;) {
			int64 sq = squareRoot(f);

			if (sq * sq != f)
				powerNums.push_back(f);

			if (f >= limit)
				break;
			f *= a;
		}
	}

	sort(ALL(powerNums));
	powerNums.erase(unique(ALL(powerNums)), powerNums.end());

	//cout << SZ(powerNums) << endl;
}

int main()
{
	calcNonSquarePowerNums();

	int T;
	for (cin >> T; T--;)
	{
		int64 P; cin >> P;
		if (isPowerNum(P))
			cout << getPowerNumsLessThan(P) + 1 << endl;
		else
			cout << simulate(P) << endl;
	}

	return 0;
}

import sys
f = sys.stdin

T = int(f.readline())
for tc in xrange(T):
    N = int(f.readline())
    if N%2 == 1:
        print 1
        for i in xrange(N): f.readline()
        continue
    x,y = [list(l) for l in zip(*[[int(c) for c in f.readline().split()] for i in xrange(N)])]
    x.sort(),y.sort()
    x1,y1 = ( v[N/2] - v[N/2 - 1] + 1 for v in (x,y))
    print x1*y1

# matrix multiplication function
def matmul(a,b,l,m,n):
	c = []
	for i in range(l):
		dummy = []
		for j in range(n):
			ans = 0
			for k in range(m):
				ans = ans + a[i][k] * b[k][j]
			dummy.append(ans)
		c.append(dummy)
	return c

#function to create identity matrix in case matrix is raised to power 0
def identity_matrix(n):
	c = []
	for i in range(n):
		k = []
		for j in range(n):
			if i == j:
				k.append(1.0)
			else:
				k.append(0.0)
		c.append(k)
	return c

#function to raise a matrix A to power n
def power_matrix(a,n):
	if n == 0:
		return identity_matrix(26)
	elif n == 1:
		return a
	elif n%2 == 0:
		return power_matrix(matmul(a,a,26,26,26),n/2)
	elif n%2 == 1:
		return matmul(a,power_matrix(matmul(a,a,26,26,26),(n-1)/2),26,26,26)
     

dup3 = []
for i in range(17576):
	dup3.append(0)
dup2 = []
for i in range(676):
	dup2.append(0)
dup1 = []
for i in range(26):
	dup1.append(0)

def initialize():
	for i in range(17576):
		dup3[i] = 0
	for i in range(676):
		dup2[i] = 0
	for i in range(26):
		dup1[i] = 0

def duplicate(s):
	l = len(s)
	ans = 1
	if l == 1:
		ans = ord(s[0])-97
		if dup1[ans] == 1:
			return 1
		else:
			dup1[ans] = 1
			return 0
	elif l == 2:
		ans = 26*(ord(s[0])-97) + (ord(s[1])-97)
		if dup2[ans] == 1:
			return 1
		else:
			dup2[ans] = 1
			return 0
	elif l == 3:
		ans = 676*(ord(s[0])-97) + 26*(ord(s[1])-97) + (ord(s[2])-97)
		if dup3[ans] == 1:
			return 1
		else:
			dup3[ans] = 1
			return 0



a = []
for i in range(26):
	k = []
	for j in range(26):
		k.append(0.0)
	a.append(k)
t = input()
for dummy in range(t):
	initialize()
	n, k = raw_input().split()
	n = int(n)
	k = int(k)
	word = raw_input()
	length = len(word)
	word = list(word)
	for i in range(length):
		word[i] = ord(word[i]) - 97
	for i in range(26):
		num = raw_input().split()
		for j in range(26):
			a[i][j] = float(num[j])
	a = power_matrix(a,k)
	prob = 0
	for j in range(n):
		p1 = 1
		str1 = raw_input()
		if(len(str1) != length):
			continue
		elif duplicate(str1) == 1:
			continue
		else:
			s = list(str1)
			for i in range(len(s)):
				s[i] = ord(s[i])-97
			for i in range(length):
				p1 = p1*a[word[i]][s[i]]
				if p1 == 0:
					break
			prob = prob + p1
	print prob 
t = int(raw_input())
for i in xrange(t):
    n = int(raw_input())
    a = map(int, raw_input().split())
    mi = a[0]
    ma = a[0]
    for j in xrange(1,n):
        b = mi*a[j]
        c = mi+a[j]
        d = mi-a[j]
        e = ma*a[j]
        f = ma+a[j]
        g = ma-a[j]
        mi = min(b,c,d,e,f,g)
        ma = max(b,c,d,e,f,g)
    print mi

c=[]
for i in range(100001):
    c.append(-1)
n,k=map(int,raw_input().split())
l=list(map(int,raw_input().split()))
maxl=max(l)
ans=0
maxi=-1
for i in range(n):
    if k<l[i]:
        for j in range(k,maxl+1,l[i]):
            if c[j]!=-1:
                maxi=max(maxi,c[j])
    ans+=i-maxi
    c[l[i]]=i
print ans

test = input()
from itertools import combinations
while test:
    test-=1
    n,k = map(int,raw_input().split())
    weights = []
    costs = []
    index = []
    for i in range(n):
        c,w = map(int,raw_input().split())
        costs.append(c)
        weights.append(w)
        index.append(i)
    max = 0
    for r in range(1,n+1):
        for sub in combinations(index,r):
            cost = 0
            weight = 0
            for i in sub:
                cost += costs[i]
                weight += weights[i]
            if cost <=k and weight > max:
                max = weight
    print max
        
    
    

"""flag=1
def sor(a,n):
    global flag
    i=0
    while i<len(a):
        o=[]
        t=a[i]
        #del(a[i])
        #a=[t]+a
        j=i+1
        k=0
        while j<len(a):
            if(t>a[j]):
                k=1
                o=[t]+o
                #print t," ",a[j]
                t=a[j]
                #del(a[j])
                #i+=1
                #a=[t]+a
            #else:
                #if(j==len(a)-1)&(k==0):
                 # flag+=1     
            j+=1
        if(o!=[]):
            flag+=1
            a=o[::-1]   
def sort(a,n):
    global flag
    i=0
    while i<n:
        j=i+1
        while j<n-1:
            if(a[i]>a[j]):
                flag+=1
                while((j<n-1)&(a[i]>a[j])):
                    j+=1
                t=a[i]
                a[i]=a[j]

                a[j]=t
            j+=1    
        i+=1"""
def index(lis,l,r,k):
    while(r-l>1):
        m=l+(r-l)/2;
        if(lis[m]<=k):
            r=m
        else:
            l=m
    return r        
def count(lis,n):
    t=[]
    len1=1
    t+=[lis[0]]
    i=1
    while i<n:
        if(lis[i]>t[0]):
            t[0]=lis[i]
        elif(lis[i]<t[len1-1]):
            t+=[lis[i]]
            len1+=1
        else:
            t[index(t,-1,len1-1,lis[i])]=lis[i]
        i+=1    
    """if(len(t)!=0):    
     k=0
     l=[]
     for i in t:
         t=k
         k=lis[k:].index(i)
         l+=[k+t]
     i=0
     while i<len(l):
         del(lis[l[i]-i])
         i+=1"""
    return len1     
t=input()
a=[int(x) for x in raw_input().split()]
"""l=0
while(len(a)!=0):
     g=count(a,t)
     l+=1
     if(g!=a):
         a=g
     else:
         l+=len(a)
         break"""
print count(a,t)        


p=10**9+7;

def modpow(x,n):
	if(n==0):
		return 1;
	elif(n%2==0):
		m=modpow(x,n/2);
		return (m*m)%p;
	else:
		m=modpow(x,n/2);
		return (m*m*x)%p;		

def modinv(x):
	return modpow(x,p-2);



inv2=modinv(2);
mods=[1]*31;

mod2s=[1]*31;
for i in range(1,31):
	mods[i]=(mods[i-1]*3)%p;
	mod2s[i]=(mod2s[i-1]*2);

#A:0 indexed array, m:no. of minutes,x:position in array
#Returns the sum upto position x(0 indexed)
def computeSum(A,m,x):
	if(x==-1):
		return 0;
	sum1=0;
	n=len(A)-1;# An extra element at the end
	i=1;
	while((i<=n)and((i*(2**m)-1)<=x)):
		#INV:Sum of indices upto (i-1)*(2^m)-1 has been taken, i.e. the elements before old A[i-1] (exclusive) has been considered
		sum1=(sum1+A[i-1]+(A[i]+A[i-1])*(mods[m]-1)*inv2)%p;
		i=i+1;
	if((i<=n)and ((i-1)*(2**m))<=x):
		sum1=(sum1+A[i-1]+computePartSum(A[i-1],A[i],m,x-mod2s[m]*(i-1)))%p;
	return sum1;

def computePartSum(a,b,m,x):
	if(m==0):
		return 0;
	mid=2**(m-1)	
	if(x<mid):
		return computePartSum(a,(a+b)%p,m-1,x);
	elif(x==mid):
		return (a+b+(a+(a+b))*(mods[m-1]-1)*inv2)%p;
	else:# x>mid
		return 	(a+b+(a+(a+b))*(mods[m-1]-1)*inv2+computePartSum(a+b,b,m-1,x-(mid)))%p;


T=input();
sums=[];
for i in range(T):
	[N,m,x,y]=map(lambda x:int(x),raw_input().split());
	x=x-1;
	y=y-1;
	A=map(lambda x:int(x),raw_input().split());
	A.append(0);
	sums.append((computeSum(A,m,y)-computeSum(A,m,x-1))%p);

for s in sums:
	print(s);
def comb(n,k):
	return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))
	
import math
t=int(raw_input())
while t:
	t=t-1
	s=raw_input()
	n,k,m=(long(x) for x in s.split())
	ans=''
	if comb(n,k)<m:
		print -1
		continue
	for x in range(0,n):
		
		if n-(x+1)-k>=0:
			c=comb(n-(x+1),k)
		else:
			c=0
		if c<m:
			ans=ans+'1'
			k=k-1
			m=m-c
		else:
			ans=ans+'0'
	print ans

def fn():
    mod = 1000000007
    u,d,m,n = map(int,raw_input().split())
    
    a = []
    for i in range(3):
        t = []
        for j in range(n):
            t.append(0)
        a.append(t)
        
    for i in range(n):
        t1 = pow(i,d,n)
        t2 = (u-i)/n + 1
        t2 %= mod
        
        a[0][t1]+=t2
        a[0][t1]%=mod
        
    for i in range(n):
        for j in range(n):
            a[1][(i+j)%n]+= (a[0][i] * a[0][j])
            a[1][(i+j)%n]%= mod
            
    
    for i in range(n):
        for j in range(n):
            a[2][(i+j)%n]+= (a[0][i]* a[1][j])
            a[2][(i+j)%n]%= mod

    print a[2][m] % mod

t = int(raw_input())

for i in range(t):
    fn()
__author__ = 'user'
d = {}
def find_max(v):
    if d.__contains__(v):
        return d[v]
    a = v/2
    b = v/3
    c = v/4
    if a+b+c > v:
        d[v]=find_max(a)+find_max(b)+find_max(c)
    else:
        d[v]=v
    return d[v]

for _ in xrange(10):
    v = input()

    print find_max(v)
from sys import stdin
 
MOD = 1000000007
 
for trial in xrange(int(stdin.readline())):
    N,K = map(int,stdin.readline().split())
    Kmod = K%MOD
    K1mod=(K-1)%MOD
    K2mod=(K-2)%MOD
    if K==1: print 0
    elif K==2: print 2
    else:
        inner = ((Kmod*K1mod*K1mod)%MOD + (Kmod*K1mod*K2mod*K2mod)%MOD)%MOD
        if N==1: print (K*(K-1))%MOD
        elif N==2: print inner
        else: print ((inner)*pow(K**2-3*K+3,N-2,MOD))%MOD 
n,m=map(int,raw_input().split())
dic={}
for i in range(n):
    a,b,c,d=map(int,raw_input().split())
    if (a,b) in dic:
        if dic[(a,b)][1]<=d:
            dic[(a,b)]=[c,d]
    else:
        dic[(a,b)]=[c,d]
for i in range(m):
    a,b=map(int,raw_input().split())
    print dic[(a,b)][0]
#print dic
import sys
scan = lambda:sys.stdin.readline().rstrip()

def hammingDist(a,b):
	return sum(a[i]!=b[i] for i in range(len(a)))

goodStr2 = [[],[],[],[],[],[],[],[],[]]
goodStr3 = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]

def isGood(s):
    l = len(s)
    if l<3:
        return True
    else:
       # for i in range(l-2):
       #     for j in range(1,l/2+1):
       #         if i+2*j > l-1:
       #             break
       #         if s[i] == s[i+j] and s[i+j] == s[i+ 2*j]:
       #             return False
        i = l-1
        for j in range(1,15):
            if i < 2*j:
                break
            if s[i] == s[i-j] and s[i-j] == s[i-2*j]:
                return False
    return True

def genGoodStr2(string):
    if len(string)>=9:
        return
    if isGood(string):
        goodStr2[len(string)].append(string)
        genGoodStr2(string+"a")
        genGoodStr2(string+"b")

def genGoodStr3(string):
    if len(string)>=27:
        return
    if isGood(string):
        goodStr3[len(string)].append(string)
        genGoodStr3(string+"a")
        genGoodStr3(string+"b")
        genGoodStr3(string+"c")


genGoodStr2("a")
genGoodStr2("b")
genGoodStr3("a")
genGoodStr3("b")
genGoodStr3("c")

#print len(goodStr2)
#print len(goodStr3)

for t in range(int(scan())):
    #a_k = raw_input().split(' ')
    A,K = map(int,scan().split())
    #A = int(a_k[0])
    #K = int(a_k[1])
    s = scan()
    l = len(s)
    if A==1:
        if l < 3:
            print 1
        else:
            print 0
    elif A==2:
        if l<9:
            count = 0
            lim = len(goodStr2[l])
            for i in range(lim):
                if hammingDist(goodStr2[l][i],s) <= K:
                    count+=1
            print count
        else:
            print 0
    else: # A==3
        if l<27:
            count = 0
            lim = len(goodStr3[l])
            for i in range(lim):
                if hammingDist(goodStr3[l][i],s) <= K:
                    count+=1
            print count
        else:
            print 0

def power(a,b):
    x=1
    while(b):
        if(b&1):
            x=(x*a)%m
        a=(a*a)%m
        b>>=1
    return x
m=10**9+7
t=int(raw_input())
while t>0:
    t-=1
    n,k=map(int,raw_input().split())
    if k==1:
        print 0
        continue
    inv=power(k-1,m-2)
    inv=power(inv,3)
    inv=(k*inv)%m
    temp=power(k,n)
    n1=(n*n)%m
    t6=(((3*n1)%m+6*n+2)*temp)%m
    t1=(2*((temp*k)%m)*(3*n1+3*n+2))%m
    t2=(((temp*k*k)%m)*(3*n1-1))%m
    temp1=power(k,2*n+1)
    t3=(6*(n+1)*temp1)%m
    t4=(6*k*((n*temp1)%m))%m
    t5=power(k,3*n+2)
    ans=(t6+t5-t4+t3+t2-t1-2*k-2)%m
    ans=(ans*inv)%m
    print ans 
uniqueueId = 0
class Dictionary(object):
	#generic dectionary object
	def __init__(self, type):
		self.descriptor = type
		self.hashTable = {}

	def setKeyValPair(self, key, value):
		self.hashTable[key] = value

	def getValue(self, key):
		if key in self.hashTable:
			return self.hashTable[key]
		return None

#helper funcs
def getObject(name):
	global dictionary
	obj = dictionary.getValue(name)
	if obj == None:
		obj = Person(name)
		dummyAncestor = Person(None)
		dummyAncestor.initChildrenList(obj)
		obj.initParentList(dummyAncestor)
	return obj

def setFirstObjectParentofSecondObject(parentObj, child):
	#is it possible that parentObj is already a parent of child? No since there are no cyclic relations
	for parentOtherHalf in child.getParentList():
		break
	newParents = set([parentObj])

	#update the children set
	parentObj.appendChildren(parentOtherHalf.getChildrenList())
	if type(parentOtherHalf.getName()) != type(1):
		parentObj.setOtherHalf(parentOtherHalf)
		parentOtherHalf.setOtherHalf(parentObj)
		parentOtherHalf.initChildrenList(parentObj.getChildrenList())
		newParents.add(parentOtherHalf)
	elif parentObj.getOtherHalf() != None:
		existingOtherHalf = parentObj.getOtherHalf()
		newParents.add(existingOtherHalf)
		existingOtherHalf.initChildrenList(parentObj.getChildrenList())
		
	#update the parent set in the children
	for child in parentObj.getChildrenList():
		child.initParentList(newParents)

def setTheObjectBros(bro1, bro2):
	bBro1Parent = not bro1.isMyCurrentParentDummy()
	bBro2Parent = not bro2.isMyCurrentParentDummy()
	parent1 = bro1.getParentList()
	parent2 = bro2.getParentList()
	for parentBro1 in parent1:
		break
	for parentBro2 in parent2:
		break
	broBand1 = parentBro1.getChildrenList()
	broBand2 = parentBro2.getChildrenList()

	if bBro1Parent and bBro2Parent:
		newParents = parent1.union(parent2)
		newBroBand = broBand1.union(broBand2)
		for bro in newBroBand:
			bro.initParentList(newParents)
		parentBro1.initChildrenList(newBroBand)
		parentBro2.initChildrenList(newBroBand)
		#update other half fields too!
		if parentBro1.__hash__() != parentBro2.__hash__():
			parentBro1.setOtherHalf(parentBro2)
			parentBro2.setOtherHalf(parentBro1)
	elif bBro1Parent or bBro2Parent:
		#make sure that bro1 is the one with valid parent parent1
		if not bBro1Parent:
			bro1, bro2 = bro2, bro1
			parent1, parent2 = parent2, parent1
			broBand1, broBand2 = broBand2, broBand1
		iterParent1 = iter(parent1)
		half1 = next(iterParent1)
		half1.appendChildren(broBand2)
		if len(parent1) == 2:
			half2 = next(iterParent1)
			half2.initChildrenList(half1.getChildrenList())
		for bro in broBand2:
			bro.initParentList(parent1)
	else:
		#make sure that bro1 is the one with higher no. of bros
		if len(broBand1) < len(broBand2):
			bro1, bro2 = bro2, bro1
			parent1, parent2 = parent2, parent1
			broBand1, broBand2 = broBand2, broBand1
		for parent in parent1:
			break
		parent.appendChildren(broBand2)
		for bro in broBand2:
			bro.initParentList(parent1)

def bfs(bfsPerson):
	global distance, visited, currentVisitedCount
	bfsPersonId = bfsPerson.__hash__()
	queue = [[bfsPerson, 0]]
	while len(queue) != 0:
		thisPersonEntry = queue.pop(0)
		thisPerson = thisPersonEntry[0]
		thisPersonId = thisPerson.__hash__()
		#mark it as visited and update its distance
		if visited[thisPersonId] != currentVisitedCount:
			visited[thisPersonId] = currentVisitedCount
		else:
			continue
		thisPersonDist = thisPersonEntry[1]
		distance[bfsPersonId][thisPersonId] = thisPersonDist
		#append thisPersonEntry's parents, siblings, and offsprings to the list, if they are not already visited,  with updated distance
		#parents
		for parent in thisPerson.getParentList():
			if type(parent.getName()) != type(1) and visited[parent.__hash__()] != currentVisitedCount:
				queue.append([parent, thisPersonDist + 1])
		#siblings
		#The outer for loop is executed only once. It serves the purpose of initialization of parent
		for parent in thisPerson.getParentList():
			for sibling in parent.getChildrenList():
				if visited[sibling.__hash__()] != currentVisitedCount:
					queue.append([sibling, thisPersonDist + 1])
			break;
		#children
		for child in thisPerson.getChildrenList():
			if visited[child.__hash__()] != currentVisitedCount:
				queue.append([child, thisPersonDist + 1])
		

def getDistance(person1, person2):
	global distance, currentVisitedCount
	if distance[person1.__hash__()][person1.__hash__()] == 0:
		return distance[person1.__hash__()][person2.__hash__()]
	elif distance[person2.__hash__()][person2.__hash__()] == 0:
		return distance[person2.__hash__()][person1.__hash__()]
	else:#polulate the distance array for person1
		bfs(person1)
		currentVisitedCount += 1
		return distance[person1.__hash__()][person2.__hash__()]

class Person(object):
	def __init__(self, name):
		#if name is None, its a dummy object.
		global dictionary, uniqueueId
		if name == None:
			self.name = uniqueueId
		else:
			self.name = name
		self.uid = uniqueueId
		uniqueueId += 1
		self.otherHalf = None
		#use dictionary instead of list
		self.parents = set()
		self.children = set()
		dictionary.setKeyValPair(self.name, self)

	def __hash__(self):
		# The only required property is that objects which compare equal have the same hash value
		return self.uid
	
	def __str__(self):
		return str(self.name)

	def getName(self):
		return self.name

	def getOtherHalf(self):
		return self.otherHalf

	def getParentList(self):
		return self.parents

	def getChildrenList(self):
		return self.children

	def appendChildren(self, children):
		if isinstance(children , set):
			self.children = self.children.union(children)
		else:
			self.children.add(children)

	def initChildrenList(self, children):
		#used for setting same set of children for both parents, so that changes are propogated to them
		if isinstance(children , set):
			self.children = children
		#used while normal initialization of child od dummy parent
		else:
			self.children = set([children])

	def appendParent(self, parent):
		if isinstance(parent, set):
			self.parents = self.parents.union(parent)
		else:
			self.parents.add(parent)

	def initParentList(self, parents):
		#used for setting same set of parent for all the children, so that changes are propogated to all
		if isinstance(parents, set):
			self.parents = parents
		#used while normal initialization of dummy parent for a child
		else:
			self.parents = set([parents])

	def setOtherHalf(self, otherHalf):
		self.otherHalf = otherHalf

	def isMyCurrentParentDummy(self):
		return len(self.parents) == 1 and type(next(iter(self.parents)).getName()) == type(1)


#main prog
#create a dictionary to lookup Person object from its name
dictionary = Dictionary("nameLookupTable")
NRStr = raw_input().split()
N = int(NRStr[0])
R = int(NRStr[1])
for i in range(R):
	relation = raw_input().split()
	if relation[2] == "father" or relation[2] == "mother":
		parentObj = getObject(relation[0])
		child = getObject(relation[4])
		setFirstObjectParentofSecondObject(parentObj, child)
	elif relation[2] == "son" or relation[2] == "daughter":
		parentObj = getObject(relation[4])
		child = getObject(relation[0])
		setFirstObjectParentofSecondObject(parentObj, child)
	else:
		c1 = getObject(relation[0])
		c2 = getObject(relation[4])
		setTheObjectBros(c1, c2)
	
#for name in dictionary.hashTable:
#	personObj = dictionary.hashTable[name] #This is hacky
#	if type(personObj.getName()) != type(1):
#		print
#		print "person name: ", personObj
#		print "Other half: ", personObj.getOtherHalf()
#		print "Its offsprings: \n\t", 
#		for child in personObj.getChildrenList():
#			print child,
#		print
#		print "Its parent list: \n\t", 
#		for parent in personObj.getParentList():
#			print parent,
#		print
#distance is 2d list which is indexed by person's uniqueue id. uniqueue id can never go beyond 2*N
distance = [[ -1 for i in range(2*N + 1)] for j in range(2*N + 1)]
currentVisitedCount = 1
visited = [0] * 2*N
Q = int(raw_input())
for i in range(Q):
	strXY = raw_input().split()
	X = getObject(strXY[0])
	Y = getObject(strXY[1])
	print getDistance(X, Y)

cases=int(raw_input())
while cases:
	length=int(raw_input())
	m=raw_input().split()
	arr=map(int,m)
	
	hash=[-1]*length
	modu=[0]*(length+1)
	sum=0
	modu[0]=0
	hash[0]=0
	for i in range(1,length+1):
		sum=sum+arr[i-1]
		x=sum%length
		if hash[x]==-1:
			hash[x]=i
		else:
			count=i-hash[x]
			print count
			for j in range(hash[x],i):
				print j+1,
			print " "		
			break		
	cases-=1
	
	
		
	
		
	
	

import sys,copy
mynumber=0
def merge(a,b,n,m):
    global mynumber
    i=0
    j=0
    c=[]
    if(n==0):
        return b
    if(m==0):
      return a
    while((i<n) and (j<m)):
        if(a[i]<=b[j]):
            c+=[a[i]]
            i+=1
        else:
            c+=[b[j]]
            mynumber+=len(a[i:])
            j+=1
    if(i<n):
        c+=a[i:]
    if(j<m):    
        c+=b[j:]
    return c
def mergesort(a,n):
    if(n==1):
        return a
    else:
        b=mergesort(a[:n/2],n/2)
        c=mergesort(a[n/2:],n-n/2)
        return merge(b,c,n/2,n-n/2)
def count_inversions(arr,n):
    global mynumber
    mynumber=0
    arr2=copy.deepcopy(arr)
    #arr2[x],arr2[y]=arr2[y],arr2[x]
    mergesort(arr2,n)
    return mynumber
def another_count_inversions(arr,n):
    i=0
    count=0
    while i<n:
        j=i+1
        while j<n:
            if(arr[j]<arr[i]):
                count+=1
            j+=1
        i+=1
    return count
def count_inversions2(a,n):
  res = 0
  counts = [0]*(n+1)
  rank = { v : i+1 for i, v in enumerate(sorted(a)) }
  for x in reversed(a):
    i = rank[x] - 1
    while i:
      res += counts[i]
      i -= i & -i
    i = rank[x]
    while i <= len(a):
      counts[i] += 1
      i += i & -i
  return res
n,q=[int(x) for x in raw_input().split()]
arr=[int(x) for x in raw_input().split()]
value=count_inversions2(arr,n)
while q:
    x,y=[int(x) for x in raw_input().split()]
    if(x>y):
            if(arr[x-1]>arr[y-1]):
                value+=1
            else:
              value-=1
    else:
            if(arr[y-1]>arr[x-1]):
                value+=1
            else:
              value-=1
    k=x-1
    z=y-1
    arr[k],arr[z]=arr[z],arr[k]
    print value%2
    q-=1
    

import numpy as np
import math
def inv_2(A):
    M=A.size
    N=int(math.sqrt(M))
    bakra=np.copy(A)
    inv=np.identity(N,int)
    for i in xrange(0,N):
        if bakra[i,i] == 0:
            loc=np.where(bakra[i:N,i]==1)
            p=len(loc[0])
            if p >= 1:
                loc = loc[0][0]
                loc=loc + i
                bakra[i,:]= (bakra[i,:] + bakra[loc,:])%2
                inv[i,:]= (inv[i,:] + inv[loc,:])%2
            else:
                continue
        if bakra[i,i] == 1:
            for j in xrange(i + 1,N):
                if bakra[j,i] == 1:
                    bakra[j,:]=(bakra[i,:] + bakra[j,:])%2
                    inv[j,:]=(inv[i,:] + inv[j,:])%2
    for i in xrange(N-1,-1,- 1):
        for j in xrange(i - 1,-1,- 1):
            if bakra[j,i] == 1:
                bakra[j,:]=(bakra[i,:] + bakra[j,:])%2
                inv[j,:]=(inv[i,:] + inv[j,:])%2
    return inv
  
def playMatrix(siz):
    v=None
    I=np.identity(siz,int)
    Z=I * 0
    C=np.identity(siz,int)
    for pp in range(siz):
        for qq in range(siz):
            diff = abs(pp-qq)
            if diff <=1:
                C[pp,qq]=1

			
    for pp in range(siz):
        c = None
        for qq in range(siz):
            diff = abs(pp-qq)
            if diff == 0:
                TMP = C
            elif diff ==1:
                TMP = I
            else:
                TMP = Z
            if qq ==0 :
                c = TMP
            else:
                c = np.hstack((c,TMP))
        if pp ==0 :
            v=c
        else:
            v = np.vstack((v,c))
    return v
for gg in range(0,int((raw_input()))):
    siz = int(raw_input())
    A = playMatrix(siz)
    iA= inv_2(A)
    B=[]
    for xx in range(siz):
        B = B+ map(int,(list(raw_input().strip())))
    B = np.array(B,int)
    ans = np.dot(B,iA)%2
    i=0  
    print int(sum(ans))

    for k in ans:
        if int(k)==1:
            print str(i/siz+1) +' '+str(i%siz + 1)
        i+=1
from math import sqrt
 
def fn():
    a,b,c = map(int,raw_input().split())
    if a == 0 and b > 0 and c==0:
        print -1 
        return 
    af,cf = [], []
    for i in range(1,int(sqrt(a))+1):
        if i*i == a:
            af.append(i)
        else:
            if a%i==0:
                af.append(i)
                af.append(a/i)
 
    for i in range(1,int(sqrt(c))+1):
        if i*i == c:
            cf.append(i)
        else:
            if c%i==0:
                cf.append(i)
                cf.append(c/i)
                
    xy = []
    for g in af:
        if g*g - b*g>0:
            if (g*c+a)%(g*g-b*g)==0:
                xy.append((g*c+a)/(g*g-b*g))
        elif g*g - b*g == 0:
            if a == 0 and c ==0:
                print -1
                return 
    if a==0:
        for x in cf:
            xy.append(c/x)
 
                
    np = []
    for i in xy:
        cnt = 0
        for j in range(2,int(sqrt(i)+1)):
            if i%j == 0:
                cnt += 1
                while(i%j==0):
                    i/=j
        if i != 1:
            cnt += 1
        np.append(cnt)
    
    sm = 0
    for i in np:
        sm+=pow(2,i)
        
    print sm
        
t = int(raw_input())
for i in range(t):
    fn()  
#!/usr/bin/env python

#
# a basic implementation of the Pollard rho factorization
# Written by Mark VandeWettering <markv@pixar.com>
#

import sys
import locale
import random
try:
    import readline
except ImportError, msg:
    print msg
    print "Line editing disabled."

# an inefficient but straightforward way to find primes...

def primes(n):
    primes = [2]
    for x in range(3, n, 2):
        prime = True
        for p in primes:
            if p * p > n:
                break
            if x % p == 0:
                # it's composite..
                prime = False
                break
        if prime:
            primes.append(x)
    return primes

class FactorError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def miller_rabin_pass(a, n):
    d = n - 1
    s = 0
    while d % 2 == 0:
        d >>= 1
        s += 1

    a_to_power = pow(a, d, n)
    if a_to_power == 1:
        return True
    for i in xrange(s-1):
        if a_to_power == n - 1:
            return True
        a_to_power = (a_to_power * a_to_power) % n
    return a_to_power == n - 1

def isprime(n):
    for repeat in xrange(20):
        a = 0
        while a == 0:
            a = random.randrange(n)
        if not miller_rabin_pass(a, n):
            return False
    return True

def gcd(a, b):
    while b != 0:
        a, b = b, a%b
    return a

def findfactor(n):
    for c in range(1, 10):
        x = y = random.randint(1, n-1)
        x = (x * x + c) % n
        y = (y * y + c) % n
        y = (y * y + c) % n
        while True:
            t = gcd(n, abs(x-y))
            if t == 1:
                x = (x * x + c) % n
                y = (y * y + c) % n
                y = (y * y + c) % n
            elif t == n:
                break
            else:
                return t
    raise FactorError("couldn't find a factor.")

def factor(n):
    r = []
    for p in primes(10000):
        while n % p == 0:
            r.append(p)
            n = n / p
    if n == 1:
        return r
    while True:
        if isprime(n):
            r.append(n)
            break
        try:
            f = findfactor(n)
            r.append(f)
            n = n / f
        except FactorError, msg:
            r.append(n)
            break
    r.sort()
    return r

# this function would be easier to write recursively, but
# python isn't good at tail recursion, so in theory, it could
# fail.  Too bad.

def shorten(flist):
    slist = []
    idx = 0
    while flist[idx:] != []:
        hd = flist[idx]
        idx = idx + 1
        exp = 1
        while flist[idx:] != [] and flist[idx] == hd:
            exp = exp + 1
            idx = idx + 1
	
        if exp > 1:
        	slist.append([hd,exp])        
		#slist.append(locale.format("%d", hd, True) + "**"+str(exp))
        else:
		slist.append([hd,exp])
               # slist.append(locale.format("%d", hd, True))
    return slist

def factorit(n):
        flist = shorten(factor(n))
	sum=0
	for pair in flist:
		sum+=pair[0]*pair[1]
	return sum



while True:
        try:
                num = input()
		if(num<2):
			print num
		else:
			print factorit(num)
				
        #except NameError, msg:
                #print >> sys.stderr, msg
        #except SyntaxError, msg:
                #print >> sys.stderr, msg
        #except KeyboardInterrupt, msg:
                #print >> sys.stderr, "**Interrupted**"
                #continue
        except EOFError, msg:
                #print
                break


def prime(n,p):
	i=2
	a=[0]*(n+1)
	i=2
	while (i<=n):
		if (a[i]==0):
			p.append(i);
			j=i*i;
			while (j<=n):
				a[j]=1;
				j+=i;
		i+=1;
	return len(p)

def checksq(a):
	b=int(a**0.5)
	return b*b==a

def gcd(a,b):
	if a%b==0:
		return b
	return gcd(b,a%b)

def pow22(base,ex,k):
	a=base
	re=1
	while (ex>0):
		if (ex%2==1):
			re=re*a;
			re=re%k;
		a=a*a;
		a=a%k;
		ex=ex/2;
	return re;

MAX=10**6
MOD=1000000007

p=[]
prime(10**6,p)
MAX=len(p)
cube=[]
sq=[]
one=[]
i=0
while i<MAX:
	cube.append(p[i]*p[i]*p[i])
	sq.append(p[i]*p[i])
	one.append(p[i])
	i+=1

t=input()
while t:
	ans=1
	n=input()
	pow1=[]
	pow2=[]
	d={}
	b=map(int,raw_input().split())
	a=[]
	for x in b:
		i=0
		while x>1 and i<MAX and x>=one[i]*one[i]*one[i]:
			if (x%cube[i]==0):
				x/=cube[i]
				if p[i] in d:
					d[p[i]]+=3
				else:
					d[p[i]]=3
				i-=1
			elif (x%sq[i]==0):
				x/=sq[i]
				if p[i] in d:
					d[p[i]]+=2
				else:
					d[p[i]]=2
				i-=1
			elif (x%one[i]==0):
				x/=one[i]
				if p[i] in d:
					d[p[i]]+=1
				else:
					d[p[i]]=1
				i-=1
			i+=1
		if (x!=1):
			a.append(x)
	i=0
	while i<len(a):
		j=i+1
		while j<len(a):
			g=gcd(a[i],a[j])
			if (g!=1 and g!=max(a[j],a[i])):
				if (a[i]/g in d):
					d[a[i]/g]+=1
				else:
					d[a[i]/g]=1
				if (a[j]/g in d):
					d[a[j]/g]+=1
				else:
					d[a[j]/g]=1
				if g in d:
					d[g]+=2
				else:
					d[g]=2
				a[i]=1
				a[j]=1
			j+=1
		i+=1

	for x in a:
		if x!=1:
			if (checksq(x)):
				y=int(x**0.5)
				if y in d:
					d[y]+=2
				else:
					d[y]=2
			else:
				if x in d:
					d[x]+=1
				else:
					d[x]=1

	te=d.keys()
	for x in te:
		for y in te:
			g=gcd(x,y)
			if (x!=y and g!=1):
				if (x/g in d):
					d[x/g]+=min(d[x],d[y])
				else:
					d[x/g]=min(d[x],d[y])
				if (y/g in d):
					d[y/g]+=min(d[x],d[y])
				else:
					d[y/g]=min(d[x],d[y])
				if g in d:
					d[g]+=min(d[x],d[y])*2
				else:
					d[g]=min(d[x],d[y])*2
				d[x],d[y]=d[x]-min(d[x],d[y]),d[y]-min(d[x],d[y])
	for x in d:
		if (d[x]!=0):
			if (d[x]%3==0):
				mult=d[x]
			else:
				mult=(d[x]/3+1)*3
			ans=ans*pow22(x,mult,MOD)
			ans%=MOD
	print ans
	t-=1
import math
# def isWinning(position, memo = None):
# 	if memo == None:
# 		#Initialize memo on first call.
# 		memo = {}
# 	if position in memo:
# 		return memo[position]
# 	if position == 0:
# 		memo[position] = 0
# 		return 0
# 	moves = []
# 	if position >=0:
# 		moves.append(position//6)
# 	if position >=0:
# 		moves.append(position//5)
# 	if position >=0:
# 		moves.append(position//4)
# 	if position >=0:
# 		moves.append(position//3)
# 	if position >=0:
# 		moves.append(position//2)
# 	for x in moves:
# 		if not isWinning(x, memo) == 1:
# 			memo[position] = 1
# 			return 1
# 	memo[position] = 0
# 	return 0
def grundyNumbers(position, memo = None):
	if memo == None:
		memo = {}
	if position in memo:
		return memo[position]
	if position == 0:
		return 0
	moves = []
	moves.append(grundyNumbers(position//6, memo))
	moves.append(grundyNumbers(position//5, memo))
	moves.append(grundyNumbers(position//4, memo))
	moves.append(grundyNumbers(position//3, memo))
	moves.append(grundyNumbers(position//2, memo))
	moves.sort()
	answer = 0
	for x in moves:
		if answer == x:
			answer += 1
	memo[position] = answer
	return answer


def isWinning2(position):
	if position == 0:
		return 0
	if position == 1:
		return 1
	if position == 2 or position == 3:
		return 2
	if position == 4 or position == 5:
		return 3
	p = int(math.log(2*position, 12))
	if math.log(2*position + 1) < math.log(12)*p + math.log(2):
		return 0
	elif math.log(2*position + 1) < math.log(12)*p + math.log(4):
		return 1
	elif math.log(2*position + 1) < math.log(12)*p + math.log(8):
		return 2
	else:
		return 3

grunds = [0, 1, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0]
def grundy2(n):
	return grunds[n] if n < 12 else grundy2(n / 12)
	

test_case = int(raw_input())
for t in xrange(test_case):
	n = int(raw_input())
	array = map(int, raw_input().split())
	result = 0
	for a in xrange(len(array)):
		if a == 0:
			result = grundy2(array[a])
		else:
			result = result^grundy2(array[a])
	#print result
	if result == 0:
		print 'Derek'
	else:
		print 'Henry'
# import random
# for i in xrange(100000):
# 	value = random.randint(1,10*18)
# 	if not isWinning2(value) == grundy2(value):
# 		print 'F'
# for i in range(100000):
	# isWinning2(i)
# print grundyNumbers(10**18)
# print grundyNumbers(1)^grundyNumbers(2)
def minCost(n,c,m, p):
	if n == 1:
		return '0.000000000'
	
	if c.find('.') != -1:
		arr = c.split('.')
		ic = int(arr[0])
		while len(arr[1]) != 9:
			arr[1] = arr[1] + '0'
		fc = '0'+ '.' + arr[1]
		ccoeff = n-m-1
		tp = n*(n-1)
	else:
		ic = int(c)
		fc = '0.000000000'

	#print "ic : ", ic, "fc : ", fc
	
	mintpSpTree = 2*(n-1)* (n-1)
	mintp = n*(n-1)
	#minFlyCost = c*(n-m-1)
	twoDistinctEdges = False;

	if m == 0:
		tp = mintpSpTree
		minedges = n-1
		if ic <2: #fully connected graph
			tp = mintp
			ccoeff = (n*(n-1))/2
		elif ic >=2:
			tp = mintpSpTree
			ccoeff = n-1
	elif m == 1:
		tp = mintpSpTree
		minedges = n-2
		if ic < 2: #fully connected graph
			tp = mintp
			ccoeff = (n*(n-1))/2 - 1
		elif ic >=2:
			tp = mintpSpTree
			ccoeff = n-2
	else:
		#only one edge points are same
		if((p[0][0] == p[1][0] or p[0][0] == p[1][1]) and( p[0][1] == p[1][0] or p[0][1] == p[1][1])): 
			tp = mintpSpTree
			minedges = n-2
			if ic < 2: #fully connected graph
				tp = mintp
				ccoeff = (n*(n-1))/2 - 1
			elif ic >=2:
				tp = mintpSpTree
				ccoeff = n-2
		#two edges sharing one node 
		elif(p[0][0] == p[1][0] or p[0][0] == p[1][1] or p[0][1] == p[1][0] or p[0][1] == p[1][1]): 
			tp = mintpSpTree
			minedges = n-3
			if ic < 2: 
				tp = mintp
				ccoeff = (n*(n-1))/2 - 2
			elif ic >=2:
				tp = mintpSpTree
				ccoeff = n-3
		#two distinct edges
		else:
			minedges = n-3
			tp1 = 2*(n+1)*(n-2)
			ccoeff1 = n-3

			tp2 = mintpSpTree-2
			ccoeff2 = n-2
			
			if ic>=2*(n-2):
				tp = tp1
				ccoeff = ccoeff1
			else:
				tp = tp2
				ccoeff = ccoeff2
				if ic < 2:
					tp = mintp
					ccoeff = (n*(n-1))/2 -2
				elif ic >=2:
					tp = tp2
					ccoeff = ccoeff2
		
	#print "--------ic : ", ic, "fc : ", fc
	#print "--------tp : ", tp, "ccoeff : ", ccoeff
	
	itotal = ic* ccoeff + tp
	#print "itotal is ", itotal
	ftotal = int(fc[2:])
	#print "ftotal is ", ftotal
	
	ftotal = ftotal*ccoeff
	#print "ftotal 1 is ", ftotal
	fitotal = ftotal/1000000000
	itotal = itotal + fitotal
	#print "fitotap is ", fitotal
	ftotal = ftotal - fitotal*1000000000
	#print "11ftotap is ", fitotal
	#print "22ftotal is ", ftotal
	sf = "%s"%ftotal
	while len(sf)!=9:
		sf = '0' + sf
	si = "%s"%itotal
	return si + '.' + sf


		#itotal = itotal + fitotal
		
		#ftotal = fc*ccoeff
		#if ftotal >1:
		#	iftotal = int(ftotal)
		#	ftotal = ftotal - iftotal
		#	itotal = itotal + iftotal
		#a = "%d"%itotal
		#b = "%.9f"%ftotal
		#return a+b
		#return mintc1
if __name__ == "__main__":
	t = int(raw_input())
	for i in range(0,t):
		n = 0
		c = 0
		m = 0;
		s = raw_input()
		s = s.split(' ')
		n = int(s[0])
		c = s[1]
		m = int(s[2])
		l = []
		for k in range(0,m):
			s1 = raw_input()
			s1 = s1.split(' ')
			p1 = int(s1[0])
			p2 = int(s1[1])
			l.append((p1,p2))
			
		print minCost(n,c,m,l)

#include <algorithm>
#include <iostream>
#include <sstream>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <deque>
#include <ctime>
#include <list>
#include <set>
#include <map>
#include <iomanip>
//zlb//

using namespace std;

typedef long long     LL;
typedef unsigned long long     uLL;
typedef pair<LL,LL> pii;

double PI  = acos(-1);
double EPS = 1e-7;
LL INF    = 1000000000;
LL MOD    = 1000000007;
LL MAXINT = 2147483647;
LL INFLL   = 1000000000000000000LL;
LL MAXLL   = 9223372036854775807LL;

#define fi            first
#define se            second
#define mp            make_pair
#define pb            push_back
#define SIZE(a)       (int)a.size()
#define MIN(a, b)     (a) = min((a), (b))
#define MAX(a, b)     (a) = max((a), (b))
#define input(in)     freopen(in,"r",stdin)
#define output(out)   freopen(out,"w",stdout)
#define RESET(a, b)   memset(a,b,sizeof(a))
#define FOR(a, b, c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--)
#define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)

LL mx[8] = {-1,1,0,0,-1,-1,1,1};
LL my[8] = {0,0,-1,1,-1,1,-1,1};

// ------------ //

 #define getcx getchar

 inline void inp( int &n ) 
 {
    n=0;
    int ch=getcx();int sign=1;
    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}

    while(  ch >= '0' && ch <= '9' )
            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
    n=n*sign;
  }   

struct seg
{
	int s,d,sum;
};

int x[100005];
int expp[3][100005];
seg lol[3][400005];
int n,q,R;
int p[3];

inline int pwr(int id,int num,int ex)
{
	if (ex == 0) return 1;
	else if (ex%2==0)
	{
		int tmp = pwr(id,num,ex/2);
		return ((LL)tmp*tmp)%(LL)p[id];
	}
	else
	{
		return ((LL)num*pwr(id,num,ex-1))%(LL)p[id];
	}
}

int tmp2[3];
int tmp3[3];
bool yoy[3];

inline int val(int id,int k,int l,int r)
{
	int n = (r-l+1);
	if (!yoy[id])
	{
		LL s1 = n;
		LL s2 = ((2*lol[id][k].s)+((LL)(n-1)*lol[id][k].d));
		if (s1&1) s2/=2;
		else s1 /=2; 
		return (((LL)s1*(s2%(LL)p[id]))+(LL)lol[id][k].sum)%(LL)p[id];
	}
	else
	{
		int s1 = (((((((LL)lol[id][k].s+(((LL)(n-1)*(LL)lol[id][k].d)%p[id]))*(LL)expp[id][n])%p[id])-(LL)lol[id][k].s))*(LL)tmp2[id])%p[id]-((((LL)lol[id][k].d*(LL)R)%p[id]*((LL)(expp[id][n-1]-1+p[id])))%p[id]*(LL)tmp3[id])%p[id];
		s1 %= p[id];
		if (s1 < 0) s1 += p[id];
		return ((LL)lol[id][k].sum+s1)%p[id];
	}
}



inline void build(int k=1,int l=1,int r=n)
{
	lol[1][k].sum = lol[1][k].s = lol[1][k].d = 0;
	lol[2][k].sum = lol[2][k].s = lol[2][k].d = 0;
	if (l == r)
	{
		lol[1][k].sum = x[l]%p[1];
		lol[2][k].sum = x[l]%p[2];
		return;
	}
	int m = (l+r)/2;
	build(2*k,l,m);
	build(2*k+1,m+1,r);
	lol[1][k].sum = (val(1,2*k,l,m)+val(1,2*k+1,m+1,r))%p[1];
	lol[2][k].sum = (val(2,2*k,l,m)+val(2,2*k+1,m+1,r))%p[2];
}

inline void pass(int id,int k,int l,int r)
{
	int m = (l+r)/2;
	lol[id][2*k].s = (lol[id][2*k].s+lol[id][k].s);
	if (lol[id][2*k].s >= p[id]) lol[id][2*k].s -= p[id];
	lol[id][2*k].d = (lol[id][2*k].d+lol[id][k].d)%p[id];
	if (lol[id][2*k].d >= p[id]) lol[id][2*k].d -= p[id];

	int dif = m+1-l;
	lol[id][2*k+1].s += ((LL)expp[id][dif]*(lol[id][k].s+(dif*(LL)lol[id][k].d)%p[id])%p[id])%p[id];
	lol[id][2*k+1].d += ((LL)expp[id][dif]*(LL)lol[id][k].d)%p[id];
	if (lol[id][2*k+1].s >= p[id]) lol[id][2*k+1].s -= p[id];
	if (lol[id][2*k+1].d >= p[id]) lol[id][2*k+1].d -= p[id];


	lol[id][k].s = lol[id][k].d = 0;
}

inline void update(int s,int d,int x,int y,int id,int k=1,int l=1,int r=n)
{
	//cout << "UPDATE " << s << " " << d << " " << x << " " << y << " " << k << " " << l << " " << r << endl;
	if (l > y || r < x) return;
	if (x <= l && r <= y)
	{
		lol[id][k].s = (lol[id][k].s+s);
		if (lol[id][k].s >= p[id]) lol[id][k].s -= p[id];
		lol[id][k].d = (lol[id][k].d+d);
		if (lol[id][k].d >= p[id]) lol[id][k].d -= p[id];
		return;
	}
	int m = (l+r)/2;
	pass(id,k,l,r);
	if (x <= m)
	{
		update(s,d,x,min(y,m),id,2*k,l,m);
	}
	if (y >= m+1)
	{
		if (x <= m) 
		{
			int dif = m+1-x;
			s = ((LL)expp[id][dif]*(s+(((LL)dif*d)%p[id])))%p[id];
			d = ((LL)expp[id][dif]*(LL)d)%p[id];
			update(s,d,max(m+1,x),y,id,2*k+1,m+1,r);
		}
		else update(s,d,max(m+1,x),y,id,2*k+1,m+1,r);
	}
	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id];
}

inline int query(int x,int y,int id,int k=1,int l=1,int r=n)
{
	if (l > y || r < x) return 0;
	if (x <= l && r <= y)
	{
		return val(id,k,l,r);
	}
	int m = (l+r)/2;
	pass(id,k,l,r);
	int res = (query(x,y,id,2*k,l,m)+query(x,y,id,2*k+1,m+1,r))%p[id];
	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id];
	return res;
}

int main()
{
	int T;
	scanf("%d",&T);
	FOR(tc,1,T)
	{
		//scanf("%d%d%d%d%d",&n,&q,&R,&p[1],&p[2]);
		inp(n);
		inp(q);
		inp(R);
		inp(p[1]);
		inp(p[2]);
		expp[1][0] = 1;
		expp[2][0] = 1;
		tmp2[1] = pwr(1,R-1,p[1]-2);
		tmp2[2] = pwr(2,R-1,p[2]-2);
		tmp3[2] = ((LL)tmp2[2]*tmp2[2])%p[2];
		tmp3[1] = ((LL)tmp2[1]*tmp2[1])%p[1];
		
		yoy[1] = (R-1)%p[1];
		yoy[2] = (R-1)%p[2];
		FOR(a,1,n)
		{
			//scanf("%d",&x[a]);
			inp(x[a]);
			expp[1][a] = ((LL)expp[1][a-1]*R)%(LL)p[1];
			expp[2][a] = ((LL)expp[2][a-1]*R)%(LL)p[2];
		}
		build();
		while(q--)
		{
			int t,s,d,x,y,g;
			inp(t);
			//scanf("%d",&t);
			if (t == 0)
			{
				//scanf("%d %d %d %d",&s,&d,&x,&y);
				inp(s);
				inp(d);
				inp(x);
				inp(y);
				update(s%p[1],d%p[1],x,y,1);
				update(s%p[2],d%p[2],x,y,2);
			}
			else if (t == 1)
			{
				//scanf("%d %d",&x,&g);
				inp(x);
				inp(g);
				int t1 = query(x,x,1);
				int t2 = query(x,x,2);
				int tmp = pwr(2,t2,g);
				update((p[1]-t1+tmp)%p[1],0,x,x,1);
				update((p[2]-t2+tmp)%p[2],0,x,x,2);
			}
			else
			{
				//scanf("%d %d",&x,&y);
				inp(x);
				inp(y);
				printf("%d\n",(query(x,y,1)+p[1])%p[1]);
			}
		}

	}
}

from fractions import gcd
for dfj in range(input()):
    a,b,c,d = [int(i) for i in raw_input().split()]
    g = gcd(c,d)
    print(min((a-b)%g,(b-a)%g))
def get_opposite(point, dimention):
	opposite_vertex = [i for i in point]
	opposite_vertex[dimention] = -point[dimention]
	return opposite_vertex


def print_vertex(start_point, dimention):
	if dimention == 0:
		opposite_vertex  = get_opposite(start_point, dimention)
		print ' '.join([str(i) for i in start_point])
		print ' '.join([str(i) for i in opposite_vertex])
		return opposite_vertex
	end_vertex = print_vertex(start_point, dimention-1)
	opposite_vertex = get_opposite(end_vertex, dimention)
	return print_vertex(opposite_vertex, dimention-1)

T = int(raw_input())
for t in xrange(T):
	input = raw_input().split(' ')
	N, D = int(input[0]), int(input[1])
	l = [int(i) for i in raw_input().split(' ')]
	if D < 4:
		print -2
		continue
	print_vertex(l, N-1)
		

/*
author:jxy
lang:C/C++
university:China,Xidian University
**If you need to reprint,please indicate the source**
*/
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define Maxn 314160
using namespace std;
inline void inp( int &n )//fast input function
{
	n=0;
	int ch=getchar(),sign=1;
	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();}
	while( ch >= '0' && ch <= '9' )
 		n=(n<<3)+(n<<1)+ ch-'0', ch=getchar();
	n=n*sign;
	return;
}
char s[100];
int k=0;
inline void out(int &a)
{
    if(a==0){putchar('0');return;}
    while(a)
        s[k++]=a%10+'0',a/=10;
    while(k)
        putchar(s[--k]);
    return;
}
int R[Maxn];//房间客人
int room[Maxn],start[Maxn];
int n,m;
int main()
{
    int T,i;
    scanf("%d",&T);
    while(T--)
    {
        inp(n);inp(m);
        memset(R,0,n*sizeof(R[0]));
        int time,inc,now=0,ll=n-1;
        for(i=1;i<=m;i++)
        {
            inp(time);
            inp(inc);
            start[i]=time;
            if(n!=now)//没住满，依次安排
            {
                room[i]=now-inc;
                R[now++]=i;
            }
            else//已住满，赶走之前的人
            {
                if(inc==n){room[i]=0;continue;}//没房间
                room[i]=ll-inc;
                start[R[ll]]=time-start[R[ll]];
                R[ll]=i;
            }
        }
        ++time;
        for(i=0;i<n;i++)
            start[R[i]]=time-start[R[i]];
        for(i=1;i<=m;i++)
        {
            out(room[i]);
            putchar(' ');
            out(start[i]);
            putchar('\n');
        }
    }
}

#!/usr/bin/python
## Solve Every Sudoku Puzzle

## See http://norvig.com/sudoku.html
## modified by jc.unternet.net for CodeChef SudokuX competition

## Throughout this program we have:
##   r is a row,    e.g. 'A'
##   c is a column, e.g. '3'
##   s is a square, e.g. 'A3'
##   d is a digit,  e.g. '9'
##   u is a unit,   e.g. ['A1','B1','C1','D1','E1','F1','G1','H1','I1']
##   g is a grid,   e.g. 81 non-blank chars, e.g. starting with '.18...7...
##   values is a dict of possible values, e.g. {'A1':'123489', 'A2':'8', ...}
import sys

def cross(A, B):
    return [a+b for a in A for b in B]

rows = 'ABCDEFGHI'
cols = '123456789'
digits   = '123456789'
squares  = cross(rows, cols)
unitlist = ([cross(rows, c) for c in cols] +
            [cross(r, cols) for r in rows] +
            [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')] +
            [map(''.join, map(None, rows, cols))] +
            [map(''.join, map(None, rows, cols[::-1]))]
)

units = dict((s, [u for u in unitlist if s in u]) 
             for s in squares)
peers = dict((s, set(s2 for u in units[s] for s2 in u if s2 != s))
             for s in squares)

def main():
 input = map(str.strip, sys.stdin.readlines())
 number = int(input.pop(0))
 for i in range(number):
  sudoku = parse_grid(''.join(input[i * 10:(i * 10) + 10]))
  print codechef(search(sudoku))
  
def search(values):
    "Using depth-first search and propagation, try all possible values."
    if values is False:
        return False ## Failed earlier
    if all(len(values[s]) == 1 for s in squares): 
        return values ## Solved!
    ## Chose the unfilled square s with the fewest possibilities
    _,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)
    return some(search(assign(values.copy(), s, d)) 
                for d in values[s])

def assign(values, s, d):
    "Eliminate all the other values (except d) from values[s] and propagate."
    if all(eliminate(values, s, d2) for d2 in values[s] if d2 != d):
        return values
    else:
        return False

def eliminate(values, s, d):
    "Eliminate d from values[s]; propagate when values or places <= 2."
    if d not in values[s]:
        return values ## Already eliminated
    values[s] = values[s].replace(d,'')
    if len(values[s]) == 0:
        return False ## Contradiction: removed last value
    elif len(values[s]) == 1:
        ## If there is only one value (d2) left in square, remove it from peers
        d2, = values[s]
        if not all(eliminate(values, s2, d2) for s2 in peers[s]):
            return False
    ## Now check the places where d appears in the units of s
    for u in units[s]:
        dplaces = [s for s in u if d in values[s]]
        if len(dplaces) == 0:
            return False
        elif len(dplaces) == 1:
            # d can only be in one place in unit; assign it there
            if not assign(values, dplaces[0], d):
                return False
    return values
                    
def parse_grid(grid):
    "Given a string of 81 digits (or .0-), return a dict of {cell:values}"
    grid = [c for c in grid if c in '0.-123456789']
    values = dict((s, digits) for s in squares) ## Each square can be any digit
    for s,d in zip(squares, grid):
        if d in digits and not assign(values, s, d):
            return False
    return values

def solve_file(filename, sep='\n', action=lambda x: x):
    "Parse a file into a sequence of 81-char descriptions and solve them."
    results = [action(search(parse_grid(grid)))
               for grid in file(filename).read().strip().split(sep)]
    print "## Got %d out of %d" % (
          sum((r is not False) for r in results), len(results))
    return results

def codechef(values):
 answers = [values[square] for square in squares]
 board = ''
 for row in range(0, len(answers), 9):
  board += ''.join(answers[row:row+9]) + '\n'
 return board

def printboard(values):
    "Used for debugging."
    width = 1+max(len(values[s]) for s in squares)
    line = '\n' + '+'.join(['-'*(width*3)]*3)
    for r in rows:
        print ''.join(values[r+c].center(width)+(c in '36' and '|' or '')
                      for c in cols) + (r in 'CF' and line or '')
    print
    return values

def all(seq):
    for e in seq:
        if not e: return False
    return True

def some(seq):
    for e in seq:
        if e: return e
    return False

main()

## References used:
## http://www.scanraid.com/BasicStrategies.htm
## http://www.krazydad.com/blog/2005/09/29/an-index-of-sudoku-strategies/
## http://www2.warwick.ac.uk/fac/sci/moac/currentstudents/peter_cock/python/sudoku/

def power(a,b,mod):
    r=1
    if(a==0):
        return 0;
    while (b>0):
        if (b%2==1):
           r =((r)*(a))%mod
        b=b>>1
        a=((a)*(a))%mod
    return r
t=(int)(raw_input().strip())
p=[0 for i in range(200)];
q=[0 for i in range(200)];
l=[0 for i in range(200)];
while(t>0):
        t=t-1
        b=raw_input().strip()
        a=b.split()
        v=int(a[0])
        n=int(a[1])
        # print v
        # print n
        p[0],p[1],a0, b0, c0, m0=map(int,raw_input().split())
        q[0],q[1],a1, b1, c1, m1=map(int,raw_input().split())
        s=1
        mod=1000000007
        c=0
        for i in range(0, n):
             if(i>=2):
                 p[i]=((((a0 * a0)) * p[i-1])+((b0 * p[i-2] ))+c0)%m0;
                 q[i]=(((((a1 * a1)) * q[i-1]) + (b1 * q[i-2] ))+c1)%m1;
             l[i]=((p[i]*m1)+q[i]);
             if(l[i]!=0):
                  s=(s*(l[i]%(mod-1)))%(mod-1);
             else :
                  c=1;
        if (c==0):
            r=power(v%mod,s,mod)
            print r
        else :
            print '1'

#include <stdio.h>
#include <algorithm>
#include <vector>
#include <stack>
 
/* given any string of left and right parens, after removing all matching left
   and right parens, what remains is a string consisting of some number of 
   left parans followed by some number of right parens */
struct ReducedStr1 {
  int left_count;
  int right_count;
  ReducedStr1(char paren = 0) : 
    left_count((paren == '(') ? 1 : 0),
    right_count((paren == ')') ? 1 : 0)
  {} 
};
 
ReducedStr1 operator+(ReducedStr1 a, ReducedStr1 b) {
  ReducedStr1 ret;
  int cancelled = std::min(a.left_count, b.right_count);
  ret.left_count = a.left_count + b.left_count - cancelled;
  ret.right_count = a.right_count + b.right_count - cancelled;
  return ret;
} 
 
struct ReducedStr {
  ReducedStr1 forward, reverse;
  ReducedStr(char paren = 0) : forward(paren), reverse(paren) {}
};
 
ReducedStr operator+(ReducedStr a, ReducedStr b) {
  ReducedStr ret;
  ret.forward = a.forward + b.forward;
  ret.reverse = b.reverse + a.reverse;
  return ret;
}
 
struct Node;
 
struct AncestorInfo {
  Node* n;
  ReducedStr str; // path string to n (not including paren at n)
  AncestorInfo(Node* n, ReducedStr str) : n(n), str(str) {}
};
 
struct Node {
  char paren;  // ')' or '('
  std::vector<AncestorInfo> anc; // anc[i] is 2^i hops toward the root
  std::vector<Node*> adj; // list of adjacent nodes
  int level;
  Node() : paren(0) {}
  Node* find_ancestor_at_level(int level, ReducedStr& str)
  {
    if (this->level <= level) return this;
    int i;
    for (i=0;i<anc.size();i++)
      if (anc[i].n->level <= level) break;
    if (i != anc.size() && anc[i].n->level == level) {
      str = str + anc[i].str;
      return anc[i].n;
    }
    str = str + anc[i-1].str;
    return anc[i-1].n->find_ancestor_at_level(level, str);
  }
};
 
Node* find_common_ancestor(Node* u, Node* v, ReducedStr& s, ReducedStr& t)
{
  if (u == v) return u;
  int i;
  for (i=0;i<u->anc.size();i++)
    if (u->anc[i].n == v->anc[i].n) break;
  if (i==0) {
    s = s + u->anc[0].str;
    t = t + v->anc[0].str;
    return u->anc[i].n;
  }
  s = s + u->anc[i-1].str;
  t = t + v->anc[i-1].str;
  return find_common_ancestor(u->anc[i-1].n, v->anc[i-1].n, s, t);
}
 
int is_balanced(Node *u, Node* v)
{
  ReducedStr s, t;
  if (u->level > v->level)
    u = u->find_ancestor_at_level(v->level, s);
  else if (v->level > u->level)
    v = v->find_ancestor_at_level(u->level, t);
 
  Node* w = find_common_ancestor(u,v,s,t);
 
  ReducedStr1 path = s.forward + w->paren + t.reverse;
  return (!path.left_count && !path.right_count);
}
 
void make_tree(Node* root)
{
  std::stack<Node*> st;
  st.push(root);
  root->level = 0;
  while (!st.empty()) {
    Node* u = st.top();
    st.pop();
    for (int j=0;j<u->adj.size();j++) {
      Node* v = u->adj[j];
      if (v == root || !v->anc.empty()) continue;
      v->anc.push_back(AncestorInfo(u, ReducedStr(v->paren)));
      Node* w = u;
      for (int k=1;k <= w->anc.size();k++) {
        Node* x = w->anc[k-1].n;
        v->anc.push_back(
          AncestorInfo(x, v->anc[k-1].str + w->anc[k-1].str));
        w = x;
      }
      v->level = u->level + 1;
      st.push(v);
    }
  }
}
 
int main()
{
  int T;
 
  scanf("%d\n", &T);
  for (int i=0;i<T;i++) {
    int N, Q;
    scanf("%d %d\n", &N, &Q);
    std::vector<Node> tree(N);
    for (int j=0;j<(N-1);j++) {
      int u, v;
      scanf("%d %d\n", &u, &v);
      --u; --v;
      tree[u].adj.push_back(&tree[v]);
      tree[v].adj.push_back(&tree[u]);
    }
    for (int j=0;j<N;j++) {
      char c;
      scanf(j == (N-1) ? "%c\n" : "%c ", &c);
      tree[j].paren = c;
    }
    make_tree(&tree[0]);
    for (int j=0;j<Q;j++) {
      int u, v;
      scanf("%d %d\n", &u, &v);
      --u; --v;
      printf("%s\n", is_balanced(&tree[u], &tree[v]) ? "Yes" : "No");
    }
  } 
  return 0;
}
 
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;

#define MOD 1000000007
#define ll long long
#define REP(i,a) for(i=0;i<a;i++)
#define FOR(i,a,b) for(i=a;i<b;i++)
#define VE vector<int>
#define SZ size()
#define PB push_back

//inline ll NFIBO(ll a){ll phi=(1+sqrt(5))/2; ll x=floor(pow(phi,a)/sqrt(5)+1/2); return x;}
//inline void FFIBO(unsigned ll n,unsigned ll ans[]){unsigned ll a,b,c,d;if(n == 0){ans[0] = 0;ans[1] = 1;return;}FFIBO((n/2),ans);a = ans[0];b = ans[1];c = 2*b - a;if(c < 0)c += MOD;c = (a * c) % MOD;d = (a*a + b*b) % MOD;if(n%2 == 0){ans[0] = c;ans[1] = d;}else{ans[0] = d;ans[1] = c+d;}}


int main()
{
    int t;
    cin>>t;
    cin.ignore(254,'\n');
    while(t--)
    {

        string s,t;
        const char *a,*b;
        cin>>s;
        cin>>t;
        s.assign(s.begin(), unique(s.begin(),s.end()));
        t.assign(t.begin(), unique(t.begin(), t.end()));
        a = s.c_str();
        b = t.c_str();
        if(strcmp(a,b)==0)
        cout<<"Yes\n";
        else
        cout<<"No\n";

    }
}

#include <bits/stdc++.h>
#define forn(i, a, n) for (int i = a; i < n; ++i)
#define forr(i, a, n) for (int i = (n) - 1; i >= a; --i)
#define pb push_back
#define pf push_front
#define lag long long

using namespace std;
const int M = 1e9 + 7;
const int N = 1e5 + 7;

int t, n, p[N], e[N], pr[N], size;
bool is[N];
lag fact[N] = {1};
lag mp(lag b, lag e, lag m) {
	lag a = 1;
	b %= m;
	while (e) {
		if (e & 1) a = a * b % m;
		e >>= 1;
		b = b * b % m;
	}
	return a;
}
lag inv(lag x) {
	return mp(x, M - 2, M);
}
lag choose(int n, int k) {
	return fact[n] * inv(fact[k]) % M * inv(fact[n-k]) % M;
}
int get(int n, int p) {
	int k = 0;
	while (n / p > 0) {
		k += n / p;
		n /= p;
	}
	return k;
}
lag choosem(int n, int k) {
	// modulo (M - 1)
	lag a = 1;
	forn (i, 0, size) {
		if (pr[i] > n)
			break;
		int e = get(n, pr[i]) - get(k, pr[i]) - get(n - k, pr[i]);
		a = a * mp(pr[i], e, M-1) % (M-1);
	}
	return a;
}
int main() {
	forn (i, 1, N)
		fact[i] = fact[i-1] * i % M;
	forn (i, 2, N)
		is[i] = true;
	for (int i = 2; i*i < N; ++i)
		if (is[i])
			for (int j = i*i; j < N; j += i)
				is[j] = false;
	forn (i, 2, N)
		if (is[i])
			pr[size++] = i;
	scanf("%d", &t);
	while (t--) {
		scanf("%d", &n);
		lag P = 1;
		forn (i, 0, n) {
			scanf("%d%d", p+i, e+i);
			P = P * e[i] % M;
		}
		if (n == 1) {
			printf("1 %lld\n", (P + 1) % M);
			continue;
		}
		lag antichains = choose(n, n / 2);
		lag same;
		if (n & 1) {
			same = mp(P, choosem(n - 1, n/2 - 1), M) + mp(P, choosem(n - 1, (n + 1) / 2 - 1), M);
		} else {
			same = mp(P, choosem(n - 1, n/2 - 1), M);
		}
		printf("%lld %lld\n", (antichains%M+M)%M, (same%M+M)%M);
	}
}
import java.util.*;
import java.lang.*;
import java.io.*;

class JALEBI
{
	static int min;
	static char best[];
	public static void main (String[] args) throws java.lang.Exception
	{
		Reader re = new Reader(System.in);
		int T = re.nextInt();
		while(T-->0){
			int K = re.nextInt();
			String A[] = new String[K];
			for(int i=0; i<K; i++)
				A[i] = re.next();
			char s[] = new char[16];
			min = 17;
			best = new char[16];
			work(s, A, 0);
			String out = new String(best);
			System.out.println(out);
		}
	}
	
	static void work(char s[], String A[], int i){
		if(hasAll(s, A, i)){
			if(i<min){
				System.arraycopy(s, 0, best, 0, 16);
				min = i;
			}
			return;
		}
		if(i>15)
			return;
		s[i] = 'B';
		work(s, A, i+1);
		s[i] = 'G';
		work(s, A, i+1);
		s[i] = 0;
	}
	
	static boolean hasAll(char s[], String A[], int max){
		for(String s1 : A){
			if(s1.length()>max)
				return false;
			int j = 0;
			for(int i=0; i<max; i++)
				if(s[i]==s1.charAt(j)){
					j++;
					if(j>=s1.length())
						break;
				}
			if(j<s1.length())
				return false;
		}
		return true;
	}
}

class Reader{
    BufferedReader br;
    StringTokenizer st;
    Reader(InputStream in) throws Exception{
        br = new BufferedReader(new InputStreamReader(in));
        st = new StringTokenizer("");
    }
 
    String next() throws Exception{
        while(!st.hasMoreTokens())
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }
 
    int nextInt() throws Exception{
        return Integer.parseInt(next());
    }
}
import re
t=int(raw_input())
for i in range(t):
    n=raw_input()
    q=n.split(' ',1)
    q[0]=int(q[0])
    x=re.split('(\D+)',q[1])
    k=[]
    rem=[]
    for j in range(len(x)):
        if x[j]=='**':
            k.append(pow(int(x[j-1]),int(x[j+1]),q[0]))
            rem.append(x[j-1])
            rem.append(x[j+1])
        else:
            k.append(x[j])
    #print k
    #print rem
    for j in rem:
        if j in k:
            k.remove(j)
    #print k
    ans=1
    for j in range(0,len(k),2):
        ans=((ans%q[0])*(k[j]%q[0]))%q[0]
    print ans
N = 3400
res = [0 for x in range(N)]
res[2] = 2
for i in range(3, N):
    if i % 2 == 1:
        n = i / 2
        res[i] = (2 * n - 1) * res[i - 1] / n
    else:
        res[i] = 2 * res[i - 1]
def f(val):
    if val == 2 or val == 4:
        return 1
    elif val < 4:
        return 0
    else:
        (le, ri) = (2, N - 1)
        while le < ri:
            me = (le + ri) / 2
            if res[me - 2] >= val:
                ri = me
            else:
                le = me + 1
        if res[le - 2] == val :
            return 1
        else:
            return 0

t = int(raw_input()) 
for i in range(t):
    val = int(raw_input())
    if f(val) == 1:
        print 'YES'
    else:
        print 'NO'

count=0
def inversion(a,n):
    if(n<=1):
        return [a[0],]
    else:
        l=a[0:n/2]
        r=a[n/2:]
        return merge(inversion(l,n/2),inversion(r,n-(n/2)))
def merge(a,b):
    global count
    
    l1=len(a)
    l2=len(b)
    i=0;j=0;
    c=[]
    while(i<l1 and j<l2):
        if(a[i][1]>b[j][1]):
            count+=l1-i
            c.append(b[j])
            j+=1
        else:
            c.append(a[i])
            i+=1
    while(i<l1):
        c.append(a[i])
        i+=1
    while(j<l2):
        c.append(b[j])
        j+=1
    return c

n=input()
m=[]
f=[]

for i in range(n):
    a=raw_input()
    a=a.strip().split()
    m.append((int(a[0]),int(a[1])))
m=sorted(m)
inversion(m,n)
print count


import sys
x = lambda : [int(n) for n in sys.stdin.readline().rstrip().split()]
def bfs(i, mode):
    stack = [i+1]
    while len(stack)!=0:
        current = stack.pop()
        if graph.has_key(current):
            for node in graph[current]:
                val = graph[current][node]^answer[current-1]
                if visit[node-1] == mode:
                    visit[node-1] = not visit[node-1]
                    answer[node-1] = val
                    stack.append(node)
                elif val != answer[node-1]:
                    return 0
    return 1
(n,m,k) = x()
k-=1
answer = [0]*n
visit = [False]*n
graph = {}
while m:
    (a,b,w) = x()
    if not graph.has_key(a):
        graph[a] = {}
    if not graph.has_key(b):
        graph[b] = {}
    graph[a][b] = w
    graph[b][a] = w
    m-=1
exists = True
lastGraph = 0
for i in range(n):
    if not visit[i]:
        visit[i] = not visit[i]
        lastGraph = i
        if not bfs(i, False):
            exists = False
            break
if not exists:
    print -1
else:
    answer[lastGraph] ^= k
    bfs(lastGraph, True)
    print ' '.join(str(n) for n in answer)

numOfTests = int(raw_input())

def computeMaxProd(N, N4, N7):
    if N == 0:
        return N4*N7
    
    x = (N+N7-N4)/2

    
    if x < 0:
        x = 0
        y = x+1
    elif x > N:
        x = N
        y = x
    else:
        y = x+1

    

    
    return max( (x+N4)*(N-x+N7) , (y+N4)*(N-y+N7))

def defMaxProd(L, R, N=0, N4=0, N7=0):
    if not L:
        return computeMaxProd(N, N4, N7)
            
    r = int(R[0])
    l = int(L[0])

    if not r - l:
        if r == 7:
            N7 += 1
        elif r == 4:
            N4 += 1

        L = L[1:]
        R = R[1:]

        
        return defMaxProd(L, R, N4=N4, N7=N7)
        

    elif r - l == 1:
        rN4 = lN4 = N4
        rN7 = lN7 = N7

        if r == 7:
            rN7 += 1
        elif r == 4:
            rN4 += 1
        elif l == 7:
            lN7 += 1
        elif l == 4:
            lN4 += 1

        L = L[1:]
        R = R[1:]

        return max(defMaxProd(['0']*len(L), R, N4=rN4, N7=rN7), defMaxProd(L, ['9']*len(R), N4=lN4, N7=lN7))
        
    
    elif r - l > 1:
        L = L[1:]
        R = R[1:]
        N += len(R) 

        maxprod = 0
        
        if 4 in map(lambda x: x%10, range(l+1, r)):
            maxprod = computeMaxProd(N=N,N4=N4+1,N7=N7)
        
        if 7 in map(lambda x: x%10, range(l+1, r)):
            maxprod = max( maxprod, computeMaxProd(N,N4,N7+1))
            
        if not maxprod:
            maxprod = computeMaxProd(N=N,N4=N4,N7=N7)

        if r == 7:
            maxprod = max(maxprod, defMaxProd(['0']*len(L), R, N4=N4, N7=N7+1))
        if r == 4:
            maxprod = max(maxprod, defMaxProd(['0']*len(L), R, N4=N4+1, N7=N7))
        if l == 7:
            maxprod = max(maxprod, defMaxProd(L, ['9']*len(R), N4=N4, N7=N7+1))
        if l == 4:
            maxprod = max(maxprod, defMaxProd(L, ['9']*len(R), N4=N4+1, N7=N7))
        
        return maxprod

for test in xrange(numOfTests):
    L, R = raw_input().split()

    L = list(L)
    R = list(R)

    L = ['0']*(len(R)-len(L)) + L

    print defMaxProd(L, R, N=0, N4=0, N7=0)

mod = 1000000007
fact = [1]
for i in xrange(1,5003):
    fact.append((i*fact[i-1])%mod)
inv = []
for j in xrange(5003):
    nv = pow(fact[j] , mod-2 , mod)
    inv.append(nv)
for j in xrange(int(raw_input())):
    l = raw_input()
    four = l.count('4')
    seven = l.count('7')
    if (four == 0 or seven == 0 ):
        print 1
    else:
        ans = (fact[len(l)]*inv[four]*inv[len(l) - four])%mod
        ans = (ans - fact[len(l)-2]*inv[four-1]*inv[len(l)-1-four])%mod
        print ans%mod
#!/usr/bin/python
# Richard Lee
import os
import sys

def champion_possible(team_id, r_m, c_list):
   def team_sort(x, y):
      rx = r[x]
      ry = r[y]
      if rx == ry:
         return p[y] - p[x]
      return rx - ry
   
   def team_sort_r(x, y):
      rx = r[x]
      ry = r[y]
      if rx == ry:
         return p[x] - p[y]
      return ry - rx
   
   r, p, t_a = r_m
   team_sz = len(c_list)
   r[team_id] += p[team_id]
   p[team_id] = 0
   t_r = t_a[team_id]
   while len(t_r) > 0:
      j = t_r.pop()
      p[j] -= 1
      t_a[j].remove(team_id)
   
   c_win = True
   t_l = [i for i in xrange(team_sz)]
   t_l.remove(team_id)
   t_l = sorted(t_l, lambda x,y: team_sort(x,y))
   while len(t_l) > 0:
      t_i = t_l.pop()
      t_r = t_a[t_i]
      t_s = r[t_i] + p[t_i]
      if t_s > r[team_id]:
         t_r = sorted(t_r, lambda x,y: team_sort_r(x,y))
         t_r_sz = len(t_r)
         d = t_s - r[team_id]
         for i in xrange(0, t_r_sz):
            t_low = t_r.pop()
            if r[t_low] + 1 <= r[team_id]:
               p[t_i] -= 1
               p[t_low] -= 1
               r[t_low] += 1
               d -= 1
               t_a[t_low].remove(t_i)
            else:
               t_r.append(t_low)
            if d == 0:
               break
      r[t_i] += p[t_i]
      if r[t_i] > r[team_id]:
         c_win = False
         break
      elif p[t_i] > 0:
         while len(t_r) > 0:
            t_low = t_r.pop()
            p[t_low] -= 1
            t_a[t_low].remove(t_i)
   if c_win:
      for i in xrange(team_sz):
         if r[i] == r[team_id]:
            c_list[i] = 1
   
      
   
tc = int(sys.stdin.readline())
for t_i in xrange(tc):
   teamcount = int(sys.stdin.readline())
   max_s = 0
   r = [0 for i in xrange(teamcount)]
   t = r[:]
   p = r[:]
   champ_list = r[:]
   
   for i in xrange(teamcount):
      l = sys.stdin.readline().rstrip()
      l_p = l.split()
      t_r = []
      for j in xrange(teamcount):
         c = int(l_p[j])
         if c == 1:
            r[i] += 1
         elif c == 2:
            p[i] += 1
            t_r.append(j)
      if r[i] > max_s:
         max_s = r[i]
      t[i] = t_r
   
   if max_s == 0:
      print 0
      continue
   
   for i in xrange(teamcount):
      if r[i] + p[i] >= max_s and not champ_list[i]:
         t_c = [0 for j in xrange(teamcount)]
         for j in xrange(teamcount):
            t_c[j] = t[j][:]
         champion_possible(i, (r[:],p[:],t_c), champ_list)

   s_o = ""
   for i in xrange(teamcount):
      s_o += "%i" %(champ_list[i])
   print s_o
   
   
exit(0)
   
   






tests = int(raw_input())
while tests:
	K = int(raw_input())
	digits = map(int, str(K))
	highest = 100
	perm = range(highest, highest - digits[0], -1)
	highest -= digits[0]
	for i, d in enumerate(digits[1:], 1):
		perm[0:0] = range(highest, highest - 10, -1)
		highest -= 10
		perm.extend(range(highest - i, highest - d - i, -1) + range(highest - i + 1, highest + 1))
		highest -= d + i
	perm[0:0] = range(1, highest + 1)
	print len(perm)
	print " ".join(map(str, perm))
	tests -= 1

from fractions import Fraction
k = int(raw_input())
i=0

def fct(n,k):
    ct=Fraction(1,1)
    if n-k>k:
        while k>0:
           ct*=Fraction(n,k)
           k-=1
           n-=1
        return ct
    else:
        while n-k>0:
           ct*=Fraction(n,n-k)
           #k+=1
           n-=1
        return ct   

while i<k:
    i+=1
    try:
        n,r=[int(x) for x in raw_input().split()]
        if n-r==0: print 1
        else :
            print fct(n-1,r-1)
    except:
        break 
import sys
 
mod= 100000000000007
a=[0]*10004
a[0]=1
a[1]=0
for j in xrange(2,10002):
	a[j]=(j-1)*(2*a[j-1]+3*a[j-2])/(j+1)
for j in xrange(0,10002):
	a[j]=(a[j]+a[j+1])
#print a[10000]
#print filter(lambda y: y==0, [x%(43**3) for x in a[1:10001]])
 
c=[0]*10004
c[0]=1
for j in xrange(0,10001):
	c[j+1]=2*(2*j+1)*c[j]/(j+2)
	
#for j in xrange(0,10001):
#	c[j]%=mod
#print c[:20]
#print a[:20]
 
t=int(sys.stdin.readline())
while t:
	t-=1
	n,k=map(int,sys.stdin.readline().split())
	if k==0:
		print 0
	elif n==0:
		print 0
	elif k==1:
		w=a[n]%mod-1
		if w>=0:
			print w
		else:
			print mod-1
	elif k>=2:
		w=c[n]%mod-1
		if w>=0:
			print w
		else:
			print mod-1 
def opt(par,data):
    fail,total=par
    success=0
    data=sorted(data)
    for a in data:
        if(a%2==0):
            half=a/2
            if(total-half<0):
                break
            else:
                total-=half
                fail-=1
        else:
            half=a/2+1
            if(total-half<0):
                break
            else:
                total-=half
                fail-=1            

    for a in data:         
        remhalf=a/2
        if(total-remhalf<0):
            break
        else:
            total-=remhalf
            success+=1
    return str(fail)+" "+str(success)
    
                
    
def process(s):
    return map(int,s.split())

print opt(process(raw_input()),process(raw_input()))

from sys import stdin
readln = stdin.readline
while True :
	line = readln()
	if len(line)==0 : break;
	N = int(line)
	data = map(int,readln().split())
	mixtures = [ [0]*N for i in xrange(N) ]
	smoke    = [ [-1]*N for i in xrange(N) ]
	
	for i in xrange(N): 
		mixtures[i][i] = data[i]
		smoke[i][i] = 0
	
	
	for j in xrange(1,N):
		for i in xrange(j-1,-1,-1):
			for k in xrange(i,j):
				smk = smoke[i][k]+smoke[k+1][j]+mixtures[i][k]*mixtures[k+1][j]
				mix = (mixtures[i][k]+mixtures[k+1][j])%100
				if smoke[i][j]==-1 or smk<smoke[i][j] :
					smoke[i][j] = smk
					mixtures[i][j] = mix
				
	print smoke[0][N-1]
# your code goes here
t=int(raw_input())
while t:
	t-=1
	n=int(raw_input())
	arr=raw_input().split(' ')
	arr=map(int, arr)
	a,b,c=(raw_input().split(' '))
	a=int(a)
	b=int(b)
	c=int(c)
	bo=True
	mul=1
	add=0
	i=0
	j=n-1
	str=raw_input()
	for o in str:
		if (o=='R'):
			bo=not bo
		elif (o=='A'):
			add=(add+a)%c
		else:
			add=(add*b)%c
			mul=(mul*b)%c
		if(bo):
			print ((arr[i]*mul)%c+add)%c,
			i+=1
		else:
			print ((arr[j]*mul)%c+add)%c,
			j-=1
	print ''
	

#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <string>
#include <queue>
#include <cassert>
#define rep(i,a,n) for(int i=a;i<n;i++)
#define in(n) scanf("%d",&n)
#define inl(n) scanf("%lld",&n)
#define out(n) printf("%d ",n)
#define outln(n) printf("%d\n",n)
#define outl(n) printf("%lld ",n)
#define outlln(n) printf("%lld\n",n)
#define LL long long 
#define pb push_back
#define f first
#define s second
 
using namespace std;
 
int a[10];
long long int n;
double x,y,s;
double g[10][4];
 
 
void ne(double tmp[], double& xx, double& yy, double tt) {
    xx = tmp[0] + tmp[2]*tt;
    yy = tmp[1] + tmp[3]*tt;
}
 
double re(double tmp[], double xx, double yy, double tt) {
    double py = tmp[1], px = tmp[0], vx = tmp[2], vy = tmp[3];
    px = px + vx * tt, py = py + vy * tt;
    double aa = s*s - vy*vy - vx*vx;
    double bb = -2*((py - yy)*vy + (px-xx)*vx);
    double cc = -1*(py-yy)*(py-yy) + -1LL*(px-xx)*(px-xx);
    double aax;
    double sol1 = -bb + (aax = sqrt(bb*bb - 4 * aa * cc));
    double sol2 = -bb - aax;
    if(sol2 > 0.0)
        return sol2/(2*aa);
    return sol1/(2*aa);
}
 
int main()
{
    int nt, kase = 1;
    while(1) {
        double ix, iy;
        rep(i,0,10)a[i] = i;
        double mint = 1000000000000000000LL;
        if(inl(n)==EOF)break;
        if(n==0LL)break;
        rep(i,0,n) {
            rep(tt,0,4)scanf("%lf",&g[i][tt]);
        }
        scanf("%lf%lf%lf",&x,&y,&s);
        ix = x, iy = y;
        do {
            x = ix, y = iy;
            double cur = 0;
            for(int i=0;i<n;i++) {
                double xx = re(g[a[i]], x, y, cur/3600LL);
                double tt = xx*3600LL + 3600LL;
                cur += tt;
                ne(g[a[i]], x, y, cur/3600LL);
            }
            double back = (x - ix)*(x-ix) + (y-iy)*(y-iy);
            back = sqrt(back);
            back /= s;
            back = back * 3600LL;
            mint = min(mint, cur + back);
        }
        while(next_permutation(a,a+n));
        long long miint = ceil(mint);
        long long hrs = miint / 3600LL;
        miint = miint % 3600LL;
        long long mins = miint / 60LL;
        miint = miint % 60LL;
        printf("%d %lld %lld %lld\n",kase++, hrs, mins, miint);
    }
    return 0;
} 
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<queue>
 
using namespace std;
 
int main(){
	int T;
	cin >> T;
	long long int waiting[1000000];
	while(T--){
		long long int p, q, m, n, k;
		scanf("%lld%lld%lld%lld%lld",&p,&q,&m,&n,&k);
		long long int alreadyTook = 0;
		long long int readyToLand = p;
		long long int alreadyLanded = 0;
		long long int initial = 0;
		long long int final = -1;
		long long int waitingCount = 0;
		long long int readyToFly = q;
		queue <long long int> temp;
		for (long long int i=1;i<k+2;i++){
			if(! temp.empty()){	
			if(temp.front()+n <= i){
				temp.pop();
				readyToFly++;
			}
			}
			if(readyToLand){
				readyToLand--;
				alreadyLanded++;
				//insert
				temp.push(i);
				//final++;
				//waiting[final] = n;
			}
			else if(readyToFly){
				readyToFly--;
				alreadyTook++;
			}
			if ((i)%m == 0 ){
				readyToLand++;
			}
		//cout <<  alreadyTook << " " << readyToLand << " " << waitingCount << " " << readyToFly << endl;
		}
		//printf("%lld %lld %lld %lld\n", alreadyLanded, alreadyTook, readyToLand, 
 
		cout << alreadyLanded << " " << alreadyTook << " " << readyToLand << " " << readyToFly+temp.size() << endl;
	}
	return 0;
}
/* package codechef; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be "Main" only if the class is public. */
class Codechef
{
    
    static int ans(int[][] a,int order)
    {
        if(order==1)
        return a[0][0];
        int max=0;
        for(int i=0;i<order;i++)
        {
            int[][] b = new int[order-1][order-1];
            for(int j=1;j<order;j++)
            {
                
                int subindex=0;
                
                for(int k=0;k<order;k++)
                {
                    if(i!=k)
                    b[j-1][subindex++] = a[j][k];
                }
            }
            
            int temp = a[0][i] + ans(b,order-1);
            if(temp>max)
            max=temp;
        }
        return max;
    }
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int given[][]={
			{55,60,4,25,18,10,12,8,11,50},
			{60,45,75,23,27,20,24,7,33,12},
			{4,75,78,32,36,30,36,6,12,65},
			{25,23,32,15,45,40,48,5,14,23},
			{18,27,36,45,54,50,60,4,15,12},
			{10,20,30,40,50,60,72,3,32,34},
			{12,24,36,48,60,72,84,2,23,34},
			{8,7,6,5,4,3,2,1,34,123},
			{11,33,12,14,15,32,23,34,65,48},
			{50,12,65,23,12,34,34,123,48,71}
		};
		
		int T = Integer.parseInt(br.readLine());
		for(int p=0;p<T;p++)
		{
		    
		   String line =  br.readLine();
		  line = br.readLine();
		  
		  String[] h = line.split(" ");
		  int[] reward = new int[7];
		  int count=0;
		  for(int i=0;i<10;i++)
		  {
		      int x = Integer.parseInt(h[i]);
		  if(x==1)
		  reward[count++] = i;
		      
		  } 
		  int[][] a = new int[count][count];
		  
		  for(int i=0;i<count;i++)
		  {
		      for(int j=0;j<count;j++)
		      {
		          a[i][j] = given[reward[i]][reward[j]];
		      }
		  }
		   int finalans  = ans(a,count);
	   out.write(Integer.toString(finalans));
		   out.newLine();
		}
		out.flush();
	}
}

MAXN = 30

hash = [[2,2] for i in range(MAXN+1)]
hash[0] = [0,0]

for i in range(2, MAXN + 1):
	hash[i][0] = (i+1) + hash[i/2][0] + hash[i-i/2 - 1][0]
	hash[i][1] = (i+1) + hash[i-1][1]

t = int(raw_input())

for i in range(t):
	(n,m) = tuple(map(int, str(raw_input()).split(' ')))

	if m>=hash[n][0] and m<=hash[n][1]:
		print(0)
	elif m>hash[n][1]:
		print(m - hash[n][1])
	else:
		print(-1)



def factor(n):
  """
  factorize a number
  """
  r = {}
  q = 2
  w = int(n**.5)+1
  while n > 1 and q <= w:
    c = 0
    while n % q == 0: n /= q; c += 1
    if c: r[q] = c
    q += 1
  if n > 1: r[n] = 1  
  return r

def join(f, g):
  for k in g:
    if k in f:
      f[k] += g[k]
    else:
      f[k] = g[k]

T = input()
for t in range(T):
  l = input()
  s = map(int,raw_input().split())
  f = {}
  for q in s:
    g = factor(q)
    join(f, g)
  p = 1
  for d in f.values():
    p *= d + 1
  print p  
import sys
import math

# def ndigits(n):
    # return int(math.floor(math.log10(n)) + 1.1)
# 
# m = 10**100
# 
# def tostr(n):
    # if n < m:
        # return str(n)
    # ndig = ndigits(n)
    # botdig = ndig//2
    # mid = 10 ** botdig
    # top = tostr(n // mid)
    # bot = tostr(n % mid)
    # if len(bot) != botdig:
        # return top + '0'*(botdig - len(bot)) + bot
    # return top + bot

DIG = 300
MAX = 10**DIG
M2 = (MAX >> 1)

def div2(l):
    for i in xrange(len(l)):
        if l[i] & 1 == 1:
            l[i] -= 1
            l[i-1] += MAX/2
        l[i] /= 2
    for i in xrange(len(l)):
        if l[i] < 0:
            l[i] += MAX
            l[i+1] -= 1
    if l[-1] == 0:
        del l[-1]
            
def add1(l):
    i = 0
    while True:
        l[i] += 1
        if l[i] < MAX:
            return
        l[i] = 0
        if i == len(l)-1:
            l.append(1)
            return
        i += 1

def multlists(l1, l2):
    rtn = [0] * (len(l1) + len(l2) - 1)
    for i in xrange(len(l1)):
        for j in xrange(len(l2)):
            rtn[i+j] += l1[i] * l2[j]
    # print rtn
    for i in xrange(len(rtn)-1):
        rtn[i+1] += rtn[i] / MAX
        rtn[i] %= MAX
    while rtn[-1] > MAX:
        n = rtn[-1] / MAX
        rtn[-1] %= MAX
        rtn.append(n)
    return rtn

def fromstr(s):
    chars = list(reversed(s))
    # print chars
    l = [int(''.join(reversed(chars[i:i+DIG]))) for i in xrange(0, len(chars), DIG)]
    return l

def tolist(n):
    l = []
    while n:
        l.append(n % MAX)
        n /= MAX
    return l

t = int(sys.stdin.readline())
for _t in xrange(t):
    s = sys.stdin.readline()
    n = fromstr(s.strip())
    # print n
    n1 = list(n)
    add1(n1)
    if n[0] & 1:
        div2(n1)
    else:
        div2(n)
    # print n
    # print n1
    x = multlists(n, n1)
    # print x
    sys.stdout.write('%d' % x.pop())
    FMT = '%%0%dd' % DIG
    for i in reversed(x):
        sys.stdout.write(FMT % i)
    print

t=int(raw_input())
def powerfn(n,power):
	value=1
	while power>0 :
		
		if not power%2==0:
			value=value*n
			value=value%1000000007
		n=n*n
		n=n%1000000007
		power=power/2
	return value
def inversemod(n):
	return powerfn(n,1000000005)
factorial=[1]
for i in range(1,2000002):
	factor=(i*factorial[i-1])%1000000007
	factorial.append(factor)
def combination(n,r):
	if n<r:
		return 0
	else:
		return (factorial[n]*((inversemod(factorial[r])*inversemod(factorial[n-r]))%1000000007))%1000000007



for i in range(t):
	n,k=map(int,raw_input().split(" "))
	print (((2*combination(n+k+1,k+2))%1000000007)-n+1000000007)%1000000007
def res(l,n):
	l.sort(key=lambda x:x[0])
	ans=[l[0]]
	
	for i in range(1,n):
		
		if ans[-1][1]<l[i][0] :
			ans.append(l[i])
		if ans[-1][1]>l[i][0] and ans[-1][1]<l[i][1]:
			k=ans[-1][1]
			ans=ans[:len(ans)-1]
			ans.append((l[i][0],k))
		if ans[-1][1]>l[i][0] and ans[-1][1]>l[i][1]:
			ans=ans[:len(ans)-1]
			ans.append(l[i])

		

	return len(ans)

	
t=int(raw_input())
while t>0:
	n=int(raw_input())
	l=[]
	for i in range(0,n):
		p,q=raw_input().split()
		ran=(int(p),int(q))
		l.append(ran)
	print res(l,n)
	t-=1	


INFINITY = 10**9+7
from heapq import *
def dijkstra(s):
	global mini
	q, seen = [(0, s)], set()
	while q:
		cost, v1 = heappop(q)
		if v1 not in seen:
			seen.add(v1)
			shortestDistance[v1] = cost
			if cost > mini:
				break
			if specials[v1] == 1:
				if v1 != s:
					mini = cost
					break
			for c, v2 in g[v1]:
				if v2 not in seen:
					heappush(q, (cost+c, v2))

N, M, K = map(int, raw_input().split())
A = map(int, raw_input().split())
specials = [-1 for _ in xrange(N+1)]
for a in A:
	specials[a] = 1
g = [[] for _ in xrange(N+1)]
for m in xrange(M):
	X, Y, Z = map(int, raw_input().split())
	g[X].append((Z, Y))
	g[Y].append((Z, X))
ds = []
mini = INFINITY
shortestDistance = [-1 for _ in xrange(N+1)]
for i in xrange(1, K+1):
	if shortestDistance[A[i-1]] == -1:
		dijkstra(A[i-1])
print mini
def solution():
    T = int(raw_input().strip())
    for i in xrange(T):
        numb = raw_input().strip()
        print palindrome(numb)

def palindrome(numb):
    len_numb = len(numb)

    if numb == '9' * len_numb:
        return int(numb) + 2

    if len_numb == 1:
        if numb == '9':
            return int(numb) + 2
        else:
            return int(numb) + 1

    mid = len_numb // 2
    left = numb[0:mid]
    # print left, right
    if len_numb % 2 == 0:
        center = ''
    else:
        center = numb[mid]
    right = left[::-1]
    string = left + center + right
    # print string
    if string > numb:
        return string


    if (len_numb % 2) != 0:
        if center != '9':
            center = str(int(center) + 1)
            string = left + center + right
            return string

        else:
            center = '0'

    left_list = list(left)
    i = mid - 1
    while left_list[i] == '9':
        left_list[i] = '0'
        i -= 1
    left_list[i] = str(int(left[i]) + 1)
    left = ''.join(k for k in left_list)
    right = left[::-1]
    string = left + center + right

    return string
solution()

#parallel.py

n=int(raw_input())

#n=5
nstep = 0
total = 0
for xx in range(1):
##    if xx==0:
##        n=501
##    else:
##        n=500
    

    lines = []
    k=1    
    while k<=n:
        count=0
        steps=""
        for i in range(k,n,2*k):
            j = i+k
            if j<=n:
                step = " "+ str(i)+"+"+str(j)+"="+str(j)
                count +=1
                steps += step
        line = str(count)+steps
        if count>0:
            lines.append(line)
            total += count
            nstep +=1
        k *=2

    #print k

    k//=2

    #print k
    while k>1:
        count=0
        steps=""
        for i in range(k,n+1,k):
            j = i+k/2
            if j<=n:
                step = " "+ str(i)+"+"+str(j)+"="+str(j)
                count +=1
                steps += step
        line = str(count)+steps
        if count>0:
            lines.append(line)
            total += count
            nstep +=1
        k /=2


print nstep
for line in lines:
    print line

#print nstep, total

for t in range(int(raw_input())):
    n,f=map(long,raw_input().split())
    a=map(long,raw_input().split())
    l=[]
    d={}
    for i in a:
        k=i
        while k%f==0:
            k/=f
        l.append(k)
        d[k]=0
    for i in l:
        d[i]+=1
    ans=0L
    for i in d:
        ans+=(d[i]*(d[i]-1))/2
    print ans

def gcd(a, b):
    while b:
        a, b = b, a%b
    return a

def solve(a,b,c):
    if c==0:return 0
    if c==a or c==b:return 1
    if a>b:a,b=b,a
    if c>b:return -1
    if c==b-a:return 2
    d=gcd(a,b)
    if d!=1:
        if c%d:return -1
        a/=d;b/=d;c/=d;
    q=b/a
    rk=0
    r=a
    while True:
        if c==r:return rk
        rk+=2
        if c==b-r:return rk
        x=r;y=b-r
        for k in range(1,q+2):
            x+=a
            y=b-x
            rk+=2        
            if y<0:
                r=-y
                break
            if c==x or c==y:return rk

t=int(raw_input())
for _ in range(t):
    a=int(raw_input())
    b=int(raw_input())
    c=int(raw_input())
    print solve(a,b,c)

#!/usr/bin/env python
#-*- coding:utf-8 -*-

import random


def count_bits(n):
    res = 0
    while n:
        res += 1
        n >>= 1
    return res


t = int(raw_input())
for _ in range(t):
    n = int(raw_input())
    lst = map(int, raw_input().split())
    #lst = [random.randint(0, (1 << 16) - 1) for i in range(10**5)]

    n_bits = count_bits(max(lst))
    counts = [(0, 0, 0) for _ in range(n_bits)]
    for num in lst:
        for i, (c0, c1, count) in enumerate(counts):
            bit = (num & (1 << i)) >> i
            if bit == 1:
                c0, c1 = c1, c0
                c1 += 1
            else:
                c0 += 1
            count += c1

            counts[i] = c0, c1, count

    result = 0
    for i, (c0, c1, count) in enumerate(counts):
        result += count << i

    print result

'''
count = 0

c0, c1 = 0, 0
for i, bit in enumerate(lst):
    #print c0, c1, "bit", bit, "->",
    if bit == 1:
        c0, c1 = c1, c0
        c1 += 1
    else:
        c0 += 1
    count += c1
    #print c0, c1, "count", count

print count
'''

"""Prime Generator


All submissions for this problem are available.

Shridhar wants to generate some prime numbers for his cryptosystem. Help him! Your task is to generate all prime numbers between two given numbers.
Input

The first line contains t, the number of test cases (less then or equal to 10). Followed by t lines which contain two numbers m and n (1 <= m <= n <= 1000000000, n-m<=100000) separated by a space.
Output

For every test case print all prime numbers p such that m <= p <= n, one number per line. Separate the answers for each test case by an empty line.
Example

Input:
2
1 10
3 5

Output:
2
3
5
7

3
5

Warning: large Input/Output data, be careful with certain languages (though most should be OK if the algorithm is well designed) """

import random

def getkq(no):
    x = 0
    while no % 2 == 0:
        x += 1
        no /= 2
    return (x, no)

def primalityTest(no):
    (k, q) = getkq(no-1)
    a = random.randint(2, no - 2)
    # print "no = ", no, "a = ", a
    
    x = pow(a, q, no)
    no -= 1
    if (x == 1) or (x == no) :
        return True
    i = 1
    while i < k :
        x = pow(x, 2, (no+1))
        if x == 1 :
            return False
        if x == no :
            return True
        i += 1
    return False
    
def primeGenerator():
    t = eval(raw_input())
    while t > 0 :
        t -= 1
        (j, end) = (raw_input().split())
        j = eval(j)
        end = eval(end)
        if j == 1 :
            print 2
            j = 3
        if j == 2 :
            print 2
            j = 3
        if j == 3 :
            print 3
            j = 5
        while j <= end:
            # print "j = ", j
            if j % 2 == 0:
                j += 1
                continue
            i = 0
            # print "i at start = ", i
            isPrime = True
            while (i <= 5):
                i += 1
                # print "i = ", i
                if primalityTest(j) == False :
                    isPrime = False
                    break
            if isPrime :
                print j
            j += 1
    
if __name__ == "__main__" :
    # i = 1;
    # while i < 10:
    #     print i
    #     i += 1
    primeGenerator()
    
def isvalid(s, c):
    if c.difference(s):
        return False
    return True
def main():
    n = input()
    l = raw_input().split()
    s = set(l)
    answer = 0
    for _ in xrange(111, 1000):
        a = [i for i in str(_)]
        if isvalid(s, set(a)):
            for __ in xrange(11, 100):
                b = [i for i in str(__)]
                if isvalid(s, set(b)):
                    a1 = _ * int(b[0])
                    a2 = _ * int(b[1])
                    final = (a1*10)+a2
                    a1_set = set([i for i in str(a1)])
                    a2_set = set([i for i in str(a2)])
                    final_set = set([i for i in str(final)])
                    if a1<1000 and a2 < 1000 and final < 10000 and isvalid(s, a1_set) and isvalid(s, a2_set) and isvalid(s, final_set):
                        answer += 1
    print answer
main()

import sys

def get_int():
    return int(sys.stdin.readline())

def get_ints():
    return [int(i) for i in sys.stdin.readline().split()]

def find_max(line, pos, L, H):
    for i in range(H-L):
        new_pos = [ j + 1 for j in pos if j != len(line) - 1]
        #print 'new', new_pos
        if len(new_pos) < len(pos):
            return len(pos), L+i
        for i0 in range(len(new_pos) -1):
            if line[new_pos[i0]] != line[new_pos[i0+1]]:
                return len(pos), L+i
        pos = new_pos
    return len(pos), H

def run():
    while True:
        L, H = get_ints()
        if L == 0:
            break
        line = sys.stdin.readline()[:-1]
        # Find the maximun occurrence of length L
        dd = {}
        for i in range(len(line)-L+1):
            s = line[i:i+L]
            dd.setdefault(s, []).append(i+L-1)
        max_l = 0
        poses = []
        br = False
        #print line, dd
        for k, v in dd.viewitems():
            if len(v) > max_l:
                max_l = len(v)
                poses = [v,]
            elif len(v) == max_l:
                poses.append(v)
        max_l = 0
        r = None
        for pos in poses:
            m = find_max(line, pos, L, H)
            #print 'm', m
            if m[1] > max_l:
                r = m
                max_l = m[1]
        print r[0], r[1]


run()

from sys import stdin
def listInput():
 return map(int,stdin.readline().split())
adjList={}
def ConnectedComp(V):
 dfs_num=[0]*(len(V)+1)
 def dfs(i,cc):
  dfs_num[i]=True
  cc.add(i)
  for j in adjList[i]:
   if not dfs_num[j]: dfs(j,cc)
  return cc
 ccset=[]
 for i in V:
  if not dfs_num[i]: ccset.append(dfs(i,set([])))
 return ccset
n=input()
adjList={i:set([]) for i in xrange(n)}
bitvals=[0]*n
for i in xrange(n):
 li=stdin.readline()
 bitvals[i]=int(li,2)# take as base 2 no
 for j in xrange(n):
  if li[j]=="1":
   adjList[i].add(j)
#cc=ConnectedComp(adjList.keys())
ans=0
for i in xrange(n):
 temp=0
 for j in adjList[i]:
  temp|=bitvals[j]
 #print temp,str(bin(temp))
 temp=list(str(bin(temp&(~bitvals[i])))[2:])
 #print temp
 temp=temp.count("1")-1
 ans+=(temp if temp>0 else 0)
print ans
 
import sys

hs = [0.0]*(10**5+1)
def compute() :
    for i in range(1,10**5+1) :
        hs[i] = hs[i-1] + (1.0/i)

if __name__ == "__main__" :
    compute()
    for __ in range(input()) :
        n = input()
        print "%.1f"%(n*hs[n])

import gc; gc.disable()
from sys import stdin,stdout
def main():
    sr = stdin.readline
    m,n = sr().split()
    m=int(m);n=int(n)
    a=map(int,sr().split())
    ar = [[set(),set(),i,x,None,None] for i,x in enumerate(a)]
    ar[0][5] = ar[1];ar[m-1][4] = ar[m-2]
    for i in xrange(1,m-1):
        ar[i][5]=ar[i+1]
        ar[i][4]=ar[i-1]
    for j in xrange(n):
        l,r = sr().split()
        ar[int(l)-1][0].add(j);ar[int(r)-1][1].add(j)
    y=0
    ys=[]
    for k in xrange(int(sr())):
        n = ar[y+int(sr())-1]
        if n[3]>1: n[3]-=1
        else:
            if n[5] is not None:
                n[5][0]|=n[0]
                n[5][4] = n[4]
            if n[4] is not None:
                n[4][1]|=n[1]
                n[4][5] = n[5]
            y+=len(n[0]&n[1])
        ys.append(y)
        
    stdout.write( "\n".join(map(str,ys)) )
 
main()
# collect primes until 100
primes = [p for p in xrange(2,100) if all(p % q for q in xrange(2,p))]

def memoize(func):
    '''
    Given a function, return a memoized version of it, i.e.,
    it never calls the original function more than once given the same arguments.
    '''
    memo = {} # storage for already-calculated results
    def new_func(*args):
        if args not in memo: 
            # not found in memo, so new set of args. call func
            memo[args] = func(*args)
        return memo[args]
    return new_func

def ave(vs):
    ''' Returns the average of vs '''
    return sum(vs) / len(vs)

@memoize
def simplify(a,b):
    '''
    Normalize the primes of a, and fix b along with it.
    simplify(3*7*11^2,2*5*7*11*13) = 3*5
    '''
    res = 1
    i = 0
    for p in primes:
        if a % p == 0:
            if b % p == 0:
                res *= primes[i]
            i += 1
    return res

@memoize
def winning_optimal(g,*vs):
    '''
    Returns the probability of winning, given that the numbers are vs, the current gcd is g,
    and both players play optimally.
    '''
    n = len(vs)
    if g == 1: return 1
    if n == 0: return 0
    if g != 0: return winning_optimal(0, *sorted(simplify(g,v) for v in vs))
    return max([1 - winning_optimal(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)])

@memoize
def winning_random(g,*vs):
    '''
    Returns the probability of winning, given that the numbers are vs, the current gcd is g,
    and both players play randomly.
    '''
    n = len(vs)
    if g == 1: return 1.
    if n == 0: return 0.
    if g != 0: return winning_random(0, *sorted(simplify(g,v) for v in vs))
    return ave([1 - winning_random(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)])

z = input()
for cas in xrange(z):
    n = input()
    vs = map(int, raw_input().strip().split())
    print "%d %.4f" % (winning_optimal(0,*vs), winning_random(0,*vs))

import sys, decimal
raw_input = sys.stdin.readline

for tc in range(int(raw_input())):
    N, M = map(int, raw_input().split())
    deno = 0
    for n in range(N):
        product = decimal.Decimal('1.0')
        for p in map(decimal.Decimal, raw_input().split()): product *= p
        
        if n == 0: num = product
        
        deno += product
        
    print "%.6f" % (num/deno if num else 0)
import itertools
MODULO=1000000007
visited = [0] * 100001
count_connected_components = 0
#functions
def depth_first_traversal(graph, node, visited):
	stack = []
	visited[node] = 1
	stack.extend(graph[node])
	while len(stack) != 0:
		seed = stack.pop()
		if not visited[seed]:
			visited[seed] = 1
			stack.extend(graph[seed])
	
def connected_components(graph):
	global count_connected_components, visited
	count_connected_components = 0
	count_indegree_1 = 0
	bInvalid = False
	for node in graph:
		if not visited[node]:
			count_connected_components += 1
			depth_first_traversal(graph, node, visited)
	for node in graph:
		if len(graph[node]) > 2:
			bInvalid = True
		elif len(graph[node]) == 1:
			count_indegree_1 += 1
		visited[node] = 0
	if bInvalid or (count_indegree_1 != 2 * count_connected_components):
		return -1
	return count_connected_components

def find_count(edges, N):
	#prepare the adjacency graph
	global count_connected_components
	graph = {}
	for e in edges:
		if e[0] in graph:
			graph[e[0]].append(e[1])
		else:
			graph[e[0]] = [e[1]]
		if e[1] in graph:
			graph[e[1]].append(e[0])
		else:
			graph[e[1]] = [e[0]]
	count_connected_components = connected_components(graph)
	if count_connected_components == -1:
		return 0
	connected_components_including_solo_vertices = N - len(graph) + count_connected_components
	#calculate connected_components_including_solo_vertices!
	fact_connected_components_including_solo_vertices = fact_n[connected_components_including_solo_vertices]
	answer = fact_connected_components_including_solo_vertices
	answer *= (1 << count_connected_components)
	answer %= MODULO
	return answer

def process_case(N, M):
	sign = 1
	global fact_n
	#read list of edges, call it gaps
	#print fact_n
	gaps = []
	for i in range(M):
		e1, e2 = raw_input().split()
		e1, e2 = int(e1), int(e2)
		if e1 != e2:
			gaps.append([e1, e2])
	
	removed_edges = 0
	for n_m in range(1, M+1):
		combination_of__n_m = list(itertools.combinations(gaps, n_m))
		for combination in combination_of__n_m:
			count = find_count(combination, N)
			#print count, combination, sign
			removed_edges = (removed_edges + sign * count) #% MODULO
		#toggle the sign after value of n_m increases
		sign *= -1

	#to avoid negative answer
	answer = fact_n[N]
	answer += MODULO
	#if removed_edges < 0:
	#	removed_edges += MODULO
	#print "removed edges:" + str(removed_edges)
	fact = answer - removed_edges + MODULO
	fact = fact % MODULO
	return fact
			
#main program
#calculate n! modulo MODULO
fact_n = [0] * 100001
fact_n[1] = 1
for i in range(2, 100001):
	fact_n[i] = (i * fact_n[i-1]) % MODULO

T = int(raw_input())

for test_case in range(T):
	N, M = raw_input().split()
	N, M = int(N), int(M)

	print process_case(N, M)
s = bytearray()
x=0
for i in range(200010):
    x = (x*1103515245 + 12345) % 4294967296
    s.append('1' if (x >> 16)&1 else '0')
#print s
test = input()
while test:
    test-=1
    st = raw_input()
    if st[:50] in s:
        print 'LCG'
    else:
        print 'Xorshift'
        
            
        
        
    

import sys
 
dp =[0 for __ in range(10**5+100)]
MOD = 10**9+7
def solve(n,k) :
	if dp[n] :
		return dp[n]
	if k > n :
		dp[n] = 1
		return dp[n]
	if k == n :
		dp[n] = 2
		return dp[n]
	dp[n] = solve(n-1,k)+solve(n-k,k)
	return dp[n]%MOD
 
for __ in range(input()) :
	n , k = map(int,sys.stdin.readline().split())
	dp[0] = dp[1] = 1
	if k==1 :
		print pow(2,n,10**9+7)
		continue
	for i in range(1,n+1) :
		dp[i] = dp[i-1]
		if i>=k :
			dp[i] += dp[i-k]
		dp[i] %= MOD
	print dp[n]
itr = int(raw_input())
for i in xrange(itr):
    b = int(raw_input())
    a = raw_input().split()
    a = [int(s) for s in a]
    for s in a:
        if s==0:
            b-=1
    d = sum(a)
    if d<=(99+b) and d>=100:
        print "YES"
    else:
        print "NO"

#!/usr/bin/python
import sys
file = sys.stdin

first = file.readline()

noitems, money = [ int(x) for x in first.split()]
items = [[], [], [], [], [], []]
for x in range(noitems):
  li = file.readline().split()
  if len(li) != 3:
    continue
  itemno, price, quality = [ int(x) for x in li]
  if itemno > 6 or itemno < 1:
    continue
  items[itemno - 1].append( (price, quality,) )

#import pdb; pdb.set_trace()
try:
  for k in range(6):
    items[k] = sorted(items[k])
    x = 1
    val = items[k][0][1]
    while x < len(items[k]):
      if items[k][x][1] <= val:
        del items[k][x]
      else:
        val = items[k][x][1]
        x = x + 1
    items[k] = [(0,0)] + items[k]

except:
  pass

def argmin(array):
  ans = 0;
  for x in range(1, len(array)):
    if array[x] < array[ans]:
      ans = x
  return ans
    
cur = [0,0,0,0,0,0]
min_quality_off = 0
try:
  while True:
    min_quality_off = argmin([ items[x][cur[x]][1] for x in range(6) ])

    if len(items[min_quality_off]) > cur[min_quality_off] + 1 and items[min_quality_off][cur[min_quality_off] + 1][0] <= money:
      cur[min_quality_off] += 1
      money -= items[min_quality_off][cur[min_quality_off]][0]
    else:
      break
except:
  pass

print items[min_quality_off][cur[min_quality_off]][1]   

ct=[0,1,2,3,6,10,20,35,70,126,252,462,924,1716,3432,6435,12870,24310,48620,92378,184756,352716,705432,1352078,2704156,5200300,10400600,20058300,40116600,77558760,155117520,300540195,601080390,1166803110,2333606220,4537567650,9075135300,17672631900,35345263800,68923264410,137846528820,269128937220,538257874440,1052049481860,2104098963720,4116715363800,8233430727600,16123801841550,32247603683100,63205303218876,126410606437752,247959266474052,495918532948104,973469712824056,1946939425648112,3824345300380220,7648690600760440,15033633249770520,30067266499541040,59132290782430712,118264581564861424,232714176627630544,465428353255261088,916312070471295267,1832624140942590534]
l=65
for t in range(input()):
    n=input()
    l=0
    h=64
    while h>=l:
        m=(h+l)/2
        if (ct[m]>=n and ct[m-1]<n):
            break
        if ct[m]<=n:
            l=m+1
        else:
            h=m-1
    print m
            
    

"""
The stable marriage problem from CodeChef
"""
from collections import defaultdict

def revdict(dic):
    for key in dic.keys():
        dic[key] = dic[key][::-1]
    return dic

def smp(boy_prefs, girl_prefs):
    stable = {}

    ranks = dict()
    for girl, gpref in girl_prefs.items():
        for i, boy in enumerate(gpref):
            ranks[(girl, boy)] = i

    free_boys = set(boy_prefs.keys())
    free_girls = set(girl_prefs.keys())

    n = len(boy_prefs)
    # Reverse orders
    boy_prefs = revdict(boy_prefs)
    while free_boys:
        boy = free_boys.pop()
        if not boy_prefs.has_key(boy):
            continue
        girl = boy_prefs[boy].pop()
        if girl in free_girls:
            stable[girl] = (boy, ranks[(girl, boy)])
            free_girls.remove(girl)
        elif ranks[(girl, boy)] < stable[girl][1]:
            free_boys.add(stable[girl][0])
            stable[girl] = (boy, ranks[(girl, boy)])
        else:
            free_boys.add(boy)

    results = sorted((boy, girl) for girl, (boy, rank) in stable.items())
    return results    

def test():
    gprefs = { 1: [4, 3, 1, 2],
               2: [2, 1, 3, 4],
               3: [1, 3, 4, 2],
               4: [4, 3, 1, 2]
               }

    bprefs = {
        1: [3, 2, 4, 1],
        2: [2, 3, 1, 4],
        3: [3, 1, 2, 4],
        4: [3, 2, 4, 1]
    }

    print smp(bprefs, gprefs)

def main():
    cases = int(raw_input())
    for i in range(cases):
        k = int(raw_input())
        gprefs, bprefs = {}, {}
        for a in range(k):
            gprefs[a+1] = map(int, raw_input().split())[1:]
        for b in range(k):
            bprefs[b+1] = map(int, raw_input().split())[1:]
        for boy, girl in smp(bprefs, gprefs):
            print boy, girl

if __name__ == '__main__':
    main()


#Manage maximum events given start date and duration for a case
def main():
	#f = open('C:\\Users\\GLCR3257\\Desktop\\pyLogics\\test.txt','r')
	N=int(raw_input())
	#print N
	E=[]
	for i in range(N):
		start,duration=map(int,raw_input().split())
		E.append([start+duration,start])
 
	E.sort()
	#print E
	x=E[0][0]
	#print x
	ans=1
 
	for i in range(1,N):
		if(E[i][1]>x):
			#print x
			ans=ans+1
			x=E[i][0]
 
	print(ans)
	
if __name__=='__main__':
	main()
import sys
 
for __ in range(input()) :
	n = input()
	ch = raw_input()
	ops = {')':'(','}':'{',']':'[','>':'<'}
	cls = ['}',')','>',']']
	lists = map(int,sys.stdin.readline().split())
	dp , res , temp = [0]*(n+1) , 0 , 0
	for j,i in enumerate(lists) :
		dp[j] = dp[j-1]+i
	par_st , max_pr = [] , [-1]*(n+1)
	for j,i in enumerate(ch) :
		if len(par_st) > 0 :
			if i in cls and ch[par_st[-1]] == ops[i] :
				max_pr[j] = par_st.pop()
			else :
				par_st.append(j)
		else :
			par_st.append(j)
	ans = [0]*(n+1)
	for i,j in enumerate(lists) :
		if max_pr[i]!=-1 :
			ans[i] = max(dp[i] - dp[max_pr[i]-1]+ans[max_pr[i]-1],ans[i])
 
	print max(ans)

N = input()
S = []
for i in range(N):
  S += [input()]

#N = 4
#S = [5, 3, 4, 1]
#S = [2,4,8,10]

ma = 0
for i in range(N):
  a = S[i].bit_length()
  if ma < a:
    ma = a

for e in range(ma,-1,-1):
  msk = 1 << e
  t = []
  for s in S:
    if s & msk:
      t += [s]
  if len(t) > 1:
    S = t

m = (1 << ma) - 1
for a in S:
  m &= a
print m
  
          
n,x,y = map(int,raw_input().split())
n1 = [int(i) for i in raw_input().split()]
n2 = [int(i) for i in raw_input().split()]
num = [n1[i]-n2[i] for i in xrange(n) ]
num.sort(reverse=True)
mx = max(0,n-y)
Mx = min(n,x)
xy = sum(n2)
for i in xrange(mx):
    xy += num[i]
ans = xy
for i in xrange(mx,Mx):
    xy += num[i]
    ans =  max(ans,xy)
print ans
                 
import sys

for i1 in xrange(int(sys.stdin.readline())):
    a = set()
    flag = 0
    n,k,p = map(int,sys.stdin.readline().split())
    for i in xrange(k):
        x,y = map(int,sys.stdin.readline().split())
        a.add(x)

    for i in xrange(p):
        x,y = map(int,sys.stdin.readline().split())
        if x not in a:
            flag = 1

    if flag:
        print "No"
    else:
        print "Yes"


n = input()
a = raw_input()
b = raw_input()

n0 = n / 2
n1 = n0 / 2
while n1:
  idx = b.find(a[:n0]) 
  if idx >= 0: n0 += n1
  else: n0 -= n1
  n1 /= 2
  
while b.find(a[:n0]) < 0:
  n0 -= 1
print b.find(a[:n0])     
#!/usr/bin/python
import math;

def eliminate(M,r,c):
	N=[];
	n=len(M);

	for i in xrange(n):	
		if(i==r):
			continue;
		row=[]
		
		for j in xrange(n):
			if(j!=c):
				row.append(M[i][j]);
		N.append(row);

	return N;
	


def det(M):
	n=len(M);
	if(n==0) :
		return 0;
	elif(n==1):
		return M[0][0];

	sign=1
	delta=0
	for i in xrange(len(M)):
		if (M[0][i]!=0):
			delta+=sign*M[0][i]*det(eliminate(M,0,i));
		sign*=-1;

	return delta;


def getMat(size):
	M=[]
	for i in xrange(size):	
		row=[]
		for j in xrange(size):
			row.append(0);
		M.append(row);
	return M;

def printMat(M):
	for i in xrange(len(M)):
		for j in xrange(len(M)):
			print M[i][j],
		print

#Main

def area(a,b,c):
	s=float(a+b+c)/2.0;
	ar= math.sqrt(s*(s-a)*(s-b)*(s-c));	
	#print ar;
	return ar;


M=getMat(5);
for i in xrange(1,5):
	M[0][i]=M[i][0]=1;

#printMat(M);


cases=int(input());
for i in xrange(cases):
	line=raw_input();
	dist=line.split(" ");
	
	for i in xrange(len(dist)):
		dist[i]=int(dist[i]);
		
	

		# dist[0] d12  dist[1] d13  dist[2] d14
		#		dist[3] d23  dist[4] d24
		#				dist[5] d34

	M[1][2]=M[2][1]=dist[0]*dist[0];
	M[1][3]=M[3][1]=dist[1]*dist[1];
	M[1][4]=M[4][1]=dist[2]*dist[2];
		
	M[2][3]=M[3][2]=dist[3]*dist[3];
	M[2][4]=M[4][2]=dist[4]*dist[4];
	M[3][4]=M[4][3]=dist[5]*dist[5];

	X=float(det(M));
	Volume= math.sqrt(X/288.00)
		#    12 13 14                       12 14 24    		13   14 34                        23      24  34
	Surface=area(dist[0], dist[1],dist[3])+area(dist[0],dist[2],dist[4])+area(dist[1], dist[2],dist[5])+ area(dist[3],dist[4],dist[5]);
	#print Volume, Surface;

	Radius=3*Volume/Surface;
	print "%.4f"% round(Radius,4); 	
					
						




ip=raw_input().split()
n,k=int(ip[0]),int(ip[1])
MOD=1000000007
if n<k and n==1:
	print "0"
elif n==1:
	print "1"
else:
	ans=pow(n,n-2,MOD)
	if k==1:
		print ans
	else:
		print (ans*pow(k,n*k-2,MOD)*pow(n-1,n*(k-1),MOD))%MOD

#include <bits/stdc++.h>
using namespace std;

#if !ONLINE_JUDGE
#include "debug.h"
#else
#endif

typedef long long int LL;
typedef unsigned long long LLU;
typedef long double LD;

#define INF 1500000000000000000LL
#define MOD 1000000007
#define F first
#define S second
#define PB push_back
#define MK make_pair
#define LEN(vale) strlen(vale)
#define SZ(vale) (int)vale.size()
#define SQ(A) ((A)*(A))
#define FI(i,fa,fb) for(int i=fa;i<fb;++i)
#define FD(i,fa,fb) for(int i=fa;i>fb;--i)
#define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) 
#define bits(vale) __builtin_popcount(vale)
#define VT vector

#define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val;
#define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val;

#define ALL(a) (a.begin(),a.end())
#define LB (lower_bound)
#define UB (upper_bound)

#define SI(vale) scanf("%d",&vale)
#define PI(vale) printf("%d\n",vale)
#define PIS(vale) printf("%d ",vale)
#define SL(vale) scanf("%lld",&vale)
#define PL(vale) printf("%lld\n",vale)
#define PLS(vale) printf("%lld ",vale)
#define SS(vale) scanf("%s",vale)
#define PS(vale) printf("%s\n",vale)
#define SLD(vale) scanf("%Lf",&vale)
#define PLD(vale) printf("%0.12Lf\n",vale)
#define NL printf("\n")
#define TCS() int testcase; SI(testcase);while(testcase--) 

typedef pair<int,int> PR;
bool deb = false;
const int N = 50011;
const int LOGN = 32;
int n,Ncount;
bool mark[N];                                                                                                                                     
int dp[N][LOGN+5],dep[N],in[N],T;
int out[N],q[N]; // q stores query 
vector<int >gr[N];     // tree stores auxiliary tree
int deg[N];

void dfs(int v,int p) {
     in[v] = ++T;
     dp[v][0] = p;
     for(int i=1;i<=LOGN;++i)
          dp[v][i] = dp[dp[v][i-1]][i-1];
     dep[v] = dep[p] + 1;
     for(int i = 0;i<gr[v].size();i++) {
          int u = gr[v][i];
          if(u != p) {
               dfs(u,v);
          }
     }
     out[v] = T;
}


int LCA(int a,int b) {
     if(a == b)
          return a;
     if(dep[a] < dep[b]) swap(a,b);
     int diff = dep[a] - dep[b];
     int i = 0;
     while(i < LOGN) {
          if( (diff >> i) & 1)
               a = dp[a][i];
          i++;
     }
     if(a == b) return  a;
     i = LOGN-1;
     while(i >= 0) {
          if(dp[a][i] != dp[b][i])
               a = dp[a][i],b = dp[b][i];
          i--;
     }
     return dp[a][0];
}


bool isAnc(int p,int u) {
     return (in[p] <= in[u] && out[p] >= out[u]);
}


bool comp(int aa,int ab) {
     return in[aa] < in[ab];
}


int build_tree() {        // build auxiliary tree
     set<int>st;
     for(int i=0;i<Ncount;i++) st.insert(q[i]);
     Ncount = 0;
     for(auto it : st) {
          q[Ncount++] = it;
     }                   // find the unique nodes
     int TNodes = Ncount;
     sort(q,q+Ncount,comp);
     for(int i=0;i<TNodes-1;i++) {
          int lca = LCA(q[i],q[i+1]);
          if(st.find(lca) != st.end())   // if parent already exists
               continue;
          q[Ncount++] = lca;
          st.insert(lca);
     }
     sort(q,q+Ncount,comp);
     stack<int>S;
     S.push(q[0]);
     for(int i=1;i<Ncount;i++) {
          while((!isAnc(S.top(),q[i])))
               S.pop();
          deg[S.top()]++;
          deg[q[i]]++;
          S.push(q[i]);
     }
     return q[0];
}


void dfs2(int v,int p) {

}


void init() {
     T = 0;
     dp[1][0] = 0;
     dfs(1,0);
}


int main(){
     //clock_t tStart = clock();
     int t,m;
     TCS(){
          SI(n);SI(m);
          FI(i,0,n+2)gr[i].clear();
          FI(i,1,n) {
               int u,v;
               SI(u),SI(v);
               gr[u].PB(v);
               gr[v].PB(u);
          }
          init();
          while(m--) {
               SI(Ncount);
               int orc = Ncount;
               FI(i,0,Ncount) {
                    SI(q[i]);
                    mark[q[i]] = 1;
               }
               if(Ncount == 2) {
                    PI(dep[q[0]]+dep[q[1]]-2*dep[LCA(q[0],q[1])]-1);
               }
               else {
                    int root = build_tree();
                    int ans = 0;
                    FI(i,0,Ncount) if(deg[q[i]] == orc && !mark[q[i]]) {
                         ans++; break;
                    }
                    PI(ans);
               }
               FI(i,0,Ncount) {
                    mark[q[i]] = 0;
                    deg[q[i]] = 0;
               }
          }
     }
     //exectime();
     return 0;        
}



test_case=int(raw_input())
for _ in range(test_case):
    node= int(raw_input())
    sumx=0
    listp=[]
    for i in range(node):
        p,c =[int(u) for u in raw_input().split()]
        listp.append(p)
        sumx=sumx+p-c
    for x in range(node):
        if listp[x] == sumx:
            print sumx    
     
        
from sys import stdin
def printBS(li):
 print " ".join([str(x) for x in li])
def listInput():
 return map(int,stdin.readline().split())
cases=input()
for case in range(cases):
 n=input()
 li=listInput()
 turn=1
 xor=0
 for i in li: xor^=i
 while li and xor:
  #print li,xor
  xorli=[]
  #print xorli
  for i in li: 
   xorli.append(xor^i)
  i=0
  while i<len(li) and not xorli[i]: i+=1
  if i==len(li): 
   turn=1-turn
   break
  li.remove(li[i])
  xor=xorli[i]
  turn=1-turn
 if turn==1: print "First"
 else: print "Second"
n,k = [int(p) for p in raw_input().split()]

listq=[]
for i in range(1,int(n)+1):
    listq.append('CLICK '+str(i))
dic={key: 0 for key in listq}

def clk(n,k,x):
    if 'CLICK' in x:
        dic[x] += 1
    elif x =='CLOSEALL':
        for i in range(1,int(n)+1):dic['CLICK '+str(i)] = 0
    for t in dic:
        dic[t]%=2
    return sum(dic.values())

cnt = 0
while cnt<k:
    cnt+=1
    try:
        x=raw_input()
        print clk(n,k,x)
    except:
        break

def prejdi_strom(linky, presiel, zoznam):
    cache = {}
    ret = []
    for p in zoznam:
        for q in linky.get(p,[]):
            if q not in presiel and q not in cache:
                ret.append(q)
                cache[q] = 1
    return ret

def rozhodni(prve, druhe, linky):
    zaznam = {}
    for p1 in prve:
        delta = prve.get(p1,0) - druhe.get(p1,0)
        if delta==0 : continue
        if abs(delta) > 1 : return False
        if delta in zaznam: return False
        zaznam[delta] = p1

    for p1 in druhe:
        if p1 not in prve:
            if druhe[p1] != 1: return False
            if -1 in zaznam: return False
            zaznam[-1] = p1

    if 1 in zaznam: 
        start = zaznam[1]
    else: 
        for p1 in prve:
            start = p1
            break
    
    presiel = [start]
    zoznam  = [start]
    
    while True:
        nc = prejdi_strom(linky, presiel, zoznam)
        if nc == [] : break
        presiel += nc
        zoznam = nc
    
    return [x for x in prve if x not in presiel] == [] and [x for x in prve if x not in presiel]== []
    
def readInput(file):
    n = int(file.readline())
    prve = {}
    druhe = {}
    linky = {}
    for _ in xrange(0,n):
        s = file.readline().strip()
        prve[s[0]] = prve.setdefault(s[0],0) + 1
        druhe[s[-1]] = druhe.setdefault(s[-1],0) + 1
        linky.setdefault(s[0],[]).append(s[-1])
    return prve, druhe, linky

if __name__ == "__main__":
    import sys
    file = sys.stdin
    tc = int(file.readline())
    for _ in xrange(0,tc):
        prve, druhe, linky = readInput(file)
        print ["The door cannot be opened.","Ordering is possible."][rozhodni(prve, druhe, linky)] 

T=input()
x=[ '']*T
t=['rgb','rbg','grb','gbr','brg','bgr']
def min_time(r):
	minval=0
	m=0
	#print t
	for i in t:
		mint=0
		count=0
		for k in range(0,len(r)):
			if(r[k]==i[0]):	
				mint+=k-count 
				if(m==1 and minval <mint):
					continue
				count+=1 
		minl=0
		count=0
		q=[ -p for p in range(1,len(r)+1)]
		a=0
		for k in q:
		
			if(r[k]==i[0]):
				a+=1
				continue
			if(r[k]==i[2]):
				minl+= -k-count-a-1
				if(m==1 and minval <minl):
					continue
				count+=1
		if(m==0):
			m=1
			minval=minl+mint
			#print i,mint,minl
			continue
		if(minl+mint<minval):
			minval=minl+mint
		#print i,mint,minl,'\n'
	return minval
		
#def find_cluster():
	#print x[i]
for i in range(0,T):
	x[i]=raw_input()
#	find_cluster()
	print min_time(x[i])
exit(0)

import sys

for __ in range(input()) :
    n , m = map(int,sys.stdin.readline().split())
    cood = []
    for __ in range(m) :
        cood.append(map(int,sys.stdin.readline().split()))
    x , y = [i[0] for i in cood] , [i[1] for i in cood]
    if m==2 :
        k = set()
        for i in x :
            k.add(i)
        for i in y :
            k.add(i)
        if len(k)==3 :
            print "YES"
        else :
            print "NO"
    elif m > 2:
        print "NO"
    else :
        print "YES"

#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <cmath>
#include <complex>
#include <utility>
#include <set>
#include <queue>

using namespace std;

typedef complex<double> point;
typedef pair<double, int> PDI;

const double INF = 1E100;
const int MAX_P = 26;

struct edge {
  int a, b; double fuel;
  edge(int a_, int b_, double fuel_) : a(a_), b(b_), fuel(fuel_) {}
  };

point getUV(double t, const point &p, const point &q, const point &r) {
  point pp = p-q, rp = r-q;
  point rh = rp / abs(rp);

  point dc = conj(pp) * rh;
  double u = dc.real() + dc.imag()/tan(t);
  double v = dc.real() - dc.imag()/tan(t);
  u /= abs(rp); v /= abs(rp);

  if (u > v) swap(u, v);
  return point(u, v);
  }

int main() {
  cout << fixed << setprecision(3);
  int n, f, cNum = 0;
  while ((cin >> n >> f) && n) {
    double theta = acos(1.0 / f);

    vector<point> verts;
    for (int i = 0; i <= n; ++i) {
      int x, y; cin >> x >> y;
      verts.push_back(point(x, y));
      }

    vector<edge> edges;
    for (int i = 0; i <= n; ++i)
      for (int j = 0; j <= n; ++j)
        if (j != i+1)
          edges.push_back(edge(i, j, f*abs(verts[j]-verts[i])));

    for (int j = 0; j < n; ++j) {
      set<PDI> jumpPts;
      for (int i = 0; i <= n; ++i) {
        point uv = getUV(theta, verts[i], verts[j], verts[j+1]);
        double u = uv.real(), v = uv.imag();
        if ((0 < u) && (u < 1)) {
          point t = verts[j] + u*(verts[j+1] - verts[j]);
          int ti = verts.size();

          verts.push_back(t); jumpPts.insert(PDI(u, ti));
          edges.push_back(edge(ti, i, f*abs(verts[i] - t)));
          }
        if ((0 < v) && (v < 1)) {
          point t = verts[j] + v*(verts[j+1] - verts[j]);
          int ti = verts.size();

          verts.push_back(t); jumpPts.insert(PDI(v, ti));
          edges.push_back(edge(i, ti, f*abs(t - verts[i])));
          }
        }

      int prev = j;
      for (set<PDI>::const_iterator k = jumpPts.begin(); k != jumpPts.end(); ++k) {
        edges.push_back(edge(prev, k->second, abs(verts[k->second] - verts[prev])));
        prev = k->second;
        }
      edges.push_back(edge(prev, j+1, abs(verts[j+1] - verts[prev])));
      }

    int nV = verts.size();
    vector< vector<edge> > g(nV);
    for (vector<edge>::const_iterator i = edges.begin(); i != edges.end(); ++i)
      g[i->a].push_back(*i);

    vector<double> fuelTo(nV, INF); fuelTo[0] = 0;
    priority_queue<PDI> q; q.push(PDI(0, 0));

    while (!q.empty()) {
      PDI t = q.top(); q.pop();

      if (t.first == -fuelTo[t.second]) {
        for (vector<edge>::const_iterator i = g[t.second].begin(); i != g[t.second].end(); ++i)
          if (fuelTo[t.second] + i->fuel < fuelTo[i->b]) {
            fuelTo[i->b] = fuelTo[t.second] + i->fuel;
            q.push(PDI(-fuelTo[i->b], i->b));
            }
        }
      }

    cout << "Case " << ++cNum << ": " << fuelTo[n] << '\n';
    }
  }

#include<iostream>
#include<cstring>
#include<string>
#include<vector>
#include<cassert>
#include<algorithm>
using namespace std;
const int mx_nodes = 100;

enum Op {
	PL,
	MI,
	MU,
	ID
};

struct Parse_Node {
	int id;
	Op op;
	Parse_Node * lc, * rc;
	int num_vars;
};

string s;
int n;
long long l, h;
long long a[15];
int match[mx_nodes];
int num_nodes;
vector<pair<long long,int> > vals[mx_nodes][1 << 12];

Parse_Node* go(int lo, int hi) {
	while (match[lo] == hi - 1) lo ++, hi --;
	Parse_Node* res = new Parse_Node;
	int lvl = 0;
	int pos_pl = -1, pos_mi = -1, pos_mu = -1;
	for (int i = lo; i < hi; i ++) {
		if (s[i] == '(') lvl ++; else
		if (s[i] == ')') lvl --; else
		if (lvl == 0 && s[i] == '+') pos_pl = i; else
		if (lvl == 0 && s[i] == '-') pos_mi = i; else
		if (lvl == 0 && s[i] == '*') pos_mu = i;
	}
	int pos = -1;
	if (pos_pl >= 0) {
		res -> op = PL;
		pos = pos_pl;
	}
	else if (pos_mi >= 0) {
		res -> op = MI;
		pos = pos_mi;
	}
	else if (pos_mu >= 0) {
		res -> op = MU;
		pos = pos_mu;
	}
	else {
		res -> op = ID;
		res -> num_vars = 1;
	}
	if (pos >= 0) {
		res -> lc = go(lo, pos);
		res -> rc = go(pos + 1, hi);
		res -> num_vars = res -> lc -> num_vars + res -> rc -> num_vars;
	}
	res -> id = num_nodes ++;
	return res;
}

Parse_Node* parse() {
	vector<int> a;
	memset(match,-1,sizeof(match));
	int len = s.size();
	for (int i = 0; i < len; i ++) {
		if (s[i] == '(') a.push_back(i); else
		if (s[i] == ')') match[a.back()] = i, a.pop_back();
	}
	num_nodes = 0;
	return go(0, len);
}

pair<long long, int> t[5000000];
// int its;
void calc(Parse_Node* node) {
	int cnt_t;
	if (node -> op == ID) {
		for (int i = 0; i < n; i ++) {
			vals[node -> id][1 << i].push_back(make_pair(a[i], 1));
		}
	}
	else {
		calc(node -> lc);
		calc(node -> rc);
		for (int i = 0; i < (1 << n); i ++) if (__builtin_popcount(i) == node -> num_vars) {
			cnt_t = 0;
			for (int i1 = i; i1 != 0; i1 = (i1 - 1) & i) if (__builtin_popcount(i1) == node -> lc -> num_vars) {
				// its += vals[node -> lc -> id][i1].size() * vals[node -> rc -> id][i ^ i1].size();
				vector<pair<long long,int> >::iterator p1, p2;
				if (node -> op == PL)
				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++)
					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++)
						t[cnt_t].first = (*p1).first + (*p2).first,
						t[cnt_t].second = (*p1).second * (*p2).second,
						cnt_t ++;
				else if (node -> op == MI)
				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++)
					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++)
						t[cnt_t].first = (*p1).first - (*p2).first,
						t[cnt_t].second = (*p1).second * (*p2).second,
						cnt_t ++;
				else
				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++)
					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++)
						t[cnt_t].first = (*p1).first * (*p2).first,
						t[cnt_t].second = (*p1).second * (*p2).second,
						cnt_t ++;
			}
			sort(t, t + cnt_t);
			for (int j = 0; j < cnt_t; j ++) {
				if (j < cnt_t - 1 && t[j + 1].first == t[j].first)
					t[j + 1].second += t[j].second;
				else vals[node -> id][i].push_back(make_pair(t[j].first, t[j].second));
			}
		}
	}
}

void solve() {
	cin >> n >> l >> h;
	for (int i = 0; i < n; i ++) cin >> a[i];
	cin >> s;
	Parse_Node* root = parse();
	for (int i = 0; i < mx_nodes; i ++) for (int j = 0; j < (1 << 12); j ++) vals[i][j].clear();
	// cout << num_nodes << endl;
	calc(root);
	
	int res = 0;
	vector<pair<long long,int> > m = vals[root -> id][(1 << n) - 1];
	vector<pair<long long,int> >::iterator it;
	for (it = m.begin(); it != m.end(); it ++) {
		if ((*it).first >= l && (*it).first <= h) res += (*it).second;
		// cout << (*it).first << " (" << (*it).second << ")" << endl;
	}
	int b[10]; memset(b,0,sizeof(b));
	for (int i = 0; i < n; i ++) b[a[i]] ++;
	for (int i = 0; i < 10; i ++) {
		for (int j = 1; j <= b[i]; j ++) res /= j;
	}
	cout<<res<<endl;
}

int main() {
	int T; cin >> T; while (T--) solve();
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <vector>
#include <deque>
#include <queue>
#include <list>
#include <stack>
#include <algorithm>
#include <cassert>
#include <map>

using namespace std;

inline int re() {
	static int n = 0, ch;
	ch = getchar(); n = 0;
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) n = n * 10 + ch - '0', ch = getchar();
	return n;
}
struct Vector
{
	double x , y;
	Vector(double x=0 , double y=0):x(x),y(y){}
	
	double real() { return x; }
	double imag() { return y; }
	Vector operator +(Vector b) { return Vector(x + b.x , y + b.y); }
	Vector operator -(Vector b) { return Vector(x - b.x , y - b.y); }
	Vector operator *(Vector b) { return Vector(x * b.x - y * b.y , x * b.y + y * b.x);; }
	Vector operator /(double  b) { return Vector(x / b , y / b); }
};

typedef Vector cd;
typedef vector<cd> vc;
typedef vector<double> vd;

int m = 1;

inline void FFT(vc &a , int inv)
{
	int n = m;
	for(int i=0,j=0;i<n;i++)
	{
		if(j > i) swap(a[i] , a[j]);
		
		int k = n;
		while(j & (k >>= 1)) j &= ~k;
		j |= k;
	}
	
	double Pi = inv * acos(-1);
	for(int i=1;i<n;i <<= 1)
	{
		cd wn = cd(cos(Pi/i) , sin(Pi/i));
		for(int j=0;j<n;j += i<<1)
		{
			cd w = cd(1 , 0);
			for(int k=j;k<i+j;k++)
			{
				cd x = a[k];
				cd y = a[k+i] * w;
				a[k] = x + y;
				a[k+i]=x - y;
				w = w*wn;
			}
		}
	}
	
	if(inv == -1) for(int i=0;i<n;i++) a[i] = a[i] / n;
}

vc c , d; vd res;
vd operator *(vd&a , vd&b)
{
	for(int i=0;i<m;i++) c[i] = d[i] = 0;
	for(int i=0;i<m;i++) c[i] = a[i];
	FFT(c , 1);
 	for(int i=0;i<m;i++) d[i] = b[i];
	FFT(d , 1);
	for(int i=0;i<m;i++)  c[i] = c[i] * d[i];
	FFT(c ,-1);
	
	for(int i=0;i<m;i++) res[i] = c[i].real();
	return res;
}

const int maxn = 7e5+1e3;
const int blockSize = 2000;
const int blockNum = maxn/blockSize + 10;


int n , a[maxn] , book[maxn];
int l[blockNum] , r[blockNum];

void move(vd &v , int w , int inv)
{
	for(int i=l[w];i<=r[w];i++) v[a[i]] += inv;
}

int main()
{
	n = re();
	int mx = 0;
	for(int i=0;i<n;i++) mx = max(mx , a[i] = re());
	++(mx *= 2);
	
	while(m < mx) m <<= 1;
	c = d = vc(m , 0); res = vd(m , 0);

	int cnt = n/blockSize;
	for(int i=0;i<cnt;i++) l[i] = i * blockSize , r[i] = l[i] + blockSize - 1;
	if(n%blockSize) l[cnt] = n/blockSize*blockSize , r[cnt++] = n-1;

	long long res = 0;
	for(int i=0;i<cnt;i++) 
	{
		memset(book , 0 , sizeof (int) * m);
		for(int j=l[i];j<=r[i];book[a[j++]]++) for(int k=j+1;k<=r[i];k++) if(2 * a[j] >= a[k]) res += book[2*a[j] - a[k]];
	}
	
	vd L(m , 0) , R(m , 0);
	for(int i=cnt-1;i;i--) move(R , i , 1);
	for(int i=0;i<cnt;)
	{	
		for(int j=l[i];j<=r[i];j++) for(int k=j+1;k<=r[i];k++) 
		{
			if(2 * a[j] >= a[k]) res += int(L[2*a[j] - a[k]] + 0.5);
			if(2 * a[k] >= a[j]) res += int(R[2*a[k] - a[j]] + 0.5);
		}
		
		vd now = L * R;
		for(int j=l[i];j<=r[i];j++) res += (long long)(now[a[j]*2] + 0.5);
		
		move(L ,  i , 1);
		move(R ,++i ,-1);
	}
	printf("%lld\n" , res);
	return 0;
}

import random
class Ordinal(object):
    def __init__(self, v, r = 0):
        while (v&1)==0 and r > 0:
            v >>= 1
            r -= 1
        self.v, self.r = v, r

    def __repr__(self):
        return '%d / 2^%d' % (self.v, self.r)

    def __add__(self, o):
        if isinstance(o, int):
            o = Ordinal(o)
        if o.r < self.r:
            return Ordinal(self.v+(o.v<<(self.r-o.r)), self.r)
        else:
            return Ordinal(o.v+(self.v<<(o.r-self.r)), o.r)

    def __eq__(self, o):
        return self.r == o.r and self.v == o.v

    def sign(self):
        if self.v > 0:
            return 1
        elif self.v < 0:
            return -1
        else:
            return 0

    def colon(self, o):
        if o == 1:
            # return (1:x)
            if self.v >= 0:
                return Ordinal(self.v+(1L<<self.r), self.r)
            else:
                k = 1-(self.v >> self.r)
                return Ordinal(self.v+(k<<self.r), self.r+(k-1))
        elif o == -1:
            # return (-1:x)
            if self.v <= 0:
                return Ordinal(self.v-(1L<<self.r), self.r)
            else:
                k = 1-((-self.v) >> self.r)
                return Ordinal(self.v-(k<<self.r), self.r+(k-1))
        else:
            raise ValueError

    @staticmethod
    def stick_test(s):
        r1 = Ordinal(0)
        for x in s:
            if r1.r == 0 and r1.v * x >= 0:
                r1 += x
            else:
                r1 += Ordinal(x, r1.r+1)
        r2 = Ordinal(0)
        for x in s[::-1]:
            r2 = r2.colon(x)
        if not (r1 == r2):
            print str(s) + ': exp ' + str(r1) + ',  got ' + str(r2)
            raise ValueError

def HackenbushTree(n, e):
    ve = [list() for _ in range(n+1)]
    for x in e:
        ve[x[0]].append((x[1], x[2]))
        ve[x[1]].append((x[0], x[2]))
    q = [[1, 0, None, None]]
    res = None
    while len(q):
        x, cx, px, v = q.pop()
        if v is None:
            cur = [x, cx, px, Ordinal(0)]
            q.append(cur)
            for y, cy in ve[x]:
                if px is None or y != px[0]:
                    q.append([y, cy, cur, None])
        else:
            if px is None:
                res = v
            else:
                px[3] += v.colon(cx)
    return res.sign()

def main():
    t = int(raw_input())
    for _ in range(t):
        n = int(raw_input())
        e = []
        for _ in range(n-1):
            u, v, c = map(int, raw_input().split())
            e.append((u, v, 1-2*c))
        res = HackenbushTree(n, e)
        if res > 0:
            print 'Chef Chef'
        elif res < 0:
            print 'Ksen Ksen'
        else:
            print 'Ksen Chef'

if __name__ == '__main__':
    main()

#!/usr/bin/python
#Filename: happy.py

def getInt():
	while True:
		s=raw_input().strip()
		if(s!=""): return int(s)

def getString():
	while True:
		s = raw_input()
		if(s!=""): return s

def det(A,n):
	r=1
	for i in range(n):
		for j in range(i+1,n):
			 while(A[j][i]!=0):  # non-zero, swap with row i :)
				 f = A[i][i]/A[j][i]
				 for k in range(i,n):
					 A[i][k] = A[i][k] - A[j][k]*f
				 for k in range(i,n):
					 t = A[i][k]
					 A[i][k] = A[j][k]
					 A[j][k] = t
		r = r * A[i][i]
	return abs(r)


kases = getInt()
for kase in range(kases):
	G = []

	sa = getString().split()
	n = int(sa[0])
	m = int(sa[1])
	
	A = []
	for i in range(n):
		t = []
		for j in range(n):
			t.append(0)
		A.append(t)

	for i in range(m):
		sa = getString().split()
		a = int(sa[0])-1
		b = int(sa[1])-1
		if(a!=b):
			A[a][b]-=1
			A[b][a]-=1
			A[a][a]+=1
			A[b][b]+=1

	if(n==1): print "1"
	else:
		print det(A,n-1)		


import java.io.*;
import java.util.*;



class WaitForIt {

//  static Map<Integer,Long> memo = new HashMap<Integer, Long>();
  
  static ILMap memo;
  
  static final long mod = 1_000_000_007;

  static void init(){
    memo = new ILMap();
  }
  
  static class ILMap{
    static int S = 20_000_003;
    int[] in = new int[S];
    long[] out = new long[S];
    public ILMap() {
      Arrays.fill(out,-1);
    }
    int getLoc(long x){
      int loc = (int) ((x+x) % (long) S);
      while(in[loc]!= 0 && in[loc]!=x){
        loc ++;
        if(loc == S)
          loc = 0;
      }
      return loc;
    }
    
    long get(int x){
      return out[getLoc(x)];      
    }
    void put(int x,long y){
      int l = getLoc(x);
      in[l] = x;
      out[l] = y;
    }
  }
  
  static long count(int n){
    if(n == 1) return 1;
    long ret = memo.get(n);
    if(ret != -1)
      return ret;
    long r = n;
    r *= r;
    int rn = (int) Math.sqrt(n);
    for(int i=2; i<=rn; ++i)
      r -= count(n/i);
    rn = n/rn;
    for(int i=1; i<rn; ++i)
      r -= count(i)*(n/i - n/(i+1));
    r %= mod;
    if (r < 0) r += mod;
    memo.put(n,r);
    return r;
  }
  
  static long solve(long a0, long b0, int n){
    long ret = 0;
    long a,b;
    a=b=1;
    for(int i=1; i<=n; ++i){
      a = a*a0 % mod;
      b = b*b0 % mod;
      long c = a-b;
      if(c < 0)
        c += mod;
      ret += c*count(n/i);
      ret %= mod;
    }
    System.out.println(ret);
    return ret;
  }
  
  
  static long pow(long x,int y){
    x %= mod;
    long ret = 1;
    for(;y>0; y>>=1){
      if((y & 1) > 0)
        ret = (ret * x) % mod;
      x = (x * x) % mod;
    }
    return ret;
  }
  
  public static long[] gcd(long p, long q){
    if (q == 0)
      return new long[] { p, 1, 0 };

    long[] vals = gcd(q, p % q);
    long d = vals[0];
    long a = vals[2];
    long b = vals[1] - (p / q) * vals[2];
    return new long[] { d, a, b };
  }

  public static long inv(long x){
    if(x < 0)
      x += mod;
    long ret = gcd(mod,x)[2];
    if(ret < 0)
      ret += mod;
    return ret;
  }

  
  static long solve2(long a0, long b0, int n){
    long ret = 0;
    long a,b;
    a=b=1;
    int rn = (int) Math.sqrt(n);
    for(int i=1; i<=rn; ++i){
      a = a*a0 % mod;
      b = b*b0 % mod;
      long c = a-b;
      if(c < 0)
        c += mod;
      ret += c*count(n/i);
      ret %= mod;
    }
    rn = n/rn;
    long ai = inv(a0-1);
    long bi = b0==1 ? 1 : inv(b0-1);
    for(int i=1; i<rn; ++i){
      int i0 = n/(i+1)+1;
      int i1 = n/i;
      a = pow(a0,i1+1)-pow(a0,i0);
      b = b0 == 1 ? i1-i0+1 : pow(b0,i1+1)-pow(b0,i0);
      a *= ai;
      b *= bi;
      a %= mod;
      b %= mod;
      long c = a-b;
      c %= mod;
      if(c < 0)
        c += mod;
      
      ret += c*count(i);
      ret %= mod;
    
    }
    
    System.out.println(ret);    
    return ret;
  }
  
  
  static long solve3(long a0, long b0, int n){
    long ret = 0;
    long a,b;
    a=b=1;
    int rn = (int) Math.sqrt(n);
    for(int i=1; i<=rn; ++i){
      a = a*a0 % mod;
      b = b*b0 % mod;
      long c = a-b;
      if(c < 0)
        c += mod;
      ret += c*count(n/i);
      ret %= mod;
    }
    rn = n/rn;
    long ai = inv(a0-1);
    long bi = b0==1 ? 1 : inv(b0-1);
    
    int i1 = n/(rn);
    long ap = pow(a0,i1+1);
    long bp = pow(b0,i1+1);
    
    for(int i=rn-1; i>0; --i){
      int i0 = i1;
      i1 = n/i;
      a = - ap;
      ap *= pow(a0,i1-i0);
      ap %= mod;
      a += ap;
      a %= mod;
      
      if(b0 == 1)
        b = i1-i0;
      else{
        b = - bp;
        bp *= pow(b0,i1-i0);
        bp %= mod;
        b += bp;
        b %= mod;
      }
      a *= ai;
      b *= bi;
      a %= mod;
      b %= mod;
      long c = a-b;
      c %= mod;
      if(c < 0)
        c += mod;
      
      ret += c*count(i);
      ret %= mod;
    
    }
    
    System.out.println(ret);    
    return ret;
  }
  
  
  public static void main(String[] args) throws Exception{
    //goFile("input/input.txt");
    init();
    go();
  }
  
  static int[] getInts(BufferedReader br) throws IOException{
    String[] ss = new String[0];
    while(ss.length==0 || "".equals(ss[0])) ss =  br.readLine().split(" ");
    int[] ret = new int[ss.length];
    for(int i=0; i<ss.length; ++i){
      ret[i] = Integer.parseInt(ss[i]);
    }
    return ret;
  }

  static void goFile(String s) throws Exception{
    go(new FileReader(new File(s)));
  }

  static void go() throws Exception{
    go(new InputStreamReader(System.in));
  }


  static void go(Reader r) throws Exception{
    BufferedReader br = new BufferedReader(r);
    int t = getInts(br)[0];
    for(int i=0; i<t; ++i){
      int[] x = getInts(br);
      solve3(x[0],x[1],x[2]);
    }
  }
}

#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <climits>
#include <cstring>
#include <ctime>
#include <cmath>
#include <cassert>
#include <vector>
#include <queue>
#include <stack>
#include <list>
#include <set>
#include <map>
#include <bitset>
#include <algorithm>
#include <utility>
#include <numeric>
#include <functional>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
#define forl(i, n) for (int i = 1; i <= int(n); i++)
#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)
#define fore(i, l, r) for (int i = int(l); i <= int(r); i++)
#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))
#define all(a) (a).begin(), (a).end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
#define mp(x, y) make_pair((x), (y))
#define ft first
#define sc second
#define x first
#define y second
 
using namespace std;
 
typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;
 
template<typename X> inline X abs(const X& a) { return a < 0? -a: a; }
template<typename X> inline X sqr(const X& a) { return a * a; }
 
const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;
 
int m, w[10];
 
inline bool read()
{
	if (scanf("%d", &m) != 1)
		return false;
		
	forn(i, 10)
		assert(scanf("%d", &w[i]) == 1);
		
	return true;
}
 
typedef unsigned int uint;
 
const int N = 4 * 1000 * 1000 + 3, C = (1 << 9) + 3;
 
int szcur, sznext;
int cur[N], next[N];
int minPos[N];
uint ans[N];
int u = 0, used[N];
int d1[N], d2[N];
queue<int> q[C];
 
inline void solve(int test)
{
	forn(i, m) d1[i] = d2[i] = INF;
	
	d1[0] = 0;
	q[d1[0]].push(0);
	
	for (int qq = 0, dd = 0; ; qq = (qq + 1) & 511, dd++)
	{
		bool end = true; forn(i, 512) end &= q[i].empty();
		if (end) break;
		
		while (!q[qq].empty())
		{
    		int v = q[qq].front();
    		q[qq].pop();
    		
    		if (d1[v] != dd) continue;
    		
    		int nrm = v * 10;
    		(nrm >= m) && (nrm %= m);
    		
    		int dd1 = d1[v];
    		
    		forn(i, 10)
    		{
    			int next = nrm + i;
    			while (next >= m) next -= m;
    			int nd1 = dd1 + w[i];
    			
    			if (d1[next] > nd1)
    			{
    				d1[next] = nd1;
    				q[d1[next] & 511].push(next);
    			}
    		}
		}
	}
	
	cerr << clock() << endl;
	
	queue<int> qq;
	d2[0] = 0;
	qq.push(0);
	
	while (!qq.empty())
	{
		int v = qq.front();
		qq.pop();
		
		int nrm = v * 10;
		(nrm >= m) && (nrm %= m);
		
		int dd1 = d1[v];
		int dd2 = d2[v];
		
		forn(i, 10)
		{
			int next = nrm + i;
			while (next >= m) next -= m;
			int nd1 = dd1 + w[i];
			int nd2 = dd2 + 1;
			
			if (d1[next] == nd1 && d2[next] > nd2)
			{
				d2[next] = nd2;
				qq.push(next);
			}
		}
 	}
	
	//forn(i, m) assert(d[i].ft < INF / 2);
	
	cerr << clock() << endl;
	
	forn(i, m) minPos[i] = INF;
	
	u++;
	used[0] = u;
	szcur = 0;
	cur[szcur++] = 0;
	ans[0] = 0;
	
	li res = 0;
	int sum = 0;
	
	while (szcur > 0)
	{
		sum += szcur;
		
		forn(t, szcur)
		{
			int v = cur[t];
			res += ::ans[v];
			
    		forn(i, 10)
    		{
    			int next = (v * 10 + i) % m;
    			
    			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1) minPos[next] = min(minPos[next], t);
    		}
    	}
    	
		sznext = 0;
		
		forn(t, szcur)
		{
			int v = cur[t];
			
    		forn(i, 10)
    		{
    			int next = (v * 10 + i) % m;
    			
    			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1 && minPos[next] == t && used[next] != u)
    			{
    				used[next] = u;
    				ans[next] = ans[v] * 3141 + i;
    				::next[sznext++] = next;
    			}
    		}
    	}
    	
    	//sort(next, next + sznext);
    	
    	szcur = sznext;
    	forn(i, szcur) cur[i] = next[i];
	}
	
	//cerr << sum << ' ' << m << endl;
	assert(sum == m);
	
	cout << res << endl;
	
	cerr << clock() << endl;
}
 
int main()
{
#ifdef SU2_PROJ
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt", stdout);
#endif
    
    cout << setprecision(10) << fixed;
    cerr << setprecision(5) << fixed;
    
    int testCount;
    cin >> testCount;
    
    forn(test, testCount)
    {
	    assert(read());
		solve(test);
	}
	
    return 0;
}

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>

using namespace std;

int T;
int N;

struct bian_
{
	int to;
	int next;
}bian[200010]={{0,0}};
int First[100010]={0};

struct Tree
{
	int fas,fax;
	int son[2];
	int Min;
}tree[100010]={{0,0,{0},0}};

struct SegTree
{
	long long Sum;
	long long add;
}segtree[400010]={{0,0}};

int St[100010]={0},En[100010]={0};
int dfsp=0;

void Add(int p,int q,int k)
{
	bian[k].to=q;
	bian[k].next=First[p];
	First[p]=k;
	return;
}

void Merge(int x)
{
	tree[x].Min=x;
	if(tree[x].son[0]!=0)
		tree[x].Min=tree[tree[x].son[0]].Min;
	return;
}

void Rotate(int x)
{
	int Fa=tree[x].fas;
	swap(tree[x].fax,tree[Fa].fax);
	tree[x].fas=tree[Fa].fas;
	if(tree[Fa].fas!=0)
	{
		int g=(tree[tree[Fa].fas].son[1]==Fa);
		tree[tree[Fa].fas].son[g]=x;
	}
	tree[Fa].fas=x;
	int g=(tree[Fa].son[1]==x);
	tree[Fa].son[g]=tree[x].son[g^1];
	if(tree[x].son[g^1]!=0)
		tree[tree[x].son[g^1]].fas=Fa;
	tree[x].son[g^1]=Fa;
	Merge(Fa);Merge(x);
	return;
}

void Splay(int x)
{
	for(;tree[x].fas!=0;)
	{
		int Fa=tree[x].fas;
		if(tree[Fa].fas!=0)
		{
			int g1=(tree[tree[Fa].fas].son[1]==Fa);
			int g2=(tree[Fa].son[1]==x);
			if(g1==g2)
				Rotate(Fa);
			else Rotate(x);
		}
		Rotate(x);
	}
	return;
}

void update(int l,int r,int k,long long c)
{
	segtree[k].add+=c;
	segtree[k].Sum+=c*(r-l+1);
	return;
}

void pushdown(int l,int r,int k)
{
	int mid=(l+r)>>1;
	update(l,mid,k<<1,segtree[k].add);
	update(mid+1,r,k<<1|1,segtree[k].add);
	segtree[k].add=0;
	return;
}

void Change(int l,int r,int k,int al,int ar,long long c)
{
	if(al<=l && r<=ar)
	{
		update(l,r,k,c);
		return;
	}
	pushdown(l,r,k);
	int mid=(l+r)>>1;
	if(al<=mid) Change(l,mid,k<<1,al,ar,c);
	if(ar>mid) Change(mid+1,r,k<<1|1,al,ar,c);
	segtree[k].Sum=segtree[k<<1].Sum+segtree[k<<1|1].Sum;
	return;
}

long long Query(int l,int r,int k,int al,int ar)
{
	if(al<=l && r<=ar) return segtree[k].Sum;
	pushdown(l,r,k);
	long long ret=0;
	int mid=(l+r)>>1;
	if(al<=mid) ret+=Query(l,mid,k<<1,al,ar);
	if(ar>mid) ret+=Query(mid+1,r,k<<1|1,al,ar);
	return ret;
}

void cut(int x,int g)
{
	if(tree[x].son[g]==0) return;
	int Son=tree[x].son[g];
	tree[x].son[g]=0;
	swap(tree[Son].fax,tree[Son].fas);
	Change(1,N,1,St[tree[Son].Min],En[tree[Son].Min],1);
	return;
}

void Link(int x,int y)
{
	tree[x].son[1]=y;
	swap(tree[y].fas,tree[y].fax);
	Change(1,N,1,St[tree[y].Min],En[tree[y].Min],-1);
	return;
}

void access(int x)
{
	Splay(x);
	cut(x,1);
	for(;tree[x].fax!=0;)
	{
		Splay(tree[x].fax);
		cut(tree[x].fax,1);
		Link(tree[x].fax,x);
		Splay(x);
	}
	return;
}

void buildtree(int cnt,int fa)
{
	St[cnt]=++dfsp;
	tree[cnt].Min=cnt;
	for(int i=First[cnt];i!=0;i=bian[i].next)
	{
		int u=bian[i].to;
		if(u==fa) continue;
		tree[u].fax=cnt;
		buildtree(u,cnt);
		Change(1,N,1,St[u],En[u],1);
	}
	En[cnt]=dfsp;
	return;
}

int main()
{
	cin>>T;
	for(;T>0;T--)
	{
		cin>>N;
		memset(First,0,sizeof(First));
		memset(tree,0,sizeof(tree));
		memset(segtree,0,sizeof(segtree));
		dfsp=0;
		for(int i=1;i<N;i++)
		{
			int p,q;
			scanf("%d%d",&p,&q);
			p++,q++;
			Add(p,q,(i<<1)-1);
			Add(q,p,i<<1);
		}
		buildtree(1,0);
		int Q;
		cin>>Q;
		for(;Q>0;Q--)
		{
			char ch[20]="\0";
			int x;
			scanf("%s%d",ch,&x);
			x++;
			if(ch[0]=='O')
				access(x);
			else printf("%.10lf\n",Query(1,N,1,St[x],En[x])*1.0/(En[x]-St[x]+1));
		}
	}
	return 0;
}
# cook your code here
test = input()
for t in xrange(test):
    s = range(1, input()+1)
    w = map(int, raw_input().split())
    for i in xrange(len(w)-1, -1, -1):
        if w[i] > 0:
            s.insert(i, s.pop(i - w[i]))
    print ' '.join(map(str, s))
    
#include<iostream>
#include<algorithm>
#include<cstdio>
#define N 100001
using namespace std;
struct node{
	long long K,B;
	long long sum;
	int son[2];
	int belong;
	long long calc(long long x){
		return x*B+K*(x-1)*x/2;
	}
}f[N*17*17];
int L;
int n,m,now,last,top;
int dfn[N],b[N][2],deep[N],g[N],h[N],fa[N][17],a[N*2][2],q[N];
void ins(int x,int y){
	static int sum=1;
	a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;
}
void dfs(int x){
	for (int i=0;fa[fa[x][i]][i];i++)fa[x][i+1]=fa[fa[x][i]][i];
	deep[x]++;
	for (int i=g[x];i;i=a[i][1])
		if (a[i][0]!=fa[x][0]){
			deep[a[i][0]]=deep[x];
			fa[a[i][0]][0]=x;
			dfs(a[i][0]);
			if (b[a[i][0]][1]+1>b[x][1])
				b[x][1]=b[a[i][0]][1]+1,b[x][0]=a[i][0];
		}
}
void dfs1(int x){
	static int sum=0;
	dfn[x]=++sum;
	if (b[x][0])
		h[b[x][0]]=h[x],dfs1(b[x][0]);
	for (int i=g[x];i;i=a[i][1])
		if (a[i][0]!=b[x][0]&&a[i][0]!=fa[x][0])
			h[a[i][0]]=a[i][0],dfs1(a[i][0]);
}
int getlca(int x,int y){
	static int i;
	i=16;
	if (deep[x]<deep[y])swap(x,y);
	while (deep[x]!=deep[y]){
		for (;deep[fa[x][i]]<deep[y];i--);
		x=fa[x][i];
	}
	i=16;
	while (x!=y){
		for (;i&&fa[x][i]==fa[y][i];i--);
		x=fa[x][i],y=fa[y][i];
	}
	return x;
}
int getlca1(int x,int y){
	static int i;
	i=16;
	while (deep[x]>y){
		for (;deep[fa[x][i]]<y;)i--;
		x=fa[x][i];
	}
	return x;
}
long long get(int s,int l,int r,int ll,int rr){
	ll=max(ll,l);
	rr=min(rr,r);
	if (ll>rr||!s)return 0;
	if (ll==l&&r==rr)return f[s].sum;
	return get(f[s].son[0],l,(l+r)>>1,ll,rr)+get(f[s].son[1],((l+r)>>1)+1,r,ll,rr)-f[s].calc(ll-l)+f[s].calc(rr-l+1);
}
long long up(int x,int y){
	static long long s;
	s=0;
	while (deep[x]>=deep[y]){
		if (deep[h[x]]<=deep[y]){
			s+=get(now,1,n,dfn[y],dfn[x]);
			break;
		}
		s+=get(now,1,n,dfn[h[x]],dfn[x]);
		x=fa[h[x]][0];
	}
	return s;
}
long long getans(int x,int y){
	static long long s;
	s=0;
	while (deep[x]>=deep[y]){
		if (deep[h[x]]<=deep[y]){
			s+=get(now,1,n,dfn[y],dfn[x]);
			break;
		}
		s+=get(now,1,n,dfn[h[x]],dfn[x]);
		x=fa[h[x]][0];
	}
	return s;
}
int ins(int s,int l,int r,int ll,int rr,long long K,long long B){
	ll=max(ll,l),rr=min(rr,r);
	if (ll>rr)return s;
	if (!s)
		f[s=++L].belong=now;
	else
	if (f[s].belong!=now){
		f[++L]=f[s];
		f[L].belong=now;
		s=L;
	}
	if (ll<=l&&r<=rr){
		f[s].K+=K,f[s].B+=B;
		f[s].sum+=K*(r-l)*(r-l+1)/2+B*(r-l+1);
		return s;
	}
	int mid=(l+r)>>1;
	if (mid>=ll){
		f[s].son[0]=ins(f[s].son[0],l,(l+r)>>1,ll,rr,K,B);
		f[s].son[1]=ins(f[s].son[1],((l+r)>>1)+1,r,ll,rr,K,B+K*(mid-ll+1));
	}else
		f[s].son[1]=ins(f[s].son[1],((l+r)>>1)+1,r,ll,rr,K,B);
	f[s].sum=f[f[s].son[0]].sum+f[f[s].son[1]].sum+f[s].calc(r-l+1);
	return s;
}
void up(int x,int y,long long K,long long B){
	static int sum;
	while (deep[x]>=deep[y]){
		if (deep[h[x]]<=deep[y]){
			sum=deep[x]-deep[y]+1;
			ins(now,1,n,dfn[y],dfn[x],-K,B+(sum-1)*K);
			break;
		}
		sum=deep[x]-deep[h[x]]+1;
		ins(now,1,n,dfn[h[x]],dfn[x],-K,B+(sum-1)*K);
		B+=sum*K;
		x=fa[h[x]][0];
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for (int i=1;i<n;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		ins(x,y),ins(y,x);
	}
	dfs(1);
	h[1]=1;
	dfs1(1);
	now=1;
	q[0]=1;
	L=1;
	f[1].belong=1;
	long long ans=0;
	while (m--){
		char c;
		int x,y,K,B;
		scanf(" %c",&c);
		if (c=='c'){
			scanf("%d %d %d %d",&x,&y,&B,&K);
			x=(x+ans)%n+1,y=(y+ans)%n+1;
			int lca=getlca(x,y);
			last=now,now=++L,f[now]=f[last];
			q[++top]=now;
			f[now].belong=now;
			up(x,lca,K,B);
			if (y==lca)continue;
			int lca1=getlca1(y,deep[lca]+1);
			up(y,lca1,-K,B+K*(deep[x]+deep[y]-deep[lca]*2));
		}else
		if (c=='q'){
			scanf("%d %d",&x,&y);
			x=(x+ans)%n+1,y=(y+ans)%n+1;
			if (deep[x]<deep[y])swap(x,y);
			int lca=getlca(x,y);
			if (lca==y){
				printf("%lld\n",ans=getans(x,lca));
				continue;
			}
			int lca1=getlca1(y,deep[lca]+1);
			printf("%lld\n",ans=getans(x,lca)+getans(y,lca1));
		}else{
			scanf("%d",&x);
			x=(x+ans)%(top+1);
			now=q[x];
		}
	}
	return 0;
}
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <stack>
 
using namespace std;
 
template <typename T> T sqr(T x) { return x * x; }
template <typename T> T abs(T x) { return x < 0? -x : x; }
 
const int MAXN = 10007;
const int MAXK = 80;
 
#define A first
#define S second
 
#define left dsalkhfas
#define right sdjkfhkas
 
typedef map < int, stack <int> > mmap;
 
int ans[MAXN];
mmap M;
int n, m, k;
int L, H, N;
int left, right;
 
vector < pair <int, int> > a, b;
map < int, int > f[MAXK][MAXK], g[MAXK][MAXK];
 
void solve(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK])
{
		for (int i = 0; i <= (int)a.size(); i++)
			for (int j = 0; j <= N; j++)
				f[i][j].clear();
				
		f[0][0][0] = 0;
		for (int i = 0; i < (int)a.size(); i++)
			for (int j = 0; j <= N; j++)
				for (int k = 0; k <= N - j && k * H <= a[i].S; k++)
					if ((a[i].S - k * H) % L == 0)
						for (map < int, int > :: iterator iter = f[i][j].begin(); iter != f[i][j].end(); iter++)
							f[i + 1][j + k][(iter->first + (k + (a[i].S - k * H) / L) * (long long)a[i].A) % m] = k;
}
 
 
void recovery(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK], int x, int y, int z)
{
	while (x)
	{
		int c = f[x][y][z];
		x--;
		
		stack <int> &st = M[a[x].A]; 
		for (int i = 0; i < c; i++)
		{
			for (int j = 0; j < H; j++)
			{
				ans[left + k * j] = st.top();
				st.pop();
			}
			left++;
		}
		
		for (int i = 0; i < (a[x].S - c * H) / L; i++)
		{
			for (int j = 0; j < L; j++)
			{
				ans[right + k * j] = st.top();
				st.pop();
			}
			right--;
		}
		
		z = ((z - (c + (a[x].S - c * H) / L) * (long long)a[x].A) % m + m) % m;
		y -= c;
	}	
}
 
int main()
{
	#ifndef ONLINE_JUDGE
		freopen("in", "r", stdin);
		freopen("out", "w", stdout);
	#endif
	int t;
	scanf("%d", &t);
	while (t--)
	{
		M.clear();
		scanf("%d %d %d", &n, &m, &k);
		for (int i = 0; i < n; i++)
		{
			int x;
			scanf("%d", &x);
			M[x % m].push(x);
		}
		if ((int)M.size() > k)
		{
			puts("-1");
			continue;
		}
		a.clear();
		b.clear();
		for (mmap :: iterator iter = M.begin(); iter != M.end(); ++iter)
		{
			if (a.size() == b.size())
				a.push_back(make_pair(iter->first, iter->second.size()));
			else
				b.push_back(make_pair(iter->first, iter->second.size()));
		}
		
		H = n / k + 1;
		L = H - 1;
		N = n % k;
		
		solve(a, f);
		solve(b, g);
		
		bool flg = false;
		left = 0;
		right = k - 1;
		for (int i = 0; i <= N && !flg; i++)
			for (map < int, int > :: iterator iter = f[(int)a.size()][i].begin(); iter != f[(int)a.size()][i].end(); iter++)
				if (g[(int)b.size()][N - i].find((m - iter->first) % m) != g[(int)b.size()][N - i].end())
				{
					recovery(a, f, a.size(), i, iter->first);
					recovery(b, g, b.size(), N - i, (m - iter->first) % m);
					flg = true;
					break;
				}
 
		if (!flg)
		{
			puts("-1");
			continue;
		}
		
		for (int i = 0; i < n; i++)
		{
			if (i) printf(" ");
			printf("%d", ans[i]);
		}
		printf("\n");
	}
	
	return 0;
}
def c(n,p,q,pp,qq):
    p.sort(reverse=pp);q.sort(reverse=qq)
    ta=tb=0
    ma=mb=-1
    ca=cb=0
    a=[-1]*n;b=[-1]*n
    A=[i for i in xrange(n)];B=[i for i in xrange(n)]
    while 1:
        f=1
        if ta==tb:ma=mb=-1
        if ta<=tb:
            for i in A:
                if p[i][1]==mb:continue
                a[p[i][1]]=ta;ma=p[i][1];ta+=p[i][0]
                f=0;A.remove(i);ca+=1;break
            if f:ta=tb
        if ta>=tb:
            for i in B:
                if q[i][1]==ma:continue
                b[q[i][1]]=tb;mb=q[i][1];tb+=q[i][0]
                f=0;B.remove(i);cb+=1;break
            if f:tb=ta
        if ca==n and cb==n:break
    return max(ta,tb),a,b
 
t=input()
for _ in xrange(t):
    n=input()
    p=[0]*n;q=[0]*n
    for i in xrange(n):
        tmp=map(int,raw_input().split())
        p[i]=[tmp[0],i];q[i]=[tmp[1],i]
    ans=2*10**9+1
    for i in xrange(2):
        for j in xrange(2):
            tmp=c(n,p,q,i,j)
            if tmp[0]<ans:
                ans=tmp[0];a=tmp[1];b=tmp[2]
    print ans
    for i in xrange(n):
        print a[i],b[i]
from itertools import combinations
from collections import defaultdict
 
 
def small_j(sticks, cum, k):
    for j in range(k - 1, len(sticks)):
        i = j - k + 1
        hyp = sticks[j]
        rest = cum[j - 1] - cum[i] + sticks[i]
        if rest > hyp:
            return i, j
    return None, None
 
def small_ii(sticks, cum, k):
    for jj in range(-1, k - len(sticks) - 1, -1):
        ii = jj - k + 1
        hyp = sticks[jj]
        rest = cum[jj - 1] - cum[ii] + sticks[ii]
        if rest > hyp:
            return len(sticks) + ii, len(sticks) + jj
    assert False
 
 
 
 
 
 
def solve(n, k, sticks):
    len_pos = defaultdict(list)
    for pos, len_ in enumerate(sticks):
        len_pos[len_].append(str(pos + 1))
 
    sticks.sort()
    tot = 0
    cum = []
    for s in sticks:
        tot += s
        cum.append(tot)
 
    i, j = small_j(sticks, cum, k)
    if j is None:
        return "No"
 
    ii, jj = small_ii(sticks, cum, k)
 
    if ii > j:
        ans = sticks[i:j+1] + sticks[ii:jj+1]
        ans_i = []
        for len_ in ans:
            ans_i.append(len_pos[len_].pop())
        return "Yes\n" + " ".join(ans_i)
 
    if jj < 2*k - 1:
        return "No"
 
    chosen_sticks = list(enumerate(sticks[jj - 2*k + 1: jj+1]))
    assert len(chosen_sticks) == 2*k
 
    positions = range(len(chosen_sticks))
 
    solution = None
    for poly1 in combinations(positions, r=k):
        poly1 = list(poly1)
        i1 = 0
        sum1 = 0
        sum2 = 0
        hyp1 = 0
        hyp2 = 0
        for pos, cs in chosen_sticks:
            if i1 < k and pos == poly1[i1]:
                sum1 += cs
                i1 += 1
                hyp1 = cs
            else:
                sum2 += cs
                hyp2 = cs
        sum1 -= hyp1
        sum2 -= hyp2
        if sum1 > hyp1 and sum2 > hyp2:
            solution = poly1
            break
 
    if solution is None:
        return "No"
    else:
        chosen_sticks = [v for _, v in chosen_sticks]
        poly1 = [chosen_sticks[i] for i in solution]
        for v in poly1:
            chosen_sticks.remove(v)
        poly2 = chosen_sticks
        ans = poly1 + poly2
        ans_i = []
        for len_ in ans:
            ans_i.append(len_pos[len_].pop())
        return "Yes\n" + " ".join(ans_i)
 
 
# from random import randint
#
# for i in range(100):
#     break
#     for mx in range(1,100, 5):
#         for x in range(0, 5):
#             for k in range(3, 10):
#                 half1 = [randint(1, mx) for i in range(k-1)]
#                 half1.append(sum(half1)-1)
#                 half2 = [randint(1, mx) for i in range(k-1)]
#                 half2.append(sum(half2)-1)
#                 extra = [randint(1, mx) for i in range(x)]
#                 sticks = half1 + half2 + extra
#                 ans = solve(len(sticks), k, sticks)
#                 if ans == "No":
#                     print half1, half2, sticks
#                 else:
#                     pass
#                     #print ans
#
# print solve(6,3, [4, 46, 53, 59, 62, 98])
 
n, k = map(int, raw_input().split())
sticks = map(int, raw_input().split())
print solve(n, k, sticks) 
n,k = map(int, raw_input().split())
b = map(int, raw_input().split())
bs = sorted(set(b))

lst = bs[0]
add = 1
for i in range(1,len(bs)):
    if(bs[i]>=lst+k):
        lst=bs[i]
        add+=1
print add
#include <bits/stdc++.h>
#define MOD 1000000007
#define maxn 555
#define maxm 1111111
using namespace std;
int B[] = {1,500000004,166666668,0,766666672,0,23809524,0,766666672,0,348484851,0,469963373,0,166666669,0,413725486,0,865914848,0,948484326,0,427542427,0,469876793,0,168092185,0,980747753,0,678176322,0,297409831,0,781306726,0,35337905,0,482221937,0,83084250,0,310292012,0,334581823,0,437628892,0,708314481,0,860344292,0,643009310,0,159517512,0,742356578,0,392872747,0,465850017,0,647900229,0,431346688,0,461733065,0,255588829,0,307276324,0,610411531,0,197137262,0,18565655,0,852238879,0,284923925,0,483196916,0,208794235,0,148591948,0,244784253,0,416223553,0,138705149,0,711847843,0,394739272,0,39530788,0,94103270,0,944699132,0,555008829,0,134395782,0,775574192,0,526027076,0,366329102,0,997501812,0,64960653,0,917154602,0,537182455,0,171713000,0,799849313,0,974650756,0,764681019,0,129465940,0,514970793,0,185828032,0,874015104,0,8063031,0,637955273,0,873230471,0,104279039,0,836586090,0,597557491,0,392225623,0,676908015,0,88768944,0,498487309,0,451730794,0,566607730,0,444106794,0,181463496,0,127835995,0,763021163,0,570276863,0,393273175,0,462754189,0,379663078,0,318486088,0,208134750,0,178450624,0,960012260,0,180738104,0,756632653,0,645210773,0,79148833,0,45135138,0,965798517,0,513668750,0,569147985,0,377199181,0,822327589,0,256265266,0,791964162,0,29587355,0,327610019,0,862621077,0,549923786,0,132821305,0,674078980,0,961947656,0,919724059,0,689243733,0,72331329,0,586420422,0,773720988,0,443408114,0,908991031,0,207009656,0,296402826,0,77102696,0,369815072,0,310161627,0,631457613,0,604069632,0,716006985,0,510023389,0,167568388,0,694658101,0,706710536,0,838416939,0,240289128,0,696217436,0,343729523,0,34462081,0,373123193,0,279501781,0,519692461,0,869446785,0,529273692,0,499794482,0,658700293,0,493702151,0,342395770,0,729371213,0,301819236,0,128980415,0,132306570,0,241791898,0,492800463,0,663928117,0,609246064,0,742804971,0,191205480,0,733562164,0,534291334,0,100454741,0,680938365,0,112611490,0,518509669,0,515895557,0,650367989,0,482520941,0,608281652,0,132944223,0,980310087,0,492175239,0,276254120,0,937618650,0,342877120,0,603124736,0,499580133,0,956083803,0,647937936,0,391675275,0,551847266,0,189330612,0,536587296,0,137527475,0,634139293,0,547079242,0,62582319,0,874691594,0,953985920,0,123065123,0,102680251,0,598629189,0,765865958,0,122003913,0,5388217,0,985831463,0,35749021,0,5485253,0,610847551,0,957553266,0,966107971,0,434637748,0,891023940,0,368937249,0,743121746,0,647582764,0,394861194,0,259611444,0,401218546,0,280958587,0,146726474,0,73728156,0,420484782,0,860432061,0,263555720,0,171370950,0,288940895,0,433962809,0,12810405,0,389000258,0,232347992,0,457377160,0,611980685,0,931117158,0,528373281,0,776924478,0,895196991,0,52260137,0,103734862,0,534188375,0,528819173,0,515009883,0,358459629,0,411876639,0,110831030,0,369807092,0,151928066,0,481598434,0,213781569,0,946564591,0,22612993,0,147058031,0,705049590,0,671160341,0,274407250,0,803279265,0,296028218,0,829477416,0,627699152,0,889545991,0,602277421,0,440283672,0,574919593,0,151551215,0,467285232,0,590802585,0,914358666,0,760187446,0,475666672,0,666337315,0,666685349,0,972161058,0,141242138,0,210381798,0,330198584,0,489119877,0,165342809,0,412027566,0,35036448,0,301656123,0,275725170,0,723660845,0,97140868,0,687293653,0,756858419,0,740061355,0,477765430,0,978160109,0,170517295,0,603571894,0,856182503,0,315060077,0,604702699,0,188059190,0,746154800,0,590957649,0,598277218,0,632775339,0,664543162,0,2176347,0,672563104,0,128051225,0,589594871,0,122041955,0,448233270,0,648217760,0,348479553,0,3463898,0,601897670,0,948217634,0,981358001,0,667164726,0,394191524,0,925543283,0,325843658,0,541338833,0,746489435,0,91488040,0,715678547,0,750655274,0,814132750,0,116397711,0,914346845,0,556250432,0,324132590,0,690119570,0,828813439,0,239695356,0,365272463,0,666187216,0,195595943,0,421967346,0,775431091,0,962497750,0,26142436,0,83393779,0,705969466,0,91227746,0,753015148,0,413503277,0,931653254,0,580717169,0,154398267,0,837431357,0,350394676,0,451728855,0,255961371,0,646092315,0,193948002,0,229698568,0,24114743,0,600293174,0,92511515,0,119801205,0,836131171,0,11051624,0,402298382,0,379031843,0,726940835,0,701472598,0,810405972,0,232826697,0,66223100,0,314900196,0,714385546,0,432605375,0,653849391,0,215662321,0,305796813,0,198384728,0,360640745,0,597797231,0,962965419,0,233437891,0,390675234,0,358927306,0,440784360,0,416144987,0,736130703,0,923999423,0,421227050,0,937497055,0,904911796,0,177537196,0,832966398,0,955747054,0,769028146,0,217829919,0,121312046,0,642425322,0,16482376,0,595844855,0,577119793,0,317026562,0,954366898,0,828469135,0,962293354,0,385244332,0,665114228,0,410022759,0,112347819,0,168547779,0,152521210,0,52115211,0,578426471,0,541479976,0,259759934,0,328695806,0,816904224,0,959827211,0,507215664,0,910936985,0,547178368,0,134666216,0,270841805,0,188889050,0,204016097,0,373911022,0,516605109,0,809450330,0,867867022,0,412200713,0,123461364,0,54686621,0,335364566,0,565701631,0,761346648,0,375958382,0,291271867,0,169228778,0,929819070,0,344008620,0,397270941,0,341713260,0,557438041,0,975894363,0,220974084,0,304187612,0,82742958,0,747790793,0,622077487,0,170945937,0,907505719,0,908097107,0,327932984,0,351751775,0,134879555,0,330690210,0,395457038,0,466835879,0,914274480,0,739247533,0,91394730,0,109420689,0,785342130,0,511158008,0,964424181,0,792887384,0,422772213,0,513370334,0,606290202,0,267324432,0,619123502,0,268619297,0,455319584,0,949580630,0,294472744,0,251873935,0,194966337,0,977958395,0,453441611,0,202648831,0,469022610,0,921283067,0,592849363,0,825258420,0,146297264,0,729026590,0,717160336,0,365993381,0,92261170,0,219584935,0,315450728,0,403464842,0,960156873,0,69810174,0,435551605,0,1412253,0,941905734,0,698038089,0,717005321,0,77477037,0,270474705,0,601555224,0,635487116,0,841345296,0,322347063,0,67096504,0,839915524,0,406371237,0,528931370,0,18278769,0,247546212,0,875698645,0,23327113,0,35115245,0,80637764,0,973745532,0,515280823,0,341936397,0,67429829,0,765714429,0,574598713,0,840447354,0,206666322,0,674749538,0,842767205,0,16011385,0,881411065,0,79476894} ;
 
int nCr[maxn][maxn];
bool isPrime[maxm];
int inv[maxn];
vector<long long> prime;
vector<long long> Ft;
long long pws[maxn];
long long n, k;
 
void comb() {
	inv[0] = 1 ;
    inv[1] = 1 ;
    for(int i=2;i<=300;i++){
        inv[i] = 1LL * (MOD - MOD/i) * (inv[MOD%i]) % MOD ;
    }
    for(int i=0;i<=300;i++){
        nCr[i][0] = 1 ;
 
    }
    for(int i=1;i<=300;i++){
        for(int j=1;j<=i;j++){
            nCr[i][j] = nCr[i-1][j-1] + nCr[i-1][j] ;
            if(nCr[i][j] >= MOD)
                nCr[i][j] = nCr[i][j]%MOD ;
        }
    }
}
void seive() {
	for(int i=2;i<maxm; i++) {
		if(!isPrime[i]) {
			prime.push_back(i);
			for(int j=2*i ;j<maxm; j+=i) {
				isPrime[j] = true;
			}
		}
	}
}
 
void factorize() {
	long long temp = n;
	int i=0;
	Ft.clear();
	while(1LL * prime[i] * prime[i] <= temp) {
		if(temp % prime[i] == 0) {
			Ft.push_back(prime[i]);
			while(temp%prime[i] == 0 ) {
				temp = temp / prime[i];
			}
		}
		
		i++;
	}
	if(temp > 1) {
		Ft.push_back(temp);
	}
}
 
long long powermod(long long a, long long p) {
	long long temp = 1;
	while(p) {
		if(p & 1) {
			temp = temp * a;
		}
		if(temp >= MOD) {
			temp = temp  % MOD;
		}
		
		a = a * a;
		if(a>=MOD) {
			a = a%MOD;
		}
		p = p/2;
	}
	return  temp;
}
void task1() {
	long long res = 0;
	for(long long i=1;i<=n; i++) {
		if(__gcd(i, n) == 1) {
			res = res + powermod(i, k);
		}
		if(res >= MOD) {
			res = res % MOD;
		}
	}
	printf("%lld\n",res);
}
long long fun(long long n, long long k) {
	long long s = 0 ;
    long long temp = n ; temp %= MOD ;
    for(int i=0;i<=k;i++){
        s = (1LL * s * temp % MOD ) + (1LL * nCr[k+1][i] * B[i]) % MOD ;
        if(s >= MOD) s = s % MOD ;
    }
    s = 1LL * s * temp % MOD ;
    s = 1LL * s * inv[k+1] % MOD ;
    return s ;
}
void solve() {
	if(k > 256) {
		task1();
	} else {
		factorize();
		
		int fSize = Ft.size();
		//cout<<fSize<<"\n";
		long long res = 0;
		for(int mask = 0; mask < (1<<fSize); mask++) {
			int cnt = 0;
			long long num = 1;
			for(int j=0; j<fSize; j++) {
				if((1<<j)&mask) {
					cnt++;
					num *= Ft[j];
				}
			}
			
			if(cnt&1) {
				res = res - (1LL*fun(n/num, k) * (powermod(num%MOD, k))%MOD);
				if(res < 0) {
					res = res + MOD;
				}
			} else {
				res = res + (1LL*fun(n/num, k) * (powermod(num%MOD, k))%MOD);
				if(res >= MOD) {
					res = res - MOD;
				}
			}
		}
		printf("%lld\n",res);
	}
}
int main() {
	// your code goes here
	int t;
	comb();
	seive();
	
	scanf("%d",&t);
	while(t--) {
		scanf("%lld %lld",&n, &k);
		solve();
	}
	return 0;
} 
import sys
import math

n=int(raw_input())
#n=(10**100)-222

a={}
a[n]=1
v=1
while v<=n:
  a[v]=[v/2,v/2]
  v*=2
def close(x):
  ret=1
  while ret*2<=x:
    ret*=2
  return ret
def see(x):
  if x==0 or x==1:
    return
  if x%2:
    a[x]=[1,x-1]
    if not a.has_key(x-1):
      a[x-1]=1
      see(x-1)
    return
  v=x-close(x)
  if v==0:
    return
  a[x]=[v,x-v]
  if not a.has_key(v):
    a[v]=1
    see(v)
see(n)
ta=a
if len(a)<len(ta):
  ta=a
###########################################################
primes=[3,5,7,11,13,17,19]#,23,29,31,37,41]
a={}
a[1]=1
a[n]=1
def get2(x):
  if x==1:
    return
  if x%2==0:
    a[x]=[x/2,x/2]
    if not a.has_key(x/2):
      a[x/2]=1
      get2(x/2)
  else:
    for p in primes:
      if x%p==0:
        v=x/p
        a[x]=[v,x-v]
        if not a.has_key(v):
          a[v]=1
          get2(v)
        if not a.has_key(x-v):
          a[x-v]=1
          get2(x-v)
        return
    a[x]=[1,x-1]
    if not a.has_key(x-1):
      a[x-1]=1
      get2(x-1)
get2(n)
#print 'here2',len(a)
if len(a)<len(ta):
  ta=a

###########################################################
def get3(x):
  if x==1:
    return
  c=a.keys()
  c.sort()
  atx=0
  aty=len(c)-1
  while atx<=aty:
    if c[atx]+c[aty]==x:
      a[x]=[c[atx],c[aty]]
      return
    elif c[atx]+c[aty]>x:
      aty-=1
    else:
      atx+=1
  if x%2==0:
    a[x]=[x/2,x/2]
    if not a.has_key(x/2):
      a[x/2]=1
      get2(x/2)
  else:
    for p in primes:
      if x%p==0:
        v=x/p
        a[x]=[v,x-v]
        if not a.has_key(v):
          a[v]=1
          get2(v)
        if not a.has_key(x-v):
          a[x-v]=1
          get2(x-v)
        return
    a[x]=[1,x-1]
    if not a.has_key(x-1):
      a[x-1]=1
      get2(x-1)
for at in range(2,9):
  a={}
  a[1]=1
  visit=[]
  for i in range(2,2**at):
    visit.append(0)
    #a[i]=[1,i-1]

  mod=int(2**at)
  #print at,mod
  def get(x):
    if a.has_key(x):
      return
    if x<mod:
      visit[x-2]=1
      return
    if x%2==0:
      while(x%2)==0:
        y=x/2
        a[x]=[y,y]
        x=y
      get(y)
    else:
      y=x%mod
      visit[y-2]=1
      a[x]=[y,x-y]
      get(x-y)      
  get(n)
  last=1
  for i in range(2,2**at):
    if visit[i-2]==1:
      get3(i)
      
  #print len(a),len(ta)
  if len(a)<len(ta):
    ta=a

b=ta.keys()
b.sort()
l=len(b)
#print b

def find(start, end, v):
  if start==end:
    return start
  mid=(start+end)/2
  if v<=b[mid]:
    return find(start,mid,v)
  else:
    return find(mid+1,end,v)

print l-1
for key in b:
  if key!=1:
    #print key
    x=ta[key]
    (x,y)= (find(0,l-1,x[0]), find(0,l-1,x[1]))
    print x,y

print"0"
#!/usr/bin/env python

def process(N, M, mines):
    G = [0] * (2 ** N)
    for x, y in mines:
        G[x] |= 1
    print G.count(0)
    for x in xrange(2 ** N):
        if  not G[x]:
            print x, 0

def main():
    N = int(raw_input().strip())
    M = int(raw_input().strip())
    mines = []
    for m in xrange(M):
        mines.append(map(int, raw_input().strip().split()[:2]))
    process(N, M, mines)

main()

def payed(amount,mark,arr,n):
	#print "fun"
	#print "amount",amount
	if(amount==0):
	#	print "if-1"
		return 1
	i=0;count=0
	while(i<n):
		if(arr[i]<=amount and mark[i]!=1):
	#		print "minus",arr[i],"from",amount
			mark[i]=1
			if( payed(amount-arr[i],mark[:],arr,n ) ):
	#			print "if-2"
				return 1
		i+=1
	#print "ducki"
	return 0

t=input()
while(t>0):
	t-=1
	n,m=map(int,raw_input().split())
	i=0;arr=[0]*n;mark=[0]*n
	while(i<n):
		arr[i]=input()
		i+=1
	if(payed(m,mark,arr,n)):
		print "Yes"
	else:
		print "No"
def check():
	a=[]
	k=int(raw_input())
	a[0:]=map(int,raw_input().split())
	s=0.5
	for i in range(len(a)):
		s=s*2-a[i]
	if s == 0:
		return 1
	else:
		return 0

def main():
	m=0	
	j=int(raw_input())
	while m<j:
		if(check()):
			print "Yes"
		else:
			print "No"
	 	m=m+1
	return 
if __name__=="__main__":
	main()
import sys
from collections import Counter
 
t = sys.stdin.readline()
m = 1
M = 1000000000
for _ in range(int(t)):
	k = sys.stdin.readline()
	k = int(k)
	assert(1 <= k <= 100000)
	c = Counter()
	for _ in range(k):
		line = sys.stdin.readline()
		o, l, v = line.strip().split()
		l = int(l)
		assert(m <= l <= M)
		v = v.upper()
		if o == '<' and v == 'YES': #less
			c[l] += 1				
		elif o == '<' and v == 'NO': #great or equal 
			c[m] += 1				 
			c[l] -= 1
		elif o == '>' and v == 'YES':	#great
			c[m] += 1
			c[l+1] -= 1
		elif o == '>' and v == 'NO':	#less or equal
			c[l+1] += 1
		elif o == '=' and v == 'YES':
			c[m] += 1
			c[l] -= 1
			c[l+1] += 1
		elif o == '=' and v == 'NO':
			c[l] += 1
			c[l+1] -= 1
 
	count = 0
	mcount = k
	for key in sorted(c):
		count += c[key]
		if key <= M:
			mcount = min(mcount, count)
	print(mcount)
s2 = ['AA', 'BB']
s2a = ['A', 'B']
s3 = ['ABA', 'BAB', 'AAB', 'BBA', 'BAA', 'ABB']
s3a = ['A', 'B', 'A', 'B', 'A', 'B']
t = int(raw_input())
for i in xrange(t):
    s = raw_input().upper()
    if len(s) == 2:
        if s in s2:
            print s2a[s2.index(s)]
        else:
            print -1
    elif len(s) == 3:
        if s in s3:
            print s3a[s3.index(s)]
        else:
            print -1
    else:
        if s[0] == 'A':
            s = 'B' + s
        else:
            s = 'A' + s
        if s[len(s) - 1] == 'A':
            s = s + 'B'
        else:
            s = s + 'A'
        n = len(s)
        if 'ABBA' in s or 'BAAB' in s:
            index = s.find('ABBA')
            if index < 0:
                index = s.find('BAAB')
            if index == 0:
                print s[1] + s[3 : n - 1]
            elif index == n - 4:
                print s[1 : n - 2]
            else:
                print s[1 : index + 2] + s[index + 3: n - 1]
        else:
            print -1 
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<limits>
#include<vector>
using namespace std;
#define MOD 1000000007LL
#define LL long long
#define ULL unsigned long long
#define LD long double
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(x) ((x)<0?-(x):(x))
#define si(n) scanf("%d",&n)
#define sf(n) scanf("%f",&n)
#define sl(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
#define slu(n) scanf("%llu",&n)
#define sd(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define pnl printf("\n")//print new line
#define REP(i,n) for(int i=0;i<(n);i++)//repeat n times
#define FOR(i,a,b) for(int i=(a);i<(b);i++)//end not included
#define FORR(i,n) for(int i=(n);i>=0;i--)//reverse for
#define DB(x) cout<<"\n"<<#x<<" = "<<(x)<<"\n";//debugging
#define CL(a,b) memset(a,b,sizeof(a))
const double PI=3.14159265358979323846264338327950288419716939937510582097494459230;
void swaps (char *x,char *y){char temp;temp=*x;*x=*y;*y=temp;}
void swapi(int *a,int *b){int temp;temp=*a;*a=*b;*b=temp;}
ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);}
//}

int main() {
	// your code goes here
	string n="";
	int f=2;
	while(1){
		string s;
		cin>>s;
		if(s[0]=='#'){
			LL ans=0;
			reverse(n.begin(),n.end());
			for(int i=0;i<n.size();i++)
				ans += (n[i]-'0')<<i;
			cout<<ans<<endl;
			n="";
			f=2;
		}else if(s[0]=='~'){
			break;
		}
		int l=s.size();
		if(l==1)f=1;
		else if(l==2)f=0;
		for(int i=0;i<l-2;i++)n+='0'+f;
	}
	return 0;
}

n,m = map(int,raw_input().split())
arr = raw_input()
my = [0]*10

ans = [ 0 for i in xrange(n)]

for i in xrange(n):
    x = ord(arr[i])-48
    y = 0
    for j in xrange(10):
        ans[i] +=abs(x-j)*my[j]
    my[x] +=1

for i in xrange(m):
    x = input()-1
    print ans[x]
    



fib=[1,1,2,3,5]
i=4
while fib[i] < 10e18:
	i+=1
	fib+=[fib[i-1]+fib[i-2]]
t=int(input())
while t:
	n=int(input())
	i=0
	while fib[i]<=n:
		i+=1
	print i-1
	t-=1
import sys
import math 
 

check={}
 
def primes(n):
    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """ Input n>=6, Returns a list of primes, 2 <= p < n """
    correction = (n%6>1)
    n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]
    sieve = [True] * (n/3)
    sieve[0] = False
    for i in xrange(int(n**0.5)/3+1):
      if sieve[i]:
        k=3*i+1|1
        sieve[      ((k*k)/3)      ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1)
        sieve[(k*k+4*k-2*k*(i&1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&1))/6-1)/k+1)
    return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]]
 
upto=5000000+1
for i in primes(upto):
    if i%4==1:
        for j in range(i,upto,i):
            check[j]=True
            
 
def main():
    t=int(sys.stdin.readline())
    for i in range(t):
        num=int(sys.stdin.readline())
        if check.has_key(num):
            print "YES"
        else:
            print "NO"
main()

import sys
import math

M = 1000000007

rs = {}

def fn(An, En, V, l=0):
    global rs, M
    if V < 0:
        return 0
    
    if rs.has_key(An):
        if rs[An].has_key(En):
            if rs[An][En].has_key(V):
                return rs[An][En][V]
        else:
            rs[An][En] = {}
    else:
        rs[An] = {}
        rs[An][En] = {}

    rs[An][En][V] = None
    if V < An:
        rs[An][En][V] = 0

    if An == 0 and En == 0:
        if V == 0:
            rs[An][En][V] = 1
        else:
            rs[An][En][V] = 0
    
    if An == 1 and En == 0:
        if V == 0:
            rs[An][En][V] = 0
        else:
            rs[An][En][V] = 1

    if An == 0 and En == 1:
        rs[An][En][V] = 1

    if rs[An][En][V] == None:
        vRemain = V - An
        s = (An + En) / 2
        cnt = 0
        for an1 in range(max(0, s - En), min(An, s)+1):
            an2 = An - an1
            en1 = s - an1
            en2 = En - en1
            cnt1 = cnt2 = 0L
            cnt1 = fn(an1, en1, vRemain, l+1)
            cnt2 = fn(an2, en2, vRemain, l+1)
            cnt += cnt1 * cnt2
        rs[An][En][V] = cnt % M
    return rs[An][En][V]
    
def main():        
    testCases = int(sys.stdin.readline())
    cases = []
    for n in range(0, testCases):
        An, En, V = sys.stdin.readline().split(' ')
        print "%s" % ((fn(int(An), int(En), int(V)) - fn(int(An), int(En), int(V)-1) + M ) % M)
 
if __name__ == '__main__':
    main()

import string,sys
s = sys.stdin.readline()
maxi = 0
l = 0
a = 0
j = 0
for i in string.uppercase:
    if i in s:
        l = 1
        break
if l:
    l = 0
    length = len(s)
    for i in xrange(length):
        if s[i] in string.uppercase:
            if l:
                nm = int(s[a:j]+"9"+s[j+1:i])
                if maxi < nm:
                    maxi = nm
                a = j + 1 
            else:
                l = 1
            j = i
        if i == length - 1:
            nm = int(s[a:j]+"9"+s[j+1:i + 1])
            if maxi < nm:
                maxi = nm
            a = j + 1 
else:
    maxi = int(s)
print maxi
import sys
a =  int(raw_input())
while a>0:
    n = int(raw_input())
    b=[0]*n
    i=0
    l=0
    b=map(int,sys.stdin.readline().split())
    while i<(n-1):
        if(b[i]==b[i+1]):
            l+=1
        i+=1
    n=n-l
    m=((n-l)*(n-l-1))/2
    print m
    a-=1

#! /usr/bin/env python
# -*- coding: utf-8 -*-

lst = [0, 1]
for i in range(2, 5020):
    lst.append(lst[i-2]+lst[i-1])

def evaluate(fromd, to):
    if length <= 3:
        fromd = 0
        to    = 20
    for i in range(fromd, to):
        if int(fib_int) == lst[i]:
            print "YES"
            return
    print "NO"

num = input()
while num:
    fib_int = raw_input()
    length  = len(fib_int)
    fromd   = int(length*4.784688995215311)-10
    to      = int(length*4.784688995215311)+10
    evaluate(fromd, to)
    num     = num-1

def ans(l,k):
	n = len(l)
	if (n%(k+1) == 0):
		k = n/(k+1)
	else:
		k = (n/(k+1)) + 1
	return (l[k-1])

n = int(input())
l = list(map(int,raw_input().split()))
l.sort()
i = 0
s = 0
while (i < len(l)):
	s += l[i]
	l[i] = s
	i += 1
q = int(input())
while (q != 0):
	k = int(input())
	q -= 1
	print(ans(l,k))

t=int(raw_input())
def gcd(a,b):
	if a==0:
		return b
	return gcd(b%a,a)
while t>0:
	t-=1
	n=int(raw_input())
	a=map(int,raw_input().split())
	b=gcd(a[0],a[1])
	if n>2:
		for i in range(2,n):
		    b=gcd(b,a[i])
	print b	
for _ in xrange(input()):
        n,m = map(int, raw_input().strip().split())
        l = map(int, raw_input().strip().split())
        mx = max(l)
        mn = min(l)
        out = [max(abs(mx-i), abs(i-mn)) for i in range(n)]
        print " ".join(map(str,out))
import sys
a =  int(raw_input())
while a>0:
    b=int(raw_input())
    i=sum=0
    p = map(int,sys.stdin.readline().split())
    p.sort()
    p.reverse()
    j=int(b/4)
    l=b%4
    while i<j:
        sum+=p[4*i]+p[(4*i)+1]
        i+=1
    if b==1:
        print p
    elif l==0:
        print sum
    elif l==1:
        print (sum+p[4*j])
    elif l==3 or l==2:
        print (sum+p[4*j]+p[(4*j)+1])
    a-=1
        

test_case = int(raw_input())
for t in range(test_case):
	n = int(raw_input())
	if 360 % n == 0:
		print 'y',
	else:
		print 'n',
	if n <= 360:
		print 'y',
	else:
		print 'n'
	if (n*(n+1)/2) <= 360:
		print 'y',
	else:
		print 'n'
import math
output = list()
prime = list()
val = raw_input()
t = int(val)
for i in range(t) :
	nums = list()
	string1 = raw_input()
	nums = string1.split()
	a = float(nums[0])
	b = float(nums[1])
	output.append(a+b-1)
for i in range(t) :
	print output[i]
for t in range(int(raw_input())):
    n=int(raw_input())
    print (n+1)**2-(n*(n+1))/2-1
t=input()
while(t>0):
	t-=1
	n=input()
	N= 103993;R=33102;index=0;s="3."
#	print "r"
	r=N%R
#	print r
	while(index<n):
	#	print "while"
	#	print "index"
		index+=1
	#	print index
		r=r*10
		while(r<R and index<n):
		#	print "while-while"
			r=r*10
			s=s+str(0)
			index+=1
#		p#rint "r"
		#print r
		s=s+str(r/R)
		r=r%R
#		print "s"
#		print s
#		print "r"
#		print r
	if(n==0):print 3
	else: print s

t=int(raw_input())
for i in xrange(t):
    n,y=map(int,raw_input().split())
    x=list(map(int,raw_input().split()))
    x.sort()
    counter=0
    mini=20000000000
    for j in xrange(n):
        for k in xrange(j+1,n):
            if abs(x[j]+x[k]-y)<mini:
                mini=abs(x[j]+x[k]-y)
                counter=1
            elif abs(x[j]+x[k]-y)==mini:
                counter+=1
    print mini,counter 
def binInt(n):
        b = bin(n)[2:].zfill(k)
        r = b[::-1]
        return [int(b,2),int(r,2)]


for _ in range(input()):
        k,s = raw_input().strip().split()
        k = int(k)
        sl = [i for i in s]
        l = [0] * (2**k)

        for i in range(2**k):
                b,r = binInt(i)
                if l[b] == 0 or l[r] == 0:
                        sl[b],sl[r] = sl[r],sl[b]
                        l[b] = 1
                        l[r] = 1
        print "".join(sl)
'''
Yet Another Nice Girl

Problem code: ARRGAME2

Problem Statement

Little Chef doesn't love math anymore. He loves Aleksandra.

Sashen'ka is nice. They spend all the time together. Even their
birthdays they are celebrating together, because they were born on the
same day :)

And now, this day is coming...

Chef know that most of all Sasha loves numbers, that's why he bought N
positive numbers to a girl.

From her side, Sasha as all girls, thought that if she likes
something, then all people like that too. And bought to a boy N
numbers too. xD

After all greeting young people decide to play a game with their gifts.
The game will be continued for N turns, in each turn the following will
 be done:

Chef randomly choose some number x from his gift.

Sasha randomly choose some number y form her gift.

If x^y > y^x then girl will kiss fellow.

Numbers x,y will be discarded from gifts.

Now chef is wondering what is the expected number of times he will be
kissed by Sasha ?

Input

The first line of the input contains an integer T denoting the number
of test cases. The description of T test cases follows.

The first line of each test case contains a single integer N denoting
the number of numbers in each gift. The second line contains N
space-separated integers A1, A2, ..., AN denoting the numbers Sasha
gave to Chef. Next line describe B1, B2, ..., BN numbers boy gave to
girl in the same way.

Output

For each test case, output a single line containing answer for
corresponding test. Your answer will be considered as correct if it
will have absolute error not more then 10^-6.

Constraints
1 <= T <= 5
1 <= N <= 10^5
1 <= Ai <= 10^9
1 <= Bi <= 10^9

Example

Input
3
1
3
4
2
2 3
1 4
2
2 4
2 2

Output:
1.000000
1.500000
0.000000

Explanation

Example case 1. Game will have only 1 turn. Chef will choose 3, while
Sasha will choose 4. Since 3^4>4^3 girl will kiss boy. Hence answer is
1.

Author:         ballon_ziq
Tester:         shangjingbo
Tags            ballon_ziq
Date Added:     2-08-2013
Time Limit:     2 sec
Source Limit:   50000 Bytes
'''

from math import log
from sys import stdin

#### codechef 2013-10 Yet Another Nice Girl

def search(x,B):
    def is_yes(mid):
        y = B[mid]
        # log(x^y) > log(y^x) whack a big number with log().
        # a = y * log(x); b = x * log(y)
        return x < y
    n = len(B); lo = 0; hi = n-1
    while lo < hi:
        mid = lo + (hi-lo)/2
        if is_yes(mid):
            hi = mid
        else:
            lo = mid + 1
    if is_yes(lo) is False:
        # Reach to the end but still cannot find 'Yes'.
        return 0
    return n-lo

def solve(A,B):
    B = sorted(B); ans = 0; n = len(A)
    ones = twos = 0
    for b in B:
        if b == 1:
            ones += 1
        if b == 2:
            twos += 1
    # This can be modeled as throwing balls A to bins B?
    for a in A:
        if a > 1:
            if a == 2:
                a = 4
            cnt = search(a,B)
            if a == 3:
                cnt += twos
            ans += cnt + ones            
    ans = ans * 1.0/n
    return ans

def check_test(A, B, data='', case=[0]):
    print
    print "test %d:" % case[0]
    print A
    if abs(A-B) > 1e-9:
        if data:
            print data
        print '>>>', A
        print '<<<', B
        print "!!!!!!!! FAIL !!!!!!!!"
    else:
        print ":::::::) OK"
    case[0] += 1

def unit_test():
    print
    A,B, ans = (3,),(4,), 1.0
    check_test(solve(A,B), ans, (A,B))

    A,B, ans = (2,3),(1,4), 1.5
    check_test(solve(A,B), ans, (A,B))

    A,B, ans = (2,4),(2,2), 0
    check_test(solve(A,B), ans, (A,B))

def output():
    for case in xrange(1, int(stdin.next()) + 1):
        N = int(stdin.next())
        A = [int(i) for i in stdin.next().split()]
        B = [int(i) for i in stdin.next().split()]
        ans = solve(A,B)
        print "%.6f" % ans

if __name__ == '__main__':
#    unit_test()
    output()

__author__ = 'robert'
from collections import defaultdict
import sys

def solve(cache, between, i, j):
    if (i, j) in cache:
        return cache[(i, j)]
    if not between[(i, j)]:
        return 0
    if len(between[(i, j)]) == 1:
        return 1
    grundy_numbers = set()
    for word in between[(i, j)]:
        start, end = word
        grundy_numbers.add(
            solve(cache, between, i, start) ^ solve(cache, between, end, j)
        )
    mex = 0
    while mex in grundy_numbers:
        mex += 1
    cache[(i, j)] = mex
    return mex



def run():
    input_ = (i.strip() for i in sys.stdin)
    test_cases = int(next(input_))
    for case in range(test_cases):
        s = next(input_)
        n = int(next(input_))
        words = [next(input_) for i in range(n)]
        word_locations = []
        for i in range(len(s)):
            for j in range(i + 1, len(s) + 1):
                if s[i:j] in words:
                    word_locations.append((i, j))
        between = defaultdict(list)
        for word in word_locations:
            start, end = word
            for i in range(start + 1):
                for j in range(end, len(s) + 1):
                    between[(i, j)].append(word)
        cache = {}
        print "Teddy" if solve(cache, between, 0, len(s)) else "Tracy"

run()
import heapq
    
def solve(s, k):
    res = []
    start_index = -1
    end_index = len(s) - k
    #choose the staring window
    h = [(y, x) for x, y in enumerate(s[:end_index])]
    heapq.heapify(h)

    for _ in range(k):
        # enlarge the window by increamenting one (character, pos_of_haracter) from right
        heapq.heappush(h, (s[end_index], end_index))
        end_index += 1
        # get the min from s[start_index : end_index] by using heappop (O(logN)) 
        while True:
            val, ind = heapq.heappop(h)
            if ind > start_index: break
        # save the min, shorten the window
        res.append(val)
        start_index = ind
    return ''.join(res)

def astring():
    T = int(raw_input())
    for t in range(T):
        s = raw_input()
        k = int(raw_input())
        print solve(s,k)

if __name__ == "__main__":
  astring()
# create atoms from the input
tc=int(raw_input())

for i in range(tc):
	n_m = (raw_input())
	n = int(n_m.split()[0])
	m = int(n_m.split()[1])
	#generate list of atoms
	atoms=[]
	for j in range(n):
		atoms.append(j)
	atomlist = ['']*n

	for k in range(m):
		s=[]
		s.extend(raw_input().split()[1:])	
		for w in range(n):
			if str(w) in s:
				atomlist[w]+="1"
			else:
				atomlist[w]+="0"

	print len(set(atomlist))


		

import sys
a =  int(raw_input())
while a>0:
    s=raw_input()
    i=l=c=0
    k=s.split("#")
    b=len(k)
    while i<b:
        j=k[i].count(".")
        if j>l:
            c+=1
            l=j
        i+=1
    print c
    a-=1

no_cases =int(raw_input())
for i in range(no_cases):
    m, p= raw_input().split(' ')
    m= int(m)
    p=float(p)
    a= (10**9)*(1-(-p)**m)/(1+p)
    b= (10**9)*(p+(-p)**m)/(1+p)
    print a,b
import sys

def main():
  n_books = 0
  min_q = []

  for (a, s) in actions():
    if a == -1:
      _, n, s = min_q.pop()
      print (n_books-n), s

      n_books = n-1
    elif a > 0:
      n_books += 1
      if (not min_q) or (a <= min_q[-1][0]):
        min_q.append((a, n_books, s))

def actions(cin = sys.stdin):
  n = int(cin.next())
  for _ in xrange(n):
    ss = cin.next()
    if ss[0] == '-':
      yield (-1, "")
    else:
      ss = ss.split()
      yield (int(ss[0]), ss[1])

if __name__ == "__main__": sys.exit(main())


k=int(raw_input())
def powerfn(n,power):
	value=1
	while power>0 :
		
		if not power%2==0:
			value=value*n
			value=value%1000000009
		n=n*n
		n=n%1000000009
		power=power/2
	return value
def inversemod(n):
	return powerfn(n,1000000007)
factorial=[1]
for i in range(1,1048577):
	factor=(i*factorial[i-1])%1000000009
	factorial.append(factor)
def combination(n,r):
	if n<r:
		return 0
	else:
		return (factorial[n]*((inversemod(factorial[r])*inversemod(factorial[n-r]))%1000000009))%1000000009
n=powerfn(2,k)
strength=n/2
for i in range(1,n+1):
	print (((combination(i-1,strength-1)*((factorial[strength]*factorial[strength])%1000000009))%1000000009)*2)%1000000009
output = list()
prime = list()
val = raw_input()
t = int(val)
for i in range(t) :
	nums = list()
	counter = 0
	string1 = raw_input()
	nums = string1.split()
	a1 = int(nums[0])
	b1 = int(nums[1])
	if a1>b1 :
		a = a1
		b = b1
	else :
		a = b1
		b = a1	
	c = a
	d = b
	lev1 = 0
	lev2 = 0
	while c > 0:
		c = c/2
		lev1 = lev1 + 1
	while d > 0:
		d = d/2
		lev2 = lev2 + 1
	diff = lev1 - lev2
	while diff > 0 :
		a = a/2
		diff = diff - 1
		counter = counter + 1
	while True :
		if a == b :
			break
		a = a/2
		b = b/2
		counter = counter + 2
	output.append(counter)
for i in range(t) :
	print output[i]
    # cook your code here
import math
t = int(raw_input())
while(t):
	n,k = raw_input().split()
        n = int(n)
        k = int(k)
        mod1  = 1000000007
        ans = 0
        ans = (pow(k-1,n-1,mod1)*k)%mod1
        print ans
        t = t-1 
	
def foo(a,b):
    x=a
    y=b
    while y!=0:
        r=x%y
        x=y
        y=r
        
    return ( a/x, b/x )
 
 
em={0:(0,0),1:(1,1),2:(2,1)}
 
piss=2
tc=input()
for xyz in xrange(tc):
    number=input()
    mass=max(piss,number)
    if(mass==piss):
        c,d=em[number]
        if d==1:
            print c
        else:
            print "%d/%d" %(c,d)
    else:
        for i in xrange(piss,number):
            m,n=em[i]
            o,p=em[i-1]
            em[i+1]=foo(n*p*((i+1)**2-3*i)+2*(i)*m*p-n*o,(2*i-1)*n*p)
        piss=number
       # print em
        c,d=em[piss]
        if d==1:
            print c
        else:
            print "%d/%d" %(c,d)
output = list()
val = raw_input()
t = int(val)
for i in range(t) :
	nums = list()
	fault = 0
	indi = list()
	val2 = raw_input()
	players = int(val2)
	string1 = raw_input()
	nums = string1.split()
	for j in range(players) :
		nums[j] = int(nums[j])
	if nums[0] != nums [1] :
		fault+=1
	for j in range(1,(players-1)) :
		if nums[j] != nums[j+1] or nums[j] != nums[j-1] :
			fault += 1
	if nums[-1] != nums[-2] :
		fault += 1
	output.append(fault)
for i in range(t) :
	print output[i]
#include <iostream>
#include <algorithm>
#include <string.h>
using namespace std;

int main()
{
    long int t,n,x,i,ramt,sum;
	cin>>t;
	while(t--)
	{
	    sum=0;
	    cin>>n>>x;
	    long int a[n];
	    for(i=0;i<n;i++)
	    {
	        cin>>a[i];
	        sum+=a[i];
	    }
	    ramt=sum%x;
	    sort(a,a+n);
	    for(i=0;i<n;i++)
	    {
	        if(a[i]<=ramt)
	        break;
	    }
	    if(i<n)
	    cout<<"-1\n";
	    else
	    cout<<sum/x<<endl;
	}
    return 0;
}


#include <cstdio>
 
#define MOD 1000000007
 
struct mat{
	int vals[3][3];
	mat(){
		for(int i=0; i<3; i++)
		for(int j=0; j<3; j++)
			vals[i][j]=i==j;
	}
};
 
mat operator*(const mat &lhs, const mat &rhs){
	mat res;
	for(int i=0; i<3; i++)
	for(int j=0; j<3; j++){
		long long sum=0;
		for(int k=0; k<3; k++)
			sum+=(long long)lhs.vals[i][k]*rhs.vals[k][j];
		res.vals[i][j]=sum%MOD;
	}
	return res;
}
 
mat pow(const mat &base, int exp){
	mat res;
	mat sq(base);
	for(; exp; exp>>=1){
		if(exp&1)
			res=res*sq;
		sq=sq*sq;
	}
	return res;
}
 
int m[3][3]={
	1, 4, 2,
	1, 0, 0,
	0, 1, 0,
};
 
int solve(int N){
	mat base;
	for(int i=0; i<3; i++)
	for(int j=0; j<3; j++)
		base.vals[i][j]=m[i][j];
	return pow(base, N).vals[0][0];
}
 
int main(){
	int T;
	scanf("%d", &T);
	while(T--){
		int N;
		scanf("%d", &N);
		printf("%d\n", solve(N));
	}
	return 0;
} 
t = int(raw_input())
for ii in range(t):
    n , m = raw_input().split()
    n=int(n)
    m=int(m)
    if n<m:
        n,m = m,n
    if n==1 or m==1:
        print n*(n-1)
        continue
    print (n*m) * (n*m-1) - 4*( (n-1)*(m-2) + (n-2)*(m-1))
    
        
    

a=int(raw_input())
ans=[]
for i in range(0,a):
    q=0
    b=int(raw_input())
    c=raw_input()
    if b==2 and c[0]=='?':
        if c.find('0')>0 and c.find('1')>0:
            if c.find('1') < c.find('0') and c.find('1')%2==0:
                c='1'+c[1:]
            elif c.find('1') > c.find('0') and c.find('0')%2==1:
                c='1'+c[1:]
        elif c.find('1') < 0 and c.find('0') > 0 and c.find('0')%2==1:
            c='1'+c[1:]
        elif c.find('0') < 0 and c.find('1') > 0 and c.find('1')%2==0:
            c='1'+c[1:]
    if len(c)==1 and c[0]!='?':
        ans.append(c)
    elif c[0]==c[-1] and c[0]!='?' and len(c)>1:
        q=1
        ans.append("NO")
    else:
        for j in range(0,len(c)):
            q=0
            if c[j]=='?':
                for k in range(0,b+1):
                    if j+1<len(c):
                        if str(k)!=c[j-1] and str(k)!=c[j+1]:
                            c=c[:j]+str(k)+c[j+1:]
                            break
                    else:
                        if str(k)!=c[j-1] and str(k)!=c[0]:
                            c=c[:j]+str(k)+c[j+1:]
                            break
                if k==b:
                    q=1
                    ans.append("NO")
                    break
            else:
                if j+1<len(c):
                    if c[j]==c[j-1] or c[j]==c[j+1]:
                        q=1
                        ans.append("NO")
                        break
                else:
                    if c[j]==c[j-1] or c[j]==c[0]:
                        q=1
                        ans.append("NO")
                        break
                    
        if q==0:
            ans.append(c)

for i in ans:
    print(i)

for _ in xrange(input()):
    r,c = map(int,raw_input().split())
    a = [list(raw_input()) for _ in range(r)]
    tot = 0
    for i in range(r):
        for j in range(c):
            if a[i][j] != '^':
                continue
            L = 0
            for k in range(i-1,-1,-1):
                if a[k][j] == '#':
                    break
                L += 1
            R = 0
            for k in range(i+1,r,1):
                if a[k][j] == '#':
                    break
                R += 1
            T = 0
            for k in range(j-1,-1,-1):
                if a[i][k] == '#':
                    break
                T += 1
            B = 0
            for k in range(j+1,c,1):
                if a[i][k] == '#':
                    break
                B += 1
            fi = min(L,T,B,R)
            if fi >= 2:
                tot += 1
    print(tot)
            

t=input()
while(t>0):
	t-=1
	n=input()
	arr=map(int,raw_input().split())
	arr=sorted(arr)
	index=0;time=1
	while(index<n-1):
		if( arr[index]!=arr[index+1] ):
			time+=1
		index+=1
	print time
for _ in range(int(raw_input())):
    N = int(raw_input())
    L = [int(i) for i in raw_input().split()]
    cars = 1
    for i in range(len(L)-1):
        if L[i] > L[i+1]: cars+=1
        else: L[i+1] = L[i]
    print cars

T = int(raw_input())
n = []
a = []
m = []

for t in xrange(T):
	n.append(int(raw_input()))
	a.append(map(int, raw_input().split()))
	m.append(max(a[-1]))

M = max(m)
l = [False, False] + [True] * (M-1)

for i in xrange(2,M+1):
	if (l[i]):
		for j in range(2*i, M+1, i):
			l[j]=False

for t in xrange(T):
	x = 0
	for i in xrange(1, n[t]):
		if (a[t][i] < a[t][i-1]):
			x += a[t][i-1] - a[t][i]
			a[t][i] = a[t][i-1]
	y = 0
	for j in a[t]:
		y += ((2 - (j % 2)) % 2)
	for i in range(3,m[t]+1):
		temp = 0
		if (l[i]):
			for j in a[t]:
				temp += ((i - (j % i)) % i)
				if (temp > y):
					break
			y = min(y,temp)
			if (y == 0):
				break
	print x+y
string1 = raw_input()
t = int(string1)
for i in range(t) :
	memory = list()
	string3 = raw_input()
	n = int(string3)
	string2 = raw_input()
	nums1 = string2.split()
	for j in range(n):
		memory.append(int(nums1[j]))
	counter = memory[0]
	for j in range(1,n) :
		if memory[j]>memory[j-1] :
			counter = counter + memory[j] - memory[j-1]
	print counter

for n in range(int(raw_input())):
     i,j,m = map(int, raw_input().split())
     k = int(raw_input())
     print min(k-1,i) + min(k-1,j) + min(k-1,m) + 1
# your code goes here
t=input()
for i in range(t):
	b = raw_input().split()
	if(b[0]==b[2] and b[2]==b[4] and b[4]==b[0]):
		print 'YES'
	elif(b[0]==b[2] and b[2]==b[5] and b[5]==b[0]):
		print 'YES'	
	elif(b[0]==b[3] and b[3]==b[4] and b[4]==b[0]):
		print 'YES'	
	elif(b[0]==b[3] and b[3]==b[5] and b[5]==b[0]):
		print 'YES'	
	elif(b[1]==b[3] and b[3]==b[5] and b[5]==b[1]):
		print 'YES'
	elif(b[1]==b[3] and b[3]==b[4] and b[4]==b[1]):
		print 'YES'
	elif(b[1]==b[2] and b[2]==b[4] and b[4]==b[1]):
		print 'YES'
	elif(b[1]==b[2] and b[2]==b[5] and b[5]==b[1]):
		print 'YES'	
	else:
		print 'NO'

from math import*
# your code goes here
t=int(raw_input())
while t>0:
	t-=1
	n=int(raw_input())
	a=map(int,raw_input().split())
	a.sort(reverse=True)
	i=0
	maxi=a[i]
	while i<n:
		i=i+2
		if(i<n):
			maxi+=a[i]
	print maxi	
	

n, m, p = map(int, raw_input().split())
arr = [dict() for _ in xrange(n)]
for _ in xrange(p):
    i,j = map(int,raw_input().split())
    i -= 1
    j -= 1
    if j not in arr[i]:
        arr[i][j] = j+1
    else:
        arr[i][j] += 1
 
def chefbm(arr,i):
    for (e,_) in arr[i].iteritems():
        if e == m-1:
            continue
        if e+1 in arr[i]:
            c = arr[i][e+1]
        else:
            c = e+1
        if arr[i][e] > c:
            return -1
    y = arr[i][m-1] if m-1 in arr[i] else m-1
    x = arr[i][0] if 0 in arr[i] else 0
    return y-x
 
for i in xrange(n):
    print chefbm(arr,i) 
for t in xrange(int(raw_input())):
	x=0
	for c in xrange(int(raw_input())):
		n,m=map(int,raw_input().split())
		g=(m+n-2)%3
		x=x^g
	if x:
		print "MasterChef"
	else:
		print  "Football"
for t in range(int(raw_input())):
    y=list(raw_input())
    z=y
    add=count=0
    if y[0]=='+':
        count+=1
    else:
        add+=1
    z[0]='-'
    y[0]='+'
    for i in range(1,len(z)):
        if i%2!=0:
            if z[i]!='+':
                count+=1
        else:
            if z[i]!='-':
                count+=1
    for i in range(1,len(z)):
        if i%2!=0:
            if y[i]!='-':
                add+=1
        else:
            if y[i]!='+':
                add+=1
    print min(add,count)
for _ in range(input()):
    n = input()
    a = map(int,raw_input().split())
    a.insert(0,-1)
    b = [0]*(n+2)
    b.insert(0,-1)
    for i in range(1,n+1):
        b[a[i]]+=1
    m = b.index(max(b))
    ans = 0
    for i in range(1,n+1):
        if a[i] != m:
            ans+=1
    print(ans)
#include <iostream>
#include <bits/stdc++.h>
typedef long long int ll;
using namespace std;

int main()
{
	ll t;
	cin>>t;
	while(t--)
	{
		ll n,m;
		cin>>n>>m;
		ll sum =0;
		for(ll i=0;i<n;i++)
		{
			ll a;
			cin>>a;
			sum += a;
		} 
		if((sum+m)%n == 0) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
}
	
from math import sqrt
T = int(raw_input())
def computesumoffactors(n):
    sum = 0
    for i in range(1,int(sqrt(n))+1):
        if n % i: continue
        if (n/i) != i: sum+=(n/i+i)
        else: sum+=i
    return sum
while T:
    N = int(raw_input())
    print computesumoffactors(N)
    T-=1

T = int(raw_input())

for x in xrange(T):
	path = raw_input()

	node = 1 #the root node, which will later on represent the current node under consideration
	i = 0
	for ch in path:
		if ch == 'l':
			if i%2 == 0:
				node = node*2
			else:
				node = node*2 - 1

		elif ch == 'r':
			if (i%2 == 0):
				node = node*2 + 2
			else:
				node = node*2 + 1

		i += 1
		node = node % (1000000007)

	print node % (1000000007)
'''input
5
12 1
13 1
13 2
13 3
13 4
'''
 
#~~~~~~~~~~~~~~~~~~~~dwij28 == Abhinav Jha~~~~~~~~~~~~~~~~~~
 
from sys import stdin, stdout
from math import sqrt, floor, ceil, log
from collections import defaultdict, Counter
 
def read(): return stdin.readline().rstrip()
def write(x): stdout.write(str(x))
def endl(): write("\n")
 
chef, mod = [1, 2], 1000000007
while chef[-1] <= 1e9: chef.append(chef[-1] + chef[-2])
 
def solve(x, k, n):
	if k == 0: return int(x == 0)
	ans = 0
	for i in xrange(n, -1, -1):
		if (chef[i]*k < x):
			return ans
		if (chef[i] <= x):
			ans = (ans + solve(x - chef[i], k-1, i)) % mod
	return ans
 
for Q in xrange(int(read())):
	x, k = map(int, read().split())
	write(solve(x, k, 43))
	endl()
for _ in range(input()):
	n,m=map(int,raw_input().split())
	if n%2==0 and m%2==0: print 'Yes'
	elif (n%2==0 and m%2==1 and m!=1) or (m%2==0 and n%2==1 and n!=1): print 'Yes'
	elif n%2==1 and m%2==1 and n!=1 and m!=1: print 'No'
	elif (n==1 and m==2) or (m==1 and n==2): print 'Yes'
	else: print 'No'

for i in range(input()):
    x = input()
    a = map(int, raw_input().split())
    a.sort()
    if a[0]==1: print '-1'
    else: print sum(a[1:])+2
            
from math import *
t = long(raw_input())
while t:
    t-=1
    a = raw_input().split(' ')
    x = float(a[0])
    k = float(a[1])
    n = 2**(long(log(k,2))+1)
    l = k - 2**long(log(k,2))
    print '%.16f' %float((x/n)+(l*(x/(2**(long(log(k,2)))))))
arr=map(int,raw_input().split())
Mremain=arr[2]-arr[0]
Psocks=arr[1]
socks=0
while(Mremain>=Psocks):
	socks+=Mremain/Psocks
	Mremain=Mremain%Psocks
if(socks%2==0):
	print "Lucky Chef"
else:
	print "Unlucky Chef"
def is_subseq(x, y):
    i = 0
    for c in x:
        while i < len(y) and y[i] != c: i += 1
        if i == len(y): return False
        i += 1
    return True

for cas in xrange(input()):
    a = raw_input()
    n = len(a)
    print 'YES' if n > 1 and (is_subseq(a[:n/2], a[n/2:]) or is_subseq(a[(n+1)/2:], a[:(n+1)/2])) else 'NO'

n = input()
s = []
dic = {}
for i in range(n):
    a = map(int,raw_input().split())
    s.append(a)
    foo = str(a[0])+','+str(a[1])
    dic[foo] = 1
if n == 0:
    print '4'
elif n == 1:
    print '3'
elif n == 2:
    print '2'
else:
    ans = 2
    for i in range(n-1):
        for j in range(i+1,n):
            maxm = 2
            x1,x2,y1,y2 = s[i][0],s[i][1],s[j][0],s[j][1]
            cx = x1 - y2+y1
            cy = y1 + x1-x2
            dx = x2 + y2-y1
            dy = y2 + x1-x2
            c = str(cx)+','+str(cy)
            d = str(dx)+','+str(dy)
            if c in dic:
                maxm += 1
            if d in dic:
                maxm += 1
            ans = max(ans,maxm)
    print 4-ans

for _ in range(input()):
        n,k = map(int, raw_input().strip().split())
        a = map(int, raw_input().strip().split())
        b = map(int, raw_input().strip().split())

        print max([b[i]*(k/a[i]) for i in range(n)])
import sys
def nCr (n,k) :

	if k == 0 :
		return 1
	else :
		return ( n*(nCr(n-1,k-1))/k )

T = int(raw_input())

while T :
	
	T-=1
	
	n , k = map(int,sys.stdin.readline().split())
	if n < k :
		print "0"
	elif n == k :
		print "1"
	else :
		if k > n-k :
			k = n-k
		print nCr(n,k)
	
for t in xrange(int(raw_input())):
	n, k, m = map(int,raw_input().split())
	a = map(int,raw_input().split())
	b = map(int,raw_input().split())
	y = sorted(map(int,(raw_input()+" "+raw_input()).split()), reverse = True)
	x = []
	for i in xrange(n):
		x.append(a[i]-b[i])
	x = sorted(x, reverse = True)
	left = sum(x)
	i = 0
	j = 0
	lx = n
	ly = k + m
	while (i<lx and j<ly):
		if (x[i]>=y[j]):
			left -= y[j]
			i += 1
			j += 1
		else:
			j += 1
	print left
n=input()
arr=map(int,raw_input().split())
i=0;maxp=0;mapl=0
while(i<n):
	p=1;l=i
	while(i<n):
		if(arr[i]==0):
			break
		p=p*arr[i]
		i+=1
	if(p>maxp):
		maxp=p
		maxl=i-l
	elif(p==maxp  and maxl<i-l):
		maxl=i-l
	i+=1
print maxl
problem='https://www.codechef.com/problems/CHFANS'
__author__='Ravindra Singh'


def gcd(a,b):
    if a%b==0:
        return b
    else:
        return gcd(b,a%b)
T=int(raw_input())
for i in range(T):
    a,b=map(int,raw_input().split())
    if a>b:
        print abs(abs((a-b))//gcd(a,b))
    else:
        print abs(abs((a-b))//gcd(b,a))


def cmp(tup):
	return (tup[1], tup[0])



def get_decoder(text,freqseq):
	mymap = {}
	for ch in text:
		if ch.isalpha():
			if ch.lower() in mymap:
				mymap[ch.lower()] += 1
			else:
				mymap[ch.lower()] = 1

	v = []
	for k in mymap:
		v.append((k,mymap[k]))

	v = sorted(v,key=cmp)

	length = len(v)
	lastcut = freqseq[-length:]

	decoder = {}
	for i in range(length):
		decoder[v[i][0]] = lastcut[i]


	return decoder


t = input()
while t:
	freqseq = raw_input()
	text = raw_input()

	#decoder = {}
	decoder = get_decoder(text,freqseq)

	ans = list(text)
	for i in range(len(ans)):
		if ans[i].isalpha():
			if ans[i].isupper():
				ans[i] = decoder[ans[i].lower()].upper()
			else:
				ans[i] = decoder[ans[i]]

	ans = ''.join(ans)

	print ans

	t = t-1



t = input()
for j in range(t):
    n = input()
    maxEdge = []
    for i in range(n):
        m = input()
        x = []
        lis = list(map(int, raw_input().split()))
        for k in lis[::2]:
            x.append(k)
        maxEdge.append([max(x), i])
    maxEdge.sort(reverse=True)
    for k in range(n):
        maxEdge[k][0] = n-1-k;
    maxEdge.sort(key=lambda x:x[1])
    for k in maxEdge:
        print k[0],
    
    
    

def rect(x,y,k):
    if (x == 1 and y==1) or (x==1 and y ==2) or (x==2 and y==1):
        return 0
    elif x == 1 or y == 1 or k == 1:
        return k
    else:
        if k%2==0:
            return k/2
        else:
            return (k/2)+ 1


import sys


for i in range(int(sys.stdin.readline())):
    a = sys.stdin.readline()
    a = a.split()
    print rect(int(a[0]),int(a[1]),int(a[2]))


            
        
        

a,b=map(int,raw_input().split())
c=a-b;
if(c%10<9):
    c+=1
else:
    c-=1
print (str)(c)
for _ in xrange(input()):
        ds,dt,d = map(int, raw_input().strip().split())
        print max(0, d-(ds+dt), ds-(d+dt), dt-(d+ds))
def solution():
    N = int(raw_input().strip())
    ceil_number = []
    not_ceil_number = []
    len_ceil_number = 0
    len_not_ceil_number = 0
    for i in xrange(N):
        d_k_0_flag = False
        eight_digit  = 0
        five_digit = 0
        three_digit = 0
        arr = map(str, raw_input().strip().split(' '))
        num = arr[-1]
        for i in num:
            if i == '8':
                eight_digit += 1
            elif i == '5':
                five_digit += 1
            elif i == '3':
                three_digit += 1
            else:
                len_not_ceil_number += 1
                d_k_0_flag = True
                continue
        if d_k_0_flag:
            continue
        if eight_digit >= five_digit >= three_digit:
            len_ceil_number += 1
        else:
            len_not_ceil_number += 1

    print "%d"%(len_ceil_number)

solution()
NumOfTests = int(raw_input())

for test in range(NumOfTests):
    N, M = map(lambda s: int(s), raw_input().split())

    # n: min_distance, is_visited, num_of_paths
    D = {}
    # paths {vertex: [(neighb_vertex, length), ...], ...}
    P = {}
    for i in range(1, N+1):
        D[i]=[float("inf"), None, 0]
        P[i] = []
        
    D[1] = [0, None, 1]
    
    for m_th in range(M):
        A, B, C = map(lambda s: int(s), raw_input().split())
        
        P[A].append((B, C))
        P[B].append((A, C))

    ################
    while True:
        vertex = min(filter(lambda v: v[1][1]==None, D.items()), key=lambda x: x[1][0])
        vertex = vertex[0] 
        if vertex == N:
            break
        for nv in P[vertex]:
            if not D[nv[0]][1]:
                if D[vertex][0] + nv[1] < D[nv[0]][0]:
                    D[nv[0]][0] = D[vertex][0] + nv[1]
                    D[nv[0]][2] = D[vertex][2]
                elif D[vertex][0] + nv[1] == D[nv[0]][0]:
                    D[nv[0]][2] += D[vertex][2]
                
        D[vertex][1] = True
        
    print D[vertex][2]
values = []
 
def evalNode(k):
    #print "eval(", k, ")"
    if values[k]>=0:
        return values[k]
    if nodes[k][0]==0:
        print "Input node- should have been set."
    elif nodes[k][0]==2: # AND gate
        val = evalNode(nodes[k][1]-1) * evalNode(nodes[k][2]-1)
    else: # OR gate
        val = 1.0 - (1.0-evalNode(nodes[k][1]-1))*(1.0-evalNode(nodes[k][2]-1))
    values[k] = val
    return val
def evaluate(prob):
    global values
    #print "Evaluate", prob
    values = [-1.0]*len(nodes)
    for i in range(len(nodes)):
        if nodes[i][0]==0:
            values[i] = prob
    return evalNode(len(nodes)-1)
 
ntest = int(raw_input())
 
for test in range(ntest):
    xx = raw_input()
    n = int(raw_input())
    nodes = []
    for i in range(n):
        node = map(int, raw_input().split())
        nodes.append(node)
     
    if nodes[-1][0] ==0:
        print "0.50000"
        continue
     
    prLow = 0.0
    prHigh = 1.0
    eps = 1e-5
    while prHigh-prLow>eps or round(prHigh,5)>round(prLow,5):
        prMid = (prLow+prHigh)/2
        valueMid = evaluate(prMid)
        if valueMid>0.5:
            prHigh = prMid
        else:
            prLow = prMid
     
    print "%.5f" % ((prLow+prHigh)/2)

NT = int(raw_input())
MOD = 1000000007
while NT > 0:
    NT -= 1
    N = int(raw_input())
    ans = 1
    if N%2 == 0:
	k = N/2
	ans = 3*pow(2,k,MOD) - 2
    else:
	k = (N+1)/2
	ans = pow(2,k+1,MOD) - 2
    ans = (ans+MOD)%MOD;
    print ans
 

for i in range(int(raw_input())):
    a,b=map(int,raw_input().split())
    d=map(int,raw_input().split())
    o=[]
    for i in range(1,a+1):
        if i not in d:
            o.append(i)
    print ' '.join(map(str,o[0::2]))
    print ' '.join(map(str,o[1::2]))

from heapq import *
import itertools

pq = []                         # list of entries arranged in a heap
entry_finder = {}               # mapping of tasks to entries
REMOVED = '<removed-task>'      # placeholder for a removed task
counter = itertools.count()     # unique sequence count


def init():
    global pq
    global entry_finder
    pq = []
    entry_finder = {}


def add_task(task, priority=0):
    'Add a new task or update the priority of an existing task'
    if task in entry_finder:
        remove_task(task)
    count = next(counter)
    entry = [priority, count, task]
    entry_finder[task] = entry
    heappush(pq, entry)


def remove_task(task):
    'Mark an existing task as REMOVED.  Raise KeyError if not found.'
    entry = entry_finder.pop(task)
    entry[-1] = REMOVED


def pop_task():
    'Remove and return the lowest priority task. Raise KeyError if empty.'
    while pq:
        priority, count, task = heappop(pq)
        if task is not REMOVED:
            del entry_finder[task]
            return task
    raise KeyError('pop from an empty priority queue')


def next_pos(cust, s, orders):
    for i in xrange(s, len(orders)):
        o = orders[i]
        if cust == o:
            return len(orders) - i - 1
    return -1


def solve(N, orders):
    init()
    free = N
    customer_table = set()
    clean_count = 0
    s = 0

    for i, o in enumerate(orders):
        if not free:
            s = i
            break

        if o not in customer_table:
            customer_table.add(o)
            clean_count += 1
            free -= 1
            #add_task(o, priority=next_pos(o, i + 1, orders))
            #heappush(farthest, (next_pos(o, i + 1, orders), o))
        add_task(o, priority=next_pos(o, i + 1, orders))

    for i in xrange(s, len(orders)):
        o = orders[i]
        #print pq, customer_table, o
        if o not in customer_table:
            # d, f = heappop(farthest)
            f = pop_task()
            customer_table.remove(f)
            customer_table.add(o)
            # add_task(o, priority=next_pos(o, i + 1, orders))
            # heappush(farthest, (next_pos(o, i + 1, orders), o))
            clean_count += 1
        add_task(o, priority=next_pos(o, i + 1, orders))

    return clean_count


assert solve(1, [1]) == 1
assert solve(1, [1, 1]) == 1
assert solve(2, [1, 1]) == 1
assert solve(2, [1, 2]) == 2
assert solve(1, [1, 1, 2, 2]) == 2
assert solve(1, [1, 1, 1, 1]) == 1
assert solve(2, [1, 1, 1, 1]) == 1
assert solve(2, [1, 1, 2, 1]) == 2
assert solve(4, [1, 2, 3, 4]) == 4
assert solve(1, [1, 2, 1, 2]) == 4
assert solve(4, [1, 2, 1, 3, 1]) == 3
assert solve(4, [1, 2, 1, 3, 1, 1, 1]) == 3
assert solve(1, range(100)) == 100
assert solve(4, [1, 2, 3, 4, 5, 1, 1]) == 5
assert solve(4, [1, 2, 3, 4, 5, 1, 1, 1, 1]) == 5
assert solve(2, [1, 2, 3, 2, 3, 1, 1, 1, 1]) == 4
assert solve(1, [1]) == 1
assert solve(2, [1, 1, 1]) == 1
assert solve(4, [1, 2, 3, 4, 1, 2, 3, 4]) == 4
assert solve(3, [1, 2, 3, 4, 5, 1, 1, 1]) == 5
assert solve(2, [1, 2, 2, 1, 2, 2, 1, 1]) == 2


for _ in xrange(int(raw_input())):
    N, M = map(int, raw_input().split())
    orders = map(int, raw_input().split())
    print solve(N, orders)

import math
fib=[]
fib.append(0)
fib.append(1)
for i in range(2,1000001):
    fib.append((fib[i-1]+fib[i-2])%1000000007)
t=int(input())
for i in range(t):
    n,k=map(int,raw_input().split())
    #n+=1
    #phi=(1+(5**0.5))/2
    #nphi=(1-(5**0.5))/2
    #fib=int(((phi**n)-(nphi**n))/(5**0.5))
    #fib=fib%1000000007
    #x=list(bin(fib))
    #print fib[n+1]
    counter=str(bin(fib[n+1])).count('1')
    #for j in x:
     #   if(j=='1'):
      #      counter+=1
    if(counter==k):
        print "CORRECT"
    else:
        print "INCORRECT"
test = input()
while test:
    test = ~(-test)
    n,k = map(int,raw_input().split())
    arr = ['0']*n
    for i in range(n):
        if i&1:
            arr[i] = ')'
        else:
            arr[i] = '('
    while k:
        k = ~(-k)
        l,r = map(int,raw_input().split())
        change = 0
        for i in range(l,r+1):
            if change:
                arr[i] = ')'
                change = 0
            else:
                arr[i] = '('
                change = 1
    print ''.join(arr)

for _ in xrange(input()):
    n, k = map(int, raw_input().split())
    if k != 0:
        A = map(int, raw_input().split())
    else:
        A = []
    A.sort()
    ans = 1
    i = 1
    j = 0
    l = 0
    while i < n + 1:
        if j < k and i == A[j]:
            j += 1
            i += 1
        else:
            if ans < i:
                break
            if j < k:
                nx = A[j] - 1
            else:
                nx = n
            ans += ((nx * (nx + 1))/2) - ((i * (i + 1))/2)
            ans += i
            i = nx + 1
    if ans % 2 == 0:
        print "Mom"
    else:
        print "Chef"

t=int(raw_input())
for q in xrange(0,t):
    x,y,k,n=map(int,raw_input().split())
    
    ans= "UnluckyChef"
    
    for i in xrange(n):
        p,c=map(int,raw_input().split())
        if k>=c:
            if (x-y)<=p:
                ans= "LuckyChef"
    print ans

i, k, s = map(int, raw_input().strip().split())
a, b = map(int, raw_input().strip().split())

from math import sqrt
sqrt2 = sqrt(2)
sqrt6 = sqrt(6)
if (i ^ k) & 1:
    i += 1
    a, b = (
        sqrt2 * (a + b) - sqrt6 * (a - b),
        sqrt2 * (a - b) + sqrt6 * (a + b),
    )

ans = (a + b) * pow(0.5, s + 2*(i - k))
print "%.11lf" % ans
t = int(raw_input())
for _ in range(t):
    n, m, k = map(int, raw_input().split())
    a = map(int, raw_input().split())
    b = []  # gain
    for _ in range(n):
        b.append(map(int, raw_input().split()))
    c = []  # loss
    for _ in range(n):
        c.append(map(int, raw_input().split()))
        
    init_cost = [0]*n
    for i in range(n):
        init_cost[i] = b[i][a[i] -1]
    
    max_gain = [0]*n
    for i in range(n):
        mp = 0 # max profit
        for j in range(m):
            np = b[i][j] - c[i][j]
            mp = max(mp, np)
        # calc gain with respect to init cost
        max_gain[i] =  mp - init_cost[i]
        
    max_gain.sort()
    max_gain.reverse()
    print sum(init_cost) + sum(max_gain[:k])

#-*- coding:utf-8 -*-

import sys


# class Point:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y

#     def mul(self, k):
#         return Point(k * self.x, k * self.y)

#     def __add__(self, other):
#         return Point(self.x + other.x, self.y + other.y)

#     def __sub__(self, other):
#         return self + (-other)

#     def __neg__(self):
#         return Point(-self.x, -self.y)

#     def __eq__(self, other):
#         return self.x == other.x and self.y == other.y

#     def __getitem__(self, index):
#         return (self.x, self.y)[index]

#     def __str__(self):
#         return "(%d;%d)" % (self.x, self.y)


DIRS = dict(
    U=(0, 1),
    D=(0, -1),
    R=(1, 0),
    L=(-1, 0)
)
KOEF = 0.2


def div(a, b):
    return round(float(a) / b, 1)


# class Moving:
#     def __init__(self, x, y, dir):
#         self.p = Point(x, y)
#         self.dir = Point(*DIRS[dir.upper()])

#     def collide(self, other):
#         times = []
#         for coord in range(2):
#             d = abs(self.p[coord] - other.p[coord])
#             d2 = abs((self.p + self.dir.mul(KOEF) - other.p)[coord])
#             d3 = abs((other.p + other.dir.mul(KOEF) - self.p)[coord])
#             d_next = abs((self.p + self.dir.mul(KOEF) - (other.p + other.dir.mul(KOEF)))[coord])
#             if d2 > d or d3 > d:
#                 return None

#             speed = abs(d_next - d)
#             if speed == 0:
#                 if self.p[coord] != other.p[coord]:
#                     return None
#                 continue
#             times.append( div(d, speed / KOEF) )

#         if len(times) == 2 and times[0] != times[1]:
#             return
#         return times[0]


def collide_coord(ex, edx, x, dx):
    d = abs(ex - x)
    d2 = abs(ex + edx - x)
    d3 = abs(ex - x - dx)
    if d2 > d or d3 > d:
        return False

    d_next = abs(ex + edx * KOEF - x - dx * KOEF)
    speed = abs(d_next - d)
    if speed == 0:
        if ex != x:
            return
        return "all"  # all
    else:
        return div(d, speed / KOEF)


def main():
    t = int(raw_input())
    for _ in range(t):
        ex, ey, dir = sys.stdin.readline().strip().split()
        ex = int(ex)
        ey = int(ey)
        edx, edy = DIRS[dir]

        n = int(sys.stdin.readline())
        min_time = float("+inf")
        for _ in range(n):
            x, y, dir = sys.stdin.readline().strip().split()
            x = int(x)
            y = int(y)
            dx, dy = DIRS[dir]

            tx = collide_coord(ex, edx, x, dx)
            if tx is False:
                continue
            ty = collide_coord(ey, edy, y, dy)
            if ty is False:
                continue

            if tx == "all":
                min_time = min(min_time, ty)
            elif ty == "all":
                min_time = min(min_time, tx)
            elif tx == ty:
                min_time = min(min_time, tx)

        print min_time if min_time < 1000000 else "SAFE"


if __name__ == '__main__':
    main()

p=input()
while(p>0):
	p-=1
	n=input()
	x=[0]*n;l=[0]*n;f=[0]*n;t=[0]*n
	i=0
	while(i<n):
		x[i],l[i],f[i]=map(int,raw_input().split())
		i+=1
	t[0]=x[0]+l[0]
	i=1
	while(i<n):
		if( t[i-1]>x[i] ):
			if((t[i-1]-x[i])%f[i]==0):
				t[i]=l[i]+t[i-1]
			else:
				t[i]=f[i]-(t[i-1]-x[i])%f[i] + l[i]+t[i-1]
		if( t[i-1]<=x[i] ):
			t[i]=x[i]-t[i-1]+l[i]+t[i-1]
		i+=1
	#$print t
	print t[n-1]

t = int(raw_input().strip())
for _ in range(t):
    count = 0
    length = -1
    l = list(raw_input().strip())
    for i in range(len(l)):
        if l[i] == "<": count += 1
        else: count -= 1
        if count == 0: length = i
        elif count < 0: break
    print length + 1
for _ in range(int(raw_input())):
    for oo in range(int(raw_input())):
        i, j, k = map(int, raw_input().split())
        if j%2 ==0 or i == k:
            print j / 2
        else:
            print j/2 +1
from fractions import gcd
from sys import stdin


def p(n):
    s = int(n ** .5)
    c = sum(n/i for i in xrange(1, s+1)) * 2 - s**2
    g = gcd(c, n ** 2)
    return '{}/{}'.format(c / g, n**2 / g)


print(
    '\n'.join(
        p(int(ln))
        for i, ln in enumerate(stdin) if i
    )
)
#include <bits/stdc++.h>

#define test int t; scanf("%d",&t);while(t--)

typedef long long ll;
using namespace std;

int MOD=1e8+7;

int prod(int a,int b){
	ll aa=a,bb=b;
	return (aa*bb)%MOD;
}
int sum(int a,int b){
	ll aa=a,bb=b;
	return (aa+bb)%MOD;
}
int power(int x,ll n){
	if(n==0)return 1;

	int temp=power(x,n/2);

	if(n%2==0)return prod(temp,temp);
	return prod(temp,prod(temp,x));
}
int inv=power(2,MOD-2);
int main(){
	test{
		ll n; cin >> n;

		int ans1=0,ans2=0;
		ans1=sum(power(3,n),1);
		ans1=(ans1-power(2,n+1)+MOD)%MOD;
		ans1=prod(ans1,inv);

		ans2=sum(power(4,n),sum(power(2,n),power(2,n+1)));
		ans2=(ans2-1+MOD)%MOD;
		ans2=(ans2-power(3,n+1)+MOD)%MOD;
		ans2=prod(ans2,inv);

		cout << ans1 << " " << ans2 << "\n";
	}
}

p=1000003

'''

calculating modulo inverse of 'a' using Euclid's Extended Lemma
'''

def invert_mod(a):
	n=1
	old=0
	q=p
	r=0
	h=0

	pos=0

	while a>0:
		r=q%a
		q=q/a
		h=q*n+old
		old=n
		n=h
		q=a
		a=r
		if pos==0:
			pos=1
		else:
			pos=0

	if(pos):
		return old
	else:
		return p-old

'''
Calculating C(n,k)--- No of ways of selecting k from n things
'''

def cal(n,k):
	if(n<k):
		return 0
	elif(n==k):
		return 1
	elif(n==0):
		return 0

	num=1

	for i in xrange(0,k):
		num=(num*(n-i))%p

	denom=1

	for i in xrange(1,k+1):
		denom=(denom*i)%p

	return (num*invert_mod(denom))%p


t=input()

for test in xrange(t):
	
	n,l,r=map(int,raw_input().split())
	
	d=r-l+1	
	# d stands for number of numbers to be considered for selection

	a=[0,0]
	b=[0,0]
	
	y=n+d

	j=0
	s=0

	while y!=0:
		a[j]=y%p
		y=y/p
		j=j+1
	
	k=0

	if n>=d:
		y=d
		while y!=0:
			b[k]=y%p
			y=y/p
			k=k+1
		s=cal(a[0],b[0])

		if(s!=0):
			s=(s*cal(a[1],b[1]))%p
	else :
		y=n
                while y!=0:
                        b[k]=y%p
                        y=y/p
                        k=k+1
                s=cal(a[0],b[0])

                if(s!=0):
                        s=(s*cal(a[1],b[1]))%p

	s=(s-1+p)%p

	print s

			

t=raw_input()

t=int(t)
while t>0:
    cnt=0
    sm=0
    s=raw_input()
    st=raw_input()
    cnt=st.count('1')
    temp=0
    temp=(cnt*(cnt-1))/2
    sm=cnt+temp
    print sm
    t=t-1
    

from heapq import *
from math import * 

#young => max heap (by using -ve)
#old => min heap (by default)

young_team = []
young_score = 0

older_team = []
older_score = 0

counter = 1 
temp = []

a = int(raw_input())
for c in range(a):
    k = raw_input().split(" ")
    age = int(k[0])
    rate = int(k[1])
    
    new_entry = [age,rate]

    if counter > 2 : 
        if len(young_team) == len(older_team):
            if older_team[0][0] < age : 
                current = heappop(older_team)
                older_score = older_score - current[1]
                
                current[0] = current[0] * -1
                heappush(young_team,current)
                young_score = young_score + current[1]

                heappush(older_team,new_entry)
                older_score = older_score + rate
                #print '=', young_team, older_team

            else :
                new_entry[0] = new_entry[0]* -1  ## added -ve value
                heappush(young_team,new_entry)
                young_score = young_score + rate
                #print '==', young_team, older_team

        elif len(young_team) > len(older_team) : 
            if ((young_team[0][0]*-1) > age) :
                current = heappop(young_team)
                young_score = young_score - current[1]
                current[0] = current[0] * -1 ##again maken +ve

                heappush(older_team,current)
                older_score = older_score + current[1]

                new_entry[0] = new_entry[0] * -1 ## added -ve 
                heappush(young_team,new_entry)
                young_score = young_score + rate 
                #print '===', young_team, older_team

            else :
                heappush(older_team,new_entry)
                older_score = older_score + rate
                #print '====', young_team, older_team

        print abs(older_score-young_score)

    else : 
        if counter == 1 :
            temp.append(new_entry)
            print new_entry[1]
        else :
            temp.append(new_entry)
            temp.sort()
            print abs(temp[0][1]-temp[1][1])
            temp_add_by_neagting = temp[0]
            temp_add_by_neagting[0] = temp_add_by_neagting[0] * -1 # add by -ve so it will become max heap 
            heappush(young_team ,temp_add_by_neagting)
            young_score = young_score + temp_add_by_neagting[1]
            heappush(older_team ,temp[1])
            older_score = older_score + temp[1][1]

    counter  = counter + 1

def removeTop(i,j,k):
    return a[i-1][j][k] if i else 0
def removeBack(i,j,k):
    return (a[i][j-1][k] - removeTop(i,j-1,k)) if j else 0
def removeSide(i,j,k):
    return (a[i][j][k-1] - removeBack(i,j,k-1) - removeTop(i,j,k-1)) if k else 0
t = int(raw_input())
while t:
    (i,j,k) = map(int, raw_input().split())
    a = []
    for x in range(i):
        d2 = []
        for y in range(j):
            d2.append(map(int, raw_input().split()))
        a.append(d2)
    for x in range(i):
        for y in range(j):
            print ' '.join(str(a[x][y][z] - (removeTop(x,y,z) + removeBack(x,y,z) + removeSide(x,y,z))) for z in range(k))
    t-=1
text = raw_input()
result = ''
l = text.split()
n = int(l[0])
m = int(l[1])
dicn = {}
dicch = {}
dicco = {}
for i in range(n):
	t = raw_input()
	l = t.split()
	dicn[l[0]] = l[1]
	dicch[l[0]] = 0;
	dicco[l[1]] = 0;
for i in range(m):
	t = raw_input()
	nt = dicch[t]
	dicch[t] = nt+1
	nt = dicco[dicn[t]]
	dicco[dicn[t]] = nt + 1
 
outch = 'ZZZZZZZZZZZ'
outco = 'ZZZZZZZZZZZ'
maxch = 0
maxco = 0
for e in dicch:
	if maxch < dicch[e]:
		outch = e
		maxch = dicch[e]
	if maxch == dicch[e] and outch > e:
		outch = e
		maxch = dicch[e]
 
for e in dicco:
	if maxco < dicco[e]:
		outco = e
		maxco = dicco[e]
	if maxco == dicco[e] and outco > e:
		outco = e
		maxco = dicco[e]
 
print outco
print outch
mapa = None

T = int(raw_input())

valid = lambda x,y : x>=0 and x<101 and y>=0 and y<101

for tt in xrange(T):
    mapa = [ [False for i in xrange(101)] for j in xrange(101) ]

    numPoints = int(raw_input())
    points = []
    
    for i in xrange(numPoints):
        (x,y) = map( lambda a: int(a)+50 ,raw_input().split())
        points.append((x,y))
        mapa[x][y]=True

        points.sort()

    count = 0
    for i in xrange(numPoints):
        for j in xrange(i+1,numPoints):
            dx = points[j][0] - points[i][0]
            dy = points[j][1] - points[i][1]
            x3 = points[j][0] - dy
            y3 = points[j][1] + dx
            if valid(x3,y3):
                x4 = points[i][0] - dy
                y4 = points[i][1] + dx
                if valid(x4,y4):
                    if (mapa[points[i][0]][points[i][1]] and
                        mapa[x3][y3] and mapa[x4][y4]) :
                        count+=1
                            
    print count/2
        
                                         

def permute(count,per):
	num=1;din=1
	while(per>0):
		num*=count
		din*=per
		per-=1
		count-=1
	return num/din

x,n=map(int,raw_input().split())
poss=0
while(n>0):
	count=map(int,list(raw_input()))
	s=[0]*55;s[1:]=count
	#print s
	n-=1
	i=1;j=54
	while(i<34):
		while(j>27):
			'''print "i-j"
			print ("%d %d ")%(i,j)'''
			count=[0]*2
			count[s[i]]+=1
			count[s[i+1]]+=1
			count[s[i+2]]+=1
			count[s[i+3]]+=1
			count[s[j]]+=1
			count[s[j-1]]+=1
			'''print 
			print s[i]
			print s[i+1]
			print s[i+2]
			print s[i+3]
			print s[j]
			print s[j-1]
			print'''
			break
		i+=4
		j-=2
		if(count[0]>=x):
			poss+=permute(count[0],x)
		#print "poss"
		#print poss
print poss
import bisect
import time
import sys
A = []
subarray = {}
keys = []
subarray_low = {}
subarray_high = {}
subarray_length = 0
# (val,start,pos) stack
# (start,end,pos) dict

def preprocess(n):
	global keys
	global A
	global subarray
	global subarray_low
	global subarray_high
	global subarray_length

	for i in A:
		subarray[i] = 0
	stack = []
	for i in range(n):
		if i == 0:
			stack.append((A[0],0,0))
		else:
			top = stack[-1]
			if A[i] <= top[0]:
				stack.append((A[i],i,i))
			else:
				while len(stack) > 0 and A[i] > stack[-1][0]:
					top = stack[-1]
					stack.pop()
					subarray[top[0]] += (i-top[2]) * (top[2]-top[1]+1)
				stack.append((A[i],top[1],i))
	end = n-1

	length = len(stack)
	i = 0
	while i<length:
		top = stack[-1]
		stack.pop()
		subarray[top[0]] += (end-top[2]+1)*(top[2]-top[1]+1)
		i += 1

	keys = sorted(subarray.keys())

	t = 0
	for i in keys:
		t += subarray[i]
		subarray_low[i] = t

	t = 0
	for i in reversed(keys):
		t += subarray[i]
		subarray_high[i] = t

	subarray_length = len(subarray)


def play(symbol,number,starter):
	global keys
	global A
	global subarray
	global subarray_low
	global subarray_high
	global subarray_length

	ans = 0
	if symbol == '<':
		k = bisect.bisect_left(keys,number)
		if k:
			ans = subarray_low[keys[k-1]]
	elif symbol == '=':
		if number in subarray:
			ans = subarray[number]
	else:
		k = bisect.bisect_right(keys,number)
		if k<subarray_length:
			ans = subarray_high[keys[k]]

	if ans%2 == 0:
		if starter == 'C':
			return 'D'
		else:
			return 'C'
	else:
		return starter



if __name__ == '__main__':
	n, m = map(int,sys.stdin.readline().split())
	A = map(int,sys.stdin.readline().split())
	preprocess(n)
	s = ''
	for j in range(m):
		C, K, X = sys.stdin.readline().split()
		K = int(K)
		s = s+play(C,K,X)
	print(s)


import sys
a =  int(raw_input())
def yo(x):
    s="a"
    i=1
    while i<=x:
        s=chr(97+i)+s
        i+=1
    return s
while a>0:
    b =  int(raw_input())
    if (b<=25):
        print yo(b)
    elif (b<=50 and b>25):
        y=yo(b-25)+yo(25)
        print y
    elif (b<=75 and b>50):
        w=yo(b-50)+yo(25)+yo(25)
        print w
    else:
        u=yo(b-75)+yo(25)+yo(25)+yo(25)
        print u
    a-=1
        


# Property 1:
#j and k cannot have gap
#because if have gap > 0, one side will eat it up

# hence for each middle position j or k
# calculate the min/max values for each section, one to the left
# and one to the right of j/k
# then calculate the largest absolute difference between each
# pair of left/right sections


import sys


T = int(sys.stdin.readline().strip())

for z in range(T):
	N = int(sys.stdin.readline().strip())
	numbers = []
	leftMins = []
	leftMaxs = []
	rightMins = []
	rightMaxs = []
	max_delish = 0
	lines = sys.stdin.readline().strip()
	for n in lines.split(" "):
		numbers.append(int(n))
		leftMins.append(10000001)
		leftMaxs.append(-10000001)
		rightMins.append(10000001)
		rightMaxs.append(-10000001)

	leftMins[0] = numbers[0] 
	leftMaxs[0] = numbers[0]

	rightMins[len(numbers)-1] = numbers[len(numbers)-1] 
	rightMaxs[len(numbers)-1] = numbers[len(numbers)-1]


	# for left sides
	for j in range(1,N-1):
		# for minimums
		if leftMins[j-1] >= 0:
			leftMins[j] = numbers[j]
		else:
			leftMins[j] = leftMins[j-1] + numbers[j]

		# for maximums
		if leftMaxs[j-1] <= 0:
			leftMaxs[j] = numbers[j]
		else:
			leftMaxs[j] = leftMaxs[j-1] + numbers[j]

	# for right sides
	for z in range(1,N-1):
		j = N - 1 - z
		# for minimums
		if rightMins[j+1] >= 0:
			rightMins[j] = numbers[j]
		else:
			rightMins[j] = rightMins[j+1] + numbers[j]


		# for maximums
		if rightMaxs[j+1] <= 0:
			rightMaxs[j] = numbers[j]
		else:
			rightMaxs[j] = rightMaxs[j+1] + numbers[j]
		
	max_delish = 0
	for j in range(N-1):
		k = j+1
		delish = max(rightMaxs[k] - leftMins[j], leftMaxs[j] - rightMins[k])
		if delish > max_delish:
			max_delish = delish
	print max_delish

# Author : Avikalp Srivastava

T = int(raw_input(''))
while T > 0:
	T -= 1
	N = int(raw_input(''))
	A_str = raw_input('')
	A = [x for x in A_str.split()]
	if len(A) == 1:
		print '1'
		continue
	A.sort()
	y = 2
	x = len(A)-1
	mid = 1 + ((x-1) / y)
	median = A[mid]
	count = 0
	for item in A:
		if item == median:
			count += 1
	if count >= (len(A)/2 + 1):
		print count
	else:
		if len(A)%2 == 0:
			print len(A)/2
		else:
			print (len(A)/2 + 1)
	del A[:]
t=int(input())
for i in xrange(t):
    typ=int(input())
    s=list(raw_input())
    if(abs(s.count('B')-s.count('G'))>1):
        print -1
        continue
    if('B' not in s and 'G' not in s):
        print -1
        continue
    m=-1
    ans=0
    temp=0
    li=[]
    li2=[]
    temp_li=[]
    temp_li2=[]
    if(s.count('B')>s.count('G')):
        m=1
    elif(s.count('B')<s.count('G')):
        m=0
    else:
        m=-1
    for j in xrange(0,len(s),2):
        if(m==1):
            if(s[j]=='B'):
                continue
            else:
                li.append(j)
        elif(m==0):
            if(s[j]=='G'):
                continue
            else:
                li.append(j)
        else:
            if(s[j]==s[0]):
                temp_li.append(j)
            else:
                li.append(j)
    if(m==-1):
        if not temp_li:
            print 0
            continue
        if not li:
            print 0
            continue
    if not li:
        print 0
        continue
    for j in xrange(1,len(s),2):
        if(m==1):
            if(s[j]=='B'):
                li2.append(j)
            else:
                continue
        elif(m==0):
            if(s[j]=='G'):
                li2.append(j)
            else:
                continue
        else:
            if(s[j]==s[0]):
                li2.append(j)
            else:
                temp_li2.append(j)
    if(typ==0):
        typ=0
    else:
        typ=1
    for j in xrange(0,len(li)):
        ans+=(abs(li[j]-li2[j]))**(typ)
    if(m==-1):
        for k in xrange(0,len(temp_li)):
            temp+=(abs(temp_li[k]-temp_li2[k]))**(typ)
    if(m==-1):
        print min(temp,ans)
        continue
    print ans
    continue  
for t in xrange(int(raw_input())):
	n, m = map(int, raw_input().split())
	r, c = n, m
	row = []
	col = []
	
	for i in xrange(m):
		col.append("")
	for i in xrange(n):
		s = raw_input()
		row.append(s)
		for j in xrange(m):
			col[j] += s[j]
			
	for i in range(n):
		if (row[i].count(".") == m):
			r -= 1
		else:
			break
	for i in range(n-1,n-r-1,-1):
		if (row[i].count(".") == m):
			r -= 1
		else:
			break
	for i in range(m):
		if (col[i].count(".") == n):
			c -= 1
		else:
			break
	for i in range(m-1,m-c-1,-1):
		if (col[i].count(".") == n):
			c -= 1
		else:
			break
	if (r+c):
		print max(r,c)/2+1
	else:
		print 0
def r():
	return map(int,raw_input().split())
def process(stack):
	if len(stack)<k+1:
		ans.extend(stack)
		return
	# print stack,
	# global count
	if len(stack)%(k+1)==0:
		# print "as"
		for i in range(k,len(stack)-1,k+1):
			stack[i]=(stack[i]+1)%2
		stack[-2]=(stack[-2]+1)%2
	else:
		for i in range(k,len(stack),k+1):
			# print i
			stack[i]=(stack[i]+1)%2
	# count+=((len(stack)+k)/(k+1))
	# print stack
	ans.extend(stack)
for i in range(input()):
	n,k = r()
	arr = map(int,list(raw_input()))
	if k==1:
		s=[]
		c=0
		for i in range(n):
			s.append((c+1)%2)
			c+=1
		s1=[]
		c=1
		for i in range(n):
			s1.append((c+1)%2)
			c+=1
		ans1,ans2=0,0
		for i in range(n):
			if arr[i]!=s1[i]:
				ans2+=1
			if arr[i]!=s[i]:
				ans1+=1
		s1=map(str,s1)
		s=map(str,s)
		if ans1<ans2:
			print ans1
			print ''.join(s)
		else:
			print ans2
			print ''.join(s1)
	else:
		# print japasas
		ans=[]
		c=1
		count=0
		stack=[arr[0]]
		for i in range(1,n):
			if arr[i]==arr[i-1]:
				stack.append(arr[i])
			else:
				process(stack)
				stack=[arr[i]]
		# ans.extend(stack)
		process(stack)
		count=0
		for i in range(n):
			if ans[i]!=arr[i]:
				count+=1
		print count
		ans=map(str,ans)
		print ''.join(ans)

"""http://www.codechef.com/problems/
Shortest path algorithm [x]
Dynamic programming
"""

import sys
from collections import deque

inf = int(pow(2,63) - 1)

def digdump(digits):
    digits = convert(digits)
    dtable = [inf,] * 10
    dist = [inf,] * len(digits)
    dist[0] = 0
    dtable[digits[0]] = 0
    for i in xrange(1, len(digits)):
        d = digits[i]
        prev_cost = dist[i-1]
        if prev_cost < dtable[d]:
            dist[i] = prev_cost + 1
            if d == digits[i-1]:
                dtable[d] = prev_cost
            else:
                dtable[d] = prev_cost + 1
        else:
            dist[i] = dtable[d] + 1
        # print dist[i], dtable[d]
        # fix prev cost by step back
        if prev_cost > dist[i] + 1:
            dist[i-1] = dist[i] + 1
            if dist[i-1] < dtable[digits[i-1]]:
                dtable[digits[i-1]] = dist[i-1] 
            #print 'back', i, dist[i-1], d, prev_cost
    # print dist, dtable
    return dist[-1]

 
def convert(line):
    return [int(i) for i in line]
 

def debug_dtab(group):
    for i, v in enumerate(group):
        print len(v)


def digjump_bfs(digits):
    visited_digits.clear()
    visited = set()
    parent = [None,] * len(digits)
    queue = deque()
    tab = build_group(digits)
    #debug_dtab(tab)
    queue.append(0)
    visited.add(0)
    while queue:
        node = queue.pop()
        # print 'node', node
        for child in gen_children(digits, tab, node, parent):
            if child not in visited:
                visited.add(child)
                # print 'c', child
                parent[child] = node
                queue.appendleft(child)
    # Trace back
    n = len(digits) - 1
    count = 0
    while n != 0:
        n = parent[n]
        count += 1
    return count

visited_digits = set()

def gen_children(digits, tab, i, parent):
    if i > 0:
        yield i - 1
    if i < len(digits) - 1:
        yield i + 1
    d = digits[i]
    if d not in visited_digits:
        visited_digits.add(d)
    else:
        return
    # if parent[i] is not None and digits[parent[i]] == digits[i]:
    #     return
    for j in tab[d]:
        if j not in (i, i-1, i+1):
            yield j


def build_group(digits):
    tab = []
    for i in range(10):
        tab.append(set())
    for i, d in enumerate(digits):
        tab[d].add(i)
    return tab


def test():
    # test_func = digdump
    test_func = digjump_bfs
    print test_func(convert('0'))
    print test_func(convert('101'))
    # print test_func(convert('0121344444434443'))
    # print test_func(convert('01234567890'))
    # print test_func(convert('0123410193837418926571657382471036517356173084'))
    print test_func(convert('0998887776665554443322223300885577'))
    print test_func(convert('099887730085577'))
#    '''
    import random
    digits = []
    for i in xrange(pow(10, 6)):
        digits.append(random.randint(0, 9))
    print 'starting..'
    print test_func(digits)
#    '''

def main():
    line = raw_input().strip()
    print digjump_bfs(convert(line))
 
 
main()
#test()

t=input()
while(t>0):
	t-=1
	n=input()
	a=[0]*n;c=[0]*n;i=0
	while(i<n):
		b=raw_input().split()
		a[i]=b[0];c[i]=b[2:]
		i+=1
	print "Begin on",
	for j in c[n-1]:
		print j,
	print
	i=n-2
	while(i>=0):
		if(a[i+1]=='Left'):
			print "Right on",
			for j in c[i]:
				print j,
			print
		elif(a[i+1]=='Right'):
			print "Left on",
			for j in c[i]:
				print j,
			print			
		i-=1
output = list()
val = raw_input()
t = int(val)
for i in range(t) :
	string1 = raw_input()
	dstring = list()
	for j in range(len(string1)) :
		if string1[j] not in dstring :
			dstring.append(string1[j])
	output.append(len(dstring))
for i in range(t) :
	print output[i]
#!/usr/bin/env python

import sys

parent = None
#child = dict()

def find_set(x):
    global parent
    while parent[x] != x:
        parent[x] = parent[parent[x]]
        x = parent[x]
    return parent[x]

if __name__=='__main__':
    t = int(sys.stdin.readline())

    while t > 0:
        t -= 1
        n = int(sys.stdin.readline())
        si = map(int, sys.stdin.readline().strip().split())
        parent = range(n)

        q = int(sys.stdin.readline())
        while q > 0:
            q -= 1
            d = map(int, sys.stdin.readline().strip().split())
            k = len(d)
            if k == 3:
                l, m = find_set(d[1]-1), find_set(d[2]-1)
                if l == m:
                    print "Invalid query!"
                elif si[l] > si[m]:
                    parent[m] = l
                elif si[l] < si[m]:
                    parent[l] = m
            else:
                print find_set(d[1]-1) + 1

for t in xrange(int(raw_input())):
	n=int(raw_input())
	inp=raw_input()
	inp=list(inp)
	arr=[]
	#print inp[0]
	for i in xrange(n):
		temp=list(inp)
		ch=temp[i]
		temp.pop(i)
		for j in xrange(n-1):
			if ord(temp[j]) > ord(ch):
				temp.insert(j,ch)
				temp=''.join(temp)
				arr.append(temp)
				break
		temp=list(inp)
		temp.insert(n,ch)
		temp.pop(i)
		temp=''.join(temp)
		arr.append(temp)
	print min(arr)

n = int(raw_input())
stamp = map(int, raw_input().split())
if sum(stamp[:]) == n*(n+1)/2:
	print 'YES'
else:
	print 'NO'
T = input()
while T:
    T-=1
    N,M = [int(x) for x in raw_input().split()]
    A = [int(x) for x in raw_input().split()]
    A = sorted(A,reverse = False)
    Reqd = M-1
    k = 0
    Total = 0
    while True:
        if A[k] + 1 < Reqd:
            Reqd -= (A[k] + 1)
            Total += A[k]
        elif A[k] + 1 == Reqd or A[k] == Reqd:
            Reqd = 0
            Total += A[k]
            break
        else:
            Total += Reqd
            break
        k+=1
    print Total

t=input()
while(t>0):
	n,a,b=map(int,raw_input().strip().split())
	a1=list(format(a,'0'+str(n)+'b'))
	b1=list(format(b,'0'+str(n)+'b'))
	a1.sort()
	b1.sort(reverse=True)
	c=[]
	for i in xrange(len(a1)):
		if a1[i]!=b1[i]:res='1'
		else:res='0'
		c.append(res)
	c.sort(reverse=True)	
	final=''.join(c)	
	max_num=int(final,2)
	print max_num
	t-=1
n, k = map(int, raw_input().split())
times = map(int, raw_input().split())
times = sorted(zip(times, xrange(len(times))), key=lambda x: x[0])

cnt, i = 0, 0
while(i < n):
  j = i+1
  while(j < n and times[i][0] == times[j][0] and times[j][1] - times[i][1] < k):
   j += 1
  cnt += 1
  i = j
print cnt

def solution():
	T = raw_input('')
	answers = []
	for i in range(0,int(T)):
		N,M = map(int,raw_input('').split(' '))
		power_of_soints = {}
		power_of_sofloats = {}
		for i in range(0,N):
			power, level = map(int,raw_input('').split(' '))
			if level not in power_of_soints.keys():
				power_of_soints[level] = power
			else:
				power_of_soints[level] += power
		for i in range(0,M):
			power,level = map(int,raw_input('').split(' '))
			if level not in power_of_sofloats.keys():
				power_of_sofloats[level] = power
			else:
				power_of_sofloats[level] += power
		if sum(power_of_soints.values()) == 0:
			sochef += 1
		sochef = sochef_extra(power_of_soints,power_of_sofloats)
		answers.append(sochef)
	for i in answers:
		print "%d"%(i)

def sochef_extra(dict1,dict2):
	sochef = 0
	for i in dict1.keys():
		if dict1[i] < dict2[i]:
			sochef += dict2[i] - dict1[i]
	return sochef
solution()
import fractions
t = input()
for i in range(t):
    l = map(long, raw_input().split())
    a,b,c,d,k = l[0],l[1],l[2],l[3],l[4]
    gcd1 = fractions.gcd(a,b)
    gcd2 = fractions.gcd(c,d)
    lcm = (gcd1*gcd2)/fractions.gcd(gcd1,gcd2)
    ans = 2*(k/lcm)+1
    print ans

137=2(2(2)+2+2(0))+2(2+2(0))+2(0)
1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
73=2(2(2)+2)+2(2+2(0))+2(0)
136=2(2(2)+2+2(0))+2(2+2(0))
255=2(2(2)+2+2(0))+2(2(2)+2)+2(2(2)+2(0))+2(2(2))+2(2+2(0))+2(2)+2+2(0)
1384=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2)+2(2(2)+2(0))+2(2+2(0))
16385=2(2(2+2(0))+2(2)+2)+2(0)
import math
t=int(raw_input())
for i in range(t):
    n,k=map(int,raw_input().split())
    x=list(map(int,raw_input().split()))
    counter,rem=0,0
    for j in range(n):
        if(rem>0):
                rem-=1
        if x[j]<=rem:
            rem-=x[j]
        elif x[j]>rem:
            temp=counter
            counter+=int(math.ceil((x[j]-rem)/float(k)))
            #print ((x[j]-rem)/k)
            rem=((counter-temp)*k)-(x[j]-rem)
    print counter
import fractions
t = input()
for i in xrange(t):
    l = map(int,raw_input().split())
    n = l[0]
    change = l[1]
    gcd = fractions.gcd(n,change)
    if n/gcd == n:
        print "Yes"
    else :
        print "No "+str(n/gcd) 
    
    

# your code goes here
# your code goes here
import math
A=[]
t=int(raw_input())
for u in range(0,t):
	size=int(raw_input())
	A=map(int,raw_input().split())
	idli=[0]*(size+1)
	count=0
	for k in A:
		idli[k]+=1
		count =count+k
	if(count%size!=0):
		print("-1")
	else:
		i=0
		j=size
		count=0
		while i<j:
			while idli[i]==0:
				i += 1
			while idli[j]==0:
				j -= 1
			if(i==j):
				break
			r=int(math.ceil((j-i)/2))
		#	r=(j-i)/2 + (j-i)%2
		
			idli[j] -= 1
			idli[i] -= 1
			idli[j-r] += 1
			idli[i+r] += 1
			count += 1
		print(count)
		
			
			

T=int(raw_input())
ans=[]
for i in range(T):
    N=int(raw_input())
    perm=[]
    raw_ans=raw_input()
    raw_ans=raw_ans.split(' ')
    for j in range(N):
        perm.append(int(raw_ans[j]))
    perm=[int(j) for j in perm]
    temp_ans=[]

    sum_X=sum(perm)/(N-1)
    for i in range(N):
        temp_ans.append(sum_X-perm[i])
    ans.append(temp_ans)
for k in ans:
    for l in k:
        print l,
    print		

#include <bits/stdc++.h>
#define ll long long int
#define ld long double
using namespace std;
#include<stdio.h>

int main()

{

    int i,j,k,s[35],a[35],t,n,flag,p,temp,m,count;

    s[4]=4; s[6]=5; s[8]=12; s[9]=6; s[10]=7; s[12]=16; s[14]=9; s[15]=8; s[16]=32;

    s[18]=21; s[20]=24; s[21]=10; s[22]=13; s[24]=44; s[25]=10; s[26]=15; s[27]=27; s[28]=32;

    s[30]=31;

    s[2]=s[3]=s[5]=s[7]=s[11]=s[13]=s[17]=s[19]=s[23]=s[29]=0;

    scanf("%d",&t);

    while(t--)

    {


       scanf("%d",&n);

       count=0;

       flag=0;

       scanf("%d",&a[0]);

       for(i=1;i<n;++i)

       {

          scanf("%d",&a[i]);

          if(a[i]!=a[i-1]) flag=1;

       }

       flag=1;

       if(flag==0)

       {

         printf("0\n");

       }

       else

       {

           if(s[n]==0)

           {

              printf("%d\n",1);

              printf("%d ",n);

              for(i=1;i<=n;++i)

              {

                printf("%d ",i);

              }

              printf("\n");

           }

           else

           {

               printf("%d\n",s[n]);

               k=n;

               for(p=29;p>=2;p--)

               {

                   if(s[p]==0 && k%p==0)

                   {

                             temp=p;

                             k=k/p;

                             break;

                   }

               }

               for(i=0;i<k;++i)

               {

                  printf("%d ",p);

                  for(j=i*p;j<(i+1)*p;++j)

                  {

                      printf("%d ",j+1);


                  }

                  printf("\n");

               }

               for(i=p;i>=2;--i)

               {

                  if(s[i]==0 && k%i==0  && k>1)

                  {


                     for(j=1;j<=30;++j) a[j]=0;

                     for(j=1;j<=n;++j)

                     {

                        if(a[j]==0)

                        {

                           printf("%d ",i);

                           for(m=0;m<i;++m)

                           {

                              printf("%d ",j+m*temp);

                              a[j+m*temp]=1;


                           }

                           printf("\n");

                        }

                     }

                     temp=temp*i;

                     k=k/i;

                     ++i;


                  }

               }

           }

       }


    }
return 0;
}

def sol(n):
    if n>=0:
        return ((n+3)*(n+2)*(n+1))/6
    else:
        return 0


for _ in range(input()):
    n,a,b,c= map(int,raw_input().split())
    print  sol(n)-sol(n-a-1)-sol(n-b-1)-sol(n-c-1)+sol(n-a-b-2)+sol(n-b-c-2)+sol(n-a-c-2)-sol(n-a-b-c-3)
t=int(raw_input())
for i in range(t):
    s=raw_input()
    a='010'
    b='101'
    x=s.find(a)
    y=s.find(b)
    if x!=-1 or y!=-1:
        print 'Good'
    else:print 'Bad'
        

T=input()
for i in xrange(T):
    data=raw_input().split(' ')
    N=int(data[0])
    K=int(data[1])
    r=K
    m=0
    nm=r
    for j in xrange(1,N-1):
        if j==N-2:
           r=(m*K+nm*(K-1))%1000000007
        else:
            m=nm
            r=(r*K)%1000000007
            nm=r-m
    print(r)
class unionFind:
	def __init__(self, noOfClasses):
		self.sets = [[-1, 1, 1] for i in range(noOfClasses)]
		self.parentIndex 			= 0
		self.rankIndex 				= 1
		self.classElement			= 2
		self.noOfClasses 			= noOfClasses
		self.noOfElements			= noOfClasses

	def find(self, element):
		if self.sets[element][self.parentIndex] == -1:
			return element
		self.sets[element][self.parentIndex] = self.find(self.sets[element][self.parentIndex])
		return self.sets[element][self.parentIndex]

	def union(self, element1, element2):
		parent1 = self.find(element1)
		parent2 = self.find(element2)

		if parent1 != parent2:
			if self.sets[parent1][self.rankIndex] < self.sets[parent2][self.rankIndex]:
				self.sets[parent1][self.parentIndex] = parent2
				self.sets[parent2][self.classElement] += self.sets[parent1][self.classElement]
			elif self.sets[parent1][self.rankIndex] > self.sets[parent2][self.rankIndex]:
				self.sets[parent2][self.parentIndex] = parent1
				self.sets[parent1][self.classElement] += self.sets[parent2][self.classElement]
			else:
				self.sets[parent1][self.parentIndex] = parent2
				self.sets[parent2][self.rankIndex] += 1
				self.sets[parent2][self.classElement] += self.sets[parent1][self.classElement]

			self.noOfClasses -= 1

	def getNoOfClasses(self):
		return self.noOfClasses

	def getClassElements(self):
		elements = list()
		for i in range(self.noOfElements):
			if self.sets[i][self.parentIndex] == -1:
				elements.append(self.sets[i][self.classElement])
		return elements

if __name__ == '__main__':
	import sys
	test_cases = int(sys.stdin.readline())
	mod = 1000000007
	while test_cases > 0:
		test_cases -= 1
		noOfEmp, noOfRel = map(int, sys.stdin.readline().split())
		uf = unionFind(noOfEmp)
		for i in range(noOfRel):
			frnd1, frnd2 = map(int, sys.stdin.readline().split())
			uf.union(frnd1 - 1, frnd2 - 1)
		noOfClasses = uf.getNoOfClasses()
		elements = uf.getClassElements()
		ways = 1
		for i in elements:
			ways = (ways * i) % mod
		print noOfClasses, ways

from sys import stdin,stdout
n,w,l = map(int,stdin.readline().split(' '))
h = []
r = []
for i in xrange(n):
	a,b = map(int,stdin.readline().strip().split(' '))
	h.append(a)
	r.append(b)
tl = 0
th = 10000000000000000000
while tl <= th:
	cut = 0
	tm = (th+tl)/2
	for i in xrange(n):
		if (h[i] + r[i]*tm) >= l:
			cut += (h[i] + r[i]*tm)
		if cut > w:
			break
	if cut < w:
		tl = tm+1
	elif cut > w:
		th = tm-1
	else:
		break
cut = 0
for i in xrange(n):
		if (h[i] + r[i]*tm) >= l:
			cut += (h[i] + r[i]*tm)
if cut < w:
	tm += 1
stdout.write(str(tm))
# Chef changed the password of his laptop a few days ago, but he can't remember it today. Luckily, he wrote the encrypted password on a piece of paper, along with the rules for decryption.
# The encrypted password is a string S consists of ASCII printable characters except space (ASCII 33 - 126, in decimal notation, the same below). Read here for more details: ASCII printable characters.
# Each rule contains a pair of characters ci, pi, denoting that every character ci appears in the encrypted password should be replaced with pi. Notice that it is not allowed to do multiple replacements on a single position, see example case 1 for clarification.
# After all the character replacements, the string is guaranteed to be a decimal number. The shortest notation of this number is the real password. To get the shortest notation, we should delete all the unnecessary leading and trailing zeros. If the number contains only non-zero decimal part, the integral part should be omitted (the shortest notation of "0.5" is ".5"). If the number contains zero decimal part, the decimal point should be omitted as well (the shortest notation of "5.00" is "5").
# Please help Chef to find the real password.

# Input
# The first line of the input contains an interger T denoting the number of test cases.
# The description of T test cases follows.
# The first line of each test case contains a single interger N, denoting the number of rules.
# Each of the next N lines contains two space-separated characters ci and pi,
# denoting a rule.
# The next line contains a string S, denoting the encrypted password.

# Output
# For each test case, output a single line containing the real password.

# Constraints
#     1 <= T <= 1000
#     0 <= N <= 94
#     All characters in S and ci may be any ASCII printable character except space. (ASCII 33 - 126)
#     All ci in a single test case are distinct.
#     pi is a digit ("0" - "9") or a decimal point "." (ASCII 46).
#     The total length of S in a single input file will not exceed 106.

# Example

# Input:
# 4
# 2
# 5 3
# 3 1
# 5
# 0
# 01800.00
# 0
# 0.00100
# 3
# x 0
# d 3
# # .
# 0xd21#dd098x

# Output:
# 3
# 1800
# .001
# 321.33098

#Status - Successful

import sys

T=input()
S_list=[]

for testcases in xrange(T):

	N=input()
	#cp_list=[]
	ci_list=""
	pi_list=""

	for rules in xrange(N):

		ci,pi=sys.stdin.readline().split()
		#cp_list.append([ci,pi])
		ci_list+=ci
		pi_list+=pi

	S=raw_input()

	if N!=0: # If N == 0, saves len(S) loops

		S=list(S) # To use assignment operator
		for index in xrange(0,len(S)):

			#char=S[index]
			index2=ci_list.find(S[index])
			if index2 != -1: # Find first ci corresponding to char in S
				S[index]=pi_list[index2]
		S="".join(S) # Convert S back to string

	if S.count('.')==0: # In case there is a number without decimal point. We don't want to rstrip it!
		S=S.lstrip('0')
	else:
		S=S.strip('0')
		S=S.rstrip('.')
	if S=="": S="0"
	S_list.append(S)
print '\n'.join(S_list)
def f(x):
    return x[1]
n, k, p= map(int, raw_input().split())
a = map(int, raw_input().split())
l = [] #index, position, max_dist
for i in range(n):
    l.append([i, a[i], 0])
l = sorted(l, key = f, reverse = True)
#print l
l[0][2] = l[0][1] + k
for i in range(1,n):
    if (l[i-1][1] - l[i][1] <= k):
        l[i][2] = l[i-1][2]
    else:
        l[i][2] = l[i][1] + k
#print l
l = sorted(l)
#print l
for _ in range(p):
    x,y = map(int, raw_input().split())
    if (l[x-1][2] == l[y-1][2]):
        print "Yes"
    else:
        print "No"

global FACT
FACT=[]
FACT.append(1)
for i in range(1,1001):
	FACT.append(i*FACT[i-1])

def nCr(n,r):
	if n<r:
		return 0
	else: 
		return (FACT[n]/FACT[n-r]/FACT[r])
		
t=input()
for _ in range(0,t):
	s,n,m,k=map(int,raw_input().split(' '))
	ans=0
	if k==0:
		print "1.000000"
	elif s==n:
		print "1.000000"
	elif k>=n:
		print "0.000000"
	else:
		if m>n:
			p=n
		else:
			p=m
		for j in range(k,m):
			a=nCr(m-1,j)
			b=nCr(s-m,n-j-1)
			ans+=(a*b)
		print"%.8f"%(ans/float(nCr(s-1,n-1)))

MAXINT = 1000000
 
from sys import stdin
 
N, M = map(int, stdin.readline().split())
AdjList = [[] for i in xrange(N)]
 
for i in xrange(M):
	A, B = map(int, stdin.readline().split())
	AdjList[A-1].append(B-1)
	AdjList[B-1].append(A-1)
 
C = [int(stdin.readline()) for i in xrange(N)]
 
Visited = [0 for i in xrange(N)]
start = 0
CCs = []
 
while True:
	for i in xrange(start, N):
		if not(Visited[i]):
			start = i+1
			break
	else:
		break #No more unvisited planets
	MinPosC = MAXINT
	Buffer = [i]
	Visited[i] = 1
	
	while Buffer:
		i = Buffer.pop()
		if 0 <= C[i] < MinPosC:
			MinPosC = C[i]
		for j in AdjList[i]:
			if not(Visited[j]):
				Buffer.append(j)
				Visited[j] = 1
	CCs.append(MinPosC)
 
CCsmin, CCsmax = min(CCs), max(CCs)
 
if len(CCs) == 1:
	print 0
elif CCsmax == MAXINT:
	print -1
else:
	print sum(CCs) + (len(CCs)-2)*min(CCs)
t = int(raw_input())

def grundy(a,b):
    if a==b:
        return 0
    if b>a:
        a,b = b,a
    if a%b == 0:
        return a/b - 1
    g = grundy(a%b, b)
    if g>=(a/b):
        return (a/b)-1
    else:
        return (a/b)


for i in range(t):
    n = int(raw_input())
    res = 0
    for i in range(n):
        a,b = map(int, (raw_input().split()))
        res ^= grundy(a,b)
    if res:
        print "YES"
    else:
        print "NO"
def iterF(arr,n,m,iter1):
	#print "fyuv"
	i=iter1;j=iter1;count=0
	while(i<n):
		j=iter1
		while(j<m):
			#print "i,j,iter",i,j,iter1
			if(arr[i][j]==arr[i][j-iter1] and arr[i][j]==arr[i-iter1][j]\
				and arr[i-iter1][j-iter1]==arr[i][j] ):
				#print "i,j,iter",i,j,iter1,"trure re"
				count+=1
			j+=1
		i+=1
	return count

t=input()
while(t>0):
	t-=1
	n,m=map(int,raw_input().split())
	arr=[[] for i in range(n)]
	#print arr
	i=0
	while(i<n):
		arr[i][:]=list(raw_input())
		i+=1
	iter1=min(n,m)
	i=1;count=0
	while(i<n):
		count+=iterF(arr,n,m,i)
		i+=1
	print count
from fractions import gcd
for i in xrange(input()):
    a,b=map(int,raw_input().split())
    print gcd(a,b)

t=input()
while t:
    t-=1
    n=input()
    l=[0]*(n+1)
    r=[0]*(n+1)
    for i in range(n):
        l[i],r[i]=map(int,raw_input().split())
    i=0
    count=0
    ans=""
    while i<(n-1):
        if l[i+1]>=r[i]:
            ans=ans+"L+"*(r[i]-l[i]-1)+"R+L+"*(l[i+1]-r[i]+1)+"R+"*(r[i+1]-l[i+1]-1)
        elif r[i+1]>=r[i] and l[i+1]>=l[i]:
            ans=ans+"L+"*(l[i+1]-l[i])+"R+"*(r[i+1]-r[i])
        elif r[i+1]>=r[i] and l[i+1]<=l[i]:
            ans=ans+"L-"*(l[i]-l[i+1]) +"R+"*(r[i+1]-r[i])
        elif r[i+1]>=l[i] and l[i+1]>=l[i]:
            ans=ans+"L+"*(l[i+1]-l[i])+"R-"*(r[i]-r[i+1])
        elif r[i+1]>=l[i] and l[i+1]<=l[i]:
            ans=ans+"L-"*(l[i]-l[i+1]) +"R-"*(r[i]-r[i+1])
        else:
            ans=ans+"L-"*(l[i]-l[i+1])+"R-"*(r[i]-r[i+1])
        i+=1
    print len(ans)/2
    print ans
                          
                          
                                                                    
                                                            
            

t=input()
while t!=0:
    t=t-1
    gf=map(int,raw_input().split(":"))
    chef=map(int,raw_input().split(":"))
    dist=input()
    t1=(gf[0]-chef[0])*60+gf[1]-chef[1]+dist
    t2=t1-dist
    t2=float(t2)
    dist=float(dist)
    if 2*dist>t2:
        t2=t2+(2*dist-t2)/2

    print float(t1),t2

mod = 1000000007
comb_cache = {}
def combinations(n, r):
   if r < (n // 2): r = n - r
   if (n, r) in comb_cache: return comb_cache[(n, r)]
   comb = 1
   for i in xrange(r + 1, n + 1): comb *= i
   for i in xrange(1, n - r + 1): comb /= i
   comb_cache[(n, r)] = comb % mod
   return comb

F_cache = {}
A0, A1, A2, A3 = (0, 0, 0, 0)
def F(N):
   if N not in F_cache: 
      F_cache[N] = (((A3 * N + A2) * N + A1) * N + A0) % mod
   return F_cache[N]
   
meal = {}
def cook(N, S):
   if S == 0: return 1
   if N == 0: return 0
   if (N, S) in meal: return meal[(N, S)]
   food = 0
   for rank in xrange(N, 0, -1):
      for count in xrange(S // rank, 0, -1):
         food = (food + combinations(F(rank) + count - 1, count) * cook(rank - 1, S - (rank * count))) % mod
   meal[(N, S)] = food
   return food
   
for _ in xrange(int(raw_input())):
   A0, A1, A2, A3 = map(int, raw_input().split())
   S = int(raw_input())
   F_cache = {}
   meal = {}
   print cook(S, S)
t=int(raw_input())
while t>0:
	s=raw_input().split(' ')
	s1=s[0]
	s2=s[1]
	d1={}
	d2={}
	flag1=1
	flag2=1
	for i in range(len(s1)):
		if d1.has_key(s1[i]):
			d1[s1[i]]=d1[s1[i]]+1
		else:
		   d1[s1[i]]=1
	for i in range(len(s2)):
		if d2.has_key(s2[i]):
			d2[s2[i]]=d2[s2[i]]+1
		else:
		   d2[s2[i]]=1
	if len(d1) == len(d2):
		for i in range(len(s2)):
				if d1.has_key(s2[i]):
					if d2[s2[i]]!=d1[s2[i]]:
						flag1=0 
						break

				else:
					flag1=0
					break
		for i in range(len(s2)):
			if s2[i] not in d1:
				flag2=0
				break
		if flag1==flag2:
			print "YES"
		else:
			print "NO"
				
			
	else:
		print "YES"

	t=t-1


	

import sys

def main():
    s = sys.stdin.readline
    n = int(s())
    if n>=135:
        print "Yes"
        return
    nums = map(int, s().split())
    for i in xrange(n):
        for j in xrange(i+1,n):
            for k in xrange(j+1,n):
                for l in xrange(k+1, n):
                    if nums[i]^nums[j]^nums[k]^nums[l]==0:
                        print "Yes"
                        return
    print "No"
    return

if __name__ == '__main__':
    main()

#!/usr/bin/python

T = int(raw_input())

def test():

	L1 = raw_input()
	L2 = raw_input()

	d1 = [ch == '#' for ch in L1]
	d2 = [ch == '#' for ch in L2]

	data = zip(d1, d2)
	possible = (True, True) not in data

	print 'Yes' if possible else 'No'

	if not possible:
		return

	# Filter out cells where both slots are open
	data = filter(lambda pair: pair != (False, False), data)

	count = 0
	if len(data):
		last = data[0]
		for cell in data:
			if cell != last:
				count += 1
				last = cell

	print count

for x in range(0, T):
	test()
for i in range(input()):
    n = input()
    arr = []
    dp = [[-2 for i in range(n)] for j in range(n)]
    for c in range(n):
        arr.append(list(raw_input()))
        for j in range(n - 1, -1, -1):
            if arr[c][j] == '.':
                dp[c][j] += 1
            else:
                break
    for i in range(n):
        for j in range(n - 1, -1, -1):
            if arr[j][i] == '.':
                dp[j][i] += 1
            else:
                break
    count = 0
    for i in range(n):
        for j in range(n):
            if dp[i][j] == 0:
                count += 1
    print count

from __future__ import division

def main():
    t=int(raw_input())
    for i in range(t):
        tokens = raw_input().split()
        default , talktime, addons  =  float(tokens[0]), int(tokens[1]), int(tokens[2])
        defaultCost = round(talktime * default,3)
        bestPlan = 0
        bestPlanVal = defaultCost;
        for plan in range(addons):
            tokens = raw_input().split()
            months, rate, cost  = int(tokens[0]), float(tokens[1]), int(tokens[2])
            planCost  = talktime * rate + cost/months
            planCost = round(planCost, 3)
            #print planCost, defaultCost
            if planCost < bestPlanVal :
                bestPlan = plan + 1;
                bestPlanVal = planCost;
        print bestPlan

main()

def f(ar):
	ax,ay,bx,by,cx,cy = ar
	area = abs(ax*(by-cy)+bx*(cy-ay)+cx*(ay-by))/2.0
	return area
	
mix=10000000000000
mii=0
max=0
mai=0
for i in range(int(raw_input())):
	a= f([int(x) for x in raw_input().split()])
	if a<=mix:
		mix=a
		mii=i+1
	if a>=max:
		max=a
		mai=i+1
print mii,mai 

def solve(n, horse):
    horse.sort()
    res = horse[1]-horse[0]
    for h in range(1,n-1):
        res = min(res, horse[h+1]-horse[h])
    return res

def horses():
    T = int(raw_input())
    for i in range(T):
        n = int(raw_input())
        horse = map(int, raw_input().split())
        print solve(n, horse)
 
if __name__ == '__main__':
    horses() 

a=[[0 for i in xrange(1001)] for y in range(1001)]

def row(i,j):
    for k in xrange(1001-j-1):
        a[i][k+j+1]=2

def col(i,j):
    for k in xrange(1001-i-1):
        a[k+i+1][j]=2

def diag(i,j):
    i=i+1
    j=j+1
    while(i<1001)and(j<1001):
        a[i][j]=2
        i=i+1
        j=j+1

def main():
	test=input()
	for i in xrange(1001):
		for j in xrange(1001):
			if(a[i][j]==0):
				a[i][j]=1
				row(i,j)
				col(i,j)
				diag(i,j)
	for t in xrange(test):
		m,n,p,q=map(int,raw_input().split())
		if(a[m-p][n-q]==1):
			print "Bob"
		else:
			print "Alice"
	return 0
	
if __name__ == '__main__':
	main()


def initialArray(matrix, n, letter):
    for i in xrange(0,n):
        for j in xrange(0,n):
            if matrix[i][j] == letter:
                yield (i,j)

def nextMove(matrix, n, pos, letter):
    for d in diagonals:
        nm = nextMove1(matrix, n, pos, letter, d)
        if nm != None: 
            yield nm

def nextMove1(matrix, n, pos, letter, delta):
    x,y = pos[0]+delta[0], pos[1]+delta[1]
    if 0 <= x < n and  0 <= y < n and letter == matrix[x][y]: 
        return (x,y)

def flatten(lst):
    for elem in lst:
        for i in elem:
            yield i

if __name__ == "__main__":
    n = int(raw_input())

    matrix = []
    diagonals = [(-1,-1),(1,-1),(-1,1),(1,1)]

    for i in xrange(0,n):
        matrix.append(raw_input().strip().split(' '))

    hladaj = raw_input().strip()
   
    l = []
    for i in xrange(0,len(hladaj)):
        if i==0:
            l = list(initialArray(matrix, n, hladaj[i]))
        else:
            l = list(flatten(nextMove(matrix, n, pos, hladaj[i]) for pos in l))

    print len(l)
n=int(raw_input())
x=list(map(int,raw_input().split()))
cost=int(raw_input())
neg=[abs(i) for i in x if i<0]
neg.sort()
total=len(neg)
ans=0
if total==0:
    print "0"
elif x==0:
    print "0"
elif total==1:
    print neg[0]
elif total<=cost:
    print sum(neg)
else:
    ans=neg[-1]*cost
    arr=[neg[0]]
    for i in range(1,total):
        arr.append(arr[i-1]+neg[i])
    for i in range(total):
        ans=min(ans,neg[i]*cost+arr[-1]-arr[i]-(neg[i]*(total-1-i)))
    print ans
t = input()
while(t>0):
	p,s =map(int, list(raw_input().split()))
	a = (p-pow(p*p-24*s,0.5))/12
	b = (p+pow(p*p-24*s,0.5))/12
	h = (p-8*a)/4
	h1 = (p-8*b)/4
	v= a*a*h
	v1 = b*b*h1
	if( v>v1 ):
		print("%.2f" % v)
	else:
		print("%.2f" % v1)
	t-=1
for i in range(input()):
	n = input()
	a= map(int,raw_input().split())
	c=a[input()-1]
	a=sorted(a)
	while(n>0):
		if(a[n-1]==c):
			print n
			break
		n-=1

import sys

def F(x):
	return (x-1)%9+1

T =int(sys.stdin.readline())

for t in range(T):
	inp =sys.stdin.readline().split()
	A, D, L, R = int(inp[0]), int(inp[1]), int(inp[2])-1, int(inp[3])-1
	sum_per9 =0;
	for i in range(1,10): sum_per9 +=F(A+D*i)
	ans =0
	while (R-L+1)%9 != 0:
		ans +=F(A+D*R)
		R -=1
	ans +=sum_per9*(R-L+1)//9
	sys.stdout.write(str(ans)+"\n")
t=input()
def function(l,i,j):
	if i>=j:
		return 0
		
	if l[j]-l[i]<=k:
		return 0

	if mat[i][j]!=-1:
		return mat[i][j]

	count1=l[i]
	count1+=function(l,i+1,j)

	count2=l[j]-l[i]-k
	count2+=function(l,i,j-1)
	mat[i][j]=min(count1,count2)
	return mat[i][j]
	#mat[i][j]=min(l[i]+mat[i+1][j],mat[i][j-1]+l[j]-l[i]-k)

def find_kgood(word,k):
	a={}
	for i in word:
		if i in a:
			a[i]+=1
		else:
			a[i]=1
	l=sorted([a[i] for i in a])
	res=function(l,0,len(l)-1)
	return res


while(t>0):
	word,k=raw_input().strip().split()
	mat=[[-1 for i in range(26)] for j in range(26)]
	#mat[0][0]=0
	#mat[]
	k=int(k)
	print find_kgood(word,k)
	t-=1



for _ in range(int(raw_input())):
    n=int(raw_input())
    arr=map(int,raw_input().split())
    num=min(arr)
    ans=1
    done=False
    sum=0
    for each in arr:
        if each==num and done==False:
            done=True
            
        else:
            sum+=num*each
            
    print sum
            

def check(a):
	v = ord(a[0])-ord(a[3])
	u = ord(a[1])-ord(a[4])
	if((abs(v)==1 and abs(u)==2)or(abs(v)==2 and abs(u)==1)):
		print "Yes"
	else:
		print "No"
def check2(a):
	w=ord(a[0])-96
	x=ord(a[3])-96
	y=ord(a[1])-48
	z=ord(a[4])-48
	if((w<=8 and w>=1)and(x<=8 and x>=1)and(y<=8 and y>=1)and(z<=8 and z>=1)):
		return True
	else:
		return False
def main():
	t = input()
	for i in range(t):
		a = raw_input()
		if(len(a)!=5):
			print "Error"
		elif (not(a[1].isdigit() and a[4].isdigit() and a[0].isalpha() and a[3].isalpha() and a[2]=='-' and check2(a) )):
			print "Error"
		else:
			check(a)
if(__name__=="__main__"):
	main()

#include <stdio.h>
#include <stdlib.h>
#define MOD 10000000

int main()
{
  int T, N, sum, values[1000],i,j;
  long long dp[10001],total;
  scanf("%d",&T);
  while(T--)
  {
    scanf("%d",&N);
    sum = 0;
    for(i=0; i<N; i++)
    {
      scanf("%d",&values[i]);
      sum += values[i];
    }
    for(i=0; i<=sum; i++)
     dp[i] = 0;
    dp[0] = 1;

    for(i=0; i<N; i++) //coin-change DP
     for(j=sum; j>=0; j--)
      if(dp[j] > 0 )//&& j + values[i] <= sum)
       dp[j + values[i]] = ((dp[j+values[i]]) + (dp[j]))%MOD;

    total = 0;
    for(i=0; i<=sum; i++)
     if(dp[i] > 0)
     {
       long long inc = ((long long)((((long long)abs(sum - 2*i))) * (dp[i])))%MOD;
       total = (total + inc)%MOD;
     }
    printf("%ld\n",total);
  }
  return 0;
}

#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

typedef long long ll;
typedef unsigned long long llu;

using namespace std;

int main() {
    FIO
    int t;
    cin>>t;
    while(t--)
    {
        int n,d;
        cin>>n>>d;
        string a,b;
        cin>>a>>b;
        vector<int> ca(26,0),cb(26,0);
        bool poss = true;
        for(int i=0; i<a.length()&&i<d; i++)
        {
            for(int j=i; j<n; j+=d)
            {
                ca[a[j]-'a']++;
                cb[b[j]-'a']++;
            }
            
            for(int j=0; j<26; j++)
            {
                if(ca[j]!=cb[j])
                {
                    poss = false;
                    break;
                }
                ca[j] = 0;
                cb[j] = 0;
            }
            
            if(!poss)
                break;
        }
        cout<<(poss?"Yes":"No")<<endl;
    }
	return 0;
}

#include<bits/stdc++.h>                         //Author: Sharad Chandran
#define lld long long int                       //Handle: sharad07
#define llu unsigned long long int
#define pb(x) push_back(x)
#define pii pair<int,int>
#define pll pair<lld,lld>
#define pq priority_queue<int> 
#define mp(x,y) make_pair(x,y)
#define sz size()
#define inp1(x) scanf("%lld",&x)
#define inp2(x,y) scanf("%lld%lld",&x,&y)
#define inp3(x,y,z) scanf("%d%d%d",&x,&y,&z)
#define print(x) printf("%d",x)
#define println(x) printf("%lld\n",x)
#define _for(i,x,y) for(int i=x;i<y;i++)
using namespace std;
const int maxx=1e5+2;
lld mod=1e9+7;
lld A[maxx],C[102][102];
lld k,sum[102][maxx],flag,n,Pow[102][maxx];
 
inline bool cmp(const lld &a,const lld &b)
{
    return a>b?1:0;
}
 
inline lld neg_mod(lld &num)
{
    if(num>mod) num-=(num/mod)*mod; 
    else if(num<0) 
    {
        lld temp=-num,quo;
        quo=temp/mod;
        if(quo*mod!=temp) quo++;
        num=quo*mod-temp;
    }
}
 
lld modPow(lld a, lld x, lld p) 
{
    //calculates a^x mod p in logarithmic time.
    lld res = 1;
    while(x > 0)
    {
        if( x % 2 != 0)
        {
            res = (res * a);
            neg_mod(res);
        }
        a = (a * a) % p;
        x /= 2;
    }
    return res;
}
 
lld modInverse(lld a, lld p) 
{
    return modPow(a, p-2, p);
}
 
lld nCr(lld n, lld k, lld p) // calculates C(n,k) mod p (assuming p is prime).
{
    lld numerator = 1; 
    for (lld i=0; i<min(k,p); i++) 
    {
        numerator = (numerator * (n-i) );
        neg_mod(numerator);
    }
    
    lld denominator = 1; 
    for (lld i=1; i<=min(k, p); i++)
    {
        denominator = (denominator * i);
        neg_mod(denominator);
    }
    lld ans=numerator* modInverse(denominator,p);
    neg_mod(ans);
    return  ans;
}
 
lld calc(int r)
{
    lld ans=0,coeff=C[k][r];
    _for(i,0,n-1)
    {
        ans=(ans+Pow[k-r][i]*sum[r][i+1]);
        neg_mod(ans);
    }
    ans*=coeff;
    neg_mod(ans);
    return ans;
}
 
inline void solve()  //..O(NK +NlogN)
{
    inp2(n,k);
    _for(i,0,n) 
    {
        inp1(A[i]);
        Pow[0][i]=1;
    }
    
    sort(A,A+n,cmp);
    
    _for(i,0,k+1)
    {    
        if(i>0) 
        {
            Pow[i][n-1]=Pow[i-1][n-1]*A[n-1];
            neg_mod(Pow[i][n-1]);
        }
        sum[i][n-1]=Pow[i][n-1];
        for(int j=n-2;j>=0;j--)
        {   
            if(i>0)
            {
                Pow[i][j]=Pow[i-1][j]*A[j];
                neg_mod(Pow[i][j]);
            }
            sum[i][j]=sum[i][j+1]+Pow[i][j];
            neg_mod(sum[i][j]);
        }
    }
    
    lld res=0;
    
    flag=1;
    for(int r=0;r<=k;r++)
    {
        res=res+calc(r)*flag;
        neg_mod(res);
        flag*=-1;
    }
    res=(res*2)%mod;
    println(res);
}
 
int main()
{
    int t;
    inp1(t);
    
    _for(i,0,101)
    {
        _for(j,0,i+1) C[i][j]=nCr(i,j,mod);
    }
    
    while(t--)
    {
        solve();
    }
    return 0;
}
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.util.Comparator;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.RandomAccess;
import java.util.AbstractList;
import java.io.Writer;
import java.util.List;
import java.io.IOException;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.Random;
import java.math.BigInteger;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.util.Stack;

public class Main 
{
	public static void main(String[] args) throws Exception
	{
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;

		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		SaveTheTrees solver = new SaveTheTrees();
		int T = in.readInt();
		for(int count = 0; count < T; count++)
		{
			solver.solve(count+1, in, out);			
		}
		out.close();

	}//end of main()
}
 
class SaveTheTrees 
{
	int N;
	int[] A;
	Point2D[] points;

	public void solve(int testNumber, InputReader in, OutputWriter out) throws Exception
	{
		N = in.readInt();
		A = new int[N];

		for(int count = 0; count < N; count++)
		{
			A[count] = in.readInt();
		}

		int numOfPoints = (N*2 - 3);
		points = new Point2D[numOfPoints];
		
		long[] yMin = new long[N];
		long[] yMax = new long[N];
		yMin[N-1] = A[N-1];
		yMax[N-1] = A[N-1];
		for(int count = N-2; count >= 0; count--) {
			yMin[count] = Math.min(yMin[count+1], A[count+1]);
			yMax[count] = Math.max(yMax[count+1], A[count+1]);
		}

		int pointCount = 0;
		for(int xCount = 0; xCount < N-2; xCount++) {
			points[pointCount] = new Point2D(A[xCount], yMin[xCount]);
			//System.out.println(points[pointCount]);
			points[pointCount+1] = new Point2D(A[xCount], yMax[xCount]);
			//System.out.println(points[pointCount+1]);
			pointCount+=2;
		}
		points[pointCount] = new Point2D(A[N-2], A[N-1]);
		//System.out.println(points[pointCount]);
		//System.out.println(pointCount+1);
		out.print(getArea(points, out) + "\n");		
		//long ans = getSchedule(X, Y, N);
		//out.print(ans + "\n");

	}//end of solve()

	public long getArea(Point2D[] points, OutputWriter out)
	{
		GrahamScan gs = new GrahamScan();
		gs.grahamScan(points);
		Point2D[] hull = gs.getCCWHull();
		long area = 0;
		for(int count = 1; count < hull.length; count++) {
			area += ((hull[count-1].x * hull[count].y) - (hull[count-1].y * hull[count].x));
		}
		
		return Math.abs(area);
	}

}//end of class SaveTheTrees

class InputReader 
{
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
 
	public InputReader(InputStream stream) 
	{
		this.stream = stream;
	}
	 
	public int read() 
	{
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) 
		{
			curChar = 0;
			try 
			{
				numChars = stream.read(buf);
			} 
			catch (IOException e) 
			{
				throw new InputMismatchException();
			}

			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
 
	public int readInt() 
	{
		int c = read();

		while (isSpaceChar(c))
			c = read();

		int sgn = 1;
		if (c == '-') 
		{
			sgn = -1;
			c = read();
		}

		int res = 0;
		do 
		{
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} 
		while (!isSpaceChar(c));

		return res * sgn;
	}

	public String readString() 
	{
		StringBuilder sb = new StringBuilder();
		int c = read();
		while (isWhiteSpace(c)) 
		{
		    c = read();
		}

		while (!isWhiteSpace(c)) 
		{
		    sb.appendCodePoint(c);
		    c = read();
		}

		return sb.toString();
	}

	public static boolean isWhiteSpace(int c) 
	{
		return c >= -1 && c <= 32;
	}
 
	public static boolean isSpaceChar(int c) 
	{
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
}
 
class OutputWriter 
{
	private final PrintWriter writer;
	 
	public OutputWriter(OutputStream outputStream) 
	{
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}
	 
	public OutputWriter(Writer writer) 
	{
		this.writer = new PrintWriter(writer);
	}
	 
	public void print(Object...objects) 
	{
		for (int i = 0; i < objects.length; i++) 
		{
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}
	 
	public void printLine(Object...objects) 
	{
		print(objects);
		writer.println();
	}
	 
	public void close() 
	{
		writer.close();
	}
 
}


class GrahamScan {
	Stack<Point2D> hull = new Stack<Point2D>();
	
	public void grahamScan(Point2D[] points) {
		int pointsCount = points.length;
	
		// sort by y-coordinate
		Arrays.sort(points);
		
		// sort by points[0].polarOrder
		Arrays.sort(points, 1, pointsCount, points[0].polarOrder());
		
		hull.push(points[0]);
		
		// find index k1 such that points[0] != points[k1]
		int k1;
		for(k1 = 1; k1 < pointsCount; k1++) {
			if(!points[k1].equals(points[0])) {
				break;
			}
		}
		
		// if all points co-incide
		if (k1 == pointsCount) {
			return;
		}
		
		// find index k2 such that points[0], points[k1], points[k2] are non-collinear
		int k2;
		for(k2 = k1+1; k2 < pointsCount; k2++) {
			if(Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
				break;
			}
		}
		
		// points[k2-1] is the second extreme point
		hull.push(points[k2-1]);
		
		for(; k2 < pointsCount; k2++) {
			Point2D top = hull.pop();
			while(Point2D.ccw(hull.peek(), top, points[k2]) <= 0) {
				top = hull.pop();
			}
			hull.push(top);
			hull.push(points[k2]);
		}

	}
	
	public Point2D[] getCCWHull() {
		Point2D[] ccwHull = new Point2D[hull.size() + 1];
		int count = hull.size();
		while(count > 0) {
			ccwHull[count-1] = hull.pop();
			count--;
		}
		ccwHull[ccwHull.length - 1] = ccwHull[0];
		
		return ccwHull;
	}

}// end of Graham Scan

class Point2D implements Comparable<Point2D> {
	long x, y;
	
	public Point2D(long x, long y) {
		this.x = x;
		this.y = y;
	}
	
	public int compareTo(Point2D that) {
		if (this.y < that.y) return -1;
		if (this.y > that.y) return 1;
		if (this.x < that.x) return -1;
		if (this.x > that.x) return 1;
		return 0;
	}
	
	public boolean equals(Object other) {
		if (this == other) return true;
		if (other == null) return false;
		if (this.getClass() != other.getClass()) return false;
		Point2D that = (Point2D) other;
		return this.x == that.x && this.y == that.y;
	}
	
	public int hashCode() {
		int hashX = ((Long)x).hashCode();
		int hashY = ((Long)x).hashCode();
		return 31*hashX + hashY;
	}
	
	public static int ccw(Point2D a, Point2D b, Point2D c) {
		long area1 = (c.y - a.y) * (b.x - a.x);
		long area2 = (b.y - a.y) * (c.x - a.x);
		
		if (area1 > area2) {
			return 1;
		}
		if (area2 > area1) {
			return -1;
		}
		
		return 0;
	}
	
	private class PolarOrder implements Comparator<Point2D> {
	
		public int compare(Point2D p1, Point2D p2) {
			long dy1 = p1.y - y;
			long dy2 = p2.y - y;
			long dx1 = p1.x - x;
			long dx2 = p2.x - x;
			if (dy1 >= 0 && dy2 < 0) return -1;
			if (dy1 < 0 && dy2 >= 0) return 1;
			// 3 collinear and horizontal points
			if (dy1 == 0 && dy2 == 0) {
				if (dx1 < 0 && dx2 >= 0) return 1;
				if (dx1 >= 0 && dx2 < 0) return -1;
			}
			
			return -ccw(Point2D.this, p1, p2);
		}
		
	}
	
	public Comparator<Point2D> polarOrder() {
		return new PolarOrder();
	}
	
	public String toString() {
		return "(" + x + "," + y + ")";
	}
}
import sys

def sieve(n):
    A=[0,0]+[1 for i in range(n-1)]
    s=int(n**.5)
    for i in xrange(2,s+1):
        if A[i]==1:
            for j in xrange(i*i,n+1,i): A[j]=0
    return [i for i, p in enumerate(A) if p]

T = int(sys.stdin.readline())
L=100000
p = sieve(L)
distinct=[0]*(L+1)

for i in p:
    for j in range(i,L+1,i):
        distinct[j]+=1

counts = [[0 for i in range(L+1)] for j in range(6)]

for k in range(1,6):
    for i in range(1,L+1):
        counts[k][i] = counts[k][i-1] + int(distinct[i]==k)

for trial in range(T):
    A,B,k=map(int,sys.stdin.readline().split())
    print counts[k][B] - counts[k][A-1]


from heapq import heappush as insert, heappop as extractMax

def KSums():
	n,k = map(int, raw_input().split())
	a = map(int, raw_input().split())
	heap = []
	insert(heap, (-sum(a), (0, n-1)))
	pairs = set()
	pairs.add((0,n-1))
	for x in xrange(k):
		value = extractMax(heap)
		print -value[0],
		i,j = value[1]
		if (i+1, j) not in pairs:
			pairs.add((i+1, j))
			insert(heap, (a[i]+value[0], (i+1,j)))
		if (i, j-1) not in pairs:
			pairs.add((i, j-1))
			insert(heap, (a[j]+value[0], (i, j-1)))

KSums()
import sys
a =  int(raw_input())
while a>0:
    s=raw_input()
    x=len(s)
    y=x/2
    t=[0]*2
    if x%2==0:
        t[0]=s[:y]
        t[1]=s[y:]
    else:
        t[0]=s[:y]
        t[1]=s[y+1:]
    z=122
    v=[0]*26
    u=[0]*26
    i=0
    k=25
    while z>=97:
        v[z-97]+=t[0].count(chr(z))
        u[z-97]+=t[1].count(chr(z))
        z-=1
    while k>-1:
        if v[k]!=u[k]:
            i+=1
        k-=1
    if i==0:
        print ("YES")
    else:
        print ("NO")
    a-=1
            
        
        
    
    

n=int(raw_input())
a=map(int,raw_input().split())
for i in a:
	temp=i;
	count=0
	while (temp%5==0):
		count+=1
		temp/=5
	while (temp%2==0):
		count-=1
		temp/=2
	while (count>0):
		count-=2
		i*=4
	print i
for _ in xrange(input()):
	a = list(raw_input())
	b = list(raw_input())
	a.sort()
	b.sort()
	la, lb = len(a), len(b)
	i, j, ans = 0, 0, 0  
	while(i<la and j<lb):
		oa = ord(a[i])
		ob = ord(b[j])
		if(oa == ob):
			ans += 1
			i += 1
			j += 1
		elif(oa<ob):
			i+=1
		elif(oa>ob):
			j+=1
	print ans
	
#!/usr/bin/python
from sys import stdin

T = int(stdin.readline())
global N,K,M,R
global minimal

def check(i,current):
    global N,K,M,R
    global minimal
    #print current,minimal,i,R
    if current >= minimal:
        return
    if i >= N:
        if current < minimal:
            minimal = current
        return


    #print current,R
    for add in [0,1]:
        R[i] += add

        if i >= K - 1:
            start = 1 + min(i - K, N - K)
            end   = start + K
            #print start, end
            high = R[start]
            start += 1
            count = 1
            while start < end:
                if R[start] == high:
                    count += 1
                elif R[start] > high:
                    high = R[start]
                    count = 1
                start += 1
        else:
            count = 0
        if count < M:
            check(i+1, current + add)
            if minimal == 0:return
        R[i] -= add

#T = 1
for _ in xrange(T):
    N,K,M = (int(x) for x in stdin.readline().split())
    R = [int(x) for x in stdin.readline().split()]
    current = 0
    minimal = N+1
    if M == 0:
        minimal = 0
    elif M != 1:
        check(0,0)
    if minimal == N+1:
        print '-1'
    else:
        print minimal


def fn():
    n,m = map(int, raw_input().split())
    tnum,tcost = [0 for i in range(41)], [0 for i in range(41)]
    for i in range(n):
        a,b = map(int, raw_input().split())
        tnum[a]+=1
        tcost[a]+=b
    num, cost = [], []
    for i in range(41):
        if tnum[i]:
            num.append(tnum[i])
            cost.append(tcost[i])
    dpd = [[0 for i in range(41)] for i in range(41)]
    dpn = [[0 for i in range(41)] for i in range(41)]
    k = len(num)
    for i in range(k+1):
        dpd[i][0] = 1
        
    
    
    for i in range(1,k+1):
        for j in range(1,k+1):
            dpd[i][j] = dpd[i-1][j] + dpd[i-1][j-1]*(pow(2,num[i-1])-1)

    for i in range(1,k+1):
        for j in range(1,k+1):
            dpn[i][j] = dpn[i-1][j] + dpn[i-1][j-1]*(pow(2,num[i-1])-1) + dpd[i-1][j-1]*cost[i-1]*pow(2,num[i-1]-1)

    d, n = 0, 0.0

    for j in range(m,k+1):
        d += dpd[k][j]
        n += dpn[k][j]

    print '{0:.9f}'.format(n/d)

t = int(raw_input())
for i in range(t):
    fn()
for t in xrange(int(raw_input())):
    n = int(raw_input())
    h = map(int, raw_input().split())
    d = map(int, raw_input().split())
    if (n != 2):
        if ((sum(d) - sum(h)) % abs(n-2) != 0):
            print -1
        else:
            s = (sum(d) - sum(h)) / (n-2)
            if (s < 0):
                print -1
            else:
                sm = 0
                for  i in range(n):
                    mi = s - (d[i] - h[i])
                    if (mi % 2 != 0 or mi/2 < 0 or mi/2 > s):
                        print -1
                        break
                    sm += mi/2
                else:
                    if (sm == s):
                        print s
                    else:
                        print -1
    else:
        if (h[0]+h[1] != d[0]+d[1]):
            print -1
        else:
            print abs(h[0]-d[0])

test_case = int(raw_input())
for t in range(test_case):
	number = int(raw_input())
	building = raw_input()
	not_blown = 0
	for b in range(len(building)):
		if number == 1:
			if building[b] == '0':
				not_blown += 1
				break
		elif b == 0:
			if building[b] == '0' and building[b+1] == '0':
				not_blown += 1
		elif b == number -1:
			if building[b] == '0' and building[b-1] == '0':
				not_blown += 1
		else:
			if building[b] == '0' and building[b-1] == '0' and building[b+1] == '0':
				not_blown += 1
	print not_blown
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 12 10:42:41 2013

@author: Ross
"""

def comb(N,k): # from scipy.comb(), but MODIFIED!
    if (k > N) or (N < 0) or (k < 0):
        return 0L
    N,k = map(long,(N,k))
    top = N
    val = 1L
    while (top > (N-k)):
        val *= top
        top -= 1
    n = 1L
    while (n < k+1L):
        val /= n
        n += 1
    return val

def ways(n):
    if n % 2 == 1:
        return 2**(n-1)
    return int((2**n - comb(n, n/2))/2)

T = input()
sizes = []
for test in range(T):
    le = raw_input()
    sizes.append(le)
    inputs = raw_input()

for size in sizes:
    print ways(int(size)) % 1000000007
def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)

def prime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return i
    return n


for t in range(int(raw_input())):
    n=int(raw_input())
    N=map(int,raw_input().split())
    g=0
    for i in range(n):
        g=gcd(g,N[i])
    if g==1:
        print -1
    else:
        print prime(g)
def solve(i, ld, pf):
    if i == n:
        return pf
    ans = 0
    for (l,P) in [(A[i], p[i]), (B[i], 100-p[i])]:
        if ld[l-1] == True:
            continue
        ld[l-1] = True
        ans += solve(i+1, ld, pf*P/100.0)
        ld[l-1] = False
    return ans
for i in range(int(raw_input())):
    n = int(raw_input())
    l = [False] * 16;
    p = []
    A, B = [], []
    for j in range(n):
        P, a, b = map(int, raw_input().split(' '))
        p.append(P)
        A.append(a)
        B.append(b)
    if n<=16:
        finalans = solve(0, l, 1)
    else:
        finalans = 0
    print finalans
for _ in range(input()):
    m,n = map(int,raw_input().split())
    arr=map(int,raw_input().split())
    arr.sort()
    count = 0
    drink = []
    for i in range(m):
        lem = map(int,raw_input().split())
        drink.append(lem[1:])
    for room in arr:
        if drink[room]:
            maxdrink = max(drink[room])
            count += maxdrink
            drink[room].remove(maxdrink)
    print count
#! /usr/bin/python

MAX_M = 100000

def xdiff(i, j, matrix, isYflow):
	""" coming to i,j position in the matrix from x direction. 
	isYflow states the direction of second last move considering this as last,
	0 represents from left, 1 from top and -1 for the case when both are possible.
	Returns the additional affected mice because of this x shift"""

	psum = get(i, j+1, matrix) + get(i+1, j, matrix)
	return psum if isYflow else psum + get(i-1, j, matrix)

def ydiff(i, j, matrix, isYflow):
	""" Read xdiff """

	psum = get(i+1, j, matrix) + get(i, j+1, matrix)
	return psum + get(i, j-1, matrix) if isYflow == 1 else psum

def get(i, j, matrix):
	""" returns matrix[i][j]. For the cases where i, j is not in matrix	returns 0. """

	n, m = len(matrix), len(matrix[0])
	if i < 0 or i >= n or j <  0 or j >= m:
		return 0
	else:
		return matrix[i][j]

def get_affected(i, j, matrix):
	""" Returns number of the affected mice for a given point """

	return (get(i+1, j, matrix) + get(i, j-1, matrix) + get(i, j+1, matrix) + get(i-1, j, matrix) + get(i, j, matrix))

l = int(raw_input()) # number of test cases
for x in xrange(0, l):
	input = raw_input().split(' ')
	n, m = int(input[0]), int(input[1])
	matrix = []  # matrix for each test case
	for y in xrange(0, n):
		matrix.append([int(c) for c in raw_input()])
	matrix_soln = []	# matrix_soln[i][j] = (least number of mice touched from 0,0 to i-1,j-1 in matrix, 0 or 1 based on last move from x or y position)
	# dynamic approach
	for i in xrange(0, n+1):
		current_row_soln = []
		for j in xrange(0, m+1):
			if i == 0: # initialization, for first column assume that the last move was from x direction i.e. coming from out of the box hence a 0
				current_row_soln.append((MAX_M, 0))
			elif j == 0: # coming from out of box from y direction hence a 1
				current_row_soln.append((MAX_M, 1))
			elif i == 1 and j == 1:
				current_row_soln.append((get_affected(i-1, j-1, matrix), 0))
			else:
				from_up = matrix_soln[i-1][j][0] + ydiff(i-1,j-1,matrix, matrix_soln[i-1][j][1])
				from_left = current_row_soln[j-1][0] + xdiff(i-1,j-1,matrix, current_row_soln[j-1][1])
				if from_up < from_left:
					soln = (from_up, 1)
				elif from_up > from_left:
					soln = (from_left, 0)
				else:
					soln = (from_up, -1)
				current_row_soln.append(soln)
		matrix_soln.append(current_row_soln)
#	for sol in matrix_soln:
#		print sol
	print matrix_soln[n][m][0]


from operator import itemgetter
t=int(raw_input())
for i in range(t):
    arr=[]
    dic={}
    n=int(raw_input())
    for j in range(n):
        x=list(map(int,raw_input().split()))
        if x[0] in dic:
            if(dic[x[0]]>x[1]):
                c=[]
                c.append(x[0])
                c.append(dic[x[0]])
                arr.append(c)
                dic[x[0]]=x[1]
            else:
                arr.append(x)
        else:
            dic[x[0]]=x[1]
#        print dic
#        print arr
    sweetness=0
    counter=0
    arr2=[]
    for j in dic:
        c=[]
        c.append(j)
        c.append(dic[j])
        arr2.append(c)
    arr2=sorted(arr2,key=itemgetter(1))
    for j in range(len(arr2)):
        counter+=1
        sweetness+=arr2[j][1]*(counter)
    arr=sorted(arr,key=itemgetter(1))
    for j in range(len(arr)):
        sweetness+=counter*arr[j][1]
    print sweetness
for _ in xrange(input()):
    n=input()
    a=list(map(int,raw_input().split()))
    ct1=0
    for i in xrange(n):
        for j in xrange(i+1,n):
            if a[i]>a[j]:
                ct1+=1
    ct2=0
    for i in xrange(1,n):
        if a[i]<a[i-1]:
            ct2+=1
    if ct1==ct2:
        print "YES"
    else:
        print "NO"

from math import sqrt
def sieve(n):
	L = [0 for i in range(n+1)]; s = int(sqrt(n)); P,S = {},[];  L[0],L[1] = 1,1
	for i in range(2,s+1):
		if L[i] is 0:
			for j in range(i*i,n+1,i): L[j] = 1
	for i in range(len(L)):
		if L[i] is 0: P[i] = None; S.append(i)
	return P,S
def precompute():
	P,S = sieve(int(1e4)); l = len(S); cnt = [0 for i in range(int(1e4)+1)]
	for i in range(l):
		for j in range(l):
			if 2*S[j] + S[i] > 10000: break
			cnt[2 * S[j] + S[i]]+=1
	return cnt
def LEVY():
	t = int(raw_input())
	cnt = precompute()
	while t:
		n = int(raw_input())
		print cnt[n]; t-=1
if __name__ == '__main__': LEVY()
		
		

val = raw_input()
t = int(val)
for i in range(t) :
	val1 = raw_input()
	n = int(val1)
	a = list()
	val2 = raw_input()
	val3 = val2.split()
	for i in range(n) :
		a.append(int(val3[i]))
	num = max(a)
	c = a.count(num)
	print ((2**c) - 1 )% 1000000007







#program for one dimensional game of life
iteration = int(raw_input())
match = [[0,1],[3,2],[5,4],[6,7]]
poss = [[0,3,5,6],[1,2,4,7]]
for i in range(iteration):
	count = 0
	row = raw_input()
	arr = poss[int(row[-1])]
	for el in arr:
		output = str(el % 2)
		current = el
		for j in range(len(row)):
			current = match[current % 4][int(row[j])]
			if j == len(row)-1:
				if current == el:
					count = count + 1
					finalout = output
			else:
				output = output + str(current % 2)
	if count == 0:
		print 'No solution'
	elif count > 1:
		print 'Multiple solutions'
	else:
		print finalout
t = int(raw_input())
for i in range(t):
    maxy = [999999999999,-999999999999, 0]
    maxx = [-999999999999,-999999999999, 0]
    miny = [999999999999,999999999999, 0]
    minx = [999999999999,999999999999, 0]
    n = int(raw_input())
    ref = []
    for j in range (n):
        x, y = map(int, raw_input().split())
        ref.append([x,y,j+1])
        if y > maxy[1]:
            maxy[0], maxy[1], maxy[2] = x, y, j+1
        if x > maxx[0]:
            maxx[0], maxx[1], maxx[2] = x, y, j+1
        if y < miny[1]:
            miny[0], miny[1], miny[2] = x, y, j+1
        if x < minx[0]:
            minx[0], minx[1], minx[2] = x, y, j+1
    maxyminx = maxy
    maxymaxx = maxy
    minyminx = miny
    minymaxx = miny
    for k in ref:
        if k[1] == maxyminx[1] and k[0] < maxyminx[0]:
            maxyminx = k
        if k[1] == maxymaxx[1] and k[0] > maxymaxx[0]:
            maxymaxx = k
        if k[1] == minyminx[1] and k[0] < minyminx[0]:
            minyminx = k
        if k[1] == minymaxx[1] and k[0] > minymaxx[0]:
            minymaxx = k
        
    """
    print maxymaxx,
    print maxyminx
    print maxx
    print minymaxx,
    print minyminx
    print minx"""
    if maxx[0] == minymaxx[0]:
        print "1"
        print minymaxx[2],
        print "NW"
    elif maxx[0] == maxymaxx[0]:
        print "1"
        print maxymaxx[2],
        print "SW"
    elif minx[0] == minyminx[0]:
        print "1"
        print minyminx[2],
        print "NE"
    elif minx[0] == maxyminx[0]:
        print "1"
        print maxyminx[2],
        print "SE"
    elif maxx[0] > minymaxx[0] and minx[0] < minymaxx[0] and minymaxx[0] <= maxymaxx[0]:
        print "2"
        print minymaxx[2],
        print "NE"
        print maxymaxx[2],
        print "SW"
    elif maxx[0] > minymaxx[0] and minx[0] < minymaxx[0] and minymaxx[0] > maxymaxx[0]:
        print "2"
        print minymaxx[2],
        print "NW"
        print maxymaxx[2],
        print "SE" 
def solve(a,b,num):
	# temp=[w for w in c]
	# heapify(temp)
	# for i in xrange(num):
	# 	ans=heappop(temp)
	# 	heapify(temp)
	# return ans	
	while(len(a)*len(b)>num):
		if len(a)==1 or len(b)==1:
			break
		if a[-1]>b[-1]:
			a.pop()
		else:
			b.pop()
	p=[]
	for i in xrange(len(a)):
		for j in xrange(len(b)):
			p.append(a[i]+b[j])
	return sorted(p)						

from heapq import *
t=input()
while(t>0):
	k,q=map(int,raw_input().strip().split())
	a=sorted([int(x) for x in raw_input().strip().split()])
	b=sorted([int(x) for x in raw_input().strip().split()])
	c=solve(a,b,100001)
	# c=[]
	# for i in xrange(k):
	# 	for j in xrange(k):
	# 		c.append(a[i]+b[j])
	# c.sort()		
	while(q>0):
		num=input()
		print c[num-1]
		q-=1
	t-=1

import sys, copy

def makeLucky( ss ):
    # return tuple ( lowpal, changecnt ) or (None,None) if unlucky

    s = bytearray( ss )    
    lens = len(s)
    if lens<9:
        return (None,None)
    swaplim = int(lens/2)
    if swaplim*2 == lens:
        # even     
        firstspanx = swaplim - (5-1)  # 1st index of 'lucky' span pal area
        lastspanx  = swaplim - 1      # last such index
    else:
        firstspanx = swaplim - (5-2)  # 1st index of 'lucky' span pal area
        lastspanx  = swaplim - 1      # last such index

    blucky = bytearray( b'lucky' )
    spal = copy.copy( s )
    spchgs = bytearray( lens )  #zeros
    totspchgs = 0
    for i in xrange(lens):
        ii = lens-1-i
        if spal[i] > spal[ii]:
            spal[i] = spal[ii]
            spchgs[i] = 1
            totspchgs += 1
    save1 = bytearray( 5 )
    save2 = bytearray( 5 )

    minchgs = 999999
    bestpal = bytearray( lens )
    for i in xrange(lens-4):
        # complentary slices [i:i+5] and [lens-5-i:lens-i]
        #     calc: [ lens-1-(i+4) = lens-5-i  :  (lens-5-i)+ 5 = lens-i ]        
        if i >= firstspanx and i <= lastspanx:
            # part of 'lucky' is in pal midpoint area; known can't form palindrome
            pass
        else:
            # count changes to get lucky
            chgs = 0
            for k in xrange(i,i+5):
                chgs += (s[k] != blucky[k-i])  # move to put lucky in
                kk = lens-1-k
                if kk != k:
                    chgs += (s[kk] != blucky[k-i]) # copy to match lucky
            # count swaps generally needed less our two uniquely modified areas
            notdone = sum(spchgs[i:i+5]) + sum(spchgs[lens-5-i:lens-i])
            chgs += totspchgs - notdone
            if chgs <= minchgs:
                # construct seq in spal, compare, and remember if it is best
                save1[:] = spal[i:i+5]
                save2[:] = spal[lens-5-i:lens-i]
                spal[i:i+5] = blucky
                for k in xrange(i,i+5):
                    if spal[lens-1-k] != spal[k]:
                        spal[lens-1-k] = spal[k]
                if chgs < minchgs:
                    minchgs = chgs
                    bestpal[:] = spal
                else:
                    if spal < bestpal:
                        bestpal[:] = spal
                if testing:
                    print str(spal), chgs
                spal[i:i+5] = save1
                spal[lens-5-i:lens-i] = save2
    return (str(bestpal),minchgs)
                
def testLucky( s ):
    global testing
    testing = False #True
    print s, '<------ input'
    best, cnt = makeLucky( s )
    print best, cnt, '<------ output'

def testit( ):
    testLucky( 'evenlength' )
    testLucky( 'eventyngth' )
    testLucky( 'yuckykcuy' )
    testLucky( 'ykcuxucky' )
    testLucky( 'yuckxucky' )
    testLucky( 'lzckxucky' )
    testLucky( 'luckxucky' )
    testLucky( 'abcdefyedabc' )
    testLucky( 'abcdefyfedabc' )
    testLucky( 'laubcdkey' )
    testLucky( 'luckycodechef' )
    testLucky( 'aaaaaaaa' )
    testLucky( 'qrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbd' )
    testLucky( 'xrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqb' )
    #testLucky( 'qrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' )

def runit():
    global testing
    testing = False
    ncases = int(sys.stdin.readline())
    for cn in xrange(ncases):
        s = sys.stdin.readline().rstrip()
        best, cnt = makeLucky( s )
        if best == None:
            print "unlucky"
        else:
            print best, cnt


runit()

lis = [0] * 100001
num4 = [0] * 100001
num7 = [0] * 100001
diff = [0] * 100001
diff[0] = 1

def preCompute():
	cnt4 = cnt7 = 0
	for i in range(1, 100001):
		t = i
		while t > 0:
			if t % 10 == 4 :
				cnt4 += 1
			elif t % 10 == 7 :
				cnt7 += 1
			t /= 10
		num4[i] = cnt4
		num7[i] = cnt7
		lis[i] = lis[i-1] + diff[num4[i] - num7[i]]
		diff[num4[i] - num7[i]] += 1

preCompute()
n = int(raw_input())
while(n > 0):
	n = n - 1
	c = int(raw_input())
	print lis[c]
import sys, os
# import unittest

def getToTarget(target, values, priorities):
	returnTarget = 0
	returnValues = values
	for p in priorities:
		x = values[p]
		toTarget = target-returnTarget
		add = min(x,toTarget)
		returnValues[p] = x-add
		returnTarget += add

	return returnTarget, returnValues

def solve(values, sevensTarget, foursTarget):
	sevens, values = getToTarget(sevensTarget, values, [2, 0, 1, 3])
	fours, values = getToTarget(foursTarget, values, [0,1])

	return sevens, fours, values

def count(str):
	counts = [0] * 10
	for x in str:
		d = ord(x)-ord('0')
		counts[d] += 1

	return  [ 
			  counts[0] + counts[1] + counts[2] + counts[3],
			  counts[4],
			  counts[5] + counts[6],
			  counts[7]
		 	]

def solveCase(a,b):
	valuesA = count(a)
	valuesB = count(b)

	# print valuesA, valuesB
	sevensA, foursA, valuesB = solve(valuesB, valuesA[3], 0)
	valuesA[3] -= sevensA
	valuesA[1] -= foursA
	sevensB, foursB, valuesA = solve(valuesA, valuesB[3], 0)

	sevens = sevensA + sevensB

	sevensA, foursA, valuesB = solve(valuesB, 0, valuesA[1])
	valuesA[3] -= sevensA
	valuesA[1] -= foursA
	sevensB, foursB, valuesA = solve(valuesA, 0, valuesB[1])

	fours = foursB + foursA

	return '7'*(sevens) + '4'*(fours)

# class Tests(unittest.TestCase):
# 	def test_0(self):
# 		self.assertEqual(solveCase('4', '7'), '7')

# 	def test_1(self):
# 		self.assertEqual(solveCase('435', '479'), '74')

# 	def test_2(self):
# 		self.assertEqual(solveCase('7','8'), '')

# 	def test_3(self):
# 		self.assertEqual(solveCase('1675475', '9756417'), '777744')

# 	def test_4(self):
# 		self.assertEqual(solveCase('777444', '666666'), '777')

# 	def test_5(self):
# 		self.assertEqual(solveCase('777444', '666444'), '777444')

# 	def test_6(self):
# 		self.assertEqual(solveCase('666444', '777444'), '777444')

# 	def test_7(self):
# 		self.assertEqual(solveCase('111344', '777433'), '777444')

# 	def test_8(self):
# 		self.assertEqual(solveCase('778888', '111174'), '77')

# 	def test_9(self):
# 		self.assertEqual(solveCase('87432', '87643'), '7744')

# 	def test_10(self):
# 		self.assertEqual(solveCase('84847487764', '19887294978'), '77777')

# 	def test_11(self):
# 		# 777778934
# 		# 774409861
# 		# 88487786847
# 		# 79774772742
# 		self.assertEqual(solveCase('88487786847', '79774772742'), '777777')

if __name__ == '__main__':
	# unittest.main()
	# sys.stdin = open('test.txt')
	cases = int(sys.stdin.readline().strip())
	for x in range(cases):
		a = sys.stdin.readline().strip()
		b = sys.stdin.readline().strip()
		print solveCase(a,b)
test_case = int(raw_input())
for t in range(test_case):
	n = raw_input().strip()
	print len(n) - n.count('4') - n.count('7')
n = input()
for i in range(n):
    str = raw_input()
    l = len(str)
    megacounter = 0
    counter = 0
    i = 0
    while(1):
        while(i<l and str[i]=='7'):
            i=i+1
            counter=counter+1
        if(i>=l):
            break
        megacounter = megacounter + (counter*(counter+1))/2
        i=i+1
        counter=0
    megacounter = megacounter + (counter*(counter+1))/2
    supercounter = (l*(l+1))/2 - megacounter
    print supercounter
import sys
a,b = map(int,sys.stdin.readline().split())
i=j=0
k=[0]*a
l=[0]*b
while i<a:
    k[i]=(raw_input())
    i+=1
while j<b:
    m=0
    c=0
    l[j]=(raw_input())
    x=len(l[j])
    if x>46:
        c+=1
    while m<a:
        if (k[m] in l[j])==True:
            c+=1
        m+=1
    if c>0:
        print "Good"
    else :
        print "Bad"
    j+=1
    

'''
from collections import Counter
import string,sys
N = int(raw_input()); s = raw_input();
if N == 1: print s; sys.exit(0)
sc = Counter(s)
for i in range(N-1):
    st = raw_input(); stc = Counter(st)
    for i in list(string.ascii_lowercase):
        if sc.get(i) != None and stc.get(i) == None: sc.pop(i,None)
        elif sc.get(i) != None and stc.get(i) != None and sc.get(i) != stc.get(i): sc[i] = abs(sc.get(i) - stc.get(i))
if sc == {}: print 'no such string'; sys.exit(0)
letters = sorted(sc.keys())
print "".join(letters)
from math import sqrt
t = int(raw_input())
fromset = set('0149')
while t:
    a,b = map(int,raw_input().split())
    sa,sb,count = int(sqrt(a)),int(sqrt(b)),0
    if sa ** 2 < a: sa = sa + 1
    for i in range(sa,sb+1):
        s = i * i; st = str(s); stset = set(st) 
        if stset.issubset(fromset): count+=1 
    print count; t-=1
'''
'''
# Second attempt :-) Previous code above...
squares = [i**2 for i in range(1,int(1e5)+1) if set(str(i**2)).issubset(set('0149'))]
def binary_search(A,left,right,key):
    while left < right:
        mid = left + ( right - left ) / 2
        if A[mid] < key: left = mid + 1
        elif A[mid] > key: right = mid
        elif A[mid] == key: return mid
    return left
t = int(raw_input())
l = len(squares)
while t:
    a,b = map(int,raw_input().split()); count = 0
    lower_limit = binary_search(squares,0,l,a)
    upper_limit = binary_search(squares,0,l,b)
    if squares[upper_limit] == b: print upper_limit - lower_limit + 1
    else: print upper_limit - lower_limit
    t-=1
'''
from math import sqrt
def isoverlucky(x):
    return '4' in x or '7' in x
t = int(raw_input())
while t:
    n = int(raw_input()); count = 0
    for i in range(1,int(sqrt(n)+1)):
        if n % i: continue
        if isoverlucky(str(i)): count+=1
        j = n / i
        if j != i:
            if isoverlucky(str(j)): count+=1
    print count; t-=1


for _ in range(int(raw_input())):
    n = int(raw_input())
    a = map(int, raw_input().split())
    ans = "No"
    c = 1
    p = a[0]
    for i in a[1:]:
        if i == p:
            c += 1
            if c == 3:
                ans = "Yes"
                break
        else:
            p = i
            c = 1
    print ans 
output = list()
string1 = raw_input()
n = int(string1)
for i in range(n) :
	inp1 = raw_input()
	todo = list(inp1)
	for j in range(len(todo)-1,-1,-1) :
		if (j>=3 and (todo[j-3]=='C' or todo[j-3]=='?') and (todo[j-2]=='H' or todo[j-2]=='?') and (todo[j-1]=='E' or todo[j-1]=='?') and (todo[j]=='F' or todo[j]=='?')) :
			todo[j-3:j+1] = 'CHEF'
		elif todo[j] == '?' :
			todo[j] = 'A'
	transstr = ''.join(todo)
	output.append(transstr)
for i in range(n) :
	print output[i]
def choices(n,m,banknotes):
    """n <= 20;  the value of a single banknote <= 1000 """
    if m == 0 or m < 1:
        return False
    elif n == 0:
        return False
    else:
        if banknotes[0] == m:
            return [banknotes[0]]
        else:
            choice = choices(n-1,(m - banknotes[0]), banknotes[1:]) 
            if choice:
                return [banknotes[0]] + choice
            else:
                return choices(n-1, m, banknotes[1:])

def solve(n,m,banknotes):
    if choices(n,m,banknotes):
        return 'Yes'
    return 'No'

def marcha1():
    T = int(raw_input())
    for t in xrange(T):
        n, m = map(int, raw_input().split())
        banknotes = []
        for i in xrange(n):
            banknotes.append(int(raw_input()))
        print solve(n,m, banknotes)

if __name__ == "__main__":
    marcha1()
#!/usr/bin/python

# read the number of testcases
testcases = int(raw_input())

# for each testcase
for i in range(0, testcases):
	# read the number of levels
	beanlevel = int(raw_input())
	# read the leaf count
	leafcount = map(int, str(raw_input()).split())
	# sanity check
	if len(leafcount) > 1 and leafcount[0] > 0:
		print 'No'
		continue
	# reverse leafcount
	leafcount.reverse()
	# set noflag to false
	noflag = False
	# initialize stems to zero
	stems = 0
	# verify if john counted correctly
	for j in leafcount:
		stems = int(stems / 2)
		stems = stems + j
		if stems % 2 and stems > 1:
			noflag = True
			break
		
	# check if the last level matches
	if noflag == False and stems == 1:
		print 'Yes'
	else:
		print 'No'


from sys import stdin
from collections import defaultdict

class Event(object):
	def __init__(self, start, end, value):
		self.start = start
		self.end = end
		self.value = value

T = int(stdin.readline())

for _ in range(T):
	number_of_events = int(stdin.readline())
	events = defaultdict(list)
	for _ in range(number_of_events):
		event = Event(*[int(x) for x in stdin.readline().split()])
		events[event.start].append(event)
	max_value = [0]*49
	def event_value(event):
		return event.value + max_value[event.end]

	for start in reversed(range(48)):
		e = events[start]
		if e:
			best = max([event_value(x) for x in e])
			max_value[start] = max(best, max_value[start + 1])
		else:
			max_value[start] = max_value[start + 1]
	print(max_value[0])
import sys
a =  int(raw_input())
while a>0:
    n,k = map(int,sys.stdin.readline().split())
    b=[0]*n
    i=0
    l=0
    b=map(int,sys.stdin.readline().split())
    while i<n:      
        l+=b[i]
        i+=1
    a-=1
    b.sort()
    j=0
    sum=0
    if k>=((n+1)/2):
        k=n-k
    while j<k:
        sum+=b[j]
        j+=1
    m=abs((l)-(2*sum))
    print m
    

t=int(raw_input())
while t>0:
	n,k=map(int,raw_input().strip().split())
	a=map(int,raw_input().strip().split())
	b=map(int,raw_input().strip().split())
	sum=0
	high=-1
	for i in range(n):
		sum+=a[i]*b[i]
		if abs(b[i])>high:
			high=abs(b[i])
	sum+=high*k
	print sum
	t-=1

mod = 10**9+7
def fast_exp(base, exp):
    res = 1
    while (exp>0):
        if (exp%2==1):
            res = (base*res)%mod
        base = (base*base)%mod
        exp/=2
    return res
for t in xrange(int(raw_input())):
    print fast_exp(2,int(raw_input()))-1


def f(i, j):
    if (score[i][j] is not None):
        return score[i][j]
    elif (i==0 and j==0):
        score[i][j] = grid[i][j]
    elif (i==0):
        score[i][j] = grid[i][j] + f(i, j-1)
    elif (j==0):
        score[i][j] = grid[i][j] + f(i-1, j)
    else:
        score[i][j] = grid[i][j] + max(f(i-1, j), f(i, j-1))
    return score[i][j]
for t in xrange(int(raw_input())):
    n = int(raw_input())
    score = []
    grid = []
    for i in range(n):
        score.append([None]*n)
        grid.append(map(int, raw_input().split()))
    f(n-1,n-1)
    if (score[n-1][n-1]<0):
        print "Bad Judges"
    else:
        print score[n-1][n-1] / float(n+n-3)
    

n,m=map(int,raw_input().split())
arr=[]
for i in range(n):
    x=list(map(int,raw_input().split()))
    arr.append(x)
l=int(raw_input())
b=[]
for i in range(l):
    a=list(map(int,raw_input().split()))
    b.append(a)
sum1=0
sum2=0
for i in range(l):
    if((b[i][0]-1)<n and (b[i][1]-1)<m):
        sum1+=arr[b[i][0]-1][b[i][1]-1]
    else:
        sum1=-1
        break
for i in range(l):
    if((b[i][1]-1)<n and (b[i][0]-1)<m):
        sum2+=arr[b[i][1]-1][b[i][0]-1]
    else:
        sum2=-1
        break
#print arr
#print b
print max(sum1,sum2)
inp = raw_input()
inp = inp.split()
n = int(inp[0])
q = int(inp[1])
lookups = {}
for i in range(0, n):
	x = raw_input()
	x = (x.strip()).split()
	lookups[x[0]] = x[1]
keyset = lookups.keys()
for i in range(0, q):
	f = raw_input()
	f = f.strip()
	idx = f.rfind('.')
	if idx==-1:
		print "unknown"
	else:
		ext = f[idx+1:]
		if ext in keyset:
			print lookups[ext]
		else:
			print "unknown"

#!/usr/bin/python

def R(): return map(int, raw_input().split())

T = R()[0]
for i in range(T):
    N = R()[0]
    A = R()

    all_negative = True
    max_element = None
    max_so_far = 0
    max_ending_left = 0     # maximum subsequence ending at prev position
    max_skipped_one = 0     # maximum subsequence ending at curr position where one element was skipped
    for x in A:
        max_element = max(max_element, x)
        all_negative = all_negative and x < 0

        max_ending_left, max_skipped_one  = max(0, max_ending_left + x), max(0, max_ending_left, max_skipped_one + x)
        max_so_far = max(max_so_far, max_skipped_one, max_ending_left)

    print max_element if all_negative else max_so_far

t = int(input())
for i in range(t):
    a,b,c=raw_input().split()
    a = int(a)
    b = int(b)
    c = int(c)
    maxV = a*100+b
    step = 0
    result = 0
    temp = maxV
    while(c<=temp and step < 10000):
        if b < c:
            a = a-1
            b = b+100
        b=b-c
        temp = a
        a = b
        b = temp
        temp = a*100+b
        step = step + 1
        if maxV < temp:
            maxV = temp
            result = step
    print result
import sys

tokenizedInput = sys.stdin.read().split()
mod=1000000007
arr=[1]*5001
for i in range(1,5001):
  arr[i]=(arr[i-1]*i)%mod
        

def Power(base,expo):
    if(expo==0):
      return 1
    else:
        if(expo&1):
          return(base*Power(base,expo-1)%mod)
        else:
          root=Power(base,expo>>1)
          return(root*root%mod)
        
def combo(r,n,mod):
    q=arr[n]
    r=(arr[r]*arr[n-r])%mod
    return (q*Power(r,mod-2))%mod

elm=0

for i in range (0,5001):
    n=int(tokenizedInput[elm])
    elm=elm+1
    k=int(tokenizedInput[elm])
    elm=elm+1
    if(n==0 and k==0):
        break
    out=0
    if(((k-1)/2)!=(k/2)):
      out=(2*combo((k-1)/2,n-2,mod)*combo(k/2,n-2,mod))%mod
    else:
      out=(2*combo(k/2,n-2,mod)**2)%mod
    print out
def fn():
    n,k = map(int,raw_input().split())
    
    l = []
    
    for i in range(1001):
        l.append(0)
    
    a = map(int,raw_input().split())
    
    for i in a:
        l[i-1] += 1
        
    g = t = tc = 0
    
    for i in range(1000,-1,-1):
        if l[i] == 1:
            g += 1
            tc = (g-1)/k + 1
        else:
            t += tc
            
    print t
    
    

t = int(raw_input())

for i in range(t):
    fn()
import sys

q = []
visited = {}
backTrack = {}
goalState = [0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0]

rotations = {
    0 : {
        'R' : [0, 2, 5, 8, 6, 3],
        'L' : [0, 3, 6, 8, 5, 2],
    },
    1 : {
        'R' : [1, 3, 6, 9, 7, 4],
        'L' : [1, 4, 7, 9, 6, 3],
    },
    2 : {
        'R' : [6, 8, 10, 12, 11, 9],
        'L' : [6, 9, 11, 12, 10, 8],
    },
}

def getHashKey(state):
    h = 0
    for i in range(13):
        h = h * 2 + int(state[i])
    return h

def printSolution(key):
    target = key
    cnt = 0
    l = []
    while key != 600:
        cnt += 1
        key, no, direction, state = backTrack[key]
        direction = 1 if direction == 'L' else 0
        l.append((no, direction))

    print cnt
    for no, direction in l:
        print no, direction

def solve(key):
    startKey = key

    if len(q) == 0:
        q.insert(0, goalState)

    while len(q) > 0:
        state = q.pop()
        sKey = getHashKey(state)
        found = 0
        for rstate, no, direction in rotate(state):
            rKey = getHashKey(rstate)
            
            if rKey == startKey:
                found = 1

            if not visited.has_key(rKey):
                visited[rKey] = True
                backTrack[rKey] = (sKey, no, direction, state)
                q.insert(0, rstate)

        if found:
            printSolution(startKey)
            return

def rotate(state):
    for no in range(3):
        for direction in ['L', 'R']:
            result = state[:]
            rot = rotations[no][direction]
            prev = 0
            tmp = result[rot[prev]]
            for cur in range(1, 6):
                result[rot[prev]] = result[rot[cur]]
                prev = cur
            result[rot[prev]] = tmp
            yield result, no, direction

noTestCases = int(sys.stdin.readline().rstrip())
while noTestCases > 0:
    noTestCases -= 1
    state = sys.stdin.readline().rstrip()
    key = getHashKey(state)
    if backTrack.has_key(key):
        printSolution(key)
    else:
        solve(key)

for _ in range(input()):
        a,b = raw_input().strip().split()
        pl = [i for i in a+b]
        n = input()
        c = ""
        for _ in xrange(n):
                c += raw_input()
        cl = [i for i in c]
        flag = 0
        for i in set(cl):
                if cl.count(i) > pl.count(i):
                        flag = 1
                        break
        print 'NO' if flag else 'YES'
def is_subsequence(male, female):
	if len(male) >= len(female):
		f = 0
		for i in range(len(male)):
			if male[i] == female[f]:
				f += 1
			if f == len(female): return True
		return False
	return False

test_case = int(raw_input())
for t in range(test_case):
	male, female = map(str, raw_input().split())
	if is_subsequence(male, female) or is_subsequence(female, male):
		print 'YES'
	else:
		print 'NO'
import string
dic = list(string.ascii_lowercase)
n=input()
while n > 0 :
    t = input()
    if t < 27 :
        print string.ascii_lowercase[0:t]
    else :
        a = string.ascii_lowercase
        a *= t/26
        b = a[0:t % 26]
        a += b
        print a
    n -= 1

while 1:
    n = raw_input()
    if n == '':
        continue
    n = int(n)  
    if n == 0:
        break
    users = 0
    for i in xrange(0 , n):
        vote , score = raw_input().split()
        score = int(score)
        if vote == 'P':
            vote = 1
        else:
            vote = -1
        score -= vote
        score = abs(score)
        if score >= users:
            users = score 
        else:
            users += (score - users)%2
                 
    print users
import sys
import logging
import copy
from heapq import *
import cProfile
from math import *

class Map:

	def __init__(self):
		self.map = []

	def read_map(self,f):
		size_d = f.readline().split()
		self.height = int(size_d[0])
		self.width = int(size_d[1])
		logging.info("Size: %s x %s", self.height, self.width)	
		for i in range(0,self.height):
			self.map.extend([int(x) for x in f.readline().strip().split()])
		p_l = f.readline().split()
		self.p_y = int(p_l[0])-1
		self.p_x = int(p_l[1])-1
		self.p_pos = self.p_y * self.width + self.p_x
		self.T = int(p_l[2])
		logging.info("Princess x: %d y: %d , T=%d", self.p_x, self.p_y, self.T)


	def build_neighbour_list(self):
		size = len(self.map)
		self.neighbours = size * [None]
		
		h = self.height
		w = self.width
# Corners
		self.neighbours[0] = [1,w]
		ne = w-1
		self.neighbours[ne] = [ne-1,ne+w]
		sw = size-w
		self.neighbours[sw] = [sw+1,sw-w]
		se = size-1
		self.neighbours[se] = [se-1,se-w]

# Top row
		for i in range(1,w-1):
			self.neighbours[i]=[i-1,i+1,i+w]
# Bottom row
		for i in range(size-w+1,size-1):
			self.neighbours[i]=[i-1,i+1,i-w]
# Left and right columns
		for i in range(1,h-1):
			l = i*w
			r = (i+1)*w-1
			self.neighbours[l]=[l-w,l+w,(l+1)]
			self.neighbours[r]=[r-w,r+w,(r-1)]
			
		for i in xrange(size):
			if not self.neighbours[i]:
				self.neighbours[i]=[i-w, i-1, i+1, i+w] 

			
	def print_map(self):
		for n in range(self.height):
			i = n*self.width
			print self.map[i:i+self.width]
		
	def get_neighbours(self,pos):
		return self.neighbours[pos]


	def init_dist_map(self):
		self.dist_map=self.height*self.width * [None]
			

	def solve(self):
		h = []
		T = self.T - self.map[self.p_pos]
		heappush(h, (-T,self.p_pos))
		
		while h:
			(T, pos) = heappop(h)
			T = -T
			if T < 0:
				break;

			if not self.dist_map[pos] or (self.dist_map[pos] < T):
				self.dist_map[pos]=T
				for p in self.get_neighbours(pos):
					if self.dist_map[p] == None:
						heappush(h, (self.map[p]-T,p))	
			
		
		spare_time = self.dist_map[0]
		if spare_time >= 0:
			print "YES"
			print spare_time
		else:
			print "NO"
			
			
def run():
#	logging.basicConfig(level=logging.DEBUG)
	m = Map()
	m.read_map(sys.stdin)
	m.build_neighbour_list()
	m.init_dist_map()
	m.solve()


run()
#cProfile.run('run()')

mod=1000000007
t=input()

while t:
    n=input()
    print (pow(3,n,mod)+3*pow(-1,n))%mod
    t-=1

import math
listx=[0]*10
def no(x):
    i=int(x)-1
    el=0
    while(i>=0):
        el+=listx[i]
        i-=1
    return el
t=int(raw_input().strip())
while t:
    t-=1
    ans=1
    listx=[0]*10
    num=raw_input().strip()
    for i in num:
        listx[int(i)]+=1
    leng=len(num)-1
    i=0
    while leng>0:
        temp=no(num[i])*math.factorial(leng)
        if(temp>0):
            for x in listx:
                temp/=math.factorial(x)
        ans+=temp
        listx[int(num[i])]-=1
        leng-=1
        i+=1
    ans+=no(num[i])
    print(ans)

#include <stdio.h>
 
#define min(A,B) ((A) > (B) ? (B) : (A))
#define max(A,B) ((A) > (B) ? (A) : (B))
 
int main(void){
	int testCount;
	scanf("%d", &testCount);
 
	while (testCount--){
		int cars, wander, ready, p, r, k;
		int doneCount, ridingCount, carsWaiting;
		int carArrives[50];
		int becomeReady[5100];
		int nextCar;
		int totalPeople;
		int i, time;
 
		scanf("%d %d %d %d %d %d", &cars, &wander, &ready, &p, &r, &k);
		
		if (cars == 0){
			int movedToReady = min(wander, k/r);
			printf("0 0 %d %d\n", wander - movedToReady, ready + movedToReady);
			continue;
		}
 
		doneCount = ridingCount = 0;
 
		for (i = 0; i < cars; i++)
			carArrives[i] = 0;
		
		totalPeople = wander+ready;
		for (i = 0; i < ready; i++)
			becomeReady[i] = 0;
		for (i = ready; i < totalPeople; i++)
			becomeReady[i] = (i-ready+1)*r;
 
		nextCar = 0;
		for (i = 0; i < totalPeople; i++){
			int readyTime = becomeReady[i];
			if (readyTime > k)
				break;
			
			if (carArrives[nextCar] > readyTime)
				readyTime = carArrives[nextCar];
			carArrives[nextCar] = readyTime + p;
			nextCar = (nextCar+1) % cars;
 
			if (readyTime + p <= k)
				doneCount++;
			else if (readyTime <= k)
				ridingCount++;
		}
 
		carsWaiting = 0;
		for (i = 0; i < cars; i++)
			if (carArrives[i] <= k)
				carsWaiting++;
 
		printf("%d %d %d %d\n", carsWaiting, doneCount, max(0, wander - k/r), ready + min(wander, k/r) - doneCount - ridingCount);
	}
 
	return 0;
} 
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

long long adj[2510][2510];
long long swe(pair<int,int> const &p1,pair<int,int> const & p2)
{
	return (long long)(p1.first - p2.first)*(p1.first-p2.first)+
		(long long)(p1.second-p2.second)*(p1.second-p2.second);
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		vector<pair<int,int>> pos(n+2);
		for(int i=0;i<n+2;++i)
		{
			cin>>pos[i].first>>pos[i].second;
			for(int j=0;j<=i;++j)
			{
				adj[i][j] = adj[j][i] = swe(pos[i],pos[j]);
			}
		}
		vector<long long> dis(n+2,INT_MAX);
		dis[n]=0;
		vector<char> visit(n+2,0);
		while(1)
		{
			int idx=-1,mi=INT_MAX;
			for(int i=0;i<n+2;++i)
			{
				if(visit[i]==0 && dis[i]<mi)
				{
					idx=i;
					mi = dis[i];
				}
			}
			if(idx==-1) break;
			visit[idx]=1;
			for(int i=0;i<n+2;++i)
			{
				if(visit[i]==0)
				{
					dis[i] = min(dis[i],mi+adj[i][idx]);
				}
			}
		}
		cout<<dis[n+1]<<endl;
	}
	return 0;
}

import sys
a =  int(raw_input())
while a>0:
    s=raw_input()
    x=len(s)*11
    y=ord(s[0])-97
    i=1
    sum=0
    while i<len(s):
        w=ord(s[i])-97
        if(w>=y):
            sum+=w-y
            y=w
        else:
            sum+=26-y+w
            y=w
        i+=1
    sum+=(len(s)+1)
    if sum>x:
        print "NO"
    else:
        print "YES"
    a-=1
        

/*  IF THIS COMMENT IS REMOVED THE PROGRAM WIint BLOW UP
 *
 *  Copyright (c) 2016, Aadil
 *  Aint rights reserved.
 *
 *  This program is licensed under the F**cked_UP_Coder (FUP) License v0.2
 *
 *  You can use this program freely, if :
 *  - this code works :P
 *  - you are a FUP
 */

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <climits>
#include <string>
#include <queue>
#include <stack>
#include <map>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define input0based(arr, n) for(ll i = 0; i < n; ++i) cin >> arr[i];
#define input1based(arr, n) for(ll i = 1; i <= n; ++i)  cin >> arr[i];
#define forLoop(start, end) for(ll i = (start); i < (end); ++i)

int main() {
    
    cin.sync_with_stdio(false);
    
    ll t;
    cin >> t;
    
    vector<string> arr;
    cin.clear();
    cin.ignore(INT_MAX, '\n');
    string temp;
    
    ll z = t;
    while (z-- > 0) {
        getline(cin, temp);
        arr.push_back(temp);
    }
    
    for (ll i = 0; i < t; ++i) {
        
        int ch[26] = { 0 };
        
        ll len = arr[i].length();
        
        for (ll j = 0; j < len; ++j) {
            if (arr[i][j] >= 'A' && arr[i][j] <= 'Z')
                ++ch[tolower(arr[i][j]) % 97];
            else if (arr[i][j] >= 'a' && arr[i][j] <= 'z')
                ++ch[arr[i][j] % 97];
        }
        
        
        char x = '~';
        for (ll i = 0; i < 26; ++i) {
          //cout << ch[i] << " ";
            if (ch[i] == 0) {
                x = i + 97;
                break;
            }
        }
        
        cout << x << endl;
    }
    
    return 0;
}
def sum_pair_less_than(v, S):
	i,j,pair_count = 0,len(v)-1,0
	while i < j:
		if v[i]+v[j] < S :
			pair_count += j-i
			i+=1
		else:
			j-=1
	return pair_count

def not_a_triangle_count(v):
	non_tri_count = 0
	v.sort()
	i=len(v)-1
	while i >= 2 :
		non_tri_count += sum_pair_less_than(v[0:i],v[i])
		i-=1
	return non_tri_count

while True:
	n = input()
	if n==0 :
		exit()
	v = [int(x) for x in raw_input().split(' ')]
	print not_a_triangle_count(v)
statement = raw_input('')
a,n,k = statement.split(' ')
a= int(a)
n = int(n)
k = int(k)
numb = 0
for i in range(0,k):
	numb = a%(n+1)
	print(numb)
	a =  a //(n+1)

from operator import itemgetter
t=int(raw_input())
for i in range(t):
    arr=[]
    n=int(raw_input())
    for j in range(n):
        a,b=map(str,raw_input().split())
        b=int(b)
        arr.append([a,b])
    arr=sorted(arr,key=itemgetter(1))
    if n==1:
        print arr[0][0]
    elif arr[0][1]!=arr[1][1]:
        print arr[0][0]
    else:
        flag=0
        #print arr
        for j in range(1,n-1):
            if arr[j][1]!=arr[j-1][1] and arr[j][1]!=arr[j+1][1]:
                print arr[j][0]
                flag=1
                break
        if flag==0:
            if arr[n-1][1]!=arr[n-2][1]:
                print arr[n-1][0]
            else:
                print "Nobody wins."
for i in xrange(input()):
    n=input()
    if n%4==1:
        print "ALICE"
    else:
        print "BOB"

md = 1000000007
n,b = map(int,raw_input().split())

sum = []
dp = []
l = [0]
for i in range(n):
	t = int(raw_input())
	l.append(t)

for i in range(n+5):
	dp.append(0)
	sum.append(0)

dp[b] = 1
sum[b] = 1

for i in range(b-1,0,-1):
	dp[i] = (sum[i+1]-sum[i+1+l[i]])%md
	sum[i] = (dp[i]+sum[i+1])%md


q = int(raw_input())
for i in range(q):
	t = int(raw_input())
	print dp[t]

def f(n):
	divsum = 0
	for i in xrange(1, n + 1, 2):
		divsum += i * (n / i)
	return divsum

if __name__ == "__main__":
	T = raw_input()
	T = int(T)
	while(T > 0):
		T -= 1
		l_and_r = raw_input()
		l, r = l_and_r.split()
		l = int(l)
		r = int(r)
		print f(r) - f(l-1)
a=int(raw_input())
r=a%6
if r==0 or r==1 or r==3 or r==6 :
	print "yes"
else :
	print "no"
	
t=input()
while(t>0):
	hh,mm=map(int,raw_input().strip().split())
	acc=0
	for i in xrange(hh):
		for j in xrange(mm):
			if len(set(str(i)+str(j)))==1:
				acc+=1
	print acc
	t-=1			
# your code goes here
n = int(raw_input())
arr = map(int, raw_input().split())
# arr.sort()
extra = 0
ans = 0
sum = 0
for i in arr:
	sum += i
sum += (sum%2)
sum /= 2
ans = max(sum,n)
print ans
n = input()
for i in range(0,n):
    p = input()
    box = []
    band = []
    t = raw_input()
    t = t.split()
    for j in range(0,p):
        box.append(4*int(t[j]))
    q = input()
    for k in range(0,q):
        a = raw_input()
        b = a.split()
        band.append((2*22.0/7*int(b[0]),2*22.0/7*int(b[1])))
    box = sorted(box,reverse=True)
    band = sorted(band,key=lambda band:band[0],reverse=True)
    band_e = sorted(band,key=lambda band:band[1],reverse=True)
    count=0
    exi=0
    while len(box)!=0 and len(band)!=0 and len(band_e)!=0:
        while len(band)!=0 and len(box)!=0 and box[0]<band[0][0]:
            band_e.remove(band.pop(0))
            if len(band)==0:
                exi=1
                break
        if exi==1:
            break
        if box[0]>band_e[0][1]:
            box.pop(0)
        else:
            t = 0
            while t<len(band):
                if band[t][1]>=box[0]:
                    count=count+1
                    band_e.remove(band.pop(t))
                    break
                t= t+1
            box.pop(0)
    print count
    
                
output = list()
val = raw_input()
t = int(val)
for i in range(t) :
	pairs = list()
	avail = list()
	output1 = list()
	string1 = raw_input()
	nums = string1.split()
	n = int(nums[0])
	m = int(nums[1])
	for j in range(m) :
		string2 = raw_input()
		num = string2.split()
		a = int(num[0])
		b = int(num[1])
		pairs.append(a)
		pairs.append(b)
	output1.append(m-1)
	spe1 = pairs[-1]
	spe2 = pairs[-2]
	avail = range(n)
	avail.remove(spe1)
	avail.remove(spe2)
	c = m-2
	for j in range(((2*m)-3),-1,-2) :
		if pairs[j] in avail :
			if pairs[j-1] in avail :
				output1.append(c)
				avail.remove(pairs[j])
				avail.remove(pairs[j-1])
		c = c - 1
	output1.sort()
	for j in range(len(output1)) :
		output1[j] = str(output1[j])
	strfinal = ' '.join(output1)
	output.append(strfinal)
for i in range(t) :
	print output[i]
















test=int(raw_input())
dp=[[0 for _ in range(0,1002)] for _ in range(0,1002)]
mod=1e9+7
for i in range(1,1001):
	dp[i][i]=1
for i in range(1,1001):
	for j in range(1,i):
		dp[i][j]=(dp[i-1][j]*j+dp[i-1][j-1])%mod
for _ in range(0,test):
	n=int(raw_input())
	ans=0
	for i in range(0,n+1):
		ans=(ans+dp[n][i])%mod
	print int(ans)

n=input()
li=list(map(int,raw_input().split()))
dp=[0]*n
temp=[]
for i in xrange(n):
    t=[]
    if dp[i]==0:
        j=i
        t.append(j+1)
        while dp[j]==0:
            dp[j]=1
            t.append(li[j])
            j=li[j]-1
        temp.append(t)
print len(temp)
for i in temp:
    for j in i:
        print j,
    print
        

intv_new = []
def bsearch(lo, hi, key):
	global intv_new
	mid = 0
	while hi >= lo:
		mid = (hi + lo)/2
		if key[0] < intv_new[mid][0]:
			hi = mid-1
		elif key[1] > intv_new[mid][1]:
			lo = mid+1
		elif key[0] >= intv_new[mid][0] and key[1] <= intv_new[mid][1]:
			return True
	return False

t = input()
while t != 0:
	t -=1 
	fg = False
	perm,intv,l,r = [],[],0,0
	intv_new = []
	nt = ()
	n,m = map(int, raw_input().strip().split()) 
	perm = map(int, raw_input().strip().split()) 
	for _ in xrange(m):
		l,r = map(int,raw_input().strip().split()) 
		intv.append((l,r))
	intv = sorted(intv)
	prev = intv[0] 
	for i in intv[1:]:
		#left matches,or right.. merge them..
		if prev[1] == i[0]+1 or prev[1] >= i[0]:
			prev = (prev[0],max(i[1],prev[1]))
		#else add to new intv list
		else:
			intv_new.append(prev)
			prev = i 
	intv_new.append(prev)
	for i in xrange(n):
		if not i+1 == perm[i] and i+1 < perm[i] and not bsearch(0,len(intv_new)-1,(min(i+1,perm[i]),max(i+1,perm[i]))):
			print "Impossible"
			fg = True 
			break
	if not fg:
		print "Possible"

def p(s):
	print "".join(map(str,s))
def f(i):
	op = []
	if i == 'a': return 0
	if i == 'b': return 1
	if i == 'c': return 2
	if i == 'd': return 3 
	if i == 'e': return 4
	if i == 'A': return 5
	if i == 'B': return 6
	if i == 'C': return 7
	if i == 'D': return 8
	if i == 'E': return 9


T = input()
d = {
		'a':['e', 'b', 'A'],
		'b':['a', 'c', 'B'],
		'c':['b', 'd', 'C'],
		'd':['c', 'e', 'D'],
		'e':['d', 'a', 'E'],
		'A':['C', 'D', 'a'],
		'B':['D', 'E', 'b'],
		'C':['E', 'A', 'c'],
		'D':['A', 'B', 'd'],
		'E':['B', 'C', 'e']
	}
while T > 0:
	T -= 1
	s = raw_input()
	i = 1
	l = []
	l.append(f(s[0].lower()))
	while i < len(s):
		x = f(s[i])
		y = f(s[i].lower())
		
		if l[-1] < 5:
			if x == l[-1] + 5:
				l.append(x)
			elif y == (l[-1]+1) % 5 or y == (l[-1]-1) %5:
				l.append(y)
			else: break
		
		else:
			if y == l[-1] - 5:
				l.append(y)
			elif abs(l[-1]-x) == 2 or abs(l[-1]-x) == 3:
				l.append(x)
			else: break

		i += 1
	if len(l) == len(s):
		p(l)
	else:
		i = 1
		l = []
		l.append(f(s[0]))
		while i < len(s):
			x = f(s[i])
			y = f(s[i].lower())
			
			if l[-1] < 5:
				if x == l[-1] + 5:
					l.append(x)
				elif y == (l[-1]+1) % 5 or y == (l[-1]-1) %5:
					l.append(y)
				else: break
			
			else:
				if y == l[-1] - 5:
					l.append(y)
				elif abs(l[-1]-x) == 2 or abs(l[-1]-x) == 3:
					l.append(x)
				else: break

			i += 1
		if len(l) == len(s):
			p(l)
		else:
			print -1
for _ in range(input()):
	s=raw_input()
	n=input()
	t,st=0,0
	for i in s:
		if i=='T':
			t+=2
			#print t
		else:
			st+=1
	sum=t+st
	#print sum
	temp=12*n
	j,i,c=temp,1,0
	while i<=temp:
		j=temp-i
		while j:
			j-=sum
			if j>=0:
				c+=1
			
			if j-sum<0:
				break
		i+=1
		if temp-i<sum:
			break
	print c	
		
t = int(raw_input())
for _ in xrange(t):
	n = int(raw_input())
	a = map(int,raw_input().split())
	mi = 100000000000
	mii = -1
	ma = -1
	mai = -1
	ans = -1
	mi = a[0]
	for i in range(1,n):
		if a[i]<mi:
			mi = a[i]
		elif a[i]>mi:
			ans = max(ans, a[i] - mi)
	if ans == -1:
		print "UNFIT"
	else:
		print ans
import math
test_case = int(raw_input())
for t in range(test_case):
	l, d , s ,c = map(int, raw_input().split())
	#print 'log value =', math.log(s) + (d-1) * math.log(c+1) - math.log(l), 'log(s) =', math.log(s), '(d-1) * log(c+1) =', (d-1)* math.log(c+1), 'log(l) =', math.log(l)
	if math.log(s) + (d-1)*math.log(c+1) - math.log(l) < 0:
		print 'DEAD AND ROTTING'
	else:
		print 'ALIVE AND KICKING'
from operator import itemgetter
N,M,H = map(int,raw_input().split()); residual = N * M; cost = 0
L = sorted([tuple(map(int,raw_input().split())) for i in range(H)],key=itemgetter(1))
for pair in L:
    if pair[0] <= residual: cost += (pair[0] * pair[1]); residual -= pair[0]
    elif pair[0] > residual: cost += (residual * pair[1]); residual = 0
    if residual == 0: print cost; break
else: print 'Impossible'
    
     


totalCases = int(raw_input())
for i in range(totalCases):
    cards = []
    cards.extend(raw_input().split())
    values = []
    suits = []
    for item in cards:
        values.append(item[0])
        suits.append(item[1])
    aceInHand = 0
    for j in range(len(values)):
        if values[j] == 'A':
            values[j] = 14
            aceInHand = j+1
        elif values[j] == 'K':
            values[j] = 13
        elif values[j] == 'Q':
            values[j] = 12
        elif values[j] == 'J':
            values[j] = 11
        elif values[j] == 'T':
            values[j] = 10
        else:
            values[j] = int(values[j])
    
    #First check for hands that deal with being in order:
    flush = 0
    straight = 0
    royal = 0
    if suits[0] == suits[1] and suits[0] == suits[2] and suits[0] == suits[3] and suits[0] == suits[4]:
        flush = 1
    tempValues = []
    tempValues.extend(values)
    tempValues.sort()
    
    if tempValues[4] == 14 and tempValues[3] == 13 and tempValues[2] == 12 and tempValues[1] == 11 and tempValues[0] == 10:
        royal = 1
    if (tempValues[4] - tempValues[3]) == 1 and (tempValues[3] - tempValues[2]) == 1 and (tempValues[2] - tempValues[1]) == 1 and (tempValues[1] - tempValues[0]) == 1:
        straight = 1
    if aceInHand:
        tempValues = []
        tempValues.extend(values)
        tempValues[aceInHand-1] = 1
        tempValues.sort()
        if (tempValues[4] - tempValues[3]) == 1 and (tempValues[3] - tempValues[2]) == 1 and (tempValues[2] - tempValues[1]) == 1 and (tempValues[1] - tempValues[0]) == 1:
            straight = 1
    if royal and flush:
        print "royal flush"
        continue
    elif straight and flush:
        print "straight flush"
        continue
    elif flush:
        print "flush"
        continue
    elif straight:
        print "straight"
        continue
    
    #Next deal with hands that require multiple of a value:
    fourOfAKind = 0
    threeOfAKind = 0
    pair = 0
    for x in range(13):
        cardCount = values.count(x+2)
        if cardCount == 4:
            fourOfAKind = 1
            break
        elif cardCount == 3:
            threeOfAKind = 1
        elif cardCount == 2:
            pair += 1
    if fourOfAKind:
        print "four of a kind"
        continue
    if threeOfAKind and pair:
        print "full house"
        continue
    if threeOfAKind:
        print "three of a kind"
        continue
    if pair == 2:
        print "two pairs"
        continue
    if pair == 1:
        print "pair"
        continue
    print "high card"
    
        
prime=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173 
,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281 
,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409 
,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541 
,547,557,563,569,571,577,587,593,599,601 
,607,613,617,619,631,641,643,647,653,659 
,661,673,677,683,691,701,709,719,727,733 
,739,743,751,757,761,769,773,787,797,809 
,811,821,823,827,829,839,853,857,859,863 
,877,881,883,887,907,911,919,929,937,941 
,947,953,967,971,977,983,991,997,1009,1013 
,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069 
,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151 
,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223 
,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291 
,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373 
,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451 
,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511 
,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583 
,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657 
,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733 
,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811 
,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889 
,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987 
,1993,1997,1999,2003]

t=int(raw_input())

while t>0:
    t-=1
    L=[int(x) for x in raw_input().split(' ')]
    x=L[0]+L[1]
    for i in range(0,len(prime)):
        if prime[i] > x:
            print(prime[i]-x)
            break

        
    
    
    
    
import sys
import math

t= int(sys.stdin.readline())
while(t>0) :
	t = t-1
	l,r = sys.stdin.readline().split(' ')
	l = int(l)
	r = int(r)
	cat1 = int(math.log10(l));
	cat2 = int(math.log10(r));
	if cat1==cat2:
		sum =  (r*(r+1)/2 - (l*(l-1)/2))*(cat1+1);
		print sum%1000000007
	else:
		cat1 = cat1+1
		num1 = pow(10,cat1);
		num2 = pow(10,cat2);
		sum1 = (((num1-1)*num1)/2 - (l*(l-1))/2)*cat1;
		sum2 = ((r*(r+1))/2 - ((num2-1)*num2)/2)*(cat2+1);
		sum3 = 0;
		for i in range(cat1, cat2):			
			num1 = pow(10,i);
			num2 = pow(10,i+1);
			sum3 +=  (num2*(num2-1)/2 - (num1*(num1-1)/2))*(i+1);
		print (sum1+sum2+sum3)%1000000007
	
def check(w,n,arr,stock):
	#print "func"
	#print "w,n",w,n
	if(w<0):
		#print "return----"
		return -arr[n][1]
	if(stock[w][n]>=0 or w==0 or n==0):
		return stock[w][n]
	#print "return"
	#print "w,n,c1",w-arr[n-1][0],n-1,c1
	#print "w,n,c2",w,n-1,c2
	#if(stock[w][n]!=-1):
		#return stock[w][n]
	#else:
		#stock[w][n]= 
	stock[w][n]= max(check(w-arr[n-1][0],n-1,arr,stock)+arr[n-1][1],check(w,n-1,arr,stock))
	return stock[w][n]
	#print "max1",max1

t=input()
while(t):
	t-=1
	n,w=map(int,raw_input().split())
	arr=[];stock=[[-1 for i in range(n+1)]for j in range(w+1)]
	i=0
	while(i<n):
		stock[0][i]=0
		a=map(int,raw_input().split())
		arr.append([a[2],a[0]*a[1]])
		i+=1
	i=0
	while(i<w):
		stock[i][0]=0
		i+=1
	if(n>0):
		print max(check(w-arr[n-1][0],n-1,arr,stock)+arr[n-1][1],check(w,n-1,arr,stock))
	else:
		print 0
for t in xrange(int(raw_input())):
    PA = float(raw_input())
    if(PA >= 0.5):
        print (10000 + 10000 * (1 - PA) * (2 * PA - 1))
    else:
        print (10000 + 10000 * PA * (1 - 2 * PA))
#include <stdio.h>
#define N 100
int a[N];
int main() {
    int t, n, k, i, j, k1, x, c;
     scanf("%d", &t);
    while(t--) {
        scanf("%d%d", &n, &k);
          x = 0;
          for(i=0; i<n; i++) {
            scanf("%d", &a[i]);
        }
        
        for (i = 0; i < n; i++) {
			for (j = i; j < n; j++) {
				c = 0;
				for (k1 = i; k1 <= j; k1++) {
					if (a[k1] % 2 == 0) {
						c++;
					}
				}
				if (c == k) {
					x = 1;
				}
			}
		}
        
        if(x)
            printf("YES\n");
        else
            printf("NO\n");
        
    }
    
    
	return 0;
}
 
#!/usr/bin/python
import numpy as np
isPrime=[bool(1) for num in range(1000000)]
primes=[]
idx1=-1
idx2=-1
isPrime[0]=isPrime[1]=bool(0)
for num in range(2,1000000):
		if(isPrime[num]==bool(1)):
			for k in range(num*num,1000000,num):
				isPrime[k]=bool(0)
			if(num>100 and idx1==-1): idx1=len(primes)
			if(num>1000 and idx2==-1): idx2=len(primes)
			primes.append(num)
num=input()
while num!=0:
	found=0
	for i in range(0,idx1):
		if (num-primes[i]*primes[i]*primes[i])>0: 
			for j in range(0,idx2):
				if(num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j])>0:
					if(isPrime[num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j]]):
						print "{0} {1} {2}".format((num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j]),primes[j],primes[i])
						found=1
				if found==1: break
		if found==1: break
	if found==0: print "0 0 0"
	num=input()
# Devajit Asem
# PRLADDU
t = int(raw_input())
def display(a):
    for i in a:
        print i,
    print 
for i in range(t):
    n = int(raw_input())
    D = map(int,raw_input().split())
    c=0
    k=0
    for i in xrange(n):
        c+=D[i]
        k+=abs(c)
    print k

for i in range(input()):
	n =[]
	n = map(float,list(raw_input().split()))
	print (n[0])/(n[0]+n[1])
for _ in xrange(input()):
        n = input()
        l = raw_input().strip().split()
        o = l.count('1') + l.count('0')
        t = l.count('2')
        t = t*(t-1)/2
        n -= o
        print n*(n-1)/2 - t
t=int(raw_input())
while t>0:
    s=raw_input()
    length=len(s)
    i=0
    j=length-1
    counter=0
    while(i<j):
        if(s[i]!=s[j]):
            counter+=1
            i+=1
        else:
            i+=1
            j-=1
    if(counter<=1):
        print "YES"
    else:
        i=0
        j=length-1
        counter=0
        while(i<j):
            if(s[i]!=s[j]):
                counter+=1
                j-=1
            else:
                i+=1
                j-=1 
        if(counter<=1):
            print "YES"   
        else:
            print "NO"
    t-=1
t =input()
for i in range(t):
	r,g,b,m =map(int,raw_input().split())
	rlist =map(int,raw_input().split())
	listg = map(int,raw_input().split())
	listb = map(int,raw_input().split())
	rmax = max(rlist)
	gmax = max(listg)
	bmax = max(listb)
	ls=[rmax,gmax,bmax]
	for j in xrange(m):	
		ls[ls.index(max(ls))]/=2
	print max(ls)
	
t=input()
while(t>0):
	t-=1
	a,b=map(int,raw_input().split())
	if(a%2!=0 and b%2!=0):
		print "Vanka"
	else:
		print "Tuzik"
#!/usr/bin/python
# coding=utf8
import sys
import math
from time import time
from itertools import permutations, combinations
import collections
import functools
from fractions import gcd, Fraction
import string
import random
import bisect


class timed(object):
    def __init__(self, func):
        self.func = func
    def __call__(self, *args):
        t1 = time()
        ret = self.func(*args)
        dif_time = time() - t1
        print "%s: returned %s in %f seconds" % (self.func.__name__, ret, dif_time)
        return ret


def comp(f1, f2, *args):
    t1 = time()
    r1 = f1(*args) if f1 is not None else None
    t2 = time()
    r2 = f2(*args) if f2 is not None else None
    t3 = time()
    res = "%5s: %s in %f\n%5s: %s in %f" % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2)
    if r1 != r2:
        dr = "!! DIFFERENT RESULTS !!"
        res = dr + "\n" + res + "\n" + dr
    print res


def alg(bubbles):
    nb_lines = 10
    nb_lanes = 9

    not_valid = 0
    for m in xrange(1, 501):
        line_has_paint = [True] * nb_lines
        for start, end, line in bubbles:
            if m >= start and m <= end:
                line_has_paint[line] = False
        for l in xrange(nb_lanes):
            if not line_has_paint[l] and not line_has_paint[l + 1]:
                not_valid += 1
                break

    return 500 - not_valid


def main():
    #import cProfile
    #cProfile.runctx('alg()', globals(), locals())
    data = sys.stdin
    nb = int(data.readline())
    #a, b = map(int,data.readline().split())
    for icase in xrange(nb):
        nb_bubbles = int(data.readline())
        bubbles = []
        for ib in xrange(nb_bubbles):
            bubbles.append(map(int, data.readline().split()))
        res = alg(bubbles)
        print res


if __name__ == "__main__":
    main()

a=int(raw_input())
if a<13:
	print 0
else:
	x=a-13
	x=x/2
	n=x+6
	res=n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)
	res=res/720
	res=res%1000000007
	print res
t=int(raw_input())
while(t):
    a,b=map(int,raw_input().split())
    x=(8.0*(b-a))+1
    n=int(((x**0.5)+1)/2.0) 
    print a-n
    t-=1  
from sys import stdin
from math import log
def printBS(li):
 print " ".join([str(x) for x in li])
def listInput():
 return map(int,stdin.readline().split())
def lcaP(a,b):
 if a==b: return a
 parents=set([])
 while a!=0:
  parents.add(a)
  a/=2
 while b!=0:
  if b in parents:
   return b
  b/=2
 return 1
#returns whether node black or red,blackcount,red count pair
def calc(node,rootBlack):
 if node==0: return (0,0,0)
 if node==1: level=1
 else: level=int(log(node,2))+1
 if level%2:
  if rootBlack:
   return (True,(level+1)/2,level/2)
  else: return (False,level/2,(level+1)/2)
 return (not rootBlack,level/2,level/2)
n=input()
blackRoot=True
for i in xrange(n):
 q=stdin.readline().split()
 if q[0]=="Qi":
  blackRoot=not blackRoot
 else: 
  a=int(q[1])
  b=int(q[2])
  ad=calc(a,blackRoot)
  bd=calc(b,blackRoot)
  lcan=lcaP(a,b)
  if q[0]=="Qb":
   print ad[1]+bd[1]-calc(lcan,blackRoot)[1]-calc(lcan/2,blackRoot)[1]
  else:
   print ad[2]+bd[2]-calc(lcan,blackRoot)[2]-calc(lcan/2,blackRoot)[2]

  
def main():    # Don't leave the code in the global namespace, it runs slower
    sumBelowCache = [[0.0 for x in range(0, 32)] for x in range(0, 100001)]
    for b in range (0, 32):
        sumBelowCache[0][b] = 0.0;
    for a in range (1, 100001):
        sumBelowCache[a][0] = sumBelowCache[a-1][0] + a
        sumBelowCache[a][1] = sumBelowCache[a-1][1] + 0.5*a - 0.5
    for b in range (2, 32):
        for a in range (2, 100000):
            sumBelowCache[a][b] = sumBelowCache[a-1][b] + sumBelowCache[a-1][b-1]/a

    tokenizedInput = map(int, sys.stdin.read().split())    # Read at once, tokenize
    testcases = tokenizedInput[0]
    readAt = 1    # Position to begin reading
    for count in range(0,testcases):
        n,k = tokenizedInput[readAt:readAt+2]    # Read the tokenized input
        if k >= 32:
            print("0.0")
        elif k == 0:
            print(n)
        else:
            output = sumBelowCache[n-1][k-1]/float(n)
            if output < 0.000001:
                print("0.0")
            else:
                print(output)
        readAt = readAt + 2

import sys
main()
import sys
from math import sqrt
def RESQ():
	t = int(raw_input())
	while t:
		n = int(raw_input()); diff = sys.maxint
		for i in range(1,int(sqrt(n))+1):
			if n % i is 0 and diff > (n/i - i):
				diff = n/i - i
		print diff; t-=1
if __name__ == '__main__': RESQ()

t=int(raw_input())
for i in range(t):
    x,y=map(int,raw_input().split())
    x,y=abs(x),abs(y)
    if x==y:
        print x+y
    elif x<y:
        if (x+y)%2==0:
            print 2*y
        else:
            print 2*y-1
    else:
        if (x+y)%2==0:
            print 2*x
        else:
            print 2*x+1
n, m = map(int, raw_input().split()) # verticies, edges
g = dict(zip((i for i in xrange(n)), ([] for i in xrange(n))))
anti_g = dict(zip((i for i in xrange(n)), ([] for i in xrange(n))))
for _ in xrange(m):
    a, b = map(int, raw_input().split())
    a, b = a-1, b-1
    g[a].append(b)
    anti_g[b].append(a)

# find minimum number of edges to reverse to complete a path from 1 to n
dp = [100001 for _ in xrange(n)]
dp[0] = 0
q = [0]
aq = []
visited = [False for _ in xrange(n)]
while q or aq:
    if q:
        node = q.pop(0)
    else:
        node = aq.pop(0)
    if visited[node]: continue
    visited[node] = True
    for k in g[node]:
        dp[k] = min(dp[k], dp[node])
        q.append(k)
    for ak in anti_g[node]:
        dp[ak] = min(dp[ak], dp[node]+1)
        aq.append(ak)

if dp[n-1] == 100001:
    print '-1'
else:
    print dp[n-1]

import math
test = int(raw_input().strip())
for i in range(test):
	h,s = map(float,raw_input().strip().split(" "))
	try:
		th2 = math.asin((4.0*s)/float(h*h))
		th = float(th2)/2.00	
		l = [ h,h*math.sin(th), h*math.cos(th)]
		l.sort()
		print l[0],l[1],l[2]
	except Exception as e:
		print -1

'''
from operator import itemgetter
N,M,H = map(int,raw_input().split()); residual = N * M; cost = 0
L = sorted([tuple(map(int,raw_input().split())) for i in range(H)],key=itemgetter(1))
for pair in L:
    if pair[0] <= residual: cost += (pair[0] * pair[1]); residual -= pair[0]
    elif pair[0] > residual: cost += (residual * pair[1]); residual = 0
    if residual == 0: print cost; break
else: print 'Impossible'
'''
N,M = map(int,raw_input().split())
L = [int(i) for i in raw_input().split()]; ns = 0
for i in range(M):
    O,S = raw_input().split(); S = int(S)
    if O == 'R': print L[(S-1+ns)%N]
    elif O == 'C': ns += S
    else: ns -= S     
     


#include<stdio.h>
#include<malloc.h>
int main()
{
	int n,q;
	int *row,*column;
	int i;
	int add,k;
	int maxrow,maxcolumn;
	char input[10];
	scanf("%d %d",&n,&q);
	row=(int *)malloc((n+1)*sizeof(int));
	column=(int *)malloc((n+1)*sizeof(int));
	for(i=0;i<=n;i++)
		row[i]=column[i]=0;
	maxrow=maxcolumn=1;
	for(i=0;i<q;i++)
	{
		
		scanf("%s %d %d",input,&k,&add);
		if(input[0]=='R')
		{
				if(maxrow==k)
				{
					row[k]=row[k]+add;
				}
				else
				{
					row[k]=row[k]+add;
					if(row[k]>row[maxrow])
						maxrow=k;
				} 
		}
		else
		{
			if(maxcolumn==k)
			{
				column[k]=column[k]+add;
			}
			else
			{
				column[k]=column[k]+add;
				if(column[k]>column[maxcolumn])
					maxcolumn=k;
			}
		}
		
	}
	printf("%d",row[maxrow]+column[maxcolumn]);
	return 0;
}

cases = int(raw_input())
while cases:
    cases -= 1
    n,k,init = map(int , raw_input().split())
    arr = [int(x) for x in raw_input().split()]
    op = raw_input().strip()
    ans = 0
    if k == 0:
        print init
        continue
    if op == 'AND':
       # for i in xrange(1,k):
        tmp = arr[0]
        for j in xrange(1,n):
            tmp &= arr[j]
        ans = init&tmp
    elif op == 'OR':
        tmp = arr[0]
        for j in xrange(1,n):
            tmp |=arr[j]
        ans = init|tmp
    else:
        #or i in xrange(1,k):
        if k % 2 == 0:
            tmp = 0
        else:
            tmp = arr[0]
            for j in xrange(1,n):
                tmp ^= arr[j]
        ans = tmp^init
    print ans
from math import*
t=int(raw_input())
while t>0:
	n=int(raw_input())
	a=map(int,raw_input().split())
	a.sort()
	sum=1
	for i in range(1,n):
		if a[i]!=a[i-1]:
			sum+=1
	print sum
	t-=1
T = int(raw_input()); M = int(1e7) + 9
while T:
    s = raw_input(); l = len(s) - 1; r = 1
    for i in range(l/2+1):
        if s[i] == '?' and s[l-i] == '?': r *= 26; r %= M
        elif s[i] != s[l-i] and ( s[i] != '?' and s[l-i] != '?' ): 
            print 0; break
    else: print r
    T -= 1
       

import sys

N, M, K = map(lambda x: int(x), sys.stdin.readline().split())
A = map(lambda x: int(x), sys.stdin.readline().split())
moves = map(lambda x: (M - x) / K + 1, A)

moves_sum = sum(moves)
moves_max = max(moves)
moves.remove(moves_max)
moves_max2 = max(moves)

min_moves = max((moves_sum - moves_max + 1) / 2, moves_max2)
max_moves = min(moves_sum / 2, moves_sum - moves_max)

print (max_moves - min_moves + 1) % (10 ** 9 + 7)
mod = 10**7 + 7
n, m  = map(int, raw_input().split())
s = [0]*m
for i in range(n):
    temp = (map(int, raw_input().split()))
    for j in xrange(m):
        s[j]+=temp[j]
p = 1
for e in s:
    p*=e
    p%=mod
print (p+mod)%mod

import sys

n,k=map(int,sys.stdin.readline().split())
a=map(int,sys.stdin.readline().split())
if k==0:
    for i in a:
        print i,
else:
    if k%2==1:
        lar=max(a)
        for i in a:
            i=lar-i
            print i,
    if k%2==0:
        lar=max(a)
        for i in range(len(a)):
            a[i]=lar-a[i]
        lar=max(a)
        for i in range(len(a)):
            a[i]=lar-a[i]
            print a[i],
N,M = map(int,raw_input().split())
while M:
    q = int(raw_input())
    L,U = N + 2,3*N
    if q < L or q > U: print 0
    elif q >= L and q <= 2*N + 1: print q - L + 1
    elif q > 2*N + 1 and q <= U: print U - q + 1
    M-=1 

#gift rift prob on cc
dim = raw_input()
dim = map(int,dim.split())
max_col = [0]*dim[1]
min_row = []
min_row_ind = []
max_col_ind = [[] for i in range(dim[1])]
for i in range(0,dim[0]):
    row = map(int,raw_input().split())
    mr = min(row)
    min_row_ind.append([p for p,v in enumerate(row) if v==mr])
    min_row.append(mr)
    for j in range(0,dim[1]):
        if max_col[j]<row[j]:
            max_col[j]=row[j]
            max_col_ind[j]=[i]
        elif max_col[j] == row[j]:
            max_col_ind[j].append(i)
state = 1
for j in range(0,dim[1]):
    for k in max_col_ind[j]:
        if min_row_ind[k].count(j)>0:
            print str(max_col[j])
            state = 0
            break
    if state==0:
        break
if state:
    print "GUESS"
for _ in range(int(raw_input())):
    N=int(raw_input())
    arr = map(int,raw_input().split())
    print sum(arr)-N*min(arr)

def possible(A, e, n):
    def rec(i, r):
        if r == 0:
            return True
        if i == n:
            return False
        if A[i] > 0 and r >= A[i]:
            p = rec(i + 1, r - A[i])
            if p:
                A[i] = 0
                return True
        p = rec(i + 1, r)
        if p:
            return True
        return False
    for i in xrange(k):
        if not rec(0, e):
            break
    else:
        return True
    return False
T = int(raw_input())
while T > 0:
    n, k = map(int, raw_input().split())
    a = map(int, raw_input().split())
    total = sum(a)
    if n < k:
        print "no"
    elif total % k == 0:
        if possible(a, sum(a)/k, n):
            print "yes"
        else:
            print "no"
    else:
        print "no"
    T -= 1

import re
def solution():
	T = input()
	lists = []
	for i in range(1,100000+1):
		val = str(i*i)
		a = re.search('[2,3,5,6,7,8]',val)
		if a == None :
			lists.append(int(val))
	#print lists, len(lists)
	len_list = len(lists)
	for i in range(T):
		result = 0
		start, stop = map(int,raw_input('').split(' '))
		for i in range(0,len_list):
			if lists[i] >= start:
				index1 = i
				break
		for j in range(0,len_list):
			if lists[j] == stop:
				index2 = j
				break
			if lists[j] > stop:
				index2 = j - 1
				break
		result = index2 - index1 + 1
		print "%d"%(result)

solution()

def mod(a,b,c):
    x = 1
    y = a
    while(b>0):
        if(b%2==1):
            x = (x*y)%c
        y = (y*y)%c
        b /=2
    return x%c
t = int(raw_input())
num = 10**9+7
for i in range(t):
    n,m,q,k = map(int,raw_input().split())
    if m<=q:
        print 0
    else:
        a1 = m-q
        a2 = mod(q+1,n,num)
        a3 = mod(q-1,n,num)
        a4 = mod(q,n,num)
        a5 = a2-2*a4+a3
        ans = a1*a5
        print (ans%num)

from collections import Counter

# compute factorials and inverse factorials
mod = 10**9 + 7
N = 10**5 + 11
fac = [1]*N
ifc = [1]*N
for i in xrange(2,N):
    ifc[i] = (mod - mod/i) * ifc[mod%i] % mod

for i in xrange(2,N):
    fac[i] = fac[i-1] *     i  % mod
    ifc[i] = ifc[i-1] * ifc[i] % mod

for cas in xrange(input()):
    # only the frequencies of letters matter
    A = Counter(raw_input().strip()).values()
    t = 0

    # no swap
    t += 1

    # 1 swap
    for i in xrange(len(A)):
        for j in xrange(i):
            t += A[i] * A[j]

    # 2 swaps, ab cd
    for i in xrange(len(A)):
        for j in xrange(i):
            for k in xrange(j):
                for l in xrange(k):
                    t += 3 * A[i] * A[j] * A[k] * A[l]

    # 2 swaps, ab ac
    for i in xrange(len(A)):
        for j in xrange(len(A)):
            if i != j:
                for k in xrange(j):
                    if i != k:
                        t += A[i] * (A[i]-1) * A[j] * A[k]

    # 2 swaps, ab ab
    for i in xrange(len(A)):
        for j in xrange(i):
            t += A[i] * (A[i]-1)/2 * A[j] * (A[j]-1)/2

    # 2 swaps, abc
    for i in xrange(len(A)):
        for j in xrange(i):
            for k in xrange(j):
                t += A[i] * A[j] * A[k] * 2

    p = fac[sum(A)]
    for i in xrange(len(A)):
        p = p * ifc[A[i]] % mod
    print (p * p - p * t) % mod
def lcm(a, b):
    if b == 0 or a == b or a%b == 0:
        return a
    else:
        temp_a, temp_b = a,b
        while temp_b:
            temp = temp_b
            temp_b = temp_a%temp_b
            temp_a = temp
        return a*b/temp_a

for i in xrange(int(raw_input())):
	size = int(raw_input())
	bandit = map(int, raw_input().split())
	whistle = [0 for i in xrange(size)]
	for i in xrange(size):
		if whistle[i] == 0:
			new_band = bandit[i]
			temp_count = 1
			while new_band != i+1:
				whistle[new_band-1] = 1
				new_band = bandit[new_band-1]
				temp_count += 1
			whistle[new_band-1] = temp_count
			count_whistle = 1 
	for i in xrange(size):
		if whistle[i] > 1:
			count_whistle = lcm(count_whistle, whistle[i])			
	print count_whistle%1000000007

t =  input()
while(t>0):
    l = list(map(int, raw_input().split()))
    n = l[0]
    m = l[1]
    
    print abs(n-m)
    t-=1
limit = 10**6 + 1
a = [i for i in range(limit)]
a[1] = 0
for i in range(2, limit):
    if a[i] == i :
        for j in range(i, limit, i):
            a[j]/=i
            a[j]*=(i-1)
        
b = [0]*(limit)
for i in range(1, limit):
    b[i] = b[i-1] + a[i]
#print time.time() - s
    
for t in xrange(int(raw_input())):
    print b[int(raw_input())]

test_case = int(raw_input())
for t in range(test_case):
	candle, k = map(int, raw_input().split())
	if candle == 0:
		print 0, 0
	elif k == 0:
		print 0, candle
	else:
		print candle//k , candle%k
for _ in xrange(input()):
        row,col = map(int, raw_input().strip().split())
        r = []
        c = []
        flag = 0
        for i in xrange(row):
                r.append(raw_input().lower())
        if row < 5 and col < 5:
                print 'There is indeed no spoon!'
                continue
        for j in range(col):
                c.append("".join([i[j] for i in r]))
        for i in r:
                if 'spoon' in i:
                        flag = 1
                        break
        if not flag:
                for i in c:
                        if 'spoon' in i:
                                flag = 1
                                break
        print 'There is a spoon!' if flag else 'There is indeed no spoon!'
'''
from __future__ import division
from math import sqrt
N,A,index = int(raw_input()),[],1
def euclideanDist(x1,y1,x2,y2):
    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
while N:
    L = [int(i) for i in raw_input().split()];
    a,b,c = euclideanDist(L[0],L[1],L[2],L[3]),euclideanDist(L[2],L[3],L[4],L[5]),euclideanDist(L[0],L[1],L[4],L[5])
    s = (a + b + c) / 2
    area = sqrt(s*(s-a)*(s-b)*(s-c)); A.append((area,index)); index+=1; N-=1
A.sort(key=lambda x: x[0])
print A[0][1],A[-1][1]
'''
def modular_exponentiation(base,power,modulus):
    res = 1
    while power:
        if power % 2 == 1: res = ( res * base ) % modulus
        base = (base * base) % modulus; power >>= 1
    return res
def decimal_to_binary(n):
    s = ''
    while n:
        s = str(n%2) + s; n/=2
    return int(s)
def SPOTWO():
    t = int(raw_input())
    while t:
        N = int(raw_input())
        print modular_exponentiation(2,2*decimal_to_binary(N),int(1e9)+7)
        t-=1
SPOTWO()

def calc(n):
    k=2
    ans=0
    while k<=n:
        ans+=1
        q=k*3
        while q<=n:
            ans+=1
            q*=3
        k*=2
    return ans

t=int(raw_input())
for z in range(t):
    a,b=map(int,raw_input().split())
    mainans=0
    x=calc(b)
    y=calc(a-1)
    #print x,y
    if 1>=a and 1<=b:
        print (x-y)+1
    else:
        print x-y
def binarysearch(li, val):
    low=0
    high=len(li)-1
    ret=-1
    while(low<=high):
        mid=(low+high)/2
        if li[mid]>val:
            ret=mid
            high=mid-1
        else:
            low=mid+1
    return ret
for _ in xrange(int(raw_input())):
    n=int(raw_input())
    li=map(int, raw_input().split())
    ans=[]
    ans.append(li[0])
    for i in xrange(1, n):
        temp=binarysearch(ans, li[i])
        if temp==-1:
            ans.append(li[i])
        else:
            ans[temp]=li[i]
    print len(ans),
    for i in ans:
        print i,
    print
    
t=int(raw_input())
for i in range(t):
	n=int(raw_input())
	arr=raw_input().split()
	ss=[]
	j=len(arr[0])
	while j>0:
		i=0
		while i+j<=len(arr[0]):
			ss.append(arr[0][i:i+j])
			i+=1
		j-=1
	for j in arr[1:]:
		cn=0
		while cn<len(ss):
			if ss[cn] not in j:
				ss.remove(ss[cn])
			else:
				cn+=1	
	if not ss:
		print ""
	else:	
		na=[]
		n=len(ss[0])
		k=0
		while len(ss[k])==n:
			na.append(ss[k])
			k+=1
			if k==len(ss)-1:
				break
		na.sort()
		print na[0]	 
			
			
t=input()
for _ in range(t):
	k=map(int,raw_input().split(" "))
	v=[0]*(k[0]+1)
	m,s=0,1
	for i in range(k[1]):
		p=map(int,raw_input().split(" "))
		a,b=p[0],p[1]
		if s:
			if v[a] == 0: v[a] = 1
			if v[b] == 0: v[b] = v[a]+1	
			if v[b] < v[a]: s=0
			if m < v[b]: m=v[b]
	if s == 0:
		print 'IMPOSSIBLE'
	else:
		print m
def series(maxx,m):
    global seriesSum
    seriesSum=[1]
    for i in range(1,maxx+2):
        seriesSum.append((seriesSum[i-1]*i%m)%m)
        
n,m=map(int,raw_input().split())
arr=map(long,raw_input().split())

final=0

maxx=max(arr)

if maxx<=1000000:
    series(maxx,m)
else:
    series(1000000,m)

for num in arr:
    if num%2:
        first=second=num
        third=(num+1)/2
    else:
        first=num+1
        second=num
        third=num/2

    ans=(first%m*second%m*third%m)%m

    if num+1>=m:
        ans+=-1
    else:
        ans=(ans%m+seriesSum[num+1]%m-1)%m

    final=(final%m+ans%m)%m

print final%m
    
        

    

    
        
    



from sys import stdin as ip
for _ in xrange(int(ip.readline())):
    s=raw_input()
    j=raw_input()
    ct=0
    for i in set(s):
        ct+=j.count(i)
    print ct

#!/usr/bin/env python
# -*- encoding: utf-8 -*-
# pylint: disable=invalid-name,missing-docstring,bad-builtin
import sys

def main():
    dstream = iter(sys.stdin.read().split())
    for _ in xrange(int(next(dstream))):
        n, k = int(next(dstream)), int(next(dstream))
        s = next(dstream)
        updates = [0]*(n + 1)
        val, count = 0, 0
        for i, chx in enumerate(s):
            val += updates[i]
            if ((chx == 'R') + val) % 2 == 0:
                continue
            updates[min(n, i + k)] -= 1
            val += 1
            count += 1
        print count

main()


ch=str(raw_input())
length=len(ch)
arr=[]
cur=0
temp=[]
for k in range(length):
     if(ch[k]=='c'):
            cur+=1
            temp.append(cur)
     else:
            temp.append(cur)
arr.append(temp)
cur=0
temp=[]
for k in range(length):
     if(ch[k]=='e'):
            cur+=1
            temp.append(cur)
     else:
            temp.append(cur)
arr.append(temp)
cur=0
temp=[]
for k in range(length):
     if(ch[k]=='f'):
            cur+=1
            temp.append(cur)
     else:
            temp.append(cur)
arr.append(temp)
cur=0
temp=[]
for k in range(length):
     if(ch[k]=='h'):
            cur+=1
            temp.append(cur)
     else:
            temp.append(cur)
arr.append(temp)
dp=[]
for i in range(4):
    dp.append([])
    for k in range(4):
        dp[i].append([0])
for i in range(4):
    for j in range(4):
        if(i==j):
            continue
        for k in range(1,length):
            if(j==0):
                if(ch[k]=='c'):
                    dp[i][j].append(dp[i][j][k-1]+arr[i][k-1])
                else:
                    dp[i][j].append(dp[i][j][k-1])
            elif(j==1):
                if(ch[k]=='e'):
                    dp[i][j].append(dp[i][j][k-1]+arr[i][k-1])
                else:
                    dp[i][j].append(dp[i][j][k-1])
            elif(j==2):
                if(ch[k]=='f'):
                    dp[i][j].append(dp[i][j][k-1]+arr[i][k-1])
                else:
                    dp[i][j].append(dp[i][j][k-1])
            elif(j==3):
                if(ch[k]=='h'):
                    dp[i][j].append(dp[i][j][k-1]+arr[i][k-1])
                else:
                    dp[i][j].append(dp[i][j][k-1])
q=int(raw_input())
for i in range(q):
    z=raw_input().split()
    ans=0
    a=z[0]
    b=z[1]
    l=int(z[2])
    r=int(z[3])
    temp2=0
    temp1=0
    if(a=='c'):
        temp1=0
    elif(a=='e'):
        temp1=1
    elif(a=='f'):
        temp1=2
    else:
        temp1=3
    if(b=='c'):
         temp2=0
    elif(b=='e'):
        temp2=1
    elif(b=='f'):
        temp2=2
    else:
        temp2=3
    if(l==1):
        ans=dp[temp1][temp2][r-1]
    else:
        ans=dp[temp1][temp2][r-1]-dp[temp1][temp2][l-2]-arr[temp1][l-2]*(arr[temp2][r-1]-arr[temp2][l-2])
    print ans 

def sumv(fr, to):
    num = to - fr + 1
    return (to + fr) * num / 2
t = int(raw_input())
for i in xrange(t):
    n, k, q = map(int, raw_input().split())
    s = raw_input().rstrip()
    cnt = 0
    c1 = 0
    c0 = 0
    far = [0 for x in xrange(n)]
    for j in xrange(n):
        while (c0 == k and s[j] == '0') or (c1 == k and s[j] == '1'):
            far[cnt] = j - 1
            if s[cnt] == '0':
                c0 -= 1
            else:
                c1 -= 1
            cnt += 1
        if s[j] == '0':
            c0 += 1
        else:
            c1 += 1
    for j in xrange(cnt, n):
        far[j] = n - 1
    cdf = [0 for x in xrange(n)]
    cdf[0] = far[0]
    for j in xrange(1, n):
        cdf[j] = cdf[j - 1] + far[j]
    last = [None for x in xrange(n)]
    pre = None
    r = n - 1
    for j in xrange(n - 1, -1, -1):
        if pre == None or pre != far[j]:
            pre = far[j]
            ind = j
        while r >= pre:
            last[r] = ind
            r -= 1
    for j in xrange(q):
        l, r = map(int, raw_input().split())
        l -= 1
        r -= 1
        res = 0
        h = last[r]
        if l <= h:
            if l == 0:
                res += cdf[h]
            else:
                res += cdf[h] - cdf[l - 1]
            res += r * (r - h)
            res -= sumv(l - 1, r - 1)
        else:
            res += sumv(1, r - l + 1)
        print res
    
    
t=input()
c=t
count=[[0 for i in range(t)] for j in range(26)];arr=[[]for i in range(t)]
while(t>0):
	arr[t-1]=list(raw_input())
	t-=1
j=0
##print arr
while(j<c):
	i=0;n=len(arr[j])
	while(i<n):
		iter1=(ord(arr[j][i])-19)%26
		count[iter1][j]+=1
		i+=1
	j+=1
#print count
i=0;t=c;c=''
while(i<26):
	j=t;min1=99999999
	while(j>=0):
		j-=1
		if(count[i][j]<min1):
			min1=count[i][j]
	j=0
	while(j<min1):
		c+=chr(97+i)
		j+=1
	i+=1
if(len(c)==0):
	print "no such string"
else:
	print c
def gcd(a,b):
    if b == 0: return a
    else: return gcd(b,a%b)
t = int(raw_input())
while t:
    N = int(raw_input()); L = [int(i) for i in raw_input().split()]; r = gcd(L[0],L[1])
    if r is 1: print N; t-=1; continue
    for i in range(2,N):
        r = gcd(r,L[i]); 
        if r is 1: print N; break
    else: print -1
    t-=1

# your code goes here
n=int(raw_input())
a=map(int,raw_input().split())
q=int(raw_input())

while q>0:
	q-=1
	k=int(raw_input())
	count=0
	for i in range(n):
		min=a[i]
		for j in range(i,n):
			if a[j]<min:
				min=a[j]
			if min==k:
				count+=1
	print count
	
t = int(raw_input().strip())
while(t>0):
	n,d=map(int,raw_input().strip().split(" "))
	arr = map(int,raw_input().strip().split(" "))
	#arr = list(set(arr))
	arr = sorted(arr,reverse=True)
	i=0
	sumn = 0
	while(i<n-1):
		if((arr[i]-arr[i+1])<d):
			sumn += arr[i]+arr[i+1]
			i+=2
		else:
			i+=1
	print sumn
	t-=1

t=int(raw_input())
p=list()
p.append(0)
while t>0:
    n=int(raw_input())
    s=len(p)
    for i in range(s,n+1): p.append(p[i-1]*1.1+0.45-0.1*p[i-2]);
    print p[n]
    t=t-1
n ,k = map(int,raw_input().split())
lis = []
for i in xrange(n):
	lis.append(int(raw_input()))
lis = sorted(lis)
ans = 0
i = 0
while(i<n-1):
	if lis[i+1]-lis[i]<=k:
		ans+=1
		i+=2
	else:
		i+=1
print ans
import sys

MOD = 1000000007

A = 26

_ = sys.stdin.readline().rstrip()

for ns in sys.stdin:
    n = int(ns)
    p = (n+1) // 2

    prod = pow(A,p,MOD)
    den = pow(A-1, MOD-2, MOD)

    res = (((2 * A * ((prod - 1) % MOD)) % MOD) * den) % MOD

    if n%2 != 0:
        res = (res - prod) % MOD

    print res

test_case = int(raw_input())
for t in range(test_case):
	n , c, q = map(int, raw_input().split())
	for i in range(q):
		l, r = map(int, raw_input().split())
		if c <= r and c >= l:
			c = r - (c - l)
			#print 'c =', c
	print c
# cook your code here
it = int(raw_input())
for i in range(it):
    r=map(int,raw_input().split())
    r.sort()
    m= 1000000007
    print (r[0]*((r[1]-1)*(r[2]-2))%m)%m
from collections import defaultdict as dd
 
def pre_times():
	rs=dd(list)
	for h in xrange(12):
		ha=0.0+h*30
		ma=0.0
		for m in xrange(60):
 
			calculated_angle=min(abs(ha-ma),360-abs(ha-ma))
			index=int(calculated_angle)
			rs[index].append({calculated_angle:[h,m]})
 
			ha+=0.5
			ma+=6.0
 
	return rs
 
def get_actual_time(rs,given_angle):
	key=int(given_angle)
	sorted_output=[]
 
	if rs.has_key(key):
		for valid_time_angle in rs[key]:
			valid_angle=valid_time_angle.keys()[0]
			valid_time=valid_time_angle.values()[0]
 
			if abs(valid_angle- given_angle)<1.0/120:
				sorted_output.append([valid_time[0],valid_time[1]])
 
		for h,m in sorted(sorted_output):
			print "%02d:%02d"%(h,m)
 
def main(rs):
	temp = int(input())
	for i in xrange(temp):
		angle=float(input())
		get_actual_time(rs,angle)
 
 
if __name__ == '__main__':
 
	rs=pre_times()
	main(rs)

Line1=raw_input().split(' ')
t=int(Line1[0])

dic={}

for i in range(0,26):
    dic[chr(i+97)]=Line1[1][i]
    dic[chr(i+65)]=Line1[1][i].upper()

dic['_']=' '

while t>0:
    t-=1
    Line=raw_input()
    O=""
    for x in Line:
        if x in dic:
            O=O+dic[x]
        else:
            O=O+x
    print(O)
    
from sys import stdin,stdout
def printBS(li):
 print " ".join([str(x) for x in li])
def listInput():
 return map(int,stdin.readline().split())
cases=input()
for case in xrange(cases):
 n=input()
 no=0
 mapping={}
 revmap={}
 count=[0]*n
 adjList={i:[] for i in xrange(n)}
 for i in xrange(n-1):
  a,b,w=stdin.readline().strip().split()
  if a not in mapping:
   mapping[a]=no
   revmap[no]=a
   no+=1
  if b not in mapping:
   mapping[b]=no
   revmap[no]=b
   no+=1
  count[mapping[a]]+=1
  count[mapping[b]]+=1
  adjList[mapping[a]]=(mapping[b],int(w[:-1]))
 s=0
 #print adjList
 for i in xrange(n):
  if count[i]==1 and adjList[i]:
   s=i
   break
 i=s
 output=""
 cost=0
 while adjList[i]:
  output=output+"%s %s %d$\n"%(revmap[i],revmap[adjList[i][0]],adjList[i][1])
  cost+=adjList[i][1]
  i=adjList[i][0]
 stdout.write(output)
 print str(cost)+"$"
#include <iostream>
#include <stdio.h>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 1e4 + 2;
ll arr[N];
double brr[N];
int main(){
	int t, i, j, n, m,  tempn;
	double pr;
	scanf( "%d", &t );
    	while(t--){
                scanf("%d %d %lf", &n, &m, &pr );
                pr /= 100.0f;
                for( i=0 ; i<m ; ++i ){
                        scanf("%d", &tempn );
                        arr[i] = tempn-1;
                }
                sort( arr, arr+m ) ;
                for( i=0 ; i<m ; ++i ) brr[i] = 1.0;
                for( j=1 ; j<n ; j<<=1 ){
                        for( i=0 ; i<m ; ++i ) arr[i] >>= 1;
                        int k = 0;
                        for( i=0 ; i<m ; ++i ){
                                if( arr[i] == arr[i+1] && m!=1 && i!=m-1){
                                        arr[i-k] = arr[i];
                                        brr[i-k] = brr[i]*brr[i+1] + pr*brr[i]*(1.0-brr[i+1]) + pr * ( 1- brr[i] ) * brr[i+1];
                                        i++;k++;
                                }
                                else{
                                        arr[i-k] = arr[i];
                                        brr[i-k] = brr[i]*pr;
                                }
                        }
                        m -= k;
                }
                printf("%.13lf\n", 100.0*brr[0]);
    	}
    	return 0;
}

import math
t=int(raw_input())
while t!=0:
    a=[]
    b=[]
    nodes=2**t-1
    x=list(map(int,raw_input().split()))
    a.append(0)
    b.append(0)
    for i in range(len(x)):
        a.append(x[i])
        b.append(0)
#    print a
#    print b
    for i in range(len(a)-1,0,-1):
#        print i
        if (2*i<=(len(a)-1) and 2*i+1<=(len(a)-1)):
            b[i]=max(a[i]*b[2*i],a[i]*b[2*i+1])
#	elif (2*i<=len(a)-1):
#	    b[i]=a[i]*b[2*i]
#	elif (2*i+1<=len(a)-1):
#	    b[i]=a[i]*b[2*i+1]
	else:
	    b[i]=a[i]
#    print a
#    print b
    print b[1]%1000000007    
    t=int(raw_input())
n=int(raw_input())
s=list(map(str,raw_input().split()))
m=int(raw_input())
dic={}
for i in range(m):
    a,b,c=map(str,raw_input().split())
    c=int(c)
    dic[(a,b)]=c
        
t=int(raw_input())
for i in range(t):
    x=list(map(str,raw_input().split()))
    y=len(x)
    if int(x[0])==1 and x[1] in s:
        print "0"
    elif int(x[0])==1:
        print "ERROR"
    elif x[1]==x[y-1]:
        print "ERROR"
    else:
        if int(x[0])>n:
            print "ERROR"
        else:
            flag=1
            ans=0
            dic2={}
            for j in range(1,len(x)):
                if x[j] in dic2:
                    dic2[x[j]]+=1
                else:
                    dic2[x[j]]=1
            for j in dic2:
                if dic2[j]>1:
                    flag=0
                    break
            if flag==1:
                for j in range(1,len(x)-1):
                    if (x[j],x[j+1]) in dic:
                        ans+=dic[(x[j],x[j+1])]
                    else:
                        flag=0
                        break
            if flag==0:
                print "ERROR"
            else:
                print ans
t = int(raw_input())
for i in range(0,t):
	list = []
	sum = 0
	n = int(raw_input())
	sum = ((n)*(n+1))/2
	if n%2 ==0:
		n = n/2
	else:
		n = (n+1)/2 	
	number_notprinted = raw_input()
	list = number_notprinted.split(" ")
	for j in range(1,len(list)):
		sum-=int(list[j])
	number_torn = int(raw_input())
	number_left = n-number_torn	
	result = float(number_left) *float(sum)/n
	print "%.4f" % result
	
	
dic={}
def calc(x,y):
    a=max(dic[x][0]+1,dic[y][0]+1)
    b=max(n-dic[x][-1],n-dic[y][-1])
    c=max(dic[x][0]+1,n-dic[y][-1])
    d=max(n-dic[x][-1],dic[y][0]+1)
    #print x,y,"=>","a=",a,"b=",b,"c=",c,"d=",d
    return min(a,b,c,d)

n,k=map(int,raw_input().split())
x=list(map(int,raw_input().split()))
for i in xrange(len(x)):
    if x[i] in dic:
        dic[x[i]].append(i)
    else:
        dic[x[i]]=[i]
#print dic
ans=10000000000
for i in xrange(len(x)):
    if k-x[i] in dic:
        #print x[i],k-x[i]
        if x[i]!=(k-x[i]):
            ans=min(ans,calc(x[i],k-x[i]))
if ans!=10000000000:
    print ans
else:
    print "-1"
d={}
for z in range(input()):
    s,v=raw_input().split(' ')
    d[int(v)]=s
s=sorted(d,reverse=True)
for x in range(input()):
    q=raw_input()
    found,l=False,len(q)
    for i in s:
        if d[i][:l]==q:
            print d[i]
            found=True
            break
    if not found:print 'NO'
array_len, allowed_changes = map(int, raw_input().split())
array = map(int, raw_input().split())

MAX = 10 ** 9 + 1

best_a = MAX
best_d = MAX
for start in xrange(allowed_changes + 1):
    rem = allowed_changes - start
    for end in xrange(max(start + 1, array_len - rem - 1), array_len):
        d = (array[end] - array[start]) / (end - start)
        a = (array[start] - start * d)
        changes = 0
        for i in xrange(array_len):
            if (array[i] != a + d * i):
                changes += 1
        if changes <= allowed_changes:
            if (a < best_a or (a == best_a and d < best_d)):
                best_a, best_d = a, d
            
    
print " ".join(map(str, [best_a + i * best_d for i in xrange(array_len)]))
from sys import stdin
 
def merge(v):
    T, last = [0], -1
    v.sort()
    for i in range(len(v) - 1):
        if v[i] == last: continue
        if v[i] == v[i+1]:
           T.append(v[i])
           T[0] += 1
           last = v[i]
    return T
 
def main():
    n = sum(map(int, raw_input().split()))
    v = map(int, stdin.readlines())
    x = merge(v)
    for i in x: print i
 
main()
import sys
a =  int(raw_input())
while a>0:
    b=int(raw_input())
    i=0
    p = map(int,sys.stdin.readline().split())
    while i<b:
        p[i]+=i
        i+=1
    x=max(p)
    print (x)
    a-=1
    

t=int(input())
while t:
    s=raw_input()
    dic={}
    length=len(s)
    for i in s:
        if i in dic:
            dic[i]+=1
        else:
            dic[i]=1
    j=length
    ans=1
    while(j>0):
        ans*=j
        j-=1
    for var in dic:
        j=dic[var]
        ans2=1
        while(j>0):
            ans2*=j
            j-=1
        ans/=ans2
    print ans%1000000007
    t-=1
#!/usr/bin/python
mainlis=[]
maxv=1000000080798150871
for i in range(0,1000,1):
  mainlis.append([])
  varlis=mainlis[i]	
  for j in range(0,3,1):
    varlis.append(0)	
test=input()
while test >0:
  string=raw_input()
  lis=string.split()
  n=int(lis[0])
  m=int(lis[1])
  l=int(lis[2])
  k=int(lis[3])
  for i in range(0,n,1):
    string=raw_input()
    varlis=mainlis[i]	
    for j in range(0,m,1):
      varlis[j]=int(string[j])
  if m==1:
    count=0
    for i in range(0,n,1):
      varlis=mainlis[i]
      if varlis[0]==1:
        count=count+1
    ans=1
    for i in range(0,l,1):
      ans=(ans*(count-i))/(i+1)
  elif m==2:
    if k==2:
      count=0
      for i in range(0,n,1):
        varlis=mainlis[i]
        if varlis[0]==1 and varlis[1]==1:
          count=count+1
      ans=1
      for i in range(0,l,1):
        ans=(ans*(count-i))/(i+1)
    elif k==1:	
      count1=0
      count2=0	
      for i in range(0,n,1):
        varlis=mainlis[i]
        if varlis[0]==1:
          count1=count1+1
        if varlis[1]==1:
          count2=count2+1	
      ans1=1
      ans2=1	
      for i in range(0,l,1):
        ans1=(ans1*(count1-i))/(i+1)
        ans2=(ans2*(count2-i))/(i+1)
      ans=ans1%maxv+ans2%maxv
  elif m==3:
    if k==3:
      count=0
      for i in range(0,n,1):
        varlis=mainlis[i]
        if varlis[0]==1 and varlis[1]==1 and varlis[2]==1:
          count=count+1
      ans=1
      for i in range(0,l,1):
        ans=(ans*(count-i))/(i+1)
    elif k==1:
      count1=0
      count2=0
      count3=0	
      for i in range(0,n,1):
        varlis=mainlis[i]
        if varlis[0]==1:
          count1=count1+1
        if varlis[1]==1:
          count2=count2+1
        if varlis[2]==1:
          count3=count3+1
    	
      ans1=1
      ans2=1
      ans3=1
      for i in range(0,l,1):
        ans1=(ans1*(count1-i))/(i+1)
        ans2=(ans2*(count2-i))/(i+1)
        ans3=(ans3*(count3-i))/(i+1)
      ans=ans1%maxv + ans2%maxv +ans3%maxv
    	
    elif k==2:
      count1=0
      count2=0
      count3=0
      for i in range(0,n,1):
        varlis=mainlis[i]	      
        if varlis[0]==1 and varlis[1]==1:
          count1=count1+1
        if varlis[0]==1 and varlis[2]==1:
          count2=count2+1
        if varlis[1]==1 and varlis[2]==1:
          count3=count3+1
      ans1=1
      ans2=1
      ans3=1
# print count1,count2,count3	
      for i in range(0,l,1):
        ans1=(ans1*(count1-i))/(i+1)
        ans2=(ans2*(count2-i))/(i+1)
        ans3=(ans3*(count3-i))/(i+1)
      ans=ans1%maxv + ans2%maxv + ans3%maxv	
    	
	
    	
      	
  print ans%maxv	
  test=test-1
	

	
      	    


from math import sqrt
import os,sys
h=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
skip=[1,2,1,2,3,4,5,6,1,2,3,4,1,2,1,2,3,4,1,2,1,2,3,4,1,2,3,4,5,6]
lookup={1373653:1373639,25326001:25325981,3215031751:3215031749,2152302898747:2152302898729,3474749660383:3474749660329,341550071728321:341550071728289}
def f(n):
    if n==2: return 2
    if not (n&1):n-=1
    mod=n%30
    while 1:
      b=False
      if n== 1373653 or n==25326001 or n==3215031751 or n==2152302898747 or n==3474749660383 or n==341550071728321:return lookup[n]
      v=sqrt(n)
      for x in h:
        if not n%x:
          if x>v:return n
          b=True
          break
      if not b:
        d,s=n-1,0
        while not (d & 1):
          d >>= 1
          s += 1
        atp = pow(2, d, n)
        if atp==1 or atp == n-1 : return n
        for i in xrange(s-1):
          atp = (atp*atp)%n
          if atp == n - 1: return n
      n,mod=n-skip[mod],mod-skip[mod]
      if mod<0:mod+=30
    return n
 
v=os.read(0,500*19).split()
for x in xrange(1,len(v)):
  sys.stdout.write(str(f(int(v[x])))+"\n") 
# cook your code here
for _ in range(int(raw_input())):
    n,h=map(int,raw_input().split())
    a=[0]*(n+2)
    for i in range(n):
        l,r=map(int,raw_input().split())
        a[l+1]+=1
        a[r+2]-=1
    for i in range(1,n+1):
        a[i]=a[i]+a[i-1]
    for i in range(n+1):
        a[i]=a[i]+a[i-1]
    print n*h-max(a[i+h]-a[i] for i in range(n-h+1))
D = {2**i - 1:True for i in range(31)}
T = int(raw_input())
while T:
    N = int(raw_input())
    if N == 1: print '2'
    elif D.get(N): print N/2
    else: print '-1'
    T-=1

def least_bit_set(x):
    return x & (-x)

def eliminate(values):
    values = list(values)
    i = 0
    while True:
        values = [v for v in values if v > 0]
        if i >= len(values):
            return values
        j = i
        for k in range(i + 1, len(values)):
            if least_bit_set(values[k]) < least_bit_set(values[j]):
                j = k
        values[i], values[j] = (values[j], values[i])
        for k in range(i + 1, len(values)):
            if least_bit_set(values[k]) == least_bit_set(values[i]):
                values[k] ^= values[i]
        i += 1
    return values

def in_span(x, eliminated_values):
    for y in eliminated_values:
        if least_bit_set(y) & x != 0:
            x ^= y
    return x == 0

for _ in xrange(int(raw_input())):
  n, k = map(int, raw_input().split())
  values = map(int, raw_input().split())
  eliminated_values = eliminate(values)
  res = k
  for target in xrange(1023, 0, -1):
    if in_span(target ^ k, eliminated_values):
      res = target
      break
  print res

t=int(raw_input())
b=[]
l=[]
d=0
for i in xrange(0,t*t):
	k=raw_input()
	if(k[0]=='Y'):
		d='1'	
	elif(k[0]=='N'):
		d='0'
	l.append(d)
	if(i%t==t-1):
		b.append(''.join(l))
		l=[]

#print b
ans=0
for i in xrange(0,t):
	f=1
	for j in xrange(0,t):
		if((b[i]==b[j] and b[i][j]=='0') or (b[i]!=b[j] and b[i][j]=='1')):
			f=0
			break
#		print f
	if(f==1):
		ans=b[i]
		break;

#print ans
if(ans!=0):
	for i in ans:
		if(i=='1'):
			print 'YES'
		else:
			print 'NO'
else:
	for i in xrange(0,t):
		print 'NO'

